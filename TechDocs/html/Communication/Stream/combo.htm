<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD>
<!-- This page was automatically generated from a bunch of smaller pages. -->
<META NAME="copyright" CONTENT="Copyright GEOWORKS">
<LINK REL="STYLESHEET" HREF="../../docHelpers/style.css">
<LINK REV="MADE" HREF="mailto:doc-feedback@geoworks.com">
<TITLE>Using Streams</TITLE>
</HEAD>
<BODY BGCOLOR="#ffffdf">
This document is a single-page version of a <A HREF="index.htm">a multi-page document</A>, suitable for easy printing.
<A NAME="index.htm"></A>



<H1 CLASS="chapterTitle">

<A NAME="index.htm_28889">
 </A>
Using Streams

</H1>
<P>
<A NAME="index.htm_IX_Streams">
 </A>
<A NAME="index.htm_IX_Streams">
 </A>
It is often useful for an application to be able to write out data in an orderly manner to be read by another program or sent to a device such as a printer or modem. GEOS provides a mechanism called a <EM>
stream</EM>
 to allow an orderly flow of data between two programs, between two threads of a multi-threaded program, or between a program and a device such as a serial or parallel port. The stream interface includes various ways to notify a program that bytes are available to read, or that there is room to write additional data.</P>
<P>
The GEOS parallel and serial port drivers use the stream mechanism, so programs that will use these ports must do so via this mechanism; however, libraries exist to handle some of the more common uses for port communications. Programs do not need to access the serial or parallel ports in order to print because the spooler does it for them. For more information about the spooler and printing, see <A HREF="../../Communication/Printing/combo.htm"></A>
. </P>
<P>
This chapter may be read with only a general understanding of GEOS and Object Assembly. Messaging is used heavily in informing the application using a stream of the stream's status, so a good understanding of object-oriented programming will be helpful. You should also be familiar with the GEOS memory manager. The chapter is divided into three main sections:

</P>
<UL>
<LI>
A general description of a GEOS stream and how the two sides (writers and readers) access it.</LI>
<LI>
A description of the specific routines and conventions for using streams to send data to and receive data from a serial port.</LI>
<LI>
A description of the specific routines and conventions for using a stream to send data to a parallel port.</LI>
</UL>
<P CLASS="sectionlinks">
<STRONG>
&nbsp;&nbsp;<A HREF="#Stream_1.htm">1 Using Streams: The Basics</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Stream_2.htm">1.1 Initializing a Stream</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Stream_3.htm">1.2 Blocking on Read or Write</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Stream_4.htm">1.3 Writing Data to a Stream</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Stream_5.htm">1.4 Reading Data from a Stream</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Stream_6.htm">1.5 Shutting Down a Stream</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Stream_7.htm">1.6 Miscellaneous Functions</A><BR>
&nbsp;&nbsp;<A HREF="#Stream_8.htm">2 Using the Serial Ports</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Stream_9.htm">2.1 Initializing a Serial Port</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Stream_a.htm">2.2 Communicating</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Stream_b.htm">2.3 Closing a Serial Port</A><BR>
&nbsp;&nbsp;<A HREF="#Stream_c.htm">3 Using the Parallel Ports</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Stream_d.htm">3.1 Initializing a Parallel Port</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Stream_e.htm">3.2 Communicating</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Stream_f.htm">3.3 Closing a Parallel Port</A><BR>
</STRONG>
</P> <!-- end of sectionlinks blob -->

<HR>
<A NAME="Stream_1.htm"></A>


<H2 CLASS="sectionTitle">
<A HREF="#index.htm">Using Streams</A>: 1 
<A NAME="Stream_1.htm_60837">
 </A>
Using Streams: The Basics</H2>
<P>
A stream is a path along which information flows in one direction. At one end of the stream is a <EM>
writer</EM>
, who puts data into the stream. At the opposite end of the stream is a <EM>
reader</EM>
, who receives data from the stream. The writer and reader can be GEOS programs or device drivers. Data flow in both directions can be achieved by using two streams, one in each direction; this is how the serial port driver is implemented. </P>
<P>
Even though the stream driver is loaded automatically when a stream is created, you will need to initialize, configure, and destroy any streams you use. The specific steps involved in this process are
<IMG SRC="Stream_1.gif">

</P>
<OL>
<LI>
Get the handle of the stream driver.<BR>
You will need to get this handle to use most of the stream-library routines. You can get this handle by calling <CODE>
GeodeUseDriver()</CODE>
.</LI>
<LI FIXME_NumListOther>
Create the stream.<BR>
You must create each stream you plan on using. When a stream is initialized, it is designated a token that is used when calling the stream driver's strategy routine.</LI>
<LI FIXME_NumListOther>
Configure the stream.<BR>
Arrange how your geode will be notified by the stream driver when certain situations (error received or buffer full/empty) arise, and make sure that all geodes accessing the stream have been given the stream's token.</LI>
<LI FIXME_NumListOther>
Use the stream.</LI>
<LI FIXME_NumListOther>
Shut down the stream.<BR>
Not a trivial task, shutting down a stream can involve several synchronization issues.</LI>
</OL>
<P>
Streams are created and managed by the Stream <EM>
Driver</EM>
. Programs written in Object-Assembly can call the driver directly. Goc programs cannot do this; instead, they make calls to the Stream <EM>
Library</EM>
, which in turn calls the Stream Driver, and passes back any return values.</P>
<P CLASS="subsectionLink">
<A HREF="#Stream_2.htm">Initializing a Stream</A></P>
<P CLASS="subsectionLink">
<A HREF="#Stream_3.htm">Blocking on Read or Write</A></P>
<P CLASS="subsectionLink">
<A HREF="#Stream_4.htm">Writing Data to a Stream</A></P>
<P CLASS="subsectionLink">
<A HREF="#Stream_5.htm">Reading Data from a Stream</A></P>
<P CLASS="subsectionLink">
<A HREF="#Stream_6.htm">Shutting Down a Stream</A></P>
<P CLASS="subsectionLink">
<A HREF="#Stream_7.htm">Miscellaneous Functions</A></P>
<HR>
<A NAME="Stream_2.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Using Streams</A>: 1.1 <A HREF="#Stream_1.htm">Using Streams: The Basics</A>: 
<A NAME="Stream_2.htm_85445">
 </A>
Initializing a Stream</H3>
<P>
A stream is essentially a first-in-first-out data buffer, in which the writer is different from the reader. When the writer writes data to the stream, the kernel stores it in the buffer; when the reader requests information from the stream, the kernel retrieves the oldest data not yet read. The data is stored in a memory block; this block may be either fixed or movable. If it is movable, both the reader and the writer must lock the block before calling any stream routines.</P>
<P>
Note that the kernel does not enforce who is the reader or writer to a stream. Any geode may call the appropriate stream library routine, passing in the token for a stream, and read or write data. However, in practice, only those threads with a legitimate interest in a stream will know the stream's token.</P>
<P>
The serial and parallel drivers are built on top of the stream driver. There are separate routines to access the serial and parallel ports; these routines are discussed in <A HREF="#Stream_8.htm_49334"> Using the Serial Ports</A>
 for the serial driver and <A HREF="#Stream_c.htm_42952"> Using the Parallel Ports</A>
 for the parallel driver.</P>

<H4 CLASS="HeadingC">
Creating a Stream<A NAME="Stream_2.htm_67491">
 </A>
</H4>
<PRE>StreamOpen()</PRE>
<P>
<A NAME="Stream_2.htm_IX_DR_STREAM_CREATE">
 </A>
<A NAME="Stream_2.htm_IX_StreamOpen()">
 </A>
To create and initialize a new stream, call the routine <CODE>
StreamOpen()</CODE>
. This routine takes five arguments:</P>
<UL>
<LI>
The handle of the stream driver.</LI>
<LI>
The size of the stream buffer, in bytes. This may not be larger than 32767.</LI>
<LI>
The <CODE>
GeodeHandle</CODE>
 of the geode that will own this stream. When this geode exits, the stream will be freed; however, you should call <CODE>
StreamClose()</CODE>
 before this happens.</LI>
<LI>
A set of <CODE>
HeapFlags</CODE>
. The routine will have to allocate a block to hold the stream. The <CODE>
HeapFlags</CODE>
 specify whether that block will be fixed or movable. If it is fixed, this argument should contain the flag HF_FIXED; otherwise it should be blank.</LI>
<LI>
<A NAME="Stream_2.htm_IX_StreamToken:with StreamOpen()">
 </A>
The pointer to a <CODE>
StreamToken</CODE>
 variable. <CODE>
StreamOpen()</CODE>
 will create the stream and write its token to this variable. You will need this token whenever you access the stream, for reading or writing.</LI>
</UL>
<P>
If the creation is successful, <CODE>
StreamOpen()</CODE>
 will return zero and store the stream's token in the <CODE>
StreamToken</CODE>
 variable. You must see to it that both the reader and the writer have this token. If the stream cannot be created, the strategy routine will set an error flag and return either STREAM_CANNOT_ALLOC (if the memory for the stream's buffer cannot be allocated) or STREAM_BUFFER_TOO_LARGE (if the requested stream size was greater than 32767).</P>


<H4 CLASS="HeadingC">
Assigning Readers and Writers</H4>
<P>
Once a stream is created, you must make sure that both ends will be managed--a stream that has only a writer or only a reader is not a useful stream.</P>
<P>
When communicating with a device such as a serial or parallel port, the port is considered to be the entity on the other end. However, if two threads are communicating via a stream, you must make sure the other thread can gain access to the stream. The best way to do this is to set up a message that will be sent by the creator to the other geode. This message should contain as an argument the token of the stream and probably the direction of the stream (whether the creator will be reading or writing).</P>
<P>
Once both geodes have the stream's token, each can access the stream normally. The next several sections explain how to access a stream for writing and reading.</P>

<HR>
<A NAME="Stream_3.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Using Streams</A>: 1.2 <A HREF="#Stream_1.htm">Using Streams: The Basics</A>: 
<A NAME="Stream_3.htm_22136">
 </A>
Blocking on Read or Write</H3>
<PRE>StreamBlocker, StreamError, StreamGetError(), StreamSetError()</PRE>
<P>
A stream is a data buffer of limited size. When a thread writes to the stream, there is a chance it could run out of space. Similarly, when a thread reads from the stream, there is a possibility that it will try to read more data than is available; for example, it might try to read 500 bytes, when only 250 bytes of data are sitting in the stream.</P>
<P>
There are two ways you can deal with these situations. One way is, you can instruct the thread to block. For example, if you try to write 500 bytes to a stream and there is only 200 bytes of space available, the driver will write the first 200 bytes to that space, then have the writing thread block until more space is available (i.e. until the reading thread has read some data). The writing thread will not resume execution until all the data has been written. Similarly, a reading thread could block until the stream provided all the data it requested.</P>
<P>
The other approach is to have the stream driver write or read all it can, then return an appropriate error code. This requires a little more work by the calling thread, as it cannot assume that all the data is always read or written; however, it avoids the risk of deadlock.</P>
<P>
<A NAME="Stream_3.htm_IX_StreamBlocker">
 </A>
All read and write routines are passed a member of the <CODE>
StreamBlocker</CODE>
 enumerated type. This type has two members: STREAM_BLOCK, indicating that the calling thread should block in the situations described above; and STREAM_NO_BLOCK, indicating that the routine should immediately return with an error if enough space is not available. A single thread may, if it wishes, pass STREAM_BLOCK sometimes and STREAM_NO_BLOCK sometimes.</P>
<P>
If a stream routine returns an error, the error will be a member of the <CODE>
StreamError</CODE>
 enumerated type. The possible error values are described in the section for each routine.</P>
<P>
<A NAME="Stream_3.htm_IX_StreamSetError()">
 </A>
Sometimes the device or application at the other end of the stream will need to return a special error value. For example, it may have its own error enumerated type, and may wish to signal an error to the application on the other end of the stream. It can do this by calling <CODE>
StreamSetError()</CODE>
. This routine is passed four arguments:</P>
<UL>
<LI>
The <CODE>
GeodeHandle</CODE>
 of the stream driver.</LI>
<LI>
<A NAME="Stream_3.htm_IX_StreamToken:with StreamSetError()">
 </A>
The <CODE>
StreamToken</CODE>
 of the stream.</LI>
<LI>
<A NAME="Stream_3.htm_IX_StreamRoles:with StreamSetError()">
 </A>
A member of the <CODE>
StreamRoles</CODE>
 enumerated type. The only appropriate values here are STREAM_ROLES_WRITER or STREAM_ROLES_READER.</LI>
<LI>
A word-sized error code.</LI>
</UL>
<P>
If the routine is succesful, it returns zero. Otherwise, it returns a member of the <CODE>
StreamError</CODE>
 enumerated type.<CODE>
</CODE>
</P>
<P>
<A NAME="Stream_3.htm_IX_StreamRoles:with StreamGetError()">
 </A>
<A NAME="Stream_3.htm_IX_StreamGetError()">
 </A>
<A NAME="Stream_3.htm_IX_StreamError">
 </A>
To read a an error value set by the other side of a stream, call <CODE>
StreamGetError()</CODE>
. This routine is passed four arguments:</P>
<UL>
<LI>
The <CODE>
GeodeHandle</CODE>
 of the stream driver.</LI>
<LI>
<A NAME="Stream_3.htm_IX_StreamToken:with StreamGetError()">
 </A>
The <CODE>
StreamToken</CODE>
 of the stream.</LI>
<LI>
A member of the <CODE>
StreamRoles</CODE>
 enumerated type. The only appropriate values here are STREAM_ROLES_WRITER or STREAM_ROLES_READER.</LI>
<LI>
A pointer to a word-sized variable.</LI>
</UL>
<P>
If successful, the routine returns zero, and writes the other side's error value to the passed word-sized argument. If it is unsuccessful, the routine returns a <CODE>
StreamError</CODE>
 value.</P>
<HR>
<A NAME="Stream_4.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Using Streams</A>: 1.3 <A HREF="#Stream_1.htm">Using Streams: The Basics</A>: 
<A NAME="Stream_4.htm_14551">
 </A>
Writing Data to a Stream</H3>
<PRE>StreamWrite(), StreamWriteByte()</PRE>
<P>
<A NAME="Stream_4.htm_IX_StreamWrite()">
 </A>
To write data into a stream, call the routine <CODE>
StreamWrite()</CODE>
. This routine takes six arguments:</P>
<UL>
<LI>
The <CODE>
GeodeHandle</CODE>
 of the stream driver.</LI>
<LI>
<A NAME="Stream_4.htm_IX_StreamToken:with StreamWrite()">
 </A>
The <CODE>
StreamToken</CODE>
 of the stream.</LI>
<LI>
A member of the <CODE>
StreamBlocker</CODE>
 enumerated type, as described in <A HREF="#Stream_3.htm_22136"> Blocking on Read or Write</A>
.</LI>
<LI>
The amount of data to be written, in bytes.</LI>
<LI>
A pointer to a data buffer; the data will be copied from that buffer to the stream.</LI>
<LI>
A pointer to an integer. <CODE>
StreamWrite()</CODE>
 will write the number of bytes actually copied to that integer.</LI>
</UL>
<P>
<A NAME="Stream_4.htm_IX_StreamError:with StreamWrite()">
 </A>
If all the data was written successfully, <CODE>
StreamWrite()</CODE>
 will return zero and write the number of bytes written (i.e. the size of the data buffer passed) to the integer pointed to by the sixth argument. If it could not successfully write all the data, it will return one of the following <CODE>
StreamError</CODE>
 values:</P>
<DL>
<DT>
STREAM_WOULD_BLOCK</DT><DD>
STREAM_NO_BLOCK had been passed, and there was no room to write any data to the stream. The sixth argument will be set to zero.</DD>
<DT>
STREAM_SHORT_READ_WRITE</DT><DD>
If STREAM_NOBLOCK had been passed, this means there was not enough room to write all the data. If STREAM_BLOCK had been passed, this means the stream was closed before all the data could be written. The sixth argument will contain the number of bytes actually written to the stream.</DD>
<DT>
STREAM_CLOSING</DT><DD>
The stream is in the process of being closed; no writing is permitted while this is happening. The sixth argument will be set to zero.</DD>
<DT>
STREAM_CLOSED</DT><DD>
The stream has already been closed. The sixth argument will be set to zero.</DD>
</DL>
<P>
<A NAME="Stream_4.htm_IX_StreamWriteByte()">
 </A>
You may often want to write a single byte to the stream. There is a special routine to do this, <CODE>
StreamWriteByte()</CODE>
. This routine takes four arguments:</P>
<UL>
<LI>
The <CODE>
GeodeHandle</CODE>
 of the stream driver.</LI>
<LI>
The <CODE>
StreamToken</CODE>
 of the stream.</LI>
<LI>
A member of the <CODE>
StreamBlocker</CODE>
 enumerated type, as described in <A HREF="#Stream_3.htm_22136"> Blocking on Read or Write</A>
.</LI>
<LI>
The byte to be written.</LI>
</UL>
<P>
If the byte is written successfully, <CODE>
StreamWriteByte()</CODE>
 will return zero. Otherwise, it will return one of the following error values:</P>
<DL>
<DT>
STREAM_WOULD_BLOCK</DT><DD>
STREAM_BLOCK had been passed, and there was no room to write any data to the stream.</DD>
<DT>
STREAM_CLOSING</DT><DD>
The stream is in the process of being closed; no writing is permitted while this is happening.</DD>
<DT>
STREAM_CLOSED</DT><DD>
The stream has already been closed.</DD>
</DL>
<HR>
<A NAME="Stream_5.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Using Streams</A>: 1.4 <A HREF="#Stream_1.htm">Using Streams: The Basics</A>: 
Reading Data from a Stream</H3>
<PRE>StreamRead(), StreamReadByte()</PRE>
<P>
<A NAME="Stream_5.htm_IX_StreamRead()">
 </A>
To read data in a stream, call the routine <CODE>
StreamRead()</CODE>
. This routine takes six arguments:</P>
<UL>
<LI>
The <CODE>
GeodeHandle</CODE>
 of the stream driver.</LI>
<LI>
<A NAME="Stream_5.htm_IX_StreamToken:with StreamRead()">
 </A>
The <CODE>
StreamToken</CODE>
 of the stream.</LI>
<LI>
A member of the <CODE>
StreamBlocker</CODE>
 enumerated type, as described in <A HREF="#Stream_3.htm_22136"> Blocking on Read or Write</A>
.</LI>
<LI>
The amount of data to be read, in bytes.</LI>
<LI>
A pointer to a data buffer; the data will be read from the stream into that buffer.</LI>
<LI>
A pointer to an integer. <CODE>
StreamRead()</CODE>
 will write the number of bytes actually read to that integer.</LI>
</UL>
<P>
<A NAME="Stream_5.htm_IX_StreamError:with StreamRead()">
 </A>
If the requested amount of data was read successfully, <CODE>
StreamRead()</CODE>
 will return zero and write the number of bytes read (i.e. the size of the data buffer passed) to the integer pointed to by the sixth argument. If it could not successfully read the requested amount of data, it will return one of the following <CODE>
StreamError</CODE>
 values:</P>
<DL>
<DT>
STREAM_WOULD_BLOCK</DT><DD>
STREAM_BLOCK had been passed, and there was no data waiting in the stream. The sixth argument will be set to zero.</DD>
<DT>
STREAM_SHORT_READ_WRITE</DT><DD>
If STREAM_NOBLOCK had been passed, this means the stream did not have the amount of data requested. If STREAM_BLOCK had been passed, this means the stream was closed before the requested amount of data could be read. The sixth argument will contain the number of bytes actually read from the stream.</DD>
<DT>
STREAM_CLOSING</DT><DD>
The stream is in the process of being closed; no reading is permitted while this is happening. The sixth argument will be set to zero.</DD>
</DL>
<P>
<A NAME="Stream_5.htm_IX_StreamReadByte()">
 </A>
You may often want to read a single byte from the stream. There is a special routine to do this, <CODE>
StreamReadByte()</CODE>
. This routine takes four arguments:</P>
<UL>
<LI>
The <CODE>
GeodeHandle</CODE>
 of the stream driver.</LI>
<LI>
The <CODE>
StreamToken</CODE>
 of the stream.</LI>
<LI>
A member of the <CODE>
StreamBlocker</CODE>
 enumerated type, as described in <A HREF="#Stream_3.htm_22136"> Blocking on Read or Write</A>
.</LI>
<LI>
A pointer to a byte-sized variable; the data byte read will be written to this variable.</LI>
</UL>
<P>
<A NAME="Stream_5.htm_IX_StreamError:with StreamReadByte()">
 </A>
If the byte is written successfully, <CODE>
StreamReadByte()</CODE>
 will return zero. Otherwise, it will return one of the following error values:</P>
<DL>
<DT>
STREAM_WOULD_BLOCK</DT><DD>
STREAM_BLOCK had been passed, and there was no data waiting in the stream.</DD>
<DT>
STREAM_CLOSING</DT><DD>
The stream is in the process of being closed; no reading is permitted while this is happening.</DD>
</DL>
<HR>
<A NAME="Stream_6.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Using Streams</A>: 1.5 <A HREF="#Stream_1.htm">Using Streams: The Basics</A>: 
<A NAME="Stream_6.htm_15612">
 </A>
Shutting Down a Stream</H3>
<PRE>StreamClose()</PRE>
<P>
<A NAME="Stream_6.htm_IX_StreamClose()">
 </A>
Either the writer or the reader can instigate stream shutdown by calling <CODE>
StreamClose()</CODE>
. When one of the two calls this routine, the shut-down process is started; it will not be completed until the other calls the routine.</P>
<P>
If the writer calls <CODE>
StreamClose()</CODE>
, it may specify that the data already in the buffer be <EM>
flushed</EM>
 (immediately cleared), or that it <EM>
linger</EM>
. If you specify that the data should linger, the data will be preserved as long as the reader has the stream open. The reader can continue to read data normally until it runs out of data. The last read-operation will most likely return STREAM_SHORT_READ_WRITE; after that, all attempts to read data will generate the error STREAM_CLOSING. At that point, the reader should call <CODE>
StreamClose()</CODE>
. (If the data was flushed by the writer, the next read attempt will return STREAM_CLOSING.)</P>
<P>
To shut down the stream, call the routine <CODE>
StreamClose()</CODE>
. This routine is passed the following arguments:</P>
<UL>
<LI>
The <CODE>
GeodeHandle</CODE>
 of the stream driver.</LI>
<LI>
<A NAME="Stream_6.htm_IX_StreamToken:with StreamClose()">
 </A>
The <CODE>
StreamToken</CODE>
 of the stream.</LI>
<LI>
A Boolean value saying whether the data in the stream should be kept until it's read; <EM>
false</EM>
 (i.e. zero) indicates it should be flushed.</LI>
</UL>
<P>
If you are using the Serial or Parallel drivers (described later in this chapter), you do not have to coordinate the closure of a stream.</P>
<HR>
<A NAME="Stream_7.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Using Streams</A>: 1.6 <A HREF="#Stream_1.htm">Using Streams: The Basics</A>: 
<A NAME="Stream_7.htm_44511">
 </A>
Miscellaneous Functions</H3>
<PRE>StreamFlush(), StreamQuery()</PRE>
<P>
<A NAME="Stream_7.htm_IX_StreamFlush()">
 </A>
To flush all the pending (written but unread) data from a stream, call the routine <CODE>
StreamFlush()</CODE>
. This routine is passed two arguments:</P>
<UL>
<LI>
The <CODE>
GeodeHandle</CODE>
 of the stream driver.</LI>
<LI>
The <CODE>
StreamToken</CODE>
 of the stream.</LI>
</UL>
<P>
<A NAME="Stream_7.htm_IX_StreamQuery()">
 </A>
To find out how much free space is available in a stream, or how much data is waiting to be read, call <CODE>
StreamQuery()</CODE>
. This routine is passed four arguments:</P>
<UL>
<LI>
The <CODE>
GeodeHandle</CODE>
 of the stream driver.</LI>
<LI>
The <CODE>
StreamToken</CODE>
 of the stream.</LI>
<LI>
<A NAME="Stream_7.htm_IX_StreamRoles:with StreamQuery()">
 </A>
A member of the <CODE>
StreamRoles</CODE>
 enumerated type. The only appropriate values here are STREAM_ROLES_WRITER (to find the amount of free space available for writing) or STREAM_ROLES_READER (to find the amount of data waiting to be read).</LI>
<LI>
A pointer to an integer variable.</LI>
</UL>
<P>
If the call is successful, <CODE>
StreamQuery()</CODE>
 returns zero and writes its return value to the fourth argument. If you pass STREAM_ROLES_WRITER, <CODE>
StreamQuery()</CODE>
 writes the number of bytes of free space available in the stream buffer. If you pass STREAM_ROLES_READER, <CODE>
StreamQuery()</CODE>
 returns the number of bytes of data waiting to be read. If the call is unsuccessful, <CODE>
StreamQuery()</CODE>
 returns a <CODE>
StreamError</CODE>
.</P>
<HR>
<A NAME="Stream_8.htm"></A>


<H2 CLASS="sectionTitle">
<A HREF="#index.htm">Using Streams</A>: 2 
<A NAME="Stream_8.htm_49334">
 </A>
Using the Serial Ports</H2>
<P>
<A NAME="Stream_8.htm_IX_Serial port">
 </A>
The serial driver uses streams to control the flow of data to and from serial ports. The kernel automatically copies data from the serial port into one stream for reading, and sends data from another stream into the serial port. An application which wishes to use the serial port simply reads and writes data from those streams. </P>
<P CLASS="subsectionLink">
<A HREF="#Stream_9.htm">Initializing a Serial Port</A></P>
<P CLASS="subsectionLink">
<A HREF="#Stream_a.htm">Communicating</A></P>
<P CLASS="subsectionLink">
<A HREF="#Stream_b.htm">Closing a Serial Port</A></P>
<HR>
<A NAME="Stream_9.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Using Streams</A>: 2.1 <A HREF="#Stream_8.htm">Using the Serial Ports</A>: 
Initializing a Serial Port</H3>
<P>
Like the stream driver, the serial driver is not accessed directly from Goc code. Instead, a Goc application makes calls to the Stream Library, which passes the requests through to the Serial Driver's strategy routine. Each serial-port command must be passed the <CODE>
GeodeHandle</CODE>
 of the Serial Library; again, you can find this handle by calling <CODE>
GeodeGetInfo()</CODE>
.</P>
<P>
The serial driver uses two streams, one for data going out to the serial port (outgoing) and one for data coming in from the serial port (incoming). Your program is the writer of the outgoing and the reader of the incoming. (In both cases, the port acts as the opposite user.)</P>

<H4 CLASS="HeadingC">
Opening a Serial Port</H4>
<PRE>SerialOpen()</PRE>
<P>
<A NAME="Stream_9.htm_IX_DR_STREAM_OPEN:with serial port">
 </A>
<A NAME="Stream_9.htm_IX_SerialOpen()">
 </A>
To open a serial port, call the routine <CODE>
SerialOpen()</CODE>
. This routine is passed the following arguments:</P>
<UL>
<LI>
The <CODE>
GeodeHandle</CODE>
 of the serial-port driver.</LI>
<LI>
A member of the <CODE>
SerialUnit</CODE>
 enumerated type; this specifies which serial port is being opened. The type's members are SERIAL_COM1, SERIAL_COM2, and so on up to SERIAL_COM8.</LI>
<LI>
<A NAME="Stream_9.htm_IX_StreamOpenFlags">
 </A>
<A NAME="Stream_9.htm_IX_STREAM_OPEN_&ldots;">
 </A>
A member of the <CODE>
StreamOpenFlags </CODE>
enumerated type, indicating what to do if the requested serial port is busy (either STREAM_OPEN_NO_BLOCK, indicating that the routine should return an error immediately; or STREAM_OPEN_TIMEOUT, indicating that the routine should wait a specified number of clock ticks to see if the port will free up).</LI>
<LI>
The total size of the stream to be used as an input buffer, in bytes.</LI>
<LI>
The total size of the stream to be used as an output buffer, in bytes.</LI>
<LI>
The maximum number of ticks to wait for the serial port to become available (if STREAM_OPEN_TIMEOUT was passed).</LI>
</UL>
<P>
<A NAME="Stream_9.htm_IX_StreamError:with SerialOpen()">
 </A>
A flag is returned to indicate whether the serial port could be opened; if not, a value of type <CODE>
StreamError</CODE>
 will be returned to indicate the reason. Possible stream error values are STREAM_BUFFER_TOO_LARGE and STREAM_CANNOT_CREATE, and the additional values STREAM_NO_DEVICE (if the serial port does not exist) or STREAM_DEVICE_IN_USE (if the device is busy and the <CODE>
StreamOpenFlags</CODE>
 passed indicate not to wait).</P>
<P>
Note that when using the serial driver, you do not identify the stream by a stream token but rather by the serial port number, known as a <EM>
unit number</EM>
. When accessing a serial port, you simply pass the port's unit number along with either STREAM_READ (if reading from the stream) or STREAM_WRITE (if writing to the stream); because each port has two streams associated with it, you must specify both parameters. The serial driver will understand which stream you are accessing.</P>


<H4 CLASS="HeadingC">
Configuring a Serial Port</H4>
<PRE>SerialSetFormat(), SerialGetFormat(),SerialSetModem(), SerialGetModem(), SerialSetFlowControl()</PRE>
<P>
<A NAME="Stream_9.htm_IX_DR_SERIAL_SET_FORMAT">
 </A>
<A NAME="Stream_9.htm_IX_SerialSetFormat()">
 </A>
Communication using a serial port requires that parity, speed, and flow control be properly set. To control these settings, call <CODE>
SerialSetFormat()</CODE>
, passing the following arguments:</P>
<UL>
<LI>
The <CODE>
GeodeHandle</CODE>
 of the serial-port driver.</LI>
<LI>
The member of the <CODE>
SerialUnit</CODE>
 enumerated type.</LI>
<LI>
A one-byte record of type <CODE>
SerialFormat</CODE>
, specifying the parity, word length, and number of stop bits to be used on the serial line; this record is described below.</LI>
<LI>
<A NAME="Stream_9.htm_IX_SM_&ldots; :with SerialSetFormat()">
 </A>
A member of the <CODE>
SerialMode</CODE>
 enumerated type, set to indicate the level of flow control: SM_COOKED to indicate XON/XOFF flow control with characters stripped to seven bits, SM_RARE to indicate XON/XOFF flow control but incoming characters left alone, or SM_RAW to indicate no flow control.</LI>
<LI>
The baud rate to use, a member of the enumerated type <CODE>
SerialBauds</CODE>
, which has the following members:</LI>
</UL>
<PRE>typedef	enum
{
	SERIAL_BAUD_115200				= 1,
	SERIAL_BAUD_57600				= 2,
	SERIAL_BAUD_38400				= 3,
	SERIAL_BAUD_19200				= 6,
	SERIAL_BAUD_14400				= 8,
	SERIAL_BAUD_9600				= 12,
	SERIAL_BAUD_7200				= 16,
	SERIAL_BAUD_4800				= 24,
	SERIAL_BAUD_3600				= 32,
	SERIAL_BAUD_2400				= 48,
	SERIAL_BAUD_2000				= 58,
	SERIAL_BAUD_1800				= 64,
	SERIAL_BAUD_1200				= 96,
	SERIAL_BAUD_600				= 192,
	SERIAL_BAUD_300				= 384
} SerialBaud;</PRE>
<P>
<CODE>
SerialFormat</CODE>
 is a byte-sized record that specifies the parity, word-length, and number of stop bits for the serial line. The record has the following fields:</P>
<DL>
<DT>
SERIAL_FORMAT_DLAB	</DT><DD>
This is for internal use only; it must be set to zero.</DD>
<DT>
SERIAL_FORMAT_BREAK	</DT><DD>
If set, this causes a BREAK condition to be asserted on the line. You must explicitly clear this bit again to resume normal operation.</DD>
<DT>
SERIAL_FORMAT_PARITY</DT><DD>
This three-bit field holds the parity to expect on receive and use on transmit. It uses the <CODE>
SerialParity</CODE>
 enumerated type, which has the following members:</DD>
<PRE>typedef		enum {
	SERIAL_PARITY_NONE				= 0,
	SERIAL_PARITY_ODD				= 1,
	SERIAL_PARITY_EVEN				= 3,
	SERIAL_PARITY_ONE				= 5,
	SERIAL_PARITY_MARK				= 5,
	SERIAL_PARITY_ZERO				= 7,
	SERIAL_PARITY_SPACE				= 7
} SerialParity;</PRE>
<DT>
SERIAL_FORMAT_EXTRA_STOP</DT><DD>
If this is set, extra stop-bits will be sent. One stop bit is always sent. However, if you set this flag, an extra 1/2 stop bit will be sent if the word-length is 5 bits long; an extra 1 stop bit will be sent if the frame is 6, 7, or 8 bits long.</DD>
<DT>
SERIAL_FORMAT_LENGTH</DT><DD>
This two-bit field holds the length of each data word, minus five (i.e. a five-bit word is represented with a zero, a six-bit word with a one).</DD>
</DL>
<P>
<A NAME="Stream_9.htm_IX_DR_SERIAL_GET_FORMAT">
 </A>
<A NAME="Stream_9.htm_IX_SerialGetFormat()">
 </A>
To find out the current settings of a serial port, call <CODE>
SerialGetFormat()</CODE>
. This routine is passed five arguments:</P>
<UL>
<LI>
The <CODE>
GeodeHandle</CODE>
 of the serial-port driver.</LI>
<LI>
The member of the <CODE>
SerialUnit</CODE>
 enumerated type.</LI>
<LI>
A pointer to a <CODE>
SerialFormat</CODE>
 variable. <CODE>
SerialGetFormat()</CODE>
 will write the format data to this variable.</LI>
<LI>
<A NAME="Stream_9.htm_IX_SM_&ldots; :with SeriealGetFormat()">
 </A>
A pointer to a <CODE>
SerialMode</CODE>
 variable. <CODE>
SerialGetFormat()</CODE>
 will write the appropriate mode constant (SM_COOKED, XON/XOFF, or SM_RARE) to this variable.</LI>
<LI>
A pointer to a <CODE>
SerialBaud</CODE>
 variable. <CODE>
SerialFormat()</CODE>
 will write the appropriate constant to this variable.</LI>
</UL>
<P>
As with other serial port routines, if the routine is successful, it will return zero; if it is unsuccessful, it will return an error code.</P>
<P>
<A NAME="Stream_9.htm_IX_SerialSetModem()">
 </A>
If you are using a modem's hardware flow control, you will have to configure the modem appropriately. You can do this by calling <CODE>
SerialSetModem()</CODE>
. This routine is passed three arguments:</P>
<UL>
<LI>
The <CODE>
GeodeHandle</CODE>
 of the serial-port driver.</LI>
<LI>
The member of the <CODE>
SerialUnit</CODE>
 enumerated type.</LI>
<LI>
A record of type <CODE>
SerialModem</CODE>
. This record has four fields: SERIAL_MODEM_OUT2, SERIAL_MODEM_OUT1, SERIAL_MODEM_RTS, and SERIAL_MODEM_DTR. Set these fields to indicate how the control-bits should be set.</LI>
</UL>
<P>
<A NAME="Stream_9.htm_IX_SerialGetModem()">
 </A>
To find out what flow control is being used, call <CODE>
SerialGetModem()</CODE>
. This routine is passed three arguments:</P>
<UL>
<LI>
The <CODE>
GeodeHandle</CODE>
 of the serial-port driver.</LI>
<LI>
The member of the <CODE>
SerialUnit</CODE>
 enumerated type.</LI>
<LI>
A pointer to a record of type <CODE>
SerialModem</CODE>
. <CODE>
SerialGetModem()</CODE>
 will set this record's SERIAL_MODEM_OUT2, SERIAL_MODEM_OUT1, SERIAL_MODEM_RTS, and SERIAL_MODEM_DTR bits appropriately.</LI>
</UL>
<P>
<A NAME="Stream_9.htm_IX_SerialSetFlowControl()">
 </A>
You can also set the flow control without setting the other format options. Do this by calling <CODE>
SerialSetFlowControl()</CODE>
. This routine is passed the following arguments:</P>
<UL>
<LI>
The <CODE>
GeodeHandle</CODE>
 of the serial-port driver.</LI>
<LI>
The member of the <CODE>
SerialUnit</CODE>
 enumerated type.</LI>
<LI>
A record of type <CODE>
SerialModem</CODE>
. This record has four fields: SERIAL_MODEM_OUT2, SERIAL_MODEM_OUT1, SERIAL_MODEM_RTS, and SERIAL_MODEM_DTR. Set these fields to indicate how the control-bits should be set.</LI>
<LI>
<A NAME="Stream_9.htm_IX_SM_&ldots; :with SerialSetFlowControl()">
 </A>
A member of the <CODE>
SerialMode</CODE>
 enumerated type, set to indicate the level of flow control: SM_COOKED to indicate XON/XOFF flow control with characters stripped to seven bits, SM_RARE to indicate XON/XOFF flow control but incoming characters left alone, or SM_RAW to indicate no flow control.</LI>
<LI>
A record of type <CODE>
SerialModemStatus</CODE>
 to indicate which lines (chosen from DCD, DSR, and CTS) should be used to control outgoing data (if hardware flow control is selected). When one of the selected lines is de-asserted by the remote system, the serial driver will not transmit any more data until the state changes.</LI>
</UL>

<HR>
<A NAME="Stream_a.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Using Streams</A>: 2.2 <A HREF="#Stream_8.htm">Using the Serial Ports</A>: 
Communicating</H3>
<PRE>SerialRead(), SerialReadByte(), SerialWrite(), SerialWriteByte(), SerialQuery(), SerialFlush(), SerialGetError(), SerialSetError(), SerialError</PRE>
<P>
Communicating with a serial port is very much like using any other stream. Special versions of the stream routines are provided, but they function just like their stream counterparts.</P>
<P>
<A NAME="Stream_a.htm_IX_SerialRead()">
 </A>
<A NAME="Stream_a.htm_IX_SerialReadByte()">
 </A>
To read data from a serial port, call <CODE>
SerialRead()</CODE>
 or <CODE>
SerialReadByte()</CODE>
. These routines take the same arguments as their <CODE>
Stream...()</CODE>
 counterparts, except that each one must be passed the handle of the Serial Driver, not the Stream Driver, and each routine is passed the <CODE>
SerialUnit</CODE>
 for the appropriate port, instead of being passed a stream token. These routines behave exactly like their <CODE>
Stream...()</CODE>
 counterparts.</P>
<P>
<A NAME="Stream_a.htm_IX_SerialWrite()">
 </A>
<A NAME="Stream_a.htm_IX_SerialWriteByte()">
 </A>
To write data to a serial port, call <CODE>
SerialWrite()</CODE>
 or <CODE>
SerialWriteByte()</CODE>
. Again, these routines behave like their <CODE>
Stream...()</CODE>
 counterparts, and take similar arguments.</P>
<P>
<A NAME="Stream_a.htm_IX_SerialQuery()">
 </A>
<A NAME="Stream_a.htm_IX_SerialFlush()">
 </A>
To find out if you can read or write data to the port, call <CODE>
SerialQuery()</CODE>
. Again, this routine behaves like its <CODE>
Stream...()</CODE>
 equivalent. To flush any data from the input or output stream, call <CODE>
SerialFlush()</CODE>
.</P>
<P>
<A NAME="Stream_a.htm_IX_SerialSetError()">
 </A>
To send an error to the other side of a serial connection, call <CODE>
SerialSetError()</CODE>
. This routine behaves much like <CODE>
StreamSetError()</CODE>
. The only difference is that the error code passed must be a member of the <CODE>
SerialError</CODE>
 enumerated type. This type has the following members:</P>
<DL>
<DT>
SE_BREAK</DT><DD>Break condition detected on line.</DD>
<DT>
SE_FRAME</DT><DD>Framing error (e.g. improper number of stop bits).</DD>
<DT>
SE_PARITY</DT><DD>Parity error in received character.</DD>
<DT>
SE_OVERRUN</DT><DD>
A new byte was received before the previous byte was read; the previous byte was discarded.</DD>
</DL>
<P>
<A NAME="Stream_a.htm_IX_SerialGetError()">
 </A>
To read an error condition passed by the other side of a serial connection, call <CODE>
SerialGetError()</CODE>
. This routine behaves just like <CODE>
StreamGetError()</CODE>
. The error code returned will be a member of the <CODE>
SerialError</CODE>
 enumerated type.</P>
<HR>
<A NAME="Stream_b.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Using Streams</A>: 2.3 <A HREF="#Stream_8.htm">Using the Serial Ports</A>: 
Closing a Serial Port</H3>
<PRE>SerialClose(), SerialCloseWithoutReset()</PRE>
<P>
<A NAME="Stream_b.htm_IX_SerialClose()">
 </A>
<A NAME="Stream_b.htm_IX_DR_STREAM_CLOSE:with serial port">
 </A>
To close a serial port, call the routine <CODE>
SerialClose()</CODE>
. This routine is passed three arguments:</P>
<UL>
<LI>
The <CODE>
GeodeHandle</CODE>
 of the serial-port driver.</LI>
<LI>
The member of the <CODE>
SerialUnit</CODE>
 enumerated type.</LI>
<LI>
Either STREAM_LINGER (to instruct the kernel to close the port after all outgoing data in the buffer has been sent), or STREAM_DISCARD (to instruct the kernel to close the port right away and discard all buffered data).</LI>
</UL>
<P>
This function returns immediately whether the port was closed right away or not. However, if STREAM_LINGER is specified, the port may not be re-opened until all the data in the Serial Port's buffer has been dealt with.</P>
<P>
<A NAME="Stream_b.htm_IX_SerialCloseWithoutReset()">
 </A>
You can also instruct the serial driver to close the stream to a port, without actually resetting the port. Do this by calling <CODE>
SerialCloseWithoutReset()</CODE>
. This routine is passed the same arguments as <CODE>
SerialClose()</CODE>
.</P>
<HR>
<A NAME="Stream_c.htm"></A>


<H2 CLASS="sectionTitle">
<A HREF="#index.htm">Using Streams</A>: 3 
<A NAME="Stream_c.htm_42952">
 </A>
Using the Parallel Ports</H2>
<P>
<A NAME="Stream_c.htm_IX_Parallel ports">
 </A>
Using a parallel port is simpler than using a serial port since data goes in only one direction. GEOS does not currently support reading data from a parallel port.</P>
<P>
Parallel ports are used primarily for printing, which is handled by the Spool Object Library. The information in this section is useful only to programmers whose applications will need to send data out through the parallel port without using the spooler. Most applications, however, will use the spooler for any and all parallel port use.</P>
<P CLASS="subsectionLink">
<A HREF="#Stream_d.htm">Initializing a Parallel Port</A></P>
<P CLASS="subsectionLink">
<A HREF="#Stream_e.htm">Communicating</A></P>
<P CLASS="subsectionLink">
<A HREF="#Stream_f.htm">Closing a Parallel Port</A></P>
<HR>
<A NAME="Stream_d.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Using Streams</A>: 3.1 <A HREF="#Stream_c.htm">Using the Parallel Ports</A>: 
Initializing a Parallel Port</H3>
<PRE>ParallelOpen()</PRE>
<P>
<A NAME="Stream_d.htm_IX_ParallelOpen()">
 </A>
<A NAME="Stream_d.htm_IX_DR_STREAM_OPEN:with serial port">
 </A>
To open a parallel port, call the routine <CODE>
ParallelOpen()</CODE>
. This routine is passed the following arguments:</P>
<UL>
<LI>
The <CODE>
GeodeHandle</CODE>
 of the parallel-port driver.</LI>
<LI>
A member of the <CODE>
ParallelUnit</CODE>
 enumerated type; this specifies which parallel port is being opened. The type's members are PARALLEL_LPT1, PARALLEL_LPT2, PARALLEL_LPT3, and PARALLEL_COM4.</LI>
<LI>
A member of the <CODE>
StreamOpenFlags </CODE>
enumerated type, indicating what to do if the requested parallel port is busy (either STREAM_OPEN_NO_BLOCK, indicating that the routine should return an error immediately; or STREAM_OPEN_TIMEOUT, indicating that the routine should wait a specified number of clock ticks to see if the port will free up).</LI>
<LI>
The unit number of the parallel port in question--this is a value of type <CODE>
ParallelPortNums</CODE>
.</LI>
<LI>
The total size of the stream to be used as an output buffer, in bytes.</LI>
<LI>
The maximum number of ticks to wait for the parallel port to become available (if STREAM_OPEN_TIMEOUT was passed).</LI>
</UL>
<P>
<A NAME="Stream_d.htm_IX_StreamError:with ParallelOpen()">
 </A>
A flag is returned to indicate whether the parallel port could be opened; if not, a value of type <CODE>
StreamError</CODE>
 will be returned to indicate the reason. Possible stream error values are STREAM_BUFFER_TOO_LARGE and STREAM_CANNOT_CREATE, and the additional values STREAM_NO_DEVICE (if the parallel port does not exist) or STREAM_DEVICE_IN_USE (if the device is busy and the <CODE>
StreamOpenFlags</CODE>
 passed indicate not to wait (or not to wait any longer)).</P>
<P>
Note that when using the parallel driver, you do not identify the stream by a stream token but rather by the parallel port number, known as a <EM>
unit number</EM>
. When accessing a parallel port, you simply pass the port's unit number along with either STREAM_READ (if reading from the stream) or STREAM_WRITE (if writing to the stream); because each port has two streams associated with it, you must specify both parameters. The parallel driver will understand which stream you are accessing.</P>
<P>
Once the port is selected, the PC will assert the SLCTIN signal, which usually will place the device on-line.</P>
<HR>
<A NAME="Stream_e.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Using Streams</A>: 3.2 <A HREF="#Stream_c.htm">Using the Parallel Ports</A>: 
<A NAME="Stream_e.htm_75636">
 </A>
Communicating</H3>
<PRE>ParallelWrite(), ParallelWriteByte()</PRE>
<P>
<A NAME="Stream_e.htm_IX_ParallelWrite()">
 </A>
<A NAME="Stream_e.htm_IX_ParallelWriteByte()">
 </A>
Writing to a parallel port is much like writing to any other stream. To write data, call <CODE>
ParallelWrite()</CODE>
 or <CODE>
ParallelWriteByte()</CODE>
. These routines take the same arguments as their <CODE>
Stream...()</CODE>
 components, except that each one must be passed the handle of the Parallel Driver, not the Stream Driver, and each routine is passed the <CODE>
ParallelUnit</CODE>
 for the appropriate port, instead of being passed a stream token. These routines behave exactly like their <CODE>
Stream...()</CODE>
 counterparts.</P>
<P>
<A NAME="Stream_e.htm_IX_ParallelSetError()">
 </A>
To send an error to the other side of a serial connection, call <CODE>
ParallelSetError()</CODE>
. (This routine is generally not called by applications.) This routine behaves much like <CODE>
StreamSetError()</CODE>
. It is passed four arguments:</P>
<UL>
<LI>
The <CODE>
GeodeHandle</CODE>
 of the parallel-port driver.</LI>
<LI>
The appropriate member of the <CODE>
ParallelUnit</CODE>
 enumerated type.</LI>
<LI>
The appropriate member of the <CODE>
StreamRoles</CODE>
 enumerated type.</LI>
<LI>
A <CODE>
ParallelError</CODE>
 record. This word-sized record has the following flags:</LI>
</UL>
<DL>
<DT>
PE_FATAL</DT><DD>Set if the driver encountered an error that means it can't continue.</DD>
<DT>
PE_TIMEOUT</DT><DD>
Set if there is no response from the printer, but no other (non-masked) error is present.</DD>
<DT>
PE_NOPAPER</DT><DD>
Set if the device is out of paper.</DD>
<DT>
PE_OFFLINE</DT><DD>Set if the device is off-line.</DD>
<DT>
PE_ERROR</DT><DD>Indicates a general error.</DD>
</DL>
<P>
<A NAME="Stream_e.htm_IX_ParallelGetError()">
 </A>
To read an error condition passed by the other side of a serial connection, call <CODE>
ParallelGetError()</CODE>
. This routine behaves much like <CODE>
StreamGetError()</CODE>
. The error code returned will be a member of the <CODE>
ParallelError</CODE>
 enumerated type.</P>
<HR>
<A NAME="Stream_f.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Using Streams</A>: 3.3 <A HREF="#Stream_c.htm">Using the Parallel Ports</A>: 
Closing a Parallel Port</H3>
<PRE>ParallelClose()</PRE>
<P>
<A NAME="Stream_f.htm_IX_ParallelClose()">
 </A>
To close a parallel port, <CODE>
ParallelClose()</CODE>
. This routine takes the following arguments:</P>
<UL>
<LI>
The <CODE>
GeodeHandle</CODE>
 of the parallel-port driver.</LI>
<LI>
The member of the <CODE>
ParallelUnit</CODE>
 enumerated type.</LI>
<LI>
Either STREAM_LINGER (to instruct the kernel to close the port after all outgoing data in the buffer has been sent), or STREAM_DISCARD (to instruct the kernel to close the port right away and discard all buffered data).</LI>
</UL>
<P>
This function returns immediately whether the port was closed right away or not. However, if STREAM_LINGER is specified, the port may not be re-opened until all the data in the parallel port's buffer has been dealt with.</P>
<HR>
This document is a single-page version of a <A HREF="index.htm">a multi-page document</A>, suitable for easy printing.
</BODY>
</HTML>
