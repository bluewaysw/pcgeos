<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD>
<!-- This page was automatically generated from a bunch of smaller pages. -->
<META NAME="copyright" CONTENT="Copyright GEOWORKS">
<LINK REL="STYLESHEET" HREF="../../docHelpers/style.css">
<LINK REV="MADE" HREF="mailto:doc-feedback@geoworks.com">
<TITLE>The File System</TITLE>
</HEAD>
<BODY BGCOLOR="#ffffdf">
This document is a single-page version of a <A HREF="index.htm">a multi-page document</A>, suitable for easy printing.
<A NAME="index.htm"></A>



<H1 CLASS="chapterTitle">

<A NAME="index.htm_15687">
 </A>
The File System

</H1>
<P>
<A NAME="index.htm_IX_Files">
 </A>
<A NAME="index.htm_IX_File system">
 </A>
Every operating system needs a way to interact with files. Files are used to hold both data and executable code. They are also the simplest way of transferring data from one computer to another.</P>
<P>
GEOS provides powerful file-management functionality. It runs on top of a disk-operating system, and uses that DOS to read files from different media. Applications which run under GEOS need only interact with the GEOS file-management system; they are insulated from the differences between versions of DOS. They are also insulated from the differences between various file-storage media: CD-ROM drives, network file servers, and floppy and hard disks all present the same interface.</P>
<P>
The GEOS file system provides functionality that many versions of DOS do not have. It allows the use of virtual directories, so (for example) the system's FONT directory could actually comprise several physical directories. GEOS files have functionality which DOS files lack. For example, GEOS provides support for file-sharing and data-access synchronization across networks. Nevertheless, GEOS lets applications access standard DOS files and directories when desired.</P>
<P>
You may not need to use much of the file system directly. The document control and file-selector objects can let the user select and open files transparently to the application. Many applications will never need to negotiate the directory structure.</P>
<P>

</P>
<P CLASS="sectionlinks">
<STRONG>
&nbsp;&nbsp;<A HREF="#FileSys_1.htm">1 Design Philosophy</A><BR>
&nbsp;&nbsp;<A HREF="#FileSys_2.htm">2 File System Overview</A><BR>
&nbsp;&nbsp;<A HREF="#FileSys_3.htm">3 Disks and Drives</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#FileSys_4.htm">3.1 Accessing Drives</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#FileSys_5.htm">3.2 Accessing Disks</A><BR>
&nbsp;&nbsp;<A HREF="#FileSys_6.htm">4 Directories and Paths</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#FileSys_7.htm">4.1 Standard Paths</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#FileSys_8.htm">4.2 Current Path and Directory Stack</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#FileSys_9.htm">4.3 Creating and Deleting Directories</A><BR>
&nbsp;&nbsp;<A HREF="#FileSys_a.htm">5 Files</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#FileSys_b.htm">5.1 DOS Files and GEOS Files</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#FileSys_c.htm">5.2 Files and File Handles</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#FileSys_d.htm">5.3 GEOS Extended Attributes</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#FileSys_e.htm">5.4 File Utilities</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#FileSys_f.htm">5.5 FileEnum()</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#FileSys_10.htm">5.6 Bytewise File Operations</A><BR>
</STRONG>
</P> <!-- end of sectionlinks blob -->

<HR>
<A NAME="FileSys_1.htm"></A>


<H2 CLASS="sectionTitle">
<A HREF="#index.htm">The File System</A>: 1 
Design Philosophy</H2>
<P>
The GEOS file system was designed to meet two goals. First, the file system should insulate geodes from differences in hardware, making them device independent; and second, it should give geodes all the functionality they might plausibly want without being cumbersome.</P>
<P>
One of the hallmarks of GEOS is its ability to insulate applications from differences in hardware. The GEOS file system plays a large role in this. Geodes which need access to files make their requests to the GEOS file system, which accesses the actual storage media. The virtues of this approach are several:</P>
<UL>
<LI>
Geodes can rely on a consistent API for accessing media. When an application needs to open a file, it uses exactly the same techniques whether the file resides on a hard or floppy disk, a network drive, or some other medium.</LI>
<LI>
GEOS can easily expand to make use of new technologies. To support a new storage medium, GEOS just needs a new device driver; all existing application binaries will automatically work with the new device.</LI>
<LI>
Applications need not worry about what DOS the system might be running under. The GEOS file system does all interaction with the DOS and automatically takes advantages of each DOS' strengths. To support new versions of DOS, GEOS just needs new drivers.</LI>
</UL>
<P>
GEOS is also flexible. Flexibility means more than just being able to use new technology in the same old ways; it means providing functionality to serve unforeseen purposes. GEOS provides this:</P>
<UL>
<LI>
The file system allows such advanced functionality as virtual paths and directories. Files can thus be distributed across various media (for example, templates and fonts on CD-ROM drives, company files on a network drive, other documents on local hard disks) transparently to both user and application.</LI>
<LI>
Other functionality can be added. For example, all GEOS files can have names up to 32 characters long, regardless of strictures on individual media. The file system maps the GEOS &quot;virtual names&quot; to device-dependent &quot;native names&quot; transparently to the user and application.</LI>
</UL>
<P>
While GEOS provides this advanced functionality, it still lets geodes access the raw files. If a geode wants to access any file as a sequence of bytes (the DOS model), it may do so. Similarly, geodes may work with physical DOS directories if they wish to.</P>
<HR>
<A NAME="FileSys_2.htm"></A>


<H2 CLASS="sectionTitle">
<A HREF="#index.htm">The File System</A>: 2 
File System Overview</H2>
<P>
The GEOS file system manages all access to files on any type of storage. Whenever a geode needs to access a data file, it calls a file system routine. The file system makes any necessary calls to the computer's DOS. Like much of the GEOS system, it is driver-based; this makes it easy to expand GEOS to accommodate new technologies.</P>
<P>
When a geode needs to access a file, it makes a call to the file system. The file system sends requests through the appropriate driver. For example, if the geode needs access to a file on a local hard or floppy disk drive, the file system will send commands through a DOS driver, which will in turn issue appropriate commands to the DOS itself. Similarly, if the file resides on a network drive, the file system will send commands through an appropriate network driver, which will translate them into corresponding commands to the network server. 
<IMG SRC="FileSys_2_geodeRelations.gif">

</P>
<P>
Every storage device is known as a <EM>
drive.</EM>
 A drive can be either fixed-media or movable-media. Fixed media drives are always associated with a specific storage medium; in effect, the drive is the same as the storage. The primary example of this is the conventional hard disk. Movable-media drives use a potentially unlimited number of storage objects. Examples include floppy disk drives, CD-ROM drives, and cartridge hard drives. </P>
<P>
<A NAME="FileSys_2.htm_IX_Volumes (file system)">
 </A>
One way of organizing storage objects is to divide them into <EM>
volumes</EM>
. Ordinarily, every disk (floppy or hard) is a single volume; however, hard disks are sometimes divided into several volumes. Network storage devices are frequently divided into several volumes. If a single drive is partitioned into several volumes, DOS and GEOS treat each volume as a separate drive. In this chapter, the words <EM>
volume</EM>
 and <EM>
disk</EM>
 will be used interchangeably.</P>
<P>
<A NAME="FileSys_2.htm_IX_Directories (file system)">
 </A>
Individual volumes are organized with <EM>
directories.</EM>
 A directory may contain several different files or directories. There is not usually a limit on the number of files a directory may contain; however, no two files or directories belonging to a given directory may have the same name.</P>
<P>
Every volume is organized in a <EM>
directory tree</EM>
. The topmost directory is known as the <EM>
root</EM>
; it is unnamed, since every volume contains exactly one root directory. The root may contain files or directories. Those directories may themselves contain files or directories, and so on. The total number of files is usually limited only by the size of the storage device.</P>
<P>
To specify a file, you need to specify three things: The volume the file resides on, the directory to which the file belongs, and the file's name. In most DOS environments, a volume is generally specified with a letter followed by a colon (for example, the first hard disk is generally specified as &quot;C:&quot;). For non-fixed media (e.g. floppy disks), the letter actually specifies the drive; the volume is presumed to be in that drive. In GEOS, volumes and drives have different identifying systems.<A NAME="FileSys_2.htm_IX_Drive number">
 </A>
 Every drive is identified by a <EM>
drive number</EM>
. This is a positive integer; the first drive has a number of zero, the second is drive one, and so on.<A NAME="FileSys_2.htm_IX_DiskHandle">
 </A>
 Every volume is identified by a token (the <EM>
disk handle</EM>
).</P>
<P>
Specifying the directory is a little trickier. There may be many directories with the same name on a given volume. For this reason, the directory is specified with a <EM>
path.</EM>
 The path begins with the root directory; the root is followed by the name of one of the directories belonging to the root; that directory is followed by the name of one of its subdirectories; and so on, until the desired directory is reached. Since all the directories belonging to a given directory must have unique names, the path is guaranteed to uniquely specify a directory on a volume. For example, you might specify a directory as &quot;\GEOWORKS\DOCUMENT\MEMOS&quot;; this would indicate a directory named &quot;MEMOS,&quot; which belongs to a directory named &quot;DOCUMENT,&quot; which in turn belongs to a directory named &quot;GEOWORKS&quot; at the root level.</P>
<P>
The file itself is identified by its name. Since its directory has been uniquely specified by the volume and path, the name is guaranteed to specify at most one file in that directory. Each disk-operating system has its own conventions about how file names can be formed; for example, MS-DOS requires file names to have a &quot;name&quot; portion of at most eight letters, followed by an &quot;extension&quot; of at most three letters (known as the &quot;FILENAME.EXT&quot; convention). 

</P>
<P>
For convenience, most operating systems let you specify a &quot;working directory.&quot; This is a combination of a volume and a path. If you have a working directory, you can omit either the volume or the path from a file specification, and the volume and/or path of the working directory will be used. This is called a &quot;relative path,&quot; i.e. a path that is relative to the working directory instead of the root directory. (Note that if you specify a disk handle for any operation, you must pass an absolute path which begins at the root of that disk or standard path.) GEOS allows every thread to have its own working directory; each thread can also save paths on a stack, letting the thread switch directories easily. For more details, see <A HREF="#FileSys_8.htm_33340"> Current Path and Directory Stack</A>
.</P>
<P>
Some disk-operating systems, such as MS-DOS, allow a working directory for each drive. GEOS does not allow this; you may have only one working directory at a time, regardless of how many drives you have. If you need to switch back and forth between directories on different drives, you can use the directory stack (see <A HREF="#FileSys_8.htm_33340"> Current Path and Directory Stack</A>
).</P>
<HR>
<A NAME="FileSys_3.htm"></A>


<H2 CLASS="sectionTitle">
<A HREF="#index.htm">The File System</A>: 3 
Disks and Drives</H2>
<P>
GEOS provides an easy interface to storage devices. Every drive (or analogous storage device) is identified by a token. Every volume is also identified by a token. This enables you to easily move from one volume to another.</P>
<P>
You generally need only worry about disks and drives when you are opening a file. Once you have a file open, you can access the file by its file handle without paying attention to the disk it resides on. The GEOS file system will automatically prompt the user to change disks whenever necessary.</P>
<P>
Note that if you use the document control object to open files, you will probably never have to worry about disks and drives. The document control automatically presents a File Selector dialog box to the user, letting the user navigate among disks and directories; when the user selects a file, the document control will automatically open the file and return its handle to the application.</P>
<P CLASS="subsectionLink">
<A HREF="#FileSys_4.htm">Accessing Drives</A></P>
<P CLASS="subsectionLink">
<A HREF="#FileSys_5.htm">Accessing Disks</A></P>
<HR>
<A NAME="FileSys_4.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">The File System</A>: 3.1 <A HREF="#FileSys_3.htm">Disks and Drives</A>: 
<A NAME="FileSys_4.htm_64044">
 </A>
Accessing Drives</H3>
<PRE>DriveGetStatus(), DriveGetExtStatus(), DriveGetDefaultMedia(), DriveTestMediaSupport(), DriveGetName(), DriveStatus, DriveType, MediaType</PRE>
<P>
Most systems running GEOS have access to a number of different drives. With the exception of network drives, the drives available will usually not change during an execution of GEOS, although the volumes mounted on the drives can change. Every drive is accessed by its <EM>
drive number</EM>
. This token is a byte-length integer value.</P>
<P>
When you wish to open a file, you must specify its volume, not its drive. This is because the volume mounted on a drive can change frequently and without warning. </P>
<P>
GEOS<A NAME="FileSys_4.htm_IX_DriveGetStatus()">
 </A>
 provides routines to get information about a drive. To get general information about a drive, call the routine <CODE>
DriveGetStatus()</CODE>
. <A NAME="FileSys_4.htm_IX_DS_&ldots;  (DriveStatus)">
 </A>
<A NAME="FileSys_4.htm_IX_DriveStatus">
 </A>
This routine takes the drive number and returns a word-length set of <CODE>
DriveStatus</CODE>
 flags (defined in <STRONG CLASS="fileName">
drive.h</STRONG>
). If an error condition exists, such as the drive you request not existing, it returns zero. The following flags may be returned:</P>
<DL>
<DT>
DS_PRESENT</DT><DD>
This flag is set if the physical drive exists, regardless of whether the drive contains a disk.</DD>
<DT>
DS_MEDIA_REMOVABLE</DT><DD>
This flag is set if the disk can be removed from the drive.</DD>
<DT>
DS_NETWORK</DT><DD>
This flag is set if the drive is accessed over a network (or via network protocols), which means the drive cannot be formatted or copied.</DD>
<DT>
DS_TYPE</DT><DD>This is a mask for the lowest four bits of the field. These bits contain a member of the <CODE>
DriveType</CODE>
 enumerated type.</DD>
</DL>
<P>
<A NAME="FileSys_4.htm_IX_DRIVE_&ldots;">
 </A>
<A NAME="FileSys_4.htm_IX_DriveType">
 </A>
The lowest four bits of the word contains a member of the <CODE>
DriveType</CODE>
 enumerated type. The field can be accessed by masking out all the bits except for those set in DS_TYPE. <CODE>
DriveType</CODE>
 comprises the following values:</P>
<DL>
<DT>
DRIVE_5_25</DT><DD>Drive uses 5.25-inch floppy disks.</DD>
<DT>
DRIVE_3_5</DT><DD>Drive uses 3.5-inch floppy disks.</DD>
<DT>
DRIVE_FIXED</DT><DD>
Drive uses some kind of fixed disk (e.g. a hard drive).</DD>
<DT>
DRIVE_RAM</DT><DD>Drive is chip-based (either RAM or ROM).</DD>
<DT>
DRIVE_CD_ROM</DT><DD>
Drive uses read-only optical disks.</DD>
<DT>
DRIVE_8</DT><DD>Drive uses 8-inch floppy disks.</DD>
<DT>
DRIVE_UNKNOWN</DT><DD>
Drive type is unknown.</DD>
</DL>
<P>
<CODE>
DriveGetStatus()</CODE>
 returns the information most often needed about a drive. However, you may sometimes need more obscure information.<A NAME="FileSys_4.htm_IX_DriveGetExtStatus()">
 </A>
 For this reason, GEOS provides the routine <CODE>
DriveGetExtStatus()</CODE>
. Like <CODE>
DriveGetStatus()</CODE>
, it takes the drive number as an argument and returns a word of flags; however, it returns additional flags. The flags returned by <CODE>
DriveGetStatus()</CODE>
 are set in the lower byte of the returned word; special additional flags are set in the upper byte. Like <CODE>
DriveGetStatus()</CODE>
, <CODE>
DriveGetExtStatus()</CODE>
 returns zero if the drive specified is invalid. The following flags are defined for the upper byte:</P>
<DL>
<DT>
DES_LOCAL_ONLY</DT><DD>
<A NAME="FileSys_4.htm_IX_DES_&ldots;">
 </A>
This flag is set if the device cannot be viewed over a network.</DD>
<DT>
DES_READ_ONLY</DT><DD>
This flag is set if the device is read only, i.e. no data can ever be written to a volume mounted on it (e.g., a CD-ROM drive).</DD>
<DT>
DES_FORMATTABLE</DT><DD>
This flag is set if disks can be formatted in the drive.</DD>
<DT>
DES_ALIAS</DT><DD>This flag is set if the drive is actually an alias for a path on another drive.</DD>
<DT>
DES_BUSY</DT><DD>This flag is set if the drive will be busy for an extended period of time (e.g., if a disk is being formatted).</DD>
</DL>
<P>
Many disk drives can take a variety of disks. For example, high-density 3.5-inch drives can read and write to either 720K disks or 1.44M disks. Every drive has a &quot;default&quot; media type. When you format a disk in that drive, it will, by default, be formatted to the default size.<A NAME="FileSys_4.htm_IX_DriveGetDefaultMedia()">
 </A>
 To find out the default disk type, call the routine <CODE>
DriveGetDefaultMedia()</CODE>
. This routine takes one argument, namely the drive number.<A NAME="FileSys_4.htm_IX_MediaType">
 </A>
 It returns a member of the <CODE>
MediaType</CODE>
 enumerated type. <CODE>
MediaType</CODE>
 has the following possible values:</P>
<DL>
<DT>
MEDIA_160K, MEDIA_180K, MEDIA_320K, MEDIA_360K</DT><DD>
<A NAME="FileSys_4.htm_IX_MEDIA_&ldots;">
 </A>
<A NAME="FileSys_4.htm_17696">
 </A>
These are all sizes used by 5.25-inch disks.</DD>
<DT>
MEDIA_720K</DT><DD>
This is the size of a regular 3.5-inch disk.</DD>
<DT>
MEDIA_1M2</DT><DD>
This is the size of a high-density 5.25-inch disk.</DD>
<DT>
MEDIA_1M44</DT><DD>
This is the size of a high-density 3.5-inch disk.</DD>
<DT>
MEDIA_2M88</DT><DD>
This is the size of an ultra-high-density 3.5-inch disk.</DD>
<DT>
MEDIA_FIXED_DISK</DT><DD>
This is returned for all fixed disks.</DD>
<DT>
MEDIA_CUSTOM</DT><DD>
This is returned if none of the other values is appropriate. For example, it is returned for CD-ROM drives.</DD>
<DT>
MEDIA_NONEXISTENT</DT><DD>
This is returned if the drive specified does not contain a disk. This value is defined to be equal to zero.</DD>
</DL>
<P>
<A NAME="FileSys_4.htm_IX_DriveTestMediaSupport()">
 </A>
If you want to find out if a drive can accommodate a certain kind of disk, call the routine <CODE>
DriveTestMediaSupport()</CODE>
. This Boolean routine takes two arguments: a drive number and a member of the <CODE>
MediaType</CODE>
 enumerated type. If the drive supports that medium, the routine returns <EM>
true</EM>
 (i.e. non-zero); otherwise, it returns <EM>
false</EM>
 (i.e. zero).</P>
<P>
<A NAME="FileSys_4.htm_IX_DriveGetName()">
 </A>
To find out the name of a given drive, call <CODE>
DriveGetName()</CODE>
. This routine is passed three arguments: a drive number, a pointer to a character buffer, and the size of that buffer. <CODE>
DriveGetName()</CODE>
 writes the drive's name to the buffer as a null-terminated string; it returns a pointer to that trailing null. If the buffer was not large enough, or the drive does not exist, it returns a null pointer.</P>
<HR>
<A NAME="FileSys_5.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">The File System</A>: 3.2 <A HREF="#FileSys_3.htm">Disks and Drives</A>: 
Accessing Disks</H3>
<P>
Applications will work with disks more than they will work with drives. Once a geode knows a disk's handle, it can ignore such questions as whether the disk is in a drive; it need merely provide the disk's handle. If necessary, the system will prompt the user to insert the disk in the appropriate drive.</P>

<H4 CLASS="HeadingC">
<A NAME="FileSys_5.htm_87244">
 </A>
Registering Disks</H4>
<PRE>DiskRegisterDisk(), DiskRegisterDiskSilently()</PRE>
<P>
GEOS automatically keeps track of all disks used. The first time a disk is accessed in a session, it is <EM>
registered</EM>
. This means that it is assigned a <EM>
disk handle</EM>
. </P>
<P>
The disk handle records certain information, such as the disk's volume name and whether the disk is writable. It also notes in which drive the disk was last inserted; if the system prompts the user to reinsert the disk, it will insist on that drive. A disk is automatically reregistered when certain actions are performed which might invalidate a disk's handle-table entry; for example, it is reregistered if it is formatted. It is also reregistered if someone tries to write a file to a disk which is marked read-only; the user may have ejected the disk and removed its write-protect tab. Note that reregistering a disk does not change its handle; it just brings GEOS's information about the disk up-to-date.</P>
<P>
Note that the disk handle is not a reference to the global handle table; thus, Swat commands like <CODE>
phandle</CODE>
 will not work with disk handles. Disk handles should always be treated as opaque 16-bit tokens.</P>
<P>
<A NAME="FileSys_5.htm_IX_DiskRegisterDisk()">
 </A>
You can specifically instruct the system to register a disk by calling the routine <CODE>
DiskRegisterDisk()</CODE>
. The routine is passed a single argument, namely the drive number. If the disk has an entry in the disk table, the routine will not reregister the disk; it will just return the disk's handle. If the disk has no entry in the table, the system will create an entry and register the disk. In this case, also, the routine will return the (new) disk handle. If the routine fails (for example, because there is no valid disk in the specified drive, or the drive itself does not exist), it returns a null handle.</P>
<P>
When a disk is registered, the system notes the volume label. This label is used when the system has to prompt the user to insert a disk. If an unlabeled disk is inserted, the system will choose an arbitrary label for the volume (e.g. &quot;UNNAMED1&quot;). The system does not actually write this label to the disk; the label is used by the system and discarded when the session ends. Ordinarily, the system will present an alert box to inform the user about the temporary label.<A NAME="FileSys_5.htm_IX_DiskRegisterDiskSilently()">
 </A>
 You can suppress this notification by calling the system routine <CODE>
DiskRegisterDiskSilently()</CODE>
. This routine has the same arguments and return values as <CODE>
DiskRegisterDisk()</CODE>
.</P>


<H4 CLASS="HeadingC">
<A NAME="FileSys_5.htm_38369">
 </A>
Getting Information about a Disk</H4>
<PRE>DiskGetVolumeInfo(), DiskGetVolumeFreeSpace(), DiskGetDrive(), DiskGetVolumeName(), DiskFind(), DiskCheckWritable(), DiskCheckInUse(), DiskCheckUnnamed(), DiskForEach(), DiskInfoStruct, DiskFindResult</PRE>
<P>
GEOS provides many routines to get information about disks. If geodes call disk routines at all, they are most likely to call these. Most of these routines are passed the handle of the disk. If you know the disk's volume label and need to find out its handle, call the routine <CODE>
DiskFind()</CODE>
 (described below). If you know the disk is currently in a drive and you need to find out its handle, register the disk (see <A HREF="#FileSys_5.htm_87244"> Registering Disks</A>
). Note that any routine which is passed a disk handle can be passed a standard path constant; in this case, the routine will give you information about the disk containing the <STRONG CLASS="fileName">
geos.ini</STRONG>
 file.</P>
<P>
<A NAME="FileSys_5.htm_IX_DiskGetVolumeInfo()">
 </A>
The basic disk-information routine is <CODE>
DiskGetVolumeInfo()</CODE>
. This returns information about the size of the disk and the amount of free space available. The routine is passed two arguments: the disk handle and a pointer to a <CODE>
DiskInfoStruct</CODE>
 structure (shown below). The routine fills in the fields of the <CODE>
DiskInfoStruct</CODE>
 structure and returns zero if it was successful. If it fails for any reason, it returns an error value and sets the thread's error value (which can be recovered with <CODE>
ThreadGetError()</CODE>
). The usual error value returned is the constant ERROR_INVALID_VOLUME.</P>
<P CLASS="figTitle">
Code Display 17-1 <A NAME="FileSys_5.htm_IX_DiskInfoStruct">
 </A>
The DiskInfoStruct Structure</P>
<PRE>typedef struct {
	word		DIS_blockSize;		/* # of bytes in a block; smallest size
					 * file system can allocate at once */
	sdword		DIS_freeSpace;		/* # of bytes free on disk */
	sdword		DIS_totalSpace;		/* Total size of the disk in bytes */
	char		DIS_name[VOLUME_BUFFER_SIZE];				
					/* Volume name; if disk is unnamed, this
					 * is the temporary name. String is
					 * null-terminated. */
} DiskInfoStruct;</PRE>
<P>
<A NAME="FileSys_5.htm_IX_DiskGetVolumeName()">
 </A>
If you just want to know a disk's name, call <CODE>
DiskGetVolumeName()</CODE>
. This routine takes two arguments: the disk handle and the address of a character buffer. (The buffer must be at least VOLUME_NAME_LENGTH_ZT characters long.) It writes the volume name to the buffer as a null-terminated string, and it returns the buffer's address. If the volume is unnamed, <CODE>
DiskGetVolumeName()</CODE>
 writes the temporary volume name.</P>
<P>
<A NAME="FileSys_5.htm_IX_DiskCheckUnnamed()">
 </A>
Note that all the routines which return a volume's name will return the temporary name if the volume is unnamed. For this reason, if you want to find out if a volume is unnamed, you must use a special purpose routine, namely <CODE>
DiskCheckUnnamed()</CODE>
. This Boolean routine is passed the disk's handle. If the volume does not have a permanent label, the routine returns <EM>
true</EM>
; otherwise, it returns <EM>
false</EM>
.</P>
<P>
<A NAME="FileSys_5.htm_IX_DiskGetVolumeFreeSpace()">
 </A>
If you want to know how much free space is available on a disk, call the routine <CODE>
DiskGetVolumeFreeSpace()</CODE>
. The routine is passed the disk handle; it returns (as a dword) the number of free bytes available. If the volume is currently read-only (e.g. a floppy disk with the write-protect tab set), it returns the amount of space that would be available if the volume were made read/write. If the volume is, by its nature, not writable (e.g. a CD-ROM disk), the routine will return zero. It will also return zero if an error condition occurs; in this case, it will also set the thread's error value.</P>
<P>
<A NAME="FileSys_5.htm_IX_DiskGetDrive()">
 </A>
If you want to know what drive a volume is associated with, call <CODE>
DiskGetDrive()</CODE>
. This routine takes one argument, namely the volume's disk handle. It returns the number of the drive which had that disk. Note that it will return this value even if that drive is no longer usable.</P>
<P>
<A NAME="FileSys_5.htm_IX_DiskFind()">
 </A>
If you know the label of a volume which has been registered and you need to find out its handle, call the routine <CODE>
DiskFind()</CODE>
. <A NAME="FileSys_5.htm_IX_DiskFindResult">
 </A>
<A NAME="FileSys_5.htm_IX_DFR_&ldots;">
 </A>
The routine takes two arguments: the address of a null-terminated string containing the volume name and a pointer to a variable of the <CODE>
DiskFindResult</CODE>
 enumerated type. It will return the disk's handle; if no disk with the specified name has been registered, it will return a null handle. <CODE>
DiskFindResult</CODE>
 has the following possible values:</P>
<DL>
<DT>
DFR_UNIQUE</DT><DD>
Exactly one volume with the specified name has been registered. The handle of that volume was returned.</DD>
<DT>
DFR_NOT_UNIQUE</DT><DD>
Two or more volumes with the specified label have been registered. The handle of an arbitrary one of these volumes was returned. If you want to find the handles of all of these disks, call <CODE>
DiskForEach()</CODE>
, described below.</DD>
<DT>
DFR_NOT_FOUND</DT><DD>
No disk with the specified label has been registered. A null handle was returned.</DD>
</DL>
<P>
<A NAME="FileSys_5.htm_IX_DiskCheckWritable()">
 </A>
To check if a volume is writable, call the Boolean routine <CODE>
DiskCheckWritable()</CODE>
. The routine takes one argument, the disk's handle. If the disk is writable, the routine returns <EM>
true</EM>
 (i.e. non-zero). If the disk is non-writable, the routine returns <EM>
false</EM>
 (i.e. zero). </P>
<P>
<A NAME="FileSys_5.htm_IX_DiskCheckInUse()">
 </A>
To see if a disk is being used by any threads, call <CODE>
DiskCheckInUse()</CODE>
. The routine takes one argument: the disk's handle. It returns <EM>
true</EM>
 (i.e. non-zero) if a file on the disk is open or if any thread has a directory on that disk in its directory stack (see <A HREF="#FileSys_8.htm_33340"> Current Path and Directory Stack</A>
). If neither condition applies, the routine returns <EM>
false</EM>
 (i.e. zero).</P>
<P>
<A NAME="FileSys_5.htm_IX_DiskForEach()">
 </A>
If you want to perform an action on every disk, call <CODE>
DiskForEach()</CODE>
. This routine takes one argument, a pointer to a Boolean callback routine. The callback routine should take a single argument, the handle of a disk. <CODE>
DiskForEach()</CODE>
 calls the callback routine once for every registered disk. It passes the disk handle to the callback routine, which can take any action it wants; for example, it could call one of the other disk-information routines. The callback routine can make <CODE>
DiskForEach()</CODE>
 halt prematurely by returning a non-zero value. If the callback routine forced an early halt, <CODE>
DiskForEach()</CODE>
 returns the last disk handle which had been passed to the callback routine; otherwise it returns a null handle. This routine is commonly called to look for a specific disk. To do this, simply have the callback routine check each disk to see if it is the one sought; if it is, simply return <EM>
true</EM>
, and <CODE>
DiskForEach()</CODE>
 will return that disk's handle.</P>
<P>
<CODE>
DiskForEach()</CODE>
 does not need to examine the actual disks; it works from the information the file-system stores about all registered disks. This means that <CODE>
DiskForEach()</CODE>
 will not have to prompt the user to insert any disks. Of course, the callback routine may need to examine the disks, in which case the user will be prompted when necessary.</P>


<H4 CLASS="HeadingC">
<A NAME="FileSys_5.htm_58568">
 </A>
Saving and Restoring a Disk Handle</H4>
<PRE>DiskSave(), DiskRestore(), DiskRestoreError</PRE>
<P>
A disk does not necessarily have the same handle from one execution of GEOS to another. This can pose a problem for an application which is restarting from a state file. In order to reopen a file, it has to know the file's location. If it knows the file's location relative to a standard path, there is no problem, since the application can use the standard path constant in the place of a disk handle. If the file is not in a standard path, the application will need some way of figuring out the disk's handle on restart.</P>
<P>
For this reason, GEOS provides <CODE>
DiskSave()</CODE>
 and <CODE>
DiskRestore()</CODE>
. <CODE>
DiskSave()</CODE>
<A NAME="FileSys_5.htm_IX_DiskSave()">
 </A>
 saves information about a disk in an opaque data structure. <CODE>
DiskRestore()</CODE>
 reads such a data buffer and returns the handle of the disk described; it even arranges to prompt the user if the disk has not been registered yet.</P>
<P>
To save a disk handle, call <CODE>
DiskSave()</CODE>
. This routine takes three arguments:</P>
<UL>
<LI>
The disk handle. <BR>
This may be a standard path.</LI>
<LI>
A pointer to a buffer. <BR>
<CODE>
DiskSave()</CODE>
 will write opaque data to that buffer; you will need to pass that data to <CODE>
DiskRestore()</CODE>
 to restore the handle.</LI>
<LI>
A pointer to an integer. <BR>
When you call <CODE>
DiskSave()</CODE>
, that integer should contain the size of the buffer (in bytes). When <CODE>
DiskSave()</CODE>
 exits, the integer will contain the size of the buffer needed or used (as described below).</LI>
</UL>
<P>
If <CODE>
DiskSave()</CODE>
 was successful, it will return <EM>
true</EM>
. The integer parameter will contain the size of the buffer actually needed; for example, if the buffer had been 100 bytes long and <CODE>
DiskSave()</CODE>
 returns 60, you can safely free the last 40 bytes in the buffer. If <CODE>
DiskSave()</CODE>
 failed, it will return <EM>
false</EM>
. If it failed because the buffer was too small, it will write the size needed into the integer passed; simply call <CODE>
DiskSave()</CODE>
 again with a large enough buffer. If <CODE>
DiskSave()</CODE>
 failed for some other reason (e.g. the disk belongs to a drive which no longer exists), it will write a zero value to the integer.</P>
<P>
<CODE>
</CODE>
<A NAME="FileSys_5.htm_IX_DiskRestore()">
 </A>
To restore a disk, call <CODE>
DiskRestore()</CODE>
. This routine takes two arguments:</P>
<UL>
<LI>
A pointer to the opaque data structure written by <CODE>
DiskSave()</CODE>
.</LI>
<LI>
A pointer to a callback routine. The callback routine is called if the user must be prompted to insert the disk. If you pass a null function pointer, <CODE>
DiskRestore()</CODE>
 will fail in this situation.</LI>
</UL>
<P>
If the disk in question has already been registered or is currently in its drive, <CODE>
DiskRestore()</CODE>
 will return its handle. If the disk is not registered and is not in any drive, <CODE>
DiskRestore()</CODE>
 will call the callback routine. The callback routine should accept the following four arguments:</P>
<UL>
<LI>
A pointer to a null-terminated string containing the drive name, specified according to the DOS convention (e.g. &quot;C:&quot;).</LI>
<LI>
A pointer to a null-terminated string containing the disk volume label.</LI>
<LI>
The <CODE>
DiskRestoreError</CODE>
 (see below) which would be returned if the callback routine hadn't been called.</LI>
<LI>
A pointer to a pointer to the opaque data structure. If the callback routine causes the data structure to move, it should fix up the pointer to point to the new location. Note that the two strings (the drive name and the disk label) are located within this data structure; thus, if you cause this structure to move, both of those pointers will be invalidated.</LI>
</UL>
<P>
If the callback routine believes the user inserted the correct disk, it should return DRE_DISK_IN_DRIVE. Otherwise, it should return a <CODE>
DiskRestoreError</CODE>
 constant. In this case, <CODE>
DiskRestore()</CODE>
 will fail and set the thread's error value to the constant specified. If the callback routine returns an error, that error will generally be DRE_USER_CANCELLED_RESTORE.</P>
<P>
If <CODE>
DiskRestore()</CODE>
 is successful, it will return the disk handle; this may be different from the disk's handle in the previous execution. You may now free the data buffer, if you like. If <CODE>
DiskRestore()</CODE>
 fails, it will return a null handle and set the thread's error value. <A NAME="FileSys_5.htm_IX_DRE_&ldots;">
 </A>
<A NAME="FileSys_5.htm_IX_DiskRestoreError">
 </A>
There are several different <CODE>
DiskRestoreError</CODE>
 values; they are listed below.</P>
<DL>
<DT>
DRE_DRIVE_NO_LONGER_EXISTS</DT><DD>
The disk had last been used in a drive which is no longer attached to the system (or the appropriate file-system driver is no longer present).</DD>
<DT>
DRE_REMOVABLE_DRIVE_DOESNT_HOLD_DISK</DT><DD>
The disk was in a removable-media drive, and that drive doesn't contain the disk.</DD>
<DT>
DRE_USER_CANCELLED_RESTORE</DT><DD>
A callback routine was called and returned this value to <CODE>
DiskRestore()</CODE>
.</DD>
<DT>
DRE_COULDNT_CREATE_NEW_DISK_HANDLE</DT><DD>
<CODE>
DiskRestore()</CODE>
 found the disk in the drive but was for some reason unable to create the disk handle.</DD>
<DT>
DRE_REMOVABLE_DRIVE_IS_BUSY</DT><DD>
The appropriate drive exists but is unavailable due to some time-consuming operation (e.g. a disk format).</DD>


</DL>
<H4 CLASS="HeadingC">
<A NAME="FileSys_5.htm_88589">
 </A>
Other Disk Utilities</H4>
<PRE>DiskSetVolumeName(), DiskFormat(), DiskCopy(), FormatError, DiskCopyCallback, DiskCopyError</PRE>
<P>
GEOS provides several utilities for working with disks. These utilities allow geodes to copy disks, format them, and change their volume names. Most applications will never need to use these utilities; they can rely on the users to take care of disk formatting with an application like GeoManager. However, some applications will want to make use of them. For example, an archiving program might automatically format storage disks and give them appropriate labels.</P>

<H5 CLASS="HeadingD">
<A NAME="FileSys_5.htm_17108">
 </A>
Changing a Volume Name</H5>
<P>
<A NAME="FileSys_5.htm_IX_DiskSetVolumeName()">
 </A>
If you want to set or change a volume's name, you should call <CODE>
DiskSetVolumeName()</CODE>
. This routine takes two arguments: the volume's handle and the address of a null-terminated string (containing the new volume name). If it is able to change the volume's name, it returns zero; otherwise, it returns an error code. It sets or clears the thread's error value appropriately. The following error codes may be returned:</P>
<DL>
<DT>
ERROR_INVALID_VOLUME</DT><DD>
An invalid disk handle was passed to the routine.</DD>
<DT>
ERROR_ACCESS_DENIED</DT><DD>
For some reason, the volume's name could not be changed. For example, the volume might not be writable.</DD>
<DT>
ERROR_DISK_STALE</DT><DD>
The drive containing that disk has been deleted. This usually only happens with network drives.</DD>


</DL>
<H5 CLASS="HeadingD">
Formatting a Disk</H5>
<P>
<A NAME="FileSys_5.htm_IX_DiskFormat()">
 </A>
If a geode needs to format a disk, it can call the routine <CODE>
DiskFormat()</CODE>
. This routine can do either low-level or high-level (&quot;soft&quot;) formats. The routine does not interact with the user interface; instead, it calls a callback routine, which can arrange any such interaction. <CODE>
DiskFormat()</CODE>
 takes seven arguments:</P>
<UL>
<LI>
The number of the drive containing the disk to be formatted.</LI>
<LI>
The address of a null-terminated string containing the disk's new volume name.</LI>
<LI>
A member of the <CODE>
MediaType</CODE>
 enumerated type (see <A HREF="#FileSys_4.htm_17696"> MEDIA_160K, MEDIA_180K, MEDIA_320K, MEDIA_360K These are all sizes used by 5.25-inch disks.</A>
).</LI>
<LI>
<A NAME="FileSys_5.htm_IX_DFF_&ldots;">
 </A>
<A NAME="FileSys_5.htm_IX_DiskFormatFlags">
 </A>
Flags indicating how the format should be done. The following flags are available:</LI>
</UL>
<DL>
<DT>
    DFF_CALLBACK_PERCENT_DONE</DT><DD>
A callback routine will be called periodically. The callback routine will be passed a single argument, namely the percentage of the format which has been done, expressed as an integer.</DD>
<DT>
    DFF_CALLBACK_CYL_HEAD</DT><DD>
A callback routine will be called periodically. The callback routine will be passed a single argument, namely the cylinder head being formatted. If both DFF_CALLBACK_PERCENT_DONE and DFF_CALLBACK_CYL_HEAD are passed, results are undefined.</DD>
<DT>
    DFF_FORCE_ERASE</DT><DD>
A &quot;hard format&quot; should be done; that is, the sectors should be rewritten and initialized to zeros. If this flag is not set, <CODE>
DiskFormat()</CODE>
 will do a &quot;soft format&quot; if possible; it will check the sectors and write a blank file allocation table, but it will not necessarily erase the data from the disk.</DD>
<UL>
<LI>
A pointer to an unsigned integer variable; the number of good sectors on the disk will be written here.</LI>
<LI>
A pointer to an unsigned integer variable; the number of bad sectors on the disk will be written here.</LI>
<LI>
The address of a Boolean callback routine, as described above. The routine should be passed either the current cylinder and head or the percentage formatted, depending on the flag passed to <CODE>
DiskFormat()</CODE>
. It should return <EM>
true</EM>
 to abort the format, or <EM>
false</EM>
 (i.e. zero) to continue with the format. If neither DFF_CALLBACK_PERCENT_DONE nor DFF_CALLBACK_CYL_HEAD is passed, the callback routine will never be called, so this argument may be a null pointer.</LI>
</UL>
</DL>
<P>
<CODE>
DiskFormat()</CODE>
<A NAME="FileSys_5.htm_IX_FMT_&ldots;">
 </A>
<A NAME="FileSys_5.htm_IX_FormatError">
 </A>
 returns a member of the <CODE>
FormatError </CODE>
enumerated type. If the format was successful, it will return the constant FMT_DONE (which is guaranteed to equal zero). Otherwise, it will return one of the following constants:</P>
<PRE>FMT_DRIVE_NOT_READY
FMT_ERROR_WRITING_BOOT
FMT_ERROR_WRITING_ROOT_DIR
FMT_ERROR_WRITING_FAT
FMT_ABORTED
FMT_SET_VOLUME_NAME_ERROR
FMT_CANNOT_FORMAT_FIXED_DISKS_IN_CUR_RELEASE
FMT_BAD_PARTITION_TABLE,
FMT_ERR_READING_PARTITION_TABLE,
FMT_ERR_NO_PARTITION_FOUND,
FMT_ERR_MULTIPLE_PRIMARY_PARTITIONS,
FMT_ERR_NO_EXTENDED_PARTITION_FOUND
FMT_ERR_CANNOT_ALLOC_SECTOR_BUFFER
FMT_ERR_DISK_IS_IN_USE
FMT_ERR_WRITE_PROTECTED
FMT_ERR_DRIVE_CANNOT_SUPPORT_GIVEN_FORMAT
FMT_ERR_INVALID_DRIVE_SPECIFIED
FMT_ERR_DRIVE_CANNOT_BE_FORMATTED
FMT_ERR_DISK_UNAVAILABLE</PRE>


<H5 CLASS="HeadingD">
Copying Disks</H5>
<P>
GEOS<A NAME="FileSys_5.htm_IX_DiskCopy()">
 </A>
 provides a routine for copying disks. This routine, <CODE>
DiskCopy()</CODE>
, maintains a balance between the two goals of limiting memory usage and minimizing disk swapping. It will reformat the destination disk if necessary. The routine does a sector-for-sector copy; therefore, the destination disk must either be of exactly the same type as the source disk (i.e., same medium and size), or it must be reformatable to be the same size. For this reason, neither the source nor the destination may be a fixed disk.</P>
<P>
<CODE>
DiskCopy()</CODE>
 does not interact with the user directly, even though the user may have to swap disks. Instead, it calls a callback routine whenever interaction with the user may be necessary. The routine takes the following arguments:</P>
<UL>
<LI>
The drive number of the source drive.</LI>
<LI>
The drive number of the destination drive. This may be the same as the source drive.</LI>
<LI>
The address of a Boolean callback routine. The routine must take three arguments: a member of the <CODE>
DiskCopyCallback</CODE>
 enumerated type (described below), a disk handle, and a word-sized parameter holding any other appropriate information. The routine should return non-zero to abort the copy; otherwise, it should return zero.</LI>
</UL>
<P>
<A NAME="FileSys_5.htm_IX_CALLBACK_&ldots;">
 </A>
<A NAME="FileSys_5.htm_IX_DiskCopyCallback">
 </A>
The callback routine is called under a variety of circumstances. When it is called, the first argument passed is a member of the <CODE>
DiskCopyCallback</CODE>
 enumerated type, which specifies both why the callback routine was called and what the other arguments signify. <CODE>
DiskCopyCallback</CODE>
 contains the following types:</P>
<DL>
<DT>
CALLBACK_GET_SOURCE_DISK</DT><DD>
The callback routine should prompt the user to insert the source disk. The second argument is meaningless for this call. The third argument is the number identifying the drive.</DD>
<DT>
CALLBACK_GET_DEST_DISK</DT><DD>
The callback routine should prompt the user to insert the destination disk. The second argument is meaningless for this call. The third argument is the number identifying the drive.</DD>
<DT>
CALLBACK_REPORT_NUM_SWAPS</DT><DD>
The second argument is meaningless for this call. The third argument is the number of disk swaps that will be necessary to copy the disk. The callback routine may wish to report this number to the user and ask for confirmation.</DD>
<DT>
CALLBACK_VERIFY_DEST_DESTRUCTION</DT><DD>
If the destination disk has already been formatted, the callback routine will be called with this parameter. The callback routine may wish to remind the user that the destination disk will be erased. The second argument is the handle of the destination disk; this is useful if, for example, you want to report the disk's name. The third argument is the destination drive's number. As in the other cases, the callback routine can abort the format by returning non-zero.</DD>
<DT>
CALLBACK_REPORT_FORMAT_PERCT</DT><DD>
If the destination disk needs to be formatted, <CODE>
DiskCopy()</CODE>
 will periodically call the callback routine with this parameter. In this case, the second argument will be meaningless; the third parameter will be the percentage of the destination disk which has been formatted.</DD>
<DT>
CALLBACK_REPORT_COPY_PERCT</DT><DD>
While the copy is taking place, <CODE>
DiskCopy()</CODE>
 will periodically call the callback routine with this parameter. In this case, the second parameter will be meaningless; the third parameter will be the percentage of the copy which has been completed.</DD>
</DL>
<P>
<A NAME="FileSys_5.htm_IX_DiskCopyError">
 </A>
If the copy was successful, <CODE>
DiskCopy()</CODE>
 returns zero. Otherwise, it returns a member of the <CODE>
DiskCopyError</CODE>
 enumerated type, which has the following members:</P>
<DL>
<DT>
ERR_DISKCOPY_INSUFFICIENT_MEM</DT><DD>
This is returned if the routine was unable to get adequate memory.</DD>
<DT>
ERR_CANT_COPY_FIXED_DISKS </DT>
<DT>
ERR_CANT_READ_FROM_SOURCE </DT>
<DT>
ERR_CANT_WRITE_TO_DEST </DT>
<DT>
ERR_INCOMPATIBLE_FORMATS </DT>
<DT>
ERR_OPERATION_CANCELLED</DT><DD>
This is returned if the callback routine ever returned a non-zero value, thus aborting the copy.</DD>
<DT>
ERR_CANT_FORMAT_DEST </DT>


</DL>
<HR>
<A NAME="FileSys_6.htm"></A>


<H2 CLASS="sectionTitle">
<A HREF="#index.htm">The File System</A>: 4 
Directories and Paths</H2>
<P>
Information, whether code or data, is always stored in files. However, storage volumes are not simply collections of files. Rather, they are organized into directories. There are two main reasons for this organization.</P>
<P>
First, a large storage device can easily contain hundreds or thousands of files. Computer users need to be able to find a specific file quickly. If they were confronted with a list of all the files on a storage device, they would have a hard time finding the one they want. The directory structure solves this problem; users can navigate through the directory tree until they find the file they want.</P>
<P>
The other reason for the directory structure is to expand the name-space for files. If every file on a volume were forced to have a unique name, users would find themselves severely restricted. Directories allow more flexibility; since a file is identified by both its name and its location, its name need only be unique within its directory.</P>
<P>
A file can be uniquely specified by a <EM>
full path</EM>
. A full path specifies the volume containing the file as well as all the directories containing the file, starting with the root directory. The volume specification can usually be omitted, indicating that the file is on the same volume as the current working directory. Alternatively, the file can be specified with a <EM>
relative path</EM>
. A relative path specifies the file's position relative to the current working directory, instead of starting with the root. </P>
<P>
In most implementations of DOS, there is a standard way of describing a path. These conventions are used in GEOS as well. A full path begins with a backslash, which represents the root directory. This may be followed by one or more directory specifications, separated by backslashes. The first directory listed would be a member of the root directory; each following directory would be a member of the preceding directory. A relative path is the same, except that it does not begin with a backslash. In either a full or a relative path, their are two special directory names. A single period (&quot;.&quot;) specifies the current directory; that is, the path &quot;.&quot; indicates the current working directory, and the path &quot;\GEOWORKS\DOCUMENT&quot; is the same as the paths &quot;\GEOWORKS\DOCUMENT\.&quot; and &quot;\GEOWORKS\.\DOCUMENT&quot;. A double period (&quot;..&quot;) indicates the parent of the current directory; thus, &quot;\GEOWORKS\DOCUMENT\..&quot; is equivalent to &quot;\GEOWORKS&quot;.</P>
<P>
The GEOS file management system allows each thread to have a working directory. Whenever a thread needs to open a file, it can rely on its working directory instead of passing a full path. GEOS provides an added mechanism: it defines certain system <EM>
standard paths</EM>
 which can be reached with simple system commands. These paths provide a way to standardize directory usage; an application might, for example, keep a certain data file in the standard PRIVDATA directory, leaving the user to decide where that PRIVDATA directory may be. This is covered in detail in the following section.</P>
<P CLASS="subsectionLink">
<A HREF="#FileSys_7.htm">Standard Paths</A></P>
<P CLASS="subsectionLink">
<A HREF="#FileSys_8.htm">Current Path and Directory Stack</A></P>
<P CLASS="subsectionLink">
<A HREF="#FileSys_9.htm">Creating and Deleting Directories</A></P>
<HR>
<A NAME="FileSys_7.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">The File System</A>: 4.1 <A HREF="#FileSys_6.htm">Directories and Paths</A>: 
<A NAME="FileSys_7.htm_33982">
 </A>
Standard Paths</H3>
<P>
The GEOS system is designed to run on a wide variety of architectures. For example, it can be stored on a hard disk, recorded in ROM chips, or resident on a network server and run by members of the network. This presents a difficulty. The system uses many files, storing both code (such as libraries) and data (such as fonts). It can't assume that they are in any specific place. For example, a user might be running GEOS from a network server, but she might have several fonts for personal use on her own hard disk. The system has to be able to look in all the right places. Applications have a similar dilemma. An application needs to be able to choose an appropriate place to create data files, and needs to be able to find them later.</P>
<P>
<A NAME="FileSys_7.htm_IX_Standard paths">
 </A>
The solution to this is to use <EM>
standard paths</EM>
. There are a number of standard directories GEOS uses. Each one of these has a constant associated with it. The constants are treated as special disk handles. For example, the routine <CODE>
FileSetCurrentPath()</CODE>
 (described in <A HREF="#FileSys_8.htm_33340"> Current Path and Directory Stack</A>
) takes two arguments, a disk handle and a path string. If the disk handle passed is the constant SP_DOCUMENT and the string passed is &quot;Memos&quot;, the routine will look in the standard document path for a directory called &quot;Memos&quot; and will open it.</P>
<P>
There are two advantages to standard paths. The first is that they give the system and the applications points of reference. An application does not need to worry where to write its internal data files; it can simply install them in the standard PRIVDATA directory.</P>
<P>
The second advantage is that the standard paths do not need to correspond to any one specific directory. A standard path can actually be several different DOS directories. For example, the GEOS kernel looks for font files in the standard path SP_FONT. The user may define this path to be several directories; it might comprise a local directory for the most commonly used fonts, a network directory for some decorative fonts, etc. The file system would automatically locate all of these fonts. Similarly, the SP_DOCUMENT directory might comprise a directory on a ROM disk for read-only files, as well as a directory on a hard disk where files are written. A standard path is considered &quot;read-only&quot; if and only if all of the directories which make up the standard path are read-only. When you create a file directly in a standard path (as opposed to in a subdirectory of a standard path), the file system will write it to the directory on the disk containing the <STRONG CLASS="fileName">
geos.ini</STRONG>
 file.</P>
<P>
The standard paths have a default hierarchy. For example, the standard path SP_VIDEO_DRIVERS usually refers to a directory named VIDEO which belongs to the standard path SP_SYSTEM. However, the user is allowed to define each standard path however he or she wishes. For this reason, the programmer may not make any assumptions about where each standard path is located.</P>
<P>
<A NAME="FileSys_7.htm_IX_SP_&ldots;">
 </A>
<A NAME="FileSys_7.htm_IX_StandardPath">
 </A>
Below is a list of standard paths currently implemented. The paths are described as if they were single directories; remember, however, that each one of these may comprise several directories. Each path is accompanied by notes on how it is used and where it might commonly be found. The user can decide where each of these directories is, so make no assumptions about their locations. These paths will always be supported; future versions of GEOS may add new paths.</P>
<DL>
<DT>
SP_TOP</DT><DD>The top level directory. This is the directory which contains GEOS.INI. This is often C:\GEOWORKS.</DD>
<DT>
SP_APPLICATION</DT><DD>
All non-system applications are in this directory or a directory belonging to it. This is often a WORLD directory under SP_TOP.</DD>
<DT>
SP_DOCUMENT</DT><DD>
All document files should go here. This is commonly a DOCUMENT directory under SP_TOP.</DD>
<DT>
SP_SYSTEM</DT><DD>All libraries and drivers belong to this directory. All libraries must go in this directory, not in a subdirectory. Drivers are further grouped into subdirectories, one for each type of driver. This is commonly a SYSTEM directory under SP_TOP. Geodes should never need to directly access this directory, other than for installing drivers to it.</DD>
<DT>
SP_PRIVATE_DATA</DT><DD>
This contains data files which should not be accessed by users. By convention, each geode creates a subdirectory with its own data files. For example, the application HELLO.GEO would use a directory called HELLO in SP_PRIVATE_DATA. This is commonly a PRIVDATA directory under SP_TOP.</DD>
<DT>
SP_DOS_ROOM</DT><DD>
This directory contains the DOS-room launchers. It is commonly a DOSROOM directory under SP_TOP.</DD>
<DT>
SP_STATE</DT><DD>This directory contains all state files. It is commonly a STATE directory under PRIVDATA.</DD>
<DT>
SP_USER_DATA</DT><DD>
This directory holds data files that the user may add to, delete, upgrade, or otherwise change. Each data file type should have its own subdirectory. This is commonly a USERDATA directory under SP_TOP.</DD>
<DT>
SP_FONT</DT><DD>This directory contains all font data files, no matter what format they are. It is often USERDATA\FONT.</DD>
<DT>
SP_SPOOL</DT><DD>This directory contains all application spooler files. It is commonly USERDATA\SPOOL.</DD>
<DT>
SP_SYS_APPLICATION</DT><DD>
This directory contains all system applications. For example, it contains the Geoworks Pro &quot;Welcome&quot; application. These applications should not be launched by the user from the desktop. This directory is commonly SYSTEM\SYSAPPL.</DD>
<DT>
SP_MOUSE_DRIVERS</DT><DD>
<A NAME="FileSys_7.htm_IX_Drivers:standard paths">
 </A>
<A NAME="FileSys_7.htm_IX_Mouse:driver standard path">
 </A>
This directory contains all mouse drivers. It is commonly SYSTEM\MOUSE.</DD>
<DT>
SP_PRINTER_DRIVERS</DT><DD>
<A NAME="FileSys_7.htm_IX_Printing:drivers standard path">
 </A>
This contains all printer drivers. It is commonly SYSTEM\PRINTER.</DD>
<DT>
SP_FILE_SYSTEM_DRIVERS</DT><DD>
<A NAME="FileSys_7.htm_IX_File system:driver standard path">
 </A>
This directory contains drivers for file systems. It has both DOS and network drivers. It is commonly SYSTEM\FS.</DD>
<DT>
SP_VIDEO_DRIVERS</DT><DD>
<A NAME="FileSys_7.htm_IX_Video drivers:standard path">
 </A>
This directory contains video drivers. It is commonly SYSTEM\VIDEO.</DD>
<DT>
SP_SWAP_DRIVERS</DT><DD>
<A NAME="FileSys_7.htm_IX_Swap drivers:standard path">
 </A>
This directory has all of the swap drivers. It is commonly SYSTEM\SWAP.</DD>
<DT>
SP_KEYBOARD_DRIVERS</DT><DD>
<A NAME="FileSys_7.htm_IX_Keyboard drivers:standard path">
 </A>
This directory has all of the keyboard drivers. It is commonly SYSTEM\KEYBOARD.</DD>
<DT>
SP_FONT_DRIVERS</DT><DD>
<A NAME="FileSys_7.htm_IX_Fonts:driver standard path">
 </A>
This directory has all of the font drivers. It is commonly SYSTEM\FONT.</DD>
<DT>
SP_IMPORT_EXPORT_DRIVERS</DT><DD>
<A NAME="FileSys_7.htm_IX_impex library:drivers standard path">
 </A>
This directory has all of the import/export libraries. It is commonly SYSTEM\IMPEX.</DD>
<DT>
SP_TASK_SWITCH_DRIVERS</DT><DD>
<A NAME="FileSys_7.htm_IX_Task switch drivers:standard path">
 </A>
This directory contains all task-switching drivers. It is commonly SYSTEM\TASK.</DD>
<DT>
SP_HELP_FILES</DT><DD>
This directory contains all help files. It is commonly USERDATA\HELP.</DD>
<DT>
SP_TEMPLATE</DT><DD>
This directory contains document templates. It is commonly DOCUMENT\TEMPLATE.</DD>
<DT>
SP_POWER_DRIVERS</DT><DD>
<A NAME="FileSys_7.htm_IX_Power management:drivers standard path">
 </A>
This directory contains power-management drivers. It is commonly SYSTEM\POWER.</DD>
<DT>
SP_HWR</DT><DD><A NAME="FileSys_7.htm_IX_Handwriting Recognition:library standard path">
 </A>
This directory contains the handwriting recognition libraries. It is commonly SYSTEM\HWR.</DD>
<DT>
SP_WASTE_BASKET</DT><DD>
This directory contains files that have been dragged to the waste basket but have not yet been thrown out. All non-open files and directories in this path are periodically deleted. Temporary files should usually be created here; they will not be deleted until after they have been closed. This directory is commonly PRIVDATA\WASTE.</DD>
<DT>
SP_BACKUP</DT><DD>This directory contains backup files made by the document control. It is commonly \PRIVDATA\BACKUP.</DD>
</DL>
<HR>
<A NAME="FileSys_8.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">The File System</A>: 4.2 <A HREF="#FileSys_6.htm">Directories and Paths</A>: 
<A NAME="FileSys_8.htm_33340">
 </A>
Current Path and Directory Stack</H3>
<PRE>FileSetCurrentPath(), FileGetCurrentPath(), FileConstructFullPath(), FileParseStandardPath(), FileResolveStandardPath(), FilePushDir(), FilePopDir(), FileResolveStandardPathFlags</PRE>
<P>
Every thread has a <EM>
current path</EM>
. When the thread opens a file, it can pass just the name of the file; the file system combines this name with the current path to find the file. The path is a combination of a disk handle and a directory sequence. To set the thread's current path, call the routine <CODE>
FileSetCurrentPath()</CODE>
<A NAME="FileSys_8.htm_IX_FileSetCurrentPath()">
 </A>
, which takes two arguments: a disk handle and a pointer to a null-terminated string. The string should contain a sequence of directories specified in the normal DOS convention. To change to a standard path, pass the path constant as the disk handle and a null string (i.e. a pointer to a null byte). To change to a subdirectory of a standard path, pass the path constant as the disk handle and a pointer to a relative or absolute path specification; for example, to change to the HELLO directory in PRIVDATA, pass the disk handle constant SP_PRIVATE_DATA and a pointer to the string &quot;HELLO&quot;. <CODE>
FileSetCurrentPath()</CODE>
 returns the handle of the disk. If you change to a standard path, it returns the path constant; if you change to a directory within a standard path, it returns the constant of the closest standard path. In the event of error, it returns a null handle and sets the thread's error value. The error most commonly returned is ERROR_PATH_NOT_FOUND, indicating that the specified directory could not be found or does not exist. <A NAME="FileSys_8.htm_IX_FileSetStandardPath()">
 </A>
To set the current path equal to a standard path, use the <CODE>
FileSetStandardPath()</CODE>
 routine.</P>
<P>
<A NAME="FileSys_8.htm_IX_FileGetCurrentPath()">
 </A>
To find out the current path, call the routine <CODE>
FileGetCurrentPath()</CODE>
. This routine takes two arguments: the address of a character buffer and the size of the buffer. It returns the handle of the current path's disk and writes the path (without drive specifier) to the buffer, truncating the path if the buffer is too small. If the directory is a standard path or a subdirectory of one, <CODE>
FileGetCurrentPath()</CODE>
 will return the disk-handle constant for that path and will write an absolute path to the buffer. <A NAME="FileSys_8.htm_IX_FileConstructFullPath()">
 </A>
If you want a full path, use <CODE>
FileConstructFullPath()</CODE>
, described below.</P>
<P>
To translate a standard path into a full path, call <CODE>
FileConstructFullPath()</CODE>
, which takes five arguments:</P>
<UL>
<LI>
A Boolean value indicating whether the drive name should be prepended to the path string returned. </LI>
<LI>
The handle of a disk. A null argument indicates that the path string passed is relative to the current working directory. The handle may be a standard path constant, indicating that the path string passed is relative to that standard path.</LI>
<LI>
A pointer to a string containing a path relative to the location indicated by the previous argument. This may be an empty string.</LI>
<LI>
A pointer to a pointer to a character buffer. The path will be written to this buffer. The routine will update this to be a pointer to a pointer to the null terminator.</LI>
<LI>
The length of that buffer.</LI>
</UL>
<P>
The routine writes the full path to the buffer and returns the disk handle. If it is unable to construct a full path, it returns a null handle. The pointer to the path buffer will have been changed to point to the end of the string; you may want to keep a copy of the old value of the pointer around when using this routine.</P>
<P>
<A NAME="FileSys_8.htm_IX_FileParseStandardPath()">
 </A>
To find the standard path to a given location, call the routine <CODE>
FileParseStandardPath()</CODE>
. This routine is passed two arguments:</P>
<UL>
<LI>
The handle of the disk. Passing a null disk handle indicates that the path string contains a drive specifier.</LI>
<LI>
A pointer to a pointer to a path string. This path should begin at the root of the disk specified.</LI>
</UL>
<P>
<CODE>
FileParseStandardPath()</CODE>
 returns the standard path constant. It also updates the pointer to point to the remaining portion of the path. For example, if you pass a pointer to a pointer to the string &quot;\GEOWORKS\DOCUMENT\MEMOS\APRIL&quot;, the pointer would be updated to point to the &quot;\MEMOS\APRIL&quot; portion, and the handle SP_DOCUMENT would be returned. If the path passed does not belong to a standard path, the constant SP_NOT_STANDARD_PATH will be returned, and the pointers will not be changed.</P>
<P>
<A NAME="FileSys_8.htm_IX_FileResolveStandardPath()">
 </A>
Because each standard path is made up of one or more directories (possibly on different devices), it can be hard to know just where a file is. For that reason, GEOS provides <CODE>
FileResolveStandardPath()</CODE>
. This routine is passed a relative path to a file; it then constructs the full path of the file, starting from the root of the disk (<EM>
not</EM>
 from a standard path); it also returns the handle of the actual disk containing the file. <CODE>
FileResolveStandardPath()</CODE>
 is passed several arguments:</P>
<UL>
<LI>
A pointer to a pointer to a character buffer. The full path will be written to that buffer, and the pointer will be updated to point to the null terminator.</LI>
<LI>
The length of the buffer, in bytes.</LI>
<LI>
A pointer to a relative path string. This path is relative to the current working directory, which is usually a standard path.</LI>
<LI>
A set of <CODE>
FileResolveStandardPathFlags</CODE>.</LI>
<LI>A pointer to an empty <CODE>FileAttrs</CODE> buffer; the routine will 
fill in this buffer with the passed file's attributes, if any.</LI>
</UL>
<P>
<CODE>
FileResolveStandardPath()</CODE>
 writes the full, absolute path to the buffer specified. It also returns the handle of the disk containing that file. If it cannot find the file specified, it returns a null handle.<A NAME="FileSys_8.htm_IX_FRSPF_&ldots;">
 </A>
<A NAME="FileSys_8.htm_IX_FileResolveStandardPathFlags">
 </A>
 There are two <CODE>
FileResolveStandardPathFlags</CODE>
 available:</P>
<DL>
<DT>
FRSPF_ADD_DRIVE_NAME</DT><DD>
The path string written to the buffer should begin with the drive name (e.g., &quot;C:\GEOWORKS\DOCUMENT\MEMOS&quot;).</DD>
<DT>
FRSPF_RETURN_FIRST_DIR</DT><DD>
<CODE>
FileResolveStandardPath()</CODE>
 should not check whether the passed path actually exists; instead, it should assume that the path exists in the first directory comprising the standard path, and return accordingly.</DD>
</DL>
<P>
<A NAME="FileSys_8.htm_IX_Directory stack">
 </A>
In addition to having a current path, every thread has a <EM>
directory stack</EM>
. The stack is used for switching paths quickly. <A NAME="FileSys_8.htm_IX_FilePushDir()">
 </A>
You can at any time push the current path onto the stack by calling <CODE>
FilePushDir()</CODE>
. This routine pushes the directory on the directory stack and returns nothing. <A NAME="FileSys_8.htm_IX_FilePopDir()">
 </A>
You can change the current path to the one on top of the directory stack by calling <CODE>
FilePopDir()</CODE>
. This pops the top directory off the stack and makes it the current path. (If the directory stack is empty, the result is undefined.) These routines are very useful when you write subroutines which may need to change the current working directory; they can push the old directory at the start of the routine and pop it at the end.</P>
<P>
Files are often specified &quot;by their paths.&quot; This simply means specifying them with a string containing the directory path and ending with the file name. This path may be either relative or absolute. </P>
<HR>
<A NAME="FileSys_9.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">The File System</A>: 4.3 <A HREF="#FileSys_6.htm">Directories and Paths</A>: 
<A NAME="FileSys_9.htm_19109">
 </A>
Creating and Deleting Directories</H3>
<PRE>FileCreateDir(), FileDeleteDir()</PRE>
<P>
<A NAME="FileSys_9.htm_IX_FileCreateDir()">
 </A>
You can create directories with <CODE>
FileCreateDir()</CODE>
. The routine takes a single argument, namely the address of a character string. If the string is simply a directory name, it will attempt to create that directory at the current location. If the string is a relative path, it will create the directory at the end of the path, if possible. For example, passing the string &quot;Memos\September&quot; will cause it to check if there is a directory called &quot;Memos&quot; at the current location. If there is, it will create the directory &quot;September&quot; inside the directory &quot;Memos&quot;. If the string is an absolute path (i.e. there is a backslash before the first directory name), it will behave the same way, but it will start with the root directory. The routine returns zero if it was successful. If it was unsuccessful, it will return one of the following error codes:</P>
<DL>
<DT>
ERROR_INVALID_NAME</DT><DD>
The name passed was inappropriate for directories on that device.</DD>
<DT>
ERROR_PATH_TOO_LONG</DT><DD>
The path string was longer than is permitted by the file system for that device.</DD>
<DT>
ERROR_FILE_EXISTS</DT><DD>
A file or directory with the specified name already exists at the specified location.</DD>
<DT>
ERROR_PATH_NOT_FOUND</DT><DD>
The path string was in some way invalid; for example, it might have instructed <CODE>
FileCreateDir()</CODE>
 to create the directory inside of a directory which does not exist.</DD>
<DT>
ERROR_ACCESS_DENIED</DT><DD>
The thread is not able to create directories in the specified location.</DD>
<DT>
ERROR_DISK_STALE	</DT><DD>
The drive that disk was on has been removed.</DD>
<DT>
ERROR_DISK_UNAVAILABLE</DT><DD>
The validation of the disk in that drive was aborted by the user.</DD>
<DT>
ERROR_WRITE_PROTECTED</DT><DD>
The volume is write-protected.</DD>
</DL>
<P>
Note that the directory name can be any acceptable GEOS file name; that is, it may be up to 32 characters long and can contain any characters other than backslashes, colons, asterisks, or question marks. For further information about GEOS file names, see <A HREF="#FileSys_b.htm_43815"> DOS Files and GEOS Files</A>
.</P>
<P>
<A NAME="FileSys_9.htm_IX_FileDeleteDir()">
 </A>
You can delete directories with <CODE>
FileDeleteDir()</CODE>
. This routine takes a single argument, namely the address of a character string. This string can specify a relative or absolute path, as with <CODE>
FileCreateDir()</CODE>
. It attempts to delete the directory specified. (Note that you are not allowed to delete your current directory or a non-empty directory.) If it successfully removes the directory, it returns zero. Otherwise, it returns one of the following members of the <CODE>
FileError</CODE>
 type:</P>
<DL>
<DT>
ERROR_PATH_NOT_FOUND</DT><DD>
The directory specified could not be found or does not exist.</DD>
<DT>
ERROR_IS_CURRENT_DIRECTORY</DT><DD>
This directory is some thread's current directory, or else it is on some thread's directory stack. Note that you cannot delete your own working directory.</DD>
<DT>
ERROR_ACCESS_DENIED</DT><DD>
The calling thread does not have permission to delete the directory. This is also returned if the directory was on a read-only device.</DD>
<DT>
ERROR_DIRECTORY_NOT_EMPTY</DT><DD>
The directory specified is not empty. Delete all the files before you attempt to delete the directory.</DD>
<DT>
ERROR_DISK_STALE	</DT><DD>
The drive that disk was on has been removed.</DD>
<DT>
ERROR_DISK_UNAVAILABLE</DT><DD>
The validation of the disk in that drive was aborted by the user.</DD>
</DL>
<HR>
<A NAME="FileSys_a.htm"></A>


<H2 CLASS="sectionTitle">
<A HREF="#index.htm">The File System</A>: 5 
Files</H2>
<P>
When data is not actually in a computer's memory, it needs to be grouped together in a manageable form. Most storage devices group data together into <EM>
files</EM>
. A file is a collection of information. It may be a program, either in machine language or in a higher-level language (as with batch files); or it may be data.</P>
<P>
When an application is accessing a data file, it is said to have that file <EM>
open</EM>
. It may be open for read and write access, just for reading, or just for writing. If a file is open, it can not be moved or deleted (although it can be copied).</P>
<P>
You will probably not have to read all of this section. <A HREF="#FileSys_10.htm_48613"> Bytewise File Operations</A>
 (<A HREF="#FileSys_10.htm_48613"> Bytewise File Operations</A>
) is important only if you will be using DOS files or GEOS byte files. Most applications will work with GEOS <EM>
Virtual Memory</EM>
 (VM) files.</P>
<P CLASS="subsectionLink">
<A HREF="#FileSys_b.htm">DOS Files and GEOS Files</A></P>
<P CLASS="subsectionLink">
<A HREF="#FileSys_c.htm">Files and File Handles</A></P>
<P CLASS="subsectionLink">
<A HREF="#FileSys_d.htm">GEOS Extended Attributes</A></P>
<P CLASS="subsectionLink">
<A HREF="#FileSys_e.htm">File Utilities</A></P>
<P CLASS="subsectionLink">
<A HREF="#FileSys_f.htm">FileEnum()</A></P>
<P CLASS="subsectionLink">
<A HREF="#FileSys_10.htm">Bytewise File Operations</A></P>
<HR>
<A NAME="FileSys_b.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">The File System</A>: 5.1 <A HREF="#FileSys_a.htm">Files</A>: 
<A NAME="FileSys_b.htm_43815">
 </A>
DOS Files and GEOS Files</H3>
<P>
Most file systems have a simple convention of what a file is. Applications treat files as if they were a sequence of bytes. They can read the bytes in order from the file, copying a sequence of bytes into memory. They have a &quot;position&quot; in the file, indicating the next byte to be read. An application can copy data from memory to a file, replacing the data there.</P>
<P>
GEOS allows geodes to access any type of DOS file using the normal DOS conventions. However, it also provides its own file format, the GEOS file. GEOS files are stored on the disk as normal DOS files. This means that they can be copied from one disk to another by any normal DOS procedure; they can be uploaded or downloaded, compressed, archived, or transferred to different devices exactly as if they were ordinary DOS files. Nevertheless, when a system is running GEOS, the files have added functionality. GEOS data files have special <EM>
extended attributes</EM>
, which keep track of such things as the file's tokens, protocol numbers, etc. For more information about extended attributes, see <A HREF="#FileSys_d.htm_49785"> GEOS Extended Attributes</A>
.</P>
<P>
Most GEOS data files are <EM>
Virtual Memory</EM>
 files. VM files can automatically back up data; they allow their users to insert data at any point in the file, and when the file's user needs access to data the VM manager automatically allocates memory and swaps the data into it. These files are created and accessed using special VM routines; for more information, see <A HREF="../../Memory/VM/combo.htm">the VM chapter</A>. Note that you can have a GEOS file hold raw data instead of having VM capability. Such a file is known as a &quot;byte&quot; file since it is treated as a sequence of bytes with no structure except what is specifically added by the file's creator. All of the routines for working with DOS files can be used with GEOS byte files.</P><P>
One basic difference between GEOS files and DOS files is in naming conventions. Each file system and disk-operating system has its own convention for how files may be named. By far, the most common convention is the one used by MS-DOS: each file is identified by a name of up to eight characters, followed by an optional extension of up to three characters. There are further restrictions on which characters may be part of a name; for example, none of the characters may be a period.</P>
<P>
GEOS provides more versatility. Each file has two different names. It has a <EM>
native</EM>
 name; this is the name used by the device holding the file and must meet all of its restrictions. For example, if the file is kept on a usual DOS-compatible disk, the native name would be in the FILENAME.EXT format. The other name is the <EM>
virtual</EM>
 file name. This may contain a number of characters equal to FILE_LONGNAME_LENGTH and may contain any characters other than backslashes (&quot;\&quot;), colons (&quot;:&quot;), asterisks (&quot;*&quot;), and question marks (&quot;?&quot;). Any time a file's name is needed, either the virtual or the native file name may be used. When a file is created, GEOS automatically maps its virtual name into an appropriate native name.</P>
<P>
Special GEOS information, such as the file's virtual name and extended attributes, is stored in the body of the file itself. Thus, while applications should not access this information directly, they can still be assured that it will be preserved when the file is copied by any normal DOS techniques. This information is stored in a special header which is transparent to geodes. If you use one of the bytewise file operations, you will not be able to affect the header.</P>
<HR>
<A NAME="FileSys_c.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">The File System</A>: 5.2 <A HREF="#FileSys_a.htm">Files</A>: 
<A NAME="FileSys_c.htm_70676">
 </A>
Files and File Handles</H3>
<PRE>FileDuplicateHandle()</PRE>
<P>
In order to read or change a file, you must <EM>
open</EM>
 it with an appropriate routine. When you open a file, the file system sees to it that the file will not be erased or moved until you close it. When a geode exits, all files it has open are automatically closed. When GEOS exits, all files are closed. If an application restarts from a saved state, it will have to reopen all files.</P>
<P>
When you open a file, the GEOS file system returns a <EM>
file handle</EM>
. This is a global handle associated with that file. Whenever you need to perform an action on a file you have opened, you specify the file by passing its handle. Note that there may be several handles which all refer to the same file. If more than one thread will need to use the same handle, they may synchronize their access by using <CODE>
HandleP()</CODE>
 and <CODE>
HandleV()</CODE>
; for details, see <A HREF="../../Memory/Heap/Memory_b.htm#68631">the Memory Management chapter</A>. The Virtual Memory routines include data-access synchronization routines for use with VM files; for details, see <A HREF="../../Memory/VM/combo.htm">the VM chapter</A>.</P><P>
<A NAME="FileSys_c.htm_IX_FileDuplicateHandle()">
 </A>
It is sometimes useful to have two different handles which indicate the same file. GEOS provides the routine <CODE>
FileDuplicateHandle()</CODE>
. This routine takes one argument, namely the handle of an open file. It creates and returns another handle which indicates the same file. You will have to close both handles to close the file. <CODE>
FileDuplicateHandle()</CODE>
 works on any type of file handle; that is, it can be used on the handles of DOS files, GEOS byte files, or VM files. Note that the duplicate handle will have the same read/write position as the original.</P>
<HR>
<A NAME="FileSys_d.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">The File System</A>: 5.3 <A HREF="#FileSys_a.htm">Files</A>: 
<A NAME="FileSys_d.htm_49785">
 </A>
GEOS Extended Attributes</H3>
<PRE>FileGetHandleExtAttributes(), FileGetPathExtAttributes(), FileSetHandleExtAttributes(), FileSetPathExtAttributes(), FileExtAttrDesc, FileDateAndTime, FileAttrs</PRE>
<P>
All GEOS files, whether they contain code or data, have special <EM>
extended attributes</EM>
. Geodes cannot look at these directly; instead, they make calls to the file system when they want to examine or change the attributes. There are many different extended attributes; however, they are all accessed and changed in a uniform way. Some of the extended attributes are also supported for non-GEOS files. The following extended attributes are currently available:</P>
<PRE>FEA_MODIFICATION
FEA_FILE_ATTR
FEA_SIZE
FEA_FILE_TYPE
FEA_FLAGS
FEA_RELEASE
FEA_PROTOCOL
FEA_TOKEN
FEA_CREATOR
FEA_USER_NOTES
FEA_NOTICE
FEA_CREATION
FEA_PASSWORD
FEA_CUSTOM
FEA_NAME
FEA_GEODE_ATTR
FEA_PATH_INFO
FEA_FILE_ID
FEA_DESKTOP_INFO
FEA_DRIVE_STATUS
FEA_DISK
FEA_DOS_NAME
FEA_OWNER
FEA_RIGHTS</PRE>
<P>
There are also two special constants, FEA_MULTIPLE and FEA_END_OF_LIST. These are also described below.</P>
<P>
<A NAME="FileSys_d.htm_IX_FileGetHandleExtAttributes()">
 </A>
There are two different routines to read a file's extended attributes: <CODE>
FileGetHandleExtAttributes()</CODE>
 and <CODE>
FileGetPathExtAttributes()</CODE>
. These routines are the same except in the way the file is specified: in one, the handle of an open file is passed, whereas in the other, the address of a path string is passed.</P>
<P>
<CODE>
FileGetHandleExtAttributes()</CODE>
 takes four arguments. The first is the handle of the file whose attributes are desired; this may be a VM file handle or a byte-file handle. The second is a constant specifying the attribute desired. All extended attributes which are currently supported are listed above; more may be added later. The third is a pointer to a buffer; the attribute's value will be written into that buffer. The fourth argument is the size of the buffer (in bytes). Before it returns, <CODE>
FileGetHandleExtAttributes()</CODE>
 will write the value of the attribute into the buffer. If successful, it will return zero; otherwise, it will return one of the following error codes:</P>
<DL>
<DT>
ERROR_ATTR_NOT_SUPPORTED</DT><DD>
The file system does not recognize the attribute constant passed.</DD>
<DT>
ERROR_ATTR_SIZE_MISMATCH</DT><DD>
The buffer passed was too small for the attribute requested.</DD>
<DT>
ERROR_ATTR_NOT_FOUND</DT><DD>
The file does not have a value set for that attribute. This is returned if you try to get certain extended attributes of a non-GEOS file.</DD>
<DT>
ERROR_ACCESS_DENIED</DT><DD>
You do not have read-access to the file.</DD>
</DL>
<P>
<CODE>
FileGetHandleExtAttrs()</CODE>
 can also fetch several attributes at once. For details on this, see the section on FEA_MULTIPLE (<A HREF="#FileSys_d.htm_40864"> FEA_MULTIPLE</A>
).</P>
<P>
<A NAME="FileSys_d.htm_IX_FileGetPathExtAttributes()">
 </A>
You can get a file's extended attributes without having it open by calling <CODE>
FileGetPathExtAttributes()</CODE>
. This routine takes a pointer to a null-terminated path string instead of a file handle. This makes it suitable for examining the attributes of an executable file or directory. Note that the file system will still have to open the file in order to get the attributes. If any geode (including the caller) has the file open with &quot;deny-read&quot; exclusive, the call will fail with error condition ERROR_ACCESS_DENIED. If it could not find the file specified, it will return ERROR_FILE_NOT_FOUND.</P>
<P>
<A NAME="FileSys_d.htm_IX_FileSetHandleExtAttributes()">
 </A>
To change one of a file's extended attributes, make a call either to <CODE>
FileSetHandleExtAttributes()</CODE>
 or<A NAME="FileSys_d.htm_IX_FileSetPathExtAttributes()">
 </A>
 to <CODE>
FileSetPathExtAttributes</CODE>
(). These routines take the same arguments as the <CODE>
FileGet...()</CODE>
 routines above; however, they copy the data from the buffer into the attribute, instead of vice versa. These routines return zero if the operation was successful. Otherwise, they return one of the following error codes:</P>
<DL>
<DT>
ERROR_ATTR_NOT_SUPPORTED</DT><DD>
The file system does not recognize the attribute constant passed. This is returned if you try to set an extended attribute for a non-GEOS file.</DD>
<DT>
ERROR_ATTR_SIZE_MISMATCH</DT><DD>
The buffer passed was the wrong size for the attribute specified.</DD>
<DT>
ERROR_ACCESS_DENIED</DT><DD>
<CODE>
FileSetHandleExtAttributes()</CODE>
 returns this if the caller does not have write-access to the file. <CODE>
FileSetPathExtAttributes()</CODE>
 returns this if any geode (including the caller) has the file open with &quot;deny-write&quot; exclusive access, or if the file is not writable.</DD>
<DT>
ERROR_CANNOT_BE_SET</DT><DD>
The extended attribute cannot be changed. Such attributes as FEA_SIZE and FEA_NAME cannot be changed with the <CODE>
FileSet...()</CODE>
 routines.</DD>

</DL>
<H5 CLASS="HeadingD">
<A NAME="FileSys_d.htm_40864">
 </A>
FEA_MULTIPLE</H5>
<P>
<A NAME="FileSys_d.htm_IX_FEA_MULTIPLE">
 </A>
By passing this extended attribute, you can get or set several extended attributes at once. This is also the only way to get, set, or create a custom attribute. If you pass this, the other arguments are slightly different. The first argument is still the file specifier (handle or path), and the second argument is FEA_MULTIPLE. <A NAME="FileSys_d.htm_IX_FEAD_&ldots;">
 </A>
<A NAME="FileSys_d.htm_IX_FileExtAttrDesc">
 </A>
However, the third argument is the base address of an array of <CODE>
FileExtAttrDesc</CODE>
 structures, and the fourth argument is the number of these structures in the array. The array has one element for each attribute you wish to get or set. Each <CODE>
FileExtAttrDesc</CODE>
 structure has the following fields:</P>
<DL>
<DT>
<CODE>
FEAD_attr</CODE>
</DT><DD>This is the numerical constant for the attribute to be read or set. If a custom attribute is being set, this should be FEA_CUSTOM.</DD>
<DT>
<CODE>
FEAD_value</DT><DD></CODE>
If the attribute is being set, this is the address of the new value. If the attribute is being read, this is the address of the buffer into which to copy the value.</DD>
<DT>
<CODE>
FEAD_size</CODE>
</DT><DD>This is the size of the buffer or value pointed to by <CODE>
FEAD_value</CODE>
.</DD>
<DT>
<CODE>
FEAD_name</DT><DD></CODE>
If <CODE>
FEAD_attr</CODE>
 is set to FEA_CUSTOM, this is the address of a null-terminated string containing the custom attribute's name. If <CODE>
FEAD_attr</CODE>
 is set to anything else, this field is ignored.</DD>


</DL>
<H5 CLASS="HeadingD">
FEA_CUSTOM</H5>
<P>
<A NAME="FileSys_d.htm_IX_FEA_CUSTOM">
 </A>
In addition to the system-defined extended attributes, any GEOS file may have any number of custom attributes. Each custom attribute is named by a null-terminated ASCII string. To create a custom attribute, call one of the <CODE>
FileSet...()</CODE>
 routines, specifying the new attribute with a <CODE>
FileExtAttrDesc</CODE>
 structure (as described immediately above). If you try to read a custom attribute which has not been defined for that file, the routine will fail with error condition ERROR_ATTR_NOT_FOUND.</P>
<P>
Note that not all file systems support the use of custom extended attributes; therefore, you should write your applications so they can perform correctly without using them.</P>


<H5 CLASS="HeadingD">
<A NAME="FileSys_d.htm_38588">
 </A>
FEA_MODIFICATION</H5>
<P>
<A NAME="FileSys_d.htm_IX_FEA_MODIFICATION">
 </A>
Every file has a &quot;last modified&quot; time. This is automatically updated whenever the file is written to. <A NAME="FileSys_d.htm_IX_FileDateAndTime">
 </A>
<A NAME="FileSys_d.htm_IX_FDAT_&ldots;">
 </A>
To find the modification time of a file, get the extended attribute FEA_MODIFICATION. The modification time is returned as a 32-bit <CODE>
FileDateAndTime</CODE>
 value. The value has the following fields, each of which is small enough to fit in a signed-byte variable:</P>
<DL>
<DT>
FDAT_YEAR</DT><DD>This field records the year, counting from a base year of 1980. (The constant FDAT_BASE_YEAR is defined as 1980.) This field is at an offset of FDAT_YEAR_OFFSET bits from the low end of the value.</DD>
<DT>
FDAT_MONTH</DT><DD>
This field records the month as an integer, with January being one. It is located at an offset of FDAT_MONTH_OFFSET.</DD>
<DT>
FDAT_DAY</DT><DD>This field records the day of the month. It is located at an offset of FDAT_DAY_OFFSET.</DD>
<DT>
FDAT_HOUR</DT><DD>This field records the hour on a 24-hour clock, with zero being the hour after midnight. It is located at an offset of FDAT_HOUR_OFFSET.</DD>
<DT>
FDAT_MINUTE</DT><DD>
This field records the minute. It is located at an offset of FDAT_MINUTE_OFFSET.</DD>
<DT>
FDAT_2SECOND</DT><DD>
This field records the second, divided by two; that is, a field value of 15 indicates the 30th second. (It is represented this way to let the second fit into 5 bits, thus letting the entire value fit into 32 bits.) It is located at an offset of FDAT_2SECOND_OFFSET.</DD>
</DL>
<P>
<A NAME="FileSys_d.htm_IX_FDATExtract&ldots; () macros">
 </A>
The macros <CODE>
FDATExtractYear()</CODE>
, <CODE>
...Month()</CODE>
, <CODE>
...Day()</CODE>
, <CODE>
...Hour()</CODE>
, <CODE>
...Minute()</CODE>
, and <CODE>
...2Second()</CODE>
 all extract the specified field from a <CODE>
FileDateAndTime</CODE>
 value. The macro <CODE>
FDATExtractSecond()</CODE>
 extracts the FDAT_2SECOND field and doubles it before returning it. The <CODE>
FDATExtractYearAD()</CODE>
 extracts the year field and adds the base year, thus producing a word-sized year value.</P>


<H5 CLASS="HeadingD">
<A NAME="FileSys_d.htm_66195">
 </A>
FEA_FILE_ATTR</H5>
<P>
<A NAME="FileSys_d.htm_IX_FEA_FILE_ATTR">
 </A>
There are certain attributes which all files have. These attributes specify such things as whether the file is hidden, whether it is read-only, and several other things. To get these attributes, call an extended attribute routine with argument FEA_FILE_ATTRIBUTES. <A NAME="FileSys_d.htm_IX_FA_&ldots;">
 </A>
<A NAME="FileSys_d.htm_IX_FileAttrs">
 </A>
The attributes are passed or returned in a <CODE>
FileAttrs</CODE>
 record. This record has the following fields:</P>
<DL>
<DT>
FA_ARCHIVE</DT><DD>
This flag is set if the file requires backup. Backup programs typically clear this flag.</DD>
<DT>
FA_SUBDIR</DT><DD>This flag is set if the &quot;file&quot; is actually a directory. Geodes may not change this flag.</DD>
<DT>
FA_VOLUME</DT><DD>
This flag is set if the &quot;file&quot; is actually the volume label. This flag will be <EM>
off</EM>
 for all files a geode will ever see. Geodes may not change this flag.</DD>
<DT>
FA_SYSTEM</DT><DD>This flag is set if the file is a system file. Geodes should not change this flag.</DD>
<DT>
FA_HIDDEN</DT><DD>This flag is set if the file is hidden from normal directory searches. For example, a GenFileSelector, by default, does not list files that have this flag set.</DD>
<DT>
FA_RDONLY</DT><DD>This flag is set if the file is read-only.</DD>
</DL>
<P>
Many file systems (including DOS) require that files be closed when you set these attributes. For that reason, you cannot change these attributes with <CODE>
FileSetHandleExtAttributes()</CODE>
. You must use either <CODE>
FileSetPathExtAttributes()</CODE>
 or <CODE>
FileSetAttributes()</CODE>
 (described below in <A HREF="#FileSys_10.htm_88250"> Getting and Setting Information about a Byte File</A>
). If you try to set this field with <CODE>
FileSetHandleExtAttributes()</CODE>
, you will be returned ERROR_ATTR_CANNOT_BE_SET.</P>


<H5 CLASS="HeadingD">
FEA_SIZE</H5>
<P>
<A NAME="FileSys_d.htm_IX_FEA_SIZE">
 </A>
This attribute is simply the size of the file in bytes. It is dword-sized 
(allowing for files as large as 4096 megabytes). The attribute can be read, but not directly changed.</P>


<H5 CLASS="HeadingD">
FEA_FILE_TYPE</H5>
<P>
<A NAME="FileSys_d.htm_IX_GFT_&ldots;">
 </A>
<A NAME="FileSys_d.htm_IX_GeosFileType">
 </A>
<A NAME="FileSys_d.htm_IX_FEA_FILE_TYPE">
 </A>
This attribute is a member of the <CODE>
GeosFileType</CODE>
 enumerated type and should not be altered. The type has the following values:</P>
<DL>
<DT>
GFT_NOT_GEOS_FILE</DT><DD>
The file is not a GEOS file. This constant is guaranteed to be equal to zero.</DD>
<DT>
GFT_EXECUTABLE</DT><DD>
The file is executable; in other words, it is some kind of geode.</DD>
<DT>
GFT_VM</DT><DD>The file is a VM file.</DD>
<DT>
GFT_DATA</DT><DD>The file is a GEOS byte file (see below).</DD>
<DT>
GFT_DIRECTORY</DT><DD>
The file is a GEOS directory.</DD>
<DT>
GFT_LINK</DT><DD>The file is a symbolic link (not yet implemented).</DD>


</DL>
<H5 CLASS="HeadingD">
FEA_FLAGS</H5>
<P>
<A NAME="FileSys_d.htm_IX_GFHF_&ldots;">
 </A>
<A NAME="FileSys_d.htm_IX_GeosFileHeaderFlags">
 </A>
<A NAME="FileSys_d.htm_IX_FEA_FLAGS">
 </A>
This attribute is a word-sized flag field, named <CODE>
GeosFileHeaderFlags</CODE>
. The following flags are implemented:</P>
<DL>
<DT>
GFHF_TEMPLATE</DT><DD>
The file is a document template.</DD>
<DT>
GFHF_SHARED_SINGLE</DT><DD>
The file can be opened for shared-single access.</DD>
<DT>
GFHF_SHARED_MULTIPLE</DT><DD>
The file can be opened for shared-multiple access.</DD>
</DL>
<P>
Shared-single and shared-multiple access are described in the VM chapter. For more details, see <A HREF="../../Memory/VM/combo.htm">the VM chapter</A>.</P>

<H5 CLASS="HeadingD">
FEA_RELEASE</H5>
<P>
<A NAME="FileSys_d.htm_IX_Release number:in file">
 </A>
<A NAME="FileSys_d.htm_IX_FEA_RELEASE">
 </A>
This attribute is a <CODE>
ReleaseNumber</CODE>
 structure. Generally, only geodes have release numbers. The structure has the following fields:</P>
<DL>
<DT>
<CODE>
RN_major</CODE>
</DT><DD>The file's major release number. An increase in the major release number generally indicates a change which is not downward-compatible.</DD>
<DT>
<CODE>
RN_minor</CODE>
</DT><DD>The file's minor release number. An increase in the minor release number generally indicates that the new version is compatible with previous versions.</DD>
<DT>
RN<CODE>
_change </DT><DD>A field for use by individual manufacturers.</CODE>
</DD>
<DT>
RN<CODE>
_engineering </DT><DD>
A field for use by individual manufacturers.</CODE>
</DD>


</DL>
<H5 CLASS="HeadingD">
<A NAME="FileSys_d.htm_47278">
 </A>
FEA_PROTOCOL</H5>
<P>
<A NAME="FileSys_d.htm_IX_FEA_PROTOCOL">
 </A>
This attribute contains the file's protocol numbers. A <CODE>
ProtocolNumber</CODE>
 structure is returned. For a discussion of file protocols, see <A HREF="../../Files/Documents/Documents_d.htm#82736">the Document Objects chapter</A>.</P>

<H5 CLASS="HeadingD">
FEA_TOKEN</H5>
<P>
<A NAME="FileSys_d.htm_IX_FEA_TOKEN">
 </A>
This attribute is the file's token. It consists of a <CODE>
GeodeToken</CODE>
 structure. For more information about tokens, see <A HREF="../../Kernel/Geodes/Geodes_b.htm">the Applications and Geodes chapter</A>.</P>

<H5 CLASS="HeadingD">
FEA_CREATOR</H5>
<P>
<A NAME="FileSys_d.htm_IX_Manufacturer ID:in file">
 </A>
<A NAME="FileSys_d.htm_IX_FEA_CREATOR">
 </A>
This attribute is the token of the document's creator. It consists of a <CODE>
GeodeToken</CODE>
 structure. For more information about tokens, see <A HREF="../../Kernel/Geodes/Geodes_b.htm">the Applications and Geodes chapter</A>.</P>

<H5 CLASS="HeadingD">
FEA_USER_NOTES</H5>
<P>
<A NAME="FileSys_d.htm_IX_User notes">
 </A>
<A NAME="FileSys_d.htm_IX_FEA_USER_NOTES">
 </A>
This attribute is a null-terminated string. It is displayed in the file's &quot;Info&quot; box. Users can edit this string with GeoManager.</P>


<H5 CLASS="HeadingD">
FEA_NOTICE</H5>
<P>
<A NAME="FileSys_d.htm_IX_FEA_NOTICE">
 </A>
This attribute contains the file's copyright notice.</P>


<H5 CLASS="HeadingD">
FEA_CREATION</H5>
<P>
<A NAME="FileSys_d.htm_IX_FEA_CREATION">
 </A>
This attribute is a <CODE>
FileDateAndTime</CODE>
 structure. It contains the time when the file was created.</P>


<H5 CLASS="HeadingD">
FEA_PASSWORD</H5>
<P>
<A NAME="FileSys_d.htm_IX_FEA_PASSWORD">
 </A>
This attribute contains the file's encrypted password, if any. </P>


<H5 CLASS="HeadingD">
FEA_NAME</H5>
<P>
<A NAME="FileSys_d.htm_IX_FEA_NAME">
 </A>
This attribute contains the file's virtual name. It is a null-terminated character string.</P>


<H5 CLASS="HeadingD">
FEA_GEODE_ATTR</H5>
<P>
This attribute contains information about the geode. If the file is not a geode, this field's value will be zero. If it is a geode, it will contain a record of <CODE>
GeodeAttrs</CODE>
. This record has the following fields:</P>
<DL>
<DT>
GA_PROCESS </DT><DD>This geode has a process thread.</DD>
<DT>
GA_LIBRARY </DT><DD>This geode is a library.</DD>
<DT>
GA_DRIVER</DT><DD>This geode is a driver.</DD>
<DT>
GA_KEEP_FILE_OPEN</DT><DD>
The GEOS kernel keeps this file open while GEOS is running.</DD>
<DT>
GA_SYSTEM </DT><DD>This file is part of the kernel.</DD>
<DT>
GA_MULTI_LAUNCHABLE</DT><DD>
This geode can be loaded more than once simultaneously.</DD>
<DT>
GA_DRIVER_INITIALIZED</DT><DD>
The geode is a driver which has been opened, loaded and initialized.</DD>
<DT>
GA_LIBRARY_INITIALIZED</DT><DD>
The geode is a library which has been opened and loaded, and whose entry point has been called.</DD>
<DT>
GA_GEODE_INITIALIZED</DT><DD>
The geode has been opened and completely initialized.</DD>
<DT>
GA_USES_COPROC</DT><DD>
The geode uses a math coprocessor, if one is available.</DD>
<DT>
GA_REQUIRES_COPROC</DT><DD>
The geode can only run if a math coprocessor or emulator is present.</DD>
<DT>
GA_HAS_GENERAL_CONSUMER_MODE</DT><DD>
The geode is an application which can be run in GCM mode.</DD>
<DT>
GA_HAS_ENTRY_POINTS_IN_C</DT><DD>
This geode is a library or driver which can be called from C code.</DD>


</DL>
<H5 CLASS="HeadingD">
FEA_PATH_INFO</H5>
<P>
This field contains information about the file's path. It is for internal use by the kernel.</P>


<H5 CLASS="HeadingD">
FEA_FILE_ID</H5>
<P>
This field is for internal use by the kernel.</P>


<H5 CLASS="HeadingD">
FEA_DESKTOP_INFO</H5>
<P>
This field is for use by the desktop manager.</P>


<H5 CLASS="HeadingD">
FEA_DRIVE_STATUS</H5>
<P>
<A NAME="FileSys_d.htm_IX_FEA_DRIVE_STATUS">
 </A>
This attribute contains the <CODE>
DriveExtendedStatus</CODE>
 word for the drive containing the file. The <CODE>
DriveExtendedStatus</CODE>
 value is described in <A HREF="#FileSys_4.htm_64044"> Accessing Drives</A>
.</P>

<HR>
<A NAME="FileSys_e.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">The File System</A>: 5.4 <A HREF="#FileSys_a.htm">Files</A>: 
<A NAME="FileSys_e.htm_32156">
 </A>
File Utilities</H3>
<PRE>FileDelete(), FileRename(), FileCopy(), FileMove(),FileGetDiskHandle()</PRE>
<P>
Most of the time, such actions as copying, deleting, and renaming files are handled by desktop management programs like GeoManager. However, other geodes may need to perform these actions themselves. For example, if you use a temporary file, you may wish to delete it when you're done. The GEOS file system provides routines for these situations. One file utility, <CODE>
FileEnum()</CODE>
, is elaborate enough to be treated in its own section; for details, see <A HREF="#FileSys_f.htm_51873"> FileEnum()</A>
.</P>
<P>
<A NAME="FileSys_e.htm_IX_FileDelete()">
 </A>
To delete a file, call <CODE>
FileDelete()</CODE>
. This routine takes one argument, namely the address of a path string. If it can delete the file, it returns zero; otherwise, it returns an error code. Common error conditions include the following:</P>
<DL>
<DT>
ERROR_FILE_NOT_FOUND</DT><DD>
No such file exists in the specified directory.</DD>
<DT>
ERROR_PATH_NOT_FOUND</DT><DD>
An invalid path string was passed.</DD>
<DT>
ERROR_ACCESS_DENIED</DT><DD>
You do not have permission to delete that file, or it exists on a read-only volume.</DD>
<DT>
ERROR_FILE_IN_USE</DT><DD>
Some geode has that file open.</DD>
</DL>
<P>
<A NAME="FileSys_e.htm_IX_FileRename()">
 </A>
To change a file's name, call <CODE>
FileRename()</CODE>
. This routine takes two arguments: a pointer to the path string specifying the file, and a pointer to a string specifying the new name for the file. If successful, <CODE>
FileRename()</CODE>
 returns zero; otherwise, it returns one of the above error codes.</P>
<P>
<A NAME="FileSys_e.htm_IX_FileCopy()">
 </A>
To make a copy of a file, call <CODE>
FileCopy()</CODE>
. This routine takes four arguments: the handles of the source and destination disks (which may be the same), and the addresses of source and destination path strings. Passing a disk handle of zero indicates the current path's disk. Each string specifies a path relative to the location specified by the corresponding disk handle. If the handle is a disk handle, the path is relative to that disk's root. If the disk handle is a standard path constant, the path string is relative to that standard path. If the disk handle is null, the path is relative to the current working directory. <CODE>
FileCopy()</CODE>
 will make a copy of the file in the specified location with the specified name. If a file with that name and location already exists, it will be overwritten. <CODE>
FileCopy()</CODE>
 returns zero if successful. Otherwise it returns one of the following error codes:</P>
<DL>
<DT>
ERROR_FILE_NOT_FOUND</DT><DD>
No such source file exists in the specified directory.</DD>
<DT>
ERROR_PATH_NOT_FOUND</DT><DD>
An invalid source or destination path string was passed.</DD>
<DT>
ERROR_ACCESS_DENIED</DT><DD>
You do not have permission to delete the existing copy of the destination file, or the destination disk or directory is not writable.</DD>
<DT>
ERROR_FILE_IN_USE</DT><DD>
Some geode has the existing destination file open.</DD>
<DT>
ERROR_SHORT_READ_WRITE</DT><DD>
There was not enough room on the destination disk. The destination disk will be left unchanged (i.e. a partial copy of the file will not be made).</DD>
</DL>
<P>
<A NAME="FileSys_e.htm_IX_FileMove()">
 </A>
To move a file from one directory to another, either on the same disk or on different disks, call <CODE>
FileMove()</CODE>
. This routine takes four arguments: the handles of the source and destination disks (which may be the same), and pointers to source and destination path strings. Passing a null disk handle indicates the current working directory. Each string specifies a path relative to the location specified by the corresponding disk handle. If the handle is a disk handle, the path is relative to that disk's root. If the disk handle is a standard path constant, the path string is relative to that standard path. If the disk handle is null, the path is relative to the current working directory. If the copy is successful, <CODE>
FileMove()</CODE>
 will return zero; otherwise, it will return one of the above error codes.</P>
<P>
<A NAME="FileSys_e.htm_IX_FileGetDiskHandle()">
 </A>
If you want to find out the handle of the disk containing an open file, call <CODE>
FileGetDiskHandle()</CODE>
. This routine is passed the file handle; it returns the disk handle. This is useful if the geode has to prepare for a shutdown; it can get the disk handle with <CODE>
FileGetDiskHandle()</CODE>
, then save that handle with <CODE>
DiskSave()</CODE>
 (see <A HREF="#FileSys_5.htm_58568"> Saving and Restoring a Disk Handle</A>
). With this information (and the file name), the geode will be able to reopen the file when it restarts.</P>
<HR>
<A NAME="FileSys_f.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">The File System</A>: 5.5 <A HREF="#FileSys_a.htm">Files</A>: 
<A NAME="FileSys_f.htm_51873">
 </A>
FileEnum()</H3>
<PRE>FileEnum(), FileEnumLocateAttr(), FileEnumWildcard(), FileEnumAttrs, FileEnumSearchFlags, FileEnumStandardReturnType, FEDosInfo, FENameAndAttr, FileEnumCallbackData</PRE>
<P>
<A NAME="FileSys_f.htm_IX_FileEnum()">
 </A>
You may sometimes need to perform an action on every file that matches certain criteria. For these situations, the file system provides the routine <CODE>
FileEnum()</CODE>
. <CODE>
FileEnum()</CODE>
 can be called in two ways. The usual way is to have <CODE>
FileEnum()</CODE>
 provide certain information about every file in a directory (or every file of a given type); when called, <CODE>
FileEnum()</CODE>
 will allocate a buffer and fill it with data structures, one for each matching file. Less commonly, you can have <CODE>
FileEnum()</CODE>
 call a callback routine for every file which matches certain criteria; this callback routine can take a broader range of actions.

</P>
<P>
You should not often need to use the <CODE>
FileEnum()</CODE>
 routine. The most common time that applications would need this functionality is when they present a list of the files in a directory to the user. The GenFileSelector object provides this functionality, making all necessary calls to <CODE>
FileEnum()</CODE>
 transparently to both the user and the geode. Note that the document control objects automatically create and manipulate a file selector when appropriate. For further information, see <A HREF="../../Files/GenFileSelector/combo.htm">the FileSelector object chapter</A>.</P><P>
<CODE>
FileEnum()</CODE>
 takes the following arguments:</P>
<UL>
<LI>
A pointer to a <CODE>
FileEnumParams</CODE>
 structure (see below). The data in this structure will tell <CODE>
FileEnum()</CODE>
 what to do.</LI>
<LI>
A pointer to a MemHandle variable. <CODE>
FileEnum()</CODE>
 will allocate a memory block to hold information about the files, and will write the block's handle to this location.</LI>
<LI>
A pointer to a word variable. If <CODE>
FileEnum()</CODE>
 was unable to fit information about all the files into the block passed, it will write the number of files not handled into this variable.</LI>
</UL>
<P>
<CODE>
FileEnum()</CODE>
 returns the number of files which were returned in the buffer.</P>
<P>
<A NAME="FileSys_f.htm_IX_FileEnumParams">
 </A>
The <CODE>
FileEnumParams</CODE>
 structure specifies how <CODE>
FileEnum()</CODE>
 should perform. The structure is defined as follows. A summary of each field's role follows; for full details, see the reference entry for <CODE>
FileEnum()</CODE>
.</P>
<PRE>typedef struct _FileEnumParams {
	FileEnumSearchFlags 				FEP_searchFlags;
	FileExtAttrDesc *				FEP_returnAttrs;
	word 				FEP_returnSize;
	FileExtAttrDesc *				FEP_matchAttrs;
	word 				FEP_bufSize;
	word 				FEP_skipCount;
	word _pascal (*FEP_callback) 
		(struct _FileEnumParams *					params,
		 FileEnumCallbackData *					fecd,
		 word 					frame);
	FileExtAttrDesc *				FEP_callbackAttrs;
	dword 				FEP_cbData1;
	dword 				FEP_cbData2;
	word 				FEP_headerSize;
} FileEnumParams;</PRE>
<DL>
<DT>
<CODE>
FEP_searchFlags</DT><DD>
</CODE>
<A NAME="FileSys_f.htm_IX_FEP_&ldots;">
 </A>
This is a byte-length flag field. The flags are of type <CODE>
FileEnumSearchFlags</CODE>
 (described below). These flags specify which files at the current location will be examined by <CODE>
FileEnum()</CODE>
. They also specify such things as whether a callback routine should be used.</DD>
<DT>
<CODE>
FEP_returnAttrs</DT><DD>
</CODE>
This field specifies what information is wanted about the files. It is a pointer to an array of <CODE>
FileExtAttrDesc</CODE>
 structures (see <A HREF="#FileSys_d.htm_40864"> FEA_MULTIPLE</A>
). The attributes will be written to the return buffer; each file will have an entry, containing all the attributes requested for that file. You can also request certain return values by setting <CODE>
FEP_returnAttrs</CODE>
 to equal a member of the <CODE>
FileEnumStandardReturnType</CODE>
 (again, by casting the <CODE>
FileEnumStandardReturnType</CODE>
 value to type <CODE>
void *</CODE>
). The <CODE>
FileEnumStandardReturnType</CODE>
 enumerated type is described later in this section.</DD>
<DT>
<CODE>
FEP_returnSize</DT><DD>
</CODE>
This is the size of each entry in the returned buffer. If a standard return type or an array of <CODE>
FileExtAttrDesc</CODE>
 structures was passed, each entry in the returned buffer will contain all the extended attribute information requested for that file.</DD>
<DT>
<CODE>
FEP_matchAttrs</DT><DD>
</CODE>
This field specifies which files should be enumerated by <CODE>
FileEnum()</CODE>
. It is a pointer to an array of <CODE>
FileExtAttrDesc</CODE>
 structures (see <A HREF="#FileSys_d.htm_40864"> FEA_MULTIPLE</A>
). These structures specify values for certain extended attributes. Only those files whose extended attributes match these will be enumerated. If you do not want to filter out any files in the working directory, or if you will use the callback routine to filter the files, pass a null pointer in this field.</DD>
<DT>
<CODE>
FEP_bufsize</CODE>
</DT><DD>This field specifies the maximum number of entries to be returned in the buffer. If you do not want to set a limit, pass the constant FEP_BUFSIZE_UNLIMITED. The buffer will be grown as necessary.</DD>
<DT>
<CODE>
FEP_skipCount</DT><DD>
</CODE>
This field contains the number of matching files to be ignored before the first one is processed. It is often used in conjunction with <CODE>
FEP_bufSize</CODE>
 to examine many files a few at a time. Each time <CODE>
FileEnum()</CODE>
 is called, you can enumerate a certain number of files; by adjusting the skip count each time, you can start each enumeration where the previous one ended. In this way you could walk through all the matching files in the directory. Note that if the <CODE>
FileEnumSearchFlags</CODE>
 bit FESF_REAL_SKIP is set (in FEP<CODE>
_searchFlags</CODE>
), the first files in the directory will be skipped <EM>
before</EM>
 they are tested to see if they match. This is faster, since the match condition won't have to be checked for the first files in the directory.</DD>
<DT>
<CODE>
FEP_callback</DT><DD>
</CODE>
This field holds a pointer to a Boolean callback routine. The callback routine can check to see if the file matches some other arbitrary criteria. The callback routine is called for any files which match all the above criteria. It can then decide whether to enumerate the file however it wishes. The callback routine should be declared <CODE>
_pascal</CODE>
. If the file should be accepted by <CODE>
FileEnum()</CODE>
, the callback should return <EM>
true</EM>
; otherwise it should return <EM>
false</EM>
. You can also instruct <CODE>
FileEnum()</CODE>
 to use one of the standard callback routines by passing a member of the <CODE>
FileEnumStandardCallback</CODE>
 enumerated type. In this case, <CODE>
FEP_callbackAttrs</CODE>
 is ignored; <CODE>
FileEnum()</CODE>
 will automatically pass the appropriate information to the callback routine. (Note that if the FESF_CALLBACK bit of the <CODE>
FEP_searchFlags</CODE>
 field is not set, the <CODE>
FEP_callback</CODE>
 field is ignored.) The callback routine may not call any routines which are in movable memory at the time <CODE>
FileEnum()</CODE>
 is called, except for routines which are in the same resource as the callback routine.</DD>
<DT>
<CODE>
FEP_callbackAttrs</DT><DD>
</CODE>
This field specifies what additional attributes should be read for the callback routine. This field is a pointer to an array of <CODE>
FileExtAttrDesc</CODE>
 structures (see <A HREF="#FileSys_d.htm_40864"> FEA_MULTIPLE</A>
). The array will be filled in with the appropriate information for each file before the callback routine is called. Note that if the FESF_CALLBACK bit of the <CODE>
FEP_searchFlags </CODE>
is not set, the <CODE>
FEP_callbackAttrs </CODE>
is ignored. If you do not need any attributes passed to the callback routine, set this field to be a null pointer.</DD>
<DT>
<CODE>
FEP_cbData1</CODE>
, <CODE>
FEP_cbData2</DT><DD>
</CODE>
These are dword-length fields. Their contents are ignored by <CODE>
FileEnum()</CODE>
; they are used to pass information to the callback routine. If you do not call a standard callback routine, you may use these fields any way you wish.</DD>
<DT>
<CODE>
FEP_headerSize</DT><DD>
</CODE>
If the flag FESF_LEAVE_HEADER is set, <CODE>
FileEnum()</CODE>
 will leave an empty header space at the beginning of the return buffer. The size of the header is specified by this field. If the flag FESF_LEAVE_HEADER is clear, this field is ignored.</DD>
</DL>
<P>
<A NAME="FileSys_f.htm_IX_FESF_&ldots;">
 </A>
<A NAME="FileSys_f.htm_IX_FileEnumSearchFlags">
 </A>
The first field of the <CODE>
FileEnumParams</CODE>
 structure, <CODE>
FEP_searchFlags</CODE>
, is a word-length record containing <CODE>
FileEnumSearchFlags</CODE>
. The following flags are available:</P>
<DL>
<DT>
FESF_DIRS</DT><DD>Directories should be examined by <CODE>
FileEnum()</CODE>
.</DD>
<DT>
FESF_NON_GEOS</DT><DD>
Non-GEOS files should be examined by <CODE>
FileEnum()</CODE>
.</DD>
<DT>
FESF_GEOS_EXECS</DT><DD>
GEOS executable files should be examined by <CODE>
FileEnum()</CODE>
.</DD>
<DT>
FESF_GEOS_NON_EXECS</DT><DD>
GEOS non-executable files (e.g., VM files) should be examined by <CODE>
FileEnum()</CODE>
.</DD>
<DT>
FESF_REAL_SKIP</DT><DD>
If a skip count of <EM>
n</EM>
 is specified, the first <EM>
n</EM>
 files will be skipped regardless of whether they matched the attributes passed. In this case, <CODE>
FileEnum()</CODE>
 will return the number of files passed through in order to get enough files to fill the buffer; the return value can thus be the real-skip count for the next pass.</DD>
<DT>
FESF_CALLBACK</DT><DD>
<CODE>
FileEnum()</CODE>
 should call a callback routine to determine whether a file should be accepted.</DD>
<DT>
FESF_LOCK_CB_DATA</DT><DD>
This flag indicates that the <CODE>
FileEnumParams</CODE>
 fields <CODE>
FEP_callback1</CODE>
 and <CODE>
FEP_callback2</CODE>
 are far pointers to movable memory that must be locked before <CODE>
FileEnum()</CODE>
 is called.</DD>
<DT>
FESF_LEAVE_HEADER</DT><DD>
If set, <CODE>
FileEnum()</CODE>
 should leave an empty header space at the start of the return buffer. The size of this buffer is specified by the <CODE>
FEP_headerSize</CODE>
 field.</DD>
</DL>
<P>
You can specify precisely which data you want about each file and in which arrangement it should be returned. However, for most purposes, you can get enough information by requesting one of the standard return types. <A NAME="FileSys_f.htm_IX_FESRT_&ldots;">
 </A>
<A NAME="FileSys_f.htm_IX_FileEnumStandardReturnType">
 </A>
If you pass a member of <CODE>
FileEnumStandardReturnType</CODE>
 in <CODE>
FEP_returnAttrs</CODE>
, <CODE>
FileEnum()</CODE>
 will write an array of structures to the return buffer; each file will have one such structure. The structures are shown below in <A HREF="#FileSys_f.htm_57154"> Standard FileEnum() Return Structures</A>
. <CODE>
FileEnumStandardReturnType</CODE>
 has the following values:</P>
<DL>
<DT>
FESRT_COUNT_ONLY</DT><DD>
<CODE>
FileEnum()</CODE>
 will not allocate any memory or return data about files; instead, it will simply return the number of files which match the specified criteria.</DD>
<DT>
FESRT_DOS_INFO</DT><DD>
<CODE>
FileEnum()</CODE>
 will return an array of <CODE>
FEDosInfo</CODE>
 structures. These structures contain basic information about the file: its virtual name, size, modification date, DOS attributes, and path information (as a <CODE>
DirPathInfo</CODE>
 record).</DD>
<DT>
FESRT_NAME</DT><DD>
<CODE>
FileEnum()</CODE>
<A NAME="FileSys_f.htm_IX_FileLongName">
 </A>
<A NAME="FileSys_f.htm_IX_FILE_LONGNAME_BUFFER_SIZE">
 </A>
 will return an array of <CODE>
FileLongName</CODE>
 strings, each one of which is FILE_LONGNAME_BUFFER_SIZE characters long; every one of these will contain a file's virtual name followed by a null terminator.</DD>
<DT>
FESRT_NAME_AND_ATTR</DT><DD>
<CODE>
FileEnum()</CODE>
 will return an array of <CODE>
FENameAndAttr</CODE>
 structures, each one of which contains a file's DOS attributes and virtual name.</DD>
</DL>
<P>
<A NAME="FileSys_f.htm_IX_DPI_&ldots;">
 </A>
<A NAME="FileSys_f.htm_IX_FEDosInfo">
 </A>
The <CODE>
FEDosInfo</CODE>
 structure includes a word-sized record which describes the file's position relative to the standard paths. It contains the following fields:</P>
<DL>
<DT>
DPI_EXISTS_LOCALLY</DT><DD>
This bit is set if the file exists in a directory under the primary tree.</DD>
<DT>
DPI_ENTRY_NUMBER_IN_PATH</DT><DD>
This is the mask for a seven-bit field whose offset is DPI_ENTRY_NUMBER_IN_PATH_OFFSET.</DD>
<DT>
DPI_STD_PATH</DT><DD>
This is the mask for an eight-bit field whose offset is DPI_STD_PATH_OFFSET. If the file is in a standard path, this field will contain a <CODE>
StandardPath</CODE>
 constant for a standard path containing the file. This need not be the &quot;closest&quot; standard path; for example, if the file is in the &quot;World&quot; directory, this constant might nevertheless be SP_TOP.</DD>
</DL>
<P CLASS="figTitle">
Code Display 17-2 <A NAME="FileSys_f.htm_57154">
 </A>
Standard FileEnum() Return Structures</P>
<PRE>/* These structures are the standard FileEnum() return types. You can also
 * instruct FileEnum() to return any arbitrary extended attribute information.
 */</PRE>
<PRE>typedef struct {			/* These are returned if you specify FESRT_DOS_INFO */
    FileAttrs 		FEDI_attributes;			/* File's DOS attributes; 
					 * see <A HREF="#FileSys_10.htm_88250"> Getting and Setting Information about a Byte File</A> */
    FileDateAndTime 		FEDI_modTimeDate			/* Last modification time; see <A HREF="#FileSys_d.htm_38588"> FEA_MODIFICATION</A> */
    dword 		FEDI_fileSize;			/* Size of file (in bytes) */
    FileLongName		FEDI_name;			/* File's virtual name; null-terminated */
    DirPathInfo 		FEDI_pathInfo;			/* PathInfo structure, described above */
} FEDosInfo;</PRE>
<PRE>typedef struct{ 			/* These are returned if you specify FESRT_NAME_AND_ATTR */
    FileAttrs 		FENAA_attributes;			/* File's DOS attributes; 
					 * see <A HREF="#FileSys_10.htm_88250"> Getting and Setting Information about a Byte File</A> */
    FileLongName 		FENAA_name;			/* File's virtual name; null-terminated */
} FENameAndAttr;</PRE>
<P>
<A NAME="FileSys_f.htm_IX_FileEnumWildcard()">
 </A>
There is currently one standard callback routine provided. This routine, <CODE>
FileEnumWildcard()</CODE>
, rejects all files whose names don't match a wildcard string. To call this routine, set <CODE>
FEP_callback</CODE>
 as follows:</P>
<PRE>enumParams.FEP_callback = (void *) FESC_WILDCARD;</PRE>
<P>
<CODE>
FEP_cbData1</CODE>
 should be a pointer to a null-terminated wildcard string. In this string, &quot;*&quot; denotes a sequence of zero or more of any character, and &quot;?&quot; denotes any one character; all other characters represent themselves. If a file's virtual name matches the wildcard string, information about it will be returned by <CODE>
FileEnum()</CODE>
. If the lowest byte of <CODE>
FEP_cbData2</CODE>
 is non-zero, the comparison will be case-insensitive; otherwise, it will be case-sensitive. (The other bytes of <CODE>
FEP_cbData2</CODE>
 are ignored.) This is different from standard DOS wildcarding; for example, the name &quot;doc*.&quot; matches any file that begins with the letters &quot;doc&quot; and ends with a period, whereas a DOS wildcard string &quot;doc*.&quot; would match only those files whose name start with &quot;doc&quot; and which have no extension.</P>
<P>
<A NAME="FileSys_f.htm_IX_FileEnumLocateAttr()">
 </A>
If you're writing your own callback routine, you may wish to use the <CODE>
FileEnumLocateAttr()</CODE>
 utility routine. This routine searches a <CODE>
FileExtAttrDesc</CODE>
 array (as passed to <CODE>
FileEnum()</CODE>
 callbacks), and will search the array for a file matching a particular attribute.</P>
<HR>
<A NAME="FileSys_10.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">The File System</A>: 5.6 <A HREF="#FileSys_a.htm">Files</A>: 
<A NAME="FileSys_10.htm_48613">
 </A>
Bytewise File Operations</H3>
<P>
There are several routines designed for working with files as a string of bytes. These routines may be used to work with DOS files or with GEOS byte files. You can open any file (including an executable file or a VM file) for byte-level access. This may be useful for such things as file-compression routines; however, be aware that if you make any changes to such files, you could invalidate them. For this reason, if you open a VM or executable file for byte-level access, you should open it for read-only use.

</P>

<H4 CLASS="HeadingC">
<A NAME="FileSys_10.htm_59832">
 </A>
Opening and Closing Files</H4>
<PRE>FileOpen(), FileCreate(), FileCreateTempFile(), FileClose(), FileAccessFlags</PRE>
<P>
The GEOS file system provides several routines for opening files for byte-level access. If you are working with GEOS Virtual Memory files, you should use the appropriate VM routines to open and close the files (see <A HREF="../../Memory/VM/combo.htm">the VM chapter</A>). You should use the byte-level routines only if you are working with DOS files or with GEOS byte files. You may occasionally want to read a VM file or an executable file as a string of bytes. In this rare case, you must use the routines in this section. Note, however, that you should not change the VM file with these routines; it is safe only to open it for read-only access.</P><P>
<A NAME="FileSys_10.htm_IX_FileOpen()">
 </A>
To open a file, call <CODE>
FileOpen()</CODE>
. This routine takes two arguments: a set of <CODE>
FileAccessFlags</CODE>
 and a pointer to a null-terminated string. The string should specify the name of the file (either the virtual name or the native name may be used). It may simply be a file name, or it may be a relative or absolute path. The <CODE>
FileAccessFlags</CODE>
 record specifies two things: what kind of access the caller wants, and what type of access is permitted to other geodes.<A NAME="FileSys_10.htm_IX_FILE_ACCESS_&ldots;">
 </A>
<A NAME="FileSys_10.htm_IX_FileAccessFlags">
 </A>
 A set of <CODE>
FileAccessFlags</CODE>
 is thus a bit-wise OR of two different values. The first specifies what kind of access the calling geode wants and has the following values:</P>
<DL>
<DT>
FILE_ACCESS_R</DT><DD>
The geode will only be reading from the file.</DD>
<DT>
FILE_ACCESS_W</DT><DD>
The geode will write to the file but will not read from it.</DD>
<DT>
FILE_ACCESS_RW</DT><DD>
The geode will read from and write to the file.</DD>
</DL>
<P>
<A NAME="FileSys_10.htm_IX_FILE_DENY_&ldots;">
 </A>
The second part specifies what kind of access other geodes may have. Note that if you try to deny a permission which has already been given to another geode (e.g. you open a file with FILE_DENY_W when another geode has the file open for write-access), the call will fail. The following permissions can be used:</P>
<DL>
<DT>
FILE_DENY_RW</DT><DD>
No geode may open the file for any kind of access, whether read, write, or read/write.</DD>
<DT>
FILE_DENY_R</DT><DD>
No geode may open the file for read or read/write access.</DD>
<DT>
FILE_DENY_W</DT><DD>
No geode may open the file for write or read/write access.</DD>
<DT>
FILE_DENY_NONE</DT><DD>
Other geodes may open the file for any kind of access.</DD>
</DL>
<P>
Two flags, one from each of these sets of values, are combined to make up a proper <CODE>
FileAccessFlags</CODE>
 value. For example, to open the file for read-only access while prohibiting other geodes from writing to the file, you would pass the flags FILE_ACCESS_R and FILE_DENY_W as follows:</P>
<PRE>myHandle = FileOpen(&quot;MyFile&quot;,
		(FILE_ACCESS_R | FILE_DENY_W));</PRE>
<P>
If successful, <CODE>
FileOpen()</CODE>
 returns the file's handle. If it is unsuccessful, it returns a null handle and sets the thread's error value. The following error values are commonly returned:</P>
<DL>
<DT>
ERROR_FILE_NOT_FOUND</DT><DD>
No file with the specified name could be found in the appropriate directory.</DD>
<DT>
ERROR_PATH_NOT_FOUND</DT><DD>
A relative or absolute path had been passed, and the path included a directory which did not exist.</DD>
<DT>
ERROR_TOO_MANY_OPEN_FILES</DT><DD>
There is a limit to how many files may be open at once. If this limit is reached, <CODE>
FileOpen()</CODE>
 will fail until a file is closed.</DD>
<DT>
ERROR_ACCESS_DENIED</DT><DD>
Either the caller requested access which could not be granted (e.g. it requested write access when another geode had already opened the file with FILE_DENY_W), or the caller tried to deny access when that access had already been granted to another geode (e.g. it tried to open the file with FILE_DENY_W when another geode already had it open for write-access).</DD>
<DT>
ERROR_WRITE_PROTECTED</DT><DD>
The caller requested write or read-write access to a file in a write-protected volume.</DD>
</DL>
<P>
Note that if you use the document control objects, they automatically make all appropriate calls to <CODE>
FileOpen()</CODE>
 when the user requests it; you will automatically be passed the file's handle.</P>
<P>
<CODE>
FileOpen()</CODE>
 can only be called if the file already exists.<A NAME="FileSys_10.htm_IX_FileCreate()">
 </A>
 In order to create a byte file, you must call <CODE>
FileCreate()</CODE>
. <CODE>
FileCreate()</CODE>
 takes four arguments: a set of <CODE>
FileCreateFlags</CODE>
, a set of <CODE>
FileAccessFlags</CODE>
, a set of <CODE>
FileAttrs</CODE>
, and a pointer to a string containing a name for the file.<A NAME="FileSys_10.htm_IX_FCF_&ldots;">
 </A>
<A NAME="FileSys_10.htm_IX_FileCreateFlags">
 </A>
 As with <CODE>
FileOpen()</CODE>
, the name may be a name alone or a relative or absolute path. The <CODE>
FileCreateFlags</CODE>
 specifies whether the file should be created if it already exists. The following flags are available:</P>
<DL>
<DT>
FILE_CREATE_TRUNCATE</DT><DD>
If a file with the given name exists, it should be opened and truncated; that is, all data should be deleted.</DD>
<DT>
FILE_CREATE_NO_TRUNCATE</DT><DD>
If the file exists, it should be opened without being truncated.</DD>
<DT>
FILE_CREATE_ONLY</DT><DD>
If the file exists, the routine should fail and set the thread's error value to ERROR_FILE_EXISTS.</DD>
<DT>
FCF_NATIVE</DT><DD>
This flag is combined with one of the above flags if the file should be created in the device's native format; e.g. if it should be a DOS file instead of a GEOS file. The name passed must be an acceptable native file name. If a GEOS file with the specified name already exists, <CODE>
FileCreate()</CODE>
 will fail with error condition ERROR_FILE_FORMAT_MISMATCH.</DD>
</DL>
<P>
The first three flags (FILE_CREATE_...) are mutually exclusive; exactly one of them must be passed to <CODE>
FileCreate()</CODE>
. That flag may or may not be combined with FCF_NATIVE.</P>
<P>
The <CODE>
FileAccessFlags</CODE>
 are the same as described in <CODE>
FileOpen()</CODE>
. Note, however, that you must request either write access or read/write access when you use <CODE>
FileCreate()</CODE>
.</P>
<P>
Every file has a set of attributes. These record certain information about the file. If you create a file, you will need to specify values for these attributes. The attributes are described above in the section on <A HREF="#FileSys_d.htm_66195"> FEA_FILE_ATTR</A>
.</P>
<P>
If <CODE>
FileCreate()</CODE>
 is successful, it will open the file and return its handle. If it fails, it will return a null handle and set the thread's error value. It may return any of the <CODE>
FileOpen()</CODE>
 errors. It may also return the following errors:</P>
<DL>
<DT>
ERROR_FILE_EXISTS</DT><DD>
Returned if <CODE>
FileCreate()</CODE>
 was called with FILE_CREATE_ONLY and a file with the specified name already exists.</DD>
<DT>
ERROR_FORMAT_MISMATCH</DT><DD>
Returned if <CODE>
FileCreate()</CODE>
 was called with FILE_CREATE_TRUNCATE or FILE_CREATE_NO_TRUNCATE and a file exists in a different format than desired; i.e. you passed FCF_NATIVE and the file already exists in the GEOS format, or vice versa.</DD>
</DL>
<P>
<A NAME="FileSys_10.htm_IX_FileCreateTempFile()">
 </A>
It is often useful to create temporary files which are not seen by the user. In these cases, you generally don't care about the file's name since you will most likely be deleting the file on exit. For these situations GEOS provides the routine <CODE>
FileCreateTempFile()</CODE>
. <CODE>
FileCreateTempFile()</CODE>
 is passed a directory; it chooses a unique name for the file. This routine takes two arguments:</P>
<UL>
<LI>
A set of <CODE>
FileAttrs</CODE>
, as described above.</LI>
<LI>
A pointer to a null-terminated string specifying the path for the temporary file. This path may be relative or absolute. To create the temporary file in the current directory, pass the string &quot;.&quot; This string should contain fourteen extra null bytes at the end, as <CODE>
FileCreateTempFile()</CODE>
 will write the name of the temporary file at the end of the string. Temporary files are typically created in SP_WASTE_BASKET.</LI>
</UL>
<P>
If successful, <CODE>
FileCreateTempFile()</CODE>
 will open the temporary file and return its handle. It will also write the file's name to the end of the string passed. You will need to know the name to delete the file. The name is also useful if GEOS shuts down while a temporary file is open; the geode will need to know the temporary file's name in order to reopen it.</P>
<P>
<A NAME="FileSys_10.htm_IX_FileClose()">
 </A>
When you are done with a file, you should close it by calling <CODE>
FileClose()</CODE>
. This releases any restrictions you may have placed on the file and allows the file to be moved or deleted. It is passed two arguments: the file handle and a Boolean value which should be set to <EM>
true</EM>
 (i.e. non-zero) if the geode cannot handle error messages; it will cause <CODE>
FileClose()</CODE>
 to fatal-error if it cannot successfully close the file. (This should only be used during development; the flag should never be passed in a finished program.) The routine returns zero if successful; otherwise, it returns a <CODE>
FileError</CODE>
 value.</P>


<H4 CLASS="HeadingC">
<A NAME="FileSys_10.htm_15825">
 </A>
Reading From and Writing To Files</H4>
<PRE>FileRead(), FileWrite(), FilePos(), FileCommit()</PRE>
<P>
There are a few specific operations you are allowed to perform on data in a byte-file. You can copy data from the file into memory; you can copy data from memory into the file, overwriting the file's contents; you can write data to the end of a file; and you can cut data from the end of the file. If you want to perform more elaborate manipulations on a byte-file, you may wish to create a temporary VM file and copy the data there (see <A HREF="../../Memory/VM/combo.htm">the VM chapter</A>).</P><P>
<A NAME="FileSys_10.htm_IX_File position">
 </A>
Every file handle has a <EM>
file position</EM>
 associated with it. All read and write operations begin at that position; they may also change the position. The first byte in a file is considered to be at position zero. If the file is a GEOS byte file, position zero is immediately after the GEOS header; thus, the header cannot be accessed or altered via the read and write operations.</P>
<P>
<A NAME="FileSys_10.htm_IX_FileRead()">
 </A>
To read data from a file, call <CODE>
FileRead()</CODE>
. This routine takes four arguments. The first is the file's handle. The second is the address of a buffer. <CODE>
FileRead()</CODE>
 will copy the requested number of bytes from the file to the buffer. The third is the number of bytes to read. The fourth is a Boolean indicating whether the caller can handle errors. (This is <EM>
true</EM>
 if the geode cannot handle error messages; it will cause <CODE>
FileRead()</CODE>
 to fatal-error if it cannot successfully read the data. This should only be used during development; the flag should never be passed in a finished program.) <CODE>
FileRead() </CODE>
returns the number of bytes actually read. This may be less than the number requested, if the end of file is reached; in this case, the thread's error value will be set to ERROR_SHORT_READ_WRITE. If <CODE>
FileRead()</CODE>
 was unable to gain access to the file, it will return -1 and set the thread's error value to ERROR_ACCESS_DENIED. In any event, the file position will be incremented by the number of bytes read; thus, it will point to the first byte after the data read.</P>
<P>
<A NAME="FileSys_10.htm_IX_FileWrite()">
 </A>
To write data to a file, call <CODE>
FileWrite()</CODE>
. This routine takes four arguments. The first is the file's handle. The second is the address of a buffer in memory. The third is the number of bytes to write. The fourth is a Boolean indicating whether the caller can handle errors. <CODE>
FileWrite()</CODE>
 will copy the specified number of bytes from the buffer to the file, starting at the current position and expanding the file as necessary. It will also increment the current position by the number of bytes written. If the current position is not at the end of the file, <CODE>
FileWrite()</CODE>
 will overwrite the file's existing data. <CODE>
FileWrite()</CODE>
 returns the number of bytes written. This may be less than the number requested, if the disk ran out of space; in this case, the thread's error value will be set to ERROR_SHORT_READ_WRITE. If <CODE>
FileWrite()</CODE>
 could not get access to the file (as, for example, if the geode had read-only access to the file), it will return -1 and set the thread's error value to ERROR_ACCESS_DENIED. </P>
<P>
If a file is on a removable disk, the kernel will make sure that the disk is in the appropriate drive before reading from or writing to it. If the disk is not in the drive, the kernel will prompt the user to insert it. The user will have the option of aborting the operation; this will result in the file-access routine failing with error condition ERROR_DISK_UNAVAILABLE.</P>
<P>
<A NAME="FileSys_10.htm_IX_FileCommit()">
 </A>
When you write changes to a file, either the GEOS file system or the underlying DOS may choose to cache those changes to save time. All cached changes will be written to the disk when the file is closed. However, you can force the cached changes to be written immediately by calling <CODE>
FileCommit()</CODE>
. This routine takes two arguments. The first is the file's handle. The second is a Boolean indicating whether the caller can handle errors. The routine returns zero if the operation was successful; otherwise it returns an error code.</P>
<P>
<A NAME="FileSys_10.htm_IX_FilePos()">
 </A>
To change the current file position, call <CODE>
FilePos()</CODE>
. This routine takes three arguments. The first is the file handle.<A NAME="FileSys_10.htm_IX_FILE_POS_&ldots;">
 </A>
<A NAME="FileSys_10.htm_IX_FilePosMode">
 </A>
 The second is a member of the <CODE>
FilePosMode</CODE>
 enumerated type; this value indicates how the new position is specified. The third argument is a number of bytes; it specifies how far the file position will be moved. <CODE>
FilePosMode</CODE>
 has the following possible values:</P>
<DL>
<DT>
FILE_POS_START</DT><DD>
The file position is set to a specified number of bytes after the start of the file. Passing this mode with an offset of zero will set the file position to the start of the file (i.e. immediately after the header information).</DD>
<DT>
FILE_POS_RELATIVE</DT><DD>
The file position is incremented or decremented by a specified number of bytes.</DD>
<DT>
FILE_POS_END</DT><DD>
The file position is set to a specified number of bytes before the end of the file. Passing this mode with an offset of zero will set the file position to the end of the file.</DD>
</DL>
<P>
<CODE>
FilePos()</CODE>
 returns a 32-bit integer. This integer specifies the file position after the move (relative to the start of the file). To find out the current file position without changing it, call <CODE>
FilePos()</CODE>
 with mode FILE_POS_RELATIVE and offset zero.</P>


<H4 CLASS="HeadingC">
<A NAME="FileSys_10.htm_88250">
 </A>
Getting and Setting Information about a Byte File</H4>
<PRE>FileGetDateAndTime(), FileSetDateAndTime(), FileGetAttributes(), FileSetAttributes()</PRE>
<P>
GEOS provides several routines to get information about files. To get information about a GEOS file, you would ordinarily use one of the extended attributes routines (see <A HREF="#FileSys_d.htm_49785"> GEOS Extended Attributes</A>
). These routines are ordinarily used for non-GEOS files. Nevertheless, all of the following routines can be used on GEOS files.</P>
<P>
<CODE>
FileGetDateAndTime()</CODE>
<A NAME="FileSys_10.htm_IX_FileGetDateAndTime()">
 </A>
 and<A NAME="FileSys_10.htm_IX_FileSetDateAndTime()">
 </A>
 <CODE>
FileSetDateAndTime()</CODE>
 are used to get and set the file's modification time. To access a GEOS file's modification time, you would ordinarily call an extended attribute routine, passing FEA_MODIFICATION. However, special-purpose routines are provided specifically for changing a file's modification time. Note that these routines may be used for GEOS or non-GEOS files. Similarly, you can change the FEA_MODIFICATION attribute even for non-GEOS files. To find out the modification time, call <CODE>
FileGetDateAndTime()</CODE>
. This routine is passed the file's handle and returns a <CODE>
FileDateAndTime</CODE>
 value (as described above on <A HREF="#FileSys_d.htm_38588"> FEA_MODIFICATION</A>
). To change the modification time, call <CODE>
FileSetDateAndTime()</CODE>
. This routine is passed the file's handle and a <CODE>
FileDateAndTime</CODE>
 value. If successful, it returns zero; otherwise, it returns an error code. You must have write permission to change the modification time; otherwise, <CODE>
FileSetDateAndTime()</CODE>
 will fail with condition ERROR_ACCESS_DENIED. <A NAME="FileSys_10.htm_IX_TimerGetFileDateTime()">
 </A>
The <CODE>
TimerGetFileDateTime()</CODE>
 routine returns the current date and time in a <CODE>
FileDateAndTime</CODE>
 structure.</P>
<P>
<A NAME="FileSys_10.htm_IX_FileGetAttributes()">
 </A>
To find out a DOS file's attributes, call <CODE>
FileGetAttributes()</CODE>
. This routine is passed a file's path.<A NAME="FileSys_10.htm_IX_FileSetAttributes()">
 </A>
 It returns the file's <CODE>
FileAttrs</CODE>
 record (as described on <A HREF="#FileSys_d.htm_66195"> FEA_FILE_ATTR</A>
). To change the file's attributes, call <CODE>
FileSetAttributes()</CODE>
. This routine takes two arguments: the address of a null-terminated path string and a <CODE>
FileAttrs</CODE>
 record. It returns zero if it was successful; otherwise, it returns an error condition. Note that a file's attributes cannot be changed if the file is open.</P>


<H4 CLASS="HeadingC">
<A NAME="FileSys_10.htm_12930">
 </A>
Data-Access Synchronization</H4>
<PRE>FileLockRecord(), FileUnlockRecord()</PRE>
<P>
GEOS provides routines to help threads synchronize file access. This functionality is very elaborate for VM files. For byte files it is less so. Several threads can synchronize their access to a single handle by using <CODE>
HandleP()</CODE>
 and <CODE>
HandleV()</CODE>
, described in <A HREF="../../Memory/Heap/Memory_b.htm#68631">the Memory Management chapter</A>. If they want to use the file at the same time, they should use <CODE>FileLockRecord()</CODE>
 and <CODE>
FileUnlockRecord()</CODE>
.</P>
<P>
<CODE>
FileLockRecord()</CODE>
<A NAME="FileSys_10.htm_IX_FileLockRecord()">
 </A>
 takes three arguments: the file handle, a dword specifying the start of the region to be locked, and a dword specifying the length (in bytes) of the region to be locked. If there are no locks on any part of that region, <CODE>
FileLockRecord()</CODE>
 returns zero; otherwise, it returns the error code ERROR_ALREADY_LOCKED. Note that there is nothing to stop another thread or geode from reading or writing to that region. The lock simply prevents anyone from <EM>
locking</EM>
 that region with <CODE>
FileLockRecord()</CODE>
. The file's users have to remember to lock any part of the file before accessing it.</P>
<P>
<A NAME="FileSys_10.htm_IX_FileUnlockRecord()">
 </A>
To release a lock on a part of a file, call <CODE>
FileUnlockRecord()</CODE>
. This routine takes the same arguments as <CODE>
FileLockRecord()</CODE>
.</P>

<HR>
This document is a single-page version of a <A HREF="index.htm">a multi-page document</A>, suitable for easy printing.
</BODY>
</HTML>
