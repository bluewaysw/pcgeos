<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD>
<!-- This page was automatically generated from a bunch of smaller pages. -->
<META NAME="copyright" CONTENT="Copyright GEOWORKS">
<LINK REL="STYLESHEET" HREF="../../docHelpers/style.css">
<LINK REV="MADE" HREF="mailto:doc-feedback@geoworks.com">
<TITLE>The Math Library</TITLE>
</HEAD>
<BODY BGCOLOR="#ffffdf">
This document is a single-page version of a <A HREF="index.htm">a multi-page document</A>, suitable for easy printing.
<A NAME="index.htm"></A>



<H1 CLASS="chapterTitle">

<A NAME="index.htm_97933">
 </A>
The Math Library

</H1>
<P>
The <A NAME="index.htm_IX_Math Library">
 </A>
Math Library allows high precision computations not available through standard integer operations. Floating Point (FP) numbers use decimal representation to express fractional quantities. This format also allows scientific notation to represent very large and very small numbers.</P>
<P>
To enable floating point operations, an application must include a GEOS Math Library. There are two Math Libraries:<STRONG CLASS="fileName">
 math.h</STRONG>
 and <STRONG CLASS="fileName">
math.goh</STRONG>
. The file <STRONG CLASS="fileName">
math.h</STRONG>
 includes what you need to get floating point numbers to work within your application. The object file, <STRONG CLASS="fileName">
math.goh</STRONG>
 (which includes <STRONG CLASS="fileName">
math.h</STRONG>
), includes the float-format controller, an object that allows the user to control how floating point numbers are formatted within an application.</P>
<P>
In most cases, the mere inclusion of the Math Library will eliminate the need to directly call Math Library routines. (The C compiler will parse the mathematical expressions into appropriate floating point routines.) You may, however, wish to call some of these routines directly. Developers using Object Assembly must use this latter approach. C developers may also want to directly manipulate the FP stack for involved computations that they would rather not leave to the compiler. This approach is discussed in the latter half of this chapter.</P>
<P>
Use of <STRONG CLASS="fileName">
math.goh</STRONG>
 is optional, depending on the purpose of the application. A spreadsheet application, for example, might want to allow the user to format FP numbers. Other applications might not want to include this file.</P>
<P CLASS="sectionlinks">
<STRONG>
&nbsp;&nbsp;<A HREF="#Math_1.htm">1 Basic Math Functions</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Math_2.htm">1.1 Algebraic Functions</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Math_3.htm">1.2 Transcendental Functions</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Math_4.htm">1.3 Random Number Generation</A><BR>
&nbsp;&nbsp;<A HREF="#Math_5.htm">2 Conversions to Other Types</A><BR>
&nbsp;&nbsp;<A HREF="#Math_6.htm">3 Float Formats</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Math_7.htm">3.1 System-defined Formats</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Math_8.htm">3.2 User-defined Formats</A><BR>
&nbsp;&nbsp;<A HREF="#Math_9.htm">4 Direct FP Operations</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Math_a.htm">4.1 Floating Point Numbers</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Math_b.htm">4.2 The Floating Point Stack</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Math_c.htm">4.3 Floating Point Math Routines</A><BR>
</STRONG>
</P> <!-- end of sectionlinks blob -->

<HR>
<A NAME="Math_1.htm"></A>


<H2 CLASS="sectionTitle">
<A HREF="#index.htm">The Math Library</A>: 1 
Basic Math Functions</H2>
<P>
The Math Library includes many routines and structures that make the manipulation of FP numbers possible. Most of these are transparent to a C programmer.</P>
<P>
C includes the following floating point types: <CODE>
float</CODE>
, <CODE>
double</CODE>
, and <CODE>
long</CODE>
 <CODE>
double</CODE>
. A floating point number in GEOS is of type <CODE>
FloatNum</CODE>
, which uses the IEEE 80 bit standard (equivalent to a long double) to represent floating point values. <CODE>
FloatNum</CODE>
 has overloaded the float, double, long double, and all basic math functions.</P>
<P>
A <A NAME="Math_1.htm_IX_FloatNum">
 </A>
<CODE>
FloatNum</CODE>
 consists of a one bit sign, a 15 bit exponent, and a 64 bit mantissa. The maximum exponent allowed is 7FFEh. An exponent of 7FFFh (FP_NAN) signals an underflow or overflow. You may check the value of this exponent using the macro <A NAME="Math_1.htm_IX_FLOAT_EXPONENT">
 </A>
FLOAT_EXPONENT to extract the exponent of a <CODE>
FloatNum</CODE>
.</P>
<P CLASS="figTitle">


Code Display D-1 Extracting an Exponent</P>
<PRE>FloatNum myNum;</PRE>
<PRE>if (FLOAT_EXPONENT(&amp;myNum) == FP_NAN)
{
     return(ERROR);
}</PRE>
<P>
If you use any floats, doubles, or long doubles in your application, GEOS will convert these types into <CODE>
FloatNum</CODE>
 values automatically and call the appropriate GEOS functions to manipulate the numbers. As this is the case, it is usually easier to declare any floating point variables in your application as <CODE>
FloatNum</CODE>
 types (or long doubles). This cuts down on conversion time.</P>
<P>
The Math Library provides all the familiar mathematical functions to manipulate these GEOS FP numbers (addition, multiplication, computation of logarithms, etc.). In C, most of these functions will automatically be called when their corresponding C operation involving FP numbers take place. (For example, when using the `+' binary operator to add two FP numbers, the Math Library will use the corresponding <A NAME="Math_1.htm_IX_FloatAdd()">
 </A>
<CODE>
FloatAdd()</CODE>
 routine.)</P>
<P>
You may, under special circumstances, wish to use these math routines directly. If you do so, you will need to manipulate the floating point stack manually, pushing numbers on the stack and making sure numbers are in the proper stack location to perform each operation. In most cases, the FP math routines operate on numbers already in place on the FP stack; they take and return no arguments of their own.</P>
<P>
Two functions you will need to use if you take this approach are <CODE>
FloatPushNumber()</CODE>
<A NAME="Math_1.htm_IX_FloatPushNumber()">
 </A>
 and<CODE>
 FloatPopNumber()</CODE>
<A NAME="Math_1.htm_IX_FloatPopNumber()">
 </A>
. <CODE>
FloatPushNumber()</CODE>
 takes the address of a variable (of type <CODE>
FloatNum</CODE>
) to push onto the FP stack; <CODE>
FloatPopNumber()</CODE>
 takes the address of a buffer to place an FP number popped off the FP stack. Other routines (for example, <CODE>
FloatAdd()</CODE>
) can then be called to operate on the FP stack. (See <A HREF="#Math_2.htm_25726"> Adding Two FP Numbers</A>
 for an example using this approach.)</P>
<P>
There are many other routines that perform stack manipulation by shifting locations of FP numbers on the stack (<CODE>
FloatRoll()</CODE>
, <CODE>
FloatDrop()</CODE>
, etc.). These routines are covered in detail in the latter part of this chapter because they are seldom needed in a C applications.</P>
<P CLASS="subsectionLink">
<A HREF="#Math_2.htm">Algebraic Functions</A></P>
<P CLASS="subsectionLink">
<A HREF="#Math_3.htm">Transcendental Functions</A></P>
<P CLASS="subsectionLink">
<A HREF="#Math_4.htm">Random Number Generation</A></P>
<HR>
<A NAME="Math_2.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">The Math Library</A>: 1.1 <A HREF="#Math_1.htm">Basic Math Functions</A>: 
<A NAME="Math_2.htm_IX_Math:Functions, Algebraic">
 </A>
Algebraic Functions</H3>
<P>
Algebraic routines perform algebraic operations on FP numbers. The Math Library provides all of the basic algebraic routines that operate on GEOS FP numbers (addition, subtraction, etc.). </P>
<P>
If you wish to call these routines directly rather than rely on the C operations, you may manipulate the floating point stack directly. To add two numbers using <CODE>
FloatAdd()</CODE>
 for example, you would use <CODE>
FloatPushNumber()</CODE>
 twice to push the two values to add onto the FP stack, and then call <CODE>
FloatAdd()</CODE>
 to operate on the FP stack. (See <A HREF="#Math_2.htm_25726"> Adding Two FP Numbers</A>
.)</P>
<P CLASS="figTitle">


Code Display D-2 <A NAME="Math_2.htm_25726">
 </A>
Adding Two FP Numbers</P>
<PRE>/*
 * The following two methods each add two FP numbers and return the result. The 
 * first method is familiar C code. The second example uses the floating point 
 * routines from math.h directly. Note that the C code will be assembled into code 
 * that uses FloatAdd() also, but that this is transparent to the code.
 */</PRE>
<PRE>@method MyProcessClass, MSG_SUM_FLOATS {
    long double			number1, number2, number3;</PRE>
<PRE>    number1 = 1.0;
    number2 = 2.0;</PRE>
<PRE>    number3 = number1 + number2;
    return(number3);
}</PRE>
<PRE>@method MyProcessClass, MSG_SUM_FLOATS_MANUALLY {
    long double			number1, number2, number3;</PRE>
<PRE>    number1 = 1.0;
    number2 = 2.0;</PRE>
<PRE>    FloatPushNumber(&amp;number1);				/* Push number1 onto the FP stack. */
    FloatPushNumber(&amp;number2);				/* Push number2 onto the FP stack. */
    FloatAdd();				/* Add the top two numbers on the FP stack. The
				 * result will be placed on top of the FP stack.*/
    FloatPopNumber(&amp;number3);				/* Pop the result into the number3 variable. */
    return(number3);
}</PRE>
<P>
Several functions have no equivalent C operation. Consult <A HREF="#Math_9.htm_25586"> Direct FP Operations</A>
 for more details on using these functions.

</P>
<P>
Note that although direct comparisons between FP numbers are not allowed, you can use the <CODE>
FloatLt0(), FloatGt0(),</CODE>
 and<CODE>
 FloatEq0()</CODE>
 functions to compare whether the the addition of two FP numbers is gretaer than, less than, or equal to zero.</P>
<HR>
<A NAME="Math_3.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">The Math Library</A>: 1.2 <A HREF="#Math_1.htm">Basic Math Functions</A>: 
<A NAME="Math_3.htm_IX_Math:Functions, Transcendental">
 </A>
Transcendental Functions</H3>
<P>
The Math Library provides an array of transcendental routines that operate on GEOS FP numbers. A transcendental function is one which cannot be derived through algebraic means. Examples of transcendental functions include the trigonometric functions (sine, cosine, etc.) and the logarithmic functions (log, natural log, etc.).
<IMG SRC="Math_3_transcTable.gif">

</P>
<P>
The table above lists the function names and the operations they perform. Typical functions in C are listed alongside. (The basic language of C itself includes no such transcendental functions but almost all compilers include a C math library that does.) As can be seen in the table, several functions have no equivalent C operation. Consult <A HREF="#Math_6.htm_20987"> Float Formats</A>
 for more details on using these functions.</P>
<HR>
<A NAME="Math_4.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">The Math Library</A>: 1.3 <A HREF="#Math_1.htm">Basic Math Functions</A>: 
Random Number Generation</H3>
<PRE><A NAME="Math_4.htm_IX_FloatRandomize()"> </A>FloatRandomize(), <A NAME="IX_FloatRandom()"> </A>FloatRandom(), <A NAME="IX_FloatRandomN()"> </A>FloatRandomN()</PRE>
<P>
The Math Library also provides routines to create random numbers. Using any of these routines requires that you manually push and pop numbers on the FP stack.</P>
<P>
<CODE>
FloatRandomize()</CODE>
 primes the random number generator, in preparation for a call to <CODE>
FloatRandom()</CODE>
 or <CODE>
FloatRandomN()</CODE>
. If <CODE>
FloatRandomize()</CODE>
 is passed the flag RGIF_USE_SEED, the routine must also pass a developer supplied seed.</P>
<P>
<CODE>
FloatRandom()</CODE>
 returns a random value between 0 (inclusive) and 1 (exclusive). The number is placed on top of the FP stack. To assign that value to a variable, use <CODE>
FloatPopNumber()</CODE>
.</P>
<P>
<CODE>
FloatRandomN()</CODE>
 returns a random value between 0 (inclusive) and N (exclusive), where N is an integer. The integer value must be on top of the FP stack. The returned integer is pushed onto the FP stack.To assign that value to a variable, use <CODE>
FloatPopNumber()</CODE>
.</P>
<P CLASS="figTitle">


Code Display D-3 Creating a Random Number</P>
<PRE>/*
 * This method takes a passed seed (passedSeed) and returns a random integer 
 * between 0 and 100.
 */</PRE>
<PRE>@method MyProcessClass, MSG_GET_RANDOM_FLOAT {
    long double			randomX;
	/* Prime the random number generator. */
    FloatRandomize(RGIF_USE_SEED, passedSeed);
    randomX = 100;
    FloatPushNumber(&amp;randomX);
    FloatRandomN();
    FloatPopNumber(&amp;randomX);
    return(randomX);
}</PRE>
<HR>
<A NAME="Math_5.htm"></A>


<H2 CLASS="sectionTitle">
<A HREF="#index.htm">The Math Library</A>: 2 
Conversions to Other Types</H2>
<P>
In many cases, FP numbers will need to be converted to different types for use in different parts of an application. For example, floating point numbers may be involved in a complex function that returns an integer. FP numbers may also need to appear to the user as ASCII text.</P>

<H5 CLASS="HeadingD">
Converting Into Other Floats</H5>
<P>
There are several routines which convert GEOS FP numbers into other float formats, compatible with the C types <CODE>
float</CODE>
 and <CODE>
double</CODE>
. Typically in C, this conversion is accomplished by casting the FP numbers into the other type. It is therefore done automatically for you.</P>
<P>
If you are working in Assembly or you wish to directly pass floats or doubles to C stubs, consult <A HREF="#Math_9.htm_25586"> Direct FP Operations</A>
.</P>


<H5 CLASS="HeadingD">
Converting ASCII to FP Numbers</H5>
<PRE><A NAME="Math_5.htm_IX_FloatAsciiToFloat()"> </A>FloatAsciiToFloat()</PRE>
<P>
<CODE>
FloatAsciiToFloat() </CODE>
converts a number represented in an ASCII text format into a FP number. The routine recognizes two flags:</P>
<UL>
<LI>
FAF_PUSH_RESULT <BR>
<A NAME="Math_5.htm_IX_FAF_PUSH_RESULT">
 </A>
Pushes the result onto the FP stack.</LI>
<LI>
FAF_STORE_NUMBER<BR>
<A NAME="Math_5.htm_IX_FAF_STORE_NUMBER">
 </A>
Stores the result in a specified address.</LI>
</UL>
<P>
The routine must also be passed a pointer to the string to convert, the number of characters in the string to convert (starting at the address) and the buffer to store the FP number if passing FAF_STORE_NUMBER.</P>


<H5 CLASS="HeadingD">
Converting FP Numbers to ASCII</H5>
<PRE><A NAME="Math_5.htm_IX_FloatFloatToAscii()"> </A>FloatFloatToAscii(), <A NAME="IX_FloatFloatToAscii_StdFormat()"> </A>FloatFloatToAscii_StdFormat(), <A NAME="IX_FloatFloatIEEE64ToAscii_StdFormat()"> </A>FloatFloatIEEE64ToAscii_StdFormat()</PRE>
<P>
<CODE>
FloatFloatToAscii() </CODE>
converts an FP number into ASCII text format. The routine must be passed a stack frame, which may be set up by declaring a local variable of type <CODE>
FFA_stackFrame </CODE>
and moving data into the appropriate fields. You should also pass the routine a pointer to a buffer to store the resultant string. This buffer must be declared with a length of either:</P>
<DL>
<DT>
	FLOAT_FLOAT_TO_ASCII_NORMAL_BUF_LEN </DT><DD>
	FLOAT_FLOAT_TO_ASCII_HUGE_BUF_LEN</DD>
</DL>
<P>
The <CODE>
FFA_stackFrame</CODE>
 is a union of two structures: <CODE>
FloatFloatAsciiData</CODE>
 or <CODE>
FloatFloatToDateTimeData</CODE>
. You will want to use the <CODE>
FloatFloatToAsciiData</CODE>
 structure in most cases; <CODE>
FloatFloatToAsciiDateTimeData</CODE>
 is used to format a FP number (representing a date and time) into a date-time format passed in the structure. The routine checks a bit in the structure to see which structure is being passed.</P>


<H4 CLASS="HeadingCApp">
Normal Conversions</H4>
<P>
The<CODE>
 FloatFloatToAsciiData</CODE>
 structure is used most often in formatting FP numbers into ASCII. The structure is rather large and cumbersome to set up. You may wish to use the routine <CODE>
FloatFloatToAscii_StdFormat()</CODE>
 which sets up many of these entries automatically. (<A HREF="#Math_5.htm_42575"> FloatFloatToAsciiData Structure</A>
 lists the entries of the <CODE>
FloatFloatToAsciiData</CODE>
 structure.)</P>
<P CLASS="figTitle">


Code Display D-4 <A NAME="Math_5.htm_42575">
 </A>
FloatFloatToAsciiData Structure</P>
<PRE>typedef struct {</PRE>
<PRE>/*
 * FFA_params stores the entries that the caller must set up.
 */
	FloatFloatToAsciiParams			FFA_params;</PRE>
<PRE>/*
 * These entries store information returned by FloatFloatToAscii() that may be 
 * examined.
 */
	word			FFA_startNumber;
	word			FFA_decimalPoint;
	word			FFA_endNumber;
	word			FFA_numChars;
	word			FFA_startExponent;</PRE>
<PRE>/*
 * The rest of the entries are for internal use only.
 */
	word			FFA_bufSize;
	word			FFA_saveDI;
	word			FFA_numSign;
	byte			FFA_startSigCount;
	byte			FFA_sigCount;
	byte			FFA_noMoreSigInfo;
	byte			FFA_startDecCount;
	byte			FFA_decCount;
	word			FFA_decExponent;
	word			FFA_curExponent;
	byte			FFA_useCommas;
	byte			FFA_charsToComma;
	char			FFA_commaChar;
	char			FFA_decimalChar;
} FloatFloatToAsciiData;</PRE>
<P>
FFA_<CODE>
params</CODE>
 is a structure that stores the following entries of its own:</P>
<DL>
<DT>
<STRONG>
formatFlags</DT><DD>
</STRONG>
Flags specifying the look and feel of the ASCII text format (see below for allowed flags).</DD>
<DT>
<EM>
decimalOffset</DT><DD>
</EM>
Integer which specifies the number of decimal places to shift the output. For example, to display a number in terms of millions, a <CODE>
decimalOffset </CODE>
of -6 shifts the decimal point six places to the left; to display in terms of tenths would require a <CODE>
decimalOffset </CODE>
of 1.</DD>
<DT>
<EM>
totalDigits	</DT><DD>
</EM>
Integer which specifies the maximum number of decimal places (integer and decimal portions) that the FP number may exhibit. The ASCII string is truncated if the length of the string is greater than this number.</DD>
<DT>
<EM>
decimalLimit</DT><DD>
</EM>
Integer which specifies the maximum number of digits to the right of the decimal point. For example a <CODE>
decimalLimit </CODE>
of 2 would print out 123.456789 as 123.46.</DD>
<DT>
<EM>
preNegative</DT><DD>
</EM>
Characters used to precede a negative number, in the format of a null terminated text string.</DD>
<DT>
<EM>
postNegative</DT><DD>
</EM>
Characters used to follow a negative number, in the format of a null terminated text string.</DD>
<DT>
<EM>
prePositive</DT><DD>
</EM>
Characters used to precede a positive number, in the format of a null terminated text string.</DD>
<DT>
<EM>
postPositive</DT><DD>
</EM>
Characters used to follow a positive number, in the format of a null terminated text string.</DD>
<DT>
<EM>
header</EM>
</DT><DD>Characters used to precede the number, in the format of a null terminated text string. For example, a typical header for a currency format might be &quot;$&quot;. </DD>
<DT>
<EM>
trailer</EM>
</DT><DD>Characters used to follow a FP number, in the format of a null terminated text string.</DD>
</DL>
<P>
The <CODE>
formatFlags </CODE>
record is a record of type <CODE>
FloatFloatToAsciiFormatFlags</CODE>
<A NAME="Math_5.htm_IX_FloatFloatToAsciiFormatFlags">
 </A>
 and defines the format of the ASCII output. Set the appropriate flags to get the desired output.</P>
<UL>
<LI>
FFAF_FROM_ADDR<BR>
Set if routine should take the FP number from a specified address, rather than the FP stack. This pointer (*number) should be passed to <CODE>
FloatFloatToAscii()</CODE>
 if this flag is set.</LI>
<LI>
FFAF_DONT_USE_SCIENTIFIC<BR>
Set if the result should not be expressed in scientific notation under any condition. If this is set, the number will always be formatted in fixed format.</LI>
<LI>
FFAF_SCIENTIFIC<BR>
Set if the result should be expressed in scientific notation even if the number can be expressed in fixed point format. For example, the number `2' will be expressed as &quot;2 x 10<EM FIXME_Superscript>
0</EM>
.&quot;</LI>
<LI>
FFAF_PERCENT<BR>
Set if the result should be expressed as a percentage.</LI>
<LI>
FFAF_USE_COMMAS<BR>
Set if the result should use commas to separate thousands.</LI>
<LI>
FFAF_NO_TRAIL_ZEROS<BR>
Set if extraneous zeros to the right of the decimal point should be ignored. For example, &quot;123.67000000&quot; will be reduced to &quot;123.67.&quot;</LI>
<LI>
FFAF_NO_LEAD_ZEROS<BR>
Set to ignore the lead zero for a number less than one. That is, &quot;0.123&quot; is reduced to &quot;.123.&quot;</LI>
<LI>
FFAF_HEADER_PRESENT<BR>
Set if a header is present; this speeds up conversion.</LI>
<LI>
FFAF_TRAILER_PRESENT<BR>
Set if a trailer is present; this speeds up conversion.</LI>
<LI>
FFAF_SIGN_CHAR_TO_FOLLOW_HEADER<BR>
Set if sign character(s) should follow the header.</LI>
<LI>
FFAF_SIGN_CHAR_TO_PRECEDE_TRAILER<BR>
Set if sign character(s) should precede the trailer.</LI>
</UL>
<P>
The rest of the entries in <CODE>
FloatFloatToAsciiData</CODE>
 store information filled in by <CODE>
FloatFloatToAscii()</CODE>
. These entries are described below:</P>
<DL>
<DT>
FFA_<CODE>
startNumber</CODE>
 stores the offset to the start of numeric characters in the ASCII buffer.</DT>
<DT>
FFA_<CODE>
decimalPoint</CODE>
 stores the offset to the decimal point character or zero if no decimal point is present.</DT>
<DT>
FFA_<CODE>
endNumber</CODE>
 stores the offset to the end of the numeric characters in the ASCII buffer.</DT>
<DT>
FFA_<CODE>
numChars</CODE>
 stores the total number of characters in the ASCII buffer (excluding the null terminator). This entry is set to zero if an error is encountered.</DT>
<DT>
FFA_<CODE>
startExponent</CODE>
 stores the offset to the &quot;E&quot; character in the ASCII buffer or zero if no exponent is present. Applications can check this to see if the number was expressed in scientific notation using the `E' format.</DT>


</DL>
<H4 CLASS="HeadingCApp">
<A NAME="Math_5.htm_IX_Time:Math Conversions">
 </A>
<A NAME="Math_5.htm_IX_Date:Math Conversions">
 </A>
Date-Time Conversions</H4>
<P>
<CODE>
FFA_stackFrame</CODE>
 may contain <CODE>
FloatFloatToAsciiDateTimeData</CODE>
 if <CODE>
FloatFloatToAscii()</CODE>
 is being used to convert a FP number into a date-time format. In that case <CODE>
FFA_stackFrame</CODE>
 contains the structure <CODE>
FloatFloatToDateTimeData</CODE>
 instead of <CODE>
FloatFloatToAsciiData</CODE>
. (<CODE>
FFA_stackFrame</CODE>
 is a union.)</P>
<P>
<CODE>
FloatFloatToDateTimeData</CODE>
<A NAME="Math_5.htm_IX_FloatFloatToDateTimeData">
 </A>
 contains one entry, FFA_<CODE>
dateTimeParams</CODE>
. This structure contains several flags which specify how the date-time should be formatted and a number of entries which break down the date-time into its respective parts (year, month, day etc.) If none of these entries are filled in, the date-time is taken from the top of the FP stack.</P>
<P>
Date-times are represented by FP numbers in GEOS. The integer portion represents dates as integers counted from Jan 1, 1900, which is designated as 1. The highest date allowed is 73049 (December 31, 2099).<CODE>
 </CODE>
The fractional portion represents a fraction of the day between midnight (0.000000) and 11:59:59 p.m. (0.999988). This fractional value is derived from the hour, minute and second of the day.</P>
<P CLASS="figTitle">


Code Display D-5 DateTime Parameters</P>
<PRE>typedef struct {
	FloatFloatToDateTimeFlags				FFA_dateTimeFlags;
	word				FFA_year;
	byte				FFA_month;
	byte				FFA_day;
	byte				FFA_weekday;
	byte				FFA_hours;
	byte				FFA_minutes;
	byte				FFA_seconds;
} FloatFloatToDateTimeParams;</PRE>
<PRE>/*
 *	FloatFloatToDateTimeFlags record
 */</PRE>
<PRE>typedef WordFlags FloatFloatToDateTimeFlags;
#define		FFDT_DATE_TIME_OP			0x8000
#define		FFDT_FROM_ADDR			0x4000
#define		FFDT_FORMAT			0x3fff</PRE>
<P>
The flag FFDT_DATE_TIME_OP is set to notify the <CODE>
FloatFloatToAscii()</CODE>
 routine that this operation is a date-time format, not a normal float to ASCII conversion. This flag must be set if you want to convert the FP number into a date-time format using <CODE>
FloatFloatToAscii()</CODE>
.</P>
<P>
FFDT_FROM_ADDR is set if the date-time FP number should not be taken from the FP stack (or passed directly in the <CODE>
FloatFloatToDateTimeParams</CODE>
 structure) but should instead be taken from the address passed in <CODE>
FloatFloatToAscii()</CODE>
.</P>
<P>
FFDT_FORMAT stores the <CODE>
DateTimeFormat</CODE>
 that the routine will use to format the number into a date-time string.</P>
<P>
If the date-time is directly passed in, and not taken from an FP date-time number either at a passed address or the top of an FP stack, <CODE>
FloatFloatToAscii()</CODE>
 looks at the other passed parameters.</P>
<P>
FFA_<CODE>
year</CODE>
 specifies the year. The value must be between 1900 and 2099. This is not a one-based year, as it is when presented as a date-time number.</P>
<P>
FFA_<CODE>
month</CODE>
 is the month of the year, a value between 1 and 12.</P>
<P>
FFA_<CODE>
day</CODE>
 is the day of a month, a value between 1 and 31. </P>
<P>
FFA_<CODE>
hour</CODE>
 specifies the hour of the day, a value between 0 and 23. Zero specifies midnight. </P>
<P>
FFA_<CODE>
minutes</CODE>
 specifies the minute of the hour, a value between 0 and 59.</P>
<P>
FFA_<CODE>
seconds</CODE>
 specifies the second of the minute, a value between 0 and 59.</P>


<H4 CLASS="HeadingCApp">
Using Standard Formats</H4>
<P>
<CODE>
FloatFloatToAscii_StdFormat() </CODE>
uses a pre-set stack frame, eliminating the need to set up the variables of the <CODE>
FloatFloatToAsciiData</CODE>
 structure manually. The only flags recognized are FFAF_FROM_ADDR, FFAF_SCIENTIFIC, FFAF_PERCENT, FFAF_USE_COMMAS, and FFAF_NO_TRAIL_ZEROS. The developer must pass the number of total digits and the number of decimal digits desired. If the flag FFAF_FROM_ADDR is used, a pointer to a FP number (not on the FP stack) must also be passed.</P>
<P>
The standard format sets the following elements of the stack frame to zero: <CODE>
decimalOffset, header, trailer, postNegative, prePositive</CODE>
, and <CODE>
postPositive</CODE>
. The structure element <CODE>
preNegative </CODE>
is set to the minus sign (&quot;<CODE FIXME_CodeTypedArgs>-</CODE>&quot;).</P>
<P>
<CODE>
FloatFloatIEEE64ToAscii_StdFormat()</CODE>
 performs the same operation as <CODE>
FloatFloatToAscii_StdFormat()</CODE>
 except that the FP number is passed (in 64 bit format) and is not taken from the stack. The entire FP number (not just a pointer to it) must be passed. All criteria for <CODE>
FloatFloatToAscii_StdFormat()</CODE>
 applies to this routine, except that the flag FFAF_FROM_ADDR is not used.</P>


<H4 CLASS="HeadingCApp">
Date and Time Routines</H4>
<PRE><A NAME="Math_5.htm_IX_FloatGetDateNumber()"> </A>FloatGetDateNumber(), <A NAME="IX_FloatDateNumberGetYear()"> </A>FloatDateNumberGetYear(), <A NAME="IX_FloatDateNumberGetMonthAndDay()"> </A>FloatDateNumberGetMonthAndDay(), <A NAME="IX_FloatDateNumberGetWeekday()"> </A>FloatDateNumberGetWeekday(), <A NAME="IX_FloatGetTimeNumber("> </A>FloatGetTimeNumber(), <A NAME="IX_FloatTimeNumberGetHour()"> </A>FloatTimeNumberGetHour(), <A NAME="IX_FloatTimeNumberGetMinutes()"> </A>FloatTimeNumberGetMinutes(), <A NAME="IX_FloatTimeNumberGetSeconds()"> </A>FloatTimeNumberGetSeconds()</PRE>
<P>
<CODE>
FloatGetDateNumber()</CODE>
, when passed the month, day, and year, converts the data into an FP &quot;date number&quot; representation. This format represents dates as integers counted from Jan 1, 1900, which is designated as 1. The highest date allowed is 73050 (December 31, 2099).</P>
<P>
<CODE>
FloatDateNumberGetYear(), FloatDateNumberGetMonthAndDay() </CODE>
and<CODE>
 FloatDateNumberGetWeekday() </CODE>
all return the appropriate data, either the year, month and day, or weekday, given an FP &quot;date number&quot; as defined above. All data are returned as integers, not as FP numbers, and the original FP &quot;date number&quot; is popped off of the stack. Years are returned as integers between 1900 and 2099. Month and Days are returned as integers between 1 and 12, and 1 and 31, respectively. Weekdays are returned as integers between 1 and 7, where 1 is Sunday, 2 is Monday, etc. </P>
<P>
<CODE>
FloatGetTimeNumber() </CODE>
when passed hours, minutes, and seconds returns an FP decimal representation between midnight (0.000000) and 11:59:59 p.m. (0.999988). </P>
<P>
<CODE>
FloatTimeNumberGetHour(), FloatTimeNumberGetMinutes() </CODE>
and<CODE>
 FloatTimeNumberGetSeconds() </CODE>
return the appropriate data given an FP &quot;time number&quot; as defined above. The original FP &quot;time number&quot; is popped off of the stack.</P>
<P>
Note that both &quot;date numbers&quot; and &quot;time numbers&quot; can be added to specify a specific point in time. For example, 73050.999988 would specify December 31, 2099, 11:59:59. Since these formats are in FP format, they can be operated on with all standard functions in the FP library. </P>


<H4 CLASS="HeadingCApp">
Miscellaneous Date Time Routines</H4>
<PRE><A NAME="Math_5.htm_IX_FloatGetDaysInMonth()"> </A>FloatGetDaysInMonth(), <A NAME="IX_FloatGetNumDigitsInIntegerPart()"> </A>FloatGetNumDigitsInIntegerPart(), <A NAME="IX_FloatFormatNumber()"> </A>FloatFormatNumber()</PRE>
<P>
<CODE>
FloatGetDaysInMonth()</CODE>
 returns the total number of days in a specific month, for a specific year. The routine must be passed the appropriate month and year.</P>
<P>
<CODE>
FloatGetNumDigitsInIntegerPart()</CODE>
 returns the number of digits in the integer portion of an FP number. Numbers between zero and one will return one as the number of digits.</P>
<PRE>FloatStringGetDateNumber(), FloatStringGetTimeNumber()</PRE>

<HR>
<A NAME="Math_6.htm"></A>


<H2 CLASS="sectionTitle">
<A HREF="#index.htm">The Math Library</A>: 3 
<A NAME="Math_6.htm_20987">
 </A>
<A NAME="Math_6.htm_IX_Floating-Point Formats;Format:Floating-Point">
 </A>
Float Formats</H2>
<P>
FP numbers can be displayed in many ways. For example, as we have seen, an FP number may actually represent a date-time. When we display the FP number 366.0000, we may want to show it (in text) as &quot;Jan 1, 1901.&quot; The Math Library has a number of system-defined formats for your use. You may also allow users to define their own formats with the Float Format controller.</P>
<P>
The underlying structures and routines to use and create float format options are explained in the next section. In most cases, however, the simple inclusion of a Float Format controller (of <CODE>
FloatFormatClass</CODE>
) provides all of the UI and functionality to create and apply formats to FP numbers within text objects.</P>
<P CLASS="subsectionLink">
<A HREF="#Math_7.htm">System-defined Formats</A></P>
<P CLASS="subsectionLink">
<A HREF="#Math_8.htm">User-defined Formats</A></P>
<HR>
<A NAME="Math_7.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">The Math Library</A>: 3.1 <A HREF="#Math_6.htm">Float Formats</A>: 
System-defined Formats</H3>
<P>
A system-defined FP format is stored within a <A NAME="Math_7.htm_IX_FormatParams">
 </A>
<CODE>
FormatParams</CODE>
 structure. This structure defines whether the FP number is a number to be converted into numerical text or a date-time. These format parameters are stored within arrays managed by the format control code. </P>
<P CLASS="figTitle">


Code Display D-6 System-defined Float Formats</P>
<PRE>/*
 * System-defined float formats are stored in an array that is maintained and 
 * accessed by the float controller code. Each element is made up of a 
 * FormatParams structure.
 */</PRE>
<PRE>typedef struct {
	/*
	 * The FloatFloatToAsciiParams_Union stores either a
	 * FloatFloatToAsciiParams structure if the number is a `pure' FP number,
	 * or a FloatFloatToDateTimeParams structure if the number is a date-time. 
	 * In this way, it is essentially the same as the FFA_stackFrame discussed
	 * earlier.
	 */
	FloatFloatToAsciiParams_Union				FP_params;</PRE>
<PRE>	/*
	 * FP_formatName stores the name of this formatting option that will be 
	 * displayed in the float controller's dynamic list. This name is loaded 
	 * from the optr given in FP_nameHan and FP_nameOff.(The table where these 
	 * strings are kept is within a localizable resource and therefore will
	 * have different text under different country setups.)
	 */
	char				FP_formatName[FORMAT_NAME_LENGTH+1];
	word				FP_nameHan;		/* MemHandle */
	word				FP_nameOff;		/* ChunkHandle */</PRE>
<PRE>	/*
	 * FP_listEntryNum stores the zero-based position of this FormatParams 
	 * entry within the table.
	 */
	word				FP_listEntryNum;</PRE>
<PRE>	/*
	 * FP_signature is an internal field used for error-checking.
	 */
	word				FP_signature;
} FormatParams;</PRE>
<P>
An application will never need to access this table of formats directly. GEOS contains several routines (in <STRONG CLASS="fileName">
math.goh</STRONG>
) that can access this table and add, delete and modify table entries. Usually, it is easiest to include a Float Format controller in your application if you intend to allow the user to change float formats with these routines.</P>
<P>
There are many system-defined float formatting options. These formats are identified by <A NAME="Math_7.htm_IX_FormatIdType">
 </A>
<CODE>
FormatIdType</CODE>
 enumerations. Each type corresponds to a <CODE>
FormatParams</CODE>
 structure. </P>
<P>
Each <CODE>
FormatIdType</CODE>
 enumeration is a direct offset into the float format lookup table. To distinguish between system-defined and user-defined formats, the high bit of a <CODE>
FormatIdType</CODE>
 is set to indicate that the format is system-defined. Thus, 8000h refers to the first system-defined format, 8000h + (size(<CODE>
FormatParams</CODE>
)) refers to the second system-defined format, etc.</P>
<P>
The format strings themselves are stored within a localizable resource, so that they may appear in a manner relevant to the particular country involved. For example, an FP number of 12.0 using the <CODE>
FormatIdType</CODE>
 FORMAT_ID_CURRENCY might appear in the U.S. as $12.00, but will appear as £12.00 in Great Britain.</P>
<P CLASS="figTitle">


Code Display D-7 Float Format IDs</P>
<PRE>typedef	enum {
	FORMAT_ID_GENERAL	 	 	 		= 0x8000,
	FORMAT_ID_FIXED		 	 		= 0x8061,
	FORMAT_ID_FIXED_WITH_COMMAS	 	 			= 0x80c2,
	FORMAT_ID_FIXED_INTEGER	 				= 0x8123,
	FORMAT_ID_CURRENCY		 	 		= 0x8184,
	FORMAT_ID_CURRENCY_WITH_COMMAS 	 				= 0x81e5,
	FORMAT_ID_CURRENCY_INTEGER 	 				= 0x8246,
	FORMAT_ID_PERCENTAGE 	 	 			= 0x82a7,
	FORMAT_ID_PERCENTAGE_INTEGER 	 				= 0x8308,
	FORMAT_ID_THOUSANDS 	 	 			= 0x8369,
	FORMAT_ID_MILLIONS 	 	 			= 0x83ca,
	FORMAT_ID_SCIENTIFIC 	 	 			= 0x842b,</PRE>
<PRE>	FORMAT_ID_DATE_LONG 	 	 			= 0x848c,
	FORMAT_ID_DATE_LONG_CONDENSED 	 				= 0x84ed,
	FORMAT_ID_DATE_LONG_NO_WKDAY 					= 0x854e,
	FORMAT_ID_DATE_LONG_NO_WKDAY_CONDENSED 					= 0x85af,
	FORMAT_ID_DATE_SHORT 	 	 			= 0x8610,
	FORMAT_ID_DATE_SHORT_ZERO_PADDED 					= 0x8671,
	FORMAT_ID_DATE_LONG_MD 	 	 			= 0x86d2,
	FORMAT_ID_DATE_LONG_MD_NO_WKDAY 					= 0x8733,
	FORMAT_ID_DATE_SHORT_MD 					= 0x8794,
	FORMAT_ID_DATE_LONG_MY 	 	 			= 0x87f5,
	FORMAT_ID_DATE_SHORT_MY 	 				= 0x8856,
	FORMAT_ID_DATE_YEAR 	 	 			= 0x88b7,
	FORMAT_ID_DATE_MONTH 	 	 			= 0x8918,
	FORMAT_ID_DATE_DAY 	 				= 0x8979,
	FORMAT_ID_DATE_WEEKDAY 	 				= 0x89da,
	FORMAT_ID_TIME_HMS			 		= 0x8a3b,
	FORMAT_ID_TIME_HM					= 0x8a9c,
	FORMAT_ID_TIME_H					= 0x8afd,
	FORMAT_ID_TIME_MS			 		= 0x8b5e,
	FORMAT_ID_TIME_HMS_24HR		 			= 0x8bbf,
	FORMAT_ID_TIME_HM_24HR		 			= 0x8c20,</PRE>
<PRE>	FORMAT_ID_INDETERMINATE 	 				= 0xffff
} FormatIdType;</PRE>
<HR>
<A NAME="Math_8.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">The Math Library</A>: 3.2 <A HREF="#Math_6.htm">Float Formats</A>: 
User-defined Formats</H3>
<P>
Users may also design their own float formatting options. These user-defined formats are stored in <A NAME="Math_8.htm_IX_FormatEntry">
 </A>
<CODE>
FormatEntry</CODE>
 structures. The array of these user-defined formats is kept separate from the system-defined formats. (user-defined formats are stored within their own VM block).</P>
<P>
User-defined <CODE>
FormatIdType</CODE>
 enums do not have the high bit (8000h) set in order to distinguish them from system-defined <CODE>
FormatIdType</CODE>
 enums.</P>
<P CLASS="figTitle">


Code Display D-8 User-defined Formats</P>
<PRE>/*
 * User-defined formats are stored in a VM block that is created and maintained by 
 * the float controller code. As each new format is added, space is made for a 
 * FormatEntry structure. As formats are deleted, their entry's FE_used field is 
 * set to zero to indicate that the entry is free for new formats to overwrite.
 */</PRE>
<PRE>typedef struct {</PRE>
<PRE>	/*
	 * Each FormatEntry contains a corresponding FormatParams structure.
	 */
	FormatParams 		FE_params;</PRE>
<PRE>	/*
	 * FE_listEntryNumber is the zero-based position of the format counting 
	 * both previous user-defined formats and system-defined formats. For 
	 * example, if there are 10 system-defined formats, the first user-defined
	 * format will have a FE_listEntryNumber of 10 (because positions are 
	 * zero-based).
	 */
	word		FE_listEntryNumber;</PRE>
<PRE>	/*
	 * FE_used, if non-zero, indicates that this entry within the user-defined 
	 * list is currently in use. If FE_used is zero, then this entry position 
	 * may be used to add a new user-defined entry without increasing the size
	 * of the VM block.
	 */
	byte		FE_used;</PRE>
<PRE>	/*
	 * FE_sig is an error-checking field used internally.
	 */
	word		FE_sig;
} FormatEntry;</PRE>
<HR>
<A NAME="Math_9.htm"></A>


<H2 CLASS="sectionTitle">
<A HREF="#index.htm">The Math Library</A>: 4 
<A NAME="Math_9.htm_25586">
 </A>
Direct FP Operations</H2>
<P>
The Math Library allows your application to use floating point (FP) numbers. C Developers will find little reason to make direct calls to functions in the Math Library as most of this functionality is taken care of for you in the C environment. (An exception is conversions from FP numbers to ASCII text characters and use of special date-time routines.) Assembly developers, however, will find direct use of the functions and structures in the Math Library essential.</P>
<P>
The latter half of this chapter (from this point on) is provided for Assembly developers who need more complete information about the intricacies of the Math Library. Much of this information may also be useful for C developers who wish to make direct calls to the functions in this library for optimization purposes.</P>
<P CLASS="subsectionLink">
<A HREF="#Math_a.htm">Floating Point Numbers</A></P>
<P CLASS="subsectionLink">
<A HREF="#Math_b.htm">The Floating Point Stack</A></P>
<P CLASS="subsectionLink">
<A HREF="#Math_c.htm">Floating Point Math Routines</A></P>
<HR>
<A NAME="Math_a.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">The Math Library</A>: 4.1 <A HREF="#Math_9.htm">Direct FP Operations</A>: 
<A NAME="Math_a.htm_IX_Numbers:Floating-Point">
 </A>
Floating Point Numbers</H3>
<P>
The Math Library defines floating point numbers by using binary point representation. In this format the bit in the zeros place is multiplied by 20, the bit in the minus-ones place is multiplied by 2-1, etc. The exponent is in base 2. For example, the Binary Point representation for 5 is:.
<IMG SRC="Math_a_binaryPoint.gif">

</P>
<P>
Floating Point Numbers in GEOS follow the IEEE 754 standard used by Intel. In this format a floating point number is represented in an 80 bit (5 word) format. (In C, this type is known as a <CODE>
long</CODE>
 <CODE>
double</CODE>
.) This format specifies that the 80 bits contain:
<IMG SRC="Math_a_80bit.gif">

</P>
<UL>
<LI>
a 1 bit sign (the most significant bit).</LI>
<LI>
a 15 bit exponent (0000h to 7FFFh).</LI>
<LI>
a 64 bit mantissa.</LI>
</UL>
<P>
The 15 bit exponent is biased by 3FFFh, so that an exponent of 1 would be represented by 4000h, and an exponent of -1 would be represented by 3FFEh. This produces a hexadecimal range for the exponent of  4000h, or a decimal range of  4932.</P>
<P>
Infinity is represented by 7FFFh in the exponent and 1 followed by 63 zeros in the mantissa. Therefore, all exponent bits are set to 1. (Negative infinity is the same except that the sign bit is also set to 1).</P>
<P>
Zero is a special case in which all 80 bits-- sign, exponent, and mantissa--are set to zero. </P>
<P>
The mantissa is normalized so that the most significant bit is always 1 (except when the FP number is zero). The binary point follows this 1 bit. This produces a precision of approximately 19 decimal places, which is adequate for most needs. This most significant bit is not &quot;assumed away&quot;; it is always present in the mantissa.
<IMG SRC="Math_a_floatPoint.gif">



</P>
<P>
Note that in most uses, the use of binary point representation is transparent to the application. </P>
<HR>
<A NAME="Math_b.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">The Math Library</A>: 4.2 <A HREF="#Math_9.htm">Direct FP Operations</A>: 
<A NAME="Math_b.htm_IX_Stack:Floating-Point">
 </A>
The Floating Point Stack</H3>
<P>
Floating Point (FP) numbers are placed and manipulated on an FP stack. Numbers can be rearranged, operated on, and removed from this stack through pushes, pops, and the use of special routines.</P>

<H4 CLASS="HeadingCApp">
Initialization of the FP Stack</H4>
<PRE><A NAME="Math_b.htm_IX_FloatInit()"> </A>FloatInit(), <A NAME="IX_FloatExit()"> </A>FloatExit()</PRE>
<P>
Before performing any floating point operations, a thread needs to call <CODE>
FloatInit()</CODE>
 to create and initialize an FP stack. Each thread using floats must have its own unique FP stack. This call to <CODE>
FloatInit()</CODE>
 is automatically performed by any application that includes the Math Library.</P>
<P>
<CODE>
FloatInit()</CODE>
 creates a swapable block of memory for the thread, initializes various stack pointers, and stores the handle for the block in the thread's data structure. <CODE>
FloatInit()</CODE>
 must be passed the size of the stack to create (in bytes) and the type of stack (<CODE>
FloatStackType</CODE>
) to create. </P>
<P>
The default FP stack holds 25 FP elements (250 bytes). An FP stack must be able to hold at least 5 FP elements.</P>
<P>
The default floating point stack is FLOAT_STACK_GROW which instructs the system to increase the size of the stack whenever its bounds are reached. This is done automatically.</P>
<P>
Other <CODE>
FloatStackType</CODE>
 types are FLOAT_STACK_WRAP, which drops the FP numbers at the low end of the stack (effectively wrapping over that end) and FLOAT_STACK_ERROR which signals an error when the stack limit has been reached.</P>
<P>
<CODE>
FloatExit()</CODE>
 detaches the floating point stack for the current thread and frees its memory. <CODE>
FloatExit()</CODE>
 only frees the FP stack associated with the current thread; other FP stacks in other threads remain unaffected. As is the case with <CODE>
FloatInit()</CODE>
, the call to <CODE>
FloatExit()</CODE>
 is automatically performed by any application that includes the Math Library.</P>
<P>
If <CODE>
FloatInit() </CODE>
is called twice before calling <CODE>
FloatExit()</CODE>
, the data on the original floating point stack will be lost.</P>


<H4 CLASS="HeadingCApp">
Pushing and Popping on the FP Stack</H4>
<PRE><A NAME="Math_b.htm_IX_FloatPushNumber()"> </A>FloatPushNumber(), <A NAME="IX_FloatPopNumber()"> </A>FloatPopNumber(), <A NAME="IX_FloatDepth()"> </A>FloatDepth()</PRE>
<P>
<CODE>
FloatPushNumber() </CODE>
pushes an FP number onto the top of the FP stack for the current thread from a passed buffer. The number must be already set up in 80 bit, FP format. The routine must be passed the pointer to the buffer storing the number.</P>
<P>
Similarly, <CODE>
FloatPopNumber()</CODE>
 pops an FP number from the top of the FP stack for the current thread into a passed buffer.</P>
<P>
<CODE>
FloatDepth() </CODE>
returns the number of FP numbers currently in place on the stack.</P>
<P>
Note: For clarity in diagrams within this chapter, stack locations will be numbered in order from the top position of the stack, S1 being first, S2 being second, etc. Variables will be numbered in the order they are pushed onto the stack, so that if X1, X2, and X3 are pushed onto the stack, the format illustrated below will result.
<IMG SRC="Math_b_push.gif">

</P>


<H4 CLASS="HeadingCApp">
FP Stack Manipulation</H4>
<PRE><A NAME="Math_b.htm_IX_FloatRoll()"> </A>FloatRoll(), <A NAME="IX_FloatRollDown()"> </A>FloatRollDown(), <A NAME="IX_FloatRot()"> </A>FloatRot(), <A NAME="IX_FloatSwap()"> </A>FloatSwap()</PRE>
<P>
Besides basic pushing and popping, the Float Library also includes many other routines which manage FP numbers on the stack. Unless otherwise specified, an operation that pushes, pops, or extracts an FP number on the stack affects all other FP numbers below the position of the operation by shifting their location in the stack either up or down, in standard stack fashion. </P>
<P>
<CODE>
FloatRoll() </CODE>
pushes a selected FP number (S<EM>
X</EM>
) onto the top of the stack (S1), removing it from location SX in the process. <CODE>
FloatRoll() </CODE>
passed with a value of 3 would move the FP number in S3 onto the top of the stack, pushing the stack in the process. All FP numbers below the extracted number remain unaffected by this routine.
<IMG SRC="Math_b_roll.gif">

</P>
<P>
<CODE>
FloatRollDown() </CODE>
performs the inverse operation of <CODE>
FloatRoll()</CODE>
. popping the top stack value (S1) into the specified location on the stack (S<EM>
X</EM>
). <CODE>
FloatRollDown() </CODE>
passed with a value of 3 would move the FP number in S1 into location S3, shifting the stack in the process.
<IMG SRC="Math_b_rolldown.gif">

</P>
<P>
Both of these routines must be passed a stack location to move to or from.</P>
<P>
<CODE>
FloatRot() </CODE>
rotates the top three numbers on the stack, placing S3 onto the top of the stack. This is equivalent to a <CODE>
FloatRoll() </CODE>
passed with a value of 3. 
<IMG SRC="Math_b_rot.gif">

</P>
<P>
<CODE>
FloatSwap() </CODE>
exchanges S1 and S2.
<IMG SRC="Math_b_swap.gif">

</P>
<P>
Repetitious applications of these routines will return the stack to its former state.</P>


<H4 CLASS="HeadingCApp">
Copying and Deleting Numbers on the FP Stack</H4>
<PRE><A NAME="Math_b.htm_IX_FloatPick()"> </A>FloatPick(), <A NAME="IX_FloatOver()"> </A>FloatOver(), <A NAME="IX_FloatDrop()"> </A>FloatDrop(), <A NAME="IX_FloatDup()"> </A>FloatDup()</PRE>
<P>
<CODE>
FloatPick() </CODE>
copies the contents of S<EM>
X </EM>
and pushes that value onto the FP stack. The entire stack is pushed in the process. <CODE>
FloatPick() </CODE>
passed with a value of 3 would copy the contents of S3 onto the FP stack.
<IMG SRC="Math_b_drop.gif">

</P>
<P>
<CODE>
FloatOver() </CODE>
copies S2 to the top of the stack, equivalent to a <CODE>
FloatPick() </CODE>
passed with a value of 2.</P>
<P>
<CODE>
FloatDrop()</CODE>
 drops (pops) the top number (S1) off the FP stack. This routine is different than <CODE>
FloatPopNumber() </CODE>
because the routine does not place the popped number into a memory address, and is therefore much faster.
<IMG SRC="Math_b_pick.gif">

</P>
<P>
<CODE>
FloatDup()</CODE>
 duplicates the value at S1, pushing it onto the top of the stack. The stack is pushed in the process.
<IMG SRC="Math_b_dup.gif">

</P>


<H4 CLASS="HeadingCApp">
Comparing Numbers on the FP Stack</H4>
<PRE><A NAME="Math_b.htm_IX_FloatComp()"> </A>FloatComp(), <A NAME="IX_FloatCompESDI()"> </A>FloatCompESDI(), <A NAME="IX_FloatCompAndDrop()"> </A>FloatCompAndDrop()</PRE>
<P>
These routines essentially perform the same operation as the Assembly command <CODE>
cmp</CODE>
. <CODE>
FloatComp()</CODE>
 performs a compare of the top two FP numbers (S1 and S2) and sets the appropriate flags in the flags register. The two FP numbers remain on the stack.<CODE>
 FloatCompESDI() </CODE>
compares the contents of <CODE>
es:[di]</CODE>
 with the value in S1 (and the FP number in S1 remains on the stack). <CODE>
FloatCompAndDrop() </CODE>
performs a compare of S1 and S2 and drops both from the FP stack.</P>


<H4 CLASS="HeadingCApp">
Recovery of the FP Stack</H4>
<PRE><A NAME="Math_b.htm_IX_FloatGetStackPointer()"> </A>FloatGetStackPointer(), <A NAME="IX_FloatSetStackPointer()"> </A>FloatSetStackPointer()</PRE>
<P>
<CODE>
FloatGetStackPointer()</CODE>
 returns the current stack pointer value of the FP stack. <CODE>
FloatSetStackPointer() </CODE>
sets the stack pointer to a previous position. This routine must be passed a value that is greater than or equal to the current value of the stack pointer. (I.e. you must be throwing something, or nothing, away.)</P>
<P>
These routines may be useful before the execution of involved routines that may push many numbers onto the stack. If an unrecoverable error is encountered, the programmer need not pop the intermediate values off the stack to return to the previous stack configuration. Only the stack pointer is saved; the state of the stack is not. If any numbers below the stack pointer are popped or altered, <CODE>
FloatSetStackPointer()</CODE>
 will not recover the previous state of the stack. </P>

<HR>
<A NAME="Math_c.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">The Math Library</A>: 4.3 <A HREF="#Math_9.htm">Direct FP Operations</A>: 
Floating Point Math Routines</H3>
<P>
The Float Library provides a number of routines to modify data on the FP stack. These routines can be categorized in several major groups:</P>
<UL>
<LI>
Constant Routines</LI>
<LI>
Math Routines</LI>
<LI>
Transcendental Routines</LI>
<LI>
Conversion Routines</LI>
<LI>
Date and Time Routines</LI>
</UL>

<H4 CLASS="HeadingCApp">
<A NAME="Math_c.htm_IX_Constants:Floating-Point;Constants:Routines;Routines:Floating-Point Routines">
 </A>
Constant Routines</H4>
<PRE>Float0(), FloatPoint5(), Float1(), FloatMinusPoint5(), FloatMinus1(),Float2(), Float5(), Float10(), Float3600(), Float16384(), Float86400()</PRE>
<PRE>FloatPi(), FloatPiDiv2(),FloatLg10(), FloatLn2(), FloatLn10(), FloatSqrt2()</PRE>
<P>
The Constant Routines provide a means of quickly obtaining an often used number or an often used operation with a constant operand. Each of these functions pushes the constant FP value onto the top of the FP stack. (For example, <CODE>
FloatMinusPoint5()</CODE>
 pushes -.5 onto the FP stack.)</P>
<P>
<CODE>
FloatPi()</CODE>
, <CODE>
FloatPiDiv2()</CODE>
, <CODE>
FloatLg10()</CODE>
, <CODE>
FloatLn2()</CODE>
, <CODE>
FloatLn10()</CODE>
, and<CODE>
 FloatSqrt2() </CODE>
each push the specified transcendental constant onto the FP stack: p,p/2, the log of 10, the natural log of 2, the natural log of 10,and the square root of 2, respectively. (See also Transcendental Routines.)</P>


<H4 CLASS="HeadingCApp">
<A NAME="Math_c.htm_IX_Constants:Floating-Point;Constants:Operands;Operands:Floating-Point Routines">
 </A>
Constant Operands</H4>
<PRE>FloatMultiply2(), FloatMultiply10(), FloatDivide2(), FloatDivide10(), Float10ToTheX()</PRE>
<P>
<CODE>
FloatMultiply2(), FloatMultiply10(), FloatDivide2(), FloatDivide10() </CODE>
perform the specified operations on the contents of S1, either multiplying or dividing the contents of S1 by 2 or 10, and push the result onto the FP stack. The original value in S1 is popped off of the stack.</P>
<P>
<CODE>
Float10ToTheX() </CODE>
pushes 10 to a passed exponent onto the FP stack.</P>


<H4 CLASS="HeadingCApp">
<A NAME="Math_c.htm_IX_Math:Algebraic Routines;Routines:Floating-Point Algebra">
 </A>
Algebraic Routines</H4>
<PRE>FloatAbs(), FloatAdd(), FloatSub(), FloatDivide(), FloatMultiply(), FloatDIV(), FloatMod(),FloatFactorial(), FloatNegate(), FloatInverse()</PRE>
<P>
The Math Routines perform various operations on numbers already placed on the FP stack. All of the following routines pop the operated numbers off of the stack and push the result onto S1.</P>
<P>
<CODE>
FloatAdd() </CODE>
adds the contents of S1 and S2, and pushes the result onto the top of the FP stack. The original values are popped off the stack.</P>
<P>
<CODE>
FloatSub() </CODE>
subtracts<CODE>
 </CODE>
the contents of S1 from the contents of S2, and pushes the result onto the top of the FP stack. The original values are popped off the stack.</P>
<P>
Note that, in general, numbers will be pushed onto the stack in the order they would normally be operated on. For example, to obtain X1-X2, the programmer would first push X1, then X2, and call <CODE>
FloatSub</CODE>
, as in the following diagram:
<IMG SRC="Math_c_sub.gif">

</P>
<P>
since X1 would now be in location S2, while X2 is in location S1.</P>
<P>
<CODE>
FloatMultiply() </CODE>
multiplies the contents of S1 and S2 and pushes the result onto the top of the FP stack. The original values are popped off the stack.</P>
<P>
<CODE>
FloatDivide() </CODE>
divides the contents of S2 by the contents of S1 and pushes the result onto the top of the FP stack. The original values are popped off the stack.</P>
<P>
<CODE>
FloatDIV() </CODE>
performs a <CODE>
FloatDivide()</CODE>
, truncating the fractional portion of the number and returning only the integer result. The original values are popped off the stack.</P>
<P>
<CODE>
FloatMod() </CODE>
pushes S2 mod S1 (the remainder of <CODE>
FloatDivide()</CODE>
) onto the top of the FP stack. The original values are popped off the stack.</P>
<P>
<CODE>
FloatAbs() </CODE>
pushes the absolute value of S1 onto the top of the FP stack. The original value is popped off the stack.</P>
<P>
<CODE>
FloatFactorial() </CODE>
pushes the factorial (x!) of the value in S1 onto the top of the FP stack. The original value is popped off the stack. </P>
<P>
<CODE>
FloatNegate() </CODE>
negates the value in S1 and pushes the result onto the top of the FP stack. The<CODE>
 </CODE>
original value is popped off the stack. </P>
<P>
<CODE>
FloatInverse() </CODE>
pushes the inverse of the value in S1 (-S1) onto the top of the FP stack. The original value is popped off of the stack.</P>


<H4 CLASS="HeadingCApp">
<A NAME="Math_c.htm_IX_Math:Comparison Routines;Routines:Floating-Point Comparison">
 </A>
Comparison Routines</H4>
<PRE><CODE>FloatMax(), FloatMin(), FloatLt0(), FloatEq0(), FloatGt0()</CODE></PRE>
<P>
<CODE>
FloatMax() </CODE>
performs a compare of the FP numbers in S1 and S2 and, if necessary, swaps the greater number into S1.</P>
<P>
<CODE>
FloatMin() </CODE>
performs a compare of the FP numbers in S1 and S2 and, if necessary, swaps the lesser number into S1.</P>
<P>
<CODE>
FloatLt0(), FloatEq0(), FloatGt0() </CODE>
check whether the FP number in S1 is less than zero, equal to zero, or greater than zero. The carry bit is set to TRUE if the relationship is true. The original value is popped off of the stack. </P>


<H4 CLASS="HeadingCApp">
<A NAME="Math_c.htm_IX_Math:Fractions and Integers;Routines:Floating-Point Fractions and Integers">
 </A>
Fractional and Integral Routines</H4>
<PRE>FloatFrac(), FloatTrunc(), FloatInt(), FloatIntFrac(), FloatRound()</PRE>
<P>
<CODE>
FloatFrac() </CODE>
pushes the fractional portion of S1 onto the FP stack. The original value is popped off of the stack. </P>
<P>
<CODE>
FloatTrunc() </CODE>
pushes the integral portion of the contents of S1 onto the FP stack. This amounts to a rounding of the FP number toward zero, so that <CODE>
FloatTrunc() </CODE>
performed on -7.8 would return -7. The original value is popped off the stack. </P>
<P>
<CODE>
FloatInt() </CODE>
rounds S1 down to its integral component, so that <CODE>
FloatInt() </CODE>
performed on -7.8 would return -8. Note that for negative numbers, this is different from <CODE>
FloatTrunc()</CODE>
. The original value is popped off the stack.</P>
<P>
<CODE>
FloatIntFrac() </CODE>
splits a number into its fractional and integral parts, with the fractional part in S1 and the integral part in S2. The original value is popped off the stack.</P>
<P>
<CODE>
FloatRound() </CODE>
rounds S1 to a given number of decimal places. <CODE>
FloatRound() </CODE>
passed with zero as an argument rounds S1 to the nearest integer, rounding up if greater than or equal to .5, rounding down if less than .5</P>


<H4 CLASS="HeadingCApp">
<A NAME="Math_c.htm_IX_Math:Random Numbers;Routines:Random Numbers">
 </A>
Routines that Return Random Values</H4>
<PRE>FloatRandom(), FloatRandomN(), FloatRandomize()</PRE>
<P>
<CODE>
FloatRandom() </CODE>
pushes a random number between 0 (inclusive) and 1 (exclusive) onto the stack. </P>
<P>
<CODE>
FloatRandomN() </CODE>
pushes a random integer between 0 (inclusive) and N (exclusive) onto the stack. </P>
<P>
<CODE>
FloatRandomize()</CODE>
 primes the random number generator. This routine expects a seed and some <CODE>
RandomGenInitFlags</CODE>
. If the flag RGIF_USE_SEED is passed, then a developer-supplied seed will be used. Otherwise, a seed based on the timer clock will be used. </P>
<P>
<CODE>
FloatRandomize() </CODE>
should always be called before any of the <CODE>
FloatRandom() </CODE>
routines to ensure a high degree of randomness.</P>
<P>
The random number generation method uses the linear congruential method, an algorithm which ensures a high degree of randomness in the computation method. </P>


<H4 CLASS="HeadingCApp">
Transcendental Functions</H4>
<P>
Transcendental functions are functions that cannot be constructed using normal arithmetic routines. Care must be taken with the following routines to ensure that they are operating on a valid range of values. Otherwise, the routines will return an error. </P>

<H5 CLASS="HeadingD">
<A NAME="Math_c.htm_IX_Math:Trigonometric Routines;Routines:Floating-Point Trigonometry">
 </A>
Trigonometric Routines</H5>
<PRE>FloatSin(), FloatCos(), FloatTan(), FloatArcSin(), FloatArcCos(), FloatArcTan(), FloatArcTan2(), FloatSinh(), FloatCosh(), FloatTanh(), FloatArcSinh(), FloatArcCosh(), FloatArcTanh()</PRE>
<P>
<CODE>
FloatSin(), FloatCos()</CODE>
, and<CODE>
 FloatTan() </CODE>
perform the given operation on the contents of S1, pushing the result onto the FP stack. S1 must be expressed in radians. The original value is popped off of the stack.</P>
<P>
<CODE>
FloatArcSin(), FloatArcCos()</CODE>
, and <CODE>
FloatArcTan() </CODE>
perform<CODE>
 </CODE>
the given inverse operation on S1, pushing the result onto the FP stack. The result is given in radians. The original value is popped off of the stack.</P>
<P>
<CODE>
FloatArcTan2() </CODE>
calculates the arc tangent given cartesian coordinates <EM>
x</EM>
 and <EM>
y</EM>
. The arctangent is calculated from the x-axis through the origin to the given point. The value returned is expressed in radians, between -p (exclusive) and +p (inclusive). The original values are popped off of the stack.</P>
<P>
<CODE>
FloatSinh(), FloatCosh()</CODE>
, and <CODE>
FloatTanh() </CODE>
perform the given hyperbolic operations on S1, pushing the result onto the FP stack. The original value is popped off of the stack.</P>
<P>
<CODE>
FloatArcSinh(), FloatArcCosh()</CODE>
, and<CODE>
 FloatArcTanh() </CODE>
perform the given inverse hyperbolic operations on S1, pushing the result onto the FP stack. The original value is popped off of the stack.</P>


<H5 CLASS="HeadingD">
<A NAME="Math_c.htm_IX_Math:Exponential Routines;Routines:Floating-Point Exponents">
 </A>
Exponential Routines</H5>
<PRE>FloatExp(), FloatExponential(), FloatLg(), FloatLog(), FloatLn(), FloatLn1plusX(), FloatSqr(), FloatSqrt()</PRE>
<P>
<CODE>
FloatExp() </CODE>
performs the exponentiation of <EM>
e</EM>
 to the power of S1, pushing the result onto the FP stack. The original value is popped off of the stack.</P>
<P>
<CODE>
FloatExponential() </CODE>
performs the exponentiation of S2 to the power of S1, pushing the result onto the FP stack. The original values are popped off of the stack.</P>
<P>
<CODE>
FloatLg()</CODE>
 performs the logarithm to the base 2 on S1, pushing the result onto the FP stack. The original value is popped off of the stack.</P>
<P>
<CODE>
FloatLog()</CODE>
 performs the logarithm to the base 10 on S1. The original value is popped off the stack.</P>
<P>
<CODE>
FloatLn() </CODE>
performs the natural logarithm (log base <EM>
e</EM>
) on S1. The original value is popped off the stack.</P>
<P>
<CODE>
FloatLn1plusX() </CODE>
performs the natural log of (1 + S1). The original value is popped off the stack.</P>
<P>
<CODE>
FloatSqr() </CODE>
performs the square of S1, pushing<CODE>
 </CODE>
the result onto the FP stack. The original value is popped off the stack.</P>
<P>
<CODE>
FloatSqrt() </CODE>
performs the square root of S1, pushing the result onto the FP stack. The original value is popped off the stack.</P>



<H4 CLASS="HeadingCApp">
<A NAME="Math_c.htm_IX_Math:Conversion Routines;Routines:Floating-Point Conversion">
 </A>
Conversion Routines</H4>
<P>
At some point 80-bit FP numbers may need to be converted into different formats, or you may need to convert these differently formatted numbers into a floating point representation. The Math Library provides for this contingency. </P>

<H5 CLASS="HeadingD">
Conversions Between Integers and FP Numbers</H5>
<PRE>FloatDwordToFloat(), FloatWordToFloat(), FloatFloatToDword()</PRE>
<P>
<CODE>
FloatDwordToFloat() </CODE>
converts a passed double-word signed integer into a floating point number, and pushes that number onto the FP stack. </P>
<P>
<CODE>
FloatWordToFloat() </CODE>
converts<CODE>
 </CODE>
a passed word signed integer into a floating point number, and pushes that number onto the FP stack.</P>
<P>
<CODE>
FloatFloatToDword() </CODE>
converts the FP number in S1 into a double-word signed integer. The FP number is converted into an integer by rounding the FP number to zero decimal places.</P>
<P>
You can convert a FP number into a word value by using <CODE>
FloatFloatToDword()</CODE>
 and just using the low word.</P>


<H5 CLASS="HeadingD">
Conversions Between 80 bit FP Numbers and Other Floats</H5>
<PRE>FloatGeos80ToIEEE64(), FloatGeos80ToIEEE32(), FloatIEEE64ToGeos80(), FloatIEEE32ToGeos80()</PRE>
<P>
<CODE>
FloatGeos80ToIEEE64()</CODE>
 converts a GEOS FP number (80 bits) into a 64 bit floating point number (in C, a type of <CODE>
double</CODE>
).</P>
<P>
<CODE>
FloatGeos80ToIEEE32()</CODE>
 converts a GEOS FP number (80 bits) into a 32 bit floating point number (in C, a type of <CODE>
float</CODE>
).</P>
<P>
<CODE>
FloatIEEE64ToGeos80()</CODE>
 converts a 64 bit FP number into a GEOS 80 bit FP number (in C, a type of <CODE>
long</CODE>
 <CODE>
double</CODE>
).</P>
<P>
<CODE>
FloatIEEE32ToGeos80()</CODE>
 converts a 32 bit FP number into a GEOS 80 bit FP number (in C, a type of <CODE>
long</CODE>
 <CODE>
double</CODE>
).</P>


<HR>
This document is a single-page version of a <A HREF="index.htm">a multi-page document</A>, suitable for easy printing.
</BODY>
</HTML>
