<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD>
<!-- This page was automatically generated from a bunch of smaller pages. -->
<META NAME="copyright" CONTENT="Copyright GEOWORKS">
<LINK REL="STYLESHEET" HREF="../../docHelpers/style.css">
<LINK REV="MADE" HREF="mailto:doc-feedback@geoworks.com">
<TITLE>Viewer-Compatible Documents</TITLE>
</HEAD>
<BODY BGCOLOR="#ffffdf">
This document is a single-page version of a <A HREF="index.htm">a multi-page document</A>, suitable for easy printing.
<A NAME="index.htm"></A>

<H1 CLASS="chapterTitle">
Viewer-Compatible Documents
</H1>

<P>
The user of a Nokia 9000i Communicator can create various kinds of 
documents, including mail, SMS messages, and notes. Most of these 
documents can be shared between applications.  The SMS application 
can open short Mail documents, the Fax program can send text from 
Notes, the Notes application can read and edit many kinds of documents.
</P>

<P>
The Viewer library makes this document-sharing possible.  An application
can instantiate an object of FileOpenControlClass, a class defined by 
the Viewer library, which allows the user to select a document.
The Viewer library will then start up another library which will allow 
the user to view and edit the document--a VILFile 
library exists for each document type.  If you are defining a new kind of 
document to be compatible with the Viewer library, you will need 
to write a corresponding VILFile library.  
</P>

<P>
Before embarking on this task, consider if it's appropriate.  Do you 
really <EM>need</EM> to make your documents Viewer Library-compatible?  Consider 
the "Tones" files created and edited by means of the Composer application.  
These are documents, but it seems unlikely that the user would want 
to view or edit these files from other applications--users probably 
don't want to send their Tones via Fax.  Instead of creating 
a VILFile library to work with these documents, the programmers wrote
a specialized application to work with the documents; this task was 
more straightforward than writing a VILFile library.
</P>

<P>
To define a new type of Viewer-library compatible document, you will
need to do the following things:
</P>
<DL>
<DT><STRONG>Choose a four-character token.</STRONG></DT>
    <DD>When the Viewer library determines which VILFile library
        to use to view a document, it identifies the document's type by means
        of a four-character token.  In later examples we will use the 
        token 'TABV'.</DD>
<DT><STRONG>Create a document browser application with a FileOpenControl.</STRONG></DT>
    <DD>Write an application that lets the user create documents 
        of your type.  To allow
        this application to work with the Viewer library,
        <A HREF="#FSApp.htm_Controller">add a
        FileOpenControl</A> object to the application, and configure the
        controller appropriately.</DD>
<DT><STRONG>Associate the token with your VILFile Library.</STRONG></DT>
    <DD>The Viewer library uses a table in the device's INI file to figure 
        out which VILFile library to use when viewing a document.
        Before the user can view one of your files, you set up the proper
        entry in the INI file.  Assuming that you're writing a
        document browser application
        that creates these documents, <A HREF="#FSApp.htm_INI">this
        application could add the appropriate entry to the INI file</A>.</DD>
<DT><STRONG>Create a <A HREF="#FSLib.htm">VILFile Library</A>.</STRONG></DT>
    <DD>Set up the framework of your VILFile Library.  There should

        be a UI resource containing a ViewerDialog and four entry point
        routines.</DD>
<DT><STRONG>Decide on your document's file format.</STRONG></DT>
    <DD>Document data is stored in VM files.  When the user creates
        or opens a document, the Viewer library will tell your
        VILFile library the file's directory and name.  It's then
        up to your code to store data in and retrieve data from
        the file.</DD>
<DT><STRONG>Decide on your UI's state block format.</STRONG></DT>
    <DD>If the device is turned off or is running low on memory,
        your VILFile library will have to store its state in a
        heap block; later on, it will have to restore its state
        from the data in that block.  Your code should be able to
        store the name and location of the current document, along
        with the current state of UI gadgetry.</DD>
<DT><STRONG>Customize the UI that displays and edits the document.</STRONG></DT>
    <DD>A <A HREF="#FSLib.htm_ViewerDialog">ViewerDialog</A> object is a
        a dialog which provides some standard triggers and behavior.  To
        display the document's data, create a ViewerDialog and then place
        other objects within it.</DD>
<DT><STRONG>Write the <A HREF="#FSLib.htm">four entry-point</A> routines for the library.</STRONG></DT>
    <DD>The Viewer library will call routines of your VILFile library
        when it's time to open a document, close a document, save to
        state, or switch between documents.  You will need to write
        code for these four routines.</DD>
<DT><STRONG>Install your geodes in the proper place.</STRONG></DT>
    <DD>Your application(s) probably belong in the device's
        WORLD\EXTRAPPS directory.  Your VILFile library goes
        in the SYSTEM directory.</DD>
</DL>
<P>The rest of the chapter discusses how to carry out these tasks.</P>
<P CLASS="sectionlinks">
<STRONG>
&nbsp;&nbsp;<A HREF="#FSApp.htm">1 Document Browser Application</A><BR>
&nbsp;&nbsp;<A HREF="#FSLib.htm">2 VILFile Library</A><BR>
</STRONG>
</P> <!-- end of sectionlinks blob -->

<HR>
<A NAME="FSApp.htm"></A>
<H2 CLASS="sectionTitle">
<A HREF="#index.htm">Viewer-Compatible Documents</A>: 1
Document Browser Application</H2>

<P>You'll probably want to write some sort of document browser application to 
handle two tasks involved with supporting a viewer-compatible document type.
(It's possible to carry out these tasks in other ways; in most cases, it's 
simplest to write an application.)
</P>
<UL>
<LI>Associate the VILFile library with the document type token
<LI>Allow the user to create documents of the document type
</UL>

<A NAME="FSApp.htm_INI"></A>
<H3>Associating the VILFile Library with the Document Type Token</H3>

<P>
The system will recognize your document's type by its four-byte token.  
As soon as possible, you will
need to tell the system which VILFile library to use to work with 
files of your type.  If your software package includes some setup 
or install application, it can set up the association by editing 
the device's GEOS.INI file.  If your package contains no such set-up 
application, but does contain some other application, 
make that application edit the INI file; warn users that 
the system will only recognize the document type after they've run 
the application.
</P>

<P>
The following code snippet shows how a GEOS program could 
edit the GEOS.INI to associate the token "TABV" with the 
<CODE>tablev</CODE> library.  A program using this snippet 
would write a line to the <CODE>vilFileTable</CODE> section 
of the INI file reading "TABV = tablev.geo" ; 
the system will look for this line.</P>

<PRE>
#include &lt;initfile.h&gt; /* header for InitFileWriteString() */

#define TV_FILE_TOKEN     "TABV" 

@method MyProcessClass, MSG_GEN_PROCESS_OPEN_APPLICATION
{
  @callsuper(); 
  NEC( InitFileWriteString("vilFileTable", TV_FILE_TOKEN, "tablev.geo"); )
  EC(  InitFileWriteString("vilFileTable", TV_FILE_TOKEN, "tablevec.geo"); )
} /* MSG_GEN_PROCESS_OPEN_APPLICATION */
</PRE>

<P>The application's process object will receive 
<A HREF="../../SysObjects/GenProc/GenProcess_1.htm#IX_MSG_GEN_PROCESS_OPEN_APPLICATION">MSG_GEN_PROCESS_OPEN_APPLICATION</A>
soon after the application is run.</P>

<P>When we're testing on the error-checking version of the system, we'll use 
   the error-checking version of the <CODE>tablev</CODE> library.  The filename 
   of the library differs between the normal and error-checking versions; 
   we use the 
   <CODE><A HREF="../../CRef/Routines/R_1e.htm#IX_EC() macro">EC()</A></CODE> 
   and 
   <CODE><A HREF="../../CRef/Routines/R_74.htm#IX_NEC() macro">NEC()</A></CODE>
   conditional compilation 
   macros to make sure that we write out the correct file name.</P>

<A NAME="FSApp.htm_Controller"> </A>
<H3>Allowing the User To Create Documents of Your Type</H3>

<A NAME="FSApp.htm_IX_FileOpenControlClass"> </A>

<P>The common way to allow the user to create Viewer-compatible documents 
   of a given type is by means of a subclassed FileOpenControl object.  
   Let's take a look at how one might configure such an object, 
   then see how to integrate it into an application's UI.</P>

<IMG SRC="fileopen.gif" ALT="[FileOpenControl screen shot]" WIDTH="648" HEIGHT="204">

<P>The following code snippet shows a fairly feature-rich instance of a 
   FileOpenControl object set up to create documents of the "TABV" type.</P>

<PRE>
@include &lt;viewer.goh&gt; /* header for the Viewer library */

#define TV_FILE_TOKEN     "TABV"
#define TV_MAJOR_PROTOCOL 0
#define TV_MINOR_PROTOCOL 0

@class MyFileOpenControlClass, FileOpenControlClass;
@endc;

@classdecl MyFileOpenControlClass;

@object MyFileOpenControlClass MyFileOpen = {
  CMI_topText = @FCMoniker; 
  ATTR_GEN_CONTROL_REQUIRE_UI = { FOF_MOVE | FOF_CREATE_FOLDER | 
                                  FOF_COPY | FOF_OPEN | 
                                  FOF_DELETE | FOF_RENAME_COPY | 
                                  FOF_RENAME | FOF_CLOSE };

  ATTR_FILE_OPEN_CREATE_TRIGGER_MONIKER = @CreateTriggerMoniker; 
  HINT_EXPAND_HEIGHT_TO_FIT_PARENT;
  ATTR_FILE_OPEN_DEFAULT_FILE_NAME_PREFIX = @VFFPrefix; 
  ATTR_FILE_OPEN_FILE_ATTR_INFO = {
    TV_FILE_TOKEN, 26, TV_MAJOR_PROTOCOL, TV_MINOR_PROTOCOL 
  };
} 
@chunk TCHAR FCMoniker[] = "CalcuWriter";
@chunk TCHAR CreateTriggerMonikerText[] ="New\rCalc";
@chunk FileOpenCreateNewMoniker CreateTriggerMoniker = { 
  @CreateTriggerMonikerText, 
  0 
} ;

@method MyFileOpenControlClass, MSG_FILE_OPEN_CONTROL_GET_VIEWER_LIBRARY_NAME {
    GeodeToken           theToken;
    ViewerInterfaceError error;

    if ( error = ViewerGetFileToken( docInfo, &amp;theToken ) ) {
      return( error );
    }

    if ( theToken.GT_chars[0] ) { /* check for null token */
      return( @callsuper() );
    }
    else {
      return( VIE_NO_VIEWER_LIBRARY );
    }
    
}
</PRE>

<P>The sizing hint <CODE>HINT_EXPAND_HEIGHT_TO_FIT_PARENT</CODE> is 
   fairly important.
   Without any sizing hint, the object is likely to change size over 
   its lifetime.</P>

<A NAME="FSApp.htm_IX_ATTR_FILE_OPEN_CREATE_TRIGGER_MONIKER"> </A>
<A NAME="FSApp.htm_IX_FileOpenCreateNewMoniker"> </A>

<P>The <CODE>ATTR_FILE_OPEN_CREATE_TRIGGER_MONIKER</CODE> variable data field  
   allows you to specify a custom moniker for the control's "Create" trigger, 
   if one exists.  As shown in this example, this field should hold the chunk handle 
   of a <CODE>FileOpenCreateNewMoniker</CODE> structure in the same resource  
   as the <STRONG>FileOpenControl</STRONG>.</P>

<A NAME="FSApp.htm_IX_ATTR_FILE_OPEN_DEFAULT_FILE_NAME_PREFIX"> </A>

<P><CODE>ATTR_FILE_OPEN_DEFAULT_FILE_NAME_PREFIX</CODE> specifies a 
   default file name for documents created with this controller 
   (if it supports the feature of creating documents).  This field 
   should hold the chunk handle of a string in the same resource as 
   the <STRONG>FileOpenControl</STRONG>.</P>

<P>If the <STRONG>FileOpenControl</STRONG> is to create new documents, 
   specify the document type of those documents 
   with <CODE>ATTR_FILE_OPEN_FILE_ATTR_INFO</CODE>.  This field should 
   contain a 
   <A HREF="../../CRef/Structs/S_1b.htm#IX_GeodeToken">GeodeToken</A>
   structure holding the document type's token, 
   your <CODE>ManufacturerID</CODE>, and a 
   <A HREF="../../CRef/Structs/S_2f.htm">protocol number</A>.  
   The <CODE>ManufacturerID</CODE>
   and token identify the type; the protocol number allows you to 
   specify different versions of the type.</P>

<A NAME="FSApp.htm_IX_FileOpenFeatures"> </A>
<A NAME="FSApp.htm_IX_FOF_&ldots;"> </A>

<P>The <CODE>ATTR_GEN_CONTROL_REQUIRE_UI</CODE> 
  (not used in this example) 
  variable data field allow you to turn on 
  some of the FileOpenControl's features. 
  (Use <CODE>ATTR_GEN_CONTROL_PROHIBIT_UI</CODE>, not shown in 
  this example, to turn off some of these features.)</P>

<DL>
<DT><CODE>FOF_RENAME</CODE></DT>
    <DL>Allows the user to rename a file.</DL>
<DT><CODE>FOF_COPY</CODE></DT>
    <DL>Allows the user to copy a file to a different directory.</DL>
<DT><CODE>FOF_RENAME_COPY</CODE></DT>
    <DL>Allows the user to copy a file to another directory, specifying a new name for the copy.</DL>
<DT><CODE>FOF_DELETE</CODE></DT>
    <DL>Allows the user to delete a file.</DL>
<DT><CODE>FOF_CREATE_NEW</CODE></DT>
    <DL>Allows the user to create a new file.  You will need to make sure that 
        the FileOpenControl knows what kind of document to create, using 
        the <CODE>ATTR_FILE_OPEN_FILE_ATTR_INFO</CODE> field.</DL>
<DT><CODE>FOF_OPEN</CODE></DT>
    <DL>Allows the user to open an existing file.</DL>
<DT><CODE>FOF_CLOSE</CODE></DT>
    <DL>Allows the user to close a subdirectory.</DL>
<DT><CODE>FOF_CREATE_FOLDER</CODE></DT>
    <DL>Allows the user to create a subdirectory.</DL>
<DT><CODE>FOF_MOVE</CODE></DT>
    <DL>Allows the user to move a file to a different directory.</DL>
<DT><CODE>FOF_COPY_TO_SOUNDS</CODE></DT>
    <DL>Allows the user to copy the file to the Tones directory. 
        A FileOpenControl does not normally display this directory.</DL>
</DL>

<P>The method for <CODE>MSG_FILE_OPEN_CONTROL_GET_VIEWER_LIBRARY_NAME</CODE>
   is a work-around for a bug.  Without this work-around, the system will 
   crash if the user uses the <STRONG>FileOpenControl</STRONG> to open a 
   file that has a null token.</P>

<H3>Fitting the FileOpenControl into your Application</H3>

<P>In addition to configuring the application's 
   <STRONG>FileOpenControl</STRONG>, you will need to do some things to 
   allow the <STRONG>FileOpenControl</STRONG> to coexist with the rest 
   of your application's objects.</P>

<UL>
<LI>Make sure the <STRONG>FileOpenControl</STRONG> object is on the 
    <CODE>MGCNLT_ACTIVE_LIST</CODE> and 
    <CODE>GAGCNLT_VIEWER_NOTIFICATIONS</CODE> 
    notification lists.  The FileOpenControl, like most controllers 
    needs to be on these lists to get certain system notifications.</LI>
<LI>Add <STRONG>FileOpenControl</STRONG> to the application's UI tree.
    Typically, the <STRONG>FileOpenControl</STRONG> is the child of 
    the application's primary window.</LI>
<LI>Fix overloaded button slots.
    Usually, a <STRONG>FileOpenControl</STRONG> will show additional
    triggers when it's displaying a subdirectory.  For instance, 
    it brings up a "Close" trigger.</LI>
 <P>An application might have some triggers in the same window that 
    contains the <STRONG>FileOpenControl</STRONG>.  For instance, 
    there might be a "Close" trigger to exit the application.  This 
    can lead to overlaps when the <STRONG>FileOpenControl</STRONG> 
    tries to put its own triggers in the occupied slots.  To work 
    around this, intercept <CODE>MSG_FILE_OPEN_CONTROL_SUB_DIR_OPEN</CODE>
    and <CODE>MSG_FILE_OPEN_CONTROL_SUB_DIR_CLOSE</CODE> and set the 
    extra triggers not-usable or usable.</P>
</UL>

<IMG SRC="subdir.gif" ALT="[FileOpenControl screen shot]" WIDTH="648" HEIGHT="204">
<P CLASS="figTitle"><STRONG>Figure:</STRONG> The "Close" trigger is covering another trigger in the same slot.</P>

<P>The following code snippets show how an application might 
   carry out these tasks.</P>

<PRE>
/* Put the FileOpenControl on the necessary notification lists */
@object FoamSubApplicationClass VFApp = {
  ...
  gcnList( MANUFACTURER_ID_GEOWORKS, MGCNLT_ACTIVE_LIST ) = 
        @MyFileOpen;
  gcnList( MANUFACTURER_ID_GEOWORKS, GAGCNLT_VIEWER_NOTIFICATIONS ) =
	@MyFileOpen;
}

/* Make the controller a child of the primary window. */
@object GenPrimaryClass VFPrimary = {
  GI_comp = ... , @MyFileOpen ;
}

/* Disable and re-enable triggers whose slots overlap 
   the FileOpenControl's when it views a subdirectory. */
@method MyFileOpenControlClass, MSG_FILE_OPEN_CONTROL_SUB_DIR_OPEN { 
  @send VFCloseTrigger::MSG_GEN_SET_NOT_USABLE( VUM_DELAYED_VIA_APP_QUEUE );
}

@method MyFileOpenControlClass, MSG_FILE_OPEN_CONTROL_SUB_DIR_CLOSE {
  @send VFCloseTrigger::MSG_GEN_SET_USABLE( VUM_DELAYED_VIA_APP_QUEUE );
}

</PRE>

<HR>
<A NAME="FSLib.htm"></A>
<H2 CLASS="sectionTitle">
<A HREF="#index.htm">Viewer-Compatible Documents</A>: 2
VILFile Library</H2>

<P>Each viewer-compatible document type needs a VILFile library responsible 
   for reading, writing, and displaying documents of that type.  Writing 
   such a library requires
   some UI work, VM file operations, and an understanding of 
   the actions which the Viewer library requests of VILFile libraries.</P>

<P>Each VILFile library must have at least four 
   entry points (exported routines); the Viewer library will call these 
   routines when it needs the VILFile library to carry out certain tasks:
   </P>

<OL>
<LI><STRONG>Open:</STRONG><BR>
    <EM>Purpose:</EM> The Viewer library needs the VILFile document to open a document. 
<BR>The user may have 
    just now selected the document; 
<BR>the user may have just now created 
    the document; 
<BR>the user may have opened the document a while ago, 
    the application may have been shut down to state (and the document 
    closed), and the application may now be opening again, so that the 
    document must be re-opened.</LI>
<P><EM>Action:</EM> Typically, the Open routine displays UI and caches 
   information that 
    will be needed later, including the document file's path.  If the 
    document is new, the routine is 
    responsible for initializing the document.</P>
<LI><STRONG>Detach (Quit to State):</STRONG><BR>
    <EM>Purpose:</EM> The device must close the document though the user hasn't 
    explicitly closed it.  Perhaps the device is running low on 
    memory and must shut down the viewing application, or perhaps the 
    device is powering down.  </LI>
<P><EM>Action:</EM> The routine is responsible for collecting all state information 
    and encoding it into a block of memory which it returns to the 
    Viewer library.  If the document file is open, this routine should 
    close it.  This routine is normally responsible
    destroy the UI which displays the document.</P>
<LI><STRONG>Change Document (Switch Documents):</STRONG><BR>
    <EM>Purpose:</EM> The user is jumping from document to document.  The Viewer library 
    needs the VILFile library to close the current document and open another.</LI>
<P><EM>Action:</EM> The routine should close the current document and attempt to 
    open the new document.  This document's location is passed as an argument.
    It may update the displayed UI.
    It will probably need to update cached information useful for 
    other tasks.</P>
<LI><STRONG>Close Document:</STRONG><BR>
    <EM>Purpose:</EM> The user is done with the current 
    document. The Viewer library needs to close the document.</LI>
<P><EM>Action:</EM> The routine is responsible for closing the current document.
    Typically, it will also destroy the UI used to display the 
    document.</P>
</OL>

<P>Below, we'll see source code for a simple VILFile library  
   which carries out these duties.</P>

<H3>GP File</H3>

<P>Before discussing the VILFile library's procedural code, 
   it's worthwhile to note directives needed in the library's GP file.</P>

<UL>
<LI>You will need to link the <STRONG>viewer</STRONG> library.</LI>
<LI>The first four exported routines correspond to the four 
    routines which each VILFile library must support.  </LI>
<LI>Typically, your library will create UI by making a copy
    of a template resource.  This template 
    resource should be marked <CODE>read-only</CODE> and <CODE>shared</CODE>
    in the GP file.  We'll discuss this UI template in greater detail 
    below.</LI> 
<LI>Your library will almost certainly have to declare a subclass of 
    <STRONG>ViewerDialogClass</STRONG>; export this class.</LI>
</UL>

<P CLASS="figTitle"><STRONG>Code Display:</STRONG> Typical .GP file for a VILFile library</P>
<PRE>
library viewer
library ansic    # Not all VILFile libraries will use ansic, but 
                 # our example code does.  (It uses strncpy())

resource THEVIEWERUI           object read-only shared

export TVOPEN
export TVDETACH
export TVCHANGEDOCUMENT
export TVCLOSE

export MyViewerDialogClass
</PRE>

<H3>Declaring UI</H3>

<A NAME="FSLib.htm_ViewerDialog"></A>

<P>The typical VILFile library will use UI gadgetry to display the 
   contents of a document.  The top object of this gadgetry should 
   be a <STRONG>ViewerDialog</STRONG> object. Because it's an easy way 
   to take care of some VILFile library duties, libraries often use 
   a subclass of <STRONG>ViewerDialogClass</STRONG>.</P>

<P>Typically, the VILFile library creates the document display gadgetry by 
   making a copy of a template UI resource.  This 
   resource should be marked as <CODE>read-only</CODE> and <CODE>shared</CODE>
   in the GP file. It should be declared <CODE>notDetachable</CODE>.

<P>When it comes time to discard the UI, we'll send a 
   <CODE>MSG_VD_CLOSE</CODE> to the ViewerDialog object.  
   It will do some clean-up work before closing down.</P>

<IMG SRC="vdialog.gif" ALT="[ViewerDialog screen shot]" WIDTH="648" HEIGHT="204">

<PRE>
@include &lt;viewer.goh&gt;

@class MyViewerDialogClass, ViewerDialogClass;

/* The following messages are utilities; we added them to help out 
   with some VILFile library duties */
  @message word			MSG_MVD_OPEN_DOCUMENT( DocumentInfo *doc );
  @message void                 MSG_MVD_CLOSE_DOCUMENT();
  @message word			MSG_MVD_RESTORE_STATE( MemHandle stateBlock );
  @message MemHandle            MSG_MVD_SAVE_STATE();

/* In our dialog UI, we added a "Close" button.   It sends this message. */
  @message void 		MSG_MVD_CLOSE();

/* The following instance data fields contain cached information.
   The information is cached when the document is opened; the information 
   is useful for accessing the document file and for closing it. */
  @instance VMFileHandle	MVDI_fileStash;
  @instance DocumentInfo        MVDI_docStash;

/* The dialog is a handy place to cache information.  This example 
   displays the sum of two user-entered numbers.  It caches the3 
   value of this sum in an instance data field; 
   no doubt your library will have various data best cached in the dialog. */
  @instance WWFixedAsDWord 	MVDI_sumNum;
@endc;

@classdecl MyViewerDialogClass; 

/* Here is the template UI block; the library will make a copy 
   of this template whenever it needs to display a document. */
@start TheViewerUI, notDetachable;

/* At the top of the template's UI tree is a subclassed ViewerDialog */
@object MyViewerDialogClass TVDialog = {
  GI_comp = @TVLabel, @TVCloseTrigger, 
            @TVAddend0, @TVAddend1, @TVSum ;
  GI_states = @default & ~GS_USABLE;
}

/* A GenGlyph to display the document name. */
@object GenGlyphClass TVLabel = { 
  GI_visMoniker = "docName"; 
  @localize not;
} 

/* In this example, the document's data consists of two numbers, 
   which the program adds together.  These two GenValues show 
   the numbers, and allow the user to change them. */
@object GenValueClass TVAddend0 = { 
  GI_visMoniker = "add";
  GVLI_maximum = MakeWWFixed( 16000 ); 
}

@object GenValueClass TVAddend1 = { 
  GI_visMoniker = "to";
  GVLI_maximum = MakeWWFixed( 16000 ); 
}

/* This GenGlyph displays the sum. */
@object GenGlyphClass TVSum = {
  GI_visMoniker = "0";
}

/* This is the Close trigger for the dialog. */
@object ComplexMonikerClass TVCloseTrigger = {
  ComplexMoniker = GenTriggerClass;
  CMI_topText = CMT_CLOSE;
  CMI_textStyle = TS_BOLD;

  GTI_destination = @TVDialog;
  GTI_actionMsg = MSG_MVD_CLOSE;

  HINT_SEEK_REPLY_BAR;
  HINT_SEEK_SLOT = 3;
}

@end TheViewerUI;
</PRE>

<H3>Four Entry Points</H3>

<P>Your VILFile library must provide four entry points (exported routines).
   The order in which these routines are exported (in the GP file) is 
   important; they should correspond to the values of the 
   <CODE>ViewerLibraryRoutine</CODE> enumerated type (defined in 
   viewer.goh).  You will need to write these routines.</P>
<DL>
<DT><STRONG>Open</STRONG></DT>
<DD>This routine is responsible for opening the document or restoring 
    from state.  There is a number 
    of other tasks which typically take place here.</DD>
    <UL>
    <LI>Create UI to display the document.  This is normally done by 
        means of a call to 
        <CODE><A HREF="../../CRef/Routines/R_9e.htm#IX_UserCreateDialog()">UserCreateDialog()</A></CODE>, 
        passing the optr of a 
        subclassed <STRONG>ViewerDialog</STRONG> object in a template 
        resource.  However you go about creating the UI, follow up 
        by sending a <CODE>MSG_VD_SET_VIEWER_PARAMS</CODE> 
        to the dialog.</LI>
    <LI>The new UI is going to take up memory.  The document browser application 
        will probably need more heap space to allow this.  The 
        <STRONG>ViewerDialogClass</STRONG> has a mechanism to help with 
        this.  If you call <CODE>GeodeRequestSpace()</CODE> and pass 
        the returned token to <CODE>MSG_VD_SET_HEAPSPACE_TOKEN</CODE>, 
        the <STRONG>ViewerDialog</STRONG> knows to release this heapspace 
        when it is dismissed.  The upshot of all this: now 
        is a good time to call <CODE>GeodeRequestSpace()</CODE>.</LI>
    <LI>Do some correctness checking on the document.  Check its protocol 
        number.  If your document format has some "magic number" or checksum,
        this would be a good time to check it.</LI>
    <LI>If there's a problem, alert the user and discard the UI by 
        sending a MSG_VD_CLOSE to the <STRONG>ViewerDialog</STRONG>.
    </UL>
    <P>The routine is passed a <STRONG>ViewerParams</STRONG> structure 
       which provides either state information or information about 
       the document to be opened.  The routine should return an optr (null 
       if there was a problem).  The Viewer library will pass this optr 
       as an argument to subsequent routines.</P>
    <P>If you're restoring from state, you'll be passed a block of memory 
       which you previously filled with state information.</P>

<DT><STRONG>Detach (Save to State)</STRONG></DT>
<DD>This routine is responsible for allocating and filling a block of 
    memory with state information--information which may later be used 
    to restore from state.  This routine should also close the document 
    file and discard the document-display UI.</DD>
<DT><STRONG>Change Document (Switch Documents)</STRONG></DT>
<DD>This routine is responsible for switching between two documents by  
    closing the current document and opening another.  The routine should 
    check the new document for correctness 
    (as described for "Open," above).  It should update 
    the document-display UI so that it corresponds to the new document.
    If there's a problem, it should discard the document-display UI.</DD>
<DT><STRONG>Close</STRONG></DT>
<DD>This routine is responsible for closing the current document.  It 
    should close the document file and discard the document-display UI.</DD>
</DL>

<P>It's a good idea to keep the document file open as long as the 
   the document is open--this marks the file as "in use" so that 
   the user won't try to open it and change it in another application.</P>

<P CLASS="figTitle"><STRONG>Code Display:</STRONG> Sample handlers for the four entry points</P>
<PRE>
/* VLR_OPEN       optr( ViewerParams *vp ) */
optr _pascal TVOpen( ViewerParams *vp ) {
  optr   		theTableUI;
  ReservationHandle     moreSpace;

  /* We want to request more heapspace for the app to hold all 
     the memory we're going to need. */

  moreSpace = GeodeRequestSpace( 14, GeodeGetProcessHandle() );
    /* We got that 14 by using the 'heapspace' Swat command on an 
       app that uses this library, trying to figure out how many 
       more k the application needed when it was using this library. */

  if ( moreSpace == 0 ) {
    /* We should alert the user that we're out of memory, 
       perhaps with a SysNotify().  But I won't do that for 
       now because I'm lazy.  */

    return( NullHandle );
  }  

  /* Create the UI to display the document by copying the template resource */
  theTableUI = UserCreateDialog( @TVDialog );

  /* Tell the ViewerDialog about the heapspace we reserved.  The dialog will 
     free it when closed. */
  @call theTableUI::MSG_VD_SET_HEAPSPACE_TOKEN( moreSpace );

  @call theTableUI::MSG_VD_SET_VIEWER_PARAMS( vp );

  /* Are we restoring from state or just opening a document? */
  if (vp-&gt;VP_state == FALSE ) {

    /* We're opening a document.  Is it new?  */
    if ( vp-&gt;VP_attr & VA_NEW_DOCUMENT ) {

      /* Initialize the new document -- we'll see this code later */

    }
    /* Call the code we wrote that opens and displays the document */
    if ( 0 == @call theTableUI::MSG_MVD_OPEN_DOCUMENT( &vp-&gt;VP_documentInfo )) {   
      /* If there was a problem, discard the UI. */
      @send theTableUI::MSG_VD_CLOSE(GeodeGetCodeProcessHandle(), VCS_CLOSED );
      return( NullHandle );
    }
  }

  else {  /* We're restoring from state. */
      /* Call the code we wrote that restores from state. */
      if (0 == @call theTableUI::MSG_MVD_RESTORE_STATE( vp-&gt;VP_state )) {
        /* If there was a problem, discard the UI. */
        @send theTableUI::MSG_VD_CLOSE( GeodeGetCodeProcessHandle(), VCS_CLOSED );
        return( NullHandle );
      }
  }

  /* Whether we're opening a document or restoring from state, we've 
     initialized the UI correctly.  Bring up the dialog box. */
  @call theTableUI::MSG_GEN_INTERACTION_INITIATE();

  return( theTableUI );
}

/* VLR_DETACH hptr( optr optrUI );  */
hptr _pascal TVDetach( optr optrUI ) {
  /* We will save our data to state, close the document, and discard UI */
  MemHandle theState;

  theState = @call optrUI::MSG_MVD_SAVE_STATE();
  @call optrUI::MSG_MVD_CLOSE_DOCUMENT();
  @call optrUI::MSG_VD_CLOSE( GeodeGetCodeProcessHandle(), VCS_CLOSED );
  return( theState );
}

/* VLR_CHANGE_DOCUMENT   void( ViewerChangeDocumentStruct *vcds) */
void _pascal TVChangeDocument( ViewerChangeDocumentStruct *vcds) {
  /* Switch between documents--close the current document and open 
     the passed document. */
  @call vcds-&gt;VCD_viewerOD::MSG_MVD_CLOSE_DOCUMENT();
  if ( 0 == @call vcds-&gt;VCD_viewerOD::MSG_MVD_OPEN_DOCUMENT( &vcds-&gt;VCD_documentInfo )) {
    @send vcds-&gt;VCD_viewerOD::MSG_VD_CLOSE(GeodeGetCodeProcessHandle(), VCS_CLOSED );
  }
}

/* VLR_CLOSE  void (optr optrUI) */
void _pascal TVClose( optr optrUI ) {
  /* Close the current document and discard UI */
  @call optrUI::MSG_MVD_CLOSE_DOCUMENT();
  @call optrUI::MSG_VD_CLOSE( GeodeGetCodeProcessHandle(), VCS_CLOSED );
}
</PRE>

<H3>Supporting Other Document UI</H3>

<P>Not all document-manipulation requests need come in via the four 
   entry points described above.  For example, you might want to add 
   a "Close" trigger to the document display dialog.  Pressing the 
   button corresponding to this trigger might result in closing the 
   document and discarding the document display UI.  The following 
   code snippet shows how your program might handle a Close trigger's 
   action.</P>

<PRE>

@method Close, MyViewerDialogClass, MSG_MVD_CLOSE {
  /* The user pressed the "Close" button.  Close the document 
     file and discard the document display UI */
  @call self::MSG_MVD_CLOSE_DOCUMENT();  
  @send self::MSG_VD_CLOSE( GeodeGetCodeProcessHandle(), VCS_CLOSED );
}

</PRE>

<H3>Creating, Opening, and Saving Document Files</H3>

<P>As discussed, VILFile will, in response to requests from 
   the system or requests generated internally, want to act upon 
   the document file.  We haven't talked about how a program 
   goes about doing so.</P>

<P>When the Viewer library requests that the VILFile library 
   open the document file, it will pass the file's path, 
   encoded as a <STRONG>FoamPathHandle</STRONG>, which is equivalent to 
   a <STRONG>FDocumentDir</STRONG>.  It will also pass the 
   document file's name.  Using a combination of Foam and 
   kernel library routines, your library can open the file 
   and manipulate its contents as shown in the code examples 
   below.  The file is a normal GEOS VM File; you may use 
   <A HREF="../../Memory/VM/VM_7.htm">normal VM routines</A> 
   with it.</P>

<P>Because the Viewer library only supplies a reference to the 
   document file when that file is to be opened, your library 
   will probably need to cache a reference to the file for 
   future operations.  It's a good idea to keep the file open 
   while the user is working with the document, so that the 
   system's file-sharing protection will keep other programs 
   from trying to change the file.</P>

<P CLASS="figTable"><STRONG>Code Display:</STRONG> Manipulating the Document file</P>
<PRE>
#include &lt;Ansi/string.h&gt;

  /* This snippet of code for creating new documents is taken 
     from the VLR_OPEN handler. */
  /* This code makes use of "vp", the ViewerParameters structure passed 
     to the Open routine */

      VMFileHandle      theFile;
      VMBlockHandle 	theBlock;
      WWFixedAsDWord 	*theBuffer;
      MemHandle         dummyHandle;

      /* Open the document */
      /* Save the current directory */
      FilePushDir();  
      FoamSetDocumentDir( vp-&gt;VP_documentInfo.DI_docDir );  
      theFile = VMOpen( vp-&gt;VP_documentInfo.DI_docName,
                        VMAF_FORCE_READ_WRITE | VMAF_FORCE_DENY_WRITE, 
                        VMO_OPEN, 0 );

      /* Now that we've opened the file, initialize its data.
         In our example, document files are pretty simple, 
         containing two WWWFixedAsDWord values. */
      theBlock = VMAlloc( theFile, 2*sizeof(WWFixedAsDWord), 0 );
      VMSetMapBlock( theFile, theBlock );
      theBuffer = VMLock( theFile, theBlock, &dummyHandle );
      theBuffer[0] = 0;
      theBuffer[1] = 0;

      /* We've written the data.  Mark the file dirty and close it. */
      VMDirty( dummyHandle );
      VMUnlock( dummyHandle );
      VMClose( theFile, FALSE );

      FilePopDir();
  /* So ends the snippet from the VLR_OPEN handler */

  ---------

/* word	MSG_MVD_OPEN_DOCUMENT( DocumentInfo *doc ); */
@method OpenDocument, MyViewerDialogClass, MSG_MVD_OPEN_DOCUMENT {
  /* The entry point routines send this message when they want to open a 
     document.
     The handler checks the document's version (to make sure it wasn't 
     created by a later, incompatible version of this library) opens the 
     document file, reads its contents, and updates the document 
     display UI. */

  VMBlockHandle 	theBlock;
  WWFixedAsDWord 	*theBuffer;
  MemHandle         	dummyHandle;
  optr   		someObject;
  ProtocolNumber 	protocol;

  /* Cache the document file's path. */
  pself-&gt;MVDI_docStash.DI_docDir = doc-&gt;DI_docDir;
  strncpy( pself-&gt;MVDI_docStash.DI_docName, doc-&gt;DI_docName, FILE_LONGNAME_BUFFER_SIZE );

  /* Open the document file. */
  FilePushDir();  /* Save the old directory */
  FoamSetDocumentDir( doc-&gt;DI_docDir );
  pself-&gt;MVDI_fileStash = VMOpen( doc-&gt;DI_docName,
                                  VMAF_FORCE_READ_WRITE | VMAF_FORCE_DENY_WRITE, 
                                  VMO_OPEN, 0 );

  /* Check to see if something went wrong. */
  if ( NullHandle == pself-&gt;MVDI_fileStash ) {

    /* Something went wrong--we couldn't open the file. */
    /* We should put in some code here to alert the user 
       that something went wrong when we tried to open 
       the file.  Maybe someone else has it open. */
     /* For this simple example, we just return an error. 
        The code which called us will make the dialog 
        go away.  Which is fine.  But it would be better 
        if we let the user know what was going on. */
    return( 0 ) ;
  }

  /* We successfully opened the file.  */
  /* Now we check its protocol number.  Perhaps this document was 
     created by another, later version of this same library--and 
     it might not be compatible with this library.  Normally, 
     incompatible versions use different major protocol numbers. */
  /* If we encounter a document with the wrong protocol number, 
     we reject it and return an error.  Of course, if we encountered 
     an old-version document, we could take measures to extract its 
     information and save it out again in the new format.  We would 
     then use FileSetHandleExtAttributes() to mark the file with 
     its new protocol number. */
  FileGetHandleExtAttributes( pself-&gt;MVDI_fileStash,
                              FEA_PROTOCOL,
                              &protocol,
                              sizeof( ProtocolNumber ) );
  if ( protocol.PN_major != 0 ) {
     /* We should put in some code here to alert the user 
        that this document is older or newer than we 
        know how to deal with. */
     /* For this simple example, we just return an error. 
        The code which called us will make the dialog 
        go away.  Which is fine.  But it would be better 
        if we let the user know what was going on. */
    VMClose( pself-&gt;MVDI_fileStash, FALSE );
    return( 0 ) ;
  }   

  FilePopDir();

  /* We've successfully opened the file and it looks correct.
     Read its data out and update the document display UI. */
  theBlock = VMGetMapBlock( pself-&gt;MVDI_fileStash ); 
  theBuffer = VMLock( pself-&gt;MVDI_fileStash, theBlock, &dummyHandle );

  /* We reuse the "someObject" variable to refer to each of the 
     document display objects in turn. */
  someObject = ConstructOptr( OptrToHandle( oself ),
                              OptrToChunk( @TVAddend0 ) );
  @call someObject::MSG_GEN_VALUE_SET_VALUE( theBuffer[0], FALSE );
  someObject = ConstructOptr( OptrToHandle( oself ),
                              OptrToChunk( @TVAddend1 ) );
  @call someObject::MSG_GEN_VALUE_SET_VALUE( theBuffer[1], FALSE );
  someObject = ConstructOptr( OptrToHandle( oself ),
                              OptrToChunk( @TVLabel ) );
  @call someObject::MSG_GEN_REPLACE_VIS_MONIKER_TEXT( doc-&gt;DI_docName, 
                                                      VUM_NOW );

  /* We're done with the data.  Unlock the data block, but keep the 
     file open to discourage other programs from opening it. */
  VMUnlock( dummyHandle );

  /* Return success */
  return( 1 ) ;
}

/* Save and Close the file */
@method CloseDocument, MyViewerDialogClass, MSG_MVD_CLOSE_DOCUMENT {
  /* Our code calls this message when it wants to close a document.  */
  /* The handler gets the current data from the document display UI, 
     saves this data to the document file, and closes the document file. */
  WWFixedAsDWord *theBuffer;
  VMBlockHandle  theBlock;
  MemHandle      dummyHandle;
  optr           someObject;

  /* We've previously stashed the handle of the document file. */
  theBlock = VMGetMapBlock( pself-&gt;MVDI_fileStash ); 
  theBuffer = VMLock( pself-&gt;MVDI_fileStash, theBlock, &dummyHandle );

  /* Retrieve the data from the document display UI.
     We re-use the "someObject" variable to reference
     each appropriate display object in turn.  */
  someObject = ConstructOptr( OptrToHandle( oself ),
                              OptrToChunk( @TVAddend0 ) );
  theBuffer[0] = @call someObject::MSG_GEN_VALUE_GET_VALUE( );
  someObject = ConstructOptr( OptrToHandle( oself ),
                              OptrToChunk( @TVAddend1 ) );
  theBuffer[1] = @call someObject::MSG_GEN_VALUE_GET_VALUE( );

  /* We've written the data.  Mark the file dirty and close it. */
  VMDirty( dummyHandle );
  VMUnlock( dummyHandle );
  VMClose( pself-&gt;MVDI_fileStash, FALSE );
}
</PRE>

<H3>Saving and Restoring State</H3>

<P>Sometimes the document viewer might have to shut down even though 
   the user hasn't explicitly closed the document.  The user might 
   power down the device, the device might run low on power, or the device 
   might run low on memory while the viewer application is in the background 
   and decide to shut down the viewer application.</P>

<P>Under these circumstances, the VILFile library should save the 
   information needed to restore the document display UI state.
   As shown below, there is likely to be more state information than 
   there was information in the document itself.  The state information 
   will almost certainly need to include the path and filename information 
   for the document file.</P>

<PRE>
#include &lt;Ansi/string.h&gt;

typedef struct {
  WWFixedAsDWord TVS_addend0;
  WWFixedAsDWord TVS_addend1;
  WWFixedAsDWord TVS_sumNum;
  DocumentInfo   TVS_doc;
} TVState;

@method RestoreState, MyViewerDialogClass, MSG_MVD_RESTORE_STATE {
  /* Our code calls this message when it wants to restore from state */
  /* The handler reads data from the passed memory block and updates 
     the dialog's instance data and the document display UI's data.
     It also opens the document file, though it ignores the file's 
     contents. */
  TVState *theBuffer;
  optr    someObject;
  char	  sumString[LOCAL_DISTANCE_BUFFER_SIZE];

  /* Lock down the passed block */
  theBuffer = MemLock( stateBlock );  

  /* Update the document display UI and the data we cache in the 
     dialog's instance data. */
  /* We re-use the "someObject" variable to refer to each of the 
     document display UI objects in turn. */
  someObject = ConstructOptr( OptrToHandle( oself ),
                              OptrToChunk( @TVAddend0 ) );
  @call someObject::MSG_GEN_VALUE_SET_VALUE( theBuffer-&gt;TVS_addend0, FALSE );
  someObject = ConstructOptr( OptrToHandle( oself ),
                              OptrToChunk( @TVAddend1 ) );
  @call someObject::MSG_GEN_VALUE_SET_VALUE( theBuffer-&gt;TVS_addend1, FALSE );
  pself-&gt;MVDI_docStash.DI_docDir = theBuffer-&gt;TVS_doc.DI_docDir;
  strncpy( pself-&gt;MVDI_docStash.DI_docName, 
           theBuffer-&gt;TVS_doc.DI_docName, 
           FILE_LONGNAME_BUFFER_SIZE );

  /* Open the document file. */
  FilePushDir();
  FoamSetDocumentDir( theBuffer-&gt;TVS_doc.DI_docDir );
  pself-&gt;MVDI_fileStash = VMOpen( theBuffer-&gt;TVS_doc.DI_docName,
                                  VMAF_FORCE_READ_WRITE | VMAF_FORCE_DENY_WRITE, 
                                  VMO_OPEN, 0 );

  if ( NullHandle == pself-&gt;MVDI_fileStash ) {
    /* Something went wrong when we attempted to open the file.
       In the time after we shut down to state, any of a number 
       of things could have happened.  The file may have been 
       deleted, or it may have been opened by another application. 
       We should get the error and do something with it. */

     /* In this simple example, we just return an error. 
        The code which called us will make the dialog 
        go away.  Which is fine.  But it would be better 
        if we let the user know what was going on. */
    return( 0 );
  }

  FilePopDir();

  someObject = ConstructOptr( OptrToHandle( oself ),
                              OptrToChunk( @TVLabel ) );
  @call someObject::MSG_GEN_REPLACE_VIS_MONIKER_TEXT( theBuffer-&gt;TVS_doc.DI_docName, 
                                                      VUM_NOW );
  pself-&gt;MVDI_sumNum = theBuffer-&gt;TVS_sumNum;
  someObject = ConstructOptr( OptrToHandle( oself ),
                              OptrToChunk( @TVSum ) );
  LocalFixedToAscii( sumString, pself-&gt;MVDI_sumNum, 0 );
  @call someObject::MSG_GEN_REPLACE_VIS_MONIKER_TEXT( sumString, VUM_NOW );

  return( 1 ) ;      
}

@method SaveState, MyViewerDialogClass, MSG_MVD_SAVE_STATE {
/* Our code sends this message when it needs to shut down to state.
   The handler allocates a memory block and fills it with the 
   information we'll need to restore to state later--data from 
   the document display UI objects and cached information from 
   the dialog. */
  MemHandle 	stateBlock;
  TVState   	*theBuffer;
  optr 		someObject;

  /* Allocate the block */
  stateBlock = MemAlloc( sizeof( TVState ), 
                         (HF_DYNAMIC | HF_SHARABLE) ,
                         HAF_LOCK ); 
  theBuffer = MemDeref( stateBlock );

  /* Retrieve data from objects and write it to the block */
  theBuffer-&gt;TVS_doc.DI_docDir = pself-&gt;MVDI_docStash.DI_docDir;
  strncpy( theBuffer-&gt;TVS_doc.DI_docName, 
           pself-&gt;MVDI_docStash.DI_docName, 
           FILE_LONGNAME_BUFFER_SIZE );
  theBuffer-&gt;TVS_sumNum = pself-&gt;MVDI_sumNum;
  someObject = ConstructOptr( OptrToHandle( oself ),
                              OptrToChunk( @TVAddend0 ) );
  theBuffer-&gt;TVS_addend0 = @call someObject::MSG_GEN_VALUE_GET_VALUE( );
  someObject = ConstructOptr( OptrToHandle( oself ),
                              OptrToChunk( @TVAddend1 ) );
  theBuffer-&gt;TVS_addend1 = @call someObject::MSG_GEN_VALUE_GET_VALUE( );
  
  /* We're done.  Unlock the block and return it. */
  MemUnlock( stateBlock );
  return( stateBlock );
}


</PRE>

<HR>
This document is a single-page version of a <A HREF="index.htm">a multi-page document</A>, suitable for easy printing.
</BODY>
</HTML>
