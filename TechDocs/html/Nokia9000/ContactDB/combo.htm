<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD>
<!-- This page was automatically generated from a bunch of smaller pages. -->
<META NAME="copyright" CONTENT="Copyright GEOWORKS">
<LINK REL="STYLESHEET" HREF="../../docHelpers/style.css">
<LINK REV="MADE" HREF="mailto:doc-feedback@geoworks.com">
<TITLE>Contacts</TITLE>
</HEAD>
<BODY BGCOLOR="#ffffdf">
This document is a single-page version of a <A HREF="index.htm">a multi-page document</A>, suitable for easy printing.
<A NAME="index.htm"></A>



<H1 CLASS="chapterTitle">
<A NAME="index.htm_IX_ContDB library"> </A>
<A NAME="index.htm_IX_ContLog library"> </A>

<A NAME="index.htm_26023">
 </A>
Contacts

</H1>
<P>
The Nokia 9000i Communicator has a Contact database which acts as a central repository of &quot;address book&quot; information. Every time the user enters information about how a place may be reached by phone, fax, or e-mail that information is stored in the Contact database.</P>
<P>
Whenever you prompt the user for information about where to send something, you'll probably use the Contact database. This will allow the user to choose which of their contacts should receive. </P>
<P>
There are two libraries which exist to keep track of the Contact database and provide an API for the applications which share access to it. </P>
<UL>
<LI>
The <EM>
ContDB </EM>
library keeps track of the contact information, and may be used to look up or edit contact information. It also provides a controller which allows the user to choose a contact from a list of existing contacts.</LI>
<LI>
The <EM>
ContLog</EM>
library provides an API for logging what sorts of communication has been made with the entities described in the Contact database. It also provides a controller which allows the user to select a recently contacted contact.</LI>
</UL>
<P>
The Contact database is a Foam database, and some operations upon the database will make use of Foam database commands. We will not explore the meanings of these commands closely here, but will show how they are used in the context of the Contact database.</P>
<P>
Before reading this chapter, you should be familiar with controllers, Object-Oriented Programming, and the GEOS messaging system. It helps if you try out the &quot;Contacts&quot; built-in application, which demonstrates much of the functionality we'll discuss here.</P>
<P>
Most programmers first encounter the ContDB and ContLog libraries when they need to intercept a message associated with a <CODE>
ContactList</CODE>
 or perhaps a <CODE>
RecentContactsControl</CODE>
 object. These object classes provide the user with a standard way to choose a contact. </P>
<P>
There are other controllers which allow the user to choose an SMS contact. <CODE>
SMAddressControlClass</CODE>
 allows the user to choose a recipient for a SMS message. This class should cover some applications' needs when it comes to allowing the user to choose a contact. However, if you need a custom control, you may wish to use a <CODE>
ContactList</CODE>
 and/or a <CODE>
RecentContactsSMSControl</CODE>
. </P>
<P>
A <CODE>
ContactList</CODE>
presents the user with a list of known contacts. The user may choose a name from the list. In <A HREF="#ContactDB_1.htm_65699"> Setting up a Contact List</A>
, we show how to set up such an object and get the phone number of the contact the user selects.

</P>
<P>
The <CODE>
RecentContactsSMSControl</CODE>
presents the user with a list containing names and numbers associated with contacts that have recently had SMS transactions with the user. The user may choose a name or number from the list. In <A HREF="#ContactDB_5.htm_82044"> Choosing Contacts From a Log</A>
, we show how to set up such an object and get the phone number of the contact the user selects.

</P>

<P CLASS="sectionlinks">
<STRONG>
&nbsp;&nbsp;<A HREF="#ContactDB_1.htm">1 Setting up a Contact List</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#ContactDB_2.htm">1.1 Multiple-Selection ContactLists</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#ContactDB_3.htm">1.2 Remembering the Search</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#ContactDB_4.htm">1.3 Detecting Unknown Phone Numbers</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#ContactDB_alternate.htm">1.4 Alternate Messages</A><BR>
&nbsp;&nbsp;<A HREF="#ContactDB_5.htm">2 Choosing Contacts From a Log</A><BR>
&nbsp;&nbsp;<A HREF="#ContactDB_6.htm">3 Using a Dedicated Contact</A><BR>
&nbsp;&nbsp;<A HREF="#ContactDB_7.htm">4 Logging Calls</A><BR>
&nbsp;&nbsp;<A HREF="#ContactDB_8.htm">5 To Get More Info on a Contact</A><BR>
&nbsp;&nbsp;<A HREF="#ContactDB_9.htm">6 The User's Own Data</A><BR>
</STRONG>
</P> <!-- end of sectionlinks blob -->

<HR>
<A NAME="ContactDB_1.htm"></A>


<H2 CLASS="sectionTitle">
<A HREF="#index.htm">Contacts</A>: 1 
<A NAME="ContactDB_1.htm_65699">
 </A>
Setting up a Contact List</H2>
<PRE>ContactListClass, CONTACT_LIST_NOTIFY_CONTACT_SELECTED_MSG, ContactGetDBHandle(), FoamDBGetRecordFromID(), FoamDBGetFieldData(), FoamDBDiscardRecord(), ContactReleaseDBHandle()</PRE>
<P>
To present the user with a list of Contacts, do the following:</P>
<P>
Make sure that your .gp file contains lines requiring the <STRONG CLASS="fileName">
foamdb</STRONG>
 and <STRONG CLASS="fileName">
contdb</STRONG>
 libraries:</P>
<PRE>library contdb
library foamdb</PRE>
<P>
In your source code, create a <CODE>
ContactList</CODE>
 object. The following <CODE>
ContactList</CODE>
 object declaration allows the user to pick a contact. If the contact has more than one GSM phone number, the controller will make the user choose one of the fields. </P>
<UL>
<LI>
When the user chooses a contact, the ContactList will send a message to an object The <CODE>
ContactList</CODE>
's <CODE>
GCI_output</CODE>
 and ATTR_CONTACT_LIST_NOTIFY_CONTACT_SELECTED_MSG specify the object and message. In the example below, the application's process object will handle a message. We will discuss the message in more detail below.</LI>
<LI>
To make the <CODE>
ContactList</CODE>
 SMS-specific, set its ATTR_CONTACT_LIST_CALL_TYPE to CCT_SMS as shown below; also, set the CLF_SELECT_CONTACT_NUMBER feature flag in ATTR_GEN_CONTROL_REQUIRE_UI.</LI>
<LI>
To include the <CODE>
ContactList</CODE>
's Search bar, set the CLF_SEARCH feature flag in ATTR_GEN_CONTROL_REQUIRE_UI; to exclude the Search bar, exclude the UI.</LI>
<LI>
Optionally, you can use the standard Contact List bitmap by making your <CODE>
ContactList</CODE>
 a <CODE>
ComplexMoniker</CODE>
 and setting its <CODE>
CMI_iconBitmap</CODE>
 field to CMB_CONTACT_LIST.</LI>
</UL>
<P>
Putting this together, we end up with the following:</P>
<PRE>@object ContactListClass MyContactList = {
  GI_visMoniker = &quot;I want to talk to...&quot;;
  GCI_output = (TO_PROCESS);
  ATTR_CONTACT_LIST_CALL_TYPE = CCT_SMS;
  ATTR_GEN_CONTROL_REQUIRE_UI = CLF_SEARCH |
                       CLF_SELECT_CONTACT_NUMBER ; 
  HINT_EXPAND_HEIGHT_TO_FIT_PARENT;
  ATTR_CONTACT_LIST_NOTIFY_CONTACT_SELECTED_MSG = 
                        MSG_MYPROCESS_SEND_MESSAGE ;
}</PRE>
<P>
With this configuration, the <CODE>
ContactList</CODE>
 will send a <CODE>
MSG_MYPROCESS_SEND_MESSAGE</CODE>
 message to your process object when the user chooses a contact. A sample handler for this message is shown below (<A HREF="#ContactDB_1.htm_31767"> Handling the ContactList's "Selected" Message</A>
). The message will conform to the prototype:</P>
<PRE>@prototype void
    CONTACT_LIST_NOTIFY_CONTACT_SELECTED_MSG(
                                   dword recordID,
                                   word fieldID);</PRE>
<P>
The message handler should carry out the following steps:</P>
<OL>
<LI>
Get the Contact database's handle. To do this, call <CODE>
ContactGetDBHandle()</CODE>
. This routine takes no arguments, and returns the Contact database's handle.</LI>
<LI FIXME_NumListOther>
Get the handle of the record by calling <CODE>
FoamDBGetRecordFromID()</CODE>
. This routine takes the Contact's database handle and the record's <CODE>
RecordID</CODE>
 value. It allocates a block of memory to hold the record's data and returns the record's handle. </LI>
<LI FIXME_NumListOther>
To extract the contact's GSM phone number, call <CODE>
FoamDBGetFieldData()</CODE>
. Pass the database handle, the record handle, the <CODE>
FieldID</CODE>
 associated with the GSM number field (this number is supplied by the <CODE>
ContactList</CODE>
 when it sends this message), a buffer to write the name to, and the size of that buffer. The function fills in the buffer with the phone number string, and returns the length of that string. The returned string might not be null-terminated; thus you will either need to keep track of the returned string length, or else terminate the string.</LI>
<LI FIXME_NumListOther>
Now that you're done with the record, let the database know by calling <CODE>
FoamDBDiscardRecord()</CODE>
. This routine takes the Contact's database handle and the record's handle as arguments.</LI>
<LI FIXME_NumListOther>
Now that you're done with the database, release its handle by calling <CODE>
ContactReleaseDBHandle()</CODE>
.</LI>
</OL>
<P>
The example below shows a way of carrying out the above set of steps.</P>
<P CLASS="figTitle">
Code Display 4-1 <A NAME="ContactDB_1.htm_31767">
 </A>
Handling the ContactList's &quot;Selected&quot; Message</P>
<PRE>@class MyProcessClass, GenProcessClass;
	@message (CONTACT_LIST_NOTIFY_CONTACT_SELECTED_MSG)
						MSG_MYPROCESS_SEND_MESSAGE;
@endc</PRE>
<PRE>@method MyProcessClass, MSG_MYPROCESS_SEND_MESSAGE {
	TCHAR           theNumber[31];
	TCHAR           theName[MAX_NAME_DATA_LEN+1];
	word            numLen;
	VMFileHandle    CDBHandle;
	MemHandle       theRecord;</PRE>
<PRE>		/* Get the Contact database's handle */
	CDBHandle = ContactGetDBHandle();</PRE>
<PRE>		/* Get the handle to the record we're interested in */
	theRecord = FoamDBGetRecordFromID( CDBHandle, recordID );</PRE>
<PRE>		/* Get the GSM phone number string; null-terminate it. */
	FoamDBGetFieldData( CDBHandle, theRecord, fieldID, theNumber, 30);
	theNumber[numLen] = `\000'; /* add null terminator */</PRE>
<PRE>		/* We'll copy the name to theName buffer. */
	ContactGetName(theRecord, theName);

		/* If you need more information about the contact 
		 * (e.g., business name, job title), this is a good place 
		 * to retrieve it. */

	/* Do what you like with theNumber and theName */</PRE>
<PRE>		/* We're done with this record. */
	FoamDBDiscardRecord(CDBHandle, theRecord );</PRE>
<PRE>		/* We're done with the database. */
	ContactReleaseDBHandle();
}</PRE>
<P CLASS="subsectionLink">
<A HREF="#ContactDB_2.htm">Multiple-Selection ContactLists</A></P>
<P CLASS="subsectionLink">
<A HREF="#ContactDB_3.htm">Remembering the Search</A></P>
<P CLASS="subsectionLink">
<A HREF="#ContactDB_4.htm">Detecting Unknown Phone Numbers</A></P>
<P CLASS="subsectionLink">
<A HREF="#ContactDB_alternate.htm">Alternate Selection Messages</A></P>
<HR>
<A NAME="ContactDB_2.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Contacts</A>: 1.1 <A HREF="#ContactDB_1.htm">Setting up a Contact List</A>: 
<A NAME="ContactDB_2.htm_49077">
 </A>
Multiple-Selection ContactLists</H3>
<A NAME="ContactDB_2.htm_IX_ATTR_CONTACT_LIST_NON_EXCLUSIVE_LIST"> </A>
<P>
Recent versions of the ContDB library support ContactLists which allow the user to select more than one contact at a time. This feature is available on devices with version numbers &quot;Responder Build 4....&quot; and higher. See <A HREF="../../Nokia9000/Versions/Update_1.htm">Software Version Number</A>
 for information about finding out the software version of the user's device.)</P>
<P>
To create such a ContactList, give it the hint <CODE> HINT_CONTACT_LIST_NON_EXCLUSIVE_LIST</CODE>. The field <CODE>ATTR_CONTACT_LIST_NUM_ITEMS</CODE> will then store the number of selected contacts.  
<P>
There are two methods which may be used to obtain the list of currently selected contacts:
<UL>
	<LI>Allocate a buffer to store a list of contacts, and query the ContactList with <CODE>MSG_CONTACT_LIST_GET_IDS_OF_SELECTED_RECORDS</CODE>, using  the size of this buffer (in bytes) as the input parameter. The message will fill the buffer with the selected <CODE>ContactListSelectedEntry</CODE>s.
	<LI>Set the flag <CODE>CLF_SELECT_CONTACT_NUMBER</CODE> in <CODE>ATTR_GEN_CONTROL_REQUIRE_UI</CODE>, and set <CODE> ATTR_CONTACT_LIST_NOTIFY_MULTIPLE_CONTACTS_SELECTED_MSG</CODE> to the message which will be sent whenever two or more contacts are selected from the contact list. This message must be of the prototype:
<PRE>
        @prototype void 
            CONTACT_LIST_NOTIFY_MULTIPLE_CONTACTS_SELECTED_MSG(
				MemHandle block = cx, 
				word num = dx);
</PRE>

The passed memory handle <EM>block</EM> will contain the set of <CODE>ContactListSelectedEntry</CODE>s, and <CODE>num</CODE> will contain the number of these entries. Your message must free the passed memory block.
</UL>

<HR>
<A NAME="ContactDB_3.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Contacts</A>: 1.2 <A HREF="#ContactDB_1.htm">Setting up a Contact List</A>: 
<A NAME="ContactDB_3.htm_45810">
 </A>
Remembering the Search</H3>
<A NAME="ContactDB_3.htm_IX_MSG_CONTACT_LIST_PRESERVE_SEARCH_ON_NEXT_LOST_FOCUS"> </A>
<P>
Normally, a ContactList will lose track of the user's current search if the focus moves to another object.  To force the list to remember the current search, send it a MSG_CONTACT_LIST_PRESERVE_SEARCH_ON_NEXT_LOST_FOCUS before it loses the focus.  (This message is available on devices with version numbers &quot;Responder Build 4....&quot; and higher. See <A HREF="../../Nokia9000/Versions/Update_1.htm">Software Version Number</A>
 for information about finding out the software version of the user's device.)</P>
<HR>
<A NAME="ContactDB_4.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Contacts</A>: 1 <A HREF="#ContactDB_1.htm">Setting up a Contact List</A>: 
<A NAME="ContactDB_4.htm_49596">
 </A>
1.3 Detecting Unknown Phone Numbers</H3>
<P>
If the user enters a valid phone number in the search box of a ContactList, but that number is not found, an application may request that the ContactList send out a notification using a variable data field. (This variable data field is available on devices with version numbers &quot;Responder Build 4....&quot; and higher. See <A HREF="../../Nokia9000/Versions/Update_1.htm">Software Version Number</A>
 for information about finding out the software version of the user's device.)</P>

<A NAME="ContactDB_4.htm_IX_ATTR_CONTACT_LIST_NOTIFY_NUMBER_ENTERED_MSG"> </A>
<P>
Give the ContactList a ATTR_CONTACT_LIST_NOTIFY_NUMBER_ENTERED_MSG variable data field.  This field's data is a message.</P>
<P>
The message should have parameters:</P>
<PRE>  void MSG_MY_CL_NOTIFY( MemHandle phNumber = cx);</PRE>
<P>
The passed block contains the phone number string. The message's recipient is responsible for freeing the passed block.</P>
<P>
&nbsp;</P>
<HR>
<A NAME="ContactDB_alternate.htm"></A>
<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Contacts</A>: 1 <A HREF = "ContactDB_1.htm">Setting up a Contact List</A> : 1.4 Alternate Selection Messages </H3>

<P>
Builds 4.3.7 or newer of the Responder (see <A HREF = "../../Nokia9000/Versions/Update_1.htm">versions</A> for more information about software versions) support two different methods for selecting contacts from a <CODE>CCT_PHONE</CODE> type of contact controller list. If the user quickly presses the &quot;Select&quot; trigger (F1 on the PC emulator), then, depending on the circumstances, the message specified by <CODE>ATTR_CONTACT_LIST_NOTIFY_CONTACT_SELECTED_MSG</CODE>, <CODE>ATTR_CONTACT_LIST_NOTIFY_NUMBER_ENTERED_MSG</CODE>, or
<CODE>ATTR_CONTACT_LIST_NOTIFY_MULTIPLE_CONTACTS_SELECTED_MSG</CODE> is sent. If the user holds the &quot;Select&quot; trigger for a longer time period, an alternate type of message analogous to the normal selection message is sent. These alternate messages include:
<P>
<DL>
<DT><A NAME="ContactDB_alternate.htm_IX_ATTR_CONTACT_LIST_ALTERNATE_NOTIFY_CONTACT_SELECTED_MSG"></A><CODE>ATTR_CONTACT_LIST_ALTERNATE_NOTIFY_CONTACT_SELECTED_MSG</CODE> </DT>
<DD>Set this to the message which will be called when the user selects a contact from the list after holding the &quot;Select&quot; trigger for a long duration. If more than one contact was selected then this message returns the first selection. This message must follow the prototype:</P>
<A NAME="ContactDB_alternate.htm_IX_CONTACT_LIST_ALTERNATE_NOTIFY_CONTACT_SELECTED_MSG"></A>
<PRE CLASS="syntax">
@prototype void CONTACT_LIST_ALTERNATE_NOTIFY_CONTACT_SELECTED_MSG(
                                dword recordID = cx:dx,
                                word fieldID = bp);
</PRE>
<EM>fieldID</EM> is the ID of the field containing the selected GSM phone number of the record with the ID <EM>recordID</EM>. <P>
</DD>

<DT><A NAME="ContactDB_alternate.htm_IX_ATTR_CONTACT_LIST_ALTERNATE_NOTIFY_NUMBER_ENTERED_MSG"></A><CODE>ATTR_CONTACT_LIST_ALTERNATE_NOTIFY_NUMBER_ENTERED_MSG</CODE> </DT>
<DD>Set this to the message which should be sent when the user has entered a valid phone number in the search field which does not match any record in the contact list and the user has held the trigger for a long duration. For this message to be sent, <CODE>CLF_SELECT_CONTACT_NUMBER</CODE> must be set. The message must follow the prototype:</P>
<A NAME="ContactDB_alternate.htm_IX_CONTACT_LIST_ALTERNATE_NOTIFY_NUMBER_ENTERED_MSG"></A>
<PRE CLASS="syntax">
@prototype void CONTACT_LIST_ALTERNATE_NOTIFY_NUMBER_ENTERED_MSG(
                                MemHandle block = cx);
</PRE>
</P>
<EM>block</EM> will contain the null-terminated phone number.<P>
</DD>

<DT><A NAME="ContactDB_alternate.htm_IX_ATTR_CONTACT_LIST_ALTERNATE_NOTIFY_MULTIPLE_CONTACTS_SELECTED_MSG"></A><CODE> ATTR_CONTACT_LIST_ALTERNATE_NOTIFY_MULTIPLE_CONTACTS_SELECTED_MSG</CODE> </DT>
<DD>Set this to the message which will be sent when the user selects 1 or more contacts from the list and holds the &quot;Select&quot; trigger for a long duration. Note that  <CODE>CLF_SELECT_CONTACT_NUMBER</CODE> and <CODE>HINT_NON_EXCLUSIVE_LIST</CODE> must be present for multiple selection contact lists. This message must follow the prototype:</P>
<A NAME="ContactDB_alternate.htm_IX_CONTACT_LIST_ALTERNATE_NOTIFY_MULTIPLE_CONTACTS_SELECTED_MSG"></A>
<PRE CLASS="syntax">
@prototype void CONTACT_LIST_ALTERNATE_NOTIFY_MULTIPLE_CONTACTS_SELECTED_MSG(
                                MemHandle block = cx, 
                                word num = dx);
</PRE>
<EM>block</EM> will contain the <EM>num</EM> <CODE>ContactListSelectedEntry</CODE> selected items.
</DD>
</DL>

<HR>
<A NAME="ContactDB_5.htm"></A>


<H2 CLASS="sectionTitle">
<A HREF="#index.htm">Contacts</A>: 2 
<A NAME="ContactDB_5.htm_82044">
 </A>
Choosing Contacts From a Log</H2>
<PRE>RecentContactsSMSControlClass, CONTACTS_CONTROL_NOTIFY_ENTRY_SELECTED_MSG</PRE>
<A NAME="ContactDB_5.htm_IX_RecentContactsControlClass:RecentContactsSMSControl in an example"> </A>
<A NAME="ContactDB_5.htm_IX_RecentContactsSMSControlClass"> </A>
<A NAME="ContactDB_5.htm_IX_ATTR_RECENT_CONTACTS_CONTROL_NOTIFY_ENTRY_SELECTED_MSG"> </A>
<A NAME="ContactDB_5.htm_IX_CONTACTS_CONTROL_NOTIFY_ENTRY_SELECTED_MSG"> </A>

<P>
For a list of recent SMS contacts, use a <CODE>
RecentContactsSMSController</CODE>
. You will need the following line in your <STRONG CLASS="fileName">
.gp</STRONG>
 file:</P>
<PRE>library		contlog</PRE>
<P>
The following setup would allow the user to pick a phone number from a list of recently called SMS numbers, sending a <CODE>
MSG_MYPROCESS_SEND_RECENT</CODE>
 message to the application's process object:</P>
<PRE>		@object RecentContactsSMSControlClass MyLog = {
			GCI_output = ( TO_PROCESS );
			ATTR_RECENT_CONTACTS_CONTROL_NOTIFY_ENTRY_SELECTED_MSG = 
							MSG_MYPROCESS_SEND_RECENT;
		}</PRE>
<P>
With this setup, when the user chooses a phone number from the log, a <CODE>
MSG_MYPROCESS_SEND_RECENT</CODE>
 message will be sent to the process object, which should handle the message. The message should conform to the CONTACTS_CONTROL_NOTIFY_ENTRY_SELECTED_MSG prototype. </P>

<A NAME="ContactDB_5.htm_IX_RecentContactsData"> </A>
<A NAME="ContactDB_5.htm_IX_RCD_&ldots;"> </A>

<PRE>@prototype void
    CONTACTS_CONTROL_NOTIFY_ENTRY_SELECTED_MSG(
                           RecentContactsData *data)</PRE>
<PRE>typedef struct {
	dword               RCD_contactID;
	NameOrNumber        RCD_number;
} RecentContactsData;</PRE>
<P>
The <EM>data</EM> argument's <CODE>
RCD_number</CODE>
 field contains the GSM phone number of the selected contact. The code example below shows handler that extract's the name associated with the selected contact. It makes use of functions described in <A HREF="#ContactDB_1.htm_65699"> Setting up a Contact List</A>
.</P>
<P CLASS="figTitle">
Code Display 4-2 <A NAME="ContactDB_5.htm_86000">
 </A>
Handling the RecentContacts &quot;Selected&quot; Message</P>
<PRE>@class MyProcessClass, GenProcessClass;
	@message (CONTACTS_CONTROL_NOTIFY_ENTRY_SELECTED_MSG)
						MSG_MYPROCESS_SEND_RECENT;
@endc</PRE>
<PRE>@method MyProcessClass, MSG_MYPROCESS_SEND_RECENT {</PRE>
<PRE>	/* Note: all of the code in this example is only useful if you need 
	 * the contact's name. If all you need is the GSM phone number, 
	 * none of this code is necessary. The phone number string is in 
	 * data-&gt;RCD_number. 
	 * 
	 * If you do need the following code, you will need to make sure 
	 * that your .gp file includes the lines
		library contdb
		library foamdb
	 */</PRE>
<PRE>	TCHAR           theName[MAX_NAME_DATA_LEN+1];
	VMFileHandle    CDBHandle;
	MemHandle       theRecord;</PRE>
<PRE>		/* If the user chose a phone number that doesn't have a contact 
		 * associated with it, the contact's RecordID value is -1, 
		 * signalling an invalid contact. */
	if ( data-&gt;RCD_contactID != LECI_INVALID_CONTACT_ID) {
	 CDBHandle = ContactGetDBHandle();
	 theRecord = FoamDBGetRecordFromID( CDBHandle, data-&gt;RCD_contactID );</PRE>
<PRE>	 ContactGetName(theRecord, theName);

		/* If you need more information about the contact 
		 * (e.g., business name, job title), this is a good place 
		 * to retrieve it. */

	 FoamDBDiscardRecord(CDBHandle, theRecord );
	 ContactReleaseDBHandle();
	}

	/* do something clever with data-&gt;RCD_number and theName */
}</PRE>

<P>
Recent <A HREF = "../../Nokia9000/Versions/index.htm">versions</A> of the Nokia 9000i Communicator allow fax and SMS contact lists to support multiple selections. Set the <CODE>RCFCF_MULTIPLE_SELECTION</CODE> or <CODE>RCMCF_MULTIPLE_SELECTION</CODE> bit to enable multiple selection for, respectively, a fax or SMS recent contact list and specify the message <A NAME="ContactDB_5.htm_IX_ATTR_RECENT_CONTACTS_CONTROL_NOTIFY_ENTRY_SELECTED_MSG"></A> <CODE>ATTR_RECENT_CONTACTS_CONTROL_NOTIFY_ENTRY_SELECTED_MSG</CODE> which will be sent when the user chooses an item from the list.
<HR>
<A NAME="ContactDB_6.htm"></A>


<H2 CLASS="sectionTitle">
<A HREF="#index.htm">Contacts</A>: 3 
<A NAME="ContactDB_6.htm_85958">
 </A>
Using a Dedicated Contact</H2>
<PRE>ContactMatchName(), ContactEnsureField()</PRE>
<A NAME="ContactDB_6.htm_IX_ContactMatchName():description"> </A>
<A NAME="ContactDB_6.htm_IX_ContactEnsureField():description"> </A>
<P>
Perhaps you're writing a special-purpose application that is supposed to communicate with just one contact. Perhaps a carry-out restaurant chain has contracted you to write an application that the user can use to place an order over the phone. The program would only need to make contact with one place: the local restaurant's GSM phone number.</P>
<P>
In this case, you wouldn't want to provide any gadgetry for choosing a contact--your program is only interested in one dedicated contact. Still, it's worthwhile to store the contact in the Contact database--if the restaurant's phone number changes, the user can enter the corrected number using the Contact Manager built-in application. </P>
<P>
To find the Contact record for a particular contact, you will need to make sure that your <STRONG CLASS="fileName">
.gp</STRONG>
 file contains the following lines:</P>
<PRE>library contdb
library foamdb</PRE>
<P>
<A HREF="#ContactDB_6.htm_33238"> Finding the "Stuckey's Snack Shack" Contact</A>
, below, shows an example of how you could find a dedicated contact in the Contact database, and extract the phone number associated with that contact.</P>
<P>
To locate a dedicated contact and extract its phone number, carry out the following steps:</P>
<OL>
<LI>
To get the <CODE>
RecordID</CODE>
 of the contact's record, call <CODE>
ContactMatchName()</CODE>
. This routine takes a search string (pass the contact's name), a <CODE>
ContdbFieldType</CODE>
 (pass CFT_NAME, since we're searching by name), a flag (pass a non-zero value to specify that you're only interested in one matching record), a pointer to a <CODE>
FieldID</CODE>
 buffer to fill in and a pointer to a word value to fill in. It returns the <CODE>
RecordID</CODE>
 of the contact (or -1 if the contact wasn't found). It also fills in the <CODE>
FieldID</CODE>
 buffer with the contact's name field <CODE>
FieldID</CODE>
 and fills in the word value with the number of matches found; neither of these values is important to our purpose.<BR>
If the contact is not found, there are a couple of approaches the application can take:<BR>
¸ Create a new record with the proper name and a guess at the phone number. The code example below illustrates this approach.<BR>
¸ Signal to the user that an error has occured and halt the current operation.</LI>
<LI FIXME_NumListOther>
Get the Contact database's handle. To do this, call <CODE>
ContactGetDBHandle()</CODE>
. This routine takes no arguments and returns the database's handle.</LI>
<LI FIXME_NumListOther>
Get the record's handle by calling <CODE>
FoamDBGetRecordFromID()</CODE>
. This routine takes the Contact database's handle and the record's <CODE>
RecordID</CODE>
. It returns the record's memory handle.</LI>
<LI FIXME_NumListOther>
Get the <CODE>
FieldID</CODE>
 of the record's GSM phone number field. In the example below, we assume that the record has only one phone number field, and that this is the field we want. For a more rigorous approach, we could examine each field to make sure it was named &quot;Tel (GSM)&quot;. For an example of how one might examine all the fields of a record, see <A HREF="#ContactDB_8.htm_53240"> To Get More Info on a Contact</A>
.<BR>
For our shortcut, we use the <CODE>
ContactEnsureField()</CODE>
 function. This function takes as arguments a record handle, a field name string (in our example, we pass a null optr to specify that we should use the default field name, and the <CODE>
ContdbFieldType</CODE>
 of the field to find ( pass CFT_PHONE). The function returns a <CODE>
FieldID</CODE>
.</LI>
<LI FIXME_NumListOther>
To extract the phone number data, call <CODE>
FoamDBGetFieldData()</CODE>
. Pass the database handle, the record handle, the <CODE>
FieldID</CODE>
, a buffer to write the name to, and the size of that buffer. The function fills in the buffer with the phone number string, and returns the length of that string. The returned string might not be null-terminated; thus you will either need to keep track of the returned string length, or else terminate the string.</LI>
<LI FIXME_NumListOther>
Now that you're done with the record, let the database know by calling <CODE>
FoamDBDiscardRecord()</CODE>
. This routine takes the Contact's database handle and the record's handle as arguments.</LI>
<LI FIXME_NumListOther>
Now that you're done with the database, release its handle by calling <CODE>
ContactReleaseDBHandle()</CODE>
.</LI>
</OL>
<P CLASS="figTitle">
Code Display 4-3 <A NAME="ContactDB_6.htm_33238">
 </A>
Finding the &quot;Stuckey's Snack Shack&quot; Contact</P>
<PRE>TCHAR 		theName[]=		&quot;Stuckey's Snack Shack&quot;;
TCHAR 		gsmNum[MAX_NUMBER_FIELD_DATA_LEN] = &quot;1.800.788.2539&quot;
word 		gsmNumLen;
FieldID 		theField;
word		dummyNumMatches;
RecordID		theRecordID;
Memhandle 		theRecord;
VMFileHandle 		CDBHandle;</PRE>
<PRE>theRecordID = ContactMatchName(theName, CFT_NAME,1, &amp;theField, &amp;dummnyNumMatches);
if ( theRecordID == LECI_INVALID_CONTACT_ID) { /* If we didn't find the record...*/
  theRecord = ContactCreateRecordFromTemplate(); /* ... then we create it */

  /* Fill in the name field; here @TelGSMStr is a chunk holding the string
   * &quot;Tel(GSM)&quot; */
  theField = ContactEnsureField( theRecord, NullOptr, CFT_NAME );
  CDBHandle = ContactGetDBHandle();
  FoamDBSetFieldData( CDBHandle, theRecord,theField, theName, sizeof(theName)-1 );
  /* Fill in the fax field of new record with default GSM number string */
  /* Fill in the name field; here @TelGSMStr is a chunk holding the string
   * &quot;Tel(GSM)&quot; */
  theField = ContactEnsureField( theRecord, @TelGSMStr, CFT_PHONE );
  FoamDBSetFieldData( CDBHandle, theRecord, theField, gsmNum, 14 );

  ContactReleaseDBHandle();
  /* Save the newly created record to the Contact DB */
  theRecordIIndex = ContactSaveRecord( theRecord );
  theRecord = FoamDBGetVisibleRecord( CDBHandle, theRecordIndex );
}</PRE>
<PRE>else { /* If we successfully found the record, then get its handle */
CDBHandle = ContactGetDBHandle();
theRecord = FoamDBGetRecordFromID( CDBHandle, theRecordID);
}</PRE>
<PRE>/* Whether we found the record or just now created it, we now have 
 * its handle and can extract the information that we want. */
  /* Fill in the name field; here @TelGSMStr is a chunk holding the string
   * &quot;Tel(GSM)&quot; */
theField = ContactEnsureField( theRecord, @TelGSMStr, CFT_PHONE );
/* Copy the fax number into our buffer */
gsmNumLen = FoamDBGetFieldData( CDBHandle, theRecord, theField, gsmNum,
						MAX_NUMBER_FIELD_DATA_LEN);
gsmNum[gsmNumLen]= `\000`</PRE>
<PRE>	/* If we need more information about the contact (e.g., street address,
	 * fax number, etc.) this would be a good place to get it. */</PRE>
<PRE>FoamDBDiscardRecord( CDBHandle, theRecord );
ContactReleaseHandle();

/* Do something clever with theName and gsmNum */</PRE>
<P>
To allow the user to edit the contact information for this single contact, use a <CODE>
ContactEdit</CODE>
 object. To specify the contact that the user will work with, you will need its handle. Pass the handle as an argument to the MSG_CONTACT_EDIT_DISPLAY_RECORD message. (Don't call <CODE>
ContactSaveRecord()</CODE>
, <CODE>
FoamDBDeleteRecord()</CODE>
, or <CODE>
FoamDBDiscardRecord()</CODE>
 when done with this handle; the controller will do so.)</P>
<HR>
<A NAME="ContactDB_7.htm"></A>


<H2 CLASS="sectionTitle">
<A HREF="#index.htm">Contacts</A>: 4 
<A NAME="ContactDB_7.htm_44804">
 </A>
Logging Calls</H2>
<PRE>LogAddEntry()</PRE>
<A NAME="ContactDB_7.htm_IX_LogAddEntry()"> </A>
<A NAME="ContactDB_7.htm_IX_LogEntry"> </A>
<A NAME="ContactDB_7.htm_IX_LE_&ldots;"> </A>
<A NAME="ContactDB_7.htm_IX_LEF_WILDCARD_NUMBER:logging unknown phone numbers"> </A>
<A NAME="ContactDB_7.htm_IX_Logging communications"> </A>

<P>
If you wish to log incoming or outgoing messages, you will use the <CODE>
LogAddEntry()</CODE>
 function, provided by the <STRONG CLASS="fileName">
contlog</STRONG>
 library. Make sure that you your<STRONG CLASS="fileName">
 .gp</STRONG>
 file contains the line</P>
<PRE>library contlog</PRE>
<P>
When it comes time to make the call that you want to log, carry out the following steps:</P>
<OL>
<LI>
Set up a <CODE>
LogEntry</CODE>
 structure and call <CODE>
LogAddEntry()</CODE>
. The code shown in <A HREF="#ContactDB_7.htm_43403"> Logging an SMS Call</A>
 would be appropriate for logging an outgoing message; to log an incoming message, substitute LED_RECEIVED for LED_SENT. </LI>
<LI FIXME_NumListOther>
Make the call.</LI>
<LI FIXME_NumListOther>
When the call is done, call <CODE>
LogAddEntry()</CODE>
 again, passing the same <CODE>
LogEntry</CODE>
 structure as before, after writing the duration (in seconds) in the <CODE>
LogEntry</CODE>
's <CODE>
LE_duration</CODE>
 field. (The previous invokation of <CODE>
LogAddEntry()</CODE>
 will have filled in the <CODE>
LogEntry</CODE>
's <CODE>
LE_flags</CODE>
 field with correct values.)</LI>
</OL>
<P CLASS="figTitle">
Code Display 4-4 <A NAME="ContactDB_7.htm_43403">
 </A>
Logging an SMS Call</P>
<PRE>LogEntry MyEntry ;
dword 		duration;
TimerDateAndTime tdat;
TimerGetDateAndTime(&amp;tdat);
duration = TimerGetCount();</PRE>
<PRE>strcpy( MyEntry-&gt;LE_number, theNumber);
MyEntry.LE_contactID = recordID;
MyEntry.LE_type = LET_SMS;
MyEntry.LE_direction = LED_SENT; 
MyEntry.LE_duration = 1;
MyEntry.LE_dateTime.DAT_year = tdat.TDAT_year;
MyEntry.LE_datetime.DAT_month = tdat.TDAT_month;
MyEntry.LE_datetime.DAT_day = tdat.TDAT_day;
MyEntry.LE_datetime.DAT_hour = tdat.TDAT_hours;
MyEntry.LE_datetime.DAT_minute = tdat.TDAT_minutes;</PRE>
<PRE>LogAddEntry( &amp;MyEntry );</PRE>
<PRE>/* Send the message, and when done...*/</PRE>
<PRE>MyEntry.LE_duration = TimerGetCount() - duration;</PRE>
<PRE>LogAddEntry( &amp;MyEntry );</PRE>
<P>
When using the Contact Log library to log a contact, if you don't know the phone number, you can pass LEF_WILDCARD_NUMBER to <CODE>
LogAddEntry() </CODE>
to specify that this call's number should match any phone number. This is only allowed on devices with version numbers &quot;Responder Build 4....&quot; and higher. See <A HREF="../../Nokia9000/Versions/Update_1.htm">Software Version Number</A>
 for information about finding out the software version of the user's device.</P>
<HR>
<A NAME="ContactDB_8.htm"></A>


<H2 CLASS="sectionTitle">
<A HREF="#index.htm">Contacts</A>: 5 
<A NAME="ContactDB_8.htm_53240">
 </A>
To Get More Info on a Contact</H2>
<PRE>FoamDBFieldEnum(), FoamDBGetFieldType(), FoamDBGetFieldName()</PRE>
<P>
In the examples above, we've shown how to get a selected contact's name and GSM phone number. It is possible to get more information about a contact given its <CODE>
RecordID</CODE>
 number.</P>
<P>
In the examples shown in <A HREF="#ContactDB_1.htm_31767"> Handling the ContactList's "Selected" Message</A>
, <A HREF="#ContactDB_5.htm_86000"> Handling the RecentContacts "Selected" Message</A>
, and <A HREF="#ContactDB_6.htm_33238"> Finding the "Stuckey's Snack Shack" Contact</A>
 there is a comment noting a good place to get more information about a contact. If, for some reason, you need to find out information about a Contact in a context other than shown in one of those examples, </P>
<OL>
<LI>
You will need the record's <CODE>
RecordID</CODE>
 number. Presumedly, you've stored away this number after using code like that shown in one of the examples shown above.<BR>
To query a <CODE>
ContactList</CODE>
 object for the <CODE>
RecordID</CODE>
 of its selected record, use the <CODE>
MSG_CONTACT_LIST_GET_ID_OF_SELECTED_RECORD</CODE>
 message. This message takes no arguments, and returns a <CODE>
RecordID</CODE>
.</LI>
<LI>
Gain access to the Contact database by calling <CODE>
ContactGetDBHandle()</CODE>
, storing the returned handle.</LI>
<LI>
To access the database record corresponding to the selected contact, call <CODE>
FoamDBGetRecordFromID()</CODE>
. This returns the record's handle.</LI>
<LI>
Get the contact information you need. Information about how you might do this is described in the paragraphs following this checklist.</LI>
<LI>
When you're done with the record handle, call <CODE>
FoamDBDiscardRecord()</CODE>
 to free the handle.</LI>
<LI>
Be sure to call <CODE>
ContactReleaseDBHandle()</CODE>
 to signal you're done with the database. You shouldn't keep the handle around for long; doing so prevents the file from being closed.</LI>
</OL>
<P>
To find out any other sort of information about the contact, you'll need to access one of the fields of the record. Fields within a Foam DB record (the Contact DB is a Foam DB) are identified by a <CODE>
FieldID</CODE>
 number. </P>
<A NAME="ContactDB_8.htm_IX_FoamDBFieldEnum():in Contact DB example"> </A>
<A NAME="ContactDB_8.htm_IX_FoamDBGetFieldData():in Contact DB example"> </A>
<A NAME="ContactDB_8.htm_IX_FoamDBGetFieldName():in Contact DB example"> </A>

<P>
The <CODE>
FoamDBFieldEnum()</CODE>
 function provides a way to scan all the fields of a record. The following code snippet shows how you might use <CODE>
FoamDBFieldEnum()</CODE>
 to search for all of a contact's voice phone numbers. <CODE>
FoamDBFieldEnum()</CODE>
 calls a callback routine for each of the record's fields. <CODE>
FoamDBFieldEnum()</CODE>
 takes as arguments a record handle, a pointer to a data buffer (this pointer will be passed to the callback routine; it gives you a way to pass data to the callback; in our example, we pass the record handle in the buffer), and a pointer to a callback function. The callback function is passed a <CODE>
FieldHeader</CODE>
 structure and a pointer to the data buffer that was passed to<CODE>
 FoamDBFieldEnum()</CODE>
. From the FieldHeader, it can get the <CODE>
FieldID</CODE>
 from the <CODE>
FieldHeader</CODE>
's <CODE>
FH_id</CODE>
 field. To get information about each field, use the <CODE>
FoamDBGetFieldType()</CODE>
, <CODE>
FoamDBGetFieldName()</CODE>
, and/or <CODE>
FoamDBGetFieldData()</CODE>
 routines. Each of these routines takes the contact database handle, a record handle, a <CODE>
FieldID</CODE>
, and a pointer to a buffer to fill with a return value.</P>
<P CLASS="figTitle">
Code Display 4-5 Checking All Fields of a Contact</P>
<P CLASS="figCaption">
In this example, we check all fields of a contact, and build up an array with the names and data for those fields that correspond to voice phone numbers. </P>
<P CLASS="figCaption">
In this example, all we know at the start is the record's RecordID number. </P>
<PRE>void BuildNumberList( RecordID recordID ) {
	/* Scan all fields of the Contact record */
	/* For each one that corresponds to a voice phone number, store 
	 * the field's name (e.g., &quot;Phone&quot;) and data (e.g., &quot;555-1212&quot;) in
	 * the global Data array. */

	VMFileHandle 		CDBHandle;
	MemHandle		curRecord;</PRE>
<PRE>	CDBHandle = ContactGetDBHandle();
	curRecord = FoamDBGetRecordFromID( CDBHandle, recordID );
	NumberOfNumbers = 0			/* Global variable: 
					number of elements in Data array*/
	FoamDBFieldEnum( curRecord, &amp;curRecord, &amp;BuildNumberListCallback );
	FoamDBDiscardRecord( CDBhandle, curRecord) ; /* Done with the record */
	ContactReleaseDBHandle(); /* Done with the Contact DB for now */
}</PRE>
<PRE>Boolean _pascal BuildNumberListCallback( FieldHeader *field, void *enumData ) {
	VMFileHandle		CDBHandle;
	byte		fieldType;
	MemHandle		curRecord = *((MemHandle *) enumData );</PRE>
<PRE>	CDBandle = ContactGetDBHandle();
	FoamDBGetFieldType( CDBHandle, curRecord, field-&gt;FH_id, &amp;fieldType);
	if (fieldType == CFT_PHONE ) { /* For each voice phone number */
				/* To look for something other than a phone 
				 * number, we would use a different 
				 * ContdbFieldType value. */
					/* Grab the field name */
	  FoamDBGetFieldName( CDBHandle, curRecord, field-&gt;FH_id, 
			Data[NumberOfNumbers].fName, MAX_FIELD_LABEL_LEN);
					/* Grab the field data */
					/* If the data has zero length, func will
					 * return zero. */
	  if (FoamDBGetFieldData( CDBHandle, curRecord, field-&gt;FH_id, 
			Data[NumberOfNumbers].fData, MAX_FIELD_NUMBER_DATA_LEN)) {
					/* If the data was not of zero length
					 * (wasn't just a blank field), then 
					 * up our NumberOfNumbers. */
	    NumberOfNumbers++;
	  }
	}
	ContactReleaseDBHandle(); 	/* We're done with the database */
				/* if we return non-zero, we'll stop Enum'ing 
				 * through the fields. Since we only have room
				 * for 10 fields in our array... */
	return( NumberOfNumbers &gt; 10) ; 
}</PRE>
<P>
As shown above, to get the field data and field name associate with a field, use the <CODE>
FoamDBGetFieldData()</CODE>
 and <CODE>
FoamDBFGetFieldName()</CODE>
 functions. Many users will leave blank fields in their contact records; to test for a blank field, check <CODE>
FoamDBGetFieldData()</CODE>
's return value; if it's zero, then the user has not filled in that field of the contact information.</P>
<HR>
<A NAME="ContactDB_9.htm"></A>


<H2 CLASS="sectionTitle">
<A HREF="#index.htm">Contacts</A>: 6 
The User's Own Data</H2>
<PRE>ContactGetUserDataName(), ContactGetUserDataID()</PRE>
<P>
Recent versions of the ContDB library provide routines which access the user's own contact information. These routines are only available on devices with version numbers &quot;Responder Build 4....&quot; and higher. See <A HREF="../../Nokia9000/Versions/Update_1.htm">Software Version Number</A>
 for information about finding out the software version of the user's device.</P>
<A NAME="ContactDB_9.htm_IX_ContactGetUserDataName():description"> </A>
<A NAME="ContactDB_9.htm_IX_ContactGetUserDataID():description"> </A>
<P>
The ContDB library provides two routines useful for accessing the contact information the user has specified for themself. The <CODE>
ContactGetUserDataName()</CODE>
 routine returns the user's name string. <CODE>
ContactGetUserDataID()</CODE>
 returns the record ID number of a record which contains the user's contact information.</P>
<HR>
<A NAME=""></A>
This document is a single-page version of a <A HREF="index.htm">a multi-page document</A>, suitable for easy printing.
</BODY>
</HTML>
