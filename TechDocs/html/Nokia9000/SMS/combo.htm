<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD>
<!-- This page was automatically generated from a bunch of smaller pages. -->
<META NAME="copyright" CONTENT="Copyright GEOWORKS">
<LINK REL="STYLESHEET" HREF="../../docHelpers/style.css">
<LINK REV="MADE" HREF="mailto:doc-feedback@geoworks.com">
<TITLE>SMS Guide</TITLE>
</HEAD>
<BODY BGCOLOR="#ffffdf">
This document is a single-page version of a <A HREF="index.htm">a multi-page document</A>, suitable for easy printing.
<A NAME="index.htm"></A>



<H1 CLASS="chapterTitle">

<A NAME="index.htm_26023">
 </A>
SMS Guide

</H1>
<P>
The Short Message Service (SMS) is a protocol designed to transmit short alpha-numeric messages via a dedicated cellular provider's &quot;service center.&quot; SMS is built into the GSM (Global System for Mobile communications) standard that has gained general acceptance within Europe; SMS will also most likely be integrated into whatever digital cellular network becomes the de-facto standard within the United States.</P>
<P>
The Nokia 9000i Communicator is compliant with the transmission and 
reception of SMS protocol messages according to the GSM standard. With 
SMS, it is possible to create applications and services that request 
and retrieve short text messages (up to 160 characters) to any server 
or user on the GSM network. The ability to send and receive short 
messages can enable a wide variety of services. For example, short 
messages can be used to retrieve stock quotes, place horse-racing bets 
at a paramutual facility, or play chess with another member of the GSM 
network. The possible uses for the SMS protocol are almost limitless. 
A service need only be connected to the GSM network.</P>
<P>
Geoworks' Mailbox library includes built-in transmission and receipt of SMS messages. The elements of the Mailbox library that are of concern to SMS application developers have been excerpted and included in this chapter.You will not need to understand the inner workings of the Mailbox library to write an SMS application or service.</P>
<P>
Before reading this chapter, you should be familiar with cellular technologies, the SMS standard and elementary GEOS programming--in particular, the use of GEOS Virtual Memory (VM) files.</P>
&nbsp;&nbsp;<A HREF="#SMS_1.htm">1 SMS Overview</A><BR>
&nbsp;&nbsp;<A HREF="#SMS_2.htm">2 Using the Mailbox Library</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#SMS_3.htm">2.1 Mailbox Overview</A><BR>
&nbsp;&nbsp;<A HREF="#SMS_4.htm">3 Sending an SMS Message</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#SMS_5.htm">3.1 Sending and the Mailbox Library</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#SMS_6.htm">3.2 Using the SMS Mailbox API</A><BR>
&nbsp;&nbsp;<A HREF="#SMS_7.htm">4 Receiving an SMS Message</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#SMS_8.htm">4.1 SM Receive and the Mailbox Library</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#SMS_9.htm">4.2 Receiving an SMS Message</A><BR>
</STRONG>
</P> <!-- end of sectionlinks blob -->

<HR>
<A NAME="SMS_1.htm"></A>


<H2 CLASS="sectionTitle">
<A HREF="#index.htm">SMS Guide</A>: 1 
<A NAME="SMS_1.htm_65699">
 </A>
SMS Overview</H2>
<P>
The Short Message Service protocol handles a &quot;short message&quot; of up to 160 characters. The SMS standard of 160 characters allows you to send a text message to any single node (address) on the GSM network by way of a dedicated cellular service provider. </P>
<P>
The cellular service provider is responsible for managing incoming SMS messages and holding them until the recipient's phone becomes active. The length of time that an SMS message should be held can be specified by the sending party. This is known as a<EM>
 validity period</EM>
.</P>
<P>
The cellular provider may also elect to deliver the message in a format other than SMS. This is done at the server through a <EM>
message</EM>
 <EM>
conversion</EM>
 into the alternative format (e.g., as a fax message, as an email, as a page, etc.) This alternative method of delivery may also be specified by the sending party (though, of course, the recipient must have the means to handle such a format).</P>
<P>
Because the SMS message is so short, it is guaranteed to be delivered as a single packet of information.</P>
<HR>
<A NAME="SMS_2.htm"></A>


<H2 CLASS="sectionTitle">
<A HREF="#index.htm">SMS Guide</A>: 2 
<A NAME="SMS_2.htm_82374">
 </A>
Using the Mailbox Library</H2>
<P>
The Nokia 9000i Communicator comes with built-in capabilities to send and receive SMS messages. This is enabled through use of Geoworks' Mailbox library. Because the Mailbox library includes <EM>
all</EM>
 Inbox/Outbox functionality (email, faxing, etc.), it contains a large amount of information that is not relevant to an SMS service developer. This section will only detail general information about the Mailbox library and API specific to SMS application developers.</P>
<P CLASS="subsectionLink">
<A HREF="#SMS_3.htm">Mailbox Overview</A></P>
<HR>
<A NAME="SMS_3.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">SMS Guide</A>: 2.1 <A HREF="#SMS_2.htm">Using the Mailbox Library</A>: 
<A NAME="SMS_3.htm_75575">
 </A>
Mailbox Overview</H3>
<P>
The purpose of the Mailbox library is to let applications send and receive information to and from other computers, through a variety of communications media. The mailbox insulates the application as much as possible from the mechanics of transmitting and receiving the information.</P>
<P>
In order to use the Mailbox library, an application must package information in a format acceptable to both a data driver (which stores the message) and a transport driver (which sends the message) -- in this case the SMS transport driver. The application then <EM>
registers</EM>
 this message with the Mailbox library. During the registration process, you specify in which data format the message is stored.</P>
<P>
The Mailbox library stores messages that have not yet been transmitted in its <EM>
outbox</EM>
. Messages are held in the outbox until the hardware connection necessary for transmission is available. An application can also specify that a message not be delivered until a specific time. In this case, the message will automatically remain in the outbox until that time. While a message is in the outbox, the device's user can examine information about the message and delay or even cancel its delivery.</P>
<P>
When the time comes to send the message, the Mailbox library activates the appropriate transport driver. This activation is transparent to an application developer.</P>
<HR>
<A NAME="SMS_4.htm"></A>


<H2 CLASS="sectionTitle">
<A HREF="#index.htm">SMS Guide</A>: 3 
<A NAME="SMS_4.htm_54958">
 </A>
Sending an SMS Message</H2>
<P>
There are three pieces of information that you will need to know when you send an SMS message. These are rather self-evident:</P>
<UL>
<LI>
The text message.</LI>
<LI>
The recipient's GSM phone number.</LI>
<LI>
The cellular provider's phone number. All SMS messages are routed through the cellular provider. </LI>
</UL>
<P>
If you wish the SMS message to be sent to a particular application on the receiving Nokia 9000i Communicator, you will also need the following information:</P>
<UL>
<LI>
The application token (<CODE>
TokenChars</CODE>
) of the receiving app.</LI>
<LI>
The <CODE>
ManufacturerID</CODE>
 of the receiving app.</LI>
</UL>
<P>
In GEOS, these two pieces of information are referred to as a <CODE>
GeodeToken</CODE>
. If the application is your own, the <CODE>
GeodeToken</CODE>
 is easy enough to determine (since you will have defined it yourself). If the application is not your own, you will need to contact that manufacturer or cellular provider for this information.</P>
<P CLASS="subsectionLink">
<A HREF="#SMS_5.htm">Sending and the Mailbox Library</A></P>
<P CLASS="subsectionLink">
<A HREF="#SMS_6.htm">Using the SMS Mailbox API</A></P>
<HR>
<A NAME="SMS_5.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">SMS Guide</A>: 3.1 <A HREF="#SMS_4.htm">Sending an SMS Message</A>: 
<A NAME="SMS_5.htm_17075">
 </A>
Sending and the Mailbox Library</H3>
<P>
Any SMS message that is sent out to the cellular provider is routed through the mailbox's <EM>
outbox</EM>
. There are three basic paradigms involved in packaging up information for use by the outbox. Although knowledge of how they work is not essential to sending an SMS message, it may be important when troubleshooting problems.</P>
<P>
Apart from any parameters sent to the mailbox, the three basic pieces of information the outbox needs to know in order to send a message are:</P>
<UL>
<LI>
In what data format the message is &quot;wrapped.&quot; The mailbox can handle any data format as long as it is wrapped (contained) in a format it can understand. The mailbox calls an appropriate &quot;data driver&quot; when storing the message before it is sent.</LI>
<LI>
The type of data being sent. (The mailbox, itself, does not need to know the actual data; it only needs to know how the data is wrapped.) Telling the mailbox what the data is provides a black box abstraction.</LI>
<LI>
The transport driver to use when sending the message.</LI>
</UL>
<P>
When a message is placed in the outbox, the mailbox calls the appropriate data driver to store the data. When a connection is made, the mailbox calls the appropriate transport driver and sends the message. Note that the mailbox itself does not need to know the message's contents, or even its format.</P>
<HR>
<A NAME="SMS_6.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">SMS Guide</A>: 3.2 <A HREF="#SMS_4.htm">Sending an SMS Message</A>: 
<A NAME="SMS_6.htm_87102">
 </A>
Using the SMS Mailbox API</H3>
<PRE><STRONG CLASS="fileName">mailbox.goh</STRONG></PRE>
<P>
To send an SMS message to the outside world, an application will need to perform the following steps:</P>
<OL>
<LI>
Set up the text message. In many cases, the text will reside in a simple text buffer. If you wish to address the SMS message to a particular application, you will need to prepend a twelve-character prefix to the text message. The message itself will then be, at most, 148 characters in length. Without a prefix, you may send a 160-character SMS message. (See <A HREF="#SMS_6.htm_18470"> Setting Up the Text Message</A>
.)</LI>
<LI>
Copy the text into a VM file. The Mailbox library may store an SMS text message in a variety of formats (indicated by type <CODE>
GeoworksMailboxDataFormatID</CODE>
), but a VM file is the easiest to manipulate. This VM file will be accessed by a Mailbox data driver. (See <A HREF="#SMS_6.htm_87685"> Storing the Text Within a VM File</A>
.)</LI>
<LI>
Set up the <CODE>
SMSendingOptions</CODE>
 parameters in a DB item. These will be used by the SMS transport driver when the message is delivered. (See <A HREF="#SMS_6.htm_51857"> Setting Up the SMSending Options</A>
.)</LI>
<LI>
Set up the <CODE>
MailboxRegisterMessageArgs</CODE>
 structure. (See <A HREF="#SMS_6.htm_62442"> Setting Up the MailboxRegisterMessageArgs</A>
.)</LI>
<LI>
Call <CODE>
MailboxRegisterMessage()</CODE>
. (See <A HREF="#SMS_6.htm_47344"> Registering the Message</A>
.)</LI>
<LI>
Upon success, notify the Mailbox library that we are done with the VM file.</LI>
</OL>
<P>
These steps are detailed in the sections following.</P>

<H4 CLASS="HeadingC">
<A NAME="SMS_6.htm_18470">
 </A>
Setting Up the Text Message</H4>
<P>
<STRONG CLASS="fileName">
foam.goh</STRONG>
</P>
<P>
The Short Message Service protocol is able to handle a &quot;short message&quot; of up to 160 characters. The Foam library defines this character limit:</P>
<PRE>#define FOAM_MAX_SMS_TEXT_SIZE 160</PRE>
<P>
The Nokia 9000i Communicator also allows you to further specify a <EM>
particular</EM>
 application within the Nokia 9000i Communicator by adding a prefix to the SMS message (thus reducing the amount of useful text).</P>
<P>
This prefix consists of two backslashes (&quot;//&quot;),
a 4-byte GEOS application token (<CODE> TokenChars</CODE>), 
a 5-byte GEOS <CODE> ManufacturerID</CODE>, 
and a carriage return (&quot;/r&quot;, ASCII 13, or 0x0D hex). 
The Mailbox library will correctly read all characters up to the carriage return.</P>
<P>
For example:</P>
<PRE>//SKAA11\r</PRE>
<P>
is a valid prefix.</P>
<P>
The application <CODE>
TokenChars </CODE>
and <CODE>
ManufacturerID</CODE>
 should match those of the intended <EM>
receiving</EM>
 application. If you define your own application, and only wish to communicate with its counterpart running on another device, you will define this string in the application's <STRONG CLASS="fileName">
.gp</STRONG>
 file. The string is constructed from the <EM>
tokenchars</EM>
 and <EM>
tokenid</EM>
 lines of the <STRONG CLASS="fileName">
.gp</STRONG>
 file.</P>
<P>
You may also send a message to a different application, as long as you know its <CODE>
TokenChars</CODE>
 and <CODE>
ManufacturerID</CODE>
.</P>
<P>
This prefix should leave at least 148 characters to store the alpha-numeric text message. When concatenating two strings, be sure that you do not overflow the bounds of the array.</P>
<P CLASS="figTitle">
Code Display 3-1 Setting Up an SMS Text Message</P>
<PRE>/*
 * Declare the buffer to store the text message and write the prefix to the buffer. 
 */
TCHAR smsMessage[FOAM_MAX_SMS_TEXT_SIZE + 1] = &quot;//SKAA11\r&quot;;
TCHAR smsText[] = &quot;Here's my test message. I better make sure it fits.&quot;;</PRE>
<PRE>/*
 * Add the body of the text to the buffer but first check the bounds.
 */
if ( strlen( smsMessage ) + strlen( smsText ) &lt;= FOAM_MAX_SMS_TEXT_SIZE )
{
    strcat( smsMessage, smsText );
}</PRE>


<H4 CLASS="HeadingC">
<A NAME="SMS_6.htm_87685">
 </A>
Storing the Text Within a VM File</H4>
<PRE>MailboxGetVMFile(), <STRONG CLASS="fileName">Mailbox\vmtree.goh</STRONG></PRE>
<P>
Text within an SMS message needs to be stored by the Mailbox until it connects with a cellular service provider. When you register a message with the Mailbox library, you indicate what storage format you have selected. The Mailbox uses a<EM>
 data driver</EM>
 to store and retrieve messages. There are a number of data drivers available, but we only need to know a few.</P>
<P>
SMS messages may either be stored as VM (Virtual Memory) trees or as GEOS files, within the Mailbox itself. VM trees offer a lower overhead, and are simpler to use, so that is the format we have documented. (It is possible that future data drivers will become available as well.) If you are unfamiliar with GEOS VM trees, consult the Virtual Memory chapter of the Concepts book.</P>
<P>
The mailbox data driver stores its data in what is called a VM tree. This tree is referenced by a <CODE>
VMTreeAppRef</CODE>
 structure.</P>
<PRE>typedef struct {
    VMChain			VMTAR_vmChain;
    VMFileHandle			VMTAR_vmFile;
} VMTreeAppRef;</PRE>
<DL>
<DT>
<CODE>VMTAR_vmChain</CODE>
 stores the <CODE>
VMChain</CODE>
 to pass to the data driver. For SMS messages, simply use the VMCHAIN_MAKE_FROM_VM_BLOCK macro to construct a <CODE>
VMChain</CODE>
 from a single <CODE>
VMBlockHandle</CODE>
.</DT>
<DT>
VMTAR_<CODE>
vmFile</CODE>
 stores the <CODE>
VMFileHandle</CODE>
 which contains the VM block.</DT>
</DL>
<P>
The Mailbox stores these VM trees locally within an administation file that it maintains. To store the text within a Mailbox-compatible VM file, perform the following steps:</P>
<OL>
<LI>
Call <CODE>
MailboxGetVMFile()</CODE>
 to retrieve a VM file handle within the Mailbox. This routine expects an argument indicating the expected number of blocks to be added to the file; because the SMS message can be contained in a single block, pass 1. Also pass a buffer to store the returned <CODE>
VMStatus</CODE>.<BR>
<BR>
This routine returns a <CODE>
VMFileHandle</CODE>.</LI>
<LI>
Allocate a VM block within this file, using <CODE>
VMAlloc()</CODE>.</LI>
<LI>
Lock the block down using <CODE>
VMLock()</CODE>. This routine returns the segment address of the locked block. You will also receive a temporary memory handle that you can use to manipulate the block.</LI>
<LI>
Copy the text from your text buffer into the locked block starting at its segment address. (You will need to skip two bytes for the <CODE>
VMChainLink</CODE>
 that begins the block.)</LI>
<LI>
Dirty the block using <CODE>
VMDirty()</CODE>.</LI>
<LI>
Unlock the block using <CODE>
VMUnlock()</CODE>.</LI>
<LI>
Store the VM file and VM block within a <CODE>
VMTreeAppRef </CODE>
structure. This format is understood by the mailbox data driver.</LI>
</OL>
<P CLASS="figTitle">
Code Display 3-2 Storing the Text In a VM File</P>
<PRE>VMFileHandle		vmFile;
VMBlockHandle		vmBlock;
TCHAR		*textPtr;
MemHandle		mh;
word		vmStatus;
VMTreeAppRef		vmRef;</PRE>
<PRE>/*
 * Obtain the handle of a writable VM file from the Mailbox library. We pass one
 * since we do not plan to add additional blocks to this file (because SMS messages 
 * are so short).
 */
vmFile = MailboxGetVMFile(1, &amp;vmStatus);</PRE>
<PRE>/*
 * Allocate a VM block and store the text within this block. The block will need 
 * to fit a header (VMChainLink), the SMS message itself, and a null terminator.
 */
vmBlock = VMAlloc(vmFile, (sizeof(VMChainLink) + strlen(smsMessage) +1), 0);
charPtr = VMLock(vmFile, vmBlock, &amp;mh);</PRE>
<PRE>/*
 * We advance past the VMChainLink contained at the beginning of the VM
 * block and copy the text to that location.
 */
strcpy(textPtr + sizeof(VMChainLink), smsMessage);</PRE>
<PRE>/*
 * Dirty the block and unlock it.
 */
VMDirty(mh);
VMUnlock(mh);</PRE>
<PRE>/*
 * Store the VM file and VM block within a VMTreeAppRef structure. This is the 
 * format that the mailbox library understands. Essentially, it ia a VM &quot;chain&quot;
 * of a single VM file.
 */
vmRef.VMTAR_vmChain = VMCHAIN_MAKE_FROM_VM_BLOCK(vmBlock);
vmRef.VMTAR_vmFile = vmFile;</PRE>


<H4 CLASS="HeadingC">
<A NAME="SMS_6.htm_51857">
 </A>
Setting Up the SMSending Options</H4>
<PRE>MailboxGetAdminFile(),<STRONG CLASS="fileName"> smdefine.goh</STRONG>, SMSendingOptions, ReadCSNumberFromIniFile()</PRE>
<P>
When registering a mailbox message, the application must specify a data driver to use when storing the message. It will also need to specify which transport driver to use when the message is to be delivered. The GEOS SMS transport driver expects a number of parameters indicating how the SMS message should be sent. These parameters are passed as a <CODE>
SMSendingOptions</CODE>
 structure within a GEOS <CODE>
DBItem</CODE>.</P>
<P>
To store these parameters within a compatible DB item, perform the following steps:</P>
<OL>
<LI>
Call <CODE>
MailboxGetAdminFile() </CODE>
to retrieve the <CODE>
VMFileHandle</CODE>
 of the Mailbox administration file. This is where you will copy your SMS parameters.</LI>
<LI>
Allocate an ungrouped DB item within this file, using <CODE>
DBAllocUngrouped()</CODE>.</LI>
<LI>
Lock the DB item using <CODE>
DBLockUngrouped()</CODE>.</LI>
<LI>
Copy your basic <CODE>
SMSendingOptions</CODE>
 parameters into this DB item.</LI>
<LI>
Read the service center number from the .INI file using <CODE>
InitFileReadStringBuffer()</CODE>. Copy that number into the DB item.</LI>
<LI>
Dirty the block using <CODE>
DBDirty()</CODE>.</LI>
<LI>
Unlock the block using <CODE>
DBUnlock()</CODE>.</LI>
</OL>

<H5 CLASS="HeadingD">
The SMSendingOptions structure</H5>
<P>
The <CODE>
SMSendingOptions</CODE>
 structure is defined within<STRONG CLASS="fileName">
 smdefine.goh</STRONG>
 and is shown below:</P>
<PRE>typedef struct {
	SMReplyPath			SMSO_replyPath;
	SMValidityPeriod			SMSO_validityPeriod;
	SMMessageConversion			SMSO_messageConversion;
	TCHAR		SMSO_scAddress[MAX_ADDRESS_SIZE];
} SMSendingOptions;

#define MAX_ADDRESS_SIZE 22</PRE>
<DL>
<DT>
SMSO_<CODE>
replyPath</CODE>
 contains an <CODE>
SMReplyPath</CODE>
 value which indicates whether the recipient may reply to the message through the sender's service provider. Possible values are:</DT>
<DT>
	SMRP_NO</DT><DD>
This flag is set by default and indicates that the recipient must reply through the recipient's service provider.</DD>
<DT>
	SMRP_YES</DT><DD>
Setting this flag allows the recipient to reply through the sender's service provider.</DD>
<DT>
SMSO<CODE>
_validityPeriod</CODE>
 contains an <CODE>
SMValidityPeriod</CODE>
 value which indicates the length of time that the message is considered valid for delivery. The cellular provider should interpret this value and if it is unable to connect with the recipient, drop the message and inform the sender that the message was not delivered. Possible values are:</DT>
<DT>
	SMVP_1_HOUR</DT><DD>
SMVP_6_HOURS<BR>
SMVP_24_HOURS<BR>
SMVP_1_WEEK<BR>
SMVP_MAX (The actual value of SMVP_MAX will vary by service provider.) </DD>
<DT>
SMSO_<CODE>
messageConversion</CODE>
 contains an <CODE>
SMMessageConversion</CODE>
 value, indicating that you wish to have the SMS message delivered to the recipient in a different format than that of an SMS message (provided that the cellular provider offers this service). Possible values are:</DT>
<DT>
	SMMC_NORMAL</DT><DD>
Deliver the message as a normal SMS message. This is the default value.</DD>
<DT>
	SMMC_FAX_GROUP_3</DT><DD>
Deliver the message as a fax according to the fax group 3 standard.</DD>
<DT>
	SMMC_FAX_GROUP_4 </DT><DD>
Deliver the message as a fax according to the fax group 4 standard.</DD>
<DT>
	SMMC_VOICE</DT><DD>
Deliver the message as a voice mail message.</DD>
<DT>
	SMMC_ERMES</DT><DD>
Deliver the message according to the European Radio Messaging System standard.</DD>
<DT>
	SMMC_PAGING</DT><DD>
Deliver the message as an alpha-numeric page.</DD>
<DT>
	SMMC_EMAIL</DT><DD>
Deliver the message as an Internet e-mail message.</DD>
<DT>
	SMMC_X400</DT><DD>
Deliver the mesage according to the X400 e-mail standard.</DD>
<DT>
SMSO_<CODE>
scAddress</CODE>
 stores the address of the service center (cellular provider). This number is stored as an ASCII text string and is limited to 22 characters. This number should be retrieved from the Nokia 9000i Communicator's .INI file; the number is stored under the <STRONG CLASS="fileName">
scNumber</STRONG>
 field within the <STRONG CLASS="fileName">
SMS</STRONG>
 category. This &quot;address&quot; in this case is really just a numerical phone number.</DT>


</DL>
<H5 CLASS="HeadingD">
Reading a String From the .INI File</H5>
<PRE><STRONG CLASS="fileName">initfile.h, InitFileReadStringBuffer()</STRONG></PRE>
<P>
To read a string from the .INI file, call <CODE>
InitFileReadStringBuffer()</CODE>
. Pass &quot;SMS&quot; as the category and &quot;scNumber&quot; as the key. The routine will read the entry into a buffer passed to the routine. It will also read the size of the string into another buffer.</P>
<P CLASS="figTitle">
Code Display 3-3 Setting the SMSendingOptions Parameters</P>
<PRE>SMSendingOptions			*ptrSendingOptions
VMFileHandle			adminFile;
DBGroupAndItem			smsParams;
word			sizeOfBuffer;</PRE>
<PRE>adminFile = MailboxGetAdminFile();</PRE>
<PRE>smsParams = DBAllocUngrouped(adminFile, sizeof(SMSendingOptions));</PRE>
<PRE>ptrSendingOptions = (SMSendingOptions *) DBLockUngrouped(adminFile, smsParams);</PRE>
<PRE>/* set desired sending options */
ptrSendingOptions-&gt;SMSO_replyPath = SMRP_NO;
ptrSendingOptions-&gt;SMSO_validityPeriod = SMVP_24_HOURS;
ptrSendingOptions-&gt;SMSO_messageConversion = SMMC_NORMAL;</PRE>
<PRE>/* be sure to initialize these fields as well, otherwise the app will crash! */
ptrSendingOptions-&gt;SMSO_dataCodingScheme = 0;
ptrSendingOptions-&gt;SMSO_userDataLength = 0;
ptrSendingOptions-&gt;SMSO_userDataLength = 0;</PRE>
<PRE>InitFileReadStringBuffer(&quot;SMS&quot;,
			&quot;scNumber&quot;,
			ptrSendingOptions-&gt;SMSO_scAddress,
			0,
			&amp;sizeOfBuffer);</PRE>
<PRE>DBDirty(ptrSendingOptions);
DBNUnlock(ptrSendingOptions);</PRE>



<H4 CLASS="HeadingC">
<A NAME="SMS_6.htm_62442">
 </A>
Setting Up the MailboxRegisterMessageArgs</H4>
<PRE>MailboxRegisterMessageArgs, MailboxTransAddr</PRE>
<P>
By now, you have created a reference to the SMS message itself (within a <CODE>
VMTreeAppRef</CODE>
 structure); you have also placed the SMS sending parameters within the mailbox administration file. You are now ready to load the <CODE>
MailboxRegisterMessageArgs</CODE>
 structure with parameters. (Two of these parameters will be the location of the SMS message and its sending parameters.)</P>
<OL>
<LI>
Indicate the format in which you wish the SMS message stored while it resides in the outbox. (The mailbox will call the appropriate mailbox data driver when the message is registered.)</LI>
<LI>
Indicate the format of the actual message. This is where you tell the mailbox that this message is an SMS message.</LI>
<LI>
Indicate the VM file in which the SMS message is stored.</LI>
<LI>
Tell the mailbox to use the SMS transport driver when the mailbox sends the message.</LI>
<LI>
Give the mailbox the address of the recipient.</LI>
<LI>
Indicate the DB item where the <CODE>
SMSendingOptions</CODE>
 are located.</LI>
<LI>
Tell the mailbox when to begin delivery of the message and when to give up delivery attempts if unsuccessful.</LI>
</OL>
<P>
All of these steps are accomplished by simply filling in a <CODE>
MailboxRegisterMessageArgs</CODE>
 structure. This structure is large, but it is not altogether complicated. Each field is described in the following sections, though only SMS relevant information is shown. It is shown below:</P>
<PRE>typedef struct {
	MailboxStorage				MRA_bodyStorage;
	MailboxDataFormat				MRA_bodyFormat;
	const void 				*MRA_bodyRef;
	word				MRA_bodyRefLen;
	MailboxTransport				MRA_transport;
	MailboxTransportOption				MRA_transOption;
	MailboxTransAddr				*MRA_transAddrs;
	word				MRA_numTransAddrs;
	dword				MRA_transData;
	MailboxMessageFlags				MRA_flags;
	const char				*MRA_summary;
	GeodeToken				MRA_destApp;
	FileDateAndTime				MRA_startBound;
	FileDateAndTime				MRA_endBound;
} MailboxRegisterMessageArgs;</PRE>

<H5 CLASS="HeadingD">
Data Format for Storage</H5>
<P>
As we mentioned, the Mailbox will need to store a message in a format that it can understand. Rather than have the Mailbox understand every data format that is (or will ever be) developed, it is easier to &quot;package&quot; the message in a small number of standard formats. You specify in what format the message will be wrapped in the MRA<CODE>
_bodyStorage</CODE>
 field.</P>
<DL>
<DT>
MRA_<CODE>
bodyStorage</CODE>
 indicates under what format (of type <CODE>
MailboxStorage</CODE>
) the message will be stored in the internal Mailbox administration file. <CODE>
MailboxStorage</CODE>
 is defined as follows:</DT>
<PRE>typedef struct {
	word			MS_id;
	ManufacturerID			MS_manuf;
} MailboxStorage;</PRE>
<DT><CODE>MS_id</CODE></DT>
<DD>...stores a word of data indicating the type of data driver that will be used to store the message. For SMS messages, we will use a Geoworks data driver referenced by a <CODE>
GeoworksMailboxStorageID</CODE>. The following types are valid:</DD>
<PRE>	GMSID_FILE
	GMSID_VM_TREE</PRE>
<DD>As we indicated earlier, SMS messages should be stored in VM trees. You do have the option of storing them as GEOS files as well, but VM trees are easier to manipulate.</DD>
<DT><CODE>MS_manuf</CODE></DT>
<DD>...stores the <CODE>
ManufacturerID</CODE>
 of the data driver being used. Since we will be using Geoworks VM trees, we will store <CODE>MANUFACTURER_ID_GEOWORKS</CODE> in this location.</DD>


</DL>
<H5 CLASS="HeadingD">
Data Format of the Message</H5>
<DL>
<DT>
<CODE>MRA_bodyFormat</CODE></DT>
<DD>...indicates the format of the actual data being stored (in its original source). This field takes an argument of type <CODE>
MailboxDataFormat</CODE>
. This is defined below:</DD>
<PRE>typedef struct {
	word			MDF_id;
	ManufacturerID			MDF_manuf;
} MailboxDataFormat;</PRE>
<DT><CODE>MDF_id</CODE></DT>
<DD>...stores a word of data indicating the data stored in the message. We 
will use a Geoworks data format referenced by a <CODE>
GeoworksMailboxDataFormatID</CODE>. Pass GMDFID_SHORT_MESSAGE in this field 
to indicate that the message is a Geoworks SMS message.</DD>
<DT><CODE>MDF_manuf</CODE></DT>
<DD>...stores the <CODE>
ManufacturerID</CODE>
 of the format. Since we will be using Geoworks SMS , we will 
store MANUFACTURER_ID_GEOWORKS in this location.</DD>

</DL>
<H5 CLASS="HeadingD">
References to the VM Tree Structure</H5>
<DL>
<DT>
MRA<CODE>
_bodyRef</CODE>
 stores a pointer to the reference of the SMS message. Since we will be storing the message in a VM tree, we will reference that message with a <CODE>
VMAppTreeRef</CODE>
.</DT>
<DT>
MRA_<CODE>
bodyRefLen</CODE>
 stores the length of the reference indicated in MRA_<CODE>
bodyRef</CODE>
. In this case, we will store the size of the <CODE>
VMAppTreeRef</CODE>
 structure.</DT>


</DL>
<H5 CLASS="HeadingD">
The Transport Driver</H5>
<DL>
<DT>
The Mailbox uses an applicable transport driver when it wants to deliver a message to the outside world. You specify this transport driver in the MRA_<CODE>
transport</CODE>
 field.</DT>
<DT>
MRA<CODE>
_transport</CODE>
 takes an argument of type <CODE>
MailboxTransport</CODE>
. This is defined below:</DT>
<PRE>typedef struct {
	word			MT_id;
	ManufacturerID			MT_manuf;
} MailboxTransport;</PRE>
<DT><CODE>MT_id</CODE></DT>
<DD>...stores a word of data indicating the type of transport driver that will be used to deliver the message. For SMS messages, we will use a Geoworks transport driver referenced by a <CODE>
GeoworksMailboxTransportID</CODE>. </DD>

<DD>To send an SMS message, we will use the SM transport driver referenced by GMTID_SM.</DD>

<DT><CODE>MT_manuf</CODE></DT>
<DD>...stores the <CODE>
ManufacturerID</CODE>
 of the transport driver being used. Since we will be using Geoworks SM transport driver, we will store MANUFACTURER_ID_GEOWORKS in this location.</DD>

<DT><CODE>MRA_transOption</CODE>
<DD>...stores an unsigned value that the the transport driver uses. For SMS, set this to zero.</DD>

<DT><CODE>MRA_transAddrs</CODE></DT>
<DD>stores the address of the eventual recipient. This address is stored as a pointer to a <CODE>
MailboxTransAddr</CODE>
 structure; it is only important that the transport driver understand the format for this address. </DD>

<DD>
<BR>
If there are multiple recipients, this pointer references multiple <CODE>
MailboxTransAddr</CODE>
 structures. This structure is defined below:</DD>
<PRE>typedef struct {
	const void			*MTA_transAddr;
	unsigned			MTA_transAddrLen;
	const char			*MTA_userTransAddr;
} MailboxTransAddr;</PRE>

<DT><CODE>MTA_transAddr</CODE></DT>
<DD>...stores a pointer to the recipient address, understood by the transport driver. (For SMS this is a simple ASCII text string of the recipient's phone number.)</DD>

<DT><CODE>MTA_transAddrLen</CODE></DT>
<DD>...stores the length of the address stored in <CODE>MTA_transAddr</CODE>.</DD>

<DT><CODE>MTA_userTransAddr</CODE></DT>
<DD>...stores a user-readable version of the address, as a null-terminated text string. Because the SMS address is already stored as an ASCII text value, this field will be the same as <CODE>MTA_transAddr</CODE>.</DD>

<DT><CODE>MRA_numTransAddrs</CODE></DT>
<DD>...stores the number of recipient addresses stored in <CODE>MRA_transAddrs</CODE>.</DD>

<DT>
<CODE>MRA_transData</CODE></DT>
<DD>...stores data understood by the transport driver. As mentioned in <A HREF="#SMS_6.htm_51857"> Setting Up the SMSending Options</A>
, the SMS transport driver expects a <CODE>
DBItem</CODE>
 containing a structure of type <CODE>
SMSendingOptions</CODE>
.</DD>

<DT>
<CODE>MRA_flags</CODE></DT>
<DD>...stores a field of <CODE>
MailboxMessageFlags</CODE>. </DD>

<DD>
For SMS messages, the only flag you may care about is MMF_DELETE_BODY_AFTER_TRANSMISSION, which will delete the VM file containing the SMS message after it is delivered. Do not set any other flags.</DD>

<DT>
<CODE>MRA_summary</CODE></DT>
<DD>stores a text string that the Outbox displays to indicate the type of message being delivered. For example, if you are sending a chess move for a game in progress, you might set this field to display &quot;Chess Move.&quot;</DD>

<DT>
<CODE>MRA_destApp</CODE></DT>
<DD>...stores the <CODE>
GeodeToken</CODE>
 of the destination application.</DD>

<DT>
<CODE>MRA_startBound</CODE></DT>
<DD>...indicates a time and date (of type <CODE>
FileDateAndTime</CODE>
) to begin transmission of the message. You may also pass the value MAILBOX_NOW (0) for immediate delivery.</DD>

<DT><CODE>MRA_endBound</CODE></DT>
<DD>...indicates a time and date (of type <CODE>
FileDateAndTime</CODE>
) to end attempts to transmit the message to the service provider. You may also pass the value MAILBOX_ETERNITY (-1) to indicate attempt until successful.</DD>
</DL>
<P CLASS="figTitle">
Code Display 3-4 Setting Up the Mailbox Registration Arguments</P>
<PRE>MailboxRegisterMessageArgs				registerArgs;
MailboxTransAddr				addressList;
TCHAR				number[MAX_ADDRESS_SIZE]</PRE>
<PRE>/*
 * We tell the mailbox that the data is stored within a VMTreeAppRef.
 */
registerArgs.MRA_bodyStorage.MS_id = GMSID_VM_TREE;
registerArgs.MRA_bodyStorage.MS_manuf = MANUFACTURER_ID_GEOWORKS;</PRE>
<PRE>/*
 * We tell the mailbox that this is an SMS message. 
 */
registerArgs.MRA_bodyFormat.MDF_id = GMDFID_SHORT_MESSAGE;
registerArgs.MRA_bodyFormat.MDF_manuf = MANUFACTURER_ID_GEOWORKS;</PRE>
<PRE>/*
 * We tell the mailbox where the body text is stored.
 */
MRA_bodyRef = &amp;vmRef;
registerArgs.MRA_bodyRefLen = sizeof(VMTreeAppRef);</PRE>
<PRE>/*
 * We tell the mailbox to use the SM transport driver when sending the message. 
 */
registerArgs.MRA_transport.MT_id = GMTID_SM;
registerArgs.MRA_transport.MT_manuf = MANUFACTURER_ID_GEOWORKS;</PRE>
<PRE>registerArgs.MRA_transOption = 0;</PRE>
<PRE>/*
 * Normally, we would retrieve the phone number from an outside source (such as 
 * the contact database). Here, we just set it to a specific value.
 */</PRE>
<PRE>number = &quot;13125551212&quot;;</PRE>
<PRE>/*
 * We need to stuff each address (in this case, a phone number) into a
 * MailboxTransAddr structure.
 */</PRE>
<PRE>addressList.MTA_transAddr = &amp;number;
addressList.MTA_transAddrLen = strlen(number);
addressList.MTA_userTransAddr = &amp;number;</PRE>
<PRE>registerArgs.MRA_transAddrs = &amp;addressList;
registerArgs.MRA_numTransAddr = 1;</PRE>
<PRE>/*
 * We pass the previously set up SMSendingOptions in the DBGroupItem to the 
 * transport driver.
 */
registerArgs.MRA_transData = smsParams;</PRE>
<PRE>registerArgs.MRA_flags = MMF_DELETE_BODY_AFTER_TRANSMISSION;</PRE>
<PRE>registerArgs.MRA_summary = &quot;Chess Move&quot;;</PRE>
<PRE>strcpy(registerArgs.MRA_destApp.GT_chars, &quot;SKAA&quot;);
registerArgs.MRA_destApp.GT_manufID = MANUFACTURER_ID_NOKIA;</PRE>
<PRE>registerArgs.MRA_startBound = MAILBOX_NOW;
registerArgs.MRA_endBound = MAILBOX_ETERNITY;</PRE>



<H4 CLASS="HeadingC">
<A NAME="SMS_6.htm_47344">
 </A>
Registering the Message</H4>
<PRE>MailboxRegisterMessage(), MailboxDoneWithVMFile()</PRE>
<P>
Finally, you have everything set up. To send the message, all you need to do is register the message with the mailbox library.</P>
<P>
<CODE>
MailboxRegisterMessage()</CODE>
 takes an address (of type <CODE>
MailboxMessage</CODE>
) as a second parameter. The routine will write a token value into this address so that future mailbox routines can refer to this message by its token. </P>
<P>
Do not confuse this token with the actual message (which is sent through the <CODE>
MailboxRegisterMessageArgs</CODE>
).</P>
<P>
After you have successfully registered the message, call <CODE>
MailboxDoneWithVMFile() </CODE>
to tell the mailbox to get rid of the temporary VM file it had created.</P>
<P CLASS="figTitle">
Code Display 3-5 Using MailboxRegisterMessage</P>
<PRE>MailboxRegisterMessageArgs				registerArgs;
MailboxMessage				msgToken;
MailboxError				mailboxError;
VMFileHandle				vmFile;</PRE>
<PRE>mailboxError = MailboxRegisterMessage(&amp;registerArgs, &amp;msgToken);</PRE>
<PRE>if (mailboxError == ME_SUCCESS) {</PRE>
<PRE>    /* If we want to do anything special upon success, here it would reside ... */</PRE>
<PRE>};</PRE>
<PRE>MailboxDoneWithVMFile(vmFile);</PRE>
<P>
There is a possibility that <CODE>
MailboxRegisterMessage()</CODE>
 may return an error (of type <CODE>
MailboxError</CODE>
) if something is not working correctly (or if the message was not set up correctly). The routine returns ME_SUCCESS if the registration was successful.</P>
<P>
The following are valid mailbox error codes:</P>
<PRE>ME_SUCCESS = 0
ME_NOT_ENOUGH_MEMORY
ME_CANNOT_LOAD_DATA_DRIVER
ME_CANNOT_LOAD_TRANSPORT_DRIVER
ME_UNABLE_TO_CREATE_TRANSMIT_THREAD
ME_CANNOT_ENQUEUE_MESSAGE
ME_USER_CANCELED
ME_LOST_CONNECTION
ME_CANNOT_CREATE_MESSAGE_FILE
ME_CANNOT_RESIZE_MBOX_REF
ME_CANNOT_SAVE_MESSAGE_FILE
ME_CANCELLED_BY_RECEIVER
ME_MESSAGE_BLOCKS_ARE_MISATCHED
ME_DATA_DRIVER_CANNOT_STORE_MESSAGE_BODY
ME_INSUFFICIENT_DISK_SPACE
ME_CANNOT_CONNECT</PRE>
<P>
The following are unrecoverable <CODE>
MailboxError</CODE>
 error codes. (The high bit is set if this is the case.)</P>
<PRE>#define ME_UNRECOVERABLE 0x8000</PRE>
<PRE>ME_ADDRESS_INVALID
ME_DATA_DRIVER_CANNOT_ACCESS_MESSAGE_BODY
ME_UNSUPPORTED_BODY_FORMAT
ME_MESSAGE_BODY_INVALID
ME_INVALID_MESSAGE
ME_REPLY_ADDRESS_NOT_AVAILABLE
ME_DESTINATION_APPLICATION_UNKNOWN
ME_UNKNOWN_DISK_ERROR
ME_APP_REF_BUF_TOO_SMALL
ME_CANNOT_OPEN_MESSAGE_FILE
ME_CANNOT_READ_MESSAGE_FILE
ME_CAN_NEVER_CONNECT</PRE>

<HR>
<A NAME="SMS_7.htm"></A>


<H2 CLASS="sectionTitle">
<A HREF="#index.htm">SMS Guide</A>: 4 
<A NAME="SMS_7.htm_11980">
 </A>
Receiving an SMS Message</H2>
<P>
There are two ways the Nokia 9000i Communicator may receive an SMS message: standard, or targeted. </P>
<P>
As a developer, you do not need to concern yourself with standard messages since a &quot;standard&quot; message is handled by the Nokia 9000i Communicator's built-in SMS application. This application handles standard messages that are either sent without an SMS prefix or that are sent specifically to the SM Receive application. </P>
<P>
Targeted messages are those messages sent using the twelve character prefix.
 These messages may not necessarily be sent using another Nokia 9000i Communicator; any device that uses the correct SMS prefix can contact a specific application if it so desires. In any case, the twelve character prefix (containing the <CODE> GeodeToken</CODE>
) will specify the application that is meant to receive the message. </P>
<P CLASS="subsectionLink">
<A HREF="#SMS_8.htm">SM Receive and the Mailbox Library</A></P>
<P CLASS="subsectionLink">
<A HREF="#SMS_9.htm">Receiving an SMS Message</A></P>
<HR>
<A NAME="SMS_8.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">SMS Guide</A>: 4.1 <A HREF="#SMS_7.htm">Receiving an SMS Message</A>: 
<A NAME="SMS_8.htm_43928">
 </A>
SM Receive and the Mailbox Library</H3>
<P>
When the GSM network informs the unit that is has an SMS message pending for receipt, it launches the SM Receive application. This application retrieves the SMS message(s). If the message is a standard SMS message, it routes the message to the application's &quot;Received messages&quot; folder.</P>
<P>
If the message is targeted to a specific application, the SM Receive application contacts the mailbox and places the message in the mailbox's <EM>
inbox</EM>
. The mailbox then contacts the application by sending it a message (<EM>
MSG_META_MAILBOX_NOTIFY_MESSAGE_AVAILABLE</EM>
). If the mailbox cannot contact the application, it re-routes the message back to the SM Receive application.</P>
<P>
You do not need to know how the SM Receive application works, but it is useful to know the process which occurs when an SMS message is received.</P>
<HR>
<A NAME="SMS_9.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">SMS Guide</A>: 4.2 <A HREF="#SMS_7.htm">Receiving an SMS Message</A>: 
<A NAME="SMS_9.htm_85024">
 </A>
Receiving an SMS Message</H3>
<P>
When the inbox receives a message that it determines is destined for a specific application, the mailbox will contact that application's process class with <EM>
MSG_META_MAILBOX_NOTIFY_MESSAGE_AVAILABLE</EM>
. This message passes a token identifer of the SMS message.</P>
<P>
If you wish your application to handle an SMS message, you will need to write a message handler for <EM>
MSG_META_MAILBOX_NOTIFY_MESSAGE_AVAILABLE</EM>
. It should perform the following steps:</P>
<OL>
<LI>
Call <CODE>
MailboxAcknowledgeReceipt()</CODE>
 to inform the mailbox that we're handling the message. Pass the token identifer of the SMS message that was passed with <EM>
MSG_META_MAILBOX_NOTIFY_MESSAGE_AVAILABLE</EM>
. (See <A HREF="#SMS_9.htm_37653"> Acknowledging Receipt of the Message</A>
.)</LI>
<LI FIXME_NumListOther>
Retrieve the VM reference to the message with <CODE>
MailboxGetBodyRef()</CODE>
. (See <A HREF="#SMS_9.htm_17710"> Retrieving the Text from the VM Block</A>
.)</LI>
<LI FIXME_NumListOther>
Lock down the VM block and retrieve a pointer to the text.</LI>
<LI FIXME_NumListOther>
Copy the text to a local buffer.</LI>
<LI FIXME_NumListOther>
Unlock the VM block.</LI>
<LI FIXME_NumListOther>
Call <CODE>
MailboxDoneWithBody()</CODE>
 to instruct the mailbox to release the VM reference to the text. (See <A HREF="#SMS_9.htm_11815"> Cleaning Up</A>
.)</LI>
<LI FIXME_NumListOther>
Call <CODE>
Mailbox DeleteMessage()</CODE>
, passing the token referring to this message. </LI>
</OL>
<P>
These specific steps are described in more detail below:</P>

<H4 CLASS="HeadingC">
<A NAME="SMS_9.htm_37653">
 </A>
Acknowledging Receipt of the Message</H4>
<PRE>MailboxAcknowledgeMessageReceipt()</PRE>
<P>
When your application receives an SMS message with <EM>
MSG_META_MAILBOX_NOTIFY_MESSAGE_AVAILABLE</EM>
, your first order of business should be informing the mailbox that you have the message. To do this, send the mailbox <CODE>
MailboxAcknowledgeMessageReceipt()</CODE>
, passing it the message token.</P>
<P CLASS="figTitle">
Code Display 3-6 Acknowledging Receipt of an SMS Message</P>
<PRE>/*
 * Each application which wishes to receive SMS messages should create a 
 * MSG_META_MAILBOX_NOTIFY_MESSAGE_AVAILABLE handler in the app's main prcoess
 * class.
 */</PRE>
<PRE>@method MyProcessClass, MSG_META_MAILBOX_NOTIFY_MESSAGE_AVAILABLE {</PRE>
<PRE>    /*
     * First we inform the mailbox that we've received the message. We pass the 
     * `msg' token that was passed to this message in the first place.
     */</PRE>
<PRE>    MailboxAcknowledgeMessageReceipt(msg);</PRE>
<PRE>    /* To be continued ... */</PRE>


<H4 CLASS="HeadingC">
<A NAME="SMS_9.htm_17710">
 </A>
Retrieving the Text from the VM Block</H4>
<PRE>MailboxGetBodyRef()</PRE>
<P>
As we indicated in<A HREF="#SMS_6.htm_87685"> Storing the Text Within a VM File</A>
, it is convenient for the SMS message itself to be wrapped in a small <CODE>
VMChain</CODE>
 structure. In the following section, we assume that is indeed what was done on the sending end. </P>
<P>
Use <CODE>
MailboxGetBodyRef()</CODE>
 to retrieve this reference to the actual text. Pass the message token, a pointer to a buffer to store the body reference, and the length of that buffer.</P>
<P CLASS="figTitle">
Code Display 3-7 Retrieving the Text</P>
<PRE>    MailboxError 			errorCode;
    VMAppTreeRef			vmRef;
    word 			refSize;
    MemHandle			handleToText;
    TCHAR			smsText[FOAM_MAX_SMS_TEXT_SIZE+1];
    char			*ptrToText;</PRE>
<PRE>    /* 
     * First, retrieve the reference to the body of the SMS text from the mailbox 
     * library. Place that reference into our vmRef variable.
     */</PRE>
<PRE>    refSize = sizeof(VMTreeAppRef);
    errorCode = MailboxGetBodyRef(msg, &amp;vmRef, &amp;refSize);</PRE>
<PRE>    if (errorCode == ME_SUCCESS) {</PRE>
<PRE>	/*
	 * Lock the block and retrieve a pointer to the SMS text.
	 */
	ptrToText = (char *) VMLock(vmRef.VMTAR_vmFile,
				 VMCHAIN_GET_VM_BLOCK(vmRef.VMTAR_vmChain),
				 &amp;handleToText);</PRE>
<PRE>	/*
	 * Advance the pointer beyond the carriage return to get beyond the 
	 * prefix. 
	 */</PRE>
<PRE>	while ( *ptrToText != `\r')
	    ptrToText++;</PRE>
<PRE>	/* Advance over the `\r' ...*/
	    ptrToText++;</PRE>
<PRE>	strcpy(smsText, ptrToText);</PRE>
<PRE>	VMUnlock(handleToText);</PRE>
<PRE>	/* To be continued ... */</PRE>


<H4 CLASS="HeadingC">
<A NAME="SMS_9.htm_11815">
 </A>
Cleaning Up</H4>
<PRE>MailboxDoneWithBody(), MailboxDeleteMessage()</PRE>
<P>
Finally, we need to notify the mailbox that it can delete both the text of the message (and the reference to that text) and the message itself. To perform each of these steps, call <CODE>
MailboxDoneWithBody()</CODE>
 and <CODE>
MailboxDeleteMessage()</CODE>
.</P>
<P CLASS="figTitle">
Code Display 3-8 Cleaning Up the Mailbox</P>
<PRE>	/* Now remove the external text and the reference to that text. */</PRE>
<PRE>	MailboxDoneWithBody(msg, &amp;vmRef, refSize)</PRE>
<PRE>	/* 
	 * Finally, delete the &quot;message&quot; including the message token and any 
	 * information included with it.
	 */</PRE>
<PRE>	MailboxDeleteMessage(msg);</PRE>
<PRE>    }</PRE>
<PRE>}</PRE>

<HR>
This document is a single-page version of a <A HREF="index.htm">a multi-page document</A>, suitable for easy printing.
</BODY>
</HTML>
