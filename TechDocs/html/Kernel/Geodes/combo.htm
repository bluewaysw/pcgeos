<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD>
<!-- This page was automatically generated from a bunch of smaller pages. -->
<META NAME="copyright" CONTENT="Copyright GEOWORKS">
<LINK REL="STYLESHEET" HREF="../../docHelpers/style.css">
<LINK REV="MADE" HREF="mailto:doc-feedback@geoworks.com">
<TITLE>Applications and Geodes</TITLE>
</HEAD>
<BODY BGCOLOR="#ffffdf">
This document is a single-page version of a <A HREF="index.htm">a multi-page document</A>, suitable for easy printing.
<A NAME="index.htm"></A>



<H1 CLASS="chapterTitle">

<A NAME="index.htm_97933">
 </A>
Applications and Geodes

</H1>
<P>
This chapter discusses the life of an application as well as several topics most application programmers will want to cover at one time or another. Before reading this chapter, you should have read each of the previous chapters; this chapter builds on the knowledge you gained in those chapters. </P>
<P>
This chapter details the components and features of a <EM>
geode</EM>
, a GEOS executable. The chapter is presented in the following five sections:

</P>
<UL>
<LI>
Geodes<BR>
The <EM>
Geodes</EM>
 section describes how libraries, drivers, and applications are launched, used, and shut down. It also discusses the general sections of a geode and the geode's executable file.</LI>
<LI>
Creating Icons<BR>
The <EM>
Creating Icons</EM>
 section describes the structure of the Token Database, how icons are stored, managed, and created.</LI>
<LI>
Saving User Options<BR>
The <EM>
Saving Options</EM>
 section describes how to work with the GEOS.INI file.</LI>
<LI>
General System Utilities<BR>
The <EM>
General System Utilities </EM>
section describes several different mechanisms provided by GEOS that you may find useful in your application or other geode.</LI>
<LI>
The Error-Checking System Software<BR>
The <EM>
Error-Checking System Software</EM>
 describes the differences between the debugging and standard versions of the system software. There are two versions of nearly every part of the system software including the kernel, the UI, and most libraries and drivers.</LI>
<LI>
IACP: Inter-Application Communication Protocol<BR>
The <EM>
IACP</EM>
 section describes how applications can communicate with each other and pass data back and forth. This protocol works for applications that are not necessarily loaded and running; thus, an application can change another application's data dynamically--the recipient application is automatically started if it is not already running. (This is an advanced topic; most programmers will not need to read this section.)</LI>
</UL>
<P CLASS="sectionlinks">
<STRONG>
&nbsp;&nbsp;<A HREF="#Geodes_1.htm">1 Geodes</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Geodes_2.htm">1.1 Geode Components and Structures</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Geodes_3.htm">1.2 Launching an Application</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Geodes_4.htm">1.3 Shutting Down an Application</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Geodes_5.htm">1.4 Saving and Restoring State</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Geodes_6.htm">1.5 Using Other Geodes</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Geodes_7.htm">1.6 Writing Your Own Libraries</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Geodes_8.htm">1.7 Working with Geodes</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Geodes_9.htm">1.8 Geode Protocols and Release Levels</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Geodes_a.htm">1.9 Temporary Geode Memory</A><BR>
&nbsp;&nbsp;<A HREF="#Geodes_b.htm">2 Creating Icons</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Geodes_c.htm">2.1 The Token Database</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Geodes_d.htm">2.2 Managing the Token Database File</A><BR>
&nbsp;&nbsp;<A HREF="#Geodes_e.htm">3 Saving User Options</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Geodes_f.htm">3.1 Saving Generic Object Options</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Geodes_10.htm">3.2 The GEOS.INI File</A><BR>
&nbsp;&nbsp;<A HREF="#Geodes_11.htm">4 General System Utilities</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Geodes_12.htm">4.1 System Clock</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Geodes_13.htm">4.2 Using Timers</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Geodes_14.htm">4.3 System Statistics and Utilities</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Geodes_15.htm">4.4 Shutting the System Down</A><BR>
&nbsp;&nbsp;<A HREF="#Geodes_16.htm">5 The Error-Checking Version</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Geodes_17.htm">5.1 Adding EC Code to Your Program</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Geodes_18.htm">5.2 Special EC Routines</A><BR>
&nbsp;&nbsp;<A HREF="#Geodes_19.htm">6 Inter-Application Communication</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Geodes_1a.htm">6.1 IACP Overview</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Geodes_1b.htm">6.2 GenApplicationClass Behavior</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Geodes_1c.htm">6.3 Messages Across an IACP Link</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Geodes_1d.htm">6.4 Being a Client</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Geodes_1e.htm">6.5 Being a Server</A><BR>
</STRONG>
</P> <!-- end of sectionlinks blob -->

<HR>
<A NAME="Geodes_1.htm"></A>


<H2 CLASS="sectionTitle">
<A HREF="#index.htm">Applications and Geodes</A>: 1 
Geodes</H2>
<P>
<EM>
Geode</EM>
<A NAME="Geodes_1.htm_IX_Geodes">
 </A>
 is the term used to describe a GEOS executable. Just as DOS has executables (programs) that reside in files on a disk, so too does GEOS. GEOS executables normally have the filename extension .GEO.</P>
<P>
Each geode may have up to three different aspects:</P>
<UL>
<LI>
<EM>
process<BR>
</EM>
Most of your geodes will have this aspect. A geode that is a process has an initial event-driven thread started for it by the kernel. All applications and some libraries will have this aspect.</LI>
<LI>
<EM>
library<BR>
</EM>
This aspect indicates that the geode exports <EM>
entry points</EM>
 for other geodes to use. Typically, these entry points describe where either object classes or code for routines is within the geode. A library has a special routine (the library's entry point) that is called by the system when the library or one of its clients is loaded or in the process of being unloaded.</LI>
<LI>
<EM>
driver<BR>
</EM>
This aspect indicates that the geode hides the details of some device or similarly changeable thing from the system. A driver has a special structure that defines its type, and it has a single entry point called a <EM>
strategy routine</EM>
. All calls to the driver pass through this strategy routine.</LI>
</UL>
<P>
A geode can have any combination of these aspects. For example, the print spooler is a process-library (and therefore provides routines for other geodes while also having a thread of its own), but the sound library is actually a library-driver since it manipulates the machine's sound hardware.</P>
<P>
Library and driver geodes that do not have the process aspect do not initially have event-driven threads. Therefore, typically they will not contain objects, just procedural code. They can contain objects, however, as any geode is free to create an event-driven thread for itself at any time. In fact, the parallel port driver does just that when it is printing to a port through DOS or BIOS.</P>
<P>
Geodes are loaded either with a call to the kernel routine <CODE>
GeodeLoad()</CODE>
 or as a side effect of a library's client being loaded (in that case, the library geode will be loaded as well). The generic UI supplies the special routine <CODE>
UserLoadApplication()</CODE>
, which you may use to load an application--a geode which has both a process aspect and its process class subclassed off of <CODE>
GenProcessClass</CODE>
 (and therefore can put generic UI objects on the screen).</P>
<P>
<A NAME="Geodes_1.htm_IX_Geodes:handles">
 </A>
Once a geode has been loaded, it is identified by its <EM>
geode handle</EM>
, which is the memory handle of the block that holds all the geode's system-administrative data. <A NAME="Geodes_1.htm_IX_Core block">
 </A>
This block is called the <EM>
core block</EM>
 and should not be accessed by anything other than the kernel. The geode handle is also used to determine the owner of a particular block in memory; when queried for the owner of a particular block, the kernel will return the geode handle of the geode that owns that block. A geode is the only entity that may own a system resource. If the geode is a process, the geode handle may also be known as a process handle.</P>
<P>
When a geode is loaded, its core block is connected to a linked list of the core blocks of other geodes running in the system. This linked list is chronological, with the first entry belonging to the first geode loaded and the last entry belonging to the most recent geode loaded. Each core block contains an entry for the handle of the next core block in the list; the kernel can follow these links to locate any geode in the system. (Only the kernel may do this.)</P>
<P>
After the core block is appended to the list, GEOS scans the list for other instances of the same core block. If the geode has been loaded more than once, it will have multiple instances in the list (one instance of the core block for each time the geode is loaded; each core block references the same copy of the geode, however). GEOS then copies the shared-resource handles from an existing core block (if found) into the new core block, thus reducing the amount of work required to load a particular geode multiple times (the shared resources do not need to be reloaded or recreated). Non-shared resource handles are not copied; the resources are loaded or constructed as necessary.</P>
<P>
Each geode's core block contains a reference count for that particular geode. When the geode is first loaded, the reference count is set to one. If the geode is a process, the act of initializing the process thread increments the reference count. Each time the geode is loaded again, the new core block will get its own reference count. If the geode is loaded implicitly (as a library, with <CODE>
GeodeUseLibrary()</CODE>
, or with <CODE>
GeodeUseDriver()</CODE>
), or if it spawns a new thread, it will receive yet another reference count.</P>
<P>
The reference count is decremented when a thread owned by the geode exits. If a client of a library geode exits, the library's reference count goes down by one.</P>
<P>
When a geode's reference count reaches zero, all the geode's non-sharable resources are freed along with all the file, event, and timer handles owned by the geode. If a sharable resource is co-owned by another instance of the geode, ownership is transferred to the geode's next-oldest instance. (Shared resources are always owned by the oldest instance of their geode.) Once the resources have been freed or transferred, the core block is removed from the linked list and is freed.</P>
<P>
To make sure no synchronization problems occur while updating the core block list (e.g. a geode is being loaded while it has just been freed), GEOS maintains an internal semaphore. The geode loading and freeing routines automatically maintain this semaphore.</P>
<P CLASS="subsectionLink">
<A HREF="#Geodes_2.htm">Geode Components and Structures</A></P>
<P CLASS="subsectionLink">
<A HREF="#Geodes_3.htm">Launching an Application</A></P>
<P CLASS="subsectionLink">
<A HREF="#Geodes_4.htm">Shutting Down an Application</A></P>
<P CLASS="subsectionLink">
<A HREF="#Geodes_5.htm">Saving and Restoring State</A></P>
<P CLASS="subsectionLink">
<A HREF="#Geodes_6.htm">Using Other Geodes</A></P>
<P CLASS="subsectionLink">
<A HREF="#Geodes_7.htm">Writing Your Own Libraries</A></P>
<P CLASS="subsectionLink">
<A HREF="#Geodes_8.htm">Working with Geodes</A></P>
<P CLASS="subsectionLink">
<A HREF="#Geodes_9.htm">Geode Protocols and Release Levels</A></P>
<P CLASS="subsectionLink">
<A HREF="#Geodes_a.htm">Temporary Geode Memory</A></P>
<HR>
<A NAME="Geodes_2.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Applications and Geodes</A>: 1.1 <A HREF="#Geodes_1.htm">Geodes</A>: 
Geode Components and Structures</H3>
<P>
A geode is simply a special type of GEOS file. It has a special file header that gets loaded in as the geode's core block. This file header contains the geode's type, attributes, release and protocol levels, and many other pieces of information necessary for GEOS to work with the geode. You never will have to know the exact structure of this header as the kernel provides routines necessary to access important portions of it.</P>
<P>
Several important items contained in the header are listed below.</P>
<UL>
<LI>
Core Block Handle<BR>
The core block contains its own memory handle, filled in when the geode is loaded into memory.</LI>
<LI>
Geode Attributes<BR>
Each geode has a record of type <CODE>
GeodeAttrs</CODE>
. The geode attributes are described below in <A HREF="#Geodes_2.htm_32508"> Geode Attributes</A>
.</LI>
<LI>
Release and Protocol Levels<BR>
Each geode can have release and protocol levels associated with it to ensure compatibility between different versions. Release and protocol levels are discussed in <A HREF="#Geodes_9.htm_74509"> Protocol Numbers</A>
.</LI>
<LI>
Geode Name<BR>
Each geode has a geode name and extension specified in the geode parameters (<STRONG CLASS="fileName">
.gp</STRONG>
) file.</LI>
<LI>
Geode Token<BR>
Every geode has a token associated with it in the token database. The token describes the geode's icon and is a structure of type <CODE>
GeodeToken</CODE>
. Tokens and icons are discussed in <A HREF="#Geodes_b.htm_46120"> Creating Icons</A>
.</LI>
<LI>
Geode Reference Count<BR>
The geode's reference count is stored in the core block. See above for a discussion of the reference count and how it's managed.</LI>
<LI>
Geode File Handle<BR>
The file handle of the geode identifies the open GEO file so the kernel can locate, load, and access its various resources.</LI>
<LI>
Geode Process Handle<BR>
Each geode that has a parent process will have the handle of the process in its core block. This is the handle of the parent process' core block. (The parent process is the owner of the thread that loaded the geode. It is notified when the geode exits, if the exiting geode is a process.)</LI>
<LI>
Handle of the Next Geode<BR>
Because geode core blocks are stored in a linked list, each core block must contain a reference to the next geode in the list.</LI>
<LI>
Handle of Private Data Space<BR>
Each geode that is not the kernel can have a &quot;private data space.&quot; This private data space is discussed in <A HREF="#Geodes_a.htm_50456"> Temporary Geode Memory</A>
.</LI>
<LI>
Resource, Library, and Driver Information<BR>
Each geode that imports or exports library or driver information must keep the import and export specifics available. Additionally, each geode must keep track of the resources it owns. All this information is stored in tables referenced from within the core block.</LI>
</UL>

<H4 CLASS="HeadingC">
<A NAME="Geodes_2.htm_32508">
 </A>
Geode Attributes</H4>
<P>
<A NAME="Geodes_2.htm_IX_GeodeAttrs">
 </A>
Each geode has in its core block a record of type <CODE>
GeodeAttrs</CODE>
. This record defines several things about the geode, including which aspects it uses and which of its aspects have been initialized. The <CODE>
GeodeAttrs</CODE>
 record contains one bit for each of the following attributes.</P>
<DL>
<DT>
GA_PROCESS</DT><DD>
<A NAME="Geodes_2.htm_IX_GA_&ldots;  (GeodeAttrs)">
 </A>
This geode has a process aspect and therefore an initial event-driven thread.</DD>
<DT>
GA_LIBRARY<A NAME="Geodes_2.htm_IX_Libraries:geode attribute">
 </A>
</DT><DD>This geode has a library aspect and therefore exports routines (and possibly object classes).</DD>
<DT>
GA_DRIVER<A NAME="Geodes_2.htm_IX_Drivers:geode attribute">
 </A>
</DT><DD>This geode has a driver aspect and therefore has a driver table, in which the strategy routine is specified.</DD>
<DT>
GA_KEEP_FILE_OPEN</DT><DD>
This geode must have its .GEO file kept open because its resources may be discardable or are initially discarded.</DD>
<DT>
GA_SYSTEM</DT><DD>This geode is a privileged geode and is almost certainly a system-used driver. These geodes have special exit requirements.</DD>
<DT>
GA_MULTI_LAUNCHABLE</DT><DD>
This geode may be loaded more than once and therefore may have more than one instance of its core block in memory.</DD>
<DT>
GA_APPLICATION</DT><DD>
This geode is a user-launchable application.</DD>
<DT>
GA_DRIVER_INITIALIZED</DT><DD>
This flag is set if the geode has had its driver aspect initialized (if the driver's strategy routine has been initialized). This flag will be set dynamically by the kernel.</DD>
<DT>
GA_LIBRARY_INITIALIZED</DT><DD>
This flag is set if the geode has had its library aspect initialized (if the library's entry routine has been called). This flag will be set dynamically by the kernel.</DD>
<DT>
GA_GEODE_INITIALIZED</DT><DD>
This flag is set if all aspects of the geode have been initialized.</DD>
<DT>
GA_USES_COPROC</DT><DD>
This geode uses a math coprocessor if one is available.</DD>
<DT>
GA_REQUIRES_COPROC</DT><DD>
This geode requires the presence of a math coprocessor or a coprocessor emulator.</DD>
<DT>
GA_HAS_GENERAL_CONSUMER_MODE</DT><DD>
This geode may be run in the General Consumer (appliance) Mode.</DD>
<DT>
GA_ENTRY_POINTS_IN_C</DT><DD>
This geode has its library entry routine in C rather than assembly language.</DD>


</DL>
<H4 CLASS="HeadingC">
Geode Token</H4>
<P>
As stated above, every geode is associated with a token in the token database. This token is defined by the use of a <CODE>
GeodeToken</CODE>
 structure. This structure and its uses are discussed in <A HREF="#Geodes_b.htm_46120"> Creating Icons</A>
.</P>

<HR>
<A NAME="Geodes_3.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Applications and Geodes</A>: 1.2 <A HREF="#Geodes_1.htm">Geodes</A>: 
Launching an Application</H3>
<PRE>GeodeLoad(), UserLoadApplication(), MSG_GEN_PROCESS_OPEN_APPLICATION</PRE>
<P>
<A NAME="Geodes_3.htm_IX_Applications:launching">
 </A>
An application is a geode with its GA_APPLICATION attribute set. This type of geode may be launched by the user through GeoManager or some other means provided by the system or another application. For the most part, the system will invoke and carry out the launch; your responsibilities are limited.</P>
<P>
An application may be loaded in essentially two ways: It may be launched, or it may be reloaded from a state file. In both cases, the kernel will load the proper resources and build out the UI properly according to the application.</P>
<P>
Most of the procedure of launching is handled within <CODE>
GenProcessClass</CODE>
, a subclass of <CODE>
ProcessClass</CODE>
. An application should define its own subclass of <CODE>
GenProcessClass</CODE>
 for its Process objects (event-driven threads not acting as Process objects should be subclassed from <CODE>
ProcessClass</CODE>
, not <CODE>
GenProcessClass</CODE>
). The launch procedure may be invoked by any thread and by any geode in either of the following ways:</P>
<UL>
<LI>
<CODE>
GeodeLoad()<BR>
</CODE>
<A NAME="Geodes_3.htm_IX_GeodeLoad()">
 </A>
This loads a geode from a given file and begins executing it based on the geode's type. <CODE>
GeodeLoad()</CODE>
 takes the name of the geode's file as well as a priority to set for the new geode's process thread, if it has one. <CODE>
GeodeLoad()</CODE>
 first creates the process thread of the application, then sends this thread a message. The process thread (a subclass of <CODE>
GenProcessClass</CODE>
) then creates a UI thread for the application.</LI>
<LI>
<CODE>
UserLoadApplication()<BR>
</CODE>
<A NAME="Geodes_3.htm_IX_UserLoadApplication()">
 </A>
Used by most application launchers, this routine loads an application. (C programmers will generally use <CODE>
MSG_GEN_PROCESS_OPEN_APPLICATION</CODE>
<A NAME="Geodes_3.htm_IX_MSG_GEN_PROCESS_OPEN_APPLICATION">
 </A>
 instead.) This routine takes some additional parameters and can load a geode either in engine mode or from a state file as well as in the normal open mode (see below). The base functionality of opening and loading the geode is implemented in this routine by a call to <CODE>
GeodeLoad()</CODE>
. Note, however, that this routine may only open application geodes--geodes with the GA_APPLICATION attribute set.</LI>
</UL>
<P>
Geodes may be launched in three modes:</P>
<UL>
<LI>
<EM>
Application</EM>
 mode launches the geode, loads all its active resources, builds its UI gadgetry, and sets it usable. The geode must be an application--that is, it must have its GA_APPLICATION attribute set.</LI>
<LI>
<EM>
Engine</EM>
 mode launches the geode but leaves its UI objects unusable (it never brings them on-screen). Engine mode is useful if you need to launch an application to grab information from it. GeoManager uses engine mode to launch an application, extract its icon, and put the icon in the token database. For efficiency, the application is never set usable, so its UI is never built.</LI>
<LI>
<EM>
Restore</EM>
 mode launches the geode from a saved state file, loading in resources and merging them with the default resources. This mode is invoked automatically by the UI if it is restoring the system or the geode from saved state. This mode is handled automatically by <CODE>
GenProcessClass</CODE>
 (your Process object).</LI>
</UL>
<P>
It is possible, however, for one application to launch another in a custom mode. If this is done, the application being launched is responsible for implementing the special mode.</P>
<P>
When the launch process has been initiated with the above routines, a thread is created for the application and its Process object is loaded immediately. Also loaded is the application's GenApplication object. The Application and Process objects interact with the User Interface to load the objects on the application's active list and set them all usable, bringing them up on-screen.</P>
<P>
Near the end of this procedure, just before the GenApplication is set usable, the Process object will receive a message based on the mode of launch. If the application must set up any special notification (such as for the quick-transfer mechanism) or must restore special state file data, it should intercept this message. Typically the message received will be <CODE>
MSG_GEN_PROCESS_OPEN_APPLICATION</CODE>
--two others are received (when restoring from state and when opening in engine mode), but they should not be intercepted.</P>
<HR>
<A NAME="Geodes_4.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Applications and Geodes</A>: 1.3 <A HREF="#Geodes_1.htm">Geodes</A>: 
Shutting Down an Application</H3>
<PRE>MSG_GEN_PROCESS_CLOSE_APPLICATION, MSG_GEN_PROCESS_CLOSE_ENGINE, MSG_GEN_PROCESS_CLOSE_CUSTOM, MSG_META_QUIT</PRE>
<P>
<A NAME="Geodes_4.htm_IX_Applications:shutting down">
 </A>
Just as loading an application is handled almost entirely by the system and GEOS classes, application shutdown is also fairly automatic. If the application intercepted <CODE>
MSG_GEN_PROCESS_OPEN_APPLICATION</CODE>
 for its own purposes on startup, it likely has to do a little cleanup; otherwise, it won't have to worry about shutting down. (See <A HREF="#Geodes_5.htm_76203"> Saving and Restoring State</A>
 for special information on using this message.)</P>
<P>
Any object in the system may cause an application to shut down. Usually, shutdown occurs either when the system is being exited (when a user exits to DOS, for example) or when the user has closed the application. Therefore, the usual source of the shutdown directive is the User Interface.</P>
<P>
An application begins shutting down when either its Process object or its Application object receives a <CODE>
MSG_META_DETACH</CODE>
. If you want to cause a shutdown manually, you should send <CODE>
MSG_META_QUIT</CODE>
 to the application's GenApplication object; this will execute some default functions and then send the appropriate <CODE>
MSG_META_DETACH</CODE>
. Essentially, the same detach and destruction mechanisms used for any object are used for the entire application. The object receiving <CODE>
MSG_META_DETACH</CODE>
 passes the message along to all of its children and to all the objects on its active list. (If a <CODE>
MSG_META_DETACH</CODE>
 is used without <CODE>
MSG_META_QUIT</CODE>
, the application will create a state file.)</P>
<P>
When they have all acknowledged the detach, the application acknowledges the detach and sets itself unusable. It automatically flushes its message queues before shutting down to avoid synchronization problems. You should not subclass the <CODE>
MSG_META_DETACH</CODE>
 handler unless you have special needs for cleaning up or sending special detach messages to other objects or geodes. If you do subclass it, you must call the superclass at the end of your handler. Otherwise, the application will not finish detaching (see <A HREF="../../Programming/GOCLanguage/GOCLanguage_15.htm#57162">the GEOS Programming chapter</A>).</P><P>
Instead of intercepting <CODE>
MSG_META_DETACH</CODE>
, though, the application may intercept the mode-specific message it will also receive. Depending on the mode in which it was launched, the application will receive (via the Process object) either <CODE>
MSG_GEN_PROCESS_CLOSE_APPLICATION</CODE>
 (for application mode) or <CODE>
MSG_GEN_PROCESS_CLOSE_ENGINE</CODE>
 (for engine mode). There is no special shutdown message for shutting down to a state file; instead, <CODE>
MSG_GEN_PROCESS_CLOSE_APPLICATION</CODE>
 is used.</P>
<P>
When the system shuts down or task-switches, a different type of shutdown occurs. Applications (or other objects interested in this event) must register for notification on the notification list GCNSLT_SHUTDOWN_CONTROL (notification lists are described in <A HREF="../../Kernel/GCN/index.htm">the General Change Notification chapter</A>). When the system shuts down or task-switches, the object will then receive a <CODE>MSG_META_CONFIRM_SHUTDOWN</CODE>
, at which time the object must call <CODE>
SysShutdown()</CODE>
.</P>
<HR>
<A NAME="Geodes_5.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Applications and Geodes</A>: 1.4 <A HREF="#Geodes_1.htm">Geodes</A>: 
<A NAME="Geodes_5.htm_76203">
 </A>
Saving and Restoring State</H3>
<PRE>ObjMarkDirty(), ObjSaveBlock()</PRE>
<P>
<A NAME="Geodes_5.htm_IX_Applications:saving to state file">
 </A>
<A NAME="Geodes_5.htm_IX_State files">
 </A>
Nearly all applications will save and restore their state so the user may shut down and return to precisely the same configuration he or she left. Saving of state is almost entirely contained within the system software; for the most part, only UI objects are saved to state files. You can, however, mark other object blocks and data for saving to a state file.</P>
<P>
The state file for an application is a VM file containing object blocks. Only object blocks may be saved to the state file, though you can save LMem data by setting up object blocks with only data chunks in them. (Create the blocks with <CODE>
MemAllocLMem()</CODE>
, passing type LMEM_TYPE_OBJ_BLOCK, then simply use <CODE>
LMemAlloc()</CODE>
 to allocate data chunks.) For more information about managing LMem and data chunks, see <A HREF="../../Memory/LMem/index.htm">the Local Memory chapter</A>. You can also save an extra data block to the state file using <CODE>MSG_GEN_PROCESS_CLOSE_APPLICATION</CODE>
 and <CODE>
MSG_GEN_PROCESS_OPEN_APPLICATION</CODE>
. In the close message, you can return the handle of an extra block to be saved to the state file; in the open message, the handle of the extra block is given to you, and you can restore this data as necessary. See the reference information for these messages under <CODE>
GenProcessClass</CODE>
 for more information.</P>
<P>
When a state file is saved, the system recognizes and saves only the dirty (modified) objects and chunks. Later, when state is restored, the system merges the changes in the state file with the original object blocks, resulting in the state that was saved.</P>
<P>
<A NAME="Geodes_5.htm_IX_ObjMarkDirty()">
 </A>
<A NAME="Geodes_5.htm_IX_ObjSaveBlock()">
 </A>
For individual objects or entire object blocks to be saved to the state file, they must be marked dirty. Generic objects automatically mark themselves dirty at the appropriate times, so you don't have to worry about them. To mark other objects dirty, use the routine <CODE>
ObjMarkDirty()</CODE>
. Each object which has been marked dirty will be saved to a state file when appropriate. If you want to save an entire object block to the state file, you can call <CODE>
ObjSaveBlock()</CODE>
 on the block; the system will save the entire block, not just the dirty chunks.</P>
<P>
State files are dealt with at only two times: First, when the system starts up, it will check for the existence of application state files. If a state file exists, the system will attempt to load the application belonging to it; after loading the application's resources, it will merge the state changes with the default settings to restore the original state.</P>
<P>
The second time state files are used is when the system shuts down. A simple shutdown (called a &quot;detach&quot;) is invoked only by the UI and is not abortable. When a detach occurs, the system shuts down all geodes as cleanly and quietly as possible, saving them to state files. Only certain geodes will respond in extreme cases, offering the user the option of delaying the detach or cancelling an operation in progress. An example of this is the GEOS spooler; if one or more jobs are actively printing or queued for printing, the spooler will ask the user whether the job should continue and the detach be delayed, or whether the job should be aborted or delayed until the next startup. The spooler can not abort the detach in any case.</P>
<P>
Another type of detach is called a &quot;quit.&quot; Any geode may invoke a quit, which is actually a two-step detach. A quit will first notify all other geodes that the system will soon be detaching; other geodes then have the chance to abort the quit if they want. For example, if a terminal program were downloading a file and received a quit notification, it could ask the user whether she wanted to abort the quit or the download. If the user wanted to finish the download, she would abort the quit; if she wanted to quit, she would abort the download. The system would then either shut down via a normal detach or stop the quit sequence.</P>
<P>
When a geode is first launched, no state file exists for it. The state file is not created until the geode is actually detached to a state file. If a geode is restored from a state file, the file will exist until the geode is detached again. A geode that gets closed (not detached to state) will remove any state file it may have created during a previous detach. A geode that is detached to state will create or modify its state file as appropriate.</P>
<P>
The state of an application (how it was launched) is reflected in the <CODE>
GAI_states</CODE>
 field of the GenApplication object. To retrieve the application's state, send it <CODE>
MSG_GEN_APPLICATION_GET_STATE</CODE>
. It will return a value of <CODE>
ApplicationStates</CODE>
. The most frequent use of this message is by applications that need to know whether a &quot;quit&quot; is underway when their process objects receive the <CODE>
MSG_GEN_PROCESS_CLOSE_APPLICATION</CODE>
 message; the process object will query the GenApplication and see if it is in the AS_QUITTING state.</P>
<P>
In addition to the above state-saving functionality, the kernel provides two routines that translate handles between the state file and memory. <CODE>
ObjMapSavedToState()</CODE>
 takes the memory handle of an object block and returns its corresponding state file VM block handle. <CODE>
ObjMapStateToSaved()</CODE>
 takes the state file VM block handle and returns the corresponding memory block handle, if any.</P>
<P>
If your application's documents are VM files, it is a very simple matter to save document state. In fact, if you use the GenDocument and document control objects, they will take care of document state saving for you. Be sure that the VM file has the VMA_BACKUP flag set in its <CODE>
VMAttributes</CODE>
; then you can simply call <CODE>
VMUpdate()</CODE>
 on the document file. (Note--do not use <CODE>
VMSave()</CODE>
 instead; it will erase the backup and lock in the user's changes to the document.) If you are not using GEOS VM files, it is up to you how and if you will save the document's state. For more information about GEOS VM files, see <A HREF="../../Memory/VM/index.htm">the VM chapter</A>.</P><HR>
<A NAME="Geodes_6.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Applications and Geodes</A>: 1.5 <A HREF="#Geodes_1.htm">Geodes</A>: 
Using Other Geodes</H3>
<P>
Often, geodes will have to use other geodes. For example, a communications program will use the Serial Driver, and a draw application will use the Graphic Object Library. Normally, this is taken care of by the compiler and the linker when you include a library or driver in your <STRONG CLASS="fileName">
.goc</STRONG>
 and <STRONG CLASS="fileName">
.gp</STRONG>
 files.</P>
<P>
Other times, however, an application will have to load libraries or drivers on the fly and then free them some time later. This section describes how to load, use, and free libraries and drivers.</P>

<H4 CLASS="HeadingC">
Using Libraries</H4>
<PRE>GeodeUseLibrary(), GeodeFreeLibrary()</PRE>
<P>
<A NAME="Geodes_6.htm_IX_Libraries:loading dynamically">
 </A>
Libraries are always referenced by their file names or by their geode handles. It's easiest, however, to use the file name of the library when loading it--the system will locate the library for you. It's unusual to need to load a library for use with your geode; in almost all cases it's easiest to include the library in your<STRONG CLASS="fileName">
 .goc</STRONG>
 and<STRONG CLASS="fileName">
 .gp</STRONG>
 files and have the system load and link the library automatically. (To do this, include the library's interface definition file in your code file and list the library's geode name in your geode parameters file.)</P>
<P>
<A NAME="Geodes_6.htm_IX_GeodeUseLibrary()">
 </A>
If you need to load a library dynamically, though, use <CODE>
GeodeUseLibrary()</CODE>
. This routine takes the protocol numbers expected of the library (see <A HREF="#Geodes_9.htm_74509"> Protocol Numbers</A>
) and the library geode's filename. It will locate and load the library if not already loaded. If the library is already loaded, it will increment the library's reference count. <A NAME="Geodes_6.htm_IX_GeodeFreeLibrary()">
 </A>
When you are done using a library loaded with <CODE>
GeodeUseLibrary()</CODE>
, you must free the library's instance with <CODE>
GeodeFreeLibrary()</CODE>
.</P>


<H4 CLASS="HeadingC">
Using Drivers</H4>
<PRE>GeodeUseDriver(), GeodeInfoDriver(), GeodeGetDefaultDriver(), GeodeSetDefaultDriver(), GeodeFreeDriver()</PRE>
<P>
<A NAME="Geodes_6.htm_IX_Drivers">
 </A>
Drivers are referenced by either their permanent names or their geode handles. Most drivers used by applications will be loaded automatically by the kernel; the application must have the driver's permanent name specified in its<STRONG CLASS="fileName">
 .gp</STRONG>
 file. Should an application need to use a driver not included in its parameters file, however, it can do so with the routines described below.</P>
<P>
<A NAME="Geodes_6.htm_IX_GeodeUseDriver()">
 </A>
When you need to use a driver, the <CODE>
GeodeUseDriver()</CODE>
 routine will locate and load it, adding it to the active geodes list. You must pass the desired driver geode's filename as well as the expected protocol levels of the driver. The routine will return the driver's geode handle. <A NAME="Geodes_6.htm_IX_GeodeFreeDriver()">
 </A>
If you load a driver dynamically, you must free it with <CODE>
GeodeFreeDriver()</CODE>
 when your geode shuts down or otherwise finishes using the driver.</P>
<P>
<A NAME="Geodes_6.htm_IX_GeodeInfoDriver()">
 </A>
If you know a driver's geode handle, you can easily retrieve information about it with the routine <CODE>
GeodeInfoDriver()</CODE>
.<A NAME="Geodes_6.htm_IX_DriverInfoStruct">
 </A>
 This returns a structure of type <CODE>
DriverInfoStruct</CODE>
, which contains the driver's type (<CODE>
DriverType</CODE>
), the driver's attributes, and a far pointer to the driver's strategy routine. Many driver types have an expanded information structure, of which <CODE>
DriverInfoStruct</CODE>
 is just the first field. Video driver information structures, for example, also contain dimensions and color capabilities (among other things) of the particular devices they drive. The driver information structure is shown below.</P>
<PRE>typedef struct {
    void			(*DIS_strategy)();
    DriverAttrs			DIS_driverAttributes;
    DriverType			DIS_driverType;
} DriverInfoStruct;</PRE>
<P>
<A NAME="Geodes_6.htm_IX_DIS_&ldots;  (DriverInfoStruct structure)">
 </A>
The <CODE>
DIS_strategy</CODE>
 field of the structure contains a pointer to the driver's strategy routine in fixed memory. After the driver has been loaded, its strategy routine is called directly with a driver function name.</P>
<P>
<A NAME="Geodes_6.htm_IX_DriverAttrs">
 </A>
The <CODE>
DIS_driverAttributes</CODE>
 is an attribute record of type <CODE>
DriverAttrs</CODE>
, the flags of which are shown below:</P>
<DL>
<DT>
DA_FILE_SYSTEM</DT><DD>
<A NAME="Geodes_6.htm_IX_DA_&ldots;">
 </A>
This flag indicates that the driver is used for file access.</DD>
<DT>
DA_CHARACTER</DT><DD>
This flag indicates that the driver is used for a character-oriented device.</DD>
<DT>
DA_HAS_EXTENDED_INFO</DT><DD>
This flag indicates that the driver has a <CODE>
DriverExtendedInfo</CODE>
 structure.</DD>
</DL>
<P>
The <CODE>
DIS_driverType</CODE>
 contains the type of driver described by the information structure. The types that may be specified in this field are listed below:</P>
<DL>
<DT>
DRIVER_TYPE_VIDEO</DT><DD>
<A NAME="Geodes_6.htm_IX_DRIVER_TYPE_&ldots;">
 </A>
This is used for video drivers.</DD>
<DT>
DRIVER_TYPE_INPUT</DT><DD>
This is used for input (mouse, keyboard, pen, etc.) drivers.</DD>
<DT>
DRIVER_TYPE_MASS_STORAGE</DT><DD>
This is used for storage device drivers.</DD>
<DT>
DRIVER_TYPE_STREAM</DT><DD>
This is used for stream and port (parallel, serial) drivers.</DD>
<DT>
DRIVER_TYPE_FONT</DT><DD>
This is used for font rasterizing drivers.</DD>
<DT>
DRIVER_TYPE_OUTPUT</DT><DD>
This is used for output drivers other than video and printer drivers.</DD>
<DT>
DRIVER_TYPE_LOCALIZATION</DT><DD>
This is used for drivers that facilitate internationalization.</DD>
<DT>
DRIVER_TYPE_FILE_SYSTEM</DT><DD>
This is used for file system drivers.</DD>
<DT>
DRIVER_TYPE_PRINTER</DT><DD>
This is used for printer drivers.</DD>
<DT>
DRIVER_TYPE_SWAP</DT><DD>
This is used for the system's memory-swapping drivers.</DD>
<DT>
DRIVER_TYPE_POWER_MANAGEMENT</DT><DD>
This is used for devices that have power management systems.</DD>
<DT>
DRIVER_TYPE_TASK_SWITCH</DT><DD>
This is used for devices or systems that have task switchers.</DD>
<DT>
DRIVER_TYPE_NETWORK</DT><DD>
This is used for special networks that require driver functionality.</DD>
</DL>
<P>
When you want a driver to perform one of its functions, you must call its strategy routine. The strategy routine typically takes a number of parameters, one of which is the function the driver should perform. The <CODE>
DriverInfoStruct</CODE>
 contains a far pointer to the strategy routine; your application should store this far pointer and call it directly any time one of the driver's functions is needed. However, because the driver may be put in a different location each time it's loaded, you should not save the pointer in a state file. Note that this scheme of accessing drivers directly can only be implemented in assembly language. Some drivers may provide library interfaces as well as their standard driver interface; this allows routines to be written in C. </P>
<P>
GEOS<A NAME="Geodes_6.htm_IX_GeodeDefaultDriverType">
 </A>
 maintains default drivers for the entire system. The types of default drivers are described by <CODE>
GeodeDefaultDriverType</CODE>
; all the types are shown below. They are called default drivers because the default for each category of driver used by the system is stored in the GEOS.INI file. GEOS will, upon startup, load in the default driver of each category.</P>
<DL>
<DT>
GDDT_FILE_SYSTEM</DT><DD>
GEOS<A NAME="Geodes_6.htm_IX_GDDT_&ldots;">
 </A>
 may use several file system drivers during execution. A file system driver allows GEOS to work on a given DOS (or substitute file access system). The primary driver is considered the default driver.</DD>
<DT>
GDDT_KEYBOARD</DT><DD>
The system may only use one keyboard driver during execution; typically, keyboards can differ from country to country. Not all systems will have a keyboard.</DD>
<DT>
GDDT_MOUSE</DT><DD>
The mouse should be usable when the system comes up on the screen; the user does not have to manually load a mouse driver with each execution of GEOS. Not all systems will have a mouse.</DD>
<DT>
GDDT_VIDEO</DT><DD>
GEOS must know what type of video driver to use prior to attempting to display itself.</DD>
<DT>
GDDT_MEMORY_VIDEO</DT><DD>
The Vidmem driver is a video driver that draws to memory (i.e. to bitmaps). It is used primarily for printing but also for editing bitmaps.</DD>
<DT>
GDDT_POWER_MANAGEMENT</DT><DD>
A few machines use hardware power management systems (most notably some palmtops and some notebook and laptop machines). In order for GEOS to handle the power management hardware properly, it must load the driver on startup. (Most machines will not use this type of driver.)</DD>
<DT>
GDDT_TASK</DT><DD>Some systems will use a task switcher; in order for GEOS to be a task in one of these, it must have a default task driver.</DD>
</DL>
<P>
<A NAME="Geodes_6.htm_IX_GeodeGetDefaultDriver()">
 </A>
To retrieve the default that GEOS is using, call the routine <CODE>
GeodeGetDefaultDriver()</CODE>
 with the appropriate driver type (a member of the type <CODE>
GeodeDefaultDriverType</CODE>
). This routine will return the geode handle of the default driver of that type. <A NAME="Geodes_6.htm_IX_GeodeSetDefaultDriver()">
 </A>
To set a new default driver for a specified driver type, use <CODE>
GeodeSetDefaultDriver()</CODE>
. This routine takes a geode handle and a driver type and sets the system default for that type. Typically, system defaults will be set only by the Preferences Manager application.</P>

<HR>
<A NAME="Geodes_7.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Applications and Geodes</A>: 1.6 <A HREF="#Geodes_1.htm">Geodes</A>: 
Writing Your Own Libraries</H3>
<P>
<A NAME="Geodes_7.htm_IX_.gp files:for libraries[;gp files:for libraries]">
 </A>
<A NAME="Geodes_7.htm_IX_Libraries:writing libraries">
 </A>
Creating a library geode is a simple step beyond creating a normal application. Libraries can have their own process threads or not; most libraries do not, though some will. To create a library geode, you have to do four things:</P>
<UL>
<LI>
Declare the geode to be a library.<BR>
In the geode parameters (<STRONG CLASS="fileName">
.gp</STRONG>
) file, you must declare the type of the geode to be library.</LI>
<LI>
Define an entry point routine.<BR>
Create a routine that initializes the library; this routine is called the &quot;entry point routine&quot; and is called each time the library is loaded.</LI>
<LI>
Export the entry point routine.<BR>
Add another line in the geode parameters (<STRONG CLASS="fileName">
.gp</STRONG>
) file to export the library's entry point routine.</LI>
<LI>
Set the geode's permanent name properly.<BR>
Most libraries have the extension of their permanent name be &quot;lib.&quot; This helps identify it as a library when using Swat. The permanent name is defined in the geode parameters (<STRONG CLASS="fileName">
.gp</STRONG>
) file.</LI>
</UL>
<P>
<A HREF="#Geodes_7.htm_94502"> Defining a Library-the sound.gp File</A>
 shows an example of the three changes you must make to the geode's parameters file to make it a library.</P>
<P CLASS="figTitle">
Code Display 7-1 <A NAME="Geodes_7.htm_94502">
 </A>
Defining a Library--the sound.gp File</P>
<PRE><A NAME="Geodes_7.htm_IX_sound library:parameters file"> </A># The Sound Library has the following three lines in its geode parameters file
# (sound.gp) different from how they might appear in an application.</PRE>
<PRE>#
# The permanent name of the geode might normally be sound.app if it is an
# application. A library typically has &quot;lib&quot; as its name extension.
#
name sound.lib</PRE>
<PRE>#
# Declare the type of the geode to be a library. Applications typically have a
# &quot;process&quot; aspect; many libraries do not. Libraries must also be declared to
# have a &quot;library&quot; aspect. (Note that the Sound Library is exceptional in that
# it has both a driver aspect and a library aspect.)
#
type driver, library, single</PRE>
<PRE>#
# Export the geode's entry point routine so the kernel may call it when the
# library is loaded. This routine must be defined somewhere in the geode's code.
# Note that it is exported with the &quot;entry&quot; line rather than the standard
# &quot;export&quot; line; this is to distinguish the exported routine as the entry
# point rather than a typical routine.
#
entry SoundEntry</PRE>
<HR>
<A NAME="Geodes_8.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Applications and Geodes</A>: 1.7 <A HREF="#Geodes_1.htm">Geodes</A>: 
Working with Geodes</H3>
<P>
The system provides a number of utility routines for getting information and setting attributes of geodes. These are loosely organized throughout the following sections.</P>

<H4 CLASS="HeadingC">
Accessing the Application Object</H4>
<PRE>GeodeGetAppObject()</PRE>
<P>
GEOS<A NAME="Geodes_8.htm_IX_Application object:accessing">
 </A>
<A NAME="Geodes_8.htm_IX_GeodeGetAppObject()">
 </A>
 offers a routine for retrieving the optr of an application's GenApplication object. <CODE>
GeodeGetAppObject()</CODE>
 takes the process handle of the Process object of the application. It returns the optr of the application's GenApplication object.</P>


<H4 CLASS="HeadingC">
General Geode Information</H4>
<PRE>GeodeFind(), GeodeFindResource(), GeodeDuplicateResource(), GeodeGetInfo(), GeodeGetProcessHandle(), GeodeGetCodeProcessHandle(), ProcInfo()</PRE>
<P>
<CODE>
GeodeFind()</CODE>
<A NAME="Geodes_8.htm_IX_GeodeFind()">
 </A>
 returns a geode's handle when given a permanent name and attributes to search on. GEOS will search the active geode list for any geode with the given name and the proper attributes set or clear.</P>
<P>
<CODE>
GeodeFindResource()</CODE>
<A NAME="Geodes_8.htm_IX_GeodeFindResource()">
 </A>
 locates a given resource within a geode's file. It must be passed the file handle of the geode, the number of the resource in the file, and an offset within the resource at which the file read/write position should be placed. This routine may only be used on open geode files, and it returns the base offset and size of the resource. You will probably not need to use this routine. <A NAME="Geodes_8.htm_IX_GeodeDuplicateResource()">
 </A>
To load a resource into a new block of memory, you can call <CODE>
GeodeDuplicateResource()</CODE>
.</P>
<P>
<CODE>
GeodeGetInfo()</CODE>
<A NAME="Geodes_8.htm_IX_GeodeGetInfo()">
 </A>
 takes a geode handle, a <A NAME="Geodes_8.htm_IX_GeodeGetInfoType">
 </A>
<CODE>
GeodeGetInfoType</CODE>
 parameter, and a buffer appropriate for the return information. It returns the appropriate values as specified in the <CODE>
GeodeGetInfoType</CODE>
 parameter. (This parameter specifies what type of information is sought about the geode; the routine can return the geode's attributes, geode type, release level, protocol, token ID, or permanent name.) The possible values of <CODE>
GeodeGetInfoType</CODE>
 are shown below:</P>
<DL>
<DT>
GGIT_ATTRIBUTES</DT><DD>
<A NAME="Geodes_8.htm_IX_GGIT_&ldots;">
 </A>
This indicates the geode's attributes should be returned.</DD>
<DT>
GGIT_TYPE</DT><DD>This indicates the geode's type should be returned (type <CODE>
GeodeType</CODE>
).</DD>
<DT>
GGIT_GEODE_RELEASE</DT><DD>
This indicates the geode's release numbers should be returned.</DD>
<DT>
GGIT_GEODE_PROTOCOL</DT><DD>
This indicates the geode's protocol numbers should be returned.</DD>
<DT>
GGIT_TOKEN_ID</DT><DD>
This indicates the geode's token information should be returned.</DD>
<DT>
GGIT_PERM_NAME_AND_EXT</DT><DD>
This indicates the geode's permanent name and extender should be returned.</DD>
<DT>
GGIT_PERM_NAME_ONLY</DT><DD>
This indicates the eight characters of the geode's permanent name only should be returned, without the extender characters.</DD>
</DL>
<P>
<CODE>
GeodeGetProcessHandle()</CODE>
<A NAME="Geodes_8.htm_IX_GeodeGetProcessHandle()">
 </A>
 returns the geode handle of the current process (the owner of the current thread). Another routine, <CODE>
GeodeGetCodeProcessHandle()</CODE>
<A NAME="Geodes_8.htm_IX_GeodeGetCodeProcessHandle()">
 </A>
, returns the handle of the geode that owns the code block from which it was called.</P>
<P>
<CODE>
ProcInfo()</CODE>
<A NAME="Geodes_8.htm_IX_ProcInfo()">
 </A>
 returns the thread handle of the first thread of a given process.</P>


<H4 CLASS="HeadingC">
Managing Geode Event Queues</H4>
<PRE>GeodeAllocQueue(), GeodeFreeQueue(), GeodeInfoQueue(), GeodeFlushQueue(), ObjDispatchMessage(), QueueGetMessage(), QueuePostMessage(), GeodeDispatchFromQueue()</PRE>
<P>
<A NAME="Geodes_8.htm_IX_Event queues">
 </A>
The following routines allocate and manage event queues. These routines are rarely called by applications as event queues are automatically managed for each thread and application.</P>
<P>
<CODE>
GeodeAllocQueue()</CODE>
<A NAME="Geodes_8.htm_IX_GeodeAllocQueue()">
 </A>
 allocates an event queue and returns its handle.<CODE>
 GeodeInfoQueue()</CODE>
<A NAME="Geodes_8.htm_IX_GeodeInfoQueue()">
 </A>
 returns the number of events in a given event queue.<CODE>
 GeodeFreeQueue()</CODE>
<A NAME="Geodes_8.htm_IX_GeodeFreeQueue()">
 </A>
 frees an event queue allocated with the routine <CODE>
GeodeAllocQueue()</CODE>
. It must be passed the handle of the queue to be freed (unhandled events still in the queue will be discarded).</P>
<P>
<CODE>
GeodeFlushQueue()</CODE>
<A NAME="Geodes_8.htm_IX_GeodeFlushQueue()">
 </A>
 flushes all events from one queue and synchronously places them all in another queue (events may not simply be tossed out).</P>
<P>
<CODE>
QueueGetMessage()</CODE>
<A NAME="Geodes_8.htm_IX_QueueGetMessage()">
 </A>
<A NAME="Geodes_8.htm_IX_ObjDispatchMessage()">
 </A>
 combined with <CODE>
ObjDispatchMessage()</CODE>
 removes the first event from the given event queue and handles it via a callback routine. A far pointer to the callback routine in memory must be passed. Typically these will be used only by the assembly <CODE>
ObjMessage()</CODE>
 routine used by the kernel; some other applications of this routine may be used, though. For example, the sound driver uses a note queue unassociated with objects and messages. The callback routine therefore gets the &quot;event&quot; (note) and pretends it's handling a message.</P>
<P>
<CODE>
QueuePostMessage()</CODE>
<A NAME="Geodes_8.htm_IX_QueuePostMessage()">
 </A>
 adds an event to the specified queue. </P>

<HR>
<A NAME="Geodes_9.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Applications and Geodes</A>: 1.8 <A HREF="#Geodes_1.htm">Geodes</A>: 
Geode Protocols and Release Levels</H3>
<P>
<A NAME="Geodes_9.htm_IX_Release number">
 </A>
<A NAME="Geodes_9.htm_IX_Protocols:geode">
 </A>
Every GEOS geode and VM file has both a release level and a protocol level as extended attributes of the file. These two items help ease the transitions for both programmer and user when changes are made to applications, libraries, drivers, system software, etc. To control release and protocol numbers, use the GREV tool and a REV file as described in <A HREF="../../Tools/Tools/TTools_7.htm">the Grev section of the Using Tools chapter</A>.</P>

<H4 CLASS="HeadingC">
Release Numbers</H4>
<P>
<A NAME="Geodes_9.htm_IX_FEA_RELEASE">
 </A>
The release number is a <CODE>
ReleaseNumber</CODE>
 structure which consists of four components: The <CODE>
RN_major</CODE>
 and <CODE>
RN_</CODE>
<EM>
minor</EM>
 numbers are the most significant. The <CODE>
RN_</CODE>
<EM>
change</EM>
 and <CODE>
RN_</CODE>
<EM>
engineering</EM>
 numbers are less significant and are used primarily to indicate non-released or running upgrade types of changes to the geode. <A NAME="Geodes_9.htm_IX_ReleaseNumber">
 </A>
The <CODE>
ReleaseNumber</CODE>
 of a geode or VM file is stored in the file's FEA_RELEASE extended attribute, and its structure is shown below:</P>
<PRE>typedef struct {
    word    RN_major;
    word    RN_minor;
    word    RN_change;
    word    RN_engineering;
} ReleaseNumber;</PRE>
<P>
The contents of the release number are up to the particular geode and are product-specific. Release numbers are not used by GEOS for compatibility checking or any other validation of files, though they are used during installation procedures.</P>
<P>
To retrieve the release number of a given geode, use the routine <CODE>
GeodeGetInfo()</CODE>
. Release levels should be set at compile time and are not changeable at run-time.</P>


<H4 CLASS="HeadingC">
<A NAME="Geodes_9.htm_74509">
 </A>
Protocol Numbers</H4>
<P>
<A NAME="Geodes_9.htm_IX_FEA_PROTOCOL">
 </A>
The protocol number is a structure of type <CODE>
ProtocolNumber</CODE>
 stored in the file's FEA_PROTOCOL extended attribute. Each GEOS geode and data file has a protocol level associated with it. The protocol level is used for compatibility checking for both geodes and documents.</P>
<P>
<A NAME="Geodes_9.htm_IX_ProtocolNumber">
 </A>
The <CODE>
ProtocolNumber</CODE>
 structure consists of two parts, the major protocol and the minor protocol. This structure is shown below:</P>
<PRE>typedef struct {
    word    PN_major;
    word    PN_minor;
} ProtocolNumber;</PRE>
<P>
Differences in protocol levels indicate incompatibilities between two geodes, between a geode and its document format, or between a geode and its state file format. If the major protocols are different, the two items are not compatible at all (unless special provisions are made). If the minor protocol is greater than expected, some incompatibility may exist but should not affect the program. You should increment a geode's or document's protocol whenever a change is made.</P>
<P>
<A NAME="Geodes_9.htm_IX_Libraries:protocol numbers">
 </A>
If a change to a library is upward-compatible, only the minor protocol needs to be incremented. For example, if a library acquires a new function but the library's entry points are undisturbed, the minor protocol should be incremented and the major protocol left as is. If the new function causes relocation of the entry point numbers, however, the major protocol must also be incremented.</P>
<P>
An application's protocol must be increased whenever a change will affect the application's state files. If you make a change to an application, for example, and the user has old state files, either the changes in the application can be replaced with the old information, or the state file will cause an incompatibility with unpredictable results. If the change to the application is simply functional, increment the minor protocol. If the change is to any part of a UI resource or to any other item saved to a state file, increment the major protocol. State files will be loaded if minor protocols are different and will be ignored if major protocols are different.</P>
<P>
If an application's document format changes, you should make sure the new documents are not loaded by old applications or vice versa (unless you take the necessary conversion steps). When opening a document, you can check its protocol by checking the document file's extended attribute FEA_PROTOCOL. If the protocol level needs to be changed (after conversions have been done, of course), you can change them by setting FEA_PROTOCOL. (See <A HREF="../../Files/FileSys/index.htm">the File System chapter</A>.)</P><P>
A few examples of when minor and major protocols should be incremented follow. Keep in mind that this list is by no means exhaustive.</P>
<UL>
<LI>
If you add a data structure to a document format and older versions of the application will still be able to open the document, increment the document's minor protocol only.</LI>
<LI>
If you change the instance data structure of an object that gets saved to the document, increment the major protocol, as the new methods will be using the wrong offsets to access data in the old object.</LI>
<LI>
If you add a new class to your application and don't disturb any of the other classes' entry points (i.e. add the class at the end), increment the minor protocol only.</LI>
<LI>
If you add a new class, disturbing entry points, increment the major protocol.</LI>
<LI>
If you add or delete a resource, increment the major protocol.</LI>
<LI>
If you add a chunk or object to a resource that gets saved to state files, increment the major protocol.</LI>
<LI>
If you change an object's flags (e.g. mark it ignore-dirty), increment the major protocol. Otherwise, the flags will be restored from the state file and will override the changes you made.</LI>
</UL>

<HR>
<A NAME="Geodes_a.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Applications and Geodes</A>: 1.9 <A HREF="#Geodes_1.htm">Geodes</A>: 
<A NAME="Geodes_a.htm_50456">
 </A>
Temporary Geode Memory</H3>
<PRE>GeodePrivAlloc(), GeodePrivFree(), GeodePrivWrite(), GeodePrivRead()</PRE>
<P>
<A NAME="Geodes_a.htm_IX_Private data">
 </A>
Every geode in the system has a &quot;private data&quot; area, a space set aside in its core block. This private data is used primarily by library geodes, when each of the library's clients uses its own copy of a particular data structure that gets manipulated by the library. The private data mechanism is used in the GEOS implementation of <CODE>
malloc()</CODE>
, for example (though you need not know this to use <CODE>
malloc()</CODE>
).</P>
<P>
Private memory may be allocated, written to, read from, and freed by the library. The library does not have to allocate a block for each geode and maintain its own handle table; the use of the <CODE>
GeodePriv...()</CODE>
 routines automatically manages this.</P>
<P>
<CODE>
GeodePrivAlloc()</CODE>
<A NAME="Geodes_a.htm_IX_GeodePrivAlloc()">
 </A>
 reserves a given number of contiguous words for the library within the private data of all geodes in the system. The memory space is reserved but is not actually allocated for a given geode until it is used (written to); this is done for optimization purposes. This routine will return a tag pointing to where the reserved words begin. This tag is used when reading, writing, or freeing the private data. If the memory could not be allocated, the routine will return zero.</P>
<P>
<CODE>
GeodePrivWrite()</CODE>
<A NAME="Geodes_a.htm_IX_GeodePrivWrite()">
 </A>
 and <A NAME="Geodes_a.htm_IX_GeodePrivRead()">
 </A>
<CODE>
GeodePrivRead()</CODE>
 write to and read from the private data space. They take similar parameters: a geode handle, the tag as returned by <CODE>
GeodePrivAlloc()</CODE>
, the total number of words to be written or read, and a pointer to a locked or fixed buffer. In <CODE>
GeodePrivWrite()</CODE>
, the buffer will be passed containing the words to be written; in <CODE>
GeodePrivRead()</CODE>
, the buffer will be passed empty and returned containing the words read.</P>
<P>
Typically, the geode handle passed will be zero; this indicates that the current process (which will be the library's current client) will be the owner of the private data affected. Because the library code will be executing in the thread of a given application, the application geode will be the only one having its private data affected. Thus, a library can use the same code to store different data for each geode that uses it; neither the library nor the geode needs to know that other geodes are also using the same routines.</P>
<P>
<CODE>
GeodePrivFree()</CODE>
<A NAME="Geodes_a.htm_IX_GeodePrivFree()">
 </A>
 frees a given number of words from all geodes' private data. It needs to be passed only the number of words to be freed and the tag as returned by <CODE>
GeodePrivAlloc()</CODE>
.</P>
<HR>
<A NAME="Geodes_b.htm"></A>


<H2 CLASS="sectionTitle">
<A HREF="#index.htm">Applications and Geodes</A>: 2 
<A NAME="Geodes_b.htm_46120">
 </A>
Creating Icons</H2>
<P>
<A NAME="Geodes_b.htm_IX_Tokens:icons">
 </A>
Every geode can have an icon associated with it. Typically, only applications will have special icons; other geodes (libraries and drivers) generally use one of the system icons or the icon of the application they're primarily used by.</P>
<P>
An application's icon is stored in two places: It is defined and stored within the application's extended attributes in its .GEO file. It is also stored in a database file maintained by the UI, called the <EM>
token database</EM>
.</P>
<P>
The GEOS development kit includes an icon editor tool so you can easily create icons of various color and resolution characteristics and install them into your applications.</P>
<P CLASS="subsectionLink">
<A HREF="#Geodes_c.htm">The Token Database</A></P>
<P CLASS="subsectionLink">
<A HREF="#Geodes_d.htm">Managing the Token Database File</A></P>
<HR>
<A NAME="Geodes_c.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Applications and Geodes</A>: 2.1 <A HREF="#Geodes_b.htm">Creating Icons</A>: 
The Token Database</H3>
<PRE>TokenOpenLocalTokenDB(), TokenCloseLocalTokenDB()</PRE>
<P>
<A NAME="Geodes_c.htm_IX_Tokens:database">
 </A>
The token database is stored in its own file. Each entry represents a single icon or series of icons that can be used with any number of files. The token database file is managed by the UI and the kernel; you should have no reason to access its internals directly, and most applications will never need to use any of the token routines except to install their document icons.</P>
<P>
Some systems may have shared token database files; this is controlled by the INI file key <CODE>
sharedTokenDatabase</CODE>
 in the <CODE>
paths</CODE>
 category. Most often a shared database file exists on a network drive and may be supplemented with a local token database. By default, if a shared database file exists, it will be opened read-only in addition to the read/write local file. <A NAME="Geodes_c.htm_IX_TokenOpenLocalTokenDB()">
 </A>
<A NAME="Geodes_c.htm_IX_TokenCloseLocalTokenDB()">
 </A>
You can open and close only the local database file, however, with the routines <CODE>
TokenOpenLocalTokenDB()</CODE>
 and <CODE>
TokenCloseLocalTokenDB()</CODE>
.</P>
<P>
Every GEOS file has a token. The token is an index into the token database. When GeoManager scans a directory, it grabs the token from each file and searches through the token database file for it. If a match is found, GeoManager selects the proper icon and displays it; if no match is found or if the file's token is invalid, GeoManager will launch the application in engine mode and request that it install its token in the database.</P>
<P>
For non-GEOS files, GeoManager uses the three extension characters of the file's name as a pseudo-index. For each extension (e.g. .COM, .EXE, .DOC, .BAT, etc.), GeoManager uses a single icon. Which icon is used can be set in the GEOS.INI file if a user wishes, but GeoManager will normally select the default DOS icon (of which there are two: one for executables and one for non-executables).</P>
<P>
<A NAME="Geodes_c.htm_IX_GeodeToken">
 </A>
The index into the token database consists of two parts and is of type <CODE>
GeodeToken</CODE>
. This structure contains four text characters as well as the manufacturer ID number of the geode's manufacturer. The structure's definition is shown below:</P>
<PRE>typedef struct {
    TokenChars				GT_chars;
    ManufacturerID				GT_manufID;
} GeodeToken;</PRE>
<PRE>typedef char TokenChars[TOKEN_CHARS_LENGTH];</PRE>
<P>
This structure is created and filled automatically in the geode's <STRONG CLASS="fileName">
.geo</STRONG>
 file header by the Glue linker, which takes the values from the geode's geode parameters (<STRONG CLASS="fileName">
.gp</STRONG>
) file. The two fields used from the<STRONG CLASS="fileName">
 .gp</STRONG>
 file are <CODE>
tokenchars</CODE>
 for the four characters and <CODE>
tokenid</CODE>
 for the manufacturer ID.</P>
<P>
A <CODE>
GeodeToken</CODE>
 structure in the token database file can also be filled in when GeoManager scans a directory. If the header of a particular application's <STRONG CLASS="fileName">
.geo</STRONG>
 file does not have a recognized token, GeoManager will launch the application in &quot;engine&quot; mode, loading its GenApplication object. It will request that the application object then install its icon into the token database file (<CODE>
GenApplicationClass</CODE>
 knows how to do this).</P>
<P>
The token database file contains one entry for each token that has been installed. Each time a new token and icon is encountered, a new entry is added by the UI. This happens automatically when GeoManager scans a directory.</P>
<HR>
<A NAME="Geodes_d.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Applications and Geodes</A>: 2.2 <A HREF="#Geodes_b.htm">Creating Icons</A>: 
Managing the Token Database File</H3>
<PRE>TokenDefineToken(), TokenGetTokenInfo(), TokenLookupMoniker(), TokenLoadMonikerBlock(), TokenLoadMonikerChunk(), TokenLoadMonikerBuffer(), TokenRemoveToken(), TokenLoadTokenBlock(), TokenLoadTokenChunk(), TokenLoadTokenBuffer(), TokenLockTokenMoniker(), TokenUnlockTokenMoniker(), TokenGetTokenStats(), TokenListTokens()</PRE>
<P>
In nearly all cases, you will create your application's icon with the icon tool and not worry about it again. However, the following routines allow you to add, change, access, and remove entries from the token database.</P>
<P>
<CODE>
TokenLoadTokenBlock()</CODE>
<A NAME="Geodes_d.htm_IX_TokenLoadTokenBlock()">
 </A>
, <A NAME="Geodes_d.htm_IX_TokenLoadTokenChunk()">
 </A>
<CODE>
TokenLoadTokenChunk()</CODE>
, and <CODE>
TokenLoadTokenBuffer()</CODE>
<A NAME="Geodes_d.htm_IX_TokenLoadTokenBuffer()">
 </A>
 load a <CODE>
TokenEntry</CODE>
 structure into memory (a newly allocated block, a newly allocated chunk, or a locked buffer). The <CODE>
TokenEntry</CODE>
 structure contains information about the token, the geode's release number, and the geode's protocol number. This structure does not actually contain the monikers used for the icon.</P>
<P>
<CODE>
TokenLookupMoniker()</CODE>
<A NAME="Geodes_d.htm_IX_TokenLookupMoniker()">
 </A>
 gets the specific moniker of a token entry given the display type (CGA, EGA, VGA, etc.), the entry's <CODE>
GeodeToken</CODE>
 structure, and search flags. If the moniker is found, the entry identifier (database group and ID numbers) of the moniker are returned. You can use these return values to lock the moniker into memory (see below).</P>
<P>
<CODE>
TokenLockTokenMoniker()</CODE>
<A NAME="Geodes_d.htm_IX_TokenLockTokenMoniker()">
 </A>
 locks a moniker into memory given its entry identifier. This routine returns a pointer to a locked block and the chunk handle of the chunk containing the locked moniker. A moniker should always be locked before it is drawn; this keeps it from moving in memory while it is being accessed. <A NAME="Geodes_d.htm_IX_TokenUnlockTokenMoniker()">
 </A>
The routine <CODE>
TokenUnlockTokenMoniker()</CODE>
 unlocks a previously locked moniker when given the moniker's segment address. This unlocks the entire block, not just the individual moniker.</P>
<P>
<CODE>
TokenLoadMonikerBlock()</CODE>
<A NAME="Geodes_d.htm_IX_TokenLockMonikerBlock()">
 </A>
, <A NAME="Geodes_d.htm_IX_TokenLoadMonikerChunk()">
 </A>
<CODE>
TokenLoadMonikerChunk()</CODE>
, and <CODE>
TokenLoadMonikerBuffer()</CODE>
<A NAME="Geodes_d.htm_IX_TokenLoadMonikerBuffer()">
 </A>
 load a specific moniker into memory from the token database file (into a newly allocated block, a newly allocated chunk, or a locked buffer). It takes the same parameters as <CODE>
TokenLookupMoniker()</CODE>
 but returns the handle and chunk handle of the loaded moniker. If using this routine, simply lock the memory block rather than using <CODE>
TokenLockTokenMoniker()</CODE>
.</P>
<P>
<CODE>
TokenGetTokenInfo()</CODE>
<A NAME="Geodes_d.htm_IX_TokenGetTokenInfo()">
 </A>
 finds a token when passed its <CODE>
tokenchars</CODE>
 and <CODE>
tokenid</CODE>
 and returns the token's flags. If no token exists with the passed characteristics, it will return an error flag.</P>
<P>
<CODE>
TokenDefineToken()</CODE>
<A NAME="Geodes_d.htm_IX_TokenDefineToken()">
 </A>
 adds a new token and its moniker list to the token database. If the given token already exists, the new one will replace the old one. The token identifier (<CODE>
tokenchars</CODE>
, <CODE>
tokenid</CODE>
), handle and chunk handle of the moniker list, and flags of the new token must be passed.</P>
<P>
<CODE>
TokenRemoveToken()</CODE>
<A NAME="Geodes_d.htm_IX_TokenRemoveToken()">
 </A>
 removes a given token and its moniker list from the token database file. It returns only a flag indicating whether the token was successfully removed or not.</P>
<P>
<CODE>
TokenListTokens()</CODE>
<A NAME="Geodes_d.htm_IX_TokenListTokens()">
 </A>
 returns a list of the tokens in the token database. It is passed three arguments:</P>
<UL>
<LI>
A set of <CODE>
TokenRangeFlags</CODE>
, which specifies which tokens should be returned. The following flags are available:</LI>
</UL>
<DL>
<DT>
TRF_ONLY_GSTRING</DT><DD>
Return only those tokens which are defined with a GString.</DD>
<DT>
TRF_ONLY_PASSED_MANUFID</DT><DD>
Return only those tokens which match the passed manufacturer's ID.</DD>
<UL>
<LI>
A number of bytes to reserve for a header.</LI>
<LI>
A manufacturer ID. This field is ignored if TRF_ONLY_PASSED_MANUFID was not passed.</LI>
</UL>
</DL>
<P>
<CODE>
TokenListTokens()</CODE>
 allocates a global memory block and copies all the specified tokens into that block. It leaves a blank space at the beginning of the block; this space is the size specified by the second argument. The rest of the block is an array of <CODE>
GeodeToken</CODE>
 structures. <CODE>
TokenListTokens()</CODE>
 returns a dword. The lower word of the return value is the handle of the global memory block; the upper word is the number of <CODE>
GeodeToken</CODE>
 structures in that block.</P>
<HR>
<A NAME="Geodes_e.htm"></A>


<H2 CLASS="sectionTitle">
<A HREF="#index.htm">Applications and Geodes</A>: 3 
Saving User Options</H2>
<P>
Almost all users enjoy configuring their systems to their own tastes, whether it's setting the background bitmap or choosing a default font. Most applications will, therefore, want to provide a way for the user to choose and save various options for the application.</P>
<P>
Generic objects have this capability built in. If you set them up for saving options, they will automatically set and maintain the saved options, making sure the options are set properly whenever the application is launched. However, sometimes you will want to set additional options not managed by UI objects. This is not difficult to do in GEOS: You can have your application save its options directly to the local initialization file, GEOS.INI.</P>
<P CLASS="subsectionLink">
<A HREF="#Geodes_f.htm">Saving Generic Object Options</A></P>
<P CLASS="subsectionLink">
<A HREF="#Geodes_10.htm">The GEOS.INI File</A></P>
<HR>
<A NAME="Geodes_f.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Applications and Geodes</A>: 3.1 <A HREF="#Geodes_e.htm">Saving User Options</A>: 
Saving Generic Object Options</H3>
<P>
All appropriate generic UI objects have the ability to save their options. For example, a properties GenInteraction could save which of its options are on and which are off when the user presses a &quot;save options&quot; trigger.</P>
<P>
To save generic object options, you have to do two basic things:</P>
<UL>
<LI>
Create an Options menu<BR>
<A NAME="Geodes_f.htm_IX_GIGT_OPTIONS_MENU">
 </A>
Typically, you will create a menu for user options. This menu should be declared of type GIGT_OPTIONS_MENU as shown in <A HREF="#Geodes_f.htm_86055"> Saving Generic Object Options</A>
.</LI>
<LI>
Use a special GCN list<BR>
<A NAME="Geodes_f.htm_IX_GAGCNLT_STARTUP_LOAD_OPTIONS">
 </A>
All objects that want to save options must be put on a special GCN list in the application's GenApplication object. The list type should be either GAGCNLT_STARTUP_LOAD_OPTIONS (if the options should be loaded at the time of application startup) or <A NAME="Geodes_f.htm_IX_GAGCNLT_SELF_LOAD_OPTIONS">
 </A>
GAGCNLT_SELF_LOAD_OPTIONS (if the options should be loaded when the object deems it necessary, typically when the object is first displayed).</LI>
</UL>
<P>
<A HREF="#Geodes_f.htm_86055"> Saving Generic Object Options</A>
 shows an example of how objects should be declared for saving their options.</P>
<P CLASS="figTitle">
Code Display 7-2 <A NAME="Geodes_f.htm_86055">
 </A>
Saving Generic Object Options</P>
<PRE>/* The GenApplication object must declare a GCN list of the type appropriate for
 * the options being saved (or both types if the application uses both types).
 * This GenApplication declares a list of objects whose options do not have to be
 * loaded at startup. */</PRE>
<PRE>@object GenApplicationClass SampleApp = {
    GI_visMoniker = &quot;Sample Application&quot;;
    GI_comp = SamplePrimary;				/* Primary window object is the only child. */
    gcnList(MANUFACTURER_ID_GEOWORKS, GAGCNLT_WINDOWS) = SamplePrimary;
		/* The above list is to declare windowed objects that must appear
		 * when the application is opened and made usable. */
    gcnList(MANUFACTURER_ID_GEOWORKS, GAGCNLT_SELF_LOAD_OPTIONS) =
					SampleController;
		/* The above list is used for generic objects that save their
		 * options but do not need their options loaded at startup. */
}</PRE>
<PRE>/* Some applications that have generic objects save their own options might not
 * have a special Options menu but may just have a trigger somewhere for saving
 * options. In any case, the &quot;save options&quot; trigger sends MSG_META_SAVE_OPTIONS to
 * its GenApplication object. If you use an Options menu with GIGT_OPTIONS_MENU
 * set, this will automatically be built into the menu.
 * The SampleOptionsMenu is a child of SamplePrimary, not shown. */</PRE>
<PRE>@object GenInteractionClass SampleOptionsMenu = {
    GI_comp = SampleToolbox, SampleToolControl, SampleSaveOptsTrigger;
    GII_visibility = GIV_POPUP;					/* Make it a menu. */
    ATTR_GEN_INTERACTION_GROUP_TYPE = (GIGT_OPTIONS_MENU);
}</PRE>
<PRE>/* The other objects (controllers) are not shown here. Just the &quot;save options&quot;
 * trigger, which sends MSG_META_SAVE_OPTIONS to the GenApplication object. */</PRE>
<PRE>@object GenTriggerClass SampleSaveOptsTrigger = {
    GI_visMoniker = `S', &quot;Save Options&quot;;
    GTI_destination = SampleApp;
    GTI_actionMsg = MSG_META_SAVE_OPTIONS;
}</PRE>
<HR>
<A NAME="Geodes_10.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Applications and Geodes</A>: 3.2 <A HREF="#Geodes_e.htm">Saving User Options</A>: 
<A NAME="Geodes_10.htm_18691">
 </A>
The GEOS.INI File</H3>
<P>
GEOS<A NAME="Geodes_10.htm_IX_GEOS.INI file">
 </A>
<A NAME="Geodes_10.htm_IX_GEOS.INI file">
 </A>
 can use multiple initialization files in network situations, but only the local GEOS.INI is editable. The local GEOS.INI (referred to hereafter simply as GEOS.INI or &quot;the INI file&quot;) is read first into a moveable, swappable buffer, and it contains the path names of any other INI files to be used. The other INI files are subsequently loaded into other buffers. When the kernel searches for a specific entry in one of the INI files, it looks first in the local INI's buffer and then in any others in the order they were loaded. When it reaches what it wants, it stops searching. Thus, multiple entries are allowed but are not used, and the local INI file has precedence over all others.</P>

<H4 CLASS="HeadingC">
Configuration of the INI File</H4>
<P>
The GEOS.INI file has a very specific format and syntax. It is segmented into <EM>
categories</EM>
, each of which contains several <EM>
keys</EM>
 that determine how GEOS will perform. (For an example of an INI file, see <A HREF="#Geodes_10.htm_80559"> Example GEOS.INI File Entries</A>
.) Note that typically the GEOS.INI file should not be accessed directly because its format is subject to change.</P>
<P>
A category is essentially a group of keys. Certain geodes will work with their own categories, and certain categories will be used by several geodes. For example, the <CODE>
system</CODE>
 category is used by the kernel and the UI to determine several of the default system settings. Each category is set in GEOS.INI by putting its name within square brackets. The text within the brackets is case-insensitive and ignores white space, so [My category], [mycategory], and [MY CATEGORY] are all equivalent.
</P>
<P>
A key is any setting that the system or an application can recognize and assign a value to. A single key may exist in several different categories; since both category and key define an entry, the entries will be unique if either key or category is different. Keys may be text strings, integers, or Boolean values, and every key is identified by its name, which is an ASCII string. Data may also be read from and written to the file in binary form; the kernel will automatically convert this into ASCII hexadecimal for storage and will revert it to binary during retrieval.</P>
<P>
Both category names and key fields are called &quot;entries.&quot; Each entry may exist on a single line or may cover several lines. An entry that contains carriage returns is technically known as a &quot;blob.&quot; Each blob will automatically be enclosed in curly braces when it is written into the file. Any blob that contains curly braces will automatically have backslashes inserted before the closing braces so GEOS doesn't mistake them for the blob delimiters.</P>
<P>
Comments may be added to the INI file by putting a semicolon at the beginning of the line. The file has several standard categories and keys that can be set within them. These are detailed in <A HREF="../../Tools/Ini/index.htm">the INI File chapter</A>
.</P>
<P CLASS="figTitle">
Code Display 7-3 <A NAME="Geodes_10.htm_80559">
 </A>
Example GEOS.INI File Entries</P>
<PRE>; The category &quot;system&quot; is used by the kernel and the UI to set certain system
; defaults such as the number of handles, the default system font and size, and
; the types of memory drivers to be loaded.</PRE>
<PRE>[system]</PRE>
<PRE>; The handles key is assigned an integer that determines the number of handle
; spaces allocated for the system's Handle Table.
handles = 2500</PRE>
<PRE>; The font key is assigned a character string that represents a file name
; or a list of file names separated by spaces.
; The listed file(s) will be read in as the font driver geode.
font = nimbus.geo</PRE>
<PRE>; The memory key is assigned a blob of text containing all the names of the memory
; drivers available to the system.
memory = {
disk.geo
emm.geo
xms.geo
}</PRE>
<PRE>; The category &quot;MyApp's Category&quot; is set for example only. It is used by the MyApp
; application.</PRE>
<PRE>[My App's Category]</PRE>
<PRE>; The myappHiScore key is an integer key set by the MyApp application.
myappHiScore = 52</PRE>
<PRE>; The myappBoolean key is a Boolean value. Booleans are case-insensitive, so True,
; true, and TRUE are all equated to &quot;true&quot;. This is actually a Boolean value and
; is translated by the read and write routines that work with Boolean values.
myappBoolean = true</PRE>
<PRE>; The myappHiName is a text string that, in this case, contains carriage returns,
; backslash characters, and curly brace characters. The original text looked like
; this:
;		this is a multi-line
;		blob of text with curly
;		brace ({,}) characters }} in it
; It is automatically given backslashes in front of the closing braces, and it
; is automatically surrounded with curly braces.
myappHiName = {this is a multi-line
blob of text with curly
brace ({,\}) characters \}\} in it}</PRE>


<H4 CLASS="HeadingC">
Managing the INI File</H4>
<PRE>InitFileSave(), InitFileRevert(), InitFileGetTimeLastModified(), InitFileCommit()</PRE>
<P>
Because the INI file is common to all geodes and to all threads in the system, only one thread at a time may access it. This synchronization is handled by the kernel whenever a routine to read from or write to the INI file is used. Additionally, the INI file is loaded into a buffer when the system is first run; all operations on the INI file actually work on this buffer, and the buffer may be flushed to disk only by the kernel.</P>
<P>
There are, however, four routines that work directly on the INI file. One saves the file, another reverts it from the last save, the third checks the time the file was last modified, and the fourth commits any pending INI file changes to disk.</P>
<P>
<A NAME="Geodes_10.htm_IX_InitFileRevert()">
 </A>
<A NAME="Geodes_10.htm_IX_InitFileSave()">
 </A>
To save the local GEOS.INI, use the routine <CODE>
InitFileSave()</CODE>
; this saves the changes to the backup file. It requires no parameters and returns an error flag if the file could not be saved. <CODE>
InitFileRevert()</CODE>
 reverts the GEOS.INI file to its state the last time it was backed up. This routine takes no parameters, and it returns an error flag if the revert can not be accomplished.</P>
<P>
<CODE>
InitFileGetTimeLastModified()</CODE>
<A NAME="Geodes_10.htm_IX_InitFileGetTimeLastModified()">
 </A>
 returns the system counter's value stored the last time GEOS.INI was modified.</P>
<P>
<CODE>
InitFileCommit()</CODE>
<A NAME="Geodes_10.htm_IX_InitFileCommit()">
 </A>
 takes all the changes made since the file was last modified and flushes them to disk. This commits all the changes and should be used only from the kernel. It should not be used by applications.</P>


<H4 CLASS="HeadingC">
Writing Data to the INI File</H4>
<PRE>InitFileWriteData(), InitFileWriteString(), InitFileWriteStringSection(),
InitFileWriteInteger(), InitFileWriteBoolean()</PRE>
<P>
GEOS provides five routines to write to the INI file, one for each of the allowable data types. Each of these routines will first gain exclusive access to the local INI buffer, then locate the appropriate category for writing. After writing the key and its value, the routine will relinquish exclusive access to the buffer, allowing other threads to write into it. Writing a category or key that does not exist in the local INI file will add it to the file. If you use a routine to write keys or categories to the INI file, be sure to first convert the strings to the acceptable ASCII hex format using <CODE>InitFileMakeCanonicKeyCategory()</CODE>.
</P>
<P>
Each of these routines takes at least three arguments: The category is specified as a null-terminated character string; a pointer to the string is passed. The key name is also specified as a null-terminated character string; again, a pointer to the string is passed. The third parameter is specific to the routine and contains the value to which the key will be set.</P>
<P>
<CODE>
InitFileWriteData()</CODE>
<A NAME="Geodes_10.htm_IX_InitFileWriteData()">
 </A>
 writes a number of bytes into the INI buffer, and it takes four parameters. The additional parameter is the size of the data. The data will be converted into ASCII hexadecimal when the file is saved and will be converted back when the key is read.</P>
<P>
<CODE>
InitFileWriteString()</CODE>
<A NAME="Geodes_10.htm_IX_InitFileWriteString()">
 </A>
 takes a pointer to the null-terminated character string to be written. If the character string contains carriage returns or line feeds, it will automatically be converted into a blob.</P>
<P>
<CODE>
InitFileWriteStringSection()</CODE>
<A NAME="Geodes_10.htm_IX_InitFileWriteStringSection()">
 </A>
 writes a new string section (a portion of a blob) into the specified entry. The specified entry must be a blob already, and the string section will be appended to the blob. A string section is a line of a blob delineated by line feeds or carriage returns.</P>
<P>
<CODE>
InitFileWriteInteger()</CODE>
<A NAME="Geodes_10.htm_IX_InitFileWriteInteger()">
 </A>
 takes as its third argument the integer to be written.</P>
<P>
<CODE>
InitFileWriteBoolean()</CODE>
<A NAME="Geodes_10.htm_IX_InitFileWriteBoolean()">
 </A>
 takes a Boolean value. A zero value represents false, and any nonzero value represents true. When looking at the INI file with a text editor, the Boolean value will appear as a text string of either &quot;true&quot; or &quot;false&quot;; it will, however, be interpreted as a Boolean rather than a text string.</P>


<H4 CLASS="HeadingC">
Getting Data from the INI File</H4>
<PRE>InitFileReadDataBuffer(), InitFileReadDataBlock(), InitFileReadStringBuffer(), InitFileReadStringBlock(), InitFileEnumStringSection() InitFileReadStringSectionBuffer(), InitFileReadStringSectionBlock(), InitFileReadInteger(), InitFileReadBoolean()</PRE>
<P>
When you want to check what a key is set to in the INI file, you should use one of the <CODE>
InitFileRead...()</CODE>
 routines. These search the local INI file first and then each of the additional INI files in the order they were loaded. They will return the first occurrence of a given key, so if the key exists in both your local INI file and another INI file, these routines will return only the local value.</P>
<P>
All of these routines take at least two parameters. The first is the category of the entry to be retrieved; this is stored as a null-terminated ASCII string, and a pointer to the string is passed. The second is the key of the entry. This, too, is stored as a null-terminated ASCII string, and a pointer to the string is passed.</P>
<P>
<CODE>
InitFileReadBoolean()</CODE>
<A NAME="Geodes_10.htm_IX_InitFileReadBoolean()">
 </A>
 returns the Boolean value of the given key. If the key is set &quot;false,&quot; a value of zero (FALSE) will be returned. If the key is set &quot;true,&quot; a nonzero value will be returned (-1, the constant TRUE).</P>
<P>
<CODE>
InitFileReadInteger()</CODE>
<A NAME="Geodes_10.htm_IX_InitFileReadInteger()">
 </A>
 returns the integer value of the given key.</P>
<P>
<CODE>
InitFileReadDataBuffer()</CODE>
<A NAME="Geodes_10.htm_IX_InitFileReadDataBuffer()">
 </A>
 and <A NAME="Geodes_10.htm_IX_InitFileReadDataBlock()">
 </A>
<CODE>
InitFileReadDataBlock()</CODE>
 both return the data bytes stored in the given key. The first, however, takes the address of a buffer already allocated and puts the data into the buffer. The second allocates a new block on the heap and puts the data into it. If you don't know the size of the data, you should use <CODE>
InitFileReadDataBlock()</CODE>
.</P>
<P>
<CODE>
InitFileReadStringBuffer()</CODE>
<A NAME="Geodes_10.htm_IX_InitFileReadStringBuffer()">
 </A>
 and<A NAME="Geodes_10.htm_IX_InitFileReadStringBlock()">
 </A>
 <CODE>
InitFileReadStringBlock()</CODE>
 both return the null-terminated string stored in the given key. In both cases, curly braces will be stripped off of blobs and backslash characters will be removed if appropriate. The first, however, takes the address of a buffer already allocated and puts the string in the buffer. The second allocates a new block on the heap and returns the string in it. If you don't know the approximate size of the string, use <CODE>
InitFileReadStringBlock()</CODE>
.</P>
<P>
<CODE>
InitFileReadStringSectionBuffer()</CODE>
<A NAME="Geodes_10.htm_IX_InitFileReadStringSectionBuffer()">
 </A>
 and its counterpart <CODE>
InitFileReadStringSectionBlock()</CODE>
<A NAME="Geodes_10.htm_IX_InitFileReadStringSectionBlock()">
 </A>
 both return a null-terminated section of the string stored in the given key. A string section is defined as any number of contiguous printable ASCII characters and is delimited by carriage returns or line feeds. These routines take the number of the string section desired and return the section (if it exists). <CODE>
InitFileReadStringSectionBuffer()</CODE>
 takes the address of a buffer already allocated on the heap and returns the string section in the buffer. <CODE>
InitFileReadStringSectionBlock()</CODE>
 allocates a new block on the heap and returns the string section in it. You should use this routine if you don't know the approximate size of the string section.</P>
<P>
<CODE>
InitFileEnumStringSection()</CODE>
<A NAME="Geodes_10.htm_IX_InitFileEnumStringSection()">
 </A>
 enumerates the specified blob, executing a specified callback routine on each string section within the blob.</P>


<H4 CLASS="HeadingC">
Deleting Items from the INI File</H4>
<PRE>InitFileDeleteEntry(), InitFileDeleteCategory(), InitFileDeleteStringSection()</PRE>
<P>
<A NAME="Geodes_10.htm_IX_InitFileDeleteEntry()">
 </A>
Besides reading and writing data, you can delete categories and keys that were previously entered. <CODE>
InitFileDeleteEntry()</CODE>
 takes pointers to both the null-terminated category name and the null-terminated key name and deletes the entry. <A NAME="Geodes_10.htm_IX_InitFileDeleteCategory()">
 </A>
<CODE>
InitFileDeleteCategory()</CODE>
 takes only a pointer to the null-terminated category name and deletes the entire category, including all the keys stored under it.</P>
<P>
<A NAME="Geodes_10.htm_IX_InitFileDeleteStringSection()">
 </A>
In addition, you can delete a single string section from a specified blob. <CODE>
InitFileDeleteStringSection()</CODE>
 takes the category and key names of the blob as well as the index of the string section, and it deletes the string section. If the string section does not exist or if either the key or category can not be found, the routine will return an error flag.</P>

<HR>
<A NAME="Geodes_11.htm"></A>


<H2 CLASS="sectionTitle">
<A HREF="#index.htm">Applications and Geodes</A>: 4 
General System Utilities</H2>
<P>
The kernel provides a number of routines that fulfill general needs for system utilities. These range from setting the system's date and time to retrieving the amount of swap memory used to shutting down the system in order to execute a DOS-based program.</P>
<P CLASS="subsectionLink">
<A HREF="#Geodes_12.htm">System Clock</A></P>
<P CLASS="subsectionLink">
<A HREF="#Geodes_13.htm">Using Timers</A></P>
<P CLASS="subsectionLink">
<A HREF="#Geodes_14.htm">System Statistics and Utilities</A></P>
<P CLASS="subsectionLink">
<A HREF="#Geodes_15.htm">Shutting the System Down</A></P>
<HR>
<A NAME="Geodes_12.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Applications and Geodes</A>: 4.1 <A HREF="#Geodes_11.htm">General System Utilities</A>: 
System Clock</H3>
<PRE>TimerGetDateAndTime(), TimerSetDateAndTime(), TimerGetFileDateTime()</PRE>
<P>
The system clock reflects the current date and time of day. <CODE>
TimerGetDateAndTime()</CODE>
<A NAME="Geodes_12.htm_IX_TimerGetDateAndTime()">
 </A>
 takes a pointer to a <CODE>
TimerDateAndTime</CODE>
 structure and fills it with the current year, month, day, day of week, hour, minute, and second. <CODE>
TimerGetFileDateTime()</CODE>
 is a similar function--it gets the current date and time, returning them in structures used when working with files. <A NAME="Geodes_12.htm_IX_TimerSetDateAndTime()">
 </A>
<CODE>
TimerSetDateAndTime()</CODE>
 sets the current date and time to the values in the passed structure. It is unusual for any application other than the Preferences Manager to change the system clock.</P>
<HR>
<A NAME="Geodes_13.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Applications and Geodes</A>: 4.2 <A HREF="#Geodes_11.htm">General System Utilities</A>: 
Using Timers</H3>
<PRE>TimerStart(), TimerStop(), TimerSleep(), TimerGetCount()</PRE>
<P>
<A NAME="Geodes_13.htm_IX_Timers">
 </A>
If your geode needs an action to happen on a timed basis, you will want to use a timer. GEOS lets you set up timers that will call a routine or send a message after a given interval has passed. GEOS offers four types of timers:</P>
<UL>
<LI>
One-shot<BR>
A one-shot timer counts a certain number of &quot;ticks.&quot; (There are 60 ticks in a second.) It will call a routine or send a message after the specified number of ticks have been counted.</LI>
<LI>
Continual<BR>
A continual timer counts a certain number of ticks and then resets and counts again. Each time it reaches the specified number of ticks, it calls a routine or sends a message.</LI>
<LI>
Millisecond<BR>
A millisecond timer is a one-shot timer that counts in milliseconds rather than ticks and calls a routine when time is up (it does not send a message).</LI>
<LI>
Sleep<BR>
A sleep timer causes the thread that creates it to sleep for a certain number of ticks. The sleep timer is unlike the others in that it does not send a message or call a routine when time is up; it only awakens the sleeping thread.</LI>
<LI>
Real-time<BR>
A real-time timer is passed the number of days since 1980, the hour, and the minute of the event. On hardware platforms that support such a thing, GEOS will wake up when the real-time timer goes off. (All other timers are ignored under these conditions.)</LI>
</UL>
<P>
<A NAME="Geodes_13.htm_IX_TimerStart()">
 </A>
All timers except sleep timers are created and started with the routine <CODE>
TimerStart()</CODE>
, and continual timers can be destroyed with<A NAME="Geodes_13.htm_IX_TimerStop()">
 </A>
 <CODE>
TimerStop()</CODE>
. <CODE>
TimerStop()</CODE>
 may also be used to prematurely stop a one-shot timer, though if the one-shot sent a message, the message could be in the recipient's queue even after <CODE>
TimerStop()</CODE>
 was called. <A NAME="Geodes_13.htm_IX_TimerSleep()">
 </A>
Sleep timers are created and started with <CODE>
TimerSleep()</CODE>
, and they do not need to be stopped.</P>
<P>
<A NAME="Geodes_13.htm_IX_TimerGetCount()">
 </A>
An additional routine, <CODE>
TimerGetCount()</CODE>
, returns the current system counter. The system counter contains the number of ticks counted since GEOS was started.</P>
<HR>
<A NAME="Geodes_14.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Applications and Geodes</A>: 4.3 <A HREF="#Geodes_11.htm">General System Utilities</A>: 
System Statistics and Utilities</H3>
<PRE>SysStatistics(), SysGetInfo(), SysGetConfig(), SysGetPenMode(), SysGetDosEnvironment()</PRE>
<P>
Occasionally, a geode will need to query the kernel about the state or configuration of the system. GEOS offers five routines for this:</P>
<P>
<CODE>
SysStatistics()</CODE>
<A NAME="Geodes_14.htm_IX_SysStats">
 </A>
<A NAME="Geodes_14.htm_IX_SysStatistics()">
 </A>
 returns a structure of type <CODE>
SysStats</CODE>
. This structure contains information about how busy the CPU is, how much swap activity is going on, how many context switches occurred in the last second, how many interrupts occurred in the last second, and how many runnable threads exist. You can not set or otherwise alter this structure.</P>
<P>
<CODE>
SysGetInfo()</CODE>
<A NAME="Geodes_14.htm_IX_SysGetInfo()">
 </A>
 returns a particular statistic about the current system status. It can return a number of different statistics including the CPU speed, the total number of handles in the handle table, the total heap size, the total number of geodes running, and the size of the largest free block on the heap. Most of the information your application can request with this routine can be garnered from the Perf performance meter; it is easiest to use Perf when debugging, though a few geodes will need to know this information.</P>
<P>
<CODE>
SysGetConfig()</CODE>
<A NAME="Geodes_14.htm_IX_SysGetConfig()">
 </A>
 returns information about the current system's configuration including the processor type and machine type. It also returns flags about the particular session of GEOS including whether this session was started with Swat, whether a coprocessor exists, and other information.</P>
<P>
<CODE>
SysGetPenMode()</CODE>
<A NAME="Geodes_14.htm_IX_SysGetPenMode()">
 </A>
 returns TRUE if GEOS is currently running on a pen-based machine.</P>
<P>
<CODE>
SysGetDosEnvironment()</CODE>
<A NAME="Geodes_14.htm_IX_SysGetDosEnvironment()">
 </A>
 returns the value of a DOS environment variable. It is passed a string representing the variable name and returns a string representing the value.</P>
<HR>
<A NAME="Geodes_15.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Applications and Geodes</A>: 4.4 <A HREF="#Geodes_11.htm">General System Utilities</A>: 
<A NAME="Geodes_15.htm_59499">
 </A>
Shutting the System Down</H3>
<PRE>DosExec(), SysShutdown()</PRE>
<P>
<A NAME="Geodes_15.htm_IX_DosExec()">
 </A>
There are two ways for a geode to shut down GEOS. The first, <CODE>
DosExec()</CODE>
, shuts the system down to run a program under DOS, returning after the DOS program has finished--unless a task-switch driver is in use, in which case the system will create a new task and cause the task-switcher to switch to the new task.<A NAME="Geodes_15.htm_IX_SysShutdown()">
 </A>
 The second, <CODE>
SysShutdown()</CODE>
, forces the system to shut itself down completely. Neither of these routines is commonly used by anything other than the kernel, GeoManager, special &quot;launcher&quot; programs, or the UI. Their use by other libraries or applications is discouraged unless absolutely necessary.</P>
<P>
<CODE>
DosExec()</CODE>
 takes several parameters including the pathname of the DOS program to be run, arguments for the program, an optional disk handle of the disk that contains the program to be run, the optional directory and disk handle in which the program should be executed, and a record of <CODE>
DosExecFlags</CODE>
. If the return value is nonzero, an error occurred in loading the DOS program, and you can use <CODE>
ThreadGetError()</CODE>
 to check what error occurred. Note that <CODE>
DosExec()</CODE>
 always returns. Applications should <EM>
not</EM>
 rely on <CODE>
DosExec()</CODE>
 shutting the system down; if a task switcher is present, GEOS will be swapped out rather than shut down.</P>
<P>
<CODE>
SysShutdown()</CODE>
 causes GEOS to exit in one of several ways. This routine should be passed a shutdown mode. If the mode is SST_CLEAN, SST_RESTART, SST_SUSPEND, or SST_CLEAN_FORCED, the routine will return; otherwise, it will not return and the shutdown will commence. If SST_CLEAN is passed, the shutdown may be aborted after <CODE>
SysShutdown()</CODE>
 returns. You can have <CODE>
SysShutdown()</CODE>
 cause GEOS to reboot itself after shutting down (as the Preferences Manager application does for certain preferences settings), but this starts GEOS fresh. This routine is very rarely used by anything other than the UI, the kernel, or the Preferences Manager application.</P>
<P>
If something else (typically the UI or task switcher) shuts the system down, objects that register for shutdown notification will receive <CODE>
MSG_META_CONFIRM_SHUTDOWN</CODE>
. The application should call <CODE>
SysShutdown()</CODE>
 with the mode SST_CONFIRM_START; this allows the object to have exclusive rights for asking the user to confirm the shutdown (when the object is finished with the user interaction, it can call <CODE>
SysShutdown()</CODE>
 with SST_CONFIRM_END to release exclusive access). This is useful if your application or library has an ongoing operation and wants to verify the shutdown with the user.</P>
<HR>
<A NAME="Geodes_16.htm"></A>


<H2 CLASS="sectionTitle">
<A HREF="#index.htm">Applications and Geodes</A>: 5 
The Error-Checking Version</H2>
<P>
GEOS<A NAME="Geodes_16.htm_IX_Debugging:with error checking code">
 </A>
<A NAME="Geodes_16.htm_IX_Error checking">
 </A>
 has two versions of its system software. The normal version as shipped retail is the &quot;non-error-checking&quot; version. The other, used for debugging applications and other geodes, is called the &quot;error-checking&quot; version, or <EM>
EC version</EM>
. Nearly all components of the system software exist in both versions--the kernel, the UI, libraries, drivers, etc.</P>
<P>
Together, Swat and the EC version provide extensive and superb debugging power. The EC version allows you to call special error-checking routines to check the integrity of handles, resources, memory, files, and other things. These error-checking routines all begin with EC; for more information, see their entries in the Routine Reference Book. In addition to the full error checking provided by the EC versions of the system geodes, you can add your own error-checking code to your programs. </P>
<P CLASS="subsectionLink">
<A HREF="#Geodes_17.htm">Adding EC Code to Your Program</A></P>
<P CLASS="subsectionLink">
<A HREF="#Geodes_18.htm">Special EC Routines</A></P>
<HR>
<A NAME="Geodes_17.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Applications and Geodes</A>: 5.1 <A HREF="#Geodes_16.htm">The Error-Checking Version</A>: 
Adding EC Code to Your Program</H3>
<P>
When compiling your code, you can include certain extra lines in either the EC version or the non-EC version of your program. For example, during debugging you want your program to check the validity of each memory handle before locking the memory block; for the final version of your program, however, you don't want this validity check because it slows down your program. You can easily add a few instructions that will be compiled only into the EC version.</P>
<P>
GEOS provides five macros, listed below, for version-specific instructions. These macros must be treated as statements; they may not be used in expressions.</P>
<DL>
<DT>
EC<A NAME="Geodes_17.htm_IX_EC() macro">
 </A>
</DT><DD>This macro adds the specified line of code to the EC version only. When the non-EC version is compiled from the same code, the line will be left out.</DD>
<DT>
EC_ERROR<A NAME="Geodes_17.htm_IX_EC_ERROR() macro">
 </A>
</DT><DD>This macro halts the execution of the EC version of a program by calling <CODE>
FatalError()</CODE>
 with a specified error code. The call to <CODE>
FatalError()</CODE>
 will not be included in the non-EC version.</DD>
<DT>
EC_ERROR_IF</DT><DD>
<A NAME="Geodes_17.htm_IX_EC_ERROR_IF() macro">
 </A>
This macro works like EC_ERROR, above, but it also allows you to set a condition for whether <CODE>
FatalError()</CODE>
 will be called. If the condition is met, <CODE>
FatalError()</CODE>
 will be called.</DD>
<DT>
NEC<A NAME="Geodes_17.htm_IX_NEC() macro">
 </A>
</DT><DD>This macro adds the specified line of code to the non-EC version but leaves it out of the EC version. (It is the converse of the EC macro.)</DD>
<DT>
EC_BOUNDS<A NAME="Geodes_17.htm_IX_EC_BOUNDS() macro">
 </A>
</DT><DD><A NAME="Geodes_17.htm_IX_ECCheckBounds()">
 </A>
This macro checks the validity of a specified address (pointer) by calling the <CODE>
ECCheckBounds()</CODE>
 routine. If the pointer is out of bounds, <CODE>
ECCheckBounds()</CODE>
 will call <CODE>
FatalError()</CODE>
. This macro may only add the bounds check to the EC version.</DD>
</DL>
<P>
An example of use of these macros is shown in <A HREF="#Geodes_17.htm_69843"> EC Macros</A>
.</P>
<P CLASS="figTitle">
Code Display 7-4 <A NAME="Geodes_17.htm_69843">
 </A>
EC Macros</P>
<PRE>/* This code display shows only the usage of these macros; assume that each
 * line shown below exists within a particular function or method. */</PRE>
<PRE>/* The EC macro adds a line of code to the EC version. Its format is
 *	EC(line)		where <EM>line</EM> is the line of code to be added.
 * Note that the NEC macro is similar. */
    EC( @call MyErrorDialogBox::MSG_MY_ERR_PRINT_ERROR(); )
    NEC( @call MyErrorDialogBox::MSG_MY_ERR_PRINT_NO_ERROR(); )</PRE>
<PRE>/* The EC_ERROR macro adds a call to FatalError() to the EC version. Its format is
 *	EC_ERROR(code)		where <EM>code</EM> is the error code to be called. */
    EC_ERROR(ERROR_ATTR_NOT_FOUND)</PRE>
<PRE>/* The EC_ERROR_If macro is similar to EC_ERROR but is conditional. Its format is
 *	EC_ERROR_IF(test, code)			where <EM>test</EM> is a Boolean value and <EM>code</EM> is the
 * error code to be called. */
    lockVariable = MyAppCheckIfLocked();					/* TRUE if inaccessible. */
    EC_ERROR_IF(lockVariable, ERROR_ACCESS_DENIED)						/* Error if inaccessible. */</PRE>
<PRE>/* The EC_BOUNDS macro adds a call to ECCheckBounds() to the EC version.
 * Its format is
 *	EC_BOUNDS(addr)		where <EM>addr</EM> is the address to be checked. */
    myPointer = MyAppGetMyPointer();
    EC_BOUNDS(myPointer)</PRE>
<HR>
<A NAME="Geodes_18.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Applications and Geodes</A>: 5.2 <A HREF="#Geodes_16.htm">The Error-Checking Version</A>: 
Special EC Routines</H3>
<PRE>SysGetECLevel(), SysSetECLevel(), SysNotify(), EC...(), CFatalError(), CWarningNotice()</PRE>
<P>
<A NAME="Geodes_18.htm_IX_ErrorCheckingFlags">
 </A>
While using Swat and the EC version, you can set and retrieve the current level of error checking employed. The level is set with a record of flags, each of which determines whether a certain type of checking is turned on. This record is of type <CODE>
ErrorCheckingFlags</CODE>
. <A NAME="Geodes_18.htm_IX_SysGetECLevel()">
 </A>
You can retrieve it with <CODE>
SysGetECLevel() </CODE>
and set it with <A NAME="Geodes_18.htm_IX_SysSetECLevel()">
 </A>
<CODE>
SysSetECLevel()</CODE>
.</P>
<P>
<CODE>
SysNotify()</CODE>
<A NAME="Geodes_18.htm_IX_SysNotify()">
 </A>
 puts up the standard error dialog box--white with a black frame. This routine is available in both the EC and the non-EC versions of the kernel. This is the box used by the kernel to present unrecoverable errors to the user. You can also call it up and allow the user any of five options: retry, abort, continue, reboot, or exit. Usually, this dialog box is used only for errors, but it can be used for other user notification as well. (Note that with the &quot;exit&quot; and &quot;reboot&quot; options, this routine will <EM>
not</EM>
 return. Note also that only certain combinations of the five options are supported.)</P>
<P>
<A NAME="Geodes_18.htm_IX_FatalError()">
 </A>
<A NAME="Geodes_18.htm_IX_CFatalError()">
 </A>
<A NAME="Geodes_18.htm_IX_CWarningNotice()">
 </A>
The <CODE>
CFatalError()</CODE>
 and <CODE>
CWarningNotice()</CODE>
 routines provide run-time and compile-time error or warning messages. The <CODE>
CFatalError()</CODE>
 routine calls the kernel's <CODE>
FatalError()</CODE>
 function, which puts up an error dialog box and, in Swat, causes Swat to hit a breakpoint so you can debug the error. <CODE>
CWarningNotice()</CODE>
 may be put in error-checking code to make the compiler put up a compile-time warning note.</P>
<HR>
<A NAME="Geodes_19.htm"></A>


<H2 CLASS="sectionTitle">
<A HREF="#index.htm">Applications and Geodes</A>: 6 
Inter-Application Communication</H2>
<P>
<A NAME="Geodes_19.htm_IX_Inter-Application Communication (IACP)">
 </A>
<A NAME="Geodes_19.htm_IX_IACP">
 </A>
Applications do not usually need to communicate with each other. Most applications will interact only with the kernel and with libraries; such applications don't even notice if any other applications are running. However, a few applications will need to communicate with other applications.

</P>
<P>
For example, many desktop-managers provide a &quot;print file&quot; command; the user selects a file's icon, then chooses this command to print out the appropriate file. The desktop manager will have no way of knowing how to print the file; after all, the file could have been created by an application which hadn't even been written when the desktop manager was installed. The desktop manager therefore causes the appropriate application to be started. It then instructs the application to print the file.</P>
<P>
Because GEOS is an object-oriented system, there is a natural model for inter-application communication. When one application needs to contact another, it can simply send a message; thus, sending information or instructions to another application is not, in principle, different from sending it from one object to another within an application.</P>
<P>
The GEOS Inter-Application Communications Protocol (IACP) specifies how to open communications with another application, and how to send messages back and forth.</P>
<P CLASS="subsectionLink">
<A HREF="#Geodes_1a.htm">IACP Overview</A></P>
<P CLASS="subsectionLink">
<A HREF="#Geodes_1b.htm">GenApplicationClass Behavior</A></P>
<P CLASS="subsectionLink">
<A HREF="#Geodes_1c.htm">Messages Across an IACP Link</A></P>
<P CLASS="subsectionLink">
<A HREF="#Geodes_1d.htm">Being a Client</A></P>
<P CLASS="subsectionLink">
<A HREF="#Geodes_1e.htm">Being a Server</A></P>
<HR>
<A NAME="Geodes_1a.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Applications and Geodes</A>: 6.1 <A HREF="#Geodes_19.htm">Inter-Application Communication</A>: 
IACP Overview</H3>
<P>
There is a major difference between sending a message within an application, and sending one to a different application. When you send a message from one object to another within an application, you know that the recipient exists, and you know the optr of that recipient. This makes it easy to send messages.</P>
<P>
When you send a message to another application, however, you do not (at first) know any optrs to that application. In fact, you may not even know that the application is running. Often, all you will know is something like, &quot;I want to send a message to <CODE>
SpiffyWrite</CODE>
&quot;.</P>
<P>
GEOS uses a client-server model of inter-application communication. Every <CODE>
GeodeToken</CODE>
 corresponds to a server. Whenever an application is launched, GEOS checks to see if there is a <EM>
server-list</EM>
 corresponding to the application's token. If there is, GEOS adds the app's Application object to the server-list; if there is not, GEOS creates a server-list and adds the Application object to that list.

</P>
<P>
For example, suppose the user launches a single copy of <CODE>
SpiffyWrite</CODE>
; this application has a manufacturer-ID of MANUFACTURER_ID_SPIFFYWARE, and the token characters &quot;SWRI&quot;. GEOS will check if there's a server-list for that <CODE>
GeodeToken</CODE>
. Let us suppose there isn't such a list; GEOS will automatically create one, and add <CODE>
SpiffyWrite</CODE>
's Application object to that list. The Application object is now said to be a <EM>
server</EM>
 for the list.</P>
<P>
Now let us suppose another application needs to contact <CODE>
SpiffyWrite</CODE>
; for example, perhaps a desktop program needs to print a <STRONG CLASS="fileName">
SpiffyWrite</STRONG>
 file. It tells the kernel that it would like to be a <EM>
client</EM>
 on the list for the token &quot;{MANUFACTURER_ID_SPIFFYWARE, &quot;SWRI&quot;}&quot;. GEOS will check to see if a server-list for that token exists. If so, it will add the client to that list; this will cause a notification message (MSG_META_IACP_NEW_CONNECTION) to be sent to every server for that list.</P>
<P>
Once a client is linked to a server, it can send a message to the server list. It does this by encapsulating a message, then passing the encapsulated message to the server-list. GEOS will dispatch the message to every server for the list; the server objects will receive it just like any ordinary message. (It actually passes the encapsulated message to the server object as an argument to <CODE>
MSG_META_IACP_PROCESS_MESSAGE</CODE>
; the server can then dispatch the message to the final recipient.)</P>
<P>
This establishes the link between the applications. The client can pass an optr to the servers by putting it in the encapsulated message; a server object can then send messages straight to a particular object.</P>
<P>
When a client no longer needs to communicate with a server, it unregisters itself from the server list. GEOS then sends a notification message to every server object.</P>
<P>
Customarily, whoever allocates a global resource must also free it. For example, if a client might pass information to the server by allocating a global block, writing the data to the block, and passing the block to the server. The server should notify the client when the server is finished with that data; the client can then free the block. Similarly, if a server allocates a block to pass information to a client, the server should free the block.</P>
<P>
There may be several servers for a given server list. For example, if three copies of <CODE>
SpiffyWrite</CODE>
 were running at once, each of their Application objects would be a server for the same server-list. Furthermore, any object can make itself a server for any list. All servers will receive copies of every message sent to the server list. To distinguish between different servers for a list, every server for a list is assigned a distinct <CODE>
ServerNumber</CODE>
. If it chooses to, a client can specify that a message be sent only to the server with a specific number.</P>
<HR>
<A NAME="Geodes_1b.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Applications and Geodes</A>: 6.2 <A HREF="#Geodes_19.htm">Inter-Application Communication</A>: 
GenApplicationClass Behavior</H3>
<P>
<CODE>
GenApplicationClass</CODE>
 is built to support IACP automatically. If a server or client object is subclassed from <CODE>
GenApplicationClass</CODE>
, most of the work of supporting IACP is done transparently to the application writer. The following capabilities are built in:</P>
<UL>
<LI>
The Application Object automatically registers itself as a server for the appropriate list when it is launched in application mode. If it is launched in engine mode, it registers itself when it receives MSG_META_APP_STARTUP. If the last client-connection to the application is closed, and the Application is not currently running in application mode, the Application object will shut down automatically.</LI>
<LI>
When the Application object registers itself as a server for its own list, it sends itself MSG_GEN_APPLICATION_IACP_REGISTER. An application may subclass this if it wants to take other action at this time (e.g. registering itself for other lists). Similarly, when an Application object unregisters itself from its own server list, it sends itself MSG_GEN_APPLICATION_IACP_UNREGISTER.</LI>
<LI>
The Application object automatically handles the MSG_META_IACP... messages appropriately. In particular, when the kernel passes an encapsulated message to an Application object with <CODE>
MSG_META_IACP_PROCESS_MESSAGE</CODE>
, the Application object automatically dispatches the message to the appropriate location.</LI>
<LI>
An Application object will refuse to quit as long as any client has an open IACP connection to it. (It can, however, be forcibly detached; this happens when the system is shut down, as noted below.). In such a case, the Application object will automatically call <CODE>
IACPShutdownAll()</CODE>
 to shut down all IACP links it has open, whether it is a client or a server on those links.</LI>
<LI>
When a link is closed, IACP automatically sends MSG_META_IACP_LOST_CONNECTION to all objects on the other side of the link. When an Application object receives this message, it waits until all remaining messages from the link have been handled; it then calls <CODE>
IACPShutdown()</CODE>
 for that connection. It also forwards this message to all Document objects, so a Document object will know to close itself if the IACP connection was the only reference to it. Again, the Application object does this whether it is a client or a server.</LI>
<LI>
If the Application object is forcibly detached, it sends itself MSG_GEN_APPLICATION_IACP_SHUTDOWN_ALL_CONNECTIONS. The default handler for this message will call <CODE>
IACPShutdownAll()</CODE>
 to shut down all IACP links the Application object has open, whether it is a client or a server on those links. You can subclass this message if you need to take some additional action when the IACP connections are severed.</LI>
</UL>
<HR>
<A NAME="Geodes_1c.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Applications and Geodes</A>: 6.3 <A HREF="#Geodes_19.htm">Inter-Application Communication</A>: 
Messages Across an IACP Link</H3>
<PRE>IACPSendMessage(), IACPSendMessageToServer()</PRE>
<P>
Either a client or a server may send messages over an IACP link. Both clients and servers use the same technique. The message sender encapsulates a message, and passes the encapsulated message to <CODE>
IACPSendMessage()</CODE>
. <CODE>
IACPSendMessage()</CODE>
 dispatches the message to every object on the other side of the link. For example, if a client passes a message to <CODE>
IACPSendMessage()</CODE>
, that message will be dispatched to every server object for the specified list.</P>
<P>
<CODE>
IACPSendMessage()</CODE>
 is passed five arguments:</P>
<UL>
<LI>
The token for the IACP link.</LI>
<LI>
The <CODE>
EventHandle</CODE>
 of an encapsulated message.</LI>
<LI>
The <CODE>
TravelOption</CODE>
 for that message.</LI>
<LI>
An encapsulated completion message; this will be dispatched once each time the first message has been successfully handled.</LI>
<LI>
A member of the <CODE>
IACPSide</CODE>
 enumerated type. This tells whether the message is being sent by a client or a server. If you pass the value IACPS_CLIENT, the message will be dispatched to all servers; if you pass IACPS_SERVER, the message will be dispatched to all clients.</LI>
</UL>
<P>
The message will be dispatched to all geodes on the other side of a link. Note that a client need not send the message to the server object per se. It can use the travel options field to direct the message anywhere within the server object's geode. It can also specify the optr of the recipient when it encapsulates the message; in this case, it should pass a <CODE>
TravelOption</CODE>
 of -1.</P>
<P>
Every time the encapsulated message is successfully handled, the &quot;completion message&quot; will be dispatched. Typically, the completion message is addressed to the object that called <CODE>
IACPSendMessage()</CODE>
, instructing it to free global resources that had been allocated for the message.</P>
<P>
The routine returns the number of messages that were dispatched. This lets the sender know how many completion messages to expect, and lets it properly initialize all reference counts to global resources.</P>
<P>
A client may choose to send a message to a specific server. It can do this by calling <CODE>
IACPSendMessageToServer()</CODE>
. This takes almost the same arguments as <CODE>
IACPSendMessage()</CODE>
. However, instead of being passed an <CODE>
IACPSide</CODE>
 value, it is passed a server number. GEOS will dispatch a single copy of the message to the specified server. <CODE>
IACPSendMessageToServer()</CODE>
 returns the number of times the message was dispatched. This will ordinarily be one; however, if the specified server is no longer registered, it will be zero.</P>
<HR>
<A NAME="Geodes_1d.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Applications and Geodes</A>: 6.4 <A HREF="#Geodes_19.htm">Inter-Application Communication</A>: 
Being a Client</H3>
<P>
Any object can register as a client for an IACP server list. When an object is a client, it can send messages to the server list, which will pass them along to the servers for that list.</P>

<H4 CLASS="HeadingC">
Registering as a Client</H4>
<PRE>IACPConnect(), IACPCreateDefaultLaunchBlock()</PRE>
<P>
<A NAME="Geodes_1d.htm_IX_IACPConnect()">
 </A>
To register as a client for a list, call the routine <CODE>
IACPConnect()</CODE>
. When you call this routine, you specify which server list you are interested in. If there is no such server list running, you can instruct the kernel to start up the server list, as well as one of the default applications for that list.</P>
<P>
<CODE>
IACPConnect()</CODE>
 is passed five arguments:</P>
<UL>
<LI>
The <CODE>
GeodeToken</CODE>
 of the list for which you want to register.</LI>
<LI>
<A NAME="Geodes_1d.htm_IX_IACPConnectFlags">
 </A>
<A NAME="Geodes_1d.htm_IX_IACPF_&ldots;">
 </A>
A set of <CODE>
IACPConnectFlags</CODE>
. The following flags are available:</LI>
</UL>
<DL>
<DT>
IACPCF_OBEY_LAUNCH_MODEL</DT><DD>
This indicates that GEOS should follow the launch model, which will specify whether the user should be presented a dialog box, asking the user whether an existing application should be used as the server, or a new application launched. If you set this flag, you must pass an <CODE>
AppLaunchBlock</CODE>
, with the ALB<CODE>
_appMode</CODE>
 field set to MSG_GEN_PROCESS_OPEN_APPLICATION; you must also set IACPCF_SERVER_MODE to IACPSM_USER_INTERACTIBLE.</DD>
<DT>
IACPCF_CLIENT_OD_SPECIFIED</DT><DD>
This flag indicates that you will specify what object will be the new client. If you do not set this flag, the sending geode's Application object will be registered as the client.</DD>
<DT>
IACPCF_FIRST_ONLY</DT><DD>
If you pass this flag, the client will be connected to only the first server on the server list. Any messages sent by the client to the server list will be passed only to that one server.</DD>
<DT>
IACPCF_SERVER_MODE</DT><DD>
<A NAME="Geodes_1d.htm_IX_IACPServerMode">
 </A>
<A NAME="Geodes_1d.htm_IX_IACPSM_&ldots;">
 </A>
This field is three bits wide; it holds a member of the <CODE>
IACPServerMode</CODE>
 enumerated type. This type specifies how the client expects the server to behave. Currently, only two types are supported:</DD>
<DT>
IACPSM_NOT_USER_INTERACTIBLE</DT><DD>
This is equal to zero. It indicates that the server object need not interact with the user.</DD>
<DT>
IACPSM_USER_INTERACTIBLE</DT><DD>
This is equal to two. It indicates that the server should be able to interact with the user like any normal application.</DD>
<UL>
<LI>
The <CODE>
MemHandle</CODE>
 of an <CODE>
AppLaunchBlock</CODE>
. If the server you specify is not running, GEOS will launch the application specified by the <CODE>
AppLaunchBlock</CODE>
. If you pass a null <CODE>
MemHandle</CODE>
, GEOS will return an error if no server is running.</LI>
<LI>
The optr of the client object. This is ignored if IACPCF_CLIENT_OD_SPECIFIED was not passed.</LI>
<LI>
A pointer to a word. <CODE>
IACPConnect()</CODE>
 will write the number of servers on the list to that word.</LI>
</UL>
</DL>
<P>
<CODE>
IACPConnect()</CODE>
 returns a word-sized <CODE>
IACPConnection</CODE>
 token. You will need to pass that token when you call another IACP routine to use the connection. It will also return the number of server objects on the list; it returns this value by writing it to the address indicated by the pointer passed.</P>
<P>
If the server list you indicate is not currently running, IACP may do one of two different things. If you pass a null handle as the third argument, <CODE>
IACPConnect()</CODE>
 will fail. It will return the error value IACP_NO_CONNECTION, and indicate that there are no servers on the specified list.</P>
<P>
If you pass an <CODE>
AppLaunchBlock</CODE>
, <CODE>
IACPConnect()</CODE>
 will examine that launch block to see what application should be launched to act as a server. The <CODE>
AppLaunchBlock</CODE>
 should specify the location and name of the application to open. If the ALB<CODE>
_appRef.AIR_diskHandle</CODE>
 field is non-zero, <CODE>
IACPConnect()</CODE>
 will look in the specified disk or standard path for an application with the right <CODE>
GeodeToken</CODE>
; otherwise, it will look in the standard places for an application.</P>
<P>
Note that if you pass a launch block to <CODE>
IACPConnect()</CODE>
, you may <EM>
not</EM>
 alter or free it afterwards. If the application is created, the block you pass will be its launch block; if not, the kernel will free the block automatically. In any event, the caller no longer has access to the block.</P>
<P>
If <CODE>
IACPConnect()</CODE>
 launches an application, the caller will block until that application has been created and registers for the server list. If the application does not register for that list, the caller will never unblock. You must therefore make sure that you are launching the right application for the list. Note that every application object will automatically register for the server list which shares its token.</P>
<P>
<A NAME="Geodes_1d.htm_IX_IACPCreateDefaultLaunchBlock()">
 </A>
To create a launch block, you should call <CODE>
IACPCreateDefaultLaunchBlock()</CODE>
. This routine is passed a single argument, which specifies how the application will be opened. That argument must be MSG_GEN_PROCESS_OPEN_APPLICATION (the application will be opened as a standard, user-interactible application); MSG_GEN_PROCESS_OPEN_ENGINE (the application will be opened in engine mode, i.e. with no user interface); or MSG_GEN_PROCESS_OPEN_CUSTOM (which has an application-specified meaning).</P>
<P>
<CODE>
IACPCreateDefaultLaunchBlock()</CODE>
 allocates a launch block and sets up its fields appropriately. As created, the launch block will have the following characteristics:</P>
<UL>
<LI>
The application's initial working directory (i.e. the launch block's ALB<CODE>
_diskHandle</CODE>
 field) will be SP_DOCUMENT.</LI>
<LI>
No application directory will be specified in the launch block (i.e. ALB<CODE>
_appRef.</CODE>
AIR<CODE>
_diskHandle</CODE>
 will be zero); <CODE>
IACPConnect()</CODE>
 will attempt to find the application on its own.</LI>
<LI>
No initial data file will be specified (i.e. ALB<CODE>
_dataFile</CODE>
 will be blank).</LI>
<LI>
The application will determine its own generic parent (i.e. ALB<CODE>
_genParent</CODE>
 will be null).</LI>
<LI>
No extra data word will be passed to the application (i.e. ALB<CODE>
_extraData</CODE>
 will be zero).</LI>
<LI>
There will be no output descriptor (i.e. ALB<CODE>
_userLoadAckOutput</CODE>
 and<CODE>
 </CODE>
ALB<CODE>
_userLoadAckMessage</CODE>
 will be null.)</LI>
</UL>
<P>
<CODE>
IACPCreateDefaultLaunchBlock()</CODE>
 returns the handle of the newly-created launch block. Once the block is created, you can alter any of its fields before passing the launch block to <CODE>
IACPConnect()</CODE>
. (Once you pass the launch block to <CODE>
IACPConnect()</CODE>
, you may not alter it any more.)</P>
<P>
Often a client will want the server to open a specific document. For example, if a desktop-manager is implementing a &quot;print-file&quot; command, it will need to open a server application, instruct it to open the file to be printed, and then instruct it to print the file. To make the server open a document, pass the document's name in ALB<CODE>
_dataFile</CODE>
. The server will open the file when you register, and close it when you unregister.</P>


<H4 CLASS="HeadingC">
Unregistering as a Client</H4>
<PRE>IACPShutdown(), IACPShutdownAll()</PRE>
<P>
<A NAME="Geodes_1d.htm_IX_IACPShutdown()">
 </A>
If an application no longer needs to interact with a particular server list, it should call <CODE>
IACPShutdown()</CODE>
. This routine is also used by servers which wish to remove themselves from a server list. This section describes how the routine is used by clients; <A HREF="#Geodes_1e.htm_52457"> Being a Server</A>
 describes how it is used by servers.</P>
<P>
The routine is passed two arguments:</P>
<UL>
<LI>
The <CODE>
IACPConnection</CODE>
 token for the link which is being shut down.</LI>
<LI>
An optr. This must be null if the routine is being called by a client.</LI>
</UL>
<P>
<CODE>
IACPShutdown()</CODE>
 sends MSG_META_IACP_LOST_CONNECTION to all objects on the other side of the link; that is, if a client calls <CODE>
IACPShutdown()</CODE>
, all servers on the list will be sent this message.</P>
<P>
<CODE>
IACPShutdownAll()</CODE>
<A NAME="Geodes_1d.htm_IX_IACPShutdownAll()">
 </A>
 closes all IACP links for the application which calls it. The Application object automatically calls this routine when the application is exiting.</P>

<HR>
<A NAME="Geodes_1e.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Applications and Geodes</A>: 6.5 <A HREF="#Geodes_19.htm">Inter-Application Communication</A>: 
<A NAME="Geodes_1e.htm_52457">
 </A>
Being a Server</H3>
<P>
Every time an application is launched, its Application object automatically registers as a server for the server list that shares its <CODE>
GeodeToken</CODE>
. The Application class has default handlers for all the notification messages IACP sends to the server objects.</P>
<P>
If you wish, you can have another object act as a server. However, if you do this, you will have to do more of the work yourself. While the notification messages are defined for <CODE>
MetaClass</CODE>
, and thus can be handled by any class of object, <CODE>
MetaClass</CODE>
 does not come with handlers for these messages; if the server is not subclassed from <CODE>
GenApplicationClass</CODE>
, you will have to write the handlers yourself. This is discussed below.</P>

<H4 CLASS="HeadingC">
Registering and Unregistering a Server</H4>
<PRE>IACPRegisterServer(), IACPUnregisterServer(), IACPGetServerNumber()</PRE>
<P>
You will not generally need to register and unregister a server object explicitly. As noted above, when an application is launched, the application object is automatically registered as a server for the list with its <CODE>
GeodeToken</CODE>
; when the application exits, the Application object is automatically unregistered from that list.</P>
<P>
However, you may wish to explicitly register an object as a server. For example, you might want your application object to be a server on a list with a different <CODE>
GeodeToken</CODE>
; or you might want to register a non-Application object as a server. In this case, you will need to explicitly register and unregister the object.</P>
<P>
<A NAME="Geodes_1e.htm_IX_IACPRegisterServer()">
 </A>
To register an object as a server, call <CODE>
IACPRegisterServer()</CODE>
. This routine is passed the following arguments:</P>
<UL>
<LI>
The <CODE>
GeodeToken</CODE>
 of the list for which you are registering as a server.</LI>
<LI>
The optr of the object which is registering as a server. This object must be able to handle the MSG_META_IACP... messages appropriately (this is built into <CODE>
GenApplicationClass</CODE>
).</LI>
<LI>
<A NAME="Geodes_1e.htm_IX_IACPSM_&ldots; :with IACPRegisterServer()">
 </A>
A member of the <CODE>
IACPServerMode</CODE>
 enumerated type. This type specifies how the client expects the server to behave. Currently, only two types are supported:</LI>
</UL>
<DL>
<DT>
    IACPSM_NOT_USER_INTERACTIBLE</DT><DD>
This is equal to zero. It indicates that the server object will not interact directly with users.</DD>
<DT>
    IACPSM_USER_INTERACTIBLE</DT><DD>
This is equal to two. It indicates that the server will be able to interact with the user like any normal application.</DD>
<UL>
<LI>
<A NAME="Geodes_1e.htm_IX_IACPServerFlags:with IACPRegisterServer()">
 </A>
A set of <CODE>
IACPServerFlags</CODE>
. Currently, only two flags are supported: IACPSF_MULTIPLE_INSTANCES indicates that multiple copies of the application might be running at once (Every multi-launchable application should set this flag.); IACPSF_MAILBOX_DONT_ASK_USER asks the Mailbox library not to notify the user of new messages for this application.</LI>
</UL>
</DL>
<P>
<CODE>
IACPRegisterServer()</CODE>
 registers the object as a server for the appropriate list; it creates the server list if necessary.</P>
<P>
<A NAME="Geodes_1e.htm_IX_IACPUnregisterServer()">
 </A>
To unregister an object as a server, call <CODE>
IACPUnregisterServer()</CODE>
. This routine is passed two arguments: the <CODE>
GeodeToken</CODE>
 of the server list, and the optr of the server. The object will be removed immediately from the server list. Note, however, that the server list might have already dispatched some messages to the server being removed; these messages might be waiting on the server object's queue, and thus the server object might get some IACP messages even after it calls <CODE>
IACPUnregisterServer()</CODE>
. One way to deal with this is to have the server object send itself a message, via the queue, immediately after it calls <CODE>
IACPUnregisterServer()</CODE>
. When the object receives this message, it will know that it has no more IACP messages on its queue.</P>
<P>
<A NAME="Geodes_1e.htm_IX_IACPGetServerNumber()">
 </A>
Every server object on a given server list has a unique <EM>
server number</EM>
. This server number will not change while the server is attached to the list. A server object can find out its server number by calling <CODE>
IACPGetServerNumber()</CODE>
. This routine takes two arguments: the <CODE>
IACPConnection </CODE>
and the optr to the server object. It returns the object's server number.</P>


<H4 CLASS="HeadingC">
Non-Application Servers and Clients</H4>
<PRE>MSG_META_IACP_PROCESS_MESSAGE, IACPProcessMessage(), MSG_META_IACP_NEW_CONNECTION, MSG_META_IACP_LOST_CONNECTION</PRE>
<P>
Every server and client object must be able to handle certain messages. <CODE>
GenApplicationClass</CODE>
 comes with handlers for these messages, so you need not write them yourself. However, if you will be using some other kind of object as the server, you must handle the messages yourself. You may also choose to have your application object subclass any of these messages; in that case, you should generally have your handler use <CODE>
@callsuper</CODE>
.</P>
<P>
When a server or client sends an IACP message, the kernel passes the encapsulated message to each object on the other side of the link. It does this by sending the message MSG_META_IACP_PROCESS_MESSAGE to each object. This message comes with three arguments:</P>
<DL>
<DT>
<CODE>
msgToSend</CODE>
 </DT><DD>The <CODE>
EventHandle</CODE>
 of the encapsulated message.</DD>
<DT>
<CODE>
topt</CODE>
</DT><DD>The <CODE>
TravelOption</CODE>
 for that message.</DD>
<DT>
<CODE>
completionMsg</DT><DD>
</CODE>
The<CODE>
 EventHandle</CODE>
 of any message to be sent after <CODE>
msgToSend</CODE>
 has been dispatched. (This field may be set to zero, indicating that there is no completion message.)</DD>
</DL>
<P>
The recipient of MSG_META_IACP_PROCESS_MESSAGE should call <CODE>
IACPProcessMessage()</CODE>
. This routine is passed four arguments: the optr of the object calling the routine, and the three arguments passed with MSG_META_IACP_PROCESS_MESSAGE. <CODE>
IACPProcessMessage()</CODE>
 dispatches both encapsulated messages properly.</P>
<P>
Remember, if the client or server is subclassed from <CODE>
GenApplicationClass</CODE>
, all of this is done for you. You need only write a handler for the message if the client or server object is not from a subclass of <CODE>
GenApplicationClass</CODE>
.</P>
<P>
Whenever a client registers on an IACP list, the kernel sends MSG_META_IACP_NEW_CONNECTION to all servers on that list. This message comes with three arguments:</P>
<DL>
<DT>
<CODE>
appLaunchBlock</DT><DD>
</CODE>
This is the handle of the <CODE>
AppLaunchBlock</CODE>
 which the server passed to <CODE>
IACPConnect()</CODE>
.</DD>
<DT>
<CODE>
justLaunched</DT><DD>
</CODE>
This is a Boolean value. If the server's application has just been launched specifically to be a server, this will be <EM>
true</EM>
 (i.e. non-zero).</DD>
<DT>
<CODE>
IACPConnection</DT><DD>
</CODE>
This is the token for the IACP connection.</DD>
</DL>
<P>
When an object (either client or server) removes itself from an IACP connection, the kernel sends MSG_META_IACP_LOST_CONNECTION to all objects on the other side of the link. This message has two parameters: </P>
<DL>
<DT>
<CODE>
connection</CODE>
</DT><DD>The token for the IACP list.</DD>
<DT>
<CODE>
serverNum</CODE>
</DT><DD>If a server removed itself from the list (and this message is being sent to clients), this field will have the number of the server that removed itself. If a client removed itself from the list, this field will be zero.</DD>
</DL>
<P>
Whenever a new client is attached to a server list, MSG_META_IACP_NEW_CONNECTION is sent to every server object. This message comes with three arguments:</P>
<DL>
<DT>
<CODE>
appLaunchBlock</DT><DD>
</CODE>
This is the handle of the application's launch block. The default <CODE>
GenApplicationClass</CODE>
 handler examines the launch block to see if the application should open a document.</DD>
<DT>
<CODE>
justLaunched</DT><DD>
</CODE>
If the application was just launched specifically to be a server, this field will be <CODE>
true</CODE>
 (i.e. non-zero).</DD>
<DT>
<CODE>
connection</CODE>
</DT><DD>This is the token for the IACP connection.</DD>
</DL>
<P>
When a client is removed from a server list, every server object is sent <CODE>
MSG_META_IACP_LOST_CONNECTION</CODE>
. Similarly, when a server is removed, every client object is sent <CODE>
MSG_META_IACP_LOST_CONNECTION</CODE>
. The message comes with two arguments:</P>
<DL>
<DT>
<CODE>
IACPConnection</DT><DD>
</CODE>
This is the token for the IACP connection.</DD>
<DT>
<CODE>
serverNum</CODE>
</DT><DD>If a server left the list (and the message is being sent to clients), this argument will hold its <CODE>
serverNum</CODE>
. If a client left the list (and the message is being sent to servers), this argument will be set to zero.</DD>

</DL>
<HR>
This document is a single-page version of a <A HREF="index.htm">a multi-page document</A>, suitable for easy printing.
</BODY>
</HTML>
