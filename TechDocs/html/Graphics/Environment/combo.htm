<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD>
<!-- This page was automatically generated from a bunch of smaller pages. -->
<META NAME="copyright" CONTENT="Copyright GEOWORKS">
<LINK REL="STYLESHEET" HREF="../../docHelpers/style.css">
<LINK REV="MADE" HREF="mailto:doc-feedback@geoworks.com">
<TITLE>Graphics Environment</TITLE>
</HEAD>
<BODY BGCOLOR="#ffffdf">
This document is a single-page version of a <A HREF="index.htm">a multi-page document</A>, suitable for easy printing.
<A NAME="index.htm"></A>



<H1 CLASS="chapterTitle">

<A NAME="index.htm_74707">
 </A>
Graphics Environment

</H1>
<P>
<A NAME="index.htm_IX_Graphics">
 </A>
<A NAME="index.htm_39736">
 </A>
The GEOS graphics system provides many powerful tools to enhance your geode's appearance and graphical capabilities.</P>
<P>
The kernel automatically displays much of what appears on the screen. Generic and Visual objects display themselves, so if these objects can display everything your geode needs, you can probably skip this section for now. On the other hand, geodes with any kind of specialized display needs will need imaging code, as will any geodes that print.</P>
<P>
This, the first chapter of the Imaging Section, explains the thinking behind the graphics system and the work you'll have to get done ahead of time to set up the space you're going to be drawing to. For actual drawing commands, see <A HREF="../../Graphics/Shapes/combo.htm">the Drawing Shapes chapter</A>.</P><P>
Before reading this chapter, you should be familiar with the basics of the generic UI and messaging. You may also want to review high school geometry.

</P>
<P CLASS="sectionlinks">
<STRONG>
&nbsp;&nbsp;<A HREF="#Environment_1.htm">1 Graphics Road Map</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Environment_2.htm">1.1 Chapter Structure</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Environment_3.htm">1.2 Vocabulary</A><BR>
&nbsp;&nbsp;<A HREF="#Environment_4.htm">2 Graphics Goals</A><BR>
&nbsp;&nbsp;<A HREF="#Environment_5.htm">3 Graphics Architecture</A><BR>
&nbsp;&nbsp;<A HREF="#Environment_6.htm">4 How To Use Graphics</A><BR>
&nbsp;&nbsp;<A HREF="#Environment_7.htm">5 Coordinate Space</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Environment_8.htm">5.1 Standard Coordinate Space</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Environment_9.htm">5.2 Coordinate Transformations</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Environment_a.htm">5.3 Precise Coordinates</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Environment_b.htm">5.4 Device Coordinates</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Environment_c.htm">5.5 Larger Document Spaces</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Environment_d.htm">5.6 Current Position</A><BR>
&nbsp;&nbsp;<A HREF="#Environment_e.htm">6 Graphics State</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Environment_f.htm">6.1 GState Contents</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Environment_10.htm">6.2 Working with GStates</A><BR>
&nbsp;&nbsp;<A HREF="#Environment_11.htm">7 Working With Bitmaps</A><BR>
&nbsp;&nbsp;<A HREF="#Environment_12.htm">8 Graphics Strings</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Environment_13.htm">8.1 Storage and Loading</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Environment_14.htm">8.2 Special Drawing Commands</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Environment_15.htm">8.3 Declaring a GString Statically</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Environment_16.htm">8.4 Creating GStrings Dynamically</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Environment_17.htm">8.5 Drawing and Scanning</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Environment_18.htm">8.6 Editing GStrings Dynamically</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Environment_19.htm">8.7 Parsing GStrings</A><BR>
&nbsp;&nbsp;<A HREF="#Environment_1a.htm">9 Graphics Paths</A><BR>
&nbsp;&nbsp;<A HREF="#Environment_1b.htm">10 Working With Video Drivers</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Environment_1c.htm">10.1 Kernel Routines</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Environment_1d.htm">10.2 Direct Calls to the Driver</A><BR>
&nbsp;&nbsp;<A HREF="#Environment_1e.htm">11 Windowing and Clipping</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Environment_1f.htm">11.1 Palettes</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Environment_20.htm">11.2 Clipping</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Environment_21.htm">11.3 Signalling Updates</A><BR>
</STRONG>
</P> <!-- end of sectionlinks blob -->

<HR>
<A NAME="Environment_1.htm"></A>


<H2 CLASS="sectionTitle">
<A HREF="#index.htm">Graphics Environment</A>: 1 
<A NAME="Environment_1.htm_77474">
 </A>
Graphics Road Map</H2>
<P>
Graphics is a big topic. It has many applications and thus many ways to apply it. If you will be writing graphics-intensive programs, you'll probably end up reading everything in these chapters. Chances are, however, that you'll only need to learn a few things about the graphics system.</P>
<P>
This section is for those people who would like to skip around the GEOS imaging system. It contains an outline of the chapter as well as a list of definitions for terms that will be used throughout.</P>
<P CLASS="subsectionLink">
<A HREF="#Environment_2.htm">Chapter Structure</A></P>
<P CLASS="subsectionLink">
<A HREF="#Environment_3.htm">Vocabulary</A></P>
<HR>
<A NAME="Environment_2.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Graphics Environment</A>: 1.1 <A HREF="#Environment_1.htm">Graphics Road Map</A>: 
Chapter Structure</H3>
<P>
This chapter is divided into sections. Which sections you'll want to read depend on what you're interested in.</P>
<DL>
<DT>
<STRONG>
1 Road Map</STRONG>
	</DT><DD>
You're reading the road map now.</DD>
<DT>
<STRONG>
2 Goals</DT><DD></STRONG>
This section goes into the design philosophy behind the GEOS graphics system.</DD>
<DT>
<STRONG>
3 Architecture</DT><DD>
</STRONG>
The Graphics Architecture section describes the basics behind how the graphics system works.</DD>
<DT>
<STRONG>
4 How to Use Graphics</DT><DD>
</STRONG>
This section is for programmers new to GEOS who know what sort of graphics they want their geode to have but don't know how to get it. This section discusses the different contexts in which graphics appear and how you can work within each of those contexts. After going through the section, you may wish to return to this road map to find out where to read more about whatever sort of graphics you'll be working with.</DD>
<DT>
<STRONG>
5 Coordinate Space</DT><DD>
</STRONG>
The GEOS graphics system describes locations and distances using a rectangular grid coordinate system. This section explains how to work with and manipulate this space.</DD>
<DT>
<STRONG>
6 Graphics State</DT><DD>
</STRONG>
This section describes the GState, a data structure used in many contexts and for many purposes throughout the graphics system.</DD>
<DT>
<STRONG>
7 Bitmaps</DT><DD></STRONG>
It is possible to specify an image by using a data structure in which an array of color values is used to represent a rectangular area of the screen. This section describes how such a data structure can be manipulated.</DD>
<DT>
<STRONG>
8 Graphics Strings and Metafiles</DT><DD>
</STRONG>
This section describes how to create and draw Graphics Strings, also known as GStrings. (See the Vocabulary section, below, for a simple definition of GString.)</DD>
<DT>
<STRONG>
9 Graphics Paths</DT><DD>
</STRONG>
The graphics system allows you to specify an arbitrary area of the display which can be used in powerful graphics operations. This section explains how to set up a path, a data structure describing the outline of the area you want to specify.</DD>
<DT>
<STRONG>
10 Video Drivers</DT><DD>
</STRONG>
Most programmers can safely skip this section, but video game writers might want to read it. This section includes some advanced techniques for getting faster drawing rates.</DD>
<DT>
<STRONG>
11 Windowing and Clipping</DT><DD>
</STRONG>
This section explains some of the work the graphics system does to maintain windows in a Graphical User Interface. Included is an in-depth look at clipping, along with some commands by which you can change the way clipping works.</DD>
</DL>
<HR>
<A NAME="Environment_3.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Graphics Environment</A>: 1.2 <A HREF="#Environment_1.htm">Graphics Road Map</A>: 
Vocabulary</H3>
<P>
Several terms will crop up again and again in your dealings with graphics. Many of these terms will be familiar to programmers experienced with other graphics systems, but those not familiar with any of these terms are encouraged to find out what they mean.</P>
<DL>
<DT>
<STRONG>
GState, Graphics State</DT><DD>
</STRONG>
The graphics system maintains data structures called Graphics States, or GStates for short. GStates keep track of how a geode wants to draw things: the colors to use, current text font, scaling information, and so on. Most graphics routines, including all routines that actually draw anything, take a GState as one of their arguments. Thus to draw the outline of a red rectangle, you would first call the <CODE>
GrSetLineColor()</CODE>
 routine to change the color used for drawing lines and outlines to red. Only after thus changing the GState would you call the <CODE>
GrDrawRect()</CODE>
 command.</DD>
<DT>
<STRONG>
Standard Coordinate Space, Document Coordinate Space</DT><DD>
</STRONG>
Drawing commands in GEOS use the standard coordinate space, also known as the document coordinate space. This is a rectangular grid used for expressing locations and distances. This grid uses units of 1/72nd of an inch. Thus, drawing a point to (72, 72) will draw the point one inch to the right and one inch below the top left corner of an ordinary Content or document.</DD>
<DT>
<STRONG>
GString, Graphics String, Metafile</DT><DD>
</STRONG>
GString is short for Graphics String. A GString is a data structure representing a sequence of graphics commands. Graphics Strings are used many places in the system. GStrings are used to pass graphics through the clipboard. They serve as the descriptors of graphical monikers, which are in turn used as application icons. The printing system uses GStrings to describe images to be printed. <A NAME="Environment_3.htm_IX_Metafile:graphics">
 </A>
A graphics Metafile is just a file containing a GString, taking advantage of this data structure to store a graphics image to disk.</DD>
<DT>
<STRONG>
Bitmap</DT><DD></STRONG>
A bitmap is a picture defined as a rectangular array of color values. Note that since display devices normally have their display area defined as a rectangular grid for which each pixel can have a different color value, it is relatively easy to draw a bitmap to the screen, and in fact the graphics system normally works by constructing a bitmap of what is to be displayed and displaying it. Bitmaps are sometimes known as &quot;raster images.&quot;</DD>
<DT>
<STRONG>
Path</DT><DD></STRONG>
Paths provide a precise way to specify arbitrary areas of the display area. Like GStrings, they are described by a sequence of drawing commands. Instead of defining a picture, these commands describe a route across the graphics space. The enclosed area can be used in a variety of operations.</DD>
<DT>
<STRONG>
Region</DT><DD></STRONG>
Regions provide another approach to describing arbitrary display areas. Regions use a compressed scan-line data structure to represent a pixel-based shape on the display. Though lacking the mathematical precision of paths, region-based operations are very fast and thus ideally suited to certain simple tasks.</DD>
<DT>
<STRONG>
Palette, RGB Values</DT><DD>
</STRONG>
Many display devices can display a wide variety of colors. Of these, most cannot display all their colors at once. Typical configurations can show 16 or 256 colors at a time out of a possible 256K. A palette is one of these subsets of the set of possible colors. When drawing something in color, normally the color to draw with is specified by the palette index, that color's place in the table.<BR>
The value stored in each entry is an RGB value, a color described in terms of its red, green, and blue components. Each of these three values ranges between 0 and 255. Geodes can change the RGB values associated with palette entries and thus change the available colors.</DD>
<DT>
<STRONG>
Video Driver</DT><DD>
</STRONG>
These geodes stand between the graphics system and the actual display device. They maintain device independence and do a lot of the &quot;behind the scenes&quot; work of the graphics system.</DD>
<DT>
<STRONG>
Windowing, clipping, &quot;marked invalid&quot;</DT><DD>
</STRONG>
The windowing and graphics systems are heavily intertwined. The graphics system controls how windows should be drawn, while the windows system keeps track of which parts of various displays are visible. For the most part graphics programmers don't have to worry too much about the windowing system, but there are some terms worth knowing.<EM>
 Clipping</EM>
<A NAME="Environment_3.htm_IX_Clipping">
 </A>
 is the process of keeping track of what things drawn to a window are actually visible. If a geode draws something beyond the edge of a window, the system can't just ignore the drawing, as the user might later reveal the drawing by scrolling onto that area. The graphics system &quot;clips&quot; the graphic, being sure to show only those parts that are in the visible part of a window. Further clipping takes place when a window is obscured behind another window. Any drawing on the lower window must not show up until the upper window is moved. The &quot;clipping region&quot; is that area of a window which is visible--anything drawn to the window outside the region will be clipped (see the figure below). Programs can reduce the clipping areas of any of their associated windows.<BR>
The windowing system is able to work much more quickly by assuming that not too many things are going to be changing at once. Normally it can assume that a given area of the screen will look like it did a short while ago. When it's time to change an area of the screen, that area is said to be &quot;marked invalid,&quot; since whatever is presently being shown there is no longer valid. The normal example is that if a pull-down menu has been obscuring part of a document, when the menu goes away, the part of the document that becomes visible must be redrawn.
<IMG SRC="Environment_3_clipping.gif">

</DD>
<DT>
<CODE>
MSG_VIS_DRAW, MSG_META_EXPOSED</DT><DD>
</CODE>
These messages are sent to visible objects to instruct them to redraw themselves; if you are using graphics to display a visible object then you are probably intercepting MSG_VIS_DRAW. MSG_META_EXPOSED lets an object know that it has been marked invalid; either it has to be drawn for the first time, or part or all of it has been exposed (hence the name). The UI controller sends this message to the top object in the Vis hierarchy. MSG_VIS_DRAW, on the other hand, specifically instructs an object to redraw itself. Generally, a Vis object will respond to MSG_META_EXPOSED by sending MSG_VIS_DRAW to itself; it responds to MSG_VIS_DRAW by issuing the appropriate drawing commands, then sending MSG_VIS_DRAW to each of its children. </DD>
<DT>
<STRONG>
Graphic Objects</DT><DD>
</STRONG>
Graphic Objects provide the user with an interface for working with graphics in a manner similar to GeoDraw's. They are useful for programs which allow the users to construct some sort of graphical document or provide a sort of graphical overlay for a spreadsheet.</DD>
</DL>
<HR>
<A NAME="Environment_4.htm"></A>


<H2 CLASS="sectionTitle">
<A HREF="#index.htm">Graphics Environment</A>: 2 
<A NAME="Environment_4.htm_86244">
 </A>
Graphics Goals</H2>
<P>
The graphics system is in charge of displaying everything in GEOS. Thus, it is vital that the GEOS graphics system be both powerful and easy to use. Features such as outline font support and WYSIWYG printing, usually afterthoughts on other operating systems, have been incorporated into the GEOS kernel. The graphics system was designed to be state of the art and thus had to achieve several goals:</P>
<UL>
<LI>
Fast Operation<BR>
The GEOS graphics system is heavily optimized for common operations on low-end PCs. To allow a windowing system to run on an 8088 machine, it is vital that line drawing, clipping, and other common graphical operations run very quickly. They do.</LI>
<LI>
Device Independence<BR>
Applications are sheltered from the hardware. Coordinate system units are device independent so that all of your drawing commands use real-world measurements. These units are then translated into device coordinates by the kernel.</LI>
<LI>
Complete Set of Drawing Primitives<BR>
The graphics system must be able to draw a wide variety of shapes and objects to meet the needs of the UI and applications. It does.</LI>
<LI>
Built In Support for Outline Fonts<BR>
GEOS includes outline font technology supporting a variety of font formats. Outline fonts are text typefaces which are defined by their outline shape rather than by a bitmap representation. Outline fonts can be scaled with no apparent loss of smoothness. GEOS also supports bitmap-based fonts; however the very nature of these fonts makes them non-WYSIWYG.</LI>
<LI>
Single Imaging Model for Screen and Hardcopy<BR>
The graphics system uses the same high level graphics language for screen imaging as for printing. Because the GEOS system creates both screen and printed images through the same language, the screen can display a document just as it will be printed. Except for differences in resolution, what you see is what you get.</LI>
</UL>
<HR>
<A NAME="Environment_5.htm"></A>


<H2 CLASS="sectionTitle">
<A HREF="#index.htm">Graphics Environment</A>: 3 
<A NAME="Environment_5.htm_54740">
 </A>
Graphics Architecture</H2>
<P>
The graphics system involves many pieces of GEOS working together to turn an application's UI and graphics commands into drawings on a display.</P>
<P>
The graphics portion of the kernel automatically makes any requested transformations to the coordinate space dealing with scaling, rotation, etc. It transforms complicated drawing commands into simpler ones supported by the video drivers. 
<IMG SRC="Environment_5_architecture.gif">

</P>
<P>
The video driver can render these simplified commands directly on the device. The video driver checks for collisions, making sure that if whatever is being drawn coincides with the mouse pointer, the mouse pointer will be drawn on top. The video driver does clipping so a geode doesn't draw outside its window. </P>
<P>
Commands and information flow in this manner from application to the Video Device, though information also flows in the opposite direction, so that the kernel can get information about the display device's resolution, size, and capabilities.</P>
<P>
If the geode is going to draw text, the graphics system makes calls to the font manager. If the requested font isn't already in memory, the font manager loads it. The font manager then makes calls to the individual font driver for information about specific characters.</P>
<HR>
<A NAME="Environment_6.htm"></A>


<H2 CLASS="sectionTitle">
<A HREF="#index.htm">Graphics Environment</A>: 4 
<A NAME="Environment_6.htm_18088">
 </A>
How To Use Graphics</H2>
<P>
When looking at the source code of sample applications, it's usually not too hard to pick out the commands that do the actual drawing. Commands with names like <CODE>
GrDraw...()</CODE>
 generally are self-explanatory. It's not so easy to pick out the commands that set up an area in which the drawing will take place. Part of the problem is that there are many ways to display graphics; each is well suited for different tasks. This section of the chapter provides some practical knowledge about the various ways to display graphics and which situations are appropriate for each.</P>
<P>
When possible, the best way to learn how to perform a graphics action is to look at code which performs a similar action. The sample program presented in <A HREF="../../Intro/HelloWorld/combo.htm">the Hello World chapter</A> shows a simple graphics environment sufficient for many geodes. If you only need to change what is being displayed (as opposed to how it is displayed), you can work straight from the example, drawing different shapes using commands found in <A HREF="../../Graphics/Shapes/combo.htm">the Drawing Shapes chapter</A>. Most basic graphics techniques are used in one sample program or another. By combining and adapting code from the sample programs, you can take care of most simple graphics needs.</P><P>
If you can't find a sample geode to work from, there are several points to consider when deciding what sort of graphics environment to set up.</P>
<UL>
<LI>
Sometimes the only graphics commands in a geode will be those used to define that geode's program icon. This is a common enough case that instructions for setting up your geode's icon are in the program topics section, <A HREF="../../Kernel/Geodes/Geodes_b.htm#46120"></A>
.</LI>
<LI>
Will existing generic UI gadgetry be sufficient for everything you want to display? If you're writing a utility, it might be. If you're writing an arcade game, it probably won't be.</LI>
<LI>
If your geode will be displaying graphics, will the user ever interact directly with the graphics? A graphing program might draw a graph based on data the user types in. Such a program could draw the graph but might not actually allow the user to interact with the graph. On the other hand, an art program will probably expect the user to interact with the graphics directly.</LI>
</UL>
<P>
Once you've figured out just what your geode's graphical needs are, you're ready to find out which pieces of graphics machinery are right for you.</P>
<P>
For custom graphics that will appear in a view, the content object of the GenView must be prepared to issue graphics commands. A common tactic is to create a subclass of <CODE>
VisContentClass</CODE>
 and let an object of this subclass act as the content for a view. The subclass would very likely have a specialized <CODE>
MSG_VIS_DRAW</CODE>
. The Process object is another popular choice for the view's output descriptor. In this case, the process must be prepared to intercept any messages the view is likely to send, with <CODE>
MSG_META_EXPOSED</CODE>
 and <CODE>
MSG_VIS_DRAW</CODE>
 of the most interest. Whichever object, process or content, is the content of a view can respond to <CODE>
MSG_META_EXPOSED</CODE>
 or <CODE>
MSG_VIS_DRAW</CODE>
 by calling kernel graphics routines. For more information on how to use these objects, see <A HREF="../../UI/GenView/combo.htm">the Views chapter</A>.</P><P>
As you learn more advanced graphics concepts you may discover shortcuts. As you get deeper into graphics, you should keep a cardinal rule in mind. Any time the graphics space is obscured and then exposed, the geode must be able to draw correctly, no matter what changes have been made. If your geode only draws on a <CODE>
MSG_VIS_DRAW</CODE>
, it will automatically follow this rule. However, applications using shortcuts must take <CODE>
MSG_VIS_DRAW</CODE>
 into account; it may be sent at any time, and what it draws may wipe out what was there before. An arcade game that moves a spaceship by blitting a bitmap may be fast; however, be sure that the spaceship will be drawn to the right place if the game's window is obscured and then exposed. Don't worry if this sounds confusing now, but keep these words in mind as you read on.</P>
<HR>
<A NAME="Environment_7.htm"></A>


<H2 CLASS="sectionTitle">
<A HREF="#index.htm">Graphics Environment</A>: 5 
<A NAME="Environment_7.htm_50188">
 </A>
Coordinate Space</H2>
<P>
<A NAME="Environment_7.htm_IX_Coordinates">
 </A>
The graphics system uses a rectangular coordinate grid to specify the size and position at which drawing commands will be carried out. This is a logical choice as most display devices use a rectangular grid of pixels. &quot;Smart&quot; devices with built in graphics routines tend to use coordinate grids to set place, size, and sometimes movement. &quot;Dumb&quot; devices, capable only of displaying bitmaps, always have these bitmaps described in terms of pixels on a square grid. The GEOS graphics system expects the geode to use the provided device-independent grid to describe graphics commands. The graphics system will then convert this information to device coordinates: coordinates set up for the specific display device, using a grid of pixels. 
<IMG SRC="Environment_7_spaces.gif">

</P>
<P CLASS="subsectionLink">
<A HREF="#Environment_8.htm">Standard Coordinate Space</A></P>
<P CLASS="subsectionLink">
<A HREF="#Environment_9.htm">Coordinate Transformations</A></P>
<P CLASS="subsectionLink">
<A HREF="#Environment_a.htm">Precise Coordinates</A></P>
<P CLASS="subsectionLink">
<A HREF="#Environment_b.htm">Device Coordinates</A></P>
<P CLASS="subsectionLink">
<A HREF="#Environment_c.htm">Larger Document Spaces</A></P>
<P CLASS="subsectionLink">
<A HREF="#Environment_d.htm">Current Position</A></P>
<HR>
<A NAME="Environment_8.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Graphics Environment</A>: 5.1 <A HREF="#Environment_7.htm">Coordinate Space</A>: 
Standard Coordinate Space</H3>
<P>
The standard coordinate space is what the application uses to describe where things are to be drawn. It is device independent, based on real world units: typographer's points, about 1/72nd of an inch. The origin of the coordinate system is normally the upper left corner of the document, but this can change with context and with changes made by the kernel or even your geode. The coordinate space normally extends from -16384 to 16383 horizontally and vertically. These constants may be referenced as MIN_COORD and MAX_COORD. Note that if you're going to be printing your document, you should restrict yourself to coordinates between -4096 to +4096 to account for scaling to draw on high resolution printers. It is possible to define a 32-bit coordinate space, which gives more room but costs speed and memory. For details about 32-bit spaces, see <A HREF="#Environment_c.htm_38614"> Larger Document Spaces</A>
.</P>
<P>
Whenever you draw something, you must specify the coordinates where that thing will be drawn. The coordinates you pass specify where in the coordinate plane that thing will be drawn; the plane, in turn, may be translated, scaled, and/or rotated from the standard window coordinate system (see <A HREF="#Environment_9.htm_27206"> Coordinate Transformations</A>
).</P>
<P>
The system also maintains a device coordinate system, with a device pixel defined as the unit of the grid. This is the type of coordinate system most programmers are used to, but it is certainly not device independent. The graphics system will do all the worrying about device coordinates so your program doesn't have to. (Note, however, that <CODE>
GrDrawImage()</CODE>
, <CODE>
GrDrawHugeImage()</CODE>
, and <CODE>
GrBrushPolyline()</CODE>
 are more device-dependant than most routines; see <A HREF="../../Graphics/Shapes/Shapes_c.htm#60826">the Drawing Shapes chapter, bitmap section</A> and <A HREF="../../Graphics/Shapes/Shapes_a.htm#94543">polyline section</A> for information on these routines).</P><P>
Standard GEOS coordinates depart from the device model, taking an approach closer to a pure mathematical Cartesian plane. Programmers used to working with device-based coordinates are especially encouraged to read <A HREF="#Environment_b.htm_75207"> Device Coordinates</A>
 to learn about some of the differences. </P>
<HR>
<A NAME="Environment_9.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Graphics Environment</A>: 5.2 <A HREF="#Environment_7.htm">Coordinate Space</A>: 
<A NAME="Environment_9.htm_27206">
 </A>
Coordinate Transformations</H3>
<P>
GEOS provides routines which &quot;transform&quot; the coordinate space. These commands can shift, magnify, or rotate the coordinate grid, or perform several of these changes at once. These transformations affect structures in the GState, and new transformations can be combined with or replace a GState's current transformation.</P>
<P>
These transformations apply to the coordinate space, not to individual objects. As a result, if you apply a 200% scaling factor to a drawing not centered on the origin, not only will its size change, but its position will change as well. If you want these operations to affect an object but not its position, you should translate the coordinates so that the origin is at the desired center of scaling or rotation, apply the scaling or rotation, draw the object at the translated origin, then change the coordinates back. 
<IMG SRC="Environment_9_operations.gif">

</P>
<P>
Since they are stored in the GState, these transformations endure--they do not go away after you've drawn your next object. If you apply a 90 degree rotation, you will continue drawing rotated to 90 degrees until you either rotate to some other angle or use another Graphics State. Transformations are also cumulative. If you rotate your space 30�, then translate it up an inch, the result will be a rotated, translated coordinate space. If you want to nullify your last transformation, apply the opposite transformation.</P>
<P>
When applying a new transformation to a space which has already been transformed, the old transformations will affect the new one. Be careful, therefore, of the order of your transformations when combining a translation with any other kind of transformation. If you make your transformations in the wrong order, you may not get what you expected.
<IMG SRC="Environment_9_centeredRotate.gif">

</P>

<H4 CLASS="HeadingC">
Simple Transformations</H4>
<PRE>GrApplyRotation(), GrApplyScale(), GrApplyTranslation(), GrSetDefaultTransform(), GrSetNullTransform(), GrInitDefaultTransform(), GrSaveTransform(), GrRestoreTransform()</PRE>
<P>
If you find yourself using transformations at all, they will probably all be rotations, scalings, and translations. The GEOS graphics system includes commands to apply these kinds of transformations to your coordinate system, taking the form <CODE>
GrApplyTransformation()</CODE>
. These commands work with a transformation data structure associated with the Graphics State, so everything drawn in that Graphics State will be suitably transformed. 

</P>
<P>
<CODE>
GrApplyRotation()</CODE>
<A NAME="Environment_9.htm_IX_GrApplyRotation()">
 </A>
 rotates the coordinate space, turning it counterclockwise around the origin. All objects drawn after the rotation will appear as if someone had turned their drawing surface to a new angle. With a 90� rotation, a shape centered at 
(1,&nbsp;1)  would draw as if centered at (1,&nbsp;-1). 
Anything drawn centered at the origin would not change position but would be drawn with the new orientation. </P>
<P>
<CODE>
GrApplyScale()</CODE>
<A NAME="Environment_9.htm_IX_GrApplyScale()">
 </A>
 resizes the coordinate space; this is useful for zooming in and out. After applying a scale to double the size of everything in the x and y directions, everything will be drawn twice as big, centered twice as far away from the origin. Applying a negative scale causes objects to be drawn with the scale suggested by the magnitude of the scaling factor but &quot;flipped over&quot; to the other side of the coordinate axes.</P>
<P>
<CODE>
GrApplyTranslation()</CODE>
<A NAME="Environment_9.htm_IX_GrApplyTranslation()">
 </A>
 causes the coordinate system to be shifted over. After a translation, everything will be drawn at a new position, with no change in orientation or size. </P>
<P>
To undo the effects of a transformation, you can apply the opposite transformation: rotate the other way, translate in the opposite direction, or scale with the inverse factor. </P>
<P>
<A NAME="Environment_9.htm_IX_GrSetDefaultTransform()">
 </A>
To undo the effects of all prior transformations, return to the default transformation matrix using the <CODE>
GrSetDefaultTransform()</CODE>
 command.<A NAME="Environment_9.htm_IX_GrSetNullTransform()">
 </A>
 The routine <CODE>
GrSetNullTransform()</CODE>
 sets the Graphics State transformation to the null transform--nullifying not only your transformations, but any the system may have imposed as well. For the most part, you should avoid using the <CODE>
GrSetNullTransform()</CODE>
 command and use the <CODE>
GrSetDefaultTransform()</CODE>
 instead. <A NAME="Environment_9.htm_IX_GrInitDefaultTransform()">
 </A>
You can change the default transformation matrix using <CODE>
GrInitDefaultTransform()</CODE>
, but this is generally a bad idea since the windowing system works with the default transformation, and if a geode begins making capricious changes, this can produce strange images. </P>
<P>
There are &quot;push&quot; and &quot;pop&quot; operations for transformations. To keep a record of the GState's current transformation, call <CODE>
GrSaveTransform()</CODE>
. To restore the saved transformation, call <CODE>
GrRestoreTransform()</CODE>
.</P>


<H4 CLASS="HeadingC">
Complicated Transformations</H4>
<PRE>GrApplyTransform(), GrSetTransform(), GrGetTransform(), GrTransformByMatrix(), GrUntransformByMatrix()</PRE>
<P>
You may want to make some change to the coordinate system that has no simple correspondence to scaling, rotation, or translation. Perhaps you know some linear algebra and want to use your knowledge to combine several transformation functions into a single transformation (thus improving execution speed). All transformations on the coordinate system are expressed in the form of transformation matrices. A GEOS graphics system transformation consists of a matrix containing 6 variables and 3 constants (see figure, below). The six variables allow for standard coordinate transformations. The constants (0, 0, and 1 respectively) allow these transformation matrices to be composed. For example, multiplying a scaling matrix with a rotation matrix creates a matrix which represents a combined scaling and rotation. The six variable matrix elements are stored in a <CODE>
TransMatrix</CODE>
<A NAME="Environment_9.htm_IX_TransMatrix">
 </A>
 structure.
<IMG SRC="Environment_9_matrixStandard.gif">


<IMG SRC="Environment_9_matrixPoint.gif">

</P>
<P>
The GEOS system uses one matrix to store the Graphics State transformation and one to store the Window transformation. When told to apply a new transformation, the graphics system constructs a matrix to represent the requested transformation change and multiplies this matrix by the old transformation matrix. To combine these matrices, GEOS multiplies them together to get the cross-product 
<IMG SRC="Environment_9_matrixCombo.gif">

</P>
<P>
If you know that there's a particular combination of transformations you're going to be using a lot, you can do some math in advance to compute your own transformation matrix, then apply the raw matrix as a transformation using <CODE>
GrApplyTransform()</CODE>
<A NAME="Environment_9.htm_IX_GrApplyTransform()">
 </A>
. <A NAME="Environment_9.htm_IX_GrSetTransform()">
 </A>
To replace the GState's current transformation matrix with the matrix of your choice, use <CODE>
GrSetTransform()</CODE>
. To find out the current transformation, call <A NAME="Environment_9.htm_IX_GrGetTransform()">
 </A>
<CODE>
GrGetTransform()</CODE>
. </P>
<P>
You could combine these steps to pre-compute a transformation that combined a translation and a scaling:</P>
<OL>
<LI>
Call <CODE>
GrApplyTranslation()</CODE>
 to apply a translation to the GState's coordinate space.</LI>
<LI FIXME_NumListOther>
Call <CODE>
GrApplyScale()</CODE>
 to apply the scale factor to the GState's coordinate space. The space is now both translated and scaled.</LI>
<LI FIXME_NumListOther>
Call <CODE>
GrGetTransform()</CODE>
 to get the current GState transformation (stored in a <CODE>
TransMatrix</CODE>
 structure).</LI>
<LI FIXME_NumListOther>
To apply this transformation to another GState, use the <CODE>
GrApplyTransform()</CODE>
 command.</LI>
</OL>
<P>
<CODE>
GrTransformByMatrix()</CODE>
<A NAME="Environment_9.htm_IX_GrTransformByMatrix()">
 </A>
 returns the results of transforming a passed coordinate pair using an arbitrary transformation matrix. <CODE>
GrUntransformByMatrix()</CODE>
<A NAME="Environment_9.htm_IX_GrUntransformByMatrix()">
 </A>
 performs the reverse operation, returning the coordinates which would have transformed to the passed coordinates.</P>
<P>
Sometimes you have to be careful about the order in which these transformations are supposed to occur. When multiplying transformation matrices together, the transformation that is applied later is the first in the multiplication pair. You can combine any number of rotations and scalings together without having to worry about order: the resulting matrices will be the same. When combining a translation with any other kind of operation, it makes a difference what order you make the transformations and thus makes a difference based on what order you multiply the matrices. 
<IMG SRC="Environment_9_ordered.gif">

</P>

<HR>
<A NAME="Environment_a.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Graphics Environment</A>: 5.3 <A HREF="#Environment_7.htm">Coordinate Space</A>: 
Precise Coordinates</H3>
<P>
As has been previously stated, coordinates are normally given in typographer's points. Most graphics commands accept coordinates accurate to the nearest point. This should be more than sufficient for most geodes, but for those specialized programs, more precise drawing is possible.</P>
<P>
For simple cases, it is possible to create precise drawings by scaling the drawings. To make drawings accurate to one fourth of a point, for example, scale by 25% and multiply all coordinates accordingly. However, this approach is limited and may result in confusing code.</P>
<P>
Another way to make precise drawings is to use the graphics commands which have been specially set up to take more precise coordinates. These commands will not be described in detail here, but keep them in mind when planning ultra-high resolution applications. <CODE>
GrRelMoveTo()</CODE>
, <CODE>
GrDrawRelLineTo()</CODE>
, <CODE>
GrDrawRelCurveTo()</CODE>
, and <CODE>
GrDrawRelArc3PointTo()</CODE>
 take <CODE>
WWFixed</CODE>
 coordinates, and are thus accurate to a fraction of a point. To draw a precise outline, use these commands to draw the components of the outline. To fill an area, use the precise drawing commands to describe the path forming the outline of the area, then fill the path.</P>
<HR>
<A NAME="Environment_b.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Graphics Environment</A>: 5.4 <A HREF="#Environment_7.htm">Coordinate Space</A>: 
<A NAME="Environment_b.htm_75207">
 </A>
Device Coordinates</H3>
<P>
Most programmers can work quite well within the document space regardless of how coordinates will correspond to device coordinates. However, some programmers might need to know about the device coordinates as well. The system provides clever algorithms for going from document to device space for all programmers, as well as routines to get device coordinate information from the device driver.</P>

<H4 CLASS="HeadingC">
What the System Draws on the Device</H4>
<P>
Consider a device whose pixels are exactly 1/72nd of an inch, such that no scaling is required to map document units to device units. The relationship of the coordinate systems is illustrated below. Note that a pixel falls between each pair of document units. This is a further demonstration of the concept that document coordinates specify a location in the document coordinate space, not a pixel.
<IMG SRC="Environment_b_72dpiDevice.gif">

</P>
<P>
 Next consider a device that has a resolution of 108 dpi, which is 1.5 times greater than our default 72 dpi. That is, there are 1.5x1.5 pixels on the device for each square document unit. The basic problem here is that the coordinates that are specified in document space map to non-integer pixels in device space. The graphics system would like the pixels to be half-filled along two edges of the rectangle (see the figure below). Unfortunately, a pixel must be either filled or empty, so the system needs a set of rules to follow in this situation. These rules are</P>
<UL>
<LI>
If the midpoint of a pixel (i.e., the device coordinate of that pixel) falls inside the area's boundary, that pixel is filled. </LI>
<LI>
Conversely, if the midpoint of a pixel falls outside the area's border, the pixel is not filled.</LI>
<LI>
If the midpoint of the pixel falls exactly on the border of the area to be filled, the following rule is used: <BR>
Pixels on the left or the top are not filled; <BR>
Pixels on the right or the bottom are filled; <BR>
Pixels in the left-bottom and top-right corners are not filled.</LI>
</UL>
<P>
These rules might seem a little odd: Why not just fill all the pixels that would be touched by the area? One of the problems with this approach is that areas that did not overlap in the document space would overlap on the device. Or more specifically, they would overlap only on some devices (depending on the resolution), which is even worse. The rules have the property that adjoining areas in document space will not overlap in any device space. 
<IMG SRC="Environment_b_XdpiDevice.gif">

</P>
<P>
Our next set of potential problems comes with lines. Lines can be very thin and thus might be invisible on some low-resolution devices. If the graphics system used the rules for filled objects then some thin lines would be only partially drawn on low resolution devices. GEOS uses Bresenham's algorithm for drawing straight thin lines, ensuring that a continuous group of pixels will be turned on for a line (see the figure below). This continuity is insured due to the behavior of the algorithm:</P>
<UL>
<LI>
If the line is more horizontal then vertical, exactly one pixel will be turned on in each column between the two endpoints.</LI>
<LI>
If the line is more vertical than horizontal, exactly one pixel will be turned on in each row.</LI>
<LI>
If the line is exactly 45 degrees, exactly one pixel will be turned on in each column and row.</LI>
</UL>
<P>
Since ellipses and B�zier curves are drawn as polylines, Bresenham's algorithm will work with them.
<IMG SRC="Environment_b_bresenham.gif">

</P>


<H4 CLASS="HeadingC">
<A NAME="Environment_b.htm_50069">
 </A>
Converting Between Doc and Device Coordinates</H4>
<PRE>GrTransform(), GrUntransform(), GrTransformWWFixed(), GrUntransformWWFixed()</PRE>
<P>
Given a coordinate pair, at times it's convenient to know the corresponding device coordinates. Sometimes the reverse is true. Use these functions to convert a coordinate pair to device coordinates or vice versa. <CODE>
GrTransform()</CODE>
<A NAME="Environment_b.htm_IX_GrTransform()">
 </A>
 takes a coordinate pair and returns device coordinates. <A NAME="Environment_b.htm_IX_GrUntransform()">
 </A>
<CODE>
GrUntransform()</CODE>
 does the reverse. If you want to be able to get a more exact value for these coordinates you can use <CODE>
GrTransformWWFixed()</CODE>
<A NAME="Environment_b.htm_IX_GrTransformWWFixed()">
 </A>
 and<A NAME="Environment_b.htm_IX_GrUntransformWWFixed()">
 </A>
 <CODE>
GrUntransformWWFixed()</CODE>
. These return fixed point values so you can do other math on them before rounding off to get a whole number that the graphics system can use.</P>
<P>
To transform points through an arbitrary transformation instead of to device coordinates, use the <CODE>
GrTransformByMatrix()</CODE>
 or <CODE>
GrUntransformByMatrix()</CODE>
 routines, described previously.</P>

<HR>
<A NAME="Environment_c.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Graphics Environment</A>: 5.5 <A HREF="#Environment_7.htm">Coordinate Space</A>: 
<A NAME="Environment_c.htm_38614">
 </A>
Larger Document Spaces</H3>
<PRE>GrApplyTranslationDWord(), GrTransformDWord(), GrUntransformDWord(), GrTransformDWFixed(), GrUntransformDWFixed()</PRE>
<P>
<A NAME="Environment_c.htm_IX_Large document model:coordinates">
 </A>
Some applications may need a graphics space larger than the 19 foot square of the standard coordinate space (10 foot square for printed documents). Some spreadsheets can take up a lot of room, as can wide banners. Geodes that will need a large drawing space can request a 32-bit graphics space. Most applications will be able to get by with standard 16-bit coordinate spaces, and their authors may safely skip this section. Note, however, that the Graphic and Spreadsheet objects use 32-bit graphics spaces for display.
<IMG SRC="Environment_c_bigRects.gif">

</P>
<P>
If a geode will use a 32-bit space in a view, it will need a VisContent object with the VCNA_LARGE_DOCUMENT_MODEL attribute.</P>
<P>
For the most part, 32-bit documents use the same graphics commands as regular 16-bit documents. No single drawing command can cover more than a standard document area; each has been optimized to draw quickly in 16 bits. To draw to the outlying reaches of your document space, apply a special translation that takes 32-bit coordinates, then use normal drawing routines in your new location. </P>
<P>
A model for working with 32-bit graphics spaces commonly used with spreadsheets is to break the graphics space into sections. To draw anything, the geode first uses a translation to get to the proper section, then makes the appropriate graphics calls to draw within that section. </P>
<P>
If you wish to display this 32-bit coordinate graphics space to the screen, you'll probably want to do so in a 32-bit content.</P>
<P>
The standard graphics commands can only draw to one 16 bit space at a time. You will need to translate the coordinate space to choose which 16-bit portion of the 32-bit space you want to draw to. To do so you need to use some special translation functions.<A NAME="Environment_c.htm_IX_GrApplyTranslationDWord()">
 </A>
 <CODE>
GrApplyTranslationDWord()</CODE>
 corresponds to the <CODE>
GrApplyTranslation()</CODE>
 function normally used.You can use this routine to make the jumps necessary to access far away portions of the graphics space. Since a coordinate can now be in a much larger area than before, all routines that deal with a point's position have 32-bit equivalents. 

</P>
<P>
<CODE>
GrTransformDWord()</CODE>
<A NAME="Environment_c.htm_IX_GrTransformDWord()">
 </A>
 and<A NAME="Environment_c.htm_IX_GrUntransformDWord()">
 </A>
 <CODE>
GrUntransformDWord()</CODE>
 take the place of <CODE>
GrTransform()</CODE>
 and <CODE>
GrUntransform()</CODE>
. <CODE>
GrTransformDWFixed()</CODE>
<A NAME="Environment_c.htm_IX_GrTransformDWFixed()">
 </A>
 and<A NAME="Environment_c.htm_IX_GrUntransformDWFixed()">
 </A>
 <CODE>
GrUntransformDWFixed()</CODE>
 take the place of <CODE>
GrTransformWWFixed()</CODE>
 and <CODE>
GrUntransformWWFixed()</CODE>
, with two words in the integer part of the number instead of one.</P>
<HR>
<A NAME="Environment_d.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Graphics Environment</A>: 5.6 <A HREF="#Environment_7.htm">Coordinate Space</A>: 
Current Position</H3>
<PRE>GrMoveTo(), GrMoveToWWFixed(), GrRelMoveTo(), GrGetCurPos(), GrGetCurPosWWFixed()</PRE>
<P>
<A NAME="Environment_d.htm_IX_Current position (graphics)">
 </A>
The graphics system supports the notion of a current position, sometimes called a pen position. Note that the pen position metaphor predates &quot;pen computing&quot;; please don't confuse these concepts. The concept behind the pen position is that all graphics commands are executed by a pen that ends up at the last place drawn. So if the last command was to draw a curve ending at (20, 20), the pen will still be there. There are special drawing commands that work with the pen position, so you could then draw a line from the current position to (30, 30). The line would extend from (20, 20) to (30, 30), and the pen would then be at (30, 30). </P>
<P>
<A NAME="Environment_d.htm_IX_GrMoveTo()">
 </A>
Calling <CODE>
GrMoveTo()</CODE>
 moves the pen position to coordinates of your choice.<A NAME="Environment_d.htm_IX_GrMoveToWWFixed()">
 </A>
<CODE>
GrMoveToWWFixed()</CODE>
 moves the pen position to coordinates which may be specified with a great deal of precision. <CODE>
GrRelMoveTo()</CODE>
<A NAME="Environment_d.htm_IX_GrRelMoveTo()">
 </A>
 moves the pen to a location relative to its present position. <CODE>
GrRelMoveTo()</CODE>
 takes coordinates accurate to a fraction of a point, allowing for very precise placement. <A NAME="Environment_d.htm_IX_GrGetCurPos()">
 </A>
Call <CODE>
GrGetCurPos()</CODE>
 to get the current position, <CODE>
GrGetCurPosWWFixed()</CODE>
<A NAME="Environment_d.htm_IX_GrGetCurPosWWFixed()">
 </A>
 to do so with greater accuracy.</P>
<P>
There are some guidelines to follow when figuring out where your pen position is going to end up after a draw operation. If you call the <CODE>
GrDrawLineTo()</CODE>
 procedure, the pen will end up at the point drawn to. If you call any draw/fill procedure that takes two points as arguments, the pen position usually ends up at the second point passed; if it does not, the reference entry will note where the pen position ends. When text draws at the current position, the current position is used to place the left side of the text. When done drawing the text, the current position has moved to the right side of the text.</P>
<HR>
<A NAME="Environment_e.htm"></A>


<H2 CLASS="sectionTitle">
<A HREF="#index.htm">Graphics Environment</A>: 6 
<A NAME="Environment_e.htm_91745">
 </A>
Graphics State</H2>
<P>
<A NAME="Environment_e.htm_IX_GStates">
 </A>
The data structure known as the Graphics State, or GState, keeps track of changes your code makes about how it wants to draw things. If your geode changes its transformation, everything you draw from that point will be drawn transformed until you change the transformation again. If your geode sets the line width to two points, all lines to come will be drawn two points wide until the width is set to something else. Many graphics routines ask that you pass a GState along as one of the parameters so they know where and how to draw what you've requested.</P>
<P CLASS="subsectionLink">
<A HREF="#Environment_f.htm">GState Contents</A></P>
<P CLASS="subsectionLink">
<A HREF="#Environment_10.htm">Working with GStates</A></P>
<HR>
<A NAME="Environment_f.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Graphics Environment</A>: 6.1 <A HREF="#Environment_e.htm">Graphics State</A>: 
GState Contents</H3>
<P>
Sometimes it's convenient to think of the GState as being analogous to the Properties boxes in GeoDraw. The GState keeps track of how the program wants to draw lines, text, and filled areas, just as the Line Properties, Text Properties, and Area Properties boxes keep track of how the GeoDraw user wants to draw these objects. </P>
<P>
While handy, this analogy doesn't do the GState justice. The GState keeps track of many things:</P>
<UL>
<LI>
Mix Mode<BR>
The graphics system allows for different mix modes (sometimes known as copy modes). These drawing modes permit the geode to draw in such ways that it erases instead of drawing, draws using the inverse of whatever it's drawing on, or uses various other modes.</LI>
<LI>
Current Position (also known as Pen Position)<BR>
The graphics system keeps track of the position of the last thing drawn. If your geode wants to draw something else at this location, there are drawing commands that will draw at the current position.</LI>
<LI>
Area Attributes<BR>
The GState contains information that the graphics system will use when filling areas. This information includes the color and fill pattern to use.</LI>
<LI>
Line attributes<BR>
The graphics system uses information stored in the Graphics State to keep track of what color and pattern to use when drawing lines. The GState also keeps track of whether lines should be drawn as dotted, and if so what sort of dot-dash pattern to use. The GState contains the line width. It also contains line join information, which controls how lines will be drawn when they meet at an angle, as at the vertices of a polygon.</LI>
<LI>
Text Attributes<BR>
The Graphics State contains the ID of the current font, the font size, and the text style. It also contains a color and pattern to use, information about the font, and some esoteric text-drawing options.</LI>
<LI>
Coordinate Space Transformations<BR>
The GState keeps track of the current coordinate space transformation. If there is an associated window, the window's transformation matrix is maintained separately with the window's information.</LI>
<LI>
Associated Window<BR>
The GState knows the handle of the window associated with the GState. This is the window that will determine where drawings appear and how they are clipped.</LI>
<LI>
Associated GString<BR>
If the application is building a GString, the GState is aware of it. The GState contains a reference to the GString. When the graphics system turns graphics commands into GString elements, these elements will be appended to the referenced GString.</LI>
<LI>
Associated Path<BR>
If the application is building a path, the GState contains a pointer to the path along which new path elements are passed, similar to the way GString elements are passed. The GState also keeps track of whether the current path is to be combined with another path or should be used &quot;as is.&quot;</LI>
<LI>
Clipping Information<BR>
The GState keeps track of clipping information in addition to that maintained by the window.</LI>
</UL>
<P>
The function of many of these parts may be fairly intuitive to someone used to working with graphics programs. Some of the others may require additional explanation, especially when it comes to how to work with them.</P>
<HR>
<A NAME="Environment_10.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Graphics Environment</A>: 6.2 <A HREF="#Environment_e.htm">Graphics State</A>: 
Working with GStates</H3>
<PRE>GrCreateState(), GrDestroyState(), GrSaveState(), GrRestoreState()</PRE>
<P>
As has been mentioned, most graphics routines require that a GState handle be provided as an argument. Beginning programmers are often unclear on just where to get the GState to use.</P>
<P>
Many drawing routines are called by <CODE>
MSG_VIS_DRAW</CODE>
. This message provides a GState, and all routines in the handlers for this message should use the provided GState. Creating a new GState under these circumstances is unnecessary and wasteful. However, sometimes you will need to create a GState.<A NAME="Environment_10.htm_IX_GrCreateState()">
 </A>
 <CODE>
GrCreateState()</CODE>
 creates a GState with the default characteristics. You must specify the window with which the GState will be associated.

</P>
<P>
Commands which change drawing attributes or the current position change the GState.<A NAME="Environment_10.htm_IX_GrSetDefaultState()">
 </A>
 </P>
<P>
<CODE>
GrDestroyState()</CODE>
<A NAME="Environment_10.htm_IX_GrDestroyState()">
 </A>
 is used to get rid of a GState, freeing the memory to be used by other things. If GStates are created but not destroyed, eventually they will take too much memory. Normally, for each call to <CODE>
GrCreateState()</CODE>
 there is a corresponding <CODE>
GrDestroyState()</CODE>
. <CODE>
MSG_VIS_DRAW</CODE>
 handlers don't need to destroy the passed GState. Graphics states are cached so that <CODE>
GrCreateState()</CODE>
 and <CODE>
GrDestroyState()</CODE>
 don't normally need to call <CODE>
MemAlloc()</CODE>
 or <CODE>
MemFree()</CODE>
. When GStates are freed, their space is added to the cache. When the memory manager needs to find space on the heap, it flushes the cache.</P>
<P>
A geode is most likely to call <CODE>
GrCreateState()</CODE>
 when about to draw a piece of geode-defined UI. Other than that, you'll probably be using GStates provided to you by the system. You might want to create a GState if you wanted to calculate something (perhaps the length, in inches, of a text string) when you had no appropriate GState.</P>
<P>
<CODE>
GrSaveState()</CODE>
<A NAME="Environment_10.htm_IX_GrSaveState()">
 </A>
 provides a sort of &quot;push&quot; operation that works with GStates. When you call certain functions, like <CODE>
GrSetAreaColor()</CODE>
, new values will wipe out the values of the old GState. <A NAME="Environment_10.htm_IX_GrRestoreState()">
 </A>
But if you've previously called <CODE>
GrSaveState()</CODE>
, then any time you call <CODE>
GrRestoreState()</CODE>
 on your saved state, it will come back and displace the current state. Your application can save a GState to save a commonly used clipping region, which could then be restored by restoring the state instead of repeating all the operations needed to duplicate the region.<A NAME="Environment_10.htm_IX_GrSaveTransform()">
 </A>
 <CODE>
GrSaveTransform()</CODE>
 and<A NAME="Environment_10.htm_IX_GrRestoreTransform()">
 </A>
 <CODE>
GrRestoreTransform()</CODE>
 are optimizations of <CODE>
GrSaveState()</CODE>
 and <CODE>
GrRestoreState()</CODE>
, but they only preserve the GState's transformation.</P>
<HR>
<A NAME="Environment_11.htm"></A>


<H2 CLASS="sectionTitle">
<A HREF="#index.htm">Graphics Environment</A>: 7 
<A NAME="Environment_11.htm_30652">
 </A>
Working With Bitmaps</H2>
<PRE>GrCreateBitmap(), GrDestroyBitmap(), GrEditBitmap() GrGetPoint(), GrSetBitmapMode(), GrGetBitmapMode(), GrSetBitmapRes(), GrGetBitmapRes(), GrClearBitmap(), GrGetBitmapSize(), GrCompactBitmap(), GrUncompactBitmap()</PRE>
<P>
<A NAME="Environment_11.htm_IX_Bitmaps">
 </A>
Bitmaps are useful for describing complicated pictures that don't have to be smooth at all resolutions. For example, coming up with all the lines and shapes necessary to describe a complicated photograph would be time-consuming and a waste of memory. It's much easier to set up a rectangular array of cells and to set a color value for each cell. Bitmaps are often used for defining program icons. GEOS includes a great deal of bitmap support. It has kernel routines to create, modify, and draw bitmaps.</P>
<P>
There are three main ways to create a bitmap for an application to use. One often used is to embed the data of a desired bitmap directly into a graphics string. This is the way normally used for defining system icons. The other common way is to call the kernel graphics routine <CODE>
GrCreateBitmap()</CODE>
. Another way to create a bitmap, not used so often, is to manipulate memory directly: The formats used for describing bitmaps are public, and though it would be easier in most cases to work through <CODE>
GrCreateBitmap()</CODE>
, those with specialized needs might want to create their bitmap data structures from scratch.</P>
<P>
The <A NAME="Environment_11.htm_IX_GrCreateBitmap()">
 </A>
<CODE>
GrCreateBitmap()</CODE>
 routine creates an offscreen bitmap and returns a Graphics State which can be drawn to; changes to this Graphics State become changes to the offscreen bitmap. For example, calling <CODE>
GrDrawLine()</CODE>
 and passing the Graphics State provided with such a bitmap would result in a bitmap depicting a line. To display this bitmap, call the <CODE>
GrFillBitmap(), GrDrawHugeBitmap(), GrDrawImage(),</CODE>
 or <CODE>
GrDrawHugeImage()</CODE>
 commands in another graphics space (see <A HREF="../../Graphics/Shapes/Shapes_c.htm#60826">the Drawing Shapes chapter</A>).</P><P>
When creating a bitmap, you must make choices about what sort of bitmap you want. Depending on your choices, GEOS will be able to use a variety of optimizations. For instance, it takes much less room to store a monochrome bitmap than a color bitmap the same size.</P>
<P>
Whenever creating a bitmap, you must specify its dimensions and what sort of coloring it will use (monochrome, four bit, eight bit, or 24 bit).</P>
<P>
You may store a mask with your bitmap. This mask works something like the mask used when drawing a view's mouse pointer. When the bitmap is drawn, blank areas of the bitmap will be drawn as black for those pixels where the mask is turned on. For pixels where the mask is turned off, whatever was underneath the bitmap will be allowed to show through.</P>
<P>
By asking for a Complex bitmap, you can specify even more information. Complex bitmaps may include their own palette and may specify their own horizontal and vertical resolution. They are very useful for working with bitmaps that may have been captured on other systems or for working with display devices.</P>
<P>
<A NAME="Environment_11.htm_IX_GrDestroyBitmap()">
 </A>
The <CODE>
GrDestroyBitmap()</CODE>
 routine destroys some or all of the information associated with a bitmap. You may use this function to free all memory taken up by the bitmap. You may also use this function to free only the GState associated with a bitmap by <CODE>
GrCreateBitmap()</CODE>
, but leave the bitmap's data alone; the <A NAME="Environment_11.htm_IX_BMD_&ldots;">
 </A>
<A NAME="Environment_11.htm_IX_BMDestroy">
 </A>
<CODE>
BMDestroy</CODE>
 argument will determine exactly what is destroyed. This usage comes in handy for those times when a bitmap will not be changing, but will be drawn. Large bitmaps are stored in HugeArrays so they won't take up inordinate amounts of RAM; of course it's always wise to free the memory associated with a bitmap when that bitmap is no longer needed.</P>
<P>
If you have freed the GState associated with a huge bitmap using <CODE>
GrDestroyBitmap()</CODE>
 but want to make changes to the bitmap, all is not lost. Call <A NAME="Environment_11.htm_IX_GrEditBitmap()">
 </A>
<CODE>
GrEditBitmap()</CODE>
 to associate a new GState with the bitmap. Be careful, however; the bitmap will not recall anything about the old GState, so you must set up colors, patterns, and other such information again. To update the VM file used to store a bitmap (if any), call <A NAME="Environment_11.htm_IX_GrSetVMFile():with bitmaps">
 </A>
<CODE>
GrSetVMFile()</CODE>
.</P>
<P>
<CODE>
GrClearBitmap()</CODE>
<A NAME="Environment_11.htm_IX_GrClearBitmap()">
 </A>
 clears the data from a bitmap.</P>
<P>
<CODE>
GrGetPoint()</CODE>
<A NAME="Environment_11.htm_IX_GrGetPoint()">
 </A>
 can retrieve information from a bitmap, returning its color value for some location. It works with all sorts of display areas, not just bitmaps. It is mentioned here because of its usefulness for those who wish to be able to exercise effects on their bitmaps.</P>
<P>
<A NAME="Environment_11.htm_IX_GrSetBitmapMode()">
 </A>
<CODE>
GrSetBitmapMode()</CODE>
 gives you control over how drawing commands will affect the bitmap. If your bitmap has a mask, use this routine to switch between editing the mask and the bitmap itself; the <CODE>
BitmapMode</CODE>
<A NAME="Environment_11.htm_IX_BitmapMode">
 </A>
 argument will specify what is to be edited.

</P>
<P>
<A NAME="Environment_11.htm_IX_Dithering:clustered vs. dispersed">
 </A>
This routine also gives you control over how monochrome bitmaps should handle color. When you draw something in color to a monochrome bitmap, the system tries to approximate the color using dithering. It turns some pixels on and some pixels off in an attempt to simulate the color's brightness. A crimson area would appear with most pixels black, and thus rather dark. A pink area on the other hand would have mostly white pixels, and thus appear light. <CODE>
GrSetBitmapMode()</CODE>
 can change which strategy GEOS will use when deciding which pixels to turn on. If you wish to use &quot;dispersed&quot; dithering, the pixels turned on will be spread out evenly, resulting in a smooth gray. However, some output devices (notably certain printers) have trouble drawing small, widely spaced dots accurately. Using &quot;clustered&quot; dithering causes the system to keep the pixels turned on close together, resulting in pictures reminiscent of newspaper photographs. Thus, devices that prefer a few big dots to lots of little dots will have an easier time with bitmaps so edited. </P>
<P>
The bitmap mode information may also include a color transfer table. These tables are normally only used by printer drivers, but your geode is welcome to use them, if you can find a reason. Some models of printer have problems when mixing colors. Several printers have problems trying to mix dark colors, tending to end up with black. The table contains a byte value for each possible value of each color component. When mixing the colors, the graphics system will find the real color value to use in the table. Thus, if the reds in RGB bitmaps are looking somewhat washed out, you might set up a table so that reds would be boosted. RGBT_red[1] might be 16, RGBT_red[2] 23, so that the device would use more than the standard amount of the red component. </P>
<P>
<CODE>
GrGetBitmapMode()</CODE>
<A NAME="Environment_11.htm_IX_GrGetBitmapMode()">
 </A>
 returns the current bitmap editing mode.</P>
<P>
<CODE>
GrSetBitmapRes()</CODE>
<A NAME="Environment_11.htm_IX_GrSetBitmapRes()">
 </A>
 works with complex bitmaps, changing their resolution. Because simple bitmaps are assumed to be 72 dpi, their resolution cannot be changed unless they are turned into complex bitmaps.<A NAME="Environment_11.htm_IX_GrGetBitmapRes()">
 </A>
 <CODE>
GrGetBitmapRes()</CODE>
 returns the resolution associated with a complex bitmap.</P>
<P>
<CODE>
GrGetBitmapSize()</CODE>
<A NAME="Environment_11.htm_IX_GrGetBitmapSize()">
 </A>
 returns a bitmap's size in points. This function might be useful for quickly determining how much space to set aside when displaying the bitmap. <A NAME="Environment_11.htm_IX_GrGetHugeBitmapSize()">
 </A>
<CODE>
GrGetHugeBitmapSize()</CODE>
 retrieves the size of a bitmap stored in a <CODE>
HugeArray</CODE>
.</P>
<P>
<A NAME="Environment_11.htm_IX_GrCompactBitmap()">
 </A>
Use<CODE>
 GrCompactBitmap()</CODE>
 and<A NAME="Environment_11.htm_IX_GrUncompactBitmap()">
 </A>
 <CODE>
GrUncompactBitmap()</CODE>
 to compact and uncompact bitmaps. Compacted bitmaps take up less memory; uncompacted bitmaps draw more quickly. Note that the bitmap drawing routines can handle compacted and uncompacted bitmaps. These functions are here to aid programmers who wish more immediate control over their memory usage.</P>
<HR>
<A NAME="Environment_12.htm"></A>


<H2 CLASS="sectionTitle">
<A HREF="#index.htm">Graphics Environment</A>: 8 
<A NAME="Environment_12.htm_16169">
 </A>
Graphics Strings</H2>
<P>
<A NAME="Environment_12.htm_IX_GStrings">
 </A>
A GString is a data structure which represents a series of graphics commands. This structure may be stored in a chunk or VM file so that it may be played back later. An application may declare a GString statically or may create one dynamically using standard kernel drawing commands. They are used for describing application icons and printer jobs, among other things. </P>
<P CLASS="subsectionLink">
<A HREF="#Environment_13.htm">Storage and Loading</A></P>
<P CLASS="subsectionLink">
<A HREF="#Environment_14.htm">Special Drawing Commands</A></P>
<P CLASS="subsectionLink">
<A HREF="#Environment_15.htm">Declaring a GString Statically</A></P>
<P CLASS="subsectionLink">
<A HREF="#Environment_16.htm">Creating GStrings Dynamically</A></P>
<P CLASS="subsectionLink">
<A HREF="#Environment_17.htm">Drawing and Scanning</A></P>
<P CLASS="subsectionLink">
<A HREF="#Environment_18.htm">Editing GStrings Dynamically</A></P>
<P CLASS="subsectionLink">
<A HREF="#Environment_19.htm">Parsing GStrings</A></P>
<HR>
<A NAME="Environment_13.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Graphics Environment</A>: 8.1 <A HREF="#Environment_12.htm">Graphics Strings</A>: 
Storage and Loading</H3>
<PRE>GrCreateGString(), GrDestroyGString(), GrLoadGString(), GrEditGString(), GrCopyGString(), GrGetGStringHandle(), GrSetVMFile()</PRE>
<P>
GStrings may reside an a number of types of memory areas. Depending on the GString's storage, you will have to do different things to load it. One common case we have already discussed to some extent is when the GString is part of a visual moniker. In this case, the gstring will be stored in the <CODE>
gstring</CODE>
 field of the <CODE>
@visMoniker</CODE>
's implied structure. In this case the UI will do all loading and drawing of the GString.</P>
<P>
The GString data itself consists of a string of byte-length number values. The graphics system knows how to parse these numbers to determine the intended drawing commands. You need not know the details of the format used--there are routines by which you may build and alter GStrings using common kernel graphics routines; however, macros and constants have been set up so that you may work with the data directly.</P>
<P>
GString data may be stored in any of the following structures (corresponding to the values of the <A NAME="Environment_13.htm_IX_GST_&ldots;">
 </A>
<A NAME="Environment_13.htm_IX_GStringType">
 </A>
<CODE>
GStringType</CODE>
 enumerated type):</P>
<DL>
<DT>
<STRONG>
Chunk</STRONG>
</DT><DD>This is the storage structure of choice for GStrings which will be used as monikers.</DD>
<DT>
<STRONG>
VM Block</STRONG>
 </DT><DD>Virtual memory is normally used to store GStrings which may grow very large. GStrings residing in virtual memory may be dynamically edited.</DD>
<DT>
<STRONG>
Pointer-Referenced Memory</DT><DD>
</STRONG>
You may refer to GStrings by means of a pointer. However, this will only work for reading operations (i.e. you may not change the GString). This is the ideal way to reference a GString which is statically declared in a code resource.</DD>
<DT>
<STRONG>
Stream</STRONG>
</DT><DD>Streams are not actually used to store data--they are used to transmit it between threads or devices. If you write a GString to a stream, it is assumed that some other application, perhaps on another device, will be reading the GString.</DD>
</DL>
<P>
Note that a GString stored in a Stream, VM block, or in memory referenced only by a pointer is not quite ready to be drawn, only GStrings stored in a chunk may be drawn. Fortunately there is a routine which can load any type of GString into local memory so that it may be drawn.</P>
<P>
If you are editing or creating the GString dynamically, it will have a GState associated with it. Any drawing commands made using this GState will be appended to the GString. This GState will not be stored with the GString; it is instead stored with the other GStates. You may destroy the GState when done editing, and hook up a new one if starting some other edit; this will not affect the GString's storage.
<IMG SRC="Environment_13_gstateGString.gif">

</P>
<P>
<A NAME="Environment_13.htm_IX_GrCreateGString()">
 </A>
To dynamically create an empty GString, call the <CODE>
GrCreateGString() </CODE>
routine. You must decide where you want the GString to be stored--either in a chunk, a VM block, or a stream. If you wish to store the GString in a chunk or VM block, a memory unit of the appropriate type will be allocated for you. This routines will return the GState by which the GString may be edited and the chunk or VM block created.</P>
<P>
The <A NAME="Environment_13.htm_IX_GrDestroyGString()">
 </A>
<CODE>
GrDestroyGString()</CODE>
 routine allows you to free up the GState handle associated with your GString You may also destroy the GString's data if you wish; specify exactly what you want to destroy by means of the <CODE>
GStringKillType</CODE>
<A NAME="Environment_13.htm_IX_GSKT_&ldots;">
 </A>
<A NAME="Environment_13.htm_IX_GStringKillType">
 </A>
 argument. In addition, you may destroy another GState. You must pass the global handle of the GString to destroy--this will be the handle returned by <CODE>
GrCreateGString()</CODE>
, <CODE>
GrEditGString()</CODE>
, or <CODE>
GrLoadGString()</CODE>
.</P>
<P>
The <A NAME="Environment_13.htm_IX_GrLoadGString()">
 </A>
<CODE>
GrLoadGString()</CODE>
 command loads a GString into a global memory block so that it may be drawn. Actually, it doesn't load the entire GString into memory, but does initialize the data structure so that it may be referenced through the global memory handle which the routine returns.</P>
<P>
The <A NAME="Environment_13.htm_IX_GrEditGString()">
 </A>
<CODE>
GrEditGString()</CODE>
 command is very much like <CODE>
GrCreateGString()</CODE>
, except that instead of creating a new GString, it allows you to dynamically edit an existing GString. This command loads a VM-based GString into a special data structure. Like <CODE>
GrCreateGString()</CODE>
, it returns a GState to which you may make drawing commands. You may insert or delete drawing commands while in this mode, all using kernel drawing routines. For more information about using this routine, see <A HREF="#Environment_18.htm_19740"> Editing GStrings Dynamically</A>
.</P>
<P>
The <A NAME="Environment_13.htm_IX_GrCopyGString()">
 </A>
<CODE>
GrCopyGString()</CODE>
 command copies the contents of one GString to another. At first you might think that you could do this by allocating the target GString with <CODE>
GrCreateGString()</CODE>
, then drawing the source GString to the provided GState. However, the GState may only have one GString associated with it, whether that GString is being used as a source or target.</P>
<P>
To find the handle of the GString data associated with a GState, call <CODE>
GrGetGStringHandle()</CODE>
<A NAME="Environment_13.htm_IX_GrGetGStringHandle()">
 </A>
. To update the VM file associated with a GString (perhaps after calling <CODE>
VMSave()</CODE>
), use <A NAME="Environment_13.htm_IX_GrSetVMFile():with GStrings">
 </A>
<CODE>
GrSetVMFile()</CODE>
.</P>
<HR>
<A NAME="Environment_14.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Graphics Environment</A>: 8.2 <A HREF="#Environment_12.htm">Graphics Strings</A>: 
Special Drawing Commands</H3>
<PRE>GrEndGString(), GrNewPage(), GrLabel(), GrComment(), GrNullOp(), GrEscape(), GrSetGStringBounds()</PRE>
<P>
There are certain kernel graphics commands which, though they could be used when drawing to any graphics space, are normally only used when describing GStrings. Most of these commands have no visible effect, but only serve to provide the GString with certain control codes.</P>
<P>
The most commonly used of these routines is <A NAME="Environment_14.htm_IX_GrEndGString()">
 </A>
<CODE>
GrEndGString()</CODE>
. This signals that you are done describing the GString, writing a GR_END_GSTRING to the GString. This routine will let you know if there was an error while creating the GString (if the storage device ran out of space). Its macro equivalent is <CODE>
GSEndString()</CODE>
.</P>
<P>
The <A NAME="Environment_14.htm_IX_GrNewPage()">
 </A>
<CODE>
GrNewPage()</CODE>
 routine signals that the GString is about to start describing another page. GStrings are used to describe things to be sent to the printer, and unsurprisingly, this routine is often used in that context. An example of a prototype multi-page printing loop is shown in<A HREF="#Environment_14.htm_22134"> Multi-Page Printing Loop</A>
. Whether or not it is drawing to a GString, <CODE>
GrNewPage()</CODE>
 causes the GState to revert to the default. When calling this routine, specify whether or not a form-feed signal should be generated by means of the <CODE>
PageEndCommand</CODE>
<A NAME="Environment_14.htm_IX_PEC_&ldots;">
 </A>
<A NAME="Environment_14.htm_IX_PageEndCommand">
 </A>
 argument.</P>
<P CLASS="figTitle">
Code Display 23-1 <A NAME="Environment_14.htm_22134">
 </A>
Multi-Page Printing Loop</P>
<PRE>/* The application this code fragment is taken from stores several pages of 
 * graphics in one coordinate space. The pages are arranged each below the other.
 * To display page #<EM>X</EM>, we would scroll down <EM>X</EM> page lengths. */</PRE>
<PRE>for (curPage=0; curPage &lt; numberOfPages; curPage++) {
	GrSaveState(gstate);
	GrApplyTranslation(gstate, 0,MakeWWFixed(curPage*pageHeight));</PRE>
<PRE>	/* ...Draw current page... */</PRE>
<PRE>	GrRestoreState(gstate);
	GrNewPage(gstate, PEC_NO_FORM_FEED );}</PRE>
<P>
The<CODE>
 GrLabel()</CODE>
<A NAME="Environment_14.htm_IX_GrLabel()">
 </A>
 routine inserts a special element into the GString. This element does not draw anything. However, these GString labels, as they are called, are often used like labels in code. By using GString drawing routines with a certain option (described below), you may &quot;jump&quot; to this label and start drawing from that point in the GString. Alternately, you could start at some other part of the GString and automatically draw until you encountered that label.</P>
<P>
The <A NAME="Environment_14.htm_IX_GrComment()">
 </A>
<CODE>
GrComment()</CODE>
 routine inserts an arbitrary-length string of bytes into the GString which the GString interpreter will ignore when drawing the GString. You might use this to store anything from custom drawing commands which only your geode has to be able to understand to a series of blank bytes which could act as a sort of placeholder in memory.</P>
<P CLASS="figTitle">
Code Display 23-2 GSComment Example</P>
<PRE>static const byte MyGString[] = {
	GSComment(20), 'C','o','p','y','l','e','f','t',' ','1','9','9','3',
	' ','P','K','i','t','t','y', 
	GSDrawEllipse(72, 72, 144, 108), 
	GSEndString()};</PRE>
<P>
The <A NAME="Environment_14.htm_IX_GrNullOp()">
 </A>
<CODE>
GrNullOp()</CODE>
 routine draws nothing and does nothing other than take up space in the GString (a single-byte element of value GR_NOP). You might use it as a placeholder in the GString.</P>
<P>
The <A NAME="Environment_14.htm_IX_GrEscape()">
 </A>
<CODE>
GrEscape()</CODE>
 writes an escape code with accompanying data to the GString. Most geodes do not use this functionality; you might use it to embed special information in a <CODE>
TransferItemFormat</CODE>
 based on GStrings.</P>
<P>
Depending on what the system will do with your GString, the bounds of the GString may be used for many purposes. Normally the system determines the bounds of a GString by traversing the whole GString and finding out how much space it needs to draw. The <A NAME="Environment_14.htm_IX_GrSetGStringBounds()">
 </A>
<CODE>
GrSetGStringBounds()</CODE>
 allows you to optimize this, setting up a special GString element whose data contains the bounds of the GString. You should call this routine early on in your GString definition so that the system won't have to traverse very much of your GString to discover the special element.</P>
<HR>
<A NAME="Environment_15.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Graphics Environment</A>: 8.3 <A HREF="#Environment_12.htm">Graphics Strings</A>: 
Declaring a GString Statically</H3>
<P>
For most programmers, the first encounter with GStrings (often, in fact, their first encounter with any sort of graphics mechanism) is with a program icon. Often this program icon consists of one or more GStrings, each of which contains a bitmap. These monikers are often set up using the <CODE>
@visMoniker </CODE>
keyword. This automatically stores the GString to a chunk. For an example of a GString stored this way, see the appSMMoniker GString in <A HREF="#Environment_15.htm_14223"> GString in Visual Monikers</A>
.</P>
<P CLASS="figTitle">
Code Display 23-3 <A NAME="Environment_15.htm_14223">
 </A>
GString in Visual Monikers</P>
<PRE>@start AppResource;
@object GenApplicationClass AppIconApp = {</PRE>
<PRE>/* The visual moniker for this application (an icon) is created by selecting the
 * most appropriate moniker from the list below. Each moniker in this list is
 * suitable for a specific display type. The specific UI selects the moniker
 * according to the display type GEOS is running under. A text moniker is also
 * supplied if the specific UI desires a textual moniker. */</PRE>
<PRE> GI_visMoniker = list {
	AppIconTextMoniker, /* simple text moniker */
	appLCMoniker, /* Large Color displays */
	appLMMoniker, /* Large Monochrome displays */
	appSCMoniker, /* Small Color displays */
	appSMMoniker, /* Small Monochrome displays */
	appLCGAMoniker, /* Large CGA displays */
	appSCGAMoniker /* Small CGA displays */ }
} </PRE>
<PRE>@visMoniker AppIconTextMoniker = &quot;C AppIcon Sample Application&quot;;
@end AppResource</PRE>
<PRE>@start SAMPLEAPPICONAREASMMONIKERRESOURCE, data;
@visMoniker appSMMoniker = {
	style = icon;
/* Small monochrome icons use the standard size and 1 bit/pixel gray coloring. */
	size = standard; color = gray1; aspectRatio = normal; cachedSize = 48, 30;</PRE>
<PRE>/* The following lines hold GString data: */
<A NAME="Environment_15.htm_IX_@gstring:example"> </A> @gstring {
		/* GSFillBitmapAtCP:
		 * This macro signals that we want to fill a bitmap. The next few
		 * bytes should consist of information about the bitmap; the data
		 * after that holds the bitmap data. The GString reader will know
		 * when it's done reading the bitmap data based on the size stated
		 * in the bitmap's info--it will thus know where to look for the 
		 * next command (in this case a GSEndString() macro. */
 	GSFillBitmapAtCP(186),
		/* Bitmap():
		 * This macro is used to write basic information about the bitmap
		 * to the GString. In this case, that information consists of:
		 * The bitmap is 48x30. It is compressed using PackBits. It is 
		 * monochrome. */
	Bitmap (48, 30, 0, BMF_MONO),
		/* 0x3f, 0xff, 0xff, ...:
		 * These numbers are the bitmap data itself. */
	0x3f, 0xff, 0xff, 0xff, 0xff, 0x80, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xc0,
	0x60, 0x00, 0x00, 0x00, 0x00, 0x60, 0x60, 0x00, 0x00, 0x00, 0x00, 0x60,
	0x60, 0x00, 0x00, 0x80, 0x00, 0x60, 0x60, 0x00, 0x01, 0xc0, 0x00, 0x60,
	0x60, 0x00, 0x03, 0xe0, 0x00, 0x60, 0x60, 0x00, 0x07, 0xf0, 0x00, 0x60,
	0x60, 0x00, 0x03, 0xf8, 0x03, 0xfe, 0x60, 0x00, 0x01, 0xfc, 0x00, 0xf9,
	0x60, 0x06, 0x04, 0xfe, 0x01, 0xfd, 0x60, 0x38, 0x06, 0x1f, 0x01, 0xfd,
	0x60, 0x40, 0x03, 0x63, 0x81, 0x05, 0x60, 0x80, 0x01, 0xa3, 0xc1, 0x04,
	0x60, 0x40, 0x00, 0xc3, 0x81, 0x04, 0x60, 0x38, 0x00, 0x6f, 0x01, 0x04,
	0x60, 0x07, 0xfe, 0xf6, 0x00, 0x88, 0x60, 0x00, 0x01, 0xfc, 0x01, 0x8c,
	0x60, 0x00, 0x03, 0xfe, 0x03, 0xde, 0x60, 0x00, 0x07, 0xf5, 0x07, 0x77,
	0x60, 0x00, 0x03, 0xe2, 0x8f, 0xaf, 0x60, 0x00, 0x01, 0xc3, 0xdf, 0xdf,
	0x60, 0x00, 0x00, 0x81, 0xff, 0xff, 0x60, 0x00, 0x00, 0x00, 0xff, 0xff,
	0x60, 0x00, 0x00, 0x00, 0x7b, 0xff, 0x60, 0x00, 0x00, 0x00, 0x03, 0xff,
	0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0x00, 0x00, 0x00, 0x00, 0x03, 0xff,
		/* GSEndString():
		 * This macro lets the GString interpreter know we're done. */
	GSEndString() } }</PRE>
<PRE>@end SAMPLEAPPICONAREASMMONIKERRESOURCE;</PRE>
<P>
Notice that this example uses macros to set up the data for the GString. We could have just written the GString data as a series of numbers, as shown in <A HREF="#Environment_15.htm_49265"> GString Declared Without Macros</A>
, but the macros are usually easier to read. Each macro's name, you will notice, is taken from the corresponding graphics command name. Thus the <CODE>
GSFillBitmap()</CODE>
 macro corresponds to the <CODE>
GrFillBitmap()</CODE>
 routine. There are no GSGet...() macros; GStrings have no return values or conditional statements, and thus have no use for retrieving this sort of information.</P>
<P CLASS="figTitle">
Code Display 23-4 <A NAME="Environment_15.htm_49265">
 </A>
GString Declared Without Macros</P>
<PRE>const char byte myGString[] = {
	GR_SET_LINE_STYLE,			/* First we set the line style. */
	LS_DASHED,			/* 	We want a dashed line. */
	0, 			/* 	Draw dashes starting with index 0 */</PRE>
<PRE>	GR_DRAW_RECT_TO,			/* Next we draw a rectangle from our current 
				 * position to... */
	0, 72, 0, 72, 			/*	...the point (72, 72). (We need the zeroes
				 * 	because GStrings are arrays of bytes, but
				 * 	we need a word to describe each 
				 * 	coordinate. */
	GR_END_GSTRING
}; /* myGString */</PRE>
<P>
Just as all monikers are not GStrings, not all GStrings need be declared as monikers. See <A HREF="#Environment_15.htm_79861"> Statically Declared GString</A>
 for an example of a statically declared GString taken from the Moniker sample application; here the declared GString is eventually used as a moniker, but could just as well have been passed to <CODE>
GrDrawGString()</CODE>
 and drawn to an arbitrary graphics space.</P>
<P CLASS="figTitle">
Code Display 23-5 <A NAME="Environment_15.htm_79861">
 </A>
Statically Declared GString</P>
<PRE>static void _near			SetPreDefinedGStringMoniker(void)
{
/*
 * A predefined graphics string that draws a 
 * MONIKER_WIDTH by MONIKER_HEIGHT * light-blue rectangle at 0, 0.
 */ 
static const byte gstring[] = {
	GSSetAreaColorIndex(C_LIGHT_BLUE),
	GSFillRect(0, 0, MONIKER_WIDTH, MONIKER_HEIGHT),
	GSEndString() };</PRE>
<PRE>@call CycleMonikerTrigger::MSG_GEN_REPLACE_VIS_MONIKER(
	VUM_NOW, 				/* Update appearance immediately */
	MONIKER_HEIGHT, MONIKER_WIDTH, 				/* Since source is a GString, we need to 
					 * pass the height and width of the 
					 * GString. */
	sizeof(gstring), 				/* Pass the size of sourceGString. */
 	VMDT_GSTRING, 				/* Source is a gstring.... */
	VMST_FPTR, 				/* ...referenced by a far pointer */
	(dword) gstring); 				/* Pointer to gstring */
} /* End of SetPreDefinedGStringMoniker() */</PRE>
<P>
For more examples of statically declared GStrings, see the Moniker, GSTest, and GSTest2 sample applications.</P>
<HR>
<A NAME="Environment_16.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Graphics Environment</A>: 8.4 <A HREF="#Environment_12.htm">Graphics Strings</A>: 
Creating GStrings Dynamically</H3>
<P>
Sometimes it comes in handy to be able to create GStrings &quot;on the fly.&quot; To add elements to a GString, issue normal kernel drawing commands, but use a GState which is associated with the GString.</P>
<P>
To create a new, empty GString ready for editing (i.e. with an attached GState), call<CODE>
 GrCreateGString()</CODE>
. At this point, you may draw to the GString using normal drawing commands. For an example of creating a GString in this manner, see <A HREF="#Environment_16.htm_76851"> Creating a GString Dynamically</A>
.</P>
<P CLASS="figTitle">
Code Display 23-6 <A NAME="Environment_16.htm_76851">
 </A>
Creating a GString Dynamically</P>
<PRE>#define LABEL_BOX    2
#define LABEL_CIRCLE 3</PRE>
<PRE>gstate = GrCreateGString(file, GST_VMEM, &amp;myVMBlock);</PRE>
<PRE>GrSetLineColor(gstate, CF_INDEX, C_BLUE, 0, 0);
GrDrawRect(gstate, 0, 0, 620, 500);</PRE>
<PRE>GrLabel(gstate, LABEL_BOX);
GrSetAreaColor(gstate, CF_INDEX, C_RED, 0, 0);
GrFillRect(gstate, 10, 130, 610, 490);
GrSetLineWidth(gstate, MakeWWFixed(2));</PRE>
<PRE>GrLabel(gstate, LABEL_CIRCLE);
GrSetAreaColor(gstate, CF_INDEX, C_RED, 0, 0);
GrFillEllipse(gstate, 130, 10, 490, 370);
GrDrawEllipse(gstate, 130, 10, 490, 370);</PRE>
<PRE>GrEndGString(gstate);
GrDestroyGString(gstate, 0, GSKT_LEAVE_DATA);</PRE>
<P>
Drawing to a GString in this manner is almost exactly like drawing in any other GEOS graphics environment. However, there are some important rules to keep in mind.</P>
<UL>
<LI>
The GString must end with a GR_END_GSTRING element; when the GString interpreter encounters this element, it knows to stop drawing. When creating a GString dynamically, the normal way to assure this is to call <CODE>
GrEndGString()</CODE>
. (Actually, this rule is not strictly true--when you learn more about drawing GStrings, you will see that it is possible to stop GString drawing based on other cues. However, it's always safest to end the GString with a GR_END_GSTRING in case some other application tries to draw the same GString.)</LI>
<LI>
Remember that you are creating a data structure which will be used later. The only commands which will affect the GString's contents are the kernel graphics routines, and only those which actually draw something or change the drawing properties. When creating a GString, it is tempting to include constructions like the following:</LI>
</UL>
<PRE>if (redFlag)
	{GrSetAreaColor(
		gstate, C_RED, CF_INDEX, 0, 0);}
else  {GrSetAreaColor(
		gstate, C_BLUE,CF_INDEX, 0, 0);}
GrFillRect(gstate, 0, 0, 72, 72);</PRE>
<UL>
<LI>
You might be surprised when you found out that the following code fragments both drew rectangles which were the same color:</LI>
</UL>
<PRE>redFlag = FALSE; 
GrDrawGString(			screenGState, 
			myGString, 
			0, 0, 0, elem);
redFlag = TRUE; 
GrDrawGString(			screenGState, 
			myGString, 
			0, 0, 0, elem);</PRE>
<UL>
<LI>
The factor which would determine the color of the drawing in this example would be the value of redFlag when you were creating the GString, not when you were drawing it.</LI>
<LI>
Think carefully before making coordinate space transformations in GStrings. If you want to remove all transformation effects, you should always call <CODE>
GrSetDefaultTransform()</CODE>
, instead of <CODE>
GrSetNullTransform()</CODE>
. By using <CODE>
GrSetDefaultTransform()</CODE>
, an application that is including your GString can apply some other type of transformation and make that the default; your application will then appear transformed as intended. However, if you call <CODE>
GrSetNullTransform()</CODE>
, you ignore that default transform and will appear in a strange way.</LI>
<LI>
If you use <CODE>
GrInitDefaultTransform()</CODE>
, you should probably bracket its use with calls to <CODE>
GrSaveTransform()</CODE>
 and <CODE>
GrRestoreTransform()</CODE>
. This save/restore pair will also save the current default transformation, if there is one. By adding the save and restore, you will be preserving whatever default transform the application including yours has set up.</LI>
<LI>
If you think your Graphics String will never show up included in some other application, consider the following: The print-to-file feature creates a graphics string that can be imported into several other applications.</LI>
<LI>
If you think you have to use<CODE>
 GrSetTransform()</CODE>
, try replacing it with a <CODE>
GrSetDefaultTransform()</CODE>
/<CODE>
GrApplyTransform()</CODE>
 pair. This will most likely have the same effect, but will be more palatable to another application using the GString.</LI>
<LI>
If you are including some other externally-created Graphics String into your document, you probably want to bracket it with <CODE>
GrSaveState()</CODE>
 and <CODE>
GrRestoreState()</CODE>
.</LI>
<LI>
If you're creating a multi-page GString which might be printed, make sure that each page is independent. There should be nothing assumed about the GState at the beginning of any page--you should instead assume that each will begin with the default GState. This applies to transformations, drawing properties, the GState's path, and so on.<BR>
Keep in mind that each page should be able to print by itself if extracted from a multi-page document.<BR>
The following pseudocode is an example of a &quot;bad&quot; idea:</LI>
</UL>
<PRE>for(curPage=0;curPage &lt; numberOfPages; curPage++) {
 /* { draw current page } */
 GrNewPage();
 GrApplyTranslation(0, pageHeight); }</PRE>
<UL>
<LI>
The following pseudocode provides a &quot;better&quot; way to do the same thing:</LI>
</UL>
<PRE>for (curPage=0; curPage &lt; numberOfPages; curPage++) { GrSaveState();
  GrApplyTranslation(0,curPage*pageHeight);
  /* {draw current page} */
 GrRestoreState();
 GrNewPage(); }</PRE>
<P>
Probably the most important piece of advice is to think about how the Graphics String will be used. If it will be used only under certain well-controlled circumstances, the above concerns may not affect you.</P>
<HR>
<A NAME="Environment_17.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Graphics Environment</A>: 8.5 <A HREF="#Environment_12.htm">Graphics Strings</A>: 
Drawing and Scanning</H3>
<PRE>GrDrawGString(), GrDrawGStringAtCP(), GrSetGStringPos(), GrGetGStringBounds(), GrGetGStringBoundsDWord()</PRE>
<P>
There are several ways to use a GString. You've already seen how to use one as the visual moniker for a UI gadget. In that case, the UI is responsible for drawing the moniker. If you are learning about interfacing with printers, you probably know that you pass a GString to a PrintControl object to describe print jobs.</P>
<P>
There is also a kernel graphics routine for drawing GStrings directly. The <CODE>
GrDrawGString()</CODE>
 command draws a GString, or a part thereof. Remember that the GString must be loaded for drawing; you must call <CODE>
GrLoadGString()</CODE>
<A NAME="Environment_17.htm_IX_GrLoadGString()">
 </A>
 if you have not done so already (or if you have destroyed the GString since you last called <CODE>
GrLoadGString()</CODE>
).</P>
<P CLASS="figTitle">
Code Display 23-7 <A NAME="Environment_17.htm_98898">
 </A>
GrDrawGString() in Action</P>
<PRE>@method StaticContentClass, MSG_VIS_DRAW {
	word 	lElem;
	static const byte gstringData[] = {
		GSSetAreaColorIndex(C_RED), GSFillRect(0, 0, 72, 72),
		GSEndString() };
	@callsuper();
	gstring = GrLoadGString 			(PtrToSegment(gstringData), GST_PTR,
				 PtrToOffset(gstringData));
	GrDrawGString(gstate, gstring, 0, 0, 0, &amp;lElem); }</PRE>
<PRE>@method DynamicContentClass, MSG_VIS_DRAW{
	Handle 		gstring;
	VMFileHandle		file;
	char 		fileString[] = &quot;.&quot;, 0;
	VMBlockHandle		gstringData;
	GStringElement		lElem;</PRE>
<PRE>	@callsuper();
	file = VMOpen(fileString, 
		   (VMAF_FORCE_READ_WRITE | VMAF_USE_BLOCK_LEVEL_SYNCHRONIZATION),
		   VMO_CREATE_TRUNCATE, 
		   0);</PRE>
<PRE>	gstring = GrCreateGString(file, GST_VMEM, &amp;gstringData);
	GrSetAreaColor(gstring, CF_INDEX, C_RED, 0, 0);
	GrFillRect(gstring, 0, 0, 72, 72);
	GrEndGString(gstring);
	GrDestroyGString(gstring, NULL, GSKT_LEAVE_DATA);</PRE>
<PRE>	gstring = GrLoadGString(file, GST_VMEM, gstringData);
	GrDrawGString(gstate, gstring, 0, 0, 0, &amp;lElem);
	GrDestroyGString(gstring, NULL, GSKT_DESTROY_DATA);</PRE>
<PRE>	FileDelete(fileString);</PRE>
<P>
The <A NAME="Environment_17.htm_IX_GrDrawGString()">
 </A>
<CODE>
GrDrawGString()</CODE>
 routine has several arguments. A simple usage of the routine is shown in <A HREF="#Environment_17.htm_98898"> GrDrawGString() in Action</A>
. To take advantage of some of the more powerful features of <CODE>
GrDrawGString()</CODE>
, you should know what the purpose of the arguments.</P>
<UL>
<LI>
You must provide a GState to draw to. You may wish to call <CODE>
GrSaveState()</CODE>
 on the GState before drawing the GString (and call <CODE>
GrRestoreState()</CODE>
 afterwards). If you will draw anything else to this GState after the GString, you must call <CODE>
GrDestroyGString()</CODE>
 on the GString, and pass this GState's handle as the gstate argument so that <CODE>
GrDestroyGString()</CODE>
 can clean up the GState.</LI>
<LI>
You must provide a GString to draw. The GString must be properly loaded (probably by means of <CODE>
GrLoadGString()</CODE>
).</LI>
<LI>
You can provide a pair of coordinates at which to draw the GString. The graphics system will translate the coordinate system by these coordinates before carrying out the graphics commands stored in the GString.</LI>
<LI>
You can provide a <CODE>
GSControl</CODE>
 argument which requests that the system stop drawing the GString when it encounters a certain type of GString element. If the GString interpreter encounters one of these elements, it will immediately stop drawing. The GString will remember where it stopped drawing. If you call <CODE>
GrDrawGString() </CODE>
with that same GString, it will continue drawing where you left off. Note that any time a GString-traversing function such as <CODE>
GrDrawGString()</CODE>
 returns, it returns a <A NAME="Environment_17.htm_IX_GSRT_&ldots;">
 </A>
<A NAME="Environment_17.htm_IX_GSRetType">
 </A>
<CODE>
GSRetType</CODE>
 value which makes it clear exactly why it stopped traversing the GString.</LI>
<LI>
You must provide a pointer to an empty <CODE>
GStringElement</CODE>
 structure. <CODE>
GrDrawGString()</CODE>
 will return a value here when it is finished drawing. If the GString has stopped drawing partway through due to a passed <CODE>
GSControl</CODE>
, the returned <CODE>
GStringElement</CODE>
 value will tell you what sort of command was responsible for halting drawing. For instance, if you had instructed <CODE>
GrDrawGString()</CODE>
 to halt on an `output' element (GrDraw...() or GrFill...() commands), then when <CODE>
GrDrawGString()</CODE>
 returns, you would check the value returned to see what sort of output element was present.</LI>
</UL>
<P>
Note that those last two arguments aren't very useful except when used in conjunction with some other GString routines which we will get to later.</P>
<P>
The <A NAME="Environment_17.htm_IX_GrDrawGStringAtCP()">
 </A>
<CODE>
GrDrawGStringAtCP()</CODE>
 routine functions in much the same way as <CODE>
GrDrawGString()</CODE>
, except that the current pen position will be used in the place of passed coordinate arguments.</P>
<P>
The <A NAME="Environment_17.htm_IX_GrSetGStringPos()">
 </A>
<CODE>
GrSetGStringPos()</CODE>
 routine allows you to skip any number of GString elements, or go back to the beginning or end of the GString. You specify whether you want to skip to the beginning, end, or ahead by a few steps; this is specified by the <A NAME="Environment_17.htm_IX_GSSPT_&ldots;">
 </A>
<A NAME="Environment_17.htm_IX_GStringSetPosType">
 </A>
<CODE>
GStringSetPosType</CODE>
 argument. This routine is useful both when drawing and editing GStrings. Note that you may also use this routine to jump backwards in a GString, but this only works with VM-based GStrings. The GString must be loaded for drawing or editing, and you will pass in the GString's global handle, as supplied by <CODE>
GrLoadGString()</CODE>
 or<CODE>
 GrEditGString()</CODE>
.</P>
<P CLASS="figTitle">
Code Display 23-8 GrSetGStringPos() In Action</P>
<PRE>/* The following routine is used to allow creating an `overlay' effect. Normally,
 * multi-page GStrings will contain form feed elements that signal the break
 * between pages. Here we see a section of code which will filter out form feeds by
 * skipping those elements. The result will be a single page in which all the pages
 * of the original GString are drawn on top of each other. */</PRE>
<PRE>	for (	gsr = GrDrawGString(gstate, gstring, 0, 0, GSC_NEW_PAGE, gse);
		gsr == GSR_FORM_FEED;
		gsr = GrDrawGString(gstate, gstring, 0, 0, GSC_NEW_PAGE, gse) )
			{GrSetGStringPos(gstring, GSSPT_SKIP_1, 0); }</PRE>
<P>
Because a GString remembers its place when you stop drawing partway through, if you wish to `reset' the GString position, you should use <CODE>
GrSetGStringPos()</CODE>
 to set it back to the beginning.</P>
<P>
Occasionally you may be curious to know how much space is necessary to draw a GString. The<CODE>
 GrGetGStringBounds()</CODE>
<A NAME="Environment_17.htm_IX_GrGetGStringBounds()">
 </A>
 routine determines this, returning the coordinates describing the GString's bounding rectangle. If the GString may have very large bounds, you should use the <CODE>
GrGetGStringBoundsDWord()</CODE>
<A NAME="Environment_17.htm_IX_GrGetGStringBoundsDWord()">
 </A>
 routine instead.</P>
<HR>
<A NAME="Environment_18.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Graphics Environment</A>: 8.6 <A HREF="#Environment_12.htm">Graphics Strings</A>: 
<A NAME="Environment_18.htm_19740">
 </A>
Editing GStrings Dynamically</H3>
<PRE>GrEditGString(), GrDeleteGStringElement()</PRE>
<P>
Applications may find cause to dynamically alter an existing GString. You might create a sort of template GString and want to fill in some parts at a later time. If you will draw several similar GStrings, it might be nice to use a single GString, but change only certain parts before drawing each time.</P>
<P>
<CODE>
GrEditGString()</CODE>
 allows you to edit an existing GString. It only works with VM-based GStrings. Calling<CODE>
 GrEditGString() </CODE>
allocates a new GState and associates it with the GString. Any drawing commands to this GState will be appended to the GString. You may use <CODE>
GrDrawGString()</CODE>
 (along with appropriate <CODE>
GSControl</CODE>
 values) and <CODE>
GrSetGStringPos() </CODE>
to change position within the GString, allowing you to insert new commands into the middle of the GString.</P>
<P>
The <A NAME="Environment_18.htm_IX_GrDeleteGStringElement()">
 </A>
<CODE>
GrDeleteGStringElement()</CODE>
 routine allows you to delete any number of GString elements. The elements deleted will be taken starting at your position in the GString. This command only works while editing the GString, and you must pass the GString's editing GState handle to this routine.</P>
<HR>
<A NAME="Environment_19.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Graphics Environment</A>: 8.7 <A HREF="#Environment_12.htm">Graphics Strings</A>: 
Parsing GStrings</H3>
<PRE>GrGetGStringElement(), GrParseGString()</PRE>
<P>
For complicated GString operations, you may find the following advanced routines helpful.</P>
<P>
<CODE>
GrGetGStringElement()</CODE>
<A NAME="Environment_19.htm_IX_GrGetGStringElement()">
 </A>
 returns the raw data associated with the current GString element. To understand this stream of bytes, you must know what sorts of data are associated with each kind of GString element. For example <CODE>
GrGetGStringElement ()</CODE>
 might return GR_DRAW_RECT with the following buffer of bytes:</P>
<PRE>GR_DRAW_RECT, 0x00, 0x48, 0x00, 0x24, 
0x00, 0x90, 0x00, 0x84</PRE>
<P>
You must know enough about GString element structures to know that this will draw a rectangle with bounds {72, 36, 144, 108}. To find out this sort of information, examine the GS...() macros, or search <STRONG CLASS="fileName">
gstring.h</STRONG>
 for macros containing the appropriate <CODE>
GStringElement</CODE>
 value.</P>
<P CLASS="figTitle">
Code Display 23-9 GrGetGStringElement() In Action</P>
<PRE>/* Our application allows for a second kind of spline, a B-spline. This spline
 * looks similar to a regular B�zier spline, but is somewhat different and uses
 * a different mathematical formula. When this app creates a GString, it will 
 * output B�zier splines in the normal way.</PRE>
<PRE> * When outputting a B-spline to a GString, it outputs the GString element for a
 * regular spline. That way, other applications will be able to draw the GString
 * mostly correctly. However, all B-spline elements will be preceded by a 
 * GString comment 'B''s''p''l'.:</PRE>
<PRE> *	GSComment(4), 'B','s','p','l',
 *	GSDrawSpline(...), ...</PRE>
<PRE> * The following snippet of code will be used when this application draws a 
 * GString. It will look for the significant comments. When it finds them, it will
 * know that the following GR_DRAW_SPLINE element should actually be treated 
 * differently. */</PRE>
<PRE>	for (	gsr = GrDrawGString(gstate, gstring, 0, 0, GSC_MISC, gse);
		gsr == GSRT_MISC;
		gsr = GrDrawGString(gstate, gstring, 0, 0, GSC_MISC, gse) )
			{byte canonicalBuffer[] = {GR_COMMENT,'B','s','p','l'};
			 byte buffer[20];
			 int eSize;</PRE>
<PRE>			  GrGetGStringElement(gstate, gstring, 
				sizeof(buffer),&amp;buffer, &amp;eSize);</PRE>
<PRE>			 /* First check to see if this is the 
			  * comment we're looking for: */
			if (strncmp(buffer, canonicalBuffer, 5)) {
				 /* Skip ahead to the GrDrawSpline element */
				GrSetGStringPos(gstring, GSSPT_SKIP_1, 0);
				GrGetGStringElement(gstate, gstring, 
					sizeof(buffer), &amp;buffer, &amp;eSize);
				 /* Draw spline using our routine */
				MyDrawBSpline(gstate, buffer+3, 
					(eSize-3)/sizeof(Point))
				 /* Advance GString so kernel won't draw a
				  * B�zier spline over our B-spline. */
				GrSetGStringPos(gstring, GSSPT_SKIP_1, 0) }
		}</PRE>
<P>
The <A NAME="Environment_19.htm_IX_GrParseGString()">
 </A>
<CODE>
GrParseGString()</CODE>
 command calls a callback routine on all elements of a GString which match some criterion. The routine may save information about the elements, draw to a GState, or something completely different. <CODE>
GrParseGString()</CODE>
 takes the following arguments:</P>
<UL>
<LI>
GString to parse.</LI>
<LI>
GState handle. <CODE>
GrParseGString()</CODE>
 itself will do nothing with this handle, and passing a NULL handle is permitted. However, this GState will be passed to the callback routine. If your callback routine will draw, it is thus convenient to pass a properly initialized GState to <CODE>
GrParseGString()</CODE>
 which the callback routine may then draw to.</LI>
<LI>
A record of type <CODE>
GSControl</CODE>
. This will determine which elements will be passed on to the callback routine. If you set GSC_OUTPUT, the callback routine will be called only for those GString elements which draw something. If you set GSC_ONE, the callback routine will be called upon all of the GString elements.</LI>
<LI>
Far pointer to the callback routine itself.</LI>
</UL>
<P>
The callback routine is passed a pointer to the GString element and the handle of the GState that was passed to <CODE>
GrParseGString()</CODE>
.</P>
<HR>
<A NAME="Environment_1a.htm"></A>


<H2 CLASS="sectionTitle">
<A HREF="#index.htm">Graphics Environment</A>: 9 
<A NAME="Environment_1a.htm_69648">
 </A>
Graphics Paths</H2>
<PRE>GrBeginPath(), GrEndPath(), GrCloseSubPath(), GrSetStrokePath(), GrGetPathBounds(), GrTestPointInPath(), GrGetPathPoints(), GrGetPathRegion(), GrGetPath(), GrSetPath(), GrGetPathBoundsDWord(), GrTestPath()</PRE>
<P>
<A NAME="Environment_1a.htm_IX_Paths (graphics)">
 </A>
A <EM>
path</EM>
 is a data structure which describes a route across a graphics space. Normally, applications use the path to specify an arbitrary screen area, defining a path that describe's the area's borders. Like a GString, a path is created by calling an appropriate initiation routine followed by a series of drawing commands. </P>
<P>
Paths don't have to be continuous. An unconnected path is said to be made up of more than one path element.
<IMG SRC="Environment_1a_simplePaths.gif">

</P>
<P>
Paths can be created by taking the intersection or union of two or more paths. In this case, the paths which are combined to make the resulting path are called <EM>
sub-paths</EM>
. 
<IMG SRC="Environment_1a_comboPaths.gif">

</P>
<P>
Paths are normally used to describe regions. However, regions are basically bitmaps, whereas paths are described in terms of the standard coordinate space. Thus, while regions don't scale well at all, it is possible to scale a path perfectly, then use the transformed path to more correctly compute the desired region. If this comparison sounds similar to that between bitmap- and outline- based fonts, it should. The &quot;outline&quot; of an outline-based font character is, in fact, a specialized form of path. </P>
<P>
Paths are also used to describe clipping regions. It is possible to combine any path with a window's clipping region to further restrict the clipping area. Thus it is possible to clip to an ellipse or to a B�zier curve, or even to use text as a clipping region.
<IMG SRC="Environment_1a_clipPaths.gif">

</P>
<P>
When constructing a path, you should keep in mind what it will be used for. If the path is to be filled using the winding rule, it is important that all edges go the correct direction. The winding rule algorithm assumes that the region is described by edges that go around it counterclockwise. Edges going clockwise describe hollows. The odd/even fill rule will work independently of path direction. See <A HREF="../../Graphics/Shapes/Shapes_d.htm#23242">the Drawing Shapes chapter</A> for more information about winding rules.</P><P>
Both the winding and odd/even fill rules demand closed path elements. If any path elements are not filled, the routine will treat them as if they were, connecting the ends of each open path element with a straight line.</P>
<P>
It is also possible to alter an existing path by combining it with another. The new path thus formed preserves both paths. If drawn, both paths will appear. If the path is filled or used as a clipping region, the geode can specify how the regions described by the paths should be combined, whether the intersection or union should be taken. Any number of paths can be combined in this manner.</P>
<P>
<CODE>
GrBeginPath()</CODE>
<A NAME="Environment_1a.htm_IX_GrBeginPath()">
 </A>
 signals that the geode is about to start describing a path. <A NAME="Environment_1a.htm_IX_GrEndPath()">
 </A>
All drawing commands directed at the GState will go into constructing the path until <CODE>
GrEndPath()</CODE>
 is called. <CODE>
GrBeginPath()</CODE>
 is also the routine used to combine a path with an existing path. Calling <CODE>
GrBeginPath()</CODE>
 when already constructing a path signals that further graphics commands should describe a new path to be combined with the existing one. The new path can either replace the existing one or combine to find the intersection or the union.</P>
<P>
<CODE>
GrCloseSubPath()</CODE>
<A NAME="Environment_1a.htm_IX_GrCloseSubPath()">
 </A>
 closes the current path element, adding a straight line segment from the current position to the starting point if necessary.</P>
<P>
 <A NAME="Environment_1a.htm_IX_GrGetPathBounds()">
 </A>
<CODE>
GrGetPathBounds()</CODE>
 returns the bounding coordinates of a rectangle that completely encloses the current path. <A NAME="Environment_1a.htm_IX_GrTestPointInPath()">
 </A>
<CODE>
GrTestPointInPath()</CODE>
 tests whether a passed point falls within the current path. <A NAME="Environment_1a.htm_IX_GrGetPathPoints()">
 </A>
<CODE>
GrGetPathPoints()</CODE>
 returns all the points along a path in the order visited. <A NAME="Environment_1a.htm_IX_GrGetPathRegion()">
 </A>
<CODE>
GrGetPathRegion()</CODE>
 returns the region defined by the path. <A NAME="Environment_1a.htm_IX_GrGetPathBoundsDWord()">
 </A>
<CODE>
GrGetPathBoundsDWord()</CODE>
 returns the bounds of the path and works in a 32-bit graphics space. If you just want to know whether or not a given path exists, then call <A NAME="Environment_1a.htm_IX_GrTestPath()">
 </A>
<CODE>
GrTestPath()</CODE>
, passing the <A NAME="Environment_1a.htm_IX_GetPathType">
 </A>
<CODE>
GetPathType</CODE>
 <A NAME="Environment_1a.htm_IX_GPT_CURRENT">
 </A>
GPT_CURRENT.</P>
<P>
<CODE>
GrSetStrokePath()</CODE>
<A NAME="Environment_1a.htm_IX_GrSetStrokePath()">
 </A>
 replaces the current path with the one that would result from &quot;stroking&quot; (drawing) the current path with the current line attributes. For example, if the current line style is a dotted line, the result will most likely be a set of many skinny regions. At this time, stroke paths cannot be used for clipping purposes. However, geodes can still draw and fill these paths.</P>
<P>
Paths can be drawn or filled using the <CODE>
GrDrawPath()</CODE>
 and <CODE>
GrFillPath()</CODE>
 commands. For more information about these routines, see <A HREF="../../Graphics/Shapes/Shapes_d.htm#23242">the Drawing Shapes chapter</A>.</P><P>
<CODE>
GrGetPath()</CODE>
<A NAME="Environment_1a.htm_IX_GrGetPath()">
 </A>
 retrieves the handle of a block containing the path's data. You may pass this handle to <CODE>
GrSetPath()</CODE>
 and thus copy a path to another GState.</P>
<HR>
<A NAME="Environment_1b.htm"></A>


<H2 CLASS="sectionTitle">
<A HREF="#index.htm">Graphics Environment</A>: 10 
<A NAME="Environment_1b.htm_62266">
 </A>
Working With Video Drivers</H2>
<P>
<A NAME="Environment_1b.htm_IX_Video drivers">
 </A>
The main benefit of the device independence is that the geode writer can issue graphics commands without worrying about the device. Working with the video driver is left to the graphics system.</P>
<P CLASS="subsectionLink">
<A HREF="#Environment_1c.htm">Kernel Routines</A></P>
<P CLASS="subsectionLink">
<A HREF="#Environment_1d.htm">Direct Calls to the Driver</A></P>
<HR>
<A NAME="Environment_1c.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Graphics Environment</A>: 10.1 <A HREF="#Environment_1b.htm">Working With Video Drivers</A>: 
Kernel Routines</H3>
<PRE>GrInvalRect(), GrInvalRectDWord(), GrGrabExclusive(), GrGetExclusive(), GrReleaseExclusive(), GrBitBlt(), GrGetBitmap(), GrGetWinHandle()</PRE>
<P>
Sometimes the geode may want more power over the driver. It can see what device coordinates correspond to a set of standard GEOS coordinates or vice versa.

</P>
<P>
<A NAME="Environment_1c.htm_IX_GrInvalRect()">
 </A>
It is possible to update part of a drawing without exposing the whole window. Calling <CODE>
GrInvalRect()</CODE>
 causes a passed rectangular area to be updated; the area outside the rectangle will be unaffected.<A NAME="Environment_1c.htm_IX_GrInvalRectDWord()">
 </A>
<CODE>
 GrInvalRectDWord()</CODE>
 works the same way, but for large coordinate spaces.</P>
<P>
Programs can also seize exclusive access to a video driver by calling the <CODE>
GrGrabExclusive()</CODE>
<A NAME="Environment_1c.htm_IX_GrGrabExclusive()">
 </A>
 command, which allows only the passed GState to alter what is shown on the screen. This routine is useful for programs such as screen dumps who want to accomplish something concerning the screen without worrying that programs in other threads will change the screen in the meantime.<A NAME="Environment_1c.htm_IX_GrReleaseExclusive()">
 </A>
 <CODE>
GrReleaseExclusive()</CODE>
 ends the exclusive access to the screen so that other GStates can update.</P>
<P>
To find out if the video exclusive is presently grabbed, call <CODE>
GrGetExclusive()</CODE>
<A NAME="Environment_1c.htm_IX_GrGetExclusive()">
 </A>
. This will return the handle of the GState presently in possession of the exclusive, or zero if there is no such GState.</P>
<P>
<CODE>
GrBitBlt()</CODE>
<A NAME="Environment_1c.htm_IX_GrBitBlt()">
 </A>
 is an advanced function used to quickly copy or move data within video memory. Effectively, it can copy or move a rectangular part of the document space to another part of that space--the passed <A NAME="Environment_1c.htm_IX_BLTM_&ldots;">
 </A>
<A NAME="Environment_1c.htm_IX_BLTMode">
 </A>
BLTMode will determine whether the area is copied or moved. This might be used in an arcade game or animation program to move simple pictures around the screen very quickly. Pass this function the source and destination rectangles, and whether you are copying or moving the block. After calling <CODE>
GrBitBlt()</CODE>
, the changes have been made to video memory but have not actually been drawn to the screen. Make sure that the affected areas are redrawn by invalidating the appropriate area. If speed is a concern, and if you're using <CODE>
GrBitBlt()</CODE>
 it probably is, you'll probably want to restrict the clipping area when the drawing is refreshed.</P>
<P>
<CODE>
GrGetBitmap()</CODE>
<A NAME="Environment_1c.htm_IX_GrGetBitmap()">
 </A>
 basically returns a dump of an arbitrary display area. It is an advanced function and should be used with some caution. If asked to dump an area from a GState being displayed to screen, <CODE>
GrGetBitmap()</CODE>
 won't check to see if the dumped area is obscured by another window, and so your dump might include a picture of that other window. However, if you're working with some sort of offscreen bitmap, this function provides a way to look at large portions of it a time.<A NAME="Environment_1c.htm_IX_GrGetPoint()">
 </A>
 Note that to look at smaller areas, you might prefer to use <CODE>
GrGetPoint()</CODE>
, an optimized, easier to use function to find out the color of a pixel.</P>
<P>
At some times, it may prove useful to know what window, if any, is associated with a GState. To find out, call <A NAME="Environment_1c.htm_IX_GrGetWinHandle()">
 </A>
<CODE>
GrGetWinHandle()</CODE>
.</P>
<HR>
<A NAME="Environment_1d.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Graphics Environment</A>: 10.2 <A HREF="#Environment_1b.htm">Working With Video Drivers</A>: 
Direct Calls to the Driver</H3>
<P>
Rarely, a geode may wish to make direct calls to the video driver. In most cases, anything your code might want the video driver to do can be handled better by going through the appropriate graphics routine.<A NAME="Environment_1d.htm_IX_Video drivers">
 </A>


</P>
<HR>
<A NAME="Environment_1e.htm"></A>


<H2 CLASS="sectionTitle">
<A HREF="#index.htm">Graphics Environment</A>: 11 
<A NAME="Environment_1e.htm_83889">
 </A>
Windowing and Clipping</H2>
<P>
Windows are the interface between the graphics commands and the GEOS   user interface. In this section we will discuss some of the graphical mechanisms associated with windows in GEOS. </P>
<P CLASS="subsectionLink">
<A HREF="#Environment_1f.htm">Palettes</A></P>
<P CLASS="subsectionLink">
<A HREF="#Environment_20.htm">Clipping</A></P>
<P CLASS="subsectionLink">
<A HREF="#Environment_21.htm">Signalling Updates</A></P>
<HR>
<A NAME="Environment_1f.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Graphics Environment</A>: 11.1 <A HREF="#Environment_1e.htm">Windowing and Clipping</A>: 
<A NAME="Environment_1f.htm_96724">
 </A>
Palettes</H3>
<P>
Each window has a color palette associated with it. For more information about manipulating palettes, see <A HREF="../../Graphics/Shapes/Shapes_11.htm#84719">the Drawing Shapes chapter</A>. The system will use the palette of whatever window is active. As a result, if two windows have different palettes, when one window is active, the other's colors will be distorted.</P><HR>
<A NAME="Environment_20.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Graphics Environment</A>: 11.2 <A HREF="#Environment_1e.htm">Windowing and Clipping</A>: 
Clipping</H3>
<PRE>GrSetClipPath(), GrSetClipRect(), GrGetClipRegion(), GrTestRectInMask(), GrSetWinClipRect(), GrGetMaskBounds(), GrGetMaskBoundsDWord(), GrGetWinBounds(), GrGetWinBoundsDWord()</PRE>
<P>
<A NAME="Environment_20.htm_IX_Clipping">
 </A>
The graphics system provides some routines which allow geodes to work together with the windowing system to control clipping. A window's clipping region, you will recall, is that area of the window that must be redrawn. It corresponds to that area of the graphics space which is visible inside the window and not obscured by another window. The area outside the clipping region is supposed to be that area that doesn't need to be redrawn. Geodes which are certain that part of their graphics space doesn't need to be (or shouldn't be) redrawn can restrict their clipping region to exclude this portion.

</P>
<P>
Restricting the clipping region can lead to quicker redraws, since the graphics system doesn't have as much to redraw. Arcade games in which most of the action only takes place in one or two areas of the display can restrict their clipping region to speed redraws in the smaller, active areas. Also, the clip region can be used as a sort of stencil.</P>
<P>
The clip region is defined by a path which describes the boundaries of the region. A window typically begins with a rectangular clip region. If it is partially obscured by other windows, this rectangle will have &quot;bites&quot; taken out of it. This is done using normal path routines used for combining paths. The clipping path of a newly obscured window is determined by computing its old clipping path with that of the obscuring window.</P>
<P>
Since any number of paths may be combined, it is a simple matter for the graphics system to combine a window's clipping path with a geode's path chosen to restrict the clipping region. Thus the geode can define its restricted clipping area without knowing anything about the window's present status.</P>
<P>
<CODE>
GrSetClipPath()</CODE>
<A NAME="Environment_20.htm_IX_GrSetClipPath()">
 </A>
 sets the geode-defined path to use when restricting the window's clip path.<A NAME="Environment_20.htm_IX_GrSetClipRect()">
 </A>
 <CODE>
GrSetClipRect()</CODE>
 is an optimization of <CODE>
GrSetClipPath()</CODE>
 to handle the most common case in which the new path element is a rectangle. </P>
<P>
<CODE>
GrGetClipRegion()</CODE>
<A NAME="Environment_20.htm_IX_GrGetClipRegion()">
 </A>
 returns the <CODE>
Region</CODE>
 data structure corresponding to the current clip path. <A NAME="Environment_20.htm_IX_GrGetMaskBounds()">
 </A>
<CODE>
GrGetMaskBounds()</CODE>
 and <CODE>
GrGetMaskBoundsDWord()</CODE>
<A NAME="Environment_20.htm_IX_GrGetMaskBoundsDWord()">
 </A>
 return the bounds of the current clipping path.To find out whether there is a clip path at all, just call <CODE>
GrTestPath()</CODE>
 and pass <A NAME="Environment_20.htm_IX_GPT_CLIP">
 </A>
GPT_CLIP.</P>
<P>
<CODE>
GrTestRectInMask()</CODE>
<A NAME="Environment_20.htm_IX_GrTestRectInMask()">
 </A>
 determines whether a rectangular area lies fully, partially, or not at all within the clipping area. This routine is useful for optimizing redraws.</P>
<P>
<CODE>
GrSetWinClipRect()</CODE>
<A NAME="Environment_20.htm_IX_GrSetWinClipRect()">
 </A>
 and <A NAME="Environment_20.htm_IX_GrSetWinClipPath()">
 </A>
<CODE>
GrSetWinClipPath()</CODE>
 set the clipping path associated with the window; you should never have occasion to use it. <CODE>
GrGetWinBounds() </CODE>
<A NAME="Environment_20.htm_IX_GrGetWinBounds()">
 </A>
and <CODE>
GrGetWinBoundsDWord()</CODE>
<A NAME="Environment_20.htm_IX_GrGetWinBoundsDWord()">
 </A>
 return the bounds of the window clipping path. To find out whether there is a window clipping path at all, call <A NAME="Environment_20.htm_IX_GrTestPath():clipping paths">
 </A>
<CODE>
GrTestPath()</CODE>
 and pass <A NAME="Environment_20.htm_IX_GPT_WIN_CLIP">
 </A>
GPT_WIN_CLIP.</P>
<HR>
<A NAME="Environment_21.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Graphics Environment</A>: 11.3 <A HREF="#Environment_1e.htm">Windowing and Clipping</A>: 
Signalling Updates</H3>
<PRE>GrBeginUpdate(), GrEndUpdate()</PRE>
<P>
<A NAME="Environment_21.htm_IX_GrBeginUpdate()">
 </A>
The kernel provides two messages by which the geode may signal that it is updating the contents of a window. When updating a region (as when handling a <CODE>
MSG_META_EXPOSED</CODE>
), the geode should call<CODE>
 GrBeginUpdate()</CODE>
 after creating the GState,<A NAME="Environment_21.htm_IX_GrEndUpdate()">
 </A>
 and call <CODE>
GrEndUpdate()</CODE>
 before destroying the GState.

</P>
<P>
This causes the system to store the GState for future comparisons during clipping region calculation. If you don't call these functions, the clipping region is likely to be wrong for this and other updates. Default system MSG_META_EXPOSED handlers call these routines.</P>
<P>
Note that you only need call these routines when performing a requested update; if you are drawing to a window without being asked to do so, you need not call these routines. </P>
<HR>
This document is a single-page version of a <A HREF="index.htm">a multi-page document</A>, suitable for easy printing.
</BODY>
</HTML>
