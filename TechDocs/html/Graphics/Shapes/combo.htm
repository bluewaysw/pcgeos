<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD>
<!-- This page was automatically generated from a bunch of smaller pages. -->
<META NAME="copyright" CONTENT="Copyright GEOWORKS">
<LINK REL="STYLESHEET" HREF="../../docHelpers/style.css">
<LINK REV="MADE" HREF="mailto:doc-feedback@geoworks.com">
<TITLE>Drawing Graphics</TITLE>
</HEAD>
<BODY BGCOLOR="#ffffdf">
This document is a single-page version of a <A HREF="index.htm">a multi-page document</A>, suitable for easy printing.
<A NAME="index.htm"></A>



<H1 CLASS="chapterTitle">

<A NAME="index.htm_92351">
 </A>
Drawing Graphics

</H1>
<P>
<A NAME="index.htm_IX_Graphics">
 </A>
This chapter describes the commands used to draw things on a display. <A HREF="../../Graphics/Environment/combo.htm">the Graphics Environment chapter</A>, explains how to set up the display necessary to use these commands.</P><P>
You must have read the previous chapter; in particular, you should be familiar with GStates. To use certain commands, you should also be familiar with the GEOS fixed point number formats.

</P>
<P CLASS="sectionlinks">
<STRONG>
&nbsp;&nbsp;<A HREF="#Shapes_1.htm">1 Drawing Goals</A><BR>
&nbsp;&nbsp;<A HREF="#Shapes_2.htm">2 Shapes</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Shapes_3.htm">2.1 Dots</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Shapes_4.htm">2.2 Lines</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Shapes_5.htm">2.3 Rectangles</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Shapes_6.htm">2.4 Ellipses</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Shapes_7.htm">2.5 Elliptical Arcs</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Shapes_8.htm">2.6 Three-Point Arcs</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Shapes_9.htm">2.7 Rounded Rectangles</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Shapes_a.htm">2.8 Polylines and Polygons</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Shapes_b.htm">2.9 B�zier Curves and Splines</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Shapes_c.htm">2.10 Drawing Bitmaps</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Shapes_d.htm">2.11 Paths</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Shapes_e.htm">2.12 Regions</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Shapes_f.htm">2.13 Text</A><BR>
&nbsp;&nbsp;<A HREF="#Shapes_10.htm">3 Shape Attributes</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Shapes_11.htm">3.1 Color</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Shapes_12.htm">3.2 Patterns and Hatching</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Shapes_13.htm">3.3 Mix Mode</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Shapes_14.htm">3.4 Masks</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Shapes_15.htm">3.5 Line-Specific Attributes</A><BR>
</STRONG>
</P> <!-- end of sectionlinks blob -->

<HR>
<A NAME="Shapes_1.htm"></A>


<H2 CLASS="sectionTitle">
<A HREF="#index.htm">Drawing Graphics</A>: 1 
Drawing Goals</H2>
<P>
The graphics system has a set of graphic commands capable of describing anything that might ever be drawn; at the same time, the command set should not be overwhelming. Common routines must be heavily optimized: if the line or text drawing routines are slow, the system will be slowed by a similar amount. Commands for drawing the various shapes must exist for all the contexts discussed in the previous chapter. In GEOS, you use the same graphics commands whether you are drawing to a display, describing a GString (which can be sent to a printer), drawing to a bitmap, or describing a path. This simplifies graphics programming a great deal.</P>
<HR>
<A NAME="Shapes_2.htm"></A>


<H2 CLASS="sectionTitle">
<A HREF="#index.htm">Drawing Graphics</A>: 2 
Shapes</H2>
<P>
<A NAME="Shapes_2.htm_24809">
 </A>
Depending on how much experience you have with the GEOS graphics system, you may have some idea already about what sorts of shapes can be drawn and the ways to draw them. Most of these commands have names like <CODE>
GrDrawShape()</CODE>
 or<CODE>
 GrFillShape()</CODE>
 (e.g. <CODE>
GrDrawRect()</CODE>
, <CODE>
GrFillEllipse()</CODE>
). Normally, a command of the form <CODE>
GrDrawShape()</CODE>
 draws the outline of a shape, while <CODE>
GrFillShape()</CODE>
 fills in the interior of the shape. Commands with names like <CODE>
GrSetAttribute()</CODE>
 (e.g. <CODE>
GrSetAreaColor()</CODE>
) change the color, fill pattern, and other attributes of shapes to be drawn. Most of these commands are passed a GState. The drawing commands are also passed coordinates at which to draw.</P>
<P>
For many of these commands, there are GString opcodes which represent the command in a GString. Also, the arguments used when drawing these shapes often correspond to instance data specific to the Graphic Object which draws that shape.</P>
<P>
Most of these routines work with standard coordinates, measured in typographer's points. For geodes that need to make drawings which are precise to a fraction of a point, four routines have been set up to use WWFixed coordinates, and are thus accurate to a fraction of a point. These routines are <CODE>
GrDrawRelLineTo()</CODE>
, <CODE>
GrRelMoveTo()</CODE>
, <CODE>
GrDrawRelCurveTo()</CODE>
, and <CODE>
GrDrawRelArc3PointTo()</CODE>
. Geodes may use these routines to draw the outline of any conceivable two-dimensional shape. To create a precise, filled shape, use these routines to describe a path and then fill the path.</P>
<P CLASS="subsectionLink">
<A HREF="#Shapes_3.htm">Dots</A></P>
<P CLASS="subsectionLink">
<A HREF="#Shapes_4.htm">Lines</A></P>
<P CLASS="subsectionLink">
<A HREF="#Shapes_5.htm">Rectangles</A></P>
<P CLASS="subsectionLink">
<A HREF="#Shapes_6.htm">Ellipses</A></P>
<P CLASS="subsectionLink">
<A HREF="#Shapes_7.htm">Elliptical Arcs</A></P>
<P CLASS="subsectionLink">
<A HREF="#Shapes_8.htm">Three-Point Arcs</A></P>
<P CLASS="subsectionLink">
<A HREF="#Shapes_9.htm">Rounded Rectangles</A></P>
<P CLASS="subsectionLink">
<A HREF="#Shapes_a.htm">Polylines and Polygons</A></P>
<P CLASS="subsectionLink">
<A HREF="#Shapes_b.htm">B�zier Curves and Splines</A></P>
<P CLASS="subsectionLink">
<A HREF="#Shapes_c.htm">Drawing Bitmaps</A></P>
<P CLASS="subsectionLink">
<A HREF="#Shapes_d.htm">Paths</A></P>
<P CLASS="subsectionLink">
<A HREF="#Shapes_e.htm">Regions</A></P>
<P CLASS="subsectionLink">
<A HREF="#Shapes_f.htm">Text</A></P>
<HR>
<A NAME="Shapes_3.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Drawing Graphics</A>: 2.1 <A HREF="#Shapes_2.htm">Shapes</A>: 
Dots</H3>
<PRE>GrDrawPoint(), GrDrawPointAtCP()</PRE>
<P>
A point is the smallest thing drawable; it will always appear as a single pixel. The point's position is defined by a standard coordinate pair. Points are drawn using line attributes. After drawing a point, the pen position will be at the point's coordinates.
<IMG SRC="Shapes_3_point.gif">

</P>
<P>
<CODE>
GrDrawPoint()</CODE>
<A NAME="Shapes_3.htm_IX_GrDrawPoint()">
 </A>
 draws a point at the passed coordinate pair. <CODE>
GrDrawPointAtCP()</CODE>
<A NAME="Shapes_3.htm_IX_GrDrawPointAtCP()">
 </A>
 draws a point at the current pen position.</P>
<HR>
<A NAME="Shapes_4.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Drawing Graphics</A>: 2.2 <A HREF="#Shapes_2.htm">Shapes</A>: 
Lines</H3>
<PRE>GrDrawLine(), GrDrawLineTo(), GrDrawRelLineTo(), GrDrawHLine(), GrDrawHLineTo(), GrDrawVLine(), GrDrawVLineTo()</PRE>
<P>
<A NAME="Shapes_4.htm_IX_Lines (graphics)">
 </A>
A line is simply a line segment that connects two points. Lines are drawn using the current line attributes stored with the GState. The new pen position becomes the last passed coordinate pair.
<IMG SRC="Shapes_4_line.gif">

</P>
<P>
<CODE>
GrDrawLine()</CODE>
<A NAME="Shapes_4.htm_IX_GrDrawLine()">
 </A>
 draws a line between points.<A NAME="Shapes_4.htm_IX_GrDrawLineTo()">
 </A>
 <CODE>
GrDrawLineTo()</CODE>
 draws a line from the current pen position to the passed point.<A NAME="Shapes_4.htm_IX_GrDrawHLine()">
 </A>
 <CODE>
GrDrawHLine()</CODE>
 draws a horizontal line between two points. These two points share the same <EM>
y</EM>
 coordinate (thus the line is horizontal).<A NAME="Shapes_4.htm_IX_GrDrawHLineTo()">
 </A>
 <CODE>
GrDrawHLineTo()</CODE>
 draws a horizontal line from the current pen position to a passed <EM>
x</EM>
 coordinate. <CODE>
GrDrawVLine()</CODE>
<A NAME="Shapes_4.htm_IX_GrDrawVLine()">
 </A>
 draws a vertical line between two points which share a common <EM>
x</EM>
 coordinate.<A NAME="Shapes_4.htm_IX_GrDrawVLineTo()">
 </A>
 <CODE>
GrDrawVLineTo()</CODE>
 draws a vertical line from the current pen position to a passed <EM>
y</EM>
 coordinate. The <CODE>
GrDrawH...()</CODE>
 and <CODE>
GrDrawV...()</CODE>
 routines save space compared to <CODE>
GrDrawLine()</CODE>
 or <CODE>
GrDrawLineTo()</CODE>
, since fewer coordinates are necessary to define the line.</P>
<P>
<CODE>
GrDrawRelLineTo()</CODE>
<A NAME="Shapes_4.htm_IX_GrDrawRelLineTo()">
 </A>
 draws a line from the current pen position to the point at the specified <EM>
x</EM>
 and <EM>
y</EM>
 offset from the starting position. This routine takes very precise coordinates, and is useful for describing paths.</P>
<HR>
<A NAME="Shapes_5.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Drawing Graphics</A>: 2.3 <A HREF="#Shapes_2.htm">Shapes</A>: 
Rectangles</H3>
<PRE>GrDrawRect(), GrDrawRectTo(), GrFillRect(), GrFillRectTo()</PRE>
<P>
<A NAME="Shapes_5.htm_IX_Rectangles">
 </A>
Rectangles are defined by four coordinates which can be thought of as either defining the rectangle's left, top, right, and bottom bounds or as specifying two opposite corners of the rectangle.
<IMG SRC="Shapes_5_rect.gif">

</P>
<P>
<CODE>
GrDrawRect()</CODE>
<A NAME="Shapes_5.htm_IX_GrDrawRect()">
 </A>
 draws the outline of a rectangle using the passed coordinates.<A NAME="Shapes_5.htm_IX_GrDrawRectTo()">
 </A>
 <CODE>
GrDrawRectTo()</CODE>
 draws the outline of a rectangle using the current pen position as one of the defining points; the pen position is unchanged by this operation. These functions draw the rectangle outline using the current line attributes.<A NAME="Shapes_5.htm_IX_GrFillRect()">
 </A>
 <CODE>
GrFillRect()</CODE>
 draws a filled rectangle defined by the passed coordinates.<A NAME="Shapes_5.htm_IX_GrFillRectTo()">
 </A>
 <CODE>
GrFillRectTo()</CODE>
 fills a rectangle of which the pen position is one corner. <CODE>
GrFillRect()</CODE>
 and <CODE>
GrFillRectTo()</CODE>
 use the GState's area attributes. They do not draw a border around the rectangle; if you want a bordered rectangle, call <CODE>
GrFillRect()</CODE>
 and follow it with <CODE>
GrDrawRect()</CODE>
. Note that if the order of these operations if reversed, the fill may obscure the draw.</P>
<HR>
<A NAME="Shapes_6.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Drawing Graphics</A>: 2.4 <A HREF="#Shapes_2.htm">Shapes</A>: 
Ellipses</H3>
<PRE>GrDrawEllipse(), GrFillEllipse()</PRE>
<P>
<A NAME="Shapes_6.htm_IX_Ellipses">
 </A>
Ellipses are defined by their bounding rectangles. The pen position becomes the first coordinate pair passed. Circles are ellipses with heights equal to their widths.</P>
<P>
<CODE>
GrDrawEllipse()</CODE>
<A NAME="Shapes_6.htm_IX_GrDrawEllipse()">
 </A>
 draws the outline of an ellipse using the current line drawing attributes.<A NAME="Shapes_6.htm_IX_GrFillEllipse()">
 </A>
 <CODE>
GrFillEllipse()</CODE>
 fills the ellipse's area using the current area attributes.
<IMG SRC="Shapes_6_ellipse.gif">

</P>
<HR>
<A NAME="Shapes_7.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Drawing Graphics</A>: 2.5 <A HREF="#Shapes_2.htm">Shapes</A>: 
Elliptical Arcs</H3>
<PRE>GrDrawArc(), GrFillArc()</PRE>
<P>
<A NAME="Shapes_7.htm_IX_Arcs">
 </A>
An arc is a partial ellipse. An arc is defined in terms of its base ellipse, the angle at which to start drawing the arc, and the angle at which to stop drawing. Angles are counted in degrees counter-clockwise with 0� corresponding to the positive <EM>
x</EM>
 axis (i.e., &quot;3 o'clock&quot;).</P>
<P>
<CODE>
GrDrawArc()</CODE>
<A NAME="Shapes_7.htm_IX_GrDrawArc()">
 </A>
 draws the outline of an elliptical arc, a curved line. It does so using the GState's current line attributes.<A NAME="Shapes_7.htm_IX_GrFillArc()">
 </A>
 <CODE>
GrFillArc()</CODE>
 fills the arc. There are two ways to fill an arc: you can fill in the wedge described by the arc, or you can fill just the region between the arc and its chord; set the style with an <A NAME="Shapes_7.htm_IX_ArcCloseType">
 </A>
<CODE>
ArcCloseType</CODE>
 value. 
<IMG SRC="Shapes_7_ellArc.gif">

</P>
<HR>
<A NAME="Shapes_8.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Drawing Graphics</A>: 2.6 <A HREF="#Shapes_2.htm">Shapes</A>: 
Three-Point Arcs</H3>
<PRE>GrDrawArc3Point(), GrDrawArc3PointTo(), GrFillArc3Point(), GrFillArc3PointTo(), GrDrawRelArc3PointTo()</PRE>
<P>
The graphics system allows another way to specify arcs. Given two endpoints and one arbitrary point, there is a unique circular arc which has those endpoints and passes through that arbitrary point. The closer the arbitrary point is to the line connecting the endpoints, the shallower the described arc.
<IMG SRC="Shapes_7_3ptArc.gif">

</P>
<P>
<CODE>
GrDrawArc3Point()</CODE>
<A NAME="Shapes_8.htm_IX_GrDrawArc3Point()">
 </A>
 draws the three-point arc corresponding to the passed points. The second endpoint passed becomes the new pen position. <CODE>
GrDrawArc3PointTo()</CODE>
<A NAME="Shapes_8.htm_IX_GrDrawArc3PointTo()">
 </A>
 draws a three-point arc using the present pen position as one of the endpoints; the other endpoint becomes the new pen position.<A NAME="Shapes_8.htm_IX_GrFillArc3Point()">
 </A>
 <CODE>
GrFillArc3Point()</CODE>
 fills a three-point arc.<A NAME="Shapes_8.htm_IX_GrFillArc3PointTo()">
 </A>
 <CODE>
GrFillArc3PointTo()</CODE>
 fills an arc that has the present pen position as an endpoint.</P>
<P>
The<A NAME="Shapes_8.htm_IX_GrDrawRelArc3PointTo()">
 </A>
 <CODE>
GrDrawRelArc3PointTo() </CODE>
routine draws a three-point arc where the pen position is the first point and the other two points are specified as offsets from that position. This routine takes WWFixed coordinates for precision drawing. </P>
<P>
One time when programmers might especially want to use three point arcs is in the construction of paths. An important consideration when constructing paths is making sure that the various segments of the path are connected; that is, that they share endpoints. When specifying elliptical arcs, the endpoints are never explicitly defined. Thus, it is ambiguous in some cases whether an arc is supposed to be connected to something else. Because three-point arcs include their endpoints with their definition, there is no such ambiguity.
<IMG SRC="Shapes_7_3ptArcInPath.gif">

</P>
<HR>
<A NAME="Shapes_9.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Drawing Graphics</A>: 2.7 <A HREF="#Shapes_2.htm">Shapes</A>: 
Rounded Rectangles</H3>
<PRE>GrDrawRoundRect(), GrDrawRoundRectTo(), GrFillRoundRect(), GrFillRoundRectTo()</PRE>
<P>
Rounded rectangles are defined in terms of their bounding rectangle and the radius of the circle used to compute the rounded corners. The smaller the corner circle is, the sharper the rectangle's corners will be. A larger corner circle results in a more rounded corner with more area taken away.
<IMG SRC="Shapes_9_roundRect.gif">

</P>
<P>
<CODE>
GrDrawRoundRect()</CODE>
<A NAME="Shapes_9.htm_IX_GrDrawRoundRect()">
 </A>
 draws the outline of a rounded rectangle with the passed bounding rectangle and corner circle dimensions. The drawing position is set to the first passed coordinate pair.<A NAME="Shapes_9.htm_IX_GrDrawRoundRectTo()">
 </A>
 <CODE>
GrDrawRoundRectTo()</CODE>
 draws the outline of the rounded rectangle for which the current position is one corner of the bounding rectangle. The current position is unaffected by this operation. <CODE>
GrDrawRoundRect()</CODE>
 and <CODE>
GrDrawRoundRectTo()</CODE>
 use the current line drawing attributes.<A NAME="Shapes_9.htm_IX_GrFillRoundRect()">
 </A>
 <CODE>
GrFillRoundRect()</CODE>
 fills a rounded rectangle with passed bounding rectangle and corner radius using the current area attributes.<A NAME="Shapes_9.htm_IX_GrFillRoundRectTo()">
 </A>
 <CODE>
GrFillRoundRectTo()</CODE>
 fills a rounded rectangle that has the current position as one corner of the bounding rectangle.</P>
<HR>
<A NAME="Shapes_a.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Drawing Graphics</A>: 2.8 <A HREF="#Shapes_2.htm">Shapes</A>: 
<A NAME="Shapes_a.htm_94543">
 </A>
Polylines and Polygons</H3>
<PRE>GrDrawPolyline(), GrDrawPolygon(), GrFillPolygon(), GrBrushPolyline(), GrTestPointInPolygon()</PRE>
<P>
<A NAME="Shapes_a.htm_IX_Polygons">
 </A>
<A NAME="Shapes_a.htm_IX_Polylines">
 </A>
Polylines and polygons are drawings made up of chains of connected lines. They are defined as lists of points, or corners. After drawing a polyline or polygon, the pen position will be at the last point of the shape.
<IMG SRC="Shapes_a_polygons.gif">

</P>
<P>
<CODE>
GrDrawPolyline()</CODE>
<A NAME="Shapes_a.htm_IX_GrDrawPolyline()">
 </A>
 draws a polyline using the current line attributes. <CODE>
GrDrawPolygon()</CODE>
<A NAME="Shapes_a.htm_IX_GrDrawPolygon()">
 </A>
 draws a polygon using the current line attributes. </P>
<P>
To draw a closed figure with <CODE>
GrDrawPolyline()</CODE>
, the first and last point must have the same coordinates. <CODE>
GrDrawPolygon()</CODE>
 draws figures as closed automatically; having the same beginning and ending point is unnecessary.</P>
<P>
<CODE>
GrFillPolygon()</CODE>
<A NAME="Shapes_a.htm_IX_GrFillPolygon()">
 </A>
 fills the interior of a polygon. It does so using the current area attributes. It also uses a fill rule, describing how the polygon should be filled. The odd/even fill rule decides whether a point is within a polygon by seeing how many times a ray drawn from the point to the exterior of the polygon crosses an edge of that polygon. If the result is odd, the point is considered to be in the interior and is filled. If the result is even, the point is outside the polygon and is left alone. The winding rule works in a similar manner, but whenever the ray crosses an edge, the rule looks at the direction of that edge: if it crosses the ray left to right, an accumulator is incremented; if it crosses the ray right to left, the accumulator is decremented. Those points for which the ray's accumulator is non-zero are considered inside the region.</P>
<P>
<CODE>
GrBrushPolyline()</CODE>
<A NAME="Shapes_a.htm_IX_GrBrushPolyline()">
 </A>
 is an optimized routine. It provides a fast, simple way to draw thick polylines. Instead of specifying a line width in points, the caller passes the dimensions of a rectangle of pixels. This rectangle will be used as a sort of brush, dragged along the course of the polyline. The result is a polyline drawn very quickly. However, this function is not display-independent, and is therefore not WYSIWYG. Because the rectangle dimensions are specified in pixels instead of points, the polyline will be thicker or thinner depending on the display's resolution. In the system software, this routine provides the &quot;ink&quot; feedback for pen-based systems, where speed is a top priority.</P>
<P>
To find out whether a given point falls within a polygon, call <CODE>
GrTestPointInPolygon()</CODE>
<A NAME="Shapes_a.htm_IX_GrTestPointInPolygon()">
 </A>
.</P>
<HR>
<A NAME="Shapes_b.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Drawing Graphics</A>: 2.9 <A HREF="#Shapes_2.htm">Shapes</A>: 
B�zier Curves and Splines</H3>
<PRE>GrDrawCurve(), GrDrawCurveTo(), GrDrawSpline(), GrDrawSplineTo(), GrDrawRelCurveTo()</PRE>
<P>
<A NAME="Shapes_b.htm_IX_Splines">
 </A>
<A NAME="Shapes_b.htm_IX_Be zier curves">
 </A>
B�zier curves are mathematical constructs which provide a cheap and easy way to define smooth curves in a manner that computers can understand. There are other ways to define curves to computers, but the B�zier was chosen for the GEOS kernel because it is used in many standard font description formats. Splines, as implemented in GEOS, are created by drawing curves in sequence.
<IMG SRC="Shapes_b_bCurves.gif">

</P>
<P>
B�zier curves are defined in terms of four points. Two of these points are the endpoints, known as anchor points. The other two points are known as control points, one associated with each anchor point. The curve extends from anchor point to anchor point. The line between an anchor point and its control point determines the slope, or derivative, of the curve at the anchor point. The further the control point is from the anchor point, the further the curve wants to go along the straight line before curving off towards the other anchor point. A control point at zero distance from its anchor point won't affect the curve; if both control points are at zero distance from their anchors, the result will be a straight line segment.</P>
<P>
<CODE>
GrDrawCurve()</CODE>
<A NAME="Shapes_b.htm_IX_GrDrawCurve()">
 </A>
 draws a B�zier curve. It takes four points as arguments, using the first and last as anchor points and the middle two as control points. <CODE>
GrDrawCurveTo()</CODE>
<A NAME="Shapes_b.htm_IX_GrDrawCurveTo()">
 </A>
 draws a curve but uses the current pen position as the first anchor point, setting the pen position to the second anchor point after drawing. </P>
<P>
It would be possible to draw splines by drawing a number of curves which had common endpoints, but the graphics system provides the <CODE>
GrDrawSpline()</CODE>
<A NAME="Shapes_b.htm_IX_GrDrawSpline()">
 </A>
 routine by which a spline with an arbitrary number of spline segments may be drawn with one call. <A NAME="Shapes_b.htm_IX_GrDrawSplineTo()">
 </A>
<CODE>
GrDrawSplineTo()</CODE>
 draws a spline with the current position as the first anchor point. The spline drawing routines require the application to set up an array of points. When calling <CODE>
GrDrawSpline()</CODE>
, these points should be in the order: anchor, control, control, anchor, control, control,..., anchor. The total number of points should be equal to 3n+1, where n is equal to the number of spline segments. Since <CODE>
GrDrawSplineTo()</CODE>
 uses the current position as the first anchor point, for this function the array should start with the first control point, and there should be 3n points passed.

</P>
<P>
For most programmers, that's probably enough to know. Those programmers who want to know more and don't mind a bit of math may feel free to continue this section.
<IMG SRC="Shapes_b_smoothCurve.gif">

</P>
<P>
A curve is defined in terms of four points. There is a formula to determine the coordinates of all points on a spline in terms of these four points. The formula uses two parameterized cubic equations. These equations determine the x and y coordinates of a point on the curve. By finding the points corresponding to various parameters, it is possible to approximate the spline as closely as necessary. See below for the equations.</P>
<P>
Splines may be created by drawing curves which share endpoints. Given an anchor point which two curves of a spline share, if the control point of one lies in the exact opposite direction of the other control point, the resulting spline will be smooth. If the control points are not only in the exact opposite directions but are also the same distance from the anchor point, then not only will the resulting spline be smooth, but its derivative will be smooth as well. </P>
<P>
We call smooth splines with smooth derivatives &quot;very smooth,&quot; and this condition is analogous to C'
 continuity in functions. Smooth splines with non-smooth derivatives are called &quot;semi smooth&quot;, analogous to G' continuity.
<IMG SRC="Shapes_b_bezeirEqns.gif">

</P>
<HR>
<A NAME="Shapes_c.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Drawing Graphics</A>: 2.10 <A HREF="#Shapes_2.htm">Shapes</A>: 
<A NAME="Shapes_c.htm_60826">
 </A>
Drawing Bitmaps</H3>
<PRE>GrDrawBitmap(), GrDrawBitmapAtCP, GrFillBitmap(), GrFillBitmapAtCP(), GrDrawHugeBitmap(), GrDrawHugeBitmapAtCP(), GrDrawImage()</PRE>
<P>
<A NAME="Shapes_c.htm_IX_Bitmaps">
 </A>
In this section only drawing bitmaps will be discussed. For information on creating and modifying bitmaps, see <A HREF="../../Graphics/Environment/Environment_11.htm#30652">the Graphics Environment chapter</A>.</P><P>
<CODE>
GrDrawBitmap()</CODE>
<A NAME="Shapes_c.htm_IX_GrDrawBitmap()">
 </A>
 draws a bitmap. This routine is very versatile. It can draw simple and complex bitmaps. It can draw compacted or uncompacted bitmaps, can use a bitmap-specific palette, handles strange resolutions intelligently, and generally does the right thing. If you're working with a large bitmap and want to manage its storage, you may provide a routine to pass in part of the bitmap at a time. If the bitmap is stored in a huge array (true of all bitmaps created with <CODE>
GrCreateBitmap()</CODE>
) use <CODE>
GrDrawHugeBitmap()</CODE>
 instead of <CODE>
GrDrawBitmap()</CODE>
, and it will manage memory for you. <A NAME="Shapes_c.htm_IX_GrDrawBitmapAtCP()">
 </A>
<CODE>
GrDrawBitmapAtCP()</CODE>
 draws a bitmap at the current position. 
<IMG SRC="Shapes_c_bitmap.gif">

</P>
<P>
If you just want to draw a monochrome bitmap, consider using the <CODE>
GrFillBitmap()</CODE>
<A NAME="Shapes_c.htm_IX_GrFillBitmap()">
 </A>
 command. This routine treats the bitmap like a mask, coloring the &quot;on&quot; pixels with the present area color, and leaving the &quot;off&quot; pixels alone so that whatever is underneath the bitmap can show through. This routine is heavily optimized and very fast. <A NAME="Shapes_c.htm_IX_GrFillBitmapAtCP()">
 </A>
<CODE>
GrFillBitmapAtCP()</CODE>
 works the same way, filling the bitmap at the current position.</P>
<P>
Use <A NAME="Shapes_c.htm_IX_GrDrawHugeBitmap()">
 </A>
<CODE>
GrDrawHugeBitmap()</CODE>
 to draw a bitmap that has been stored in a HugeArray data structure. Remember that any bitmaps created by <CODE>
GrCreateBitmap()</CODE>
 are stored in a <CODE>
HugeArray</CODE>
. <CODE>
GrDrawHugeBitmap()</CODE>
 will automatically take care of memory management. <CODE>
GrDrawHugeBitmapAtCP()</CODE>
<A NAME="Shapes_c.htm_IX_GrDrawHugeBitmapAtCP()">
 </A>
 works the same way, drawing the bitmap at the current position. <A NAME="Shapes_c.htm_IX_GrFillHugeBitmap()">
 </A>
<CODE>
GrFillHugeBitmap()</CODE>
 and <CODE>
GrFillHugeBitmapAtCP()</CODE>
<A NAME="Shapes_c.htm_IX_GrFillHugeBitmapAtCP()">
 </A>
 fill huge bitmaps.
<IMG SRC="Shapes_c_GrDrawImage.gif">

</P>
<P>
<CODE>
GrDrawImage()</CODE>
<A NAME="Shapes_c.htm_IX_GrDrawImage()">
 </A>
 is less adaptable but faster than <CODE>
GrDrawBitmap()</CODE>
. <CODE>
GrDrawImage()</CODE>
 has its own kind of scaling which doesn't work in the standard GEOS fashion. This routine ignores the resolutions of both device and bitmap and displays the bitmap so that each pixel of the bitmap corresponds to one pixel of the display. If the coordinate system has been scaled or rotated, <CODE>
GrDrawImage()</CODE>
 will ignore the scale and rotation when drawing the bitmap. The bitmap may be magnified, but this is not quite the same as normal scaling: The bitmap's resolution is still ignored, but each pixel of the bitmap will receive a square of pixels on the display. <CODE>
GrDrawHugeImage()</CODE>
<A NAME="Shapes_c.htm_IX_GrDrawHugeImage()">
 </A>
 draws the image of a bitmap stored in a <CODE>
HugeArray</CODE>
.</P>
<P>
<A NAME="Shapes_c.htm_IX_IF_&ldots;  (ImageFlags)">
 </A>
<A NAME="Shapes_c.htm_IX_ImageFlags">
 </A>
The image-drawing routines take an <CODE>
ImageFlags</CODE>
 structure which holds a flag to specify whether borders should be drawn between the pixels of the bitmap and a bit size field which specifies the magnification to use.<A NAME="Shapes_c.htm_marker=255604">
 </A>
</P>
<HR>
<A NAME="Shapes_d.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Drawing Graphics</A>: 2.11 <A HREF="#Shapes_2.htm">Shapes</A>: 
<A NAME="Shapes_d.htm_23242">
 </A>
Paths</H3>
<PRE>GrDrawPath(), GrFillPath()</PRE>
<P>
<A NAME="Shapes_d.htm_IX_Paths (graphics)">
 </A>
<IMG SRC="Shapes_d_paths.gif">

</P>
<P>
<CODE>
GrDrawPath()</CODE>
<A NAME="Shapes_d.htm_IX_GrDrawPath()">
 </A>
 draws a path using the current line attributes. <CODE>
GrFillPath()</CODE>
<A NAME="Shapes_d.htm_IX_GrFillPath()">
 </A>
 fills a path using the current area attributes. <CODE>
GrFillPath()</CODE>
 can fill the path using either an odd/even or winding fill rule. If the path is to be filled using the winding fill rule, the path must have been defined so that the segments forming the border of each region go around the region so that the interior of the region is to the left. That is, on convex parts of the border, edges should be in the counterclockwise direction. On concave parts of the border edges should go clockwise. For an illustration of a path following this rule, see the figure above. The fill rule is specified by means of a <A NAME="Shapes_d.htm_IX_RegionFillRule">
 </A>
<CODE>
RegionFillRule</CODE>
 value, which may be one of <A NAME="Shapes_d.htm_IX_ODD_EVEN (RegionFillRule type)">
 </A>
ODD_EVEN or <A NAME="Shapes_d.htm_IX_WINDING (RegionFillRule type)">
 </A>
WINDING.</P>
<P>
When you define a path by combining two other paths, the result might not be exactly what you would expect. 
<IMG SRC="Shapes_d_comboPaths.gif">

</P>
<HR>
<A NAME="Shapes_e.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Drawing Graphics</A>: 2.12 <A HREF="#Shapes_2.htm">Shapes</A>: 
Regions</H3>
<PRE>GrGetPathRegion(), GrDrawRegion(), GrDrawRegionAtCP(), GrMoveReg(), GrGetPtrRegBounds(), GrTestPointInReg(), GrTestRectInReg()</PRE>
<P>
<A NAME="Shapes_e.htm_IX_Regions, graphics">
 </A>
Sometimes it's useful to be able to describe an arbitrary area of a display. Regions provide a mechanism for doing so. Regions are ideal for delimiting large, blobby areas which are relatively free of detail. They are used by the system to describe many &quot;filled shapes.&quot;</P>
<P>
<A NAME="Shapes_e.htm_IX_GrGetPathRegion()">
 </A>
While it is possible to define a region directly, writers familiar with paths may define a path and then call the <CODE>
GrGetPathRegion()</CODE>
 routine. To find out how to define a region directly, see below.</P>
<P>
<CODE>
GrDrawRegion()</CODE>
<A NAME="Shapes_e.htm_IX_GrDrawRegion()">
 </A>
 draws a region at the passed position using the current area drawing attributes.<A NAME="Shapes_e.htm_IX_GrDrawRegionAtCP()">
 </A>
 <CODE>
GrDrawRegionAtCP()</CODE>
 draws a region at the current pen position. </P>
<P>
<CODE>
GrMoveReg()</CODE>
<A NAME="Shapes_e.htm_IX_GrMoveReg()">
 </A>
 changes the coordinates stored within a region data structure by the specified <EM>
x</EM>
 and <EM>
y</EM>
 offsets.</P>
<P>
<CODE>
GrGetPtrRegBounds()</CODE>
<A NAME="Shapes_e.htm_IX_GrGetPtrRegBounds()">
 </A>
 returns the coordinates of the passed region's bounding rectangle.</P>
<P>
<CODE>
GrTestPointInReg()</CODE>
<A NAME="Shapes_e.htm_IX_GrTestPointInReg()">
 </A>
 sees if the passed point falls within a region. <CODE>
GrTestRectInReg()</CODE>
<A NAME="Shapes_e.htm_IX_GrTestRectInReg()">
 </A>
 tests to see whether the passed rectangle falls entirely or partially within a region; it returns a value of type <A NAME="Shapes_e.htm_IX_TestRectReturnType">
 </A>
<CODE>
TestRectReturnType</CODE>
 specifying the degree of overlap. These two functions are very useful when using regions for clipping purposes; if a given point or rectangle is discovered to be outside the clipping region, there's no need to draw the point or rectangle.</P>
<P>
Some application writers may wish to define regions directly without describing a path. Regions are described in terms of a rectangular array (thus the similarity to bitmaps). Instead of specifying an on/off value for each pixel, however, regions assume that the region will be fairly undetailed and that the data structure can thus be treated in the manner of a sparse array. Only the cells in which the color value of a row changes are recorded. The tricky part here is keeping in mind that when figuring out whether or not a row is the same as a previous row, the system works its way up from the bottom, so that you should compare each row with the row beneath it to determine whether it needs an entry.

</P>
<P>
<A NAME="Shapes_e.htm_IX_EOREGREC">
 </A>
The easiest region to describe is the null region, which is a special case described by a single word with the value EOREGREC (a constant whose name stands for <EM>
E</EM>
nd Of <EM>
REG</EM>
ion <EM>
REC</EM>
ord value). Describing a non-null region requires several numbers.</P>
<P>
The first four numbers of the region description give the bounds of the region. (You may encounter certain visual objects which use region structures to describe their bounds. These regions do not contain any bounds numbers. The object's drawing bounds will be used instead.)</P>
<P>
Next come one or more series of numbers. Each series describes a row, specifying which pixels of that row are part of the region. The only rows which need to be described are those which are different from the row below. The first number of each row description is the row number, its <EM>
y</EM>
 coordinate. The last number of each series is a special token, EOREGREC, which lets the kernel know that the next number of the description will be the start of another row. Between the row number and EOREGREC are the column numbers where the pixels toggle on and off. The first number after the row number corresponds to the first column in which the pixel is on; the next number is the first subsequent column in which the pixel is off; and so on.</P>
<P>
The figure below shows a simple region, along with the numbers used to define it. Those rows which are the same as the rows beneath them have no entry in this structure. Notice that rows four through seven, being the same as row eight, have no entries.
<IMG SRC="Shapes_e_sampleRegion.gif">

</P>
<P>
<A NAME="Shapes_e.htm_IX_Coordinates:parameterized">
 </A>
It is possible to customize a region by taking advantage of a feature of the coordinate system. Graphics routines take word-sized (16-bit) coordinate arguments. Normal coordinates only require 15 bits. When working with regions, the graphics system uses the extra bit to allow for coordinates that are described in terms of &quot;parameters.&quot;
<IMG SRC="Shapes_e_paramRegion.gif">

</P>
<P>
When you create a region you can specify coordinates as an offset from a <EM>
parameter</EM>
. When the region is initialized, up to four parameters may be defined. Coordinates may then be specified as 13-bit offsets from any one of these four parameters. When drawing the construct, new values may be passed for the parameters. In this way, it is possible to use a single region to describe a variety of shapes, just by changing the parameters.</P>
<P>
Coordinates with the values shown below will be interpreted as offsets.</P>
<DL>
<DT>
4000h-5FFFh: Offsets from parameter zero, with 5000h corresponding to the parameter exactly.</DT>
<DT>
6000h-7FFFh: Offsets from parameter one, with 7000h corresponding to the parameter exactly.</DT>
<DT>
8000h-9FFFh: Offsets from parameter two, with 9000h corresponding to the parameter exactly.</DT>
<DT>
A000h-BFFFh: Offsets from parameter three, with B000h corresponding to the parameter exactly.</DT>
</DL>
<P>
Thus, if a coordinate in a GString were 5000h, and the region were drawn with parameter zero equal to 72, then that drawing would take place at the coordinate 72. The coordinate 4FFFh would be interpreted as 71. Use the following constants to clarify parameterized coordinates:</P>
<PRE>/* Constants for DrawRegion */
#define PARAM_0 0x5000
#define PARAM_1 0x7000
#define PARAM_2 0x9000
#define PARAM_3 0xb000</PRE>
<P>
Some or all coordinates of a region description may incorporate parameters. Note that the region code doesn't check regions for correctness. If the bounds of a region are set incorrectly, the rows are given out of order, or an incorrect (odd) number of on/off points is given for a row, the results are undefined. </P>
<HR>
<A NAME="Shapes_f.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Drawing Graphics</A>: 2.13 <A HREF="#Shapes_2.htm">Shapes</A>: 
Text</H3>
<P>
<A NAME="Shapes_f.htm_IX_Text:rendering with graphics">
 </A>
Programs normally display text with UI gadgetry such as GenText, VisText, and GenGlyph objects. For those times when a geode will display text as part of a graphical display, sometimes it's best to display text using direct calls to the graphics system.</P>

<H4 CLASS="HeadingC">
Displaying Text</H4>
<PRE>GrDrawText(), GrDrawTextAtCP(), GrDrawChar(), GrDrawCharAtCP(), GrDrawTextField()</PRE>
<P>
<A NAME="Shapes_f.htm_IX_GrDrawText()">
 </A>
There are several functions that display text. The <CODE>
GrDrawText()</CODE>
 routine displays a text string. The passed <EM>
y</EM>
 position, adjusted by the text mode (see below), determines the vertical position. The passed <EM>
x </EM>
position determines where the text will start printing, as normal. </P>
<P>
<CODE>
GrDrawText()</CODE>
 draws a text string at the desired position using the GState's current text attributes. This text string should contain no carriage returns, line feeds, tabs, or other non-printing characters.<A NAME="Shapes_f.htm_IX_GrDrawTextAtCP()">
 </A>
 <CODE>
GrDrawTextAtCP()</CODE>
 draws a text string at the current position.<A NAME="Shapes_f.htm_IX_GrDrawChar()">
 </A>
 <CODE>
GrDrawChar()</CODE>
 and <CODE>
GrDrawCharAtCP()</CODE>
<A NAME="Shapes_f.htm_IX_GrDrawCharAtCP()">
 </A>
 draw a single character, which should not be a non-printing character.<A NAME="Shapes_f.htm_IX_GrDrawTextField()">
 </A>
 <CODE>
GrDrawTextField()</CODE>
 draws a field of text--however, this routine is only available in Assembly language. </P>


<H4 CLASS="HeadingC">
Special Text Attributes</H4>
<PRE>GrGetTextStyle(), GrSetTextStyle(), GrGetTextMode(), GrSetTextMode(), GrGetTextSpacePad(), GrSetTextSpacePad(), GrGetFont(), GrSetFont(), GrGetTrackKern() GrSetTrackKern(), GrGetFontWeight(), GrSetFontWeight(), GrGetFontWidth(), GrSetFontWidth(), GrGetSuperscriptAttr(), GrSetSuperScriptAttr(), GrGetSubscriptAttr(), GrGetSubscriptAttr()</PRE>
<P>
Applications can display text in a number of ways. Thus the GState has many attributes it keeps track of solely for drawing text.</P>
<P>
Text style is a collective set of attributes (bold, italic, etc.) that affects how the text is drawn by the graphics system.<A NAME="Shapes_f.htm_IX_GrGetTextStyle()">
 </A>
 <CODE>
GrGetTextStyle()</CODE>
 gets the current text style,<A NAME="Shapes_f.htm_IX_GrSetTextStyle()">
 </A>
 and <CODE>
GrSetTextStyle()</CODE>
 allows a new style to be specified. Styles are expressed as a <CODE>
TextStyle</CODE>
 record. Note that some complicated styles which are offered by the text objects are not available here: these styles are available only from the text objects; if you wish to offer these styles without using a text object, you'll have to do the artwork yourself.</P>
<P>
Depending on the text mode attribute, text may either be drawn from the bottom of the font box, top of the font box, baseline, or accent line.<CODE>
 GrGetTextMode()</CODE>
<A NAME="Shapes_f.htm_IX_GrGetTextMode()">
 </A>
 gets the text mode, returning information about which offset to use when drawing text.<A NAME="Shapes_f.htm_IX_GrSetTextMode()">
 </A>
 <CODE>
GrSetTextMode()</CODE>
 allows this information to be reset. The information is stored in a <CODE>
TextMode</CODE>
 record. Note that if you will be drawing characters of more than one size or font, and if you want those characters to line up by baseline, you should use <CODE>
GrSetTextMode()</CODE>
 to use the TM_DRAW_BASE text mode.
<IMG SRC="Shapes_f_textMode.gif">

</P>
<P>
<CODE>
GrSetTextSpacePad()</CODE>
<A NAME="Shapes_f.htm_IX_GrSetTextSpacePad()">
 </A>
 sets the special amount used to pad space characters; <A NAME="Shapes_f.htm_IX_GrGetTextSpacePad()">
 </A>
<CODE>
GrGetTextSpacePad()</CODE>
 retrieves the current space padding.</P>
<P>
<CODE>
GrGetFont()</CODE>
<A NAME="Shapes_f.htm_IX_FontID">
 </A>
<A NAME="Shapes_f.htm_IX_Fonts:kernel graphics routines">
 </A>
<A NAME="Shapes_f.htm_IX_GrGetFont()">
 </A>
 returns the current font and type size. The font is identified by its <CODE>
FontID</CODE>
; the default font has the ID <A NAME="Shapes_f.htm_IX_DEFAULT_FONT_ID">
 </A>
DEFAULT_FONT_ID and size DEFAULT_FONT_SIZE<A NAME="Shapes_f.htm_IX_DEFAULT_FONT_SIZE">
 </A>
; these are the values which new GStates will start with. <A NAME="Shapes_f.htm_IX_GrSetFont()">
 </A>
<CODE>
GrSetFont()</CODE>
 sets a new font to use. The font's point size may be between <A NAME="Shapes_f.htm_IX_MIN_POINT_SIZE">
 </A>
MIN_POINT_SIZE and MAX_POINT_SIZE<A NAME="Shapes_f.htm_IX_MAX_POINT_SIZE">
 </A>
.</P>
<P>
Track kerning adjusts the space between characters. A negative kerning value means that characters will be drawn closer together. A large negative kerning value can make characters draw overlapped. A positive kerning value causes characters to draw with more space between them. <CODE>
GrGetTrackKern()</CODE>
<A NAME="Shapes_f.htm_IX_GrGetTrackKern()">
 </A>
 returns the present track kerning value. <CODE>
GrSetTrackKern()</CODE>
<A NAME="Shapes_f.htm_IX_GrSetTrackKern()">
 </A>
 changes this value. The kerning value must be between MIN_TRACK_KERNING<A NAME="Shapes_f.htm_IX_MIN_TRACK_KERNING">
 </A>
 and <A NAME="Shapes_f.htm_IX_MAX_TRACK_KERNING">
 </A>
MAX_TRACK_KERNING; values greater than MAX_TRACK_KERNING will be replaced by MAX_TRACK_KERNING, values less that MIN_TRACK_KERNING will result in MIN_TRACK_KERNING being used. The kerning value will be multiplied as a percentage by the font size to get a number of points to use for kerning; if this multiplied value is greater than the <CODE>
BBFixed</CODE>
 (byte-byte fixed point) number <A NAME="Shapes_f.htm_IX_MAX_KERN_VALUE">
 </A>
MAX_KERN_VALUE or less than <A NAME="Shapes_f.htm_IX_MIN_KERN_VALUE">
 </A>
MIN_KERN_VALUE then it will be adjusted to fall at the end of this range.</P>
<P>
A font's weight determines its boldness. For many fonts, there will be only two weights defined: plain and bold. However, some fonts allow for finer control of weight. To find out the current font weight, call <CODE>
GrGetFontWeight()</CODE>
<A NAME="Shapes_f.htm_IX_GrGetFontWeight()">
 </A>
. To use a different font weight, call <CODE>
GrSetFontWeight()</CODE>
<A NAME="Shapes_f.htm_IX_GrSetFontWeight()">
 </A>
. Some useful weight values are stored in the <CODE>
FontWeight</CODE>
<A NAME="Shapes_f.htm_IX_FontWeight">
 </A>
 enumerated type. The weight should definitely be between FW_MINIMUM and FW_MAXIMUM.</P>
<P>
To make characters draw wider or narrower, adjust the font width. Some fonts come in wide or narrow versions. If the font does not support the requested width, GEOS will simulate the width as best it can. The <CODE>
GrGetFontWidth()</CODE>
<A NAME="Shapes_f.htm_IX_GrGetFontWidth()">
 </A>
 routine retrieves the current width; <CODE>
GrSetFontWidth() </CODE>
<A NAME="Shapes_f.htm_IX_GrSetFontWidth()">
 </A>
changes it. Some helpful width values are stored in the <CODE>
FontWidth</CODE>
<A NAME="Shapes_f.htm_IX_FontWidth">
 </A>
 enumerated type. The width should definitely be between FWI_MINIMUM and FWI_MAXIMUM.</P>
<P>
Geodes can control how text will be drawn in superscript and subscript styles. The super- and subscript attributes determine how to scale the characters and how far they should be displaced. There are several standard super- and subscript attributes available, including values for footnote numbers, and chemical inferiors. Typesetting enthusiasts who wish to adjust the width of these characters differently than the height (as in some standard super- and sub- script layouts) should work with the font width. Use <CODE>
GrGetSuperscriptAttr()</CODE>
<A NAME="Shapes_f.htm_IX_GrGetSuperscriptAttr()">
 </A>
 and<A NAME="Shapes_f.htm_IX_GrGetSubscriptAttr()">
 </A>
 <CODE>
GrGetSubscriptAttr()</CODE>
 to find out what the present values are.<A NAME="Shapes_f.htm_IX_GrSetSuperscriptAttr()">
 </A>
 Use <CODE>
GrSetSuperscriptAttr()</CODE>
 and <CODE>
GrSetSubscriptAttr()</CODE>
<A NAME="Shapes_f.htm_IX_GrSetSubscriptAttr()">
 </A>
 to change these values. Each of these routines works with a word sized value: the top byte is a percentage of the font size to offset sub- or superscript characters; the low byte is the percentage of font size to use for the sub- or superscript character 0x0064 (decimal 100) would be full-sized with no displacement.</P>


<H4 CLASS="HeadingC">
Accessing Available Fonts</H4>
<PRE>GrEnumFonts(), GrCheckFontAvail(), GrFindNearestPointsize(), GrGetDefFontID(), GrGetFontName()</PRE>
<P>
<CODE>
</CODE>
<A NAME="Shapes_f.htm_IX_GrEnumFonts()">
 </A>
To find out which fonts are available in the user's environment, use the <CODE>
GrEnumFonts()</CODE>
 command. You specify what sorts of fonts you're interested in by setting a number of flags, and the routine will fill a buffer with the available fonts with their <CODE>
FontID</CODE>
s and names.</P>
<P>
<A NAME="Shapes_f.htm_IX_FEF_&ldots;">
 </A>
The <A NAME="Shapes_f.htm_IX_FontEnumFlags">
 </A>
<CODE>
FontEnumFlags</CODE>
 record determines which fonts will be returned. At least one of the FEF_OUTLINES and FEF_BITMAPS flags must be set to determine whether outline, bitmap, or both kinds of fonts should be returned.Keep in mind that only outline fonts will result in true WYSIWYG printer output. The FEF_ALPHABETIZE flag will force the returned buffer of fonts to appear in lexical order. The FEF_DOWNCASE flag requests that the font names appear all in lowercase.</P>
<P>
<A NAME="Shapes_f.htm_IX_FontFamily">
 </A>
The FEF_FAMILY flag asks that the search be limited to a font family. To specify what sort of family you want, use the <CODE>
FontFamily</CODE>
 enumerated type.</P>
<P>
<CODE>
GrEnumFonts()</CODE>
 ignores the FEF__STRING flag; other routines will use this flag to find out whether the font is specified by a <CODE>
FontID</CODE>
 or its ASCII name.</P>
<P>
The other flags narrow the search: if you set the FEF_FIXED_WIDTH flag, then only fixed-width fonts will be returned. If you set the FEF_USEFUL flag, only those fonts marked as &quot;useful&quot; will be returned.</P>
<P>
<A NAME="Shapes_f.htm_IX_FontEnumStruct">
 </A>
The font information will be returned as an array of <CODE>
FontEnumStruct</CODE>
 structures. Each of these structures will contain a <CODE>
FontID</CODE>
 and the ASCII name of the associated font.</P>
<P>
<A NAME="Shapes_f.htm_IX_MAX_FONTS">
 </A>
There may be up to <A NAME="Shapes_f.htm_IX_MAX_FONTS">
 </A>
MAX_FONTS available on the system. If you're not prepared to handle an array large enough to hold this many fonts, be sure to pass an argument specifying how large an array is being provided.</P>
<P>
To find out if a given font is available in the user's environment, call either <CODE>
GrCheckFontAvailID()</CODE>
<A NAME="Shapes_f.htm_IX_GrCheckFontAvailID()">
 </A>
 or <A NAME="Shapes_f.htm_IX_GrCheckFontAvailName()">
 </A>
<CODE>
GrCheckFontAvailName()</CODE>
, depending on whether the font is being identified by its <CODE>
FontID</CODE>
 or its ASCII name. If programming in assembly language, use the <A NAME="Shapes_f.htm_IX_GrCheckFontAvail()">
 </A>
<CODE>
GrCheckFontAvail()</CODE>
 routine no matter how you're identifying the font. You may narrow the search by passing the appropriate <CODE>
FontEnumFlags</CODE>
. Make sure that the FEF_STRING bit is clear when searching by ID and set when searching by name.</P>
<P>
Some fonts are available only in certain sizes and styles. Bitmap fonts are examples of this. The <A NAME="Shapes_f.htm_IX_GrFindNearestPointsize()">
 </A>
<CODE>
GrFindNearestPointsize()</CODE>
 routine takes a typeface, size, and style set. It returns the closest available size and style (or returns FID_INVALID if the passed font isn't available).</P>
<P>
To get the font which the Generic UI will use by default, call <CODE>
GrGetDefFontID()</CODE>
<A NAME="Shapes_f.htm_IX_GrGetDefFontID()">
 </A>
. This also returns the font size to use, useful if you wish to respect the user's choice of type size.</P>
<P>
To find out the ASCII name of a string for which you have the <CODE>
FontID</CODE>
, call <CODE>
GrGetFontName()</CODE>
<A NAME="Shapes_f.htm_IX_GrGetFontName()">
 </A>
. If the font isn't available, this function will return <EM>
false</EM>
; otherwise it will fill a passed buffer with the name of the font. The passed buffer should be FID_NAME_LEN bytes long.</P>


<H4 CLASS="HeadingC">
Text Metrics</H4>
<PRE>GrTextWidth(), GrTextWidthWWFixed(), GrTextWidthWBFixed(), GrCharWidth(), GrFontMetrics(), GrCharMetrics()</PRE>
<P>
From time to time it may become important to know something about the size of a letter to be drawn. The graphics system has several routines for retrieving this information.<A NAME="Shapes_f.htm_IX_GrTextWidth()">
 </A>
 <CODE>
GrTextWidth()</CODE>
 returns the width, in points, of a string.<A NAME="Shapes_f.htm_IX_GrTextWidthWBFixed()">
 </A>
 <A NAME="Shapes_f.htm_IX_GrTextWidthWBFixed()">
 </A>
<CODE>
GrTextWidthWWFixed()</CODE>
 does the same thing, but returns a more accurate figure, including a fractional part; note that in assembly, this routine is called <CODE>
GrTextWidthWBFixed()</CODE>
.<A NAME="Shapes_f.htm_IX_GrCharWidth()">
 </A>
 <CODE>
GrCharWidth() </CODE>
returns the width of a single character. Note that the width of a text string will normally be different than the sum of the widths of the component characters. <CODE>
GrTextWidth()</CODE>
 takes track kerning and pairwise kerning into account.</P>
<P>
<CODE>
GrFontMetrics()</CODE>
<A NAME="Shapes_f.htm_IX_Fonts:metrics">
 </A>
<A NAME="Shapes_f.htm_IX_GrFontMetrics()">
 </A>
 returns information pertaining to a font. The meanings of these metrics are listed below:
<IMG SRC="Shapes_f_fontMetrics.gif">

</P>
<DL>
<DT>
<STRONG>
Height</STRONG>
</DT><DD>The height of the &quot;font box.&quot; This is how much vertical space should be allocated for a line of text. Note that when the text is drawn, some characters may go beyond these bounds. Though the height is still the vertical distance to set aside for a line of text, applications should be prepared for characters to have a vertical height equal to the maximum adjusted height, discussed below.</DD>
<DT>
<STRONG>
Maximum Adjusted Height</DT><DD>
</STRONG>
The maximum height required to draw the character. Some fonts contain characters that are meant to go beyond the normal vertical boundaries, perhaps extending into the space occupied by text on the next or previous line. This metric is the minimum height to guarantee being able to display such a character.</DD>
<DT>
<STRONG>
Above Box</STRONG>
</DT><DD>Normally the top of the font box, the uppermost limit of a font, is 3/4 of the font's height above the baseline. For those fonts which do not follow this rule, the Above Box metric is the number of points by which the true font box extends beyond the normal font box.</DD>
<DT>
<STRONG>
Below Box</STRONG>
</DT><DD>Normally, the bottom of the font box, the bottommost limit of a font, is 1/4 of the font's height below the baseline. For those fonts which do not follow this rule, the Below Box metric is the number of points by which the true font box extends below the normal font box.</DD>
<DT>
<STRONG>
Mean</STRONG>
</DT><DD>The height of a typical lower case character. This metric is sometimes called the &quot;x height,&quot; since this will be the height of a lower case &quot;x.&quot;</DD>
<DT>
<STRONG>
Descent</STRONG>
</DT><DD>How far descending characters (like &quot;y&quot; and &quot;j&quot;) extend below the baseline.</DD>
<DT>
<STRONG>
Baseline</STRONG>
</DT><DD>The vertical position of the bottoms of nondescending characters. The number referred to as the &quot;baseline&quot; is the distance between the baseline and the top of accent marks. This corresponds to the text mode TM_DRAW_BASE. </DD>
<DT>
<STRONG>
Accent</STRONG>
</DT><DD>How much space to leave for accent marks. This distance is measured from the top of the accent mark area to the ascent height. This corresponds to the text mode TM_DRAW_ACCENT. </DD>
<DT>
<STRONG>
Ascent</STRONG>
</DT><DD>Height of capital letters (and some tall lower-case letters, such as &quot;f&quot;).</DD>
<DT>
<STRONG>
Underline Position</DT><DD>
</STRONG>
The distance from the top of the accent line to the top of the underline.</DD>
<DT>
<STRONG>
Underline Thickness</DT><DD>
</STRONG>
The width of the underline.</DD>
<DT>
<STRONG>
Strikethrough Position</DT><DD>
</STRONG>
The vertical position of the line used for &quot;strikethrough&quot; text.</DD>
<DT>
<STRONG>
Average Width</DT><DD>
</STRONG>
The average character width. This figure is normally computed as a weighted average width of lower-case characters, said average weighted based on the frequency distribution of the characters.</DD>
<DT>
<STRONG>
Maximum Width</DT><DD>
</STRONG>
Width of the font's widest character.</DD>
<DT>
<STRONG>
Leading</STRONG>
</DT><DD>The height of the vertical gap between lines of text.</DD>
<DT>
<STRONG>
Kern Count</STRONG>
</DT><DD>The number of specially kerned pairs in the font. Many fonts allow certain pairs of characters to have special spacing, known as &quot;pair kerning.&quot; For example many fonts try to squish &quot;To&quot; so that the &quot;T&quot; and &quot;o&quot; are closer together than normal leading would dictate. Do not confuse kerned pairs with ligatures. A kerned pair just has strange spacing (<EM>e.g.</EM> &quot;To&quot; vs. &quot;T&nbsp;o&quot;); a ligature is a pair of characters which have been combined into one (<EM>e.g.</EM> &quot;&aelig;&quot;).</DD>
<DT>
<STRONG>
Driver</DT><DD></STRONG>
<A NAME="Shapes_f.htm_IX_FontMaker">
 </A>
The font driver associated with the font, specified by a member of the <CODE>
FontMaker</CODE>
 enumerated type.</DD>
<DT>
<STRONG>
First Character</DT><DD>
</STRONG>
The <CODE>
Char</CODE>
 value of the first defined, drawable character.</DD>
<DT>
<STRONG>
Last Character</DT><DD>
</STRONG>
The <CODE>
Char</CODE>
 value of the last defined, drawable character.</DD>
<DT>
<STRONG>
Default Character</DT><DD>
</STRONG>
The <CODE>
Char</CODE>
 value of the drawable character which will be drawn as a substitute for any undrawable characters. </DD>
</DL>
<P>
<A NAME="Shapes_f.htm_IX_GrCharMetrics()">
 </A>
The <CODE>
GrCharMetrics()</CODE>
 routine returns useful measurements for a character. For each of a font's characters, you may request the following information:
<IMG SRC="Shapes_f_charMetrics.gif">

</P>
<DL>
<DT>
<STRONG>
Width</DT><DD></STRONG>
While not a metric returned by the <CODE>
GrCharMetrics()</CODE>
 routine, the character width is very important. It determines how much space to allow for the character. The metrics that follow don't affect how much space to allow; instead, they give the bounds of the area that will be drawn to. As shown, characters are free to draw beyond the area set aside for them by the width, into the space of the previous or next character.</DD>
<DT>
<STRONG>
Minimum X</DT><DD>
</STRONG>
The character's leftmost bound. If this value is positive, it means that the character will have some extra space before it. If the value is negative, the character may infringe on the space of the previous character. This metric is also called the &quot;left side bearing.&quot;</DD>
<DT>
<STRONG>
Minimum Y</DT><DD>
</STRONG>
The character's bottommost bound. This is the character's &quot;descent,&quot; the amount it hangs below the baseline.</DD>
<DT>
<STRONG>
Maximum X</DT><DD>
</STRONG>
The character's rightmost drawing bound. This value should be greater than the Minimum X. Do not confuse this metric with the character's width. </DD>
<DT>
<STRONG>
Maximum Y</DT><DD>
</STRONG>
The character's topmost bound. This is the distance the character extends above the baseline. It is sometimes called the character's &quot;ascent.&quot;</DD>
</DL>
<P>
<A NAME="Shapes_f.htm_IX_GrGetTextBounds()">
 </A>
The <CODE>
GrGetTextBounds()</CODE>
 routine computes the drawing bounds for a string of text. </P>

<HR>
<A NAME="Shapes_10.htm"></A>


<H2 CLASS="sectionTitle">
<A HREF="#index.htm">Drawing Graphics</A>: 3 
Shape Attributes</H2>
<PRE>GrSetAreaAttr(), GrSetLineAttr(), GrSetTextAttr()</PRE>
<P>
The graphics system keeps track of many attributes which affect how graphics will be drawn. By setting attributes in the graphics state, your geode can change the color, fill pattern, and other features that won't affect the shape of what you're drawing but will affect its appearance.</P>
<P>
The following sections will explain how each of these attributes may be set individually. Note that if you wish to set all attributes to use when filling areas at once, call <A NAME="Shapes_10.htm_IX_GrSetAreaAttr()">
 </A>
<CODE>
GrSetAreaAttr()</CODE>
. Call <A NAME="Shapes_10.htm_IX_GrSetLineAttr()">
 </A>
<CODE>
GrSetLineAttr()</CODE>
 to set all attributes to use when drawing lines. Use <A NAME="Shapes_10.htm_IX_GrSetTextAttr()">
 </A>
<CODE>
GrSetTextAttr()</CODE>
 to set all text-rendering attributes.</P>
<P CLASS="subsectionLink">
<A HREF="#Shapes_11.htm">Color</A></P>
<P CLASS="subsectionLink">
<A HREF="#Shapes_12.htm">Patterns and Hatching</A></P>
<P CLASS="subsectionLink">
<A HREF="#Shapes_13.htm">Mix Mode</A></P>
<P CLASS="subsectionLink">
<A HREF="#Shapes_14.htm">Masks</A></P>
<P CLASS="subsectionLink">
<A HREF="#Shapes_15.htm">Line-Specific Attributes</A></P>
<HR>
<A NAME="Shapes_11.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Drawing Graphics</A>: 3.1 <A HREF="#Shapes_10.htm">Shape Attributes</A>: 
Color</H3>
<P>
<A NAME="Shapes_11.htm_IX_Color">
 </A>
If your geode displays graphics, you can probably make its graphical display more effective by using color. Your geode can have as much control over color as it wants, ranging from saying what colors certain objects should be to choosing which colors should be available.</P>
<P>
Most color controllers work with the concept of a palette, a subset of the colors your video device is capable of displaying. Most controllers can only use some of these colors at a time; these colors make up the palette. You can refer to colors by their color index (i.e. their place in the palette). You can also refer to colors by their RGB values.</P>
<P>
An RGB value specifies a color by mixing intensities of red, green, and blue. The more of each component color added, the more of that color will show up in the result. If all components are equal, the result will be a shade of gray. If all components are zero, the result will be black. If all components are at the maximum (255), the result will be white.</P>
<P>
<A NAME="Shapes_11.htm_IX_ColorQuad">
 </A>
The data structure used to store color information is known as the <CODE>
ColorQuad</CODE>
, shown in <A HREF="#Shapes_11.htm_89399"> Color Data Structures</A>
.</P>
<P CLASS="figTitle">
Code Display 24-1 <A NAME="Shapes_11.htm_89399">
 </A>
Color Data Structures</P>
<PRE>typedef struct {
	/* The ColorQuad data structure is used to represents a color. There are
	 * many ways to describe a color. The CQ_info field determines how the
	 * color is being specified, and the other fields will be interpreted
	 * based on CQ_info's value. Colors may be referenced by palette index,
	 * RGB value, or grey scale value. */
		/* CQ_redOrIndex
		 * If CQ_info is CF_INDEX, then this is the palette index.
		 * If CQ_info is CF_RGB, then this is the Red component.
		 * If CQ_info is CF_GRAY, then this is the Gray scale */
	byte 	CQ_redOrIndex;</PRE>
<PRE>		/* CQ_info:
		 * This ColorFlag determines how the other three fields of the
		 * ColorQuad will be interpreted. The ColorFlag type is shown 
		 * below. */
	ColorFlag 	CQ_info;</PRE>
<PRE>		/* CQ_green:
		 * If CF_RGB, then these fields are the Green and Blue components.
		 * Otherwise, these fields are ignored. */
	byte 	CQ_green;
	byte 	CQ_blue;
} ColorQuad;</PRE>
<PRE><A NAME="Shapes_11.htm_IX_ColorQuadAsDWord"> </A>typedef dword ColorQuadAsDWord;</PRE>
<PRE><A NAME="Shapes_11.htm_IX_ColorFlag"> </A><A NAME="IX_CF_&ldots;  (ColorFlag type)"> </A><A NAME="IX_ColorFlag"> </A><A NAME="IX_CF_&ldots;  (ColorFlag type)"> </A>typedef ByteEnum 	ColorFlag;
	CF_INDEX,	
		/* Color specified by palette index. The values of the first
		 * 16 entries of the system palette are specified by Color values */
	CF_GRAY,
		/* Color specified by gray value; this is like CF_RGB, but the
		 * value in CQ_redOrIndex will be used for the Green and Blue 
		 * fields as well. */
	CF_SAME,
		/* Used with hatch patterns, if this flag is set, hatches will draw
		 * using the default color (the one set using GrSetXXXXColor()) */
	CF_RGB
		/* Color Set using RGB values */</PRE>
<PRE>/* Sample Colors:
 * To use the system palette's light green:						{ C_LIGHT_GREEN, CF_INDEX, 0, 0}
 * To use the 40th color in the palette:						{ 40, CF_INDEX, 0, 0}
 * To use a custom brown:						{ 150, CF_RGB, 90, 0}
 * To use a 75% Gray (75% *256 = 192):						{ 192, CF_GRAY, 0, 0}
 */</PRE>

<H4 CLASS="HeadingC">
Using Available Colors</H4>
<PRE>GrGetAreaColor(), GrSetAreaColor(), GrGetLineColor(), GrSetLineColor(), GrGetTextColor(), GrSetTextColor()</PRE>
<P>
If a geode is to draw something in color, it first calls a routine to set which color to use, then calls the appropriate drawing routine. The color can be specified in terms of its palette index or its RGB value. The data specifying which color to use is stored in the GState, with separate color fields to keep track of how to draw lines, areas, and text.</P>
<P>
<CODE>
GrSetLineColor()</CODE>
<A NAME="Shapes_11.htm_IX_GrSetLineColor()">
 </A>
 changes the color used when drawing lines. The<CODE>
 GrSetAreaColor()</CODE>
<A NAME="Shapes_11.htm_IX_GrSetAreaColor()">
 </A>
 routine sets the color to be used when filling areas. <CODE>
GrSetTextColor()</CODE>
<A NAME="Shapes_11.htm_IX_GrSetTextColor()">
 </A>
 sets the color to be used when rendering text. <CODE>
GrGetLineColor()</CODE>
<A NAME="Shapes_11.htm_IX_GrGetTextColor()">
 </A>
<A NAME="Shapes_11.htm_IX_GrGetAreaColor()">
 </A>
<A NAME="Shapes_11.htm_IX_GrGetLineColor()">
 </A>
, <CODE>
GrGetAreaColor()</CODE>
, and <CODE>
GrGetTextColor()</CODE>
 return the color values and flags stored with the GState.
<IMG SRC="Shapes_11_Color.gif">

</P>
<P>
<A NAME="Shapes_11.htm_IX_Color">
 </A>
<A NAME="Shapes_11.htm_IX_C_&ldots;  (Color type)">
 </A>
The default system palette includes several colors whose indexes have been set up so they may be referenced by descriptive constant names. The constants are members of the enumerated type <CODE>
Color</CODE>
, the most common shown in the figure above. Thus, instead of having to remember that the index 02 means green, the constant C_GREEN can be passed to the appropriate color setting command.</P>
<P>
Other Color values include a 16-shade gray scale (the C_GRAY_...entries), some &quot;unused&quot; entries (the C_UNUSED_... entries), and a number of entries which have been set up to allow you to specify a color by its red, green, and blue components on a zero-to-five scale (the C_R..._G..._B... entries).</P>
<P>
 Programmers should use care when using these constants in conjunction with palette manipulation, as it is possible to change the RGB color value associated with a palette entry. Since the constant names are associated with palette indexes instead of RGB values, it is possible to change the RGB value of palette entry 02 so that the C_GREEN constant actually refers to, for example, a shade of magenta.</P>


<H4 CLASS="HeadingC">
When the Color Isn't in the Palette</H4>
<PRE>GrSetLineColorMap(), GrSetAreaColorMap(), GrSetTextColorMap(), GrGetLineColorMap(), GrGetAreaColorMap(), GrGetTextColorMap(), GrMapColorIndex(), GrMapColorRGB()</PRE>
<P>
Not all users have video devices which can display 256 colors at a time. Even fewer have printers capable of doing so. Therefore, the graphics system makes allowances for drawings which use unavailable colors. Exactly what the system will do with an unavailable color depends on the color mapping mode used. By default, the system will choose the two (or more) closest available colors and dither them together in an attempt to form a mixture which will appear to be the correct color overall when seen from a distance. 
<IMG SRC="Shapes_11_dither.gif">

</P>
<P>
<CODE>
GrSetLineColorMap()</CODE>
<A NAME="Shapes_11.htm_IX_GrSetLineColorMap()">
 </A>
,<A NAME="Shapes_11.htm_IX_GrSetAreaColorMap()">
 </A>
 <CODE>
GrSetAreaColorMap()</CODE>
, and <CODE>
GrSetTextColorMap()</CODE>
<A NAME="Shapes_11.htm_IX_GrSetTextColorMap()">
 </A>
 set the color mapping to use when drawing with an unavailable color. <A NAME="Shapes_11.htm_IX_GrGetLineColorMap()">
 </A>
<CODE>
GrGetLineColorMap()</CODE>
, <A NAME="Shapes_11.htm_IX_GrGetAreaColorMap()">
 </A>
<CODE>
GrGetAreaColorMap()</CODE>
, and <CODE>
GrGetTextColorMap()</CODE>
<A NAME="Shapes_11.htm_IX_GrGetTextColorMap()">
 </A>
 return the current color mapping modes. The geode may draw either in the closest available color, or using a dithering of the closest colors. Often it's a good idea to have text map to solid colors since its detailed nature doesn't go too well with dithering. </P>
<P>
When a geode wants to learn more about which colors are available, it can use the <A NAME="Shapes_11.htm_IX_GrMapColorIndex()">
 </A>
<CODE>
GrMapColorIndex()</CODE>
 routine to find the RGB value associated with an index. The <A NAME="Shapes_11.htm_IX_GrMapColorRGB()">
 </A>
<CODE>
GrMapColorRGB()</CODE>
 routine returns the index and true RGB color of the palette entry that most closely matches the values passed.</P>


<H4 CLASS="HeadingC">
<A NAME="Shapes_11.htm_84719">
 </A>
Custom Palettes</H4>
<PRE>GrCreatePalette(), GrDestroyPalette(), GrSetPaletteEntry(), GrSetPalette(), GrGetPalette()</PRE>
<P>
If the system default palette does not meet a geode's needs, the geode can change its own palette. Some bitmaps (such as those in GIF) have palettes associated with them, and a geode displaying such bitmaps might wish to display the bitmap in its true colors without settling for the closest defaults. Specialized tasks such as photo processing, anti-aliasing, and color cycle animation tend to depend on the ability to manipulate palettes. A geode can create a custom palette associated with a window, then change the color values of entries in that palette.</P>
<P>
Since the palette is associated with a window, there can be as many custom palettes as there are windows. The video driver uses the palette associated with the active window. This means that all the inactive windows (and the background) will also be drawn with the palette of the active window; thus, if you give a window a special palette, that may make inactive windows look different. To avoid this, try to avoid changing palette entries 0-15, as the UI uses these (These are the entries representing C_RED, etc.).</P>
<P>
<CODE>
GrCreatePalette()</CODE>
<A NAME="Shapes_11.htm_IX_GrCreatePalette()">
 </A>
 creates a custom palette and associates it with your graphic state's associated window. The custom palette starts with all entries having their original RGB values from the default palette. <CODE>
GrSetPaletteEntry()</CODE>
<A NAME="Shapes_11.htm_IX_GrSetPaletteEntry()">
 </A>
 takes a palette entry and sets it to a new RGB value. <CODE>
GrSetPalette()</CODE>
<A NAME="Shapes_11.htm_IX_GrSetPalette()">
 </A>
 allows you to specify new values for several palette entries at a time. <CODE>
GrSetPalette()</CODE>
 can also set an entry back to its default value. <CODE>
GrDestroyPalette()</CODE>
<A NAME="Shapes_11.htm_IX_GrDestroyPalette()">
 </A>
 destroys the custom palette, freeing the memory used for it. </P>
<P>
Given a choice of palette entries to change, you might choose one of the C_UNUSED_... entries.</P>
<P>
Call <A NAME="Shapes_11.htm_IX_GrGetPalette()">
 </A>
<CODE>
GrGetPalette() </CODE>
to get a handle to a memory block containing the palette data. Depending on the <A NAME="Shapes_11.htm_IX_GetPalType">
 </A>
<CODE>
GetPalType</CODE>
 passed, you will either get the palette information for your current palette or the default palette. This routine returns the handle of a memory block. The memory block contains an array with 256 entries (one for each color), each entry consisting of three bytes. The first byte of each entry is the color's red component, the second is the color's green component, and the third is the color's blue component.</P>

<HR>
<A NAME="Shapes_12.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Drawing Graphics</A>: 3.2 <A HREF="#Shapes_10.htm">Shape Attributes</A>: 
Patterns and Hatching</H3>
<PRE>GrSetAreaPattern(), GrSetAreaPatternCustom(), GrSetTextPattern(), GrSetTextPatternCustom(), GrGetAreaPattern(), GrGetTextPattern()</PRE>
<P>
Fill patterns allow the application to tile an area with a repeating pattern of bits or lines helpful for suggesting textures. The graphics system supports two types of fill patterns. Bitmap patterns, familiar to most computer users, tile the filled area with a repeated bitmap. Hatch patterns fill the area with a repeated sequence of lines. Hatch patterns are defined in terms of families of parallel lines. <A NAME="Shapes_12.htm_IX_PatternType">
 </A>
Patterns are referenced by a <CODE>
PatternType</CODE>
 and an index, stored in a <A NAME="Shapes_12.htm_IX_GraphicPattern">
 </A>
<CODE>
GraphicPattern</CODE>
 structure. The pattern types are</P>
<DL>
<DT>
PT_SOLID<A NAME="Shapes_12.htm_IX_PT_&ldots;  (PatternType type)">
 </A>
<STRONG>
</DT><DD></STRONG>
The lack of a pattern. Fills the area solid. This is the default. </DD>
<DT>
PT_SYSTEM_HATCH</DT><DD>
System-defined hatch pattern. These patterns are unchangeable and are available to all geodes.</DD>
<DT>
PT_SYSTEM_BITMAP</DT><DD>
System-defined tile bitmap pattern. These patterns are unchangeable and available to all geodes.</DD>
<DT>
PT_USER_HATCH</DT><DD>
User-defined hatch pattern. These patterns are available to all geodes.</DD>
<DT>
PT_USER_BITMAP</DT><DD>
User-defined tile bitmap pattern. These patterns are available to all geodes.</DD>
<DT>
PT_CUSTOM_HATCH</DT><DD>
Application-defined hatch pattern. These patterns are application-specific.</DD>
<DT>
PT_CUSTOM_BITMAP</DT><DD>
Application-defined tile bitmap pattern. These patterns are application-specific.</DD>
</DL>
<P>
<A NAME="Shapes_12.htm_IX_GrSetAreaPattern()">
 </A>
Use <CODE>
GrSetAreaPattern()</CODE>
 and<A NAME="Shapes_12.htm_IX_GrSetTextPattern()">
 </A>
 <CODE>
GrSetTextPattern()</CODE>
 to use patterns defined outside the application (system- and user-defined patterns). To use the system's brick hatch pattern, for example, pass the <A NAME="Shapes_12.htm_IX_PatternType">
 </A>
<CODE>
PatternType</CODE>
 PT_SYSTEM_HATCH<A NAME="Shapes_12.htm_IX_PT_SYSTEM_HATCH">
 </A>
 and the <A NAME="Shapes_12.htm_IX_SystemHatch">
 </A>
<CODE>
SystemHatch</CODE>
 <A NAME="Shapes_12.htm_IX_SH_&ldots;  (SystemHatch type)">
 </A>
SH_BRICK. To use a user-defined bitmap pattern, pass <CODE>
PatternType</CODE>
 PT_USER_BITMAP and the number of the pattern. If you pass an invalid pattern (requesting a user hatch pattern when the user hasn't defined one, for instance), the area or text will be filled solid.</P>
<P>
Applications may define their own patterns. Before adding custom patterns to an application, consider whether such an action is really necessary. Remember that the user may define his own patterns. The data associated with any application custom pattern may be at most 16Kbytes. 

</P>
<P>
Hatch patterns are defined in terms of families of lines. The pattern designer specifies a series of families; each family consists of a set of equidistant parallel lines. Thus, by defining one family of lines, one could cover a surface with one set of parallel lines. By asking for two families, the region could be filled with a grid. 
<IMG SRC="Shapes_12_customHatch.gif">

</P>
<P>
<A NAME="Shapes_12.htm_IX_HatchLine">
 </A>
For each line family, the application must supply certain information. Your application will work with the <CODE>
HatchLine</CODE>
 data type to specify</P>
<UL>
<LI>
Origin<BR>
Since each line family is drawn as a set of equidistant parallel lines, the origin might seem useless. Who cares where the lines start, since they fill the available space? In fact, the origin will only be meaningful if your hatch pattern contains more than one line family. The origin allows you to draw one line family at an offset from another. In the case of the example presented in the figure above, the third line family needed an origin offset from that of the first two families, since none of the lines of the third family pass through the point used as the origin by the first two families.</LI>
<LI>
Delta offset between lines of the family<BR>
Each family has a horizontal and vertical offset. When drawing the pattern, the first line will be drawn starting at the origin. The second line will be drawn at a perpendicular distance equal to the passed y offset. The second line may also be drawn at a parallel offset, but this will only affect dotted lines.</LI>
<LI>
Angle at which to draw the lines<BR>
Remember that angles are measured in degrees measured counterclockwise from the positive x axis. </LI>
<LI>
Color<BR>
You may draw the lines using the default color (area color if pattern is filling an area; text if rendering text), or you may draw using a specific color.</LI>
<LI>
Dashes<BR>
You may draw the lines using a custom dash pattern. See the Line Style attribute, below, to learn how to set up a dash pattern.</LI>
</UL>
<P>
Custom bitmap patterns are defined in terms of simple bitmaps. To find out the structure of a bitmap, see <A HREF="../../CRef/Structs/S_2.htm#72157">the struct's documentation</A>.</P><P>
<A NAME="Shapes_12.htm_IX_GrSetCustomAreaPattern()">
 </A>
To use a custom pattern, call <CODE>
GrSetCustomAreaPattern()</CODE>
 or <CODE>
GrSetCustomTextPattern()</CODE>
<A NAME="Shapes_12.htm_IX_GrSetCustomTextPattern()">
 </A>
. Along with the usual information, you must include a pointer to a memory location which marks the beginning of some structures holding the pattern data. The commands and structures are detailed in the reference manual. For an example of some code using a custom hatch pattern, see <A HREF="#Shapes_12.htm_37201"> Hatch Pattern Data</A>
.</P>
<P CLASS="figTitle">
Code Display 24-2 <A NAME="Shapes_12.htm_37201">
 </A>
Hatch Pattern Data</P>
<PRE>/* This example shows how to implement the pattern illustrated in the figure above. */</PRE>
<PRE>	/* ... */
	GrSetPatternCustom(myGState, gp, hexHatchPatt);
	/* ... */</PRE>
<PRE>GraphicPattern 	gp = {PT_CUSTOM_HATCH, 0};</PRE>
<PRE><A NAME="Shapes_12.htm_IX_HatchPattern"> </A>static HatchPattern 	hexHatchPatt = { 3 };					/* Three HatchLine structures
						 * must follow */</PRE>
<PRE>static HatchLine line1 = { 			{MakeWWFixed(0) , MakeWWFixed(0)},			/* Origin */
		 	MakeWWFixed(0),			/* Delta X 
						 *  dashes will be in alignment */
			MakeWWFixed(20.7846097),			/* Delta Y
						 *  lines will be 12*sqrt(3)
						 *  apart */
			MakeWWFixed(0),			/* Angle */
			(dword) (CF_SAME&lt;&lt;16),			/* Color 
						 *  will use default color */
			1			/* Number of dashes 
						 *  one HatchDash pattern 
						 *  must follow */
		};</PRE>
<PRE><A NAME="Shapes_12.htm_IX_HatchDash"> </A>static HatchDash dash1 = {			{12, 0},			/* On for 12 points */
			{24, 0}};			/* ...and Off for 24 points */</PRE>
<PRE>static HatchLine line2 = { 			{MakeWWFixed(0), MakeWWFixed(0)},			/* Origin */
		 	MakeWWFixed(0),			/* Delta X */
			MakeWWFixed(20.7846097),			/* Delta Y*/
			{120,0},			/* Angle */
			(dword) (CF_SAME&lt;&lt;16),			/* Color */
			1			/* Number of dashes */
		};</PRE>
<PRE>static HatchDash dash 2 = {			{12, 0},			/* On for 12 points */
			{24, 0}};			/* ...and Off for 24 points */</PRE>
<PRE>static HatchLine line3 = { 			{{12,0} , MakeWWFixed(0)},			/* Origin */
						 *  this line family will be at
						 *  a 12 pt. horizontal offset
						 *  from the other two families.
		 	MakeWWFixed(0),			/* Delta X */
			MakeWWFixed(20.7846097),			/* Delta Y*/
			{60,0},			/* Angle */
			(dword) (CF_SAME&lt;&lt;16),			/* Color */
			1			/* Number of dashes */
		};</PRE>
<PRE>static HatchDash dash3 = {			{12, 0},			/* On for 12 points */
			{24, 0}};			/* ...and Off for 24 points */</PRE>
<P>
To find out the current area or text pattern, call <A NAME="Shapes_12.htm_IX_GrGetAreaPattern()">
 </A>
<CODE>
GrGetAreaPattern()</CODE>
 or <CODE>
GrGetTextPattern()</CODE>
<A NAME="Shapes_12.htm_IX_GrGetTextPattern()">
 </A>
.</P>
<HR>
<A NAME="Shapes_13.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Drawing Graphics</A>: 3.3 <A HREF="#Shapes_10.htm">Shape Attributes</A>: 
Mix Mode</H3>
<PRE>GrGetMixMode(), GrSetMixMode()</PRE>
<P>
<A NAME="Shapes_13.htm_IX_MixMode">
 </A>
The kernel supports several mix modes. These modes control what will happen when something is drawn on top of something else. Normally when this occurs the new drawing covers up the old one. This is known as MM_COPY, since the new drawing is copied directly onto the graphics space.
<IMG SRC="Shapes_13_MixMode.gif">

</P>
<P>
<A NAME="Shapes_13.htm_IX_MM_&ldots;">
 </A>
There are many other mix modes available. </P>
<DL>
<DT>
MM_COPY</DT><DD>MM_COPY is the most common mix mode as well as the default. It draws the new drawing on top of the old as though the new drawing where on opaque paper--nothing of the old drawing shows through the region defined by the new drawing.</DD>
<DT>
MM_CLEAR</DT><DD>The region defined by the new drawing is blanked out. The color of the new drawing does not matter.</DD>
<DT>
MM_SET</DT><DD>The region defined by the new drawing is washed black. The color of the new drawing does not matter.</DD>
<DT>
MM_INVERT</DT><DD><A NAME="Shapes_13.htm_IX_Inverse drawing">
 </A>
The region defined by the new drawing is inverted. The color value displayed will be the logical inverse of the old color. The color of the new drawing does not matter.</DD>
<DT>
MM_NOP</DT><DD>The old drawing remains; nothing is drawn of the new drawing. Just about the only thing likely to change is that the pen position will be updated.</DD>
<DT>
MM_XOR</DT><DD>The color value to display is calculated by taking the bitwise XOR of the new and old colors. If painting in white, this acts as a sort of reverse paint. Note that this bitwise XOR<EM>
 </EM>
is applied to the index numbers of the colors, not to their RGB values.</DD>
<DT>
MM_OR</DT><DD>The color value to display is calculated by taking the bitwise OR of the new and old colors. On a monochrome display, this corresponds to drawing on a clear plastic overlay. The OR operation is applied to the indexes of the colors as opposed to their RGB values.</DD>
<DT>
MM_AND</DT><DD>The color value to display is calculated by taking the bitwise AND of the new and old colors. Where either drawing is blank, the result will be blank. On a monochrome display, this results in a &quot;clipping&quot; effect. The AND operation is applied to the indexes of the colors.<A NAME="Shapes_13.htm_marker=255785">
 </A>
</DD>
</DL>
<P>
<CODE>
GrGetMixMode()</CODE>
<A NAME="Shapes_13.htm_IX_GrGetMixMode()">
 </A>
 returns the current drawing mode.<A NAME="Shapes_13.htm_IX_GrSetMixMode()">
 </A>
 <CODE>
GrSetMixMode()</CODE>
 tells the system to use a new mode.</P>
<P>
Note that the drawing modes that use logical operators to compute the color have some nice effects when used with the default system colors. Due to the values of the indexes of the gray colors, MM_OR and MM_AND used with the gray colors can be thought of as lightening and darkening operations. For instance, AND-ing C_LIGHT_GRAY together with C_LIGHT_RED color results in the darker C_RED.</P>
<P>
When using drawing modes, it often pays to be aware of where a drawing command is drawing something as blank as opposed to where it isn't drawing at all. Filling a rectangular area of the screen with a black and white checkerboard pattern isn't exactly like drawing only the corresponding black squares. When using MM_COPY, the white areas of the checkerboard will overwrite whatever was underneath. When drawing a checkerboard with individual black squares, the background would show through no matter what background because there's nothing drawn between the squares.</P>
<HR>
<A NAME="Shapes_14.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Drawing Graphics</A>: 3.4 <A HREF="#Shapes_10.htm">Shape Attributes</A>: 
Masks</H3>
<PRE>GrSetAreaMaskSys(), GrSetAreaMaskCustom(), GrGetAreaMask(), GrSetLineMaskSys(), GrSetLineMaskCustom(), GrGetLineMask(), GrSetTextMaskSys(), GrSetTextMaskCustom(), GrGetTextMask()</PRE>
<P>
Masks are the pixellated equivalent of hatch patterns. Instead of specifying a set of dashed lines, the program uses an 8x8 bitmap array which will be tiled. The graphics system provides a number of standard mask patterns, including 65 percentage masks (for achieving, e.g., a 50% fill) and several shape patterns. It's simple to ask that the inverse of a system pattern be used instead of the pattern itself. The program may also specify and use custom draw masks by setting an 8 byte array. 
<IMG SRC="Shapes_14_maskRepeat.gif">

</P>
<P>
<A NAME="Shapes_14.htm_IX_GrGetAreaMask()">
 </A>
<A NAME="Shapes_14.htm_IX_GrSetAreaMaskCustom()">
 </A>
<A NAME="Shapes_14.htm_IX_GrSetAreaMaskSys()">
 </A>
The <CODE>
GrSetAreaMaskSys()</CODE>
 routine specifies one of the standard draw masks to use when filling areas. <CODE>
GrSetAreaMaskCustom()</CODE>
 allows the program to specify a custom mask by passing a pointer to an 8 byte. Each byte of the buffer represents one row of the mask; the rows are ordered from top to bottom. <CODE>
GrGetAreaMask()</CODE>
 returns the current area mask.</P>
<P>
<A NAME="Shapes_14.htm_IX_GrGetLineMask()">
 </A>
<A NAME="Shapes_14.htm_IX_GrSetLineMaskCustom()">
 </A>
<A NAME="Shapes_14.htm_IX_GrSetLineMaskSys()">
 </A>
There are similar routines which set the drawing mask to use when drawing lines: <CODE>
GrSetLineMaskSys()</CODE>
, <CODE>
GrSetLineMaskCustom()</CODE>
, and <CODE>
GrGetLineMask()</CODE>
. <A NAME="Shapes_14.htm_IX_GrGetTextMask()">
 </A>
<A NAME="Shapes_14.htm_IX_GrSetTextMaskCustom()">
 </A>
<A NAME="Shapes_14.htm_IX_GrSetTextMaskSys()">
 </A>
To work with the drawing mask used when rendering text, use <CODE>
GrSetTextMaskSys()</CODE>
, <CODE>
GrSetTextMaskCustom()</CODE>
, and <CODE>
GrGetTextMask()</CODE>
.</P>
<P>
For the most part, it's probably not a good idea to use masks when drawing text, since the pixelated nature of the mask is likely to make the text less legible. However, when drawing text in very large point sizes, draw masks are probably fine.</P>
<P>
Since several of the masks are associated with a fill percentage, some programmers may confuse masks with gray-scale fills. Grays should be implemented with colors, by drawing in a color with equal red, green, and blue values.
<IMG SRC="Shapes_14_maskThrough.gif">

</P>
<P>
When you are building a document image, do not use draw masks just to achieve a lighter color. That is, if you are not making use of the &quot;mask&quot; property of draw masks (i.e., you don't care if you can see through it), then you should just specify a lighter color and let the kernel do the dithering. This is important especially because drawing masks in PostScript takes much longer than drawing a bitmap of the same size.</P>
<P>
<A NAME="Shapes_14.htm_IX_SDM_&ldots;  (SystemDrawMask type)">
 </A>
<A NAME="Shapes_14.htm_IX_SystemDrawMask">
 </A>
<A NAME="Shapes_14.htm_IX_SysDrawMask">
 </A>
When constructing or interpreting system draw mask values, first remember that if the SDM_INVERSE flag is set, then the inverse of the mask will be used instead of the mask itself. The remaining bits should be a <CODE>
SystemDrawMask</CODE>
 value, a value between zero and SDM_0. Draw mask values between zero and 24 are various graphic draw mask patterns. Values between 25 and 89 are percentage fill masks, 89 corresponding to the empty fill and 25 to a 100% fill. Several SDM_... constants have been set up with the more commonly used system draw patterns. For a list of constants, see the Routines manual.</P>
<HR>
<A NAME="Shapes_15.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Drawing Graphics</A>: 3.5 <A HREF="#Shapes_10.htm">Shape Attributes</A>: 
Line-Specific Attributes</H3>
<PRE>GrGetLineWidth(), GrSetLineWidth(), GrGetLineJoin(), GrSetLineJoin(), GrGetLineEnd(), GrSetLineEnd(), GrSetMiterLimit(), GrGetLineStyle(), GrSetLineStyle(), GrSetLineAttr()</PRE>
<P>
Line attributes determine characteristics of lines drawn with the <CODE>
GrDraw...()</CODE>
 routines. They do not affect anything drawn with the <CODE>
GrFill...()</CODE>
 routines.</P>
<P>
<A NAME="Shapes_15.htm_IX_GrSetLineWidth()">
 </A>
<A NAME="Shapes_15.htm_IX_GrGetLineWidth()">
 </A>
You may work with the width used when drawing lines by means of the <CODE>
GrGetLineWidth()</CODE>
 and <CODE>
GrSetLineWidth()</CODE>
 routines.</P>
<P>
<A NAME="Shapes_15.htm_IX_GrSetLineStyle()">
 </A>
<A NAME="Shapes_15.htm_IX_GrGetLineStyle()">
 </A>
The graphics system makes it easy to draw dotted lines. The line style attribute controls the &quot;dottedness&quot; with which lines should be drawn; it may be changed or retrieved with the <CODE>
GrSetLineStyle()</CODE>
<A NAME="Shapes_15.htm_IX_GrSetLineStyle()">
 </A>
 and <A NAME="Shapes_15.htm_IX_GrGetLineStyle()">
 </A>
<CODE>
GrGetLineStyle()</CODE>
 routines.<A NAME="Shapes_15.htm_IX_LineStyle">
 </A>
 Lines can be drawn using any of a number of standard system <CODE>
LineStyle</CODE>
s or by defining a custom dot pattern.
<IMG SRC="Shapes_15_LineStyle.gif">

</P>
<P>
Custom dot patterns are defined in terms of arrays of pairs of bytes. The first byte of each pair gives the distance that the line should be drawn with the pen down, the second number the distance with the pen up. The array as a whole is stored in a <A NAME="Shapes_15.htm_IX_DashPairArray">
 </A>
<CODE>
DashPairArray</CODE>
. Dash lengths will scale with the line width.
<IMG SRC="Shapes_15_LineStyleArray.gif">

</P>
<P>
<A NAME="Shapes_15.htm_IX_GrGetLineJoin()">
 </A>
Line joins govern the behavior of angles and corners. Using the appropriate line join style, a geode can specify that angles should be blunt, pointed, or rounded. <CODE>
GrGetLineJoin()</CODE>
 returns the current line join drawing technique, <A NAME="Shapes_15.htm_IX_GrSetLineJoin()">
 </A>
while <CODE>
GrSetLineJoin()</CODE>
 sets a new line join to use. The join is specified by a member of the <A NAME="Shapes_15.htm_IX_LJ_&ldots;">
 </A>
<A NAME="Shapes_15.htm_IX_LineJoin">
 </A>
<CODE>
LineJoin</CODE>
 enumerated type. <A NAME="Shapes_15.htm_IX_GrGetMiterLimit()">
 </A>
<A NAME="Shapes_15.htm_IX_GrSetMiterLimit()">
 </A>
The miter limit governs the maximum length of mitererd joins; use <CODE>
GrSetMiterLimit()</CODE>
 and <CODE>
GrGetMiterLimit()</CODE>
 to work with this value.</P>
<P>
The <A NAME="Shapes_15.htm_IX_LE_&ldots;">
 </A>
<A NAME="Shapes_15.htm_IX_LineEnd">
 </A>
<A NAME="Shapes_15.htm_IX_GrGetLineEnd()">
 </A>
<A NAME="Shapes_15.htm_IX_GrSetLineEnd()">
 </A>
<CODE>
GrSetLineEnd()</CODE>
 and <CODE>
GrGetLineEnd()</CODE>
 routines set and retrieve the style with which the graphics system will draw the ends of line segments. The ending style is one of the <CODE>
LineEnd</CODE>
 values. It may be round, square and even with the end of the line, or square and extending past the mathematical end of the line.</P>
<P>
To set all of the line-drawing attributes at once, call <A NAME="Shapes_15.htm_IX_GrSetLineAttr()">
 </A>
<CODE>
GrSetLineAttr()</CODE>
.<A NAME="Shapes_15.htm_marker=255823">
 </A>
</P>
<HR>
This document is a single-page version of a <A HREF="index.htm">a multi-page document</A>, suitable for easy printing.
</BODY>
</HTML>
