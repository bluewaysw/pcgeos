<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD>
<!-- This page was automatically generated from a bunch of smaller pages. -->
<META NAME="copyright" CONTENT="Copyright GEOWORKS">
<LINK REL="STYLESHEET" HREF="../../docHelpers/style.css">
<LINK REV="MADE" HREF="mailto:doc-feedback@geoworks.com">
<TITLE>GEOS C Routine Reference</TITLE>
</HEAD>
<BODY BGCOLOR="#ffffdf">
This document is a single-page version of a <A HREF="index.htm">a multi-page document</A>, suitable for easy printing.
<A NAME="index.htm"></A>
<DIV>
</DIV>
<H1>GEOS C Routines Reference</H1>
<P>
This document contains reference information for most of the 
GEOS system routines.  You may look up information in this and 
other GEOS SDK documentation by consulting 
<A HREF="../../docIndexes/bigIndex/indexA.htm">the index</A>.  If, instead, you wish to browse 
this reference, you may choose one of the links below; the text of each 
is the name of the first routine documented on its page of the document.</P>
<P CLASS="sectionlinks">
<STRONG>
&nbsp;&nbsp;<A HREF="#R_1.htm">AccessPointCommit() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_2.htm">AccessPointGetStringPropertyBlock() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_3.htm">ArrayQuickSort() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_4.htm">CCB() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_5.htm">CFatalError() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_6.htm">ChunkArrayDelete() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_7.htm">ChunkArrayElementToPtr() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_8.htm">ChunkArrayGetCountHandles() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_9.htm">ChunkArraySort() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_a.htm">ClipboardClearQuickTransferNotification() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_b.htm">ClipboardQueryItem() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_c.htm">ClipboardSetQuickTransferFeedback() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_d.htm">ConstructOptr() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_e.htm">ContactGetDBHandle() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_f.htm">ContactMatchNumber() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_16.htm">DBAlloc() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_17.htm">DBDeref() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_18.htm">DBLock() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_19.htm">DiskCheckInUse() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_1a.htm">DiskForEach() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_1b.htm">DiskGetDrive() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_1c.htm">DiskSave() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_1d.htm">DriveGetDefaultMedia() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_1e.htm">EC() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_1f.htm">ECCheckHugeArray() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_20.htm">ECCheckProcessHandle() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_21.htm">ECVMCheckVMBlockHandle() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_22.htm">ElementArrayDelete() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_23.htm">ElementArrayRemoveReference() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_24.htm">FatalError() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_25.htm">FileCreate() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_26.htm">FileDeleteDir() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_27.htm">FileEnum() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_28.htm">FileEnumLocateAttr() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_29.htm">FileGetDiskHandle() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_2a.htm">FileOpen() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_2b.htm">FileRename() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_2c.htm">FileSetHandleExtAttributes() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_2d.htm">FileTruncate() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_2e.htm">FloatFloatToAscii() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_FoamCancel.htm">FoamCancelIfNoFreeSpace() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_FoamDBAdd.htm">FoamDBAddFieldToRecord() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_FoamDBGetCurrent.htm">FoamDBGetCurrentRecordID() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_FoamDBResumeUpdates.htm">FoamDBResumeUpdates() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_FoamDisplay.htm">FoamDisplayDeleteWarning() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_FoamDoc.htm">FoamDocCheckProtocol() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_FoamDocCreate.htm">FoamDocCreate() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_FoamDocSetBlock.htm">FoamDocSetBlockHandle() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_FoamGenerateUnique.htm">FoamGenerateUniqueFilename() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_FoamStandardDialog.htm">FoamStandardDialogOptr() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_FoamStartSound.htm">FoamStartSoundSequence() ...</A><BR>

&nbsp;&nbsp;<A HREF="#R_2f.htm">FormatIDFromManufacturerAndType ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_30.htm">GCNListAdd() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_31.htm">GCNListSend() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_32.htm">GenCopyChunk() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_33.htm">GeodeAllocQueue() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_34.htm">GeodeGetAppObject() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_35.htm">GeodeLoadDGroup ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_36.htm">GeoFree() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_37.htm">GrApplyTranslation() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_38.htm">GrClearBitmap() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_39.htm">GrDestroyBitmap() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_3a.htm">GrDrawCurve() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_3b.htm">GrDrawLine() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_3c.htm">GrDrawRect() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_3d.htm">GrDrawRoundRect() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_3e.htm">GrEndGString() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_3f.htm">GrFillEllipse() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_40.htm">GrGetAreaColor() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_41.htm">GrGetDefFontID() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_42.htm">GrGetLineMask() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_43.htm">GrGetPtrRegBounds() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_44.htm">GrInitDefaultTransform() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_45.htm">GrNewPage() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_46.htm">GrSDivDWFByWWF() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_47.htm">GrSetClipPath() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_48.htm">GrSetLineAttr() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_49.htm">GrSetPalette() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_4a.htm">GrSetTextMode() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_4b.htm">GrTestPointInPath() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_4c.htm">GrUDivWWFixed() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_4d.htm">GSCloseSubPath() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_4e.htm">GSDrawEllipse() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_4f.htm">GSDrawSpline() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_50.htm">GSFillBitmap() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_51.htm">GSMoveTo() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_52.htm">GSSetCustomLineMask() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_53.htm">GSSetLineEnd() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_54.htm">GSSetSubscriptAttr() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_55.htm">HAL_COUNT() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_56.htm">HandleV() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_57.htm">HugeArrayDestroy() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_58.htm">HugeArrayPrev() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_59.htm">IACPProcessMessage() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_5b.htm">InitFileEnumStringSection() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_5c.htm">InitFileReadStringBlock() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_5d.htm">InitFileRevert() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_5e.htm">InkDBGetDisplayInfo() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_5f.htm">InkFolderGetNumChildren() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_60.htm">InkNoteGetCreationDate() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_61.htm">InkNoteSetModificationDate() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_62.htm">isalnum() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_63.htm">LMemAlloc() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_64.htm">LMemGetChunkSize() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_65.htm">LMemReAlloc() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_66.htm">LocalAsciiToFixed() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_67.htm">LocalCustomParseDateTime() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_68.htm">LocalGeosToCodePage() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_69.htm">LocalLexicalValue() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_MailboxAck.htm">MailboxAcknowledgeMessageReceipt() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_MailboxGetBodyFormat.htm">MailboxGetBodyFormat() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_MailboxGetVMFile.htm">MailboxGetVMFile() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_6a.htm">MakeWWFixed() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_6b.htm">MemAlloc() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_6c.htm">MemDowngradeExclLock() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_6d.htm">MemLock() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_6e.htm">MemModifyFlags() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_6f.htm">MemThreadGrab() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_70.htm">MemUnlock() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_71.htm">ModemAnswerCall() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_72.htm">ModemSetMessageDataNotify() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_73.htm">NameArrayAdd() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_74.htm">NameArrayFind() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_75.htm">ObjCompFindChildByOptr() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_76.htm">ObjCompProcessChildren() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_77.htm">ObjDeref() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_78.htm">ObjDoRelocation() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_79.htm">ObjFreeChunk() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_7a.htm">ObjInitDetach() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_7b.htm">ObjIsClassADescendant() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_7c.htm">ObjResizeMaster() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_7d.htm">ObjVarAddData() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_7e.htm">ObjVarDeleteDataAt() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_7f.htm">ObjVarScanData() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_80.htm">ParallelClose() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_81.htm">PCCOMABORT() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_82.htm">qsort ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_83.htm">realloc() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_84.htm">SerialGetFormat() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_85.htm">SGC_MACHINE ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_86.htm">SocketBind() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_87.htm">SocketClose() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_88.htm">SocketGetAddressController() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_89.htm">SocketInterrupt() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_8a.htm">SocketRemoveLoadOnMsg() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_8b.htm">SoundAllocMusic() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_8c.htm">SoundFreeMusic() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_8d.htm">SoundPlayToMusicStream() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_8e.htm">SpeedDialGetNumber() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_8f.htm">SpoolGetNumPaperSizes() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_90.htm">SpoolModifyPriority() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_91.htm">StreamOpen() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_92.htm">StreamWrite() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_93.htm">SysGetPenMode() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_94.htm">SysShutdown() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_95.htm">TextSearchInString() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_96.htm">ThreadAttachToQueue() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_97.htm">ThreadGetError() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_98.htm">ThreadPSem() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_99.htm">TimerSleep() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_9a.htm">TocNameArrayFind() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_9b.htm">TokenDefineToken() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_9c.htm">TokenLoadMonikerBuffer() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_9d.htm">TokenLoadTokenChunk() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_9e.htm">UserAllocObjBlock ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_9f.htm">UserRemoveAutoExec() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_a0.htm">UtilAsciiToHex32() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_a1.htm">VirtualSerialSetFormat() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_a2.htm">VMClose() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_a3.htm">VMGetMapBlock() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_a4.htm">VMPreserveBlocksHandle() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_a5.htm">WinAckUpdate() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_a6.htm">WinGeodeSetInputObj() ...</A><BR>
&nbsp;&nbsp;<A HREF="#R_a7.htm">WinScroll() ...</A><BR>
</STRONG>
</P> <!-- end of sectionlinks blob -->
<HR>
<A NAME="R_1.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_1.htm_IX_AccessPointCommit()">
 </A>
<H1 CLASS="refHeading">
AccessPointCommit()</H1>
<PRE CLASS="syntax">void AccessPointCommit();</PRE>
<P>
This routine commits any access point data changes to permanent storage. The AccPnt library normally calls this routine when the device shuts down; applications thus need not call it. If you're trying to track down a bug which is likely to cause the system to crash before the changes can be committed, you may find this routine useful.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	accpnt.goh</P>
</DIV>
<DIV>
<A NAME="R_1.htm_IX_AccessPointCompareStandardProperty()">
 </A>
<H1 CLASS="refHeading">
AccessPointCompareStandardProperty()</H1>
<PRE CLASS="syntax">void AccessPointCompareStandardProperty(
        AccessPointStandardProperty 					prop,
        char 					*str);</PRE>
<P>
This routine compares the passed string to the name of the passed property.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	accpnt.goh</P>
</DIV>
<DIV>
<A NAME="R_1.htm_IX_AccessPointCreateEntry()">
 </A>
<H1 CLASS="refHeading">
AccessPointCreateEntry()</H1>
<PRE CLASS="syntax">word AccessPointCreateEntry(
        word 		loc,
        AccessPointType 		apt);</PRE>
<P>
This routine creates a new access point. </P>
<P>
After calling this routine, you will probably want to use the <CODE>
AccessPointSet...Property()</CODE>
 routines to provide some information about the new access point. </P>
<P CLASS="refField"><STRONG>
<STRONG>
Pass:</STRONG>	</STRONG>
</P>
<DL>
<DT>
<STRONG>
loc</STRONG>
</DT><DD>The access point before which to insert the new access point. Pass zero to append the new access point to the end of the list.</DD>
<DT>
<STRONG>
apt</STRONG>
</DT><DD>The <CODE>
AccessPointType</CODE>
 of the new access point. APT_INTERNET for an ISP, APT_TERMINAL for a dialup, etc.</DD>
</DL>
<P CLASS="refField"><STRONG>
<STRONG>
Return:</STRONG></STRONG>
	ID number of the new access point.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	accpnt.goh</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_2.htm#IX_AccessPointSetStringProperty()">AccessPointSetStringProperty()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_2.htm#IX_AccessPointSetIntegerProperty()">AccessPointSetIntegerProperty()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_1.htm_IX_AccessPointDestroyEntry()">
 </A>
<H1 CLASS="refHeading">
AccessPointDestroyEntry()</H1>
<PRE CLASS="syntax">Boolean AccessPointDestroyEntry(
        word id);</PRE>
<P>
This routine deletes an access point's information. If it returns non-zero, there was an error. (Perhaps the access point was locked or did not exist.)</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	accpnt.goh</P>
</DIV>
<DIV>
<A NAME="R_1.htm_IX_AccessPointDestroyProperty()">
 </A>
<H1 CLASS="refHeading">
AccessPointDestroyProperty()</H1>
<PRE CLASS="syntax">Boolean AccessPointDestroyProperty(
        word id, 
        char *prop);</PRE>
<P>
This routine destroys one of an access point's properties.</P>
<P CLASS="refField"><STRONG>
<STRONG>
Pass:</STRONG>	</STRONG>
</P>
<DL>
<DT>
<STRONG>
id</STRONG>
</DT><DD>The access point's ID number.</DD>
<DT>
<STRONG>
prop</STRONG>
</DT><DD>Either an <CODE>
AccessPointStandardProperty</CODE>
 value or a pointer to a buffer containing the property's name.</DD>
</DL>
<P CLASS="refField"><STRONG>
<STRONG>
Return:</STRONG></STRONG>
	Zero if there was no error, true if there was (no such access point, no such property, access point locked).</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	accpnt.goh</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_2.htm#IX_AccessPointSetStringProperty()">AccessPointSetStringProperty()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_2.htm#IX_AccessPointSetIntegerProperty()">AccessPointSetIntegerProperty()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_1.htm_IX_AccessPointGetEntries()">
 </A>
<H1 CLASS="refHeading">
AccessPointGetEntries()</H1>
<PRE CLASS="syntax">ChunkHandle AccessPointGetEntries(
        MemHandle 		mh,
        ChunkHandle 		chunk,
        AccessPointType 		apt);</PRE>
<P>
This routine gets a chunk array of all the access point IDs corresponding to access points of a given <CODE>
AccessPointType</CODE>
. Each element of the arraay is word-sized.</P>
<P CLASS="refField"><STRONG>
<STRONG>
Pass:</STRONG>	</STRONG>
</P>
<DL>
<DT>
<STRONG>
mh</STRONG>
</DT><DD>The memory block in which the chunk array shall reside.</DD>
<DT>
<STRONG>
chunk</STRONG>
</DT><DD>Either the ChunkHandle of a chunk array, or zero to request that the library allocate a chunk array.</DD>
<DT>
<STRONG>
apt</STRONG>
</DT><DD>The <CODE>
AccessPointType</CODE>
 we're interested in: APT_INTERNET, APT_TERMINAL, etc.</DD>
</DL>
<P CLASS="refField"><STRONG>
<STRONG>
Return:</STRONG></STRONG>
	The <CODE>
ChunkHandle</CODE>
 of the chunk array.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	accpnt.goh</P>
</DIV>
<DIV>
<A NAME="R_1.htm_IX_AccessPointGetIntegerProperty()">
 </A>
<H1 CLASS="refHeading">
AccessPointGetIntegerProperty()</H1>
<PRE CLASS="syntax">Boolean AccessPointGetIntegerProperty(
        word 	id,
        char 	*prop,
        int 	*val);</PRE>
<P>
This routine retrieves the value of one of an access point's property, representing the value as an integer.</P>
<P CLASS="refField"><STRONG>
<STRONG>
Pass:</STRONG>	</STRONG>
</P>
<DL>
<DT>
<STRONG>
id</STRONG>
</DT><DD>The access point's ID number.</DD>
<DT>
<STRONG>
prop</STRONG>
</DT><DD>Either an <CODE>
AccessPointStandardProperty</CODE>
 value or a pointer to a buffer containing the property's name.</DD>
<DT>
<STRONG>
val</STRONG>
 </DT><DD>Pointer to an integer; the routine will fill in this integer with the value of the property.</DD>
</DL>
<P CLASS="refField"><STRONG>
<STRONG>
Return:</STRONG></STRONG>
	Zero if there was no error, true if there was (no such access point, no such property).</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	accpnt.goh</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_2.htm#IX_AccessPointGetStringPropertyBuffer()">AccessPointGetStringPropertyBuffer()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_2.htm#IX_AccessPointGetStringPropertyBlock()">AccessPointGetStringPropertyBlock()</A></CODE>.</P>
</DIV>
<HR>
<A NAME="R_2.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_2.htm_IX_AccessPointGetStringPropertyBlock()">
 </A>
<H1 CLASS="refHeading">
AccessPointGetStringPropertyBlock()</H1>
<PRE CLASS="syntax">BooleanAccessPointGetStringPropertyBlock(
        word 		id,
        char 		*prop,
        MemHandle 		*data,
        int 		*datalen);</PRE>
<P>
This routine retrieves the value of one of an access point's property, returning the value as a string in a block of memory.</P>
<P CLASS="refField"><STRONG>
<STRONG>
Pass:</STRONG>	</STRONG>
</P>
<DL>
<DT>
<STRONG>
id</STRONG>
</DT><DD>The access point's ID number.</DD>
<DT>
<STRONG>
prop</STRONG>
</DT><DD>Either an <CODE>
AccessPointStandardProperty</CODE>
 value or a pointer to a buffer containing the property's name.</DD>
<DT>
<STRONG>
data</STRONG>
</DT><DD><CODE>
MemHandle</CODE>
 of block to fill with value (pass zero to request that the block be allocated).</DD>
<DT>
<STRONG>
dataLen</STRONG>
 </DT><DD>Pointer to integer; the routine will fill in this integer with the length of the value string, excluding the trailing NULL.</DD>
</DL>
<P CLASS="refField"><STRONG>
<STRONG>
Return:</STRONG></STRONG>
	Zero if there was no error, true if there was (no such access point, no such property).</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	accpnt.goh</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_2.htm#IX_AccessPointGetStringPropertyBuffer()">AccessPointGetStringPropertyBuffer()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_1.htm#IX_AccessPointGetIntegerProperty()">AccessPointGetIntegerProperty()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_2.htm_IX_AccessPointGetStringPropertyBuffer()">
 </A>
<H1 CLASS="refHeading">
AccessPointGetStringPropertyBuffer()</H1>
<PRE CLASS="syntax">Boolean AccessPointGetStringPropertyBuffer(
        word 	id,
        char 	*prop,
        char 	*buf,
        int 	*datalen);</PRE>
<P>
This routine retrieves the value of one of an access point's property, returning the value as a string in a buffer of memory.</P>
<P CLASS="refField"><STRONG>
<STRONG>
Pass:</STRONG>	</STRONG>
</P>
<DL>
<DT>
<STRONG>
id</STRONG>
</DT><DD>The access point's ID number.</DD>
<DT>
<STRONG>
prop</STRONG>
</DT><DD>Either an <CODE>
AccessPointStandardProperty</CODE>
 value or a pointer to a buffer containing the property's name.</DD>
<DT>
<STRONG>
buf</STRONG>
</DT><DD>Pointer to buffer to fill with value.</DD>
<DT>
<STRONG>
dataLen</STRONG>
 </DT><DD>Pointer to integer; pass the size of buf. The routine will fill in this integer with the length of the value string.</DD>
</DL>
<P CLASS="refField"><STRONG>
<STRONG>
Return:</STRONG></STRONG>
	Zero if there was no error, true if there was (no such access point, no such property).</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	accpnt.goh</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_2.htm#IX_AccessPointGetStringPropertyBlock()">AccessPointGetStringPropertyBlock()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_1.htm#IX_AccessPointGetIntegerProperty()">AccessPointGetIntegerProperty()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_2.htm_IX_AccessPointGetType()">
 </A>
<H1 CLASS="refHeading">
AccessPointGetType()</H1>
<PRE CLASS="syntax">AccessPointType AccessPointCommit(
        word id);</PRE>
<P>
This routine returns the type of an access point: APT_INTERNET, APT_TELNET, etc.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	accpnt.goh</P>
</DIV>


<DIV>
<A NAME="R_2.htm_IX_AccessPointInUse()">
 </A>
<H1 CLASS="refHeading">
AccessPointInUse()</H1>
<PRE CLASS="syntax">Boolean   AccessPointInUse (word id);</PRE>
<P>
If the access point with the ID <EM>id</EM> is being used by a connection, then this routine returns <CODE>TRUE</CODE> (non-zero); otherwise, it returns <CODE>FALSE</CODE> (zero).</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>
accpnt.goh
 </P>
</DIV>


<DIV>
<A NAME="R_2.htm_IX_AccessPointIsEntryValid()">
 </A>
<H1 CLASS="refHeading">
AccessPointIsEntryValid()</H1>
<PRE CLASS="syntax">Boolean AccessPointIsEntryValid(
        word id);</PRE>
<P>
This routine returns zero if the passed access point does not exist; it returns non-zero if it does exist.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	accpnt.goh</P>
</DIV>
<DIV>
<A NAME="R_2.htm_IX_AccessPointLock()">
 </A>
<H1 CLASS="refHeading">
AccessPointLock()</H1>
<PRE CLASS="syntax">void AccessPointLock(
        word id);</PRE>
<P>
This routine locks an access point, preventing changes to it.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	accpnt.goh</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_2.htm#IX_AccessPointUnlock()">AccessPointUnlock()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_2.htm_IX_AccessPointSetIntegerProperty()">
 </A>
<H1 CLASS="refHeading">
AccessPointSetIntegerProperty()</H1>
<PRE CLASS="syntax">Boolean AccessPointSetIntegerProperty(
        word 	id,
        char+ 	*prop,
        int 	val);</PRE>
<P>
This routine sets the value of one of an access point's properties to an integer.</P>
<P CLASS="refField"><STRONG>
<STRONG>
Pass:</STRONG>	</STRONG>
</P>
<DL>
<DT>
<STRONG>
id</STRONG>
</DT><DD>The access point's ID number.</DD>
<DT>
<STRONG>
prop</STRONG>
</DT><DD>Either an <CODE>
AccessPointStandardProperty</CODE>
 value or a pointer to a buffer containing the property's name.</DD>
<DT>
<STRONG>
val</STRONG>
</DT><DD>The new value for the property.</DD>
</DL>
<P CLASS="refField"><STRONG>
<STRONG>
Return:</STRONG></STRONG>
	Zero if there was no error, true if there was (no such access point, access point locked).</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	accpnt.goh</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_2.htm#IX_AccessPointSetStringProperty()">AccessPointSetStringProperty()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_2.htm_IX_AccessPointSetStringProperty()">
 </A>
<H1 CLASS="refHeading">
AccessPointSetStringProperty()</H1>
<PRE CLASS="syntax">Boolean AccessPointSetStringProperty(
        word id,
        char *prop,
        char *val);</PRE>
<P>
This routine sets the value of one of an access point's properties to a string.</P>
<P CLASS="refField"><STRONG>
<STRONG>
Pass:</STRONG>	</STRONG>
</P>
<DL>
<DT>
<STRONG>
id</STRONG>
</DT><DD>The access point's ID number.</DD>
<DT>
<STRONG>
prop</STRONG>
</DT><DD>Either an <CODE>
AccessPointStandardProperty</CODE>
 value or a pointer to a buffer containing the property's name.</DD>
<DT>
<STRONG>
val</STRONG>
</DT><DD>The new value for the property.</DD>
</DL>
<P CLASS="refField"><STRONG>
<STRONG>
Return:</STRONG></STRONG>
	Zero if there was no error, true if there was (no such access point, access point locked).</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	accpnt.goh</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_2.htm#IX_AccessPointSetIntegerProperty()">AccessPointSetIntegerProperty()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_2.htm_IX_AccessPointUnlock()">
 </A>
<H1 CLASS="refHeading">
AccessPointUnlock()</H1>
<PRE CLASS="syntax">void AccessPointUnlock(
        word id);</PRE>
<P>
This routine unlocks an access point that was previously locked.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	accpnt.goh</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_2.htm#IX_AccessPointLock()">AccessPointLock()</A></CODE>.</P>
</DIV>
<HR>
<A NAME="R_3.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_3.htm_IX_ArrayQuickSort()">
 </A>
<H1 CLASS="refHeading">
ArrayQuickSort()</H1>
<PRE CLASS="syntax">void	ArrayQuickSort(
        void	*array,	/* Pointer to start of array */
        word	count,	/* Number of elements in array */
        word	elementSize,	/* Size of each element (in bytes) */
        word	valueForCallback, 		/* Passed to callback routine */
        QuickSortParameters *parameters);</PRE>
<P>
This routine sorts an array of uniform-sized elements. It uses a modified QuickSort algorithm, using an insertion sort for subarrays below a certain size. The routine calls a callback routine to actually compare elements.</P>
<P>
<CODE>
ArrayQuickSort()</CODE>
 is passed five arguments: A pointer to the first element of the array, the number of elements in the array, the size of each element in bytes, a word of data (which is passed to all callback routines), and a pointer to a <CODE>
QuickSortParameters</CODE>
 structure.</P>
<P>
Before <CODE>
ArrayQuickSort()</CODE>
 examines or changes any element, it calls a locking routine specified by the <CODE>
QuickSortParameters</CODE>
 structure. This routine locks the element, if necessary, and takes any necessary prepatory steps. Similarly, after <CODE>
ArrayQuickSort()</CODE>
 is finished with a routine, it calls an unlocking routine in the <CODE>
QuickSortParameters</CODE>
. Each of these routines is passed a pointer to the element and the word of callback data which was passed to <CODE>
ArrayQuickSort()</CODE>
.</P>
<P>
The sort routine does not compare elements. Rather, it calls a comparison callback routine specified by the <CODE>
QuickSortParameters</CODE>
. This callback routine should be declared _pascal. Whenever <CODE>
ArrayQuickSort()</CODE>
 needs to compare two elements, it calls the callback routine, passing the addresses of the elements and the <CODE>
valueForCallback</CODE>
 word which was passed to <CODE>
<A HREF="../../CRef/Routines/R_9.htm#IX_ChunkArraySort()">ChunkArraySort()</A></CODE>
. The callback routine's return value determines which element will come first in the sorted array:</P>
<UL>
<LI>
If element <CODE>
el1</CODE>
 ought to come before <EM>
el2</EM>
 in the sorted array, the callback routine should return a negative integer.</LI>
<LI>
If element <CODE>
el1</CODE>
 ought to come after <EM>
el2</EM>
 in the sorted array, the callback routine should return a positive integer.</LI>
<LI>
If it doesn't matter whether <CODE>
el1</CODE>
 comes before or after <EM>
el2</EM>
 in the array, the callback routine should return zero.</LI>
</UL>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
chunkarr.h</STRONG>
 </P>
<P CLASS="refField"><STRONG>
Tips and Tricks:</STRONG>	You may need to sort an array based on different criteria at different times. The simplest way to do this is to write one general-purpose callback routine and have the <CODE>
valueForCallback</CODE>
 word determine how the sort is done. For example, the same callback routine could sort the array in ascending or descending order, depending on the <CODE>
valueForCallback</CODE>
.</P>
<P CLASS="refField"><STRONG>
Be Sure To:</STRONG>	Lock the array on the global heap (unless it is in fixed memory).</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	Do not have the callback routine do anything which might invalidate pointers to the array. For example, if the array is in a chunk, do not resize the chunks or allocate other chunks in the same LMem heap.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Structs/S_2f.htm#IX_QuickSortParameters">QuickSortParameters</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_9.htm#IX_ChunkArraySort()">ChunkArraySort()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_3.htm_IX_BlockFromTransferBlockID() macro">
 </A>
<H1 CLASS="refHeading">
BlockFromTransferBlockID</H1>
<PRE CLASS="syntax">VMBlockHandle BlockFromTransferBlockID(id);
        TransferBlockID	 	id;</PRE>
<P>
This macro extracts the VMBlockHandle from a <CODE>
TransferBlockID</CODE>
.</P>
</DIV>
<DIV>
<A NAME="R_3.htm_IX_BlockIDFromFileAndBlock() macro">
 </A>
<H1 CLASS="refHeading">
BlockIDFromFileAndBlock</H1>
<PRE CLASS="syntax">TransferBlockID BlockIDFromFileAndBlock(file, block);
        VMFileHandle 		file;
        VMBlockHandle 		block;</PRE>
<P>
This macro creates the dword type <CODE>
TransferBlockID</CODE>
 from a VMFileHandle and a VMBlockHandle.</P>
</DIV>
<DIV>
<A NAME="R_3.htm_IX_bsearch()">
 </A>
<A NAME="R_3.htm_IX_Binary search">
 </A>
<H1 CLASS="refHeading">
bsearch()</H1>
<PRE CLASS="syntax">extern void *_pascal bsearch(
        const void 		*key, 
        const void 		*array,
        word 		count, 
        word 		elementSize,
        PCB(int, compare, (const void *, const void *)));</PRE>
<P>
This is a standard binary search routine. The callback routine must be declared _pascal.</P>
</DIV>
<DIV>
<A NAME="R_3.htm_IX_calloc()">
 </A>
<H1 CLASS="refHeading">
calloc()</H1>
<PRE CLASS="syntax">void *	calloc(
        word		n,			/* number of structures to allocate */
        size_t		size);			/* size of each structure in bytes */</PRE>
<P>
The <CODE>
<A HREF="../../CRef/Routines/R_6a.htm#IX_malloc()">malloc()</A></CODE>
 family of routines is provided for Standard C compatibility. If a geode needs a small amount of fixed memory, it can call one of the routines. The kernel will allocate a fixed block to satisfy the geode's <CODE>
<A HREF="../../CRef/Routines/R_6a.htm#IX_malloc()">malloc()</A></CODE>
 requests; it will allocate memory from this block. When the block is filled, it will allocate another fixed malloc-block. When all the memory in the block is freed, the memory manager will automatically free the block.</P>
<P>
When a geode calls <CODE>
calloc()</CODE>
, it will be allocated a contiguous section of memory large enough for the specified number of structures of the specified size. The memory will be allocated out of its malloc-block, and the address of the start of the memory will be returned. The memory will be zero-initialized. If the request cannot be satisfied, <CODE>
calloc()</CODE>
 will return a null pointer. The memory is guaranteed not to be moved until it is freed (with <CODE>
<A HREF="../../CRef/Routines/R_2f.htm#IX_free()">free()</A></CODE>
) or resized (with <CODE>
<A HREF="../../CRef/Routines/R_83.htm#IX_realloc()">realloc()</A></CODE>
). When GEOS shuts down, all fixed blocks are freed, and any memory allocated with <CODE>
calloc()</CODE>
 is lost.</P>
<P CLASS="refField"><STRONG>
Tips and Tricks:</STRONG>	You can allocate memory in another geode's malloc-block by calling <CODE>
<A HREF="../../CRef/Routines/R_36.htm#IX_GeoMalloc()">GeoMalloc()</A></CODE>
. However, that block will be freed when the other geode exits.</P>
<P CLASS="refField"><STRONG>
Be Sure To:</STRONG>	Request a size small enough to fit in a malloc-block; that is, the size of the structure times the number of structures requested must be somewhat smaller than 64K.</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	All memory allocated with <CODE>
calloc()</CODE>
 is freed when GEOS shuts down.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_6a.htm#IX_malloc()">malloc()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_2f.htm#IX_free()">free()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_36.htm#IX_GeoMalloc()">GeoMalloc()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_83.htm#IX_realloc()">realloc()</A></CODE>.</P>
</DIV>
<HR>
<A NAME="R_4.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_4.htm_IX_CCB() macro">
 </A>
<A NAME="R_4.htm_IX_callback routines:CCB() macro">
 </A>
<H1 CLASS="refHeading">
CCB()</H1>
<PRE CLASS="syntax">#define CCB(return_type, pointer_name, args) \
        return_type _cdecl (*pointer_name) args</PRE>
<P>
This macro is useful for declaring pointers to functions that use the C calling conventions. For example, to declare a pointer to a function which is passed two strings and returns an integer, one could write</P>
<PRE>CCB(int, func_ptr, (const char *, const char *));</PRE>
<P>
which would be expanded to</P>
<PRE>int _cdecl (*func_ptr) (const char *, const char *);</PRE>
<P>
Different compilers have different syntax for the _cdecl keyword. Using this macro makes your callback compiler-independent.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_80.htm#IX_PCB()">PCB()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_4.htm_IX_CellDeref()">
 </A>
<H1 CLASS="refHeading">
CellDeref()</H1>
<PRE CLASS="syntax">void *	CellDeref(
        optr		CellRef);</PRE>
<P>
This routine translates an optr to a cell into the cell's address. The routine is simply a synonym for <CODE>
<A HREF="../../CRef/Routines/R_63.htm#IX_LMemDeref()">LMemDeref()</A></CODE>
.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<CODE>
cell.h</CODE>
 </P>
</DIV>
<DIV>
<A NAME="R_4.htm_IX_CellDirty()">
 </A>
<H1 CLASS="refHeading">
CellDirty()</H1>
<PRE CLASS="syntax">void	CellDirty(
        void *		ptr);		/* pointer to anywhere in locked cell */</PRE>
<P>
This routine marks a cell as &quot;dirty&quot;; i.e., the cell will have to be copied from memory back to the disk.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<CODE>
cell.h</CODE>
 </P>
<P CLASS="refField"><STRONG>
Tips and Tricks:</STRONG>	All the cells in an item block are marked dirty at once; thus, you can call this routine just once for several cells in the same item block. Only the segment portion of the pointer is significant; thus, you can pass a pointer to anywhere in the cell. This is useful if you have incremented the pointer to the cell.</P>
</DIV>
<DIV>
<A NAME="R_4.htm_IX_CellGetDBItem()">
 </A>
<H1 CLASS="refHeading">
CellGetDBItem()</H1>
<PRE CLASS="syntax">DBGroupAndItem 	CellGetDBItem(
        CellFunctionParameters *			cfp,
        word		row,			/* Get handles of cell in this row */
        byte		column);			/*...and this column */</PRE>
<P>
All cells are stored as ungrouped DB items. If you wish to manipulate the cells with standard DB routines, you will need to know their handles. The routine is passed the address of the <CODE>
CellFunctionParameters</CODE>
 and the row and column indices of the desired cell. It returns the <CODE>
DBGroupAndItem</CODE>
 value for the specified cell. If there is no cell at the specified coordinates, it returns a null <CODE>
DBGroupAndItem</CODE>
. The routine does not lock the cell or change it in any way.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<CODE>
cell.h</CODE>
 </P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Structs/S_d.htm#IX_DBGroupAndItem">DBGroupAndItem</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_4.htm_IX_CellGetExtent()">
 </A>
<H1 CLASS="refHeading">
CellGetExtent()</H1>
<PRE CLASS="syntax">void	CellGetExtent(
        CellFunctionParameters *cfp,
        RangeEnumParams 		*rep); /* write boundaries in REP_bounds field */</PRE>
<P>
This routine returns the boundaries of the utilized portion of the cell file. The routine is passed the address of the cell file's <CODE>
CellFunctionParameters</CODE>
 structure.) It writes the results into the <CODE>
REP_bounds</CODE>
 field of the passed <CODE>
RangeEnumParams</CODE>
 structure. The index of the first row to contain cells is written into <CODE>
REP_bounds.R_top</CODE>
; the index of the last occupied row is written to <CODE>
REP_bounds.R_bottom</CODE>
; the index of the first occupied column is written to <CODE>
REP_bounds.R_left</CODE>
; and the index of the last occupied row is written to <CODE>
REP_bounds.R_right</CODE>
. If the cell file contains no cells, all four fields will be set to -1..</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
cell.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_4.htm_IX_CellLock()">
 </A>
<H1 CLASS="refHeading">
CellLock()</H1>
<PRE CLASS="syntax">void *	CellLock(
        CellFunctionParameters*			cfp,
        word			row,			/* Lock cell in this row... */
        word			column);			/* ... and this column */</PRE>
<P>
This routine is passed the address of the <CODE>
CellFunctionParameters</CODE>
 of a cell file, and the row and column indices of a cell. It locks the cell and returns a pointer to it.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
cell.h</STRONG>
 </P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_4.htm#IX_CellLockGetRef()">CellLockGetRef()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_4.htm_IX_CellLockGetRef()">
 </A>
<H1 CLASS="refHeading">
CellLockGetRef()</H1>
<PRE CLASS="syntax">void *	CellLockGetRef(
        CellFunctionParameters*			cfp,
        word			row,			/* Lock cell in this row... */
        word			column,			/* ... and this column */
        optr *			ref);			/* Write handles here */</PRE>
<P>
This routine is passed the address of the <CODE>
CellFunctionParameters</CODE>
 of a cell file, and the row and column indices of a cell. It locks the cell and returns a pointer to it. It also writes the locked cell's item-block and chunk handles to the optr. If the cell moves (e.g. because another cell is allocated), you can translate the optr structure into a pointer by passing it to <CODE>
<A HREF="../../CRef/Routines/R_4.htm#IX_CellDeref()">CellDeref()</A></CODE>
.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
cell.h</STRONG>
 </P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	The optr becomes invalid when the cell is unlocked.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_4.htm#IX_CellGetDBItem()">CellGetDBItem().</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_4.htm#IX_CellLock()">CellLock()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_4.htm_IX_CellReplace()">
 </A>
<H1 CLASS="refHeading">
CellReplace()</H1>
<PRE CLASS="syntax">void	CellReplace{
        CellFunctionParameters *			cfp,
        word		row,		/* Insert/replace cell at this row... */
        word		column,			/* ... and this column */
        const void *		cellData,			/* Copy this data into the new cell */
        word		size);			/* Size of new cell (in bytes) */</PRE>
<P>
This routine is used for creating, deleting, and replacing cells in a cell file. To create or replace a cell, set <EM>
cellData</EM>
 to point to the data to copy into the new cell, and set <EM>
size</EM>
 to the length of the cell in bytes, and <EM>
row</EM>
 and <EM>
column</EM>
 the cell's coordinates. (As usual, <EM>
cfp</EM>
 is a pointer to the cell file's <CODE>
CellFunctionParameters</CODE>
 structure.) Any pre-existing cell at the specified coordinates will automatically be freed, and a new cell will be created.</P>
<P>
To delete a cell, pass a <EM>
size</EM>
 of zero. If there is a cell at the specified coordinates, it will be freed. (The <EM>
cellData</EM>
 argument is ignored.)</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
cell.h</STRONG>
 </P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	If a cell is allocated or replaced, pointers to all ungrouped items (including cells) in that VM file may be invalidated. The <CODE>
CellFunctionParameters</CODE>
 structure must not move during the call; for this reason, it may not be in an ungrouped DB item. Never replace or free a locked cell; if you do, the cell's item block will not have its lock count decremented, which will prevent the block from being unlocked.</P>
</DIV>
<DIV>
<A NAME="R_4.htm_IX_CellUnlock()">
 </A>
<H1 CLASS="refHeading">
CellUnlock()</H1>
<PRE CLASS="syntax">void	CellUnlock(
        void *	ptr); /* pointer to anywhere in locked cell */</PRE>
<P>
This routine unlocks the cell pointed to by <EM>
ptr</EM>
. Note that a cell may be locked several times. When all locks on all cells in an item-block have been released, the block can be swapped back to the disk.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
cell.h</STRONG>
 </P>
<P CLASS="refField"><STRONG>
Tips and Tricks:</STRONG>	The DB manager does not keep track of locks on individual items; instead, it keeps a count of the total number of locks on all the items in an item-block. For this reason, only the segment address of the cell is significant; thus, you can pass a pointer to somewhere within (or immediately after) a cell to unlock it. This is useful if you have incremented the pointer to the cell.</P>
<P CLASS="refField"><STRONG>
Be Sure To:</STRONG>	If you change the cell, dirty it (with <CODE>
<A HREF="../../CRef/Routines/R_4.htm#IX_CellDirty()">CellDirty()</A></CODE>
) <EM>
before</EM>
 you unlock it.</P>
</DIV>
<HR>
<A NAME="R_5.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_5.htm_IX_CFatalError()">
 </A>
<H1 CLASS="refHeading">
CFatalError()</H1>
<PRE CLASS="syntax">void	CFatalError(
        word	code)</PRE>
<P>
This routine generates a fatal error. It stores an error code passed for use by the debugger.</P>
</DIV>
<DIV>
<A NAME="R_5.htm_IX_ChunkArrayAppend()">
 </A>
<H1 CLASS="refHeading">
ChunkArrayAppend()</H1>
<PRE CLASS="syntax">void *	ChunkArrayAppend(
        optr	array,				/* optr to chunk array */
        word	elementSize)				/* Size of new element (ignored if 
						 * elements are uniform-sized) */</PRE>
<P>
This routine adds a new element to the end of a chunk array. It automatically expands the chunk to make room for the element and updates the <CODE>
ChunkArrayHeader</CODE>
. It returns a pointer to the new element.</P>
<P>
One of the arguments is the size of the new element. This argument is significant if the array contains variable-sized elements. If the elements are uniform-sized, this argument is ignored. The array is specified with an optr.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
chunkarr.h</STRONG>
</P>
<P CLASS="refField"><STRONG>
Be Sure To:</STRONG>	Lock the block on the global heap (if it is not fixed).</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	This routine resizes the chunk, which means it can cause heap compaction or resizing. Therefore, all existing pointers to within the LMem heap are invalidated.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_8.htm#IX_ChunkArrayInsertAt()">ChunkArrayInsertAt()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_6.htm#IX_ChunkArrayDelete()">ChunkArrayDelete()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_5.htm_IX_ChunkArrayAppendHandles()">
 </A>
<H1 CLASS="refHeading">
ChunkArrayAppendHandles()</H1>
<PRE CLASS="syntax">void *	ChunkArrayAppendHandles(
        MemHandle		mh,				/* Handle of LMem heap's block */
        ChunkHandle		ch,				/* Handle of chunk array */
        word		size)				/* Size of new element (ignored if 
							 * elements are uniform-sized) */</PRE>
<P>
This routine is exactly like <CODE>
<A HREF="../../CRef/Routines/R_5.htm#IX_ChunkArrayAppend()">ChunkArrayAppend()</A></CODE>
, except that the chunk array is specified by its global and local handles instead of by an optr.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
chunkarr.h</STRONG>
</P>
<P CLASS="refField"><STRONG>
Be Sure To:</STRONG>	Lock the block on the global heap (if it is not fixed).</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	This routine resizes the chunk, which means it can cause heap compaction or resizing. Therefore, all existing pointers to within the LMem heap are invalidated.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_8.htm#IX_ChunkArrayInsertAt()">ChunkArrayInsertAt()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_6.htm#IX_ChunkArrayDelete()">ChunkArrayDelete()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_5.htm_IX_ChunkArrayCreate()">
 </A>
<H1 CLASS="refHeading">
ChunkArrayCreate()</H1>
<PRE CLASS="syntax">ChunkHandle	 ChunkArrayCreate(
        MemHandle 	mh,	/* Handle of LMem heap's block */
        word	elementSize,	/* Size of each element (or zero if elements are
			 * variable-sized) */</PRE>
<PRE CLASS="syntax">        word	headerSize,	/* Amount of chunk to use for header (or zero for
		 	 * default size) */</PRE>
<PRE CLASS="syntax">        ObjChunkFlags ocf);</PRE>
<P>
This routine sets up a chunk array in the specified LMem heap. The heap must have already been initialized normally. The routine allocates a chunk and sets up a chunk array in it. It returns the chunk's handle. If it cannot create the chunk array, it returns a null handle.</P>
<P>
If the chunk array will have uniform-size elements, you must specify the element size when you create the chunk array. You will not be able to change this. If the array will have variable-sized elements, pass an element size of zero.</P>
<P>
The chunk array always begins with a <CODE>
ChunkArrayHeader</CODE>
. You can specify the total header size; this is useful if you want to begin the chunk array with a special header containing some extra data. However, the header must be large enough to accommodate a <CODE>
ChunkArrayHeader</CODE>
, which will begin the chunk. If you define a header structure, make sure that its first element is a <CODE>
ChunkArrayHeader</CODE>
. Only the chunk array code should access the actual <CODE>
ChunkArrayHeader</CODE>
. If you pass a <CODE>
headerSize</CODE>
 of zero, the default header size will be used (namely, <CODE>
sizeof(ChunkArrayHeader)</CODE>
). If you pass a non-zero <CODE>
headerSize</CODE>
, any space between the <CODE>
ChunkArrayHeader</CODE>
 and the heap will be zero-initialized.</P>
<P>
To free a chunk array, call <CODE>
<A HREF="../../CRef/Routines/R_63.htm#IX_LMemFree()">LMemFree()</A></CODE>
 as you would for any chunk.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
chunkarr.h</STRONG>
 </P>
<P CLASS="refField"><STRONG>
Be Sure To:</STRONG>	Lock the LMem heap's block on the global heap (unless it is fixed).</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	Results are unpredictable if you pass a non-zero <CODE>
headerSize</CODE>
 argument which is smaller than <CODE>
sizeof(ChunkArrayHeader)</CODE>
. Since the routine allocates a chunk, it can cause heap compaction or resizing; all pointers to within the block are invalidated.</P>
</DIV>
<DIV>
<A NAME="R_5.htm_IX_ChunkArrayCreateAt()">
 </A>
<H1 CLASS="refHeading">
ChunkArrayCreateAt()</H1>
<PRE CLASS="syntax">ChunkHandle 	ChunkArrayCreateAt(
        optr	array,	/* Create chunk array in this chunk */
        word	elementSize,	/* Size of each element (or zero if elements are
			 * variable-sized) */</PRE>
<PRE CLASS="syntax">        word	headerSize,	/* Amount of chunk to use for header (or zero for
			 * default size) */</PRE>
<PRE CLASS="syntax">        ObjChunkFlags ocf);</PRE>
<P>
This routine is exactly like <CODE>
<A HREF="../../CRef/Routines/R_5.htm#IX_ChunkArrayCreate()">ChunkArrayCreate()</A></CODE>
, except that you specify the chunk which will be made into a chunk array. The chunk is specified with an optr. Note that any data already existing in the chunk will be overwritten.</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	The chunk may be resized, which invalidates all pointers to within the LMem heap.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
chunkarr.h</STRONG>
</P>
</DIV>
<DIV>
<A NAME="R_5.htm_IX_ChunkArrayCreateAtHandles()">
 </A>
<H1 CLASS="refHeading">
ChunkArrayCreateAtHandles()</H1>
<PRE CLASS="syntax">ChunkHandle 	ChunkArrayCreateAtHandles(
        MemHandle 		mh,
        ChunkHandle 		ch,
        word		elementSize,
        word		headerSize,
        ObjChunkFlags		ocf);</PRE>
<P>
This routine is exactly like <CODE>
<A HREF="../../CRef/Routines/R_5.htm#IX_ChunkArrayCreate()">ChunkArrayCreate()</A></CODE>
, except that the chunk is specified with its global and chunk handles instead of with an optr.</P>
<P CLASS="refField"><STRONG>
Tips and Tricks:</STRONG>	If you pass a null chunk handle, a new chunk will be allocated.</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	The chunk may be resized, which would invalidate all pointers to within the LMem heap.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
chunkarr.h</STRONG>
</P>
</DIV>
<HR>
<A NAME="R_6.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_6.htm_IX_ChunkArrayDelete()">
 </A>
<H1 CLASS="refHeading">
ChunkArrayDelete()</H1>
<PRE CLASS="syntax">void	ChunkArrayDelete(
        optr	array,				/* optr to chunk array */
        void *	element);				/* Address of element to delete */</PRE>
<P>
This routine deletes an element from a chunk array. It is passed the address of that element, as well as the optr of the array.</P>
<P>
Since the chunk is being decreased in size, the routine is guaranteed not to cause heap compaction or resizing.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
chunkarr.h</STRONG>
</P>
<P CLASS="refField"><STRONG>
Be Sure To:</STRONG>	Lock the LMem heap's block on the global heap (unless it is fixed).</P>
<P CLASS="refField"><STRONG>
Tips and Tricks:</STRONG>	Only the chunk handle portion of the optr is significant; the memory block is determined from the pointer to the element.</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	The addresses of all elements after the deleted one will change. No other addresses in the block will be affected. If the address passed is not the address of an element in the array, results are undefined.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_5.htm#IX_ChunkArrayAppend()">ChunkArrayAppend()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_8.htm#IX_ChunkArrayInsertAt()">ChunkArrayInsertAt()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_9.htm#IX_ChunkArrayZero()">ChunkArrayZero()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_6.htm_IX_ChunkArrayDeleteHandle()">
 </A>
<H1 CLASS="refHeading">
ChunkArrayDeleteHandle()</H1>
<PRE CLASS="syntax">void	ChunkArrayDeleteHandle(
        ChunkHandle		ch,				/* Handle of chunk array */
        void *		el);				/* Address of element to delete */</PRE>
<P>
This routine is exactly like <CODE>
<A HREF="../../CRef/Routines/R_6.htm#IX_ChunkArrayDelete()">ChunkArrayDelete()</A></CODE>
, except that the chunk array is specified with its chunk handle instead of with an optr. The global memory handle is not needed, as the memory block is implicit in the pointer to the element.</P>
<P CLASS="refField"><STRONG>
Be Sure To:</STRONG>	Lock the LMem heap's block on the global heap (unless it is fixed).</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
chunkarr.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_6.htm_IX_ChunkArrayDeleteRange()">
 </A>
<H1 CLASS="refHeading">
ChunkArrayDeleteRange()</H1>
<PRE CLASS="syntax">void	ChunkArrayDeleteRange(
        optr	array,		/* optr to chunk array */
        word	firstElement,		/* index of first element to delete */
        word	count);		/* # of elements to delete (-1 to delete to 
				 * end of array) */</PRE>
<P>
This routine deletes several consecutive elements from a chunk array. The routine is passed the optr of the chunk array, the index of the first element to delete, and the number of elements to delete. The routine is guaranteed not to cause heap compaction or resizing; thus, pointers to other elements in the array will remain valid.</P>
</DIV>
<DIV>
<A NAME="R_6.htm_IX_ChunkArrayElementResize()">
 </A>
<H1 CLASS="refHeading">
ChunkArrayElementResize()</H1>
<PRE CLASS="syntax">void	ChunkArrayElementResize(
        optr	array,				/* optr to chunk array */
        word	element,				/* Index of element to resize */
        word	newSize);				/* New size of element, in bytes */</PRE>
<P>
This routine resizes an element in a chunk array. The chunk array must have variable-sized elements. The routine is passed an optr to the chunk array (which must be locked on the global heap), as well as the index of the element to resize and the new size (in bytes). It does not return anything.</P>
<P>
If the new size is larger than the old, null bytes will be added to the end of the element. If the new size is smaller than the old, bytes will be removed from the end to truncate the element to the new size.</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	If the element is resized larger, the chunk array may move within the LMem heap, and the heap itself may move on the global heap; thus, all pointers to within the LMem heap will be invalidated. </P>
<P CLASS="refField"><STRONG>
Be Sure To:</STRONG>	Lock the LMem heap's block on the global heap (unless it is fixed).</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
chunkarr.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_6.htm_IX_ChunkArrayElementResizeHandles()">
 </A>
<H1 CLASS="refHeading">
ChunkArrayElementResizeHandles()</H1>
<PRE CLASS="syntax">void	ChunkArrayElementResizeHandles(
        Memhandle		mh,				/* Global handle of LMem heap */
        ChunkHandle		ch,				/* Chunk handle of chunk array */
        word		el,				/* Index of element to resize */
        word		ns);				/* New size of element, in bytes */</PRE>
<P>
This routine is exactly like <CODE>
<A HREF="../../CRef/Routines/R_6.htm#IX_ChunkArrayElementResize()">ChunkArrayElementResize()</A></CODE>
 except that the chunk array is specified with its global and chunk handles, instead of with its optr.</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	If the element is resized to larger than the old, the chunk array may move within the LMem heap, and the heap itself may move on the global heap; thus, all pointers to within the LMem heap will be invalidated. </P>
<P CLASS="refField"><STRONG>
Be Sure To:</STRONG>	Lock the LMem heap's block on the global heap (unless it is fixed).</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
chunkarr.h</STRONG>
 </P>
</DIV>
<HR>
<A NAME="R_7.htm"></A>

<DIV>
</DIV>

<DIV>
<HR>
<P>
<H1 CLASS="refHeading"><A NAME="R_7.htm_IX_ChunkArrayElementToPtr()">ChunkArrayElementToPtr()</A>
</H1>
<PRE>
void *  ChunkArrayElementToPtr(
        optr           array,                                  /* optr to chunk array */
        word           elementNumber,                                  /* Element to get address of */
        void *         elementSize);                                   /* Write element's size here */

</PRE>
<P>
This routine translates the index of an element into the element's
address. The routine is passed an optr to the chunk array, the
index of the element in question, and a pointer to a word-sized
variable. It returns a pointer to the element. If the elements
in the array are of variable size, it writes the size of the element
to the variable pointed to by the <EM>elementSize</EM> pointer.
If the elements are of uniform size, it does not do this.</P>
<P>
If the array index is out of bounds, the routine returns a pointer
to the last element in the array. The routine will also do this
if you pass the constant CA_LAST_ELEMENT.</P>
<P CLASS="refField">
<STRONG>Include:</STRONG> <STRONG>chunkarr.h</STRONG></P>
<P CLASS="refField">
<STRONG>Tips and Tricks:</STRONG> If you are not interested in
the element's size, pass a null pointer as the third argument.</P>
<P CLASS="refField">
<STRONG>Be Sure To:</STRONG> Lock the LMem heap's block on the
global heap (unless it is fixed).</P>
<P CLASS="refField">
<STRONG>Warnings:</STRONG> The error-checking version fatal-errors
if passed the index CA_NULL_ELEMENT (i.e. 0xffff, or -1).</P></DIV><DIV>
<H1 CLASS="refHeading"><A NAME="R_7.htm_IX_ChunkArrayElementToPtrHandles()">ChunkArrayElementToPtrHandles()</A>
</H1>
<PRE>
void *  ChunkArrayElementToPtrHandles(
        Memhandle              mh,                                     /* Handle of LMem heap's block */
        ChunkHandle            chunk,                                  /* Handle of chunk array */
        word           elementNumber,                                  /* Element to get address of */
        void *         elementSize);                                   /* Write element's size here */

</PRE>
<P>
This routine is just like <A HREF="../../CRef/Routines/R_7.htm#IX_ChunkArrayElementToPtr()">ChunkArrayElementToPtr()</A>
, except that the chunk array is specified with its global and
chunk handles, instead of with an optr.</P>
<P CLASS="refField">
<STRONG>Include:</STRONG> <STRONG>chunkarr.h</STRONG></P>
<P CLASS="refField">
<STRONG>Tips and Tricks:</STRONG> If you are not interested in
the element's size, pass a null pointer as the fourth argument.</P>
<P CLASS="refField">
<STRONG>Be Sure To:</STRONG> Lock the LMem heap's block on the
global heap (unless it is fixed).</P>
<P CLASS="refField">
<STRONG>See Also:</STRONG> <A HREF="../../CRef/Routines/R_8.htm#IX_ChunkArrayPtrToElement()">ChunkArrayPtrToElement()</A>.</P>
<P CLASS="refField">
<STRONG>Warnings:</STRONG> The error-checking version fatal-errors
if passed the index CA_NULL_ELEMENT (i.e. 0xffff, or -1).</P></DIV><DIV>
<H1 CLASS="refHeading"><A NAME="R_7.htm_IX_ChunkArrayEnum()">ChunkArrayEnum()</A>
</H1>
<PRE>
Boolean ChunkArrayEnum(
        optr           array,                  /* optr to chunk array */
        void *         enumData,                       /* This is passed to callback routine */
        Boolean _pascal (*callback) (void *element, void *enumData));
        /* callback called for each element; returns TRUE to stop */

</PRE>
<P>
This routine lets you apply a procedure to every element in a
chunk array. The routine is passed an optr to the chunk array,
a pointer (which is passed to the callback routine), and a pointer
to a Boolean callback routine. The callback routine, in turn,
is called once for each element in the array, and is passed two
arguments: a pointer to an element and the pointer which was passed
to <CODE>ChunkArrayEnum()</CODE> . If the callback routine ever
returns <EM>true</EM> for an element, <CODE>ChunkArrayEnum()</CODE>
will stop with that element and return <EM>true</EM> . If it enumerates
every element without being aborted, it returns <EM>false</EM>.</P>

<P>
The callback routine can call such routines as 
<A HREF="../../CRef/Routines/R_5.htm#IX_ChunkArrayAppend()">ChunkArrayAppend()</A>,
<A HREF="../../CRef/Routines/R_8.htm#IX_ChunkArrayInsertAt()">ChunkArrayInsertAt(),</A> 
and <A HREF="../../CRef/Routines/R_6.htm#IX_ChunkArrayDelete()">ChunkArrayDelete()</A>
. <CODE>ChunkArrayEnum()</CODE> will see to it that every element
is enumerated exactly once. The callback routine can even make
a nested call to <CODE>ChunkArrayEnum()</CODE> ; the nested call
will be completed for every element before the outer call goes
to the next element. The callback routine should be declared _pascal.</P>

<A NAME="R_7.htm_IX_CHUNK_ARRAY_ENUM_INSERT_OR_DELETE_RUN_BY_MULTIPLE_THREADS"></A>
<P>You can get into trouble if more than one thread of execution 
is accessing a single ChunkArray and one or both of these threads 
is using one of the ChunkArrayEnum...() routines.  The error-checking 
version of the kernel detects this situation and generates a 
CHUNK_ARRAY_ENUM_INSERT_OR_DELETE_RUN_BY_MULTIPLE_THREADS warning 
if it detects such.  If your code is getting this warning, you should 
add some synchronization between threads.  While one thread is enumerating 
through chunks in the chunk array, the other should do nothing to 
enumerate the same array, nor alter the array in any way.</P>

<P CLASS="refField">
<STRONG>Include:</STRONG> <STRONG>chunkarr.h</STRONG></P>
<P CLASS="refField">
<STRONG>Be Sure To:</STRONG> Lock the LMem heap's block on the
global heap (unless it is fixed).</P></DIV>

<DIV> 
<H1 CLASS="refHeading"><A NAME="R_7.htm_IX_ChunkArrayEnumHandles()">ChunkArrayEnumHandles()</A>
</H1>
<PRE>
Boolean ChunkArrayEnumHandles(
        MemHandle              mh,                     /* Handle of LMem heap's block */
        ChunkHandle            ch,                     /* Handle of chunk array */
        void *         enumData,                       /* Buffer used by callback routine */
        Boolean _pascal (*callback) (void *element, void *enumData));
        /* callback called for each element; returns TRUE to stop */

</PRE>
<P>
This routine is exactly like <A HREF="../../CRef/Routines/R_7.htm#IX_ChunkArrayEnum()">ChunkArrayEnum()</A>
, except that the chunk array is specified by its global and chunk
handles (instead of with an optr). </P>

<P>You can get into trouble if more than one thread of execution 
is accessing a single ChunkArray and one or both of these threads 
is using one of the ChunkArrayEnum...() routines.  The error-checking 
version of the kernel detects this situation and generates a 
CHUNK_ARRAY_ENUM_INSERT_OR_DELETE_RUN_BY_MULTIPLE_THREADS warning 
if it detects such.  If your code is getting this warning, you should 
add some synchronization between threads.  While one thread is enumerating 
through chunks in the chunk array, the other should do nothing to 
enumerate the same array, nor alter the array in any way.</P>

<P CLASS="refField">
<STRONG>Include:</STRONG> <STRONG>chunkarr.h</STRONG></P></DIV>

<DIV> 
<H1 CLASS="refHeading"><A NAME="R_7.htm_IX_ChunkArrayEnumRange()">ChunkArrayEnumRange()</A>
</H1>
<PRE>
Boolean         ChunkArrayEnumRange(
        optr   array,  /* optr to chunk array */
        word   startElement,   /* Start enumeration with this element */
        word   count,  /* Process this many elements */
        void * enumData,       /* This is passed to the callback routine */
        Boolean _pascal (*callback)            /* Return TRUE to halt enumeration */
               (void *element, void *enumData));

</PRE>
<P>
This routine is exactly like <A HREF="../../CRef/Routines/R_7.htm#IX_ChunkArrayEnum()">ChunkArrayEnum()</A>
(described above), except that it acts on a limited portion of
the array. It is passed two additional arguments: the index of
the starting element, and the number of elements to process. It
will begin the enumeration with the element specified (remember,
the first element in a chunk array has an index of zero). If the
count passed would take the enumeration past the end of the array,
<CODE>ChunkArrayEnumRange()</CODE> will automatically stop with
the last element. You can instruct <CODE>ChunkArrayEnumRange()</CODE>
to process all elements by passing a <CODE>count</CODE> of CA_LAST_ELEMENT.</P>

<P>You can get into trouble if more than one thread of execution 
is accessing a single ChunkArray and one or both of these threads 
is using one of the ChunkArrayEnum...() routines.  The error-checking 
version of the kernel detects this situation and generates a 
CHUNK_ARRAY_ENUM_INSERT_OR_DELETE_RUN_BY_MULTIPLE_THREADS warning 
if it detects such.  If your code is getting this warning, you should 
add some synchronization between threads.  While one thread is enumerating 
through chunks in the chunk array, the other should do nothing to 
enumerate the same array, nor alter the array in any way.</P>

<P CLASS="refField">
<STRONG>Include:</STRONG> <STRONG>chunkarr.h</STRONG></P>
<P CLASS="refField">
<STRONG>Warnings:</STRONG> The start element must be within the
bounds of the array.</P>
<P CLASS="refField">
<STRONG>See Also:</STRONG> <A HREF="../../CRef/Routines/R_7.htm#IX_ChunkArrayEnum()">ChunkArrayEnum()</A>.</P></DIV>

<DIV>
<H1 CLASS="refHeading"><A NAME="R_7.htm_IX_ChunkArrayEnumRangeHandles()">ChunkArrayEnumRangeHandles()</A>
</H1>
<PRE>
Boolean         ChunkArrayEnumRangeHandles(
        MemHandle      mh,     /* Handle of LMem heap's block */
        ChunkHandle    ch,     /* Handle of chunk array */
        word   startElement,   /* Start enumeration with this element */
        word   count,  /* Process this many elements */
        void * enumData,       /* This is passed to the callback routine */
        Boolean _pascal (*callback)            /* Return TRUE to halt enumeration */
               (void *element, void *enumData));

</PRE>
<P>
This routine is exactly like <A HREF="../../CRef/Routines/R_7.htm#IX_ChunkArrayEnumRange()">ChunkArrayEnumRange()</A>
, except that the chunk array is specified by its global and chunk
handles (instead of with an optr).</P>

<P>You can get into trouble if more than one thread of execution 
is accessing a single ChunkArray and one or both of these threads 
is using one of the ChunkArrayEnum...() routines.  The error-checking 
version of the kernel detects this situation and generates a 
CHUNK_ARRAY_ENUM_INSERT_OR_DELETE_RUN_BY_MULTIPLE_THREADS warning 
if it detects such.  If your code is getting this warning, you should 
add some synchronization between threads.  While one thread is enumerating 
through chunks in the chunk array, the other should do nothing to 
enumerate the same array, nor alter the array in any way.</P>
</DIV>

<DIV> 
<H1 CLASS="refHeading"><A NAME="R_7.htm_IX_ChunkArrayGetCount()">ChunkArrayGetCount()</A>
</H1>
<PRE>
word    ChunkArrayGetCount(
        optr   array);                         /* optr of chunk array */

</PRE>
<P>
This routine returns the number of elements in the specified chunk
array.</P>
<P CLASS="refField">
<STRONG>Include:</STRONG> <STRONG>chunkarr.h</STRONG></P>
<P CLASS="refField">
<STRONG>Tips and Tricks:</STRONG> It is usually faster to examine
the CAH<CODE> _count</CODE> field of the <CODE>ChunkArrayHeader</CODE>
. This field is the first word of the <CODE>ChunkArrayHeader</CODE>
(and therefore of the chunk). It contains the number of elements
in the chunk array.</P>
<P CLASS="refField">
<STRONG>Be Sure To:</STRONG> Lock the LMem heap's block on the
global heap (unless it is fixed).</P>
<P CLASS="refField">
<STRONG>See Also:</STRONG> <A HREF="../../CRef/Structs/S_6.htm#IX_ChunkArrayHeader">ChunkArrayHeader</A>.</P></DIV>
<HR>
<P>

<A NAME="R_8.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_8.htm_IX_ChunkArrayGetCountHandles()">
 </A>
<H1 CLASS="refHeading">
ChunkArrayGetCountHandles()</H1>
<PRE CLASS="syntax">word	ChunkArrayGetCountHandles(
        MemHandle		mh,				/* Handle of LMem heap's block */
        ChunkHandle		ch);				/* Handle of chunk array */</PRE>
<P>
This routine is just like <CODE>
<A HREF="../../CRef/Routines/R_7.htm#IX_ChunkArrayGetCount()">ChunkArrayGetCount()</A></CODE>
, except that the chunk array is specified by its global and local handles (instead of with an optr).</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
chunkarr.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_8.htm_IX_ChunkArrayGetElement()">
 </A>
<H1 CLASS="refHeading">
ChunkArrayGetElement()</H1>
<PRE CLASS="syntax">void	ChunkArrayGetElement(
        optr	array,					/* optr to chunk array */
        word	elementNumber,					/* Index of element to copy */
        void *	buffer);					/* Address to copy element to */</PRE>
<P>
This routine copies an element in a chunk array into the passed buffer. It is your responsibility to make sure the buffer is large enough to hold the element.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
chunkarr.h</STRONG>
 </P>
<P CLASS="refField"><STRONG>
Be Sure To:</STRONG>	Lock the LMem heap's block on the global heap (unless it is fixed). Make sure the buffer is large enough to hold the element.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_8.htm#IX_ChunkArrayPtrToElement()">ChunkArrayPtrToElement()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_7.htm#IX_ChunkArrayElementToPtr()">ChunkArrayElementToPtr()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_8.htm_IX_ChunkArrayGetElementHandles()">
 </A>
<H1 CLASS="refHeading">
ChunkArrayGetElementHandles()</H1>
<PRE CLASS="syntax">void	ChunkArrayGetElementHandles(
        Memhandle		mh,					/* Handle of LMem heap's block */
        ChunkHandle		array,					/* Handle of chunk array */
        word		elementNumber,					/* Index of element to copy */
        void *		buffer);					/* Address to copy element to */</PRE>
<P>
This routine is just like <CODE>
<A HREF="../../CRef/Routines/R_8.htm#IX_ChunkArrayGetElement()">ChunkArrayGetElement()</A></CODE>
, except that the chunk array is specified by its global and chunk handles (instead of with an optr).</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
chunkarr.h</STRONG>
 </P>
<P CLASS="refField"><STRONG>
Be Sure To:</STRONG>	Lock the LMem heap's block on the global heap (unless it is fixed). Make sure the buffer is large enough to hold the element.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_8.htm#IX_ChunkArrayPtrToElement()">ChunkArrayPtrToElement()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_7.htm#IX_ChunkArrayElementToPtr()">ChunkArrayElementToPtr()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_8.htm_IX_ChunkArrayInsertAt()">
 </A>
<H1 CLASS="refHeading">
ChunkArrayInsertAt()</H1>
<PRE CLASS="syntax">void *	ChunkArrayInsertAt(
        optr		array,				/* Handle of chunk array */
        void *		insertPointer,				/* Address at which to insert
							 * element */</PRE>
<PRE CLASS="syntax">        word		elementSize);				/* Size of new element (ignored
							 * if elements are uniform-sized) */</PRE>
<P>
This routine inserts a new element in a chunk array. You specify the location by passing a pointer to an element. A new element will be allocated at that location; thus, the element which was pointed to will be shifted, so it ends up immediately after the new element. The new element will be zero-initialized.</P>
<P>
The routine is passed three arguments: the optr of the array, the address where the new element should be inserted, and the size of the new element. (If the array is of uniform-size elements, the size argument will be ignored.) </P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
chunkarr.h</STRONG>
 </P>
<P CLASS="refField"><STRONG>
Tips and Tricks:</STRONG>	Only the chunk-handle portion of the optr is significant; the memory block is implicit in the pointer to the element.</P>
<P CLASS="refField"><STRONG>
Be Sure To:</STRONG>	Lock the block on the global heap (if it is not fixed).</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	If the address passed is not the address of an element already in the chunk array, results are undefined. The routine may cause heap compaction or resizing; all pointers within the block are invalidated.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_5.htm#IX_ChunkArrayAppend()">ChunkArrayAppend()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_6.htm#IX_ChunkArrayDelete()">ChunkArrayDelete()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_8.htm_IX_ChunkArrayInsertAtHandle()">
 </A>
<H1 CLASS="refHeading">
ChunkArrayInsertAtHandle()</H1>
<PRE CLASS="syntax">void *	ChunkArrayInsertAtHandle(
        ChunkHandle		chunk,				/* Handle of chunk array */
        void *		insertPointer,				/* Address at which to insert
							 * element */</PRE>
<PRE CLASS="syntax">        word		elementSize);				/* Size of new element (ignored
							 * if elements are uniform-sized) */</PRE>
<P>
This routine is just like <CODE>
<A HREF="../../CRef/Routines/R_8.htm#IX_ChunkArrayInsertAt()">ChunkArrayInsertAt()</A></CODE>
, except that the chunk array is specified by its chunk handle. (The global block is implicit in the pointer passed.)</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
chunkarr.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_8.htm_IX_ChunkArrayPtrToElement()">
 </A>
<H1 CLASS="refHeading">
ChunkArrayPtrToElement()</H1>
<PRE CLASS="syntax">word	ChunkArrayPtrToElement(
        optr	array,						/* Handle of chunk array */
        void *	element);						/* Address of element */</PRE>
<P>
This routine takes the address of an element in a chunk array, as well as an optr to the array. It returns the element's zero-based index.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
chunkarr.h</STRONG>
 </P>
<P CLASS="refField"><STRONG>
Tips and Tricks:</STRONG>	Only the chunk-handle portion of the optr is significant; the memory block is implicit in the pointer to the element.</P>
<P CLASS="refField"><STRONG>
Be Sure To:</STRONG>	Lock the block on the global heap (unless it is fixed).</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	If the address passed is not the address of the beginning of an element, results are unpredictable.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_7.htm#IX_ChunkArrayElementToPtr()">ChunkArrayElementToPtr()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_8.htm_IX_ChunkArrayPtrToElementHandle()">
 </A>
<H1 CLASS="refHeading">
ChunkArrayPtrToElementHandle()</H1>
<PRE CLASS="syntax">word 	ChunkArrayPtrToElementHandle(
        ChunkHandle		array,			/* chunk handle of chunk array */
        void *		element);			/* Pointer to element to delete */</PRE>
<P>
This routine is exactly like <CODE>
<A HREF="../../CRef/Routines/R_8.htm#IX_ChunkArrayPtrToElement()">ChunkArrayPtrToElement()</A></CODE>
, except that the chunk array is indicated by its chunk handle. (The global block is implicit in the pointer passed.)</P>
</DIV>
<HR>
<A NAME="R_9.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_9.htm_IX_ChunkArraySort()">
 </A>
<H1 CLASS="refHeading">
ChunkArraySort()</H1>
<PRE CLASS="syntax">void	ChunkArraySort(
        optr		array,					/* optr to chunk array */
        word		valueForCallback,					/* Passed to callback routine */
        sword _pascal (*callback)				(void *el1, 
				 void * el2, 
				 word valueForCallback))
	/* Sign of return value decides order of elements */</PRE>
<P>
This is a general-purpose sort routine for chunk arrays. It does a modified Quicksort on the array, using an insertion sort for subarrays below a certain size.</P>
<P>
The sort routine does not compare elements. Rather, it calls a comparison callback routine passed in the <CODE>
callback</CODE>
 parameter. Whenever it needs to compare two elements, it calls the callback routine, passing the addresses of the elements and the <CODE>
valueForCallback</CODE>
 word which was passed to <CODE>
ChunkArraySort()</CODE>
. The callback routine should be declared _pascal. The callback routine's return value determines which element will come first in the sorted array:</P>
<UL>
<LI>
If element <CODE>
el1</CODE>
 ought to come before <EM>
el2</EM>
 in the sorted array, the callback routine should return a negative integer.</LI>
<LI>
If element <CODE>
el1</CODE>
 ought to come after <EM>
el2</EM>
 in the sorted array, the callback routine should return a positive integer.</LI>
<LI>
If it doesn't matter whether <CODE>
el1</CODE>
 comes before or after <EM>
el2</EM>
 in the sorted array, the callback routine should return zero.</LI>
</UL>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
chunkarr.h</STRONG>
 </P>
<P CLASS="refField"><STRONG>
Tips and Tricks:</STRONG>	You may need to sort an array based on different criteria at different times. The simplest way to do this is to write one general-purpose callback routine and have the <CODE>
valueForCallback</CODE>
 word determine how the sort is done. For example, the same callback routine could sort the array in ascending or descending order, depending on the <CODE>
valueForCallback</CODE>
.</P>
<P CLASS="refField"><STRONG>
Be Sure To:</STRONG>	Lock the block on the global heap (unless it is fixed).</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	Do not have the callback routine do anything which might invalidate pointers to the array (such as allocate a new chunk or element).</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_3.htm#IX_ArrayQuickSort()">ArrayQuickSort()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_9.htm_IX_ChunkArraySortHandles()">
 </A>
<H1 CLASS="refHeading">
ChunkArraySortHandles()</H1>
<PRE CLASS="syntax">void	ChunkArraySortHandles(
        MemHandle		memHandle,					/* Handle of LMem heap's block */
        ChunkHandle		chunkHandle,					/* Handle chunk array */
        word		valueForCallback,					/* Passed to callback routine */
        sword _pascal(*callback)(void *el1, void * el2, word valueForCallback)
	/* Sign of return value decides order of elements */</PRE>
<P>
This routine is exactly like <CODE>
<A HREF="../../CRef/Routines/R_9.htm#IX_ChunkArraySort()">ChunkArraySort()</A></CODE>
 above, except that the chunk array is specified by its global and chunk handles (instead of by an optr).</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
chunkarr.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_9.htm_IX_ChunkArrayZero()">
 </A>
<H1 CLASS="refHeading">
ChunkArrayZero()</H1>
<PRE CLASS="syntax">void	ChunkArrayZero(
        optr	array);		/* optr to chunk array */</PRE>
<P>
This routine destroys all the elements in an array. It does not affect the extra-space area between the <CODE>
ChunkArrayHeader</CODE>
 and the elements. It is guaranteed not to cause heap compaction or resizing; thus, pointers to other chunks remain valid.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
chunkarr.h</STRONG>
 </P>
<P CLASS="refField"><STRONG>
Be Sure To:</STRONG>	Lock the block on the global heap (unless it is fixed).</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_6.htm#IX_ChunkArrayDelete()">ChunkArrayDelete()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_9.htm_IX_ChunkArrayZeroHandles()">
 </A>
<H1 CLASS="refHeading">
ChunkArrayZeroHandles()</H1>
<PRE CLASS="syntax">void	ChunkArrayZeroHandles(
        MemHandle		mh		/* Global handle of LMem heap */
        ChunkHandle		ch);		/* Chunk handle of chunk array */</PRE>
<P>
This routine is exactly like <CODE>
<A HREF="../../CRef/Routines/R_9.htm#IX_ChunkArrayZero()">ChunkArrayZero()</A></CODE>
 above, except that the chunk array is specified by its global and chunk handles (instead of by an optr).</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
chunkarr.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_9.htm_IX_ClipboardAbortQuickTransfer()">
 </A>
<H1 CLASS="refHeading">
ClipboardAbortQuickTransfer()</H1>
<PRE CLASS="syntax">void	ClipboardAbortQuickTransfer(void);</PRE>
<P>
This routine cancels a quick-transfer operation in progress. It is typically used when an object involved in a quick-transfer is shutting down or when an error occurs in a quick-transfer. This routine is usually used only by the object or Process which initiated the quick-transfer.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
clipbrd.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_9.htm_IX_ClipboardAddToNotificationList()">
 </A>
<H1 CLASS="refHeading">
ClipboardAddToNotificationList()</H1>
<PRE CLASS="syntax">void	ClipboardAddToNotificationList(
        optr	notificationOD);</PRE>
<P>
This routine registers the passed object or process for quick-transfer notification. This routine is typically called from within an object's <CODE>
MSG_META_INITIALIZE</CODE>
 handler or within a Process object's <CODE>
MSG_GEN_PROCESS_OPEN_APPLICATION</CODE>
 handler. Pass the optr of the object or the geode handle if the Process object should be registered.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
clipbrd.goh</STRONG>
 </P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_b.htm#IX_ClipboardRemoveFromNotificationList()">ClipboardRemoveFromNotificationList()</A></CODE>.</P>
</DIV>
<HR>
<A NAME="R_a.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_a.htm_IX_ClipboardClearQuickTransferNotification()">
 </A>
<H1 CLASS="refHeading">
ClipboardClearQuickTransferNotification()</H1>
<PRE CLASS="syntax">void	ClipboardClearQuickTransferNotification(
        optr	notificationOD);</PRE>
<P>
This routine removes an object or process from quick-transfer notification. It is typically used in the object's <CODE>
MSG_META_DETACH</CODE>
 handler or in the Process object's <CODE>
MSG_GEN_PROCESS_CLOSE_APPLICATION</CODE>
 to ensure that it is not notified after it has already detached.</P>
<P>
Pass the optr of the object specified to receive notification in <CODE>
<A HREF="../../CRef/Routines/R_c.htm#IX_ClipboardStartQuickTransfer()">ClipboardStartQuickTransfer()</A></CODE>
 (or the geode handle if a process).</P>
<P>
Note that an object may also want to check if a quick-transfer is in progress when detaching and possibly abort it if there is one.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
clipbrd.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_a.htm_IX_ClipboardDoneWithItem()">
 </A>
<H1 CLASS="refHeading">
ClipboardDoneWithItem()</H1>
<PRE CLASS="syntax">void	ClipboardDoneWithItem(
        TransferBlockID header);</PRE>
<P>
This routine is called when an object or Process is done using a transfer item. It relinquishes exclusive access to the item's transfer VM file after the caller had previously called <CODE>
<A HREF="../../CRef/Routines/R_b.htm#IX_ClipboardQueryItem()">ClipboardQueryItem()</A></CODE>
.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
clipbrd.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_a.htm_IX_ClipboardEndQuickTransfer()">
 </A>
<H1 CLASS="refHeading">
ClipboardEndQuickTransfer()</H1>
<PRE CLASS="syntax">void	ClipboardEndQuickTransfer(
        ClipboardQuickNotifyFlags 				flags);</PRE>
<P>
This routine ends a quick-transfer operation by resetting the pointer image, clearing any quick-transfer region, clearing the quick-transfer item, and sending out any needed notification of the completed transfer.</P>
<P>
Pass this routine a record of <CODE>
ClipboardQuickNotifyFlags</CODE>
. Pass the value CQNF_MOVE if the operation was completed and was a move; pass CQNF_COPY if the operation was completed and was a copy. If the operation could not be completed (e.g. incompatible data types), pass CQNF_NO_OPERATION or CQNF_ERROR.</P>
<P>
The notification sent out by the UI will be in the form of the message <CODE>
MSG_META_CLIPBOARD_NOTIFY_QUICK_TRANSFER_CONCLUDED</CODE>
. This message notifies the originator of the transfer item of the type of operation; the originator can then respond if necessary.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
clipbrd.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_a.htm_IX_ClipboardEnumItemFormats()">
 </A>
<H1 CLASS="refHeading">
ClipboardEnumItemFormats()</H1>
<PRE CLASS="syntax">word	ClipboardEnumItemFormats(
        TransferBlockID 		header,
        word 		maxNumFormats,
        ClipboardFormatID *		buffer);</PRE>
<P>
This routine returns a list of all the formats supported by the current transfer item. To see whether a particular format is supported, you can use <CODE>
<A HREF="../../CRef/Routines/R_c.htm#IX_ClipboardTestItemFormat()">ClipboardTestItemFormat()</A></CODE>
 instead.</P>
<P>
Pass this routine the following:</P>
<DL>
<DT>
<CODE>
header</CODE>
</DT><DD>The transfer item header as returned by <CODE>
<A HREF="../../CRef/Routines/R_b.htm#IX_ClipboardQueryItem()">ClipboardQueryItem()</A></CODE>
.</DD>
<DT>
<CODE>
maxNumFormats</DT><DD>
</CODE>
The maximum number of formats that should be returned. You should set your return buffer (see below) large enough to support this size.</DD>
<DT>
<CODE>
buffer</CODE>
</DT><DD>A pointer to a locked or fixed buffer into which the formats will be copied. Upon return, the buffer will contain the proper number of <CODE>
ClipboardFormatID</CODE>
 structures, one for each format available. This buffer should be at least large enough to support the number of formats requested in <CODE>
maxNumFormats</CODE>
.</DD>
</DL>
<P>
The word return value is the total number of formats returned. This number will be equal to or less than the number passed in <CODE>
maxNumFormats</CODE>
. The routine will also return the passed buffer filled with that number of <CODE>
ClipboardFormatID</CODE>
 structures.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
clipbrd.goh</STRONG>
 </P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_c.htm#IX_ClipboardTestItemFormat()">ClipboardTestItemFormat()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_a.htm_IX_ClipboardGetClipboardFile()">
 </A>
<H1 CLASS="refHeading">
ClipboardGetClipboardFile()</H1>
<PRE CLASS="syntax">VMFileHandle ClipboardGetClipboardFile(void);</PRE>
<P>
This routine returns the VM file handle of the current default transfer VM file.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
clipbrd.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_a.htm_IX_ClipboardGetItemInfo()">
 </A>
<H1 CLASS="refHeading">
ClipboardGetItemInfo()</H1>
<PRE CLASS="syntax">optr	ClipboardGetItemInfo(
        TransferBlockID header);</PRE>
<P>
This routine returns the source identifier (CIH<CODE>
_sourceID</CODE>
) of the current transfer item. Pass the transfer item's header returned by <CODE>
<A HREF="../../CRef/Routines/R_b.htm#IX_ClipboardQueryItem()">ClipboardQueryItem()</A></CODE>
. </P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
clipbrd.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_a.htm_IX_ClipboardGetNormalItemInfo()">
 </A>
<H1 CLASS="refHeading">
ClipboardGetNormalItemInfo()</H1>
<PRE CLASS="syntax">TransferBlockID ClipboardGetNormalItemInfo(void);</PRE>
<P>
This routine returns information about the normal transfer item. It returns a <CODE>
TransferBlockID</CODE>
 dword which contains the VM file handle of the transfer file and the VM block handle of the transfer item's header block.</P>
<P>
To extract the file handle from the return value, use the macro <CODE>
<A HREF="../../CRef/Routines/R_28.htm#IX_FileFromTransferBlockID() macro">FileFromTransferBlockID()</A></CODE>
. To extract the block handle, use the macro <CODE>
<A HREF="../../CRef/Routines/R_3.htm#IX_BlockFromTransferBlockID() macro">BlockFromTransferBlockID()</A></CODE>
.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
clipbrd.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_a.htm_IX_ClipboardGetQuickItemInfo()">
 </A>
<H1 CLASS="refHeading">
ClipboardGetQuickItemInfo()</H1>
<PRE CLASS="syntax">TransferBlockID ClipboardGetQuickItemInfo(void);</PRE>
<P>
This routine returns information about the quick-transfer transfer item. It returns a <CODE>
TransferBlockID</CODE>
 dword which contains the VM file handle of the transfer file and the VM block handle of the transfer item's header block.</P>
<P>
To extract the file handle from the return value, use the macro <CODE>
<A HREF="../../CRef/Routines/R_28.htm#IX_FileFromTransferBlockID() macro">FileFromTransferBlockID()</A></CODE>
. To extract the block handle, use the macro <CODE>
<A HREF="../../CRef/Routines/R_3.htm#IX_BlockFromTransferBlockID() macro">BlockFromTransferBlockID()</A></CODE>
.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
clipbrd.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_a.htm_IX_ClipboardGetQuickTransferStatus()">
 </A>
<H1 CLASS="refHeading">
ClipboardGetQuickTransferStatus()</H1>
<PRE CLASS="syntax">Boolean	ClipboardGetQuickTransferStatus(void);</PRE>
<P>
This routine returns <CODE>
true</CODE>
 if a quick-transfer operation is in progress, <CODE>
false</CODE>
 otherwise. It is often called when objects or Processes are shutting down in order to abort any quick-transfers originated by the caller.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
clipbrd.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_a.htm_IX_ClipboardGetUndoItemInfo()">
 </A>
<H1 CLASS="refHeading">
ClipboardGetUndoItemInfo()</H1>
<PRE CLASS="syntax">TransferBlockID ClipboardGetUndoItemInfo(void);</PRE>
<P>
This routine returns information about the undo transfer item. It returns a <CODE>
TransferBlockID</CODE>
 dword which contains the VM file handle of the transfer file and the VM block handle of the transfer item's header block.</P>
<P>
To extract the file handle from the return value, use the macro <CODE>
<A HREF="../../CRef/Routines/R_28.htm#IX_FileFromTransferBlockID() macro">FileFromTransferBlockID()</A></CODE>
. To extract the block handle, use the macro <CODE>
<A HREF="../../CRef/Routines/R_3.htm#IX_BlockFromTransferBlockID() macro">BlockFromTransferBlockID()</A></CODE>
.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
clipbrd.goh</STRONG>
 </P>
</DIV>
<HR>
<A NAME="R_b.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_b.htm_IX_ClipboardQueryItem()">
 </A>
	<A NAME="R_b.htm_IX_ClipboardQueryArgs">
 </A>
<A NAME="R_b.htm_IX_CQA_&ldots;">
 </A>
<H1 CLASS="refHeading">
ClipboardQueryItem()</H1>
<PRE CLASS="syntax">void	ClipboardQueryItem(
        ClipboardItemFlags 			flags,
        ClipboardQueryArgs *			retValues);</PRE>
<P>
This routine locks the transfer item for the caller's exclusive access and returns information about the current transfer item. You should call this routine when beginning any paste or clipboard query operation. For operations in which you will change the clipboard's contents, you should instead use the routine <CODE>
<A HREF="../../CRef/Routines/R_b.htm#IX_ClipboardRegisterItem()">ClipboardRegisterItem()</A></CODE>
.</P>
<P>
Pass the following values:</P>
<DL>
<DT>
<CODE>
flags</CODE>
</DT><DD>A record of <CODE>
ClipboardItemFlags</CODE>
 indicating the transfer item you want to query. Use CIF_QUICK to get information on the quick transfer item, and pass zero (or TIF_NORMAL) to get information on the normal transfer item.</DD>
<DT>
<CODE>
retValues</CODE>
A pointer to an empty <CODE>
ClipboardQueryArgs</CODE>
 structure into which return information about the transfer item will be passed. This structure is defined as follows:</DT>
<PRE>typedef struct {
	word			CQA_numFormats;
	optr			CQA_owner;
	TransferBlockID			CQA_header;
} ClipboardQueryArgs;</PRE>
</DL>
<P>
The <CODE>
CQA_header</CODE>
 field of <CODE>
ClipboardQueryArgs</CODE>
 is used as a pass value to several other clipboard routines. It contains the VM file handle of the transfer VM file and the VM block handle of the transfer item's header block. The <CODE>
CQA_owner</CODE>
 field is the optr of the object that originated the transfer item. The <CODE>
CQA_numFormats</CODE>
 field specifies the total number of formats available for this transfer item. To see if a particular format is supported by the transfer item, call the routine <CODE>
<A HREF="../../CRef/Routines/R_c.htm#IX_ClipboardTestItemFormat()">ClipboardTestItemFormat()</A></CODE>
.</P>
<P CLASS="refField"><STRONG>
Be Sure To:</STRONG>	You must call <CODE>
<A HREF="../../CRef/Routines/R_a.htm#IX_ClipboardDoneWithItem()">ClipboardDoneWithItem()</A></CODE>
 when you are done accessing the transfer item. This routine relinquishes your exclusive access to the transfer VM file.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
clipbrd.goh</STRONG>
 </P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_b.htm#IX_ClipboardRequestItemFormat()">ClipboardRequestItemFormat()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_a.htm#IX_ClipboardDoneWithItem()">ClipboardDoneWithItem()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_b.htm_IX_ClipboardRegisterItem()">
 </A>
<H1 CLASS="refHeading">
ClipboardRegisterItem()</H1>
<PRE CLASS="syntax">Boolean	ClipboardRegisterItem(
        TransferBlockID header,
        ClipboardItemFlags flags);</PRE>
<P>
This routine completes a change to the transfer item. You should use this routine whenever copying or cutting something into the clipboard or whenever attaching something as the quick-transfer item.</P>
<P>
This routine puts the item specified by <CODE>
header</CODE>
 into the transfer VM file. It frees any transfer item that may already be in the file. Pass this routine the following:</P>
<DL>
<DT>
<CODE>
header</CODE>
</DT><DD>Header information for the item, consisting of the transfer VM file handle and the VM block handle of the block containing the new transfer item. Create the <CODE>
TransferBlockID</CODE>
 structure using the macro <CODE>
<A HREF="../../CRef/Routines/R_3.htm#IX_BlockIDFromFileAndBlock() macro">BlockIDFromFileAndBlock()</A></CODE>
.</DD>
<DT>
<CODE>
flags</CODE>
</DT><DD>A record of <CODE>
ClipboardItemFlags</CODE>
 indicating whether you're registering a clipboard item or a quick-transfer item. The flag CIF_QUICK indicates the item is a quick-transfer item; zero (or TIF_NORMAL) indicates the item is a normal clipboard item.</DD>
</DL>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
clipbrd.goh</STRONG>
 </P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_b.htm#IX_ClipboardRequestItemFormat()">ClipboardRequestItemFormat()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_b.htm_IX_ClipboardRemoveFromNotificationList()">
 </A>
<H1 CLASS="refHeading">
ClipboardRemoveFromNotificationList()</H1>
<PRE CLASS="syntax">Boolean	ClipboardRemoveFromNotificationList(
        optr	notificationOD);</PRE>
<P>
This routine removes an object or Process from the clipboard's change notification list. It is typically called when the object or Process is being detached or destroyed. Pass it the same optr that was added to the notification list with <CODE>
ClipboardAddToNotificationList</CODE>
().</P>
<P>
This routine returns an error flag: The flag will be <CODE>
true</CODE>
 if the object could not be found in the notification list, <CODE>
false</CODE>
 if the object was successfully removed from the list.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
clipbrd.goh</STRONG>
 </P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_9.htm#IX_ClipboardAddToNotificationList()">ClipboardAddToNotificationList()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_b.htm_IX_ClipboardRequestItemFormat()">
 </A>
	<A NAME="R_b.htm_IX_ClipboardRequestArgs">
 </A>
<A NAME="R_b.htm_IX_CRA_&ldots;">
 </A>
<H1 CLASS="refHeading">
ClipboardRequestItemFormat()</H1>
<PRE CLASS="syntax">void	ClipboardRequestItemFormat(
        ClipboardItemFormatID 			format,
        TransferBlockID 			header,
        ClipboardRequestArgs *			retValue);</PRE>
<P>
This routine returns specific information about a particular transfer item. Because some of the passed information must be retrieved with <CODE>
<A HREF="../../CRef/Routines/R_b.htm#IX_ClipboardQueryItem()">ClipboardQueryItem()</A></CODE>
, you must call <CODE>
<A HREF="../../CRef/Routines/R_b.htm#IX_ClipboardQueryItem()">ClipboardQueryItem()</A></CODE>
 before calling this routine.</P>
<P>
Pass this routine the following:</P>
<DL>
<DT>
<CODE>
format</CODE>
</DT><DD>The manufacturer ID and format type of the new transfer item being put into the transfer VM file. Create the <CODE>
ClipboardItemFormatID</CODE>
 value with the macro <CODE>
<A HREF="../../CRef/Routines/R_2f.htm#IX_FormatIDFromManufacturerAndType()">FormatIDFromManufacturerAndType()</A></CODE>
.</DD>
<DT>
<CODE>
header</CODE>
</DT><DD>Header information for the item, consisting of the transfer VM file handle and the VM block handle of the block containing the new transfer item. Create the <CODE>
TransferBlockID</CODE>
 structure using the macro <CODE>
<A HREF="../../CRef/Routines/R_3.htm#IX_BlockIDFromFileAndBlock() macro">BlockIDFromFileAndBlock()</A></CODE>
 using returned information from <CODE>
<A HREF="../../CRef/Routines/R_b.htm#IX_ClipboardQueryItem()">ClipboardQueryItem()</A></CODE>
.</DD>
<DT>
<CODE>
retValue</CODE>
A pointer to an empty <CODE>
ClipboardRequestArgs</CODE>
 structure that will be filled by the routine. This structure is defined as follows:</DT>
<PRE>typedef struct {
	VMFileHandle		CRA_file;
	VMChain		CRA_data;
	word		CRA_extra1;
	word		CRA_extra2;
} ClipboardRequestArgs;</PRE>
</DL>
<P>
Upon return, the <CODE>
CRA_file</CODE>
 field will contain the transfer VM file's VM file handle and the <CODE>
CRA_data</CODE>
 field will contain the VM block handle of the transfer item's header block. If there is no transfer item, <CODE>
CRA_data</CODE>
 will be zero.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
clipbrd.goh</STRONG>
 </P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_b.htm#IX_ClipboardRegisterItem()">ClipboardRegisterItem()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_b.htm#IX_ClipboardQueryItem()">ClipboardQueryItem()</A></CODE>.</P>
</DIV>
<HR>
<A NAME="R_c.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_c.htm_IX_ClipboardSetQuickTransferFeedback()">
 </A>
<H1 CLASS="refHeading">
ClipboardSetQuickTransferFeedback()</H1>
<PRE CLASS="syntax">void	ClipboardSetQuickTransferFeedback(
        ClipboardQuickTransferFeedback 						cursor,
        UIFunctionsActive 						buttonFlags);</PRE>
<P>
This routine sets the image of the mouse pointer during a quick-transfer operation. Use this routine to provide visual feedback to the user during the quick-transfer. For example, an object that could not accept the quick-transfer item would set the &quot;no operation&quot; cursor while the mouse pointer was over its bounds.</P>
<P>
Pass the two following values:</P>
<DL>
<DT>
<CODE>
cursor</CODE>
</DT><DD>A value of <CODE>
ClipboardQuickTransferFeedback</CODE>
 type indicating the type of cursor to set. The possible values are listed below.</DD>
<DT>
<CODE>
buttonFlags</CODE>
</DT><DD>A record of <CODE>
UIFunctionsActive</CODE>
 flags. These flags are defined in the Input Manager section and deal with user override of the move/copy behavior.</DD>
</DL>
<P>
The cursor parameter contains a value of <CODE>
ClipboardQuickTransferFeedback</CODE>
. This is an enumerated type that defines the cursor to be set, and it has the following values:</P>
<DL>
<DT>
CQTF_MOVE</DT><DD>This sets the cursor to the specific UI's move cursor.</DD>
<DT>
CQTF_COPY</DT><DD>This sets the cursor to the specific UI's copy cursor.</DD>
<DT>
CQTF_CLEAR </DT><DD>This clears the cursor and sets it to the specific UI's modal &quot;no operation&quot; cursor.</DD>
</DL>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
clipbrd.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_c.htm_IX_ClipboardStartQuickTransfer()">
 </A>
<A NAME="R_c.htm_IX_ClipboardQuickTransferFlags">
 </A>
<A NAME="R_c.htm_IX_CQTF_&ldots;">
 </A>
<A NAME="R_c.htm_IX_CQTRI_&ldots;">
 </A>
<A NAME="R_c.htm_IX_ClipboardQuickTransferRegionInfo">
 </A>
<H1 CLASS="refHeading">
ClipboardStartQuickTransfer()</H1>
<PRE CLASS="syntax">Boolean	ClipboardStartQuickTransfer(
        ClipboardQuickTransferFlags 							flags,
        ClipboardQuickTransferFeedback							initialCursor,
        word							mouseXPos,
        word							mouseYPos,
        ClipboardQuickTransferRegionInfo *							regionParams,
        optr							notificationOD);</PRE>
<P>
This routine signals the beginning of a quick-transfer operation. Typically, an object or process will call this routine in its <CODE>
MSG_META_START_MOVE_COPY</CODE>
 handler.</P>
<P>
Pass it the following parameters:</P>
<DL>
<DT>
<CODE>
flags</CODE>
</DT><DD>A record of <CODE>
ClipboardQuickTransferFlags</CODE>
 indicating whether an addition graphic region will be attached to the cursor and whether the caller wants notification of transfer completion. The flags allowed are listed below, after the parameter list.</DD>
<DT>
<CODE>
initialCursor</DT><DD>
</CODE>
The initial cursor to use for visual feedback to the user. It is a value of <CODE>
ClipboardQuickTransferFeedback</CODE>
, either CQTF_MOVE or CQTF_COPY. If -1 is passed in this parameter, the initial cursor will be the default no-operation cursor (i.e. the transfer source may not also act as the transfer destination).</DD>
<DT>
<CODE>
mouseXPos</CODE>
</DT><DD>This field is used only if CQTF_USE_REGION is passed in <CODE>
flags</CODE>
. It is the horizontal position of the mouse in screen coordinates.</DD>
<DT>
<CODE>
mouseYPos</CODE>
</DT><DD>This field is used only if CQTF_USE_REGION is passed in <CODE>
flags</CODE>
. It is the vertical position of the mouse in screen coordinates.</DD>
<DT>
<CODE>
regionParams</DT><DD>
</CODE>
A pointer to a <CODE>
ClipboardQuickTransferRegionInfo</CODE>
 structure defining the graphical region to be attached to the cursor during the transfer operation. This structure is only required if CQTF_USE_REGION is passed in <CODE>
flags</CODE>
. It is defined below.</DD>
<DT>
<CODE>
notificationOD</DT><DD>
</CODE>
The optr of the object to be notified upon transfer completion. The object specified will receive the notification messages <CODE>
MSG_META_CLIPBOARD_NOTIFY_QUICK_TRANSFER_CONCLUDED</CODE>
 and <CODE>
MSG_..._FEEDBACK</CODE>
.</DD>
</DL>
<P>
The allowed <CODE>
ClipboardQuickTransferFlags</CODE>
 are listed below:</P>
<DL>
<DT>
CQTF_COPY_ONLY</DT><DD>
Source supports copying only (not cutting).</DD>
<DT>
CQTF_USE_REGION</DT><DD>
Source has passed the definition of a graphical region which will be attached to the tail of the quick-transfer cursor.</DD>
<DT>
CQTF_NOTIFICATION</DT><DD>
Source requires notification of completion of the transfer in order to cut original data or provide other feedback.</DD>
</DL>
<P>
If a graphical region is to be attached to the quick-transfer cursor, you must pass a pointer to a <CODE>
ClipboardQuickTransferRegionInfo</CODE>
 in the <CODE>
regionParams</CODE>
 parameter. This structure is defined below.</P>
<PRE>typedef struct {
	word	CQTRI_paramAX;
	word	CQTRI_paramBX;
	word	CQTRI_paramCX;
	word	CQTRI_paramDX;
	Point	CQTRI_regionPos;
	dword	CQTRI_strategy;
	dword	CQTRI_region;
} ClipboardQuickTransferRegionInfo;</PRE>
<P>
This structure is passed on the stack to the routine. The first four fields represent the region's definition parameters. <CODE>
CQTRI_regionPos</CODE>
 is a <CODE>
Point</CODE>
 structure indicating where (in screen coordinates) the region is to be located. <CODE>
CQTRI_strategy</CODE>
 is a pointer to the region strategy routine. <CODE>
CQTRI_strategy</CODE>
 should be a video driver strategy. To find out the strategy of the video driver associated with your window, send your object a MSG_VIS_VUP_QUERY with VUQ_VIDEO_DRIVER. Pass the handle thus gained to <CODE>
<A HREF="../../CRef/Routines/R_34.htm#IX_GeodeInfoDriver()">GeodeInfoDriver()</A></CODE>
, which will return the strategy.</P>
<P>
This routine returns an error flag: If a quick-transfer is already in progress, the return will be <CODE>
true</CODE>
. If the quick-transfer is successfully begun, the error flag will be <CODE>
false</CODE>
.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
clipbrd.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_c.htm_IX_ClipboardTestItemFormat()">
 </A>
<H1 CLASS="refHeading">
ClipboardTestItemFormat()</H1>
<PRE CLASS="syntax">Boolean	ClipboardTestItemFormat(
        TransferBlockID		header,
        ClipboardFormatID 		format);</PRE>
<P>
This routine tests whether the given format is supported by the specified transfer item. It returns <CODE>
true</CODE>
 if the format is supported, <CODE>
false</CODE>
 if the format is not supported. Pass the following values:</P>
<DL>
<DT>
<CODE>
header</CODE>
</DT><DD>A <CODE>
TransferBlockID</CODE>
 specifying the VM file handle and VM block handle of the transfer item to be checked. This is returned by the routines <CODE>
<A HREF="../../CRef/Routines/R_a.htm#IX_ClipboardGetNormalItemInfo()">ClipboardGetNormalItemInfo()</A></CODE>
, <CODE>
<A HREF="../../CRef/Routines/R_a.htm#IX_ClipboardGetQuickItemInfo()">ClipboardGetQuickItemInfo()</A></CODE>
, <CODE>
<A HREF="../../CRef/Routines/R_a.htm#IX_ClipboardGetUndoItemInfo()">ClipboardGetUndoItemInfo()</A></CODE>
, and <CODE>
<A HREF="../../CRef/Routines/R_b.htm#IX_ClipboardQueryItem()">ClipboardQueryItem()</A></CODE>
. Most often the proper routine to use is <CODE>
<A HREF="../../CRef/Routines/R_b.htm#IX_ClipboardQueryItem()">ClipboardQueryItem()</A></CODE>
.</DD>
<DT>
<CODE>
format</CODE>
</DT><DD>A <CODE>
ClipboardFormatID</CODE>
 specifying the type and manufacturer ID of the format to be checked. It is most appropriate to create this parameter from its individual parts using the macro <CODE>
<A HREF="../../CRef/Routines/R_2f.htm#IX_FormatIDFromManufacturerAndType()">FormatIDFromManufacturerAndType()</A></CODE>
.</DD>
</DL>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
clipbrd.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_c.htm_IX_ClipboardUnregisterItem()">
 </A>
<H1 CLASS="refHeading">
ClipboardUnregisterItem()</H1>
<PRE CLASS="syntax">void	ClipboardUnregisterItem(
        optr	owner);</PRE>
<P>
This routine restores the transfer item to what it was before the last <CODE>
<A HREF="../../CRef/Routines/R_b.htm#IX_ClipboardRegisterItem()">ClipboardRegisterItem()</A></CODE>
. Pass it the optr of the caller.</P>
<P>
Only the object that last registered a transfer item is allowed to unregister it. If the transfer item is owned by a different object, or if there is no transfer item, nothing will be done. If the transfer item is owned by the caller, the transfer item will be unregistered and the clipboard will be restored to its previous state.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
clipbrd.goh</STRONG>
 </P>
</DIV>
<HR>
<A NAME="R_d.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_d.htm_IX_ConstructOptr() macro">
 </A>
<A NAME="R_d.htm_IX_optr:ConstructOptr() macro">
 </A>
<H1 CLASS="refHeading">
ConstructOptr()</H1>
<PRE CLASS="syntax">optr	ConstructOptr(
        Handle 		han,
        ChunkHandle 		ch);</PRE>
<P>
This macro constructs an optr type from the given handle (typically a MemHandle) and chunk handle.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_55.htm#IX_HandleToOptr() macro">HandleToOptr()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_7f.htm#IX_OptrToHandle()">OptrToHandle()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_7f.htm#IX_OptrToChunk()">OptrToChunk()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_d.htm_IX_ContactCompareNumbers()">
 </A>
<H1 CLASS="refHeading">
ContactCompareNumbers()</H1>
<PRE CLASS="syntax">Boolean 	ContactCompareNumbers(
        TCHAR *number1, 
        TCHAR *number2);</PRE>
<P>
This function compares two phone number strings for equivalence. It ignores extraneous characters such as spaces. It returns zero if they are the same number, otherwise it returns a non-zero value.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
contdb.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_d.htm_IX_ContactCreateRecordFromTemplate()">
 </A>
<H1 CLASS="refHeading">
ContactCreateRecordFromTemplate()</H1>
<PRE CLASS="syntax">MemHandle	 ContactCreateRecordFromTemplate( void );</PRE>
<P>
This function creates a new Contact record in the Contacts database. It returns the handle of the new record. Make any desired changes to the record and then call <CODE>
<A HREF="../../CRef/Routines/R_f.htm#IX_ContactSaveRecord()">ContactSaveRecord()</A></CODE>
 to save the record or <CODE>
FoamDBDiscardRecord()</CODE>
 to discard changes.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
contdb.goh</STRONG>
 </P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_f.htm#IX_ContactSaveRecord()">ContactSaveRecord()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_f.htm#IX_ContactSetTemplateRecord()">ContactSetTemplateRecord()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_d.htm_IX_ContactEnsureEmptyField()">
 </A>
<H1 CLASS="refHeading">
ContactEnsureEmptyField()</H1>
<PRE CLASS="syntax">FieldID	ContactEnsureEmptyField( 
        MemHandle 		record,
        optr 		fieldName,
        ContdbFieldType		fieldType);</PRE>
<P>
This function creates a field in a record, and clears the dat from the existing field of that name if one already existed. This function takes the following arguemnts:</P>
<DL>
<DT>
<EM>record</EM> </DT><DD>The handle of the record, as returned by <CODE>
FoamDBGetRecordFromID()</CODE>
 or <CODE>
<A HREF="../../CRef/Routines/R_d.htm#IX_ContactCreateRecordFromTemplate()">ContactCreateRecordFromTemplate()</A></CODE>
. </DD>
<DT>
<EM>fieldName</EM></DT><DD>optr of a chunk containing the null-terminated name string, or <CODE>
NullOptr</CODE>
 to use the default name for the passed <CODE>
ContdbFieldType</CODE>
.</DD>
<DT>
<EM>fieldType</EM> </DT><DD>The type of field to find. One of CFT_NAME, CFT_COMPANY CFT_TITLE, CFT_ADDRESS, CFT_PHONE, CFT_FAX, CFT_EMAIL, CFT_DTMF, CFT_NOTES. </DD>
</DL>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
contdb.goh</STRONG>
 </P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_d.htm#IX_ContactEnsureField()">ContactEnsureField()</A></CODE>,
<CODE>FoamDBSetFieldData()</CODE>.</P>
</DIV>
<DIV>
<A NAME="R_d.htm_IX_ContactEnsureField()">
 </A>
<H1 CLASS="refHeading">
ContactEnsureField()</H1>
<PRE CLASS="syntax">FieldID	ContactEnsureField( 
        MemHandle 		record,
        optr 		fieldName,
        ContdbFieldType		fieldType);</PRE>
<P>
This functionreturns the <CODE>
FieldID</CODE>
 of a field within a record, or creates the field if it doesn't find it. This function takes the following arguemnts:</P>
<DL>
<DT>
<EM>record</EM> </DT><DD>The handle of the record, as returned by <CODE>
FoamDBGetRecordFromID()</CODE>
 or <CODE>
<A HREF="../../CRef/Routines/R_d.htm#IX_ContactCreateRecordFromTemplate()">ContactCreateRecordFromTemplate()</A></CODE>
. </DD>
<DT>
<EM>fieldName</EM></DT><DD>optr of a chunk containing the null-terminated name string, or <CODE>
NullOptr</CODE>
 to use the default name for the passed <CODE>
ContdbFieldType</CODE>
.</DD>
<DT>
<EM>fieldType</EM> </DT><DD>The type of field to find. One of CFT_NAME, CFT_COMPANY CFT_TITLE, CFT_ADDRESS, CFT_PHONE, CFT_FAX, CFT_EMAIL, CFT_DTMF, CFT_NOTES. </DD>
</DL>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
contdb.goh</STRONG>
 </P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_d.htm#IX_ContactEnsureEmptyField()">ContactEnsureEmptyField()</A></CODE>,
<CODE>FoamDBSetFieldData()</CODE>.</P>
</DIV>
<DIV>
<A NAME="R_d.htm_IX_ContactExportDBToTextFile()">
 </A>
<H1 CLASS="refHeading">
ContactExportDBToTextFile()</H1>
<PRE CLASS="syntax">ContactExportStatus 	ContactExportDBToTextFile(
        hptr 	fileExport,
        dword 	startElement,
        dword 	numOfRecords);</PRE>
<P>
This function exports the Contact database's data as an ASCII file. On success, the function returns CES_NO_ERROR, otherwise it returns CES_FILE_ERROR. This function takes the following arguments:</P>
<DL>
<DT>
<EM>fileExport</EM></DT><DD>The handle of the opened file to hold the exported text.</DD>
<DT>
<EM>startElement</DT><DD>
</EM>The <CODE>
RecordID</CODE>
 of the first record to export.</DD>
<DT>
<EM>numOfRecords</DT><DD>
</EM>This argument determines the range of records to export. All records with RecordID at least <EM>startElement</EM> but less than <EM>startElement</EM>+<EM>numOfRecords</EM> will be exported.</DD>
</DL>
<P>
To export all the records, pass a <EM>startElement</EM> of zero and a <EM>numOfRecords</EM> of CONTACT_EXPORT_ALL_RECORDS.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
contdb.goh</STRONG>
 </P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_d.htm#IX_ContactExportDBToTextFile()">ContactExportDBToTextFile()</A></CODE>.</P>
</DIV>
<HR>
<A NAME="R_e.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_e.htm_IX_ContactGetDBHandle()">
 </A>
<H1 CLASS="refHeading">
ContactGetDBHandle()</H1>
<PRE CLASS="syntax">VMFileHandle 	ContactGetDBHandle( void );</PRE>
<P>
This function returns the handle of the Contact database, the database that contains all of the &quot;address book&quot; data used by the <STRONG CLASS="fileName">
contdb</STRONG>
 library; it also lets the system know that you're using the database.  The database handle is necessary for various operations with the library. When you're done with the database, remember to call <CODE>
<A HREF="../../CRef/Routines/R_f.htm#IX_ContactReleaseDBHandle()">ContactReleaseDBHandle()</A></CODE>
.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
contdb.goh</STRONG>
 </P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_e.htm#IX_ContactGetDBHandleNoBlock()">ContactGetDBHandleNoBlock()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_f.htm#IX_ContactReleaseDBHandle()">ContactReleaseDBHandle()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_e.htm_IX_ContactGetDBHandleNoBlock()">
 </A>
<H1 CLASS="refHeading">
ContactGetDBHandleNoBlock()</H1>
<PRE CLASS="syntax">VMFileHandle 	ContactGetDBHandleNoBlock( void );</PRE>
<P>
This function behaves in the same manner as <CODE>
<A HREF="../../CRef/Routines/R_e.htm#IX_ContactGetDBHandle()">ContactGetDBHandle()</A></CODE>
, except that if it cannot get the handle, it returns zero instead of waiting until the handle is available.When you're done with the handle, remember to call <CODE>
<A HREF="../../CRef/Routines/R_f.htm#IX_ContactReleaseDBHandle()">ContactReleaseDBHandle()</A></CODE>
.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
contdb.goh</STRONG>
 </P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_e.htm#IX_ContactGetDBHandle()">ContactGetDBHandle()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_e.htm_IX_ContactGetName()">
 </A>
<H1 CLASS="refHeading">
ContactGetName()</H1>
<PRE CLASS="syntax">Boolean	ContactGetName( 
        MemHandle 		record,
        TCHAR 		*dest);</PRE>
<P>
This function gets the name associated with the record, filling in the <EM>dest</EM> buffer. If there was no name in the record, this function returns non-zero; otherwise, it returns zero.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
contdb.goh</STRONG>
 </P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_e.htm#IX_ContactGetDBHandle()">ContactGetDBHandle()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_e.htm_IX_ContactGetTruncatedName()">
 </A>
<H1 CLASS="refHeading">
ContactGetTruncatedName()</H1>
<PRE CLASS="syntax">Boolean	ContactGetTrunactedName( 
        MemHandle 		record,
        TCHAR 		*dest,
        word		destSize);				/* Size of dest buffer */</PRE>
<P>
This function gets the name associated with the record, filling in the <EM>dest</EM> buffer. It will truncate the name, as necessary to make it fit inside the buffer. Remember to leave space for the null terminator when determining how big a buffer you'll need. If there was no name in the record, this function returns non-zero; otherwise, it returns zero.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
contdb.goh</STRONG>
 </P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_e.htm#IX_ContactGetDBHandle()">ContactGetDBHandle()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_e.htm_IX_ContactGetUserDataID()">
 </A>
<H1 CLASS="refHeading">
ContactGetUserDataID()</H1>
<PRE CLASS="syntax">RecordID	ContactGetUserDataID( void );</PRE>
<P>
This functionreturns the <CODE>
RecordID </CODE>
of the special Contacts database record containing the user's own contact data.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
contdb.goh</STRONG>
 </P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE>FoamDBGetRecordFromID()</CODE>.</P>
</DIV>
<DIV>
<A NAME="R_e.htm_IX_ContactImportDBFromTextFile()">
 </A>
<H1 CLASS="refHeading">
ContactImportDBFromTextFile()</H1>
<PRE CLASS="syntax">void 	ContactImportDBFromTextFile(
        hptr 		fileImport);					/* file's handle */</PRE>
<P>
This function imports contact database information from an ASCII text file. This file's format is described below. The function will compare imported records to those already in the Contacts database. Any identical records will be merged.</P>
<P>
A short sample file is shown below. </P>
<PRE>[RECORD]
[FIELD]
Name
[FIELD-NAME]
[FIELD-DATA]
Hudson W.
[FIELD-END]
[FIELD]</PRE>
<PRE>Company
[FIELD-NAME]
[FIELD-DATA]
Space Marines
[FIELD-END]
[FIELD]
Title
[FIELD-NAME]
[FIELD-DATA]
Private
[FIELD-END]
[RECORD-END]</PRE>
<PRE>[RECORD]
[FIELD]
Name
[FIELD-NAME]
[FIELD-DATA]</PRE>
<PRE>Adams, John Quincy
[FIELD-END]
[FIELD]
Tel
[FIELD-NAME]
[FIELD-DATA]
1 617 438 1776
[FIELD-END]
[FIELD]
[FIELD-NAME]
Company
[FIELD-DATA]
[FIELD-END]
USA Government
[FIELD]
Notes
[FIELD-NAME]
Note(Birthday)
[FIELD-DATA]
July 11, 1767
Gift ideas: flowers
[FIELD-END]
[RECORD-END]</PRE>
<P>
The ASCII file follows these rules:</P>
<UL>
<LI>
The page is a DOS text file, using the &quot;Latin 1&quot; code page (number 819).</LI>
<LI>
Each line of text may ends with a newline; the newline may be preceded by an optional carriage return.</LI>
<LI>
The data corresponding to each record is delimited by a line reading [RECORD] at the start and another line reading [RECORD-END] at the end. Any text that appears outside of these delimiters is lost.</LI>
<LI>
Each record consists of one or more fields. Each field is delimited by a line reading [FIELD] and a line reading [FIELD-END].</LI>
<LI>
For each field, the first line after the [FIELD] line will consist of one of the following strings, specifying the field's type:<BR>
Name, Company, Title, Address, Tel, Fax, Mail, DTMF, Note.</LI>
<LI>
There may be a line of text between the [FIELD-NAME] and [FIELD-DATA] lines. If there is no such line of text, then the field's name is the default name for its data type. If there is such a line of text, then you may form the field name by placing the text of this line between parentheses and preceding it with the default name for the field. In the &quot;Birthday&quot; example, above, the full field name would be &quot;Note(Birthday)&quot;.<BR>
The <EM>
exception</EM>
 to this rule is &quot;GSM/PCN&quot; in phone number fields. If the line of text is &quot;GSM/PCN&quot;, treat it as if it were &quot;GSM&quot;. The full field name will probably be &quot;Tel(GSM)&quot; or &quot;Fax(GSM)&quot;.</LI>
<LI>
The line(s) of text between the [FIELD-DATA] line and the [FIELD-END] line contain the field's data, if any. If there are no lines of text, that means that the field contains no data. There may be more than one line of text.</LI>
</UL>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
contdb.goh</STRONG>
 </P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_d.htm#IX_ContactExportDBToTextFile()">ContactExportDBToTextFile()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_e.htm_IX_ContactMatchName()">
 </A>
<H1 CLASS="refHeading">
ContactMatchName()</H1>
<PRE CLASS="syntax">RecordID	ContactMatchName( 
        TCHAR		name,
        ContdbFieldType		type,
        Boolean		stopEarly,
        FieldID		*field,
        word		*numMatches );</PRE>
<P>
This function takes aname, searches all fields of the specified type in all records of the Contact database, returning the <CODE>
RecordID</CODE>
 and <CODE>
FieldID</CODE>
 of the matching field, if any; if there was no match, it returns -1.</P>
<P>
The comparison of names does not consider case.</P>
<P>
This function takes the following arguments:</P>
<DL>
<DT>
<EM>name</EM></DT><DD>String containing the name to match. </DD>
<DT>
<EM>type</EM></DT><DD>The type of phone number to match; one of CFT_NAME, CFT_COMPANY CFT_TITLE, CFT_ADDRESS, CFT_PHONE, CFT_FAX, CFT_EMAIL, CFT_DTMF, CFT_NOTES. </DD>
<DT>
<EM>stopEarly</EM></DT><DD>Set this flag <EM>
true</EM>
 to stop searching after finding the first matching name; set it <EM>
false</EM>
 to find out the number of matching names.</DD>
<DT>
<EM>field</EM></DT><DD>Pointer to a <CODE>
FieldID</CODE>
 buffer. The function will fill this buffer in with the <CODE>
FieldID</CODE>
 of the matching field, if any.</DD>
<DT>
<EM>numMatches</DT><DD>
</EM>Pointer to a word buffer. The function will fill this buffer in with the number of matching records found. This number is only meaningful if the stopEarly flag is <EM>
false</EM>
.</DD>
</DL>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
contdb.goh</STRONG>
 </P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_d.htm#IX_ContactEnsureEmptyField()">ContactEnsureEmptyField()</A></CODE>,
<CODE>FoamDBSetFieldData()</CODE>.</P>
</DIV>
<HR>
<A NAME="R_f.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_f.htm_IX_ContactMatchNumber()">
 </A>
<H1 CLASS="refHeading">
ContactMatchNumber()</H1>
<PRE CLASS="syntax">RecordID	ContactMatchNumber( 
        TCHAR		number,
        ContdbCallType		type,
        FieldID		*field,
        word		*numMatches );</PRE>
<P>
This function takes a phone number, searches all fields of the specified type in all records of the Contact database, returning the <CODE>
RecordID</CODE>
 and <CODE>
FieldID</CODE>
 of the matching field, if any; if there was no match, it returns -1.</P>
<P>
This function takes the following arguments:</P>
<DL>
<DT>
<EM>number</EM></DT><DD>String containing the phone number to match. </DD>
<DT>
<EM>type</EM></DT><DD>The type of phone number to match; one of CCT_PHONE, CCT_SMS, CCT_FAX, CCT_EMAIL, CCT_GSM_FAX, CCT_ANY.</DD>
<DT>
<EM>field</EM></DT><DD>Pointer to a <CODE>
FieldID</CODE>
 buffer. The function will fill this buffer in with the <CODE>
FieldID</CODE>
 of the matching field, if any.</DD>
<DT>
<EM>numMatches</DT><DD>
</EM>Pointer to a word buffer. The function will fill this buffer in with the number of matching records found.</DD>
</DL>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
contdb.goh</STRONG>
 </P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_d.htm#IX_ContactEnsureEmptyField()">ContactEnsureEmptyField()</A></CODE>,
<CODE>FoamDBSetFieldData()</CODE>.</P>
</DIV>
<DIV>
<A NAME="R_f.htm_IX_ContactRecreateFieldLabel()">
 </A>
<H1 CLASS="refHeading">
ContactRecreateFieldLabel()</H1>
<PRE CLASS="syntax">void ContdbRecreateFieldLabel(
        TCHAR 		*subLabel,
        TCHAR 		*destination,
        int 		fieldType);</PRE>
<P>
This utility function takes a field sub-label (e.g., &quot;GSM/PCN&quot;) and field type and creates a label from them (e.g. &quot;Tel(GSM)&quot;. It will translate standard labels from English to the user's language. (Some field sublabels are standard, such as the &quot;GSM&quot; in &quot;Tel(GSM)&quot; and will be translated; the user's custom sublabels will not be translated.) This function takes the following arguments:</P>
<DL>
<DT>
<EM>subLabel</EM></DT><DD>The sublabel string.</DD>
<DT>
<EM>destination</EM></DT><DD>String buffer to hold the field name.</DD>
<DT>
<EM>fieldType</EM></DT><DD>The <CODE>
ContdbFieldType</CODE>
 value of the field.</DD>
</DL>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
contdb.goh</STRONG>
 </P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_e.htm#IX_ContactImportDBFromTextFile()">ContactImportDBFromTextFile()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_f.htm_IX_ContactReleaseDBHandle()">
 </A>
<H1 CLASS="refHeading">
ContactReleaseDBHandle()</H1>
<PRE CLASS="syntax">void	ContactReleaseDBHandle( void );</PRE>
<P>
This function releases the Contact database's handle, signalling that the application is done with the database for now. </P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
contdb.goh</STRONG>
 </P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_e.htm#IX_ContactGetDBHandle()">ContactGetDBHandle()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_f.htm#IX_ContactReleaseDBHandle()">ContactReleaseDBHandle()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_f.htm_IX_ContactSaveRecord()">
 </A>
<H1 CLASS="refHeading">
ContactSaveRecord()</H1>
<PRE CLASS="syntax">dword	ContactSaveRecord(
        MemHandle 		record);</PRE>
<P>
This functionsaves the passed record in the database, inserting it in the proper sort order. It returns the record's <CODE>
RecordID</CODE>
 number.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
contdb.goh</STRONG>
 </P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE>FoamDBDiscardRecord()</CODE>,
<CODE>FoamDBDeleteRecord()</CODE>.</P>
</DIV>
<DIV>
<A NAME="R_f.htm_IX_ContactSetTemplateRecord()">
 </A>
<H1 CLASS="refHeading">
ContactSetTemplateRecord()</H1>
<PRE CLASS="syntax">void	ContactSetTemplateRecord( 
        MemHandle 		record);</PRE>
<P>
This functionmakes the passed record the Contact database's template record. It also frees that contact's handle.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
contdb.goh</STRONG>
 </P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_d.htm#IX_ContactCreateRecordFromTemplate()">ContactCreateRecordFromTemplate()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_f.htm_IX_ContdbTranslateSubFieldLabelToEnglish()">
 </A>
<H1 CLASS="refHeading">
ContdbTranslateSubFieldLabelToEnglish()</H1>
<PRE CLASS="syntax">void	ContdbTranslateSubFieldLabelToEnglish(
        TCHAR 		*subLabel,
        TCHAR 		*destination);</PRE>
<P>
This function translates a foreign sub-label to its english equivalent. This function only recognizes certain &quot;standard&quot; sublabels; the user's custom labels will not be translated. This function takes two arguments: a buffer containing the string to translate and a string buffer to hold the translation.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_16.htm#IX_DBAllocUngrouped()">DBAllocUngrouped()</A></CODE>.</P>
</DIV>

<DIV>
<A NAME="R_f.htm_IX_CreateVisMonikerLine()">
 </A>
<H1 CLASS="refHeading">
CreateVisMonikerLine()</H1>
<PRE CLASS="syntax">optr	CreateVisMonikerLine(
	word			pointSize,
	FontID			typeFace,
	word			numberOfFields,
	VisMonikerColumn *	vmc );</PRE>
<P>
Creates a visMoniker that separates each element into a separate
column. This is useful if you've got a GenDynamicList and you
want to display columns of data. It uses an array of
<CODE>VisMonikerColumn</CODE> structs, referred to as fields. All fields
will have the same point size, but TextStyle can vary between fields.
</p>

<p>
You can also have "adaptable columns", which are sequential text
columns in the <CODE>VisMonikerColumn</CODE> array whose <EM>VMC_just</EM>
fields are set to J_FULL. Rather than the text being padded or clipped to
fit within a fixed field width, the text of each column immediately follows the
previous column. All of the adaptable columns are left-justified in an
overall field width, specified by the <EM>VMC_width</EM> of the first J_FULL
VisMonikerColumn structure (the others are set to 0 width). Adaptable
fields are still clipped to fit within the overall field width.
A group of adaptable fields ends at the first VisMonikerColumn
structure that is not J_FULL or has non-zero width.
</p>

<p>
Example: Say you want to create a moniker that looks like:
<PRE>
	Field1    SEARCHable text   Field2
	|         |                 |     |
        01234567890123456789012345678901234
</PRE>
Where "SEARCH" is supposed to be underlined and bold. Here is the
<CODE>VisMonikerColumn</CODE> array you would pass:
<PRE>
elt#  VMC_width  VMC_ptr       VMC_just  VMC_style
--------------------------------------------------
0     10         "Field1"      J_LEFT    0
1     18         "SEARCH"      J_FULL    TS_BOLD | TS_UNDERLINE
2     0          "able text"   J_FULL    0
3     7          "Field2"      J_LEFT    0
</PRE>
elements 1 and 2 are placed together in an overall field width of 18.
</P>

<P CLASS="refField"><STRONG>
Pass:   </STRONG>
</P>
<DL>
<DT>
<EM>
pointSize</EM>
</DT><DD>Point size to use when generating the text moniker.</DD>
<DT>
<EM>
typeFace</EM>
</DT><DD>Font identifier for the font to use.</DD>
</DL>
<DT>
<EM>
numberOfFields</EM>
</DT><DD>The number of columns in the vmc array.</DD>
</DL>
<DT>
<EM>
vmc</EM>
</DT><DD>An array of VisMonikerColumn structs that contain the column
information for building the visMoniker. Each VisMonikerColumn struct
defines an element in the line.
<pre>
typedef struct {
  byte           VMC_width;   /* Width of text in chars, 0 if bitmap */
  const void * 	 VMC_ptr;     /* Pointer to text or bitmap;
                               * if bitmap, points to Bitmap structure */
  Justification  VMC_just;    /* How to justify the column text */
  TextStyle      VMC_style;   /* Column text styles */
  ColumnBorder   VMC_border;  /* Draw vertical border */
} VisMonikerColumn;
</pre>
</DD>
</DL>

<P CLASS="refField"><STRONG>
Return:</STRONG>
        Optr to the newly created visMoniker.</P>

<P CLASS="refField"><STRONG>
Warning:</strong>
Because the new visMoniker is created in its own new memory block, be sure
to free the block when you're done with it.
</P>

<P CLASS="refField"><STRONG>
Include:</STRONG>        <STRONG CLASS="fileName">
foam.goh</STRONG>
</P>
</DIV>

<HR>
<A NAME="R_16.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_16.htm_IX_DBAlloc()">
 </A>
<H1 CLASS="refHeading">
DBAlloc()</H1>
<PRE CLASS="syntax">DBItem	DBAlloc(
        VMFileHandle		file,		
        DBGroup		group,
        word		size);</PRE>
<P>
This routine allocates an item in the specified file and group. It is passed the handles for the file and group which will contain the new item. It returns the new item's item-handle.</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	All pointers to items in the group may be invalidated.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
dbase.h</STRONG>
 </P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_16.htm#IX_DBAllocUngrouped()">DBAllocUngrouped()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_16.htm_IX_DBAllocUngrouped()">
 </A>
<H1 CLASS="refHeading">
DBAllocUngrouped()</H1>
<PRE CLASS="syntax">DBGroupAndItem 	DBAllocUngrouped(
        VMFileHandle		file,			
        word		size);</PRE>
<P>
This routine allocates an ungrouped item in the specified file. It is passed the handle of the file which will contain the new item. It returns the item's <CODE>
DBGroupAndItem</CODE>
 value.</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	All pointers to ungrouped items may be invalidated.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
dbase.h</STRONG>
 </P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_16.htm#IX_DBAlloc()">DBAlloc()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_16.htm_IX_DBCombineGroupAndItem() macro">
 </A>
<H1 CLASS="refHeading">
DBCombineGroupAndItem()</H1>
<PRE CLASS="syntax">DBGroupAndItem 	DBCombineGroupAndItem(
        DBGroup 		group,
        DBItem 		item);</PRE>
<P>
This macro combines group and item handles into a dword-sized <CODE>
DBGroupAndItem</CODE>
 value.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
dbase.h</STRONG>
 </P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_17.htm#IX_DBGroupFromGroupAndItem() macro">DBGroupFromGroupAndItem()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_17.htm#IX_DBItemFromGroupAndItem() macro">DBItemFromGroupAndItem()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_16.htm_IX_DBCopyDBItem()">
 </A>
<H1 CLASS="refHeading">
DBCopyDBItem()</H1>
<PRE CLASS="syntax">DBItem 	DBCopyDBItem(
        VMFileHandle		srcFile,				
        DBGroup		srcGroup,
        DBItem		srcItem,
        VMFileHandle		destFile,				
        DBGroup		destGroup);</PRE>
<P>
This routine makes a duplicate of a DB item in the specified DB file and group. It is passed the file handle, group handle, and item handle of the source item, as well as the file handle and group handle of the destination group. It makes a copy of the DB item and returns its <CODE>
DBItem</CODE>
 handle.</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	All pointers to items in the destination group may be invalidated.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
dbase.h</STRONG>
 </P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_a2.htm#IX_VMCopyVMChain()">VMCopyVMChain()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_16.htm_IX_DBCopyDBItemUngrouped()">
 </A>
<H1 CLASS="refHeading">
DBCopyDBItemUngrouped()</H1>
<PRE CLASS="syntax">DBGroupAndItem 	DBCopyDBItemUngrouped(
        VMFileHandle		srcFile,				
        DBGroupAndItem		srcID,				/* source item */
        VMFileHandle		destFile);				</PRE>
<P>
This routine makes a duplicate of a specified DB item. It is passed the file handle and <CODE>
DBGroupAndItem</CODE>
 value specifying the source item, and the file handle of the destination file. It allocates the item as an ungrouped item in the specified file and returns its <CODE>
DBGroupAndItem</CODE>
 value.</P>
<P CLASS="refField"><STRONG>
Tips and Tricks:</STRONG>	If the source item is not ungrouped, you can combine the group and item handles into a <CODE>
DBGroupAndItem</CODE>
 value by calling the macro <CODE>
<A HREF="../../CRef/Routines/R_16.htm#IX_DBCombineGroupAndItem() macro">DBCombineGroupAndItem()</A></CODE>
.</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	All pointers to ungrouped items in the destination file may be invalidated.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
dbase.h</STRONG>
 </P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_a2.htm#IX_VMCopyVMChain()">VMCopyVMChain()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_16.htm_IX_DBDeleteAt()">
 </A>
<H1 CLASS="refHeading">
DBDeleteAt()</H1>
<PRE CLASS="syntax">void	DBDeleteAt(
        VMFileHandle		file,			
        DBGroup		group,
        DBItem		item,
        word		deleteOffset,
        word		deleteCount);</PRE>
<P>
This routine deletes a sequence of bytes from within an item. It does not invalidate pointers to other items. The routine is passed the file, group, and item handles specifying the item, as well as an offset within the item and a number of bytes to delete. It will delete the specified number of bytes from within the item, starting with the byte at the specified offset.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
dbase.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_16.htm_IX_DBDeleteAtUngrouped()">
 </A>
<H1 CLASS="refHeading">
DBDeleteAtUngrouped()</H1>
<PRE CLASS="syntax">void	DBDeleteAtUngrouped(
        VMFileHandle		file,				
        DBGroupAndItem		id,
        word		deleteOffset,
        word		deleteCount);</PRE>
<P>
This routine is just like <CODE>
<A HREF="../../CRef/Routines/R_16.htm#IX_DBDeleteAt()">DBDeleteAt()</A></CODE>
, except it is passed a <CODE>
DBGroupAndItem</CODE>
 value instead of separate group and item handles. It does not invalidate pointers to other items.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
dbase.h</STRONG>
 </P>
</DIV>
<HR>
<A NAME="R_17.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_17.htm_IX_DBDeref()">
 </A>
<H1 CLASS="refHeading">
DBDeref()</H1>
<PRE CLASS="syntax">void *	DBDeref(
        optr		*ref);</PRE>
<P>
This routine is passed an optr to a locked DB item. The routine returns the address of the item.</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	The optr becomes invalid when the DB item is unlocked.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
dbase.h</STRONG>
</P>
</DIV>
<DIV>
<A NAME="R_17.htm_IX_DBDirty()">
 </A>
<H1 CLASS="refHeading">
DBDirty()</H1>
<PRE CLASS="syntax">void	DBUnlock(
        const void *		ptr);</PRE>
<P>
This routine marks a DB item as dirty; this insures that the VM manager will copy its item-block back to the disk before freeing its memory. The routine is passed a pointer to anywhere within the item.</P>
<P CLASS="refField"><STRONG>
Tips and Tricks:</STRONG>	All the items in an item block are marked dirty at once; thus, you can call this routine just once for several items in the same item block. Only the segment portion of the pointer is significant; thus, you can pass a pointer to anywhere in the item. This is useful if you have incremented the pointer to the item.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
dbase.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_17.htm_IX_DBFree()">
 </A>
<H1 CLASS="refHeading">
DBFree()</H1>
<PRE CLASS="syntax">void	DBFree(
        VMFileHandle		file,
        DBGroup		group,
        DBItem		item);</PRE>
<P>
This routine frees the specified item. It does not invalidate pointers to other items in the group. It is passed the file, group, and item handles specifying the item; it does not return anything.</P>
<P CLASS="refField"><STRONG>
Never Use Situations:</STRONG>	 <BR>
Never call <CODE>
DBFree()</CODE>
 on a locked item. If you do, the item-block's lock count will not be decremented, which will prevent the item block from ever being properly unlocked.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
dbase.h</STRONG>
 </P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_17.htm#IX_DBFreeUngrouped()">DBFreeUngrouped()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_17.htm_IX_DBFreeUngrouped()">
 </A>
<H1 CLASS="refHeading">
DBFreeUngrouped()</H1>
<PRE CLASS="syntax">void	DBFreeUngrouped(
        VMFileHandle		file,
        DBGroupAndItem		id);</PRE>
<P>
This routine frees the specified item. It does not invalidate pointers to other ungrouped items. It is passed the file handle and <CODE>
DBGroupAndItem</CODE>
 value specifying the item; it does not return anything.</P>
<P CLASS="refField"><STRONG>
Never Use Situations:</STRONG>	 Never call <CODE>
DBFreeUngrouped()</CODE>
 on a locked item. If you do, the item-block's lock count will not be decremented, which will prevent the item block from ever being properly unlocked.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
dbase.h</STRONG>
 </P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_17.htm#IX_DBFree()">DBFree()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_17.htm_IX_DBGetMap()">
 </A>
<H1 CLASS="refHeading">
DBGetMap()</H1>
<PRE CLASS="syntax">DBGroupAndItem 	DBGetmap(
        VMFileHandle		file);</PRE>
<P>
This routine returns the <CODE>
DBGroupAndItem</CODE>
 structure for the passed file's map item. If there is no map item, it returns a null handle.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
dbase.h</STRONG>
 </P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_18.htm#IX_DBSetMap()">DBSetMap()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_18.htm#IX_DBLockMap()">DBLockMap()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_17.htm_IX_DBGroupAlloc()">
 </A>
<H1 CLASS="refHeading">
DBGroupAlloc()</H1>
<PRE CLASS="syntax">DBGroup	DBGroupAlloc(
        VMFileHandle		file);</PRE>
<P>
This routine allocates a new DB group in the specified file and returns its handle. If the group cannot be allocated, <CODE>
DBGroupAlloc()</CODE>
 returns a null handle.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
dbase.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_17.htm_IX_DBGroupFree()">
 </A>
<H1 CLASS="refHeading">
DBGroupFree()</H1>
<PRE CLASS="syntax">void	DBGroupFree(
        VMFileHandle		file,
        DBGroup		group);</PRE>
<P>
This routine frees the specified group. This deletes all items and item-blocks associated with the group. It is passed the file and group handle specifying the group. Note that you can free a group even if some of its items are locked; those locked items will also be freed.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
dbase.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_17.htm_IX_DBGroupFromGroupAndItem() macro">
 </A>
<H1 CLASS="refHeading">
DBGroupFromGroupAndItem()</H1>
<PRE CLASS="syntax">DBGroup	DBGroupFromGroupAndItem(
        DBGroupAndItem		id);</PRE>
<P>
This macro returns the <CODE>
DBGroup</CODE>
 portion of a <CODE>
DBGroupAndItem</CODE>
 value.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
dbase.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_17.htm_IX_DBInsertAt()">
 </A>
<H1 CLASS="refHeading">
DBInsertAt()</H1>
<PRE CLASS="syntax">void	DBInsertAt(
        VMFileHandle		file,			
        DBGroup		group,
        DBItem		item,
        word		insertOffset,
        word		insertCount);</PRE>
<P>
This routine inserts bytes at a specified offset within a DB item. The bytes are zero-initialized. It is passed the file, group, and item handles specifying a DB item, as well as an offset within the cell and a number of bytes to insert. It inserts the specified number of bytes beginning at the specified offset; the data which was at the passed offset will end up immediately after the inserted bytes.</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	This routine invalidates pointers to other items in the same group.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
dbase.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_17.htm_IX_DBInsertAtUngrouped()">
 </A>
<H1 CLASS="refHeading">
DBInsertAtUngrouped()</H1>
<PRE CLASS="syntax">void	DBInsertAtUngrouped(
        VMFileHandle		file,			
        DBGroupAndItem		id,
        word		insertOffset,
        word		insertCount);</PRE>
<P>
This routine is just like <CODE>
<A HREF="../../CRef/Routines/R_17.htm#IX_DBInsertAt()">DBInsertAt()</A></CODE>
, except it is passed a <CODE>
DBGroupAndItem</CODE>
 value instead of separate group and item handles.</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	This routine invalidates pointers to other ungrouped items.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
dbase.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_17.htm_IX_DBItemFromGroupAndItem() macro">
 </A>
<H1 CLASS="refHeading">
DBItemFromGroupAndItem()</H1>
<PRE CLASS="syntax">DBItem	DBItemFromGroupAndItem(
        DBGroupAndItem		id);</PRE>
<P>
This macro returns the <CODE>
DBItem</CODE>
 portion of a <CODE>
DBGroupAndItem</CODE>
 value.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
dbase.h</STRONG>
 </P>
</DIV>
<HR>
<A NAME="R_18.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_18.htm_IX_DBLock()">
 </A>
<H1 CLASS="refHeading">
DBLock()</H1>
<PRE CLASS="syntax">void *	DBLock(
        VMFileHandle		file,
        DBGroup		group,
        DBItem		item);</PRE>
<P>
This routine locks the specified item and returns a pointer to it. It is passed the file, group, and item handles specifying a DB item. If it fails, it returns a null pointer.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
dbase.h</STRONG>
 </P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_18.htm#IX_DBLockGetRef()">DBLockGetRef()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_18.htm#IX_DBLockUngrouped()">DBLockUngrouped()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_18.htm_IX_DBLockGetRef()">
 </A>
<H1 CLASS="refHeading">
DBLockGetRef()</H1>
<PRE CLASS="syntax">void *	DBLockGetRef(
        VMFileHandle		file,			
        DBGroup		group,
        DBItem		item,
        optr *		ref);</PRE>
<P>
This routine is just like <CODE>
<A HREF="../../CRef/Routines/R_18.htm#IX_DBLock()">DBLock()</A></CODE>
, except that it writes the item's optr to the passed address.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
dbase.h</STRONG>
 </P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	The optr is only valid until the DB item is unlocked.</P>
</DIV>
<DIV>
<A NAME="R_18.htm_IX_DBLockGetRefUngrouped()">
 </A>
<H1 CLASS="refHeading">
DBLockGetRefUngrouped()</H1>
<PRE CLASS="syntax">void *	DBLockGetRefUngrouped(
        VMFileHandle		file,			
        DBGroupAndItem		id,
        optr *		ref);</PRE>
<P>
This routine is the same as <CODE>
<A HREF="../../CRef/Routines/R_18.htm#IX_DBLockGetRef()">DBLockGetRef()</A></CODE>
, except that it is passed a <CODE>
DBGroupAndItem</CODE>
 value.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
dbase.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_18.htm_IX_DBLockMap()">
 </A>
<H1 CLASS="refHeading">
DBLockMap()</H1>
<PRE CLASS="syntax">void *	DBLockMap(
        VMFileHandle		file);			</PRE>
<P>
This routine locks the specified file's map item and returns its address. To unlock the map item, call <CODE>
<A HREF="../../CRef/Routines/R_18.htm#IX_DBUnlock()">DBUnlock()</A></CODE>
 normally.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
dbase.h</STRONG>
 </P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_18.htm#IX_DBLockMap()">DBLockMap()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_18.htm_IX_DBLockUngrouped()">
 </A>
<H1 CLASS="refHeading">
DBLockUngrouped()</H1>
<PRE CLASS="syntax">void *	DBLockUngrouped(
        VMFileHandle		file,			
        DBGroupAndItem		id);</PRE>
<P>
This routine is the same as <CODE>
<A HREF="../../CRef/Routines/R_18.htm#IX_DBLock()">DBLock()</A></CODE>
, except that it is passed a <CODE>
DBGroupAndItem</CODE>
 value.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
dbase.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_18.htm_IX_DBReAlloc()">
 </A>
<H1 CLASS="refHeading">
DBReAlloc()</H1>
<PRE CLASS="syntax">void	DBReAlloc(
        VMFileHandle		file,			
        DBGroup		group,
        DBItem		item,
        word		size);</PRE>
<P>
This routine changes the size of a DB item. It is passed the file, group, and item handles specifying the DB item, and a new size for the item (in bytes). If the new size is larger than the old, space will be added to the end of the item; if the new size is smaller than the old, the item will be truncated to fit.</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	If the new size is larger than the old, all pointers to items in the group are invalidated. Space added is not zero-initialized.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
dbase.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_18.htm_IX_DBReAllocUngrouped()">
 </A>
<H1 CLASS="refHeading">
DBReAllocUngrouped()</H1>
<PRE CLASS="syntax">void	DBReAllocUngrouped(
        VMFileHandle		file,			
        DBGroupAndItem		id,
        word		size);</PRE>
<P>
This routine is just like <CODE>
<A HREF="../../CRef/Routines/R_18.htm#IX_DBReAlloc()">DBReAlloc()</A></CODE>
, except it is passed a <CODE>
DBGroupAndItem</CODE>
 value instead of separate group and item handles.</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	If the new size is larger than the old, all pointers to ungrouped items are invalidated. Space added is not zero-initialized.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
dbase.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_18.htm_IX_DBSetMap()">
 </A>
<H1 CLASS="refHeading">
DBSetMap()</H1>
<PRE CLASS="syntax">void	DBSetMap(
        VMFileHandle		file,			
        DBGroup		group,
        DBItem		item);</PRE>
<P>
This routine sets the DB map item. You can later retrieve a <CODE>
DBGroupAndItem</CODE>
 structure identifying this item by calling <CODE>
<A HREF="../../CRef/Routines/R_17.htm#IX_DBGetMap()">DBGetMap()</A></CODE>
. The routine is passed the file, group, and item handles specifying the new map item; it does not return anything.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
dbase.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_18.htm_IX_DBSetMapUngrouped()">
 </A>
<H1 CLASS="refHeading">
DBSetMapUngrouped()</H1>
<PRE CLASS="syntax">void	DBSetMapUngrouped(
        VMFileHandle		file,			
        DBGroupAndItem		id);</PRE>
<P>
This routine is just like <CODE>
<A HREF="../../CRef/Routines/R_18.htm#IX_DBSetMap()">DBSetMap()</A></CODE>
, except it is passed a <CODE>
DBGroupAndItem</CODE>
 value instead of separate group and item handles.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
dbase.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_18.htm_IX_DBUnlock()">
 </A>
<H1 CLASS="refHeading">
DBUnlock()</H1>
<PRE CLASS="syntax">void	DBUnlock(
        void *	ptr); /* address of item to unlock */</PRE>
<P>
This routine unlocks the DB item whose address is passed.</P>
<P CLASS="refField"><STRONG>
Tips and Tricks:</STRONG>	Only the segment address of the pointer is significant. Thus, you can pass a pointer to somewhere within an item (or immediately after it) to unlock it.</P>
<P CLASS="refField"><STRONG>
Be Sure To:</STRONG>	If the item has been changed, make sure you call <CODE>
<A HREF="../../CRef/Routines/R_17.htm#IX_DBDirty()">DBDirty()</A></CODE>
 <EM>
before</EM>
 you unlock it.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
dbase.h</STRONG>
 </P>
</DIV>
<HR>
<A NAME="R_19.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_19.htm_IX_DiskCheckInUse()">
 </A>
<H1 CLASS="refHeading">
DiskCheckInUse()</H1>
<PRE CLASS="syntax">Boolean	DiskCheckInUse(
        DiskHandle		disk);</PRE>
<P>
This routine checks if a registered disk is being used. If a file on that disk is open, or if a path on that disk is on some thread's directory stack, the routine will return <EM>
true</EM>
 (i.e. non-zero); otherwise it will return <EM>
false</EM>
 (i.e. zero). Note that a disk may be &quot;in use&quot; even if it is not currently in any drive.</P>
<P CLASS="refField"><STRONG>
Tips and Tricks:</STRONG>	If you pass a standard path constant, this routine will return information about the disk containing the main <STRONG CLASS="fileName">
geos.ini</STRONG>
 file (which is guaranteed to be in use).</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
disk.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_19.htm_IX_DiskCheckUnnamed()">
 </A>
<H1 CLASS="refHeading">
DiskCheckUnnamed()</H1>
<PRE CLASS="syntax">Boolean	DiskCheckUnnamed( /* returns <EM>true</EM> if disk is unnamed */
        DiskHandle		disk);</PRE>
<P>
This routine checks if a registered disk has a permanent name. If the disk does not have a name, the routine returns <EM>
true</EM>
 (i.e. non-zero); otherwise it returns <EM>
false</EM>
. Note that GEOS assigns a temporary name to unnamed disks when they are registered. To find out a disk's temporary or permanent name, call <CODE>
<A HREF="../../CRef/Routines/R_1b.htm#IX_DiskGetVolumeName()">DiskGetVolumeName()</A></CODE>
.</P>
<P CLASS="refField"><STRONG>
Tips and Tricks:</STRONG>	If you pass a standard path constant, this routine will return information about the disk containing the main <STRONG CLASS="fileName">
geos.ini</STRONG>
 file.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_1b.htm#IX_DiskGetVolumeName()">DiskGetVolumeName()</A></CODE>.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
disk.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_19.htm_IX_DiskCheckWritable()">
 </A>
<H1 CLASS="refHeading">
DiskCheckWritable()</H1>
<PRE CLASS="syntax">Boolean	DiskCheckWritable(
        DiskHandle		disk);</PRE>
<P>
<CODE>
DiskCheckWritable()</CODE>
 checks if a disk is currently writable. It returns <EM>
false</EM>
 (i.e. zero) if the disk is not writable, whether by nature (e.g. a CD-ROM disk) or because the write-protect tab is on; otherwise it returns <EM>
true</EM>
 (i.e. non-zero). </P>
<P CLASS="refField"><STRONG>
Tips and Tricks:</STRONG>	If you pass a standard path constant, this routine will return information about the disk containing the main <STRONG CLASS="fileName">
geos.ini</STRONG>
 file.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
disk.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_19.htm_IX_DiskCopy()">
 </A>
<A NAME="R_19.htm_IX_CALLBACK_&ldots;">
 </A>
<A NAME="R_19.htm_IX_DiskCopyCallback">
 </A>
<A NAME="R_19.htm_IX_DiskCopyError">
 </A>
<A NAME="R_19.htm_IX_ERR_&ldots;  (DiskCopyError)">
 </A>
<H1 CLASS="refHeading">
 DiskCopy()</H1>
<PRE CLASS="syntax">DiskCopyError 	DiskCopy(
        word		source,
        word		dest,
        Boolean _pascal (*callback)
		(DiskCopyCallback					code,
		 DiskHandle					disk,
		 word					param));</PRE>
<P>
This routine copies one disk onto another. The destination disk must be formattable to be the same type as the source disk. The first two arguments specify the source and destination drive. These drives may or may not be the same. If they are different, they must take compatible disks. </P>
<P>
A disk copy requires frequent interaction with the user. For example, the copy routine must prompt the user to swap disks when necessary. For this reason, <CODE>
<A HREF="../../CRef/Routines/R_19.htm#IX_DiskCopy()">DiskCopy()</A></CODE>
 is passed a pointer to a callback routine. This routine handles all interaction with the user. It must be declared _pascal. Each time it is called, it is passed three arguments. The first is a member of the <CODE>
DiskCopyCallback</CODE>
 enumerated type; this argument specifies what the callback routine should do. The second argument is a disk handle; its significance depends on the value of the <CODE>
DiskCopyCallback</CODE>
 argument. The third argument is a word-sized piece of data whose significance depends on the value of the <CODE>
DiskCopyCallback</CODE>
 argument. Note that either of these arguments may be null values, depending on the value of the <CODE>
DiskCopyCallback</CODE>
 argument.</P>
<P>
The callback routine can abort the copy by returning <EM>
true</EM>
 (i.e. non-zero); otherwise, it should return <EM>
false</EM>
 (i.e. zero). The callback routine is called for several situations, identified by the value of <CODE>
DiskCopyCallback</CODE>
 associated with them:</P>
<DL>
<DT>
CALLBACK_GET_SOURCE_DISK</DT><DD>
The callback routine should prompt the user to insert the source disk into the appropriate drive. The second argument is meaningless for this call. The third argument is the number identifying the drive; use <CODE>
<A HREF="../../CRef/Routines/R_1d.htm#IX_DriveGetName()">DriveGetName()</A></CODE>
 to find the name for this drive.</DD>
<DT>
CALLBACK_GET_DEST_DISK</DT><DD>
The callback routine should prompt the user to insert the destination disk into the appropriate drive. The second argument is meaningless for this call. The third argument is the number identifying the drive.</DD>
<DT>
CALLBACK_REPORT_NUM_SWAPS</DT><DD>
The second argument is meaningless for this call. The third argument is the number of disk swaps that will be necessary. The callback routine may wish to report this number to the user and ask for confirmation.</DD>
<DT>
CALLBACK_VERIFY_DEST_DESTRUCTION</DT><DD>
If the destination disk has already been formatted, the callback routine will be called with this parameter. The callback routine may wish to remind the user that the destination disk will be erased. The second argument is the handle of the destination disk; this is useful if, for example, you want to report the disk's name. The third argument is the destination drive's number. If the callback routine aborts the copy at this time by returning non-zero, the destination disk will not be harmed.</DD>
<DT>
CALLBACK_REPORT_FORMAT_PCT</DT><DD>
If the destination disk needs to be formatted, <CODE>
<A HREF="../../CRef/Routines/R_19.htm#IX_DiskCopy()">DiskCopy()</A></CODE>
 will periodically call the callback routine with this parameter. The callback routine may wish to notify the user how the format is progressing. In this case, the second argument will be meaningless; the third parameter will be the percentage of the destination disk which has been formatted. The callback routine may wish to notify the user how the format is progressing.</DD>
<DT>
CALLBACK_REPORT_COPY_PCT</DT><DD>
While the copy is taking place, <CODE>
<A HREF="../../CRef/Routines/R_19.htm#IX_DiskCopy()">DiskCopy()</A></CODE>
 will periodically call the callback routine with this parameter. The callback routine may wish to notify the user how the copy is progressing. In this case, the second parameter will be meaningless; the third parameter will be the percentage of the copy which has been completed.</DD>
</DL>
<P>
If the copy was successful, <CODE>
<A HREF="../../CRef/Routines/R_19.htm#IX_DiskCopy()">DiskCopy()</A></CODE>
 returns zero. Otherwise, it returns a member of the <CODE>
DiskCopyError</CODE>
 enumerated type. That type has the following members:</P>
<DL>
<DT>
ERR_DISKCOPY_INSUFFICIENT_MEM</DT><DD>
This is returned if the routine was unable to get adequate memory.</DD>
<DT>
ERR_CANT_COPY_FIXED_DISKS </DT>
<DT>
ERR_CANT_READ_FROM_SOURCE </DT>
<DT>
ERR_CANT_WRITE_TO_DEST </DT>
<DT>
ERR_INCOMPATIBLE_FORMATS</DT><DD>
The destination drive must be able to write disks in exactly the same format as the source disk. Note that the source and destination drives may be the same.</DD>
<DT>
ERR_OPERATION_CANCELLED</DT><DD>
This is returned if the callback routine ever returned a non-zero value, thus aborting the copy.</DD>
<DT>
ERR_CANT_FORMAT_DEST </DT>
</DL>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
disk.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_19.htm_IX_DiskFind()">
 </A>
<A NAME="R_19.htm_IX_DiskFindResult">
 </A>
<A NAME="R_19.htm_IX_DFR_&ldots;">
 </A>
<H1 CLASS="refHeading">
DiskFind()</H1>
<PRE CLASS="syntax">DiskHandle 	DiskFind(
        const char *		fname,			/* Null-terminated volume name */
        DiskFindResult *		code);			/* DiskFindResult written here */</PRE>
<P>
This routine returns the handle of the disk with the specified name. If there is no registered disk with the specified name, <CODE>
DiskFind()</CODE>
 returns a null handle. Note that while disk handles are unique, volume names are not; therefore, there may be several registered disks with identical volume names. For this reason, <CODE>
DiskFind()</CODE>
 writes a member of the <CODE>
DiskFindResults</CODE>
 enumerated type (described below) into the space pointed to by the <EM>
code</EM>
 pointer.</P>
<P CLASS="refField"><STRONG>
Structures:</STRONG>	<CODE>
DiskFind()</CODE>
 uses the <CODE>
DiskFindResult</CODE>
 enumerated type, which has the following values:</P>
<DL>
<DT>
DFR_UNIQUE</DT><DD>
There is exactly one registered disk with the specified name; its handle was returned.</DD>
<DT>
DFR_NOT_UNIQUE</DT><DD>
There are two or more registered disks with the specified name; the handle of an arbitrary one of these disks was returned.</DD>
<DT>
DFR_NOT_FOUND</DT><DD>
There are no registered disks with the specified name; a null disk handle was returned.</DD>
</DL>
<P CLASS="refField"><STRONG>
Tips and Tricks:</STRONG>	If you want to find all the disks with a given volume name, call <CODE>
<A HREF="../../CRef/Routines/R_1a.htm#IX_DiskForEach()">DiskForEach()</A></CODE>
 and have the callback routine check each disk's name with <CODE>
<A HREF="../../CRef/Routines/R_1b.htm#IX_DiskGetVolumeName()">DiskGetVolumeName()</A></CODE>
.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_1b.htm#IX_DiskRegisterDisk()">DiskRegisterDisk()</A></CODE>.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
disk.h</STRONG>
 </P>
</DIV>
<HR>
<A NAME="R_1a.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_1a.htm_IX_DiskForEach()">
 </A>
<H1 CLASS="refHeading">
DiskForEach()</H1>
<PRE CLASS="syntax">DiskHandle 	DiskForEach(
        Boolean _pascal (* callback)			(DiskHandle				disk)) 		/* callback returns <EM>true
</EM>									 * to cancel */</PRE>
<P>
This routine lets you perform an action on every registered disk. It calls the callback routine once for each disk, passing the disk's handle. The callback routine must be declared _pascal. The callback routine can force an early termination by returning <EM>
true</EM>
 (i.e. non-zero). If the callback routine ever returns <EM>
true</EM>
, <CODE>
DiskForEach()</CODE>
 terminates and returns the handle of the last disk passed to the callback routine. If the callback routine examines every disk without returning <EM>
true</EM>
, <CODE>
DiskForEach()</CODE>
 returns a null handle.</P>
<P CLASS="refField"><STRONG>
Tips and Tricks:</STRONG>	<CODE>
DiskForEach()</CODE>
 is commonly used to look for a specific disk. The callback routine checks each disk to see if it's the one; if it finds a match, the callback routine simply returns <EM>
true</EM>
, and <CODE>
DiskForEach()</CODE>
 returns the disk's handle.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
disk.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_1a.htm_IX_DiskFormat()">
 </A>
<A NAME="R_1a.htm_IX_DiskFormatFlags">
 </A>
<A NAME="R_1a.htm_IX_DFF_&ldots;">
 </A>
<A NAME="R_1a.htm_IX_FormatError">
 </A>
<A NAME="R_1a.htm_IX_FMT_&ldots;">
 </A>
<H1 CLASS="refHeading">
DiskFormat()</H1>
<PRE CLASS="syntax">FormatError 	DiskFormat(
        word 		driveNumber,
        MediaType	media,			/* Format to this size */
        DiskFormatFlags	flags,			/* See flags below */
        dword		*goodClusters,		/* These are filled in at the */
        dword		*badClusters,		/* of the format */
	DiskHandle 	disk,			/* handle of disk, or
						 * 0 if disk unformatted, or
						 * 1 if drive state unknown */
	char 		*volumeName,		/* new name of disk */
        Boolean _pascal (*callback)		
			(word percentDone));	/* Return true to cancel */
</PRE>
<P>
This routine formats a disk to the specified size. When it is finished, it fills in the passed pointers to contain the number of good and bad clusters on the disk. (To find out the size of each cluster, call <CODE>
<A HREF="../../CRef/Routines/R_1b.htm#IX_DiskGetVolumeInfo()">DiskGetVolumeInfo()</A></CODE>
.) The routine returns a member of the <CODE>
FormatError</CODE>
 enumerated type (whose members are described below).</P>
<P>
<CODE>
DiskFormat()</CODE>
 can be instructed to call a callback routine periodically. This allows the application to keep the user informed about how the format is progressing. The callback routine is passed either the percent of the disk which has been formatted, or the cylinder and head currently being formatted. The callback routine must be declared _pascal. The callback routine can cancel the format by returning <EM>
true</EM>
 (i.e. non-zero); otherwise, it should return <EM>
false</EM>
 (i.e. zero).</P>
<P>
The third argument passed is a word-length flag field. Currently, only three flags are defined:</P>
<DL>
<DT>
DFF_CALLBACK_PERCENT_DONE</DT><DD>
A callback routine should be called periodically. The callback routine should be passed a single argument, namely the percentage of the format which has been done.</DD>
<DT>
DFF_CALLBACK_CYL_HEAD</DT><DD>
A callback routine should be called periodically. The callback routine should be passed a single argument, namely the cylinder head being formatted. If both DFF_CALLBACK_PERCENT_DONE and DFF_CALLBACK_CYL_HEAD are passed, results are undefined. If neither flag is set, the callback routine will never be called; a null function pointer may be passed.</DD>
<DT>
DFF_FORCE_ERASE</DT><DD>
A &quot;hard format&quot; should be done, i.e. the sectors should be rewritten and initialized to zeros. If this flag is not set, <CODE>
DiskFormat()</CODE>
 will do a &quot;soft format&quot; if possible; it will check the sectors and write a blank file allocation table, but it will not necessarily erase the data from the disk.</DD>
</DL>
<P>
<CODE>
DiskFormat()</CODE>
 returns a member of the <CODE>
FormatError</CODE>
 enumerated type. If the format was successful, it will return the constant FMT_DONE (which is guaranteed to equal zero). Otherwise, it will return one of the following constants:</P>
<PRE>FMT_DRIVE_NOT_READY
FMT_ERROR_WRITING_BOOT
FMT_ERROR_WRITING_ROOT_DIR
FMT_ERROR_WRITING_FAT
FMT_ABORTED
FMT_SET_VOLUME_NAME_ERROR
FMT_CANNOT_FORMAT_FIXED_DISKS_IN_CUR_RELEASE
FMT_BAD_PARTITION_TABLE
FMT_ERR_NO_PARTITION_FOUND
FMT_ERR_CANNOT_ALLOC_SECTOR_BUFFER
FMT_ERR_DISK_IS_IN_USE
FMT_ERR_WRITE_PROTECTED
FMT_ERR_DRIVE_CANNOT_SUPPORT_GIVEN_FORMAT
FMT_ERR_INVALID_DRIVE_SPECIFIED
FMT_ERR_DRIVE_CANNOT_BE_FORMATTED
FMT_ERR_DISK_UNAVAILABLE</PRE>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
disk.h</STRONG>
 </P>
</DIV>
<HR>
<A NAME="R_1b.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_1b.htm_IX_DiskGetDrive()">
 </A>
<H1 CLASS="refHeading">
DiskGetDrive()</H1>
<PRE CLASS="syntax">word	DiskGetDrive(
        DiskHandle		dh);</PRE>
<P>
This routine returns the drive number associated with a registered disk. Note that it will do this even if the drive is no longer usable (e.g. if a network drive has been unmapped).</P>
<P CLASS="refField"><STRONG>
Tips and Tricks:</STRONG>	If you pass a standard path constant, this routine will return information about the disk containing the main <STRONG CLASS="fileName">
geos.ini</STRONG>
 file.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_19.htm#IX_DiskFind()">DiskFind()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_1b.htm#IX_DiskRegisterDisk()">DiskRegisterDisk()</A></CODE>.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
disk.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_1b.htm_IX_DiskGetVolumeFreeSpace()">
 </A>
<H1 CLASS="refHeading">
DiskGetVolumeFreeSpace()</H1>
<PRE CLASS="syntax">dword	DiskGetVolumeFreeSpace( 
        DiskHandle		dh);</PRE>
<P>
This routine returns the amount of free space (measured in bytes) on the specified disk. If the disk is, by nature, not writable (e.g. a CD-ROM disk), <CODE>
DiskGetVolumeFreeSpace()</CODE>
 returns zero and clears the thread's error value. If an error condition exists, <CODE>
DiskGetVolumeFreeSpace()</CODE>
 returns zero and sets the thread's error value.</P>
<P CLASS="refField"><STRONG>
Tips and Tricks:</STRONG>	If you pass a standard path constant, this routine will return information about the disk containing the main <STRONG CLASS="fileName">
geos.ini</STRONG>
 file.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_1b.htm#IX_DiskGetVolumeInfo()">DiskGetVolumeInfo()</A></CODE>.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
disk.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_1b.htm_IX_DiskGetVolumeInfo()">
 </A>
<H1 CLASS="refHeading">
DiskGetVolumeInfo()</H1>
<PRE CLASS="syntax">word	DiskGetVolumeInfo(  /* Returns 0 if successful */
        DiskHandle		dh,
        DiskInfoStruct		*info);			/* Routine fills this structure */</PRE>
<P>
This routine returns general information about a disk. It returns the following four pieces of information:</P>
<UL>
<LI>
The size of each disk block in bytes. When space is allocated, it is rounded up to the nearest whole block.</LI>
<LI>
The number of free bytes on the disk.</LI>
<LI>
The total number of bytes on the disk; this is the total of free and used space.</LI>
<LI>
The disk's volume name. If the volume is unnamed, the current temporary name will be returned.</LI>
</UL>
<P>
The information is written to the passed <CODE>
DiskInfoStruct</CODE>
. If an error condition occurs, <CODE>
DiskGetVolumeInfo()</CODE>
 will return the error code and set the thread's error value; otherwise, it will return zero.</P>
<P CLASS="refField"><STRONG>
Tips and Tricks:</STRONG>	If you pass a standard path constant, this routine will return information about the disk containing the main <STRONG CLASS="fileName">
geos.ini</STRONG>
 file.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
disk.h</STRONG>
</P>
</DIV>
<DIV>
<A NAME="R_1b.htm_IX_DiskGetVolumeName()">
 </A>
<H1 CLASS="refHeading">
DiskGetVolumeName()</H1>
<PRE CLASS="syntax">void	DiskGetVolumeName(
        DiskHandle		dh,
        char *		buffer);			/* Must be VOLUME_NAME_LENGTH_ZT bytes
						 * long */</PRE>
<P>
This routine copies the disk's volume name (as a null-terminated string) to the passed buffer. If an error occurs, it sets the thread's error value. If the volume has no name, the routine returns the current temporary name.</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	<CODE>
DiskGetVolumeName()</CODE>
 does not check the size of the buffer passed. If the buffer is not at least VOLUME_NAME_LENGTH_ZT bytes long, the routine may write beyond its boundaries.</P>
<P CLASS="refField"><STRONG>
Tips and Tricks:</STRONG>	If you pass a standard path constant, this routine will return information about the disk containing the main <STRONG CLASS="fileName">
geos.ini</STRONG>
 file.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_1b.htm#IX_DiskGetVolumeInfo()">DiskGetVolumeInfo()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_1c.htm#IX_DiskSetVolumeName()">DiskSetVolumeName()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_1b.htm_IX_DiskRegisterDisk()">
 </A>
<H1 CLASS="refHeading">
DiskRegisterDisk()</H1>
<PRE CLASS="syntax">DiskHandle 	DiskRegisterDisk(
        word	driveNumber); </PRE>
<P>
This routine registers a disk in the specified drive and assigns it a disk handle. (The disk handle persists only to the end of the current session of GEOS.) If the disk already has a handle, <CODE>
DiskRegisterDisk()</CODE>
 will return it. If the disk does not have a name, GEOS will assign it a temporary name (such as &quot;UNNAMED1&quot;) and display an alert box telling the user what the temporary name is. (This is done only the first time the disk is registered in each session.) Note that the temporary name is not written to the disk; thus, it persists only until the end of the current session of GEOS.</P>
<P>
If this routine returns a disk handle, there's a disk in the drive; if it doesn't, there may still be a disk in the drive, but the disk is unformatted.</P>
<P CLASS="refField"><STRONG>
Tips and Tricks:</STRONG>	There is no harm in registering the same disk several times. Thus, if you want to get the disk handle for the disk in a specific drive, you can simply call <CODE>
DiskRegisterDisk()</CODE>
.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_1b.htm#IX_DiskRegisterDiskSilently()">DiskRegisterDiskSilently()</A></CODE>.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
disk.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_1b.htm_IX_DiskRegisterDiskSilently()">
 </A>
<H1 CLASS="refHeading">
DiskRegisterDiskSilently()</H1>
<PRE CLASS="syntax">DiskHandle 	DiskRegisterDiskSilently(
        word		driveNumber);</PRE>
<P>
This routine is almost identical to <CODE>
<A HREF="../../CRef/Routines/R_1b.htm#IX_DiskRegisterDisk()">DiskRegisterDisk()</A></CODE>
 (described immediately above). There is only one difference: If GEOS assigns a temporary name to the disk, it will not present an alert box to the user.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_1b.htm#IX_DiskRegisterDisk()">DiskRegisterDisk()</A></CODE>.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
disk.h</STRONG>
</P>
</DIV>
<DIV>
<A NAME="R_1b.htm_IX_DiskRestore()">
 </A>
<A NAME="R_1b.htm_IX_DiskRestoreError">
 </A>
<A NAME="R_1b.htm_IX_DRE_&ldots;">
 </A>
<H1 CLASS="refHeading">
DiskRestore()</H1>
<PRE CLASS="syntax">DiskHandle 	DiskRestore(
        void *		buffer,			/* buffer written by DiskSave() */
        DiskRestoreError _pascal (*callback)	
			(const char 						*driveName,
			 const char 						*diskName,
			 void 						**bufferPtr,</PRE>
<PRE CLASS="syntax">        		 DiskRestoreError 						error);</PRE>
<P>
<CODE>
DiskRestore()</CODE>
 examines a buffer written by <CODE>
<A HREF="../../CRef/Routines/R_1c.htm#IX_DiskSave()">DiskSave()</A></CODE>
 and returns the handle of the disk described by that buffer. If that disk is already registered, <CODE>
DiskRestore()</CODE>
 will simply return its handle. If the disk is not registered and is not in the drive, <CODE>
DiskRestore()</CODE>
 will call the specified callback routine. The callback routine should be declared _pascal. The callback routine is passed four arguments:</P>
<UL>
<LI>
A null-terminated string containing the name of the drive for the disk.</LI>
<LI>
A null-terminated string containing the disk's volume label.</LI>
<LI>
A pointer to a variable in the <CODE>
DiskRestore()</CODE>
 routine. This variable is itself a pointer to the opaque data structure provided by <CODE>
<A HREF="../../CRef/Routines/R_1c.htm#IX_DiskSave()">DiskSave()</A></CODE>
. If the callback routine takes any action which causes that structure to move (e.g. if it causes the global or local heap containing the buffer to be shuffled), it should update the pointer in <CODE>
DiskRestore()</CODE>
.</LI>
<LI>
A member of the <CODE>
DiskRestoreError</CODE>
 enumerated type. This is the error which <CODE>
DiskRestore()</CODE>
 would have returned if there had not been a callback routine. This is usually DRE_REMOVABLE_DRIVE_DOESNT_HOLD_DISK.</LI>
</UL>
<P>
The callback routine should prompt the user to insert a disk. If the callback routine was successful, it should return DRE_DISK_IN_DRIVE (which is guaranteed to be equal to zero). Otherwise, it should return a member of the <CODE>
DiskRestoreError</CODE>
 enumerated type; usually it will return DRE_USER_CANCELLED_RESTORE. Note that the callback routine will not generally know if the user has inserted a disk; it generally just displays an alert box and returns when the user clicks &quot;OK.&quot; After the callback routine returns, <CODE>
DiskRestore()</CODE>
 registers the disk and makes sure that it's the correct one; if it is not, it calls the callback routine again.</P>
<P>
You can pass a null function pointer to <CODE>
DiskRestore()</CODE>
 instead of providing a callback routine. In this case, <CODE>
DiskRestore()</CODE>
 will fail if the disk has not been registered and is not currently in the drive.</P>
<P>
<CODE>
DiskRestore()</CODE>
 returns the handle of the disk. If it fails for any reason, it returns a null handle and sets the thread's error value to a member of the <CODE>
DiskRestorenError</CODE>
 enumerated type. This type has the following members:</P>
<DL>
<DT>
DRE_DISK_IN_DRIVE</DT><DD>
This is returned by the callback routine. This is guaranteed to equal zero.</DD>
<DT>
DRE_DRIVE_NO_LONGER_EXISTS</DT><DD>
The disk is associated with a drive which is no longer attached to the system.</DD>
<DT>
DRE_REMOVABLE_DRIVE_DOESNT_CONTAIN_DISK</DT><DD>
The disk is unregistered, and it is not currently in the drive associated with it. If a callback routine was provided, <CODE>
DiskRestore()</CODE>
 will call it under these circumstances.</DD>
<DT>
DRE_USER_CANCELLED_RESTORE</DT><DD>
This is returned by the callback routine if the user cancels the restore.</DD>
<DT>
DRE_COULDNT_CREATE_NEW_DISK_HANDLE</DT><DD>
<CODE>
DiskRestore()</CODE>
 was unable to register the disk in the appropriate drive because it couldn't create a new disk handle.</DD>
<DT>
DRE_REMOVABLE_DRIVE_IS_BUSY</DT><DD>
The appropriate drive is busy with a time-consuming operation (e.g. a disk format).</DD>
<DT>
DRE_NOT_ATTACHED_TO_SERVER</DT><DD>
The disk was from a network server to which we are not logged in.</DD>
<DT>
DRE_PERMISSION_DENIED</DT><DD>
The disk was on a network which is now denying access to it.</DD>
<DT>
DRE_ALL_DRIVES_USED</DT><DD>
The disk was on a network volume that isn't mounted, but there is no drive left to which it can be mapped.</DD>
</DL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_1c.htm#IX_DiskSave()">DiskSave()</A></CODE>.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
disk.h</STRONG>
 </P>
</DIV>
<HR>
<A NAME="R_1c.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_1c.htm_IX_DiskSave()">
 </A>
<H1 CLASS="refHeading">
DiskSave()</H1>
<PRE CLASS="syntax">Boolean	DiskSave(
        DiskHandle		disk,
        void *		buffer,				/* data will be written here */
        word *		bufferSize);				/* Size of buffer (in bytes) */</PRE>
<P>
This routine writes information about a disk in the specified buffer. <CODE>
<A HREF="../../CRef/Routines/R_1b.htm#IX_DiskRestore()">DiskRestore()</A></CODE>
 can use this information to return the disk handle, even in another session of GEOS. The <EM>
bufferSize</EM>
 argument should point to a word containing the size of the buffer (in bytes). If the buffer is large enough, <CODE>
DiskSave()</CODE>
 will write an opaque data structure into the buffer, and change the value of <CODE>
*bufferSize</CODE>
 to the actual size of the data structure; any extra buffer space can be freed or otherwise used. In this case, <CODE>
DiskSave()</CODE>
 will return <EM>
true</EM>
 (i.e. non-zero). If the buffer was too small, <CODE>
DiskSave()</CODE>
 will return <EM>
false</EM>
 (i.e. zero) and write the size needed into <CODE>
*bufferSize</CODE>
. Simply call <CODE>
DiskSave()</CODE>
 again with a large enough buffer. If <CODE>
DiskSave()</CODE>
 failed for some other reason, it will return <EM>
false</EM>
 and set <CODE>
*bufferSize</CODE>
 to zero.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_1b.htm#IX_DiskRestore()">DiskRestore()</A></CODE>.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	 <STRONG CLASS="fileName">
disk.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_1c.htm_IX_ERROR_&ldots;">
 </A>
<A NAME="R_1c.htm_IX_DiskSetVolumeName()">
 </A>
<H1 CLASS="refHeading">
DiskSetVolumeName()</H1>
<PRE CLASS="syntax">word	DiskSetVolumeName(
        DiskHandle		dh,
        const char *		name);			/* Change the name to this */</PRE>
<P>
This routine changes the disk's volume label. If it is successful, it returns zero; otherwise it returns an error code. It also sets or clears the thread's error value appropriately. The following error codes may be returned:</P>
<DL>
<DT>
ERROR_INVALID_VOLUME</DT><DD>
An invalid disk handle was passed to the routine.</DD>
<DT>
ERROR_ACCESS_DENIED</DT><DD>
For some reason, the volume's name could not be changed. For example, the volume might not be writable.</DD>
<DT>
ERROR_DISK_STALE</DT><DD>
The drive containing that disk has been deleted. This usually only happens with network drives.</DD>
</DL>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
disk.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_1c.htm_IX_DosExec()">
 </A>
<H1 CLASS="refHeading">
DosExec()</H1>
<PRE CLASS="syntax">word	DosExec(
        const char *		prog,
        DiskHandle 		progDisk,
        const char *		arguments,
        const char *		execDir,
        DiskHandle 		execDisk,
        DosExecFlags 		flags);</PRE>
<P>
This routine shuts down GEOS to run a DOS program. It returns an error code if an error occurs or zero if successful. Its parameters are listed below:</P>
<DL>
<DT>
<CODE>
prog</CODE>
</DT><DD>A pointer to a null-terminated character string representing the path of the program to be run. If a null string (not a null pointer), the system's DOS command interpreter will be run. The path string should not contain the drive name.</DD>
<DT>
<CODE>
progDisk</CODE>
</DT><DD>A disk handle indicating the disk on which the program to be executed sits. If zero is passed, the disk on which GEOS resides will be used.</DD>
<DT>
<CODE>
arguments</CODE>
</DT><DD>A pointer to a locked or fixed buffer containing arguments to be passed to the program being run.</DD>
<DT>
<CODE>
execDir</CODE>
</DT><DD>A pointer to a null-terminated character string representing the path in which the program is to be run. The string should not contain the drive name. If a null pointer is passed and <CODE>
execDisk</CODE>
 is zero, the program will be run in the directory in which GEOS was first started.</DD>
<DT>
<CODE>
execDisk</CODE>
</DT><DD>The disk handle of the disk containing the directory in <CODE>
execDir</CODE>
.</DD>
<DT>
<CODE>
flags</CODE>
</DT><DD>A record of <CODE>
DosExecFlags</CODE>
 indicating whether the DOS program will give a prompt to the user to return to GEOS. The possible flags are DEF_PROMPT, DEF_FORCED_SHUTDOWN, and DEF_INTERACTIVE. For more information, see the entry for <CODE>
DosExecFlags</CODE>
.</DD>
</DL>
<P>
If there was no error, <CODE>
DosExec() </CODE>
will return zero. Otherwise it will return one of the following error values: ERROR_FILE_NOT_FOUND, ERROR_DOS_EXEC_IN_PROGRESS, ERROR_INSUFFICIENT_MEMORY, or ERROR_ARGS_TOO_LONG.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
system.h</STRONG>
 </P>
</DIV>
<HR>
<A NAME="R_1d.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_1d.htm_IX_DriveGetDefaultMedia()">
 </A>
<H1 CLASS="refHeading">
DriveGetDefaultMedia()</H1>
<PRE CLASS="syntax">MediaType 	DriveGetDefaultMedia(
        word		driveNumber);</PRE>
<P>
This routine returns the default media type for the specified drive. It returns a member of the <CODE>
MediaType</CODE>
 enumerated type (described in the Data Structures reference). Note that a drive can be used for media types other than the default. For example, a high-density 3.5-inch drive will have a default media type of MEDIA_1M44, but it can read from, write to, and format 3.5-inch disks with size MEDIA_720K.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_1d.htm#IX_DriveTestMediaSupport()">DriveTestMediaSupport()</A></CODE>.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
drive.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_1d.htm_IX_DriveGetExtStatus()">
 </A>
<A NAME="R_1d.htm_IX_DES_&ldots;">
 </A>
<H1 CLASS="refHeading">
DriveGetExtStatus()</H1>
<PRE CLASS="syntax">word	DriveGetExtStatus(
        word		driveNumber);</PRE>
<P>
This routine is much like <CODE>
<A HREF="../../CRef/Routines/R_1d.htm#IX_DriveGetStatus()">DriveGetStatus()</A></CODE>
 (described immediately below). However, in addition to returning all of the flags set by <CODE>
<A HREF="../../CRef/Routines/R_1d.htm#IX_DriveGetStatus()">DriveGetStatus()</A></CODE>
, it also sets additional flags in the upper byte of the return value. It returns the following additional flags:</P>
<DL>
<DT>
DES_LOCAL_ONLY</DT><DD>
This flag is set if the device cannot be viewed over a network.</DD>
<DT>
DES_READ_ONLY</DT><DD>
This flag is set if the device is read only, i.e. no data can ever be written to a volume mounted on it (e.g., a CD-ROM drive).</DD>
<DT>
DES_FORMATTABLE</DT><DD>
This flag is set if disks can be formatted in the drive.</DD>
<DT>
DES_ALIAS</DT><DD>This flag is set if the drive is actually an alias for a path on another drive.</DD>
<DT>
DES_BUSY</DT><DD>This flag is set if the drive will be busy for an extended period of time (e.g., if a disk is being formatted).</DD>
</DL>
<P>
If an error condition exists, <CODE>
DriveGetExtStatus()</CODE>
 returns zero.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_1d.htm#IX_DriveGetStatus()">DriveGetStatus()</A></CODE>.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
drive.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_1d.htm_IX_DriveGetName()">
 </A>
<H1 CLASS="refHeading">
DriveGetName()</H1>
<PRE CLASS="syntax">char *	DriveGetName(
        word	driveNumber,	/* Get name of this drive */
        char *	buffer,	/* Write name to this buffer */
        word	bufferSize);	/* Size of buffer (in bytes) */</PRE>
<P>
This routine finds the name of a specified drive. You should use this name when prompting the user to take any action regarding this drive (e.g. to insert a disk). The routine writes the name, as a null terminated string, to the buffer passed. It returns a pointer to the trailing null. If the drive does not exist, or the buffer is too small, <CODE>
DriveGetName()</CODE>
 returns a null pointer.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
drive.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_1d.htm_IX_DriveGetStatus()">
 </A>
<A NAME="R_1d.htm_IX_DriveStatus">
 </A>
<A NAME="R_1d.htm_IX_DS_&ldots;  (DriveStatus)">
 </A>
<H1 CLASS="refHeading">
DriveGetStatus()</H1>
<PRE CLASS="syntax">word	DriveGetStatus(
        word	driveNumber);</PRE>
<P>
This routine returns the current status of a drive. The drive is specified by its drive number. The routine returns a word of <CODE>
DriveStatus</CODE>
 flags. These flags are listed below:</P>
<DL>
<DT>
DS_PRESENT</DT><DD>
This flag is set if the physical drive exists, regardless of whether the drive contains a disk.</DD>
<DT>
DS_MEDIA_REMOVABLE</DT><DD>
This flag is set if the disk can be removed from the drive.</DD>
<DT>
DS_NETWORK</DT><DD>
This flag is set if the drive is accessed over a network (or via network protocols), which means the drive cannot be formatted or copied.</DD>
<DT>
DS_TYPE</DT><DD>This is a mask for the lowest four bits of the field. These bits contain a member of the <CODE>
DriveType</CODE>
 enumerated type.</DD>
</DL>
<P>
If an error condition exists, <CODE>
DriveGetStatus()</CODE>
 returns zero.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_1d.htm#IX_DriveGetExtStatus()">DriveGetExtStatus()</A></CODE>.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
drive.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_1d.htm_IX_DriveTestMediaSupport()">
 </A>
<H1 CLASS="refHeading">
DriveTestMediaSupport()</H1>
<PRE CLASS="syntax">Boolean	DriveTestMediaSupport(
        word		DriveNumber,			
        MediaType		media);				/* Desired disk size */</PRE>
<P>
This routine checks whether the specified drive can support disks in the specified size. It returns <EM>
true</EM>
 (i.e., non-zero) if the drive supports the size.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_1d.htm#IX_DriveGetDefaultMedia()">DriveGetDefaultMedia()</A></CODE>.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
drive.h</STRONG>
 </P>
</DIV>
<HR>
<A NAME="R_1e.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_1e.htm_IX_EC() macro">
 </A>
<H1 CLASS="refHeading">
EC()</H1>
<PRE CLASS="syntax">void	EC(<EM>line</EM>);</PRE>
<P>
This macro defines a line of code that will only be compiled into the error-checking version of the geode. The <CODE>
line</CODE>
 parameter of the macro is the actual line of code. When the EC version of the program is compiled, the line will be treated as a normal line of code; when the non-EC version is compiled, the line will be ignored.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_74.htm#IX_NEC() macro">NEC()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_1e.htm_IX_Pointers:bounds checking">
 </A>
<A NAME="R_1e.htm_IX_EC_BOUNDS() macro">
 </A>
<H1 CLASS="refHeading">
EC_BOUNDS()</H1>
<PRE CLASS="syntax">void	EC_BOUNDS(<EM>addr</EM>);</PRE>
<P>
This macro adds an address check to the error-checking version of a program. When the EC version of the program is compiled, the address check will be included; when the non-EC version is compiled, the address check will be left out. The <CODE>
addr</CODE>
 parameter is the address or pointer to be checked.</P>
<P>
The macro expands to a call to <CODE>
<A HREF="../../CRef/Routines/R_1e.htm#IX_ECCheckBounds()">ECCheckBounds()</A></CODE>
 on the specified address or pointer. If the address is out of bounds, the program will stop with a call to <CODE>
<A HREF="../../CRef/Routines/R_24.htm#IX_FatalError()">FatalError()</A></CODE>
.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_1e.htm#IX_ECCheckBounds()">ECCheckBounds()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_1e.htm_IX_EC_ERROR() macro">
 </A>
<H1 CLASS="refHeading">
EC_ERROR()</H1>
<PRE CLASS="syntax">void	EC_ERROR(<EM>code</EM>);</PRE>
<P>
This macro inserts a call to <CODE>
<A HREF="../../CRef/Routines/R_24.htm#IX_FatalError()">FatalError()</A></CODE>
 in the error-checking version of the program and does nothing to the non-EC version. When the program gets to this point, it will halt and put up an error message corresponding to the specified error <CODE>
code</CODE>
. If a condition should be checked before calling <CODE>
<A HREF="../../CRef/Routines/R_24.htm#IX_FatalError()">FatalError()</A></CODE>
, you can use EC_ERROR_IF() instead.</P>
</DIV>
<DIV>
<A NAME="R_1e.htm_IX_EC_ERROR_IF() macro">
 </A>
<H1 CLASS="refHeading">
EC_ERROR_IF()</H1>
<PRE CLASS="syntax">void	EC_ERROR_IF(<EM>test</EM>, <EM>code</EM>);</PRE>
<P>
This macro inserts a conditional call to <CODE>
<A HREF="../../CRef/Routines/R_24.htm#IX_FatalError()">FatalError()</A></CODE>
 in the error-checking version of a program; it does nothing for the non-EC version. The <CODE>
test</CODE>
 parameter is a Boolean value that, if <CODE>
true</CODE>
, will cause the <CODE>
<A HREF="../../CRef/Routines/R_24.htm#IX_FatalError()">FatalError()</A></CODE>
 call to be made. If <CODE>
test</CODE>
 is <CODE>
false</CODE>
, <CODE>
<A HREF="../../CRef/Routines/R_24.htm#IX_FatalError()">FatalError()</A></CODE>
 will not be called.</P>
</DIV>
<DIV>
<A NAME="R_1e.htm_IX_EC_WARNING() macro">
 </A>
<H1 CLASS="refHeading">
EC_WARNING()</H1>
<PRE CLASS="syntax">EC_WARNING(word warningCode);</PRE>
<P>
This macro generates a warning for the debugger when executed by error-checking code; it has no effect when in non-EC code.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
ec.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_1e.htm_IX_EC_WARNING_IF() macro">
 </A>
<H1 CLASS="refHeading">
EC_WARNING_IF()</H1>
<PRE CLASS="syntax">EC_WARNING_IF(&lt;expr&gt;, word warningCode)</PRE>
<P>
When this macro is executed in error-checking code, it tests &lt;<EM>expr</EM>&gt;; if  &lt;<EM>expr</EM>&gt; is non-zero, it generates a warning with code <CODE>
warningCode</CODE>
 for the debugger.</P>
<P>
In non-EC code, the macro has no effect (and &lt;<EM>expr</EM>&gt; is not evaluated).</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
ec.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_1e.htm_IX_Pointers:bounds checking">
 </A>
<A NAME="R_1e.htm_IX_ECCheckBounds()">
 </A>
<H1 CLASS="refHeading">
ECCheckBounds()</H1>
<PRE CLASS="syntax">void	ECCheckBounds(
        void	*address);</PRE>
<P>
This routine checks to see if the given pointer is within bounds of the block into which it points. If assertions fail, a fatal error will occur. If the
"lmem" EC flag is turned on and the pointer points within an LMem block,
then this routine will also check that the pointer points to a valid chunk
handle or a chunk within the LMem block.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
ec.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_1e.htm_IX_Chunk arrays:checking validity">
 </A>
<A NAME="R_1e.htm_IX_ECCheckChunkArray()">
 </A>
<H1 CLASS="refHeading">
ECCheckChunkArray()</H1>
<PRE CLASS="syntax">void	ECCheckChunkArray(
        optr	o);</PRE>
<P>
This routine checks the validity of the specified chunk array. If the
assertions fail, a fatal error will occur. The block must be locked
before calling this routine.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">ec.h</STRONG>
</P>
</DIV>
<DIV>
<A NAME="R_1e.htm_IX_Chunk arrays:checking validity">
 </A>
<A NAME="R_1e.htm_IX_ECCheckChunkArrayHandles()">
 </A>
<H1 CLASS="refHeading">
ECCheckChunkArrayHandles()</H1>
<PRE CLASS="syntax">void	ECCheckChunkArrayHandles(
        MemHandle mh,
        ChunkHandle ch);</PRE>
<P>
This routine checks the validity of the specified chunk array. If the assertions fail, a fatal error will occur.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
ec.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_1e.htm_IX_Classes:checking class pointers">
 </A>
<A NAME="R_1e.htm_IX_ECCheckClass()">
 </A>
<H1 CLASS="refHeading">
ECCheckClass()</H1>
<PRE CLASS="syntax">void	ECCheckClass(
        ClassStruct *class);</PRE>
<P>
This routine checks that the given pointer actually references a class definition. If the assertions fail, a fatal error will occur.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
ec.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_1e.htm_IX_Drivers:handle checking">
 </A>
<A NAME="R_1e.htm_IX_ECCheckDriverHandle()">
 </A>
<H1 CLASS="refHeading">
ECCheckDriverHandle()</H1>
<PRE CLASS="syntax">void	ECCheckDriverHandle(
        GeodeHandle gh);</PRE>
<P>
This routine checks that the passed handle actually references a driver. If the assertions fail, a fatal error will occur.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
ec.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_1e.htm_IX_Events:handles, checking">
 </A>
<A NAME="R_1e.htm_IX_ECCheckEventHandle()">
 </A>
<H1 CLASS="refHeading">
ECCheckEventHandle()</H1>
<PRE CLASS="syntax">void	ECCheckEventHandle(
        EventHandle eh);</PRE>
<P>
This routine checks that the passed handle actually references a stored message. If the assertions fail, a fatal error will occur.</P>
</DIV>
<DIV>
<A NAME="R_1e.htm_IX_Files:handles, checking">
 </A>
<A NAME="R_1e.htm_IX_ECCheckFileHandle()">
 </A>
<H1 CLASS="refHeading">
ECCheckFileHandle()</H1>
<PRE CLASS="syntax">void	ECCheckFileHandle(
        FileHandle file);</PRE>
<P>
This routine checks that the passed handle actually is a file handle and references a file. If the assertions fail, a fatal error will occur.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
ec.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_1e.htm_IX_Geodes:handles, checking">
 </A>
<A NAME="R_1e.htm_IX_ECCheckGeodeHandle()">
 </A>
<H1 CLASS="refHeading">
ECCheckGeodeHandle()</H1>
<PRE CLASS="syntax">void	ECCheckGeodeHandle(
        GeodeHandle gh);</PRE>
<P>
This routine checks that the passed handle references a loaded geode. If the assertions fail, a fatal error will occur.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
ec.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_1e.htm_IX_GStateHandle:checking">
 </A>
<A NAME="R_1e.htm_IX_GStates:handles, checking">
 </A>
<A NAME="R_1e.htm_IX_ECCheckGStateHandle()">
 </A>
<H1 CLASS="refHeading">
ECCheckGStateHandle()</H1>
<PRE CLASS="syntax">void	ECCheckGStateHandle(
        GStateHandle gsh);</PRE>
<P>
This routine checks that the passed handle references a GState. If the assertions fail, a fatal error will occur.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
ec.h</STRONG>
 </P>
</DIV>
<HR>
<A NAME="R_1f.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_1f.htm_IX_Huge arrays:checking">
 </A>
<A NAME="R_1f.htm_IX_ECCheckHugeArray()">
 </A>
<H1 CLASS="refHeading">
ECCheckHugeArray()</H1>
<PRE CLASS="syntax">void	ECCheckHugeArray(
        VMFileHandle		vmFile,
        VMBlockHandle		vmBlock);</PRE>
<P>
This routine checks the validity of the passed Huge Array. If the block passed is not the directory block of a Huge Array, the routine fails.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
ec.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_1f.htm_IX_Libraries:handles, checking">
 </A>
<A NAME="R_1f.htm_IX_ECCheckLibraryHandle()">
 </A>
<H1 CLASS="refHeading">
ECCheckLibraryHandle()</H1>
<PRE CLASS="syntax">void	ECCheckLibraryHandle(
        GeodeHandle gh);</PRE>
<P>
This routine checks that the passed handle references a library. If the assertions fail, a fatal error will occur.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
ec.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_1f.htm_IX_Local memory:handles, checking">
 </A>
<A NAME="R_1f.htm_IX_Chunks:checking">
 </A>
<A NAME="R_1f.htm_IX_ECCheckLMemChunk()">
 </A>
<H1 CLASS="refHeading">
ECCheckLMemChunk()</H1>
<PRE CLASS="syntax">void	ECCheckLMemChunk(
        void * chunkPtr);</PRE>
<P>
This routine checks the validity of the chunk pointed to by <CODE>
chunkPtr</CODE>
. If the assertions fail, a fatal error will occur.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
ec.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_1f.htm_IX_ECCheckLMemHandle()">
 </A>
<H1 CLASS="refHeading">
ECCheckLMemHandle()</H1>
<PRE CLASS="syntax">void	ECCheckLMemHandle(
        MemHandle mh);</PRE>
<P>
This routine checks that the passed handle is a memory handle and actually references a local memory block. If the assertions fail, a fatal error will occur.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
ec.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_1f.htm_IX_ECCheckLMemHandleNS()">
 </A>
<H1 CLASS="refHeading">
ECCheckLMemHandleNS()</H1>
<PRE CLASS="syntax">void	ECCheckLMemHandleNS(
        MemHandle mh);</PRE>
<P>
This routine checks that the passed handle is a local memory handle; unlike <CODE>
<A HREF="../../CRef/Routines/R_1f.htm#IX_ECCheckLMemHandle()">ECCheckLMemHandle()</A></CODE>
, however, it does not check sharing violations (when threads are illegally using non-sharable memory). If the assertions fail, a fatal error will occur.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
ec.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_1f.htm_IX_optr:checking">
 </A>
<A NAME="R_1f.htm_IX_Objects:address checking">
 </A>
<A NAME="R_1f.htm_IX_ECCheckLMemObject()">
 </A>
<H1 CLASS="refHeading">
ECCheckLMemObject()</H1>
<PRE CLASS="syntax">void	ECCheckLMemObject(
        optr	obj); 		/* Object must be locked down. */</PRE>
<P>
This routine checks the validity of an object to ensure that it is an object stored in an object block. If the assertions fail, a fatal error will occur.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
ec.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_1f.htm_IX_ECCheckLMemObjectHandles()">
 </A>
<H1 CLASS="refHeading">
ECCheckLMemObjectHandles()</H1>
<PRE CLASS="syntax">void	ECCheckLMemObjectHandles(
        MemHandle mh,
        ChunkHandle ch);</PRE>
<P>
This routine checks the validity of an object to ensure that it is an object stored in an object block. If the assertions fail, a fatal error will occur.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
ec.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_1f.htm_IX_ECCheckLMemOD()">
 </A>
<H1 CLASS="refHeading">
ECCheckLMemOD()</H1>
<PRE CLASS="syntax">void	ECCheckLMemOD(
        optr	o);</PRE>
<P>
This routine checks the validity of the given local-memory-based object. If assertions fail, a fatal error will occur.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
ec.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_1f.htm_IX_ECCheckLMemODHandles()">
 </A>
<H1 CLASS="refHeading">
ECCheckLMemODHandles()</H1>
<PRE CLASS="syntax">void	ECCheckLMemODHandles(
        MemHandle objHan,
        ChunkHandle objCh);</PRE>
<P>
This routine checks the validity of the given local-memory-based object. If assertions fail, a fatal error will occur.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
ec.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_1f.htm_IX_Heap:checking memory handles">
 </A>
<A NAME="R_1f.htm_IX_ECCheckMemHandle()">
 </A>
<H1 CLASS="refHeading">
ECCheckMemHandle()</H1>
<PRE CLASS="syntax">void	ECCheckMemHandle(
        MemHandle mh);</PRE>
<P>
This routine checks that the passed handle is a memory handle that references a memory block. If the assertions fail, a fatal error will occur.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
ec.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_1f.htm_IX_ECCheckHandleNS()">
 </A>
<H1 CLASS="refHeading">
ECCheckMemHandleNS()</H1>
<PRE CLASS="syntax">void	ECCheckMemHandleNS(
        MemHandle mh);</PRE>
<P>
This routine checks that the passed handle references a memory block; unlike <CODE>
<A HREF="../../CRef/Routines/R_1f.htm#IX_ECCheckMemHandle()">ECCheckMemHandle()</A></CODE>
, however, it will not check for sharing violations (when a thread illegally accesses a non-sharable block). If the assertions fail, a fatal error will occur.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
ec.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_1f.htm_IX_ECCheckObject()">
 </A>
<H1 CLASS="refHeading">
ECCheckObject()</H1>
<PRE CLASS="syntax">void	ECCheckObject(
        optr	obj);</PRE>
<P>
This routine checks the validity of the given locked object. If the assertions fail, a fatal error will occur.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
ec.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_1f.htm_IX_ECCheckObjectHandles()">
 </A>
<H1 CLASS="refHeading">
ECCheckObjectHandles()</H1>
<PRE CLASS="syntax">void	ECCheckObjectHandles(
        Memhandle mh,
        ChunkHandle ch);</PRE>
<P>
This routine checks the validity of the given locked object. If the assertions fail, a fatal error will occur.</P>
</DIV>
<DIV>
<A NAME="R_1f.htm_IX_Process object:checking">
 </A>
<A NAME="R_1f.htm_IX_ECCheckOD()">
 </A>
<H1 CLASS="refHeading">
ECCheckOD()</H1>
<PRE CLASS="syntax">void	ECCheckOD(
        optr	obj);</PRE>
<P>
This routine checks the validity of the given object. Unlike <CODE>
<A HREF="../../CRef/Routines/R_1f.htm#IX_ECCheckLMemObject()">ECCheckLMemObject()</A></CODE>
, however, it allows optrs of Process objects to be specified. If assertions fail, a fatal error will occur.</P>
</DIV>
<DIV>
<A NAME="R_1f.htm_IX_ECCheckODHandles()">
 </A>
<H1 CLASS="refHeading">
ECCheckODHandles()</H1>
<PRE CLASS="syntax">void	ECCheckODHandles(
        MemHandle objHan,
        ChunkHandle objCh);</PRE>
<P>
This routine checks the validity of the given object. Unlike <CODE>
<A HREF="../../CRef/Routines/R_1f.htm#IX_ECCheckLMemObjectHandles()">ECCheckLMemObjectHandles()</A></CODE>
, however, it allows processes to be specified. If assertions fail, a fatal error will occur.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
ec.h</STRONG>
 </P>
</DIV>
<HR>
<A NAME="R_20.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_20.htm_IX_Process object:checking">
 </A>
<A NAME="R_20.htm_IX_ECCheckProcessHandle()">
 </A>
<H1 CLASS="refHeading">
ECCheckProcessHandle()</H1>
<PRE CLASS="syntax">void	ECCheckProcessHandle(
        GeodeHandle gh);</PRE>
<P>
This routine checks that the passed handle actually references a process. If the assertions fail, a fatal error will occur.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
ec.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_20.htm_IX_Event queues:handles, checking">
 </A>
<A NAME="R_20.htm_IX_ECCheckQueueHandle()">
 </A>
<H1 CLASS="refHeading">
ECCheckQueueHandle()</H1>
<PRE CLASS="syntax">void	ECCheckQueueHandle(
        QueueHandle qh);</PRE>
<P>
This routine ensures the passed handle references an event queue. If the assertions fail, a fatal error will occur.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
ec.h</STRONG>
</P>
</DIV>
<DIV>
<A NAME="R_20.htm_IX_Resources:handles, checking">
 </A>
<A NAME="R_20.htm_IX_ECCheckResourceHandle()">
 </A>
<H1 CLASS="refHeading">
ECCheckResourceHandle()</H1>
<PRE CLASS="syntax">void	ECCheckResourceHandle(
        MemHandle mh);</PRE>
<P>
This routine ensures that the passed handle references a geode resource. If the assertions fail, a fatal error will occur.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
ec.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_20.htm_IX_Stack:checking">
 </A>
<A NAME="R_20.htm_IX_ECCheckStack()">
 </A>
<H1 CLASS="refHeading">
ECCheckStack()</H1>
<PRE CLASS="syntax">void	ECCheckStack();</PRE>
<P>
This routine checks to make sure the current stack has not overflown (and is not about to). This routine also enforces a 100-byte gap between the stack bottom and the stack pointer. If assertions fail, a fatal error will occur.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
ec.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_20.htm_IX_Threads:handles, checking">
 </A>
<A NAME="R_20.htm_IX_ECCheckThreadHandles()">
 </A>
<H1 CLASS="refHeading">
ECCheckThreadHandle()</H1>
<PRE CLASS="syntax">void	ECCheckThreadHandle(
        ThreadHandle th);</PRE>
<P>
This routine checks that the passed handle actually references a thread. If the assertions fail, a fatal error will occur.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
ec.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_20.htm_IX_Windows:handles,checking">
 </A>
<A NAME="R_20.htm_IX_ECCheckWindowHandle()">
 </A>
<H1 CLASS="refHeading">
ECCheckWindowHandle()</H1>
<PRE CLASS="syntax">void	ECCheckWindowHandle(
        WindowHandle wh);</PRE>
<P>
This routine checks that the passed handle actually references a window. If the assertions fail, a fatal error will occur.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
ec.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_20.htm_IX_Local memory:handles, checking">
 </A>
<A NAME="R_20.htm_IX_Chunks:checking">
 </A>
<A NAME="R_20.htm_IX_ECLMemExists()">
 </A>
<H1 CLASS="refHeading">
ECLMemExists()</H1>
<PRE CLASS="syntax">void	ECLMemExists(
        optr	o);</PRE>
<P>
This routine checks to see if the specified chunk exists. This routine should be called by applications to check the chunk handle's validity. If the assertions fail, a fatal error will occur.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
ec.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_20.htm_IX_ECLMemExistsHandles()">
 </A>
<H1 CLASS="refHeading">
ECLMemExistsHandles()</H1>
<PRE CLASS="syntax">void	ECLMemExistsHandles(
        MemHandle mh,
        ChunkHandle ch);</PRE>
<P>
This routine checks to see if the specified chunk exists. This routine should be called by applications to check the chunk handle's validity. If the assertions fail, a fatal error will occur.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
ec.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_20.htm_IX_ECLMemValidateHandle()">
 </A>
<H1 CLASS="refHeading">
ECLMemValidateHandle()</H1>
<PRE CLASS="syntax">void	ECLMemValidateHandle(
        optr	o);</PRE>
<P>
This routine checks that the passed optr points to a local memory chunk. If the assertions fail, a fatal error will occur.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
ec.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_20.htm_IX_ECLMemValidateHandleHandles()">
 </A>
<H1 CLASS="refHeading">
ECLMemValidateHandleHandles()</H1>
<PRE CLASS="syntax">void	ECLMemValidateHandleHandles(
        MemHandle mh,
        ChunkHandle ch);</PRE>
<P>
This routine checks that the passed memory and chunk handles actually reference a local memory chunk. If the assertions fail, a fatal error will occur.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
ec.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_20.htm_IX_ECLMemValidateHeap()">
 </A>
<H1 CLASS="refHeading">
ECLMemValidateHeap()</H1>
<PRE CLASS="syntax">void	ECLMemValidateHeap(
        MemHandle mh);</PRE>
<P>
This routine does a complete error-check of the LMem heap. It is used internally and should not be needed by application programmers.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
ec.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_20.htm_IX_ECMemVerifyHeap()">
 </A>
<H1 CLASS="refHeading">
ECMemVerifyHeap()</H1>
<PRE CLASS="syntax">void	ECMemVerifyHeap()</PRE>
<P>
This routine makes sure the global heap is in a consistent state. If the assertions fail, a fatal error will occur. This routine should likely not be called by anything other than the EC kernel.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
ec.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_20.htm_IX_Virtual memory:handles, checking">
 </A>
<A NAME="R_20.htm_IX_ECVMCheckMemHandle()">
 </A>
<H1 CLASS="refHeading">
ECVMCheckMemHandle()</H1>
<PRE CLASS="syntax">void	ECVMCheckMemHandle(
        MemHandle han);</PRE>
<P>
This routine checks that the given memory handle is actually linked to a VM block handle. If assertions fail, a fatal error will occur.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
ec.h</STRONG>
</P>
</DIV>
<HR>
<A NAME="R_21.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_21.htm_IX_Virtual memory:handles, checking">
 </A>
<A NAME="R_21.htm_IX_ECVMCheckVMBlockHandle()">
 </A>
<H1 CLASS="refHeading">
ECVMCheckVMBlockHandle()</H1>
<PRE CLASS="syntax">void	ECVMCheckVMBlockHandle(
        VMFileHandle file,
        VMBlockHandle block);</PRE>
<P>
This routine checks the validity of the given VM file and block handles. If assertions fail, a fatal error will occur.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
ec.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_21.htm_IX_ECVMCheckVMFile()">
 </A>
<H1 CLASS="refHeading">
ECVMCheckVMFile()</H1>
<PRE CLASS="syntax">void	ECVMCheckVMFile(
        VMFileHandle file);</PRE>
<P>
This routine checks the validity of the given VM file handle. If assertions fail, a fatal error will occur.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
ec.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_21.htm_IX_ElementArrayAddElement()">
 </A>
<H1 CLASS="refHeading">
ElementArrayAddElement ()</H1>
<PRE CLASS="syntax">word	ElementArrayAddElement(
        optr	arr,		/* Handle of element array */
        void *	element,		/* Element to add (if necessary) */
        dword	callBackData,		/* This is passed to the Callback routine */
        Boolean _pascal (*callback) (void *elementToAdd, 
			void *elementFromArray, 			dword valueForCallback));</PRE>
<P>
This routine is used to add elements to an array. It is passed the address of a potential element. It compares the element with each member of an element array. If there are no matches, it adds the element to the array and sets the reference count to one. If there is a match, it increments the reference count of the matching element in the array and returns; it does not add the new element. When you pass the address of an element, make sure you pass the address of the data portion of the element (not the reference-count header).</P>
<P>
You can pass a callback routine to <CODE>
<A HREF="../../CRef/Routines/R_21.htm#IX_ElementArrayAddElement()">ElementArrayAddElement()</A></CODE>
. <CODE>
<A HREF="../../CRef/Routines/R_21.htm#IX_ElementArrayAddElement()">ElementArrayAddElement()</A></CODE>
 will call the callback routine to compare elements and see if they match. The callback routine should be declared _pascal. <CODE>
<A HREF="../../CRef/Routines/R_21.htm#IX_ElementArrayAddElement()">ElementArrayAddElement()</A></CODE>
 passes the callback routine the address of the element you passed it, as well as the address of the data-portion of the element in the array (the part after the <CODE>
RefElementHeader</CODE>
 structure). If the two elements match (by whatever criteria you use), return <CODE>
true</CODE>
; otherwise, return <CODE>
false</CODE>
. If you pass a null function pointer, the default comparison routine will be called, which checks to see if every data byte matches.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
chunkarr.h</STRONG>
 </P>
<P CLASS="refField"><STRONG>
Tips and Tricks:</STRONG>	If you know the element is already in the array, you can increment its reference count by calling <CODE>
<A HREF="../../CRef/Routines/R_21.htm#IX_ElementArrayAddReference()">ElementArrayAddReference()</A></CODE>
.</P>
<P CLASS="refField"><STRONG>
Be Sure To:</STRONG>	Lock the block on the global heap before calling (unless it is fixed).</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_21.htm#IX_ElementArrayAddReference()">ElementArrayAddReference()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_21.htm_IX_ElementArrayAddElementHandles()">
 </A>
<H1 CLASS="refHeading">
ElementArrayAddElementHandles()</H1>
<PRE CLASS="syntax">word	ElementArrayAddElementHandles(
        MemHandle		mh,				/* Global handle of LMem heap */
        ChunkHandle		chunk				/* Chunk handle of element array */
        void *		element,				/* Element to add */
        dword		callBackData,		/* Passed to the Callback routine */
        Boolean _pascal (*callback) (void *elementToAdd, 
			void *elementFromArray, 			dword valueForCallback));</PRE>
<P>
This routine is exactly like <CODE>
<A HREF="../../CRef/Routines/R_21.htm#IX_ElementArrayAddElement()">ElementArrayAddElement()</A></CODE>
 above, except that the element array is specified by its global and chunk handles (instead of with an optr).</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
chunkarr.h</STRONG>
 </P>
<P CLASS="refField"><STRONG>
Tips and Tricks:</STRONG>	If you know the element is already in the array, you can increment its reference count by calling <CODE>
<A HREF="../../CRef/Routines/R_21.htm#IX_ElementArrayAddReference()">ElementArrayAddReference()</A></CODE>
.</P>
<P CLASS="refField"><STRONG>
Be Sure To:</STRONG>	Lock the block on the global heap before calling (unless it is fixed).</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_21.htm#IX_ElementArrayAddReference()">ElementArrayAddReference()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_21.htm_IX_ElementArrayAddReference()">
 </A>
<H1 CLASS="refHeading">
ElementArrayAddReference()</H1>
<PRE CLASS="syntax">void	ElementArrayAddReference(
        optr	arr,				/* optr to element array */
        word	token);				/* Index number of element */</PRE>
<P>
This routine increments the reference count of a member of an element array. </P>
<P CLASS="refField"><STRONG>
Be Sure To:</STRONG>	Lock the block on the global heap before calling (unless it is fixed).</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_21.htm#IX_ElementArrayAddElement()">ElementArrayAddElement()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_21.htm_IX_ElementArrayAddReferenceHandles()">
 </A>
<H1 CLASS="refHeading">
ElementArrayAddReferenceHandles()</H1>
<PRE CLASS="syntax">void	ElementArrayAddReferenceHandles(
        MemHandle		mh,				/* Handle of LMem heap's block */
        ChunkHandle		ch,				/* Handle of element array */
        word		token);				/* Index number of element */</PRE>
<P>
This routine is exactly like <CODE>
<A HREF="../../CRef/Routines/R_21.htm#IX_ElementArrayAddReference()">ElementArrayAddReference()</A></CODE>
 above, except that the element array is specified by its global and chunk handles (instead of with an optr).</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
chunkarr.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_21.htm_IX_ElementArrayCreate()">
 </A>
<H1 CLASS="refHeading">
ElementArrayCreate()</H1>
<PRE CLASS="syntax">ChunkHandle ElementArrayCreate(
        MemHandle		mh,				/* Handle of LMem heap's block */
        word		elementSize,				/* Size of each element, or zero
							 * for variable-sized */</PRE>
<PRE CLASS="syntax">        word		headerSize);				/* Header size (zero for default) */</PRE>
<P>
This routine creates an element array in the indicated LMem heap. It creates an <CODE>
ElementArrayHeader</CODE>
 structure at the head of the chunk. If you want to leave extra space before the start of the array, you can pass a larger header size; if you want to use the standard header, pass a header size of zero.</P>
<P>
You can specify the size of each element. Remember that the first three bytes of every element in an element array are the element's <CODE>
RefElementHeader</CODE>
; structure, which contains the reference count; leave room for this when you choose a size. For arrays with variable-sized elements, pass a size of zero.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
chunkarr.h</STRONG>
 </P>
<P CLASS="refField"><STRONG>
Tips and Tricks:</STRONG>	You may want to declare a structure for array elements; the first component should be a <CODE>
RefElementHeader</CODE>
. You can pass the size of this structure to <CODE>
ElementArrayCreate()</CODE>
.</P>
<P>
If you want extra space after the <CODE>
ElementArrayHeader</CODE>
, you may want to create your own header structure, the first element of which is an <CODE>
ElementArrayHeader</CODE>
. You can pass the size of this header to <CODE>
ElementArrayCreate()</CODE>
, and access the data in your header via the structure.</P>
<P CLASS="refField"><STRONG>
Be Sure To:</STRONG>	Lock the block on the global heap before calling this routine (unless it is fixed). If you pass a header size, make sure it is larger than <CODE>
sizeof(ElementArrayHeader)</CODE>
.</P>
</DIV>
<DIV>
<A NAME="R_21.htm_IX_ElementArrayCreateAt()">
 </A>
<H1 CLASS="refHeading">
ElementArrayCreateAt()</H1>
<PRE CLASS="syntax">ChunkHandle 	ElementArrayCreateAt(
        optr	arr,				/* optr of chunk for array */
        word	elementSize,				/* Size of each element, or zero
						 * for variable-sized */</PRE>
<PRE CLASS="syntax">        word	headerSize);				/* Header size (zero for default) */</PRE>
<P>
This routine is just like <CODE>
<A HREF="../../CRef/Routines/R_21.htm#IX_ElementArrayCreate()">ElementArrayCreate()</A></CODE>
 above, except that the element array is created in a pre-existing chunk. The contents of that chunk will be overwritten.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
chunkarr.h</STRONG>
 </P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	If the chunk isn't large enough, it will be resized. This will invalidate all pointers to chunks in that block.</P>
</DIV>
<DIV>
<A NAME="R_21.htm_IX_ElementArrayCreateAtHandles()">
 </A>
<H1 CLASS="refHeading">
ElementArrayCreateAtHandles()</H1>
<PRE CLASS="syntax">ChunkHandle 	ElementArrayCreateAtHandles(
        MemHandle		mh,				/* Handle of LMem heap */
        ChunkHandle		ch				/* Create array in this chunk */
        word		elementSize,				/* Size of each element, or zero
						 * for variable-sized */</PRE>
<PRE CLASS="syntax">        word		headerSize);				/* Header size (zero for default) */</PRE>
<P>
This routine is exactly like <CODE>
<A HREF="../../CRef/Routines/R_21.htm#IX_ElementArrayCreateAt()">ElementArrayCreateAt()</A></CODE>
 above, except that the element array is specified by its global and chunk handles (instead of with an optr).</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
chunkarr.h</STRONG>
 </P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	If the chunk isn't large enough, it will be resized. This will invalidate all pointers to chunks in that block.</P>
</DIV>
<HR>
<A NAME="R_22.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_22.htm_IX_ElementArrayDelete()">
 </A>
<H1 CLASS="refHeading">
ElementArrayDelete()</H1>
<PRE CLASS="syntax">void	ElementArrayDelete(
        optr	arr,					/* optr to element array */
        word	token);					/* index of element to delete */</PRE>
<P>
This routine deletes an element from an element array regardless of its reference count. The routine is passed the element array's optr and the token for the element to delete.</P>
<P>
Note that when an element is removed, it is actually resized down to zero size and added to a list of free elements. That way the index numbers of later elements are preserved.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
chunkarr.h</STRONG>
 </P>
<P CLASS="refField"><STRONG>
Be Sure To:</STRONG>	Lock the block on the global heap before calling (unless it is fixed).</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_23.htm#IX_ElementArrayRemoveReference()">ElementArrayRemoveReference()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_22.htm_IX_ElementArrayDeleteHandles()">
 </A>
<H1 CLASS="refHeading">
ElementArrayDeleteHandles()</H1>
<PRE CLASS="syntax">void	ElementArrayDeleteHandles(
        MemHandle		mh,				/* Handle of LMem heap */
        ChunkHandle		ch,				/* Chunk handle of element array */
        word		token);				/* Index of element delete */</PRE>
<P>
This routine is exactly like <CODE>
<A HREF="../../CRef/Routines/R_22.htm#IX_ElementArrayDelete()">ElementArrayDelete()</A></CODE>
 above, except that the element array is specified by its global and chunk handles (instead of with an optr).</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
chunkarr.h</STRONG>
 </P>
<P CLASS="refField"><STRONG>
Be Sure To:</STRONG>	Lock the block on the global heap before calling (unless it is fixed).</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_23.htm#IX_ElementArrayRemoveReference()">ElementArrayRemoveReference()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_22.htm_IX_ElementArrayElementChanged()">
 </A>
<H1 CLASS="refHeading">
ElementArrayElementChanged()</H1>
<PRE CLASS="syntax">void	ElementArrayElementChanged(
        optr	arr,				/* optr to element array */
        word	token,				/* Index number of element */
        dword	callbackData,				/* This is passed along to callback */
        Boolean _pascal (*callback)			/* Returns true if elements identical */
        		(void *			elementChanged,
        		 void *			elementToCompare,
        		 dword			valueForCallback));</PRE>
<P>
This routine checks to see if an element is identical to any other elements in the same element array. This is used after an element has changed to see if it now matches another element. If the element matches another, it will be deleted, and the other element will have its reference count incremented.</P>
<P>
The routine is passed an optr to the element array, the token of the element which is being checked, a dword of data (which is passed to the callback routine), and a pointer to a callback comparison routine. The callback routine itself is passed pointers to two elements and the <EM>
callbackData</EM>
 argument passed to <CODE>
ElementArrayElementChanged()</CODE>
. The callback routine should be declared _pascal. If the two elements are identical, the callback should return <EM>
true</EM>
 (i.e. non-zero); otherwise, it should return <EM>
false</EM>
.</P>
<P>
If you pass a null function pointer, <CODE>
ElementArrayElementChanged()</CODE>
 will do a bytewise comparison of the elements.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
chunkarr.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_22.htm_IX_ElementArrayElementChangedHandles()">
 </A>
<H1 CLASS="refHeading">
ElementArrayElementChangedHandles()</H1>
<PRE CLASS="syntax">void	ElementArrayElementChangedHandles(
        MemHandle		memHandle,				/* Handle of LMem heap's block */
        ChunkHandle		chunkHandle,				/* Chunk handle of element array */
        word		token,				/* Index number of element */
        dword		callbackData,					/* This is passed along to
							 * callback */</PRE>
<PRE CLASS="syntax">        Boolean _pascal (*callback)			/* Returns true if elements identical */
        		(void *			elementChanged,
        		 void *			elementToCompare,
        		 dword			valueForCallback));</PRE>
<P>
This routine is exactly like <CODE>
<A HREF="../../CRef/Routines/R_22.htm#IX_ElementArrayElementChanged()">ElementArrayElementChanged()</A></CODE>
 above, except that the element array is specified by its global and chunk handles (instead of with an optr).</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
chunkarr.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_22.htm_IX_ElementArrayGetUsedCount()">
 </A>
<H1 CLASS="refHeading">
ElementArrayGetUsedCount()</H1>
<PRE CLASS="syntax">word	ElementArrayGetUsedCount(
        optr	arr,			/* optr to element array */
        dword	callbackData,			/* This is passed to callback routine */
        Boolean _pascal (*callback)				/* return true to count this element */
        		(void * element, dword cbData));</PRE>
<P>
This routine counts the number of active elements in an element array; that is, elements which have a reference count of one or greater. It can be instructed to count every element, or every element which matches certain criteria. The routine is passed three parameters: the optr of the chunk array, a dword which is passed to the callback routine, and a callback routine which determines whether the element should be counted. The callback routine,which should be declared _pascal, is passed the dword an a pointer to an element. It should return <EM>
true</EM>
 if the element should be counted; otherwise, it should return <EM>
false</EM>
. To count every element, pass a null callback pointer.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
chunkarr.h</STRONG>
 </P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_23.htm#IX_ElementArrayTokenToUsedIndex()">ElementArrayTokenToUsedIndex()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_23.htm#IX_ElementArrayUsedIndexToToken()">ElementArrayUsedIndexToToken()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_22.htm_IX_ElementArrayGetUsedCountHandles()">
 </A>
<H1 CLASS="refHeading">
ElementArrayGetUsedCountHandles()</H1>
<PRE CLASS="syntax">void	ElementArrayGetUsedCountHandles(
        MemHandle 		mh,			/* Handle of LMem heap's block */
        ChunkHandle		ch,			/* Chunk handle of element array */
        dword	callbackData,			/* This is passed to callback routine */
        Boolean _pascal (*callback)				/* return true to count this element */
        		(void * element, dword cbData));</PRE>
<P>
This routine is exactly like <CODE>
<A HREF="../../CRef/Routines/R_22.htm#IX_ElementArrayGetUsedCount()">ElementArrayGetUsedCount()</A></CODE>
 above, except that the element array is specified by its global and chunk handles (instead of with an optr).</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
chunkarr.h</STRONG>
 </P>
</DIV>
<HR>
<A NAME="R_23.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_23.htm_IX_ElementArrayRemoveReference()">
 </A>
<H1 CLASS="refHeading">
ElementArrayRemoveReference()</H1>
<PRE CLASS="syntax">void	ElementArrayRemoveReference(
        optr		arr,				/* optr of element array */
        word		token,				/* Index of element to 
						 * unreference */</PRE>
<PRE CLASS="syntax">        dword		callbackData,				/* Passed to callback routine */
        void _pascal (*callback)		(void *element, dword valueForCallback));
/* Routine is called if element is actually removed */</PRE>
<P>
This routine decrements the reference count of the specified element. If the reference count drops to zero, the element will be removed. If an element is to be removed, <CODE>
ElementArrayRemoveReference()</CODE>
 calls the callback routine on that element. The callback routine should perform any cleanup necessary; it is passed a pointer to the element and the <CODE>
callbackData</CODE>
 argument. If you pass a null function pointer, no callback routine will be called.</P>
<P>
Note that when an element is removed, it is actually resized down to zero size and added to a list of free elements. That way the index numbers of later elements are preserved.</P>
<P CLASS="refField"><STRONG>
Be Sure To:</STRONG>	Lock the block on the global heap before calling (unless it is fixed).</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_22.htm#IX_ElementArrayDelete()">ElementArrayDelete()</A></CODE>.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
chunkarr.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_23.htm_IX_ElementArrayRemoveReferenceHandles()">
 </A>
<H1 CLASS="refHeading">
ElementArrayRemoveReferenceHandles()</H1>
<PRE CLASS="syntax">void	ElementArrayRemoveReferenceHandles(
        MemHandle		mh,			/* Handle of LMem heap */
        ChunkHandle		ch,			/* Chunk handle of element array */
        word		token,			/* Index of element to unreference */
        dword		callbackData,				/* Passed to callback routine */
        void _pascal (*callback)		(void *element, dword valueForCallback));
/* Routine is called if element is actually removed */</PRE>
<P>
This routine is exactly like <CODE>
<A HREF="../../CRef/Routines/R_23.htm#IX_ElementArrayRemoveReference()">ElementArrayRemoveReference()</A></CODE>
 above, except that the element array is specified by its global and chunk handles (instead of with an optr).</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
chunkarr.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_23.htm_IX_ElementArrayTokenToUsedIndex()">
 </A>
<H1 CLASS="refHeading">
ElementArrayTokenToUsedIndex()</H1>
<PRE CLASS="syntax">word	ElementArrayTokenToUsedIndex(
        optr	arr,	/* Handle of element array */
        word	token,	/* Index of element to unreference */
        dword	callbackData,	/* Data passed to callback routine */
        Boolean 	_pascal (*callback)	/* Return true to count this element */
        	    (void *element, dword cbData));</PRE>
<P>
This routine is passed the token of an element array. It translates the token into an index from some non-standard indexing scheme. The indexing scheme can either number the elements from zero, counting only those elements in use (i.e. those with a reference count greater than zero); or it can use a more restrictive scheme. If a callback routine is passed, the callback routine will be called for every used element; it should be declared _pascal and return <EM>
true</EM>
 if the element should be counted. If a null callback pointer is passed, every used element will be counted.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
chunkarr.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_23.htm_IX_ElementArrayTokenToUsedIndexHandles()">
 </A>
<H1 CLASS="refHeading">
ElementArrayTokenToUsedIndexHandles()</H1>
<PRE CLASS="syntax">word	ElementArrayTokenToUsedIndexHandles(
        MemHandle 		mh,		/* Handle of LMem heap */
        ChunkHandle 		ch,		/* Chunk handle of element array */
        word		token,		/* Index of element to unreference */
        dword		callbackData, /* Data passed to the
						 * callback routine */</PRE>
<PRE CLASS="syntax">        Boolean 	_pascal (*callback)	/* Return true to count this element */
        		(void *element, dword cbData));</PRE>
<P>
This routine is exactly like <CODE>
<A HREF="../../CRef/Routines/R_23.htm#IX_ElementArrayTokenToUsedIndex()">ElementArrayTokenToUsedIndex()</A></CODE>
 above, except that the element array is specified by its global and chunk handles (instead of with an optr).</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
chunkarr.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_23.htm_IX_ElementArrayUsedIndexToToken()">
 </A>
<H1 CLASS="refHeading">
ElementArrayUsedIndexToToken()</H1>
<PRE CLASS="syntax">word	ElementArrayUsedIndexToToken(
        optr	arr,		/* optr to element array */
        word	index,		/* Find token of element with this index */
        dword	callbackData,		/* This is passed to the callback routine */
        Boolean _pascal (*callback)			/* Return true to count this element */
        		(void *element, dword cbData));</PRE>
<P>
This routine takes an index into an element array from some non-standard indexing scheme. The routine finds the element specified and returns the element's token. The indexing scheme can either number the elements from zero, counting only those elements in use (i.e. those with a reference count greater than zero); or it can use a more restrictive scheme. If a callback routine is passed, the callback routine will be called for every used element; it should should be declared _pascal return <EM>
true</EM>
 if the element should be counted. If a null callback pointer is passed, every used element will be counted.</P>
<P>
If no matching element is found, <CODE>
ElementArrayUsedIndexToToken()</CODE>
 returns CA_NULL_ELEMENT.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
chunkarr.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_23.htm_IX_ElementArrayUsedIndexToTokenHandles()">
 </A>
<H1 CLASS="refHeading">
ElementArrayUsedIndexToTokenHandles()</H1>
<PRE CLASS="syntax">word	ElementArrayUsedIndexToTokenHandles(
        MemHandle 		mh,		/* Handle of LMem heap's block */
        ChunkHandle 		ch,		/* Handle of element array */
        word		index,		/* Find token of element with this index */
        dword		callbackData, /* Data passed to the
	 						  * callback routine */</PRE>
<PRE CLASS="syntax">        Boolean 	_pascal (*callback)	/* Return true to count this element */
        	    (void *element, dword cbData));</PRE>
<P>
This routine is exactly like <CODE>
<A HREF="../../CRef/Routines/R_23.htm#IX_ElementArrayUsedIndexToToken()">ElementArrayUsedIndexToToken()</A></CODE>
 above, except that the element array is specified by its global and chunk handles (instead of with an optr).</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
chunkarr.h</STRONG>
 </P>
</DIV>
<HR>
<A NAME="R_24.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_24.htm_IX_FatalError()">
 </A>
<H1 CLASS="refHeading">
FatalError()</H1>
<PRE CLASS="syntax">void	FatalError(
        word errorCode);</PRE>
<P>
This routine causes a fatal error, leaving <CODE>
errorCode</CODE>
 for the debugger. </P>
</DIV>
<DIV>
<A NAME="R_24.htm_IX_FileClose()">
 </A>
<H1 CLASS="refHeading">
FileClose()</H1>
<PRE CLASS="syntax">word 	FileClose( /* returns error */
        FileHandle		fh,					/* File to close */
        Boolean		noErrorFlag);					/* Set if app. can't handle
								 * errors */</PRE>
<P>
This routine closes an open byte file. If the routine succeeds, it returns zero. If the routine fails and <EM>
noErrorFlag</EM>
 is <EM>
false</EM>
 (i.e., zero), <CODE>
FileClose()</CODE>
 returns a member of the <CODE>
FileError</CODE>
 enumerated type. If the routine fails and <EM>
noErrorFlag</EM>
 is <EM>
true</EM>
 (i.e., non-zero), the routine will fatal-error.</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	The <CODE>
noErrorFlag</CODE>
 parameter should be <CODE>
true</CODE>
 only during debugging.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
file.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_24.htm_IX_FileCommit()">
 </A>
<H1 CLASS="refHeading">
FileCommit()</H1>
<PRE CLASS="syntax">word	FileCommit( /* returns error */
        FileHandle		fh,
        Boolean		noErrorFlag);				/* set if can't handle errors */</PRE>
<P>
<CODE>
FileCommit()</CODE>
 forces the file system to write any cached information about a file to the disk immediately. If it is successful, it returns zero. If it fails, it returns an error code. If the routine fails and <EM>
noErrorFlag</EM>
 is <EM>
true</EM>
 (i.e. non-zero), the routine will fatal-error.</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	The <CODE>
noErrorFlag</CODE>
 parameter should be <CODE>
true</CODE>
 only during debugging.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
file.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_24.htm_IX_FileConstructFullPath()">
 </A>
<H1 CLASS="refHeading">
FileConstructFullPath()</H1>
<PRE CLASS="syntax">DiskHandle 	FileConstructFullPath(
        char		* * buffer,				/* Path string is written here */
        word		bufSize,			/* Length of buffer (in bytes) */
        DiskHandle		disk,			/* Disk or standard path; null for 
						 * current path */</PRE>
<PRE CLASS="syntax">        const char		* tail,			/* Path relative to handle */
        Boolean		addDriveLetter);					/* Should path begin with drive
								 * name? */</PRE>
<P>
This routine translates a GEOS directory specification into a complete path string. It writes the string into the passed buffer. The directory is specified by two arguments: The first, <CODE>
disk</CODE>
, is the handle of a disk; this may also be a standard path constant. (If a null handle is passed, the current working directory is used.) The second, <CODE>
tail</CODE>
, is a pointer to the character string representing the tail end of the path. <CODE>
FileConstructFullPath()</CODE>
 appends this relative path to the location indicated by the disk handle. It then constructs a full path string, beginning with that disk's root directory, and writes it to the buffer passed. If <EM>
addDriveName</EM>
 is <EM>
true</EM>
 (i.e. non-zero), the path string will begin with the drive's name and a colon. The pointer pointed to by <EM>
buffer</EM>
 will be updated to point to the end of the constructed string.</P>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	The following call to <CODE>
FileConstructFullPath()</CODE>
 might yield these results:</P>
<P CLASS="figTitle">
Sample call to FileConstructFullPath()</P>
<PRE>/* Here we find out the full path of a subdirectory of the DOCUMENT directory */</PRE>
<PRE>	DiskHandle		documentDisk;
	char		pathBuffer[256];			/* long enough for most paths */
	char		*pB = &amp;pathBuffer;</PRE>
<PRE>	documentDisk = FileConstructFullPath(&amp;pB,						/* pointer to pointer */
					256, 		/* Length of buffer */
					SP_DOCUMENT,		/* This can be a disk or 
							 * standard path */
					&quot;MEMOS\\JANUARY&quot;, /* In C strings, the
							 * backslash must be
							 * doubled */
					TRUE);		/* Prepend drive name */</PRE>
<PRE>/* If the standard paths are set up in the default configuration, &quot;documentDisk&quot;
 * would be the handle of the main hard drive, and pathBuffer would contain a
 * string like &quot;C:\GEOWORKS\DOCUMENT\MEMOS\JANUARY&quot; */</PRE>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_2a.htm#IX_FileParseStandardPath()">FileParseStandardPath()</A></CODE>.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
file.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_24.htm_IX_FileCopy()">
 </A>
<H1 CLASS="refHeading">
FileCopy()</H1>
<PRE CLASS="syntax">word	FileCopy( /* returns error */
        const char		* source,				/* Source path and file name */
        const char		* dest,				/* Destination path and file name */
        DiskHandle		sourceDisk,				/* These handles may be Standard */
        DiskHandle		destDisk);				/* Path constants, or null to indi- 
						 * cate current working directory */</PRE>
<P>
This routine makes a copy of a file. The source and destination are specified with path strings. Each string specifies a path relative to the location specified by the corresponding disk handle. If the handle is a disk handle, the path is relative to that disk's root. If the disk handle is a standard path constant, the path string is relative to that standard path. If the disk handle is null, the path is relative to the current working directory.</P>
<P>
If <CODE>
FileCopy()</CODE>
 is successful, it returns zero. Otherwise, it returns one of the following error codes:</P>
<DL>
<DT>
ERROR_FILE_NOT_FOUND</DT><DD>
No such source file exists in the specified directory.</DD>
<DT>
ERROR_PATH_NOT_FOUND</DT><DD>
An invalid source or destination path string was passed.</DD>
<DT>
ERROR_ACCESS_DENIED</DT><DD>
You do not have permission to delete the existing copy of the destination file, or the destination disk or directory is not writable.</DD>
<DT>
ERROR_FILE_IN_USE</DT><DD>
Some geode has the existing destination file open.</DD>
<DT>
ERROR_SHORT_READ_WRITE</DT><DD>
There was not enough room on the destination disk.</DD>
</DL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_29.htm#IX_FileMove()">FileMove()</A></CODE>.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
file.h</STRONG>
 </P>
</DIV>
<HR>
<A NAME="R_25.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_25.htm_IX_FileCreate()">
 </A>
<H1 CLASS="refHeading">
FileCreate()</H1>
<PRE CLASS="syntax">FileHandle 	FileCreate( /* sets thread's error value */
        const char		* name,				/* relative to working directory */
        FileCreateFlags		flags,				/* see below */
        FileAttrs		attributes);				/* FileAttrs of new file */</PRE>
<P>
This routine creates a byte file. The file may be a DOS file or a GEOS byte file. If the file is successfully opened, <CODE>
FileCreate()</CODE>
 will return the file's handle; otherwise, it will return a null handle and set the thread's error value.</P>
<P>
The second parameter is a word-length <CODE>
FileCreateFlags</CODE>
 record. The third parameter, <CODE>
attributes</CODE>
, describes the <CODE>
FileAttrs</CODE>
 record to be set for the new file.</P>
<P>
If successful, <CODE>
FileCreate()</CODE>
 returns the file's handle. If it is unsuccessful, it returns a null handle and sets the thread's error value (accessible via <CODE>
<A HREF="../../CRef/Routines/R_97.htm#IX_ThreadGetError()">ThreadGetError()</A></CODE>
). The following error values are commonly returned:</P>
<DL>
<DT>
ERROR_PATH_NOT_FOUND</DT><DD>
A relative or absolute path was passed, and the path included a directory which did not exist.</DD>
<DT>
ERROR_TOO_MANY_OPEN_FILES</DT><DD>
There is a limit to how many files may be open at once. If this limit is reached, <CODE>
FileCreate()</CODE>
 will fail until a file is closed.</DD>
<DT>
ERROR_ACCESS_DENIED</DT><DD>
Either the caller requested access which could not be granted (e.g. it requested write access when another geode had already opened the file with FILE_DENY_W), or the caller tried to deny access when that access had already been granted to another geode (e.g. it tried to open the file with FILE_DENY_W when another geode already had it open for write-access).</DD>
<DT>
ERROR_WRITE_PROTECTED</DT><DD>
The caller requested write or read-write access to a file in a write-protected volume.</DD>
<DT>
ERROR_FILE_EXISTS</DT><DD>
Returned if <CODE>
FileCreate()</CODE>
 was called with FILE_CREATE_ONLY and a file with the specified name already exists.</DD>
<DT>
ERROR_FILE_FORMAT_MISMATCH</DT><DD>
Returned if <CODE>
FileCreate()</CODE>
 was called with FILE_CREATE_TRUNCATE or FILE_CREATE_NO_TRUNCATE and a file exists in a different format than desired; i.e. you passed FCF_NATIVE and the file already exists in the GEOS format, or vice versa.</DD>
</DL>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	An example of usage is shown below.</P>
<P CLASS="figTitle">
Example of FileCreate() usage</P>
<PRE>/* Here we create a DOS file in the current working directory. If the file already
 * exists, we open the existing file and truncate it.
 */</PRE>
<PRE>	FileHandle		newFile;</PRE>
<PRE>	newFile = 		FileCreate(&quot;NEWFILE.TXT&quot;,
					( (FILE_CREATE_TRUNCATE | FCF_NATIVE)
					 | (FILE_ACCESS_RW | FILE_DENY_RW)),
					0); /* set no attribute bits */</PRE>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_25.htm#IX_FileCreateTempFile()">FileCreateTempFile()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_2a.htm#IX_FileOpen()">FileOpen()</A></CODE>.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
file.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_25.htm_IX_Directories (file system):creation">
 </A>
<A NAME="R_25.htm_IX_FileCreateDir()">
 </A>
<H1 CLASS="refHeading">
FileCreateDir()</H1>
<PRE CLASS="syntax">word	FileCreateDir( /* Returns error &amp; sets thread's error value */
        const char * name);				/* Relative path of new directory */</PRE>
<P>
This routine creates a new directory. The parameter is a path string; the path is relative to the current directory. The last element of the path string must be the directory to create.</P>
<P>
If <CODE>
FileCreateDir()</CODE>
 is successful, it returns zero and clears the thread's error value. Otherwise, it returns an error code and sets the thread's error value (accessible via <CODE>
<A HREF="../../CRef/Routines/R_97.htm#IX_ThreadGetError()">ThreadGetError()</A></CODE>
). The following errors are returned:</P>
<DL>
<DT>
ERROR_PATH_TOO_LONG</DT><DD>
The path string was longer than is permitted by the file system for that device.</DD>
<DT>
ERROR_FILE_EXISTS</DT><DD>
A file or directory with the specified name already exists at the specified location.</DD>
<DT>
ERROR_INVALID_NAME</DT><DD>
The name passed was inappropriate for directories on that device.</DD>
<DT>
ERROR_DISK_STALE</DT><DD>
The drive that disk was on has been removed.</DD>
<DT>
ERROR_DISK_UNAVAILABLE</DT><DD>
The validation of the disk in that drive was aborted by the user.</DD>
<DT>
ERROR_PATH_NOT_FOUND</DT><DD>
The path string was in some way invalid; for example, it might have instructed <CODE>
FileCreateDir()</CODE>
 to create the directory within a directory which does not exist.</DD>
<DT>
ERROR_ACCESS_DENIED</DT><DD>
The thread is not able to create directories in the specified location, or a directory with the specified name already exists.</DD>
<DT>
ERROR_WRITE_PROTECTED</DT><DD>
The volume is write-protected.</DD>
</DL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_26.htm#IX_FileDeleteDir()">FileDeleteDir()</A></CODE>.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
file.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_25.htm_IX_FileCreateTempFile()">
 </A>
<H1 CLASS="refHeading">
FileCreateTempFile()</H1>
<PRE CLASS="syntax">FileHandle FileCreateTempFile( /* Sets thread's error value */
        char		* dir,		/* directory, relative to working dir.;
					 * file name replaces 14 trailing null
					 * characters upon return */</PRE>
<PRE CLASS="syntax">        FileCreateFlags		flags,
        FileAttrs		attributes);</PRE>
<P>
This routine creates and opens a temporary file in the directory specified. The routine automatically selects a name for the temporary file. No creation flags are needed, since the file will definitely be created anew and will be used only by this geode. The directory string must end with fourteen null bytes (enough to be replaced by the new file's name).</P>
<P>
If <CODE>
FileCreateTempFile()</CODE>
 is successful, it returns the file's handle as well as the string passed in <CODE>
dir</CODE>
, with the trailing null characters replaced by the file name. If it is unsuccessful, it returns a null handle and sets the thread's error value to a member of the <CODE>
FileError</CODE>
 enumerated type. (This error value is accessible via <CODE>
<A HREF="../../CRef/Routines/R_97.htm#IX_ThreadGetError()">ThreadGetError()</A></CODE>
.)</P>
<P CLASS="refField"><STRONG>
Tips and Tricks:</STRONG>	Temporary files are usually created in a subdirectory of SP_PRIVATE_DATA.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_25.htm#IX_FileCreate()">FileCreate()</A></CODE>.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
file.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_25.htm_IX_FileDelete()">
 </A>
<H1 CLASS="refHeading">
FileDelete()</H1>
<PRE CLASS="syntax">word	FileDelete( /* returns error */
        const char * name);			/* path relative to working directory */</PRE>
<P>
This routine deletes a file. If it is successful, it returns zero; otherwise, it returns a <CODE>
FileError</CODE>
. Common errors include:</P>
<DL>
<DT>
ERROR_FILE_NOT_FOUND</DT><DD>
No such file exists in the specified directory.</DD>
<DT>
ERROR_WRITE_PROTECTED</DT><DD>
The volume is write-protected.</DD>
<DT>
ERROR_PATH_NOT_FOUND</DT><DD>
An invalid path string was passed.</DD>
<DT>
ERROR_ACCESS_DENIED</DT><DD>
You do not have permission to delete that file.</DD>
<DT>
ERROR_FILE_IN_USE</DT><DD>
Some geode has that file open.</DD>
</DL>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
file.h</STRONG>
 </P>
</DIV>
<HR>
<A NAME="R_26.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_26.htm_IX_Directories (file system):deletion">
 </A>
<A NAME="R_26.htm_IX_FileDeleteDir()">
 </A>
<H1 CLASS="refHeading">
FileDeleteDir()</H1>
<PRE CLASS="syntax">word	FileDeleteDir( /* Returns error &amp; sets thread's error value */
        const char * name);			/* Relative path of directory to delete */</PRE>
<P>
This argument deletes an existing directory. The parameter is a string which specifies the directory's position relative to the current working directory. The last element of the path string must be the name of the directory to delete.</P>
<P>
If <CODE>
FileDeleteDir()</CODE>
 is successful, it returns zero and clears the thread's error value. Otherwise, it returns an error code and sets the thread's error value (accessible via <CODE>
<A HREF="../../CRef/Routines/R_97.htm#IX_ThreadGetError()">ThreadGetError()</A></CODE>
). The following errors are returned:</P>
<DL>
<DT>
ERROR_PATH_NOT_FOUND</DT><DD>
The directory specified could not be found or does not exist.</DD>
<DT>
ERROR_IS_CURRENT_DIRECTORY</DT><DD>
This directory is some thread's current directory, or else it is on some thread's directory stack.</DD>
<DT>
ERROR_ACCESS_DENIED</DT><DD>
The thread does not have permission to delete the directory.</DD>
<DT>
ERROR_WRITE_PROTECTED</DT><DD>
The volume is write-protected.</DD>
<DT>
ERROR_DIRECTORY_NOT_EMPTY</DT><DD>
The directory specified is not empty. A directory must be empty before it can be deleted.</DD>
</DL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_25.htm#IX_FileCreateDir()">FileCreateDir()</A></CODE>.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
file.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_26.htm_IX_FileDuplicateHandle()">
 </A>
<H1 CLASS="refHeading">
FileDuplicateHandle()</H1>
<PRE CLASS="syntax">FileHandle FileDuplicateHandle( /* Sets thread's error value */
        FileHandle fh);</PRE>
<P>
This routine duplicates the handle of an open file and returns the duplicate handle. The duplicate handle has the same read/write position as the original. Both handles will have to be closed for the file to be closed. If there is an error, <CODE>
FileDuplicateHandle()</CODE>
 returns a null handle and sets the thread's error value (accessible via <CODE>
<A HREF="../../CRef/Routines/R_97.htm#IX_ThreadGetError()">ThreadGetError()</A></CODE>
).</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
file.h</STRONG>
 </P>
</DIV>
<HR>
<A NAME="R_27.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_27.htm_IX_FileEnum()">
 </A>
<A NAME="R_27.htm_IX_FileEnumParams">
 </A>
<A NAME="R_27.htm_IX_FEP_&ldots;">
 </A>
<A NAME="R_27.htm_IX_FileEnumSearchFlags">
 </A>
<A NAME="R_27.htm_IX_FESF_&ldots;">
 </A>
<A NAME="R_27.htm_IX_FileEnumStandardReturnType">
 </A>
<A NAME="R_27.htm_IX_FESRT_&ldots;">
 </A>
<A NAME="R_27.htm_IX_FEDosInfo">
 </A>
<A NAME="R_27.htm_IX_DPI_&ldots;">
 </A>
<H1 CLASS="refHeading">
FileEnum()</H1>
<PRE CLASS="syntax">word	FileEnum( /* returns number of files returned */
        FileEnumParams		* params,			/* described below */
        MemHandle		* bufCreated,			/* FileEnum will allocate a return-
						 * buffer block &amp; write its handle
						 * here */</PRE>
<PRE CLASS="syntax">        word		* numNoFit);				/* Number of files not handled is
						 * written here */</PRE>
<P>
This routine is used to examine all the files in a directory. The routine can filter the files by whether they have certain extended attributes. It creates a buffer and writes information about the files in this buffer. This routine can be called in many different ways; <A HREF="../../Files/FileSys/FileSys_f.htm#51873">full details are available</A>.</P><P CLASS="refField"><STRONG>
Structures:</STRONG>	<CODE>
FileEnum()</CODE>
 uses several structures and enumerated types. They are shown below; the detailed description of the structures follows.</P>
<PRE CLASS="syntax">        	/* Types, values, and structures passed
 * to the FileEnum() routine: */</PRE>
<PRE CLASS="syntax">        typedef enum /* word */ {
FESRT_COUNT_ONLY,
FESRT_DOS_INFO,
FESRT_NAME,
FESRT_NAME_AND_ATTR</PRE>
<PRE CLASS="syntax">        } FileEnumStandardReturnType;
        typedef enum /* word */ {
FESC_WILDCARD</PRE>
<PRE CLASS="syntax">        } FileEnumStandardCallback;
        	/* Types, values, and structures returned
 * by the FileEnum() routine: */</PRE>
<PRE CLASS="syntax">        typedef struct {
FileAttrs 			DFIS_attributes;
FileDateAndTime 			DFIS_modTimeDate;
dword 			DFIS_fileSize;
FileLongName 			DFIS_name;
DirPathInfo 			DFIS_pathInfo;</PRE>
<PRE CLASS="syntax">        } FEDosInfo;
        typedef struct _FileEnumCallbackData {
FileExtAttrDesc 			FECD_attrs[1];</PRE>
<PRE CLASS="syntax">        } FileEnumCallbackData;
        typedef struct _FileEnumParams {
FileEnumSearchFlags 				FEP_searchFlags;
FileExtAttrDesc *				FEP_returnAttrs;
word 				FEP_returnSize;
FileExtAttrDesc *				FEP_matchAttrs;
word 				FEP_bufSize;
word 				FEP_skipCount;
word _pascal (*FEP_callback) 						(struct _FileEnumParams *params,
						 FileEnumCallbackData *fecd, 
						 word frame);
FileExtAttrDesc *				FEP_callbackAttrs;
dword 			FEP_cbData1;
dword 			FEP_cbData2;
word 			FEP_headerSize;</PRE>
<PRE CLASS="syntax">        } FileEnumParams;</PRE>
<P>
Most of the information passed to <CODE>
FileEnum()</CODE>
 is contained in a <CODE>
FileEnumParams</CODE>
 structure. The fields of the structure are as follows:</P>
<DL>
<DT>
<CODE>
FEP_searchFlags</DT><DD>
</CODE>
This is a byte-length flag field. The flags are of type <CODE>
FileEnumSearchFlags</CODE>
 (described below). These flags specify which files at the current location will be examined by <CODE>
FileEnum()</CODE>
. They also specify such things as whether a callback routine should be used.</DD>
<DT>
<CODE>
FEP_returnAttrs</DT><DD>
</CODE>
This is a pointer to an array of <CODE>
FileExtAttrDesc</CODE>
 structures. The last structure should have its <CODE>
FEA_attr</CODE>
 field set to FEA_END_OF_LIST. The array specifies what information will be returned by <CODE>
FileEnum()</CODE>
. The <CODE>
FileExtAttrDesc</CODE>
 structure is used in a slightly different way than usual. Every file will have an entry in the return buffer; this entry will contain all the extended attribute information requested. Each <CODE>
FileExtAttrDesc</CODE>
 structure will specify where in that entry its information should be written. The <CODE>
FEAD_value</CODE>
 field should contain only an offset value; the extended attribute will be written at that offset into the entry. (You can specify an offset by casting an integer value to type <CODE>
void *</CODE>
.) The <CODE>
FEAD_size</CODE>
 value specifies how long the return value can be. You can also request certain return values by setting <CODE>
FEP_returnAttrs</CODE>
 to equal a member of the <CODE>
FileEnumStandardReturnType</CODE>
 (again, by casting the <CODE>
FileEnumStandardReturnType</CODE>
 value to type <CODE>
void *</CODE>
). The <CODE>
FileEnumStandardReturnType</CODE>
 enumerated type is described later in this section.</DD>
<DT>
<CODE>
FEP_returnSize</DT><DD>
</CODE>
This is the size of each entry in the returned buffer. If a standard return type or an array of <CODE>
FileExtAttrDesc</CODE>
 structures was passed, each entry in the returned buffer will contain all the extended attribute information requested for that file.</DD>
<DT>
<CODE>
FEP_matchAttrs</DT><DD>
</CODE>
This is a pointer to an array of <CODE>
FileExtAttrDesc</CODE>
 structures. The last structure should have its <CODE>
FEA_attr</CODE>
 field set to FEA_END_OF_LIST. <CODE>
FileEnum()</CODE>
 will automatically filter out and ignore all files whose attributes do not match the ones specified by this array. For attributes that are word-sized records, <CODE>
FEAD_value.offset</CODE>
 holds the bits that must be set, and <CODE>
FEAD_value.segment</CODE>
 holds the bits that must be clear. For byte-sized flags, <CODE>
FEAD_value.offset.low</CODE>
 contains the flags that must be set, and <CODE>
FEAD_value.offset.high</CODE>
 contains flags that must be clear. Byte- and word-sized non-flag values are stored in <CODE>
FEAD_value.offset</CODE>
. For all other values, <CODE>
FEAD_value</CODE>
 holds a pointer to the exact value to match, and <CODE>
FEAD_size</CODE>
 specifies the length of that value (in bytes). If you do not want to filter out any files in the working directory, or if you will use the callback routine to filter the files, pass a null pointer in this field.</DD>
<DT>
<CODE>
FEP_bufS</DT><DD>
ize<BR>
</CODE>
This specifies the maximum number of entries to be returned in the buffer. If you do not want to set a limit, pass the constant FE_BUFSIZE_UNLIMITED. The buffer will be grown as necessary.</DD>
<DT>
<CODE>
FEP_skipCount</DT><DD>
</CODE>
This contains the number of matching files to be ignored before the first one is processed. It is often used in conjunction with <CODE>
FEP_bufSize</CODE>
 to examine many files a few at a time. For example, if you only wanted to examine ten files at a time, you would set <CODE>
FEP_bufSize</CODE>
 to ten and <CODE>
FEP_skipCount</CODE>
 to zero. <CODE>
FileEnum() </CODE>
would return the data for the first ten files which match the search criteria. After processing the returned data, if there were any files left over, you could call <CODE>
FileEnum()</CODE>
 again, this time with <CODE>
FEP_skipCount</CODE>
 set to ten; <CODE>
FileEnum()</CODE>
 would handle the next ten matching files and return the data about them. In this way you could walk through all the matching files in the directory. Note that if the <CODE>
FileEnumSearchFlags</CODE>
 bit FESF_REAL_SKIP is set (in FEP<CODE>
_searchFlags</CODE>
), the first files in the directory will be skipped <EM>
before</EM>
 they are tested to see if they match. This is faster, since the match condition won't have to be checked for the first files in the directory.</DD>
<DT>
<CODE>
FEP_callback</DT><DD>
</CODE>
This holds a pointer to a Boolean callback routine. The callback routine can check to see if the file matches some other arbitrary criteria. The callback routine is called for any files which match all the above criteria. It should be declared _pascal. It is passed three arguments: a pointer to the <CODE>
FileEnumParams</CODE>
 structure, a pointer to the current stack frame (which is used by some assembly callback routines), and a pointer to an array of <CODE>
FileExtAttrDesc</CODE>
 structures. These structures are all the attributes required either for return, matching, or callback (see FEP<CODE>
_callbackAttrs</CODE>
 below), with the information for the current file filled in; you can search through them directly for the information you want, or you can call <CODE>
<A HREF="../../CRef/Routines/R_28.htm#IX_FileEnumLocateAttr()">FileEnumLocateAttr()</A></CODE>
 to search through this array. If the file should be accepted by <CODE>
FileEnum()</CODE>
, the callback should return <EM>
true</EM>
; otherwise it should return <EM>
false</EM>
. You can also instruct <CODE>
FileEnum()</CODE>
 to use one of the standard callback routines by passing a member of the <CODE>
FileEnumStandardCallback</CODE>
 enumerated type. In this case, <CODE>
FEP_callbackAttrs</CODE>
 is ignored; <CODE>
FileEnum()</CODE>
 will automatically pass the appropriate information to the callback routine. (Note that if the FESF_CALLBACK bit of the <CODE>
FEP_searchFlags</CODE>
 field is not set, the <CODE>
FEP_callback</CODE>
 field is ignored.)</DD>
<DT>
<CODE>
FEP_callbackAttrs</DT><DD>
</CODE>
This is a pointer to an array of <CODE>
FileExtAttrDesc</CODE>
 structures. The last structure should have its <CODE>
FEA_attr</CODE>
 field set to FEA_END_OF_LIST. The array will be filled in with the appropriate information for each file before the callback routine is called. Note that if the FESF_CALLBACK bit of the <CODE>
FEP_searchFlags </CODE>
is not set, the <CODE>
FEP_callbackAttrs </CODE>
is ignored. If you do not need any attributes passed to the callback routine, set this field to be a null pointer.</DD>
<DT>
<CODE>
FEP_cbData1</CODE>
, <CODE>
FEP_cbData2</DT><DD>
</CODE>
These are dword-length fields. Their contents are ignored by <CODE>
FileEnum()</CODE>
; they are used to pass information to the callback routine. If you do not call a standard callback routine, you may use these fields any way you wish.</DD>
<DT>
<CODE>
FEP_headerSize</DT><DD>
</CODE>
If the flag FESF_LEAVE_HEADER is set, <CODE>
FileEnum()</CODE>
 will leave an empty header space at the beginning of the return buffer. The size of the header is specified by this field. If FESF_LEAVE_HEADER is clear, this field is ignored.</DD>
</DL>
<P>
The first field of the <CODE>
FileEnumParams</CODE>
 structure, <CODE>
FEP_searchFlags</CODE>
, is a word-length record containing <CODE>
FileEnumSearchFlags</CODE>
. The following flags are available:</P>
<DL>
<DT>
FESF_DIRS</DT><DD>Directories should be examined by <CODE>
FileEnum()</CODE>
.</DD>
<DT>
FESF_NON_GEOS</DT><DD>
Non-GEOS files should be examined by <CODE>
FileEnum()</CODE>
.</DD>
<DT>
FESF_GEOS_EXECS</DT><DD>
GEOS executable files should be examined by <CODE>
FileEnum()</CODE>
.</DD>
<DT>
FESF_GEOS_NON_EXECS</DT><DD>
GEOS non-executable files (e.g., VM files) should be examined by <CODE>
FileEnum()</CODE>
.</DD>
<DT>
FESF_REAL_SKIP</DT><DD>
If a skip count of <EM>
n</EM>
 is specified, the first <EM>
n</EM>
 files will be skipped regardless of whether they matched the attributes passed. In this case, <CODE>
FileEnum()</CODE>
 will return the number of files passed through in order to get enough files to fill the buffer; the return value can thus be the real-skip count for the next pass.</DD>
<DT>
FESF_CALLBACK</DT><DD>
<CODE>
FileEnum()</CODE>
 should call a callback routine to determine whether a file should be accepted.</DD>
<DT>
FESF_LOCK_CB_DATA</DT><DD>
This flag indicates that the <CODE>
FileEnumParams</CODE>
 fields <CODE>
FEP_callback1</CODE>
 and <CODE>
FEP_callback2</CODE>
 are far pointers to movable memory that must be locked before <CODE>
FileEnum()</CODE>
 is called.</DD>
<DT>
FESF_LEAVE_HEADER</DT><DD>
If set, <CODE>
FileEnum()</CODE>
 should leave an empty header space at the start of the return buffer. The size of this buffer is specified by the <CODE>
FEP_headerSize</CODE>
 field.</DD>
</DL>
<P>
The <CODE>
FileEnumStandardReturnType</CODE>
 enumerated type has the following values; they are used in conjunction with the <CODE>
FEP_returnAttrs</CODE>
 field of the <CODE>
FileEnumParams</CODE>
 structure.</P>
<DL>
<DT>
FESRT_COUNT_ONLY</DT><DD>
<CODE>
FileEnum()</CODE>
 will not allocate any memory and will not return data about files; instead, it will simply return the number of files which match the specified criteria.</DD>
<DT>
FESRT_DOS_INFO</DT><DD>
<CODE>
FileEnum()</CODE>
 will return an array of <CODE>
FEDosInfo</CODE>
 structures. These structures contain basic information about the file: its virtual name, size, modification date, DOS attributes, and path information (as a <CODE>
DirPathInfo</CODE>
 record).</DD>
<DT>
FESRT_NAME</DT><DD>
<CODE>
FileEnum()</CODE>
 will return an array of <CODE>
FileLongName</CODE>
 strings, each one of which is FILE_LONGNAME_BUFFER_SIZE characters long; every one of these will contain a file's virtual name followed by a null terminator.</DD>
<DT>
FESRT_NAME_AND_ATTR</DT><DD>
<CODE>
FileEnum()</CODE>
 will return an array of <CODE>
FENameAndAttr</CODE>
 structures, each one of which contains a file's DOS attributes and virtual name.</DD>
</DL>
<P>
The <CODE>
FEDosInfo</CODE>
 structure includes a word-sized record (<CODE>
DFIS_pathInfo</CODE>
) which describes the file's position relative to the standard paths. It contains the following fields:</P>
<DL>
<DT>
DPI_EXISTS_LOCALLY</DT><DD>
This bit is set if the file exists in a directory under the primary tree.</DD>
<DT>
DPI_ENTRY_NUMBER_IN_PATH</DT><DD>
This is the mask for a seven-bit field whose offset is DPI_ENTRY_NUMBER_IN_PATH_OFFSET.</DD>
<DT>
DPI_STD_PATH</DT><DD>
This is the mask for an eight-bit field whose offset is DPI_STD_PATH_OFFSET. If the file is in a standard path, this field will contain a <CODE>
StandardPath</CODE>
 constant for a standard path containing the file. This need not be the &quot;closest&quot; standard path; for example, if the file is in the &quot;World&quot; directory, this constant might nevertheless be SP_TOP.</DD>
</DL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_28.htm#IX_FileEnumLocateAttr()">FileEnumLocateAttr()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_28.htm#IX_FileEnumWildcard()">FileEnumWildcard()</A></CODE>.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
fileEnum.h</STRONG>
 </P>
</DIV>
<HR>
<A NAME="R_28.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_28.htm_IX_FileEnumLocateAttr()">
 </A>
<H1 CLASS="refHeading">
FileEnumLocateAttr()</H1>
<PRE CLASS="syntax">void *	FileEnumLocateAttr( /* returns NULL if attr not found */
        FileEnumCallbackData*			fecd,		/* Passed to callback routine */
        FileExtendedAttribute			attr,		/* Search for this attribute */
        const char *			* name);			/* Attribute name (if second
						 * argument is FEA_CUSTOM) */</PRE>
<P>
<CODE>
<A HREF="../../CRef/Routines/R_27.htm#IX_FileEnum()">FileEnum()</A></CODE>
 can be instructed to call a callback routine to decide which files to filter out. This callback routine is passed an array of <CODE>
FileExtAttrDesc</CODE>
 structures. To find a particular extended attribute in this array, call <CODE>
FileEnumLocateAttr()</CODE>
. This routine will find the address of the value of the attribute desired, and return that address. If the attribute is not in the array, <CODE>
FileEnumLocateAttr()</CODE>
 will return a null pointer.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
fileEnum.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_28.htm_IX_FileEnumWildcard()">
 </A>
<H1 CLASS="refHeading">
FileEnumWildcard()</H1>
<PRE CLASS="syntax">Boolean	FileEnumWildcard(
        FileEnumCallbackData			* fecd,			/* Passed to callback routine */
        word			frame);			/* Inherited stack frame */</PRE>
<P>
This routine is a utility used by <CODE>
<A HREF="../../CRef/Routines/R_27.htm#IX_FileEnum()">FileEnum()</A></CODE>
 and is rarely used by applications. It checks to see if the virtual name of the current file (the file currently being evaluated by <CODE>
<A HREF="../../CRef/Routines/R_27.htm#IX_FileEnum()">FileEnum()</A></CODE>
) matches the pattern in the <CODE>
FEP_cbData1</CODE>
 field of the <CODE>
FileEnumParams</CODE>
 structure.</P>
<P>
The <EM>
fecd</EM>
 parameter is a pointer to the callback data of the <CODE>
<A HREF="../../CRef/Routines/R_27.htm#IX_FileEnum()">FileEnum()</A></CODE>
 routine. The frame parameter is a pointer to the <CODE>
<A HREF="../../CRef/Routines/R_27.htm#IX_FileEnum()">FileEnum()</A></CODE>
 stack frame: The first dword is the <CODE>
FEP_cbData1</CODE>
 field, and the second is the <CODE>
FEP_cbData2</CODE>
 field.</P>
<P>
This routine returns <CODE>
true</CODE>
 (non-zero) if the file name and pattern match. Otherwise, it returns <CODE>
false</CODE>
.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
fileEnum.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_28.htm_IX_TransferBlockID:extracting file handle from">
 </A>
<A NAME="R_28.htm_IX_FileFromTransferBlockID() macro">
 </A>
<H1 CLASS="refHeading">
FileFromTransferBlockID()</H1>
<PRE CLASS="syntax">VMFileHandle	 FileFromTransferBlockID(id);
        TransferBlockID <EM>id</EM>;</PRE>
<P>
This macro extracts a VMFileHandle from a value of type <CODE>
TransferBlockID</CODE>
.</P>
</DIV>
<DIV>
<A NAME="R_28.htm_IX_FileGetAttributes()">
 </A>
<H1 CLASS="refHeading">
FileGetAttributes()</H1>
<PRE CLASS="syntax">FileAttrs 	FileGetAttributes( /* Sets thread's error value */
        const char * path);			/* file's path relative to current
			 * working directory */</PRE>
<P>
This routine returns the standard <CODE>
FileAttrs</CODE>
 attributes for a file. The file may be a GEOS file or a plain DOS file. Note that you can also get a file's attributes by getting the file's FEA_FILE_ATTR extended attribute. If an error occurs, this routine sets the thread's error (accessible via <CODE>
<A HREF="../../CRef/Routines/R_97.htm#IX_ThreadGetError()">ThreadGetError()</A></CODE>
).</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Structs/S_13.htm#IX_FileAttrs">FileAttrs</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_2b.htm#IX_FileSetAttributes()">FileSetAttributes()</A></CODE>.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
file.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_28.htm_IX_FileGetCurrentPath()">
 </A>
<H1 CLASS="refHeading">
FileGetCurrentPath()</H1>
<PRE CLASS="syntax">DiskHandle FileGetCurrentPath(
        char *	buffer,			/* Path string is written here */
        word	bufferSize);			/* Size of buffer in bytes */</PRE>
<P>
This routine writes the current path string (without drive specifier) to the buffer provided. If the buffer is too small, it truncates the path to fit. It returns the handle of the disk containing the current path. If the current path was declared relative to a standard path, the standard path constant will be returned.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
file.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_28.htm_IX_FileGetDateAndTime()">
 </A>
<H1 CLASS="refHeading">
FileGetDateAndTime()</H1>
<PRE CLASS="syntax"><CODE>FileDateAndTime</CODE> 	FileGetDateAndTime( /* sets thread's error value */
        FileHandle fh);</PRE>
<P>
This routine finds out the time a file was last modified. This routine can be called on GEOS or non-GEOS files. Note that you can also find out the modification time of a file by checking the extended attribute FEA_MODIFICATION. If unsuccessful, it sets the thread's error value (accessible via <CODE>
<A HREF="../../CRef/Routines/R_97.htm#IX_ThreadGetError()">ThreadGetError()</A></CODE>
).</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Structs/S_14.htm#IX_FileDateAndTime">FileDateAndTime</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_2b.htm#IX_FileSetDateAndTime()">FileSetDateAndTime()</A></CODE>.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
file.h</STRONG>
 </P>
</DIV>
<HR>
<A NAME="R_29.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_29.htm_IX_FileGetDiskHandle()">
 </A>
<H1 CLASS="refHeading">
FileGetDiskHandle()</H1>
<PRE CLASS="syntax">DiskHandle FileGetDiskHandle( /* sets thread's error value */
        FileHandle fh);</PRE>
<P>
This routine returns the handle of the disk containing an open file. If unsuccessful, it sets the thread's error value (accessible via <CODE>
<A HREF="../../CRef/Routines/R_97.htm#IX_ThreadGetError()">ThreadGetError()</A></CODE>
).</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
file.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_29.htm_IX_FileGetHandleExtAttributes()">
 </A>
<H1 CLASS="refHeading">
FileGetHandleExtAttributes()</H1>
<PRE CLASS="syntax">word	FileGetHandleExtAttributes(
        FileHandle			fh,				/* open file's handle */
        FileExtendedAttribute			attr,				/* attribute to get */
        void			* buffer,				/* attribute is written here */
        word			bufSize);				/* length of buffer in bytes */</PRE>
<P>
This routine gets one or more extended attributes of an open file. (To get the attributes of a file without opening it, call <CODE>
<A HREF="../../CRef/Routines/R_29.htm#IX_FileGetPathExtAttributes()">FileGetPathExtAttributes()</A></CODE>
.) If a single attribute is requested, the attribute will be written in the buffer passed. If several attributes are requested, <CODE>
attr</CODE>
 should be set to FEA_MULTIPLE, and <EM>
buffer</EM>
 should point to an array of <CODE>
FileExtAttrDesc</CODE>
 structures. In this case, <EM>
bufSize</EM>
 should be the number of structures in the buffer, not the length of the buffer. </P>
<P>
If <CODE>
FileGetHandleExtAttributes()</CODE>
 is successful, it returns zero. Otherwise, it returns one of the following error codes:</P>
<DL>
<DT>
ERROR_ATTR_NOT_SUPPORTED</DT><DD>
The file system does not recognize the attribute constant passed.</DD>
<DT>
ERROR_ATTR_SIZE_MISMATCH</DT><DD>
The buffer passed was too small for the attribute requested.</DD>
<DT>
ERROR_ATTR_NOT_FOUND</DT><DD>
The file does not have a value set for that attribute.</DD>
<DT>
ERROR_ACCESS_DENIED</DT><DD>
You do not have read-access to the file.</DD>
</DL>
<P CLASS="refField"><STRONG>
Tips and Tricks:</STRONG>	Note that the only way to recover a custom attribute is by passing FEA_MULTIPLE, and using a <CODE>
FileExtAttrDesc</CODE>
 to describe the attribute.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_29.htm#IX_FileGetPathExtAttributes()">FileGetPathExtAttributes()</A></CODE>.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
file.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_29.htm_IX_FileGetPathExtAttributes()">
 </A>
<H1 CLASS="refHeading">
FileGetPathExtAttributes()</H1>
<PRE CLASS="syntax">word	FileGetPathExtAttributes(
        const char			* path,				/* path relative to current
							 * working directory */</PRE>
<PRE CLASS="syntax">        FileExtendedAttribute			attr,				/* attribute to get */
        void			* buffer,				/* attribute is written here */
        word			bufSize);				/* length of buffer in bytes */</PRE>
<P>
This routine gets one or more extended attributes of a GEOS file. If a single attribute is requested, the attribute will be written in the buffer passed. If several attributes are requested, <CODE>
attr</CODE>
 should be set to FEA_MULTIPLE, and <EM>
buffer</EM>
 should point to an array of <CODE>
FileExtAttrDesc</CODE>
 structures. In this case, <EM>
bufSize</EM>
 should be the number of structures in the buffer, not the length of the buffer.</P>
<P>
If <CODE>
FileGetPathExtAttributes()</CODE>
 is successful, it returns zero. Otherwise, it returns one of the following error codes:</P>
<DL>
<DT>
ERROR_ATTR_NOT_SUPPORTED</DT><DD>
The file system does not recognize the attribute constant passed.</DD>
<DT>
ERROR_ATTR_SIZE_MISMATCH</DT><DD>
The buffer passed was too small for the attribute requested.</DD>
<DT>
ERROR_ATTR_NOT_FOUND</DT><DD>
The file does not have a value set for that attribute.</DD>
<DT>
ERROR_ACCESS_DENIED</DT><DD>
You do not have read-access to the file.</DD>
</DL>
<P CLASS="refField"><STRONG>
Tips and Tricks:</STRONG>	Note that the only way to recover a custom attribute is by passing FEA_MULTIPLE, and using a <CODE>
FileExtAttrDesc</CODE>
 to describe the attribute.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_29.htm#IX_FileGetHandleExtAttributes()">FileGetHandleExtAttributes()</A></CODE>.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
file.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_29.htm_IX_FileLockRecord()">
 </A>
<H1 CLASS="refHeading">
FileLockRecord()</H1>
<PRE CLASS="syntax">word	FileLockRecord( /* returns error */
        FileHandle		fh,
        dword		filePos,			/* lock starting at this position... */
        dword		regLength);				/* lock this many bytes */</PRE>
<P>
This routine puts a lock on a part of a byte file. It first checks to make sure that there are no locks that overlap the region specified; if there are, it will fail and return ERROR_ALREADY_LOCKED. If there are no locks, it will place a lock on the region specified and return zero.</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	Locking a region only prevents threads from locking part of the same region; it does not prevent them from reading from or writing to the region. If applications use this mechanism, they have to make sure to call <CODE>
FileLockRecord</CODE>
 before trying to access a part of a file.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_2d.htm#IX_FileUnlockRecord()">FileUnlockRecord()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_55.htm#IX_HandleP()">HandleP()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_29.htm_IX_FileMove()">
 </A>
<H1 CLASS="refHeading">
FileMove()</H1>
<PRE CLASS="syntax">word	FileMove( /* Returns error */
        const char		* source,				/* source path and file name */
        const char		* dest,				/* destination path and file name */
        DiskHandle		sourceDisk,				/* These handles may be Standard */
        DiskHandle		destDisk);				/* Path constants, or null to indi- 
						 * cate current working directory */</PRE>
<P>
This routine moves a file from one location to another. The source and destination are specified with path strings. Each string specifies a path relative to the location specified by the corresponding disk handle. If the handle is a disk handle, the path is relative to that disk's root. If the disk handle is a standard path constant, the path string is relative to that standard path. If the disk handle is null, the path is relative to the current working directory.</P>
<P>
If <CODE>
FileMove()</CODE>
 is successful, it returns zero. Otherwise, it returns one of the following error codes and sets the thread's error value.</P>
<DL>
<DT>
ERROR_FILE_NOT_FOUND</DT><DD>
No such source file exists in the specified directory.</DD>
<DT>
ERROR_PATH_NOT_FOUND</DT><DD>
An invalid source or destination path string was passed.</DD>
<DT>
ERROR_ACCESS_DENIED</DT><DD>
You do not have permission to delete the source file, or there is already a file with the same name as the destination file (and you do not have permission to delete it), or the destination disk or directory is not writable.</DD>
<DT>
ERROR_FILE_IN_USE</DT><DD>
Either the source file is in use, or there is already a file with the same name as the destination file, and it is in use.</DD>
<DT>
ERROR_SHORT_READ_WRITE</DT><DD>
There was not enough room on the destination disk.</DD>
</DL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_24.htm#IX_FileCopy()">FileCopy()</A></CODE>.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
file.h</STRONG>
 </P>
</DIV>
<HR>
<A NAME="R_2a.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_2a.htm_IX_FileOpen()">
 </A>
<H1 CLASS="refHeading">
FileOpen()</H1>
<PRE CLASS="syntax">FileHandle FileOpen( /* sets thread's error value */
        const char		* name,			/* relative to working dir */
        FileAccessFlags		flags);			/* Permissions/exclusions */</PRE>
<P>
This routine opens a file for bytewise access. The file may be a DOS file or a GEOS byte file. If the file is successfully opened, <CODE>
FileOpen()</CODE>
 will return the file's handle; otherwise, it will return a null handle and set the thread's error value (accessible via <CODE>
<A HREF="../../CRef/Routines/R_97.htm#IX_ThreadGetError()">ThreadGetError()</A></CODE>
). Errors typically set by this routine are listed below:</P>
<DL>
<DT>
ERROR_FILE_NOT_FOUND</DT><DD>
No file with the specified name could be found in the appropriate directory.</DD>
<DT>
ERROR_PATH_NOT_FOUND</DT><DD>
A relative or absolute path had been passed, and the path included a directory which did not exist.</DD>
<DT>
ERROR_TOO_MANY_OPEN_FILES</DT><DD>
There is a limit to how many files may be open at once. If this limit is reached, <CODE>
FileOpen()</CODE>
 will fail until a file is closed.</DD>
<DT>
ERROR_ACCESS_DENIED</DT><DD>
Either the caller requested access which could not be granted (e.g. it requested write access when another geode had already opened the file with FILE_DENY_W), or the caller tried to deny access when that access had already been granted to another geode (e.g. it tried to open the file with FILE_DENY_W when another geode already had it open for write-access).</DD>
<DT>
ERROR_WRITE_PROTECTED</DT><DD>
The caller requested write or read-write access to a file in a write-protected volume.</DD>
</DL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_25.htm#IX_FileCreate()">FileCreate()</A></CODE>,
<CODE><A HREF="../../CRef/Structs/S_12.htm#IX_FileAccessFlags">FileAccessFlags</A></CODE>.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
file.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_2a.htm_IX_FileParseStandardPath()">
 </A>
<H1 CLASS="refHeading">
FileParseStandardPath()</H1>
<PRE CLASS="syntax">StandardPath FileParseStandardPath(
        DiskHandle		disk,
        const char		** path);</PRE>
<P>
This routine is passed a full path (relative to the passed disk or a standard path, if the disk handle is null) and finds the standard path which most closely contains that path. It updates the pointer whose address is passed so that it points to the trailing portion of the path string. For example, if you pass the path string &quot;\GEOWORKS\DOCUMENT\MEMOS\APRIL&quot;, the pointer would be updated to point to the &quot;\MEMOS\APRIL&quot; portion, and the <CODE>
StandardPath</CODE>
 SP_DOCUMENT would be returned. If the path passed does not belong to a standard path, the constant SP_NOT_STANDARD_PATH will be returned, and the pointer will not be changed.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
file.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_2a.htm_IX_FilePopDir()">
 </A>
<H1 CLASS="refHeading">
FilePopDir()</H1>
<PRE CLASS="syntax">void	FilePopDir();</PRE>
<P>
<CODE>
FilePopDir()</CODE>
 pops the top directory off the thread's directory stack and makes it the current working directory.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_2a.htm#IX_FilePushDir()">FilePushDir()</A></CODE>.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
file.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_2a.htm_IX_FilePos()">
 </A>
<H1 CLASS="refHeading">
FilePos()</H1>
<PRE CLASS="syntax">dword	FilePos( /* Sets thread's error value */
        FileHandle		fh,
        dword		posOrOffset,
        FilePosMode		mode);</PRE>
<P>
This routine changes the current file position. The position can be specified in three ways, depending on the value of the <EM>
mode</EM>
 argument:</P>
<DL>
<DT>
FILE_POS_START</DT><DD>
The file position is set to a specified number of bytes after the start of the file. Passing this mode with an offset of zero will set the file position to the start of the file.</DD>
<DT>
FILE_POS_RELATIVE</DT><DD>
The file position is incremented by a specified number of bytes; this number may be negative.</DD>
<DT>
FILE_POS_END</DT><DD>
The file position is set to a specified number of bytes after the end of the file; it is usually passed with a negative number of bytes. Passing this mode with an offset of zero will set the file position to the end of the file.</DD>
</DL>
<P>
<CODE>
FilePos()</CODE>
 returns a 32-bit integer. This integer specifies the absolute file position after the move (relative to the start of the file). On an error, it sets the thread's error value (accessible via <CODE>
<A HREF="../../CRef/Routines/R_97.htm#IX_ThreadGetError()">ThreadGetError()</A></CODE>
).</P>
<P CLASS="refField"><STRONG>
Tips and Tricks:</STRONG>	To find out the current file position without changing it, call <CODE>
FilePos()</CODE>
 with mode FILE_POS_RELATIVE and offset zero.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
file.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_2a.htm_IX_FilePushDir()">
 </A>
<H1 CLASS="refHeading">
FilePushDir()</H1>
<PRE CLASS="syntax">void	FilePushDir();</PRE>
<P>
<CODE>
FilePushDir()</CODE>
 pushes the current working directory onto the thread's directory stack. It does not change the current working directory.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_2a.htm#IX_FilePopDir()">FilePopDir()</A></CODE>.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
file.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_2a.htm_IX_FileRead()">
 </A>
<H1 CLASS="refHeading">
FileRead()</H1>
<PRE CLASS="syntax">word	FileRead(
        FileHandle		fh,			/* handle of open file */
        void		* buf,			/* copy data to this buffer */
        word		count,			/* Length of buffer (in bytes) */
        Boolean		noErrorFlag);					/* Set if app can't
							 * handle errors */</PRE>
<P>
This routine copies data from a file into memory. It starts copying from the current position in the file. If possible, it will copy enough data to fill the buffer. If <CODE>
FileRead()</CODE>
 is successful, it returns the number of bytes copied. If an error occurs, <CODE>
FileRead()</CODE>
 returns -1 and sets the thread's error value (usually to ERROR_ACCESS_DENIED). The current file position will be changed to the first byte after the ones which were read.</P>
<P>
In C, there is no way to determine whether an ERROR_SHORT_READ_WRITE error occurs. To check whether all of the data was actually copied into memory, you must compare the number of bytes actually read with the number requested to be read. If your read operation requires multiple <CODE>
FileRead() </CODE>
operations, you may should read until zero bytes are returned.</P>
<P>
To retrieve the thread error value, use <CODE>
<A HREF="../../CRef/Routines/R_97.htm#IX_ThreadGetError()">ThreadGetError()</A></CODE>
.</P>
<P>
If the argument <EM>
noErrorFlag</EM>
 is set to <EM>
true</EM>
 (i.e. non-zero), <CODE>
FileRead()</CODE>
 will fatal-error if an error occurs (including an ERROR_SHORT_READ_WRITE).</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	Pass <CODE>
noErrorFlag</CODE>
 <CODE>
true</CODE>
 only during debugging.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
file.h</STRONG>
 </P>
</DIV>
<HR>
<A NAME="R_2b.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_2b.htm_IX_FileRename()">
 </A>
<H1 CLASS="refHeading">
FileRename()</H1>
<PRE CLASS="syntax">word	FileRename(
        const char * oldName,				/* Relative to working directory */
        const char * newName);				/* Name only, without path */</PRE>
<P>
This routine changes a file's name. It cannot move a file to a different directory; to do that, call <CODE>
<A HREF="../../CRef/Routines/R_29.htm#IX_FileMove()">FileMove()</A></CODE>
. If the routine is successful, it returns zero; otherwise, it returns a <CODE>
FileError</CODE>
. Common errors include</P>
<DL>
<DT>
ERROR_FILE_NOT_FOUND</DT><DD>
No such file exists in the specified directory.</DD>
<DT>
ERROR_PATH_NOT_FOUND</DT><DD>
An invalid path string was passed.</DD>
<DT>
ERROR_ACCESS_DENIED</DT><DD>
You do not have permission to delete that file, or it exists on a read-only volume.</DD>
<DT>
ERROR_FILE_IN_USE</DT><DD>
Some geode has that file open.</DD>
<DT>
ERROR_INVALID_NAME</DT><DD>
The name was not a valid GEOS name; or the file is a non-GEOS file, and the name was not an appropriate native name.</DD>
</DL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_29.htm#IX_FileMove()">FileMove()</A></CODE>.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
file.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_2b.htm_IX_FileResolveStandardPath()">
 </A>
<A NAME="R_2b.htm_IX_FileResolveStandardPathFlags">
 </A>
<A NAME="R_2b.htm_IX_FRSPF_&ldots;">
 </A>
<H1 CLASS="refHeading">
FileResolveStandardPath()</H1>
<PRE CLASS="syntax">DiskHandle FileResolveStandardPath(
        char		** buffer,				/* Write path here; update pointer
						 * to point to end of path */</PRE>
<PRE CLASS="syntax">        word		bufSize,				/* Size of buffer (in bytes) */
        const char *		path,				/* Relative path of file */
        FileResolveStandardPathFlags flags,							/* Flags are described below */
        FileAttrs *attrsPtr);							/* Empty buffer, will be filled with attrs of passed file, if any */</PRE>
<P>
This routine finds a file relative to the current location, then writes the full path to the file, starting at the root of the disk (<EM>
not</EM>
 at a standard path). It writes the path to the passed buffer, updating the pointer to point to the null at the end of the path string; it also returns the handle of the disk. If it cannot find the file it returns a null path.</P>
<P CLASS="refField"><STRONG>
Structures:</STRONG>	A record of <CODE>
FileResolveStandardPathFlags</CODE>
 is passed to <CODE>
FileResolveStandardPath()</CODE>
. The following flags are available:</P>
<DL>
<DT>
FRSPF_ADD_DRIVE_NAME</DT><DD>
The path string written to the buffer should begin with the drive name (e.g., &quot;C:\GEOWORKS\DOCUMENT\MEMOS&quot;).</DD>
<DT>
FRSPF_RETURN_FIRST_DIR</DT><DD>
<CODE>
FileResolveStandardPath()</CODE>
 should not check whether the passed path actually exists; instead, it should assume that the path exists in the first directory comprising the standard path, and return accordingly.</DD>
</DL>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
file.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_2b.htm_IX_FileSetAttributes()">
 </A>
<H1 CLASS="refHeading">
FileSetAttributes()</H1>
<PRE CLASS="syntax"><CODE>word</CODE>	FileSetAttributes( /* returns error value */
        const char		* path,			/* file's path relative to current
					 * working directory */</PRE>
<PRE CLASS="syntax">        FileAttrs		attr);			/* new attributes for the file */</PRE>
<P>
This routine changes the standard DOS attributes of a DOS or GEOS file. Note that you can also change the attributes of a file by setting the extended attribute FEA_FILE_ATTR.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Structs/S_13.htm#IX_FileAttrs">FileAttrs</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_28.htm#IX_FileGetAttributes()">FileGetAttributes()</A></CODE>.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
file.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_2b.htm_IX_FileSetCurrentPath()">
 </A>
<H1 CLASS="refHeading">
FileSetCurrentPath()</H1>
<PRE CLASS="syntax">DiskHandle FileSetCurrentPath(
        DiskHandle		disk,			/* May be a standard path constant */
        const char		* path);			/* path string, null-terminated */</PRE>
<P>
This routine changes the current path. It is passed two parameters: The first is the handle of the disk containing the new current path (this may be a standard path constant). The second is a null-terminated path string. It is specified with normal DOS conventions: directories are separated by backslashes; a period (&quot;.&quot;) indicates the current directory; and a pair of periods (&quot;..&quot;) indicates the parent of the current directory. The string may not contain wildcard characters.</P>
<P>
If <CODE>
disk</CODE>
 is a disk handle, the path is relative to the root directory of that disk; if <CODE>
disk</CODE>
 is a standard path constant, the path is relative to the standard path; if it is null, the path is relative to the current working directory. <CODE>
FileSetCurrentPath()</CODE>
 returns the disk handle associated with the new current path; this may be a standard path constant. If <CODE>
FileSetCurrentPath()</CODE>
 fails, it returns a null handle.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_2c.htm#IX_FileSetStandardPath()">FileSetStandardPath()</A></CODE>.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
file.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_2b.htm_IX_FileSetDateAndTime()">
 </A>
<H1 CLASS="refHeading">
FileSetDateAndTime()</H1>
<PRE CLASS="syntax"><CODE>word</CODE>	FileSetDateAndTime( /* returns error */
        FileHandle		fh,					/* handle of open file */
        FileDateAndTime		dateAndTime);					/* new modification time */</PRE>
<P>
This routine changes a file's last-modification time-stamp. This routine can be called on GEOS or non-GEOS files. Note that you can also change the modification time of a file by changing the extended attribute FEA_MODIFICATION. If unsuccessful, this routine returns an error and sets the thread's error value (accessible via <CODE>
<A HREF="../../CRef/Routines/R_97.htm#IX_ThreadGetError()">ThreadGetError()</A></CODE>
).</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Structs/S_14.htm#IX_FileDateAndTime">FileDateAndTime</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_28.htm#IX_FileGetDateAndTime()">FileGetDateAndTime()</A></CODE>.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
file.h</STRONG>
 </P>
</DIV>
<HR>
<A NAME="R_2c.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_2c.htm_IX_FileSetHandleExtAttributes()">
 </A>
<H1 CLASS="refHeading">
FileSetHandleExtAttributes()</H1>
<PRE CLASS="syntax">word	FileGetPathExtAttributes( /* returns error */
        FileHandle			fh,			/* handle of open file */
        FileExtendedAttribute		 	attr,			/* attribute to get */
        const void			* buffer,			/* attribute is read from here */
        word			bufSize);			/* length of buffer in bytes */</PRE>
<P>
This routine sets one or more extended attributes of an open GEOS file. (To set the attributes of a file without opening it, call <CODE>
<A HREF="../../CRef/Routines/R_2c.htm#IX_FileSetPathExtAttributes()">FileSetPathExtAttributes()</A></CODE>
.) If a single attribute is specified, the attribute's new value will be read from the buffer passed. If several attributes are to be changed, <CODE>
attr</CODE>
 should be set to FEA_MULTIPLE, and <EM>
buffer</EM>
 should point to an array of <CODE>
FileExtAttrDesc</CODE>
 structures. In this case, <EM>
bufSize</EM>
 should be the number of structures in the buffer, not the length of the buffer. </P>
<P>
If <CODE>
FileSetHandleExtAttributes()</CODE>
 is successful, it returns zero. Otherwise, it sets the thread's error value (accessible via <CODE>
<A HREF="../../CRef/Routines/R_97.htm#IX_ThreadGetError()">ThreadGetError()</A></CODE>
) and returns one of the following error codes:</P>
<DL>
<DT>
ERROR_ATTR_NOT_SUPPORTED</DT><DD>
The file system does not recognize the attribute constant passed.</DD>
<DT>
ERROR_ATTR_SIZE_MISMATCH</DT><DD>
The buffer passed was the wrong size for the attribute specified.</DD>
<DT>
ERROR_ACCESS_DENIED</DT><DD>
The caller does not have write-access to the file.</DD>
<DT>
ERROR_CANNOT_BE_SET</DT><DD>
The extended attribute cannot be changed. Such attributes as FEA_SIZE and FEA_NAME cannot be changed with the <CODE>
FileSet...()</CODE>
 routines.</DD>
</DL>
<P CLASS="refField"><STRONG>
Tips and Tricks:</STRONG>	Note that the only way to create or change a custom attribute is by passing FEA_MULTIPLE, and using a <CODE>
FileExtAttrDesc</CODE>
 to describe the attribute.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_2c.htm#IX_FileSetPathExtAttributes()">FileSetPathExtAttributes()</A></CODE>.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
file.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_2c.htm_IX_FileSetPathExtAttributes()">
 </A>
<H1 CLASS="refHeading">
FileSetPathExtAttributes()</H1>
<PRE CLASS="syntax">word	FileSetPathExtAttributes(
        const char			* path,			/* path relative to current
						 * working directory */</PRE>
<PRE CLASS="syntax">        FileExtendedAttribute			 attr,			/* attribute to get */
        const void			* buffer,			/* attribute is read from here */
        word			bufSize);			/* length of buffer in bytes */</PRE>
<P>
This routine sets one or more extended attributes of a file. If a single attribute is specified, the attribute will be written in the buffer passed. If several attributes are to be changed, <CODE>
attr</CODE>
 should be set to FEA_MULTIPLE and <EM>
buffer</EM>
 should point to an array of <CODE>
FileExtAttrDesc</CODE>
 structures. In this case, <EM>
bufSize</EM>
 should be the number of structures in the buffer, not the length of the buffer.</P>
<P>
If <CODE>
FileSetPathExtAttributes()</CODE>
 is successful, it returns zero. Otherwise, it sets the thread's error value (accessible via <CODE>
<A HREF="../../CRef/Routines/R_97.htm#IX_ThreadGetError()">ThreadGetError()</A></CODE>
) and returns one of the following error codes:</P>
<DL>
<DT>
ERROR_ATTR_NOT_SUPPORTED</DT><DD>
The file system does not recognize the attribute constant passed.</DD>
<DT>
ERROR_ATTR_SIZE_MISMATCH</DT><DD>
The buffer passed was the wrong size for the attribute specified.</DD>
<DT>
ERROR_ACCESS_DENIED</DT><DD>
<CODE>
FileSetPathExtAttributes()</CODE>
 returns this if any geode (including the caller) has the file open with &quot;deny-write&quot; exclusive access, or if the file is not writable.</DD>
<DT>
ERROR_CANNOT_BE_SET</DT><DD>
The extended attribute cannot be changed. Such attributes as FEA_SIZE and FEA_NAME cannot be changed with the <CODE>
FileSet...ExtAttributes()</CODE>
 routines.</DD>
</DL>
<P CLASS="refField"><STRONG>
Tips and Tricks:</STRONG>	Note that the only way to create or change a custom attribute is by passing FEA_MULTIPLE, and using a <CODE>
FileExtAttrDesc</CODE>
 to describe the attribute.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_2c.htm#IX_FileSetHandleExtAttributes()">FileSetHandleExtAttributes()</A></CODE>.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
file.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_2c.htm_IX_FileSetStandardPath()">
 </A>
<H1 CLASS="refHeading">
FileSetStandardPath()</H1>
<PRE CLASS="syntax">void	FileSetStandardPath(
        StandardPath path);			/* StandardPath to set */</PRE>
<P>
This routine changes the current working directory to one of the system's StandardPath directories. Pass a standard path.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
file.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_2c.htm_IX_FileSize()">
 </A>
<H1 CLASS="refHeading">
FileSize()</H1>
<PRE CLASS="syntax">dword	FileSize(
        FileHandle fh);		/* handle of open file */</PRE>
<P>
This routine returns the size of the open file specified.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
file.h</STRONG>
 </P>
</DIV>
<HR>
<A NAME="R_2d.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_2d.htm_IX_FileTruncate()">
 </A>
<H1 CLASS="refHeading">
FileTruncate()</H1>
<PRE CLASS="syntax">word	FileTruncate(
        FileHandle		fh,			/* handle of open file */
        dword		offset,			/* offset at which to truncate */
        Boolean		noErrorFlag); </PRE>
<P>
This routine truncates the specified file at the passed offset. The <CODE>
offset</CODE>
 parameter can also be thought of as the desired file size. If the high bit of <EM>
noErrorFlag</EM>
 is one, then no errors will be returned.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
file.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_2d.htm_IX_FileUnlockRecord()">
 </A>
<H1 CLASS="refHeading">
FileUnlockRecord()</H1>
<PRE CLASS="syntax">word	FileUnlockRecord( /* returns error */
        FileHandle		fh,				/* handle of open file
        dword		filePos,				/* Release lock that starts here */
        dword		regLength);				/* and is this long */</PRE>
<P>
This routine releases a lock on a part of a byte-file. The lock must have been previously placed with <CODE>
<A HREF="../../CRef/Routines/R_29.htm#IX_FileLockRecord()">FileLockRecord()</A></CODE>
.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_29.htm#IX_FileLockRecord()">FileLockRecord()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_56.htm#IX_HandleV()">HandleV()</A></CODE>.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
file.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_2d.htm_IX_FileWrite()">
 </A>
<H1 CLASS="refHeading">
FileWrite()</H1>
<PRE CLASS="syntax">word	FileWrite( /* sets thread's error value */
        FileHandle		fh,				/* handle of open file */
        const void		* buf,				/* Copy from here into file */
        word		count,				/* # of bytes to copy */
        Boolean		noErrorFlag);				/* Set if can't handle errors */</PRE>
<P>
This routine copies a specified number of bytes from a buffer to the file. The bytes are written starting with the current position in the file; any data already at that location will be overwritten. <CODE>
FileWrite()</CODE>
 returns the number of bytes written. If <CODE>
FileWrite()</CODE>
 could not write all the data (e.g. if the disk ran out of space), it will set the thread's error value (accessible via <CODE>
<A HREF="../../CRef/Routines/R_97.htm#IX_ThreadGetError()">ThreadGetError()</A></CODE>
) to ERROR_SHORT_READ_WRITE and return the number of bytes that were written. If it could not write the data to the file at all (e.g. if you do not have write-access to the file), it will return -1 and set the thread's error value to ERROR_ACCESS_DENIED. In any event, the file position will be changed to the first byte after the ones written.</P>
<P>
If the argument <EM>
noErrorFlag</EM>
 is set to <EM>
true</EM>
 (i.e. non-zero), <CODE>
FileWrite()</CODE>
 will fatal-error if an error occurs.</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	Pass <CODE>
noErrorFlag</CODE>
 <CODE>
true</CODE>
 only during debugging.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
file.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_2d.htm_IX_FloatAsciiToFloat()">
 </A>
<A NAME="R_2d.htm_IX_FloatAsciiToFloatFlags">
 </A>
<A NAME="R_2d.htm_IX_FAF_&ldots;">
 </A>
<H1 CLASS="refHeading">
FloatAsciiToFloat()</H1>
<PRE CLASS="syntax">Boolean	FloatAsciiToFloat( /* returns FALSE on success */
        word floatAtoFflags, 
        word stringLength,
        void *string, 
        void *resultLocation);</PRE>
<P>
This routine is used to convert an ASCII string to a floating point number. It takes the following arguments:</P>
<DL>
<DT>
<STRONG>
floatAtoFflags</DT><DD>
</STRONG>
This <CODE>
FloatAsciiToFloatFlags</CODE>
 field determines what will be done with the generated floating point number. At most one flag may be set. If FAF_PUSH_RESULT is set, then the number will be pushed on the floating-point stack. If the FAF_STORE_NUMBER flag is set, the number will be returned at the resultLocation address.</DD>
<DT>
<STRONG>
stringLength</DT><DD>
</STRONG>
This is the length of the buffer passed in string.</DD>
<DT>
<STRONG>
string</STRONG>
</DT><DD>This buffer contains the ASCII string to convert. The string should be of the format &quot;[|+|-] dddd.dddd [|E|e] [|+|-] dddd&quot;. The string is assumed to be legal. There may be at most a single decimal point. Spaces and thousands separators are ignored.</DD>
<DT>
<STRONG>
resultLocation</DT><DD>
</STRONG>
If you pass the FAF_STORE_NUMBER flag, the buffer pointed to by resultLocation will be filled with the floating point number. This buffer should be at least five words long.</DD>
</DIV>
</DL>
<HR>
<A NAME="R_2e.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_2e.htm_IX_FloatFloatToAscii()">
 </A>
<A NAME="R_2e.htm_IX_FFA_dateTime">
 </A>
<A NAME="R_2e.htm_IX_FFA_&ldots;  (FloatFloatToAsciiData structure)">
 </A>
<A NAME="R_2e.htm_IX_FloatFloatToAsciiData">
 </A>
<A NAME="R_2e.htm_IX_FloatFloatToAsciiParams">
 </A>
<A NAME="R_2e.htm_IX_FloatFloatToAsciiFormatFlags">
 </A>
<A NAME="R_2e.htm_IX_FFAF_&ldots;">
 </A>
<A NAME="R_2e.htm_IX_FFA_dateTimeParams">
 </A>
<A NAME="R_2e.htm_IX_FloatFloatToDateTime">
 </A>
<A NAME="R_2e.htm_IX_FFA_&ldots;  (FloatFloatToDateTime structure)">
 </A>
<A NAME="R_2e.htm_IX_FloatFormatToDateTimeFlags">
 </A>
<A NAME="R_2e.htm_IX_FFDTT_&ldots;">
 </A>
<H1 CLASS="refHeading">
FloatFloatToAscii()</H1>
<PRE CLASS="syntax">word	FloatFloatToAscii( /* returns # of chars in ASCII string */
        FFA_stackFrame 		*stackFrame, 
        char 		*resultString,
        FloatNum 		*number);</PRE>
<P>
This routine converts a floating point number to an ASCII string. It uses a complicated data structure, <CODE>
FFA_stackFrame</CODE>
. To convert floating point numbers to ASCII without filling in this structure, use the <CODE>
FloatFloatToAscii_StdFormat()</CODE>
 routine instead. Unless a special flag is passed, this routine will convert the top number of the floating point stack and pop it. <CODE>
FloatFloatToAscii()</CODE>
 takes the following arguments:</P>
<DL>
<DT>
<STRONG>
stackFrame</STRONG>
 </DT><DD>This is an <CODE>
FFA_stackFrame</CODE>
 structure. This structure contains a structure of parameters to <CODE>
FloatFloatToAscii()</CODE>
; also, the routine will return some information in this structure. The structure is discussed in detail below.</DD>
<DT>
<STRONG>
resultString</STRONG>
</DT><DD>Pointer to a buffer which will hold the generated ASCII string. This buffer must be either FLOAT_TO_ASCII_NORMAL_BUF_LEN or FLOAT_TO_ASCII_HUGE_BUF_LEN bytes, depending on the type of <STRONG>number</STRONG> (see below).</DD>
<DT>
<STRONG>
number</STRONG>
</DT><DD>Specifies the format of the floating number. If it is FFAF_DONT_USE_SCIENTIFIC then the buffer <CODE>resultString</CODE> must be FLOAT_TO_ASCII_HUGE_BUF_LEN bytes long; otherwise, it must be FLOAT_TO_ASCII_NORMAL_BUF_LEN bytes.         
<P>
If you pass the FFAF_FROM_ADDR flag, then instead of converting the number at the head of the floating-point stack, the routine will convert this number. 
</DD>
</DL>
<P>
The routine explicitly returns the number of characters in the generated string, not counting the null terminator. It will return zero if an error occurred.</P>
<P CLASS="refField"><STRONG>
Structures:</STRONG>	</P>
<PRE CLASS="syntax">typedef union {
	FloatFloatToAsciiData  	 				<A NAME="R_2e.htm_IX_FFA_float"></A>FFA_float;
        FloatFloatToDateTimeData				FFA_dateTime;
} FFA_stackFrame;<A NAME="R_2e.htm_IX_FFA_stackFrame"> </A>
        
        typedef struct {
        	FloatFloatToAsciiParams FFA_params;
        	word                    FFA_startNumber;
        	word                    FFA_decimalPoint;
        	word                    FFA_endNumber;
        	word                    FFA_numChars;
        	word                    FFA_startExponent;
        	word                    FFA_bufSize;
        	word                    FFA_saveDI;
        	word                    FFA_numSign;
        	byte                    FFA_startSigCount;
        	byte                    FFA_sigCount;
        	byte                    FFA_noMoreSigInfo;
        	byte                    FFA_startDecCount;
        	byte                    FFA_decCount;
        	word                    FFA_decExponent;
        	word                    FFA_curExponent;
        	byte                    FFA_useCommas;
        	byte                    FFA_charsToComma;
        	char                    FFA_commaChar;
        	char                    FFA_decimalChar;
        } FloatFloatToAsciiData;</PRE>
<P>
If you're passing a <CODE>
FloatFloatToAsciiData</CODE>
 structure, you must fill in the <CODE>
FFA_params</CODE>
 field. When <CODE>
FloatFloatToAscii()</CODE>
 returns, some of the other fields will have been filled in with potentially useful information:</P>
<DL>
<DT>
<STRONG>
FFA_startNumber</DT><DD>
</STRONG>
This is an offset into the returned string, pointing to the start of the numeric characters.</DD>
<DT>
<STRONG>
FFA_decimalPoint</DT><DD>
</STRONG>
This is an offset into the returned string, pointing to the decimal point. If no decimal point appears in the string, this field will be zero.</DD>
<DT>
<STRONG>
FFA_endNumber</DT><DD>
</STRONG>
This is an offset into the returned string, pointing to the end of the numeric characters.</DD>
<DT>
<STRONG>
FFA_numChars</DT><DD>
</STRONG>
This is the number of characters in the returned string, or zero if there was an error. This is the same as FloatFloatToAscii()'s return value.</DD>
<DT>
<STRONG>
FFA_startExponent</DT><DD>
</STRONG>
This is an offset into the returned string, pointing to the &quot;E&quot; character. If there is no such character in the string, this field will be zero.</DD>
<DT>
The other <CODE>
FloatFloatToAsciiData</CODE>
 fields are internal.</DT>
</DL>
<PRE CLASS="syntax">        typedef struct {
        	FloatFloatToAsciiFormatFlags 						formatFlags;
        	byte    						decimalOffset;
        	byte    						totalDigits;
        	byte    						decimalLimit;
        	char    						preNegative[SIGN_STR_LEN+1];
        	char    						postNegative[SIGN_STR_LEN+1];
        	char    						prePositive[SIGN_STR_LEN+1];
        	char    						postPositive[SIGN_STR_LEN+1];
        	char    						header[PAD_STR_LEN+1];
        	char    						trailer[PAD_STR_LEN+1];
        	byte    						FFTAP_unused;
        } FloatFloatToAsciiParams;</PRE>
<P>
The <CODE>
FloatFloatToAsciiParams</CODE>
 structure determines how <CODE>
FloatFloatToAscii()</CODE>
 should format its generated string. It contains the following fields:</P>
<DL>
<DT>
<STRONG>
formatFlags</STRONG>
	</DT><DD>
A <CODE>
FloatFloatToAsciiFormatFlags</CODE>
 structure containing flags used to fine-tune the formatting.</DD>
<DT>
<STRONG>
decimalOffset</DT><DD>
</STRONG>
The number of decimal places to offset the decimal point. E.g. an offset of -6 will display numbers in terms of millions.</DD>
<DT>
<STRONG>
totalDigits</STRONG>
</DT><DD>Maximum number of digits. This is normally MAX_DIGITS_FOR_NORMAL_NUMBERS. If you're using scientific notation, then this is probably MAX_DIGITS_FOR_HUGE_NUMBERS.</DD>
<DT>
<STRONG>
decimalLimit</DT><DD>
</STRONG>
Maximum number of decimal digits; the number will be rounded to meet this limit.</DD>
<DT>
<STRONG>
preNegative</DT><DD>
</STRONG>
The characters which precede a negative number. The string should be null-terminated. Thypical values are &quot;-&quot; and &quot;(&quot;.</DD>
<DT>
<STRONG>
postNegative</DT><DD>
</STRONG>
The characters used to terminate a negative number. The string should be null-terminated. Typical values include the empty string and &quot;)&quot;.</DD>
<DT>
<STRONG>
prePositive</STRONG>
</DT><DD>The characters used to precede a postive number. The string should be null-terminated. Typical values include the null string and &quot;+&quot;.</DD>
<DT>
<STRONG>
postPositive</STRONG>
</DT><DD>The character used to terminate a positive number. The string is expected to be null terminated. Typically, this is the empty string.</DD>
<DT>
<STRONG>
header</STRONG>
</DT><DD>The characters that precede the number. This string should be null terminated. This string might appear before or after the sign character, depending on whether the FFAF_SIGN_CHAR_TO_FOLLOW_HEADER flag is set. Typically, this string is empty; if it isn't, then set the FFAF_HEADER_PRESENT flag.</DD>
<DT>
<STRONG>
trailer</STRONG>
</DT><DD>The characters that follow the number. This string should be null terminated. Whether this string follows or precedes the sign is determined by the FFAF_SIGN_CHAR_TO_PRECEDE_TRAILER flag. Typically, this string is empty; if it isn't, then set the FFAF_TRAILER_PRESENT flag.</DD>
</DL>
<PRE CLASS="syntax">        typedef WordFlags FloatFloatToAsciiFormatFlags;
        #define FFAF_FLOAT_RESERVED 									0x8000
        #define FFAF_FROM_ADDR 									0x4000
        #define FFAF_DONT_USE_SCIENTIFIC 									0x0200
        #define FFAF_SCIENTIFIC 									0x0100
        #define FFAF_PERCENT 									0x0080
        #define FFAF_USE_COMMAS 									0x0040
        #define FFAF_NO_TRAIL_ZEROS 									0x0020
        #define FFAF_NO_LEAD_ZERO 									0x0010
        #define FFAF_HEADER_PRESENT 									0x0008
        #define FFAF_TRAILER_PRESENT 									0x0004
        #define FFAF_SIGN_CHAR_TO_FOLLOW_HEADER 									0x0002
        #define FFAF_SIGN_CHAR_TO_PRECEDE_TRAILER									0x0001</PRE>
<P>
The <CODE>
FloatFloatToAsciiFormatFlags</CODE>
 field contains the following flags: </P>
<DL>
<DT>
FFAF_FLOAT_RESERVED </DT><DD>
This flag must be zero.</DD>
<DT>
FFAF_FROM_ADDR </DT><DD>
Normally, <CODE>
FloatFloatToAscii()</CODE>
 will convert the number at the top of the floating point stack. By passing this flag, you ask that the routine instead convert the number pointed to by its <EM>
number</EM>
 argument.</DD>
<DT>
FFAF_DONT_USE_SCIENTIFIC </DT><DD>
If set, this flag discourages the use of scientific notation. Zero padding will be used if possible.</DD>
<DT>
FFAF_SCIENTIFIC </DT><DD>
Set this flag to enforce scientific notation.</DD>
<DT>
FFAF_PERCENT </DT><DD>
Set this flag to display number as a percentage.</DD>
<DT>
FFAF_USE_COMMAS </DT><DD>
Set this flag to use comma separators.</DD>
<DT>
FFAF_NO_TRAIL_ZEROS </DT><DD>
Set this flag to pad the number with trailing zeros.</DD>
<DT>
FFAF_NO_LEAD_ZERO </DT><DD>
Set this flag to make a leading zero appear before fractional values. E.g. &quot;.53&quot; would appear as &quot;0.53&quot; instead.</DD>
<DT>
FFAF_HEADER_PRESENT </DT><DD>
If there is no header string, leave this flag clear--this results in a speed optimization.</DD>
<DT>
FFAF_TRAILER_PRESENT </DT><DD>
If there is no trailer string, leave this flag clear--this results in a speed optimization.</DD>
<DT>
FFAF_SIGN_CHAR_TO_FOLLOW_HEADER </DT><DD>
This flag determines the relative positions of the sign and header strings.</DD>
<DT>
FFAF_SIGN_CHAR_TO_PRECEDE_TRAILER </DT><DD>
This flag determines the relative positions of the sign and trailer strings.</DD>
</DL>
<PRE CLASS="syntax">        typedef struct {
        	FloatFloatToDateTimeParams      FFA_dateTimeParams;
	} FloatFloatToDateTimeData;<A NAME="R_2e.htm_IX_FloatFloatToDateTimeData"></A>
        
        typedef struct {
                FloatFloatToDateTimeFlags 							FFA_dateTimeFlags;
                word    							FFA_year;
                byte 							FFA_month;
                byte 							FFA_day;
                byte 							FFA_weekday;
                byte 							FFA_hours;
                byte 							FFA_minutes;
                byte 							FFA_seconds;
        } FloatFloatToDateTimeParams;</PRE>
<P>
The <CODE>
FloatFloatToDateTime</CODE>
 structure is used to pass and return information for the formatting of date and time strings.</P>
<DL>
<DT>
<STRONG>
FFA_dateTimeFlags</STRONG>
 </DT><DD>
This <CODE>
FloatFloatToDateTimeFlags</CODE>
 field fine-tunes the way in which to format the date string.</DD>
<DT>
<STRONG>
FFA_year</STRONG>
 </DT>
<DT>
<STRONG>
FFA_month</STRONG>
 </DT>
<DT>
<STRONG>
FFA_day</STRONG>
 </DT>
<DT>
<STRONG>
FFA_weekday</STRONG>
 </DT>
<DT>
<STRONG>
FFA_hours</STRONG>
 </DT>
<DT>
<STRONG>
FFA_minutes</STRONG>
 </DT>
<DT>
<STRONG>
FFA_seconds</STRONG>
 </DT><DD>
These fields will be used to return the various parts of the date/time.</DD>
</DL>
<PRE CLASS="syntax">        typedef WordFlags FloatFloatToDateTimeFlags;
        #define FFDT_DATE_TIME_OP 				0x8000
        #define FFDT_FROM_ADDR 				0x4000
        #define FFDT_FORMAT 				0x3fff</PRE>
<P>
The <CODE>
FloatFloatToDateTimeFlags</CODE>
 field determines how the date/time should be formated.</P>
<DL>
<DT>
FFDTT_DATE_TIME_OP</DT><DD>
Set this flag.</DD>
<DT>
FFDTT_FROM_ADDR</DT><DD>
Set this flag to convert the number passed as the <EM>
number</EM>
 argument instead of the top number on the floating point stack.</DD>
<DT>
FFDTT_FORMAT</DT><DD>
This is a <CODE>
DateTimeFormat</CODE>
 value.</DD>
</DL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_2f.htm#IX_FloatFloatToAscii_StdFormat()">FloatFloatToAscii_StdFormat()</A></CODE>.</P>
</DIV>

<DIV>
<A NAME="R_2e.htm_IX_FloatFloatToAscii_StdFormat()">
 </A>
<H1 CLASS="refHeading">
FloatFloatToAscii_StdFormat()</H1>
<PRE CLASS="syntax">word FloatFloatToAscii_StdFormat(
        char 					*string, 
        FloatNum 					*number,
        FloatFloatToAsciiFormatFlags 					format,
        word 					numDigits, 
        word 					numFractionalDigits)</PRE>
<P>
This routine formats a floating point number as an ASCII string. It is similar in purpose to <CODE>
<A HREF="../../CRef/Routines/R_2e.htm#IX_FloatFloatToAscii()">FloatFloatToAscii()</A></CODE>
. However, this routine does not require the use of the daunting <CODE>
FFA_stackFrame</CODE>
 data structure. It has the following arguments:</P>
<DL>
<DT>
<STRONG>
string</STRONG>
</DT><DD>Buffer to hold the converted string. This buffer must be at least FLOAT_TO_ASCII_NORMAL_BUF_LEN or FLOAT_TO_ASCII_HUGE_BUF_LEN.</DD>
<DT>
<STRONG>
number</STRONG>
</DT><DD>If you pass FFAF_FROM_ADDR, this should be a pointer to a number to convert; otherwise the top number on the floating point stack will be popped and converted. </DD>
<DT>
<STRONG>
format</STRONG>
</DT><DD>This is a flags field of type <CODE>
FloatFloatToAsciiFormatFlags</CODE>
. This data type is discussed under <CODE>
<A HREF="../../CRef/Routines/R_2e.htm#IX_FloatFloatToAscii()">FloatFloatToAscii()</A></CODE>
. The following flags are permitted: FFAF_FROM_ADDR, FFAF_SCIENTIFIC, FFAFF_PERCENT, FFAF_USE_COMMAS, FFAF_NO_TRAIL_ZEROS.</DD>
<DT>
<STRONG>
numDigits</STRONG>
</DT><DD>The number of significant digits desired.</DD>
<DT>
<STRONG>
numFranctionalDigits</DT><DD>
</STRONG>
The number of digits which may follow the decimal sign.</DD>
</DL>
<P>
The routine returns the number of characters in the resulting string, or zero if there was an error.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_2e.htm#IX_FloatFloatToAscii()">FloatFloatToAscii()</A></CODE>.</P>
</DIV>

<HR>
<A NAME="R_FoamCancel.htm"></A>



<DIV>
<A NAME="R_FoamCancel.htm_IX_FoamCancelIfNoFreeSpace()">
 </A>
<H1 CLASS="refHeading">
FoamCancelIfNoFreeSpace()</H1>
<PRE CLASS="syntax">Boolean FoamCancelIfNoFreeSpace();</PRE>
<P>
Puts up an error dialog box if free disk space is below "full" level.
This should be used <EM>before</EM>any editable view is opened (or before
any operation that will consume disk space).</P>

<P CLASS="refField"><STRONG>
Pass:   </STRONG> None.
</P>

<P CLASS="refField"><STRONG>
Return:</STRONG>
TRUE if out of disk space. FALSE if free space
is below full level.</P>

<P CLASS="refField"><STRONG>
Warning:</STRONG>
This routine may resize LMem and/or object blocks, moving them on the heap
and invalidating stored pointers to them.
</P>

<P CLASS="refField"><STRONG>
Include:</STRONG>        <STRONG CLASS="fileName">
foam.goh</STRONG>
 </P>

<P CLASS="refField"><STRONG>
See Also:</STRONG>
<CODE>FoamCheckIfOutOfSpace()</CODE>
 </P>

</DIV>


<DIV>
<A NAME="R_FoamCancel.htm_IX_FoamCheckIfOutOfSpace()">
 </A>
<H1 CLASS="refHeading">
FoamCheckIfOutOfSpace()</H1>
<PRE CLASS="syntax">FoamDiskSpaceStatus    FoamCheckIfOutOfSpace();</PRE>
<P>
Determines what level the free disk space has reached. Routines which
call this can silently reject an operation if the level of disk space
is insufficient.
</P>

<P CLASS="refField"><STRONG>
Pass:   </STRONG>
None
</P>

<P CLASS="refField"><STRONG>
Return:</STRONG>
        A <CODE>FoamDiskSpaceStatus</CODE> value that indicates how much
free disk space is left. These values may be:
<UL>
<LI>FDSS_NOT_FULL (free space &GT 50K)
<LI>FDSS_NEARLY_FULL (25K &LT free space &LT 50K)
<LI>FDSS_FULL (free space &LT 25K)
</UL>
</P>

<P CLASS="refField"><STRONG>
Include:</STRONG>        <STRONG CLASS="fileName">
foam.goh</STRONG>
 </P>

<P CLASS="refField"><STRONG>
See Also:</STRONG>
<CODE>FoamCancelIfNoFreeSpace()</CODE>
 </P>

</DIV>


<HR>
<A NAME="R_FoamDBAdd.htm"></A>
<DIV>
</DIV>

<DIV>
<A NAME="R_FoamDBAdd.htm_IX_FoamDBAddFieldToRecord()">
 </A>
<H1 CLASS="refHeading">
FoamDBAddFieldToRecord()</H1>
<PRE CLASS="syntax"> FieldID FoamDBAddFieldToRecord(
        VMFileHandle       file, 
        MemHandle       record, 
        byte       *fieldName, 
        word       fieldType);
</PRE>
<P>
Adds a field to the record <EM>record</EM> and gives it the name <EM>fieldName</EM>. A unique <CODE>FieldID</CODE> is assigned to the new field and returned.  The Foam Database uses the <EM>fieldType</EM> to determine the sort order of the records (i.e., a field of type "3" will be inserted after all the existing fields of type "3", but before the fields of type "4"). If you are using this routine within the context of a <CODE>ContDB</CODE>, then <EM>fieldType</EM> should be one of the <CODE>ContdbFieldType</CODE> values (see below).  Otherwise, you may set your own field type.
<P>
<PRE CLASS="syntax">
	/*
 	* The standard field types in the contact database
 	*/
	typedef ByteEnum ContdbFieldType;
	#define CFT_NAME        0
	#define CFT_COMPANY     1
	#define CFT_TITLE       2
	#define CFT_ADDRESS     3
	#define CFT_PHONE       4
	#define CFT_FAX         5
	#define CFT_EMAIL       6
	#define CFT_DTMF        7
	#define CFT_NOTES       8
	/* Only available in Communicator products after Feb 1997: */
	#define CFT_URL         9
	#define CFT_PASSWORD    10
	#define CFT_TEL_FAX     11
	#define CFT_TEL_DATA    12 
</PRE>

<P CLASS="refField"><STRONG>
Include:</STRONG>        <STRONG CLASS="fileName">
foamdb.h </STRONG>
</P>
</DIV>


<DIV>
<A NAME="R_FoamDBAdd.htm_IX_FoamDBBinarySearch()">
 </A>
<H1 CLASS="refHeading">
FoamDBBinarySearch()</H1>
<PRE CLASS="syntax">RecordID   FoamDBBinarySearch(
		VMFileHandle file,
		MemHandle record,
		PCB(int, callback,		
			(void * passedRecord,	 /* Callback routine */
			void * curRecord )));

</PRE>
<P>
This routine performs a binary search of the Foam database <EM>file</EM> to determine the index of <EM>record</EM>. The database is sorted according to an application-defined callback routine, so <CODE>FoamDBBinarySearch()</CODE> can find <EM>record</EM> in a divide-and-conquer method using a callback routine based on the same sorting scheme. If this routine finds <EM>record</EM>, it returns the <CODE>RecordID</CODE> of this record in the database; otherwise, it returns where this record would belong in the database.
<P>
(<A HREF="#R_80.htm_IX_PCB()"><CODE>PCB</CODE></A> is a GEOS macro that defines a callback routine.) The prototype for this callback routine should be of the form:

<PRE class = "syntax">
      int  _pascal  MyCallBackRoutine(void * passedRecord, void * curRecord);
</PRE>

The callback routine should return +1 if the record <EM>passedRecord</EM> comes after <EM>curRecord</EM>, -1 if <EM>passedRecord</EM> comes before <EM>curRecord</EM>, and 0 if the items match.

<P CLASS="refField">
Include:        <STRONG CLASS="fileName">
foamdb.h </STRONG>
</P>
</DIV>




<DIV>
<A NAME="R_FoamDBAdd.htm_IX_FoamDBClose()">
 </A>
<H1 CLASS="refHeading">
FoamDBClose()</H1>
<PRE CLASS="syntax">word FoamDBClose(
        VMFileHandle    file);
</PRE>
<P>
Closes the file. It is the same as <CODE>
<A HREF="../../CRef/Routines/R_a2.htm#IX_VMClose()">VMClose()</A></CODE>. 
If successful, returns non-zero; if an error occurred, then it returns <CODE>FALSE</CODE> and the error value must be retrieved by <CODE>
<A HREF="../../CRef/Routines/R_97.htm#IX_ThreadGetError()">ThreadGetError().</A></CODE>
<P CLASS="refField"><STRONG>
Include:</STRONG>        <STRONG CLASS="fileName">
foamdb.h </STRONG>
</P>
</DIV>

<DIV>
<A NAME="R_FoamDBAdd.htm_IX_FoamDBCreateEmptyRecord()">
 </A>
<H1 CLASS="refHeading">
FoamDBCreateEmptyRecord()</H1>
<PRE CLASS="syntax">MemHandle FoamDBCreateEmptyRecord(
        VMFileHandle    file);
</PRE>
<P>
Creates a new record in the database, gives it a unique ID, and returns
 the handle of the record data. This record will contain no fields or data.
 This record does not get saved to the database unless <CODE>
<A HREF="../../CRef/Routines/R_FoamDBResumeUpdates.htm#IX_FoamDBSaveRecord()">FoamDBSaveRecord()</A></CODE>
 is called. 
<P CLASS="refField"><STRONG>
<STRONG>Warning:</STRONG></STRONG> If you want to free the memory associated with a record, <STRONG>do not</STRONG> use <CODE>
<A HREF="../../CRef/Routines/R_6c.htm#IX_MemFree()">MemFree()</A></CODE>; 
instead call
<CODE><A HREF="../../CRef/Routines/R_FoamDBAdd.htm#IX_FoamDBDiscardRecord()">FoamDBDiscardRecord()</A></CODE>
to discard any record changes or 
<CODE><A HREF="../../CRef/Routines/R_FoamDBResumeUpdates.htm#IX_FoamDBSaveRecord()">FoamDBSaveRecord()</A></CODE>
to commit them to the the database.</P>

<P CLASS="refField"><STRONG>
Include:</STRONG>        <STRONG CLASS="fileName">
foamdb.h </STRONG>
</P>
</DIV>

<DIV>
<A NAME="R_FoamDBAdd.htm_IX_FoamDBDeleteFieldFromRecord()">
 </A>
<H1 CLASS="refHeading">
FoamDBDeleteFieldFromRecord()</H1>
<PRE CLASS="syntax">void FoamDBDeleteFieldFromRecord(
        VMFileHandle    file,
        MemHandle       record,
        FieldID            id);     /* Field to delete */
</PRE>
<P>
Deletes field ID <EM>id</EM> from the <EM>record</EM> of the database <EM>file</EM>. <EM>id</EM> is the ID of the field as returned from 
<CODE><A HREF="../../CRef/Routines/R_FoamDBAdd.htm#IX_FoamDBAddFieldToRecord()">FoamDBAddFieldToRecord()</A></CODE>.
While it's not a pretty solution, you can also get the <CODE>FieldID</CODE> of a field from the <CODE>FH_id</CODE> part of the <CODE>FieldHeader</CODE> struct. 
<P CLASS="refField"><STRONG>
Include:</STRONG>        <STRONG CLASS="fileName">
foamdb.h </STRONG>
</P>
</DIV>

<DIV>
<A NAME="R_FoamDBAdd.htm_IX_FoamDBDeleteRecord()">
 </A>
<H1 CLASS="refHeading">
FoamDBDeleteRecord()</H1>
<PRE CLASS="syntax">Boolean FoamDBDeleteRecord(
	VMFileHandle 	file, 
	MemHandle 	record);    /* Record to terminated */
</PRE>
<P>
This routine frees up the record data in <EM>record</EM>, and, if the record exists in the
 database, deletes it from the database as well.
 <P>
 Returns non-zero if the record did not exist in the database.
<P CLASS="refField"><STRONG>
Include:</STRONG>        <STRONG CLASS="fileName">
foamdb.h </STRONG>
</P>
</DIV>

<DIV>
<A NAME="R_FoamDBAdd.htm_IX_FoamDBDiscardRecord()">
 </A>
<H1 CLASS="refHeading">
FoamDBDiscardRecord()</H1>
<PRE CLASS="syntax">void FoamDBDiscardRecord(
	VMFileHandle 	file, 
	MemHandle 	record);
</PRE>
<P>
This routine discards any changes to the passed record <EM>record</EM> and frees up the record data stored in the passed handle, but does nothing to the data stored in the database file.
<P CLASS="refField"><STRONG>
Include:</STRONG>        <STRONG CLASS="fileName">
foamdb.h </STRONG>
</P>
</DIV>



<DIV>
<A NAME="R_FoamDBAdd.htm_IX_FoamDBDuplicateRecord()">
 </A>
<H1 CLASS="refHeading">
FoamDBDuplicateRecord()</H1>
<PRE CLASS="syntax">MemHandle FoamDBDuplicateRecord(
        VMFileHandle    file,
        MemHandle       record);
</PRE>
<P>
Duplicates an existing record <EM>record</EM> of FoamDB <EM>file</EM>, assigns a new ID to it, and returns the handle of the duplicate.
<P CLASS="refField"><STRONG>
<STRONG>Warning:</STRONG></STRONG> As with <CODE>
<A HREF="../../CRef/Routines/R_FoamDBAdd.htm#IX_FoamDBCreateEmptyRecord()">FoamDBCreateEmptyRecord()</A></CODE>, 
the record must eventually be saved or destroyed by calling <CODE>
<A HREF="../../CRef/Routines/R_FoamDBAdd.htm#IX_FoamDBDiscardRecord()">FoamDBDiscardRecord()</A></CODE>
or <CODE>
<A HREF="../../CRef/Routines/R_FoamDBResumeUpdates.htm#IX_FoamDBSaveRecord()">FoamDBSaveRecord()</A></CODE>.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>        <STRONG CLASS="fileName">
foamdb.h </STRONG>
</P>
</DIV>

<DIV>
<A NAME="R_FoamDBAdd.htm_IX_FoamDBFieldEnum()">
 </A>
<H1 CLASS="refHeading">
FoamDBFieldEnum()</H1>
<PRE CLASS="syntax">Boolean FoamDBFieldEnum(
        MemHandle record, 
        void *enumData,
        PCB(Boolean, callback,  /* Non-zero to stop enum */
                (FieldHeader *field,  void *callbackEnumData)));      /* Callback routine */
</PRE>
<P>
This routine essentially "walks" through each field in the specified
    <EM>record</EM> and invokes the specified callback routine for each
    field.  <EM>enumData</EM> can point to the initial value of an
    application-defined buffer or data structure if one is used by 
    the callback routine, otherwise it can be ignored.  This pointer is passed to the callback routine.
</P>
<P>
The callback routine accepts two parameters; a pointer to the current field <EM>field</EM>, and some application-defined data <EM>callbackEnumData</EM>. <EM>callbackEnumData</EM> 
  may be used to store information between different calls to the callback
 routine such as storing the longest string yet found or performing
 complex filtering on the record (in which case <EM> callbackEnumData </EM> could
  point to an array of field IDs gathered from the field pointer).
To end the enumeration before reaching the last field in the
  record, return <CODE>TRUE</CODE> (or any non-zero value) from the callback  routine. 
<P>
To use the callback routine:
<P>
<PRE CLASS="syntax">
/*
 * Prototype of callback routine
 */
Boolean _pascal ExampleCallback (FieldHeader *field, void *callbackEnumData);
...
/* 
 * Call FoamDBFieldEnum() 
 */
ok = FoamDBFieldEnum(recordHandle, &someDataStruct, ExampleCallback);
</PRE>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_FoamDBGetCurrent.htm#IX_FoamDBLockedRecordEnum()">FoamDBLockedRecordEnum()</A></CODE>.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>        <STRONG CLASS="fileName">
foamdb.h </STRONG>
</P>
</DIV>
<HR>
<A NAME="R_FoamDBGetCurrent.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_FoamDBGetCurrent.htm_IX_FoamDBGetCurrentRecordID()">
 </A>
<H1 CLASS="refHeading">
FoamDBGetCurrentRecordID()</H1>
<PRE CLASS="syntax">RecordID FoamDBGetCurrentRecordID(
	VMFileHandle 	file);
</PRE>
<P>
Returns the <CODE>RecordID</CODE> that would be set for the next record in the database <EM>file</EM>. 
<P CLASS="refField"><STRONG>
Include:</STRONG>        <STRONG CLASS="fileName">
foamdb.h </STRONG>
</P>
</DIV>

<DIV>
<A NAME="R_FoamDBGetCurrent.htm_IX_FoamDBGetFieldData()">
 </A>
<H1 CLASS="refHeading">
FoamDBGetFieldData()</H1>
<PRE CLASS="syntax"> word FoamDBGetFieldData(
        VMFileHandle    file, 
        MemHandle       record, 
        FieldID             id, 
        char            *dest,      /* Buffer to store data */
        word            maxBytesToGet);      /* # bytes of data */
</PRE>
<P>
    Copies the data from the specified field of <EM>record</EM> into the
    buffer <EM>dest</EM>.  <EM>maxBytesToGet</EM> specifies the maximum
    number of bytes to copy into the buffer.
<P>
    Returns the number of bytes actually copied.
<P CLASS="refField"><STRONG>
<STRONG>Warning:</STRONG></STRONG> The standard and most efficient way to store string data is without a null terminator, so when working with string data be sure to use the returned data size.  </P>
<P CLASS="refField"><STRONG>
Include:</STRONG>        <STRONG CLASS="fileName">
foamdb.h </STRONG>
</P>
</DIV>

<DIV>
<A NAME="R_FoamDBGetCurrent.htm_IX_FoamDBGetFieldName()">
 </A>
<H1 CLASS="refHeading">
FoamDBGetFieldName()</H1>
<PRE CLASS="syntax">Boolean FoamDBGetFieldName(
	VMFileHandle    file, 
	MemHandle       record, 
	FieldID            id, 
	TCHAR   *dest,     /* Buffer to put name (null-terminated) */
	word            maxBytesToGet);     /* Number of characters to get */
</PRE>
<P>
Copies the name of the field ID <EM>id</EM> into the buffer <EM>dest</EM>.
<P>
Returns zero if field exists, non-zero if it doesn't. 
<P CLASS="refField"><STRONG>
<STRONG>Warning:</STRONG></STRONG> Field names are null-terminated. </P>
<P CLASS="refField"><STRONG>
Include:</STRONG>        <STRONG CLASS="fileName">
foamdb.h </STRONG>
</P>
</DIV>

<DIV>
<A NAME="R_FoamDBGetCurrent.htm_IX_FoamDBGetFieldType()">
 </A>
<H1 CLASS="refHeading">
FoamDBGetFieldType()</H1>
<PRE CLASS="syntax"> Boolean FoamDBGetFieldType(
        VMFileHandle    file, 
        MemHandle       record, 
        FieldID            id, 
        byte            *type);
</PRE>
<P>
Gets the type of field ID <EM>id</EM> and puts it into <EM>type</EM>. Note that this type is a <CODE>ContdbFieldType</CODE>.
<P>
Returns zero if field exists, non-zero if it does not.
<P CLASS="refField"><STRONG>
Include:</STRONG>        <STRONG CLASS="fileName">
foamdb.h </STRONG>
</P>
</DIV>

<DIV>
<A NAME="R_FoamDBGetCurrent.htm_IX_FoamDBGetNextPrevRecord()">
 </A>
<H1 CLASS="refHeading">
FoamDBGetNextPrevRecord()</H1>
<PRE CLASS="syntax">dword FoamDBGetNextPrevRecord(
	VMFileHandle 	file, 
	RecordID 	record,
	word 		count);
</PRE>
<P>
This routine returns the index into the huge array of a record <EM>count</EM> records away from the record with the <CODE>RecordID</CODE> <EM>record</EM>. <EM>count</EM> can be negative or positive, so this routine lets you move forwards or backwards through the database. Should the requested record be invalid, either because there is no record with <CODE>RecordID</CODE> <EM>record</EM> or the requested index is beyond the bounds of the database, this routine will return <EM>record</EM>.
<P CLASS="refField"><STRONG>
Include:</STRONG>        <STRONG CLASS="fileName">
foamdb.h </STRONG>
</P>
</DIV>

<DIV>
<A NAME="R_FoamDBGetCurrent.htm_IX_FoamDBGetNumVisibleRecords()">
 </A>
<H1 CLASS="refHeading">
FoamDBGetNumVisibleRecords()</H1>
<PRE CLASS="syntax">dword	FoamDBGetNumVisibleRecords(
	VMFileHandle 	file);
</PRE>
<P>
This routine returns the number of visible records in the database <EM>file</EM>. This is often used when providing a list of records to a user.
<P CLASS="refField"><STRONG>
Include:</STRONG>        <STRONG CLASS="fileName">
foamdb.h </STRONG>
</P>
</DIV>

<DIV>
<A NAME="R_FoamDBGetCurrent.htm_IX_FoamDBGetRecordFromID()">
 </A>
<H1 CLASS="refHeading">
FoamDBGetRecordFromID()</H1>
<PRE CLASS="syntax">MemHandle FoamDBGetRecordFromID(
	VMFileHandle 	file, 
	RecordID 	id);
</PRE>
<P>
This routine looks for a record in the database with the ID <EM>id</EM>, copies it
 into memory, and returns the handle. If no record in the database had
the passed ID, this routine returns <CODE>NullHandle</CODE>.
 
<P CLASS="refField"><STRONG>
<STRONG>Warning:</STRONG></STRONG>
The handle returned should be freed using 
<CODE><A HREF="../../CRef/Routines/R_FoamDBAdd.htm#IX_FoamDBDeleteRecord()">FoamDBDeleteRecord()</A></CODE>, 
<CODE><A HREF="../../CRef/Routines/R_FoamDBAdd.htm#IX_FoamDBDiscardRecord()">FoamDBDiscardRecord()</A></CODE>, or 
<CODE><A HREF="../../CRef/Routines/R_FoamDBResumeUpdates.htm#IX_FoamDBSaveRecord()">FoamDBSaveRecord()</A></CODE>.
<P CLASS="refField"><STRONG>
Include:</STRONG>        <STRONG CLASS="fileName">
foamdb.h </STRONG>
</P>
</DIV>

<DIV>
<A NAME="R_FoamDBGetCurrent.htm_IX_FoamDBGetRecordID()">
 </A>
<H1 CLASS="refHeading">
FoamDBGetRecordID()</H1>
<PRE CLASS="syntax">RecordID FoamDBGetRecordID(
        MemHandle       record);
</PRE>
<P>
Given a record handle, returns the <CODE>RecordID</CODE> of the record.
<P CLASS="refField"><STRONG>
Include:</STRONG>        <STRONG CLASS="fileName">
foamdb.h </STRONG>
</P>
</DIV>

<DIV>
<A NAME="R_FoamDBGetCurrent.htm_IX_FoamDBGetVisibleRecord()">
 </A>
<H1 CLASS="refHeading">
FoamDBGetVisibleRecord()</H1>
<PRE CLASS="syntax">MemHandle FoamDBGetVisibleRecord(
	VMFileHandle 	file, 
	dword 	index);
</PRE>
<P>
This routine finds the visible record with the index of <EM>index</EM>, copies the data into memory,
 and returns the handle of the block to the caller. If <EM>index</EM> is out of bounds, <CODE>
FoamDBGetVisibleRecord()</CODE>
returns NullHandle.

<P CLASS="refField"><STRONG>
<STRONG>Warning:</STRONG></STRONG>
The handle returned should be freed using <CODE>
<A HREF="../../CRef/Routines/R_FoamDBAdd.htm#IX_FoamDBDeleteRecord()">FoamDBDeleteRecord()</A></CODE>, 
<CODE><A HREF="../../CRef/Routines/R_FoamDBAdd.htm#IX_FoamDBDiscardRecord()">FoamDBDiscardRecord()</A></CODE>, or <CODE>
<A HREF="../../CRef/Routines/R_FoamDBResumeUpdates.htm#IX_FoamDBSaveRecord()">FoamDBSaveRecord().</A></CODE>
</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>        <STRONG CLASS="fileName">
foamdb.h </STRONG>
</P>
</DIV>

<DIV>
<A NAME="R_FoamDBGetCurrent.htm_IX_FoamDBLockedRecordEnum()">
 </A>
<H1 CLASS="refHeading">
FoamDBLockedRecordEnum()</H1>
<PRE CLASS="syntax">Boolean FoamDBLockedRecordEnum(
        MemHandle record, 
        void *enumData,
        PCB(Boolean, callback,  /* Non-zero to stop enum */
                (FieldHeader *field,  void *callbackEnumData)));      /* Callback routine */
</PRE>
<P>
This routine calls a callback routine for each field in a locked down record. The callback routine is used the same way as in 
<CODE><A HREF="../../CRef/Routines/R_FoamDBAdd.htm#IX_FoamDBFieldEnum()">FoamDBFieldEnum()</A></CODE>. 
It should be of the prototype
<PRE CLASS="syntax">
/*
 * Prototype of callback routine
 */
Boolean _pascal ExampleCallback (FieldHeader *field, void *callbackEnumData);
</PRE>
<P CLASS="refField"><STRONG>
Include:</STRONG>        <STRONG CLASS="fileName">
foamdb.h </STRONG>
</P>
</DIV>
<DIV>
<A NAME="R_FoamDBGetCurrent.htm_IX_FoamDBMapNameToToken()">
 </A>
<H1 CLASS="refHeading">
FoamDBMapNameToToken()</H1>
<PRE CLASS="syntax">Boolean FoamDBMapNameToToken(
	VMFileHandle 	file, 
	TCHAR 	*nameToLookFor, 
	word 	*token);
</PRE>
<P>
This routine looks up the field named <EM>nameToLookFor</EM> in the database <EM>file</EM> and checks to see if any fields have that name.
<P>
Returns <CODE>TRUE</CODE> (-1) if found, <CODE>FALSE</CODE> (0) if not found. <EM>token</EM> will be the index to the element within the <CODE>FieldName</CODE>
element array.  This is not something that will normally be used by an application.
<P CLASS="refField"><STRONG>
Include:</STRONG>        <STRONG CLASS="fileName">
foamdb.h </STRONG>
</P>
</DIV>

<DIV>
<A NAME="R_FoamDBGetCurrent.htm_IX_FoamDBMapTokenToName()">
 </A>
<H1 CLASS="refHeading">
FoamDBMapTokenToName()</H1>
<PRE CLASS="syntax">Boolean FoamDBMapTokenToName(
	VMFileHandle file, 
	word nameToken, 
	word maxBytesToCopy, 
	TCHAR *dest);
</PRE>
<P>
This routine finds the field name associated with the token <EM>nameToken</EM> in the database file <EM>file</EM>, and copies at maximum <EM>maxBytesToCopy</EM> bytes of that name into the buffer <EM>dest</EM>. The routine returns non-zero if the token was out of bounds.
<P CLASS="refField"><STRONG>
<STRONG>Warning:</STRONG></STRONG> Field names are null-terminated.
<P CLASS="refField"><STRONG>
Include:</STRONG>        <STRONG CLASS="fileName">
foamdb.h </STRONG>
</P>
</DIV>


<DIV>
<A NAME="R_FoamDBGetCurrent.htm_IX_FoamDBOpen()">
 </A>
<H1 CLASS="refHeading">
FoamDBOpen()</H1>
<PRE CLASS="syntax">VMFileHandle  FoamDBOpen(
        char *filename,         
        word mapBlockSize, 
        word majorProtocol,    /* Existing file protocol must match major and minor protocols */
        word minorProtocol);
</PRE>
<P>
Opens an existing database file <EM>filename</EM>, or creates a new one if it does not
 currently exist. Returns the handle of the database file or NullHandle if the
 file could not be opened. <CODE>
<A HREF="../../CRef/Routines/R_97.htm#IX_ThreadGetError()">ThreadGetError()</A></CODE>
can be called to return the
 error type, which is the error returned from <CODE>
<A HREF="../../CRef/Routines/R_a3.htm#IX_VMOpen()">VMOpen()</A></CODE>, or -1 if there was
 a protocol mismatch.
 <P>
 <EM>mapBlockSize</EM> is used to specify the size of the map block for the database.
 The default (minimum) size is <CODE>sizeof(FoamDBMap)</CODE>, but more space can
 be allocated if the application needs to store extra data in the map block.
<P>
 When creating a new file, the new file will be assigned the protocol number
 passed in <EM>majorProtocol</EM> and <EM>minorProtocol</EM>. When opening an existing file,
 the protocol number of the file is compared against the protocol number
 passed in <EM>majorProtocol</EM> and <EM>minorProtocol</EM>, and if they do not match, an
 error of -1 is returned.
<P CLASS="refField"><STRONG>
Include:</STRONG>        <STRONG CLASS="fileName">
foamdb.h </STRONG>
</P>
</DIV>

<DIV>
<A NAME="R_FoamDBGetCurrent.htm_IX_FoamDBResortDatabase()">
 </A>
<H1 CLASS="refHeading">
FoamDBResortDatabase()</H1>
<PRE CLASS="syntax">void FoamDBResortDatabase(
	VMFileHandle file, 
	PCB(sword, callback,
		(RecordHeader *record1, RecordHeader *record2)));   /* Callback Routine */
</PRE>
<P>
This routine resorts the database <EM>file</EM> using the application-defined callback function to determine record order. As with the routine 
<CODE><A HREF="../../CRef/Routines/R_FoamDBResumeUpdates.htm#IX_FoamDBSaveRecord()">FoamDBSaveRecord()</A></CODE>, 
the callback routine should return -1 if <EM>record1</EM> should come before <EM>record2</EM>, or +1 if <EM>record1</EM> should come after <EM>record2</EM> in the database. The prototype for the callback routine should look like:
<P>
<PRE class="syntax">
sword _pascal MyCallBackRoutine(RecordHeader *record1, RecordHeader *record2);
</PRE>
<P CLASS="refField"><STRONG>
Include:</STRONG>        <STRONG CLASS="fileName">
foamdb.h </STRONG>
</P>
</DIV>

<DIV>
<A NAME="R_FoamDBGetCurrent.htm_IX_FoamDBResumeNotifications()">
 </A>
<H1 CLASS="refHeading">
FoamDBResumeNotifications()</H1>
<PRE CLASS="syntax">void FoamDBResumeNotifications(
	VMFileHandle 	file);</PRE>
<P>
This routine resumes the generation of notifications for the database <EM>file</EM>. These notifications are <CODE>FoamDBActionType</CODE>s.
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_FoamDBResumeUpdates.htm#IX_FoamDBSuspendNotifications()">FoamDBSuspendNotifications()</A></CODE>.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>        <STRONG CLASS="fileName">
foamdb.h </STRONG>
</P>
</DIV>
<HR>
<A NAME="R_FoamDBResumeUpdates.htm"></A>
<DIV>
</DIV>

<DIV>
<A NAME="R_FoamDBResumeUpdates.htm_IX_FoamDBResumeUpdates()">
 </A>
<H1 CLASS="refHeading">
FoamDBResumeUpdates()</H1>
<PRE CLASS="syntax">void FoamDBResumeUpdates(
	VMFileHandle 	file);</PRE>
<P>
This routine resumes the generation of updates for the database <EM>file</EM>. 
<P CLASS="refField"><STRONG>
Include:</STRONG>        <STRONG CLASS="fileName">
foamdb.h </STRONG>
</P>
</DIV>

<DIV>
<A NAME="R_FoamDBResumeUpdates.htm_IX_FoamDBSaveRecord()">
 </A>
<H1 CLASS="refHeading">
FoamDBSaveRecord()</H1>
<PRE CLASS="syntax">dword FoamDBSaveRecord(
	VMFileHandle file, 
	MemHandle record,
	PCB(sword, callback,
		(RecordHeader *record1,  RecordHeader *record2)));    /* Callback routine */
</PRE>
<P>
This routine saves the record <EM>record</EM> in the database file <EM>file</EM>, and frees up the passed memory block containing the record data. The callback routine determines where in the database the record should be stored. The <CODE>Contdb</CODE> library provides a front-end to this routine, <CODE>
<A HREF="../../CRef/Routines/R_f.htm#IX_ContactSaveRecord()">ContactSaveRecord()</A></CODE>, 
which should be used when saving records to a contact database.
<P>

<CODE>
<A HREF="../../CRef/Routines/R_80.htm#IX_PCB()">PCB()</A></CODE>
is a GEOS macro which signifies that one of the parameters for <CODE>
FoamDBSaveRecord()</CODE>
will be a callback routine that will return a <CODE>sword</CODE> and accept two <CODE>RecordHeader</CODE>s. This callback routine should be declared as:
<PRE class = "syntax">
sword _pascal MyCallBackRoutine(RecordHeader *record1, RecordHeader *record2);
</PRE>
<P>
It should return -1 if <EM>record1</EM> should come before <EM>record2</EM>, or +1 if <EM>record1</EM> should come after <EM>record2</EM> in the database.
<P CLASS="refField"><STRONG>
Include:</STRONG>        <STRONG CLASS="fileName">
foamdb.h </STRONG>
</P>
</DIV>

<DIV>
<A NAME="R_FoamDBResumeUpdates.htm_IX_FoamDBSetCurrentRecordID()">
 </A>
<H1 CLASS="refHeading">
FoamDBSetCurrentRecordID()</H1>
<PRE CLASS="syntax">void FoamDBSetCurrentRecordID(
	VMFileHandle 	file, 
	RecordID 	id);
</PRE>
<P>
Sets the record ID that will be used for the next created record.
<P CLASS="refField"><STRONG>
Include:</STRONG>        <STRONG CLASS="fileName">
foamdb.h </STRONG>
</P>
</DIV>

<DIV>
<A NAME="R_FoamDBResumeUpdates.htm_IX_FoamDBSetFieldData()">
 </A>
<H1 CLASS="refHeading">
FoamDBSetFieldData()</H1>
<PRE CLASS="syntax"> void FoamDBSetFieldData(
        VMFileHandle    file, 
        MemHandle       record, 
        FieldID            id, 
        char            *data,          /* Data to be stored */
        word            dataSize);      /* How many bytes of data */
</PRE>
<P>
Stores <EM>dataSize</EM> bytes of <EM>data</EM> in the field ID <EM>id</EM> of <EM>record</EM>. 
<P CLASS="refField"><STRONG>
<STRONG>Warning:</STRONG></STRONG> When storing ASCII data (strings), the strings should <STRONG>not</STRONG> be null terminated. For example, if you want to store the string "<CODE>ABCD</CODE>", then let <EM>data</EM> be a pointer to the string and let <EM>dataSize</EM> equal 4.
<P CLASS="refField"><STRONG>
Include:</STRONG>        <STRONG CLASS="fileName">
foamdb.h </STRONG>
</P>
</DIV>

<DIV>
<A NAME="R_FoamDBResumeUpdates.htm_IX_FoamDBSetFieldName()">
 </A>
<H1 CLASS="refHeading">
FoamDBSetFieldName()</H1>
<PRE CLASS="syntax">void FoamDBSetFieldName(
        VMFileHandle    file, 
        MemHandle       record, 
        FieldID            id, 
        char            *name);
</PRE>
<P>
Changes the name of the field with the ID <EM>id</EM> of <EM>record</EM> to <EM>name</EM>. 
<P CLASS="refField"><STRONG>
<STRONG>Warning:</STRONG></STRONG> <EM>name</EM> is a null-terminated string.
<P CLASS="refField"><STRONG>
Include:</STRONG>        <STRONG CLASS="fileName">
foamdb.h </STRONG>
</P>
</DIV>

<DIV>
<A NAME="R_FoamDBResumeUpdates.htm_IX_FoamDBSetNameForToken()">
 </A>
<H1 CLASS="refHeading">
FoamDBSetNameForToken()</H1>
<PRE CLASS="syntax">void FoamDBSetNameForToken(
	VMFileHandle 	file, 
	word 	nameToken, 
	TCHAR 	*name);
</PRE>
<P>
Sets the name for the field identified by <EM>nameToken</EM> token
in the database's <CODE>FieldName</CODE> element array.
<P CLASS="refField"><STRONG>
<STRONG>Warning:</STRONG></STRONG> Field names are null-terminated.
<P CLASS="refField"><STRONG>
Include:</STRONG>        <STRONG CLASS="fileName">
foamdb.h </STRONG>
</P>
</DIV>
<DIV>
<A NAME="R_FoamDBResumeUpdates.htm_IX_FoamDBSuspendNotifications()">
 </A>
<H1 CLASS="refHeading">
FoamDBSuspendNotifications()</H1>
<PRE CLASS="syntax">void FoamDBSuspendNotifications(
	VMFileHandle 	file);</PRE>
<P>
This routine stops the generation of notifications to the database <EM>file</EM>. Calls to this routine
 must be matched by calls to <CODE>
<A HREF="../../CRef/Routines/R_FoamDBGetCurrent.htm#IX_FoamDBResumeNotifications()">FoamDBResumeNotifications()</A></CODE>,
<P CLASS="refField"><STRONG>
Include:</STRONG>        <STRONG CLASS="fileName">
foamdb.h </STRONG>
</P>
</DIV>

<DIV>
<A NAME="R_FoamDBResumeUpdates.htm_IX_FoamDBSuspendUpdates()">
 </A>
<H1 CLASS="refHeading">
FoamDBSuspendUpdates()</H1>
<PRE CLASS="syntax">
void FoamDBSuspendUpdates(
	VMFileHandle	 file);
</PRE>
<P>
This routine stops the generation of updates for the database <EM>file</EM>. Calls to this routine
 must be matched by calls to <CODE>
<A HREF="../../CRef/Routines/R_FoamDBResumeUpdates.htm#IX_FoamDBResumeUpdates()">FoamDBResumeUpdates()</A></CODE>.
<P CLASS="refField"><STRONG>
<STRONG>Warning:</STRONG></STRONG> It is dangerous to prevent updates.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>        <STRONG CLASS="fileName">
foamdb.h </STRONG>
</P>
</DIV>

<DIV>
<A NAME="R_FoamDBResumeUpdates.htm_IX_FoamDBVisibleRecordEnum()">
 </A>
<H1 CLASS="refHeading">
FoamDBVisibleRecordEnum()</H1>
<PRE CLASS="syntax">Boolean FoamDBVisibleRecordEnum(
	VMFileHandle file, 
	void *enumData,
	PCB(Boolean, callback,     /* Non-zero to stop enum */
		  (RecordHeader *record, void *callbackEnumData)));     /* Callback Routine */
</PRE>
This routine calls an application-specified callback routine for each visible record in the database. The
callback routine can return non-zero to stop the enumeration. <EM>enumData</EM> is a pointer to any kind of data that your application needs to pass to the callback routine and that the callback routine can modify. The callback routine can return non-zero to stop the enumeration. 
<P>
For a more complete explanation of using callback routines in a FoamDB, refer to the explanation given for the similar routine <CODE>
<A HREF="../../CRef/Routines/R_FoamDBAdd.htm#IX_FoamDBFieldEnum()">FoamDBFieldEnum()</A></CODE>. 
The callback routine should be declared as
<PRE CLASS="syntax">
/*
 * Prototype of callback routine
 */
Boolean _pascal myCallBackRoutine(RecordHeader *record, void *callbackEnumData);
</PRE> 
<P CLASS="refField"><STRONG>
Include:</STRONG>        <STRONG CLASS="fileName">
foamdb.h </STRONG>
</P>
</DIV>

<DIV>
<A NAME="R_FoamDBResumeUpdates.htm_IX_FoamDBVisibleRecordEnumWithRange()">
 </A>
<H1 CLASS="refHeading">
FoamDBVisibleRecordEnumWithRange()</H1>
<PRE CLASS="syntax"> Boolean FoamDBVisibleRecordEnumWithRange(
	VMFileHandle file, 
	void *enumData,
	dword startElement,
	dword numOfRecords,
	PCB(Boolean, callback,      /* Non-zero to stop enum */
		(RecordHeader *record, void *callbackEnumData)));     /* Callback routine */
</PRE>
<P>
This routine calls the application-specified callback routine for some visible records in the database, starting with the record number <EM>startElement</EM>, and continuing for <EM>numOfRecords</EM> records. <EM>enumData</EM> is a pointer to any kind of data that your application needs to pass to the callback routine and that the callback routine can modify. The callback routine can return non-zero to stop the enumeration.
<P>
For a more complete explanation of using callback routines in a FoamDB, refer to the explanation given for the similar routine <CODE>
<A HREF="../../CRef/Routines/R_FoamDBAdd.htm#IX_FoamDBFieldEnum()">FoamDBFieldEnum()</A></CODE>. 
The callback routine should be declared as
<PRE CLASS="syntax">
/*
 * Prototype of callback routine
 */
Boolean _pascal myCallBackRoutine(RecordHeader *record, void *callbackEnumData);
</PRE> 
<P CLASS="refField"><STRONG>
Include:</STRONG>        <STRONG CLASS="fileName">
foamdb.h </STRONG>
</P>
</DIV>

<HR>
<A NAME="R_FoamDisplay.htm"></A>


<DIV>
<A NAME="R_FoamDisplay.htm_IX_FoamDisplayDeleteWarning()">
 </A>
<H1 CLASS="refHeading">
FoamDisplayDeleteWarning()</H1>
<PRE CLASS="syntax">InteractionCommand    FoamDisplayDeleteWarning(
   optr        preText,
   TCHAR *     midText,
   optr        postText );
</PRE>
<P>
Displays a notification box that warns the user that
a file is about to be deleted.</P>

<P CLASS="refField"><STRONG>
Pass:   </STRONG>
</P>
<DL>
<DT>
<STRONG>
preText</STRONG>
</DT><DD><CODE>Optr</CODE> of the text chunk to display before the file
name; <EM>NullOptr</EM> if no text is to be displayed.</DD>
<DT>
<STRONG>
midText</STRONG>
</DT><DD>Pointer to the name of the file being deleted.</DD>
<DT>
<STRONG>
postText</STRONG>
</DT><DD><CODE>Optr</CODE> of the text chunk to display after the file
name; <EM>NullOptr</EM> if no text is to be displayed.</DD>
</DL>


<P CLASS="refField"><STRONG>
Return:</STRONG>
        Input from the user: <EM>IC_YES</EM> if okay to delete,
<EM>IC_NULL</EM> if not okay or if system couldn't create the dialog.</P>

<P CLASS="refField"><STRONG>
Warning:</STRONG>     This routine may resize LMem and/or object blocks,
moving themon the heap and invalidating stored pointers to them.
 </P>

<P CLASS="refField"><STRONG>
Include:</STRONG>        <STRONG CLASS="fileName">
foam.goh</STRONG>
 </P>

<P CLASS="refField"><STRONG>
See Also:</STRONG>     <CODE>FoamDisplayDeleteWarningNoBlock()</CODE>
 </P>

</DIV>


<DIV>
<A NAME="R_FoamDisplay.htm_IX_FoamDisplayDeleteWarningNoBlock()">
 </A>
<H1 CLASS="refHeading">
FoamDisplayDeleteWarningNoBlock()</H1>
<PRE CLASS="syntax">void FoamDisplayDeleteWarningNoBlock(
   optr  bodyText,
   word  msg,
   optr  dest );</PRE>
<P>
Displays a notification box that gives the user a delete warning.
This routine differs from <CODE>FoamDisplayDeleteWarning()</CODE> because it
does not block the caller. Instead, it displays the dialog, and
upon closure by the user it will send the specified message to
the given object.
</P>

<P CLASS="refField"><STRONG>
Pass:   </STRONG>
</P>
<DL>
<DT>
<STRONG>
bodyText</STRONG>
</DT><DD>Optr to text chunk to display in dialog.</DD>
<DT>
<STRONG>
msg</STRONG>
</DT><DD>The message to send when the user selects the &quot;Delete&quot;
option.</DD>
<DT>
<STRONG>
dest</STRONG>
</DT><DD>The object to send the message specified in msg when the
user selects the &quot;Delete&quot; option.</DD>
</DL>

<P CLASS="refField"><STRONG>
Return:</STRONG>
        None.</P>

<P CLASS="refField"><STRONG>
Warning:</STRONG>     This routine may resize <CODE>LMem</CODE> and/or
object blocks, moving them on the heap and invalidating stored
pointers to them.
</p>


<P CLASS="refField"><STRONG>
Include:</STRONG>        <STRONG CLASS="fileName">
foam.goh</STRONG>
 </P>

<P CLASS="refField"><STRONG>
See Also:</STRONG>
<CODE>FoamDisplayDeleteWarning()</CODE>
 </P>

</DIV>



<DIV>
<A NAME="R_FoamDisplay.htm_IX_FoamDisplayError()">
 </A>
<H1 CLASS="refHeading">
FoamDisplayError()</H1>
<PRE CLASS="syntax">void   FoamDisplayError(
     optr    errorText );</PRE>
<P>
Displays an error dialog box, with a single &quot;Ok&quot; trigger,
displaying the text pointed to by <EM>errorText</EM>.
Use <CODE>FoamDisplayErrorNoBlock()</CODE> if you do not want to block the
calling thread.</P>

<P CLASS="refField"><STRONG>
Pass:   </STRONG>
</P>
<DL>
<DT>
<STRONG>
errorText</STRONG>
</DT><DD>Optr to the text chunk to display in the dialog box.</DD>
</DL>

<P CLASS="refField"><STRONG>
Return:</STRONG>
        None.</P>

<P CLASS="refField"><STRONG>
Warning:</STRONG>        This routine may resize <CODE>LMem</CODE> and/or
object blocks, moving them on the heap and invalidating stored
pointers to them.</P>


<P CLASS="refField"><STRONG>
Include:</STRONG>        <STRONG CLASS="fileName">
foam.goh</STRONG>
 </P>

<P CLASS="refField"><STRONG>
See Also:</STRONG>
<CODE>FoamDisplayErrorNoBlock()</CODE>
 </P>

</DIV>



<DIV>
<A NAME="R_FoamDisplay.htm_IX_FoamDisplayErrorNoBlock()">
 </A>
<H1 CLASS="refHeading">
FoamDisplayErrorNoBlock()</H1>
<PRE CLASS="syntax">void FoamDisplayErrorNoBlock(
      optr     errorText );</PRE>
<P>
Same as the <CODE>FoamDisplayError()</CODE> routine (listed above) except
this one does not block the calling thread.</P>

<P CLASS="refField"><STRONG>
Pass:   </STRONG>
<DL>
<DT>
<STRONG>
errorText</STRONG>
</DT><DD>Optr to the text chunk to display in the dialog box.</DD>
</DL>

<P CLASS="refField"><STRONG>
Return:</STRONG> None.</P>

<P CLASS="refField"><STRONG>
Warning:</STRONG>
        This routine may resize <CODE>LMem</CODE> and/or
object blocks, moving them on the heap and invalidating stored
pointers to them.</P>

<P CLASS="refField"><STRONG>
Include:</STRONG>        <STRONG CLASS="fileName">
foam.goh</STRONG>
 </P>

<P CLASS="refField"><STRONG>
See Also:</STRONG>
<CODE>FoamDisplayError()</CODE>
 </P>

</DIV>



<DIV>
<A NAME="R_FoamDisplay.htm_IX_FoamDisplayNote()">
 </A>
<H1 CLASS="refHeading">
FoamDisplayNote()</H1>
<PRE CLASS="syntax">void FoamDisplayNote(
     optr    noteText);</PRE>
<P>
Displays a &quot;Note&quot; dialog box, with a single &quot;Ok&quot; trigger.
Use <CODE>FoamDisplayNoteNoBlock()</CODE> to not block the calling thread.</P>

<P CLASS="refField"><STRONG>
Pass:   </STRONG>
</P>
<DL>
<DT>
<STRONG>
noteText</STRONG>
</DT><DD>Optr to text chunk of the note to display.</DD>
</DL>

<P CLASS="refField"><STRONG>
Warning:</STRONG> This routine may resize <CODE>LMem</CODE> and/or
object blocks, moving them on the heap and invalidating stored
pointers to them.</P>

<P CLASS="refField"><STRONG>
Include:</STRONG>        <STRONG CLASS="fileName">
foam.goh</STRONG>
 </P>

<P CLASS="refField"><STRONG>
See Also:</STRONG>
<CODE>FoamDisplayNoteNoBlock()</CODE>
 </P>

</DIV>

<DIV>
<a name="IX_FoamDisplayNoteNoBlock()"></a>
<H1 CLASS="refHeading">
FoamDisplayNoteNoBlock()</H1>
<PRE CLASS="syntax">void FoamDisplayNoteNoBlock(
     optr  noteText );</PRE>
<P>
Same as the <CODE>FoamDisplayNote()</CODE> routine (listed above) except
this one does not block the calling thread.
</p>

<P CLASS="refField"><STRONG>Pass:</STRONG>
</P>

<DL>
<DT><STRONG>noteText</STRONG></dt>
<DD>Optr to text chunk of the note to display.</DD>
</DL>

<P CLASS="refField"><STRONG>Warning:</STRONG>
This routine may resize LMem and/or object blocks, moving them
on the heap and invalidating stored pointers to them.
</P>

<P CLASS="refField"><STRONG>Include:</STRONG>
<STRONG CLASS="fileName"> foam.goh</STRONG>
</P>

<P CLASS="refField"><STRONG>
See Also:</STRONG>
<CODE>FoamDisplayNote()</CODE>
</P>

</DIV>


<DIV>
<A NAME="R_FoamDisplay.htm_IX_FoamDisplayOkCancelWarning()">
 </A>
<H1 CLASS="refHeading">
FoamDisplayOkCancelWarning()</H1>
<PRE CLASS="syntax">InteractionCommand   FoamDisplayOkCancelWarning(
   optr  warningText ); </PRE>
<P>
Displays a warning dialog that allows the user to cancel out of an
action. The dialog will have both an &quot;Ok&quot; and a
&quot;Cancel&quot; trigger.</P>

<P CLASS="refField"><STRONG>
Pass:   </STRONG>
</P>
<DL>
<DT>
<STRONG>
warningText</STRONG>
</DT><DD>Optr to the text chunk containg a message to display in the
dialog. This will usually be a question like &quot;Delete your data?&quot;</DD>
</DL>

<P CLASS="refField"><STRONG>
Return:</STRONG>
        The user's input: <EM>IC_APPLY</EM> if user
selected &quot;Accept&quot;. <EM>IC_NULL</EM> if dialog could not be
displayed.</P>

<P CLASS="refField"><STRONG>
Warning:</STRONG>         This routine may resize LMem and/or
object blocks, moving them on the heap and invalidating stored
pointers to them.
</P>

<P CLASS="refField"><STRONG>
Include:</STRONG>        <STRONG CLASS="fileName">
foam.goh</STRONG>
 </P>

<P CLASS="refField"><STRONG>
See Also:</STRONG>
<CODE>FoamDisplayQuestion()</CODE>, <CODE>FoamDisplayWarning()</CODE>,
<CODE>FoamDisplayWarningNoBlock()</CODE>.
 </P>

</DIV>


<DIV>
<A NAME="R_FoamDisplay.htm_IX_FoamDisplayQuestion()">
 </A>
<H1 CLASS="refHeading">
FoamDisplayQuestion()</H1>
<PRE CLASS="syntax">InteractionCommand   FoamDisplayQuestion(
   optr  questionText );</PRE>
<P>
Ask the user a Yes/No question, such as &quot;Save changes to 'foo' before
quitting?&quot;. The associated text should normally end in a question
mark.</P>

<P CLASS="refField"><STRONG>
Pass:   </STRONG>
</P>
<DL>
<DT>
<STRONG>
questionText</STRONG>
</DT><DD><CODE>Optr</CODE> to the text chunk of the question being asked.</DD>
</DL>

<P CLASS="refField"><STRONG>
Return:</STRONG>
        The user's input: <EM>IC_YES</EM> if user
selected &quot;Yes&quot;. <EM>IC_NULL</EM> if dialog could not be
displayed.</P>

<P CLASS="refField"><STRONG>
Warning:</STRONG>         This routine may resize LMem and/or
object blocks, moving them on the heap and invalidating stored
pointers to them.
</P>

<P CLASS="refField"><STRONG>
Include:</STRONG>        <STRONG CLASS="fileName">
foam.goh</STRONG>
 </P>

<P CLASS="refField"><STRONG>
See Also:</STRONG>
<CODE>FoamDisplayOkCancelWarning()</CODE>,
<CODE>FoamDisplayWarning()</CODE>,
<CODE>FoamDisplayWarningNoBlock()</CODE>.
 </P>
</DIV>



<DIV>
<A NAME="R_FoamDisplay.htm_IX_FoamDisplayWarning()">
 </A>
<H1 CLASS="refHeading">
FoamDisplayWarning()</H1>
<PRE CLASS="syntax">void    FoamDisplayWarning(
   optr  warningText );
</PRE>
<P>
Displays a notification box that will warn the user about an
action. It will not allow the user to cancel the action.
Use <CODE>FoamDisplayWarningNoBlock()</CODE> to not block the calling
thread. </P>

<P CLASS="refField"><STRONG>
Pass:   </STRONG>
</P>
<DL>
<DT>
<STRONG>
warningText</STRONG>
</DT><DD>Optr to the text chunk containing the warning message.</DD>
</DL>

<P CLASS="refField"><STRONG>
Return:</STRONG>
        None.</P>

<P CLASS="refField"><STRONG>
Warning:</STRONG>         This routine may resize LMem and/or
object blocks, moving them on the heap and invalidating stored
pointers to them.
</P>

<P CLASS="refField"><STRONG>
Include:</STRONG>        <STRONG CLASS="fileName">
foam.goh</STRONG>
 </P>

<P CLASS="refField"><STRONG>
See Also:</STRONG>
<CODE>FoamDisplayOkCancelWarning()</CODE>,
<CODE>FoamDisplayQuestion()</CODE>,
<CODE>FoamDisplayWarningNoBlock()</CODE>.
 </P>

</DIV>


<DIV>
<A NAME="R_FoamDisplay.htm_IX_FoamDisplayWarningNoBlock()">
 </A>
<H1 CLASS="refHeading">
FoamDisplayWarningNoBlock()</H1>
<PRE CLASS="syntax">void    FoamDisplayWarningNoBlock(
   optr  warningText );</PRE>
<P>
Same as the <CODE>FoamDisplayWarning()</CODE> routine (above) except this
routine does not block the calling thread.
</P>

<P CLASS="refField"><STRONG>
Pass:   </STRONG>
</P>
<DL>
<DT>
<STRONG>
warningText</STRONG>
</DT><DD>Optr to the text chunk containing the warning message.</DD>
</DL>

<P CLASS="refField"><STRONG>
Return:</STRONG>
        None.</P>

<P CLASS="refField"><STRONG>
Include:</STRONG>        <STRONG CLASS="fileName">
foam.goh</STRONG>
 </P>

<P CLASS="refField"><STRONG>
See Also:</STRONG>
<CODE>FoamDisplayOkCancelWarning()</CODE>,
<CODE>FoamDisplayQuestion()</CODE>,
<CODE>FoamDisplayWarning()</CODE>.
 </P>

</DIV>



<HR>
<A NAME="R_FoamDoc.htm"></A>


<DIV>
<A NAME="R_FoamDoc.htm_IX_FoamDocCheckProtocol()">
 </A>
<H1 CLASS="refHeading">
FoamDocCheckProtocol()</H1>
<PRE CLASS="syntax">Boolean FoamDocCheckProtocol(
   DocumentHandle  docHandle,
   word            numCreatorChars,
   word            majorProtocol,
   word            minorProtocol );
</PRE>
<P>
Checks a document file for the correct protocol and creator token.  </P>

<P CLASS="refField"><STRONG>
Pass:   </STRONG>
</P>
<DL>
<DT>
<STRONG>
docHandle</STRONG>
</DT><DD>Document whose protocol will be checked.</DD>
<DT>
<STRONG>
numCreatorChars</STRONG>
</DT><DD>Number of FEA_CREATOR token chars to check. You can pass two if
you only want to check the first two characters.</DD>
<DT>
<STRONG>
majorProtocol</STRONG>
</DT><DD>Major protocol number to check.</DD>
<DT>
<STRONG>
minorProtocol</STRONG>
</DT><DD>Minor protocol number to check (pass -1 if you don't want to check
the minor protocol).</DD>
</DL>

<P CLASS="refField"><STRONG>
Return:</STRONG>
        <CODE>TRUE</CODE> if the check failed, <CODE>FALSE</CODE>
otherwise.</P>

<P CLASS="refField"><STRONG>
Include:</STRONG>        <STRONG CLASS="fileName">
foam.goh</STRONG>
 </P>

<P CLASS="refField"><STRONG>
See Also:</STRONG>
None.
 </P>

</DIV>



<DIV>
<A NAME="R_FoamDoc.htm_IX_FoamDocClose()">
 </A>
<H1 CLASS="refHeading">
FoamDocClose()</H1>
<PRE CLASS="syntax">void FoamDocClose(
   DocumentHandle  docHandle );
</PRE>
<P>
Closes a Foam document that was opened using <CODE>FoamDocOpen()</CODE>.</P>

<P CLASS="refField"><STRONG>
Pass:   </STRONG>
</P>
<DL>
<DT>
<STRONG>
docHandle</STRONG>
</DT><DD>Handle of the document to close, usually the one returned by
<CODE>FoamDocOpen()</CODE>.</DD>
</DL>

<P CLASS="refField"><STRONG>
Return:</STRONG>
        None.</P>

<P CLASS="refField"><STRONG>
Include:</STRONG>        <STRONG CLASS="fileName">
foam.goh</STRONG>
 </P>

<P CLASS="refField"><STRONG>
See Also:</STRONG>
<CODE>FoamDocCreate()</CODE>,
<CODE>FoamDocDelete()</CODE>,
<CODE>FoamDocOpen()</CODE>.
 </P>

</DIV>


<DIV>
<A NAME="R_FoamDoc.htm_IX_FoamDocConvertFromDosAppend()">
 </A>
<H1 CLASS="refHeading">
FoamDocConvertFromDosAppend()</H1>
<PRE CLASS="syntax">void FoamDocConvertFromDosAppend(
   optr     object,
   TCHAR *  buffer,
   word     bufferLength );
 </PRE>
<P>
Append a buffer of DOS text to the temporary text object.
The DOS text is converted to the GEOS character set; carriage
return and Ctrl-Z are removed.</P>

<P CLASS="refField"><STRONG>
Pass:   </STRONG>
</P>
<DL>
<DT>
<STRONG>
object</STRONG>
</DT><DD>Temporary text object to use for the conversion process. This
is usually the <CODE>optr</CODE> returned by
<CODE>FoamDocConvertFromDosInit()</CODE>.</DD>
<DT>
<STRONG>
buffer</STRONG>
</DT><DD>Pointer to the buffer of text to append.</DD>
<DT>
<STRONG>
bufferLength</STRONG>
</DT><DD>Number of characters to append. Zero if buffer is
null-terminated.</DD>
</DL>

<P CLASS="refField"><STRONG>
Return:</STRONG>
        None.</P>

<P CLASS="refField"><STRONG>
Include:</STRONG>        <STRONG CLASS="fileName">
foam.goh</STRONG>
 </P>

<P CLASS="refField"><STRONG>
See Also:</STRONG>
<CODE>FoamDocConvertFromDosDone()</CODE>,
<CODE>FoamDocConvertFromDosInit()</CODE>,
<CODE>FoamDocConvertToDosDone()</CODE>,
<CODE>FoamDocConvertToDosInit()</CODE>,
<CODE>FoamDocConvertToDosRange()</CODE>,
<CODE>FoamDocGetDosTextSmall()</CODE>.
 </P>

</DIV>



<DIV>
<A NAME="R_FoamDoc.htm_IX_FoamDocConvertFromDosDone()">
 </A>
<H1 CLASS="refHeading">
FoamDocConvertFromDosDone()</H1>
<PRE CLASS="syntax">void   FoamDocConvertFromDosDone(
   DocumentHandle  docHandle,
   optr            object );
</PRE>
<P>
This function is called when you are done appending to the temporary
text object. A text transfer item is created from the text object and
stored in the specified document. The transfer item is stored in a
VM block in the document, and its <CODE>VMBlockHandle</CODE> is stored in
the document header (the document header is the VM file's map block;
see <CODE>FoamDocMapBlock</CODE> in foam.goh for the structure of this map
block) at the <EM>FDH_TEXT_TR_ITEM</EM> slot of the
<CODE>FoamDocHeader</CODE> (see <STRONG CLASS="fileName">foam.goh</STRONG>
for the definition of that enum).
</P>
<P>
The text object specified in &quot;object&quot; is then destroyed once the
transfer is complete.
</P>

<P CLASS="refField"><STRONG>
Pass:   </STRONG>
</P>
<DL>
<DT>
<STRONG>
docHandle</STRONG>
</DT><DD>Temporary text object used in the conversion process. This
is usually the optr returned by <CODE>FoamDocConvertFromDosInit()</CODE>.</DD>
</DL>

<P CLASS="refField"><STRONG>
Return:</STRONG>
        None</P>

<P CLASS="refField"><STRONG>
Include:</STRONG>        <STRONG CLASS="fileName">
foam.goh</STRONG>
 </P>

<P CLASS="refField"><STRONG>
See Also:</STRONG>
<CODE>FoamDocConvertFromDosAppend()</CODE>,
<CODE>FoamDocConvertFromDosInit()</CODE>,
<CODE>FoamDocConvertToDosDone()</CODE>,
<CODE>FoamDocConvertToDosInit()</CODE>,
<CODE>FoamDocConvertToDosRange()</CODE>,
<CODE>FoamDocGetDosTextSmall()</CODE>.
 </P>

</DIV>


<DIV>
<A NAME="R_FoamDoc.htm_IX_FoamDocConvertFromDosInit()">
 </A>
<H1 CLASS="refHeading">
FoamDocConvertFromDosInit()</H1>
<PRE CLASS="syntax">optr FoamDocConvertFromDosInit();</PRE>
<P>
Initializes the DOS text file to Foam text document conversion. The
function returns an optr of a temporary text object used in the
conversion. The next step would be to use
<CODE>FoamDocConvertFromDosAppend</CODE> to convert DOS text to GEOS text,
then use <CODE>FoamDocConvertFromDosDone</CODE> to finish the conversion
process.
</P>

<P CLASS="refField"><STRONG>
Pass:   </STRONG>
</P>
<DL>
<DT>
<STRONG>
None</STRONG>
</DL>

<P CLASS="refField"><STRONG>
Return:</STRONG>
        Optr of the temporary text object to be used
in the conversion process.</P>

<P CLASS="refField"><STRONG>
Include:</STRONG>        <STRONG CLASS="fileName">
foam.goh</STRONG>
 </P>

<P CLASS="refField"><STRONG>
See Also:</STRONG>
<CODE>FoamDocConvertFromDosAppend()</CODE>,
<CODE>FoamDocConvertFromDosDone()</CODE>,
<CODE>FoamDocConvertToDosDone()</CODE>,
<CODE>FoamDocConvertToDosInit()</CODE>,
<CODE>FoamDocConvertToDosRange()</CODE>,
<CODE>FoamDocGetDosTextSmall()</CODE>.
 </P>

</DIV>


<DIV>
<A NAME="R_FoamDoc.htm_IX_FoamDocConvertToDosDone()">
 </A>
<H1 CLASS="refHeading">
FoamDocConvertToDosDone()</H1>
<PRE CLASS="syntax">void    FoamDocConvertToDosDone(
   optr  object );
</PRE>
<P>
This function is called when you're done retrieving text from the
temporary text object.</P>

<P CLASS="refField"><STRONG>
Pass:   </STRONG>
</P>
<DL>
<DT>
<STRONG>
object</STRONG>
</DT><DD>Optr of the temporary text object used in the conversion process. This
is usually the optr returned by FoamDocConvertToDosInit().</DD>
</DL>

<P CLASS="refField"><STRONG>
Return:</STRONG>
        None</P>

<P CLASS="refField"><STRONG>
Include:</STRONG>        <STRONG CLASS="fileName">
foam.goh</STRONG>
 </P>

<P CLASS="refField"><STRONG>
See Also:</STRONG>

<CODE>FoamDocConvertFromDosAppend()</CODE>,
<CODE>FoamDocConvertFromDosDone</CODE>,
<CODE>FoamDocConvertFromDosInit</CODE>,
<CODE>FoamDocConvertToD<A NAME="R_FoamDocCreate.htm"></A></CODE>


<DIV>
<A NAME="R_FoamDocCreate.htm_IX_FoamDocCreate()">
 </A>
<H1 CLASS="refHeading">
FoamDocCreate()</H1>
<PRE CLASS="syntax">word FoamDocCreate(
   DocumentInfo *    docInfo,
   FileAttrInfo *    fileAttr,
   DocumentPrefix *  prefix ); </PRE>
<P>
This creates a Foam document file. It is simply created and then closed.
You'll need to call <CODE>FoamDocOpen()</CODE> after using
<CODE>FoamDocCreate()</CODE> in order to access the file.</P>
<P>
The document that is created will have a default creator token of
&quot;RDOC&quot;,
<CODE>MANUFACTURER_ID_GEOWORKS</CODE>.  To change the document's creator
token, call <CODE>FoamDocSetAttrInfo()</CODE> with <EM>FIA_token</EM> set
to your application's <CODE>GeodeToken</CODE>.
</p>

<P CLASS="refField"><STRONG>
Pass:   </STRONG>
</P>
<DL>
<DT>
<STRONG>
docInfo</STRONG>
</DT><DD>Pointer to a <CODE>DocumentInfo</CODE> structure which contains
the name of the document and the subdirectory it should
go in under <CODE>SP_DOCUMENT</CODE>. Don't need <CODE>DI_docName</CODE>
if prefix points to a name prefix since <CODE>FoamDocCreate()</CODE> will
then make a default document name.</DD>
<DT>
<STRONG>
fileAttr</STRONG>
</DT><DD><CODE>GeodeToken</CODE> and <CODE>ProtocolNumber</CODE> to use for
the document.</DD>
<DT>
<STRONG>
prefix</STRONG>
</DT><DD>The prefix added to a document name. If null, no
default name is made and name must be supplied in
<CODE>docInfo</CODE> parameter; e.g. &quot;NOTE 12.12.94 12:12 PM&quot;</DD>
</DL>

<P CLASS="refField"><STRONG>
Return:</STRONG>
        Error value if something went wrong. This word is of type
<CODE>VMStatus</CODE>, defined in <CODE>vm.goh</CODE>.</P>

<P CLASS="refField"><STRONG>
Include:</STRONG>        <STRONG CLASS="fileName">
foam.goh</STRONG>
 </P>

<P CLASS="refField"><STRONG>
See Also:</STRONG>
<CODE>FoamDocClose()</CODE>,
<CODE>FoamDocDelete()</CODE>,
<CODE>FoamDocOpen()</CODE>.
 </P>

</DIV>




<DIV>
<A NAME="R_FoamDocCreate.htm_IX_FoamDocDelete()">
 </A>
<H1 CLASS="refHeading">
FoamDocDelete()</H1>
<PRE CLASS="syntax">Boolean FoamDocDelete(
   DocumentInfo *  docInfo );</PRE>
<P>
This will delete a Foam document file, given a <CODE>DocumentInfo</CODE>
struct. The document must be closed before you can delete it.</P>

<P CLASS="refField"><STRONG>
Pass:   </STRONG>
</P>
<DL>
<DT>
<STRONG>
docInfo</STRONG>
</DT><DD>Pointer to a <CODE>DocumentInfo</CODE> struct, which specifies the
file to be deleted.
<P>
<pre>
typedef	struct {
    FileLongName DI_docName;  /* Document name */
    FDocumentDir DI_docDir;   /* Document directory */
} DocumentInfo;

typedef enum {
    FDD_PRIVATE,
    FDD_DOCUMENT,
    FDD_NONE,
    FDD_CREATED_TEXTS,
    FDD_RECEIVED_FAXES,
    FDD_RECEIVED_SM,
    FDD_RECEIVED_MAILS,
    FDD_MESSAGE_TEMPLATES,
    FDD_BUSINESS_CARDS,
    FDD_DOWNLOADED_FILES,
    FDD_WWW_HOTLIST,
    FDD_BROADCAST_MESSAGES,
    FDD_INTERNET,
    FDD_TONES
} FDocumentDir;
</pre>
</P>
</DD>
</DL>

<P CLASS="refField"><STRONG>
Return:</STRONG>
        TRUE if an error occurred, FALSE otherwise.</P>

<P CLASS="refField"><STRONG>
Include:</STRONG>        <STRONG CLASS="fileName">
foam.goh</STRONG>
 </P>

<P CLASS="refField"><STRONG>
See Also:</STRONG>
<CODE>FoamDocClose()</CODE>,
<CODE>FoamDocCreate()</CODE>,
<CODE>FoamDocOpen()</CODE>.
 </P>

</DIV>



<DIV>
<A NAME="R_FoamDocCreate.htm_IX_FoamDocGetDosTextSmall()">
 </A>
<H1 CLASS="refHeading">
FoamDocGetDosTextSmall()</H1>
<PRE CLASS="syntax">word FoamDocGetDosTextSmall(
   DocumentHandle  docHandle,
   void *          buffer,
   word            count );
</PRE>
<P>
Returns the text stored in the text transfer item of the document in a
character string format.</P>
<P>
The text returned is converted from the GEOS character set to
the native character set. Lines end with LF's and a NULL marks
the end of text.
</P>

<P CLASS="refField"><STRONG>
Pass:   </STRONG>
</P>
<DL>
<DT>
<STRONG>
docHandle</STRONG>
</DT><DD>Handle of the Foam document from which to grab the text. This
document must contain a text transfer item, similar to what is
returned by <CODE>FoamDocConvertFromDosDone()</CODE>.</DD>
<DT>
<STRONG>
buffer</STRONG>
</DT><DD>Pointer to the buffer in which to put the DOS text.</DD>
<DT>
<STRONG>
count</STRONG>
</DT><DD>The number of characters to convert. Use the
<CODE>FoamDocGetTextLength()</CODE> routine to find the size of the Foam
document.</DD>
</DL>

<P CLASS="refField"><STRONG>
Return:</STRONG>
        The number of characters converted.</P>

<P CLASS="refField"><STRONG>
Warning:</STRONG>  Use this routine only if you know that the text in
the document is less than a block in size (~10k).
 </P>

<P CLASS="refField"><STRONG>
Include:</STRONG>        <STRONG CLASS="fileName">
foam.goh</STRONG>
 </P>

<P CLASS="refField"><STRONG>
See Also:</STRONG>
<CODE>FoamDocConvertFromDosAppend()</CODE>,
<CODE>FoamDocConvertFromDosDone()</CODE>,
<CODE>FoamDocConvertFromDosInit()</CODE>.
 </P>

</DIV>


<DIV>
<A NAME="R_FoamDocCreate.htm_IX_FoamDocGetHeaderData()">
 </A>
<H1 CLASS="refHeading">
FoamDocGetHeaderData()</H1>
<PRE CLASS="syntax">word FoamDocGetHeaderData(
   DocumentHandle  docHandle,
   FoamDocHeader   docHeader );
</PRE>
<P>
Retrieves the specified word of data from the Foam document's VM map
block (&quot;doc header&quot;). The document header is simply a VMem map
block. See the Concepts book for more information on <A HREF =
"../../Memory/VM/combo.htm">Virtual Memory</A>.</P>

<P CLASS="refField"><STRONG>
Pass:   </STRONG>
</P>
<DL>
<DT>
<STRONG>
docHandle</STRONG>
</DT><DD>Handle of the Foam document from which to grab the header data.</DD>
<DT>
<STRONG>
docHeader</STRONG>
</DT><DD>Specifies which word of data you want from the document header.
<pre>
typedef enum {
    FDH_TEXT_TR_ITEM,
    FDH_ADDRESS_INFO,
    FDH_HANDLE1,
    FDH_HANDLE2,
    FDH_HANDLE3,
    FDH_HANDLE4,
    FDH_HANDLE5
} FoamDocHeader;
</pre>
</DD>
</DL>

<P CLASS="refField"><STRONG>
Return:</STRONG>
        The word of data from the document header.</P>

<P CLASS="refField"><STRONG>
Include:</STRONG>        <STRONG CLASS="fileName">
foam.goh</STRONG>
 </P>

<P CLASS="refField"><STRONG>
See Also:</STRONG>
None.
 </P>

</DIV>





<DIV>
<A NAME="R_FoamDocCreate.htm_IX_FoamDocGetTextLength()">
</A>
<H1 CLASS="refHeading">
FoamDocGetTextLength()</H1>
<PRE CLASS="syntax">dword FoamDocGetTextLength(
   DocumentHandle  docHandle );</PRE>
<P>
Returns the number of characters of text in the document.
</P>

<P CLASS="refField"><STRONG>
Pass:   </STRONG>
</P>
<DL>
<DT>
<STRONG>
docHandle</STRONG>
</DT><DD>Handle of the Foam document containing the text clipboard item.</DD>
</DL>

<P CLASS="refField"><STRONG>
Return:</STRONG>
        The length of the text in characters.</P>

<P CLASS="refField"><STRONG>
Include:</STRONG>        <STRONG CLASS="fileName">
foam.goh</STRONG>
 </P>

<P CLASS="refField"><STRONG>
See Also:</STRONG>
<CODE>FoamDocGetDosSmall()</CODE>,
<CODE>FoamDocGetHeaderData()</CODE>,
<CODE>FoamDocGetTextLengthFromField()</CODE>.
 </P>

</DIV>



<DIV>
<A NAME="R_FoamDocCreate.htm_IX_FoamDocGetTextLengthFromField()">
 </A>
<H1 CLASS="refHeading">
FoamDocGetTextLengthFromField()</H1>
<PRE CLASS="syntax">dword FoamDocGetTextLengthFromField(
   char *  field );
 </PRE>
<P>
Returns the length of the text from a pointer to a field (User Notes).
The pointer must be pointing to the &quot;User notes&quot; field of the
file, as
that is where the length of the text in the Foam document is stored.</P>

<P CLASS="refField"><STRONG>
Pass:   </STRONG>
</P>
<DL>
<DT>
<STRONG>
field</STRONG>
</DT><DD>Pointer to the beginning of the  &quot;User notes&quot;  field.</DD>
</DL>

<P CLASS="refField"><STRONG>
Return:</STRONG>
        The length of the text in characters.</P>

<P CLASS="refField"><STRONG>
Include:</STRONG>        <STRONG CLASS="fileName">
foam.goh</STRONG>
 </P>

<P CLASS="refField"><STRONG>
See Also:</STRONG>
<CODE>FoamDocGetDosSmall()</CODE>,
<CODE>FoamDocGetHeaderData()</CODE>,
<CODE>FoamDocGetTextLength()</CODE>.
 </P>

</DIV>


<DIV>
<A NAME="R_FoamDocCreate.htm_IX_FoamDocIsTextFormatted()">
 </A>
<H1 CLASS="refHeading">
FoamDocIsTextFormatted()</H1>
<PRE CLASS="syntax">Boolean FoamDocIsTextFormatted(
   DocumentHandle      docHandle,
   DocumentFontInfo *  fontInfo );
</PRE>
<P>
This routine retrieves the <CODE>FoamDocLengthAndFormatted</CODE> structure
from <CODE>FEA_USER_NOTES</CODE> and returns if the text of the document is
formatted or not.
</P>

<P CLASS="refField"><STRONG>
Pass:   </STRONG>
</P>
<DL>
<DT>
<STRONG>
docHandle</STRONG>
</DT><DD>Handle of the Foam document containing a text clipboard item.</DD>
<DT>
<STRONG>
fontInfo</STRONG>
</DT><DD>ointer to a DocumentFontInfo structure, which will be filled in
with the font and point size of the unformatted text. Note that this
structure is filled in only if the text is of a single point size and
font id (i.e. FoamDocIsTextFormatted returns FALSE).
<pre>
typedef struct {
    FontID	DFI_font;
    word	DFI_pointSize;
} DocumentFontInfo;
</pre>
</DD>
</DL>

<P CLASS="refField"><STRONG>
Return:</STRONG>
        TRUE if the text is formatted, FALSE otherwise.
If FALSE, then <CODE>fontInfo</CODE> struture will be filled in with point
size and font id of the text.
</P>

<P CLASS="refField"><STRONG>
Include:</STRONG>        <STRONG CLASS="fileName">
foam.goh</STRONG>
 </P>

<P CLASS="refField"><STRONG>
See Also:</STRONG>
<CODE>FoamIsTextFormatted()</CODE>.
 </P>

</DIV>



<DIV>
<A NAME="R_FoamDocCreate.htm_IX_FoamDocOpen()">
 </A>
<H1 CLASS="refHeading">
FoamDocOpen()</H1>
<PRE CLASS="syntax">DocumentHandle FoamDocOpen(
   DocumentInfo *  docInfo,
   FDocAccess      docAccess );
</PRE>
<P>
Opens a Foam document and returns a file handle. If the return value
is <CODE>NullHandle</CODE>, use <CODE>ThreadGetError()</CODE> to check for
an error value.</P>

<P CLASS="refField"><STRONG>
Pass:   </STRONG>
</P>
<DL>
<DT>
<STRONG>
docInfo</STRONG>
</DT><DD>Pointer to a DocumentInfo structure which contains the name of
the document and the subdirectory it lives in under SP_DOCUMENT.
The structure for DocumentInfo is defined as follows:
<pre>
typedef	struct {
    FileLongName DI_docName;  /* Document name */
    FDocumentDir DI_docDir;   /* Document directory */
} DocumentInfo;

typedef enum {
    FDD_PRIVATE,
    FDD_DOCUMENT,
    FDD_NONE,
    FDD_CREATED_TEXTS,
    FDD_RECEIVED_FAXES,
    FDD_RECEIVED_SM,
    FDD_RECEIVED_MAILS,
    FDD_MESSAGE_TEMPLATES,
    FDD_BUSINESS_CARDS,
    FDD_DOWNLOADED_FILES,
    FDD_WWW_HOTLIST,
    FDD_BROADCAST_MESSAGES,
    FDD_INTERNET,
    FDD_TONES
} FDocumentDir;
</pre>
</DD>
<DT>
<STRONG>
docAccess</STRONG>
</DT><DD>Indicates how to open the file - read only or read/write.
Possible values are:
<ul>
<li><CODE>FDA_READ_WRITE</CODE>
<li><CODE>FDA_READ_ONLY</CODE>
<li><CODE>FDA_READ_ONLY_DENY_NONE</CODE>
</ul>
</DD>
</DL>

<P CLASS="refField"><STRONG>
Return:</STRONG>
        Handle of the newly open document, or <CODE>NullHandle</CODE> if an
error occurred.</P>

<P CLASS="refField"><STRONG>
Include:</STRONG>        <STRONG CLASS="fileName">
foam.goh</STRONG>
 </P>

<P CLASS="refField"><STRONG>
See Also:</STRONG>
<CODE>FoamDocClose()</CODE>,
<CODE>FoamDocCreate()</CODE>,
<CODE>FoamDocDelete()</CODE>.
 </P>

</DIV>


<DIV>
<A NAME="R_FoamDocCreate.htm_IX_FoamDocSetAttrInfo()">
 </A>
<H1 CLASS="refHeading">
FoamDocSetAttrInfo</H1>
<PRE CLASS="syntax">void FoamDocSetAttrInfo(
   DocumentHandle  docHandle,
   FileAttrInfo *  fileAttrInfo );
</PRE>
<P>
Initialize a file's extended attributes. This is done to allow detection
of when a file that is being opened is actually a specific file type or not.
Also, when major changes are made to the file structure we can change
the protocol number to see if the file that we opened is compatible.</P>

<P CLASS="refField"><STRONG>
Pass:   </STRONG>
</P>
<DL>
<DT>
<STRONG>
docHandle</STRONG>
</DT><DD>Handle of the FoamDocument being initialized.</DD>
<DT>
<STRONG>
fileAttrInfo</STRONG>
</DT><DD>Pointer to a FileAttrInfo structure that will be used to set the
files attributes. The structure definition is as follows:
<pre>
typedef struct {
    GeodeToken	   FAI_token;     /* token of file */
    ProtocolNumber FAI_protocol;  /* protocol number of file */
} FileAttrInfo;
</pre>
</DD>
</DL>

<P CLASS="refField"><STRONG>
Return:</STRONG>
        None.</P>

<P CLASS="refField"><STRONG>
Include:</STRONG>        <STRONG CLASS="fileName">
foam.goh</STRONG>
 </P>

<P CLASS="refField"><STRONG>
See Also:</STRONG>
<CODE>FoamDocSetBlockHandle()</CODE>,
<CODE>FoamDocSetHeaderData()</CODE>,
<CODE>FoamDocSetTextFormatted()</CODE>,
<CODE>FoamDocSetTextLength()</CODE>.
 </P>

</DIV>



<HR>
<A NAME="R_FoamDocSetBlock.htm"></A>



<DIV>
<A NAME="R_FoamDocSetBlock.htm_IX_FoamDocSetBlockHandle()">
 </A>
<H1 CLASS="refHeading">
FoamDocSetBlockHandle()</H1>
<PRE CLASS="syntax">void FoamDocSetBlockHandle(
   DocumentHandle  docHandle,
   VMBlockHandle   block,
   FoamDocHeader   docHeader );
 </PRE>
<P>
Stores the handle of <EM>block</EM> in a field within the document's header
block.  The field is specified by <EM>docHeader</EM>. If the field already
contains a <CODE>VMBlock</CODE> handle, that block will be freed by the system
and your block handle will be placed in the field.
</P>
<P>
If the data you want to store in the document header (which is a
<CODE>FoamDocMapBlock</CODE> structure, defined in <CODE>foam.goh</CODE>)
isn't a VM handle, then use <CODE>FoamDocSetHeaderData()</CODE> instead.
</p>
<P CLASS="refField"><STRONG>
Pass:   </STRONG>
</P>
<DL>
<DT>
<STRONG>
docHandle</STRONG>
</DT><DD>Handle of the Foam document file which is being changed.</DD>
<DT>
<STRONG>
block</STRONG>
</DT><DD>The <CODE>VMBlockHandle</CODE> being saved to the document
header.</DD>
<DT>
<STRONG>
docHeader</STRONG>
</DT><DD>Field within the document header where the <EM>block</EM> handle
will be stored. <CODE>FoamDocHeader</CODE> is defined as:
<pre>
typedef enum {
    FDH_TEXT_TR_ITEM,
    FDH_ADDRESS_INFO,
    FDH_HANDLE1,
    FDH_HANDLE2,
    FDH_HANDLE3,
    FDH_HANDLE4,
    FDH_HANDLE5
} FoamDocHeader;
</pre></DD>
</DL>

<P CLASS="refField"><STRONG>
Return:</STRONG>
        None.</P>

<P CLASS="refField"><STRONG>
Warning:</STRONG>       Do not set <EM>docHeader</EM> to
<CODE>FDH_TEXT_TR_ITEM</CODE> or <CODE>FDH_ADDRESS_INFO</CODE> as these two
fields are used by the system.
 </P>

<P CLASS="refField"><STRONG>
Include:</STRONG>        <STRONG CLASS="fileName">
foam.goh</STRONG>
 </P>

<P CLASS="refField"><STRONG>
See Also:</STRONG>
<CODE>FoamDocSetAttrInfo()</CODE>,
<CODE>FoamDocSetHeaderData()</CODE>,
<CODE>FoamDocSetTextFormatted()</CODE>,
<CODE>FoamDocSetTextLength()</CODE>.
 </P>

</DIV>


<DIV>
<A NAME="R_FoamDocSetBlock.htm_IX_FoamDocSetHeaderData()">
 </A>
<H1 CLASS="refHeading">
FoamDocSetHeaderData()</H1>
<PRE CLASS="syntax">void FoamDocSetHeaderData(
   DocumentHandle  docHandle,
   word            data,
   FoamDocHeader   docHeader );
 </PRE>
<P>
Stores a word of data in a field within the specified document's header
block.  The field is specified by <EM>docHeader</EM>.
</P>
<P>
If the data you want to store in the document header is a
<CODE>VMBlock</CODE> handle, use <CODE>FoamDocSetBlockHandle()</CODE>
instead.
</p>

<P CLASS="refField"><STRONG>
Pass:   </STRONG>
</P>
<DL>
<DT>
<STRONG>
docHandle</STRONG>
</DT><DD>Handle of the Foam document that is being changed.</DD>
<DT>
<STRONG>
data</STRONG>
</DT><DD>The word of data to store in the document header.</DD>
<DT>
<STRONG>
docHeader</STRONG>
</DT><DD>Field within the document header where the &quot;block&quot;
handle will be stored. <CODE>FoamDocHeader</CODE> is defined as follows.
<pre>
typedef enum {
    FDH_TEXT_TR_ITEM,
    FDH_ADDRESS_INFO,
    FDH_HANDLE1,
    FDH_HANDLE2,
    FDH_HANDLE3,
    FDH_HANDLE4,
    FDH_HANDLE5
} FoamDocHeader;
</pre>
</DD>
</DL>

<P CLASS="refField"><STRONG>
Return:</STRONG>
        None</P>

<P CLASS="refField"><STRONG>
Warning:</STRONG>
        Do not set <EM>docHeader</EM> to <CODE>FDH_TEXT_TR_ITEM</CODE>
or <CODE>FDH_ADDRESS_INFO</CODE> as these two fields are used by the
system.</P>

<P CLASS="refField"><STRONG>
Include:</STRONG>        <STRONG CLASS="fileName">
foam.goh</STRONG>
 </P>

<P CLASS="refField"><STRONG>
See Also:</STRONG>
<CODE>FoamDocSetAttrInfo()</CODE>,
<CODE>FoamDocSetBlockHandle()</CODE>, <CODE>FoamDocSetTextFormatted()</CODE>,
<CODE>FoamDocSetTextLength()</CODE>.
 </P>

</DIV>



<DIV>
<A NAME="R_FoamDocSetBlock.htm_IX_FoamDocSetTextFormatted()">
 </A>
<H1 CLASS="refHeading">
FoamDocSetTextFormatted()</H1>
<PRE CLASS="syntax">void FoamDocSetTextFormatted(
   DocumentHandle        docHandle,
   FoamDocTextFormatted  fdtf,
   DocumentFontInfo *    fontInfo );</PRE>
<P>
Stores information on the document text in the <CODE>GeosFileHeader</CODE>
of the Document. This information can be retrieved by calling
<CODE>FoamDocIsTextFormatted()</CODE>.
</P>

<P CLASS="refField"><STRONG>
Pass:   </STRONG>
</P>
<DL>
<DT>
<STRONG>
docHandle</STRONG>
</DT><DD>Handle of the Foam document which is being changed.</DD>
<DT>
<STRONG>
fdtf</STRONG>
</DT><DD>Set this to <CODE>FDTF_FORMATTED</CODE> if the text is formatted,
otherwise set to <CODE>FDTF_NOT_FORMATTED</CODE>.</DD>
<DT>
<STRONG>
fontInfo</STRONG>
</DT><DD>Pointer to a <CODE>DocumentFontInfo</CODE> structure. If the text
does not contain multiple formats, then pass the font and point size of the
text.
See the description for <CODE>FoamDocIsTextFormatted()</CODE> for the
definition of <CODE>DocumentFontInfo</CODE>.</DD>
</DL>

<P CLASS="refField"><STRONG>
Return:</STRONG>
        None.</P>

<P CLASS="refField"><STRONG>
Include:</STRONG>        <STRONG CLASS="fileName">
foam.goh</STRONG>
 </P>

<P CLASS="refField"><STRONG>
See Also:</STRONG>
<CODE>FoamDocIsTextFormatted()</CODE>,
<CODE>FoamDocSetAttrInfo()</CODE>,
<CODE>FoamDocSetBlockHandle()</CODE>,
<CODE>FoamDocSetHeaderData()</CODE>,
<CODE>FoamDocSetTextLength()</CODE>.
</P>
</DIV>


<DIV>
<A NAME="R_FoamDocSetBlock.htm_IX_FoamDocSetTextLength()">
 </A>
<H1 CLASS="refHeading">
FoamDocSetTextLength()</H1>
<PRE CLASS="syntax">void FoamDocSetTextLength(
   DocumentHandle  docHandle,
   dword           length );
</PRE>
<P>
Sets the document's text length. This is usually used internally and
you won't need to call this in most cases. This information is stored
in the Foam document header and does not affect the text stored in
the document.</P>

<P CLASS="refField"><STRONG>
Pass:   </STRONG>
</P>
<DL>
<DT>
<STRONG>
docHandle</STRONG>
</DT><DD>Handle of the Foam document which is being changed.</DD>
<DT>
<STRONG>
length</STRONG>
</DT><DD>Length that you want to store in the document header.</DD>
</DL>

<P CLASS="refField"><STRONG>
Return:</STRONG>
        None.</P>

<P CLASS="refField"><STRONG>
Include:</STRONG>        <STRONG CLASS="fileName">
foam.goh</STRONG>
 </P>

<P CLASS="refField"><STRONG>
See Also:</STRONG>
<CODE>FoamDocSetAttrInfo()</CODE>,
<CODE>FoamDocSetBlockHandle()</CODE>,
<CODE>FoamDocSetHeaderData()</CODE>,
<CODE>FoamDocSetTextFormatted()</CODE>.
 </P>

</DIV>



<DIV>
<A NAME="R_FoamDocSetBlock.htm_IX_FoamDocStoreDosTextSmall()">
 </A>
<H1 CLASS="refHeading">
FoamDocStoreDosTextSmall()</H1>
<PRE CLASS="syntax">void FoamDocStoreDosTextSmall(
   DocumentHandle  docHandle,
   void *          buffer,
   word            bufferLen );
 </PRE>
<P>
Stores a character string in the document <CODE>FDH_TEXT_TR_ITEM</CODE>
block. The text is converted from the native character set to the GEOS
character set. Carriage return and Ctrl-Z are removed from the string.
</P>

<P CLASS="refField"><STRONG>
Pass:   </STRONG>
</P>
<DL>
<DT>
<STRONG>
docHandle</STRONG>
</DT><DD>Handle of the Foam document which is being changed.</DD>
<DT>
<STRONG>
buffer</STRONG>
</DT><DD>Pointer to the string of text to store. Must be null-terminated.</DD>
<DT>
<STRONG>
bufferLen</STRONG>
</DT><DD>Number of characters in the string pointed to by buffer.</DD>
</DL>

<P CLASS="refField"><STRONG>
Return:</STRONG>
        None.</P>

<P CLASS="refField"><STRONG>
Warning:</STRONG>
        Use this only if the text you are storing is less than a block in
size (~10k). If the DOS text you want to store is larger than 10k, use the
<CODE>FoamDocConvertFromDos()</CODE> routines listed below.</P>

<P CLASS="refField"><STRONG>
Include:</STRONG>        <STRONG CLASS="fileName">
foam.goh</STRONG>
 </P>

<P CLASS="refField"><STRONG>
See Also:</STRONG>
<CODE>FoamDocConvertFromDosAppend()</CODE>,
<CODE>FoamDocConvertFromDosDone()</CODE>,
<CODE>FoamDocConvertFromDosInit()</CODE>,
<CODE>FoamDocStoreTextAsVMChain()</CODE>.
 </P>

</DIV>



<DIV>
<A NAME="R_FoamDocSetBlock.htm_IX_FoamDocStoreTextAsVMChain()">
 </A>
<H1 CLASS="refHeading">
FoamDocStoreTextAsVMChain()</H1>
<PRE CLASS="syntax">word FoamDocStoreTextAsVMChain(
   DocumentHandle  docHandle,
   optr            textObject );
</PRE>
<P>
This routine copies the text of a text object into a chain of text
transfer items, each about 4000 bytes in size. The starting block
of the chain is saved in <EM>FDH_TEXT_TR_ITEM</EM> of the document header.
The next transfer item block handle is saved in the
<EM>TTBH_reservedVM</EM> field of the
<CODE>TextTransferBlockHeader</CODE>.</P>
<P>
When it's time to read in the chain of text transfer items, first
use the block in <EM>FDH_TEXT_TR_ITEM</EM> with
<EM>MSG_VIS_TEXT_REPLACE_WITH_TEXT_TRANSFER_FORMAT</EM> then loop until the
high word of <EM>TTBH_reservedVM</EM> is zero. To get at
<EM>TTBH_reservedVM</EM> use <CODE>VMLock()</CODE> passing the the
<CODE>VMBlockHandle</CODE> you used when calling
<EM>MSG_VIS_TEXT_REPLACE_WITH_TEXT_TRANSFER_FORMAT</EM>.
</P>

<P CLASS="refField"><STRONG>
Pass:   </STRONG>
</P>
<DL>
<DT>
<STRONG>
docHandle</STRONG>
</DT><DD>Handle of the Foam document which is being changed.</DD>
<DT>
<STRONG>
textObject</STRONG>
</DT><DD>Optr to the text object containing the text to store in the Foam
document.</DD>
</DL>

<P CLASS="refField"><STRONG>
Return:</STRONG>
        <CODE>VMBlockHandle</CODE> of the first text transfer item.
(This handle is also stored in <EM>FDH_TEXT_TR_ITEM</EM>.)
</P>

<P CLASS="refField"><STRONG>
Include:</STRONG>        <STRONG CLASS="fileName">
foam.goh</STRONG>
 </P>

<P CLASS="refField"><STRONG>
See Also:</STRONG>
<CODE>FoamDocStoreDosTextSmall()</CODE>.
 </P>

</DIV>



<HR>
<A NAME="R_FoamGenerateUnique.htm"></A>


<DIV>
<A NAME="R_FoamGenerateUnique.htm_IX_FoamGenerateUniqueFilename()">
 </A>
<H1 CLASS="refHeading">
FoamGenerateUniqueFilename()</H1>
<PRE CLASS="syntax">void FoamGenerateUniqueFilename(
   FileLongName *nameBuffer);</PRE>
<P>
This routine will return a data file name that is unique.
If you specify a prefix in <EM>nameBuffer</EM>, this routine will add the
next available number to the prefix and return the document name
in the form: &quot;[prefix] #[number]&quot;.</P>

<P CLASS="refField"><STRONG>
Pass:   </STRONG>
</P>
<DL>
<DT>
<STRONG>
nameBuffer</STRONG>
</DT><DD>Buffer into which the file name will be written.</DD>
</DL>

<P CLASS="refField"><STRONG>
Return:</STRONG>
        None.</P>

<P CLASS="refField"><STRONG>
Warning:</STRONG>        Occasionally an invalid file name can be returned.
If you try to create a file with the returned name and the create fails,
call this routine again to get a new name.
 </P>

<P CLASS="refField"><STRONG>
Include:</STRONG>        <STRONG CLASS="fileName">
foam.goh</STRONG>
 </P>

<P CLASS="refField"><STRONG>
See Also:</STRONG>
<CODE>FoamDocCreate()</CODE>.
</P>

</DIV>



<DIV>
<A NAME="R_FoamGenerateUnique.htm_IX_FoamGetDocumentDir()">
 </A>
<H1 CLASS="refHeading">
FoamGetDocumentDir()</H1>
<PRE CLASS="syntax">FDocumentDir FoamGetDocumentDir();</PRE>
<P>
Returns the <CODE>FDocumentDir</CODE> value that corresponds to the current
path. If the current path is not one of the <CODE>FDocumentDir</CODE>, then
<EM>FDD_NONE</EM> is returned.  <CODE>FDocumentDir</CODE> is a list of
standard subdirectories under the Document directory.</P>

<P CLASS="refField"><STRONG>
Pass:   </STRONG> None.
</P>

<P CLASS="refField"><STRONG>
Return:</STRONG>
        The appropriate <CODE>FDocumentDir</CODE> value.</P>

<P CLASS="refField"><STRONG>
Include:</STRONG>        <STRONG CLASS="fileName">
foam.goh</STRONG>
 </P>

<P CLASS="refField"><STRONG>
See Also:</STRONG>
<CODE>FoamGetDocumentDirName()</CODE>,
<CODE>FoamSetDocumentDir()</CODE>.
</P>

</DIV>



<DIV>
<A NAME="R_FoamGenerateUnique.htm_IX_FoamGetDocumentDirName()">
 </A>
<H1 CLASS="refHeading">
FoamGetDocumentDirName()</H1>
<PRE CLASS="syntax">void FoamGetDocumentDirName(
   FDocumentDir fDocDir,
   FileLongName *buffer); </PRE>
<P>
Fills in the buffer with the directory name corresponding to the
specified <CODE>FDocumentDir</CODE>.  <CODE>FDocumentDir</CODE> is a list
of standard subdirectories under the Document directory.</P>

<P CLASS="refField"><STRONG>
Pass:   </STRONG>
</P>
<DL>
<DT>
<STRONG>
fDocDir</STRONG>
</DT><DD>The <CODE>FDocumentDir</CODE> enum whose name you want.</DD>
<DT>
<STRONG>
buffer</STRONG>
</DT><DD>A buffer that will hold the name of the directory.</DD>
</DL>

<P CLASS="refField"><STRONG>
Return:</STRONG>
        None; <EM>*buffer</EM> is filled in.</P>

<P CLASS="refField"><STRONG>
Include:</STRONG>        <STRONG CLASS="fileName">
foam.goh</STRONG>
 </P>

<P CLASS="refField"><STRONG>
See Also:</STRONG>
<CODE>FoamGetDocumentDir()</CODE>,
<CODE>FoamSetDocumentDir()</CODE>.
 </P>

</DIV>



<DIV>
<A NAME="R_FoamGenerateUnique.htm_IX_FoamGetFileType()">
 </A>
<H1 CLASS="refHeading">
FoamGetFileType()</H1>
<PRE CLASS="syntax">GeosFileType FoamGetFileType(
   TCHAR *filename); </PRE>
<P>
Get the <CODE>GeosFileType</CODE> of the named file.</P>

<P CLASS="refField"><STRONG>
Pass:   </STRONG>
</P>
<DL>
<DT>
<STRONG>
filename</STRONG>
</DT><DD>Name of the file whose <CODE>GeosFileType</CODE> you want to
retrieve.  The buffer need not be longer than
<EM>FILE_LONGNAME_BUFFER_SIZE</EM> bytes.
</DD>
</DL>

<P CLASS="refField"><STRONG>
Return:</STRONG>
        A <CODE>GeosFileType</CODE> will be returned.  The value will be
<ul>
<LI>GFT_VM (standard GEOS VM file)
<LI>GFT_DATA (a non-VM data file)
<LI>GFT_EXECUTABLE (file is a application, library or driver)
<LI>GFT_DIRECTORY (if the name was a directory rather than a file)
<LI>GFT_NOT_GEOS_FILE (the file was most likely created by DOS)
</UL>
</P>

<P CLASS="refField"><STRONG>
Include:</STRONG>        <STRONG CLASS="fileName">
foam.goh</STRONG>
 </P>

<P CLASS="refField"><STRONG>
See Also:</STRONG>
<CODE>FoamGetHandleFileType()</CODE>.
 </P>

</DIV>



<DIV>
<A NAME="R_FoamGenerateUnique.htm_IX_FoamGetFreeDiskSpace()">
 </A>
<H1 CLASS="refHeading">
FoamGetFreeDiskSpace()</H1>
<PRE CLASS="syntax">dword FoamGetFreeDiskSpace();
 </PRE>
<P>
This routine returns the number of bytes available on the disk.</P>

<P CLASS="refField"><STRONG>
Pass:   </STRONG> None.</P>

<P CLASS="refField"><STRONG>
Return:</STRONG>
        The number of free bytes on the disk.</P>

<P CLASS="refField"><STRONG>
Warning:</STRONG>
        Since Geos is multi-threaded, the amount of free disk space may
change rapidly as other threads use the disk..</P>

<P CLASS="refField"><STRONG>
Include:</STRONG>        <STRONG CLASS="fileName">
foam.goh</STRONG>
 </P>

<P CLASS="refField"><STRONG>
See Also:</STRONG>
<CODE>FoamRoundUpAsMultipleOfClusterSize()</CODE>,
<CODE>FoamCheckIfOutOfSpace()</CODE>,
<CODE>FoamWarnIfOutOfSpace()</CODE>,
<CODE>FoamWarnForSaving()</CODE>,
<CODE>FoamCancelIfNoFreeSpace()</CODE>,
<CODE>FoamWarnIfNotEnoughSpace()</CODE>,
<CODE>FoamWarnSpaceAfterOperation()</CODE>.
 </P>

</DIV>



<DIV>
<A NAME="R_FoamGenerateUnique.htm_IX_FoamGetHandleFileType()">
 </A>
<H1 CLASS="refHeading">
FoamGetHandleFileType()</H1>
<PRE CLASS="syntax">GeosFileType FoamGetHandleFileType(
   DocumentHandle docHandle);</PRE>
<P>
Get the <CODE>GeosFileType</CODE> of the file specified by
<EM>docHandle</EM>.</P>

<P CLASS="refField"><STRONG>
Pass:   </STRONG>
</P>
<DL>
<DT>
<STRONG>
docHandle</STRONG>
</DT><DD><CODE>DocumentHandle</CODE> of the file whose
<CODE>GeosFileType</CODE> you want to retrieve.
</DD>
</DL>

<P CLASS="refField"><STRONG>
Return:</STRONG>
        A <CODE>GeosFileType</CODE> will be returned.  The value will be
<UL>
<LI>GFT_VM (standard GEOS VM file)
<LI>GFT_DATA (a non-VM data file)
<LI>GFT_EXECUTABLE (file is a application, library or driver)
<LI>GFT_DIRECTORY (if the name was a directory rather than a file)
<LI>GFT_NOT_GEOS_FILE (the file was most likely created by DOS)
</UL></P>

<P CLASS="refField"><STRONG>
Include:</STRONG>        <STRONG CLASS="fileName">
foam.goh</STRONG>
 </P>

<P CLASS="refField"><STRONG>
See Also:</STRONG>
<CODE>FoamGetFileType()</CODE>.
 </P>

</DIV>


<DIV>
<A NAME="R_FoamGenerateUnique.htm_IX_FoamGetLexicalOrder()">
 </A>
<H1 CLASS="refHeading">
FoamGetLexicalOrder()</H1>
<PRE CLASS="syntax">byte FoamGetLexicalOrder(
   char theChar); </PRE>
<P>
Gets the &quot;lexical order&quot; of a character, for use in optimized
case and accent-insensitive searching (all versions of a character,
accented, unaccented, upper and lower case will have the same lexical
order).
</P>

<P CLASS="refField"><STRONG>
Pass:   </STRONG>
</P>
<DL>
<DT>
<STRONG>
theChar</STRONG>
</DT><DD>The character whose lexical equivalent you want.</DD>
</DL>

<P CLASS="refField"><STRONG>
Return:</STRONG>
        A <CODE>LexicalOrder</CODE> for the character is returned.
See <CODE>LexicalOrder</CODE> enumeration in Include/Internal/lexical.def.
</P>

<P CLASS="refField"><STRONG>
Include:</STRONG>        <STRONG CLASS="fileName">
foam.goh</STRONG>
 </P>

<P CLASS="refField"><STRONG>
See Also:</STRONG>
None.
 </P>

</DIV>



<DIV>
<A NAME="R_FoamGenerateUnique.htm_IX_FoamGetLowSoundFlag()">
 </A>
<H1 CLASS="refHeading">
FoamGetLowSoundFlag()</H1>
<PRE CLASS="syntax">word FoamGetLowSoundFlag();</PRE>
<P>
Returns the status of the low sound mode.
</P>
<P>
Low sound mode specifies that <CODE>UserStandardSound()</CODE> will ignore
the standard sound type it is told to play.  Instead it plays a low,
monotone note.
</P>

<P CLASS="refField"><STRONG>
Pass:   </STRONG> None.
</P>

<P CLASS="refField"><STRONG>
Return:</STRONG>
        Non-zero (TRUE) if the flag is set; zero (FALSE) if the flag is not
set.
</P>

<P CLASS="refField"><STRONG>
Include:</STRONG>        <STRONG CLASS="fileName">
foam.goh</STRONG>
 </P>

<P CLASS="refField"><STRONG>
See Also:</STRONG>
<CODE>UserStandardSound()</CODE>,
<CODE>FoamSetLowSoundFlag()</CODE>.
 </P>

</DIV>



<DIV>
<A NAME="R_FoamGenerateUnique.htm_IX_FoamIsTextFormatted()">
 </A>
<H1 CLASS="refHeading">
FoamIsTextFormatted()</H1>
<PRE CLASS="syntax">Boolean FoamIsTextFormatted(
   optr             textObject,
   DocumentFontInfo *fontInfo); </PRE>
<P>
Determines if text in a text object is formatted (does it have multiple
character attributes).  If the text is not formatted the function will
return the font and the point size of the text in <EM>*fontInfo</EM>.</P>

<P CLASS="refField"><STRONG>
Pass:   </STRONG>
</P>
<DL>
<DT>
<STRONG>
textObject</STRONG>
</DT><DD>optr to the text object to examine.</DD>
<DT>
<STRONG>
fontInfo</STRONG>
</DT><DD>buffer that will be filled in if the text isn't in multiple
formats.</DD>
</DL>

<P CLASS="refField"><STRONG>
Return:</STRONG>
         TRUE if the text is formatted, FALSE if text is
all in a single format.  If FALSE, then <EM>*fontInfo</EM> will be filled
in.</P>

<P CLASS="refField"><STRONG>
Include:</STRONG>        <STRONG CLASS="fileName">
foam.goh</STRONG>
 </P>

<P CLASS="refField"><STRONG>
See Also:</STRONG>
<CODE>FoamDocIsTextFormatted()</CODE>.
 </P>

</DIV>




<DIV>
<A NAME="R_FoamGenerateUnique.htm_IX_FoamLaunchApplication()">
 </A>
<H1 CLASS="refHeading">
FoamLaunchApplication()</H1>
<PRE CLASS="syntax">void FoamLaunchApplication(
   FApplication applicationConstant); </PRE>
<P>
Launch the application designated by <EM>applicationConstant</EM>. This is
intended to be used by applications launched by System, Extras, Services so
that when they quit (rather, lower to bottom), the original launcher appears.
</P>
<P>
When this routine is called and the designated application launched, the
current application is lowered to bottom.
</P>

<P CLASS="refField"><STRONG>
Pass:   </STRONG>
</P>
<DL>
<DT>
<STRONG>
applicationConstant</STRONG>
</DT><DD>One of the following FApplication types:
<pre>
typedef enum {
    FA_PHONE_APP,
    FA_FAX_APP,
    FA_SMS_APP,
    FA_SERVICES_APP,
    FA_CONTACT_APP,
    FA_NOTEBOOK_APP,
    FA_CALENDAR_APP,
    FA_SYSTEM_APP,
    FA_EXTRAS_APP,
    FA_CALCULATOR_APP,
    FA_CLOCK_APP,
    FA_USER_DATA_APP,
    FA_WWW_INSTALL_APP,
} FApplication;
</pre>
</DD>
</DL>

<P CLASS="refField"><STRONG>
Return:</STRONG> None.</P>

<P CLASS="refField"><STRONG>
Include:</STRONG>        <STRONG CLASS="fileName">
foam.goh</STRONG>
 </P>

<P CLASS="refField"><STRONG>
See Also:</STRONG>
<CODE>UserLoadApplication()</CODE>,
<CODE>IACPConnect()</CODE>.
 </P>

</DIV>




<DIV>
<A NAME="R_FoamGenerateUnique.htm_IX_FoamRoundUpAsMultipleOfClusterSize()">
 </A>
<H1 CLASS="refHeading">
FoamRoundUpAsMultipleOfClusterSize()</H1>
<PRE CLASS="syntax">dword FoamRoundUpAsMultipleOfClusterSize(
   dword space);</PRE>
<P>
Since files require a full cluster on the disk, whether they actually fill
the entire cluster or not, this routine allows you to calculate the actual
disk space a file will require.  Simply submit the requested space and the
routine will return a size that is a multiple of cluster sizes.  This
returned size will never be less than the requested space.  </P>
<P>
<CODE>FoamWarnForSaving()</CODE> and
<CODE>FoamWarnIfNotEnoughSpace()</CODE> use this routine.
</P>

<P CLASS="refField"><STRONG>
Pass:   </STRONG>
</P>
<DL>
<DT>
<STRONG>
space</STRONG>
</DT><DD>The number of bytes of disk space you want.</DD>
</DL>

<P CLASS="refField"><STRONG>
Return:</STRONG>
        The number of bytes of disk space that will actually be used by a
file of the specified size.
</P>

<P CLASS="refField"><STRONG>
Include:</STRONG>        <STRONG CLASS="fileName">
foam.goh</STRONG>
 </P>

<P CLASS="refField"><STRONG>
See Also:</STRONG>
None.
 </P>

</DIV>



<DIV>
<A NAME="R_FoamGenerateUnique.htm_IX_FoamSetDocumentDir()">
 </A>
<H1 CLASS="refHeading">
FoamSetDocumentDir()</H1>
<PRE CLASS="syntax">void FoamSetDocumentDir(
   FDocumentDir fDocDir); </PRE>
<P>
Sets the current path to one of the standard <CODE>FDocumentDir</CODE>
directories.
</P>

<P CLASS="refField"><STRONG>
Pass:   </STRONG>
</P>
<DL>
<DT>
<STRONG>
fDocDir</STRONG>
</DT><DD>The desired <CODE>FDocumentDir</CODE> enum.</DD>
</DL>

<P CLASS="refField"><STRONG>
Return:</STRONG>
        None.</P>

<P CLASS="refField"><STRONG>
Include:</STRONG>        <STRONG CLASS="fileName">
foam.goh</STRONG>
 </P>

<P CLASS="refField"><STRONG>
See Also:</STRONG>
<CODE>FileSetStandardPath()</CODE>,
<CODE>FileSetCurrentPath()</CODE>,
<CODE>FoamGetDocumentDir()</CODE>,
<CODE>FoamGetDocumentDirName()</CODE>.
 </P>

</DIV>



<DIV>
<A NAME="R_FoamGenerateUnique.htm_IX_FoamSetLowSoundFlag()">
 </A>
<H1 CLASS="refHeading">
FoamSetLowSoundFlag()</H1>
<PRE CLASS="syntax">void FoamSetLowSoundFlag(
   word lowSndFlag);</PRE>
<P>
This routine changes the sound played by <CODE>UserStandardSound()</CODE>.
If the <EM>lowSndFlag</EM> is set to TRUE, <CODE>UserStandardSound()</CODE>
will play one plain note no matter what <CODE>StandardSoundType</CODE> is
passed.</P>

<P CLASS="refField"><STRONG>
Pass:   </STRONG>
</P>
<DL>
<DT>
<STRONG>
lowSndFlag</STRONG>
</DT><DD>Set to TRUE to enable low sound mode.  Set to FALSE to disable
low sound mode (i.e., revert to standard sound mode).</DD>
</DL>

<P CLASS="refField"><STRONG>
Return:</STRONG>
        None.</P>

<P CLASS="refField"><STRONG>
Include:</STRONG>        <STRONG CLASS="fileName">
foam.goh</STRONG>
 </P>

<P CLASS="refField"><STRONG>
See Also:</STRONG>
<CODE>UserStandardSound()</CODE>,
<CODE>FoamGetLowSoundFlag()</CODE>.
 </P>

</DIV>





<HR>
<A NAME="R_FoamStandardDialog.htm"></A>


<DIV>
<A NAME="R_FoamStandardDialog.htm_IX_FoamStandardDialogOptr()">
 </A>
<H1 CLASS="refHeading">
FoamStandardDialogOptr()</H1>
<PRE CLASS="syntax">InteractionCommand FoamStandardDialogOptr(
   void                     *helpFile,
   void                     *helpContext,
   LayerPriority            layerPriority,
   word                     rejectTriggerMessage,
   optr                     rejectTriggerDestination,
   word                     acceptTriggerMessage,
   optr                     acceptTriggerDestination,
   optr                     triggerTopText,
   TCHAR                    *arg2,
   TCHAR                    *arg1,
   FoamCustomDialogBoxFlags dialogFlags,
   optr                     bodyText,
   optr                     titleText,
   optr                     titleIconBitmap);
 </PRE>
<P>
This routine puts up a custom dialog box.  It does not return until the
user responds to the dialog box.  The dialog is destroyed by the system
when the routine returns.</P>

<P CLASS="refField"><STRONG>
Pass:   </STRONG>
</P>
<DL>
<DT>
<STRONG>
helpFile</STRONG>
</DT><DD>The name of the helpfile to associate with this dialog.  The
helpfile must be in the Userdata\Help directory on the device.</DD>
<DT>
<STRONG>
helpContext</STRONG>
</DT><DD>The context within help file to associate with this dialog.</DD>
<DT>
<STRONG>
layerPriority</STRONG>
</DT><DD>Custom layer priority to use.  Set to zero to give standard
layer priority to the dialog.
</DD>
<DT>
<STRONG>
rejectTriggerMessage</STRONG>
</DT><DD>This parameter is not used.</DD>
<DT>
<STRONG>
rejectTriggerDestination</STRONG>
</DT><DD>This parameter is not used.</DD>
<DT>
<STRONG>
acceptTriggerMessage</STRONG>
</DT><DD>This parameter is not used.</DD>
<DT>
<STRONG>
acceptTriggerDestination</STRONG>
</DT><DD>This parameter is not used.</DD>
<DT>
<STRONG>
triggerTopText</STRONG>
</DT><DD>This text will be used in the standard affirmative response trigger
instead of the default text.  If <EM>triggerTopText</EM> is NULL the
default text
will be used.  Setting <EM>triggerTopText</EM> is only valid for
GIT_PROPERTIES and GIT_NOTIFICATION type dialogs.   Note that the trigger
will still return IC_APPLY for GIT_PROPERTIES and IC_OK or
GIT_NOTIFICAITON.</DD>
<DT>
<STRONG>
arg2</STRONG>
</DT><DD>Second string argument.  Each '\002' (0x02) in the
<EM>bodyText</EM> string will be replaced by <EM>*arg2</EM>.</DD>
<DT>
<STRONG>
arg1</STRONG>
</DT><DD>First string argument.  Each '\001' (0x01) in the
<EM>bodyText</EM> string will be replaced by <EM>*arg1</EM>.</DD>
<DT>
<STRONG>
dialogFlags</STRONG>
</DT><DD>Defines various functionality of the dialog box.  Here are the
valid flags.
<UL>
	<LI>FCDBF_SYSTEM_MODAL: Set if the dialog box should be modal.
	<LI>FCDBF_DIALOG_TYPE: One of the <CODE>CustomDialogTypes</CODE>.
This allows you to define the default title icon and text of the dialog as
a CDT_QUESTION, CDT_NOTIFICATION, CDT_WARNING, or CDT_ERROR. The offset of
FCDBF_DIALOG_TYPE is defined as FCDBF_DIALOG_TYPE_OFFSET.  This allows you
to easily set the dialog type like this:
<pre>
         (customDialogType &lt&lt FCDBF_DIALOG_TYPE_OFFSET)
</pre>

	<LI>FCDBF_INTERACTION_TYPE: Defines the standard response trigger
to give to this dialog.  The following <CODE>GenInteractionTypes</CODE> may
be used: GIT_PROPERTIES, GIT_PROGRESS, GIT_COMMAND, GIT_NOTIFICATION, or
GIT_AFFIRMATION.  Example of setting the FCDBF_INTERACTION_TYPE flag:
<pre>
         (genIntType &lt&lt FCDBF_INTERACTION_TYPE_OFFSET)
</pre>

<LI>FCDBF_DESTRUCTIVE_ACTION: This flag signals that the affirmative
	response trigger (IC_YES) cannot have the default focus.  Usually,
	this is used for dialogs that have some destructive action on an
	affirmative response.
</UL>
</DD>
<DT>
<STRONG>
bodyText</STRONG>
</DT><DD>An optr to a null-terminated string containing the body of the
main text in the dialog.  This optr cannot be NULL; it must reference
an actual block of text.</DD>
<DT>
<STRONG>
titleText</STRONG>
</DT><DD>An optr to a null-terminated string containing the text for
the title bar.  If <EM>titleText</EM> is NULL, the system will choose a
standard text title depending on the <CODE>CustomDialogType</CODE> specified
in the FCDBF_DIALOG_TYPE field of the <EM>dialogFlags</EM> parameter.</DD>
<DT>
<STRONG>
titleIconBitmap</STRONG>
</DT><DD>An optr to a Bitmap struct (see <CODE>graphics.h</CODE>) that
contains the icon for the dialogs' title bar.  If <EM>titleIconBitmap</EM>
is NULL, then the system will choose a standard dialog icon depending on
the
<CODE>CustomDialogType</CODE> specified in FCDBF_DIALOG_TYPE field of the
<EM>dialogFlags</EM> parameter.</DD>
</DL>

<P CLASS="refField"><STRONG>
Return:</STRONG>
        The response trigger chosen by the user.  This value is in the form
of an <CODE>InteractionCommand</CODE> corresponding to that trigger.</P>

<P CLASS="refField"><STRONG>
Warning:</STRONG>
        This routine may resize LMem- and/or object blocks, moving them on
the heap and invalidating pointers to those blocks.</P>

<P CLASS="refField"><STRONG>
Include:</STRONG>        <STRONG CLASS="fileName">
foam.goh</STRONG>
 </P>

<P CLASS="refField"><STRONG>
See Also:</STRONG>
<CODE>FoamStandardDialogOptrNoBlock()</CODE>,
<CODE>FoamDisplayDeleteWarning()</CODE>,
<CODE>FoamDisplayDeleteWarningNoBlock()</CODE>,
<CODE>FoamDisplayError()</CODE>,
<CODE>FoamDisplayErrorNoBlock()</CODE>,
<CODE>FoamDisplayNote()</CODE>,
<CODE>FoamDisplayNoteNoBlock()</CODE>,
<CODE>FoamDisplayOkCancelWarning()</CODE>,
<CODE>FoamDisplayQuestion()</CODE>,
<CODE>FoamDisplayWarning()</CODE>,
<CODE>FoamDisplayWarningNoBlock()</CODE>.
 </P>

</DIV>



<DIV>
<A NAME="R_FoamStandardDialog.htm_IX_FoamStandardDialogOptrNoBlock()">
 </A>
<H1 CLASS="refHeading">
FoamStandardDialogOptrNoBlock()</H1>
<PRE CLASS="syntax">optr FoamStandardDialogOptrNoBlock(
   void                     *helpFile,
   void                     *helpContext,
   LayerPriority            layerPriority,
   word                     rejectTriggerMessage,
   optr                     rejectTriggerDestination,
   word                     acceptTriggerMessage,
   optr                     acceptTriggerDestination,
   optr                     triggerTopText,
   TCHAR                    *arg2,
   TCHAR                    *arg1,
   FoamCustomDialogBoxFlags dialogFlags,
   optr                     bodyText,
   optr                     titleText,
   optr                     titleIconBitmap);
</PRE>
<P>
This routine puts up a custom dialog box and returns so the thread
is not blocked.  The dialog is destroyed by the system after the user
responds to it.</P>

<P CLASS="refField"><STRONG>
Pass:   </STRONG>
</P>
<DL>
<DT>
<STRONG>
helpFile</STRONG>
</DT><DD>The name of the helpfile to associate with this dialog.  The
helpfile must be in the Userdata\Help directory on the device.</DD>
<DT>
<STRONG>
helpContext</STRONG>
</DT><DD>The context within help file to associate with this dialog.</DD>
<DT>
<STRONG>
layerPriority</STRONG>
</DT><DD>Custom layer priority to use.  Set to zero to give standard layer
priority to the dialog. </DD>
<DT>
<STRONG>
rejectTriggerMessage</STRONG>
</DT><DD>Extra message to send when a &quot;reject&quot; trigger
(IC_DISMISS, IC_STOP, IC_NO) is pressed.  Make sure to
set <EM>rejectTriggerDestination</EM> to a valid object.</DD>
<DT>
<STRONG>
rejectTriggerDestination</STRONG>
</DT><DD>Optr of object to send <EM>rejectTriggerMessage</EM> to when a
&quot;reject&quot; trigger is pressed.  Make sure to set
<EM>rejectTriggerMessage</EM> to a valid Message.</DD>
<DT>
<STRONG>
acceptTriggerMessage</STRONG>
</DT><DD>Extra message to send when an &quot;accept&quot; trigger
(IC_OK, IC_YES, IC_APPLY) is pressed.  Make sure to
set <EM>acceptTriggerDestination</EM> to a valid object.</DD>
<DT>
<STRONG>
acceptTriggerDestination</STRONG>
</DT><DD>Optr of object to send <EM>acceptTriggerMessage</EM> to when an
&quot;accept&quot; trigger is pressed.  Make sure to
set <EM>acceptTriggerMessage</EM> to a valid Message.</DD>
<DT>
<STRONG>
triggerTopText</STRONG>
</DT><DD>This text will be used in the standard affirmative response trigger
instead of the default text.  If <EM>triggerTopText</EM> is NULL the
default text
will be used.  Setting <EM>triggerTopText</EM> is only valid for
GIT_PROPERTIES and GIT_NOTIFICATION type dialogs.</DD>
<DT>
<STRONG>
arg2</STRONG>
</DT><DD>Second string argument.  Each '\002' (0x02) in the
<EM>bodyText</EM> string will be replaced by <EM>*arg2</EM>.</DD>
<DT>
<STRONG>
arg1</STRONG>
</DT><DD>First string argument.  Each '\001' (0x01) in the
<EM>bodyText</EM> string will be replaced by <EM>*arg1</EM>.</DD>
<DT>
<STRONG>
dialogFlags</STRONG>
</DT><DD>Defines various functionality of the dialog box.  Here are the
valid flags.
<UL>
	<LI>FCDBF_SYSTEM_MODAL: Set if the dialog box should be modal.
	<LI>FCDBF_DIALOG_TYPE: One of the <CODE>CustomDialogTypes</CODE>.
This allows you to define the default title icon and text of the dialog as
a CDT_QUESTION, CDT_NOTIFICATION, CDT_WARNING, or CDT_ERROR. The offset of
FCDBF_DIALOG_TYPE is defined as FCDBF_DIALOG_TYPE_OFFSET.  This allows you
to easily set the dialog type like this:
<pre>
         (customDialogType &lt&lt FCDBF_DIALOG_TYPE_OFFSET)
</pre>

	<LI>FCDBF_INTERACTION_TYPE: Defines the standard response trigger
to give to this dialog.  The following <CODE>GenInteractionTypes</CODE> may
be used: GIT_PROPERTIES, GIT_PROGRESS, GIT_COMMAND, GIT_NOTIFICATION, or
GIT_AFFIRMATION.  Example of setting the FCDBF_INTERACTION_TYPE flag:
<pre>
         (genIntType &lt&lt FCDBF_INTERACTION_TYPE_OFFSET)
</pre>

<LI>FCDBF_DESTRUCTIVE_ACTION: This flag signals that the affirmative
	response trigger (IC_YES) cannot have the default focus.  Usually,
	this is used for dialogs that have some destructive action on an
	affirmative response.
</UL>
</DD>
<DT>
<STRONG>
bodyText</STRONG>
</DT><DD>An optr to a null-terminated string containing the body of the
main text in the dialog.  This optr cannot be NULL; it must be a
valid optr.</DD>
<DT>
<STRONG>
titleText</STRONG>
</DT><DD>An optr to a null-terminated string containing the text for
the title bar.  If <EM>titleText</EM> is NULL, the system will choose a
standard text title depending on the <CODE>CustomDialogType</CODE> specified
in the FCDBF_DIALOG_TYPE field of the <EM>dialogFlags</EM> parameter.</DD>
<DT>
<STRONG>
titleIconBitmap</STRONG>
</DT><DD>An optr to a <CODE>Bitmap</CODE> struct (see
<CODE>graphics.h</CODE>) that contains the icon for the dialogs' title bar.
If <EM>titleIconBitmap</EM> is NULL, then the system will choose a standard
dialog icon depending on the <CODE>CustomDialogType</CODE> specified in
FCDBF_DIALOG_TYPE field of the <EM>dialogFlags</EM> parameter.</DD>
</DL>

<P CLASS="refField"><STRONG>
Return:</STRONG>
        The optr to the dialog box.  This optr is only valid while the
dialog box is up.  Once the user responds (by hitting a response trigger),
the dialog is destroyed, making the optr invalid.
</P>

<P CLASS="refField"><STRONG>
Warning:</STRONG>
        This routine may resize LMem- and/or object blocks, moving them on
the heap and invalidating pointers to those blocks.
</P>

<P CLASS="refField"><STRONG>
Include:</STRONG>        <STRONG CLASS="fileName">
foam.goh</STRONG>
 </P>

<P CLASS="refField"><STRONG>
See Also:</STRONG>
<CODE>FoamStandardDialogOptr()</CODE>,
<CODE>FoamDisplayDeleteWarning()</CODE>,
<CODE>FoamDisplayDeleteWarningNoBlock()</CODE>,
<CODE>FoamDisplayError()</CODE>,
<CODE>FoamDisplayErrorNoBlock()</CODE>,
<CODE>FoamDisplayNote()</CODE>,
<CODE>FoamDisplayNoteNoBlock()</CODE>,
<CODE>FoamDisplayOkCancelWarning()</CODE>,
<CODE>FoamDisplayQuestion()</CODE>,
<CODE>FoamDisplayWarning()</CODE>,
<CODE>FoamDisplayWarningNoBlock()</CODE>.
 </P>

</DIV>



<HR>
<A NAME="R_FoamStartSound.htm"></A>


<DIV>
<A NAME="R_FoamStartSound.htm_IX_FoamStartSoundSequence()">
 </A>
<H1 CLASS="refHeading">
FoamStartSoundSequence()</H1>
<PRE CLASS="syntax">void FoamStartSoundSequence(
   StandardSoundType sound,
   word              duration,
   word              interval); </PRE>
<P>
This routine is typically used to play an alarm type sound.  It
starts a sequence of <EM>sound</EM> that plays every <EM>interval</EM>
ticks for <EM>duration</EM> ticks.  If a sequence is currently sounding,
the
routine will not play your sequence; it will continue playing the
current sequence.
</P>

<P CLASS="refField"><STRONG>
Pass:   </STRONG>
</P>
<DL>
<DT>
<STRONG>
sound</STRONG>
</DT><DD>The standard sound type to play.  FOAM_FCLOCK_ALARM_SOUND may be
used to play the clock alarm.</DD>
<DT>
<STRONG>
duration</STRONG>
</DT><DD>The number of ticks at which to stop sounding the alarm.</DD>
<DT>
<STRONG>
interval</STRONG>
</DT><DD>The number of ticks to pause between playing the sound.</DD>
</DL>

<P CLASS="refField"><STRONG>
Return:</STRONG>
        None.</P>

<P CLASS="refField"><STRONG>
Warning:</STRONG>
<UL>
<LI> If another alarm is already playing, your
alarm will not sound.
<LI>  If low sound mode has been set, your alarm
will play the low level sound instead of the <CODE>StandardSoundType</CODE>.
<LI> If you call <CODE>FoamStartSoundSequence()</CODE> and bring up a
dialog, you should intercept MSG_META_KBD_CHAR for the dialog
and call <CODE>FoamStopSoundSequence()</CODE> unless you use
<CODE>FoamStandardDialogOptr()</CODE>,
<CODE>FoamStandardDialogOptrNoBlock()</CODE>, or
<CODE>StandardDialogClass</CODE>.
</UL>
</P>

<P CLASS="refField"><STRONG>
Include:</STRONG>        <STRONG CLASS="fileName">
foam.goh</STRONG>
 </P>

<P CLASS="refField"><STRONG>
See Also:</STRONG>
<CODE>FoamStopSoundSequence()</CODE>. </P>

</DIV>

<DIV>
<A NAME="R_FoamStartSound.htm_IX_FoamStopSoundSequence()">
 </A>
<H1 CLASS="refHeading">
FoamStopSoundSequence()</H1>
<PRE CLASS="syntax">void FoamStopSoundSequence();
 </PRE>
<P>
Stop any alarm that was started by <CODE>FoamStartSoundSequence()</CODE>.

</P>

<P CLASS="refField"><STRONG>
Pass:   </STRONG> None.
</P>

<P CLASS="refField"><STRONG>
Return:</STRONG>
        None.</P>

<P CLASS="refField"><STRONG>
Include:</STRONG>        <STRONG CLASS="fileName">
foam.goh</STRONG>
 </P>

<P CLASS="refField"><STRONG>
See Also:</STRONG>
<CODE>FoamStartSoundSequence()</CODE>.
 </P>

</DIV>



<DIV>
<A NAME="R_FoamStartSound.htm_IX_FoamUTOffset()">
 </A>
<H1 CLASS="refHeading">
FoamUTOffset()</H1>
<PRE CLASS="syntax">signed int FoamUTOffset();
 </PRE>
<P>
Return the difference between the current home city (in the .ini file) and
GMT (or universal time).</P>

<P CLASS="refField"><STRONG>
Pass:   </STRONG> None.
</P>

<P CLASS="refField"><STRONG>
Return:</STRONG>
        The number of minutes from GMT.</P>

<P CLASS="refField"><STRONG>
Include:</STRONG>        <STRONG CLASS="fileName">
foam.goh</STRONG>
 </P>

<P CLASS="refField"><STRONG>
See Also:</STRONG>
None.
 </P>

</DIV>




<DIV>
<A NAME="R_FoamStartSound.htm_IX_FoamWarnForSaving()">
 </A>
<H1 CLASS="refHeading">
FoamWarnForSaving()</H1>
<PRE CLASS="syntax">FoamSaveAction FoamWarnForSaving(
   dword  space );</PRE>
<P>
Puts up a dialog box to warn the user of low disk space, but only if
the disk space is approaching full. This routine should be used by any
editable view (e.g., Contact Card, Notes editor).</P>

<P CLASS="refField"><STRONG>
Pass:   </STRONG>
</P>
<DL>
<DT>
<STRONG>
space</STRONG>
</DT><DD>Disk space required, in bytes.</DD>
</DL>

<P CLASS="refField"><STRONG>
Return:</STRONG>
The action you should take. Possible values are:
<UL>
<LI>FSA_SAVE_DATA
<LI>FSA_THROW_AWAY_CHANGES
<LI>FSA_DO_NOTHING
</UL>
</P>

<P CLASS="refField"><STRONG>
Warning:</STRONG>
This routine may resize LMem and/or object blocks, moving them on the heap
and invalidating stored segment pointers to them.
</P>

<P CLASS="refField"><STRONG>
Include:</STRONG>        <STRONG CLASS="fileName">
foam.goh</STRONG>
 </P>

<P CLASS="refField"><STRONG>
See Also:</STRONG>
<CODE>FoamWarnIfNotEnoughSpace()</CODE>,
<CODE>FoamWarnIfOutOfSpace()</CODE>,
<CODE>FoamWarnSpaceAfterOperation()</CODE>.
 </P>

</DIV>



<DIV>
<A NAME="R_FoamStartSound.htm_IX_FoamWarnIfNotEnoughSpace()">
 </A>
<H1 CLASS="refHeading">
FoamWarnIfNotEnoughSpace()</H1>
<PRE CLASS="syntax">FoamDiskSpaceStatus FoamWarnIfNotEnoughSpace(
   dword  space );</PRE>
<P>
Puts up the appropiate dialogs depending on the disk space available.
Should be called before performing a specific operation that may consume
disk space. (e.g., receiving a fax, receiving mail, reading/fetching mail,
downloading WWW files, printing).
</P>

<P CLASS="refField"><STRONG>
Pass:   </STRONG>
</P>
<DL>
<DT>
<STRONG>
space</STRONG>
</DT><DD>Disk space required, in bytes.</DD>
</DL>

<P CLASS="refField"><STRONG>
Return:</STRONG>
        How close to full the disk space will be. Possible values are:
<ul>
<li>FDSS_NOT_FULL (disk space &gt 50K)
<li>FDSS_NEARLY_FULL (25K &lt disk space &lt 50K)
<li>FDSS_FULL (disk space &lt 25K)
</ul>
</P>


<P CLASS="refField"><STRONG>
Warning:</STRONG> This routine may resize LMem and/or object blocks, moving
them on the heap and invalidating stored segment pointers to them.
</P>

<P CLASS="refField"><STRONG>
Include:</STRONG>        <STRONG CLASS="fileName">
foam.goh</STRONG>
 </P>

<P CLASS="refField"><STRONG>
See Also:</STRONG>
<CODE>FoamWarnForSaving()</CODE>,
<CODE>FoamWarnIfOutOfSpace()</CODE>,
<CODE>FoamWarnSpaceAfterOperation()</CODE>.
 </P>

</DIV>


<DIV>
<A NAME="R_FoamStartSound.htm_IX_FoamWarnIfOutOfSpace()">
 </A>
<H1 CLASS="refHeading">
FoamWarnIfOutOfSpace()</H1>
<PRE CLASS="syntax">Boolean FoamWarnIfOutOfSpace();
 </PRE>
<P>
Puts up a warning dialog box depending on how much free disk space is
available. This routine is used mainly by the system to check space after
system booted/cover opened/system unlocked. This routine calls
<CODE>FoamCheckIfOutOfSpace()</CODE> to determine the amount of space
left.</P>

<P CLASS="refField"><STRONG>
Pass:   </STRONG> None.
</P>

<P CLASS="refField"><STRONG>
Return:</STRONG>
        FALSE if space is okay, TRUE if out of space.</P>

<P CLASS="refField"><STRONG>
Warning:</STRONG>
        This routine may resize LMem and/or object blocks, moving them on
the heap and invalidating stored segment pointers to them.</P>

<P CLASS="refField"><STRONG>
Include:</STRONG>        <STRONG CLASS="fileName">
foam.goh</STRONG>
 </P>

<P CLASS="refField"><STRONG>
See Also:</STRONG>
<CODE>FoamWarnForSaving()</CODE>,
<CODE>FoamWarnIfNotEnoughSpace()</CODE>,
<CODE>FoamWarnSpaceAfterOperation()</CODE>.
</P>

</DIV>



<DIV>
<A NAME="R_FoamStartSound.htm_IX_FoamWarnSpaceAfterOperation()">
 </A>
<H1 CLASS="refHeading">
FoamWarnSpaceAfterOperation()</H1>
<PRE CLASS="syntax">FoamDiskSpaceStatus FoamWarnSpaceAfterOperation(); </PRE>
<P>
Returns the available disk space status level. This should be called after
executing an operation that has consumed disk space.</P>

<P CLASS="refField"><STRONG>
Pass:   </STRONG>
None.
</P>

<P CLASS="refField"><STRONG>
Return:</STRONG>
    Status indicating the amount of available disk space. Possible values are:
<ul>
<li>FDSS_NOT_FULL (disk space &gt 50K)
<li>FDSS_NEARLY_FULL (25K &lt disk space &lt 50K)
<li>FDSS_FULL (disk space &lt 25K)
</ul>
</P>

<P CLASS="refField"><STRONG>
Include:</STRONG>        <STRONG CLASS="fileName">
foam.goh</STRONG>
 </P>

<P CLASS="refField"><STRONG>
See Also:</STRONG>
<CODE>FoamWarnForSaving()</CODE>,
<CODE>FoamWarnIfNotEnoughSpace()</CODE>,
<CODE>FoamWarnIfOutOfSpace()</CODE>.
 </P>

</DIV>




<HR>
<A NAME="R_2f.htm"></A>
<DIV>
</DIV>

<DIV>
<A NAME="R_2f.htm_IX_FormatIDFromManufacturerAndType()">
 </A>
<H1 CLASS="refHeading">
FormatIDFromManufacturerAndType</H1>
<PRE CLASS="syntax">dword	FormatIDFromManufacturerAndType(mfr, type);
        ManufacturerIDs 			mfr;
        ClipboardItemFormat 			type;</PRE>
<P>
This macro takes a manufacturer ID and a format type (e.g. CIF_TEXT) and combines them into a dword argument of the type <CODE>
ClipboardItemFormatID</CODE>
.</P>
</DIV>
<DIV>
<A NAME="R_2f.htm_IX_free()">
 </A>
<H1 CLASS="refHeading">
free()</H1>
<PRE CLASS="syntax">void 	free(
        void * blockPtr);				/* address of memory to free */</PRE>
<P>
The <CODE>
<A HREF="../../CRef/Routines/R_6a.htm#IX_malloc()">malloc()</A></CODE>
 family of routines is provided for Standard C compatibility. The kernel will allocate a fixed block to satisfy the geode's <CODE>
<A HREF="../../CRef/Routines/R_6a.htm#IX_malloc()">malloc()</A></CODE>
 requests; it will allocate memory from this block. When the block is filled, it will allocate another fixed malloc-block. When all the memory in the block is freed, the memory manager will automatically free the block.</P>
<P>
When a geode is finished with some memory it requested from <CODE>
<A HREF="../../CRef/Routines/R_6a.htm#IX_malloc()">malloc()</A></CODE>
, it should free the memory. That makes it easier for <CODE>
<A HREF="../../CRef/Routines/R_6a.htm#IX_malloc()">malloc()</A></CODE>
 to satisfy memory request. It can free the memory by passing the address which was returned by <CODE>
<A HREF="../../CRef/Routines/R_6a.htm#IX_malloc()">malloc()</A></CODE>
 (or <CODE>
<A HREF="../../CRef/Routines/R_3.htm#IX_calloc()">calloc()</A></CODE>
 or <CODE>
<A HREF="../../CRef/Routines/R_83.htm#IX_realloc()">realloc()</A></CODE>
) when the memory was allocated. All of the memory will be freed.</P>
<P>
The memory must be in a malloc-block assigned to the geode calling <CODE>
free()</CODE>
. If you want to free memory in another geode's malloc-block, call <CODE>
<A HREF="../../CRef/Routines/R_36.htm#IX_GeoFree()">GeoFree()</A></CODE>
.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
stdlib.h</STRONG>
 </P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	Pass exactly the same address as the one returned to you when you allocated the memory. If you pass a different address, <CODE>
free()</CODE>
 will take unpredictable actions, including possibly erasing other memory or crashing the system.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_3.htm#IX_calloc()">calloc()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_6a.htm#IX_malloc()">malloc()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_36.htm#IX_GeoFree()">GeoFree()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_83.htm#IX_realloc()">realloc()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_2f.htm_IX_FractionOf() macro">
 </A>
<H1 CLASS="refHeading">
FractionOf()</H1>
<PRE CLASS="syntax">word	FractionOf(
        WWFixedAsDWord		wwf);</PRE>
<P>
This macro returns the fractional portion of a <CODE>
WWFixedAsDWord</CODE>
 value.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
geos.h</STRONG>
</P>
</DIV>
<HR>
<A NAME="R_30.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_30.htm_IX_GCNListAdd()">
 </A>
<H1 CLASS="refHeading">
GCNListAdd()</H1>
<PRE CLASS="syntax">Boolean	GCNListAdd(
        optr		OD,				/* optr to add to list */
        ManufacturerID		manufID,				/* manufacturer ID of list */
        word		listType);				/* list type */</PRE>
<P>
This routine adds an object pointer (optr) to a GCN list interested in a particular change. The routine must be passed the optr to add, along with the <CODE>
manufID</CODE>
 and the type of the list to add it to. If no list of the specified manufacturer and type currently exists, a new list will be created.</P>
<P>
This routine will return <CODE>
true</CODE>
 if the optr was successfully added to the GCN list and <CODE>
false</CODE>
 if the optr could not be added. An optr cannot be added to a GCN list if it currently exists on that list.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gcnlist.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_30.htm_IX_GCNListAddHandles()">
 </A>
<H1 CLASS="refHeading">
GCNListAddHandles()</H1>
<PRE CLASS="syntax">Boolean	GCNListAddHandles(
        MemHandle		mh,				/* handle of object to add */
        ChunkHandle		ch,				/* chunk of object to add */
        ManufacturerIDs		manufID,				/* manufacturer ID of list */
        word		listType);				/* list type */</PRE>
<P>
This routine is exactly the same as <CODE>
<A HREF="../../CRef/Routines/R_30.htm#IX_GCNListAdd()">GCNListAdd()</A></CODE>
, except it takes the memory and chunk handles of the object rather than a complete optr.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gcnlist.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_30.htm_IX_GCNListAddToBlock()">
 </A>
<H1 CLASS="refHeading">
GCNListAddToBlock()</H1>
<PRE CLASS="syntax">Boolean	GCNListAddToBlock(
        optr		OD,				/* optr of list to add */
        ManufacturerID		manufID,				/* manufacturer ID of list */
        word		listType,				/* list type */
        MemHandle		mh,				/* handle of block holding list */
        ChunkHandle		listOfLists);				/* chunk of list of lists
							 * in block */</PRE>
<P>
This routine adds a new GCN list to a block containing the GCN lists. Pass it the optr of the chunk containing the new GCN list as well as the list's type and manufacturer ID. Pass also the memory handle and chunk handle of the chunk containing the GCN &quot;list of lists&quot; which will manage the new list.</P>
<P>
This routine returns true of the new optr is added to the GCN mechanism, false if it could not be added (if it was already there).</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	This routine may resize chunks in the block, so you should dereference any pointers after calling this routine.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gcnlist.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_30.htm_IX_GCNListCreateBlock()">
 </A>
<H1 CLASS="refHeading">
GCNListCreateBlock()</H1>
<PRE CLASS="syntax">ChunkHandle GCNListCreateBlock(
        MemHandle mh);			/* handle of the locked LMem block */</PRE>
<P>
This routine creates a list of lists for the GCN mechanism. It is rarely, if ever, called by applications. Pass it the handle of the locked LMem block in which the list should be created.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gcnlist.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_30.htm_IX_GCNListDestroyBlock()">
 </A>
<H1 CLASS="refHeading">
GCNListDestroyBlock()</H1>
<PRE CLASS="syntax">void	GCNListDestroyBlock(
        MemHandle		mh,					/* handle of locked block to
							 * be destroyed */</PRE>
<PRE CLASS="syntax">        ChunkHandle		listOfLists);					/* chunk of list of lists */</PRE>
<P>
This routine destroys a GCN list of lists and all the GCN lists associated with it. Pass it the handle of the locked LMem block containing the lists as well as the chunk handle of the chunk containing the list of lists.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gcnlist.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_30.htm_IX_GCNListDestroyList()">
 </A>
<H1 CLASS="refHeading">
GCNListDestroyList()</H1>
<PRE CLASS="syntax">void	GCNListDestroyList(
        optr	list);		/* optr of the GCN list to be destroyed */</PRE>
<P>
This routine destroys the specified GCN list.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gcnlist.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_30.htm_IX_GCNListRelocateBlock()">
 </A>
<H1 CLASS="refHeading">
GCNListRelocateBlock()</H1>
<PRE CLASS="syntax">void	GCNListRelocateBlock(
        MemHandle		mh,					/* handle of locked LMem block
							 * containing GCN lists */</PRE>
<PRE CLASS="syntax">        ChunkHandle		listOfLists,					/* chunk of list of lists */
        MemHandle		relocBlock);					/* handle of block containing
							 * relocation information */</PRE>
<P>
This routine relocates the GCN list of lists in the specified block, updating all the optrs stored therein.</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	This routine can resize and/or move the LMem block, so you should dereference pointers after calling it.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gcnlist.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_30.htm_IX_GCNListRemove()">
 </A>
<H1 CLASS="refHeading">
GCNListRemove()</H1>
<PRE CLASS="syntax">Boolean	GCNListRemove(
        optr		OD,				/* the optr to be removed */
        ManufacturerID		manufID,				/* manufacturer ID of the list */
        word		listType);				/* list type */</PRE>
<P>
This routine removes the passed optr from the specified GCN list. The routine must be passed the optr to remove along with the manufacturer ID and list type of the list to remove it from.</P>
<P>
This routine will return <CODE>
true</CODE>
 if the optr was successfully removed from the GCN list and <CODE>
false</CODE>
 if the optr could not be found on the GCN list and therefore could not be removed.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gcnlist.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_30.htm_IX_GCNListRemoveFromBlock()">
 </A>
<H1 CLASS="refHeading">
GCNListRemoveFromBlock()</H1>
<PRE CLASS="syntax">Boolean	GCNListRemoveFromBlock(
        optr		OD,				/* optr of GCN list to remove */
        ManufacturerID		manufID,				/* manufacturer of list to remove */
        word		listType,				/* type of list being removed */
        MemHandle		mh,				/* handle of locked LMem block
						 * containing the list of lists */</PRE>
<PRE CLASS="syntax">        ChunkHandle		listOfLists);				/* chunk of list of lists */</PRE>
<P>
This routine removes a GCN list from a GCN list block and from the list of lists therein.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gcnlist.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_30.htm_IX_GCNListRemoveHandles()">
 </A>
<H1 CLASS="refHeading">
GCNListRemoveHandles()</H1>
<PRE CLASS="syntax">Boolean	GCNListRemoveHandles(
        MemHandle		mh,
        ChunkHandle		ch,
        ManufacturerID		manufID,
        word		listType);</PRE>
<P>
This routine is exactly the same as <CODE>
<A HREF="../../CRef/Routines/R_30.htm#IX_GCNListRemove()">GCNListRemove()</A></CODE>
, except it specifies the object to be removed via handles rather than an optr.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gcnlist.goh</STRONG>
 </P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_30.htm#IX_GCNListRemove()">GCNListRemove()</A></CODE>.</P>
</DIV>
<HR>
<A NAME="R_31.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_31.htm_IX_GCNListSend()">
 </A>
<A NAME="R_31.htm_IX_GCNListSendFlags:with GCNListSend()">
 </A>
<H1 CLASS="refHeading">
GCNListSend()</H1>
<PRE CLASS="syntax">word	GCNListSend(
        ManufacturerID		manufID,						/* manufacturer of list */
        word		listType,						/* notification type */
        EventHandle		event,						/* event to be sent to list */
        MemHandle		dataBlock,						/* data block, if any */
        word		gcnListSendFlags);						/* GCNListSendFlags */</PRE>
<P>
This routine sends a message to all objects in the specified GCN list. The message is specified in <CODE>
event</CODE>
, and the list is specified in <CODE>
manufID</CODE>
 and <CODE>
listType</CODE>
. The message will be sent asynchronously (some time after the change has occurred) by the message queue. </P>
<P>
The <CODE>
dataBlock</CODE>
 parameter contains the memory handle of an extra data block to be sent with the notification, if any; this block should also be specified in the classed event. If no data block is required, pass a NullHandle. If a data block with a reference cound is used, increment the reference count by one before calling this routine; this routine decrements the count and frees the block if the count reaches zero.</P>
<P>
The <CODE>
gcnListSendFlags</CODE>
 parameter is of type <CODE>
GCNListSendFlags</CODE>
, which has only one meaningful flag for this routine:</P>
<DL>
<DT>
GCNLSF_SET_STATUS</DT><DD>
Causes the message sent to the GCN list to be set as the lists &quot;status.&quot; The list's status message is then sent to any object adding itself to the list at a later time. If this flag is set, the event handle in <CODE>
event</CODE>
 will be returned by the routine. If this flag is not set, the return value will be the number of messages sent out.</DD>
</DL>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gcnlist.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_31.htm_IX_GCNListSendToBlock()">
 </A>
<H1 CLASS="refHeading">
GCNListSendToBlock()</H1>
<PRE CLASS="syntax">word	GCNListSendToBlock(
        ManufacturerID		manufID,				/* manufacturer id of list */
        word		listType,				/* notification type */
        EventHandle		event,				/* event to be sent to list */
        MemHandle		dataBlock,				/* data block, if any */
        MemHandle		mh,				/* handle of locked LMem block
						 * containing GCN list of lists */</PRE>
<PRE CLASS="syntax">        ChunkHandle		listOfLists,				/* chunk of list of lists */
        GCNListSendFlags		flags);				/* GCNListSendFlags */</PRE>
<P>
This routine sends the specified <CODE>
event</CODE>
 to the specified list, just as <CODE>
<A HREF="../../CRef/Routines/R_31.htm#IX_GCNListSend()">GCNListSend()</A></CODE>
. <CODE>
GCNListSendToBlock()</CODE>
, however, specifies a particular instance of the GCN list by specifying the appropriate list of lists in <CODE>
mh</CODE>
 and <CODE>
listOfLists</CODE>
. Other parameters and return values are identical to <CODE>
<A HREF="../../CRef/Routines/R_31.htm#IX_GCNListSend()">GCNListSend()</A></CODE>
.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_31.htm#IX_GCNListSend()">GCNListSend()</A></CODE>.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gcnlist.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_31.htm_IX_GCNListSendToList()">
 </A>
<H1 CLASS="refHeading">
GCNListSendToList()</H1>
<PRE CLASS="syntax">void	GCNListSendToList(
        optr		list,				/* optr of GCN list */
        EventHandle		event,				/* event to send to list */
        MemHandle		dataBlock,				/* handle of data block, if any */
        GCNListSendFlags		flags);				/* GCNListSendFlags */</PRE>
<P>
This routine sends the specified <CODE>
event</CODE>
 to the specified GCN <CODE>
list</CODE>
. The list is specified explicitly by optr as opposed to by manufacturer ID and type. The event will be sent via the proper queues to all objects registered on the list. After the notification is handled by all notified objects, the event will be freed, as will the data block passed. (If no data block, pass NullHandle in <CODE>
dataBlock</CODE>
)</P>
<P>
The <CODE>
flags</CODE>
 parameter can have one flag, GCNLSF_SET_STATUS. If this flag is set, the event passed will be set as the list's status message.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gcnlist.goh</STRONG>
 </P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_31.htm#IX_GCNListSend()">GCNListSend()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_31.htm_IX_GCNListSendToListHandles()">
 </A>
<H1 CLASS="refHeading">
GCNListSendToListHandles()</H1>
<PRE CLASS="syntax">void	GCNListSendToListHandles(
        MemHandle		mh,				/* handle of list's block */
        ChunkHandle		ch,				/* chunk of list */
        EventHandle		event,				/* event to send to list */
        MemHandle		dataBlock,				/* handle of data block, if any */
        GCNListSendFlags		flags);				/* GCNListSendFlags */</PRE>
<P>
This routine is exactly the same as <CODE>
<A HREF="../../CRef/Routines/R_31.htm#IX_GCNListSendToList()">GCNListSendToList()</A></CODE>
; the list is specified not by optr, however, but by a combination of its global and chunk handles.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_31.htm#IX_GCNListSendToList()">GCNListSendToList()</A></CODE>.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gcnlist.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_31.htm_IX_GCNListUnRelocateBlock()">
 </A>
<H1 CLASS="refHeading">
GCNListUnRelocateBlock()</H1>
<PRE CLASS="syntax">Boolean	GCNListUnRelocateBlock(
        MemHandle		mh,				/* handle of the locked lmem block
						 * containing the list of lists */</PRE>
<PRE CLASS="syntax">        ChunkHandle		listOfLists,				/* chunk of the list of lists */
        MemHandle		relocBlock);				/* handle of block containing
						 * relocation/unrelocation info */</PRE>
<P>
This routine unrelocates the specified list of lists, updating all the optrs according to the information in <EM>
relocBlock</EM>
. This routine is rarely, if ever, used by applications; it is used primarily by the UI when shutting down to a state file.</P>
<P>
It returns <CODE>
true</CODE>
 if the specified list of lists has no lists saved to state and therefore is simply destroyed. The return value is <CODE>
false</CODE>
 if the list of lists is saved to the state file normally.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gcnlist.goh</STRONG>
 </P>
</DIV>
<HR>
<A NAME="R_32.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_32.htm_IX_GenCopyChunk()">
 </A>
<H1 CLASS="refHeading">
GenCopyChunk()</H1>
<PRE CLASS="syntax">word	GenCopyChunk(
        MemHandle		destBlock,			/* handle of locked LMem block into
					 * which chunk will be copied */</PRE>
<PRE CLASS="syntax">        MemHandle		blk,			/* handle of locked source LMem block */
        ChunkHandle		chnk,			/* chunk handle of chunk to be copied */
        word		flags);			/* CompChildFlags */</PRE>
<P>
This is a utility routine that copies one LMem chunk into a newly created chunk. The routine will allocate the new chunk in the block passed in <CODE>
destBlock</CODE>
 and will return the chunk handle of the new chunk. It is used primarily by the UI to duplicate generic object chunks.</P>
<P>
The source chunk is specified by the global handle <CODE>
blk</CODE>
 and the chunk handle <CODE>
chnk</CODE>
. The <CODE>
flags</CODE>
 parameter contains a record of <CODE>
CompChildFlags</CODE>
, of which only the CCF_MARK_DIRTY flag is meaningful. If this flag is set, the new chunk will be marked dirty.</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	This routine may resize and/or move chunks and blocks, so you must dereference pointers after calling it.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
genC.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_32.htm_IX_GenFindObjectInTree()">
 </A>
<H1 CLASS="refHeading">
GenFindObjectInTree()</H1>
<PRE CLASS="syntax">optr	GenFindObjectInTree(
        optr	startObject,		/* optr of object at which to start search */
        dword	childTable);		/* pointer to table of bytes, each indicating
			 * the position of the child at the given
			 * level; -1 is the end of the table */</PRE>
<P>
This utility routine finds the object having the optr <CODE>
startObject</CODE>
 in the generic tree. Applications will not likely need this routine.</P>
<P>
The childTable parameter points to a table of bytes, each byte representing the child number to be found at each level. The first byte indicates the child of startObject to get; the second byte indicates the child to get at the next level; the third byte indicates the child to get at the next level, and so on. A byte of -1 indicates the end of the table. The object found will be returned.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
genC.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_32.htm_IX_GenInsertChild()">
 </A>
<H1 CLASS="refHeading">
GenInsertChild()</H1>
<PRE CLASS="syntax">void	GenInsertChild(
        MemHandle		mh,					/* handle of parent */
        ChunkHandle		chnk,					/* chunk of parent */
        optr		childToAdd,					/* optr of new child */
        optr		referenceChild,					/* optr of reference child */
        word		flags);					/* CompChildFlags */</PRE>
<P>
This utility routine adds a child object to a composite object. It is used almost exclusively by the UI for generic objects--applications will typically use <CODE>
MSG_GEN_ADD_CHILD</CODE>
.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE>MSG_GEN_ADD_CHILD</CODE>.</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	This routine may move or resize chunks and/or object blocks; therefore, you must dereference pointers after calling it.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
genC.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_32.htm_IX_GenProcessAction()">
 </A>
<H1 CLASS="refHeading">
GenProcessAction()</H1>
<P>
This is an Esp-only routine. In most cases, Goc programmers will use <CODE>
MSG_GEN_OUTPUT_ACTION</CODE>
 instead.</P>
</DIV>
<DIV>
<A NAME="R_32.htm_IX_GenProcessGenAttrsAfterAction()">
 </A>
<H1 CLASS="refHeading">
GenProcessGenAttrsAfterAction()</H1>
<PRE CLASS="syntax">void	GenProcessGenAttrsAfterAction(
        MemHandle		mh,		/* handle of object calling the routine */
        ChunkHandle		chnk);		/* chunk of object calling the routine */</PRE>
<P>
This utility routine processes various attributes for a generic object after the object's action message has been sent. It is used almost exclusively by the generic UI after <CODE>
MSG_GEN_OUTPUT_ACTION</CODE>
 or <CODE>
<A HREF="../../CRef/Routines/R_32.htm#IX_GenProcessAction()">GenProcessAction()</A></CODE>
.</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	This routine may move or resize chunks and/or object blocks; therefore, you must dereference pointers after calling it.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
genC.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_32.htm_IX_GenProcessGenAttrsBeforeAction()">
 </A>
<H1 CLASS="refHeading">
GenProcessGenAttrsBeforeAction()</H1>
<PRE CLASS="syntax">void	GenProcessGenAttrsBeforeAction(
        MemHandle		mh,		/* handle of object calling the routine */
        ChunkHandle		chnk);		/* chunk of object calling the routine */</PRE>
<P>
This utility routine processes various attributes for a generic object before the object's action message has been sent. It is used almost exclusively by the generic UI before <CODE>
MSG_GEN_OUTPUT_ACTION</CODE>
 or <CODE>
<A HREF="../../CRef/Routines/R_32.htm#IX_GenProcessAction()">GenProcessAction()</A></CODE>
.</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	This routine may move or resize chunks and/or object blocks; therefore, you must dereference pointers after calling it.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
genC.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_32.htm_IX_GenProcessUndoGetFile()">
 </A>
<H1 CLASS="refHeading">
GenProcessUndoGetFile()</H1>
<PRE CLASS="syntax">VMFileHandle GenProcessUndoGetFile();</PRE>
<P>
This routine returns the handle of the file that holds the process' undo information.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
Objects/gProcC.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_32.htm_IX_GenProcessUndoCheckIfIgnoring()">
 </A>
<H1 CLASS="refHeading">
GenProcessUndoCheckIfIgnoring()</H1>
<PRE CLASS="syntax">Boolean GenProcessUndoCheckIfIgnoring();</PRE>
<P>
This routine returns <EM>
true</EM>
 if the process is currently ignoring actions.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
Objects/gProcC.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_32.htm_IX_GenRemoveDownwardLink()">
 </A>
<H1 CLASS="refHeading">
GenRemoveDownwardLink()</H1>
<PRE CLASS="syntax">void	GenRemoveDownwardLink(
        MemHandle		mh,			/* handle of calling object */
        ChunkHandle		chnk,			/* chunk of calling object */
        word		flags);			/* CompChildFlags */</PRE>
<P>
This utility routine removes a child from the generic tree, preserving the child's upward link and usability flags. It is called primarily by the generic UI and is rarely used by applications. The flags parameter specifies whether the object linkage should be marked dirty by passing the CCF_MARK_DIRTY flag.</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	This routine may move or resize chunks and/or object blocks; therefore, you must dereference pointers after calling it.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
genC.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_32.htm_IX_GenSetUpwardLink()">
 </A>
<H1 CLASS="refHeading">
GenSetUpwardLink()</H1>
<PRE CLASS="syntax">void	GenSetUpwardLink(
        MemHandle		mh,			/* handle of calling object */
        ChunkHandle		chnk,			/* chunk of calling object */
        optr		parent);			/* optr of calling object's parent */</PRE>
<P>
This utility routine converts the child/parent link to an upward-only link. Pass the handle and chunk of the locked child object and the optr of the parent composite.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
genC.goh</STRONG>
 </P>
</DIV>
<HR>
<A NAME="R_33.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_33.htm_IX_GeodeAllocQueue()">
 </A>
<H1 CLASS="refHeading">
GeodeAllocQueue()</H1>
<PRE CLASS="syntax">QueueHandle GeodeAllocQueue();</PRE>
<P>
This routine allocates an event queue which can then be attached to a thread with <CODE>
<A HREF="../../CRef/Routines/R_96.htm#IX_ThreadAttachToQueue()">ThreadAttachToQueue()</A></CODE>
. It returns the queue's handle if one is allocated; it will return zero otherwise. This routine is used outside the kernel only in exceptional circumstances.</P>
<P CLASS="refField"><STRONG>
Be Sure To:</STRONG>	You must free the queue when you are done with it; use <CODE>
<A HREF="../../CRef/Routines/R_33.htm#IX_GeodeFreeQueue()">GeodeFreeQueue()</A></CODE>
.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
geode.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_33.htm_IX_GeodeDuplicateResource()">
 </A>
<H1 CLASS="refHeading">
GeodeDuplicateResource()</H1>
<PRE CLASS="syntax">MemHandle GeodeDuplicateResource(
        MemHandle mh);		/* handle of geode resource to duplicate */</PRE>
<P>
This routine reads a resource from a geode into a newly-allocated block (allocated by this routine). Any relocations on the resource to itself are adjusted to be the duplicated block. The handle of the duplicated block is returned.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
resource.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_33.htm_IX_GeodeFind()">
 </A>
<H1 CLASS="refHeading">
GeodeFind()</H1>
<PRE CLASS="syntax">GeodeHandle GeodeFind(
        const char	* name,			/* geode's permanent name */
        word		numChars,		/* number of characters to match:
				 		 * 8 for name, 12 for name.ext */
	GeodeAttrs	attrMatch,		/* GeodeAttrs that must be set */
        GeodeAttrs	attrNoMatch);		/* GeodeAttrs that must be off */</PRE>
<P>
This routine finds a geode given its permanent name, returning the geode handle if found. If the geode can not be found, a null handle will be returned. Pass it the following:</P>
<DL>
<DT>
<CODE>
name</CODE>
</DT><DD>A pointer to the null-terminated permanent name of the geode.</DD>
<DT>
<CODE>
numChars</CODE>
</DT><DD>The number of characters to match before returning. Pass GEODE_NAME_SIZE to match the permanent name, (GEODE_NAME_SIZE + GEODE_NAME_EXT_SIZE) to match the name and extension.</DD>
<DT>
<CODE>
attrMatch</CODE>
</DT><DD>A record of <CODE>
GeodeAttrs</CODE>
 the subject geode must have set for a positive match.</DD>
<DT>
<CODE>
attrNoMatch</DT><DD>
</CODE>
A record of <CODE>
GeodeAttrs</CODE>
 the subject geode must have cleared for a positive match.</DD>
</DL>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
geode.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_33.htm_IX_GeodeFindResource()">
 </A>
<H1 CLASS="refHeading">
GeodeFindResource()</H1>
<PRE CLASS="syntax">word	GeodeFindResource(
        FileHandle	file,			/* geode's executable file */
        word		resNum,			/* resource number to find */
        word		resOffset,		/* offset to resource */
        dword		* base);		/* pointer to second return value */</PRE>
<P>
This routine locates a resource within a geode's executable (<STRONG CLASS="fileName">
.geo</STRONG>
) file. It returns the size of the resource as well as the base position of the first byte of the resource in the file (pointed to by <CODE>
base</CODE>
). Pass the following:</P>
<DL>
<DT>
<CODE>
file</CODE>
</DT><DD>The file handle of the geode's executable file.</DD>
<DT>
<CODE>
resNum</CODE>
</DT><DD>The number of the resource to be found.</DD>
<DT>
<CODE>
resOffset</CODE>
</DT><DD>The offset within the resource at which to position the file's read/write position.</DD>
<DT>
<CODE>
base</CODE>
</DT><DD>A pointer to a dword value to be filled in by the routine. This value will be the base offset from the beginning of the file to the first byte of the resource.</DD>
</DL>
<P CLASS="refField"><STRONG>
Structures:</STRONG>	A geode's executable file is laid out as shown below.</P>
<PRE>0:	Geode file header</PRE>
<PRE>1:	Imported Library Table</PRE>
<PRE>2:	Exported Routine Table</PRE>
<PRE>3:	Resource Size Table</PRE>
<PRE>4:	Resource Position Table</PRE>
<PRE>5:	Relocation Table Size Table</PRE>
<PRE>6:	Allocation Flags Table</PRE>
<PRE>7+:	application resources</PRE>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
geode.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_33.htm_IX_GeodeFlushQueue()">
 </A>
<H1 CLASS="refHeading">
GeodeFlushQueue()</H1>
<PRE CLASS="syntax">void	GeodeFlushQueue(
        QueueHandle	source,			/* source queue to flush */
        QueueHandle	dest,			/* queue to hold flushed events */
        optr		obj			/* object to handle flushed events */
        MessageFlags	flags);			/* MF_INSERT_AT_FRONT or zero */</PRE>
<P>
This routine flushes all events from one event queue into another, synchronously. Pass it the following:</P>
<DL>
<DT>
<CODE>
source</CODE>
</DT><DD>The queue handle of the source queue (the one to be emptied).</DD>
<DT>
<CODE>
dest</CODE>
</DT><DD>The queue handle of the destination queue that will receive the flushed events.</DD>
<DT>
<CODE>
obj</CODE>
</DT><DD>The object that will handle flushed events that were destined for the process owning the source queue. If the process owning the destination queue should be used, pass the destination queue handle in the handle portion of the optr and a null chunk handle.</DD>
<DT>
<CODE>
flags</CODE>
</DT><DD>A record of <CODE>
MessageFlags</CODE>
. The only meaningful flag for this routine is MF_INSERT_AT_FRONT, which should be set to flush source queue's events to the front of the destination queue. If this flag is not passed, events will be appended to the queue.</DD>
</DL>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
geode.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_33.htm_IX_GeodeFreeDriver()">
 </A>
<H1 CLASS="refHeading">
GeodeFreeDriver()</H1>
<PRE CLASS="syntax">void	GeodeFreeDriver(
        GeodeHandle gh);			/* handle of the driver */</PRE>
<P>
This routine frees a driver geode that had been loaded with <CODE>
<A HREF="../../CRef/Routines/R_35.htm#IX_GeodeUseDriver()">GeodeUseDriver()</A></CODE>
. Pass it the geode handle of the driver as returned by that routine.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
driver.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_33.htm_IX_GeodeFreeLibrary()">
 </A>
<H1 CLASS="refHeading">
GeodeFreeLibrary()</H1>
<PRE CLASS="syntax">void	GeodeFreeLibrary(
        GeodeHandle gh);			/* handle of the library */</PRE>
<P>
This routine frees a library geode that had been loaded with <CODE>
<A HREF="../../CRef/Routines/R_35.htm#IX_GeodeUseLibrary()">GeodeUseLibrary()</A></CODE>
. Pass it the geode handle of the library.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
library.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_33.htm_IX_GeodeFreeQueue()">
 </A>
<H1 CLASS="refHeading">
GeodeFreeQueue()</H1>
<PRE CLASS="syntax">void	GeodeFreeQueue(
        QueueHandle qh);			/* handle of queue being freed */</PRE>
<P>
This routine frees an event queue allocated with <CODE>
<A HREF="../../CRef/Routines/R_33.htm#IX_GeodeAllocQueue()">GeodeAllocQueue()</A></CODE>
. Any events still on the queue will be flushed as with <CODE>
<A HREF="../../CRef/Routines/R_33.htm#IX_GeodeFlushQueue()">GeodeFlushQueue()</A></CODE>
. You must pass the handle of the queue to be freed.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
geode.h</STRONG>
 </P>
</DIV>
<HR>
<A NAME="R_34.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_34.htm_IX_GeodeGetAppObject()">
 </A>
<H1 CLASS="refHeading">
GeodeGetAppObject()</H1>
<PRE CLASS="syntax">optr	GeodeGetAppObject(
        GeodeHandle gh);			/* handle of the application geode */</PRE>
<P>
This routine returns the optr of the specified geode's GenApplication object. The geode should be an application. Pass zero to get the optr of the caller's application object.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
geode.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_34.htm_IX_GeodeGetCodeProcessHandle()">
 </A>
<H1 CLASS="refHeading">
GeodeGetCodeProcessHandle()</H1>
<PRE CLASS="syntax">GeodeHandle GeodeGetCodeProcessHandle();</PRE>
<P>
This routine returns the geode handle of the geode that owns the block in which the code which calls this routine resides.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
geode.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_34.htm_IX_GeodeGetDefaultDriver()">
 </A>
<H1 CLASS="refHeading">
GeodeGetDefaultDriver()</H1>
<PRE CLASS="syntax">GeodeHandle GeodeGetDefaultDriver(
        GeodeDefaultDriverType type);		/* type of default driver to get */</PRE>
<P>
This routine returns the default driver's geode handle for the type passed. The type must be one of the values of <CODE>
GeodeDefaultDriverType</CODE>
.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
driver.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_34.htm_IX_GeodeGetInfo()">
 </A>
<A NAME="R_34.htm_IX_GeodeGetInfoType">
 </A>
<A NAME="R_34.htm_IX_GGIT_&ldots;">
 </A>
<H1 CLASS="refHeading">
GeodeGetInfo()</H1>
<PRE CLASS="syntax">word	GeodeGetInfo(
        GeodeHandle	  gh,			/* handle of the subject geode */
        GeodeGetInfoType  info,			/* type of information to return */
        void	 	* buf);			/* buffer to contain returned info */</PRE>
<P>
This routine returns information about the specified geode. The geode must be loaded already. The meaning of the returned word depends on the value passed in <CODE>
info</CODE>
; the <CODE>
GeodeGetInfoType</CODE>
 is shown below. Pass the following:</P>
<DL>
<DT>
<CODE>
gh</CODE>
</DT><DD>The geode handle of the geode. If gh is null then the routine will return the information of the current geode.</DD>
<DT>
<CODE>
info</CODE>
</DT><DD>The type of information requested; this should be one of the values listed below.</DD>
<DT>
<CODE>
buf</CODE>
</DT><DD>A pointer to a locked or fixed buffer which will contain returned information for various types requested.</DD>
</DL>
<P>
<CODE>
GeodeGetInfoType</CODE>
 has the following enumerations (only one may be requested at a time):</P>
<DL>
<DT>
GGIT_ATTRIBUTES</DT><DD>
Get the geode's attributes. The return value will be a record of <CODE>
GeodeAttrs</CODE>
 corresponding to those attributes set for the geode. Pass a null buffer pointer.</DD>
<DT>
 GGIT_TYPE</DT><DD>Get the type of the geode. The returned value will be a value of <CODE>
GeosFileType</CODE>
 indicating the type of file storing the geode. Pass a null buffer pointer.</DD>
<DT>
 GGIT_GEODE_RELEASE</DT><DD>
Get the release number of the geode. The returned word will be the size of the buffer pointed to by <CODE>
buf</CODE>
, and the buffer will contain the <CODE>
ReleaseNumber</CODE>
 structure of the geode.</DD>
<DT>
 GGIT_GEODE_PROTOCOL</DT><DD>
Get the protocol level of the geode. The returned word will be the size of the buffer pointed to by <CODE>
buf</CODE>
, and the buffer will contain the <CODE>
ProtocolNumber</CODE>
 structure of the geode.</DD>
<DT>
 GGIT_TOKEN_ID</DT><DD>
Get the token identifier of the geode. The returned word will be the size of the buffer pointed to by <CODE>
buf</CODE>
, and the buffer will contain a <CODE>
GeodeToken</CODE>
 structure containing the token characters and token ID of the geode's token.</DD>
<DT>
 GGIT_PERM_NAME_AND_EXT</DT><DD>
Get the permanent name of the geode, with the extension characters. The returned word will be the size of the buffer pointed to by <CODE>
buf</CODE>
, and the buffer will contain a null-terminated character string representing the geode's permanent name (as set in its geode parameters file). Note that the buffer must be at least 13 bytes.</DD>
<DT>
GGIT_PERM_NAME_ONLY</DT><DD>
Get the permanent name of the geode without the extension characters. The returned word will be the size of the buffer pointed to by buf, and the buffer will contain the null-terminated character string representing the geode's permanent name. The buffer must be at least nine bytes.</DD>
</DL>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
geode.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_34.htm_IX_GeodeGetOptrNS()">
 </A>
<H1 CLASS="refHeading">
GeodeGetOptrNS()</H1>
<PRE CLASS="syntax">optr	GeodeGetOptrNS(
        optr	obj);</PRE>
<P>
This routine unrelocates an optr, changing the virtual-segment handle to an actual global handle.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
resource.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_34.htm_IX_GeodeGetProcessHandle()">
 </A>
<H1 CLASS="refHeading">
GeodeGetProcessHandle()</H1>
<PRE CLASS="syntax">GeodeHandle GeodeGetProcessHandle();</PRE>
<P>
This routine returns the geode handle of the current executing process (i.e. the owner of the current running thread). Use it when you need to pass your application's geode handle or Process object's handle to a routine or message.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
geode.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_34.htm_IX_GeodeGetUIData()">
 </A>
<H1 CLASS="refHeading">
GeodeGetUIData()</H1>
<PRE CLASS="syntax">word	GeodeGetUIData(
        GeodeHandle		gh);</PRE>
<P>
 </P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
geode.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_34.htm_IX_GeodeInfoDriver()">
 </A>
<H1 CLASS="refHeading">
GeodeInfoDriver()</H1>
<PRE CLASS="syntax">DriverInfoStruct  * GeodeInfoDriver(
        GeodeHandle gh);	 /* handle of the driver to get information about */</PRE>
<P>
This routine returns information about the specified driver geode. Pass the geode handle of the driver as returned by <CODE>
<A HREF="../../CRef/Routines/R_35.htm#IX_GeodeUseDriver()">GeodeUseDriver()</A></CODE>
. It returns a pointer to a <CODE>
DriverInfoStruct</CODE>
 structure, shown below.</P>
<PRE>typedef struct {
    void			(*DIS_strategy)();
    DriverAttrs			DIS_driverAttributes;
    DriverType			DIS_driverType;
} DriverInfoStruct;</PRE>
<P>
For full information on this structure, see the <CODE>
DriverInfoStruct</CODE>
 reference entry.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
driver.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_34.htm_IX_GeodeInfoQueue()">
 </A>
<H1 CLASS="refHeading">
GeodeInfoQueue()</H1>
<PRE CLASS="syntax">word	GeodeInfoQueue(
        QueueHandle qh);			/* queue to query */</PRE>
<P>
This routine returns information about a specific event queue. Pass the handle of the queue; for information about the current process' queue, pass a null handle. This routine returns the number of events (or messages) currently in the queue.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
geode.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_34.htm_IX_GeodeLoad()">
 </A>
<H1 CLASS="refHeading">
GeodeLoad()</H1>
<PRE CLASS="syntax">GeodeHandle GeodeLoad(
        const char *		name,				/* file name of geode */
        GeodeAttrs		attrMatch,				/* GeodeAttrs that must be set */
        GeodeAttrs		attrNoMatch,				/* GeodeAttrs that must be clear */
        word		priority,				/* priority of the loaded geode */
        dword		appInfo,				/* special load information */
        GeodeLoadError *		err);				/* returned error value */</PRE>
<P>
This routine loads the specified geode from the given file and then executes the geode based on its type. It returns the geode handle of the loaded geode if successful; if unsuccessful, the returned value will be NullHandle and the <CODE>
err</CODE>
 pointer will point to an error value. Pass this routine the following:</P>
<DL>
<DT>
<CODE>
name</CODE>
</DT><DD>A pointer to the name of the geode's file. This is a null-terminated character string that represents the full path of the file (or a path relative to the current working directory).</DD>
<DT>
<CODE>
attrMatch</CODE>
</DT><DD>A record of <CODE>
GeodeAttrs</CODE>
 that must be set in the specified geode for the load to be successful.</DD>
<DT>
<CODE>
attrNoMatch</DT><DD>
</CODE>
A record of <CODE>
GeodeAttrs</CODE>
 that must be cleared in the specified geode for the load to be successful. (That is, each bit which is set in <CODE>
attrNoMatch</CODE>
 must be clear in the geode's <CODE>
GeodeAttrs</CODE>
 field.)</DD>
<DT>
<CODE>
priority</CODE>
</DT><DD>If the subject geode is a process, this is the priority at which its process thread will run.</DD>
<DT>
<CODE>
appInfo</CODE>
</DT><DD>Two words of data to be passed directly to the loaded geode. For libraries and drivers, this should be a far pointer to a null-terminated string of parameters.</DD>
<DT>
<CODE>
err</CODE>
</DT><DD>A pointer to an empty <CODE>
GeodeLoadError</CODE>
 which will hold any returned error values.</DD>
</DL>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	If you load a geode dynamically with <CODE>
GeodeLoad()</CODE>
, you must be sure to free it when you are done with <CODE>
<A HREF="../../CRef/Routines/R_33.htm#IX_GeodeFreeDriver()">GeodeFreeDriver()</A></CODE>
 or <CODE>
<A HREF="../../CRef/Routines/R_33.htm#IX_GeodeFreeLibrary()">GeodeFreeLibrary()</A></CODE>
.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
geode.h</STRONG>
 </P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_9e.htm#IX_UserLoadApplication()">UserLoadApplication()</A></CODE>.</P>
</DIV>
<HR>
<A NAME="R_35.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_35.htm_IX_GeodeLoadDGroup()">
 </A>
<A NAME="R_35.htm_IX_dgroup:GeodeLoadDGroup()">
 </A>
<H1 CLASS="refHeading">
GeodeLoadDGroup</H1>
<PRE CLASS="syntax">void	GeodeLoadDGroup(
        MemHandle		mh);</PRE>
<P>
This routine forces the <CODE>
dgroup</CODE>
 segment into the data-segment register. This routine expects the <CODE>
MemHandle</CODE>
 of the code resource, which can be retrieved with <CODE>
<A HREF="../../CRef/Routines/R_34.htm#IX_GeodeGetCodeProcessHandle()">GeodeGetCodeProcessHandle()</A></CODE>
.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
resource.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_35.htm_IX_GeodePrivAlloc()">
 </A>
<A NAME="R_35.htm_IX_Geodes:private data">
 </A>
<A NAME="R_35.htm_IX_Private data:GeodePrivAlloc()">
 </A>
<H1 CLASS="refHeading">
GeodePrivAlloc()</H1>
<PRE CLASS="syntax">word	GeodePrivAlloc(
        GeodeHandle		gh,				/* handle of the owner of the
						 * newly-allocated private data */</PRE>
<PRE CLASS="syntax">        word		numWords);				/* number of words to allocate */</PRE>
<P>
This routine allocates a string of contiguous words in all geodes' private data areas; each set of words will be owned by the geode specified in <CODE>
gh</CODE>
. The data allocated can be accessed with <CODE>
<A HREF="../../CRef/Routines/R_35.htm#IX_GeodePrivWrite()">GeodePrivWrite()</A></CODE>
 and <CODE>
<A HREF="../../CRef/Routines/R_35.htm#IX_GeodePrivRead()">GeodePrivRead()</A></CODE>
 and must be freed with <CODE>
<A HREF="../../CRef/Routines/R_35.htm#IX_GeodePrivFree()">GeodePrivFree()</A></CODE>
. The return value will be the offset to the start of the allocated range, or zero if the routine could not allocate the space.</P>
<P>
Each geode has a block of private data the is accessed using the <CODE>
GeodePriv...()</CODE>
 routines. A specific geode's private data block is expanded only when a valid <CODE>
<A HREF="../../CRef/Routines/R_35.htm#IX_GeodePrivWrite()">GeodePrivWrite()</A></CODE>
 is performed for the geode. Space is &quot;allocated&quot; in the data blocks of all geodes (loaded or yet-to-be loaded) simultaneously via a call to <CODE>
GeodePrivAlloc()</CODE>
. Data that have never been written are returned as all zeros.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
geode.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_35.htm_IX_GeodePrivFree()">
 </A>
<H1 CLASS="refHeading">
GeodePrivFree()</H1>
<PRE CLASS="syntax">void	GeodePrivFree(
        word	offset,		/* offset returned by GeodePrivAlloc() */
        word	numWords);		/* number of words to free */</PRE>
<P>
This routine frees a group of contiguous words from all geodes' private data areas. The space must previously have been allocated with <CODE>
<A HREF="../../CRef/Routines/R_35.htm#IX_GeodePrivAlloc()">GeodePrivAlloc()</A></CODE>
. Pass the offset to the words as returned by <CODE>
<A HREF="../../CRef/Routines/R_35.htm#IX_GeodePrivAlloc()">GeodePrivAlloc()</A></CODE>
 as well as the number of words to be freed.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
geode.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_35.htm_IX_GeodePrivRead()">
 </A>
<H1 CLASS="refHeading">
GeodePrivRead()</H1>
<PRE CLASS="syntax">void	GeodePrivRead(
        GeodeHandle		gh,			/* handle of owner of private data */
        word		offset,			/* offset returned by
					 * GeodePrivAlloc() */</PRE>
<PRE CLASS="syntax">        word		numWords,			/* number of words to read */
        word		* dest);			/* pointer to buffer into which data
					 * will be copied */</PRE>
<P>
This routine reads a number of words from the geode's private data area. Pass the following:</P>
<DL>
<DT>
<CODE>
gh</CODE>
</DT><DD>The geode handle of the owner of the private data to be read.</DD>
<DT>
<CODE>
offset</CODE>
</DT><DD>The offset to the private data as returned by <CODE>
<A HREF="../../CRef/Routines/R_35.htm#IX_GeodePrivAlloc()">GeodePrivAlloc()</A></CODE>
.</DD>
<DT>
<CODE>
numWords</CODE>
</DT><DD>The number of words to read.</DD>
<DT>
<CODE>
dest</CODE>
</DT><DD>A pointer to a locked or fixed buffer into which the words should be read. It must be at least <CODE>
numWords</CODE>
 words long.</DD>
</DL>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
geode.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_35.htm_IX_GeodePrivWrite()">
 </A>
<H1 CLASS="refHeading">
GeodePrivWrite()</H1>
<PRE CLASS="syntax">void	GeodePrivWrite(
        GeodeHandle		gh,			/* handle of owner of private data */
        word		offset,			/* offset returned by
						 * GeodePrivAlloc() */</PRE>
<PRE CLASS="syntax">        word		numWords,			/* number of words to be written */
        word		* src);			/* buffer containing data */</PRE>
<P>
This routine writes a number of words into a geode's private data area. The area being written must have been allocated previously with <CODE>
<A HREF="../../CRef/Routines/R_35.htm#IX_GeodePrivAlloc()">GeodePrivAlloc()</A></CODE>
. Pass the following:</P>
<DL>
<DT>
<CODE>
gh</CODE>
</DT><DD>The geode handle of the owner of the private data space.</DD>
<DT>
<CODE>
offset</CODE>
</DT><DD>The offset to begin writing to, as returned by <CODE>
<A HREF="../../CRef/Routines/R_35.htm#IX_GeodePrivAlloc()">GeodePrivAlloc()</A></CODE>
.</DD>
<DT>
<CODE>
numWords</CODE>
</DT><DD>The number of words to be written. This should be no more than had been previously allocated.</DD>
<DT>
<CODE>
src</CODE>
</DT><DD>A pointer to the locked or fixed buffer containing the data to be written.</DD>
</DL>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
geode.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_35.htm_IX_GeodeSetDefaultDriver()">
 </A>
<H1 CLASS="refHeading">
GeodeSetDefaultDriver()</H1>
<PRE CLASS="syntax">void	GeodeSetDefaultDriver(
        GeodeDefaultDriverType			type,		/* type of default driver to set */
        GeodeHandle			gh);		/* driver to set as the default */</PRE>
<P>
This routine sets the default driver for the indicated driver type. Pass the type of default driver in <CODE>
type</CODE>
 and the handle of the driver in <CODE>
gh</CODE>
. The type must be a value of <CODE>
GeodeDefaultDriverType</CODE>
.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
driver.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_35.htm_IX_GeodeSetUIData()">
 </A>
<H1 CLASS="refHeading">
GeodeSetUIData()</H1>
<PRE CLASS="syntax">void	GeodeSetUIData(
        GeodeHandle		gh,
        word		data)</PRE>
<P>
  </P>
</DIV>
<DIV>
<A NAME="R_35.htm_IX_GeodeUseDriver()">
 </A>
<H1 CLASS="refHeading">
GeodeUseDriver()</H1>
<PRE CLASS="syntax">GeodeHandle GeodeUseDriver(
        const	char	* name,				/* file name of driver to load */
        word		protoMajor,				/* expected major protocol */
        word		protoMinor,				/* expected minor protocol */
        GeodeLoadError		* err);				/* pointer to returned error */</PRE>
<P>
This routine dynamically loads a driver geode given the driver's file name. It returns the geode handle of the driver if successful; if unsuccessful, it returns an error code of type <CODE>
GeodeLoadError</CODE>
 pointed to by <CODE>
err</CODE>
. Pass this routine the following:</P>
<DL>
<DT>
<CODE>
name</CODE>
</DT><DD>A pointer to the driver's null-terminated full path and file name.</DD>
<DT>
<CODE>
protoMajor</CODE>
</DT><DD>The expected major protocol of the driver. If zero, any protocol is acceptable.</DD>
<DT>
<CODE>
protoMinor</CODE>
</DT><DD>The expected minor protocol of the driver.</DD>
<DT>
<CODE>
err</CODE>
</DT><DD>A pointer to a <CODE>
GeodeLoadError</CODE>
 in which any error values will be returned.</DD>
</DL>
<P CLASS="refField"><STRONG>
Tips and Tricks:</STRONG>	It is much easier to automatically load the drivers you need by noting them in your geode parameters file.</P>
<P CLASS="refField"><STRONG>
Be Sure To:</STRONG>	If you use <CODE>
GeodeUseDriver()</CODE>
 to dynamically load a driver, you must also use <CODE>
<A HREF="../../CRef/Routines/R_33.htm#IX_GeodeFreeDriver()">GeodeFreeDriver()</A></CODE>
 to free it when you are done using it.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
driver.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_35.htm_IX_GeodeUseLibrary()">
 </A>
<H1 CLASS="refHeading">
GeodeUseLibrary()</H1>
<PRE CLASS="syntax">GeodeHandle GeodeUseLibrary(
        const char	 *	name,				/* file name of library to load */
        word		protoMajor,				/* expected major protocol */
        word		protoMinor,				/* expected minor protocol */
        GeodeLoadError *		err);				/* pointer to returned error */</PRE>
<P>
This routine dynamically loads a library geode when given the library's file name. (The library must be in the thread's working directory.) It returns the geode handle of the loaded library if successful; if unsuccessful, it returns an error code (<CODE>
GeodeLoadError</CODE>
) pointed to by <CODE>
err</CODE>
. Pass this routine the following parameters:</P>
<DL>
<DT>
<CODE>
name</CODE>
</DT><DD>A pointer to the library's null-terminated file name.</DD>
<DT>
<CODE>
protoMajor</CODE>
</DT><DD>The expected major protocol of the library. If zero, any protocol is acceptable.</DD>
<DT>
<CODE>
protoMinor</CODE>
</DT><DD>The expected minor protocol of the library.</DD>
<DT>
<CODE>
err</CODE>
</DT><DD>A pointer to a <CODE>
GeodeLoadError</CODE>
 which will contain any returned error values.</DD>
</DL>
<P CLASS="refField"><STRONG>
Be Sure To:</STRONG>	If you dynamically load a library with <CODE>
GeodeUseLibrary()</CODE>
, you must manually free it when finished, with <CODE>
<A HREF="../../CRef/Routines/R_33.htm#IX_GeodeFreeLibrary()">GeodeFreeLibrary()</A></CODE>
.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
library.h</STRONG>
 </P>
</DIV>
<HR>
<A NAME="R_36.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_36.htm_IX_GeoFree()">
 </A>
<H1 CLASS="refHeading">
GeoFree()</H1>
<PRE CLASS="syntax">void	* GeoFree(
        void		* blockPtr,				/* address of memory to free */
        GeodeHandle		geodeHan);				/* owner of block to be used */</PRE>
<P>
The routine <CODE>
<A HREF="../../CRef/Routines/R_6a.htm#IX_malloc()">malloc()</A></CODE>
 can free only memory in the malloc-block belonging to the calling geode. If you want to free memory in another geode's malloc-block, call <CODE>
GeoFree()</CODE>
. Passing a null <CODE>
GeodeHandle</CODE>
 will make <CODE>
<A HREF="../../CRef/Routines/R_36.htm#IX_GeoMalloc()">GeoMalloc()</A></CODE>
 act on memory in the calling geode's malloc-block.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
geode.h</STRONG>
 </P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	Pass exactly the same address as the one returned to you when you allocated the memory. If you pass a different address, <CODE>
GeoFree()</CODE>
 will take unpredictable actions, including possibly erasing other memory or crashing the system.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_2f.htm#IX_free()">free()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_36.htm_IX_GeoMalloc()">
 </A>
<H1 CLASS="refHeading">
GeoMalloc()</H1>
<PRE CLASS="syntax">void	* GeoMalloc(
        size_t		blockSize,				/* # of bytes to allocate*/
        GeodeHandle		geodeHan,				/* Owner of block to be used */
        word		zeroInit);				/* Zero-initialize memory? */</PRE>
<P>
The routine <CODE>
<A HREF="../../CRef/Routines/R_6a.htm#IX_malloc()">malloc()</A></CODE>
 automatically allocates memory in the malloc-block belonging to the calling geode. It does not zero-initialize the memory. If you want to zero-initialize the memory, or want to allocate it in another geode's malloc-block, call <CODE>
GeoMalloc()</CODE>
. Pass <EM>
true</EM>
 (i.e., non-zero) in <CODE>
zeroInit</CODE>
 to zero-initialize the memory.</P>
<P>
Passing a null <CODE>
GeodeHandle</CODE>
 will make <CODE>
GeoMalloc()</CODE>
 allocate the memory in the calling geode's malloc-block. If &quot;zeroInit&quot; is true, the memory will be initialized to null bytes; otherwise, the memory will be left uninitialized.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
geode.h</STRONG>
 </P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	All memory allocated with <CODE>
<A HREF="../../CRef/Routines/R_6a.htm#IX_malloc()">malloc()</A></CODE>
 is freed when GEOS shuts down.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_6a.htm#IX_malloc()">malloc()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_36.htm_IX_GeoReAlloc()">
 </A>
<H1 CLASS="refHeading">
GeoReAlloc()</H1>
<PRE CLASS="syntax">void	* GeoReAlloc(
        void		* blockPtr,				/* address of memory to resize */
        size_t		newSize,				/* New size in bytes */
        GeodeHandle		geodeHan);				/* Owner of block to be used */</PRE>
<P>
The routine <CODE>
<A HREF="../../CRef/Routines/R_83.htm#IX_realloc()">realloc()</A></CODE>
 can resize only memory in the malloc-block belonging to the calling geode. If you want to resize memory in another geode's malloc-block, call <CODE>
GeoReAlloc()</CODE>
. Passing a null <CODE>
GeodeHandle</CODE>
 will make <CODE>
GeoReAlloc()</CODE>
 act on memory in the calling geode's malloc-block.</P>
<P>
If the block is resized larger, the new memory will not be zero-initialized. Resizing a block smaller will never fail. If <CODE>
GeoReAlloc()</CODE>
 fails, it will return a null pointer (zero). If you pass a <CODE>
newSize</CODE>
 of zero, the passed block pointer is freed and the return pointer is a null pointer.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
geode.h</STRONG>
 </P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	Pass exactly the same address as the one returned to you when you allocated the memory. If you pass a different address, <CODE>
GeoReAlloc()</CODE>
 will take unpredictable actions, including possibly erasing other memory or crashing the system.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_83.htm#IX_realloc()">realloc()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_36.htm_IX_GrApplyRotation()">
 </A>
<H1 CLASS="refHeading">
GrApplyRotation()</H1>
<PRE CLASS="syntax">void	GrApplyRotation(
        GStateHandle		gstate,			/* GState to alter */
        WWFixedAsDWord		angle); 			/* degrees counterclockwise */</PRE>
<P>
Apply a rotation to the GState's transformation matrix.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_36.htm_IX_GrApplyScale()">
 </A>
<H1 CLASS="refHeading">
GrApplyScale()</H1>
<PRE CLASS="syntax">void	GrApplyScale(
        GStateHandle		gstate,			/* GState to alter */
        WWFixedAsDWord		xScale,			/* new x scale factor */
        WWFixedAsDWord		yScale);			/* new y scale factor */</PRE>
<P>
Apply a scale factor to the GState's transformation matrix.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_36.htm_IX_GrApplyTransform()">
 </A>
<H1 CLASS="refHeading">
GrApplyTransform()</H1>
<PRE CLASS="syntax">void	GrApplyTransform(
        GStateHandle		gstate,			/* GState to draw to */
        const TransMatrix		*tm);			/* transformation matrix to apply */</PRE>
<P>
Apply a transformation, expressed as a transformation matrix, to a GState's coordinate system.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<HR>
<A NAME="R_37.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_37.htm_IX_GrApplyTranslation()">
 </A>
<H1 CLASS="refHeading">
GrApplyTranslation()</H1>
<PRE CLASS="syntax">void	GrApplyTranslation(
        GStateHandle		gstate,			/* GState to alter */
        WWFixedAsDWord		xTrans,			/* translation in x */
        WWFixedAsDWord		yTrans);			/* translation in y */</PRE>
<P>
Apply a translation to the GState.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_37.htm_IX_GrApplyTranslationDWord()">
 </A>
<H1 CLASS="refHeading">
GrApplyTranslationDWord()</H1>
<PRE CLASS="syntax">void	GrApplyTranslationDWord(
        GStateHandle		gstate,			/* GState to alter */
        sdword		xTrans,			/* extended translation in x */
        sdword		yTrans);			/* extended translation in y */</PRE>
<P>
Apply a 32-bit integer extended translation to the GState.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_37.htm_IX_GrBeginPath()">
 </A>
<H1 CLASS="refHeading">
GrBeginPath()</H1>
<PRE CLASS="syntax">void	GrBeginPath(
        GStateHandle		gstate,			/* GState to alter */
        PathCombineType		params);			/* path parameters */</PRE>
<P>
Starts or alters the path associated with a GState. All graphics operations that are executed until <CODE>
<A HREF="../../CRef/Routines/R_3e.htm#IX_GrEndPath()">GrEndPath()</A></CODE>
 is called become part of the path.</P>
<P>
Depending on the value of the <CODE>
params</CODE>
 field, the new path may replace the old path, or may be combined with the old path by intersection or union.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_37.htm_IX_GrBeginUpdate()">
 </A>
<H1 CLASS="refHeading">
GrBeginUpdate()</H1>
<PRE CLASS="syntax">void 	GrBeginUpdate(
        GStateHandle gstate);			/* GState to draw to */</PRE>
<P>
Called by an application to signal that it is about to begin updating the exposed region. This routine is normally called as part of a <CODE>
MSG_META_EXPOSED</CODE>
 handler. Blanks out the invalid area.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
win.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_37.htm_IX_Video drivers:blitting">
 </A>
<A NAME="R_37.htm_IX_GrBitBlt()">
 </A>
<A NAME="R_37.htm_IX_BLTMode">
 </A>
<A NAME="R_37.htm_IX_BLTM_&ldots;">
 </A>
<H1 CLASS="refHeading">
GrBitBlt()</H1>
<PRE CLASS="syntax">void	GrBitBlt(
        GStateHandle		gstate,				/* GState to draw to */
        sword		sourceX,				/* original x origin */
        sword		sourceY,				/* original y origin */
        sword		destX,				/* new x origin */
        sword		destY,				/* new y origin */
        word		width,				/* width of area */
        word		height,				/* height of area */
        BLTMode		mode);				/* draw mode (see below) */</PRE>
<P>
Transfer a bit-boundary block of pixels between two locations in video memory. This routine is useful for animation and other applications which involve moving a drawing around the screen.</P>
<P CLASS="refField"><STRONG>
Structures:</STRONG>	</P>
<PRE CLASS="syntax">        	typedef enum /* word */ {
    BLTM_COPY, 				/* Leave source region alone */
    BLTM_MOVE, 				/* Clear &amp; invalidate source rect */
    BLTM_CLEAR				/* Clear source rectangle */
} BLTMode;</PRE>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_37.htm_IX_GrBrushPolyline()">
 </A>
<H1 CLASS="refHeading">
GrBrushPolyline()</H1>
<PRE CLASS="syntax">void	GrBrushPolyline(
        GStateHandle		gstate,			/* GState to draw to */
        const Point		* points,			/* array of Point structures to draw */
        word		numPoints,			/* number of points in array */
        word		brushH,			/* brush height */
        word		brushW);			/* brush width */</PRE>
<P>
Draw a brushed connected polyline. Note that this routine ignores the GState's line width, and instead uses a brush height and width, measured in pixels.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_37.htm_IX_GrCharMetrics()">
 </A>
<A NAME="R_37.htm_IX_GCM_Info">
 </A>
<A NAME="R_37.htm_IX_GCMI_&ldots;">
 </A>
<H1 CLASS="refHeading">
GrCharMetrics()</H1>
<PRE CLASS="syntax">dword	GrCharMetrics(
        GStatehandle		gstate,			/* GState to get metrics for */
        GCM_info		info,			/* information to return */
        word		ch);			/* character of type Chars */</PRE>
<P>
Returns metric information for a single character of a font. This information is used to determine the drawing bounds for a character. To find out how wide a character is (how much space to leave for it if drawing a line of text character-by-character), use <CODE>
<A HREF="../../CRef/Routines/R_37.htm#IX_GrCharWidth()">GrCharWidth()</A></CODE>
 instead.</P>
<P CLASS="refField"><STRONG>
Structures:</STRONG>	</P>
<PRE CLASS="syntax">        	typedef enum {
    GCMI_MIN_X, 						/* return = value &lt;&lt; 16 */
    GCMI_MIN_X_ROUNDED,					 	/* return = value */
    GCMI_MIN_Y, 						/* return = value &lt;&lt; 16 */
    GCMI_MIN_Y_ROUNDED,				 		/* return = value &lt;&lt; 16 */
    GCMI_MAX_X, 						/* return = value &lt;&lt; 16 */
    GCMI_MAX_X_ROUNDED, 						/* return = value &lt;&lt; 16 */
    GCMI_MAX_Y, 						/* return = value &lt;&lt; 16 */
    GCMI_MAX_Y_ROUNDED 						/* return = value &lt;&lt; 16 */
} GCM_Info;</PRE>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_37.htm#IX_GrCharWidth()">GrCharWidth()</A></CODE>.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
font.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_37.htm_IX_GrCharWidth()">
 </A>
<H1 CLASS="refHeading">
GrCharWidth()</H1>
<PRE CLASS="syntax">dword	GrCharWidth( /* Returns width &lt;&lt; 16 */
        GStateHandle		gstate,			/* GState to query */
        word		ch);			/* character of type Chars */</PRE>
<P>
Return the width of a single character. Note that this routine does not take into account track kerning, pairwise kerning, space padding, or other attributes that apply to multiple characters.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_37.htm_IX_GrCheckFontAvailID()">
 </A>
<H1 CLASS="refHeading">
GrCheckFontAvailID()</H1>
<PRE CLASS="syntax">FontID 	GrCheckFontAvailID(
        FontEnumFlags 		flags,
        word 		family,
        FontID 		id);</PRE>
<P>
See if font (identified by ID) exists.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_37.htm_IX_GrCheckFontAvailName()">
 </A>
<H1 CLASS="refHeading">
GrCheckFontAvailName()</H1>
<PRE CLASS="syntax">FontID 	GrCheckFontAvailName(
        FontEnumFlags 		flags,
        word 		family,
        const char 		* name);</PRE>
<P>
See if font (identified by name) exists.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<HR>
<A NAME="R_38.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_38.htm_IX_GrClearBitmap()">
 </A>
<H1 CLASS="refHeading">
GrClearBitmap()</H1>
<PRE CLASS="syntax">void	GrClearBitmap(
        GStateHandle 	gstate);			/* GState to affect */</PRE>
<P>
Clear out the content of a bitmap. Note that the part of the bitmap actually cleared depends on the bitmap mode. For the normal mode, the data portion of the bitmap is cleared. If the bitmap is in BM_EDIT_MASK mode, then the mask is cleared and the data portion is left alone.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_38.htm_IX_GrCloseSubPath()">
 </A>
<H1 CLASS="refHeading">
GrCloseSubPath()</H1>
<PRE CLASS="syntax">void	GrCloseSubPath(
        GStateHandle gstate);			/* GState to affect */</PRE>
<P>
Geometrically closes the currently open path segment. Note that you must still call <CODE>
<A HREF="../../CRef/Routines/R_3e.htm#IX_GrEndPath()">GrEndPath()</A></CODE>
 to end the path definition.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_38.htm_IX_GrComment()">
 </A>
<H1 CLASS="refHeading">
GrComment()</H1>
<PRE CLASS="syntax">void	GrComment(
        GStateHandle		gstate,			/* GState to affect */
        const void  		* data,			/* comment string */
        word		size);			/* Size of data, in bytes */</PRE>
<P>
Write a comment out to a graphics string.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_38.htm_IX_GrCopyGString()">
 </A>
<H1 CLASS="refHeading">
GrCopyGString()</H1>
<PRE CLASS="syntax">GSRetType GrCopyGString(
        GStateHandle		source,			/* GState from which to get GString */
        GStateHandle		dest,			/* GState to which to copy GString */
        GSControl 		flags);			/* flags for the copy */</PRE>
<P>
Copy all or part of a Graphics String. The <CODE>
GSControl</CODE>
 record can have the following flags:</P>
<PRE> GSC_ONE			/* just do one element */
 GSC_MISC			/* return on MISC opcode */
 GSC_LABEL			/* return on GR_LABEL opcode */
 GSC_ESCAPE			/* return on GR_ESCAPE opcode */
 GSC_NEW_PAGE			/* return when we get to a NEW_PAGE */
 GSC_XFORM			/* return on TRANSFORMATIONopcode */
 GSC_OUTPUT:			/* return on OUTPUT opcode */
 GSC_ATTR			/* return on ATTRIBUTE opcode */
 GSC_PATH			/* return on PATH opcode */</PRE>
<P>
The return value can be any one of <CODE>
GSRetType</CODE>
, a byte-size field:</P>
<PRE>GSRT_COMPLETE
GSRT_ONE
GSRT_MISC
GSRT_LABEL
GSRT_ESCAPE
GSRT_NEW_PAGE
GSRT_XFORM
GSRT_OUTPUT
GSRT_ATTR
GSRT_PATH
GSRT_FAULT</PRE>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_38.htm_IX_GrCreateBitmap()">
 </A>
<H1 CLASS="refHeading">
GrCreateBitmap()</H1>
<PRE CLASS="syntax">VMBlockHandle GrCreateBitmap(
        BMFormat 		initFormat,				/* color fomat of bitmap */
        word		initWidth,				/* initial width of bitmap */
        word		initHeight,				/* initial height of bitmap */
        VMFileHandle 		vmFile,				/* VM file to hold bitmap's data*/
        optr 		exposureOD,				/* optr to get MSG_META_EXPOSED */
        GStateHandle		* bmgs);				/* Draws to this GState
							 * will draw to the bitmap */</PRE>
<P>
This routine allocates memory for a bitmap and creates an off-screen window in which to hold the bitmap. This routine takes the following arguments:</P>
<DL>
<DT>
<EM>initFormat</EM></DT><DD>The depth of the bitmap's color.</DD>
<DT>
<EM>initWidth</EM></DT><DD>Bitmap's width.</DD>
<DT>
<EM>initHeight</EM></DT><DD>Bitmap's height.</DD>
<DT>
<EM>vmFile</EM></DT><DD>File to hold the bitmap data; the routine will allocate a block within this file.</DD>
<DT>
<EM>exposureOD</EM>	Object which will receive the &quot;exposed&quot; message when the bitmap's window is invalidated. If this argument is zero, then no exposed message will be sent. </DT><DD>
Remember that an off-screen window is created to house the bitmap. When this window is first created, it will be invalid, and it is conceivable that later actions could cause it to become invalid again. On these occasions, the object specified by this argument will receive a MSG_META_EXPOSED.</DD>
<DT>
<EM>bmgs</EM></DT><DD>The GStateHandle pointed to by this argument can start out as null; the routine will use it to return the GState by which the bitmap can be drawn to. Any graphics routines which draw to this returned GState will be carried out upon the bitmap.</DD>
</DL>
<P>
The routine returns a <CODE>
VMBlockHandle</CODE>
, the handle of the block within the passed VM file which contains the bitmap's data. The block will be set up as the first block of a HugeArray. Its header area will be filled with the following:</P>
<DL>
<DT>
Complex Bitmap Header</DT><DD>
This is a <CODE>
CBitmap</CODE>
 structure which contains some basic information about the bitmap.</DD>
<DT>
Editing Mode</DT><DD>
These flags can change how the bitmap is being edited.</DD>
<DT>
Device Information Block</DT><DD>
This internal structure contains information about and used by the video driver. (Don't worry that you don't know the size of this structure; remember that the CBitmap structure contains the offsets of the bitmap and palette data areas.)</DD>
<DT>
Pallette Information (optional)</DT><DD>
If the bitmap has its own pallette, this is where the palette data will be stored; it will consist of an array of 3-byte entries. Depending on how many colors the bitmap supports, there may be 16 or 256 entries in this array.</DD>
</DL>
<P>
The bitmap's raw data is in the VM block, but outside of the header area.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_38.htm_IX_GrCreateGString()">
 </A>
<H1 CLASS="refHeading">
GrCreateGString()</H1>
<PRE CLASS="syntax">GStateHandle GrCreateGString(
        Handle		han,			/* memory, stream, or VM file handle */
        GStringType		hanType,			/* type of handle in han parameter */
        word		* gsBlock);				/* returned for GST_MEMORY and 
						 * GST_VMEM types only */</PRE>
<P>
Open a graphics string and start redirecting graphics orders to the string. The hanType parameter must be GST_MEMORY, GST_STREAM, or GST_VMEM.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_38.htm_IX_GrCreatePalette()">
 </A>
<H1 CLASS="refHeading">
GrCreatePalette()</H1>
<PRE CLASS="syntax">word	GrCreatePalette( /* Returns # of entries in color table
            * or 0 for monochrome or 24-bit */</PRE>
<PRE CLASS="syntax">        GStateHandle gstate);</PRE>
<P>
Create a color mapping table and associate it with the current window. Initialize the table entries to the default palette for the device.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_38.htm_IX_GrCreateState()">
 </A>
<H1 CLASS="refHeading">
GrCreateState()</H1>
<PRE CLASS="syntax">GStateHandle GrCreateState(
        WindowHandle win);			/* Window in which GState will be active */</PRE>
<P>
Create a graphics state (GState) block containg default GState information.</P>
<P>
If zero is passed, then the GState created will have no window associated with it.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_38.htm_IX_GrDeleteGStringElement()">
 </A>
<H1 CLASS="refHeading">
GrDeleteGStringElement()</H1>
<PRE CLASS="syntax">void	GrDeleteGStringElement(
        GStateHandle		gstate,			/* GState containing GString */
        word		count);			/* number of elements to delete */</PRE>
<P>
Delete a range of GString elements from the GString in the passed GState.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<HR>
<A NAME="R_39.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_39.htm_IX_GrDestroyBitmap()">
 </A>
<A NAME="R_39.htm_IX_BMDestroy">
 </A>
<A NAME="R_39.htm_IX_BMD_&ldots;">
 </A>
<H1 CLASS="refHeading">
GrDestroyBitmap()</H1>
<PRE CLASS="syntax">void	GrDestroyBitmap(
        GStateHandle		gstate,			/* GState containing bitmap */
        BMDestroy 		flags);			/* flags for removing data */</PRE>
<P>
Free the bitmap and disassociate it with its window. Depending on the passed flag, the bitmap's data may be freed or preserved. Thus, it is possible to remove the GString used to edit the bitmap while maintaining the bitmap in a drawable state.</P>
<P CLASS="refField"><STRONG>
Structures:</STRONG>	</P>
<PRE>typedef ByteEnum BMDestroy;
/* 	BMD_KILL_DATA, 
 	BMD_LEAVE_DATA */</PRE>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_39.htm_IX_GrDestroyGString()">
 </A>
<A NAME="R_39.htm_IX_GStringKillType">
 </A>
<A NAME="R_39.htm_IX_GSKT_&ldots;">
 </A>
<H1 CLASS="refHeading">
GrDestroyGString()</H1>
<PRE CLASS="syntax">void	GrDestroyGString(
        Handle		gstring,			/* Handle of GString */
        GStateHandle		gstate,			/* NULL, or handle of another
					 * gstate to free*/</PRE>
<PRE CLASS="syntax">        GStringKillType		type);			/* Kill type for data removal */</PRE>
<P>
Destroys a GString. Depending on the <CODE>
GStringKillType</CODE>
 argument, this either constitutes removing the GState from the GString data; or freeing both the GState and the GString's data. If you have been drawing the GString to a GState, you should pass the GState's handle as <EM>
gstate</EM>
, and this routine will do some cleaning up.</P>
<P CLASS="refField"><STRONG>
Structures:</STRONG>	</P>
<PRE>typedef ByteEnum GStringKillType;
/* 	GSKT_KILL_DATA, 
	GSKT_LEAVE_DATA */</PRE>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_39.htm_IX_GrDestroyPalette()">
 </A>
<H1 CLASS="refHeading">
GrDestroyPalette()</H1>
<PRE CLASS="syntax">void	GrDestroyPalette(
        GStateHandle gstate);			/* GState of palette to destroy */</PRE>
<P>
Free any custom palette associated with the current window.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_39.htm_IX_GrDestroyState()">
 </A>
<H1 CLASS="refHeading">
GrDestroyState()</H1>
<PRE CLASS="syntax">void	GrDestroyState(
        GStateHandle gstate);			/* GState to be destroyed */</PRE>
<P>
Free a graphics state block.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_39.htm_IX_GrDrawArc()">
 </A>
<H1 CLASS="refHeading">
GrDrawArc()</H1>
<PRE CLASS="syntax">void	GrDrawArc(
        GStateHandle		gstate,				/* GState to draw to */
        sword		left,				/* bounds of box outlining arc */
        sword		top,
        sword		right,
        sword		bottom,
        word		startAngle,				/* angles in degrees
        word		endAngle,				 * counter-clockwise */
        ArcCloseType		arcType);				/* how the arc is closed */</PRE>
<P>
Draw an arc along the ellipse that is specified by a bounding box, from the starting angle to the ending angle.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_39.htm_IX_GrDrawArc3Point()">
 </A>
<H1 CLASS="refHeading">
GrDrawArc3Point()</H1>
<PRE CLASS="syntax">void	GrDrawArc3Point(
        GStateHandle		gstate,			/* GState to draw to */
        const ThreePointArcParams 	*params);			</PRE>
<P>
Draw a circular arc, given three points along the arc; both endpoints and any other point on the arc.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_39.htm_IX_GrDrawArc3PointTo()">
 </A>
<H1 CLASS="refHeading">
GrDrawArc3PointTo()</H1>
<PRE CLASS="syntax">void	GrDrawArc3PointTo(
        GStateHandle		gstate,			/* GState to draw to */
        const ThreePointArcToParams *params);</PRE>
<P>
As <CODE>
GrDrawArc3Point()</CODE>
, above, except that the current position is automatically used as one of the endpoints.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_39.htm_IX_GrDrawBitmap()">
 </A>
<H1 CLASS="refHeading">
GrDrawBitmap()</H1>
<PRE CLASS="syntax">void	GrDrawBitmap(
        GStateHandle		gstate,			/* GState to draw to */
        sword		x,				/* x starting point */
        sword		y,				/* y starting point */
        const	Bitmap	* bm,				/* pointer to the bitmap */
        Bitmap * _pascal (*callback) (Bitmap *bm));	/* NULL for no callback */</PRE>
<P>
Draw a bitmap. Note that if the bitmap takes up a great deal of memory, it is necessary to manage its memory when drawing. If the bitmap resides in a <CODE>
HugeArray</CODE>
 (true of any bitmap created using <CODE>
<A HREF="../../CRef/Routines/R_38.htm#IX_GrCreateBitmap()">GrCreateBitmap()</A></CODE>
), then calling <CODE>
<A HREF="../../CRef/Routines/R_3a.htm#IX_GrDrawHugeBitmap()">GrDrawHugeBitmap()</A></CODE>
 will automatically take care of memory management. Otherwise, you may wish to provide a suitable callback routine. This routine should be declared _pascal and is passed a pointer into the passed bitmap and is expected to return a pointer to the next slice. This allows the bitmap to be drawn in horizontal bands, or swaths. The callback should signal it is done returning blocks by returning a null pointer.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_39.htm_IX_GrDrawBitmapAtCP()">
 </A>
<H1 CLASS="refHeading">
GrDrawBitmapAtCP()</H1>
<PRE CLASS="syntax">void	GrDrawBitmapAtCP(
        GStateHandle		gstate,			/* GState to draw to */
        const	Bitmap	* bm,				/* pointer to the bitmap */
        Bitmap * _pascal (*callback) (Bitmap *bm));	/* NULL for no callback */</PRE>
<P>
This routine is the same as<CODE>
 GrDrawBitmap()</CODE>
, above, except that the bitmap is drawn at the current position.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_39.htm_IX_GrDrawChar()">
 </A>
<H1 CLASS="refHeading">
GrDrawChar()</H1>
<PRE CLASS="syntax">void	GrDrawChar(
        GStateHandle		gstate,			/* GState to draw to */
        sword		x,			/* x position at which to draw */
        sword		y,			/* y position at which to draw */
        word		ch);			/* character of type Chars */</PRE>
<P>
Draw a character at the given position with the current text drawing attributes.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_39.htm_IX_GrDrawCharAtCP()">
 </A>
<H1 CLASS="refHeading">
GrDrawCharAtCP()</H1>
<PRE CLASS="syntax">void	GrDrawCharAtCP(
        GStateHandle		gstate,			/* GState to draw to */
        word		ch);			/* character of type Chars */</PRE>
<P>
Draw a character at the current position with the current text drawing attributes.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<HR>
<A NAME="R_3a.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_3a.htm_IX_GrDrawCurve()">
 </A>
<A NAME="R_3a.htm_IX_Bezier curves:GrDrawCurve()">
 </A>
<H1 CLASS="refHeading">
GrDrawCurve()</H1>
<PRE CLASS="syntax">void	GrDrawCurve(
        GStateHandle		gstate,				/* GState to draw to */
        const	Point	*points);				/* array of four Points */</PRE>
<P>
Draw a Bezier curve.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_3a.htm_IX_GrDrawCurveTo()">
 </A>
<H1 CLASS="refHeading">
GrDrawCurveTo()</H1>
<PRE CLASS="syntax">void	GrDrawCurveTo(
        GStateHandle		gstate,				/* GState to draw to */
        const	Point	*points);			/* array of three Points */</PRE>
<P>
Draw a Bezier curve, using the current postion as the first point.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_3a.htm_IX_Ellipses:GrDrawEllipse() macro">
 </A>
<A NAME="R_3a.htm_IX_GrDrawEllipse()">
 </A>
<H1 CLASS="refHeading">
GrDrawEllipse()</H1>
<PRE CLASS="syntax">void	GrDrawEllipse(
        GStateHandle		gstate,			/* GState to draw to */
        sword		left,			/* bounding box bounds */
        sword		top,
        sword		right,
        sword		bottom);</PRE>
<P>
Draw an ellipse, defined by its bounding box.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_3a.htm_IX_GrDrawGString()">
 </A>
<H1 CLASS="refHeading">
GrDrawGString()</H1>
<PRE CLASS="syntax">GSRetType GrDrawGString(
        GStateHandle		gstate,					/* GState to draw to */
        Handle		gstringToDraw,					/* GString to draw */
        sword		x,					/* point at which to draw */
        sword		y,
        GSControl 		flags,					/* GSControl record */
        GStringElement		* lastElement);					/* pointer to empty structure */</PRE>
<P>
Draw a graphics string. The passed control flag allows drawing to stop upon encountering certain kinds of drawing elements. If this causes the drawing to stop in mid-string, then the routine will provide a pointer to the next <CODE>
GStringElement</CODE>
 to be played.</P>
<UL>
<LI>
You must provide a GState to draw to. You may wish to call <CODE>
<A HREF="../../CRef/Routines/R_45.htm#IX_GrSaveState()">GrSaveState()</A></CODE>
 on the GState before drawing the GString (and call <CODE>
<A HREF="../../CRef/Routines/R_45.htm#IX_GrRestoreState()">GrRestoreState()</A></CODE>
 afterwards). If you will draw anything else to this GState after the GString, you must call <CODE>
<A HREF="../../CRef/Routines/R_39.htm#IX_GrDestroyGString()">GrDestroyGString()</A></CODE>
 on the GString, and pass this GState's handle as the gstate argument so that <CODE>
<A HREF="../../CRef/Routines/R_39.htm#IX_GrDestroyGString()">GrDestroyGString()</A></CODE>
 can clean up the GState.</LI>
<LI>
You must provide a GString to draw. The GString must be properly loaded (probably by means of <CODE>
<A HREF="../../CRef/Routines/R_44.htm#IX_GrLoadGString()">GrLoadGString()</A></CODE>
).</LI>
<LI>
You can provide a pair of coordinates at which to draw the GString. The graphics system will translate the coordinate system by these coordinates before carrying out the graphics commands stored in the GString.</LI>
<LI>
You can provide a <CODE>
GSControl</CODE>
 argument which requests that the system stop drawing the GString when it encounters a certain type of GString element. If the GString interpreter encounters one of these elements, it will immediately stop drawing. The GString will remember where it stopped drawing. If you call <CODE>
GrDrawGString() </CODE>
with that same GString, it will continue drawing where you left off.</LI>
<LI>
You must provide a pointer to an empty <CODE>
GStringElement</CODE>
 structure. <CODE>
GrDrawGString()</CODE>
 will return a value here when it is finished drawing. If the GString has stopped drawing partway through due to a passed <CODE>
GSControl</CODE>
, the returned <CODE>
GStringElement</CODE>
 value will tell you what sort of command was responsible for halting drawing. For instance, if you had instructed <CODE>
GrDrawGString()</CODE>
 to halt on an `output' element (GrDraw...() or GrFill...() commands), then when <CODE>
GrDrawGString()</CODE>
 returns, you would check the value returned to see what sort of output element was present.</LI>
</UL>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_3a.htm_IX_GrDrawGStringAtCP()">
 </A>
<H1 CLASS="refHeading">
GrDrawGStringAtCP()</H1>
<PRE CLASS="syntax">GSRetType GrDrawGStringAtCP(
        GStateHandle		gstate,					/* GState to draw to */
        GStringeHandle		gstringToDraw,					/* GString to draw */
        GSControl 		flags,					/* GSControl flags */
        GStringElement 		* lastElement);					/* last element to draw */</PRE>
<P>
Draw a graphics string as <CODE>
<A HREF="../../CRef/Routines/R_3a.htm#IX_GrDrawGString()">GrDrawGString()</A></CODE>
, above, except that drawing takes place at the current position.</P>
<UL>
<LI>
You must provide a GState to draw to. You may wish to call <CODE>
<A HREF="../../CRef/Routines/R_45.htm#IX_GrSaveState()">GrSaveState()</A></CODE>
 on the GState before drawing the GString (and call <CODE>
<A HREF="../../CRef/Routines/R_45.htm#IX_GrRestoreState()">GrRestoreState()</A></CODE>
 afterwards). If you will draw anything else to this GState after the GString, you must call <CODE>
<A HREF="../../CRef/Routines/R_39.htm#IX_GrDestroyGString()">GrDestroyGString()</A></CODE>
 on the GString, and pass this GState's handle as the gstate argument so that <CODE>
<A HREF="../../CRef/Routines/R_39.htm#IX_GrDestroyGString()">GrDestroyGString()</A></CODE>
 can clean up the GState.</LI>
<LI>
You must provide a GString to draw. The GString must be properly loaded (probably by means of <CODE>
<A HREF="../../CRef/Routines/R_44.htm#IX_GrLoadGString()">GrLoadGString()</A></CODE>
).</LI>
<LI>
You can provide a <CODE>
GSControl</CODE>
 argument which requests that the system stop drawing the GString when it encounters a certain type of GString element. If the GString interpreter encounters one of these elements, it will immediately stop drawing. The GString will remember where it stopped drawing. If you call <CODE>
GrDrawGString() </CODE>
with that same GString, it will continue drawing where you left off.</LI>
<LI>
You must provide a pointer to an empty <CODE>
GStringElement</CODE>
 structure. <CODE>
<A HREF="../../CRef/Routines/R_3a.htm#IX_GrDrawGString()">GrDrawGString()</A></CODE>
 will return a value here when it is finished drawing. If the GString has stopped drawing partway through due to a passed <CODE>
GSControl</CODE>
, the returned <CODE>
GStringElement</CODE>
 value will tell you what sort of command was responsible for halting drawing. For instance, if you had instructed <CODE>
<A HREF="../../CRef/Routines/R_3a.htm#IX_GrDrawGString()">GrDrawGString()</A></CODE>
 to halt on an `output' element (GrDraw...() or GrFill...() commands), then when <CODE>
<A HREF="../../CRef/Routines/R_3a.htm#IX_GrDrawGString()">GrDrawGString()</A></CODE>
 returns, you would check the value returned to see what sort of output element was present.</LI>
</UL>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_3a.htm_IX_GrDrawHLine()">
 </A>
<H1 CLASS="refHeading">
GrDrawHLine()</H1>
<PRE CLASS="syntax">void	GrDrawHLine(
        GStateHandle		gstate,			/* GState to draw to */
        sword		x1,			/* first horizontal coordinate */
        sword		y,			/* vertical position of line */
        sword		x2);			/* second horizontal coordinate */</PRE>
<P>
Draw a horizontal line.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_3a.htm_IX_GrDrawHLineTo()">
 </A>
<H1 CLASS="refHeading">
GrDrawHLineTo()</H1>
<PRE CLASS="syntax">void	GrDrawHLineTo(
        GStateHandle		gstate,			/* GState to draw to */
        sword		x);			/* ending horizontal coordinate */</PRE>
<P>
Draw a horizontal line starting from the current position.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_3a.htm_IX_GrDrawHugeBitmap()">
 </A>
<H1 CLASS="refHeading">
GrDrawHugeBitmap()</H1>
<PRE CLASS="syntax">void	GrDrawHugeBitmap(
        GStateHandle		gstate,			/* GState to draw to */
        sword		x			/* Point at which to draw */
        sword		y,
        VMFileHandle 		vmFile,			/* VM File holding HugeArray */
        VMBlockHandle 		vmBlk);			/* VM block of HugeArray */</PRE>
<P>
Draw a bitmap that resides in a HugeArray.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_39.htm#IX_GrDrawBitmap()">GrDrawBitmap()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_3a.htm#IX_GrDrawHugeBitmapAtCP()">GrDrawHugeBitmapAtCP()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_3a.htm#IX_GrDrawHugeImage()">GrDrawHugeImage()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_3a.htm_IX_GrDrawHugeBitmapAtCP()">
 </A>
<H1 CLASS="refHeading">
GrDrawHugeBitmapAtCP()</H1>
<PRE CLASS="syntax">void	GrDrawHugeBitmapAtCP(
        GStateHandle		gstate,			/* GState to draw to */
        VMFileHandle	 	vmFile,			/* VM file containing HugeArray */
        VMBlockHandle 		vmBlk);			/* VM block containing HugeArray */</PRE>
<P>
As <CODE>
<A HREF="../../CRef/Routines/R_3a.htm#IX_GrDrawHugeBitmap()">GrDrawHugeBitmap()</A></CODE>
, above, except that the bitmap is drawn at the current position.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_39.htm#IX_GrDrawBitmapAtCP()">GrDrawBitmapAtCP()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_3a.htm#IX_GrDrawHugeBitmap()">GrDrawHugeBitmap()</A></CODE>.</P>
</DIV>
<DIV>
. Note that the bitmap will be <A NAME="R_3a.htm_IX_GrDrawHugeImage()">
 </A>
<H1 CLASS="refHeading">
GrDrawHugeImage()</H1>
<PRE CLASS="syntax">void	GrDrawHugeImage(
        GStateHandle 		gstate,			/* GState to draw to */
        sword		x			/* point at which to draw */
        sword		y,
        ImageFlags 		flags,
        VMFileHandle 		vmFile,			/* VM file holding HugeArray */
        VMBlockHandle 		vmBlk);			/* VM block holding HugeArray */</PRE>
<P>
Draw a bitmap that resides in a <CODE>
HugeArray</CODE>
drawn on an assumption of one device pixel per bitmap pixel. The bitmap will not draw rotated or scaled. Depending on the value of the flags argument, the bitmap may be expanded so that a square of device pixels displays each bitmap pixel.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_3a.htm#IX_GrDrawImage()">GrDrawImage()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_3a.htm#IX_GrDrawHugeBitmapAtCP()">GrDrawHugeBitmapAtCP()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_3a.htm_IX_GrDrawImage()">
 </A>
<H1 CLASS="refHeading">
GrDrawImage()</H1>
<PRE CLASS="syntax">void	GrDrawImage(
        GStateHandle 		gstate,			/* GState to draw to */
        sword		x			/* point at which to draw */
        sword		y,
        ImageFlags 		flags,			
        const Bitmap 		* bm);			/* pointer to bitmap */</PRE>
<P>
Draw a bitmap. Note that the bitmap will be drawn on an assumption of one device pixel per bitmap pixel. The bitmap will not draw rotated or scaled. Depending on the value of the flags argument, the bitmap may be expanded so that a square of device pixels displays each bitmap pixel.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_3a.htm#IX_GrDrawHugeImage()">GrDrawHugeImage()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_39.htm#IX_GrDrawBitmap()">GrDrawBitmap()</A></CODE>.</P>
</DIV>
<HR>
<A NAME="R_3b.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_3b.htm_IX_GrDrawLine()">
 </A>
<H1 CLASS="refHeading">
GrDrawLine()</H1>
<PRE CLASS="syntax">void	GrDrawLine(
        GStateHandle		gstate,			/* GState to draw to */
        sword		x1,			/* First coordinate of line */
        sword		y1,
        sword		x2,			/* Second coordinate of line */
        sword		y2);</PRE>
<P>
Draw a line.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_3b.htm#IX_GrDrawLineTo()">GrDrawLineTo()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_3a.htm#IX_GrDrawHLine()">GrDrawHLine()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_3d.htm#IX_GrDrawVLine()">GrDrawVLine()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_3b.htm_IX_GrDrawLineTo()">
 </A>
<H1 CLASS="refHeading">
GrDrawLineTo()</H1>
<PRE CLASS="syntax">void	GrDrawLineTo(
        GStateHandle		gstate,			/* GState to draw to */
        sword		x,			/* Second coordinate of line */
        sword		y);</PRE>
<P>
Draw a line starting from the current position.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_3b.htm#IX_GrDrawLine()">GrDrawLine()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_3a.htm#IX_GrDrawHLineTo()">GrDrawHLineTo()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_3d.htm#IX_GrDrawVLineTo()">GrDrawVLineTo()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_3b.htm_IX_GrDrawPath()">
 </A>
<H1 CLASS="refHeading">
GrDrawPath()</H1>
<PRE CLASS="syntax">void	GrDrawPath(
        GStateHandle gstate);			/* GState to draw to */</PRE>
<P>
Draws the stroked version of the current path, using the current graphic line attributes.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_3b.htm_IX_GrDrawPoint()">
 </A>
<H1 CLASS="refHeading">
GrDrawPoint()</H1>
<PRE CLASS="syntax">void	GrDrawPoint(
        GStateHandle		gstate,			/* GState to draw to */
        sword 		x,			/* Coordinates of point to draw */
        sword 		y);</PRE>
<P>
Draw a pixel.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_3b.htm_IX_GrDrawPointAtCP()">
 </A>
<H1 CLASS="refHeading">
GrDrawPointAtCP()</H1>
<PRE CLASS="syntax">void	GrDrawPointAtCP(
        GStateHandle gstate);			/* GState to draw to */</PRE>
<P>
Draw a pixel.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_3b.htm_IX_Polygons:GrDrawPolygon()">
 </A>
<A NAME="R_3b.htm_IX_GrDrawPolygon()">
 </A>
<H1 CLASS="refHeading">
GrDrawPolygon()</H1>
<PRE CLASS="syntax">void	GrDrawPolygon(
        GStateHandle		gstate,				/* GState to draw to */
        const	Point 	* points,				/* array of points in polygon */
        word		numPoints);				/* number of points in array */</PRE>
<P>
Draws a connected polygon.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_3b.htm_IX_Polylines:GrDrawPolyline()">
 </A>
<A NAME="R_3b.htm_IX_GrDrawPolyline()">
 </A>
<H1 CLASS="refHeading">
GrDrawPolyline()</H1>
<PRE CLASS="syntax">void	GrDrawPolyline(
        GStateHandle		gstate,				/* GState to draw to */
        const	Point	* points,				/* array of points in polyline */
        word		numPoints);				/* number of points in array */</PRE>
<P>
Draws a simple polyline.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<HR>
<A NAME="R_3c.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_3c.htm_IX_Rectangles:GrDrawRect()">
 </A>
<A NAME="R_3c.htm_IX_GrDrawRect()">
 </A>
<H1 CLASS="refHeading">
GrDrawRect()</H1>
<PRE CLASS="syntax">void	GrDrawRect(
        GStateHandle		gstate,			/* GState to draw to */
        sword		left,			/* bounds of rectangle to draw */
        sword		top,
        sword		right,
        sword		bottom);</PRE>
<P>
Draws the outline of a rectangle.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_3c.htm_IX_GrDrawRectTo()">
 </A>
<H1 CLASS="refHeading">
GrDrawRectTo()</H1>
<PRE CLASS="syntax">void	GrDrawRectTo(
        GStateHandle		gstate,			/* GState to draw to */
        sword		x,			/* opposite corner of rectangle */
        sword		y);</PRE>
<P>
Draws the outline of a rectangle, with one corner defined by the current position.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_3c.htm_IX_GrDrawRegion()">
 </A>
<H1 CLASS="refHeading">
GrDrawRegion()</H1>
<PRE CLASS="syntax">void	GrDrawRegion(
        GStateHandle		gstate,			/* GState to draw to */
        sword		xPos,			/* Position at which to draw */
        sword		yPos,
        const	Region	* reg,			/* Region definition */
        sword		param0,			/* value to use with
					 * parameterized coordinates */</PRE>
<PRE CLASS="syntax">        sword		param1);			/* value to use with
					 * parameterized coordinates */</PRE>
<P>
Draw a region. The area will be rendered filled with the GState's area attributes.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_3c.htm_IX_GrDrawRegionAtCP()">
 </A>
<H1 CLASS="refHeading">
GrDrawRegionAtCP()</H1>
<PRE CLASS="syntax">void	GrDrawRegionAtCP(
        GStateHandle		gstate,			/* GState to draw to */
        const	Region 	* reg,			/* region definition */
        sword	param0,	/* Value to use with parameterized coordinates */
        sword	param1,	/* Value to use with parameterized coordinates */
        sword	param2,	/* Value to use with parameterized coordinates */
        sword	param3);	/* Value to use with parameterized coordinates */</PRE>
<P>
Draw a region at the current pen position. The area will be rendered filled with the GState's area attributes.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_3c.htm_IX_GrDrawRelArc3PointTo()">
 </A>
<H1 CLASS="refHeading">
GrDrawRelArc3PointTo()</H1>
<PRE CLASS="syntax">void 	GrDrawRelArc3PointTo(
        const ThreePointRelArcToParams *params);</PRE>
<P>
Draw a circular arc relative to the current point given two additional points: the other endpoint and any other point on the arc, both described in relative coordinates.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_3c.htm_IX_GrDrawRelLineTo()">
 </A>
<H1 CLASS="refHeading">
GrDrawRelLineTo()</H1>
<PRE CLASS="syntax">void 	GrDrawRelLineTo(
        GStateHandle 		gstate,			/* GState to draw to */
        WWFixedAsDWord 		x,			/* horizontal offset of second point */
        WWFixedAsDWord 		y);			/* vertical offset of second point */</PRE>
<P>
Draw a line from the current pen position, given a displacement from the current pen position to draw to.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<HR>
<A NAME="R_3d.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_3d.htm_IX_GrDrawRoundRect()">
 </A>
<H1 CLASS="refHeading">
GrDrawRoundRect()</H1>
<PRE CLASS="syntax">void	GrDrawRoundRect(
        GStateHandle		gstate,					/* GState to draw to */
        sword		left,					/* bounds of rectangle */
        sword		top,
        sword		right,
        sword		bottom,
        word		cornerRadius);					/* radius of corner rounding */</PRE>
<P>
Draw the outline of a rounded rectangle.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_3d.htm_IX_GrDrawRoundRectTo()">
 </A>
<H1 CLASS="refHeading">
GrDrawRoundRectTo()</H1>
<PRE CLASS="syntax">void	GrDrawRoundRectTo(
        GStateHandle		gstate,					/* GState to draw to */
        sword		x,					/* opposite corner of bounds */
        sword		y,
        word		cornerRadius);					/* radius of corner rounding */</PRE>
<P>
Draw the outline of a rounded rectangle, where one corner of the bounding rectangle is the current position.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_3d.htm_IX_Splines:GrDrawSpline()">
 </A>
<A NAME="R_3d.htm_IX_Bezier curves:GrDrawSpline()">
 </A>
<A NAME="R_3d.htm_IX_GrDrawSpline()">
 </A>
<H1 CLASS="refHeading">
GrDrawSpline()</H1>
<PRE CLASS="syntax">void	GrDrawSpline(
        GStateHandle		gstate,				/* GState to draw to */
        const	Point	* points,				/* array of points */
        word		numPoints,); 				/* number of points in array */</PRE>
<P>
Draw a B�zier spline.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_3a.htm#IX_GrDrawCurve()">GrDrawCurve()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_3d.htm_IX_GrDrawSplineTo()">
 </A>
<H1 CLASS="refHeading">
GrDrawSplineTo()</H1>
<PRE CLASS="syntax">void	GrDrawSplineTo(
        GStateHandle		gstate,				/* GState to draw to */
        const	Point	*points,				/* array of points */
        word		numPoints);				/* number of points in array */</PRE>
<P>
Draw a Bezier spline, using the current position as one endpoint.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_3a.htm#IX_GrDrawCurveTo()">GrDrawCurveTo()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_3d.htm_IX_GrDrawText()">
 </A>
<H1 CLASS="refHeading">
GrDrawText()</H1>
<PRE CLASS="syntax">void	GrDrawText(
        GStateHandle		gstate,			/* GState to draw to */
        sword		x,			/* point at which to draw */
        sword		y,
        const	Chars	* str,			/* pointer to character string */
        word		size);			/* length of string */</PRE>
<P>
Draw a string of text. The string is represented as an array of characters. Note that the text will be drawn using the GState's font drawing attributes and that this routine does not accept any style run arguments.</P>
<P>
If the passed <CODE>
size</CODE>
 argument is zero, the string is assumed to be null-terminated.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_3d.htm_IX_GrDrawTextAtCP()">
 </A>
<H1 CLASS="refHeading">
GrDrawTextAtCP()</H1>
<PRE CLASS="syntax">void	GrDrawTextAtCP(
        GStateHandle		gstate,			/* GState to draw to */
        const	Chars	* str,			/* pointer to character string */
        word		size);			/* length of string */</PRE>
<P>
As <CODE>
<A HREF="../../CRef/Routines/R_3d.htm#IX_GrDrawText()">GrDrawText()</A></CODE>
, above, except that the text is drawn at the current position.</P>
<P>
If the passed <CODE>
size</CODE>
 argument is zero, the string is assumed to be null-terminated.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_3d.htm_IX_GrDrawVLine()">
 </A>
<H1 CLASS="refHeading">
GrDrawVLine()</H1>
<PRE CLASS="syntax">void	GrDrawVLine(
        GStateHandle		gstate,			/* GState to draw to */
        sword		x,			/* horizontal position of line */
        sword		y1,			/* first vertical coordinate */
        sword		y2);			/* second vertical coordinate */</PRE>
<P>
Draw a vertical line.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_3d.htm_IX_GrDrawVLineTo()">
 </A>
<H1 CLASS="refHeading">
GrDrawVLineTo()</H1>
<PRE CLASS="syntax">void	GrDrawVLineTo(
        GStateHandle		gstate,			/* GState to draw to */
        sword		y);			/* second vertical position */</PRE>
<P>
Draw a vertical line starting from the current position.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_3d.htm_IX_GrEditBitmap()">
 </A>
<H1 CLASS="refHeading">
GrEditBitmap()</H1>
<PRE CLASS="syntax">GStateHandle GrEditBitmap(
        VMFileHandle 		vmFile,				/* VM file of bitmap */
        VMBlockHandle 		vmBlock,				/* VM block of bitmap */
        optr 		exposureOD);				/* optr to get MSG_META_EXPOSED */</PRE>
<P>
This routine attaches a GState to the passed bitmap so that new drawings may be be sent to the bitmap.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_3d.htm_IX_GrEditGString()">
 </A>
<H1 CLASS="refHeading">
GrEditGString()</H1>
<PRE CLASS="syntax">GStateHandle GrEditGString(
        Handle	vmFile,	/* VM file containing the GString */
        word	vmBlock);	/* VM block containing the GString */</PRE>
<P>
This routine takes the location of a GString data block stored in a VM file. It will associate a GState with this GString data and returns the handle of this GState. Any graphics commands issued using this GStateHandle will be appended to the GString.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<HR>
<A NAME="R_3e.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_3e.htm_IX_GrEndGString()">
 </A>
<H1 CLASS="refHeading">
GrEndGString()</H1>
<PRE CLASS="syntax">GStringErrorType GrEndGString( 
        GStateHandle gstate);			/* GState to draw to */</PRE>
<P>
Finish the definition of a graphics string.</P>
<P CLASS="refField"><STRONG>
Structures:</STRONG>	</P>
<PRE CLASS="syntax">        	typedef enum { 
		GSET_NO_ERROR, 				
		GSET_DISK_FULL 
} GStringErrorType;</PRE>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_3e.htm_IX_GrEndPath()">
 </A>
<H1 CLASS="refHeading">
GrEndPath()</H1>
<PRE CLASS="syntax">void	GrEndPath(
        GStateHandle gstate);			/* GState to draw to */</PRE>
<P>
Finish definition of a path. Further graphics commands will draw to the display, as normal.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_3e.htm_IX_GrEndUpdate()">
 </A>
<H1 CLASS="refHeading">
GrEndUpdate()</H1>
<PRE CLASS="syntax">void	GrEndUpdate(
        GStateHandle gstate);			/* GState to draw to */</PRE>
<P>
Unlocks window from an update.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
win.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_3e.htm_IX_GrEnumFonts()">
 </A>
<A NAME="R_3e.htm_IX_Fonts:finding available">
 </A>
<H1 CLASS="refHeading">
GrEnumFonts()</H1>
<PRE CLASS="syntax">word	GrEnumFonts( /* Return value = number of fonts found */
        FontEnumStruct		* buffer,			/* buffer for returned values */
        word		size,			/* number of structures to return */
        FontEnumFlags		flags,			/* FontEnumFlags */
        word		family);			/* FontFamily */</PRE>
<P>
Generate a list of available fonts. The font information includes both the font's ID and a string name.</P>
<P CLASS="refField"><STRONG>
Structures:</STRONG>	</P>
<PRE CLASS="syntax">        	typedef struct {
		FontID FES_ID; 
		char FES_name[FID_NAME_LEN];
} FontEnumStruct; </PRE>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
font.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_3e.htm_IX_GrEscape()">
 </A>
<A NAME="R_3e.htm_IX_Printing:escape codes">
 </A>
<H1 CLASS="refHeading">
GrEscape()</H1>
<PRE CLASS="syntax">void	GrEscape(
        GStateHandle		gstate,			/* GState to draw to */
        word		code,			/* escape code */
        const	void	* data,			/* pointer to the data */
        word		size);			/* Size of data, in bytes */</PRE>
<P>
Write an escape code to a graphics string.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_3e.htm_IX_GrFillArc()">
 </A>
<H1 CLASS="refHeading">
GrFillArc()</H1>
<PRE CLASS="syntax">void	GrFillArc(
        GStateHandle		gstate,				/* GState to draw to */
        sword		left,				/* bounding rectangle */
        sword		top,
        sword		right,
        sword		bottom,
        word		startAngle,				/* angles in degrees
        word		endAngle				 * counter-clockwise */
        ArcCloseType 		closeType);				/* OPEN, CHORD, or PIE */</PRE>
<P>
Fill an elliptical arc. The arc is defined by the bounding rectangle of the base ellipse and two angles. Depending on how the arc is closed, this will result in either a wedge or a chord fill.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_3e.htm_IX_GrFillArc3Point()">
 </A>
<H1 CLASS="refHeading">
GrFillArc3Point()</H1>
<PRE CLASS="syntax">void	GrFillArc3Point(
        GStateHandle		gstate,				/* GState to draw to */
        const ThreePointParams *params);</PRE>
<P>
Fill an arc. Depending on how the arc is closed, this will result in either a wedge or a chord fill. The arc is defined in terms of its endpoints and one other point, all of which must lie on the arc.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_3e.htm_IX_GrFillArc3PointTo()">
 </A>
<H1 CLASS="refHeading">
GrFillArc3PointTo()</H1>
<PRE CLASS="syntax">void	GrFillArc3PointTo(
        GStateHandle		gstate,				/* GState to draw to */
        const ThreePointArcParams 	*params);			</PRE>
<P>
As <CODE>
GrFillArc3Point()</CODE>
, above, except that one endpoint of the arc is defined by the current position.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_3e.htm_IX_GrFillBitmap()">
 </A>
<H1 CLASS="refHeading">
GrFillBitmap()</H1>
<PRE CLASS="syntax">void 	GrFillBitmap (
        GStateHandle 		gstate,				/* GState to draw to */
        sword 		x,				/* point at which to draw */
        sword 		y,
        const Bitmap 		* bm,				/* pointer to bitmap */
        Bitmap * _pascal (*callback) (Bitmap *bm));</PRE>
<P>
Fill a monochrome bitmap with the current area attributes. The arguments to this routine are the same as those for <CODE>
<A HREF="../../CRef/Routines/R_39.htm#IX_GrDrawBitmap()">GrDrawBitmap()</A></CODE>
.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_3e.htm_IX_GrFillBitmapAtCP()">
 </A>
<H1 CLASS="refHeading">
GrFillBitmapAtCP()</H1>
<PRE CLASS="syntax">void 	GrFillBitmapAtCP (
        GStateHandle 		gstate,					/* GState to draw to */
        const Bitmap 		* bm,					/* pointer to bitmap */
        Bitmap * _pascal (*callback) (Bitmap *bm));</PRE>
<P>
Fill a monochrome bitmap with the current area attributes. The bitmap will be drawn at the current position. The arguments to this routine are the same as those for <CODE>
<A HREF="../../CRef/Routines/R_39.htm#IX_GrDrawBitmapAtCP()">GrDrawBitmapAtCP()</A></CODE>
.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_3e.htm_IX_GrFillHugeBitmap()">
 </A>
<H1 CLASS="refHeading">
GrFillHugeBitmap()</H1>
<PRE CLASS="syntax">void 	GrFillHugeBitmap(
        GStateHandle 		gstate, 
        sword 		x, 
        sword 		y,
        VMFileHandle 		vmFile, 
        VMBlockHandle 		vmBlk);</PRE>
<P>
This routine fills a monochrom bitmap where said bitmap is stored in a huge array data structure. The bitmap is specified by means of the <EM>
vmFile</EM>
 and <EM>
vmBlk</EM>
 arguments which should reference the huge array.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_3e.htm_IX_GrFillHugeBitmapAtCP()">
 </A>
<H1 CLASS="refHeading">
GrFillHugeBitmapAtCP()</H1>
<PRE CLASS="syntax">void 	GrFillHugeBitmapAtCP(
        GStateHandle 		gstate, 
        VMFileHandle 		vmFile, 
        VMBlockHandle 		vmBlk);</PRE>
<P>
This routine fills a monochrom bitmap where said bitmap is stored in a huge array data structure. It will draw at the GState's current position. The bitmap is specified by means of the <EM>
vmFile</EM>
 and <EM>
vmBlk</EM>
 arguments which should reference the huge array.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<HR>
<A NAME="R_3f.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_3f.htm_IX_Ellipses:GrFillEllipse()">
 </A>
<A NAME="R_3f.htm_IX_GrFillEllipse()">
 </A>
<H1 CLASS="refHeading">
GrFillEllipse()</H1>
<PRE CLASS="syntax">void	GrFillEllipse(
        GStateHandle		gstate,				/* GState to draw to */
        sword		left,				/* Bounds of bounding rectangle */
        sword		top,
        sword		right,
        sword		bottom);</PRE>
<P>
Draw a filled ellipse. The ellipse's dimensions are defined by its bounding box.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_3f.htm_IX_GrFillPath()">
 </A>
<H1 CLASS="refHeading">
GrFillPath()</H1>
<PRE CLASS="syntax">void	GrFillPath(
        GStateHandle		gstate,				/* GState to draw to */
        RegionFillRule		rule);				/* ODD_EVEN or WINDING */</PRE>
<P>
Fill an area whose outline is defined by the GState's path.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_3f.htm_IX_GrFillPolygon()">
 </A>
<A NAME="R_3f.htm_IX_Polygons:GrFillPolygon()">
 </A>
<H1 CLASS="refHeading">
GrFillPolygon()</H1>
<PRE CLASS="syntax">void	GrFillPolygon(
        GStateHandle		gstate,					/* GState to draw to */
        RegionFillRule		windingRule,					/* ODD_EVEN or WINDING */
        const	Point	* points,					/* array of points in polygon */
        word		numPoints);					/* number of points in array */</PRE>
<P>
This routine draws a filled polygon. The polygon is defined by the passed array of points.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_3f.htm_IX_Rectangles:GrFillRect()">
 </A>
<A NAME="R_3f.htm_IX_GrFillRect()">
 </A>
<H1 CLASS="refHeading">
GrFillRect()</H1>
<PRE CLASS="syntax">void	GrFillRect(
        GStateHandle		gstate,				/* GState to draw to */
        sword		left,				/* bounds of rectangle */
        sword		top,
        sword		right,
        sword		bottom);</PRE>
<P>
Draw a filled rectangle.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_3f.htm_IX_GrFillRectTo()">
 </A>
<H1 CLASS="refHeading">
GrFillRectTo()</H1>
<PRE CLASS="syntax">void	GrFillRectTo(
        GStateHandle		gstate,				/* GState to draw to */
        sword		x,				/* opposite corner of rectangle */
        sword		y);</PRE>
<P>
Draw a filled rectangle. The current position will define one of the corners.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_3f.htm_IX_GrFillRoundRect()">
 </A>
<H1 CLASS="refHeading">
GrFillRoundRect()</H1>
<PRE CLASS="syntax">void	GrFillRoundRect(
        GStateHandle		gstate,					/* GState to draw to */
        sword		left,					/* bounds of rectangle */
        sword		top,
        sword		right,
        sword		bottom
        word 		cornerRadius);					/* radius of corner rounding */</PRE>
<P>
Draw a filled rounded rectangle.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_3f.htm_IX_GrFillRoundRectTo()">
 </A>
<H1 CLASS="refHeading">
GrFillRoundRectTo()</H1>
<PRE CLASS="syntax">void	GrFillRoundRectTo(
        GStateHandle		gstate,				/* GState to draw to */
        sword		x,				/* opposite corner of rectangle */
        sword		y
        word 		cornerRadius);					/* radius of corner roundings */</PRE>
<P>
Draw a filled rounded rectangle, using the current position to define one corner of the bounding rectangle.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_3f.htm_IX_GrFindNearestPointsize()">
 </A>
<H1 CLASS="refHeading">
GrFindNearestPointsize()</H1>
<PRE CLASS="syntax">Boolean	GrFindNearestPointsize( /* If false, then FontID invalid */
        FontID 		id,					/* fond ID */
        dword		sizeSHL16,					/* point size */
        TextStyle 		styles,					/* style */
        TextStyle 		* styleFound,						/* buffer for style */
        dword		* sizeFoundSHL16);						/* buffer for size */</PRE>
<P>
Find the nearest available point size for a font. If the font passed in <CODE>
id</CODE>
 exists, then <CODE>
styleFound</CODE>
 will point to the styles available and <CODE>
sizeFoundSHL16</CODE>
 will point to the nearest point size to that passed. If the font is not found, the return valued will be <CODE>
true</CODE>
.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
font.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_3f.htm_IX_GrFontMetrics()">
 </A>
<A NAME="R_3f.htm_IX_GFM_info">
 </A>
<A NAME="R_3f.htm_IX_GFMI_&ldots;">
 </A>
<H1 CLASS="refHeading">
GrFontMetrics()</H1>
<PRE CLASS="syntax">dword	GrFontMetrics(
        GStateHandle		gstate,				/* subject GState */
        GFM_info		info);				/* Type of information to return */</PRE>
<P>
Get metrics information about a font. It returns the requested information based on the <CODE>
info</CODE>
 parameter.</P>
<P CLASS="refField"><STRONG>
Structures:</STRONG>	</P>
<PRE>typedef enum /* word */ {
	GFMI_HEIGHT,				/* return = val &lt;&lt; 16 */
	GFMI_MEAN,				/* return = val &lt;&lt; 16 */
	GFMI_DESCENT,				/* return = val &lt;&lt; 16 */
	GFMI_BASELINE,				/* return = val &lt;&lt; 16 */
	GFMI_LEADING,				/* return = val &lt;&lt; 16 */
	GFMI_AVERAGE_WIDTH,				/* return = val &lt;&lt; 16 */
	GFMI_ASCENT,				/* return = val &lt;&lt; 16 */
	GFMI_MAX_WIDTH,				/* return = val &lt;&lt; 16 */
	GFMI_MAX_ADJUSTED_HEIGHT,				/* return = val &lt;&lt; 16 */
	GFMI_UNDER_POS,				/* return = val &lt;&lt; 16 */
	GFMI_UNDER_THICKNESS, 				/* return = val &lt;&lt; 16 */
	GFMI_ABOVE_BOX,				/* return = val &lt;&lt; 16 */
	GFMI_ACCENT,				/* return = val &lt;&lt; 16 */
	GFMI_MANUFACTURER,				/* return = val */
	GFMI_KERN_COUNT, 				/* return = Char */
	GFMI_FIRST_CHAR, 				/* return = Char */
	GFMI_LAST_CHAR, 				/* return = FontMaker */
	GFMI_DEFAULT_CHAR,				/* return = Char */
	GFMI_STRIKE_POS,				/* return = Char */
	GFMI_BELOW_BOX, 				/* return = Char */
	GFMI_HEIGHT_ROUNDED				/* return = Char */
	GFMI_DESCENT_ROUNDED, 				/* return = Char */
	GFMI_BASELINE_ROUNDED, 				/* return = Char */
	GFMI_LEADING_ROUNDED, 				/* return = Char */
	GFMI_AVERAGE_WIDTH_ROUNDED,				/* return = Char */
	GFMI_ASCENT_ROUNDED, 				/* return = Char */
	GFMI_MAX_WIDTH_ROUNDED, 				/* return = Char */
	GFMI_MAX_ADJUSTED_HEIGHT_ROUNDED, /* ret = Char */
	GFMI_UNDER_POS_ROUNDED, 				/* return = Char */
	GFMI_UNDER_THICKNESS_ROUNDED, /* return = Char */
	GFMI_ABOVE_BOX_ROUNDED, 				/* return = Char */
	GFMI_ACCENT_ROUNDED=, 				/* return = Char */
	GFMI_STRIKE_POS_ROUNDED,				/* return = Char */
	GFMI_BELOW_BOX_ROUNDED				/* return = Char */
} GFM_info; </PRE>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
font.h</STRONG>
 </P>
</DIV>
<HR>
<A NAME="R_40.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_40.htm_IX_GrGetAreaColor()">
 </A>
<H1 CLASS="refHeading">
GrGetAreaColor()</H1>
<PRE CLASS="syntax">RGBColorAsDWord 	GrGetAreaColor(
        GStateHandle gstate);			/* GState of which to get color */</PRE>
<P>
Get the color which is being used to fill areas.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_40.htm_IX_GrGetAreaColorMap()">
 </A>
<H1 CLASS="refHeading">
GrGetAreaColorMap()</H1>
<PRE CLASS="syntax">ColorMapMode GrGetAreaColorMap(
        GStateHandle gstate);				/* GState of which to get area color map */</PRE>
<P>
Get the mapping mode used for filling areas with unavailable colors.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_40.htm_IX_GrGetAreaMask()">
 </A>
<H1 CLASS="refHeading">
GrGetAreaMask()</H1>
<PRE CLASS="syntax">SysDrawMask GrGetAreaMask(
        GStateHandle		gstate,			/* GState of which to get mask */
        DrawMask		* dm);			/* buffer for returned mask */</PRE>
<P>
Get the draw mask used when filling areas. The <EM>
dm</EM>
 argument should point to a buffer capable of holding at least eight bytes to get the bit-pattern of the mask; otherwise <EM>
dm</EM>
 should be NULL. The returned buffer is the 8x8 bit pattern: each byte represents a row of the pattern, and the bytes are ordered from top row to bottom.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_40.htm_IX_GrGetAreaPattern()">
 </A>
<H1 CLASS="refHeading">
GrGetAreaPattern()</H1>
<PRE CLASS="syntax">GraphicPattern 	GrGetAreaPattern(
        GStateHandle 		gstate,					/* GState of area pattern */
        const MemHandle		* customPattern,					/* pointer to handle of block for
						 	 * returned custom pattern */</PRE>
<PRE CLASS="syntax">        word 		* customSize);					/* pointer to size of returned
							 * buffer */</PRE>
<P>
Get the area pattern used when filling areas.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_40.htm_IX_Video drivers:screen dumps">
 </A>
<A NAME="R_40.htm_IX_GrGetBitmap()">
 </A>
<H1 CLASS="refHeading">
GrGetBitmap()</H1>
<PRE CLASS="syntax">MemHandle GrGetBitmap(
        GStateHandle		gstate,					/* GState containing bitmap */
        sword		x,					/* bitmap origin */
        sword		y,
        word		width,					/* bitmap width and height */
        word		height,
        XYSize	 	* sizeCopied);					/* buffer for returned size */</PRE>
<P>
Dump an area of the display to a bitmap. The handle of a block containing the bitmap is returned; the <CODE>
sizeCopied</CODE>
 pointer points to the actual size of the bitmap successfully copied.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_40.htm_IX_GrGetBitmapMode()">
 </A>
<H1 CLASS="refHeading">
GrGetBitmapMode()</H1>
<PRE CLASS="syntax">BitmapMode 	GrGetBitmapMode(
        GStateHandle gstate);				/* GState containing bitmap */</PRE>
<P>
Get mode bits for an editable bitmap.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_40.htm_IX_GrGetBitmapRes()">
 </A>
<H1 CLASS="refHeading">
GrGetBitmapRes()</H1>
<PRE CLASS="syntax">XYValueAsDWord GrGetBitmapRes(
        const Bitmap		* bm);				/* pointer to the bitmap */</PRE>
<P>
Get the resolution of a bitmap. </P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_40.htm_IX_GrGetBitmapSize()">
 </A>
<H1 CLASS="refHeading">
GrGetBitmapSize()</H1>
<PRE CLASS="syntax">XYValueAsDWord GrGetBitmapSize(
        const	Bitmap	* bm);				/* pointer to the bitmap */</PRE>
<P>
Get the dimensions, in points, of a bitmap.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_40.htm_IX_GrGetClipRegion()">
 </A>
<H1 CLASS="refHeading">
GrGetClipRegion()</H1>
<PRE CLASS="syntax">MemHandle GrGetClipRegion(
        GStateHandle		gstate,			/* subject GState */
        RegionFillRule		rule);			/* ODD_EVEN or WINDING */</PRE>
<P>
Get the current clip region. A null handle (zero) will be returned if no clip paths are se for the GState.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_40.htm_IX_Current position (graphics):GrGetCurPos()">
 </A>
<A NAME="R_40.htm_IX_GrGetCurPos()">
 </A>
<H1 CLASS="refHeading">
GrGetCurPos()</H1>
<PRE CLASS="syntax">XYValueAsDWord GrGetCurPos(
        GStateHandle gstate);				/* subject GState */</PRE>
<P>
Get the current pen position.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_40.htm_IX_GrGetCurPosWWFixed()">
 </A>
<H1 CLASS="refHeading">
GrGetCurPosWWFixed()</H1>
<PRE CLASS="syntax">void GrGetCurPosWWFixed(
        GStateHandle gstate,				/* subject GState */
        PointWWFixed 	*cp);			/* buffer in which to return cur. pos. */</PRE>
<P>
Get the current pen position.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<HR>
<A NAME="R_41.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_41.htm_IX_GrGetDefFontID()">
 </A>
<H1 CLASS="refHeading">
GrGetDefFontID()</H1>
<PRE CLASS="syntax">FontID	GrGetDefFontID(
        dword	* sizeSHL16);		/* pointer to buffer for returned size */</PRE>
<P>
Get the system default font (including size).</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
font.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_41.htm_IX_GrGetExclusive()">
 </A>
<H1 CLASS="refHeading">
GrGetExclusive()</H1>
<PRE CLASS="syntax">GStateHandle 	GrGetExclusive(
        GeodeHandle videoDriver);</PRE>
<P>
Use this routine to find out which GState, if any, has grabbed the video exclusive.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_41.htm_IX_GrGetFont()">
 </A>
<H1 CLASS="refHeading">
GrGetFont()</H1>
<PRE CLASS="syntax">FontID	GrGetFont(
        GStateHandle		gstate,				/* subject GState */
        WWFixedAsDWord		* pointSize);				/* pointer to buffer for
						 * returned point size */</PRE>
<P>
Get the passed GState's current font, including point size.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_41.htm_IX_GrGetFontName()">
 </A>
<H1 CLASS="refHeading">
GrGetFontName()</H1>
<PRE CLASS="syntax">FontID 	GrGetFontName(
        FontID 		id,			/* ID of font */
        const char 		* name);			/* buffer for returned name string */</PRE>
<P>
Get the string name of a font. Note that if the returned <CODE>
FontID</CODE>
 is zero, then the font was not found. The name string buffer should be a least FID_NAME_LEN in size.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
font.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_41.htm_IX_GrGetFontWeight()">
 </A>
<H1 CLASS="refHeading">
GrGetFontWeight()</H1>
<PRE CLASS="syntax">FontWeight GrGetFontWeight(
        GStateHandle gstate);				/* GState containing the font */</PRE>
<P>
Get the current font weight set for the passed GState.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
font.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_41.htm_IX_GrGetFontWidth()">
 </A>
<H1 CLASS="refHeading">
GrGetFontWidth()</H1>
<PRE CLASS="syntax">FontWidth GrGetFontWidth(
        GStateHandle gstate);				/* GState containing the font */</PRE>
<P>
Get the current font width set for the passed GState.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
font.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_41.htm_IX_GrGetGStringBounds()">
 </A>
<H1 CLASS="refHeading">
GrGetGStringBounds()</H1>
<PRE CLASS="syntax">void	GrGetGStringBounds(
        GStringHandle		source,				/* GString to be checked */
        GStateHandle		dest,				/* handle of GState to use */
        GSControl		flags,				/* GSControl flags */
        Rectangle		* bounds);				/* returned bounds of GState */</PRE>
<P>
This routine returns the coordinate bounds of the <CODE>
source</CODE>
 GString drawn at the current position in the GString. The <CODE>
dest</CODE>
 GState will be used if passed; to have no GState restrictions, pass a null handle. The bounds of the smallest containing rectangle will be returned in the structure pointed to by <CODE>
bounds</CODE>
.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_41.htm_IX_GrGetGStringBoundsDWord()">
 </A>
<H1 CLASS="refHeading">
GrGetGStringBoundsDWord</H1>
<PRE CLASS="syntax">void	GrGetGStringBoundsDWord(
        Handle		gstring,				/* GString to be checked */
        GStateHandle		gstate,				/* handle of GState to use */
        GSControl		flags,				/* GSControl flags */
        RectDWord		* bounds);				/* returned bounds of GState */</PRE>
<P>
This routine behaves as <CODE>
<A HREF="../../CRef/Routines/R_41.htm#IX_GrGetGStringBounds()">GrGetGStringBounds()</A></CODE>
, but has been alterred to work with 32-bit graphics spaces.</P>
<P>
This routine returns the coordinate bounds of aGString drawn at the current position in the GString. The <EM>
gstate</EM>
 GState will be used if passed; to have no GState restrictions, pass a null handle. The bounds of the smallest containing rectangle will be returned in the structure pointed to by <CODE>
bounds</CODE>
.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_41.htm_IX_GrGetGStringElement()">
 </A>
<H1 CLASS="refHeading">
GrGetGStringElement()</H1>
<PRE CLASS="syntax">GStringElement GrGetGStringElement(
        GStateHandle		gstate,					/* handle of GString's GState */
        void 		* buffer,					/* pointer to return buffer */
        word 		bufSize,					/* size of return buffer */
        word 		* elementSize,					/* size of GString element */
        void		** pointerAfterData);							/* pointer to pointer to
							 * next element in GString */</PRE>
<P>
Extract the next element from a graphics string. The opcode is returned explicitly. The routine's data can be returned in a buffer.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>

<DIV>
<A NAME="R_41.htm_IX_GrGetHugeBitmapSize()">
 </A>
<H1 CLASS="refHeading">
GrGetHugeBitmapSize()</H1>
<PRE CLASS="syntax">XYValueAsDWord GrGetHugeBitmapSize(
        VMFileHandle		vmFile,	
        VMBlockHandle 		vmBlk);</PRE>
<P>
Returns the dimensions (horizontal and vertical) of the passed huge bitmap, 
as referenced by a VM block and file.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>

<DIV>
<A NAME="R_41.htm_IX_GrGetInfo()">
 </A>
<H1 CLASS="refHeading">
GrGetInfo()</H1>
<PRE CLASS="syntax">void	GrGetInfo(
        GStateHandle		gstate,			/* GState to get information about */
        GrInfoTypes		type,			/* type of information to get */
        void	 	* data);			/* buffer for returned information */</PRE>
<P>
Get the private data, window handle, or pen position associated with the GState.</P>
<P CLASS="refField"><STRONG>
Structures:</STRONG>	</P>
<PRE>typedef enum {
    GIT_PRIVATE_DATA,
    GIT_WINDOW, 
    GIT_PEN_POS
} GrInfoType</PRE>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_41.htm_IX_GrGetLineColor()">
 </A>
<H1 CLASS="refHeading">
GrGetLineColor()</H1>
<PRE CLASS="syntax">RGBColorAsDWord GrGetLineColor(
        GStateHandle gstate);				/* subject GState */</PRE>
<P>
Get the color used when drawing lines.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_41.htm_IX_GrGetLineColorMap()">
 </A>
<H1 CLASS="refHeading">
GrGetLineColorMap()</H1>
<PRE CLASS="syntax">ColorMapMode GrGetLineColorMap(
        GStateHandle gstate);				/* subject GState */</PRE>
<P>
Get the mode used when drawing lines in an unavailable color.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_41.htm_IX_GrGetLineEnd()">
 </A>
<H1 CLASS="refHeading">
GrGetLineEnd()</H1>
<PRE CLASS="syntax">LineEnd	GrGetLineEnd(
        GStateHandle gstate);				/* subject GState */</PRE>
<P>
Get the end used when drawing lines.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_41.htm_IX_GrGetLineJoin()">
 </A>
<H1 CLASS="refHeading">
GrGetLineJoin()</H1>
<PRE CLASS="syntax">LineJoin GrGetLineJoin(
        GStateHandle gstate);				/* subject GState */</PRE>
<P>
Get the join used when drawing corners.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<HR>
<A NAME="R_42.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_42.htm_IX_GrGetLineMask()">
 </A>
<H1 CLASS="refHeading">
GrGetLineMask()</H1>
<PRE CLASS="syntax">SysDrawMask GrGetLineMask(
        GStateHandle		gstate,			/* subject GState */
        DrawMask		* dm);			/* buffer for returned custom mask */</PRE>
<P>
Get the drawing mask used when drawing lines. The <EM>
dm</EM>
 argument should point to a buffer capable of holding at least eight bytes to get the bit-pattern of the mask; otherwise <EM>
dm</EM>
 should be NULL. The returned buffer is the 8x8 bit pattern: each byte represents a row of the pattern, and the bytes are ordered from top row to bottom.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_42.htm_IX_GrGetLineStyle()">
 </A>
<H1 CLASS="refHeading">
GrGetLineStyle()</H1>
<PRE CLASS="syntax">LineStyle GrGetLineStyle(
        GStateHandle gstate);				/* subject GState */</PRE>
<P>
Get the style, or &quot;dottedness,&quot; used when drawing lines.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_42.htm_IX_GrGetLineWidth()">
 </A>
<H1 CLASS="refHeading">
GrGetLineWidth()</H1>
<PRE CLASS="syntax">WWFixedAsDWord 	GrGetLineWidth(
        GStateHandle gstate);				/* subject GState */</PRE>
<P>
Get the current line width.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_42.htm_IX_GrGetMaskBounds()">
 </A>
<H1 CLASS="refHeading">
GrGetMaskBounds()</H1>
<PRE CLASS="syntax">void	GrGetMaskBounds(
        GStateHandle		gstate,				/* subject GState */
        Rectangle		* bounds);				/* buffer for returned bounds */</PRE>
<P>
Get the 16-bit bounds of the current clip rectangle.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_42.htm_IX_GrGetMaskBoundsDWord()">
 </A>
<H1 CLASS="refHeading">
GrGetMaskBoundsDWord()</H1>
<PRE CLASS="syntax">void	GrGetMaskBoundsDWord(
        GStateHandle		gstate,				/* subject GState */
        RectDWord		* bounds);				/* buffer for returned bounds */</PRE>
<P>
Get the 16-bit bounds of the current clip rectangle, accurate to a fraction of a point.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_42.htm_IX_GrGetMiterLimit()">
 </A>
<H1 CLASS="refHeading">
GrGetMiterLimit()</H1>
<PRE CLASS="syntax">WWFixedAsDWord GrGetMiterLimit(
        GStateHandle gstate);						/* subject GState */</PRE>
<P>
Get the miter limit to use when drawing mitered corners.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_42.htm_IX_GrGetMixMode()">
 </A>
<H1 CLASS="refHeading">
GrGetMixMode()</H1>
<PRE CLASS="syntax">MixMode GrGetMixMode(
        GStateHandle gstate);					/* subject GState */</PRE>
<P>
Get the current mixing mode.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_42.htm_IX_GrGetPalette()">
 </A>
<H1 CLASS="refHeading">
GrGetPalette()</H1>
<PRE CLASS="syntax">MemHandle GrGetPalette(
        GStateHandle		gstate,					/* subject GState */
        GetPalType		flag,					/* GPT_ACTIVE, GPT_CUSTOM, or
							 * GPT_DEFAULT */</PRE>
<PRE CLASS="syntax">        word	 	* numEntries);					/* number of entries in block */</PRE>
<P>
Return all or part of the window's color lookup table. This routine returns the  handle of a block containing all the returned palette entries.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_42.htm_IX_GrGetPath()">
 </A>
<H1 CLASS="refHeading">
GrGetPath()</H1>
<PRE CLASS="syntax">MemHandle 	GrGetPath(
        GStateHandle		gstate,				/* subject GState */
        GetPathType 		ptype);				/* Which path to retrieve */</PRE>
<P>
Returns handle to block containing path data. Either the current path, the clipping path, or the window clipping path may be retrieved.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_42.htm_IX_GrGetPathBounds()">
 </A>
<H1 CLASS="refHeading">
GrGetPathBounds()</H1>
<PRE CLASS="syntax">Boolean	GrGetPathBounds(
        GStateHandle		gstate,				/* subject GState */
        GetPathType 		ptype,
        Rectangle		* bounds);				/* buffer for returned bounds */</PRE>
<P>
Returns the rectangular bounds that encompass the current path as it would be filled. A <CODE>
true</CODE>
 return value indicates an error occurred or there was no path for the GState.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_42.htm_IX_GrGetPathBoundsDWord()">
 </A>
<H1 CLASS="refHeading">
GrGetPathBoundsDWord()</H1>
<PRE CLASS="syntax">Boolean	GrGetPathBoundsDWord(
        GStateHandle		gstate,				/* subject GState */
        GetPathType		ptype,
        RectDWord		* bounds);				/* buffer for returned bounds */</PRE>
<P>
Returns the rectangular bounds that encompass the current path as it would be filled. A <CODE>
true</CODE>
 return value indicates an error occurred or there was no path for the GState.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_42.htm_IX_GrGetPathPoints()">
 </A>
<H1 CLASS="refHeading">
GrGetPathPoints()</H1>
<PRE CLASS="syntax">MemHandle 	GrGetPathPoints(
        GStateHandle		gstate,					/* subject GState */
        word		resolution);					/* dots per inch */</PRE>
<P>
Returns a series of points that fall along the current path. The returned points are in document coordinates.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_42.htm_IX_GrGetPathRegion()">
 </A>
<H1 CLASS="refHeading">
GrGetPathRegion()</H1>
<PRE CLASS="syntax">MemHandle GrGetPathRegion(
        GStateHandle		gstate,				/* subject GState */
        RegionFillRule		rule);				/* ODD_EVEN or WINDING */</PRE>
<P>
Get the region enclosed by a path.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_42.htm_IX_GrGetPoint()">
 </A>
<H1 CLASS="refHeading">
GrGetPoint()</H1>
<PRE CLASS="syntax">RGBColorAsDWord GrGetPoint(
        GStateHandle		gstate,			/* subject GState */
        sword		x,			/* coordinates of pixel */
        sword		y);</PRE>
<P>
Get the color of the pixel corresponding to the specified coordinates.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<HR>
<A NAME="R_43.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_43.htm_IX_GrGetPtrRegBounds()">
 </A>
<A NAME="R_43.htm_IX_Regions, graphics:GrGetPtrRegBounds()">
 </A>
<H1 CLASS="refHeading">
GrGetPtrRegBounds()</H1>
<PRE CLASS="syntax">word	GrGetPtrRegBounds( /* Returns size of Region data struct. */
        const	Region	* reg,				/* pointer to region */
        Rectangle		* bounds);				/* returned bounds of region */</PRE>
<P>
Get the bounds of the passed region.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_43.htm_IX_GrGetSubscriptAttr()">
 </A>
<H1 CLASS="refHeading">
GrGetSubscriptAttr()</H1>
<PRE CLASS="syntax">ScriptAttrAsWord GrGetSubscriptAttr(
        GStateHandle gstate);					/* subject GState */</PRE>
<P>
Get the GState's subscript drawing attributes. The high byte of the return value is the percentage of the font size for the subscript; the low byte is the percentage of the font size from the top at which the character gets drawn.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
font.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_43.htm_IX_GrGetSuperscriptAttr()">
 </A>
<H1 CLASS="refHeading">
GrGetSuperscriptAttr()</H1>
<PRE CLASS="syntax">ScriptAttrAsWord GrGetSuperscriptAttr(
        GStateHandle gstate);					/* subject GState */</PRE>
<P>
Get the GState's superscript drawing attributes. The high byte of the return value is the percentage of the font size for the superscript; the low byte is the percentage of the font size from the bottom at which the character gets drawn.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
font.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_43.htm_IX_Fonts:metrics, GrGetTextBounds() and">
 </A>
<A NAME="R_43.htm_IX_GrGetTextBounds()">
 </A>
<H1 CLASS="refHeading">
GrGetTextBounds()</H1>
<PRE CLASS="syntax">Boolean	GrGetTextBounds(
        GStateHandle		gstate,			/* subject GState */
        const char		* str,			/* text string */
        word 		xpos,			/* position where text would be drawn */
        word 		ypos,
        word 		count,			/* max number of characters to check */
        Rectangle 		* bounds);				/* returned bounding rectangle */</PRE>
<P>
Get the bounds required to draw the passed text. If the passed <CODE>
count</CODE>
 argument is zero, the string is assumed to be null-terminated.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_43.htm_IX_GrGetTextColor()">
 </A>
<H1 CLASS="refHeading">
GrGetTextColor()</H1>
<PRE CLASS="syntax">RGBColorAsDWord GrGetTextColor(
        GStateHandle gstate);				/* subject GState */</PRE>
<P>
Get the color used when drawing text.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_43.htm_IX_GrGetTextColorMap()">
 </A>
<H1 CLASS="refHeading">
GrGetTextColorMap()</H1>
<PRE CLASS="syntax">ColorMapMode 	GrGetTextColorMap(
        GStateHandle gstate);				/* subject GState */</PRE>
<P>
Get the mode used when drawing text in an unavailable color.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_43.htm_IX_GrGetTextMask()">
 </A>
<H1 CLASS="refHeading">
GrGetTextMask()</H1>
<PRE CLASS="syntax">SystemDrawMask 	GrGetTextMask(
        GStateHandle		gstate,			/* subject GState */
        DrawMask		* dm);			/* returned custom mask, if any */</PRE>
<P>
Get the draw mask used when drawing text.The <EM>
dm</EM>
 argument should point to a buffer capable of holding at least eight bytes to get the bit-pattern of the mask; otherwise <EM>
dm</EM>
 should be NULL. The returned buffer is the 8x8 bit pattern: each byte represents a row of the pattern, and the bytes are ordered from top row to bottom.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_43.htm_IX_GrGetTextMode()">
 </A>
<H1 CLASS="refHeading">
GrGetTextMode()</H1>
<PRE CLASS="syntax">TextMode	GrGetTextMode(
        GStateHandle gstate);				/* subject GState */</PRE>
<P>
Get the text mode, including information about the vertical offset used when drawing text.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_43.htm_IX_GrGetTextPattern()">
 </A>
<H1 CLASS="refHeading">
GrGetTextPattern()</H1>
<PRE CLASS="syntax">GraphicPattern 	GrGetTextPattern(
        GStateHandle	 	gstate,						/* subject GState */
        const MemHandle		* customPattern,						/* pointer to returned handle
								 * of block containing the
								 * returned pattern */</PRE>
<PRE CLASS="syntax">        word		* customSize);						/* size of returned block */</PRE>
<P>
Get the graphics pattern used when drawing text.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_43.htm_IX_GrGetTextSpacePad()">
 </A>
<H1 CLASS="refHeading">
GrGetTextSpacePad()</H1>
<PRE CLASS="syntax">WWFixedAsDWord GrGetTextSpacePad(
        GStateHandle gstate);				/* subject GState */</PRE>
<P>
Get the space pad used when drawing strings of text.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_43.htm_IX_GrGetTextStyle()">
 </A>
<H1 CLASS="refHeading">
GrGetTextStyle()</H1>
<PRE CLASS="syntax">TextStyle 	GrGetTextStyle(
        GStateHandle gstate);					/* subject GState */</PRE>
<P>
Get the style used when drawing text.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_43.htm_IX_GrGetTrackKern()">
 </A>
<H1 CLASS="refHeading">
GrGetTrackKern()</H1>
<PRE CLASS="syntax">word 	GrGetTrackKern(
        GStateHandle 	gstate);				/* subject GState */</PRE>
<P>
Get the track kerning used when drawing strings of text.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_43.htm_IX_GrGetTransform()">
 </A>
<H1 CLASS="refHeading">
GrGetTransform()</H1>
<PRE CLASS="syntax">void	GrGetTransform(
        GStateHandle		gstate,			/* subject GState */
        TransMatrix		* tm);			/* pointer to returned TransMatrix */</PRE>
<P>
Get the current coordinate transformation, expressed as a matrix.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_43.htm_IX_GrGetWinBounds()">
 </A>
<H1 CLASS="refHeading">
GrGetWinBounds()</H1>
<PRE CLASS="syntax">void	GrGetWinBounds(
        GStateHandle		gstate,				/* subject GState */
        Rectangle		* bounds);				/* returned window bounds */</PRE>
<P>
Get the bounds of the GState's associated window.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_43.htm_IX_GrGetWinBoundsDWord()">
 </A>
<H1 CLASS="refHeading">
GrGetWinBoundsDWord()</H1>
<PRE CLASS="syntax">void	GrGetWinBoundsDWord(
        GStateHandle		gstate,				/* subject GState */
        RectDWord		* bounds);				/* returned window bounds */</PRE>
<P>
Get the bounds of the GState's associated window, accurate to a fraction of a point.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_43.htm_IX_GrGetWinHandle()">
 </A>
<H1 CLASS="refHeading">
GrGetWinHandle()</H1>
<PRE CLASS="syntax">WindowHandle GrGetWinHandle(
        GStateHandle gstate);					/* subject GState */</PRE>
<P>
Get the handle of the GState's associated window.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_43.htm_IX_GrGrabExclusive()">
 </A>
<H1 CLASS="refHeading">
GrGrabExclusive()</H1>
<PRE CLASS="syntax">GStateHandle GrGrabExclusive(
        GeodeHandle		videoDriver,				/* NULL for default */
        GStateHandle		gstate);				/* subject GState */</PRE>
<P>
Start drawing exclusively to a video driver.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<HR>
<A NAME="R_44.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_44.htm_IX_GrInitDefaultTransform()">
 </A>
<H1 CLASS="refHeading">
GrInitDefaultTransform()</H1>
<PRE CLASS="syntax">void	GrInitDefaultTransform(
        GStateHandle gstate);					/* subject GState */</PRE>
<P>
Initialize the GState's default transformation to hold the value of the current transformation.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_44.htm_IX_GrInvalRect()">
 </A>
<H1 CLASS="refHeading">
GrInvalRect()</H1>
<PRE CLASS="syntax">void	GrInvalRect(
        GStateHandle		gstate,				/* subject GState */
        sword		left,				/* bounds to be invalidated */
        sword		top,
        sword		right,
        sword		bottom);</PRE>
<P>
Invalidate the passed rectangular area. This area will be redrawn.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_44.htm_IX_GrInvalRectDWord()">
 </A>
<H1 CLASS="refHeading">
GrInvalRectDWord()</H1>
<PRE CLASS="syntax">void	GrInvalRectDWord(
        GStateHandle		gstate,				/* subject GState */
        const	RectDWord	* bounds);				/* bounds to be invalidated */</PRE>
<P>
Invalidate the passed rectangular area. This area will be redrawn.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_44.htm_IX_GrLabel()">
 </A>
<H1 CLASS="refHeading">
GrLabel()</H1>
<PRE CLASS="syntax">void	GrLabel(
        GStringHandle		gstate,			/* subject GState */
        word			label);			/* label to write to GString */</PRE>
<P>
Write the passed label into the passed GString.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_44.htm_IX_GrLoadGString()">
 </A>
<H1 CLASS="refHeading">
GrLoadGString()</H1>
<PRE CLASS="syntax">Handle GrLoadGString(
        Handle		han,				/* handle of GString source */
        GStringType	hanType,			/* handle type */
        word		vmBlock);			/* if VM file, handle of VM block */</PRE>
<P>
Load a graphics string from a file. Used with stream, VM, and pointer
addressed GStrings.</P>
<P>
When done with the GString, you may free it via <CODE>
<A HREF="../../CRef/Routines/R_39.htm#IX_GrDestroyGString()">GrDestroyGString()</A></CODE>.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_44.htm_IX_GrMapColorIndex()">
 </A>
<H1 CLASS="refHeading">
GrMapColorIndex()</H1>
<PRE CLASS="syntax">RGBColorAsDWord GrMapColorIndex(
        GStateHandle		gstate,			/* GState to use for mapping */
        Color		c);			/* source color to be mapped */</PRE>
<P>
Map a color index to its RGB equivalent using the color mapping scheme of the passed GState.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_44.htm_IX_GrMapColorRGB()">
 </A>
<H1 CLASS="refHeading">
GrMapColorRGB()</H1>
<PRE CLASS="syntax">RGBColorAsDWord GrMapColorRGB(
        GStateHandle		gstate,			/* GState to use for mapping */
        word		red,			/* RGB values to map */
        word		green,
        word		blue);</PRE>
<P>
Map an RGB color to an index.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_44.htm_IX_GrMoveReg()">
 </A>
<A NAME="R_44.htm_IX_Regions, graphics:GrMoveReg()">
 </A>
<H1 CLASS="refHeading">
GrMoveReg()</H1>
<PRE CLASS="syntax">void	GrMoveReg(
        Region	* reg,	/* pointer to region */
        sword	xOffset,	/* amount to shift horizontally */
        sword	yOffset);	/* amount to shift vertically */</PRE>
<P>
Moves a region a given amount. Note that this operation affects only the region's data structure. The region must be redrawn or used in some other way for the changes to have any visible effect.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_44.htm_IX_Current position (graphics):GrMoveTo()">
 </A>
<A NAME="R_44.htm_IX_GrMoveTo()">
 </A>
<H1 CLASS="refHeading">
GrMoveTo()</H1>
<PRE CLASS="syntax">void	GrMoveTo(
        GStateHandle		gstate,			/* subject GState */
        sword		x,			/* new absolute pen position */
        sword		y);</PRE>
<P>
Change the pen position.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_44.htm_IX_GrMoveToWWFixed()">
 </A>
<H1 CLASS="refHeading">
GrMoveToWWFixed()</H1>
<PRE CLASS="syntax">void GrMoveToWWFixed(
        GStateHandle gstate, 
        WWFixedAsDWord x, 
        WWFixedAsDWord y);</PRE>
<P>
This routine changes the pen position very precisely.</P>
</DIV>
<DIV>
<A NAME="R_44.htm_IX_GrMulDWFixed()">
 </A>
<H1 CLASS="refHeading">
GrMulDWFixed()</H1>
<PRE CLASS="syntax">void	GrMulDWFixed(
        const	DWFixed	* i,				/* first number */
        const	DWFixed	* j,				/* second number */
        DWFixed		* result);				/* pointer to returned result */</PRE>
<P>
Multiply two fixed point numbers.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_44.htm_IX_GrMulWWFixed()">
 </A>
<H1 CLASS="refHeading">
GrMulWWFixed()</H1>
<PRE CLASS="syntax">WWFixedAsDWord GrMulWWFixed(
        WWFixedAsDWord i,			/* first number */
        WWFixedAsDWord j);			/* second number */</PRE>
<P>
Multiply two fixed point numbers.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<HR>
<A NAME="R_45.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_45.htm_IX_Printing:form feeds">
 </A>
<A NAME="R_45.htm_IX_GrNewPage()">
 </A>
<H1 CLASS="refHeading">
GrNewPage()</H1>
<PRE CLASS="syntax">void	GrNewPage(
        GStateHandle 		gstate,
        PageEndCommand 		pageEndCommand);</PRE>
<P>
Begin drawing a new page. Normally used when printing documents.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_45.htm_IX_GrNullOp()">
 </A>
<H1 CLASS="refHeading">
GrNullOp()</H1>
<PRE CLASS="syntax">void	GrNullOp(
        GStateHandle gstate);				/* subject GState */</PRE>
<P>
Write a null operation element to a GString.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_45.htm_IX_GrParseGString()">
 </A>
<H1 CLASS="refHeading">
GrParseGString()</H1>
<PRE CLASS="syntax">void	GrParseGString(
        GStateHandle gstate, 
        GStateHandle gstringToDraw,
        GSControl flags, 
        Boolean (*callback) /* TRUE to stop */ (void *element));</PRE>
<P>
This routine traverses a GString, calling a callback function on each GStringElement encountered.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_45.htm_IX_GrQuickArcSine()">
 </A>
<H1 CLASS="refHeading">
GrQuickArcSine()</H1>
<PRE CLASS="syntax">WWFixedAsDWord GrQuickArcSine(
        WWFixedAsDWord		deltaYDivDistance,						/* delta y / distance */
        word		origDeltaX);						/* original delta x */</PRE>
<P>
Compute a fixed point arcsine. Angles are given in degrees counterclockwise of the positive x axis.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_45.htm_IX_GrQuickCosine()">
 </A>
<H1 CLASS="refHeading">
GrQuickCosine()</H1>
<PRE CLASS="syntax">WWFixedAsDWord GrQuickCosine(
        WWFixedAsDWord angle);				/* angle to cosine */</PRE>
<P>
Compute a fixed point cosine. Angles are given in degrees counterclockwise of the positive x axis.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_45.htm_IX_GrQuickSine()">
 </A>
<H1 CLASS="refHeading">
GrQuickSine()</H1>
<PRE CLASS="syntax">WWFixedAsDWord GrQuickSine(
        WWFixedAsDWord angle);				/* angle to sine */</PRE>
<P>
Compute a fixed point sine. Angles are given in degrees counterclockwise of the positive x axis.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_45.htm_IX_GrQuickTangent()">
 </A>
<H1 CLASS="refHeading">
GrQuickTangent()</H1>
<PRE CLASS="syntax">WWFixedAsDWord GrQuickTangent(
        WWFixedAsDWord angle);				/* angle to tangent */</PRE>
<P>
Compute a fixed point tangent. Angles are given in degrees counterclockwise of the positive x axis.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_45.htm_IX_GrReleaseExclusive()">
 </A>
<H1 CLASS="refHeading">
GrReleaseExclusive()</H1>
<PRE CLASS="syntax">void 	GrReleaseExclusive( /* TRUE if system had to force a redraw */
        GeodeHandle		videoDriver,				/* handle of video driver */
        GStateHandle		gstate,				/* GState that was drawing */
        Rectangle 		*bounds);				/* Bounds of aborted drawings */</PRE>
<P>
Stop drawing exclusively to a video driver.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_45.htm_IX_GrRelMoveTo()">
 </A>
<H1 CLASS="refHeading">
GrRelMoveTo()</H1>
<PRE CLASS="syntax">void	GrRelMoveTo(
        GStateHandle		gstate,			/* subject GState */
        WWFixedAsDWord 		x,			/* offsets to new pen position */
        WWFixedAsDWord 		y);</PRE>
<P>
Change the pen position to coordinate expressed relative to the current position.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_45.htm_IX_GrRestoreState()">
 </A>
<H1 CLASS="refHeading">
GrRestoreState()</H1>
<PRE CLASS="syntax">void	GrRestoreState(
        GStateHandle gstate);				/* subject GState */</PRE>
<P>
Restore the values of a saved GState.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_45.htm_IX_GrSaveState()">
 </A>
<H1 CLASS="refHeading">
GrSaveState()</H1>
<PRE CLASS="syntax">void	GrSaveState(
        GStateHandle gstate);				/* subject GState */</PRE>
<P>
Save the values of a GState, so that they may be restored by <CODE>
<A HREF="../../CRef/Routines/R_45.htm#IX_GrRestoreState()">GrRestoreState()</A></CODE>
.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<HR>
<A NAME="R_46.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_46.htm_IX_GrSDivDWFByWWF()">
 </A>
<H1 CLASS="refHeading">
GrSDivDWFByWWF()</H1>
<PRE CLASS="syntax">void GrSDivDWFByWWF(
        const DWFixed 		* dividend,
        const WWFixed 		* divisor,
        DWFixed 		* quotient)				/* returned value */</PRE>
<P>
Divide two fixed point numbers.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_46.htm_IX_GrSDivWWFixed()">
 </A>
<H1 CLASS="refHeading">
GrSDivWWFixed()</H1>
<PRE CLASS="syntax">WWFixedAsDWord GrSDivWWFixed(
        WWFixedAsDWord dividend,
        WWFixedAsDWord divisor)</PRE>
<P>
Divide two fixed point numbers.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_46.htm_IX_GrSetAreaAttr()">
 </A>
<H1 CLASS="refHeading">
GrSetAreaAttr()</H1>
<PRE CLASS="syntax">void	GrSetAreaAttr(
        GStateHandle		gstate,			/* subject GState */
        const AreaAttr 		* aa);			/* AreaAttr structure */</PRE>
<P>
Set all of the attributes used when filling areas.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_46.htm_IX_GrSetAreaColor()">
 </A>
<H1 CLASS="refHeading">
GrSetAreaColor()</H1>
<PRE CLASS="syntax">void	GrSetAreaColor(
        GStateHandle 		gstate,				/* GState to set color for */
        ColorFlag 		flag,				/* flag of how to set color */
        word		redOrIndex,				/* color index or red RGB value */
        word		green,				/* green RGB value or zero */
        word		blue);				/* blue RGB value or zero */</PRE>
<P>
Set the color to use when filling areas. The flag parameter may be CF_RGB (to set RGB values), CF_INDEX (to set a palette index), CF_GRAY, or CF_SAME.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_46.htm_IX_GrSetAreaColorMap()">
 </A>
<H1 CLASS="refHeading">
GrSetAreaColorMap()</H1>
<PRE CLASS="syntax">void	GrSetAreaColorMap(
        GStateHandle 		gstate,				/* subject GState */
        ColorMapMode 		colorMap);				/* color mapping mode */</PRE>
<P>
Set mode to use when trying to fill an area with an unavailable color.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_46.htm_IX_GrSetAreaMaskCustom()">
 </A>
<H1 CLASS="refHeading">
GrSetAreaMaskCustom()</H1>
<PRE CLASS="syntax">void	GrSetAreaMaskCustom(
        GStateHandle 		gstate,				/* subject GState */
        const	DrawMask  	* dm);				/* pointer to new custom mask */</PRE>
<P>
Set the drawing mask to use when filling areas.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_46.htm_IX_GrSetAreaMaskSys()">
 </A>
<H1 CLASS="refHeading">
GrSetAreaMaskSys()</H1>
<PRE CLASS="syntax">void	GrSetAreaMaskSys(
        GStateHandle 		gstate,				/* subject GState */
        SystemDrawMask 		sysDM);				/* new system area mask */</PRE>
<P>
Set the drawing mask to use when filling areas.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_46.htm_IX_GrSetAreaPattern()">
 </A>
<H1 CLASS="refHeading">
GrSetAreaPattern()</H1>
<PRE CLASS="syntax">void 	GrSetAreaPattern(
        GStateHandle 		gstate,				/* subject GState */
        GraphicPattern 		pattern);				/* new pattern */</PRE>
<P>
Set the graphics pattern to use when filling areas.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_46.htm_IX_GrSetBitmapMode()">
 </A>
<H1 CLASS="refHeading">
GrSetBitmapMode()</H1>
<PRE CLASS="syntax">void	GrSetBitmapMode(
        GStateHandle  		gstate,				/* subject GState */
        word 		flags,		 /* BM_EDIT_MASK or BM_CLUSTERED_DITHER */
        MemHandle 		colorCorr);				/* handle of ColorTransfer */</PRE>
<P>
Set the bitmap editing mode. This allows the editing of a bitmap's mask, or turning on clustered dithering.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_46.htm_IX_GrSetBitmapRes()">
 </A>
<H1 CLASS="refHeading">
GrSetBitmapRes()</H1>
<PRE CLASS="syntax">Boolean	GrSetBitmapRes(
        GStateHandle		gstate,				/* subject GState */
        word		xRes,				/* new resolutions */
        word		yRes);</PRE>
<P>
Set a complex bitmap's resolution.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<HR>
<A NAME="R_47.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_47.htm_IX_GrSetClipPath()">
 </A>
<H1 CLASS="refHeading">
GrSetClipPath()</H1>
<PRE CLASS="syntax">void	GrSetClipPath(
        GStateHandle 		gstate,				/* subject GState */
        PathCombineType 		params,				/* how paths should be combined */
        RegionFillRule 		rule);				/* ODD_EVEN or WINDING */</PRE>
<P>
Restrict the clipping region by intersecting it with the passed path.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_47.htm_IX_GrSetClipRect()">
 </A>
<H1 CLASS="refHeading">
GrSetClipRect()</H1>
<PRE CLASS="syntax">void	GrSetClipRect(
        GStateHandle 		gstate,				/* subject GState */
        PathCombineType		flags,				/* how paths should be combined */
        sword		left,				/* bounds of clipping rectangle */
        sword		top,
        sword		right,
        sword		bottom);</PRE>
<P>
Restrict the clipping region by intersecting it with the passed rectangle.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_47.htm_IX_GrSetCustomAreaPattern()">
 </A>
<H1 CLASS="refHeading">
GrSetCustomAreaPattern()</H1>
<PRE CLASS="syntax">void 	GrSetCustomAreaPattern(
        GStateHandle 		gstate,				/* subject GState */
        GraphicPattern 		pattern,				/* new area pattern */
        const void 	*	patternData,				/* pointer to pattern data */
        word		patternSize); /* size of pattern data buffer */</PRE>
<P>
Set the graphics pattern to use when filling areas.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_47.htm_IX_GrSetCustomTextPattern()">
 </A>
<H1 CLASS="refHeading">
GrSetCustomTextPattern()</H1>
<PRE CLASS="syntax">void 	GrSetCustomTextPattern(
        GStateHandle 		gstate,					/* subject GState */
        GraphicPattern		pattern,					/* new pattern */
        const void 		* patternData		);			/* pointer to pattern data */</PRE>
<P>
Set the graphic pattern used when drawing text.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_47.htm_IX_GrSetDefaultTransform()">
 </A>
<H1 CLASS="refHeading">
GrSetDefaultTransform()</H1>
<PRE CLASS="syntax">void	GrSetDefaultTransform(
        GStateHandle gstate);				/* subject GState */</PRE>
<P>
Replace the current coordinate transformation with the default transformation.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_47.htm_IX_GrSetFont()">
 </A>
<H1 CLASS="refHeading">
GrSetFont()</H1>
<PRE CLASS="syntax">void	GrSetFont(
        GStateHandle 		gstate,				/* subject GState */
        FontID 		id,				/* new font ID */
        WWFixedAsDWord 		pointSize);				/* new point size */</PRE>
<P>
Set the font to use when drawing text.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_47.htm_IX_GrSetFontWeight()">
 </A>
<H1 CLASS="refHeading">
GrSetFontWeight()</H1>
<PRE CLASS="syntax">void	GrSetFontWeight(
        GStateHandle 		gstate,				/* subject GState */
        FontWeight 		weight);				/* new font weight */</PRE>
<P>
Set the font weight to use when drawing text.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
font.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_47.htm_IX_GrSetFontWidth()">
 </A>
<H1 CLASS="refHeading">
GrSetFontWidth()</H1>
<PRE CLASS="syntax">void	GrSetFontWidth(
        GStateHandle 		gstate,				/* subject GState */
        FontWidth 		width);				/* new font width */</PRE>
<P>
Set the font width to use when drawing text.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
font.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_47.htm_IX_GrSetGStringBounds()">
 </A>
<A NAME="R_47.htm_IX_GStrings:GrSetGStringBounds() optimization">
 </A>
<H1 CLASS="refHeading">
GrSetGStringBounds()</H1>
<PRE CLASS="syntax">void	GrSetGStringBounds(
        Handle		gstate,				/* GState or GString handle */
        sword		left,				/* new bounds of GString */
        sword		top,
        sword		right,
        sword		bottom);</PRE>
<P>
Optimization routine which allows you to set bounds values for a GString. This bounds information will be returned by <CODE>
GrGetGStringBounds() </CODE>
whenever that routine is called upon the affected GString.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_47.htm_IX_GrSetGStringPos()">
 </A>
<A NAME="R_47.htm_IX_GStringSetPosType">
 </A>
<A NAME="R_47.htm_IX_GSSPT_&ldots;">
 </A>
<H1 CLASS="refHeading">
GrSetGStringPos()</H1>
<PRE CLASS="syntax">void	GrSetGStringPos(
        GStateHandle		gstate,				/* subject GState */
        GStringSetPosType		type,				/* how to set position */
        word		skip);				/* number of elements to skip */</PRE>
<P>
Set a graphics strings' &quot;playing position.&quot; Using this routine, it is possible to draw only selected elements of a GString.</P>
<P CLASS="refField"><STRONG>
Structures:</STRONG>	</P>
<PRE>typedef ByteEnum GStringSetPosType;
/*	GSSPT_SKIP, 
	GSSPT_RELATIVE, 
	GSSPT_BEGINNING,
	GSSPT_END		*/</PRE>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<HR>
<A NAME="R_48.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_48.htm_IX_GrSetLineAttr()">
 </A>
<H1 CLASS="refHeading">
GrSetLineAttr()</H1>
<PRE CLASS="syntax">void	GrSetLineAttr(
        GStateHandle 		gstate,			/* subject GState */
        const LineAttr 		* la);			/* new line attributes */</PRE>
<P>
Set all attributes to use when drawing lines and corners.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_48.htm_IX_GrSetLineColor()">
 </A>
<H1 CLASS="refHeading">
GrSetLineColor()</H1>
<PRE CLASS="syntax">void	GrSetLineColor(
        GStateHandle 		gstate,				/* subject GState */
        ColorFlag 		flag,				/* color flag */
        word		redOrIndex,				/* new index or red RGB value */
        word		green,				/* new green RGB value or zero */
        word		blue);				/* new blue RGB value or zero */</PRE>
<P>
Set the color to use when drawing lines.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_48.htm_IX_GrSetLineColorMap()">
 </A>
<H1 CLASS="refHeading">
GrSetLineColorMap()</H1>
<PRE CLASS="syntax">void	GrSetLineColorMap(
        GStateHandle gstate,				/* subject GState */
        ColorMapMode colorMap);				/* new color map mode for lines */</PRE>
<P>
Set the mode to use when trying to draw lines in an unavailable color.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_48.htm_IX_GrSetLineEnd()">
 </A>
<H1 CLASS="refHeading">
GrSetLineEnd()</H1>
<PRE CLASS="syntax">void	GrSetLineEnd(
        GStateHandle 		gstate,				/* subject GState */
        LineEnd 		end);				/* new line end specification */</PRE>
<P>
Set the end to use when drawing lines.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_48.htm_IX_GrSetLineJoin()">
 </A>
<H1 CLASS="refHeading">
GrSetLineJoin()</H1>
<PRE CLASS="syntax">void	GrSetLineJoin(
        GStateHandle 		gstate,				/* subject GState */
        LineJoin 		join);				/* new line join specification */</PRE>
<P>
Set the line join to use when drawing corners.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_48.htm_IX_GrSetLineMaskCustom()">
 </A>
<H1 CLASS="refHeading">
GrSetLineMaskCustom()</H1>
<PRE CLASS="syntax">void	GrSetLineMaskCustom(
        GStateHandle 		gstate,				/* subject GState */
        const	DrawMask  	* dm);				/* new line draw mask */</PRE>
<P>
Set the drawing mask used when drawing lines.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_48.htm_IX_GrSetLineMaskSys()">
 </A>
<H1 CLASS="refHeading">
GrSetLineMaskSys()</H1>
<PRE CLASS="syntax">void	GrSetLineMaskSys(
        GStateHandle 		gstate,				/* subject GState */
        SystemDrawMask 		sysDM);				/* the new system line mask */</PRE>
<P>
Set the drawing mask used when drawing lines.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_48.htm_IX_GrSetLineStyle()">
 </A>
<H1 CLASS="refHeading">
GrSetLineStyle()</H1>
<PRE CLASS="syntax">void	GrSetLineStyle(
        GStateHandle	 	gstate,					/* subject GState */
        LineStyle 		style,					/* new line style */
        word		skipDistance,					/* skip distance to first pair */
        const DashPairArray		* dpa,					/* dash definition */
        word		numPairs);					/* number of pairs */</PRE>
<P>
Set the style, or &quot;dottedness,&quot; to use when drawing lines.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_48.htm_IX_GrSetLineWidth()">
 </A>
<H1 CLASS="refHeading">
GrSetLineWidth()</H1>
<PRE CLASS="syntax">void	GrSetLineWidth(
        GStateHandle 		gstate,				/* subject GState */
        WWFixedAsDWord 		width);				/* new line width */</PRE>
<P>
Set the line width to use when drawing lines.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_48.htm_IX_GrSetMiterLimit()">
 </A>
<H1 CLASS="refHeading">
GrSetMiterLimit()</H1>
<PRE CLASS="syntax">void	GrSetMiterLimit(
        GStateHandle 		gstate,				/* subject GState */
        WWFixedAsDWord 		limit);				/* new miter limit */</PRE>
<P>
Set the miter limit to use when drawing mitered corners.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_48.htm_IX_GrSetMixMode()">
 </A>
<H1 CLASS="refHeading">
GrSetMixMode()</H1>
<PRE CLASS="syntax">void	GrSetMixMode(
        GStateHandle 		gstate,				/* subject GState */
        MixMode 		mode);				/* new mix mode */</PRE>
<P>
Set the GState's mix mode, used to determine what happens when something is drawn on top of an existing drawing.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_48.htm_IX_GrSetNullTransform()">
 </A>
<H1 CLASS="refHeading">
GrSetNullTransform()</H1>
<PRE CLASS="syntax">void	GrSetNullTransform(
        GStateHandle gstate);				/* subject GState */</PRE>
<P>
Clear the coordinate transformation. Most applications will actually want to replace the coordinate transformation with the default transformation using <CODE>
<A HREF="../../CRef/Routines/R_47.htm#IX_GrSetDefaultTransform()">GrSetDefaultTransform()</A></CODE>
.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<HR>
<A NAME="R_49.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_49.htm_IX_GrSetPalette()">
 </A>
<H1 CLASS="refHeading">
GrSetPalette()</H1>
<PRE CLASS="syntax">void	GrSetPalette(
        GStateHandle 		gstate,				/* subject GState */
        SetPalType 		type,				/* SPT_DEFAULT or SPT_CUSTOM */
        const RGBValue 		*buffer,				/* array of palette entries */
        word		index, 				/* First element to change */
        word		numEntries);				/* number of entries in array */</PRE>
<P>
Set one or more entries in a palette, a window's color lookup table.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_49.htm_IX_GrSetPaletteEntry()">
 </A>
<H1 CLASS="refHeading">
GrSetPaletteEntry()</H1>
<PRE CLASS="syntax">void	GrSetPaletteEntry(
        GStateHandle 		gstate,				/* subject GState */
        word		index,				/* index in palette to set */
        word		red,				/* new RGB color values for entry */
        word		green,
        word		blue);</PRE>
<P>
Set one entry in a palette, a GState's color lookup table.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_49.htm_IX_GrSetPrivateData()">
 </A>
<H1 CLASS="refHeading">
GrSetPrivateData()</H1>
<PRE CLASS="syntax">void	GrSetPrivateData(
        GStateHandle		gstate,				/* subject GState */
        word		dataAX,				/* data to set */
        word		dataBX,
        word		dataCX,
        word		dataDX);</PRE>
<P>
Set the private data for a GState.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_49.htm_IX_GrSetStrokePath()">
 </A>
<H1 CLASS="refHeading">
GrSetStrokePath()</H1>
<PRE CLASS="syntax">void	GrSetStrokePath(
        GStateHandle gstate);				/* subject GState */</PRE>
<P>
Replace a GState's path with the path resulting from stroking the original path. Note that this stroked path may be drawn, but may not be used for clipping.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_49.htm_IX_GrSetSubscriptAttr()">
 </A>
<H1 CLASS="refHeading">
GrSetSubscriptAttr()</H1>
<PRE CLASS="syntax">void 	GrSetSubscriptAttr(
        GStateHandle 		gstate,				/* subject GState */
        ScriptAttrAsWord 		attrs);				/* new subscript percentages */</PRE>
<P>
Get the attributes used when drawing subscript characters.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
font.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_49.htm_IX_GrSetSuperscriptAttr()">
 </A>
<H1 CLASS="refHeading">
GrSetSuperscriptAttr()</H1>
<PRE CLASS="syntax">void 	GrSetSuperscriptAttr(
        GStateHandle 		gstate,				/* subject GState */
        ScriptAttrAsWord 		attrs);				/* new superscript percentages */</PRE>
<P>
Get the attributes used when drawing superscript characters.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
font.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_49.htm_IX_GrSetTextAttr()">
 </A>
<H1 CLASS="refHeading">
GrSetTextAttr()</H1>
<PRE CLASS="syntax">void	GrSetTextAttr(
        GStateHandle		gstate,				/* subject GState */
        const	TextAttr	* ta);				/* pointer to text attributes */</PRE>
<P>
Set all attributes used when drawing characters and text strings.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_49.htm_IX_GrSetTextColor()">
 </A>
<H1 CLASS="refHeading">
GrSetTextColor()</H1>
<PRE CLASS="syntax">void	GrSetTextColor(
        GStateHandle		gstate,				/* subject GState */
        ColorFlag		flag,				/* color flag */
        word		redOrIndex,				/* palette index or red RGB value */
        word		green,				/* green RGB value or zero */
        word		blue);				/* blue RGB value or zero */</PRE>
<P>
Set the color used when drawing text.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_49.htm_IX_GrSetTextColorMap()">
 </A>
<H1 CLASS="refHeading">
GrSetTextColorMap()</H1>
<PRE CLASS="syntax">void	GrSetTextColorMap(
        GStateHandle		gstate,				/* subject GState */
        ColorMapMode 		colorMap);				/* new color mapping mode */</PRE>
<P>
Set the mode used when trying to draw text in an unavailable color.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_49.htm_IX_GrSetTextMaskCustom()">
 </A>
<H1 CLASS="refHeading">
GrSetTextMaskCustom()</H1>
<PRE CLASS="syntax">void	GrSetTextMaskCustom(
        GStateHandle		gstate,				/* subject GState */
        const	DrawMask	* dm);				/* pointer to custom mask */</PRE>
<P>
Set the drawing mask used when drawing text.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_49.htm_IX_GrSetTextMaskSys()">
 </A>
<H1 CLASS="refHeading">
GrSetTextMaskSys()</H1>
<PRE CLASS="syntax">void	GrSetTextMaskSys(
        GStateHandle		gstate,				/* subject GState */
        SystemDrawMask 		sysDM);				/* new system draw mask */</PRE>
<P>
Set the drawing mask used when drawing text.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<HR>
<A NAME="R_4a.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_4a.htm_IX_GrSetTextMode()">
 </A>
<H1 CLASS="refHeading">
GrSetTextMode()</H1>
<PRE CLASS="syntax">void	GrSetTextMode(
        GStateHandle		gstate,					/* subject GState */
        TextMode 		bitsToSet,					/* TextMode flags to set */
        TextMode 		bitsToClear);					/* TextMode flags to clear */</PRE>
<P>
Set the text mode associated with a GState. Using this routine, it is possible to change the vertical offset used when drawing text.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_4a.htm_IX_GrSetTextPattern()">
 </A>
<H1 CLASS="refHeading">
GrSetTextPattern()</H1>
<PRE CLASS="syntax">void 	GrSetTextPattern(
        GStateHandle 		gstate,				/* subject GState */
        GraphicPattern 		pattern);				/* new graphic pattern for text */</PRE>
<P>
Set the graphic pattern used when drawing text.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_4a.htm_IX_GrSetTextSpacePad()">
 </A>
<H1 CLASS="refHeading">
GrSetTextSpacePad()</H1>
<PRE CLASS="syntax">void	GrSetTextSpacePad(
        GStateHandle		gstate,				/* subject GState */
        WWFixedAsDWord		padding);				/* new space padding */</PRE>
<P>
Set the space pad used when drawing text strings.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_4a.htm_IX_GrSetTextStyle()">
 </A>
<H1 CLASS="refHeading">
GrSetTextStyle()</H1>
<PRE CLASS="syntax">void	GrSetTextStyle(
        GStateHandle		gstate,				/* subject GState */
        TextStyle 		bitsToSet,				/* TextStyle flags to set */
        TextStyle		bitsToClear);				/* TextStyle flags to clear */</PRE>
<P>
Set the style to use when drawing text.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_4a.htm_IX_GrSetTrackKern()">
 </A>
<H1 CLASS="refHeading">
GrSetTrackKern()</H1>
<PRE CLASS="syntax">void	GrSetTrackKern(
        GStateHandle		gstate,				/* subject GState */
        word		tk);				/* degree of track kerning */</PRE>
<P>
Set the track kerning to use when drawing text strings.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_4a.htm_IX_GrSetTransform()">
 </A>
<H1 CLASS="refHeading">
GrSetTransform()</H1>
<PRE CLASS="syntax">void	GrSetTransform(
        GStateHandle		gstate,				/* subject GState */
        const TransMatrix 		* tm);				/* new transformation matrix */</PRE>
<P>
Set the GState's coordinate transformation.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
Update the VM file associated with a GState (this may apply when working <A NAME="R_4a.htm_IX_GrSetVMFile()">
 </A>
<H1 CLASS="refHeading">
GrSetVMFile()</H1>
<PRE CLASS="syntax">void	GrSetVMFile(
        GStateHandle		gstate,				/* subject GState */
        VMFileHandle 		vmFile);				/* new transformation matrix */</PRE>
<P>
with certain kinds of bitmaps and GStrings).</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_4a.htm_IX_GrSetWinClipPath()">
 </A>
<H1 CLASS="refHeading">
GrSetWinClipPath()</H1>
<PRE CLASS="syntax">void	GrSetWinClipPath(
        GStateHandle		gstate,				/* subject GState */
        PathCombineType		params,				/* how paths are combined */
        RegionFillRule		rule);				/* ODD_EVEN or WINDING */</PRE>
<P>
Restrict the window's clipping region by intersecting it with the passed path.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_4a.htm_IX_GrSetWinClipRect()">
 </A>
<H1 CLASS="refHeading">
GrSetWinClipRect()</H1>
<PRE CLASS="syntax">void	GrSetWinClipRect(
        GStateHandle		gstate,				/* subject GState */
        PathCombineType		flags,				/* how paths are combined */
        sword		left,				/* new clipping rectangle bounds */
        sword		top,
        sword		right,
        sword		bottom);</PRE>
<P>
Restrict the window's clipping region by intersecting it with the passed rectangle.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_4a.htm_IX_GrSqrRootWWFixed()">
 </A>
<H1 CLASS="refHeading">
GrSqrRootWWFixed()</H1>
<PRE CLASS="syntax">WWFixedAsDWord GrSqrRootWWFixed(
        WWFixedAsDWord i);			/* number to get the square root of */</PRE>
<P>
Compute the square root of a fixed point number.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_4a.htm_IX_GrTestPath()">
 </A>
<H1 CLASS="refHeading">
GrTestPath()</H1>
<PRE CLASS="syntax">Boolean	GrTestPath(
        GStateHandle		gstate,				/* subject GState */
        GetPathType		ptype);				/* Type of path to check for */</PRE>
<P>
Determine whether the GState has a path of the specified type.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<HR>
<A NAME="R_4b.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_4b.htm_IX_GrTestPointInPath()">
 </A>
<H1 CLASS="refHeading">
GrTestPointInPath()</H1>
<PRE CLASS="syntax">Boolean	GrTestPointInPath(
        GStateHandle		gstate,				/* subject GState */
        word		xPos,				/* point to test */
        word		yPos,
        RegionFillRule		rule);				/* ODD_EVEN or WINDING */</PRE>
<P>
Determine whether the passed point falls in the interior of the GState's path.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_4b.htm_IX_GrTestPointInPolygon()">
 </A>
<H1 CLASS="refHeading">
GrTestPointInPolygon()</H1>
<PRE CLASS="syntax">Boolean	GrTestPointInPolygon(
        GStateHandle		gstate,				/* subject GState */
        RegionFillRule		rule,				/* ODD_EVEN or WINDING */
        Point		* list,				/* array of points in polygon */
        word		numPoints,				/* number of points in array */
        sword		xCoord,				/* coordinates of point to test */
        sword		yCoord);</PRE>
<P>
Determine whether the passed point lies in the interior of the passed polygon.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_4b.htm_IX_GrTestPointInReg()">
 </A>
<H1 CLASS="refHeading">
GrTestPointInReg()</H1>
<PRE CLASS="syntax">Boolean 	GrTestPointInReg( 
        const	Region	* reg,				/* pointer to region */
        sword 		x,				/* coordinates of point to test */
        sword 		y,
        Rectangle		*boundingRect);					/* returned bounding rectangle,
							 * if point in region */</PRE>
<P>
Determine whether a point lies within the passed region. If the point is not in the region, the return value is <CODE>
true</CODE>
.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_4b.htm_IX_GrTestRectInMask()">
 </A>
<H1 CLASS="refHeading">
GrTestRectInMask()</H1>
<PRE CLASS="syntax">TestRectReturnType GrTestRectInMask(
        GStateHandle 		gstate, 
        sword 		left, 
        sword 		top,
        sword 		right, 
        sword 		bottom);	</PRE>
<P>
This routine determines whether the passed rectangular area falls within the clipping region.</P>
<P CLASS="refField"><STRONG>
Structures:</STRONG>	</P>
<PRE CLASS="syntax">        typedef ByteEnum TestRectReturnType;
TRRT_OUT,			/* rectangle completely out of region */
TRRT_PARTIAL,			/* rectangle partially in region */
TRRT_IN 			/* rectangle completely in region */</PRE>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_4b.htm_IX_GrTestRectInReg()">
 </A>
<A NAME="R_4b.htm_IX_TestRectReturnType">
 </A>
<A NAME="R_4b.htm_IX_TRRT_&ldots;">
 </A>
<H1 CLASS="refHeading">
GrTestRectInReg()</H1>
<PRE CLASS="syntax">TestRectReturnType GrTestRectInReg( 
        const Region		* reg			/* pointer to region */
        sword		left,			/* bounds of rectangle to be tested */
        sword		top,
        sword		right,
        sword		bottom);</PRE>
<P>
Determine whether a rectangle lies within the passed region.</P>
<P CLASS="refField"><STRONG>
Structures:</STRONG>	</P>
<PRE CLASS="syntax">        typedef ByteEnum TestRectReturnType;
TRRT_OUT,			/* rectangle completely out of region */
TRRT_PARTIAL,			/* rectangle partially in region */
TRRT_IN 			/* rectangle completely in region */</PRE>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_4b.htm_IX_GrTextWidth()">
 </A>
<H1 CLASS="refHeading">
GrTextWidth()</H1>
<PRE CLASS="syntax">word	GrTextWidth(
        GStateHandle		gstate,				/* subject GState */
        const	Chars	* str,				/* text string to check */
        word		size);				/* maximum number of
						 * characters to check */</PRE>
<P>
Compute the space the passed text string would require in a line of text. Use <CODE>
<A HREF="../../CRef/Routines/R_43.htm#IX_GrGetTextBounds()">GrGetTextBounds()</A></CODE>
 to determine the area necessary to render the text.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_4b.htm_IX_GrTextWidthWWFixed()">
 </A>
<H1 CLASS="refHeading">
GrTextWidthWWFixed()</H1>
<PRE CLASS="syntax">WWFixedAsDWord 	GrTextWidthWWFixed( /* returns width &lt;&lt; 16 */
        GStateHandle		gstate,				/* subject GState */
        const	Chars	* str,				/* text string to check */
        word		size)				/* maximum number of
						 * characters to check */</PRE>
<P>
Compute the spacing the passed text string would require in a line of text, accurate to a fraction of a point. Use <CODE>
<A HREF="../../CRef/Routines/R_43.htm#IX_GrGetTextBounds()">GrGetTextBounds()</A></CODE>
 to determine the area necessary to render the text.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_4b.htm_IX_GrTransform()">
 </A>
<H1 CLASS="refHeading">
GrTransform()</H1>
<PRE CLASS="syntax">XYValueAsDWord 	GrTransform(
        GStateHandle		gstate,				/* subject GState */
        sword 		xCoord,				/* coordinates to transform */
        sword 		yCoord);</PRE>
<P>
Apply the device's transformation to the passed point.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_4b.htm_IX_GrTransformDWFixed()">
 </A>
<H1 CLASS="refHeading">
GrTransformDWFixed()</H1>
<PRE CLASS="syntax">void	GrTransformDWFixed(
        GStateHandle		gstate,				/* subject GState */
        PointDWFixed		* coord);				/* coordinates to transform */</PRE>
<P>
Apply the device's transformation to the passed point.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_4b.htm_IX_GrTransformDWord()">
 </A>
<H1 CLASS="refHeading">
GrTransformDWord()</H1>
<PRE CLASS="syntax">void 	GrTransformDWord(
        GStateHandle		gstate,				/* subject GState */
        sdword		xCoord,				/* coordinates to transform */
        sdword		yCoord,
        PointDWord		* deviceCoordinates);
			/* pointer to returned devide coordinates */</PRE>
<P>
Apply the device's transormation to the passed point.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_4b.htm_IX_GrTransformWWFixed()">
 </A>
<H1 CLASS="refHeading">
GrTransformWWFixed()</H1>
<PRE CLASS="syntax">void	GrTransformWWFixed(
        GStateHandle		gstate,				/* subject GState */
        WWFixedAsDWord		xPos,				/* coordinates to transform */
        WWFixedAsDWord		yPos,
        PointWWFixed		* deviceCoordinates);
        			/* pointer to returned devide coordinates */</PRE>
<P>
Apply the device's transormation to the passed point.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<HR>
<A NAME="R_4c.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_4c.htm_IX_GrUDivWWFixed()">
 </A>
<H1 CLASS="refHeading">
GrUDivWWFixed()</H1>
<PRE CLASS="syntax">WWFixedAsDWord GrUDivWWFixed(
        WWFixedAsDWord		dividend,
        WWFixedAsDWord		divisor);</PRE>
<P>
Compute an unsigned division of two fixed point numbers.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_4c.htm_IX_GrUncompactBitmap()">
 </A>
<H1 CLASS="refHeading">
GrUncompactBitmap()</H1>
<PRE CLASS="syntax">VMBlockHandle GrUncompactBitmap(
        VMFileHandle 		srcFile, 
        VMBlockHandle 		srcBlock, 
        VMFileHandle 		destFile);</PRE>
<P>
This routine uncompacts the data of a huge bitmap.</P>
</DIV>
<DIV>
<A NAME="R_4c.htm_IX_GrUntransform()">
 </A>
<H1 CLASS="refHeading">
GrUntransform()</H1>
<PRE CLASS="syntax">XYValueAsDWord GrUnTransformCoord(
        GStateHandle		gstate,				/* subject GState */
        sword		xCoord,				/* coordinates to untransform */
        sword		yCoord);</PRE>
<P>
Apply the reverse of the device's transformation to the passed point.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_4c.htm_IX_GrUntransformDWFixed()">
 </A>
<H1 CLASS="refHeading">
GrUntransformDWFixed()</H1>
<PRE CLASS="syntax">void	GrUnTransCoordDWFixed(
        GStateHandle		gstate,				/* subject GState */
        PointDWFixed		* coord);				/* coordinates to untransform */</PRE>
<P>
Apply the reverse of the device's transformation to the passed point.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_4c.htm_IX_GrUntransformDWord()">
 </A>
<H1 CLASS="refHeading">
GrUntransformDWord()</H1>
<PRE CLASS="syntax">void	GrUnTransformExtCoord(
        GStateHandle		gstate,				/* subject GState */
        sdword		xCoord,				/* coordinates to untransform */
        sdword		yCoord,
        PointDWord		* documentCoordinates);
        			/* pointer to returned devide coordinates *</PRE>
<P>
Apply the reverse of the device's transformation to the passed point.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_4c.htm_IX_GrUntransformWWFixed()">
 </A>
<H1 CLASS="refHeading">
GrUntransformWWFixed()</H1>
<PRE CLASS="syntax">void	GrUnTransCoordWWFixed(
        GStateHandle		gstate,				/* subject GState */
        WWFixedAsDWord		xPos,				/* coordinates to untransform */
        WWFixedAsDWord		yPos,
        PointWWFixed		* documentCoordinates);
        			/* pointer to returned devide coordinates *</PRE>
<P>
Apply the reverse of the device's transformation to the passed point.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_4c.htm_IX_GSApplyRotation() macro">
 </A>
<H1 CLASS="refHeading">
GSApplyRotation()</H1>
<PRE CLASS="syntax">#define GSApplyRotation(angle_f) \
        GR_APPLY_ROTATION,GOC_WWF(angle_f</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro applies a passed <CODE>
WWFixed</CODE>
 value angle to the coordinate transformation.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_4c.htm_IX_GSApplyScale() macro">
 </A>
<H1 CLASS="refHeading">
GSApplyScale()</H1>
<PRE CLASS="syntax">#define GSApplyScale(x_f,y_f) \
        GR_APPLY_SCALE,GOC_WWF(x_f),GOC_WWF(y_f)</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro applies the passed scale (defined in terms of two <CODE>
WWFixed</CODE>
 numbers, one each for the <EM>
x</EM>
 and <EM>
y</EM>
 scale factors) to the coordinate transformation.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_4c.htm_IX_GSApplyTransform() macro">
 </A>
<H1 CLASS="refHeading">
GSApplyTransform()</H1>
<PRE CLASS="syntax">#define GSApplyTransform(e11_f,e12_f,e21_f,e22_f,e31_df,e32_df) \
        GR_APPLY_TRANSFORM,GOC_WWF(e11_f),GOC_WWF(e12_f), \
        GOC_WWF(e21_f),GOC_WWF(e22_f), \
        GOC_DWF(e31_df), GOC_DWF(e32_df)</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro applies the passed translation matrix to the coordinate transformation. The translation matrix is determined in terms of six of its elements, four defined by <CODE>
WWFixed</CODE>
 values and two by <CODE>
DWFixed</CODE>
 values.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_4c.htm_IX_GSApplyTranslation() macro">
 </A>
<H1 CLASS="refHeading">
GSApplyTranslation()</H1>
<PRE CLASS="syntax">#define GSApplyTranslation(x_f,y_f) \
        GR_APPLY_TRANSLATION,GOC_WWF(x_f),GOC_WWF(y_f)</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro applies the passed translation (defined in terms of two <CODE>
WWFixed</CODE>
 numbers, one each for the <EM>
x</EM>
 and <EM>
y</EM>
 translations) to the coordinate transformation.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_4c.htm_IX_GSApplyTranslationDWord() macro">
 </A>
<H1 CLASS="refHeading">
GSApplyTranslationDWord()</H1>
<PRE CLASS="syntax">#define GSApplyTranslationDWord(x_sdw,y_sdw) \
        GR_APPLY_TRANSLATION_DWORD,GOC_SDW(x_sdw), GOC_SDW(y_sdw)</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro applies a large translation (defined in terms of two dword-sized values, one each for the <EM>
x</EM>
 and <EM>
y</EM>
 translations) to the transformation.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_4c.htm_IX_GSBeginPath() macro">
 </A>
<H1 CLASS="refHeading">
GSBeginPath()</H1>
<PRE CLASS="syntax">#define GSBeginPath(flags) GR_BEGIN_PATH,(flags)</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro signals that the drawing commands that follow, up until the next <CODE>
<A HREF="../../CRef/Routines/R_4f.htm#IX_GSEndPath() macro">GSEndPath()</A></CODE>
, describe a path. It takes one argument, a <CODE>
PathCombineType</CODE>
.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_4c.htm_IX_GSBrushPolyline() macro">
 </A>
<H1 CLASS="refHeading">
GSBrushPolyline()</H1>
<PRE CLASS="syntax">#define GSBrushPolyline(width_b,height_b,pts_b) \
        GR_BRUSH_POLYLINE, GOC_WORD(pts_b), (width_b), (height_b)</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro brushes a polyline. It takes three arguments: a word containing the number of points in the polyline and the byte-size width and height of the brush rectangle. Following this macro should appear the points of the polyline, each point passed via a GOC_POINT macro.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<HR>
<A NAME="R_4d.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_4d.htm_IX_GSCloseSubPath() macro">
 </A>
<H1 CLASS="refHeading">
GSCloseSubPath()</H1>
<PRE CLASS="syntax">#define GSCloseSubPath() GR_CLOSE_SUB_PATH</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro geometrically closes the currently open path. You must still use <CODE>
<A HREF="../../CRef/Routines/R_4f.htm#IX_GSEndPath() macro">GSEndPath()</A></CODE>
 to signal that you are done defining the path.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_4d.htm_IX_GSComment() macro">
 </A>
<H1 CLASS="refHeading">
GSComment()</H1>
<PRE CLASS="syntax">#define GSComment(size_b) \
        GR_COMMENT, GOC_WORD(size_b</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro signals the start of a comment within the GString. It takes one argument, the length of the comment in bytes. Following this macro you should place the comment data.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_4d.htm_IX_GSCreatePalette() macro">
 </A>
<H1 CLASS="refHeading">
GSCreatePalette()</H1>
<PRE CLASS="syntax">#define GSCreatePalette() GR_CREATE_PALETTE</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro creates a custom palette.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_4d.htm_IX_GSDestroyPalette() macro">
 </A>
<H1 CLASS="refHeading">
GSDestroyPalette()</H1>
<PRE CLASS="syntax">#define GSDestroyPalette() GR_DESTROY_PALETTE</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro destroys the custom palette, if any.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_4d.htm_IX_GSDrawArc() macro">
 </A>
<H1 CLASS="refHeading">
GSDrawArc()</H1>
<PRE CLASS="syntax">#define GSDrawArc(close_enum,x1_w,y1_w,x2_w,y2_w,ang1_w,ang2_w) \
        GR_DRAW_ARC,GOC_WORD(close_enum), \
GOC_SW(x1_w), GOC_SW(y1_w), \
GOC_SW(x2_w), GOC_SW(y2_w), \
GOC_SW(ang1_w),GOC_SW(ang2_w)</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro draws an arc. It takes several arguments. First it takes an <CODE>
ArcCloseType</CODE>
 value. Next it takes the boundaries of the arc's base ellipse. Finally, it takes starting and ending angles for the arc.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_4d.htm_IX_GSDrawArc3Point() macro">
 </A>
<H1 CLASS="refHeading">
GSDrawArc3Point()</H1>
<PRE CLASS="syntax">#define GSDrawArc3Point(close, x1, y1, x2, y2, x3, y3) \
        GR_DRAW_ARC_3POINT,GOC_WORD(close),GOC_WWF(x1), \
GOC_WWF(y1), GOC_WWF(x2), GOC_WWF(y2), \
GOC_WWF(x3), GOC_WWF(y3)</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro draws a three-point arc. It takes several arguments: an <CODE>
ArcCloseType</CODE>
 and the coordinates of the three points defining the arc, each expressed as a <CODE>
WWFixed</CODE>
 value.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_4d.htm_IX_GSDrawArc3PointTo() macro">
 </A>
<H1 CLASS="refHeading">
GSDrawArc3PointTo()</H1>
<PRE CLASS="syntax">#define GSDrawArc3Point(close, x1, y1, x2, y2, x3, y3) \
        GR_DRAW_ARC_3POINT,GOC_WORD(close),GOC_WWF(x1), \
GOC_WWF(y1), GOC_WWF(x2), GOC_WWF(y2), \
GOC_WWF(x3), GOC_WWF(y3)</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro draws a three-point arc with the current position acting as one of the endpoints. It takes several arguments: an <CODE>
ArcCloseType</CODE>
 and the coordinates of the remaining defining points of the arc, each expressed as a <CODE>
WWFixed</CODE>
 value.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_4d.htm_IX_GSDrawBitmap() macro">
 </A>
<H1 CLASS="refHeading">
GSDrawBitmap()</H1>
<PRE CLASS="syntax">#define GSDrawBitmap(x_w,y_w,w_w) \
        GR_DRAW_BITMAP, GOC_SW(x_w), \
GOC_SW(y_w), GOC_WORD(w_w)</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro draws a bitmap. It takes three arguments: the coordinates at which to draw the bitmap and the size of the bitmap's data. This macro should be followed by the bitmap's data: a <CODE>
Bitmap</CODE>
 structure and the mask and color data for the bitmap.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_4d.htm_IX_GSDrawBitmapAtCP() macro">
 </A>
<H1 CLASS="refHeading">
GSDrawBitmapAtCP()</H1>
<PRE CLASS="syntax">#define GSDrawBitmapAtCP(bsize_w) \
        GR_DRAW_BITMAP_CP, GOC_WORD(bsize_w)</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro draws a bitmap at the current position. It takes one argument, the size of the bitmap data in bytes. This macro should be followed by the bitmap's data: a <CODE>
Bitmap</CODE>
 structure and the mask and color data for the bitmap.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_4d.htm_IX_GSDrawBitmapOptr() macro">
 </A>
<H1 CLASS="refHeading">
GSDrawBitmapOptr()</H1>
<PRE CLASS="syntax">#define GSDrawBitmapOptr(x_w,y_w,o_ptr) \
        GR_DRAW_BITMAP_OPTR,GOC_SW(x_w), \
GOC_SW(y_w),GOC_OPTR(o_ptr)</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro draws a bitmap at the passed coordinates; the data for said bitmap should be stored in a chunk referenced by the passed optr.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_4d.htm_IX_GSDrawCBitmap() macro">
 </A>
<H1 CLASS="refHeading">
GSDrawCBitmap()</H1>
<PRE CLASS="syntax">#define GSDrawCBitmap(x_w,y_w,slice1size_w,totalSize) \
        GR_DRAW_BITMAP,GOC_SW(x_w), GOC_SW(y_w), \
GOC_WORD(slice1size_w)</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro draws a complex bitmap. It takes four arguments: the <EM>
x</EM>
 and <EM>
y</EM>
 coordinates at which to draw the bitmap, the size of one slice of the bitmap's mask and color data, and the total size of the bitmap's data. This macro should be followed by the bitmap's data: a <CODE>
CBitmap</CODE>
 structure followed by the mask, color, and any other associated data.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_4d.htm_IX_GSDrawChar() macro">
 </A>
<H1 CLASS="refHeading">
GSDrawChar()</H1>
<PRE CLASS="syntax">#define GSDrawChar(c,x1_w,y1_w) \
        GR_DRAW_CHAR,(c),GOC_SW(x1_w),GOC_SW(y1_w)</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro draws a text character. It takes three arguments: the <CODE>
Chars</CODE>
 value of the character and the <EM>
x</EM>
 and <EM>
y</EM>
 coordinates at which to draw the character.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_4d.htm_IX_GSDrawCharAtCP() macro">
 </A>
<H1 CLASS="refHeading">
GSDrawCharAtCP()</H1>
<PRE CLASS="syntax">#define GSDrawCharAtCP(c) \
        GR_DRAW_CHAR_CP,(c)</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro draws a single character at the current position. It takes one argument, the <CODE>
Chars</CODE>
 value of the character to draw.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_4d.htm_IX_GSDrawCurve() macro">
 </A>
<H1 CLASS="refHeading">
GSDrawCurve()</H1>
<PRE CLASS="syntax">#define GSDrawCurve(x1_sw,y1_sw,x2_sw,y2_sw,x3_sw,y3_sw,x4_sw,y4_sw) \
        GR_DRAW_CURVE,GOC_SW(x1_sw),GOC_SW(y1_sw), \
GOC_SW(x2_sw),GOC_SW(y2_sw), \
GOC_SW(x3_sw),GOC_SW(y3_sw),GOC_SW(x4_sw),GOC_SW(y4_sw)</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro draws a Bezier curve. It takes eight arguments consisting of the coordinates for the curve's anchor and control points.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_4d.htm_IX_GSDrawCurveTo() macro">
 </A>
<H1 CLASS="refHeading">
GSDrawCurveTo()</H1>
<PRE CLASS="syntax">#define GSDrawCurveTo(x2_sw,y2_sw,x3_sw,y3_sw,x4_sw,y4_sw) \
        GR_DRAW_CURVE_TO,GOC_SW(x2_sw),GOC_SW(y2_sw), \
GOC_SW(x3_sw),GOC_SW(y3_sw), \
GOC_SW(x4_sw),GOC_SW(y4_sw)</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro draws a Bezier curve, using the current position as one endpoint. It takes six arugments, the coordinates of the remaining anchor and control points.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<HR>
<A NAME="R_4e.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_4e.htm_IX_GSDrawEllipse() macro">
 </A>
<H1 CLASS="refHeading">
GSDrawEllipse()</H1>
<PRE CLASS="syntax">#define GSDrawEllipse(x1_w,y1_w,x2_w,y2_w) \
        GR_DRAW_ELLIPSE,GOC_SW(x1_w),GOC_SW(y1_w), \
GOC_SW(x2_w),GOC_SW(y2_w)</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro draws an ellipse with bounds defined by the passed coordinates.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_4e.htm_IX_GSDrawHLine() macro">
 </A>
<H1 CLASS="refHeading">
GSDrawHLine()</H1>
<PRE CLASS="syntax">#define GSDrawHLine(x1_w,y1_w,x2_w) \
        GR_DRAW_HLINE,GOC_SW(x1_w), \
GOC_SW(y1_w),GOC_SW(x2_w)</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro draws a horizontal line. It takes three word-length arguments: the coordinates of the first endpoint and the <EM>
x</EM>
 coordinate of the second endpoint.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_4e.htm_IX_GSDrawHLineTo() macro">
 </A>
<H1 CLASS="refHeading">
GSDrawHLineTo()</H1>
<PRE CLASS="syntax">#define GSDrawHLineTo(x2_w) \
        GR_DRAW_HLINE_TO,GOC_SW(x2_w)</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro draws a horizontal line from the current position to the passed <EM>
x</EM>
 coordinate.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_4e.htm_IX_GSDrawLine() macro">
 </A>
<H1 CLASS="refHeading">
GSDrawLine()</H1>
<PRE CLASS="syntax">#define GSDrawLine(x1_w,y1_w,x2_w,y2_w) \
        GR_DRAW_LINE,GOC_SW(x1_w),GOC_SW(y1_w), \
GOC_SW(x2_w),GOC_SW(y2_w)</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro draws a line between the two passed points. The points are defined in terms of their <EM>
x</EM>
 and <EM>
y</EM>
 coordinates, passed as word values.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_4e.htm_IX_GSDrawLineTo() macro">
 </A>
<H1 CLASS="refHeading">
GSDrawLineTo()</H1>
<PRE CLASS="syntax">#define GSDrawLineTo(x2_w,y2_w) \
        GR_DRAW_LINE_TO,GOC_SW(x2_w),GOC_SW(y2_w)</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro draws a line from the current postion to the passed point. The endpoint of the line is passed via two words describing its <EM>
x</EM>
 and <EM>
y</EM>
 coordinates.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_4e.htm_IX_GSDrawPath() macro">
 </A>
<H1 CLASS="refHeading">
GSDrawPath()</H1>
<PRE CLASS="syntax">#define GSDrawPath() GR_DRAW_PATH
        &nbsp;</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro draws the current path.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_4e.htm_IX_GSDrawPoint() macro">
 </A>
<H1 CLASS="refHeading">
GSDrawPoint()</H1>
<PRE CLASS="syntax">#define GSDrawPoint(x1_w,y1_w) \
        GR_DRAW_POINT,GOC_SW(x1_w),GOC_SW(y1_w)</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro draws a dot at the passed coordinates.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_4e.htm_IX_GSDrawPointAtCP() macro">
 </A>
<H1 CLASS="refHeading">
GSDrawPointAtCP()</H1>
<PRE CLASS="syntax">#define GSDrawPointAtCP() \
                GR_DRAW_POINT_CP</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro draws a dot at the current drawing position.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_4e.htm_IX_GSDrawPolygon() macro">
 </A>
<H1 CLASS="refHeading">
GSDrawPolygon()</H1>
<PRE CLASS="syntax">#define GSDrawPolygon(count_w) \
        GR_DRAW_POLYGON,GOC_WORD(count_w)</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro draws the outline of a polygon. It takes one argument, the number of points in the polygon. Follow the macro with the points of the polygon, each passed via a GOC_POINT macro.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_4e.htm_IX_GSDrawPolyline() macro">
 </A>
<H1 CLASS="refHeading">
GSDrawPolyline()</H1>
<PRE CLASS="syntax">#define GSDrawPolyline(count_w) \
        GR_DRAW_POLYLINE,GOC_WORD(count_w)</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro draws a polyline--a spline with corners. The macro takes one argument: the number of points in the polyline. The point data should follow the macro, each point passed via a GOC_POINT macro.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_4e.htm_IX_GSDrawRect() macro">
 </A>
<H1 CLASS="refHeading">
GSDrawRect()</H1>
<PRE CLASS="syntax">#define GSDrawRect(x1_w,y1_w,x2_w,y2_w) \
        GR_DRAW_RECT,GOC_SW(x1_w),GOC_SW(y1_w), \
        GOC_SW(x2_w),GOC_SW(y2_w)</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro draws a rectangle with bounds defined by the passed coordinates, each coordinate a word-length value.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_4e.htm_IX_GSDrawRectTo() macro">
 </A>
<H1 CLASS="refHeading">
GSDrawRectTo()</H1>
<PRE CLASS="syntax">#define GSDrawRectTo(x2_w,y2_w) \
        GR_DRAW_RECT_TO,GOC_SW(x2_w),GOC_SW(y2_w)</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro draws a rectangle with one corner at the current position and the other corner at the point defined by the passed coordinates.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_4e.htm_IX_GSDrawRelArc3PointTo() macro">
 </A>
<H1 CLASS="refHeading">
GSDrawRelArc3PointTo()</H1>
<PRE CLASS="syntax">#define GSDrawRelArc3PointTo(close, x2, y2, x3, y3) \
        GR_DRAW_REL_ARC_3POINT_TO,GOC_WORD(close), \
GOC_WWF(x2), GOC_WWF(y2), GOC_WWF(x3), GOC_WWF(y3)</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro draws a three-point arc with the current position acting as one endpoint and the other points coordinates specified as offsets from the coordinates of the current position. In addition to these offsets, this macro has one more argument: an <CODE>
ArcCloseType</CODE>
.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_4e.htm_IX_GSDrawRelCurveTo() macro">
 </A>
<H1 CLASS="refHeading">
GSDrawRelCurveTo()</H1>
<PRE CLASS="syntax">#define GSDrawRelCurveTo(x2_sw,y2_sw,x3_sw,y3_sw,x4_sw,y4_sw) \
        GR_DRAW_REL_CURVE_TO,GOC_SW(x2_sw),GOC_SW(y2_sw), \
GOC_SW(x3_sw),GOC_SW(y3_sw), \
GOC_SW(x4_sw),GOC_SW(y4_sw)</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro draws a Bezier curve. It uses the current position as one endpoint of the curve; it takes six arguments: the coordinates of the other points of the curve expressed as offsets from the coordinates of the current position.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_4e.htm_IX_GSDrawRoundRect() macro">
 </A>
<H1 CLASS="refHeading">
GSDrawRoundRect()</H1>
<PRE CLASS="syntax">#define GSDrawRoundRect(x1_w,y1_w,x2_w,y2_w,r_w) \
        GR_DRAW_ROUND_RECT,GOC_WORD(r_w), \
GOC_SW(x1_w),GOC_SW(y1_w), \
GOC_SW(x2_w),GOC_SW(y2_w)</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro draws a rounded rectangle with bounds specified by its first four arguments and corner radius specified by its final argument. All arguments are word-length values except the radius, which is a word.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_4e.htm_IX_GSDrawRoundRectTo() macro">
 </A>
<H1 CLASS="refHeading">
GSDrawRoundRectTo()</H1>
<PRE CLASS="syntax">#define GSDrawRoundRectTo(x2_w,y2_w,r_w) \
        GR_DRAW_ROUND_RECT_TO,GOC_WORD(r_w), \
GOC_SW(x2_w),GOC_SW(y2_w)</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro draws a rounded rect with bounds defined by the coordinates of the current position and the coordinates of the passed point; the corner radius is specified by the macro's last argument.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<HR>
<A NAME="R_4f.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_4f.htm_IX_GSDrawSpline() macro">
 </A>
<H1 CLASS="refHeading">
GSDrawSpline()</H1>
<PRE CLASS="syntax">#define GSDrawSpline(count_w) \
        GR_DRAW_SPLINE,GOC_WORD(count_w)</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro draws a spline. It takes one argument, the number of points in the spline. Follow this macro with the list of points for the spline; each point should be defined by means of a GOC_POINT macro.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_4f.htm_IX_GSDrawSplineTo() macro">
 </A>
<H1 CLASS="refHeading">
GSDrawSplineTo()</H1>
<PRE CLASS="syntax">#define GSDrawSplineTo(count_w) \
                GR_DRAW_SPLINE_TO,GOC_WORD(count_w)</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro draws a spline using the current postion as one endpoint. It takes one argument, the number of points in the spline. Follow this macro with the list of points for the spline; each point should be defined by means of a GOC_POINT macro.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_4f.htm_IX_GSDrawText() macro">
 </A>
<H1 CLASS="refHeading">
GSDrawText()</H1>
<PRE CLASS="syntax">#define GSDrawText(x1_w,y1_w) \
        GR_DRAW_TEXT,GOC_SW(x1_w),GOC_SW(y1_w)</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro draws a string of text. Follow the macro with the string of text like so:</P>
<PRE>GSDrawText(10,10),&quot;foo&quot;, </PRE>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_4f.htm_IX_GSDrawTextAtCP() macro">
 </A>
<H1 CLASS="refHeading">
GSDrawTextAtCP()</H1>
<PRE CLASS="syntax">#define GSDrawTextAtCP() GR_DRAW_TEXT_CP</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro draws a string of text at the current position. Follow the macro with the text to draw like so:</P>
<PRE>GSDrawTextAtCP(),&quot;bar&quot;,</PRE>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_4f.htm_IX_GSDrawTextOptr() macro">
 </A>
<H1 CLASS="refHeading">
GSDrawTextOptr()</H1>
<PRE CLASS="syntax">#define GSDrawTextOptr(x_w,y_w,o_ptr) \
        GR_DRAW_TEXT_OPTR, GOC_SW(x_w), \
GOC_SW(y_w),GOC_OPTR(o_ptr)</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro draws a string of text. It takes three arguments: the <EM>
x</EM>
 and <EM>
y</EM>
 coordinates at which to start drawing the text and an optr to the chunk in which the text is stored.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_4f.htm_IX_GSDrawVLine() macro">
 </A>
<H1 CLASS="refHeading">
GSDrawVLine()</H1>
<PRE CLASS="syntax">#define GSDrawVLine(x1_w,y1_w,y2_w) \
        GR_DRAW_VLINE,GOC_SW(x1_w), \
GOC_SW(y1_w),GOC_SW(y2_w)</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro draws a vertical line. It takes three arguments: the coordinates of the first endpoint and the <EM>
y</EM>
 coordinate of the second endpoint.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_4f.htm_IX_GSDrawVLineTo() macro">
 </A>
<H1 CLASS="refHeading">
GSDrawVLineTo()</H1>
<PRE CLASS="syntax">#define GSDrawVLineTo(y2_w) \
        GR_DRAW_VLINE_TO,GOC_SW(y2_w)</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro draws a vertical line from the current position to the passed <EM>
y</EM>
 coordinate.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_4f.htm_IX_GSEndPath() macro">
 </A>
<H1 CLASS="refHeading">
GSEndPath()</H1>
<PRE CLASS="syntax">#define GSEndPath()                             GR_END_PATH</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro signals the end of path-defining commands; from here on, drawing commands will draw instead of specifying path strokes.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_4f.htm_IX_GSEndString() macro">
 </A>
<H1 CLASS="refHeading">
GSEndString()</H1>
<PRE CLASS="syntax">#define GSEndString() \
        GR_END_GSTRING</PRE>
<P>
This <CODE>
GString</CODE>
 definition macro marks the end of a graphics string.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_4f.htm_IX_GSEscape() macro">
 </A>
<H1 CLASS="refHeading">
GSEscape()</H1>
<PRE CLASS="syntax">#define GSEscape(esc_w,size_w) \
        GR_ESCAPE,GOC_WORD(esc_w),GOC_WORD(size_w)</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro inserts an escape code into the GString. The macro's first argument is a word-length escape code. The second argument is the size of any additional escape code data which follows, in bytes. Following this macro, you may place any amount of additional data to associate with the escape code.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_4f.htm_IX_GSFillArc() macro">
 </A>
<H1 CLASS="refHeading">
GSFillArc()</H1>
<PRE CLASS="syntax">#define GSFillArc(close_enum,x1_w,y1_w,x2_w,y2_w,ang1_w,ang2_w) \
        GR_FILL_ARC,GOC_WORD(close_enum), \
GOC_SW(x1_w),GOC_SW(y1_w), \
GOC_SW(x2_w),GOC_SW(y2_w),GOC_SW(ang1_w), \
GOC_SW(ang2_w)</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro draws a filled arc. It takes several arguments: an <CODE>
ArcCloseType</CODE>
 value, the bounding coordinates of the arc's base ellipse, and the arc's starting and ending angles.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_4f.htm_IX_GSFillArc3Point() macro">
 </A>
<H1 CLASS="refHeading">
GSFillArc3Point()</H1>
<PRE CLASS="syntax">#define GSFillArc3Point(close, x1, y1, x2, y2, x3, y3) \
        GR_FILL_ARC_3POINT,GOC_WORD(close),GOC_WWF(x1), GOC_WWF(y1),\
GOC_WWF(x2), GOC_WWF(y2), GOC_WWF(x3), GOC_WWF(y3)</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro fills a three-point arc. It takes several arguments: an <CODE>
ArcCloseType</CODE>
 and the coordinates of the points defining the arc.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_4f.htm_IX_GSFillArc3PointTo() macro">
 </A>
<H1 CLASS="refHeading">
GSFillArc3PointTo()</H1>
<PRE CLASS="syntax">#define GSFillArc3PointTo(close, x2, y2, x3, y3) \
        GR_FILL_ARC_3POINT_TO,GOC_WORD(close), \
GOC_WWF(x2), GOC_WWF(y2), GOC_WWF(x3), GOC_WWF(y3)</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro fills a three-point arc. The current position acts as one of the arc's endpoints, with the macro's arguments specifying the coordinates of the other points. The macro has one other argument: an <CODE>
ArcCloseType</CODE>
.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<HR>
<A NAME="R_50.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_50.htm_IX_GSFillBitmap() macro">
 </A>
<H1 CLASS="refHeading">
GSFillBitmap()</H1>
<PRE CLASS="syntax">#define GSFillBitmap(x_w,y_w,bsize_w) \
        GR_FILL_BITMAP,GOC_SW(x_w), \
GOC_SW(y_w),GOC_WORD(bsize_w)</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro draws a bitmap using the area-filling color. It will draw the bitmap at the passed coordinates; the macro's final argument is the size of the bitmap's data. Following the macro you should place the bitmap's data: first a Bitmap structure, then a number of bytes containing the mask and color values for the bitmap.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_50.htm_IX_GSFillBitmapAtCP() macro">
 </A>
<H1 CLASS="refHeading">
GSFillBitmapAtCP()</H1>
<PRE CLASS="syntax">#define GSFillBitmapAtCP(bsize_w) \
        GR_FILL_BITMAP_CP, GOC_WORD(bsize_w)</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro draws a bitmap using the area-filling color at the current position. It takes one argument, the size of the bitmap's data. Following the macro you should place the bitmap's data: first a Bitmap structure, then a number of bytes containing the mask and color values for the bitmap.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_50.htm_IX_GSFillBitmapOptr() macro">
 </A>
<H1 CLASS="refHeading">
GSFillBitmapOptr()</H1>
<PRE CLASS="syntax">#define GSFillBitmapOptr(x_w,y_w,o_ptr) \
        GR_FILL_BITMAP_OPTR,GOC_SW(x_w),GOC_SW(y_w),GOC_OPTR(o_ptr)</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro draws a bitmap using the area-filling color. It does so at the passed coordinates; the bitmap's data should be stored in the chunk referenced by the passed optr.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_50.htm_IX_GSFillEllipse() macro">
 </A>
<H1 CLASS="refHeading">
GSFillEllipse()</H1>
<PRE CLASS="syntax">#define GSFillEllipse(x1_w,y1_w,x2_w,y2_w) \
        GR_FILL_ELLIPSE,GOC_SW(x1_w),GOC_SW(y1_w), \
GOC_SW(x2_w),GOC_SW(y2_w)</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro draws a filled ellipse. It takes four arguments, the bounding coordinates of the ellipse.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_50.htm_IX_GSFillPath() macro">
 </A>
<H1 CLASS="refHeading">
GSFillPath()</H1>
<PRE CLASS="syntax">#define GSFillPath(region_fill_rule) \
        GR_FILL_PATH,(region_fill_rule)</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro fills the current path using the passed <CODE>
RegionFillRule</CODE>
 value.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_50.htm_IX_GSFillPolygon() macro">
 </A>
<H1 CLASS="refHeading">
GSFillPolygon()</H1>
<PRE CLASS="syntax">#define GSFillPolygon(count_w,fillrule_enum) \
        GR_FILL_POLYGON,GOC_WORD(count_w),(fillrule_enum)</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro draws a filled polygon. It takes two arguments, the number of points in the polygon and a <CODE>
RegionFillRule</CODE>
 value. This macro should be followed by the points of the polygon, each passed via a GOC_POINT macro.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_50.htm_IX_GSFillRect() macro">
 </A>
<H1 CLASS="refHeading">
GSFillRect()</H1>
<PRE CLASS="syntax">#define GSFillRect(x1_w,y1_w,x2_w,y2_w) \
        GR_FILL_RECT,GOC_SW(x1_w),GOC_SW(y1_w), \
GOC_SW(x2_w),GOC_SW(y2_w)</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro draws a filled rectangle. The macro takes four arguments, the bounds of the rectangle.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_50.htm_IX_GSFillRectTo() macro">
 </A>
<H1 CLASS="refHeading">
GSFillRectTo()</H1>
<PRE CLASS="syntax">#define GSFillRectTo(x2_w,y2_w) \
        GR_FILL_RECT_TO ,GOC_SW(x2_w),GOC_SW(y2_w)</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro draws a filled rectangle with the current position defining one corner and the opposite corner defined by the passed coordinates.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_50.htm_IX_GSFillRoundRect() macro">
 </A>
<H1 CLASS="refHeading">
GSFillRoundRect()</H1>
<PRE CLASS="syntax">#define GSFillRoundRect(x1_w,y1_w,x2_w,y2_w,r_w) \
        GR_FILL_ROUND_RECT,GOC_WORD(r_w),GOC_SW(x1_w), \
GOC_SW(y1_w),GOC_SW(x2_w), \
GOC_SW(y2_w)</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro draws a filled rounded rectangle. It takes five arguments; the first four give the bounding coordinates of the rectangle; the final argument is the corner radius.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_50.htm_IX_GSFillRoundRectTo() macro">
 </A>
<H1 CLASS="refHeading">
GSFillRoundRectTo()</H1>
<PRE CLASS="syntax">#define GSFillRoundRectTo(x2_w,y2_w,r_w) \
        GR_FILL_ROUND_RECT_TO,GOC_WORD(r_w),GOC_SW(x2_w), GOC_SW(y2_w)</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro draws a filled rounded rectangle. The rectangle's bounding coordinates are defined by the the current position and the two passed coordinates; its corner radius is defined by the macro's final argument.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_50.htm_IX_GSInitDefaultTransform() macro">
 </A>
<H1 CLASS="refHeading">
GSInitDefaultTransform()</H1>
<PRE CLASS="syntax">#define GSInitDefaultTransform() \
        GR_INIT_DEFAULT_TRANSFORM</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro initializes the GState's default transformation to hold the value of the current coordinate transformation.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_50.htm_IX_GSLabel() macro">
 </A>
<H1 CLASS="refHeading">
GSLabel()</H1>
<PRE CLASS="syntax">#define GSLabel(w) \
        GR_LABEL, GOC_WORD(w)</PRE>
<P>
This <CODE>
GString</CODE>
 definition macro creates a label in the GString. This macro takes one argument, a word which acts as the label's token. By passing GSC_LABEL to <CODE>
<A HREF="../../CRef/Routines/R_3a.htm#IX_GrDrawGString()">GrDrawGString()</A></CODE>
 or another GString-traversing command, you may use this label as something analogous to the label used by a goto command.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<HR>
<A NAME="R_51.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_51.htm_IX_GSMoveTo() macro">
 </A>
<H1 CLASS="refHeading">
GSMoveTo()</H1>
<PRE CLASS="syntax">#define GSMoveTo(x1_w,y1_w) \
        GR_MOVE_TO, GOC_SW(x1_w), GOC_SW(y1_w)</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro updates the current position to the passed coordinates.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_51.htm_IX_GSNewPage() macro">
 </A>
<H1 CLASS="refHeading">
GSNewPage()</H1>
<PRE CLASS="syntax">#define GSNewPage(pageEndCommand) \
        GR_NEW_PAGE,(pageEndCommand)</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro signals the end of a page. The <EM>
pageEndCommand</EM>
 argument should be a <CODE>
PageEndCommand</CODE>
 value.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_51.htm_IX_GSNullOp() macro">
 </A>
<H1 CLASS="refHeading">
GSNullOp()</H1>
<PRE CLASS="syntax">#define GSNullOp() 
        GR_NULL_OP</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro inserts a null-operation element into the GString.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_51.htm_IX_GSRelMoveTo() macro">
 </A>
<H1 CLASS="refHeading">
GSRelMoveTo()</H1>
<PRE CLASS="syntax">#define GSRelMoveTo(x1_wwf,y1_wwf) \
        GR_REL_MOVE_TO, GOC_WWF(x1_wwf),GOC_WWF(y1_wwf)</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro updates the current position to a set of coordinates specified as offsets from those of the old current position.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_51.htm_IX_GSRestoreState() macro">
 </A>
<H1 CLASS="refHeading">
GSRestoreState()</H1>
<PRE CLASS="syntax">#define GSRestoreState() \
        GR_RESTORE_STATE</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro causes a GState saved by <CODE>
<A HREF="../../CRef/Routines/R_51.htm#IX_GSSaveState() macro">GSSaveState()</A></CODE>
 to be restored.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_51.htm_IX_GSRestoreTransform() macro">
 </A>
<H1 CLASS="refHeading">
GSRestoreTransform()</H1>
<PRE CLASS="syntax">#define GSRestoreTransform() \
        GR_RESTORE_TRANSFORM</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro restores a transformation matrix previously saved via <CODE>
<A HREF="../../CRef/Routines/R_51.htm#IX_GSSaveTransform() macro">GSSaveTransform()</A></CODE>
.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_51.htm_IX_GSSaveState() macro">
 </A>
<H1 CLASS="refHeading">
GSSaveState()</H1>
<PRE CLASS="syntax">#define GSSaveState()\
        GR_SAVE_STATE</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro causes the GState to be saved so that it may be restored by a subsequent <CODE>
<A HREF="../../CRef/Routines/R_51.htm#IX_GSRestoreState() macro">GSRestoreState()</A></CODE>
.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_51.htm_IX_GSSaveTransform() macro">
 </A>
<H1 CLASS="refHeading">
GSSaveTransform()</H1>
<PRE CLASS="syntax">#define GSSaveTransform() \
        GR_SAVE_TRANSFORM</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro saves the current tranformation matrix which may be retrieved by means of a <CODE>
<A HREF="../../CRef/Routines/R_51.htm#IX_GSRestoreTransform() macro">GSRestoreTransform()</A></CODE>
.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_51.htm_IX_GSSetAreaAttr() macro">
 </A>
<H1 CLASS="refHeading">
GSSetAreaAttr()</H1>
<PRE CLASS="syntax">#define GSSetAreaAttr(r,g,b,mode,mask) \
                GR_SET_AREA_ATTR,(CF_RGB),(r),(g),(b),(mask),(mode)</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro sets the <CODE>
AreaAttr</CODE>
 value to use when filling areas. It takes several arguments: the red, green, and blue components of the color; the <CODE>
ColorMapMode</CODE>
 to use when trying to draw in an unavailable color, and the mask to use.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_51.htm_IX_GSSetAreaColor() macro">
 </A>
<H1 CLASS="refHeading">
GSSetAreaColor()</H1>
<PRE CLASS="syntax">#define GSSetAreaColor(r,g,b) GR_SET_AREA_COLOR,(r),(g),(b)</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro specifies a new area-filling color in terms of its red, green, and blue components.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_51.htm_IX_GSSetAreaColorIndex() macro">
 </A>
<H1 CLASS="refHeading">
GSSetAreaColorIndex()</H1>
<PRE CLASS="syntax">#define GSSetAreaColorIndex(index) GR_SET_AREA_COLOR_INDEX,(index)</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro specifies the new area-filling color by means of its index in the palette.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_51.htm_IX_GSSetAreaColorMap() macro">
 </A>
<H1 CLASS="refHeading">
GSSetAreaColorMap()</H1>
<PRE CLASS="syntax">#define GSSetAreaColorMap(mode) GR_SET_AREA_COLOR_MAP,(mode)</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro sets the <CODE>
ColorMapMode</CODE>
 to use when trying to fill an area using an unavailable color.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_51.htm_IX_GSSetAreaMask() macro">
 </A>
<H1 CLASS="refHeading">
GSSetAreaMask()</H1>
<PRE CLASS="syntax">#define GSSetAreaMask(index) GR_SET_AREA_MASK, (index)</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro sets the mask to use when filling areas.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_51.htm_IX_GSSetAreaPattern() macro">
 </A>
<H1 CLASS="refHeading">
GSSetAreaPattern()</H1>
<PRE CLASS="syntax">#define GSSetAreaPattern(pattern) \
        GR_SET_AREA_PATTERN,GOC_PATTERN(pattern)</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro sets the <CODE>
GraphicPattern</CODE>
 to use when filling areas.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_51.htm_IX_GSSetClipPath() macro">
 </A>
<H1 CLASS="refHeading">
GSSetClipPath()</H1>
<PRE CLASS="syntax">#define GSSetClipPath(flags) GR_SET_CLIP_PATH,(flags)</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro combines the current path with the clipping path using the passed <CODE>
PathCombineType</CODE>
.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_51.htm_IX_GSSetClipRect() macro">
 </A>
<H1 CLASS="refHeading">
GSSetClipRect()</H1>
<PRE CLASS="syntax">#define GSSetClipRect(path,rl_sw,rt_sw,rr_sw,rb_sw) \
        GR_SET_CLIP_RECT,GOC_SW(rl_sw), \
GOC_SW(rt_sw),GOC_SW(rr_sw),GOC_SW(rb_sw)</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro sets a clipping rectangle. It takes five arguments: a <CODE>
PathCombineType</CODE>
 and the bounding coordinates of the rectangle.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_51.htm_IX_GSSetCustomAreaMask() macro">
 </A>
<H1 CLASS="refHeading">
GSSetCustomAreaMask()</H1>
<PRE CLASS="syntax">#define GSSetCustomAreaMask(m1,m2,m3,m4,m5,m6,m7,m8) \
        GR_SET_CUSTOM_AREA_MASK, (m1), (m2), (m3), (m4), (m5), (m6), (m7),
(m8)</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro specifies a custom bitmask to use when filling areas. It takes eight arguments, each a byte representing the pixels of one row.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_51.htm_IX_GSSetCustomAreaPattern() macro">
 </A>
<H1 CLASS="refHeading">
GSSetCustomAreaPattern()</H1>
<PRE CLASS="syntax">#define GSSetCustomAreaPattern(pattern,size) \
        GR_SET_CUSTOM_AREA_PATTERN, GOC_PATTERN(pattern),GOC_WORD(size)</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro sets up a custom pattern to use when filling areas. It takes two arguments: a <CODE>
GraphicPattern</CODE>
 value and the size of the pattern's data. Following this macro should appear the pattern's data.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<HR>
<A NAME="R_52.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_52.htm_IX_GSSetCustomLineMask() macro">
 </A>
<H1 CLASS="refHeading">
GSSetCustomLineMask()</H1>
<PRE CLASS="syntax">#define GSSetCustomLineMask(m1,m2,m3,m4,m5,m6,m7,m8) \
        GR_SET_CUSTOM_LINE_MASK, (m1), (m2), (m3), (m4), (m5), (m6), (m7), \
(m8)</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro specifies a new bitmap to use as the mask when drawing lines. It takes eight arguments, each a byte representing the pixels one one row.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_52.htm_IX_GSSetCustomLineStyle() macro">
 </A>
<H1 CLASS="refHeading">
GSSetCustomLineStyle()</H1>
<PRE CLASS="syntax">#define GSSetCustomLineStyle(index,count) \
        GR_SET_CUSTOM_LINE_STYLE,(index),(count)</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro sets a custom style, or &quot;dottedness,&quot; to use when drawing lines. It takes two arguments: the first is the index into the pattern to use, the second is the number of dash pairs in the line style. Following this macro should appear a <CODE>
DashPairArray</CODE>
 containing the line style's data.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_52.htm_IX_GSSetCustomTextMask() macro">
 </A>
<H1 CLASS="refHeading">
GSSetCustomTextMask()</H1>
<PRE CLASS="syntax">#define GSSetCustomTextMask(m1,m2,m3,m4,m5,m6,m7,m8) \
        GR_SET_CUSTOM_TEXT_MASK, (m1), (m2), (m3), (m4), (m5), (m6), (m7),
(m8)</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro specifies a custom bitmask to use when rendering text. It takes eight arguments, each a byte representing one row of pixel data.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_52.htm_IX_GSSetCustomTextPattern() macro">
 </A>
<H1 CLASS="refHeading">
GSSetCustomTextPattern()</H1>
<PRE CLASS="syntax">#define GSSetCustomTextPattern(pattern,size) \
        GR_SET_CUSTOM_TEXT_PATTERN,GOC_PATTERN(pattern), GOC_WORD(size)</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro sets a custom pattern to use when rendering text. It takes two arguments: a <CODE>
GraphicPattern</CODE>
 value and the size of the pattern's data. Following this macro should appear the pattern's data.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_52.htm_IX_GSSetDefaultTransformation() macro">
 </A>
<H1 CLASS="refHeading">
GSSetDefaultTransformation()</H1>
<PRE CLASS="syntax">#define GSSetDefaultTransform() \
        GR_SET_DEFAULT_TRANSFORM</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro replaces the current coordinate transformation with the default coordinate transformation.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_52.htm_IX_GSSetFont() macro">
 </A>
<H1 CLASS="refHeading">
GSSetFont()</H1>
<PRE CLASS="syntax">#define GSSetFont(id,size_wbf) \
                GR_SET_FONT,GOC_WBF(size_wbf),GOC_WORD(id)</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro sets the font to use when rendering text. It takes two arguments: a <CODE>
FontID</CODE>
 and a pointsize, expressed as a <CODE>
WBFixed</CODE>
 number.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_52.htm_IX_GSSetFontWeight() macro">
 </A>
<H1 CLASS="refHeading">
GSSetFontWeight()</H1>
<PRE CLASS="syntax">#define GSSetFontWeight(weight) GR_SET_FONT_WEIGHT,GOC_WORD(weight)</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro sets the <CODE>
FontWeight</CODE>
 to use when rendering text.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_52.htm_IX_GSSetFontWidth() macro">
 </A>
<H1 CLASS="refHeading">
GSSetFontWidth()</H1>
<PRE CLASS="syntax">#define GSSetFontWidth(width) GR_SET_FONT_WIDTH,GOC_WORD(width) </PRE>
<P>
This <CODE>
GString</CODE>
 creation macro sets the <CODE>
FontWidth</CODE>
 to use when rendering text.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_52.htm_IX_GSSetGStringBounds() macro">
 </A>
<H1 CLASS="refHeading">
GSSetGStringBounds()</H1>
<PRE CLASS="syntax">#define GSSetGStringBounds(x1_w,y1_w,x2_w,y2_w) \
        GR_SET_GSTRING_BOUNDS,GOC_SW(x1_w),GOC_SW(y1_w), \
GOC_SW(x2_w),GOC_SW(y2_w)</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro is useful for optimizations. When drawing your <CODE>
GString</CODE>
, the graphics system will take time to traverse your <CODE>
GString</CODE>
 and determine its drawing bounds. If you compute those bounds ahead of time, you may pass them as arguments to this macro--if the graphics system encounters this <CODE>
GString</CODE>
 element, it won't bother to traverse the rest of the <CODE>
GString</CODE>
, but will use the pre-computed values. Thus, if you use this <CODE>
GString</CODE>
 element, you should place it at the beginning of your <CODE>
GString</CODE>
. The macro takes four word-length arguments, the coordinates of the bounds of the <CODE>
GString</CODE>
.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_52.htm_IX_GSSetLineAttr() macro">
 </A>
<H1 CLASS="refHeading">
GSSetLineAttr()</H1>
<PRE CLASS="syntax">#define GSSetLineAttr(r,g,b,mode,mask,width,end,join,style) \
        GR_SET_LINE_ATTR,(CF_RGB),(r),(g),(b),(mask),(mode),(end),(join), \
(style) ,GOC_WWF(width)</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro sets the <CODE>
LineAttr </CODE>
to use when drawing lines. It takes several arguments: the red, green, and blue components of the color to use; the ColorMapMode to use when trying to draw in an unavailable color, the drawing mask to use, the width, the <CODE>
LineEnd</CODE>
, the <CODE>
LineJoin</CODE>
, and the <CODE>
LineStyle</CODE>
.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_52.htm_IX_GSSetLineColor() macro">
 </A>
<H1 CLASS="refHeading">
GSSetLineColor()</H1>
<PRE CLASS="syntax">#define GSSetLineColor(r,g,b) GR_SET_LINE_COLOR,(r),(g),(b)</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro sets the line-drawing color in terms of its red, green, and blue components.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_52.htm_IX_GSSetLineColorIndex() macro">
 </A>
<H1 CLASS="refHeading">
GSSetLineColorIndex()</H1>
<PRE CLASS="syntax">#define GSSetLineColorIndex(color) GR_SET_LINE_COLOR_INDEX, (color)</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro sets the line-drawing color by specifying which entry in the palette to use.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_52.htm_IX_GSSetLineColorMap() macro">
 </A>
<H1 CLASS="refHeading">
GSSetLineColorMap()</H1>
<PRE CLASS="syntax">#define GSSetLineColorMap(mode) GR_SET_LINE_COLOR_MAP,(mode)</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro sets the <CODE>
ColorMapMode</CODE>
 to use when trying to draw lines with an unavailable color.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<HR>
<A NAME="R_53.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_53.htm_IX_GSSetLineEnd() macro">
 </A>
<H1 CLASS="refHeading">
GSSetLineEnd()</H1>
<PRE CLASS="syntax">#define GSSetLineEnd(end) \
        GR_SET_LINE_END,(end)</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro sets the <CODE>
LineEnd</CODE>
 value to use when drawing endpoints of lines.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_53.htm_IX_GSSetLineJoin() macro">
 </A>
<H1 CLASS="refHeading">
GSSetLineJoin()</H1>
<PRE CLASS="syntax">#define GSSetLineJoin(join) \
                GR_SET_LINE_JOIN,(join)</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro sets the <CODE>
LineJoin</CODE>
 value to use when drawing corners in polylines, polygons, and rectangles.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_53.htm_IX_GSSetLineMask() macro">
 </A>
<H1 CLASS="refHeading">
GSSetLineMask()</H1>
<PRE CLASS="syntax">#define GSSetLineMask(index) GR_SET_LINE_MASK, (index)</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro sets the mask to use when drawing lines. </P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_53.htm_IX_GSSetLineStyle() macro">
 </A>
<H1 CLASS="refHeading">
GSSetLineStyle()</H1>
<PRE CLASS="syntax">#define GSSetLineStyle(style,index) \
                GR_SET_LINE_STYLE,(style),(index)</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro sets the style, or &quot;dottedness,&quot; to use when drawing lines.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_53.htm_IX_GSSetLineWidth() macro">
 </A>
<H1 CLASS="refHeading">
GSSetLineWidth()</H1>
<PRE CLASS="syntax">#define GSSetLineWidth(width_wwf) \
                GR_SET_LINE_WIDTH, GOC_WWF(width_wwf)</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro sets the width to use when drawing lines. It takes a single argument, the width expressed as a <CODE>
WWFixed</CODE>
 number.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_53.htm_IX_GSSetMiterLimit() macro">
 </A>
<H1 CLASS="refHeading">
GSSetMiterLimit()</H1>
<PRE CLASS="syntax">#define GSSetMiterLimit(limit_wwf) \
        GR_SET_MITER_LIMIT, GOC_WWF(limit_wwf)</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro sets the miter limit to use when drawing mitered corners of rectangles, polylines, and polygons. This miter limit is expressed as a <CODE>
WWFixed</CODE>
 value.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_53.htm_IX_GSSetMixMode() macro">
 </A>
<H1 CLASS="refHeading">
GSSetMixMode()</H1>
<PRE CLASS="syntax">#define GSSetMixMode(mode) GR_SET_MIX_MODE, (mode)</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro sets the mix mode to use when drawing on top of existing drawings.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_53.htm_IX_GSSetNullPath() macro">
 </A>
<H1 CLASS="refHeading">
GSSetNullPath()</H1>
<PRE CLASS="syntax">#define GSSetNullPath() GR_SET_NULL_PATH</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro clears the current path.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_53.htm_IX_GSSetNullTransform() macro">
 </A>
<H1 CLASS="refHeading">
GSSetNullTransform()</H1>
<PRE CLASS="syntax">#define GSSetNullTransform() \
        GR_SET_NULL_TRANSFORM</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro nullifies the coordinate transformation.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_53.htm_IX_GSSetPalette() macro">
 </A>
<H1 CLASS="refHeading">
GSSetPalette()</H1>
<PRE CLASS="syntax">#define GSSetPalette(entry_count) GR_SET_PALETTE,(entry),(count)</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro allows you to change several palette colors at once. It takes two arguments: the index of the first color entry to change, and the number of entries to change. Follow this macro with trios of bytes, each triplet specifying the red, green, and blue components of the colors.</P>
</DIV>
<DIV>
<A NAME="R_53.htm_IX_GSSetPaletteEntry() macro">
 </A>
<H1 CLASS="refHeading">
GSSetPaletteEntry()</H1>
<PRE CLASS="syntax">#define GSSetPaletteEntry(entry,r,g,b) \
        GR_SET_PALETTE_ENTRY GOC_WORD(entry),(r), (g),(b)</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro changes a single entry in a custom palette. It takes four arguments: the index number of the entry and the red, green, and blue components of the new color for this entry.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_53.htm_IX_GSSetStrokePath() macro">
 </A>
<H1 CLASS="refHeading">
GSSetStrokePath()</H1>
<PRE CLASS="syntax">#define GSSetStrokePath() GR_SET_STROKE_PATH</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro replaces the current path with the path which results from stroking the current path with the current line attributes. This new path may be drawn, but may not be used for clipping.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<HR>
<A NAME="R_54.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_54.htm_IX_GSSetSubscriptAttr() macro">
 </A>
<H1 CLASS="refHeading">
GSSetSubscriptAttr()</H1>
<PRE CLASS="syntax">#define GSSetSubscriptAttr(pos,size) \
        GR_SET_SUBSCRIPT_ATTR,(pos),(size)</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro sets the vertical offset and size to use when rendering subscript text.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_54.htm_IX_GSSetSuperScriptAttr() macro">
 </A>
<H1 CLASS="refHeading">
GSSetSuperscriptAttr()</H1>
<PRE CLASS="syntax">#define GSSetSuperscriptAttr(pos,size) \
        GR_SET_SUPERSCRIPT_ATTR,(pos),(size)</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro sets the vertical offset and size to use when rendering superscript text.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_54.htm_IX_GSSetTextAttr() macro">
 </A>
<H1 CLASS="refHeading">
GSSetTextAttr()</H1>
<PRE CLASS="syntax">#define GSSetTextAttr(cflag,r,g,b,mask,sSet,sReset,mSet,mReset,
sPad,id,pSize,trk Krn,fWeight,fWidth) \</PRE>
<PRE CLASS="syntax">        GR_SET_TEXT_ATTR,(cflag),(r),(g),(b),(mask),(sSet), \
(sReset),(mSet),(mReset),GOC_WWF(sPad), \
GOC_WORD(id), GOC_WWF(pSize),GOC_SW(trkKrn),(fWeight),(fWidth)</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro sets the <CODE>
TextAttr</CODE>
 structure to use when rendering text. It takes several arguments: the four components of a <CODE>
ColorQuad</CODE>
, a drawing mask, <CODE>
TextStyle</CODE>
 flags to set and clear, <CODE>
TextMode</CODE>
 flags to set and clear, a spacing pad, a <CODE>
FontID</CODE>
, a pointsize expressed as a <CODE>
WWFixed</CODE>
 number, a track kerning value, a <CODE>
FontWeight</CODE>
, and a <CODE>
FontWidth</CODE>
.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_54.htm_IX_GSSetTextColor() macro">
 </A>
<H1 CLASS="refHeading">
GSSetTextColor()</H1>
<PRE CLASS="syntax">#define GSSetTextColor(r,g,b) GR_SET_TEXT_COLOR,(r),(g),(b)</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro sets the text-rendering color by means of red, green, and blue component values.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_54.htm_IX_GSSetTextColorIndex() macro">
 </A>
<H1 CLASS="refHeading">
GSSetTextColorIndex()</H1>
<PRE CLASS="syntax">#define GSSetTextColorIndex(index) GR_SET_TEXT_COLOR_INDEX,(index)</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro specifies the text-rendering color as an index of the palette.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_54.htm_IX_GSSetTextColorMap() macro">
 </A>
<H1 CLASS="refHeading">
GSSetTextColorMap()</H1>
<PRE CLASS="syntax">#define GSSetTextColorMap(mode) GR_SET_TEXT_COLOR_MAP,(mode)</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro sets the <CODE>
ColorMapMode</CODE>
 to use when trying to render text in an unavailable color.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_54.htm_IX_GSSetTextMask() macro">
 </A>
<H1 CLASS="refHeading">
GSSetTextMask()</H1>
<PRE CLASS="syntax">#define GSSetTextMask(index) GR_SET_TEXT_MASK, (index)</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro specifies the mask to use when rendering text.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_54.htm_IX_GSSetTextMode() macro">
 </A>
<H1 CLASS="refHeading">
GSSetTextMode()</H1>
<PRE CLASS="syntax">#define GSSetTextMode(set,reset) \
                GR_SET_TEXT_MODE,(set),(reset) </PRE>
<P>
This <CODE>
GString</CODE>
 creation macro sets and clears <CODE>
TextMode</CODE>
 flags. It takes two arguments: the flags to set and the flags to clear.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_54.htm_IX_GSSetTextPattern() macro">
 </A>
<H1 CLASS="refHeading">
GSSetTextPattern()</H1>
<PRE CLASS="syntax">#define GSSetTextPattern(pattern) \
        GR_SET_TEXT_PATTERN,GOC_PATTERN(pattern)</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro sets the <CODE>
GraphicPattern</CODE>
 to use when rendering text.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_54.htm_IX_GSSetTextSpacePad() macro">
 </A>
<H1 CLASS="refHeading">
GSSetTextSpacePad()</H1>
<PRE CLASS="syntax">#define GSSetTextSpacePad(pad_wbf) \
                GR_SET_TEXT_SPACE_PAD, GOC_WBF(pad_wbf)</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro specifies the space pad to use when rendering text. It takes one argument: the space padding value, expressed as a <CODE>
WBFixed</CODE>
 number.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_54.htm_IX_GSSetTextStyle() macro">
 </A>
<H1 CLASS="refHeading">
GSSetTextStyle()</H1>
<PRE CLASS="syntax">#define GSSetTextStyle(set,reset) \
                GR_SET_TEXT_STYLE,(set),(reset)</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro changes the <CODE>
TextStyle</CODE>
 flags to use when drawing text. It takes two arguments, the flags to set and the flags to clear.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_54.htm_IX_GSSetTrackKern() macro">
 </A>
<H1 CLASS="refHeading">
GSSetTrackKern()</H1>
<PRE CLASS="syntax">#define GSSetTrackKern(degree) GR_SET_TRACK_KERN, GOC_SW(degree)</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro sets the track kerning value to use when rendering text strings.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_54.htm_IX_GSSetTransform() macro">
 </A>
<H1 CLASS="refHeading">
GSSetTransform()</H1>
<PRE CLASS="syntax">#define GSSetTransform(e11_f,e12_f,e21_f,e22_f,e31_df,e32_df) \
        GR_SET_TRANSFORM,GOC_WWF(e11_f), \
GOC_WWF(e12_f),GOC_WWF(e21_f), \
GOC_WWF(e22_f),GOC_DWF(e31_df),GOC_DWF(e32_df)</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro sets the coordinate transformation. The new transformation is defined in terms of the elements of a transformation matrix, four <CODE>
WWFixed</CODE>
 values and two <CODE>
DWFixed</CODE>
 values.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_54.htm_IX_GSSetWinClipPath() macro">
 </A>
<H1 CLASS="refHeading">
GSSetWinClipPath()</H1>
<PRE CLASS="syntax">#define GSSetWinClipPath(flags) GR_SET_WIN_CLIP_PATH,(flags)</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro combines the current path with the window clipping path, using the passed <CODE>
PathCombineType</CODE>
.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_54.htm_IX_GSSetWinClipRect() macro">
 </A>
<H1 CLASS="refHeading">
GSSetWinClipRect()</H1>
<PRE CLASS="syntax">#define GSSetWinClipRect(path,rl_sw,rt_sw,rr_sw,rb_sw) \
        GR_SET_WIN_CLIP_RECT,GOC_SW(rl_sw), \
GOC_SW(rt_sw),GOC_SW(rr_sw),GOC_SW(rb_sw)</PRE>
<P>
This <CODE>
GString</CODE>
 creation macro combines a rectangle with the existing window clipping path. It takes five arguments: a <CODE>
PathCombineType</CODE>
 and the bounding coordinates of the rectangle.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
<P>
&nbsp;</P>
</DIV>
<HR>
<A NAME="R_55.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_55.htm_IX_HAL_COUNT() macro">
 </A>
<H1 CLASS="refHeading">
HAL_COUNT()</H1>
<PRE CLASS="syntax">word	HAL_COUNT(
        dword	val);</PRE>
<P>
This macro is provided for use with <CODE>
<A HREF="../../CRef/Routines/R_57.htm#IX_HugeArrayLock()">HugeArrayLock()</A></CODE>
. It extracts the lower word of the <CODE>
<A HREF="../../CRef/Routines/R_57.htm#IX_HugeArrayLock()">HugeArrayLock()</A></CODE>
 return value. This is the number of elements in the Huge Array block after the locked one (counting that locked one).</P>
</DIV>
<DIV>
<A NAME="R_55.htm_IX_HAL_PREV() macro">
 </A>
<H1 CLASS="refHeading">
HAL_PREV</H1>
<PRE CLASS="syntax">word	HAL_PREV(
        dword	val);</PRE>
<P>
This macro is provided for use with <CODE>
<A HREF="../../CRef/Routines/R_57.htm#IX_HugeArrayLock()">HugeArrayLock()</A></CODE>
. It extracts the upper word of the <CODE>
<A HREF="../../CRef/Routines/R_57.htm#IX_HugeArrayLock()">HugeArrayLock()</A></CODE>
 return value. This is the number of elements in the Huge Array block before the locked one (counting that locked one).</P>
</DIV>
<DIV>
<A NAME="R_55.htm_IX_HandleModifyOwner()">
 </A>
<H1 CLASS="refHeading">
HandleModifyOwner()</H1>
<PRE CLASS="syntax">void	HandleModifyOwner(
        MemHandle		mh,			/* Handle of block to modify */
        GeodeHandle		owner);			/* Handle of block's new owner */</PRE>
<P>
This routine changes the owner of the indicated global memory block. Note that this routine can be called only by a thread belonging to the block's original owner; that is, you can only use this routine to transfer ownership of a block <EM>
from</EM>
 yourself <EM>
to</EM>
 some other geode.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
heap.h</STRONG>
 </P>
<P CLASS="refField"><STRONG>
Never Use Situations:</STRONG>	<BR>
Never use this unless the block already belongs to you and you are giving up ownership.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_6c.htm#IX_MemGetInfo()">MemGetInfo()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_6e.htm#IX_MemModifyFlags()">MemModifyFlags()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_6e.htm#IX_MemModifyOtherInfo()">MemModifyOtherInfo()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_55.htm_IX_HandleP()">
 </A>
<A NAME="R_55.htm_IX_Semaphores:HandleP()">
 </A>
<H1 CLASS="refHeading">
HandleP()</H1>
<PRE CLASS="syntax">void	HandleP(
        MemHandle		mh);		/* Handle of block to grab */</PRE>
<P>
If several different threads will be accessing the same global memory block, they need to make sure their activities will not conflict. The way they do that is to use synchronization routines to get control of a block. <CODE>
HandleP()</CODE>
 is part of one set of synchronization routines.</P>
<P>
If the threads are using this family of routines, then whenever a thread needs access to the block in question, it can call <CODE>
HandleP()</CODE>
. This routine checks whether any thread has grabbed the block with <CODE>
HandleP()</CODE>
 (or <CODE>
<A HREF="../../CRef/Routines/R_6e.htm#IX_MemPLock()">MemPLock()</A></CODE>
). If no thread has the block, it grabs the block for the calling thread and returns (it does not lock the block on the global heap). If a thread has the block, <CODE>
HandleP()</CODE>
 puts the thread on a priority queue and sleeps. When the block is free for it to take, it awakens, grabs the block, and returns.When the thread is done with the block, it should release it with <CODE>
<A HREF="../../CRef/Routines/R_70.htm#IX_MemUnlockV()">MemUnlockV()</A></CODE>
 or <CODE>
<A HREF="../../CRef/Routines/R_56.htm#IX_HandleV()">HandleV()</A></CODE>
.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
heap.h</STRONG>
 </P>
<P CLASS="refField"><STRONG>
Tips and Tricks:</STRONG>	If you will be locking the block after you grab it, use the routine <CODE>
<A HREF="../../CRef/Routines/R_6e.htm#IX_MemPLock()">MemPLock()</A></CODE>
 (which calls <CODE>
HandleP()</CODE>
 and then locks the block with <CODE>
<A HREF="../../CRef/Routines/R_6d.htm#IX_MemLock()">MemLock()</A></CODE>
). You can find out if the block is being accessed by looking at the <CODE>
HM_otherInfo</CODE>
 word (with <CODE>
<A HREF="../../CRef/Routines/R_6c.htm#IX_MemGetInfo()">MemGetInfo()</A></CODE>
). If <CODE>
HM_otherInfo</CODE>
 equals one, the block is not grabbed; if it equals zero, it is grabbed, but no threads are queued; otherwise, it equals the handle of the first thread queued.</P>
<P CLASS="refField"><STRONG>
Be Sure To:</STRONG>	Make sure that all threads accessing the block use <CODE>
HandleP()</CODE>
 and/or <CODE>
<A HREF="../../CRef/Routines/R_6e.htm#IX_MemPLock()">MemPLock()</A></CODE>
 to access the block. The routines use the <CODE>
HM_otherInfo</CODE>
 field of the handle table entry; do not alter this field. Release the block with <CODE>
<A HREF="../../CRef/Routines/R_56.htm#IX_HandleV()">HandleV()</A></CODE>
 or <CODE>
<A HREF="../../CRef/Routines/R_70.htm#IX_MemUnlockV()">MemUnlockV()</A></CODE>
 when you are done with it.</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	If a thread calls <CODE>
HandleP()</CODE>
 when it already has control of the block, it will deadlock; <CODE>
HandleP()</CODE>
 will put the thread to sleep until the thread releases the block, but the thread will not be able to release the block because it's sleeping. <CODE>
<A HREF="../../CRef/Routines/R_6f.htm#IX_MemThreadGrab()">MemThreadGrab()</A></CODE>
 avoids this conflict. If you try to grab a non-sharable block owned by another thread, <CODE>
HandleP()</CODE>
 will fatal-error.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_6f.htm#IX_MemThreadGrab()">MemThreadGrab()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_6f.htm#IX_MemThreadGrabNB()">MemThreadGrabNB()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_6f.htm#IX_MemThreadRelease()">MemThreadRelease()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_56.htm#IX_HandleV()">HandleV()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_55.htm#IX_HandleP()">HandleP()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_6e.htm#IX_MemPLock()">MemPLock()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_70.htm#IX_MemUnlockV()">MemUnlockV()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_55.htm_IX_HandleToOptr() macro">
 </A>
<A NAME="R_55.htm_IX_optr:HandleToOptr() macro">
 </A>
<H1 CLASS="refHeading">
HandleToOptr()</H1>
<PRE CLASS="syntax">optr	HandleToOptr(
        Handle 	han;</PRE>
<P>
This macro casts any handle to an optr, leaving the chunk handle portion of the resultant optr to be zero.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_d.htm#IX_ConstructOptr() macro">ConstructOptr()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_7f.htm#IX_OptrToHandle()">OptrToHandle()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_7f.htm#IX_OptrToChunk()">OptrToChunk()</A></CODE>.</P>
</DIV>
<HR>
<A NAME="R_56.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_56.htm_IX_HandleV()">
 </A>
<A NAME="R_56.htm_IX_Semaphores:HandleV()">
 </A>
<H1 CLASS="refHeading">
HandleV()</H1>
<PRE CLASS="syntax">void	HandleV(
        MemHandle		mh);		/* Handle of block to grab */</PRE>
<P>
<CODE>
HandleV()</CODE>
 is part of a set of synchronization routines. If several different threads will be accessing the same global memory block, they need to make sure their activities will not conflict. The way they do that is to use synchronization routines to get control of a block. <CODE>
HandleV()</CODE>
 is part of one set of synchronization routines.</P>
<P>
If a block is being accessed via these synchronization routines, then a thread will not access a block until it has &quot;grabbed&quot; it with <CODE>
<A HREF="../../CRef/Routines/R_55.htm#IX_HandleP()">HandleP()</A></CODE>
 or <CODE>
<A HREF="../../CRef/Routines/R_6e.htm#IX_MemPLock()">MemPLock()</A></CODE>
. When a thread is done with the block, it can release it for use by the other threads by calling <CODE>
HandleV()</CODE>
. Note that <CODE>
HandleV()</CODE>
 does not unlock the block; it just changes the block's semaphore so other threads can grab it.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
heap.h</STRONG>
 </P>
<P CLASS="refField"><STRONG>
Tips and Tricks:</STRONG>	If you need to unlock the thread just before releasing it, use the routine <CODE>
<A HREF="../../CRef/Routines/R_70.htm#IX_MemUnlockV()">MemUnlockV()</A></CODE>
, which first unlocks the thread, and then calls <CODE>
HandleV()</CODE>
 to release it. You can find out if the block is being accessed by looking at the <CODE>
HM_otherInfo</CODE>
 word (with <CODE>
<A HREF="../../CRef/Routines/R_6c.htm#IX_MemGetInfo()">MemGetInfo()</A></CODE>
). If <CODE>
HM_otherInfo</CODE>
 equals one, the block is not grabbed; if it equals zero, it is grabbed, but no threads are queued; otherwise, it equals the handle of the first thread queued.</P>
<P CLASS="refField"><STRONG>
Be Sure To:</STRONG>	Make sure that all threads accessing the block use <CODE>
<A HREF="../../CRef/Routines/R_55.htm#IX_HandleP()">HandleP()</A></CODE>
 or <CODE>
<A HREF="../../CRef/Routines/R_6e.htm#IX_MemPLock()">MemPLock()</A></CODE>
 to access the thread. The routines use the<CODE>
 HM_otherInfo</CODE>
 field of the handle table entry; do not alter this field.</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	Do not use this on a block unless you have grabbed it. The routine does not check to see that you have grabbed the thread; it just clears the semaphore and returns.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_6f.htm#IX_MemThreadGrab()">MemThreadGrab()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_6f.htm#IX_MemThreadGrabNB()">MemThreadGrabNB()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_6f.htm#IX_MemThreadRelease()">MemThreadRelease()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_56.htm#IX_HandleV()">HandleV()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_55.htm#IX_HandleP()">HandleP()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_6e.htm#IX_MemPLock()">MemPLock()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_70.htm#IX_MemUnlockV()">MemUnlockV()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_56.htm_IX_HelpSendHelpNotification()">
 </A>
<H1 CLASS="refHeading">
HelpSendHelpNotification()</H1>
<PRE CLASS="syntax">void 	HelpSendHelpNotification(
        word 		HelpType, 
        const char 		*contextname, 
        const char 		*filename);</PRE>
<P>
Use this routine to bring up on-line help on the fly or to dynamically change the context presently showing in on-line help.</P>
</DIV>
<DIV>
<A NAME="R_56.htm_IX_HugeArrayAppend()">
 </A>
<H1 CLASS="refHeading">
HugeArrayAppend()</H1>
<PRE CLASS="syntax">dword	HugeArrayAppend(
        VMFileHandle		file,
        VMBlockhandle		vmBlock,				/* Handle of directory block */
        word		numElem,				/* # of elements to add to end of 
						 * array */</PRE>
<PRE CLASS="syntax">        const void *		initData);				/* Copy into new element(s) */</PRE>
<P>
This routine appends one or more elements to a Huge Array. If <CODE>
initData</CODE>
 is a null pointer, the elements will be uninitialized.</P>
<P>
If the Huge Array contains variable sized elements, this routine will append a single element; this element will be <CODE>
numElem</CODE>
 bytes long. The single element will be initialized to hold <EM>
initData</EM>
.</P>
<P>
If the Huge Array contains constant-sized elements, then <EM>
initData</EM>
 will be treated as an array of element-sized structures. <EM>
initData</EM>
[0] will be the initial value of the first element, <EM>
initData</EM>
[1] will be the initial value of the second, and so on.</P>
<P>
The return value is the element number of the element added. If more than one element was added; this will be the number of the first element added.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
hugearr.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_56.htm_IX_HugeArrayCompressBlocks()">
 </A>
<H1 CLASS="refHeading">
HugeArrayCompressBlocks()</H1>
<PRE CLASS="syntax">void	HugeArrayCompressBlocks(
        VMFileHandle		vmFile,			/* File containing Huge Array */
        VMBlockHandle		vmBlock);			/* handle of directory block */</PRE>
<P>
This routine compacts a Huge Array, resizing every block to be just as large as necessary to accommodate its elements. It does not change any of the data in the Huge Array.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
hugearr.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_56.htm_IX_HugeArrayContract()">
 </A>
<H1 CLASS="refHeading">
HugeArrayContract()</H1>
<PRE CLASS="syntax">word	HugeArrayContract(
        void **		elemPtr,				/* **elemPtr is first element to
 						 * delete */</PRE>
<PRE CLASS="syntax">        word		numElem);				/* # of elements to delete */</PRE>
<P>
Delete a number of elements starting at an address in a Huge Array. The routine will fix up the pointer so it points to the first element after the deleted elements. The routine automatically locks and unlocks Huge Array blocks as necessary.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
hugearr.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_56.htm_IX_HugeArrayCreate()">
 </A>
<H1 CLASS="refHeading">
HugeArrayCreate()</H1>
<PRE CLASS="syntax">VMBlockhandle 	HugeArrayCreate(
        VMFileHandle		vmFile,				/* Create in this VM file */
        word		elemSize,				/* Pass zero for variable-size
						 * elements */</PRE>
<PRE CLASS="syntax">        word		headerSize);				/* Pass zero for default header */</PRE>
<P>
This routine creates and initializes a Huge Array in the specified file. It returns the handle of the Huge Array's directory block.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
hugearr.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_56.htm_IX_HugeArrayDelete()">
 </A>
<H1 CLASS="refHeading">
HugeArrayDelete()</H1>
<PRE CLASS="syntax">void	HugeArrayDelete(
        VMFileHandle		vmFile,
        VMBlockHandle		vmBlock,			/* handle of directory block */
        word		numElem,			/* # of elements to delete */
        dword		elemNum);			/* Index of first element to delete */</PRE>
<P>
This routine deletes one or more elements from a Huge Array. It contracts and frees blocks as necessary.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
hugearr.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_56.htm_IX_HugeArrayDirty()">
 </A>
<H1 CLASS="refHeading">
HugeArrayDirty()</H1>
<PRE CLASS="syntax">void	HugeArrayDirty(
        const void *		elemPtr);				/* Element in dirty block */</PRE>
<P>
This routine marks a block in a Huge Array as dirty. The routine is passed a pointer to anywhere in a dirty element; that element's block will be dirtied.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
hugearr.h</STRONG>
 </P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	Be sure to call this routine before you unlock the element; otherwise, the block may be discarded before you can dirty it.</P>
</DIV>
<HR>
<A NAME="R_57.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_57.htm_IX_HugeArrayDestroy()">
 </A>
<H1 CLASS="refHeading">
HugeArrayDestroy()</H1>
<PRE CLASS="syntax">void	HugeArrayDestroy(
        VMFileHandle		vmFile,
        VMBlockHandle		vmBlock);			/* Handle of directory block */</PRE>
<P>
This routine destroys a HugeArray by freeing all of its blocks.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
hugearr.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_57.htm_IX_HugeArrayEnum()">
 </A>
<H1 CLASS="refHeading">
HugeArrayEnum()</H1>
<PRE CLASS="syntax">Boolean	HugeArrayEnum(
        VMFileHandle	vmFile,			/* Handle of Huge Array's VM file */
        VMBlockHandle	vmBlock,		/* Handle of the Huge Array's
						 * directory block */
        Boolean	 _pascal 	(*callback) (	/* return <EM>true</EM> to stop */
       		void *			element,	/* element to examine */
       		void * 			enumData),	/* pointer to data */
        dword		startElement,		/* first element to examine */
        dword		count,			/* examine this many elements */
        void *		enumData;		/* this pointer is passed to
						 * callback routine */</PRE>
<P>
This routine lets you examine a sequence of elements in a Huge Array. <CODE>
HugeArrayEnum()</CODE>
 is passed six arguments. The first two are a file handle and block handle; these specify the Huge Array to be examined. The third is a pointer to a Boolean callback routine. The fourth argument is the index of the first element to be examined (remember, the first element in the Huge Array has an index of zero). The fifth argument is the number of elements to examine, or -1 to examine through the last element. The sixth argument is a pointer which is passed unchanged to the callback routine; you can use this to pass data to the callback routine, or to keep track of a scratch space.</P>
<P>
The callback routine, which must be declared _pascal, itself takes two arguments. The first is a pointer to an element in the huge array. The callback routine will be called once for each element in the specified range; each time, the first argument will point to the element being examined. The second argument is the pointer that was passed as the final argument to <CODE>
HugeArrayEnum()</CODE>
. The callback routine can make <CODE>
HugeArrayEnum()</CODE>
 abort by returning <EM>
true</EM>
; this is useful if you need to search for a specific element. Otherwise, the callback routine should return <EM>
false</EM>
. If the callback routine aborts the enumeration, <CODE>
HugeArrayEnum()</CODE>
 returns <EM>
true</EM>
; otherwise, it returns <EM>
false</EM>
.</P>
<P>
<CODE>
HugeArrayEnum()</CODE>
 is guaranteed to examine the elements in numerical order, beginning with <EM>
startElement</EM>
. The routine will automatically stop with the last element, even if <EM>
count</EM>
 elements have not been enumerated. However, the starting element must be the index of an element in the array.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
hugearr.h</STRONG>
 </P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	The callback routine may not allocate, free, or resize any elements in the Huge Array. All it should do is examine or change (<EM>
without</EM>
 resizing) a single element. </P>
<P>
The starting element must be an element in the array. If you pass a starting index which is out-of-bounds, the results are undefined.</P>
</DIV>
<DIV>
<A NAME="R_57.htm_IX_HugeArrayExpand()">
 </A>
<H1 CLASS="refHeading">
HugeArrayExpand()</H1>
<PRE CLASS="syntax">word	HugeArrayExpand(
        void **		elemPtr,				/* **elemPtr is element at location
						 * where new elements will be
						 * created */</PRE>
<PRE CLASS="syntax">        word		numElem,				/* # of elements to insert */
        const void *		initData);				/* Copy this into each new 
						 * element */</PRE>
<P>
This routine inserts a number of elements at a specified location in a HugeArray. The element pointed to will be shifted so it comes after the newly-created elements. The pointer will be fixed up to point to the first new element. The data pointed to by <EM>
initData</EM>
 will be copied into each new element. If <EM>
initData</EM>
 is null, the new elements will be uninitialized.</P>
<P>
If the elements are of variable size, this routine will insert a single element; this element will be <CODE>
numElem</CODE>
 bytes long.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
hugearr.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_57.htm_IX_HugeArrayGetCount()">
 </A>
<H1 CLASS="refHeading">
HugeArrayGetCount()</H1>
<PRE CLASS="syntax">dword	HugeArrayGetCount(
        VMFileHandle		vmFile,
        VMBlockHandle		vmBlock);			/* Handle of directory block */</PRE>
<P>
This routine returns the number of elements in a Huge Array.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
hugearr.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_57.htm_IX_HugeArrayInsert()">
 </A>
<H1 CLASS="refHeading">
HugeArrayInsert()</H1>
<PRE CLASS="syntax">void	HugeArrayInsert(
        VMFileHandle		vmFile,
        VMBlockHandle		vmBlock,			/* Handle of directory block */
        word		numElem,			/* # of elements to insert */
        dword		elemNum,			/* Index of first new element */
        const void *		initData);			/* Copy this into each new element */</PRE>
<P>
This routine inserts one or more elements in the midst of a Huge Array. The first new element will have index <EM>
elemNum</EM>
; thus, the element which previously had that index will now come after the new elements. The data pointed to by <CODE>
initData</CODE>
 will be copied into each new element. If <CODE>
initData</CODE>
 is null, the new elements will be uninitialized.</P>
<P>
If the elements are of variable size, this routine will insert a single element; this element will be <CODE>
numElem</CODE>
 bytes long.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
heap.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_57.htm_IX_HugeArrayLock()">
 </A>
<H1 CLASS="refHeading">
HugeArrayLock()</H1>
<PRE CLASS="syntax">dword	HugeArrayLock(
        VMFileHandle		vmFile,
        VMBlockhandle		vmBlock,			/* Handle of directory block */
        dword		elemNum,			/* Element to lock */
        void **		elemPtr,			/* Pointer to element is written here */
        word *		elemSize);</PRE>
<P>
This routine locks an element in a Huge Array. It writes the element's address to <CODE>
*elemPtr</CODE>
. The dword returned indicates how many elements come before and after the element in that blok The upper word indicates how many elements come before the locked one, counting the locked element; the lower word indicates how many elements come after the locked element, again counting the locked one. If an error occured, then the lower word of the return value will be zero. </P>
<P>
The routine also writes the size of the locked element (in bytes) to <CODE>
*elemSize</CODE>
. You may examine or change all the other elements in the block without making further calls to <CODE>
HugeArrayLock()</CODE>
.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
heap.h</STRONG>
 </P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_55.htm#IX_HAL_COUNT() macro">HAL_COUNT()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_55.htm#IX_HAL_PREV() macro">HAL_PREV()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_57.htm_IX_HugeArrayNext()">
 </A>
<H1 CLASS="refHeading">
HugeArrayNext()</H1>
<PRE CLASS="syntax">word	HugeArrayNext(
        void **		elemPtr,
        word *		size);</PRE>
<P>
This routine increments a pointer to an element in a HugeArray to point to
the next element. If the element was the last element in its block,
<CODE>HugeArrayNext()</CODE> will unlock its block and lock the next one.
The routine writes the pointer to <EM>*elemPtr</EM>; it returns the number
of elements which come after the newly-locked one in its block, counting
the newly-locked element. If this routine is passed a pointer to the last
element in a HugeArray, it returns zero and <EM>elemPtr</EM> will point
to the last element.</P>
<P>
If the elements are variable-sized, then the word pointed to by
<EM>size</EM> will be updated to reflect the size of the newly-locked
element; otherwise, the value will be undefined.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
heap.h</STRONG>
 </P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	This routine may unlock the block containing the passed element. Therefore, if you need to mark the block as dirty, do so before making this call.</P>
</DIV>
<HR>
<A NAME="R_58.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_58.htm_IX_HugeArrayPrev()">
 </A>
<H1 CLASS="refHeading">
HugeArrayPrev()</H1>
<PRE CLASS="syntax">word	HugeArrayPrev(
        void **		elemPtr1,				/* indicates current element */
        void **		elemPtr2,
        word * 		size);</PRE>
<P>
This routine decrements a pointer to an element in a HugeArray to point to
the previous element. If the element was the first element in its block,
<CODE>HugeArrayPrev()</CODE> will unlock its block and lock the previous
one. The routine writes the pointer to <EM>*elemPtr1</EM>, and writes a
pointer to the first element in the block in <CODE>*elemPtr2</CODE>. It
returns the number of elements which come before the newly-locked one in
its block, counting the newly-locked element. If this routine is passed a
pointer to the first element in a HugeArray, it returns zero and
<EM>*elemPtr1</EM> will point to the first element.</P>
<P>
If the elements are variable-sized, then the word pointed to by <EM>size</EM>
will be updated to reflect the size of the newly-locked element; otherwise,
the value will be undefined.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
hugearr.h</STRONG>
 </P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	This routine may unlock the block containing the passed element. Therefore, if you need to mark the block as dirty, do so before making this call.</P>
</DIV>
<DIV>
<A NAME="R_58.htm_IX_HugeArrayReplace()">
 </A>
<H1 CLASS="refHeading">
HugeArrayReplace()</H1>
<PRE CLASS="syntax">void	HugeArrayReplace(
        VMFileHandle		file,
        VMBlockHandle		vmblock,				/* Handle of directory block */
        word		numElem,				/* # of elements to replace */
        dword		elemNum,				/* First element to replace */
        const void *		initData);				/* Copy this into each element</PRE>
<P>
This routine replaces one or more elements with copies of the passed data. If <EM>
initData</EM>
 is null, the elements will be filled with null bytes.</P>
<P>
If the elements are of variable size, a single element will be resized; its new size will be <CODE>
numElem </CODE>
bytes long.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
hugearr.h</STRONG>
 </P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_58.htm#IX_HugeArrayResize()">HugeArrayResize()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_58.htm_IX_HugeArrayResize()">
 </A>
<H1 CLASS="refHeading">
HugeArrayResize()</H1>
<PRE CLASS="syntax">void	HugeArrayResize(
        VMFileHandle		vmFile,
        VMBlockHandle		vmBlock,			/* Handle of directory block */
        dword		elemNum,			/* Resize this element */
        word		newSize);			/* New size in bytes */</PRE>
<P>
This routine resizes an element in a Huge Array. The array must contain variable-sized elements. If the new size is larger than the old, the extra space will be zero-initialized. If it is smaller, the element will be truncated.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
hugearr.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_58.htm_IX_HugeArrayUnlock()">
 </A>
<H1 CLASS="refHeading">
HugeArrayUnlock()</H1>
<PRE CLASS="syntax">void	HugeArrayUnlock(
        void *		elemPtr);</PRE>
<P>
This routine unlocks the block of a HugeArray which contains the passed element.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
hugearr.h</STRONG>
 </P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	If you have changed any of the elements in the block, be sure to call <CODE>
<A HREF="../../CRef/Routines/R_56.htm#IX_HugeArrayDirty()">HugeArrayDirty()</A></CODE>
 <EM>
before</EM>
 you unlock the block; otherwise the block might be discarded.</P>
</DIV>
<DIV>
<A NAME="R_58.htm_IX_IACPConnect()">
 </A>
<H1 CLASS="refHeading">
IACPConnect()</H1>
<PRE CLASS="syntax">IACPConnection IACPConnect(
        GeodeToken 		*list, 
        IACPConnectFlags 		flags, 
        MemHandle 		appLaunchBlock, 
        optr 		client, 
        word 		*numServers);</PRE>
<P>
This routine establishes a connection between a client object (by default the calling thread's application object) and one or more servers registered with the indicated list.</P>
<P>
The <EM>
client</EM>
 argument should be <CODE>
NullOptr</CODE>
 unless the IACPCF_CLIENT_OD_SPECIFIED flag is set in the flags parameter.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
iacp.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_58.htm_IX_IACPCreateDefaultLaunchBlock()">
 </A>
<H1 CLASS="refHeading">
IACPCreateDefaultLaunchBlock()</H1>
<PRE CLASS="syntax">MemHandle IACPCreateDefaultLaunchBlock(
        word 		appMode);</PRE>
<P>
This routine creates a memory block holding an <CODE>
AppLaunchBlock</CODE>
 structure suitable for passing to <CODE>
<A HREF="../../CRef/Routines/R_58.htm#IX_IACPConnect()">IACPConnect()</A></CODE>
. The two valid values to pass in <EM>
appMode</EM>
 are <CODE>
MSG_GEN_PROCESS_OPEN_APPLICATION</CODE>
 and <CODE>
MSG_GEN_PROCESS_OPEN_ENGINE</CODE>
.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
iacp.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_58.htm_IX_IACPFinishConnect()">
 </A>
<H1 CLASS="refHeading">
IACPFinishConnect()</H1>
<PRE CLASS="syntax">void	IACPFinishConnect(
        IACPConnection		connection,
        optr		server);</PRE>
<P>
Finishes a connection made to a server which had to change from non-interactible to interactible.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
iacp.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_58.htm_IX_IACPGetServerNumber()">
 </A>
<H1 CLASS="refHeading">
IACPGetServerNumber()</H1>
<PRE CLASS="syntax">word	IACPGetServerNumber(
        IACPConnection		connection,
        optr		server);</PRE>
<P>
This routine retrieves the server number for a particular server in a particular connection. It returns the server number.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
iacp.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_58.htm_IX_IACPLostConnection()">
 </A>
<H1 CLASS="refHeading">
IACPLostConnection()</H1>
<PRE CLASS="syntax">void IACPLostConnection(
        optr 		oself, 
        IACPConnection 		connection);</PRE>
<P>
This routine is called by IACP server objects to handle when a client closes a connection.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
iacp.goh</STRONG>
 </P>
</DIV>
<HR>
<A NAME="R_59.htm"></A>
<P>
<!-- $Id: R_59.htm,v 1.6 97/12/15 14:10:57 nfiedler Exp $ --><!-- <META NAME="description" CONTENT=""> --><!-- <META NAME="keywords" CONTENT=""> -->
<A HREF="#index.htm"><IMG SRC="../../docImages/up.gif" ALT="Up" BORDER="0"></A><!-- down to first child -->
<!-- to previous --> | <A HREF="#R_58.htm"><IMG SRC="../../docImages/prev.gif" BORDER="0" ALT="Prev: ">HugeArrayPrev() ...</A>
<!-- to next --> | <A HREF="#R_5a.htm"><IMG SRC="../../docImages/next.gif" BORDER="0" ALT="Next: ">InitFileCommit() ...</A>

<HR>
<P>
<H1 CLASS="refHeading"><A NAME="R_59.htm_IX_IACPProcessMessage()">IACPProcessMessage()</A>
</H1>
<PRE>
void IACPProcessMessage(
        optr           oself, 
        EventHandle            msgToSend, 
        TravelOption           topt, 
        EventHandle            completionMsg);

</PRE>
<P>
This is a utility routine to dispatch an encapsulated message
handed to an object by an IACP connection.</P>
<P CLASS="refField">
<STRONG>Include:</STRONG> <STRONG>iacp.goh</STRONG> </P></DIV><DIV>
<H1 CLASS="refHeading"><A NAME="R_59.htm_IX_IACPRegisterDocument()">IACPRegisterDocument()</A>
</H1>
<PRE>
void IACPRegisterDocument(
        optr   server,
        word   disk,
        dword  fileID);

</PRE>
<P>
This routine registers an open document and the server object
for it.</P>
<P>
This routine is to be used only by servers, not by clients, and
should only be used by the creator of the document. There is no
provision for using IACP to connect to a server that is not the
creator of the document in question.</P>
<P CLASS="refField">
<STRONG>Include:</STRONG> <STRONG>iacp.goh</STRONG> </P></DIV><DIV>
<H1 CLASS="refHeading"><A NAME="R_59.htm_IX_IACPRegisterServer()">IACPRegisterServer()</A>
</H1>
<PRE>
void    IACPRegisterServer(
        GeodeToken             *list, 
        optr           server,
        IACPServerMode                 mode,
        IACPServerFlags                flags);

</PRE>
<P>
This routine registers an object as a server for the IACP server
list specified by the passed token.</P>
<P CLASS="refField">
<STRONG>Include:</STRONG> <STRONG>iacp.goh</STRONG> </P></DIV><DIV>

 <H1 CLASS="refHeading"><A NAME="R_59.htm_IX_IACPSendMessage()">IACPSendMessage()</A>
</H1>
<PRE class="syntax">
word IACPSendMessage(
	IACPConnection 	connection,
	EventHandle 		msgToSend,
	TravelOption 		topt,	
	EventHandle 		completionMsg,
	IACPSide 		side);

</PRE>
<P>
This routine sends the message event via IACP to all the objects on the
other side of an IACP connection.</P>
<P CLASS="refField">
<STRONG>Include:</STRONG> <STRONG>iacp.goh</STRONG> </P></DIV><DIV>


<H1 CLASS="refHeading"><A NAME="R_59.htm_IX_IACPSendMessageAndWait()">IACPSendMessageAndWait()</A>
</H1>
<PRE>
word IACPSendMessageAndWait(
        IACPConnection                 connection, 
        EventHandle            msgToSend, 
        TravelOption           topt, 
        IACPSide     side); 

</PRE>
<P>
This routine sends a recorded message to all the objects on the
other side of an IACP connection, and waits until
the other application responds that it has received the message via
IACP. This does not mean the message has been handled by the other
application, only that the other application was given the <CODE>EventHandle</CODE> and
will try to deal with it. This is useful when passing volatile data.</P>
<P CLASS="refField">
<STRONG>Include:</STRONG> <STRONG>iacp.goh</STRONG> </P></DIV><DIV>
<H1 CLASS="refHeading"><A NAME="R_59.htm_IX_IACPSendMessageToServer()">IACPSendMessageToServer()</A>
</H1>
<PRE>
word IACPSendMessageToServer(
        IACPConnection                 connection, 
        EventHandle            msgToSend, 
        TravelOption           topt, 
        EventHandle            completionMsg, 
        word           serverNum);

</PRE>
<P>
This routine sends a message to a specific server on the other
side of an IACP connection.</P>
<P CLASS="refField">
<STRONG>Include:</STRONG> <STRONG>iacp.goh</STRONG> </P></DIV><DIV>
<H1 CLASS="refHeading"><A NAME="R_59.htm_IX_IACPShutdown()">IACPShutdown()</A>
</H1>
<PRE>
void IACPShutdown(
        IACPConnection                 connection, 
        optr           serverOD);

</PRE>
<P>
This routine removes a server or client from an IACP connection.</P>
<P CLASS="refField">
<STRONG>Include:</STRONG> <STRONG>iacp.goh</STRONG> </P></DIV><DIV>
<H1 CLASS="refHeading"><A NAME="R_59.htm_IX_IACPShutdownAll()">IACPShutdownAll()</A>
</H1>
<PRE>
void IACPShutdownAll(
        optr obj);

</PRE>
<P>
This calls <A HREF="../../CRef/Routines/R_59.htm#IX_IACPShutdown()">IACPShutdown()</A>
for all connections to which the passed object is a party. It's
primarily used by <CODE>GenApplicationClass</CODE> when the application
is exiting.</P>
<P CLASS="refField">
<STRONG>Include:</STRONG> <STRONG>iacp.goh</STRONG> </P></DIV><DIV>
<H1 CLASS="refHeading"><A NAME="R_59.htm_IX_IACPUnregisterDocument()">IACPUnregisterDocument()</A>
</H1>
<PRE>
void IACPUnregisterDocument(
        optr   server,
        word   disk,
        dword  fileID);

</PRE>
<P>
This routine unregisters an open document and the server object
for it.</P>
<P CLASS="refField">
<STRONG>Include:</STRONG> <STRONG>iacp.goh</STRONG> </P></DIV><DIV>
<H1 CLASS="refHeading"><A NAME="R_59.htm_IX_IACPUnregisterServer()">IACPUnregisterServer()</A>
</H1>
<PRE>
void IACPUnregisterServer(
        GeodeToken     *list,
        optr           server);

</PRE>
<P>
<A NAME="R_5a.htm"></A>
<DIV>
</DIV>

<DIV>
<A NAME="R_5a.htm_IX_InitFileCommit()">
 </A>
<H1 CLASS="refHeading">
InitFileCommit()</H1>
<PRE CLASS="syntax">void	InitFileCommit(void);</PRE>
<P>
This routine commits any changes to the GEOS.INI file, removing and replacing its stored backup. It ensures that no other threads are working on the file during the commit operation.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
initfile.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_5a.htm_IX_InitFileDeleteCategory()">
 </A>
<H1 CLASS="refHeading">
InitFileDeleteCategory()</H1>
<PRE CLASS="syntax">void	InitFileDeleteCategory(
        const char *category);</PRE>
<P>
This routine deletes the specified category, along with all its entries, from the GEOS.INI file. Pass it the following:</P>
<DL>
<DT>
<CODE>
category</CODE>
</DT><DD>A pointer to the null-terminated string representing the category to be deleted. This string ignores white space and is case-insensitive.</DD>
</DL>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
initfile.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_5a.htm_IX_InitFileDeleteEntry()">
 </A>
<H1 CLASS="refHeading">
InitFileDeleteEntry()</H1>
<PRE CLASS="syntax">void	InitFileDeleteEntry(
        const char *category,
        const char *key);</PRE>
<P>
This routine deletes an entry in the GEOS.INI file. Pass it the following:</P>
<DL>
<DT>
<CODE>
category</CODE>
</DT><DD>A pointer to the null-terminated string representing the category in which the entry resides. This string ignores white space and is case-insensitive.</DD>
<DT>
<CODE>
key</CODE>
</DT><DD>A pointer to the null-terminated string representing the key to be deleted.</DD>
</DL>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
initfile.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_5a.htm_IX_InitFileDeleteStringSection()">
 </A>
<H1 CLASS="refHeading">
InitFileDeleteStringSection()</H1>
<PRE CLASS="syntax">void	InitFileDeleteStringSection(
        const char *		category,
        const char *		key,
        word		stringNum);</PRE>
<P>
This routine deletes the specified string section from the given blob in the GEOS.INI file. Pass it the following:</P>
<DL>
<DT>
<CODE>
category</CODE>
</DT><DD>A pointer to the null-terminated string representing the category in which the entry resides. This string ignores white space and is case-insensitive.</DD>
<DT>
<CODE>
key</CODE>
</DT><DD>A pointer to the null-terminated string representing the key to be edited.</DD>
<DT>
<CODE>
stringNum</CODE>
</DT><DD>The zero-based string section number.</DD>
</DL>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
initfile.h</STRONG>
 </P>
</DIV>
<HR>
<A NAME="R_5b.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_5b.htm_IX_InitFileEnumStringSection()">
 </A>
<H1 CLASS="refHeading">
InitFileEnumStringSection()</H1>
<PRE CLASS="syntax">Boolean	InitFileEnumStringSection(
        const char *		category,
        const char *		key,
        InitFileReadFlags		flags,
        Boolean _pascal (*callback)		(const char *				stringSection,
        		 word 				sectionNum,
        		 void *				enumData),
        void *		enumdata);</PRE>
<P>
This routine enumerates a particular blob, allowing a callback routine to process each of the string sections in it. The routine will stop processing either after the last string section or when the callback routine returns <CODE>
true</CODE>
.</P>
<P>
Pass this routine the following:</P>
<DL>
<DT>
<CODE>
category</CODE>
</DT><DD>A pointer to the null-terminated string representing the category in which the entry resides. This string ignores white space and is case-insensitive.</DD>
<DT>
<CODE>
key</CODE>
</DT><DD>A pointer to the null-terminated string representing the key to be enumerated.</DD>
<DT>
<CODE>
flags</CODE>
</DT><DD>A record of <CODE>
InitFileReadFlags</CODE>
 indicating the method of character conversion upon reading (upcase all, downcase all, do not change).</DD>
<DT>
<CODE>
callback</CODE>
</DT><DD>A pointer to a Boolean callback routine. The callback routine is described below.</DD>
<DT>
<EM>
enumData</EM>
</DT><DD>This pointer is passed unchanged to the callback routine. <CODE>
InitFileEnumStringSection()</CODE>
 does not use it.</DD>
</DL>
<P>
This routine returns a Boolean value. It returns <CODE>
true</CODE>
 if the callback routine halted the enumeration by returning <EM>
true</EM>
; otherwise, it returns <EM>
false</EM>
.</P>
<P CLASS="refField"><STRONG>
<STRONG>
Callback Routine:</STRONG></STRONG>
 </P>
<P>
The callback routine may do anything it wants with the string section it receives. It must be declared _pascal. It must return a Boolean value: If it returns <CODE>
true</CODE>
, <CODE>
InitFileEnumStringSection()</CODE>
 will stop processing the blob. If it returns <CODE>
false</CODE>
, processing will continue to the next string section, if any. The callback will receive the following parameters:</P>
<DL>
<DT>
<CODE>
stringSection</DT><DD>
</CODE>
A pointer to the null-terminated string section to be processed.</DD>
<DT>
<CODE>
sectionNum</CODE>
</DT><DD>The zero-based number of the string section currently being processed.</DD>
<DT>
<CODE>
enumData</CODE>
</DT><DD>A pointer passed through from the caller of <CODE>
InitFileEnumStringSection()</CODE>
.</DD>
</DL>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
initfile.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_5b.htm_IX_InitFileGetTimeLastModified()">
 </A>
<H1 CLASS="refHeading">
InitFileGetTimeLastModified()</H1>
<PRE CLASS="syntax">dword	InitFileGetTimeLastModified(void);</PRE>
<P>
This routine returns the time when the GEOS.INI file was last modified. The returned time is the value of the system counter when the file was last written.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
initfile.h</STRONG>
 </P>
</DIV>


<DIV>
<A NAME="R_5b.htm_IX_InitFileMakeCanonicKeyCategory()">
 </A>
<H1 CLASS="refHeading">
InitFileMakeCanonicKeyCategory()</H1>
<PRE CLASS="syntax">void       InitFileMakeCanonicKeyCategory(
	char 		*keyCat, 
	const TCHAR 	*src);</PRE>
<P>
Converts a SBCS/DBCS (depending on GEOS version) string to an ASCIIX string without special INI characters. This is used to convert any type of string to one suitable for use as an INI file key or category. 
 </P>

<P CLASS="refField"><STRONG>
Pass:   </STRONG>
</P>
<DL>
<DT>
<STRONG>
keyCat</STRONG>
</DT><DD>The unconverted SBCS/DBCS string.</DD>
<DT>
<STRONG>
src</STRONG>
</DT><DD>The buffer for the converted SBCS ASCII hex string. If <EM>keyCat</EM> is SBCS, then <EM>src</EM> should be the same length as <EM>keyCat</EM> (including the NULL terminator); otherwise, if <EM>keyCat</EM> is DBCS then <EM>src</EM> should point to a buffer which is twice as long as <EM>keyCat</EM> (including its NULL terminator).</DD>
</DL>

<P CLASS="refField"><STRONG>
Include:</STRONG>        <STRONG CLASS="fileName">
initfile.h</STRONG>
 </P>

<P CLASS="refField"><STRONG>
Version:</STRONG>    This routine is available on builds 4 or greater of the Nokia 9000i Communicator (see <A HREF = "../../Nokia9000/Versions/combo.htm">the Versions chapter</A> for more information).
 </P>

</DIV>




<DIV>
<A NAME="R_5b.htm_IX_InitFileReadBoolean()">
 </A>
<H1 CLASS="refHeading">
InitFileReadBoolean()</H1>
<PRE CLASS="syntax">Boolean	InitFileReadBoolean(
        const char *		category,
        const char *		key,
        Boolean *		bool);</PRE>
<P>
This routine reads a Boolean entry in the GEOS.INI file, copying it into a passed buffer. It returns the first instance of the category/key combination it encounters, searching the local INI file first. Thus, local settings will always override system or network settings.</P>
<P>
This routine is used for reading data written with <CODE>
<A HREF="../../CRef/Routines/R_5d.htm#IX_InitFileWriteBoolean()">InitFileWriteBoolean()</A></CODE>
. Pass it the following parameters:</P>
<DL>
<DT>
<CODE>
category</CODE>
</DT><DD>A pointer to the null-terminated string representing the category in which the entry resides. This string ignores white space and is case-insensitive.</DD>
<DT>
<CODE>
key</CODE>
</DT><DD>A pointer to the null-terminated string representing the key to be retrieved.</DD>
<DT>
<CODE>
bool</CODE>
</DT><DD>A pointer to a Boolean variable in which the Boolean value will be returned.</DD>
</DL>
<P>
The function's return value will be <CODE>
true</CODE>
 if an error occurs or if the entry could not be found; it will be <CODE>
false</CODE>
 otherwise.</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	The return value of this function is <EM>
not</EM>
 the Boolean stored in the GEOS.INI file. That value is returned in the Boolean pointed to by <CODE>
bool</CODE>
.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
initfile.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_5b.htm_IX_InitFileReadDataBlock()">
 </A>
<H1 CLASS="refHeading">
InitFileReadDataBlock()</H1>
<PRE CLASS="syntax">Boolean	InitFileReadDataBlock(
        const char *		category,
        const char *		key,
        MemHandle *		block,
        word *		dataSize);</PRE>
<P>
This routine reads an entry in the GEOS.INI file, allocating a new block and copying the data into it. The routine returns the first instance of the category/key combination it encounters, searching the local INI file first. Thus, local settings will always override system or network settings.</P>
<P>
This routine is used for reading data written with <CODE>
<A HREF="../../CRef/Routines/R_5d.htm#IX_InitFileWriteData()">InitFileWriteData()</A></CODE>
. Pass it the following parameters:</P>
<DL>
<DT>
<CODE>
category</CODE>
</DT><DD>A pointer to the null-terminated string representing the category in which the entry resides. This string ignores white space and is case-insensitive.</DD>
<DT>
<CODE>
key</CODE>
</DT><DD>A pointer to the null-terminated string representing the key to be retrieved.</DD>
<DT>
<CODE>
block</CODE>
</DT><DD>A pointer to a null memory handle. This pointer will point to the newly-allocated block handle upon return. The data read will be in the new block. It is your responsibility to free this block when you're done with it.</DD>
<DT>
<CODE>
dataSize</CODE>
</DT><DD>The size of the read data. All the data will be read; the block will be as large as necessary.</DD>
</DL>
<P>
The function's return value will be <CODE>
true</CODE>
 if an error occurs or if the entry could not be found; it will be <CODE>
false</CODE>
 otherwise.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
initfile.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_5b.htm_IX_InitFileReadDataBuffer()">
 </A>
<H1 CLASS="refHeading">
InitFileReadDataBuffer()</H1>
<PRE CLASS="syntax">Boolean	InitFileReadDataBuffer(
        const char *		category,
        const char *		key,
        void *		buffer,
        word		bufSize,
        word *		dataSize);</PRE>
<P>
This routine reads an entry in the GEOS.INI file, copying it into a passed buffer. It returns the first instance of the category/key combination it encounters, searching the local INI file first. Thus, local settings will always override system or network settings.</P>
<P>
This routine is used for reading data written with <CODE>
<A HREF="../../CRef/Routines/R_5d.htm#IX_InitFileWriteData()">InitFileWriteData()</A></CODE>
. Pass it the following parameters:</P>
<DL>
<DT>
<CODE>
category</CODE>
</DT><DD>A pointer to the null-terminated string representing the category in which the entry resides. This string ignores white space and is case-insensitive.</DD>
<DT>
<CODE>
key</CODE>
</DT><DD>A pointer to the null-terminated string representing the key to be retrieved.</DD>
<DT>
<CODE>
buffer</CODE>
</DT><DD>A pointer to the buffer in which the data will be returned. This buffer must be in locked or fixed memory.</DD>
<DT>
<CODE>
bufSize</CODE>
</DT><DD>The size of the passed buffer in bytes. If you are not sure what the data's size will be, you may want to use the (slightly less efficient) <CODE>
<A HREF="../../CRef/Routines/R_5b.htm#IX_InitFileReadDataBlock()">InitFileReadDataBlock()</A></CODE>
.</DD>
<DT>
<CODE>
dataSize</CODE>
</DT><DD>A pointer to a word; on return, the word pointed to will contain the size (in bytes) of the data returned.</DD>
</DL>
<P>
The function's return value will be <CODE>
true</CODE>
 if an error occurs or if the entry could not be found; it will be <CODE>
false</CODE>
 otherwise.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
initfile.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_5b.htm_IX_InitFileReadInteger()">
 </A>
<H1 CLASS="refHeading">
InitFileReadInteger()</H1>
<PRE CLASS="syntax">Boolean	InitFileReadInteger(
        const char *		category,
        const char *		key,
        word *		i);</PRE>
<P>
This routine reads an integer entry in the GEOS.INI file, copying it into the passed variable. It returns the first instance of the category/key combination it encounters, searching the local INI file first. Thus, local settings will always override system or network settings.</P>
<P>
This routine is used for reading data written with <CODE>
<A HREF="../../CRef/Routines/R_5d.htm#IX_InitFileWriteInteger()">InitFileWriteInteger()</A></CODE>
. Pass it the following parameters:</P>
<DL>
<DT>
<CODE>
category</CODE>
</DT><DD>A pointer to the null-terminated string representing the category in which the entry resides. This string ignores white space and is case-insensitive.</DD>
<DT>
<CODE>
key</CODE>
</DT><DD>A pointer to the null-terminated string representing the key to be retrieved.</DD>
<DT>
<CODE>
i</CODE>
</DT><DD>A pointer to a word in which the integer will be returned.</DD>
</DL>
<P>
The function's return value will be <CODE>
true</CODE>
 if an error occurs or if the entry could not be found; it will be <CODE>
false</CODE>
 otherwise.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
initfile.h</STRONG>
 </P>
</DIV>
<HR>
<A NAME="R_5c.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_5c.htm_IX_InitFileReadStringBlock()">
 </A>
<H1 CLASS="refHeading">
InitFileReadStringBlock()</H1>
<PRE CLASS="syntax">Boolean	InitFileReadStringBlock(
        const char *		category,
        const char *		key,
        MemHandle *		block,
        InitFileReadFlags		flags,
        word *		dataSize);</PRE>
<P>
This routine reads a string entry in the GEOS.INI file, allocates a new block on the global heap, and copies the read string into the new block. It returns the first instance of the category/key combination it encounters, searching the local INI file first. Thus, local settings will always override system or network settings.</P>
<P>
This routine is used for reading data written with <CODE>
<A HREF="../../CRef/Routines/R_5d.htm#IX_InitFileWriteString()">InitFileWriteString()</A></CODE>
. Pass it the following parameters:</P>
<DL>
<DT>
<CODE>
category</CODE>
</DT><DD>A pointer to the null-terminated string representing the category in which the entry resides. This string ignores white space and is case-insensitive.</DD>
<DT>
<CODE>
key</CODE>
</DT><DD>A pointer to the null-terminated string representing the key to be retrieved.</DD>
<DT>
<CODE>
block</CODE>
</DT><DD>A pointer to a memory block handle variable. Upon return, this variable will contain the handle of the newly allocated block; the block will contain the string read from the file. It is your responsibility to free this block when you're done with it.</DD>
<DT>
<CODE>
flags</CODE>
</DT><DD>A record of <CODE>
InitFileReadFlags</CODE>
 indicating the method of character conversion upon reading (upcase all, downcase all, do not change).</DD>
<DT>
<CODE>
dataSize</CODE>
</DT><DD>A pointer to a word which, upon return, will contain the size of the string (in bytes) actually read from the file.</DD>
</DL>
<P>
The function's return value will be <CODE>
true</CODE>
 if an error occurs or if the entry could not be found; it will be <CODE>
false</CODE>
 otherwise.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
initfile.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_5c.htm_IX_InitFileReadStringBuffer()">
 </A>
<H1 CLASS="refHeading">
InitFileReadStringBuffer()</H1>
<PRE CLASS="syntax">Boolean	InitFileReadStringBuffer(
        const char *		category,
        const char *		key,
        char *		buffer,
        InitFileReadFlags		flags,
        word *		dataSize);</PRE>
<P>
This routine reads a string entry in the GEOS.INI file, copying it into a passed, locked buffer. It returns the first instance of the category/key combination it encounters, searching the local INI file first. Thus, local settings will always override system or network settings.</P>
<P>
This routine is used for reading data written with <CODE>
<A HREF="../../CRef/Routines/R_5d.htm#IX_InitFileWriteString()">InitFileWriteString()</A></CODE>
. Pass it the following parameters:</P>
<DL>
<DT>
<CODE>
category</CODE>
</DT><DD>A pointer to the null-terminated string representing the category in which the entry resides. This string ignores white space and is case-insensitive.</DD>
<DT>
<CODE>
key</CODE>
</DT><DD>A pointer to the null-terminated string representing the key to be retrieved.</DD>
<DT>
<CODE>
buffer</CODE>
</DT><DD>A pointer to a buffer into which the returned string will be written. This buffer must be in locked or fixed memory. If you don't know the approximate size of the data, you may want to use the (slightly less efficient) <CODE>
<A HREF="../../CRef/Routines/R_5c.htm#IX_InitFileReadStringBlock()">InitFileReadStringBlock()</A></CODE>
.</DD>
<DT>
<CODE>
flags</CODE>
</DT><DD>A record of <CODE>
InitFileReadFlags</CODE>
 indicating the size of the passed buffer as well as the method of character conversion upon reading (upcase all, downcase all, do not change).</DD>
<DT>
<CODE>
dataSize</CODE>
</DT><DD>A pointer to a word which, upon return, will contain the size of the string (in bytes) actually read from the file.</DD>
</DL>
<P>
The function's return value will be <CODE>
true</CODE>
 if an error occurs or if the entry could not be found; it will be <CODE>
false</CODE>
 otherwise.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
initfile.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_5c.htm_IX_InitFileReadStringSectionBlock()">
 </A>
<H1 CLASS="refHeading">
InitFileReadStringSectionBlock()</H1>
<PRE CLASS="syntax">Boolean	InitFileReadStringSectionBlock(
        const char *		category,
        const char *		key,
        word		section,
        MemHandle *		block,
        InitFileReadFlags		flags,
        word *		dataSize);</PRE>
<P>
This routine reads a string section from the specified entry in the GEOS.INI file, allocates a new block on the global heap, and copies the read string section into the new block. It returns the first instance of the category/key combination it encounters, searching the local INI file first. Thus, local settings will always override system or network settings.</P>
<P>
This routine is used for reading data written with <CODE>
<A HREF="../../CRef/Routines/R_5d.htm#IX_InitFileWriteString()">InitFileWriteString()</A></CODE>
 or <CODE>
<A HREF="../../CRef/Routines/R_5d.htm#IX_InitFileWriteStringSection()">InitFileWriteStringSection()</A></CODE>
. Pass it the following parameters:</P>
<DL>
<DT>
<CODE>
category</CODE>
</DT><DD>A pointer to the null-terminated string representing the category in which the entry resides. This string ignores white space and is case-insensitive.</DD>
<DT>
<CODE>
key</CODE>
</DT><DD>A pointer to the null-terminated string representing the key to be retrieved.</DD>
<DT>
<CODE>
section</CODE>
</DT><DD>The zero-based number of the string section to retrieved.</DD>
<DT>
<CODE>
block</CODE>
</DT><DD>A pointer to a memory block handle. Upon return, this pointer will point to the handle of the newly allocated block; the block will contain the string section read from the file.</DD>
<DT>
<CODE>
flags</CODE>
</DT><DD>A record of <CODE>
InitFileReadFlags</CODE>
 indicating the method of character conversion upon reading (upcase all, downcase all, do not change).</DD>
<DT>
<CODE>
dataSize</CODE>
</DT><DD>A pointer to a word which, upon return, will contain the size of the string section (in bytes) actually read from the file.</DD>
</DL>
<P>
The function's return value will be <CODE>
true</CODE>
 if an error occurs or if the entry could not be found; it will be <CODE>
false</CODE>
 otherwise.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
initfile.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_5c.htm_IX_InitFileReadStringSectionBuffer()">
 </A>
<H1 CLASS="refHeading">
InitFileReadStringSectionBuffer()</H1>
<PRE CLASS="syntax">Boolean	InitFileReadStringSectionBuffer(
        const char *		category,
        const char *		key,
        word		section,
        char *		buffer,
        InitFileReadFlags		flags,
        word *		dataSize);</PRE>
<P>
This routine reads a string section from the specified entry in the GEOS.INI file, copying it into a passed, locked buffer. It returns the indicated section in the first instance of the category/key combination it encounters, searching the local INI file first. Thus, local settings will always override system or network settings.</P>
<P>
This routine is used for reading data written with <CODE>
<A HREF="../../CRef/Routines/R_5d.htm#IX_InitFileWriteStringSection()">InitFileWriteStringSection()</A></CODE>
. Pass it the following parameters:</P>
<DL>
<DT>
<CODE>
category</CODE>
</DT><DD>A pointer to the null-terminated string representing the category in which the entry resides. This string ignores white space and is case-insensitive.</DD>
<DT>
<CODE>
key</CODE>
</DT><DD>A pointer to the null-terminated string representing the key to be retrieved.</DD>
<DT>
<CODE>
section</CODE>
</DT><DD>The zero-based number of the string section to be retrieved.</DD>
<DT>
<CODE>
buffer</CODE>
</DT><DD>A pointer to a buffer into which the returned string section will be written. This buffer must be in locked or fixed memory. If you don't know the approximate size of the string section, you may want to use the (slightly less efficient) <CODE>
<A HREF="../../CRef/Routines/R_5c.htm#IX_InitFileReadStringSectionBlock()">InitFileReadStringSectionBlock()</A></CODE>
.</DD>
<DT>
<CODE>
flags</CODE>
</DT><DD>A record of <CODE>
InitFileReadFlags</CODE>
 indicating the size of the passed buffer as well as the method of character conversion upon reading (upcase all, downcase all, do not change).</DD>
<DT>
<CODE>
dataSize</CODE>
</DT><DD>A pointer to a word which, upon return, will contain the size of the string section (in bytes) actually read from the file.</DD>
</DL>
<P>
The function's return value will be <CODE>
true</CODE>
 if an error occurs or if the entry could not be found; it will be <CODE>
false</CODE>
 otherwise.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
initfile.h</STRONG>
 </P>
</DIV>
<HR>
<A NAME="R_5d.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_5d.htm_IX_InitFileRevert()">
 </A>
<H1 CLASS="refHeading">
InitFileRevert()</H1>
<PRE CLASS="syntax">Boolean	InitFileRevert(void);</PRE>
<P>
This routine restores the GEOS.INI file from its saved backup version. It ensures that no other thread is operating on the file while it is being restored. This function returns an error flag: <CODE>
true</CODE>
 represents an error in restoring the file; <CODE>
false</CODE>
 indicates success.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
initfile.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_5d.htm_IX_InitFileSave()">
 </A>
<H1 CLASS="refHeading">
InitFileSave()</H1>
<PRE CLASS="syntax">Boolean	InitFileSave(void);</PRE>
<P>
This routine saves a backup copy of the GEOS.INI, synchronously updating the backup file (<STRONG CLASS="fileName">privdata\ini.bak</STRONG>) to be the current version. (<CODE>
<A HREF="../../CRef/Routines/R_5a.htm#IX_InitFileCommit()">InitFileCommit()</A></CODE>
 overwrites the GEOS.INI file itself.) It ensures that no other thread is operating on the file while it is being written out. This function returns an error flag: <CODE>
true</CODE>
 represents an error in trying to save the file; <CODE>
false</CODE>
 indicates success.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
initfile.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_5d.htm_IX_InitFileWriteBoolean()">
 </A>
<H1 CLASS="refHeading">
InitFileWriteBoolean()</H1>
<PRE CLASS="syntax">void	InitFileWriteBoolean(
        const char *		category,
        const char *		key,
        Boolean 		bool);</PRE>
<P>
This integer writes a Boolean value into the specified category and key of the local GEOS.INI file. The Boolean will appear as &quot;true&quot; or &quot;false&quot; if the user looks at GEOS.INI with a text editor, but it will be an actual Boolean value to GEOS. Pass this routine the following:</P>
<DL>
<DT>
<CODE>
category</CODE>
</DT><DD>A pointer to the null-terminated character string representing the INI category into which the data should be written.</DD>
<DT>
<CODE>
key</CODE>
</DT><DD>A pointer to the null-terminated character string representing the INI key within <CODE>
category</CODE>
 into which the data should be written.</DD>
<DT>
<CODE>
bool</CODE>
</DT><DD>The Boolean value to be written.</DD>
</DL>
<P>
Once written, the Boolean value can be read with <CODE>
<A HREF="../../CRef/Routines/R_5b.htm#IX_InitFileReadBoolean()">InitFileReadBoolean()</A></CODE>
.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
initfile.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_5d.htm_IX_InitFileWriteData()">
 </A>
<H1 CLASS="refHeading">
InitFileWriteData()</H1>
<PRE CLASS="syntax">void	InitFileWriteData(
        const char 		*category,
        const char 		*key,
        const void 		*buffer,
        word		bufSize);</PRE>
<P>
This routine writes a given piece of data to the local GEOS.INI file. Pass it the following:</P>
<DL>
<DT>
<CODE>
category</CODE>
</DT><DD>A pointer to the null-terminated character string representing the INI category into which the data should be written.</DD>
<DT>
<CODE>
key</CODE>
</DT><DD>A pointer to the null-terminated character string representing the INI key within <CODE>
category</CODE>
 into which the data should be written.</DD>
<DT>
<CODE>
buffer</CODE>
</DT><DD>A pointer to a locked or fixed buffer containing the data to be written.</DD>
<DT>
<CODE>
bufSize</CODE>
</DT><DD>The size of the buffer in bytes.</DD>
</DL>
<P>
Once data has been written to the INI file, it can be read with <CODE>
<A HREF="../../CRef/Routines/R_5b.htm#IX_InitFileReadDataBlock()">InitFileReadDataBlock()</A></CODE>
 or <CODE>
<A HREF="../../CRef/Routines/R_5b.htm#IX_InitFileReadDataBuffer()">InitFileReadDataBuffer()</A></CODE>
.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
initfile.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_5d.htm_IX_InitFileWriteInteger()">
 </A>
<H1 CLASS="refHeading">
InitFileWriteInteger()</H1>
<PRE CLASS="syntax">void	InitFileWriteInteger(
        const char 		*category,
        const char 		*key,
        word		value);</PRE>
<P>
This routine writes an integer into the category and key specified for the local GEOS.INI file. Pass the following:</P>
<DL>
<DT>
<CODE>
category</CODE>
</DT><DD>A pointer to the null-terminated character string representing the INI category into which the data should be written.</DD>
<DT>
<CODE>
key</CODE>
</DT><DD>A pointer to the null-terminated character string representing the INI key within <CODE>
category</CODE>
 into which the data should be written.</DD>
<DT>
<CODE>
value</CODE>
</DT><DD>The integer to be written.</DD>
</DL>
<P>
The integer, once written, can be read with <CODE>
<A HREF="../../CRef/Routines/R_5b.htm#IX_InitFileReadInteger()">InitFileReadInteger()</A></CODE>
.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
initfile.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_5d.htm_IX_InitFileWriteString()">
 </A>
<H1 CLASS="refHeading">
InitFileWriteString()</H1>
<PRE CLASS="syntax">void	InitFileWriteString(
        const char *category,
        const char *key,
        const char *str);</PRE>
<P>
This routine writes an entire string into the category and key specified for the local GEOS.INI file. Pass it the following:</P>
<DL>
<DT>
<CODE>
category</CODE>
</DT><DD>A pointer to the null-terminated character string representing the INI category into which the data should be written.</DD>
<DT>
<CODE>
key</CODE>
</DT><DD>A pointer to the null-terminated character string representing the INI key within <CODE>
category</CODE>
 into which the data should be written.</DD>
<DT>
<CODE>
str</CODE>
</DT><DD>A pointer to the null-terminated string to be written. If the string contains line feeds or carriage returns, it will automatically be parsed into string segments and be put within curly braces; if it contains curly braces, all closing braces will automatically have a backslash inserted before them.</DD>
</DL>
<P>
To read a string written with this routine, use <CODE>
<A HREF="../../CRef/Routines/R_5c.htm#IX_InitFileReadStringBlock()">InitFileReadStringBlock()</A></CODE>
 or <CODE>
<A HREF="../../CRef/Routines/R_5c.htm#IX_InitFileReadStringBuffer()">InitFileReadStringBuffer()</A></CODE>
.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
initfile.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_5d.htm_IX_InitFileWriteStringSection()">
 </A>
<H1 CLASS="refHeading">
InitFileWriteStringSection()</H1>
<PRE CLASS="syntax">void	InitFileWriteStringSection(
        const char *category,
        const char *key,
        const char *string);</PRE>
<P>
This routine appends a string section onto the blob specified by the <CODE>
category</CODE>
 and <CODE>
key</CODE>
 parameters. The string section will become part of the blob and will be its last section. The section may not contain any carriage returns or line feeds. Pass this routine the following:</P>
<DL>
<DT>
<CODE>
category</CODE>
</DT><DD>A pointer to the null-terminated character string representing the INI category into which the data should be written.</DD>
<DT>
<CODE>
key</CODE>
</DT><DD>A pointer to the null-terminated character string representing the INI key within <CODE>
category</CODE>
 into which the data should be written.</DD>
<DT>
<CODE>
string</CODE>
</DT><DD>A pointer to the string section to be written.</DD>
</DL>
<P>
Once written, the segment may be read with <CODE>
<A HREF="../../CRef/Routines/R_5c.htm#IX_InitFileReadStringSectionBlock()">InitFileReadStringSectionBlock()</A></CODE>
 or <CODE>
<A HREF="../../CRef/Routines/R_5c.htm#IX_InitFileReadStringSectionBuffer()">InitFileReadStringSectionBuffer()</A></CODE>
.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
initfile.h</STRONG>
 </P>
</DIV>
<HR>
<A NAME="R_5e.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_5e.htm_IX_InkDBGetDisplayInfo()">
 </A>
<A NAME="R_5e.htm_IX_InkDBDisplayInfo">
 </A>
<A NAME="R_5e.htm_IX_IDBDI_&ldots;">
 </A>
<H1 CLASS="refHeading">
InkDBGetDisplayInfo()</H1>
<PRE CLASS="syntax">void 	InkDBGetDisplayInfo(
        InkDBDisplayInfo *		retVal,
        VMFileHandle 		fh);</PRE>
<P>
This routine returns the dword ID of the note or folder which is presently being displayed by the Ink Database. It also returns the ID of the parent folder, and the page number, if applicable.</P>
<P CLASS="refField"><STRONG>
Structures:</STRONG>	It returns this information by filling in an <CODE>
InkDBDisplayInfo</CODE>
 structure:</P>
<PRE>typedef struct {
	dword 	IDBDI_currentDisplay;
	dword 	IDBDI_parentFolder;
	word 	IDBDI_pageNumber;
} InkDBDisplayInfo;</PRE>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
pen.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_5e.htm_IX_InkDBGetHeadFolder()">
 </A>
<H1 CLASS="refHeading">
InkDBGetHeadFolder()</H1>
<PRE CLASS="syntax">dword 	InkDBGetHeadFolder(
        VMFileHandle 		fh);</PRE>
<P>
This routine returns the dword ID of the head folder of an Ink Database file.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
pen.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_5e.htm_IX_InkDBInit()">
 </A>
<H1 CLASS="refHeading">
InkDBInit()</H1>
<PRE CLASS="syntax">void 	InkDBInit(
        VMFileHandle 		fh);</PRE>
<P>
This routine takes a new Ink Database file. It initializes the file for use, creating all needed maps and a top-level folder. </P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
pen.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_5e.htm_IX_InkDBSetDisplayInfo()">
 </A>
<H1 CLASS="refHeading">
InkDBSetDisplayInfo()</H1>
<PRE CLASS="syntax">void 	InkDBSetDisplayInfo(
        VMFileHandle 		fh,
        dword 		ofh,		/* Parent Folder dword ID# */
        dword		note,		/* ID# of note or folder to display */
        word		page); 		/* If displaying note, page # to display*/</PRE>
<P>
This routine sets the display information for an Ink Database file. This routine sets the user's location in the database. The caller must supply the dword ID number of the note or folder to display, the parent folder (0 if displaying the top level folder), and the page number to display if displaying a note.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
pen.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_5e.htm_IX_InkFolderCreateSubFolder()">
 </A>
<H1 CLASS="refHeading">
InkFolderCreateSubFolder()</H1>
<PRE CLASS="syntax">dword 	InkFolderCreateSubFolder(
        dword 		tag, 	/* ID# of parent folder (0 for top-level) */
        VMFileHandle 		fh); 	/* Handle of Ink DB file */</PRE>
<P>
This routine creates a subfolder within the passed folder. The new folder is automatically added to it's parent's chunk array. The return value is new folder's dword ID number.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
pen.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_5e.htm_IX_InkFolderDelete()">
 </A>
<H1 CLASS="refHeading">
InkFolderDelete()</H1>
<PRE CLASS="syntax">void 	InkFolderDelete(
        dword 		tag,		/* ID# of folder */
        VMFileHandle 		fh);		/* Handle of Ink DB file */</PRE>
<P>
This routine removes an Ink Database folder.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
pen.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_5e.htm_IX_InkFolderDepthFirstTraverse()">
 </A>
<H1 CLASS="refHeading">
InkFolderDepthFirstTraverse()</H1>
<PRE CLASS="syntax">word 	InkFolderDepthFirstTraverse(
        dword 		rfldr,		/* ID# of folder at root of search tree */
        VMFileHandle		fh, 		/* Handle of Ink DB file */
        Boolean 	_pascal	(*callback)( /* far ptr to callback routine */
			dword				fldr,
			VMFileHandle 				fh,
			word *				info),</PRE>
<PRE CLASS="syntax">        word *		info);		/* Extra data to pass to callback */</PRE>
<P>
This routine does a depth-first traversal of a folder tree. The callback routine, which must be declared _pascal, can halt the search by returning <EM>
true</EM>
, in which case the search routine will immediately return <EM>
true</EM>
; otherwise the search will return <EM>
false</EM>
.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
pen.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_5e.htm_IX_InkFolderDisplayChildInList()">
 </A>
<H1 CLASS="refHeading">
InkFolderDisplayChildInList()</H1>
<PRE CLASS="syntax">void 	InkFolderDisplayChildInList(
        dword 		fldr, 		/* ID# of folder */
        VMFileHandle 		fh,		/* Handle of Ink DB file */
        optr 		list, 		/* GenDynamicList */
        word		entry, 		/* entry number of child to display */
        Boolean		displayFolders); /* Include monikers in count,
							* return their monikers */</PRE>
<P>
This routine requests that a dynamic list display the name of one of a folder's children. It is normally called in an applications <CODE>
GDLI_queryMsg</CODE>
 handler.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
pen.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_5e.htm_IX_InkFolderGetChildInfo()">
 </A>
<H1 CLASS="refHeading">
InkFolderGetChildInfo()</H1>
<PRE CLASS="syntax">Boolean 	InkFolderDisplayChildInfo( /* true if folder; else note */
        dword 		fldr, 		/* ID# of folder */
        VMFileHandle 		fh,		/* Handle of Ink DB file */
        word		entry, 		/* entry number of child */
        dword *		childID);	/* Pointer to returned child ID # */</PRE>
<P>
This routine returns information about one of a folder's children. The explicit return value will be true if the child is a folder, false if the child is a note. In addition, the passed dword pointer will point to the child's dword ID number.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
pen.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_5e.htm_IX_InkFolderGetChildNumber()">
 </A>
<H1 CLASS="refHeading">
InkFolderGetChildNumber()</H1>
<PRE CLASS="syntax">word 	InkFolderDisplayChildInList( 
        dword 		fldr, 		/* ID# of folder */
        VMFileHandle 		fh,		/* Handle of Ink DB file */
        dword		note); 		/* ID# of child note or folder */</PRE>
<P>
This routine returns the passed note or folder's entry number within its passed parent folder.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
pen.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_5e.htm_IX_InkFolderGetContents()">
 </A>
<H1 CLASS="refHeading">
InkFolderGetContents()</H1>
<PRE CLASS="syntax">DBGroupAndItem 	InkFolderGetContents(
        dword 		tag, 				/* ID# of folder */
        VMFileHandle 		fh,				/* Handle of Ink DB file */
        DBGroupAndItem *		subFolders); 		/* pointer to return value */);</PRE>
<P>
This routine returns the contents of a folder. It returns two chunk arrays, each of which is filled with dword ID numbers of the folder's children. The explicitly returned array holds the numbers of the folder's child notes. The routine also fills in a pointer with a DB item holding a chunk array with the ID numbers of the subfolders.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
pen.goh</STRONG>
 </P>
</DIV>
<HR>
<A NAME="R_5f.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_5f.htm_IX_InkFolderGetNumChildren()">
 </A>
<H1 CLASS="refHeading">
InkFolderGetNumChildren()</H1>
<PRE CLASS="syntax">dword 	InkFolderGetNumChildren( /* Subfolders:Notes */
        dword 		fldr, 		/* ID# of folder */
        VMFileHandle 		fh);		/* Handle of Ink DB file */</PRE>
<P>
This message returns the number of children the Ink Database folder has. The high word of the return value holds the number of sub folders; the low word holds the number of notes.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
pen.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_5f.htm_IX_InkFolderMove()">
 </A>
<H1 CLASS="refHeading">
InkFolderMove()</H1>
<PRE CLASS="syntax">void 	InkFolderMove(
        dword 		fldr, 		/* ID# of folder to move */
        dword 		pfldr);/* ID# of new parent folder */</PRE>
<P>
This routine moves an Ink Database folder to a new location in the folder tree.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
pen.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_5f.htm_IX_InkFolderSetTitle()">
 </A>
<H1 CLASS="refHeading">
InkFolderSetTitle()</H1>
<PRE CLASS="syntax">void 	InkFolderSetTitle(
        dword 		tag, 		/* ID# of folder */
        VMFileHandle 		fh,		/* Handle of Ink DB file */
        const char *		name); 		/* Text object */);</PRE>
<P>
This routine renames an Ink Database folder. The passed name should be null-terminated.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
pen.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_5f.htm_IX_InkFolderSetTitleFromTextObject()">
 </A>
<H1 CLASS="refHeading">
InkFolderSetTitleFromTextObject()</H1>
<PRE CLASS="syntax">void 	InkFolderSetTitleFromTextObject(
        dword 		tag, 		/* ID# of folder */
        FileHandle 		fh,		/* Handle of Ink DB file */
        optr		text); 		/* Text object */);</PRE>
<P>
This routine sets the name of the passed Ink Database folder from the contents of the passed VisText object.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
pen.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_5f.htm_IX_InkGetDocPageInfo()">
 </A>
<H1 CLASS="refHeading">
InkGetDocPageInfo()</H1>
<PRE CLASS="syntax">void 	InkGetDocPageInfo(
        PageSizeReport *		psr, 		/* Structure to fill with return value */
        VMFileHandle 		fh);</PRE>
<P>
This routine returns the dword ID of the head folder of an Ink Database file.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
pen.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_5f.htm_IX_InkGetDocCustomGString()">
 </A>
<H1 CLASS="refHeading">
InkGetDocCustomGString()</H1>
<PRE CLASS="syntax">GStateHandle 	InkGetDocCustomGString(
        VMFileHandle 		dbfh);</PRE>
<P>
This routine returns the custom GString associated with the passed Ink Database file. Note that this custom background will only be used if the document's basic <CODE>
InkBackgroundType</CODE>
 is IBT_CUSTOM. (This may be determined using the <CODE>
<A HREF="../../CRef/Routines/R_61.htm#IX_InkSetDocGString()">InkSetDocGString()</A></CODE>
 routine.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
pen.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_5f.htm_IX_InkGetDocGString()">
 </A>
<H1 CLASS="refHeading">
InkGetDocGString()</H1>
<PRE CLASS="syntax">InkBackgroundType 	InkGetDocGString(
        VMFileHandle 		dbfh);</PRE>
<P>
This routine returns the standard GString to use as a background picture with the passed Ink Database file. If the returned background type is custom, be sure to also call <CODE>
<A HREF="../../CRef/Routines/R_5f.htm#IX_InkGetDocCustomGString()">InkGetDocCustomGString()</A></CODE>
.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
pen.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_5f.htm_IX_InkGetParentFolder()">
 </A>
<H1 CLASS="refHeading">
InkGetParentFolder()</H1>
<PRE CLASS="syntax">dword 	InkGetParentFolder(
        dword 		tag, 		/* ID# of folder or note */
        VMFileHandle 		fh);		/* Handle of Ink DB file */</PRE>
<P>
This message returns the dword ID of the passed Ink Database note or folder.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
pen.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_5f.htm_IX_InkGetTitle()">
 </A>
<H1 CLASS="refHeading">
InkGetTitle()</H1>
<PRE CLASS="syntax">word 	InkGetTitle(
        dword 		tag, 		/* ID# of folder or note */
        VMFileHandle 		fh,		/* Handle of Ink DB file */
        char *		dest); 		/* should be INK_DB_MAX_TITLE_SIZE +1 */);</PRE>
<P>
This message fills the passed text buffer with the folder's or note's title, a null-terminated string. The routine's explicit return value is the length of the string (including the terminator).</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
pen.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_5f.htm_IX_InkNoteCopyMoniker()">
 </A>
<H1 CLASS="refHeading">
InkNoteCopyMoniker()</H1>
<PRE CLASS="syntax">dword 	InkNoteCopyMoniker(
        dword 	title,	/* ID# of parent folder */
        optr 	list, 	/* Output list */
        word 	type, 	/* 1: text note
			 * 0: ink note
			 * -1: folder */</PRE>
<PRE CLASS="syntax">        word	entry);	/* Handle of Ink DB file */</PRE>
<P>
This routine copies the icon nd title into the VisMoniker.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
pen.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_5f.htm_IX_InkNoteCreate()">
 </A>
<H1 CLASS="refHeading">
InkNoteCreate()</H1>
<PRE CLASS="syntax">dword 	InkNoteCreate(
        dword 		tag,		/* ID# of parent folder */
        VMFileHandle		fh);		/* Handle of Ink DB file */</PRE>
<P>
This routine creates a note and adds it to the passed folder's child list. The new note's dword ID is returned.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
pen.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_5f.htm_IX_InkNoteCreatePage()">
 </A>
<H1 CLASS="refHeading">
InkNoteCreatePage()</H1>
<PRE CLASS="syntax">word 	InkNoteCreatePage(
        dword 		tag,		/* ID# of note */
        VMFileHandle		fh,		/* Handle of Ink DB file */
        word 		page); /* Page number to insert before, 
				 * CA_NULL_ELEMENT to append */</PRE>
<P>
This routine creates a new page within a note. It returns the new page number.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
pen.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_5f.htm_IX_InkNoteDelete()">
 </A>
<H1 CLASS="refHeading">
InkNoteDelete()</H1>
<PRE CLASS="syntax">void 	InkNoteDelete(
        dword 		tag, 		/* ID# of note */
        VMFileHandle 		fh);		/* Handle of Ink DB file */</PRE>
<P>
This message deletes the passed note. All references to the note are deleted.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
pen.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_5f.htm_IX_InkNoteFindByKeywords()">
 </A>
<H1 CLASS="refHeading">
InkNoteFindByKeywords()</H1>
<PRE CLASS="syntax">ChunkHandle 	InkNoteFindByKeywords( 
/* Return value is chunk array with elements:
 *  FindNoteHeader
 *  -dword tag-
 *  -dword tag-
 *   etc... */</PRE>
<PRE CLASS="syntax">        VMFileHandle 		fh,
        char *		strings,		/* strings to match (separated by 
					* whitespace or commas), can contain
					* C_WILDCARD or C_SINGLE_WILDCARD */</PRE>
<PRE CLASS="syntax">        word 		opt,		/* true to match all keywords; 
				 * false to match at least one keyword */</PRE>
<P>
This routine returns a chunk array containing the dword ID numbers of all notes whose keywords match the passed search string, preceded by the number of matching notes. If no such notes are found, then the returned handle will be NULL.</P>
<P>
Note that this routine will only return about 20K notes; if there are more that match, only the first 20K will be returned.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
pen.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_5f.htm_IX_InkNoteFindByTitle()">
 </A>
<H1 CLASS="refHeading">
InkNoteFindByTitle()</H1>
<PRE CLASS="syntax">ChunkHandle 	InkNoteFindByTitle( 
/* Return value is chunk array with elements:
 *  FindNoteHeader
 *  -dword tag-
 *  -dword tag-
 *   etc... */</PRE>
<PRE CLASS="syntax">        const char *		string,		/* string to match (can contain C_WILDCARD
				  * or C_SINGLE_WILDCARD */</PRE>
<PRE CLASS="syntax">        SearchOptions 		opt,		/* Search options */
        Boolean 		Body, 		/* true if you want to look in the body
				 * of text notes */</PRE>
<PRE CLASS="syntax">        VMFileHandle		fh);		/* Handle of Ink DB file */</PRE>
<P>
This routine returns a chunk array containing the dword ID numbers of all notes whose titles match the passed search string, preceded by the number of matching notes. If no such notes are found, then the returned handle will be NULL.</P>
<P>
Note that this routine will only return about 20K notes; if there are more that match, only the first 20K will be returned.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
pen.goh</STRONG>
 </P>
</DIV>
<HR>
<A NAME="R_60.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_60.htm_IX_InkNoteGetCreationDate()">
 </A>
<H1 CLASS="refHeading">
InkNoteGetCreationDate()</H1>
<PRE CLASS="syntax">dword 	InkNoteGetCreationDate( 
        dword 		tag,		/* ID# of note */
        VMFileHandle		fh);		/* Handle of Ink DB file */</PRE>
<P>
This routine gets a note's creation date.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
pen.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_60.htm_IX_InkNoteGetKeywords()">
 </A>
<H1 CLASS="refHeading">
InkNoteGetKeywords()</H1>
<PRE CLASS="syntax">void 	InkNoteGetKeywords(
        dword 		tag, 		/* ID# of note */
        VMFileHandle 		fh,		/* Handle of Ink DB file */
        char *		text); 		/* String to hold return value */);</PRE>
<P>
This routine fills the passed buffer with the note's keywords. The target buffer should be of atleast length INK_DB_MAX_NOTE_KEYWORDS_SIZE +1. The string will be null-terminated.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
pen.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_60.htm_IX_InkNoteGetModificationDate()">
 </A>
<H1 CLASS="refHeading">
InkNoteGetModificationDate()</H1>
<PRE CLASS="syntax">dword 	InkNoteGetModificationDate( 
        dword 		tag,		/* ID# of note */
        VMFileHandle		fh);		/* Handle of Ink DB file */</PRE>
<P>
This routine gets a note's modification date.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
pen.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_60.htm_IX_InkNoteGetNoteType()">
 </A>
<H1 CLASS="refHeading">
InkNoteGetNoteType()</H1>
<PRE CLASS="syntax">NoteType 	InkNoteGetNoteType( /* 0: Ink, 1: Text */
        dword 		tag,		/* ID# of note */
        VMFileHandle		fh);		/* Handle of Ink DB file */</PRE>
<P>
This routine gets a note's <CODE>
NoteType</CODE>
: NT_INK or NT_TEXT.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
pen.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_60.htm_IX_InkNoteGetNumPages()">
 </A>
<H1 CLASS="refHeading">
InkNoteGetNumPages()</H1>
<PRE CLASS="syntax">word 	InkNoteGetNumPages(
        dword 		tag);		/* ID# of note */</PRE>
<P>
This routine returns the number of pages within the passed note.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
pen.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_60.htm_IX_InkNoteGetPages()">
 </A>
<H1 CLASS="refHeading">
InkNoteGetPages()</H1>
<PRE CLASS="syntax">DBGroupAndItem 	InkNoteGetPages(
        dword 		tag,		/* ID# of note */
        VMFileHandle		fh);		/* Handle of Ink DB file */</PRE>
<P>
This routine returns a DB group and item containing a chunk array. The chunk array contains the page information of the note, either compressed pen data or text. Each array element holds one page of data.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
pen.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_60.htm_IX_InkNoteLoadPage()">
 </A>
<H1 CLASS="refHeading">
InkNoteLoadPage()</H1>
<PRE CLASS="syntax">void 	InkNoteLoadPage(
        dword 		tag,		/* ID# of note */
        VMFileHandle		fh,		/* Handle of Ink DB file */
        word 		page, 		/* Page number */
        optr 		obj, 		/* an Ink or VisText object */
        word 		type);		/* note type 0: ink, 1: text */</PRE>
<P>
This routine loads a visual object (Ink or Text) with the contents of the passed Ink Database page. Be sure to load only the correct type of data into an object.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
pen.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_60.htm_IX_InkNoteMove()">
 </A>
<H1 CLASS="refHeading">
InkNoteMove()</H1>
<PRE CLASS="syntax">void 	InkNoteMove(
        dword 		tag, 			/* ID# of note */
        dword 		pfolder, 			/* ID# of new parent folder */
        VMFileHandle 		fh);			/* Handle of Ink DB file */</PRE>
<P>
This message moves the passed note to a new location. All references to the note are suitably altered.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
pen.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_60.htm_IX_InkNoteSavePage()">
 </A>
<H1 CLASS="refHeading">
InkNoteSavePage()</H1>
<PRE CLASS="syntax">void 	InkNoteSavePage(
        dword 		tag,		/* ID# of note */
        VMFileHandle		fh,		/* Handle of Ink DB file */
        word 		page, 		/* Page number */
        optr 		obj, 		/* an Ink or VisText object */
        word 		type);		/* note type 0: ink, 1: text */</PRE>
<P>
This routine saves the contents of a visual object (Ink or Text) to the passed Ink Database page.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
pen.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_60.htm_IX_InkNoteSendKeywordsToTextObject()">
 </A>
<H1 CLASS="refHeading">
InkNoteSendKeywordsToTextObject()</H1>
<PRE CLASS="syntax">void 	InkNoteSendKeywordsToTextObject(
        dword 		tag, 		/* ID# of note */
        VMFileHandle 		fh,		/* Handle of Ink DB file */
        optr		text); 		/* Text object to set */);</PRE>
<P>
This message replaces the passed VisText object's text with the keywords from the passed folder or note of an Ink Database file.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
pen.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_60.htm_IX_InkNoteSetKeywords()">
 </A>
<H1 CLASS="refHeading">
InkNoteSetKeywords()</H1>
<PRE CLASS="syntax">void 	InkNoteSetKeywords(
        dword 		tag, 			/* ID# of note */
        VMFileHandle 		fh,			/* Handle of Ink DB file */
        const char *		text); 			/* Keyword string */);</PRE>
<P>
This message sets an Ink Database note's keywords. The passed string should be null-terminated.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
pen.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_60.htm_IX_InkNoteSetKeywordsFromTextObject()">
 </A>
<H1 CLASS="refHeading">
InkNoteSetKeywordsFromTextObject()</H1>
<PRE CLASS="syntax">void 	InkNoteSetKeywordsFromTextObject(
        dword 		tag, 			/* ID# of note */
        VMFileHandle 		fh,			/* Handle of Ink DB file */
        optr *		text); 			/* Text object */);</PRE>
<P>
This message sets an Ink Database note's keywords by copying them from the passed text object.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
pen.goh</STRONG>
 </P>
</DIV>
<HR>
<A NAME="R_61.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_61.htm_IX_InkNoteSetModificationDate()">
 </A>
<H1 CLASS="refHeading">
InkNoteSetModificationDate()</H1>
<PRE CLASS="syntax">void 	InkNoteSetModificationDate( 
        word		tdft1, 		/* First two words of */
        word		tdft2,		/*   TimerDateAndTime structure */
        dword 		note,		/* ID# of note */
        FileHandle		fh);		/* Handle of Ink DB file */</PRE>
<P>
This routine sets a note's modification date.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
pen.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_61.htm_IX_InkNoteSetNoteType()">
 </A>
<H1 CLASS="refHeading">
InkNoteSetNoteType()</H1>
<PRE CLASS="syntax">void 	InkNoteSetNoteType( 
        dword 		tag,		/* ID# of note */
        VMFileHandle		fh,		/* Handle of Ink DB file */
        NoteType 		nt);		/* NT_INK or NT_TEXT */</PRE>
<P>
This routine sets a note's type: text or ink.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
pen.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_61.htm_IX_InkNoteSetTitle()">
 </A>
<H1 CLASS="refHeading">
InkNoteSetTitle()</H1>
<PRE CLASS="syntax">void 	InkNoteSetTitle(
        dword 		tag, 			/* ID# of note */
        VMFileHandle 		fh,			/* Handle of Ink DB file */
        const char *		name); 			/* Text object */);</PRE>
<P>
This message renames an Ink Database note. The passed name should be null-terminated. The string may be up to INK_DB_MAX_NOTE_KEYWORDS_SIZE +1 in length.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
pen.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_61.htm_IX_InkNoteSetTitleFromTextObject()">
 </A>
<H1 CLASS="refHeading">
InkNoteSetTitleFromTextObject()</H1>
<PRE CLASS="syntax">void 	InkNoteSetTitleFromTextObject(
        dword 		tag, 		/* ID# of note */
        FileHandle 		fh,		/* Handle of Ink DB file */
        optr		text); 		/* Text object */);</PRE>
<P>
This message sets the name of the passed Ink Database note from the contents of the passed VisText object.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
pen.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_61.htm_IX_InkSendTitleToTextObject()">
 </A>
<H1 CLASS="refHeading">
InkSendTitleToTextObject()</H1>
<PRE CLASS="syntax">void 	InkSendTitleToTextObject(
        dword 		tag, 		/* ID# of folder or note */
        VMFileHandle 		fh,		/* Handle of Ink DB file */
        optr		to); 		/* Text object to set */);</PRE>
<P>
This message replaces the passed VisText object's text with the name from the passed folder or note of an Ink Database file.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
pen.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_61.htm_IX_InkSetDocCustomGString()">
 </A>
<H1 CLASS="refHeading">
InkSetDocCustomGString()</H1>
<PRE CLASS="syntax">void	InkSetDocCustomGString(
        VMFileHandle 		dbfh,
        Handle		gstring);</PRE>
<P>
This routine sets the custom GString to use as a background for the passed Ink Database file. Note that this custom background will only be used if the document's basic <CODE>
InkBackgroundType</CODE>
 is IBT_CUSTOM. (Set this using the <CODE>
<A HREF="../../CRef/Routines/R_61.htm#IX_InkSetDocGString()">InkSetDocGString()</A></CODE>
 routine.)</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
pen.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_61.htm_IX_InkSetDocGString()">
 </A>
<H1 CLASS="refHeading">
InkSetDocGString()</H1>
<PRE CLASS="syntax">void	InkSetDocGString(
        VMFileHandle 		dbfh,
        InkBackgroundType		type);</PRE>
<P>
This routine sets the standard GString to use as a background picture with the passed Ink Database file. If the passed background type is custom, be sure to also call <CODE>
<A HREF="../../CRef/Routines/R_61.htm#IX_InkSetDocCustomGString()">InkSetDocCustomGString()</A></CODE>
.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
pen.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_61.htm_IX_InkSetDocPageInfo()">
 </A>
<H1 CLASS="refHeading">
InkSetDocPageInfo()</H1>
<PRE CLASS="syntax">void 	InkSetDocPageInfo(
        PageSizeReport *		psr,
        VMFileHandle 		fh);</PRE>
<P>
Set the page information for an Ink Database file.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
pen.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_61.htm_IX_IntegerOf()">
 </A>
<H1 CLASS="refHeading">
IntegerOf()</H1>
<PRE CLASS="syntax">word	IntegerOf(
        WWFixedAsDWord		wwf)</PRE>
<P>
This macro returns the integral portion of a <CODE>
WWFixedAsDWord</CODE>
 value.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
geos.h</STRONG>
 </P>
</DIV>
<HR>
<A NAME="R_62.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_62.htm_IX_isalnum()">
 </A>
<H1 CLASS="refHeading">
isalnum()</H1>
<PRE CLASS="syntax">int	LocalIsAlphaNumeric(
        int	__C);</PRE>
<P>
This routine returns <EM>
true</EM>
 if the passed character is alphanumeric.</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	If you pass a char to this routine, beware: the routine takes an integer, and if the passed value gets sign-extended, the result may not be what you expect.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
localize.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_62.htm_IX_isalpha()">
 </A>
<H1 CLASS="refHeading">
isalpha()</H1>
<PRE CLASS="syntax">int	isalpha(
        int	__C);</PRE>
<P>
This routine returns <EM>
true</EM>
 if the passed character is alphabetic.</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	If you pass a char to this routine, beware: the routine takes an integer, and if the passed value gets sign-extended, the result may not be what you expect.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
localize.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_62.htm_IX_iscntrl()">
 </A>
<H1 CLASS="refHeading">
iscntrl()</H1>
<PRE CLASS="syntax">int	iscntrl(
        int	__C);</PRE>
<P>
This routine returns <EM>
true</EM>
 if the passed character is a control character.</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	If you pass a char to this routine, beware: the routine takes an integer, and if the passed value gets sign-extended, the result may not be what you expect.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
localize.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_62.htm_IX_isdigit()">
 </A>
<H1 CLASS="refHeading">
isdigit()</H1>
<PRE CLASS="syntax">int	isdigit(
        int	__c);</PRE>
<P>
This routine returns <EM>
true</EM>
 if the passed character is a decimal digit.</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	If you pass a char to this routine, beware: the routine takes an integer, and if the passed value gets sign-extended, the result may not be what you expect.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
localize.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_62.htm_IX_isgraphic()">
 </A>
<H1 CLASS="refHeading">
isgraph()</H1>
<PRE CLASS="syntax">int	isgraph(
        wint	__C);</PRE>
<P>
This routine returns <EM>
true</EM>
 if the passed character is displayable.</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	If you pass a char to this routine, beware: the routine takes an integer, and if the passed value gets sign-extended, the result may not be what you expect.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
localize.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_62.htm_IX_islower()">
 </A>
<H1 CLASS="refHeading">
islower()</H1>
<PRE CLASS="syntax">int	islower(
        int	__C);</PRE>
<P>
This routine returns <EM>
true</EM>
 if the passed character is a lower case alphabetic character.</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	If you pass a char to this routine, beware: the routine takes an integer, and if the passed value gets sign-extended, the result may not be what you expect.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
localize.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_62.htm_IX_isprint()">
 </A>
<H1 CLASS="refHeading">
isprint()</H1>
<PRE CLASS="syntax">int	isprint(
        int	__C);</PRE>
<P>
This routine returns <EM>
true</EM>
 if the passed character is printable (i.e. takes up a space when printing).</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	If you pass a char to this routine, beware: the routine takes an integer, and if the passed value gets sign-extended, the result may not be what you expect.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
localize.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_62.htm_IX_ispunct()">
 </A>
<H1 CLASS="refHeading">
ispunct()</H1>
<PRE CLASS="syntax">int	ispunct(
        int	__c);</PRE>
<P>
This routine returns <EM>
true</EM>
 if the passed character is a punctuation mark.</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	If you pass a char to this routine, beware: the routine takes an integer, and if the passed value gets sign-extended, the result may not be what you expect.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
localize.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_62.htm_IX_isspace()">
 </A>
<H1 CLASS="refHeading">
isspace()</H1>
<PRE CLASS="syntax">int	isspace(
        int	__c);</PRE>
<P>
This routine returns <EM>
true</EM>
 if the passed character is whitespace.</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	If you pass a char to this routine, beware: the routine takes an integer, and if the passed value gets sign-extended, the result may not be what you expect.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
localize.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_62.htm_IX_isupper()">
 </A>
<H1 CLASS="refHeading">
isupper()</H1>
<PRE CLASS="syntax">int	isupper(
        int	__c);</PRE>
<P>
This routine returns <EM>
true</EM>
 if the passed character is an upper case alphabetic character.</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	If you pass a char to this routine, beware: the routine takes an integer, and if the passed value gets sign-extended, the result may not be what you expect.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
localize.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_62.htm_IX_isxdigit()">
 </A>
<H1 CLASS="refHeading">
isxdigit()</H1>
<PRE CLASS="syntax">int	isxdigit(
        int	__C);</PRE>
<P>
This routine returns <EM>
true</EM>
 if the passed character is a hexadecimal digit.</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	If you pass a char to this routine, beware: the routine takes an integer, and if the passed value gets sign-extended, the result may not be what you expect.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
localize.h</STRONG>
 </P>
</DIV>
<HR>
<A NAME="R_63.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_63.htm_IX_LMemAlloc()">
 </A>
<H1 CLASS="refHeading">
LMemAlloc()</H1>
<PRE CLASS="syntax">ChunkHandle	 LMemAlloc(
        MemHandle		mh,			/* Handle of block containing heap */
        word		chunkSize);				/* Size of new chunk in bytes */</PRE>
<P>
This routine allocates a new chunk in the LMem heap. The heap must be locked or fixed. It allocates a chunk, expanding the chunk table if enccessary, and returns the chunk's handle. The chunk is not zero-initialized. If the chunk could not be allocated, it returns a null handle. Chunks are dword-aligned, so the chunk's actual size may be slightly larger than you request.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
lmem.h</STRONG>
 </P>
<P CLASS="refField"><STRONG>
Be Sure To:</STRONG>	Lock the block on the global heap (unless the block is fixed).</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	The heap may be compacted; thus, all pointers to chunks are invalidated. If LMF_NO_EXPAND is not set, the heap may be resized (and thus moved), thus invalidating all pointers to that block. Even fixed blocks can be resized and moved.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_63.htm#IX_LMemDeref()">LMemDeref()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_65.htm#IX_LMemReAlloc()">LMemReAlloc()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_63.htm_IX_LMemContract()">
 </A>
<H1 CLASS="refHeading">
LMemContract()</H1>
<PRE CLASS="syntax">void	LMemContract(
        MemHandle		mh);		/* Handle of LMem heap */</PRE>
<P>
This routine contracts an LMem heap; that is, it deletes all the free chunks, moves all the used chunks to the beginning of the heap (right after the chunk handle table), and resizes the block to free the unused space at the end. It's a good idea to call this routine if you have just freed a lot of chunks, since that will free up some of the global heap. The LMem heap is guaranteed not to move; however, all pointers to chunks will be invalidated.</P>
<P CLASS="refField"><STRONG>
Be Sure To:</STRONG>	Lock the block on the global heap (if it isn't fixed).</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
lmem.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_63.htm_IX_LMemDeleteAt()">
 </A>
<H1 CLASS="refHeading">
LMemDeleteAt()</H1>
<PRE CLASS="syntax">void	LMemDeleteAt(
        optr	chunk,				/* Chunk to resize */
        word	deleteOffset,				/* Offset within chunk of first 
					 * byte to be deleted */</PRE>
<PRE CLASS="syntax">        word	deleteCount);				/* # of bytes to delete */</PRE>
<P>
This routine deletes a specified number of bytes from inside a chunk. It is guaranteed not to cause the heap to be resized or compacted; thus, pointers to other chunks remain valid.</P>
<P CLASS="refField"><STRONG>
Be Sure To:</STRONG>	Lock the block on the global heap (unless it is fixed).</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	The bytes you delete must all be in the chunk. If <CODE>
deleteOffset</CODE>
 and <CODE>
deleteCount</CODE>
 indicate bytes that are not in the chunk, results are undefined.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
lmem.h</STRONG>
 </P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_65.htm#IX_LMemReAlloc()">LMemReAlloc()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_64.htm#IX_LMemInsertAt()">LMemInsertAt()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_63.htm#IX_LMemDeleteAtHandles()">LMemDeleteAtHandles()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_63.htm_IX_LMemDeleteAtHandles()">
 </A>
<H1 CLASS="refHeading">
LMemDeleteAtHandles()</H1>
<PRE CLASS="syntax">void	LMemDeleteAtHandles(
        MemHandle		mh,				/* Handle of LMem heap */
        ChunkHandle		ch,				/* Handle of chunk to resize */
        word		deleteOffset,				/* Offset within chunk of first 
						 * byte to be deleted */</PRE>
<PRE CLASS="syntax">        word		deleteCount);				/* # of bytes to delete */</PRE>
<P>
This routine is exactly like <CODE>
<A HREF="../../CRef/Routines/R_63.htm#IX_LMemDeleteAt()">LMemDeleteAt()</A></CODE>
 above, except that the chunk is specified by its global and chunk handles.</P>
<P CLASS="refField"><STRONG>
Be Sure To:</STRONG>	Lock the block on the global heap (unless it is fixed).</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	The bytes you delete must all be in the chunk. If <CODE>
deleteOffset</CODE>
 and <CODE>
deleteCount</CODE>
 indicate bytes that are not in the chunk, results are undefined.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
lmem.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_63.htm_IX_LMemDeref()">
 </A>
<H1 CLASS="refHeading">
LMemDeref()</H1>
<PRE CLASS="syntax">void *	LMemDeref(
        optr	chunk);	/* optr to chunk to dereference */</PRE>
<P>
This routine translates an optr into the address of the chunk. The LMem heap must be locked or fixed on the global heap. Chunk addresses can be invalidated by many LMem routines, forcing you to dereference the optr again.</P>
<P CLASS="refField"><STRONG>
Be Sure To:</STRONG>	Lock the block on the global heap (unless it is fixed).</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
lmem.h</STRONG>
 </P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_63.htm#IX_LMemDerefHandles()">LMemDerefHandles()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_63.htm_IX_LMemDerefHandles()">
 </A>
<H1 CLASS="refHeading">
LMemDerefHandles()</H1>
<PRE CLASS="syntax">void *	LMemDerefHandles(
        MemHandle		mh,				/* Handle of LMem heap's block */
        ChunkHandle		chunk);				/* Handle of chunk to dereference */</PRE>
<P>
This routine is exactly like <CODE>
<A HREF="../../CRef/Routines/R_63.htm#IX_LMemDeref()">LMemDeref()</A></CODE>
 above, except that the chunk is specified by its global and chunk handles.</P>
<P CLASS="refField"><STRONG>
Be Sure To:</STRONG>	Lock the block on the global heap (unless it is fixed).</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
lmem.h</STRONG>
 </P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_63.htm#IX_LMemDeref()">LMemDeref()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_63.htm_IX_LMemFree()">
 </A>
<H1 CLASS="refHeading">
LMemFree()</H1>
<PRE CLASS="syntax">void	LMemFree(
        optr	chunk);				/*optr of chunk to free */</PRE>
<P>
This routine frees a chunk from an LMem heap. The chunk is added to the heap's free list. The routine is guaranteed not to compact or resize the heap; thus, all pointers within the block remain valid (except for pointers to data in the freed chunk, of course).</P>
<P CLASS="refField"><STRONG>
Be Sure To:</STRONG>	Lock the block on the global heap (unless it is fixed).</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
lmem.h</STRONG>
 </P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_63.htm#IX_LMemFreeHandles()">LMemFreeHandles()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_63.htm_IX_LMemFreeHandles()">
 </A>
<H1 CLASS="refHeading">
LMemFreeHandles()</H1>
<PRE CLASS="syntax">void	LMemFreeHandles(
        MemHandle		mh,				/* Handle of LMem heap */
        ChunkHandle		chunk);				/* Handle of chunk to free */</PRE>
<P>
This routine is just like <CODE>
<A HREF="../../CRef/Routines/R_63.htm#IX_LMemFree()">LMemFree()</A></CODE>
 above, except that the chunk is specified by its global and chunk handles (instead of by an optr).</P>
<P CLASS="refField"><STRONG>
Be Sure To:</STRONG>	Lock the block on the global heap (unless it is fixed).</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
lmem.h</STRONG>
 </P>
</DIV>
<HR>
<A NAME="R_64.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_64.htm_IX_LMemGetChunkSize()">
 </A>
<H1 CLASS="refHeading">
LMemGetChunkSize()</H1>
<PRE CLASS="syntax">word	LMemGetChunkSize(
        optr	chunk);					/* optr of subject chunk */</PRE>
<P>
This routine returns the size (in bytes) of a chunk in an LMem heap. Since LMem chunks are dword-aligned, the chunk's size may be slightly larger than the size specified when it was allocated. The routine is guaranteed not to compact or resize the heap; thus, all pointers within the block remain valid.</P>
<P CLASS="refField"><STRONG>
Be Sure To:</STRONG>	Lock the block on the global heap (unless it is fixed).</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
lmem.h</STRONG>
 </P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_64.htm#IX_LMemGetChunkSizeHandles()">LMemGetChunkSizeHandles()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_64.htm_IX_LMemGetChunkSizeHandles()">
 </A>
<H1 CLASS="refHeading">
LMemGetChunkSizeHandles()</H1>
<PRE CLASS="syntax">word	Routine(
        MemHandle		mh,				/* Handle of LMem heap */
        ChunkHandle		chunk);				/* Handle of chunk in question */</PRE>
<P>
This routine is just like <CODE>
<A HREF="../../CRef/Routines/R_64.htm#IX_LMemGetChunkSize()">LMemGetChunkSize()</A></CODE>
 above, except that the chunk is specified by its global and chunk handles (instead of by an optr).</P>
<P CLASS="refField"><STRONG>
Be Sure To:</STRONG>	Lock the block on the global heap (unless it is fixed).</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
lmem.h</STRONG>
 </P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_64.htm#IX_LMemGetChunkSize()">LMemGetChunkSize()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_64.htm_IX_LMemInitHeap()">
 </A>
<A NAME="R_64.htm_IX_LMemType:with LMemInitHeap()">
 </A>
<A NAME="R_64.htm_IX_LocalMemoryFlags">
 </A>
<A NAME="R_64.htm_IX_LMF_&ldots;">
 </A>
<H1 CLASS="refHeading">
LMemInitHeap()</H1>
<PRE CLASS="syntax">void	LMemInitHeap(
        MemHandle		mh,				/* Handle of (locked or fixed)
						 * block which will contain heap 	*/</PRE>
<PRE CLASS="syntax">        LMemType		type,				/* Type of heap to create */
        LocalMemoryFlags		flags,				/* Record of LocalMemoryFlags */
        word		lmemOffset,				/* Offset of first chunk in heap */
        word		numHandles,				/* Size of starter handle table */
        word		freeSpace);				/* Size of first free chunk 
						 * created */</PRE>
<P>
This routine creates an LMem heap in a global memory block. The block must be locked or fixed in memory. The routine initializes the <CODE>
LMemBlockHeader</CODE>
, creates a handle table, allocates a single free chunk, and turns on the HF_LMEM flag for the block. The block will be reallocated if necessary to make room for the heap. The routine takes six arguments:</P>
<DL>
<DT>
<CODE>
mh</CODE>
</DT><DD>The memory block's handle</DD>
<DT>
<CODE>
type</CODE>
</DT><DD>A member of the <CODE>
LMemType </CODE>
enumerated type, specifying the kind of block to create. For most applications, this will be LMEM_TYPE_GENERAL.</DD>
<DT>
<CODE>
flags</CODE>
</DT><DD>A record of <CODE>
LocalMemoryFlags</CODE>
, specifying certain properties of the heap. Most applications will pass a null record.</DD>
<DT>
<CODE>
lmemOffset</CODE>
</DT><DD>The offset within the block at which to start the heap. This must be larger than the size of the <CODE>
LMemBlockHeader</CODE>
 structure which begins every heap block. Any space between the <CODE>
LMemBlockHeader</CODE>
 and the heap is left untouched by all LMem routines. Usually you can just pass sizeof(<CODE>
LMemBlockHeader</CODE>
) as this argument, or sizeof(<CODE>
ObjLMemBlockHeader</CODE>
) for object blocks.</DD>
<DT>
<CODE>
numHandles</CODE>
</DT><DD>The number of entries to create in the block's chunk handle table. The chunk handle table will grow automatically when all entries have been used up. Applications should generally pass the constant STD_INIT_HANDLES; they should definitely pass a positive number.</DD>
<DT>
<CODE>
freeSpace</CODE>
</DT><DD>The amount of space to allocate to the first free chunk. Applications should generally pass the constant STD_INIT_HEAP; they should definitely pass a positive number.</DD>
</DL>
<P>
To destroy an LMem heap, call <CODE>
<A HREF="../../CRef/Routines/R_6c.htm#IX_MemFree()">MemFree()</A></CODE>
 to free the block containing the heap.</P>
<P CLASS="refField"><STRONG>
Structures:</STRONG>	There are two special data types used by this routine: <CODE>
LMemType</CODE>
 and <CODE>
LocalMemoryFlags</CODE>
.</P>
<P>
LMem heaps are created for many different purposes. Some of these purposes require the heap to have special functionality. For this reason, you must pass a member of the <CODE>
LMemType</CODE>
 enumerated type to specify the kind of heap to create. The following types can be used; other types exist but should not be used with <CODE>
LMemInitHeap()</CODE>
.</P>
<DL>
<DT>
LMEM_TYPE_GENERAL</DT><DD>
Ordinary heap. Most application LMem heaps will be of this type.</DD>
<DT>
LMEM_TYPE_OBJ_BLOCK</DT><DD>
The heap will contain object instance chunks.</DD>
</DL>
<P>
When an LMem heap is created, you must pass a record of flags to <CODE>
LMemInitHeap()</CODE>
 to indicate how the heap should be treated. Most of the <CODE>
LocalMemoryFlags</CODE>
 are only passed by system routines; the flags available for this routine are: LMF_HAS_FLAGS, LMF_DETACHABLE, LMF_NO_ENLARGE, LMF_RETURN_ERRORS. The flags can be read by examining the <CODE>
LMemBlockHeader</CODE>
 structure at the beginning of the block. Ordinarily, general LMem heaps will have all flags cleared.</P>
<P CLASS="refField"><STRONG>
Tips and Tricks:</STRONG>	If you want a fixed data space after the header, declare a structure whose first element is an <CODE>
LMemBlockHeader</CODE>
 and whose other fields are for the data you will store in the fixed data space. Pass the size of this structure as the <EM>
LMemOffset</EM>
 argument. You can now access the fixed data area by using the fields of the structure.</P>
<P CLASS="refField"><STRONG>
Be Sure To:</STRONG>	Pass an offset at least as large as <CODE>
sizeof(LMemBlockHeader)</CODE>
. If you pass an offset that is too small, the results are undefined. Lock the block on the global heap before calling this routine (unless the block is fixed).</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	The block may be relocated, if its initial size is too small to accommodate the heap. This is true even for fixed blocks. If the flag LMF_NO_ENLARGE is set, the block will never be relocated; however, you must make sure it starts out large enough to accommodate the entire heap.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
lmem.h</STRONG>
 </P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Structs/S_25.htm#IX_LMemBlockHeader">LMemBlockHeader</A></CODE>,
<CODE><A HREF="../../CRef/Structs/S_26.htm#IX_LMemType">LMemType</A></CODE>,
<CODE><A HREF="../../CRef/Structs/S_26.htm#IX_LocalMemoryFlags">LocalMemoryFlags</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_6b.htm#IX_MemAlloc()">MemAlloc()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_6b.htm#IX_MemAllocLMem()">MemAllocLMem()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_6c.htm#IX_MemFree()">MemFree()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_a1.htm#IX_VMAllocLMem()">VMAllocLMem()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_64.htm_IX_LMemInsertAt()">
 </A>
<H1 CLASS="refHeading">
LMemInsertAt()</H1>
<PRE CLASS="syntax">void	LMemInsertAt(
        optr	chunk,				/* optr of chunk to resize */
        word	insertOffset,				/* Offset within chunk of first byte
					 * to be added */</PRE>
<PRE CLASS="syntax">        word	insertCount);				/* # of bytes to add */</PRE>
<P>
This routine inserts space in the middle of a chunk and zero-initializes the new space. The first new byte will be at the specified offset within the chunk. </P>
<P CLASS="refField"><STRONG>
Be Sure To:</STRONG>	Lock the block on the global heap (unless it is fixed). Make sure the offset is within the specified chunk.</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	This routine may resize or compact the heap; thus, all pointers to data within the block are invalidated.</P>
<P>
You must pass an <CODE>
insertOffset</CODE>
 that is actually within the chunk; if the offset is out-of-bounds, results are undefined.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
lmem.h</STRONG>
 </P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_65.htm#IX_LMemReAlloc()">LMemReAlloc()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_63.htm#IX_LMemDeleteAt()">LMemDeleteAt()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_64.htm#IX_LMemInsertAtHandles()">LMemInsertAtHandles()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_64.htm_IX_LMemInsertAtHandles()">
 </A>
<H1 CLASS="refHeading">
LMemInsertAtHandles()</H1>
<PRE CLASS="syntax">void	LMemInsertAtHandles(
        MemHandle		mh,				/* Handle of LMem heap */
        ChunkHandle		chunk,				/* Chunk to resize */
        word		insertOffset,				/* Offset within chunk of first byte
						 * to be added */</PRE>
<PRE CLASS="syntax">        word		insertCount);				/* # of bytes to add */</PRE>
<P>
This routine is just like <CODE>
<A HREF="../../CRef/Routines/R_64.htm#IX_LMemInsertAt()">LMemInsertAt()</A></CODE>
 above, except that the chunk is specified by its global and chunk handles (instead of by an optr).</P>
<P CLASS="refField"><STRONG>
Be Sure To:</STRONG>	Lock the block on the global heap (unless it is fixed). Make sure the offset is within the specified chunk.</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	This routine may resize or compact the heap; thus, all pointers to data within the block are invalidated.</P>
<P>
You must pass an <CODE>
insertOffset</CODE>
 that is actually within the chunk; if the offset is out-of-bounds, results are undefined.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
lmem.h</STRONG>
 </P>
</DIV>
<HR>
<A NAME="R_65.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_65.htm_IX_LMemReAlloc()">
 </A>
<H1 CLASS="refHeading">
LMemReAlloc()</H1>
<PRE CLASS="syntax">Boolean	LMemReAlloc(
        optr	chunk,				/* optr of chunk to resize */
        word	chunkSize);				/* New size of chunk in bytes */</PRE>
<P>
This routine resizes a chunk in an LMem heap. The heap must be in a locked or fixed block. If the routine succeeds, it returns zero. If it fails (because the heap ran out of space and could not be expanded), it returns non-zero.</P>
<P>
If the new size is larger than the original size, extra bytes will be added to the end of the chunk. These bytes will not be zero-initialized. The heap may have to be compacted or resized to accommodate the request; thus, all pointers to data within the block are invalidated. </P>
<P>
If the new size is smaller than the old, the chunk will be truncated. The request is guaranteed to succeed, and the chunk will not be moved; neither will the heap be compacted or resized. Thus, all pointers to other chunks remain valid. Reallocating a chunk to zero bytes is the same as freeing it.</P>
<P CLASS="refField"><STRONG>
Be Sure To:</STRONG>	Lock the block on the global heap (unless it is fixed).</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	As noted, if the new size is larger than the old, the heap may be compacted or resized, invalidating pointers.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
lmem.h</STRONG>
 </P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_65.htm#IX_LMemReAllocHandles()">LMemReAllocHandles()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_64.htm#IX_LMemInsertAt()">LMemInsertAt()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_63.htm#IX_LMemDeleteAt()">LMemDeleteAt()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_65.htm_IX_LMemReAllocHandles()">
 </A>
<H1 CLASS="refHeading">
LMemReAllocHandles()</H1>
<PRE CLASS="syntax">Boolean	LMemReAllocHandles(
        MemHandle		mh,				/* Handle of LMem heap */
        ChunkHandle		chunk,				/* Handle of chunk to resize */
        word		chunkSize);				/* New size of chunk in bytes */</PRE>
<P>
This routine is just like <CODE>
<A HREF="../../CRef/Routines/R_65.htm#IX_LMemReAlloc()">LMemReAlloc()</A></CODE>
 above, except that the chunk is specified by its global and chunk handles (instead of by an optr).</P>
<P CLASS="refField"><STRONG>
Be Sure To:</STRONG>	Lock the block on the global heap (unless it is fixed).</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	As noted, if the new size is larger than the old, the heap may be compacted or resized, invalidating pointers.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
lmem.h</STRONG>
 </P>
</DIV>
<HR>
<A NAME="R_66.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_66.htm_IX_LocalAsciiToFixed()">
 </A>
<H1 CLASS="refHeading">
LocalAsciiToFixed()</H1>
<PRE CLASS="syntax">WWFixedAsDWord LocalAsciiToFixed(
        const char *		buffer,
        char **		parseEnd);</PRE>
<P>
This routines converts a string like &quot;12.345&quot; to a fixed point number. The pointer pointed to by <EM>
parseEnd</EM>
 will be returned pointing into the buffer after the last character parsed.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
localize.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_66.htm_IX_LocalCalcDaysInMonth()">
 </A>
<H1 CLASS="refHeading">
LocalCalcDaysInMonth()</H1>
<PRE CLASS="syntax">word 	LocalCalcDaysInMonth(
        word 	year, 
        word 	month);</PRE>
<P>
This routine computes the number of days in a given month.</P>
</DIV>
<DIV>
<A NAME="R_66.htm_IX_LocalCmpStrings()">
 </A>
<H1 CLASS="refHeading">
LocalCmpStrings()</H1>
<PRE CLASS="syntax">sword	LocalCmpStrings(
        const char *		str1,
        const char *		<EM>str2</EM>,
        word		strSize);</PRE>
<P>
This routine compares two strings to determine which comes first in a lexical (i.e. alphabetic) ordering. If the return value is negative, then <EM>
str1</EM>
 is earlier than <EM>
str2</EM>
. If the return value is positive, then <EM>
str1</EM>
 is later than <EM>
str2</EM>
. If the return value is zero, then the strings appear at the same place in alphabetical order.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
localize.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_66.htm_IX_LocalCmpStringsDosToGeos()">
 </A>
<A NAME="R_66.htm_IX_LocalCmpStringsDosToGeosFlags">
 </A>
<A NAME="R_66.htm_IX_LCSDTG_NO_CONVERT_STRING_&ldots;">
 </A>
<H1 CLASS="refHeading">
LocalCmpStringsDosToGeos()</H1>
<PRE CLASS="syntax">sword	LocalCmpStringsDosToGeos(
        const char *					str1,
        const char *					str2,
        word					strSize,
        word					defaultChar,
        LocalCmpStringsDosToGeosFlags 					flags);</PRE>
<P>
This routine compares two strings to determine which comes first in lexical ordering. Either or both of these strings may be a DOS string.  If the return value is negative, then <EM>
str1</EM>
 is earlier than <EM>
str2</EM>
. If the return value is positive, then <EM>
str1</EM>
 is later than <EM>
str2</EM>
. If the return value is zero, then the strings appear at the same place in alphabetical order.</P>
<P CLASS="refField"><STRONG>
Structures:</STRONG>	</P>
<PRE CLASS="syntax">        typedef ByteFlags LocalCmpStringsDosToGeosFlags;
/* The following flags may be combined using | and &amp;:
 * 		LCSDTG_NO_CONVERT_STRING_2,
 * 		LCSDTG_NO_CONVERT_STRING_1 */</PRE>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
localize.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_66.htm_IX_LocalCmpStringsNoCase()">
 </A>
<H1 CLASS="refHeading">
LocalCmpStringsNoCase()</H1>
<PRE CLASS="syntax">sword	LocalCmpStringsNoCase(
        const char *		str1,
        const char *		str2,
        word		strSize);</PRE>
<P>
This routine compares two strings to determine which comes first in a lexical (i.e. alphabetic) ordering. The comparison used is not case-sensitive.  If the return value is negative, then <EM>
str1</EM>
 is earlier than <EM>
str2</EM>
. If the return value is positive, then <EM>
str1</EM>
 is later than <EM>
str2</EM>
. If the return value is zero, then the strings appear at the same place in alphabetical order.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
localize.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_66.htm_IX_LocalCmpStringsNoSpace()">
 </A>
<H1 CLASS="refHeading">
LocalCmpStringsNoSpace()</H1>
<PRE CLASS="syntax">sword 	LocalCmpStringsNoSpace(
        const char 		*str1, 
        const char 		*str2, 
        word 		strSize);</PRE>
<P>
This routine compares two strings to determine which comes first in a lexical (i.e. alphabetic) ordering. The comparison ignores spaces.  If the return value is negative, then <EM>
str1</EM>
 is earlier than <EM>
str2</EM>
. If the return value is positive, then <EM>
str1</EM>
 is later than <EM>
str2</EM>
. If the return value is zero, then the strings appear at the same place in alphabetical order.</P>
</DIV>
<DIV>
<A NAME="R_66.htm_IX_LocalCmpStringsNoSpaceCase()">
 </A>
<H1 CLASS="refHeading">
LocalCmpStringsNoSpaceCase()</H1>
<PRE CLASS="syntax">sword 	LocalCmpStringsNoSpaceCase(
        const char 		*str1, 
        const char 		*str2, 
        word 		strSize);</PRE>
<P>
This routine compares two strings to determine which comes first in a lexical (i.e. alphabetic) ordering. The comparison ignores spaces and is case-insensitive.  If the return value is negative, then <EM>
str1</EM>
 is earlier than <EM>
str2</EM>
. If the return value is positive, then <EM>
str1</EM>
 is later than <EM>
str2</EM>
. If the return value is zero, then the strings appear at the same place in alphabetical order.</P>
</DIV>
<DIV>
<A NAME="R_66.htm_IX_LocalCodePageToGeos()">
 </A>
<H1 CLASS="refHeading">
LocalCodePageToGeos()</H1>
<PRE CLASS="syntax">Boolean	LocalCodePageToGeos(
        char *		str,
        word		strSize,			/* Size of the string, in bytes */
        DosCodePage 		codePage,
        word		defaultChar);</PRE>
<P>
This routine converts a DOS string to standard GEOS text using a specified code page. Any characters for which there is no GEOS equivalent will be replaced by the passed default character.  </P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
localize.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_66.htm_IX_LocalCodePageToGeosChar()">
 </A>
<H1 CLASS="refHeading">
LocalCodePageToGeosChar()</H1>
<PRE CLASS="syntax">word	LocalCodePageToGeosChar(
        word	ch,
        DosCodePage codePage,
        word	defaultChar);</PRE>
<P>
This routine converts a DOS character to standard GEOS text using a specified code page. Any character for which there is no GEOS equivalent will be replaced by the passed default character.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
localize.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_66.htm_IX_LocalCustomFormatDateTime()">
 </A>
<H1 CLASS="refHeading">
LocalCustomFormatDateTime()</H1>
<PRE CLASS="syntax">word	LocalCustomFormatDateTime(
        char *	str,			/* Buffer to save formatted text in */
        const char *	format,			/* Format string */
        const	TimerDateAndTime *dateTime);</PRE>
<P>
This routine takes a date or time and constructs a string using a custom format. </P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
localize.h</STRONG>
 </P>
</DIV>
<HR>
<A NAME="R_67.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_67.htm_IX_LocalCustomParseDateTime()">
 </A>
<H1 CLASS="refHeading">
LocalCustomParseDateTime()</H1>
<PRE CLASS="syntax">word	LocalCustomParseDateTime(
        const char *		str,
        DateTimeFormat		format,
        TimerDateAndTime *		dateTime);</PRE>
<P>
This routine parses a date and time string by comparing it with the passed <CODE>
DateTimeFormat</CODE>
. It fills in the fields of the <CODE>
TimerDateAndTime</CODE>
 structure. Any fields which are not specified in the format string will be filled with -1.</P>
<P>
If the string parses correctly, <CODE>
LocalCustomParseDateTime()</CODE>
 returns -1. Otherwise it reutrns the offset to the start of the text which did not parse correctly.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
localize.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_67.htm_IX_LocalDistanceFromAscii()">
 </A>
<A NAME="R_67.htm_IX_Measurement:LocalDistanceFromAscii()">
 </A>
<H1 CLASS="refHeading">
LocalDistanceFromAscii()</H1>
<PRE CLASS="syntax">WWFixedAsDword 	LocalDistanceFromAscii( 
        const char *		buffer,
        DistanceUnit 		distanceUnits,
        MeasurementTypes		measurementType);</PRE>
<P>
This routine takes a function like &quot;72 pt&quot; and returns a number representing the distance. The returned answer represents the measure in points, inches, centimeters, or some other measure as specified by the passed unit.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
localize.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_67.htm_IX_LocalDistanceToAscii()">
 </A>
<A NAME="R_67.htm_IX_Measurement:LocalDistanceToAscii()">
 </A>
<H1 CLASS="refHeading">
LocalDistanceToAscii()</H1>
<PRE CLASS="syntax">word	LocalDistanceToAscii( /* Length of string, including NULL */
        char *		buffer,			/*Buffer to save formatted text in */
        word 		value,
        DistanceUnit 		distanceUnits,
        MeasurementType 		measurementType);</PRE>
<P>
This routine takes a distance and a set of units and returns a string containing a properly formatted distance.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
localize.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_67.htm_IX_LocalDosToGeos()">
 </A>
<H1 CLASS="refHeading">
LocalDosToGeos()</H1>
<PRE CLASS="syntax">Boolean	LocalDosToGeos(
        char *	str,
        word	strSize,
        word	defaultChar);</PRE>
<P>
Convert a DOS string to GEOS text. Any characters for which there is no GEOS equivalent will be replaced by the passed default character.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
localize.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_67.htm_IX_LocalDosToGeosChar()">
 </A>
<H1 CLASS="refHeading">
LocalDosToGeosChar()</H1>
<PRE CLASS="syntax">word	LocalDosToGeosChar(
        word	ch,
        word	defaultChar);</PRE>
<P>
Convert a DOS character to GEOS text. Any characters for which there is no GEOS equivalent will be replaced by the passed default character.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
localize.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_67.htm_IX_LocalDowncaseChar()">
 </A>
<H1 CLASS="refHeading">
LocalDowncaseChar()</H1>
<PRE CLASS="syntax">word	LocalDowncaseChar(
        word	ch);</PRE>
<P>
Return the lower case equivalent, if any, of the passed character.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
localize.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_67.htm_IX_LocalDowncaseString()">
 </A>
<H1 CLASS="refHeading">
LocalDowncaseString()</H1>
<PRE CLASS="syntax">void	LocalDowncaseString(
        char *	str,
        word	size);		/* Size of string, in bytes */</PRE>
<P>
Convert the passed string to its all lower case equivalent.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
localize.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_67.htm_IX_LocalFixedToAscii()">
 </A>
<H1 CLASS="refHeading">
LocalFixedToAscii()</H1>
<PRE CLASS="syntax">void	LocalFixedToAscii(
        char *	buffer,
        WWFixedAsDWord value,
        word	fracDigits);</PRE>
<P>
This routine returns the ASCII expression of a fixed point number.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
localize.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_67.htm_IX_LocalFormatDateTime()">
 </A>
<H1 CLASS="refHeading">
LocalFormatDateTime()</H1>
<PRE CLASS="syntax">word	LocalFormatDateTime( /* Length of returned string */
        char *			str,
        DateTimeFormat 			format,
        const TimerDateAndTime *	dateTime);</PRE>
<P>
This routine returns the string (e.g. &quot;9:37&quot;) corresponding to the passed DateAndTime.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
localize.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_67.htm_IX_LocalFormatFileDateTime()">
 </A>
<H1 CLASS="refHeading">
LocalFormatFileDateTime()</H1>
<PRE CLASS="syntax">word 	LocalFormatFileDateTime(
        char 			*str, 
        DateTimeFormat 			format,
        const FileDateAndTime 			*dateTime);</PRE>
<P>
This utility routine provides a simple way to present a <CODE>
FileDateAndTime</CODE>
 structure such as used with file-related operations.</P>
<P CLASS="refField"><STRONG>
Structures:</STRONG>	</P>
<PRE CLASS="syntax">        typedef struct {
            byte        numberFormatFlags; /* NumberFormatFlags value */
            byte        decimalDigits;
            wchar       thousandsSeparator;
            wchar       decimalSeparator;
            wchar       listSeparator;
        } LocalNumericFormat;</PRE>
<P>
The first byte is a <CODE>
NumberFormatFlags</CODE>
 field specifying whether or not to use a leading zero. The second byte is the number of digits to show after the decimal point. </P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
localize.h</STRONG>
 </P>
</DIV>
<HR>
<A NAME="R_68.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_68.htm_IX_LocalGeosToCodePage()">
 </A>
<H1 CLASS="refHeading">
LocalGeosToCodePage()</H1>
<PRE CLASS="syntax">Boolean	LocalGeosToCodePage(
        char *		str,
        word		strSize,
        DosCodePage 		codePage,
        word		defaultChar);</PRE>
<P>
Convert a GEOS string to DOS text, using the specified code page. Any characters for which there is no DOS equivalent will be replaced by the passed default character.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
localize.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_68.htm_IX_LocalGeosToCodePageChar()">
 </A>
<H1 CLASS="refHeading">
LocalGeosToCodePageChar()</H1>
<PRE CLASS="syntax">word	LocalGeosToCodePageChar(
        word		ch,
        DosCodePage 		codePage,
        word		defaultChar);</PRE>
<P>
Convert a GEOS character to DOS text, using the specified code page. Any character for which there is no DOS equivalent will be replaced by the passed default character.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
localize.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_68.htm_IX_LocalGeosToDos()">
 </A>
<H1 CLASS="refHeading">
LocalGeosToDos()</H1>
<PRE CLASS="syntax">Boolean	LocalGeosToDos(
        char *	str,
        word	strSize,
        word	defaultChar);</PRE>
<P>
Convert a GEOS string to DOS text. Any characters for which there is no DOS equivalent will be replaced by the passed default character.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
localize.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_68.htm_IX_LocalGeosToDosChar()">
 </A>
<H1 CLASS="refHeading">
LocalGeosToDosChar()</H1>
<PRE CLASS="syntax">word	LocalGeosToDosChar(
        word	ch,
        word	defaultChar);</PRE>
<P>
Convert a GEOS character to DOS text. Any character for which there is no DOS equivalent will be replaced by the passed default character.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
localize.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_68.htm_IX_LocalGetCodePage()">
 </A>
<H1 CLASS="refHeading">
LocalGetCodePage()</H1>
<PRE CLASS="syntax">DosCodePage LocalGetCodePage(void);</PRE>
<P>
This routine returns the current code page, used by DOS to handle international character sets.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
localize.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_68.htm_IX_LocalGetCurrencyFormat()">
 </A>
<H1 CLASS="refHeading">
LocalGetCurrencyFormat()</H1>
<PRE CLASS="syntax">void	LocalGetCurrencyFormat(
        LocalCurrencyFormat *			buf,
        char *			symbol);</PRE>
<P>
This routine returns the current currency format and symbol.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
localize.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_68.htm_IX_LocalGetDateTimeFormat()">
 </A>
<H1 CLASS="refHeading">
LocalGetDateTimeFormat()</H1>
<PRE CLASS="syntax">void	LocalGetDateTimeFormat(
        char *		str,
        DateTimeFormat 		format);</PRE>
<P>
This routine returns the user's preferred time and date formats.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
localize.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_68.htm_IX_LocalGetLanguage()">
 </A>
<H1 CLASS="refHeading">
LocalGetLanguage()</H1>
<PRE CLASS="syntax">word 	LocalGetLanguage(void); /* Returns a StandardLanguage value */</PRE>
<P>
This routine returns the user machine's language.</P>
</DIV>
<DIV>
<A NAME="R_68.htm_IX_LocalGetMeasurementType()">
 </A>
<H1 CLASS="refHeading">
LocalGetMeasurementType()</H1>
<PRE CLASS="syntax">MeasurementTypes LocalGetMeasurementType(void);</PRE>
<P>
This routine returns the user preference between US and metric measurement systems.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
localize.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_68.htm_IX_LocalGetNumericFormat()">
 </A>
<H1 CLASS="refHeading">
LocalGetNumericFormat()</H1>
<PRE CLASS="syntax">void	LocalGetNumericFormat(
        LocalNumericFormat *		buf);</PRE>
<P>
This routine returns the user's preferred format for numbers.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
localize.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_68.htm_IX_LocalGetQuotes()">
 </A>
<H1 CLASS="refHeading">
LocalGetQuotes()</H1>
<PRE CLASS="syntax">void	LocalGetQuotes(
        LocalQuotes *		quotes);</PRE>
<P>
This routine returns the user's preferred quote marks.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
localize.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_68.htm_IX_LocalIsDateChar()">
 </A>
<H1 CLASS="refHeading">
LocalIsDateChar()</H1>
<PRE CLASS="syntax">Boolean	LocalIsDateChar(
        word	ch);</PRE>
<P>
This routine returns <EM>
true</EM>
 if the passed character could be part of a date or time.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
localize.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_68.htm_IX_LocalIsDosChar()">
 </A>
<H1 CLASS="refHeading">
LocalIsDosChar()</H1>
<PRE CLASS="syntax">Boolean	LocalIsDosChar(
        word	ch);</PRE>
<P>
This routine returns <EM>
true</EM>
 if the passed character is part of the DOS character set.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
localize.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_68.htm_IX_LocalIsNumChar()">
 </A>
<H1 CLASS="refHeading">
LocalIsNumChar()</H1>
<PRE CLASS="syntax">Boolean	LocalIsNumChar(
        word	ch);</PRE>
<P>
This routine returns <EM>
true</EM>
 if the passed character is a number or part of the number format.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
localize.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_68.htm_IX_LocalIsSymbol()">
 </A>
<H1 CLASS="refHeading">
LocalIsSymbol()</H1>
<PRE CLASS="syntax">Boolean	LocalIsSymbol(
        word	ch);</PRE>
<P>
This routine returns <EM>
true</EM>
 if the passed character is a symbol.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
localize.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_68.htm_IX_LocalIsTimeChar()">
 </A>
<H1 CLASS="refHeading">
LocalIsTimeChar()</H1>
<PRE CLASS="syntax">Boolean	LocalIsTimeChar(
        word	ch);</PRE>
<P>
This routine returns <EM>
true</EM>
 if the passed character is a number or part of the user's time format.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
localize.h</STRONG>
 </P>
</DIV>
<HR>
<A NAME="R_69.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_69.htm_IX_LocalLexicalValue()">
 </A>
<H1 CLASS="refHeading">
LocalLexicalValue()</H1>
<PRE CLASS="syntax">word	LocalLexicalValue(
        word	ch);</PRE>
<P>
This routine returns the passed character's lexical value, useful when trying to sort strings alphabetically.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
localize.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_69.htm_IX_LocalLexicalValueNoCase()">
 </A>
<H1 CLASS="refHeading">
LocalLexicalValueNoCase()</H1>
<PRE CLASS="syntax">word	LocalLexicalValueNoCase(
        word	ch);</PRE>
<P>
This routine returns the passed character's case-insensitive lexical value, useful when trying to sort strings alphabetically.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
localize.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_69.htm_IX_LocalParseDateTime()">
 </A>
<H1 CLASS="refHeading">
LocalParseDateTime()</H1>
<PRE CLASS="syntax">Boolean	LocalParseDateTime(
        const char *		str,
        DateTimeFormat 		format,
        TimerDateAndTime *	dateTime);</PRE>
<P>
This routine takes a string describing a date or time (e.g. &quot;9:37&quot;)
and parses it using the passed format. It returns TRUE (-1) on success. On
failure it returns the offset to the start of the text that didn't match.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
localize.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_69.htm_IX_LocalSetCurrencyFormat()">
 </A>
<H1 CLASS="refHeading">
LocalSetCurrencyFormat()</H1>
<PRE CLASS="syntax">void	LocalSetCurrencyFormat(
        const LocalCurrencyFormat *				buf,
        const char *				symbol);</PRE>
<P>
This routine changes the stored preferred currency format.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
localize.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_69.htm_IX_LocalSetDateTimeFormat()">
 </A>
<H1 CLASS="refHeading">
LocalSetDateTimeFormat()</H1>
<PRE CLASS="syntax">void	LocalSetDateTimeFormat(
        const char *		str,
        DateTimeFormat 		format);</PRE>
<P>
This routine changes the stored preferred time and date format.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
localize.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_69.htm_IX_LocalSetMeasurementType()">
 </A>
<H1 CLASS="refHeading">
LocalSetMeasurementType()</H1>
<PRE CLASS="syntax">void	LocalSetMeasurementType(
        MeasurementTypes meas);</PRE>
<P>
This routine changes the stored preferred measurement type.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
localize.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_69.htm_IX_LocalSetNumericFormat()">
 </A>
<H1 CLASS="refHeading">
LocalSetNumericFormat()</H1>
<PRE CLASS="syntax">void	LocalSetNumericFormat(
        const LocalNumericFormat *				buf);</PRE>
<P>
This routine changes the stored preferred number format.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
localize.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_69.htm_IX_LocalSetQuotes()">
 </A>
<H1 CLASS="refHeading">
LocalSetQuotes()</H1>
<PRE CLASS="syntax">void	LocalSetQuotes(
        const LocalQuotes *		quotes);</PRE>
<P>
This routine changes the stored preferred quote marks.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
localize.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_69.htm_IX_LocalStringLength()">
 </A>
<H1 CLASS="refHeading">
LocalStringLength()</H1>
<PRE CLASS="syntax">word	LocalStringLength(
        const char *		str);</PRE>
<P>
This routine returns the length (in characters) of a null-terminated string (not counting the null), even for multibyte character sets.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
localize.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_69.htm_IX_LocalStringSize()">
 </A>
<H1 CLASS="refHeading">
LocalStringSize()</H1>
<PRE CLASS="syntax">word	LocalStringSize(
        const char *		str);</PRE>
<P>
This routine returns the size (in bytes) of a null-terminated string.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
localize.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_69.htm_IX_LocalUpcaseChar()">
 </A>
<H1 CLASS="refHeading">
LocalUpcaseChar()</H1>
<PRE CLASS="syntax">word	LocalUpcaseChar(
        word	ch);</PRE>
<P>
This routine returns the upper case equivalent, if any, of the passed character.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
localize.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_69.htm_IX_LocalUpcaseString()">
 </A>
<H1 CLASS="refHeading">
LocalUpcaseString()</H1>
<PRE CLASS="syntax">void	LocalUpcaseString(
        char *	str,
        word	size);</PRE>
<P>
This routine converts the passed string to its all upper case equivalent.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
localize.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_69.htm_IX_LogAddEntry()">
 </A>
<H1 CLASS="refHeading">
LogAddEntry()</H1>
<PRE CLASS="syntax">void 	LogAddEntry(
        LogEntry 		*logEntry);</PRE>
<P>
This function adds an entry to the Contact log. (The Contact log keeps track of what calls the user has sent to and received from each of their contacts; this is the function that logs a call.) The function takes on argument, a <CODE>
LogEntry</CODE>
 structure. </P>
<PRE>typedef struct {
  NameOrNumber 			LE_number;
  dword 			LE_contactID;
  LogEntryType 			LE_type;
  LogEntryDirection 			LE_direction;
  dword 			LE_duration;
  DateAndTime 			LE_datetime;
  LogEntryFlags 			LE_flags; 
} LogEntry;</PRE>
<P>
Normally, this function is invoked twice for each call--once at the start of the call, and again when the call is done. </P>
<P>
When invlking the function at the start of the call, set up the <STRONG CLASS="fileName">
LogEntry</STRONG>
 structure. Fill in the <CODE>
LE_number</CODE>
 and/or <CODE>
LE_contactID</CODE>
 fields if you know the contact's name, number, or <CODE>
RecordID</CODE>
 number, Fill in the <CODE>
LE_type</CODE>
 field with one of LET_CALL, LET_FAX, LET_SMS, LET_DATA_MAILBOX, LET_DATA_WWW, or LET_DATA_TELNET. Fill in the <CODE>
LE_direction</CODE>
 field with one of LED_SENT, LED_RECEIVED, or LED_MISSED. The LE_duration should be zero. Fill in the <CODE>
LE_datetime</CODE>
 field with the current date and time. (The <CODE>
<A HREF="../../CRef/Routines/R_98.htm#IX_TimerGetDateAndTime()">TimerGetDateAndTime()</A></CODE>
 function returns this information.) Leave the <CODE>
LE_flags</CODE>
 field alone. </P>
<P>
Keep the structure around after you call the routine; it will fill in some of the fields. Then when the call is complete, fill in the <CODE>
LE_duration</CODE>
 field and invoke the function again. The <CODE>
LE_duration</CODE>
 field should contain the call's duration in seconds. One way to compute this time is to call <CODE>
<A HREF="../../CRef/Routines/R_98.htm#IX_TimerGetCount()">TimerGetCount()</A></CODE>
 twice: once at the start of the call and once at the end. By subtracting the start time from the end time and dividing by 60, one can compute the number of seconds that passed.</P>
<P>
Having invoked the function a second time, the program may safely free the <CODE>
LogEntry</CODE>
 structure.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
contlog.goh</STRONG>
 </P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_98.htm#IX_TimerGetDateAndTime()">TimerGetDateAndTime()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_98.htm#IX_TimerGetCount()">TimerGetCount()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_69.htm_IX_LogDeleteAllEntries()">
 </A>
<H1 CLASS="refHeading">
LogDeleteAllEntries()</H1>
<PRE CLASS="syntax">void 	LogDeleteAllEntries();</PRE>
<P>
This function deletes all entries in the contact log. </P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
contlog.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_69.htm_IX_LogDestroy()">
 </A>
<H1 CLASS="refHeading">
LogDestroy()</H1>
<PRE CLASS="syntax">void 	LogDestroy();</PRE>
<P>
This function deletes the contact log's log file. </P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
contlog.goh</STRONG>
 </P>
<P>
&nbsp;</P>
</DIV>
<HR>
<A NAME="R_MailboxAck.htm"></A>
<DIV>
</DIV>

<DIV>
<A NAME="R_MailboxAck.htm_IX_MailboxAcknowledgeMessageReceipt()">
 </A>
<H1 CLASS="refHeading">
MailboxAcknowledgeMessageReceipt()</H1>
<PRE CLASS="syntax"> void 	MailboxAcknowledgeMessageReceipt(
	MailboxMessage 		msg);
</PRE>
<P>
This routine tells the Mailbox library that the application has taken control of the message <EM>msg</EM>. <EM>msg</EM> will be visually removed from the system inbox only when this function is called.
</P>
<P CLASS="refField">
<STRONG>Warning:</STRONG> 
When the mailbox receives a message targeted for an application, it sends that application the message <CODE>MSG_META_MAILBOX_NOTIFY_MESSAGE_AVAILABLE</CODE>. Should the application not acknowledge the message with <CODE>
MailboxAcknowledgeMessageReceipt()</CODE> 
and the application exits and restarts, the application will again be notified of the message's availability. 
</P>
<P CLASS="refField">
<STRONG>Include:</STRONG>	<STRONG CLASS="fileName">
mailbox.h</STRONG>
 </P>
</DIV>




<DIV>
<A NAME="R_MailboxAck.htm_IX_MailboxBodyReformatted()">
 </A>
<H1 CLASS="refHeading">
MailboxBodyReformatted()</H1>
<PRE CLASS="syntax"> MailboxError 	MailboxBodyReformatted(
	MailboxMessage 	msg,
	MailboxDataFormat 	newFormat,
	MailboxMessageFlags 	newBodyFlags);
</PRE>
<P>
This routine changes the format indication of the message <EM>msg</EM> to <EM>newFormat</EM> and  sets the <CODE> MailboxMessageFlags</CODE> <EM> newBodyFlags</EM> to either <CODE>MMF_BODY_DATA_VOLATILE</CODE> or <CODE>MMF_DELETE_BODY_AFTER_TRANSMISSION</CODE>. This routine does not alter the contents of msg <EM>msg</EM>.If <EM>msg</EM> is invalid then a <CODE>MailboxError</CODE> will be generated. 
</P>
<P>The <CODE>MailboxDataFormat</CODE> structure is formatted as:<PRE CLASS = "syntax">    typedef struct {		        word		MDF_id;     /*GeoworksMailboxDataFormatID*/        ManufacturerID	MDF_manuf;    } MailboxDataFormat;</PRE></P>
<P CLASS="refField"><STRONG>Warning:</STRONG> 
<CODE>
MailboxBodyReformatted()</CODE> 
is used to change the format of <EM>msg</EM> in-place. To create a copy of a message in a new format, use <CODE>
MailboxChangeBodyFormat()</CODE>
.
</P>
<P CLASS="refField">
<STRONG>Include:</STRONG>	<STRONG CLASS="fileName">
mailbox.h</STRONG>
 </P>
</DIV>





<DIV>
<A NAME="R_MailboxAck.htm_IX_MailboxChangeBodyFormat()">
 </A>
<H1 CLASS="refHeading">
MailboxChangeBodyFormat()</H1>
<PRE CLASS="syntax"> MailboxError	MailboxChangeBodyFormat(
	MailboxMessage 	msg,
	const MailboxChangeBodyFormatArgs 	*mcbfArgs);
</PRE>
<P>
This routine replaces the format and the body of the message <EM>msg</EM> with <EM>mcbfArgs</EM>. If <EM>msg</EM> is invalid or the body is in use, then a <CODE>MailboxError</CODE> will be generated. 
</P>
<P CLASS="refField"><STRONG>Warning:</STRONG> 
<CODE>MailboxChangeBodyFormat()
</CODE> should be used when creating a copy of a message in a new format. To reformat the message in-place, use <CODE>
MailboxBodyReformatted()</CODE>
.
</P>
<P CLASS="refField">
<STRONG>Include:</STRONG>	<STRONG CLASS="fileName">
mailbox.h</STRONG>
 </P>
</DIV>



<DIV>
<A NAME="R_MailboxAck.htm_IX_ MailboxChangeToMailboxDir()">
 </A>
<H1 CLASS="refHeading">
MailboxChangeToMailboxDir()</H1>
<PRE CLASS="syntax">void	MailboxChangeToMailboxDir(void);
</PRE>
<P>
This routine changes the application's current working directoryto the directory where the Mailbox library holds its message bodies and administrative files. 
</P>
<P CLASS="refField"><STRONG>Warning: </STRONG>
This is primarily intended for use by data and transport drivers.
</P>
<P CLASS="refField">
<STRONG>Include:</STRONG>	<STRONG CLASS="fileName">
mailbox.h</STRONG>
 </P>
</DIV>




<DIV>
<A NAME="R_MailboxAck.htm_IX_MailboxCheckMediumAvailable()">
 </A>
<H1 CLASS="refHeading">
MailboxCheckMediumAvailable()</H1>
<PRE CLASS="syntax">Boolean  MailboxCheckMediumAvailable(
	MediumType 	mediumType, 
	word 	unitNum, 
	MediumUnitType 	unitType);
</PRE>
<P>
If the transmission medium <CODE>mediumType</CODE> exists, then this routine returns <CODE>TRUE</CODE> (non-zero); otherwise, it returns <CODE>FALSE</CODE> (zero). Since the Mailbox library cannot control the comings and goings of the different media, there is no guarantee that a medium which exists now will exist later. 
</P>
<P><STRONG>For example</STRONG>, if a modem PCMCIA card is inserted, then
the DATA_MODEM medium will be available (and the unit number will be the
SERIAL_COMx constant by which the modem can be reached). When the PCMCIA card
is removed, then that medium will no longer be available and
<CODE>
MailboxCheckMediumAvailable()</CODE>
will return <CODE>FALSE</CODE>.
</P>
<P CLASS="refField">
<STRONG>Warning:</STRONG> If <EM>unitType</EM> is a <CODE>MUT_MEM_BLOCK</CODE> (a handle to other data), it means that the Mailbox library will take responsibility for freeing the memory block. In this case, the application should no longer reference the handle it passed in as the unit number.
</P>
<P CLASS="refField">
<STRONG>Include:</STRONG>	<STRONG CLASS="fileName">
mailbox.h</STRONG>
 </P>
</DIV>


<DIV>
<A NAME="R_MailboxAck.htm_IX_MailboxCheckMediumConnected()">
 </A>
<H1 CLASS="refHeading">
MailboxCheckMediumConnected()</H1>
<PRE CLASS="syntax">Boolean 	MailboxCheckMediumConnected(
	MediumType 	mediumType, 
	word 	unitNum, 
	MediumUnitType 	unitType);
</PRE>
<P>
Sees if the Mailbox library has been told whether a connection over the specified transmission medium exists. The medium is not guaranteed to remain connected once this call returns, as the Mailbox library has no control over connections, usually.  This routine returns non-zero if, while the call was in-progress, the medium using <CODE> MediumType</CODE> <EM> mediumType</EM>, unit number <EM> unitNum</EM> (ignored if <EM>unitType</EM> is set to <CODE>MUT_NONE</CODE>), and <CODE> MediumUnitType</CODE> <EM> unitType</EM> were connected; otherwise, the routine returns zero. 
</P>
<P CLASS="refField">
<STRONG>Warning:</STRONG> If <EM>unitType</EM> is a <CODE>MUT_MEM_BLOCK</CODE> (a handle to other data), it means that the Mailbox library will take responsibility for freeing the memory block. In this case, the application should no longer reference the handle it passed in as the unit number.
</P>
<P CLASS="refField">
<STRONG>Include:</STRONG>	<STRONG CLASS="fileName">
mailbox.h</STRONG>
 </P>
</DIV>
 



<DIV>
<A NAME="R_MailboxAck.htm_IX_MailboxDeleteMessage()">
 </A>
<H1 CLASS="refHeading">
MailboxDeleteMessage()</H1>
<PRE CLASS="syntax"> void 	MailboxDeleteMessage(MailboxMessage msg);
</PRE>
<P>
This routine lets the Mailbox library know that it is free to delete the message <EM>msg</EM>. This routine should only be called after the application has called <CODE>
MailboxAcknowledgeMessageReceipt()</CODE>
to acknowledge that it has finished handling the message.
</P>
<P CLASS="refField">
<STRONG>Include:</STRONG>	<STRONG CLASS="fileName">
mailbox.h</STRONG>
 </P>
</DIV>



<DIV>
<A NAME="R_MailboxAck.htm_IX_MailboxDoneWithBody()">
 </A>
<H1 CLASS="refHeading">
MailboxDoneWithBody()</H1>
<PRE CLASS="syntax"> void 	MailboxDoneWithBody(
	MailboxMessage	msg,
	const void 	*appRef, 	
	word 	appRefSize);		</PRE>
<P>
This routine indicates that the body reference <EM>appRef</EM> returned by an earlier call to <CODE>
MailboxGetBodyRef()</CODE>
will no longer be used, so the data driver is free to close the file, etc. <EM>appRef</EM> points to the body of the message <EM>msg</EM>, and <EM>appRefSize</EM> refers to the size of this body, in bytes.</P>
<P CLASS="refField">
<STRONG>Warning:</STRONG>
After calling this routine, no further use of the body via <EM>appRef</EM> may be made.
</P>
<P CLASS="refField">
<STRONG>Include:</STRONG>	<STRONG CLASS="fileName">
mailbox.h</STRONG>
 </P>
</DIV>







<DIV>
<A NAME="R_MailboxAck.htm_IX_MailboxDoneWithVMFile()">
 </A>
<H1 CLASS="refHeading">
MailboxDoneWithVMFile()</H1>
<PRE CLASS="syntax"> void 	MailboxDoneWithVMFile(	VMFileHandle file);
</PRE>
<P>
Lets the Mailbox know that the application is done using the file <EM>file</EM>,  a parameter which was returned from <CODE>
MailboxGetVMFile()</CODE>
. The Mailbox library is free to close <EM>file</EM> after this routine is called.
<P CLASS="refField">
<STRONG>Include:</STRONG>	<STRONG CLASS="fileName">
mailbox.h</STRONG>
 </P>
</DIV>



<DIV>
<A NAME="R_MailboxAck.htm_IX_MailboxFreeDriver()">
 </A>
<H1 CLASS="refHeading">
MailboxFreeDriver()</H1>
<PRE CLASS="syntax">void	MailboxFreeDriver(
	GeodeHandle 	driverHandle);
</PRE>
<P>
This routine unloads the driver <EM> driverHandle</EM> previously loaded by the Mailbox library.
 Note that a call to <CODE>
MailboxLoad...Driver()</CODE>
should be balanced with a call to <CODE>
MailboxFreeDriver()</CODE>
.</P>
<P CLASS="refField">
<STRONG>See Also: </STRONG> <CODE>MailboxLoadDataDriver()</CODE><BR> <CODE>MailboxLoadDataDriverWithError()</CODE><BR> <CODE>MailboxLoadTransportDriver()</CODE></P>
<P CLASS="refField">
<STRONG>Include:</STRONG>	<STRONG CLASS="fileName">
mailbox.h</STRONG>
 </P>
</DIV>




<DIV>
<A NAME="R_MailboxAck.htm_IX_MailboxGetAdminFile()">
 </A>
<H1 CLASS="refHeading">
MailboxGetAdminFile()</H1>
<PRE CLASS="syntax">VMFileHandle	MailboxGetAdminFile(void);
</PRE>
<P>
Returns the handle of the main administrative VM file that is maintained by the Mailbox library.
</P>
<P CLASS = "refField">
<STRONG>Warning:</STRONG> The returned file should <STRONG>NOT</STRONG> be used for general storage of data. This routine is intended to allow applications that wish to
register a message without the aid of a <CODE>MailboxSendControl</CODE> to
create the <CODE>transData</CODE> argument required by the transport driver
they've chosen, should the driver expect something to be
allocated within the admin file.
</P>
<P CLASS="refField">
<STRONG>Include:</STRONG>	<STRONG CLASS="fileName">
mailbox.h</STRONG>
 </P>
</DIV>

<HR>
<P><EM>This document is in Beta.  Ride at your own risk.  <A HREF="#mailto:isv-feedback@geoworks.com">Mail us</A> your comments and suggestions</EM></P>
<A NAME="R_MailboxGetBodyFormat.htm"></A>
<DIV>




<DIV>
<A NAME="R_MailboxGetBodyFormat.htm_IX_MailboxGetBodyFormat()">
 </A>
<H1 CLASS="refHeading">
MailboxGetBodyFormat()</H1>
<PRE CLASS="syntax"> MailboxError	MailboxGetBodyFormat(
	MailboxMessage 	msg,
	MailboxDataFormat 	*dataFormat);
</PRE>
<P>This routine gets the <CODE>MailboxDataFormat</CODE> token of the message <EM>msg</EM> and copies it into <EM>dataFormat</EM>. It returns a <CODE>MailboxError</CODE> if the routine is invalid.
</P>
<P CLASS="refField">
<STRONG>Include:</STRONG>	<STRONG CLASS="fileName">
mailbox.h</STRONG>
 </P>
</DIV>

<DIV>
<A NAME="R_MailboxGetBodyFormat.htm_IX_ MailboxGetBodyMboxRefBlock()">
 </A>
<H1 CLASS="refHeading">
MailboxGetBodyMboxRefBlock()</H1>
<PRE CLASS="syntax"> MailboxError	MailboxGetBodyMboxRefBlock(
	MailboxMessage 	msg,
	MemHandle 	*mboxRefHandle);
</PRE>
<P>
Fetches the opaque mailbox reference to the message body of message <EM>msg</EM> and stores it in the block <EM>mboxRefHandle</EM>. This returned block contains a mailbox reference structure specific to the Data Driver.  Examples are:
<PRE>
	/* for mailbox data drivers that use VMChains */
	typedef {  
		dword VMTMR_vmChain;
		TCHAR VMTMR_filename[];
	} VMTreeMboxRef;

	/* for mailbox data drivers that use raw data files */
	typedef {
		Boolean FMR_deleteAfterTransmit;
		word FMR_diskDataOffset;
		word FMR_diskDataLen;
		word FMR_filenameLen;
		byte FMR_filenameAndDiskData[];
			/* start of null-terminated filename, 
			 * followed by diskData (at 
			 * FMR_diskDataOffset). */
	} FileDDMboxRef;
</PRE>

The routine returns <CODE>ME_INVALID_MESSAGE</CODE> if the message is invalid, or <CODE>ME_NOT_ENOUGH_MEMORY</CODE> if the block of data could not be created.
</P>
<P CLASS="refField"><STRONG>Note:</STRONG> This routine is normally used by the mailbox drivers, not by applications.
</P>
<P CLASS="refField">
<STRONG>Include:</STRONG>	<STRONG CLASS="fileName">
mailbox.h</STRONG>
 </P>
</DIV>

<DIV>
<A NAME="R_MailboxGetBodyFormat.htm_IX_MailboxGetBodyRef()">
 </A>
<H1 CLASS="refHeading">
MailboxGetBodyRef()</H1>
<PRE CLASS="syntax"> MailboxError	MailboxGetBodyRef(
	MailboxMessage 	msg,
	void 	*appRefBuf, 		
	word 	*appRefBufSize);	
</PRE>
<P>
This routine retrieves the address of the message body of the message <EM>msg</EM> in the format understood and used by applications registering a message with the Mailbox library, the app-reference. The definitions of app-reference structures are defined in the documentation for each of the various communication methods, <EM>e.g.</EM> <A HREF="../../Nokia9000/SMS/combo.htm">the SMS chapter</A>. This reference to the body is copied into the buffer <EM>appRefBuf</EM>. <EM>appRefBufSize</EM> initially points to the size of this buffer in bytes, and then it is set to the number of bytes that were copied into the buffer. In the case of an error (<EM>msg</EM> is invalid, the library is unable to load the driver, there is insufficient memory, the app-ref buffer too small, there is no message body available) a <CODE>MailboxError</CODE> will be generated.
</P>
<P CLASS="refField">
<STRONG>Warning: </STRONG>
Each call to this routine must be matched by a call to <CODE>
MailboxDoneWithBody()</CODE>
.
</P>
<P CLASS="refField">
<STRONG>Include:</STRONG>	<STRONG CLASS="fileName">
mailbox.h</STRONG>
 </P>
</DIV>





<DIV>
<A NAME="R_MailboxGetBodyFormat.htm_IX_MailboxGetDestApp()">
 </A>
<H1 CLASS="refHeading">
MailboxGetDestApp()</H1>
<PRE CLASS="syntax"> MailboxError	MailboxGetDestApp(
	MailboxMessage 	msg,
	GeodeToken 	*tokenBuf);

</PRE>
<P>Gets the <CODE>GeodeToken</CODE> for the destination application from the message <EM>msg</EM> and copies it into <EM>tokenBuf</EM>. This routine returns <CODE>ME_INVALID_MESSAGE</CODE> if the passed MailboxMessage is invalid.
</P>
<P CLASS="refField">
<STRONG>Include:</STRONG>	<STRONG CLASS="fileName">
mailbox.h</STRONG>
 </P>
</DIV>



<DIV>
<A NAME="R_MailboxGetBodyFormat.htm_IX_MailboxGetEndBound()">
 </A>
<H1 CLASS="refHeading">
MailboxGetEndBound()</H1>
<PRE CLASS="syntax"> MailboxError	MailboxGetEndBound(
	MailboxMessage 	msg,
	FileDateAndTime 	*dateTime);
</PRE>
<P>
Fetches the end bound of the message <EM>msg</EM> and copies it into <EM>dateTime</EM>. If the message is invalid, this routine returns <CODE> ME_INVALID_MESSAGE</CODE>.
</P>
<P CLASS="refField"><STRONG>See Also:</STRONG> <CODE>MailboxGetStartBound()</CODE></P>
<P CLASS="refField">
<STRONG>Include:</STRONG>	<STRONG CLASS="fileName">
mailbox.h</STRONG>
 </P>
</DIV>


<DIV>
<A NAME="R_MailboxGetBodyFormat.htm_IX_MailboxGetFirstMediumUnit()">
 </A>
<H1 CLASS="refHeading">
MailboxGetFirstMediumUnit()</H1>
<PRE CLASS="syntax"> word	 MailboxGetFirstMediumUnit(
	MediumType 	mediumType, 
	MediumUnitType 	*unitType);
</PRE>
<P>
Puts the first available unit of the indicated <CODE>MediumType</CODE> <EM>mediumType</EM> into <EM>unitType</EM>. This should be used when a transport driver just wants to use a particular medium but doesn't care which one. This routine returns the unit number. 
</P>
<P CLASS="refField">
<STRONG>Warning:</STRONG>
 Do not call this for a medium that doesn't use unit numbers. You will generate a fatal-error in the error-checking version, and won't get any additional information in the non-error-checking version (since the return will be <CODE>MUT_NONE</CODE> whether there's an available unit or not). Use <CODE>
MailboxCheckMediumAvailable()</CODE> 
instead. Also remember, if <EM>unitType</EM> is a handle to other memory because it is a <CODE>MUT_MEM_BLOCK</CODE>,  it will be your responsibility to free the associated memory block.
</P>
<P CLASS="refField">
<STRONG>Include:</STRONG>	<STRONG CLASS="fileName">
mailbox.h</STRONG>
 </P>
</DIV>



<DIV>
<A NAME="R_MailboxGetBodyFormat.htm_IX_MailboxGetMessageFlags()">
 </A>
<H1 CLASS="refHeading">
MailboxGetMessageFlags()</H1>
<PRE CLASS="syntax"> MailboxError	MailboxGetMessageFlags(
	MailboxMessage 	msg,
	MailboxMessageFlags 	*flags);
</PRE>
<P>
Retrieves the <CODE>MailboxMessageFlags</CODE> for the message <EM>msg</EM> and copies them into <EM>flags</EM>. If the message is invalid, <CODE>ME_INVALID_MESSAGE</CODE> is returned.
</P>
<P CLASS="refField">
<STRONG>Include:</STRONG>	<STRONG CLASS="fileName">
mailbox.h</STRONG>
 </P>
</DIV>


<DIV>
<A NAME="R_MailboxGetBodyFormat.htm_IX_MailboxGetNumTransAddrs()">
 </A>
<H1 CLASS="refHeading">
MailboxGetNumTransAddrs()</H1>
<PRE CLASS="syntax"> MailboxError	MailboxGetNumTransAddrs(
	MailboxMessage 		msg, 
	word 	*numAddresses);
</PRE>
<P>
Retrieves the number of transport addresses bound to the message <EM>msg</EM> and stores that number in <EM>numAddresses</EM>. If <EM>msg</EM> is in the inbox, then <EM>numAddressess</EM> is set to zero. If the number of addresses can't be obtained, then the routine returns <CODE>ME_INVALID_MESSAGE</CODE>.
</P>
<P CLASS="refField"><STRONG>See Also:</STRONG> <CODE>MailboxGetTransAddr()</CODE></P>
<P CLASS="refField">
<STRONG>Include:</STRONG>	<STRONG CLASS="fileName">
mailbox.h</STRONG>
 </P>
</DIV>

<DIV>
<A NAME="R_MailboxGetBodyFormat.htm_IX_MailboxGetStartBound()">
 </A>
<H1 CLASS="refHeading">
MailboxGetStartBound()</H1>
<PRE CLASS="syntax"> MailboxError	MailboxGetStartBound(
	MailboxMessage 	msg,
	FileDateAndTime	*dateTime);
</PRE>
<P>
Fetches the start bound of the message <EM>msg</EM> and copies it into <EM>dateTime</EM>. If the message is invalid, this routine returns  <CODE>ME_INVALID_MESSAGE</CODE>.
</P>
<P CLASS="refField"><STRONG>See Also:</STRONG> <CODE> MailboxGetEndBound()</CODE></P>
<P CLASS="refField">
<STRONG>Include:</STRONG>	<STRONG CLASS="fileName">
mailbox.h</STRONG>
 </P>
</DIV>



<DIV>
<A NAME="R_MailboxGetBodyFormat.htm_IX_MailboxGetStorageType()">
 </A>
<H1 CLASS="refHeading">
MailboxGetStorageType()</H1>
<PRE CLASS="syntax"> MailboxError 	MailboxGetStorageType(
	MailboxMessage 	msg,
	MailboxStorage 	*storage);
</PRE>
<P>
This routine gets the <CODE>MailboxStorage</CODE> token for the message <EM>msg</EM> and copies it into <EM>storage</EM>. If the message is invalid, <CODE>ME_INVALID_MESSAGE</CODE> is returned.
</P>
<P CLASS="refField">
<STRONG>Include:</STRONG>	<STRONG CLASS="fileName">
mailbox.h</STRONG>
 </P>
</DIV>

<DIV>
<A NAME="R_MailboxGetBodyFormat.htm_IX_MailboxGetSubjectBlock()">
 </A>
<H1 CLASS="refHeading">
MailboxGetSubjectBlock()</H1>
<PRE CLASS="syntax"> MailboxError	MailboxGetSubjectBlock(
	MailboxMessage 	msg, 
	MemHandle 	*subjHandle);
</PRE>
<P>
Retrieves the null-terminated subject/summary of the message <EM>msg</EM> and copies it into a global memory block, then puts the associated <CODE>MemHandle</CODE> into <EM> subjHandle</EM>. Returns <CODE>ME_INVALID_MESSAGE</CODE> if <EM>msg</EM> is invalid or <CODE>ME_NOT_ENOUGH_MEMORY</CODE> if there isn't sufficient memory to create the block.
</P>
<P CLASS="refField">
<STRONG>Include:</STRONG>	<STRONG CLASS="fileName">
mailbox.h</STRONG>
 </P>
</DIV>

<DIV>
<A NAME="R_MailboxGetBodyFormat.htm_IX_MailboxGetSubjectLMem()">
 </A>
<H1 CLASS="refHeading">
MailboxGetSubjectLMem()</H1>
<PRE CLASS="syntax"> MailboxError	MailboxGetSubjectLMem(
	MailboxMessage 	msg, 
	MemHandle 	lmemBlock, 
	ChunkHandle 	*subjectChunk);
</PRE>
<P>
Retrieves the subject/summary of the message <EM>msg</EM> and copies it into a local memory block <EM>lmemBlock</EM>, and puts the <CODE>ChunkHandle</CODE> for this null-terminated subject into <EM>subjectChunk</EM>. Returns <CODE>ME_INVALID_MESSAGE</CODE> if <EM>msg</EM> is invalid or <CODE>ME_NOT_ENOUGH_MEMORY</CODE> if there isn't sufficient memory to create the block.
</P>

<P CLASS="refField">
<STRONG>Include:</STRONG>	<STRONG CLASS="fileName">
mailbox.h</STRONG>
 </P>
</DIV>

<DIV>
<A NAME="R_MailboxGetBodyFormat.htm_IX_MailboxGetTransAddr()">
 </A>
<H1 CLASS="refHeading">
MailboxGetTransAddr()</H1>
<PRE CLASS="syntax"> Boolean	MailboxGetTransAddr(
	MailboxMessage 	msg, 
	word 	addrNumber,
	void 	*addressBuffer,
	word 	*bufSizePtr);
</PRE>

<P>
This routine retrieves the <EM>addrNumber</EM>-th transport address from the message <EM>msg</EM> and copies the address into <EM>addressBuffer</EM>. <EM>bufSizePtr</EM> should initially point to the size of the buffer in bytes and, if the routine works successfully, it will be set to the number of bytes that were actually copied into <EM>addressBuffer</EM>. If the <EM>addrNumber</EM> is invalid because it is either too large or the message doesn't exist, then <EM>bufSizePtr</EM> will be set to zero. If the buffer isn't large enough to store the address, then <EM>bufSizePtr</EM> is set to the number of bytes required. The routine returns zero (<CODE>FALSE</CODE>) if an error occurred, otherwise it returns non-zero.
</P>

<P CLASS="refField"><STRONG>See Also:</STRONG> <CODE>MailboxGetNumTransAddrs()<BR> MailboxGetUserTransAddrLMem()<BR> MailboxSetTransAddr()</CODE></P>

<P CLASS="refField">
<STRONG>Include:</STRONG>	<STRONG CLASS="fileName">
mailbox.h</STRONG>
 </P>
</DIV>


<DIV>
<A NAME="R_MailboxGetBodyFormat.htm_IX_MailboxGetTransData()">
 </A>
<H1 CLASS="refHeading">
MailboxGetTransData()</H1>
<PRE CLASS="syntax"> MailboxError 	MailboxGetTransData(
	MailboxMessage 	msg, 
	dword 	*transData);
</PRE>

<P>
Puts the 32-bit transport data registered with the message <EM>msg</EM> into <EM>transData</EM>. If <EM>msg</EM> is an invalid message then the routine returns <CODE>ME_INVALID_MESSAGE</CODE>.
</P>

<P CLASS="refField"><STRONG>See Also:</STRONG> <CODE>MailboxSetTransData()</CODE>
</P>

<P CLASS="refField">
<STRONG>Include:</STRONG>	<STRONG CLASS="fileName">
mailbox.h</STRONG>
 </P>
</DIV>

<DIV>
<A NAME="R_MailboxGetBodyFormat.htm_IX_MailboxGetUserTransAddrLMem()">
 </A>

<H1 CLASS="refHeading">
MailboxGetUserTransAddrLMem()</H1>
<PRE CLASS="syntax"> MailboxError 	MailboxGetUserTransAddrLMem(
	MailboxMessage 	msg, 
	word 	addrNumber,
	MemHandle 	lmemBlock,
	ChunkHandle 	*addrChunk);
</PRE>

<P>
Retrieves a user-readable transport address from a message. The input parameters are the message <EM>msg</EM>, the address number <EM>addrNumber</EM>, and the handle of the lmem block <EM>lmemBlock</EM> in which to place the string. The routine copies the null-terminated string into this block, and sets <EM>addrChunk</EM> to point to the string's chuck. There are three errors that could occur: if <EM>addrNumber</EM> is not valid, <CODE>ME_ADDRESS_INVALID</CODE> is returned; if <EM>msg</EM> is not valid, <CODE>ME_INVALID_MESSAGE</CODE> is returned; and if there is insufficient memory to create the chunk, <CODE>ME_NOT_ENOUGH_MEMORY</CODE> is returned;
</P>

<P CLASS="refField"><STRONG>See Also:</STRONG><CODE>MailboxGetTransAddr()</CODE></P>

<P CLASS="refField">
<STRONG>Include:</STRONG>	<STRONG CLASS="fileName">
mailbox.h</STRONG>
 </P>
</DIV>

<HR>
<P><EM>This document is in Beta.  Ride at your own risk.  <A HREF="#mailto:isv-feedback@geoworks.com">Mail us</A> your comments and suggestions</EM></P>
<A NAME="R_MailboxGetVMFile.htm"></A>

<DIV>
</DIV>

<DIV>
<A NAME="R_MailboxGetVMFile.htm_IX_MailboxGetVMFile()">
 </A>
<H1 CLASS="refHeading">
MailboxGetVMFile()</H1>
<PRE CLASS="syntax"> VMFileHandle 	MailboxGetVMFile(
	word 	expectedNumBlocks, 
	word 	*vmStatusp);
</PRE>
<P>
This routine obtains the handle of a writable VM file in which data can be stored. The file is managed by the Mailbox library, so the data stored in it can be passed off to the library without being marked as <CODE>MMF_BODY_DATA_VOLATILE</CODE>.
</P>
<P>
<STRONG>Parameters:</STRONG>
<DL>
<DT><EM>expectedNumBlocks</EM>
<DD> This parameter is your estimate of your file's size, in blocks. The library uses this estimate to rationally apportion data among various VM files without getting block sizes within one file so large that the system is in danger of running out of conventional memory. Poor estimates will usually not cause fatal problems since the library is rather cautious when deciding whether to start a new file. Still, you should do your best to come up with accurate information on your needs. You should request 1 block for every 4Kb of data to store.  For example, SMS message would only require 1 block. If <EM>expectedNumBlocks</EM> is set to zero, then a system-assumed value will be used.
<DT><EM>vmStatusp</EM>
<DD>This is a pointer to a word that, in the case of an error, will be set to the error type. 
</DL>
<P CLASS="refField"><STRONG>Returns:</STRONG> If successful, this routine returns a <CODE>VMFileHandle</CODE> to a writable VM File. If it fails, it returns <CODE>NullHandle</CODE> and sets <EM>vmStatusp</EM>.
</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
mailbox.h</STRONG>
 </P>
</DIV>


<DIV>
<A NAME="R_MailboxGetVMFile.htm_IX_MailboxGetVMFileName()">
 </A>
<H1 CLASS="refHeading">
MailboxGetVMFileName()</H1>
<PRE CLASS="syntax">void 	MailboxGetVMFileName(
	VMFileHandle 	file, 
	FileLongName 	*namep);
</PRE>
<P>
Gets the name of a VM file <EM>file</EM> which was previously opened by the Mailbox library. This file resides in the Mailbox library's spool directory. <EM>namep</EM> is a buffer in which to place the file's <CODE>FileLongName</CODE>, a null-terminated file name. </P>
<P CLASS="refField"><STRONG>Warning:</STRONG> 
<CODE>
MailboxGetVMFileName()</CODE>
is used primarily by data storage drivers to obtain a persistent reference to the body of a message since file handles aren't preserved across shutdowns or file closes.
</P>
<P CLASS="refField">
<STRONG>Include:</STRONG>	<STRONG CLASS="fileName">
mailbox.h</STRONG>
 </P>
</DIV>


<DIV>
<A NAME="R_MailboxGetVMFile.htm_IX_MailboxLoadDataDriver()">
 </A>
<H1 CLASS="refHeading">
MailboxLoadDataDriver()</H1>
<PRE CLASS="syntax"> GeodeHandle	MailboxLoadDataDriver(
	MailboxStorage 	storage,
	GeodeLoadError 	*error);
</PRE>
<P>
<CODE> MailboxLoadDataDriver() </CODE> loads the specified data storage driver.</P>
<P CLASS="refField">
<STRONG>Parameters:</STRONG>
</P>
<DL>
<DD><EM>storage</EM> is a <CODE>MailboxStorage</CODE> token of the requested data storage driver.<DD><EM>error</EM> is a buffer to store a <CODE>GeodeLoadError</CODE> should the driver not load properly.
</DL>
<P CLASS="refField">
<STRONG>Return:</STRONG> If this routine is successful, it returns the handle of the loaded driver. Otherwise, the error is put into <EM>error</EM>.</P>
<P> This driver should be unloaded using <CODE>
MailboxFreeDriver()</CODE>
.
</P>
<P CLASS="refField">
<STRONG>Include:</STRONG>	<STRONG CLASS="fileName">
mailbox.h</STRONG>
 </P>
</DIV>

<DIV>
<A NAME="R_MailboxGetVMFile.htm_IX_MailboxLoadDataDriverWithError()">
 </A>
<H1 CLASS="refHeading">
MailboxLoadDataDriverWithError()</H1>
<PRE CLASS="syntax"> GeodeHandle	MailboxLoadDataDriverWithError(
	MailboxStorage 	storage,
	GeodeLoadError 	*error);
</PRE>
<P>
<CODE>
MailboxLoadDataDriverWithError()</CODE> 
loads the specified data storage driver. If the driver can't be loaded then the error message <EM>error</EM> will be used to prompt the user to make the driver available, with the option to retry the load.</P>

<P CLASS="refField"><STRONG>Parameters:</STRONG> </P>
<DL>
<DD><EM>storage</EM> is a <CODE>MailboxStorage</CODE> token of the requested data storage driver.
<DD><EM>error</EM> should point to a notification string that the user will see if the driver cannot load properly. If <EM>error</EM> points to NULL, then this routine behaves just like <CODE>
MailboxLoadDataDriver()</CODE>
.</DD></DL>
<P><STRONG>Return:</STRONG> If this routine is successful, it returns the handle of the loaded driver. Otherwise, the error is put into <EM>error</EM>.</P>
<P> This driver should be unloaded using <CODE>
MailboxFreeDriver()</CODE>.
</P>
<P CLASS="refField">
<STRONG>Include:</STRONG>	<STRONG CLASS="fileName">
mailbox.h</STRONG>
 </P>
</DIV>

<DIV>
<A NAME="R_MailboxGetVMFile.htm_IX_MailboxLoadTransportDriver()">
 </A>
<H1 CLASS="refHeading">
MailboxLoadTransportDriver()</H1>
<PRE CLASS="syntax"> GeodeHandle	MailboxLoadTransportDriver(
	MailboxTransport 	transport,
	GeodeLoadError 	*error);
</PRE>
<P>
<CODE>
MailboxLoadTransportDriver()</CODE>
 loads the transport driver with the <CODE> MailboxTransport </CODE> token <EM> transport </EM> and returns the handle of the driver. If the driver can't be loaded, then the <CODE> GeodeLoadError </CODE> is put into <EM>error</EM>.
</P>
<P>
 The driver should be unloaded using <CODE>
MailboxFreeDriver()</CODE>
.
</P>
<P CLASS="refField">
<STRONG>Include:</STRONG>	<STRONG CLASS="fileName">
mailbox.h</STRONG>
 </P>
</DIV>

<DIV>
<A NAME="R_MailboxGetVMFile.htm_IX_MailboxOpenVMFile()">
 </A>
<H1 CLASS="refHeading">
MailboxOpenVMFile()</H1>
<PRE CLASS="syntax"> VMFileHandle 	MailboxOpenVMFile(
	FileLongName 	*namep, 
	word 	*vmStatusp);
</PRE>
<P>
Reopens a VM file that was previously returned by <CODE>
MailboxGetVMFileName()</CODE>
, and whose name <EM>namep</EM> was obtained through <CODE>MailboxGetVMFileName</CODE>. If successful, the routine returns a <CODE>VMFileHandle</CODE> to the <CODE>VMFile</CODE>. If there is an error, this routine returns <CODE>NullHandle</CODE> with <CODE>vmStatusp</CODE> filled in with the appropriate <CODE>VMStatus</CODE> value.</P>
<P CLASS="refField"><STRONG>Warning:</STRONG>
Any call to this routine must be matched with a call to <CODE>
MailboxDoneWithVMFile()</CODE>
.
 </P>
<P CLASS="refField">
<STRONG>Include:</STRONG>	<STRONG CLASS="fileName">
mailbox.h</STRONG>
 </P>
</DIV>


<DIV>
<A NAME="R_MailboxGetVMFile.htm_IX_MailboxPushToMailboxDir()">
 </A>
<H1 CLASS="refHeading">
MailboxPushToMailboxDir()</H1>
<PRE CLASS="syntax">void 	MailboxPushToMailboxDir();
</PRE>
<P>
This routine performs a <CODE>
FilePushDir()</CODE>
 followed by a <CODE>
MailboxChangeToMailboxDir()</CODE>
.
</P>
<P CLASS="refField">
<STRONG>Include:</STRONG>	<STRONG CLASS="fileName">
mailbox.h</STRONG>
 </P>
</DIV>



<DIV>
<A NAME="R_MailboxGetVMFile.htm_IX_MailboxRegisterMessage()">
 </A>
<H1 CLASS="refHeading">
MailboxRegisterMessage()</H1>
<PRE CLASS="syntax">MailboxError MailboxRegisterMessage(
	MailboxRegisterMessageArgs 	*mrmArgs,
	MailboxMessage 		*msg);
</PRE>
<P>
The routine registers a message with the system. A message consists of the information the system needs to properly process that message, the <CODE>MailboxRegisterMessageArgs</CODE> <EM>mrmArgs</EM>, and the body data of the message itself, <EM>msg</EM>. The body data are copied, if necessary, or simply taken-possession-of by the system.

<P>You can find examples of filling in <CODE>MailboxRegisterMessageArgs</CODE> in the chapters that discuss the various communication methods, such as 
<A HREF="../../Nokia9000/SMS/combo.htm">the SMS chapter</A>.

<P CLASS="refField">
<STRONG>Include:</STRONG>	<STRONG CLASS="fileName">
mailbox.h</STRONG>
 </P>
</DIV>



<DIV>
<A NAME="R_MailboxGetVMFile.htm_IX_MailboxSetTransAddr()">
 </A>
<H1 CLASS="refHeading">
MailboxSetTransAddr()</H1>
<PRE CLASS="syntax"> MailboxError	MailboxSetTransAddr(
	MailboxMessage msg, 
	word addrNumber,
	const void *newAddress,
	word addrSize);
</PRE>
<P>
Sets the opaque transport address of the <EM>addrNumber</EM>-th address for the message <EM>msg</EM> to <EM>newAddress</EM>, replacing the existing one. <EM>addrSzie</EM> is the size of the new address buffer, in bytes. This routine returns <CODE>ME_INVALID_MESSAGE</CODE> if <EM>msg</EM> is invalid or <CODE>ME_NOT_ENOUGH_MEMORY</CODE> if there is not enough memory. </P>
<P CLASS="refField">
<STRONG>Warning:</STRONG> The new address may not differ from the old address in its significant address bytes. This is not intended to allow arbitrary redirection of a message, but simply for transport drivers to record their progress for a particular address in the insignificant portion of the address.
</P>
<P CLASS="refField"><STRONG>See Also: </STRONG><CODE>MailboxGetTransAddr()</CODE></P>
<P CLASS="refField"><STRONG>Include:</STRONG>	<STRONG CLASS="fileName">
mailbox.h</STRONG>
 </P>
</DIV>



<DIV>
<A NAME="R_MailboxGetVMFile.htm_IX_MailboxSetTransData()">
 </A>
<H1 CLASS="refHeading">
MailboxSetTransData()</H1>
<PRE CLASS="syntax"> MailboxError 	MailboxGetTransData(
	MailboxMessage 	msg, 
	dword 	transData);
</PRE>
<P>
This routine replaces the 32-bit transport data registered with the message <EM>msg</EM> with <EM>transData</EM>.  If the message is invalid then the routine returns <CODE>ME_INVALID_MESSAGE</CODE>; if successful, it returns <CODE>ME_SUCCESS</CODE>.
</P>
<P CLASS = "refField">
<STRONG>Warning:</STRONG> 
The caller is responsible for freeing any resources referred to by the previous <CODE>dword</CODE> transport data since the Mailbox library places absolutely no interpretation on the <CODE>transData</CODE>, and thus cannot know what needs to be freed when one <CODE>transData</CODE> dword replaces another.
</P>
<P CLASS="refField"><STRONG>See Also: </STRONG><CODE>MailboxGetTransAddr()</CODE></P>

<P CLASS="refField">
<STRONG>Include:</STRONG>	<STRONG CLASS="fileName">
mailbox.h</STRONG>
 </P>
</DIV>


<DIV>
<A NAME="R_MailboxGetVMFile.htm_IX_MailboxStealBody()">
 </A>
<H1 CLASS="refHeading">
MailboxStealBody()</H1>
<PRE CLASS="syntax"> MailboxError	MailboxStealBody(
	MailboxMessage 	msg,
	void 	*appRefBuf, 
	word 	*appRefBufSize);
</PRE>
<P>
This routine lets an application take possession of the body of the message <EM>msg</EM>. It puts the app-reference to the body in <EM>appRefBuf</EM>. The app-reference structure defined for each communication mode is defined in the documentation for that communication mode, <EM>e.g.</EM> 
<A HREF="../../Nokia9000/SMS/combo.htm">the SMS chapter</A>. 
The application is responsible for destroying the data associated with this app-reference. If the message body is within a VM file, the application is responsible for calling 
<CODE><A HREF="../../CRef/Routines/R_MailboxAck.htm#IX_MailboxDoneWithVMFile()">MailboxDoneWithVMFile()</A></CODE> 
after freeing the data that make up the body. The parameters for this routine are the message <EM>msg</EM>, a pointer <EM>appRefBuf</EM> to an app-reference, and a word <EM>appRefBufSize</EM> that points to the size of <EM>appRefBuf</EM>, in bytes. <EM>appRefBufSize</EM> is then filled with the number of bytes that are put into <EM>appRefBuf</EM>. 



<P>The possible errors are <CODE>ME_INVALID_MESSAGE, ME_NOT_ENOUGH_MEMORY, ME_CANNOT_LOAD_DATA_DRIVER,    ME_CANNOT_LOAD_TRANSPORT_DRIVER, ME_APP_REF_BUF_TOO_SMALL, ME_CANNOT_OPEN_MESSAGE_FILE, </CODE> and <CODE>ME_CANNOT_READ_MESSAGE_FILE</CODE>.</P>
<P CLASS="refField">
<STRONG>Include:</STRONG>	<STRONG CLASS="fileName">
mailbox.h</STRONG>
 </P>
</DIV>

<HR>
<A NAME="R_6a.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_6a.htm_IX_MakeWWFixed()">
 </A>
<H1 CLASS="refHeading">
MakeWWFixed()</H1>
<PRE CLASS="syntax">WWFixed MakeWWFixed(number);</PRE>
<P>
This macro casts a floating-point or integer number to a <CODE>
WWFixed</CODE>
 value.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	geos.h</P>
</DIV>
<DIV>
<A NAME="R_6a.htm_IX_malloc()">
 </A>
<H1 CLASS="refHeading">
malloc()</H1>
<PRE CLASS="syntax">void	* malloc(
        size_t		blockSize);				/* # of bytes to allocate*/</PRE>
<P>
The <CODE>
malloc()</CODE>
 family of routines is provided for Standard C compatibility. If a geode needs a small amount of fixed memory, it can call one of the routines. The kernel will allocate a fixed block to satisfy the geode's <CODE>
malloc()</CODE>
 requests; it will allocate memory from this block. When the block is filled, it will allocate another fixed malloc-block. When all the memory in the block is freed, the memory manager will automatically free the block.</P>
<P>
When a geode calls <CODE>
malloc()</CODE>
, a section of memory of the size specified will be allocated out of its malloc-block, and the address of the start of the memory will be returned. The memory will <EM>
not</EM>
 be zero-initialized. If the request cannot be satisfied, <CODE>
malloc</CODE>
 will return a null pointer. The memory is guaranteed not to be moved until it is freed (with <CODE>
<A HREF="../../CRef/Routines/R_2f.htm#IX_free()">free()</A></CODE>
) or resized (with <CODE>
<A HREF="../../CRef/Routines/R_83.htm#IX_realloc()">realloc()</A></CODE>
). When GEOS shuts down, all fixed blocks are freed, and any memory allocated with <CODE>
malloc()</CODE>
 is lost.</P>
<P>
Using too many fixed blocks degrades the memory manager's performance, slowing the whole system. For this reason, applications should not use <CODE>
malloc</CODE>
-family routines if they can possibly be avoided. They are provided only to simplify porting of existing programs; however, applications should make every effort to use the GEOS memory management and LMem routines instead. If you must use the <CODE>
malloc</CODE>
-family routines, use them sparingly, and free the memory as quickly as possible.</P>
<P CLASS="refField"><STRONG>
Tips and Tricks:</STRONG>	You can allocate memory in another geode's malloc-block by calling <CODE>
<A HREF="../../CRef/Routines/R_36.htm#IX_GeoMalloc()">GeoMalloc()</A></CODE>
. However, that block will be freed when the other geode exits.</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	All memory allocated with <CODE>
malloc()</CODE>
 is freed when GEOS shuts down.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	stdlib.h</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_3.htm#IX_calloc()">calloc()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_2f.htm#IX_free()">free()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_36.htm#IX_GeoMalloc()">GeoMalloc()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_83.htm#IX_realloc()">realloc()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_6a.htm_IX_ManufacturerFromFormatID">
 </A>
<H1 CLASS="refHeading">
ManufacturerFromFormatID</H1>
<PRE CLASS="syntax">word	ManufacturerFromFormatID(id);
        ClipboardItemFormatID <EM>id</EM>;</PRE>
<P>
This macro extracts the word-sized manufacturer ID (of type <CODE>
ManufacturerIDs</CODE>
) from a <CODE>
ClipboardInfoFormatID</CODE>
 argument.</P>
</DIV>
<HR>
<A NAME="R_6b.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_6b.htm_IX_MemAlloc()">
 </A>
<H1 CLASS="refHeading">
MemAlloc()</H1>
<PRE CLASS="syntax">MemHandle MemAlloc(
        word		byteSize,				/* Size of block in bytes */
        HeapFlags		hfFlags,				/* Type of block */
        HeapAllocFlags		haFlags);				/* How to allocate block */</PRE>
<P>
This routine allocates a global memory block and creates an entry for it in the global handle table. The properties of the block are determined by the <CODE>
HeapFlags</CODE>
 record passed; the way the block should be allocated is determined by the <CODE>
HeapAllocFlags</CODE>
 record. Both sets of flags are described below. The routine returns the block's handle. If it could not allocate the block, it returns a null handle. The block allocated may be larger than the size requested, as the block size is rounded up to the next even paragraph (one paragraph equals sixteen bytes).</P>
<P>
<CODE>
HeapFlags</CODE>
 are stored in the block's handle table entry. They can be retrieved with the routine <CODE>
<A HREF="../../CRef/Routines/R_6c.htm#IX_MemGetInfo()">MemGetInfo()</A></CODE>
; some of them can be changed with the routine <CODE>
<A HREF="../../CRef/Routines/R_6e.htm#IX_MemModifyFlags()">MemModifyFlags()</A></CODE>
. The following flags are available:</P>
<DL>
<DT>
HF_FIXED</DT><DD>
The block will not move from its place in the global heap until it is freed. If this flag is off, the memory manager may move the block while it is unlocked. If the flag is on, the block may not be locked, and HF_DISCARDABLE and HF_SWAPABLE must be off.</DD>
<DT>
HF_SHARABLE</DT><DD>
The block may be locked by threads belonging to geodes other than the block's owner.</DD>
<DT>
HF_DISCARDABLE</DT><DD>
The block may be discarded when unlocked.</DD>
<DT>
HF_SWAPABLE</DT><DD>
The block may be swapped to extended/expanded memory or to the disk swap space when it is unlocked.</DD>
<DT>
HF_LMEM</DT><DD>
The block contains a local memory heap. This flag is set automatically by <CODE>
<A HREF="../../CRef/Routines/R_64.htm#IX_LMemInitHeap()">LMemInitHeap()</A></CODE>
 and <CODE>
<A HREF="../../CRef/Routines/R_a1.htm#IX_VMAllocLMem()">VMAllocLMem()</A></CODE>
; applications should not need to set this flag.</DD>
<DT>
HF_DISCARDED</DT><DD>
The memory manager turns this bit on when it discards a block. The bit is turned off when the block is reallocated.</DD>
<DT>
HF_SWAPPED</DT><DD>
The memory manager turns this bit on when it swaps a block to extended/expanded memory or to the disk swap space. It turns the bit off when it swaps the block back into the global heap.</DD>
</DL>
<P>
<CODE>
HeapAllocFlags</CODE>
 indicate how the block should be allocated and initialized. They are not stored and can not be retrieved. Some of the flags can be passed with <CODE>
<A HREF="../../CRef/Routines/R_6e.htm#IX_MemReAlloc()">MemReAlloc()</A></CODE>
. The following flags are available:</P>
<DL>
<DT>
HAF_ZERO_INIT</DT><DD>
The memory manager should initialize the block to null bytes. This flag may be passed to <CODE>
<A HREF="../../CRef/Routines/R_6e.htm#IX_MemReAlloc()">MemReAlloc()</A></CODE>
 to cause new memory to be zero-initialized.</DD>
<DT>
HAF_LOCK</DT><DD>The memory manager should lock the block after allocating it. To get the block's address, call <CODE>
<A HREF="../../CRef/Routines/R_6b.htm#IX_MemDeref()">MemDeref()</A></CODE>
. This flag may be passed to <CODE>
<A HREF="../../CRef/Routines/R_6e.htm#IX_MemReAlloc()">MemReAlloc()</A></CODE>
.</DD>
<DT>
HAF_NO_ERR</DT><DD>
The memory manager should not return errors. If it cannot allocate block, GEOS will crash. Use of this flag is strongly discouraged. This flag may be passed to <CODE>
<A HREF="../../CRef/Routines/R_6e.htm#IX_MemReAlloc()">MemReAlloc()</A></CODE>
.</DD>
<DT>
HAF_UI</DT><DD>If both HAF_OBJECT_RESOURCE and HAF_UI are set, this block will be run by the application's UI thread.</DD>
<DT>
HAF_READ_ONLY</DT><DD>
The block's data will not be modified. Useful for the debugger.</DD>
<DT>
HAF_OBJECT_RESOURCE</DT><DD>
This block will be an object block.</DD>
<DT>
HAF_CODE</DT><DD>This block contains executable code.</DD>
<DT>
HAF_CONFORMING</DT><DD>
If the block contains code, the code may be run by a less privileged entity. If the block contains data, the data may be accessed or altered by a less privileged entity.</DD>
</DL>
<P>
If necessary, this routine will automatically compact the heap to find enough space to allocated the desired sized block.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
heap.h</STRONG>
 </P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_6b.htm#IX_MemAllocSetOwner()">MemAllocSetOwner()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_6e.htm#IX_MemReAlloc()">MemReAlloc()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_6b.htm#IX_MemDeref()">MemDeref()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_6b.htm_IX_MemAllocLMem()">
 </A>
<H1 CLASS="refHeading">
MemAllocLMem()</H1>
<PRE CLASS="syntax">MemHandle MemAllocLMem(
        LMemType		type,				/* type of LMem block */
        word		headerSize);				/* size of header structure */</PRE>
<P>
This routine allocates and initializes a local memory block; it can be used to simplify this procedure from the two-step process of <CODE>
<A HREF="../../CRef/Routines/R_6b.htm#IX_MemAlloc()">MemAlloc()</A></CODE>
 followed by <CODE>
<A HREF="../../CRef/Routines/R_64.htm#IX_LMemInitHeap()">LMemInitHeap()</A></CODE>
. Pass an LMem type indicating what will be stored in the block, along with the size of the header structure to use. If the block is to have the standard header, pass zero in <CODE>
headerSize</CODE>
.</P>
<P>
This routine returns the handle of the unlocked, newly allocated block. The block will contain two LMem handles and 64 bytes allocated for the LMem heap.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	lmem.h</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_64.htm#IX_LMemInitHeap()">LMemInitHeap()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_6b.htm_IX_MemAllocSetOwner()">
 </A>
<H1 CLASS="refHeading">
MemAllocSetOwner()</H1>
<PRE CLASS="syntax">MemHandle MemAllocSetOwner(
        GeodeHandle		owner,				/* Handle of block's owner */
        word		byteSize,				/* Size of block in bytes */
        HeapFlags		hfFlags,				/* Type of block */
        HeapAllocFlags		haFlags);				/* How to allocate block */</PRE>
<P>
This routine is the same as <CODE>
<A HREF="../../CRef/Routines/R_6b.htm#IX_MemAlloc()">MemAlloc()</A></CODE>
 except that you can specify the owner of the global memory block created.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	heap.h</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_6b.htm#IX_MemAlloc()">MemAlloc()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_6b.htm_IX_MemDecRefCount()">
 </A>
<H1 CLASS="refHeading">
MemDecRefCount()</H1>
<PRE CLASS="syntax">void	MemDecRefCount(
        MemHandle		mh);				/* handle of affected block */</PRE>
<P>
This routine decrements the reference count of a global memory block (the reference count is stored in HM<CODE>
_otherInfo</CODE>
). If the reference count reaches zero, <CODE>
MemDecRefCount()</CODE>
 will free the block.</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	This routine assumes that a reference count is stored in HM<CODE>
_otherInfo</CODE>
. You may only use this routine if the block has had a reference count set up with <CODE>
<A HREF="../../CRef/Routines/R_6c.htm#IX_MemInitRefCount()">MemInitRefCount()</A></CODE>
.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	heap.h</P>
</DIV>
<DIV>
<A NAME="R_6b.htm_IX_MemDeref()">
 </A>
<H1 CLASS="refHeading">
MemDeref()</H1>
<PRE CLASS="syntax">void	* MemDeref(
        MemHandle		mh);		/* Handle of locked block to dereference */</PRE>
<P>
This routine takes one argument, the handle of a global memory block; it returns the address of the block on the global heap. If the block has been discarded, or if the handle is not a memory handle, it returns a null pointer. It gets this information by reading the block's handle table entry; it does not need to actually access the block.</P>
<P>
Note that if the handle is of an unlocked, moveable block, <CODE>
MemDeref()</CODE>
 will return the block's address with out any warning; however, the address will be unreliable, since the memory manager can move the block at any time.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	heap.h</P>
<P CLASS="refField"><STRONG>
Tips and Tricks:</STRONG>	This is very useful when you allocate a fixed or locked block, and need to get the block's address without calling <CODE>
<A HREF="../../CRef/Routines/R_6d.htm#IX_MemLock()">MemLock()</A></CODE>
.</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	This routine, if given an unlocked, moveable block, will return the pointer without a warning, even though that block may move at any time.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_6c.htm#IX_MemGetInfo()">MemGetInfo()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_6e.htm#IX_MemModifyFlags()">MemModifyFlags()</A></CODE>.</P>
</DIV>
<HR>
<A NAME="R_6c.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_6c.htm_IX_MemDowngradeExclLock()">
 </A>
<H1 CLASS="refHeading">
MemDowngradeExclLock()</H1>
<PRE CLASS="syntax">void	MemDowngradeExclLock(
        MemHandle		mh);			/* handle of affected block */</PRE>
<P>
An application that has an exclusive lock on a block may downgrade it to a shared lock with this routine. It does not otherwise affect the block.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	heap.h</P>
</DIV>
<DIV>
<A NAME="R_6c.htm_IX_MemFree()">
 </A>
<H1 CLASS="refHeading">
MemFree()</H1>
<PRE CLASS="syntax">void	MemFree(
        MemHandle		mh);			/* handle of block to be freed */</PRE>
<P>
This routine frees a global memory block. The block can be locked or unlocked. </P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	heap.h</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	The routine does not care whether other threads have locked the block. If you try to free a bad handle, routine may fatal-error.</P>
</DIV>
<DIV>
<A NAME="R_6c.htm_IX_MemGetInfo()">
 </A>
<H1 CLASS="refHeading">
MemGetInfo()</H1>
<PRE CLASS="syntax">word	MemGetInfo( /* return value depends on flag passed */
        MemHandle		mh, 			/* Handle of block to get info about */
        MemGetInfoType		info);			/* Type of information to get */</PRE>
<P>
<CODE>
MemGetInfo()</CODE>
 is a general-purpose routine for getting information about a global memory block. It gets the information by looking in the block's handle table entry; it does not need to access the actual block. It returns a single word of data; the meaning of that word depends on the value of the <CODE>
MemGetInfoType</CODE>
 variable passed. The following types are available:</P>
<DL>
<DT>
MGIT_SIZE</DT><DD>Return value is size of the block in bytes. This may be larger than the size originally requested, as blocks are allocated along paragraph boundaries.</DD>
<DT>
MGIT_FLAGS_AND_LOCK_COUNT</DT><DD>
The upper byte of the return value is the current <CODE>
HeapFlags</CODE>
 record for the block. The lower byte is the number of locks currently on the block.</DD>
<DT>
MGIT_OWNER_OR_VM_FILE_HANDLE</DT><DD>
If the block is part of a VM file, return value is the VM file handle. Otherwise, return value is the GeodeHandle of the owning thread.</DD>
<DT>
MGIT_ADDRESS</DT><DD>
Return value is block's segment address on the global heap, or zero if block has been discarded. If block is unlocked and moveable, address may change without warning. Ordinarily, <CODE>
<A HREF="../../CRef/Routines/R_6b.htm#IX_MemDeref()">MemDeref()</A></CODE>
 is preferable.</DD>
<DT>
MGIT_OTHER_INFO</DT><DD>
Returns the value of the <CODE>
HM_otherInfo</CODE>
 word. This word is used in different ways for different types of handles.</DD>
<DT>
MGIT_EXEC_THREAD</DT><DD>
Returns the ThreadHandle of the thread executing this block, if any.</DD>
</DL>
<P CLASS="refField"><STRONG>
Include:</STRONG>	heap.h</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	If the handle is not a global memory block handle, results are unpredictable (the routine will read inappropriate data from the handle table entry).</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_6b.htm#IX_MemDeref()">MemDeref()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_6e.htm#IX_MemModifyFlags()">MemModifyFlags()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_6e.htm#IX_MemModifyOtherInfo()">MemModifyOtherInfo()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_55.htm#IX_HandleModifyOwner()">HandleModifyOwner()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_6c.htm_IX_MemIncRefCount()">
 </A>
<H1 CLASS="refHeading">
MemIncRefCount()</H1>
<PRE CLASS="syntax">void	MemIncRefCount(
        MemHandle		mh);			/* handle of affected block */</PRE>
<P>
This routine increments the reference count of a global memory block (the reference count is stored in HM<CODE>
_otherInfo</CODE>
).</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	This routine assumes that a reference count is stored in HM<CODE>
_otherInfo</CODE>
. You may only use this routine if the block has had a reference count set up with <CODE>
<A HREF="../../CRef/Routines/R_6c.htm#IX_MemInitRefCount()">MemInitRefCount()</A></CODE>
.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	heap.h</P>
</DIV>
<DIV>
<A NAME="R_6c.htm_IX_MemInitRefCount()">
 </A>
<H1 CLASS="refHeading">
MemInitRefCount()</H1>
<PRE CLASS="syntax">void	MemInitRefCount(
        MemHandle		mh,				/* handle of affected block */
        word		count);				/* initial reference count */</PRE>
<P>
This routine sets up a reference count for the specified global memory block. The passed count is stored in the HM<CODE>
_otherInfo</CODE>
 field of the block's handle-table entry.</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	This routine overwrites the HM<CODE>
_otherInfo</CODE>
 field. Since the semaphore routines (<CODE>
<A HREF="../../CRef/Routines/R_55.htm#IX_HandleP()">HandleP()</A></CODE>
 and <CODE>
<A HREF="../../CRef/Routines/R_56.htm#IX_HandleV()">HandleV()</A></CODE>
 and the routines which use them) use this field, you cannot use both the semaphore routines and the reference count routines on the same block.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	heap.h</P>
</DIV>
<HR>
<A NAME="R_6d.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_6d.htm_IX_MemLock()">
 </A>
<H1 CLASS="refHeading">
MemLock()</H1>
<PRE CLASS="syntax">void	* MemLock(
        MemHandle		mh);			/* Handle of block to lock */</PRE>
<P>
This routine locks a global memory block on the global heap. If the block is swapped, the memory manager swaps it back into the global heap; it then increments the lock count (up to a maximum of 255). The block will not be moved, swapped, or discarded until the lock count reaches zero. This routine returns a pointer to the start of the block, or a null pointer if block has been discarded. To get the address of a block without locking it, use <CODE>
<A HREF="../../CRef/Routines/R_6b.htm#IX_MemDeref()">MemDeref()</A></CODE>
.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	heap.h</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	If you try to lock a bad handle, the routine may fatal-error. This routine does not check for synchronization problems; if the block is used by several threads, you should use the synchronization routines.</P>
<P CLASS="refField">
<STRONG>Never Use Situations:</STRONG>	<BR>
Never lock a fixed block. Never use <CODE>MemLock()</CODE> to lock a block
containing objects. Instead use <A HREF="#R_7b.htm_IX_ObjLockObjBlock()">
<CODE>ObjLockObjBlock()</CODE></A> and then use
<A HREF="#R_70.htm_IX_MemUnlock()"><CODE>MemUnlock()</CODE></A> to unlock
the block.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_6b.htm#IX_MemDeref()">MemDeref()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_6d.htm_IX_MemLockExcl()">
 </A>
<H1 CLASS="refHeading">
MemLockExcl()</H1>
<PRE CLASS="syntax">void	* MemLockExcl(
        MemHandle		mh);			/* Handle of block to grab */</PRE>
<P>
If several different threads will be accessing the same global memory block, they should use data-access synchronization routines. <CODE>
MemLockExcl()</CODE>
 belongs to one such set of routines. Often, several threads will need access to the same block; however, most of the time, they will not need to change the block. There is no synchronization problem if several threads read the same block at once, as long as none of them alters the block (by resizing it, writing to it, etc.) However, if a thread needs to change a block, no other thread should have access at that time.</P>
<P>
The routines <CODE>
MemLockExcl()</CODE>
, <CODE>
<A HREF="../../CRef/Routines/R_6d.htm#IX_MemLockShared()">MemLockShared()</A></CODE>
, <CODE>
<A HREF="../../CRef/Routines/R_70.htm#IX_MemUnlockShared()">MemUnlockShared()</A></CODE>
, and <CODE>
<A HREF="../../CRef/Routines/R_70.htm#IX_MemUnlockExcl()">MemUnlockExcl()</A></CODE>
 take advantage of this situation. They maintain a queue of threads requesting access to a block. When the block is not being used, they awaken the highest priority thread on the queue. If that thread requested exclusive access, the other threads sleep until it relinquishes access (via <CODE>
<A HREF="../../CRef/Routines/R_70.htm#IX_MemUnlockExcl()">MemUnlockExcl()</A></CODE>
). If it requested shared access, the routines awaken every other thread which requested shared access; the other threads on the queue will sleep until every active thread relinquishes access (via <CODE>
<A HREF="../../CRef/Routines/R_70.htm#IX_MemUnlockShared()">MemUnlockShared()</A></CODE>
).</P>
<P>
<CODE>
MemLockExcl()</CODE>
 requests exclusive access to the block. If the block is not being accessed, the routine will grab exclusive access for the block, lock the block, and return the block's address. If the block is being accessed, the routine will sleep on the queue until it can get access; it will then awaken, lock the block, and return its address.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	heap.h</P>
<P CLASS="refField"><STRONG>
Tips and Tricks:</STRONG>	You can find out if the block is being accessed by looking at the HM<CODE>
_otherInfo</CODE>
 word (with <CODE>
<A HREF="../../CRef/Routines/R_6c.htm#IX_MemGetInfo()">MemGetInfo()</A></CODE>
). If HM<CODE>
_otherInfo</CODE>
 equals one, the block is not grabbed; if it equals zero, it is grabbed, but no threads are queued; otherwise, it equals the handle of the first thread queued.</P>
<P CLASS="refField"><STRONG>
Be Sure To:</STRONG>	Make sure that all routines accessing the block get access with <CODE>
MemLockExcl()</CODE>
 or <CODE>
<A HREF="../../CRef/Routines/R_6d.htm#IX_MemLockShared()">MemLockShared()</A></CODE>
. The routines use the block's <CODE>
HM_otherInfo</CODE>
 word; you must not alter it. When you are done accessing the block, make sure to relinquish access by calling <CODE>
<A HREF="../../CRef/Routines/R_70.htm#IX_MemUnlockExcl()">MemUnlockExcl()</A></CODE>
.</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	If a thread calls <CODE>
MemLockExcl()</CODE>
 when it already has shared or exclusive access, it will deadlock; it will sleep until access is relinquished, but it cannot relinquish access while it is sleeping. If you try to grab a block which is owned by a different geode and is non-sharable, the routine will fatal-error.</P>
<P CLASS="refField"><STRONG>
Never Use Situations:</STRONG>	<BR>
Never use <CODE>
MemLockExcl()</CODE>
 or <CODE>
<A HREF="../../CRef/Routines/R_6d.htm#IX_MemLockShared()">MemLockShared()</A></CODE>
 on a fixed block. It will attempt to lock the block, and fixed blocks cannot be locked. Instead, use the <CODE>
<A HREF="../../CRef/Routines/R_55.htm#IX_HandleP()">HandleP()</A></CODE>
 and <CODE>
<A HREF="../../CRef/Routines/R_56.htm#IX_HandleV()">HandleV()</A></CODE>
 routines.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_6d.htm#IX_MemLockShared()">MemLockShared()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_70.htm#IX_MemUnlockExcl()">MemUnlockExcl()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_70.htm#IX_MemUnlockShared()">MemUnlockShared()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_6d.htm_IX_MemLockFixedOrMovable()">
 </A>
<H1 CLASS="refHeading">
MemLockFixedOrMovable()</H1>
<PRE CLASS="syntax">void	* MemLockFixedOrMovable(
        void	* ptr);		/* virtual segment */</PRE>
<P>
Given a virtual segment, this routine locks it (if it was movable). A virtual segment is an opaque pointer to a block that an application views as locked or fixed--the memory manager can actually swap locked or fixed blocks and will designate them as virtual segments.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	heap.h</P>
</DIV>
<DIV>
<A NAME="R_6d.htm_IX_MemLockShared()">
 </A>
<H1 CLASS="refHeading">
MemLockShared()</H1>
<PRE CLASS="syntax">void	* MemLockShared(
        MemHandle		mh);			/* Handle of block to grab */</PRE>
<P>
<CODE>
MemLockShared()</CODE>
 requests shared access to the passed block. If the block is not being accessed, or if it is held for shared access and the queue is empty, the routine gets access, locks the block, and returns the block's address. Otherwise it sleeps on the queue until the shared requests are awakened; it then locks the block and returns the block's address.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	heap.h</P>
<P CLASS="refField"><STRONG>
Be Sure To:</STRONG>	Make sure that all routines accessing the block get access with <CODE>
<A HREF="../../CRef/Routines/R_6d.htm#IX_MemLockExcl()">MemLockExcl()</A></CODE>
 or <CODE>
MemLockShared()</CODE>
. The routines use the block's HM<CODE>
_otherInfo</CODE>
 word; you must not alter it. When you are done accessing the block, make sure to relinquish access by calling <CODE>
<A HREF="../../CRef/Routines/R_70.htm#IX_MemUnlockExcl()">MemUnlockExcl()</A></CODE>
.</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	If a thread calls <CODE>
MemLockShared()</CODE>
 when it already has exclusive access, it will deadlock; it will sleep until access is relinquished, but it cannot relinquish access while it is sleeping. The thread must be careful not to take actions which could change the block, such as resizing it or writing to it. The routine will not enforce this. If you try to grab a block which is owned by a different geode and is non-sharable, the routine will fatal-error.</P>
<P CLASS="refField"><STRONG>
Never Use Situations:</STRONG>	<BR>
Never use <CODE>
<A HREF="../../CRef/Routines/R_6d.htm#IX_MemLockExcl()">MemLockExcl()</A></CODE>
 or <CODE>
MemLockShared()</CODE>
 on a fixed block. It will attempt to lock the block, and fixed blocks cannot be locked. Instead, use the <CODE>
<A HREF="../../CRef/Routines/R_55.htm#IX_HandleP()">HandleP()</A></CODE>
 and <CODE>
<A HREF="../../CRef/Routines/R_56.htm#IX_HandleV()">HandleV()</A></CODE>
 routines.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_6d.htm#IX_MemLockExcl()">MemLockExcl()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_70.htm#IX_MemUnlockExcl()">MemUnlockExcl()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_70.htm#IX_MemUnlockShared()">MemUnlockShared()</A></CODE>.</P>
</DIV>
<HR>
<A NAME="R_6e.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_6e.htm_IX_MemModifyFlags()">
 </A>
<H1 CLASS="refHeading">
MemModifyFlags()</H1>
<PRE CLASS="syntax">void	MemModifyFlags(
        MemHandle		mh,					/* Handle of block to modify */
        HeapFlags		bitsToSet,					/* HeapFlags to turn on */
        HeapFlags		bitsToClear);					/* HeapFlags to turn off */</PRE>
<P>
<CODE>
MemModifyFlags() </CODE>
changes the<CODE>
 </CODE>
<CODE>
HeapFlags</CODE>
 record of the global memory<CODE>
 </CODE>
block specified. Not all flags can be changed after the block is created; only the flags<CODE>
 </CODE>
HF_SHARABLE, HF_DISCARDABLE, HF_SWAPABLE, and HF_LMEM can be changed.</P>
<P>
The routine uses the handle table entry of the block specified; it does not need to look at the actual block. The routine performs normally whether or not the block is locked, fixed, or discarded.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	heap.h</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	If the handle is not a global memory handle, results are unpredictable; the routine will change inappropriate bits of the handle table entry.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_6c.htm#IX_MemGetInfo()">MemGetInfo()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_55.htm#IX_HandleModifyOwner()">HandleModifyOwner()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_6e.htm#IX_MemModifyOtherInfo()">MemModifyOtherInfo()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_6e.htm_IX_MemModifyOtherInfo()">
 </A>
<H1 CLASS="refHeading">
MemModifyOtherInfo()</H1>
<PRE CLASS="syntax">void	MemModifyOtherInfo(
        MemHandle		mh,				/* Handle of block to modify */
        word		otherInfo);				/* New value of HM_otherInfo word */</PRE>
<P>
Use this routine to change the value of the global memory block's HM<CODE>
_otherInfo</CODE>
 word. Some blocks need this word left alone; for example, data-access synchronization routines use this word. Object blocks use this space to store the handle of the burden thread.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	heap.h</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_6c.htm#IX_MemGetInfo()">MemGetInfo()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_6e.htm#IX_MemModifyFlags()">MemModifyFlags()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_55.htm#IX_HandleModifyOwner()">HandleModifyOwner()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_6e.htm_IX_MemOwner()">
 </A>
<H1 CLASS="refHeading">
MemOwner()</H1>
<PRE CLASS="syntax">GeodeHandle MemOwner(
        MemHandle		mh);			/* handle of block queried */</PRE>
<P>
This routine returns the owning geode of the passed block. If the block belongs to a VM file, the owner of the VM file will be returned (unlike <CODE>
<A HREF="../../CRef/Routines/R_6c.htm#IX_MemGetInfo()">MemGetInfo()</A></CODE>
, which returns the VM file handle).</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	heap.h</P>
</DIV>
<DIV>
<A NAME="R_6e.htm_IX_MemPLock()">
 </A>
<H1 CLASS="refHeading">
MemPLock()</H1>
<PRE CLASS="syntax">void	* MemPLock(
        MemHandle		mh);		/* Handle of block to lock */</PRE>
<P>
If several different threads will be accessing the same global memory block, they need to make sure their activities will not conflict. The way they do that is to use synchronization routines to get control of a block. <CODE>
MemPLock()</CODE>
 is part of one set of synchronization routines.</P>
<P>
If the threads are using the <CODE>
MemPLock()</CODE>
 family, then whenever a thread needs access to the block in question, it can call <CODE>
MemPLock()</CODE>
. This routine calls <CODE>
<A HREF="../../CRef/Routines/R_55.htm#IX_HandleP()">HandleP()</A></CODE>
 to get control of the block; it then locks the block and returns its address. If the block has been discarded, it grabs the block and returns a null pointer; you can then reallocate the block. When the thread is done with the block, it should release it with <CODE>
<A HREF="../../CRef/Routines/R_70.htm#IX_MemUnlockV()">MemUnlockV()</A></CODE>
.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	heap.h</P>
<P CLASS="refField"><STRONG>
Tips and Tricks:</STRONG>	You can find out if the block is being accessed by looking at the HM<CODE>
_otherInfo</CODE>
 word (with <CODE>
<A HREF="../../CRef/Routines/R_6c.htm#IX_MemGetInfo()">MemGetInfo()</A></CODE>
). If HM<CODE>
_otherInfo</CODE>
 equals one, the block is not grabbed; if it equals zero, it is grabbed, but no threads are queued; otherwise, it equals the handle of the first thread queued.</P>
<P CLASS="refField"><STRONG>
Be Sure To:</STRONG>	Make sure that all threads accessing the block use <CODE>
MemPLock()</CODE>
 and/or <CODE>
<A HREF="../../CRef/Routines/R_55.htm#IX_HandleP()">HandleP()</A></CODE>
 to grab the block. These routines use the HM<CODE>
_otherInfo</CODE>
 field of the block's handle table entry; do not alter this field. Release the block with <CODE>
<A HREF="../../CRef/Routines/R_56.htm#IX_HandleV()">HandleV()</A></CODE>
 or <CODE>
<A HREF="../../CRef/Routines/R_70.htm#IX_MemUnlockV()">MemUnlockV()</A></CODE>
 when you are done with it.</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	If a thread calls <CODE>
MemPLock()</CODE>
 when it already has control of the block, it will deadlock. <CODE>
<A HREF="../../CRef/Routines/R_6f.htm#IX_MemThreadGrab()">MemThreadGrab()</A></CODE>
 avoids this conflict. If you try to grab a non-sharable block owned by another thread, <CODE>
MemPLock()</CODE>
 will fatal-error.</P>
<P CLASS="refField"><STRONG>
Never Use Situations:</STRONG>	<BR>
Never use <CODE>
MemPLock()</CODE>
 with a fixed block. It will try to lock the block, and fixed blocks cannot be locked. Instead, use <CODE>
<A HREF="../../CRef/Routines/R_55.htm#IX_HandleP()">HandleP()</A></CODE>
.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_55.htm#IX_HandleP()">HandleP()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_70.htm#IX_MemUnlockV()">MemUnlockV()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_56.htm#IX_HandleV()">HandleV()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_6e.htm_IX_MemPtrToHandle()">
 </A>
<H1 CLASS="refHeading">
MemPtrToHandle()</H1>
<PRE CLASS="syntax">MemHandle MemPtrToHandle(
        void	* ptr);		/* pointer to locked block */</PRE>
<P>
This routine returns the global handle of the locked block.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	heap.h</P>
</DIV>
<DIV>
<A NAME="R_6e.htm_IX_MemReAlloc()">
 </A>
<H1 CLASS="refHeading">
MemReAlloc()</H1>
<PRE CLASS="syntax">MemHandle 	MemReAlloc(
        MemHandle		mh,					/* Handle of block */
        word		byteSize,					/* New size of the block */
        HeapAllocFlags		heapAllocFlags);					/* How to reallocate block */</PRE>
<P>
This routine reallocates a global memory block. It can be used to resize a block; it can also be used to reallocate memory for a discarded block. Locked and fixed blocks can be reallocated; however, they may move on the global heap, so all pointers within the block must be adjusted. Note, however, that if the new size is smaller than the old size, the block is guaranteed not to move. The reallocated block may be larger than the size requested, as the block size is rounded up to the next even paragraph (one paragraph equals sixteen bytes). If you request that the block be expanded, but this is impossible, then the routine will return NullHandle. </P>
<P>
The routine is passed a record of <CODE>
HeapAllocFlags</CODE>
. Only the flags HAF_ZERO_INIT, HAF_LOCK, and HAF_NO_ERR may be passed.</P>
<P>
If necessary, the routine will automatically compact the heap.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	heap.h</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	If HAF_LOCK is passed, the lock count will be incremented even if the block is already locked by this thread. The routine does not care whether the block has been locked by another thread (possibly belonging to another geode); thus, if the block is being used by more than one thread, it is important to use the synchronization routines.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_6b.htm#IX_MemAlloc()">MemAlloc()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_6b.htm#IX_MemDeref()">MemDeref()</A></CODE>.</P>
</DIV>
<HR>
<A NAME="R_6f.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_6f.htm_IX_MemThreadGrab()">
 </A>
<H1 CLASS="refHeading">
MemThreadGrab()</H1>
<PRE CLASS="syntax">void	* MemThreadGrab(
        MemHandle		mh);			/* Handle of block to grab */</PRE>
<P>
<CODE>
MemThreadGrab()</CODE>
 is used in conjunction with <CODE>
<A HREF="../../CRef/Routines/R_6f.htm#IX_MemThreadGrabNB()">MemThreadGrabNB()</A></CODE>
 and <CODE>
<A HREF="../../CRef/Routines/R_6f.htm#IX_MemThreadRelease()">MemThreadRelease()</A></CODE>
 to maintain data-access synchronization. If several threads will all have access to the same global memory block, they should use data-acess synchronization routines to make sure that their activities do not conflict. If a thread uses <CODE>
MemThreadGrab()</CODE>
 and no other thread has grabbed the block in question, the routine will increment the &quot;grab count,&quot; lock the block, and return its address. It can do this even if the calling thread has already grabbed the block. If another thread has grabbed the block, <CODE>
MemThreadGrab()</CODE>
 will put the calling thread in a queue to get the block; the thread will sleep until it gets the block, then <CODE>
MemThreadGrab()</CODE>
 will grab the block, lock it, and return its address.</P>
<P>
If the block has been discarded, <CODE>
MemThreadGrab()</CODE>
 grabs the block and returns a null pointer; you can then reallocate memory for the block.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	heap.h</P>
<P CLASS="refField"><STRONG>
Be Sure To:</STRONG>	Make sure that all threads using the block use the <CODE>
MemThread...()</CODE>
 routines to access it (not other data-acess synchronization routines). Do not change the HM<CODE>
_otherInfo</CODE>
 word of the block's handle table entry (the routines use that word as a semaphore).</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	If you try to grab a block which is owned by a different geode and is non-sharable, the routine will fatal-error.</P>
<P CLASS="refField"><STRONG>
Never Use Situations:</STRONG>	<BR>
Never use <CODE>
MemThreadGrab()</CODE>
 with a fixed block. It will try to lock the block, and fixed blocks cannot be locked. If you need data-access synchronization for a fixed block, use the <CODE>
<A HREF="../../CRef/Routines/R_55.htm#IX_HandleP()">HandleP()</A></CODE>
 and <CODE>
<A HREF="../../CRef/Routines/R_56.htm#IX_HandleV()">HandleV()</A></CODE>
 routines.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_6f.htm#IX_MemThreadGrabNB()">MemThreadGrabNB()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_6f.htm#IX_MemThreadRelease()">MemThreadRelease()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_6f.htm_IX_MemThreadGrabNB()">
 </A>
<H1 CLASS="refHeading">
MemThreadGrabNB()</H1>
<PRE CLASS="syntax">void	* MemThreadGrabNB(
        MemHandle		mh); /* handle of block to grab */</PRE>
<P>
This is a data-synchronization routine to be used in conjunction with <CODE>
<A HREF="../../CRef/Routines/R_6f.htm#IX_MemThreadGrab()">MemThreadGrab()</A></CODE>
 and <CODE>
<A HREF="../../CRef/Routines/R_6f.htm#IX_MemThreadRelease()">MemThreadRelease()</A></CODE>
. It is exactly the same as <CODE>
<A HREF="../../CRef/Routines/R_6f.htm#IX_MemThreadGrab()">MemThreadGrab()</A></CODE>
, except that if it cannot grab the global memory block because another thread has it, the routine returns an error instead of blocking.</P>
<P>
If successful, <CODE>
MemThreadGrabNB()</CODE>
 returns a pointer to the block. If the block has been discarded, it grabs the block and returns a null pointer; you can then reallocate memory for the block. If the block has been grabbed by another thread, <CODE>
<A HREF="../../CRef/Routines/R_6f.htm#IX_MemThreadGrab()">MemThreadGrab()</A></CODE>
 returns the constant BLOCK_GRABBED.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	heap.h</P>
<P CLASS="refField"><STRONG>
Tips and Tricks:</STRONG>	You can find out if the block is being accessed by looking at the HM<CODE>
_otherInfo</CODE>
 word (with <CODE>
<A HREF="../../CRef/Routines/R_6c.htm#IX_MemGetInfo()">MemGetInfo()</A></CODE>
). If HM<CODE>
_otherInfo</CODE>
 equals one, the block is not grabbed; if it equals zero, it is grabbed, but no threads are queued; otherwise, it equals the handle of the first thread queued.</P>
<P CLASS="refField"><STRONG>
Be Sure To:</STRONG>	Make sure that all threads using the block use the <CODE>
MemThread...()</CODE>
 routines to access the block (not other data-access synchronization routines). Do not change the HM<CODE>
_otherInfo</CODE>
 word of the block's handle table entry (the routines use that word as a semaphore).</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	If you try to grab a block that is owned by a different geode and is non-sharable, the routine will fatal-error.</P>
<P CLASS="refField"><STRONG>
Never Use Situations:</STRONG>	<BR>
Never use <CODE>
MemThreadGrabNB()</CODE>
 with a fixed block. It will try to lock the block, and fixed blocks cannot be locked. If you need synchronization for a fixed block, use the <CODE>
<A HREF="../../CRef/Routines/R_55.htm#IX_HandleP()">HandleP()</A></CODE>
 and <CODE>
<A HREF="../../CRef/Routines/R_56.htm#IX_HandleV()">HandleV()</A></CODE>
 routines.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_6f.htm#IX_MemThreadGrab()">MemThreadGrab()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_6f.htm#IX_MemThreadRelease()">MemThreadRelease()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_6f.htm_IX_MemThreadRelease()">
 </A>
<H1 CLASS="refHeading">
MemThreadRelease()</H1>
<PRE CLASS="syntax">void	MemThreadRelease(
        MemHandle		mh); /* handle of locked block to release */</PRE>
<P>
Use this routine to release a global memory block which you have grabbed with <CODE>
<A HREF="../../CRef/Routines/R_6f.htm#IX_MemThreadGrab()">MemThreadGrab()</A></CODE>
 or <CODE>
<A HREF="../../CRef/Routines/R_6f.htm#IX_MemThreadGrabNB()">MemThreadGrabNB()</A></CODE>
. The routine decrements the grab count; if the grab count reaches zero, the routine unlocks the block.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	heap.h</P>
<P CLASS="refField"><STRONG>
Tips and Tricks:</STRONG>	You can find out if the block is being accessed by looking at the HM<CODE>
_otherInfo</CODE>
 word (with <CODE>
<A HREF="../../CRef/Routines/R_6c.htm#IX_MemGetInfo()">MemGetInfo()</A></CODE>
). If HM<CODE>
_otherInfo</CODE>
 equals one, the block is not grabbed; if it equals zero, it is grabbed, but no threads are queued; otherwise, it equals the handle of the first thread queued.</P>
<P CLASS="refField"><STRONG>
Be Sure To:</STRONG>	Make sure that all threads using the block use the <CODE>
MemThread...()</CODE>
 routines to access the block (not other data-access synchronization routines). Do not change the HM<CODE>
_otherInfo</CODE>
 word of the block's handle table entry (the routines use that word as a semaphore). Make sure to release the block once for every time you grab it; the block is not unlocked until each of your grabs is released.</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	If you try to release a block that you have not successfully grabbed, the routine will fatal-error.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_6f.htm#IX_MemThreadGrab()">MemThreadGrab()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_6f.htm#IX_MemThreadGrabNB()">MemThreadGrabNB()</A></CODE>.</P>
</DIV>
<HR>
<A NAME="R_70.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_70.htm_IX_MemUnlock()">
 </A>
<H1 CLASS="refHeading">
MemUnlock()</H1>
<PRE CLASS="syntax">void	MemUnlock(
        MemHandle		mh);		/* Handle of block to unlock */</PRE>
<P>
This routine decrements the lock count of the indicated block. If the lock count reaches zero, the block becomes unlocked (it can be moved, swapped, or discarded). Do not try to unlock a block that has not been locked.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	heap.h</P>
</DIV>
<DIV>
<A NAME="R_70.htm_IX_MemUnlockExcl()">
 </A>
<H1 CLASS="refHeading">
MemUnlockExcl()</H1>
<PRE CLASS="syntax">void	MemUnlockExcl(
        memHandle		mh);			/* Handle of block to release */</PRE>
<P>
If a thread has gained access to a block with <CODE>
<A HREF="../../CRef/Routines/R_6d.htm#IX_MemLockExcl()">MemLockExcl()</A></CODE>
, it should release the block as soon as it can. Until it does, no other thread can access the block for either shared or exclusive access. It can release the block by calling <CODE>
MemUnlockExcl()</CODE>
. This routine unlocks the block and releases the thread's access to it. If there is a queue for this block, the highest-priority thread waiting will be awakened, as described in <CODE>
<A HREF="../../CRef/Routines/R_6d.htm#IX_MemLockExcl()">MemLockExcl()</A></CODE>
.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	heap.h</P>
<P CLASS="refField"><STRONG>
Tips and Tricks:</STRONG>	You can find out if the block is being accessed by looking at the HM<CODE>
_otherInfo</CODE>
 word (with <CODE>
<A HREF="../../CRef/Routines/R_6c.htm#IX_MemGetInfo()">MemGetInfo()</A></CODE>
). If HM<CODE>
_otherInfo</CODE>
 equals one, the block is not grabbed; if it equals zero, it is grabbed, but no threads are queued; otherwise, it equals the handle of the first thread queued.</P>
<P CLASS="refField"><STRONG>
Be Sure To:</STRONG>	Make sure that all routines accessing the block get access with <CODE>
<A HREF="../../CRef/Routines/R_6d.htm#IX_MemLockExcl()">MemLockExcl()</A></CODE>
 or <CODE>
<A HREF="../../CRef/Routines/R_6d.htm#IX_MemLockShared()">MemLockShared()</A></CODE>
. The routines use the block's HM<CODE>
_otherInfo</CODE>
 word; you must not alter it. Call this routine while the block is still locked; it will call <CODE>
<A HREF="../../CRef/Routines/R_70.htm#IX_MemUnlock()">MemUnlock()</A></CODE>
 to unlock the block.</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	If you call this routine on a block which you have not gained access to, it may fatal-error.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_6d.htm#IX_MemLockExcl()">MemLockExcl()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_6d.htm#IX_MemLockShared()">MemLockShared()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_70.htm#IX_MemUnlockShared()">MemUnlockShared()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_70.htm_IX_MemUnlockFixedOrMovable()">
 </A>
<H1 CLASS="refHeading">
MemUnlockFixedOrMovable()</H1>
<PRE CLASS="syntax">void	MemUnlockFixedOrMovable(
        void	* ptr);		/* virtual segment */</PRE>
<P>
This routine unlocks a previously locked, movable virtual segment. Do not call this routine with normal locked or fixed blocks; only call it for those blocks locked with <CODE>
<A HREF="../../CRef/Routines/R_6d.htm#IX_MemLockFixedOrMovable()">MemLockFixedOrMovable()</A></CODE>
.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	heap.h</P>
</DIV>
<DIV>
<A NAME="R_70.htm_IX_MemUnlockShared()">
 </A>
<H1 CLASS="refHeading">
MemUnlockShared()</H1>
<PRE CLASS="syntax">void	MemUnlockShared(
        MemHandle		mh);		/* Handle of block to release */</PRE>
<P>
If a thread has gained access to a block with <CODE>
<A HREF="../../CRef/Routines/R_6d.htm#IX_MemLockShared()">MemLockShared()</A></CODE>
, it should release the block as soon as it can. Until it does, no thread can be awakened from the queue. It can release the block by calling <CODE>
MemUnlockShared()</CODE>
. This routine calls <CODE>
<A HREF="../../CRef/Routines/R_70.htm#IX_MemUnlock()">MemUnlock()</A></CODE>
, decrementing the block's lock count; it then releases the thread's access to it. If no other thread is accessing the block and there is a queue for this block, the highest-priority thread waiting will be awakened, as described in <CODE>
<A HREF="../../CRef/Routines/R_6d.htm#IX_MemLockExcl()">MemLockExcl()</A></CODE>
.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	heap.h</P>
<P CLASS="refField"><STRONG>
Tips and Tricks:</STRONG>	You can find out if the block is being accessed by looking at the HM<CODE>
_otherInfo</CODE>
 word (with <CODE>
<A HREF="../../CRef/Routines/R_6c.htm#IX_MemGetInfo()">MemGetInfo()</A></CODE>
). If HM<CODE>
_otherInfo</CODE>
 equals one, the block is not grabbed; if it equals zero, it is grabbed, but no threads are queued; otherwise, it equals the handle of the first thread queued.</P>
<P CLASS="refField"><STRONG>
Be Sure To:</STRONG>	Make sure that all routines accessing the block get access with <CODE>
<A HREF="../../CRef/Routines/R_6d.htm#IX_MemLockExcl()">MemLockExcl()</A></CODE>
 or <CODE>
<A HREF="../../CRef/Routines/R_6d.htm#IX_MemLockShared()">MemLockShared()</A></CODE>
. These routines use the block's HM<CODE>
_otherInfo</CODE>
 word; you must not alter it. Call this routine while the block is still locked; it will call <CODE>
<A HREF="../../CRef/Routines/R_70.htm#IX_MemUnlock()">MemUnlock()</A></CODE>
 to unlock the block.</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	If you call this routine on a block which you have not gained access to, it may fatal-error.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_6d.htm#IX_MemLockExcl()">MemLockExcl()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_6d.htm#IX_MemLockShared()">MemLockShared()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_70.htm#IX_MemUnlockExcl()">MemUnlockExcl()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_70.htm_IX_MemUnlockV()">
 </A>
<H1 CLASS="refHeading">
MemUnlockV()</H1>
<PRE CLASS="syntax">void	MemUnlockV(
        MemHandle		mh);			/* Handle of block to release */</PRE>
<P>
This routine unlocks a block with <CODE>
<A HREF="../../CRef/Routines/R_70.htm#IX_MemUnlock()">MemUnlock()</A></CODE>
, then releases its semaphore with <CODE>
<A HREF="../../CRef/Routines/R_56.htm#IX_HandleV()">HandleV()</A></CODE>
. Do not use this routine unless the block's semaphore was grabbed and the block locked (typically with the <CODE>
<A HREF="../../CRef/Routines/R_6e.htm#IX_MemPLock()">MemPLock()</A></CODE>
 routine).</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	heap.h</P>
<P CLASS="refField"><STRONG>
Tips and Tricks:</STRONG>	You can find out if the block is being accessed by looking at the HM<CODE>
_otherInfo</CODE>
 word (with <CODE>
<A HREF="../../CRef/Routines/R_6c.htm#IX_MemGetInfo()">MemGetInfo()</A></CODE>
). If HM<CODE>
_otherInfo</CODE>
 equals one, the block is not grabbed; if it equals zero, it is grabbed, but no threads are queued; otherwise, it equals the handle of the first thread queued.</P>
<P CLASS="refField"><STRONG>
Be Sure To:</STRONG>	Make sure that all threads accessing the block use <CODE>
<A HREF="../../CRef/Routines/R_55.htm#IX_HandleP()">HandleP()</A></CODE>
 or <CODE>
<A HREF="../../CRef/Routines/R_6e.htm#IX_MemPLock()">MemPLock()</A></CODE>
 to access the thread. These routines use the<CODE>
 </CODE>
HM<CODE>
_otherInfo</CODE>
 field of the handle table entry; do not alter this field.</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	Do not use this on a block unless you have grabbed it. The routine does not check to see that you have grabbed the thread; it just clears the semaphore and returns.</P>
<P CLASS="refField"><STRONG>
Never Use Situations:</STRONG>	<BR>
Never use this routine to release a fixed block. It will try to unlock the block; fixed blocks cannot be locked or unlocked. Instead, call <CODE>
<A HREF="../../CRef/Routines/R_56.htm#IX_HandleV()">HandleV()</A></CODE>
 directly.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_6e.htm#IX_MemPLock()">MemPLock()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_55.htm#IX_HandleP()">HandleP()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_56.htm#IX_HandleV()">HandleV()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_70.htm_IX_MemUpgradeSharedLock()">
 </A>
<H1 CLASS="refHeading">
MemUpgradeSharedLock()</H1>
<PRE CLASS="syntax">void	* MemUpgradeSharedLock(
        MemHandle		mh);			/* handle of locked block */</PRE>
<P>
This routine upgrades a shared lock on the block to an exclusive lock, as if the caller had used MemLockExcl(). If other threads have access to the block, the caller will sleep in the access queue until it can gain exclusive access.</P>
<P>
This routine returns the pointer of the locked block because, if the caller sleeps in the queue, the memory block could move between the call and the granting of access.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	heap.h</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_6d.htm#IX_MemLockExcl()">MemLockExcl()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_6d.htm#IX_MemLockShared()">MemLockShared()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_6c.htm#IX_MemDowngradeExclLock()">MemDowngradeExclLock()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_70.htm_IX_MessageSetDestination()">
 </A>
<H1 CLASS="refHeading">
MessageSetDestination()</H1>
<PRE CLASS="syntax">void	MessageSetDestination(
        EventHandle		event,			/* handle of the event to be modified */
        optr		dest);			/* new destination for the event */</PRE>
<P>
This routine sets the destination of an event to the optr passed.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	object.h</P>
</DIV>
<HR>
<A NAME="R_71.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_71.htm_IX_ModemAnswerCall()">
 </A>
<H1 CLASS="refHeading">
ModemAnswerCall()</H1>
<PRE CLASS="syntax">Boolean	ModemAnswerCall(
        SerialPortNum		port,			/* serial port number */
        ModemResultCode		*result);</PRE>
<P>
Answers an incoming data call. Returns [???] if a connection has been established (and writes MRC_OK to <EM>result</EM>) or non-zero if an error has occurred (and [???]).</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	modemC.goh</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_71.htm#IX_ModemAutoAnswer()">ModemAutoAnswer()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_71.htm_IX_ModemAutoAnswer()">
 </A>
<H1 CLASS="refHeading">
ModemAutoAnswer()</H1>
<PRE CLASS="syntax">Boolean	ModemAutoAnswer(
        SerialPortNum		port,		/* serial port number */
        word		number_of_rings,
        ModemResultCode		*result);</PRE>
<P>
Sets modem to answer calls automatically. Does not wait for a call but returns [???] after successfully setting modem to auto-answer (and writes MRC_OK to <EM>result</EM>) or non-zero if an error has occurred (and [???]).</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	modemC.goh</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	Modem must be in command mode when calling this routine.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_71.htm#IX_ModemAnswerCall()">ModemAnswerCall()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_71.htm_IX_ModemClose()">
 </A>
<H1 CLASS="refHeading">
ModemClose()</H1>
<PRE CLASS="syntax">void	ModemClose(
        SerialPortNum		port,			/* serial port number */
        StreamLingerMode		close_mode); /* manner in which to close stream */</PRE>
<P>
Closes the serial port being used for a modem connection. Possible values for <EM>close_mode</EM> include STREAM_DISCARD or STREAM_LINGER.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	modemC.goh</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	Use <CODE>
<A HREF="../../CRef/Routines/R_71.htm#IX_ModemHangup()">ModemHangup()</A></CODE>
 to hang up an existing call.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_71.htm#IX_ModemHangup()">ModemHangup()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_71.htm_IX_ModemDial()">
 </A>
<H1 CLASS="refHeading">
ModemDial()</H1>
<PRE CLASS="syntax">Boolean	ModemDial(
        SerialPortNum		port,			/* serial port number */
        word		dial_string_length,
        const char		*dial_string,	/* phone number to dial */
        ModemResultCode		*result);</PRE>
<P>
Sends the modem's dial command to dial the specified number. Returns [???] if a connection has been established (and writes MRC_OK to <EM>result</EM>) or non-zero if an error has occurred (and [???]).</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	modemC.goh</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_71.htm#IX_ModemOpen()">ModemOpen()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_71.htm_IX_ModemFactoryReset()">
 </A>
<H1 CLASS="refHeading">
ModemFactoryReset()</H1>
<PRE CLASS="syntax">Boolean	ModemFactoryReset(
        SerialPortNum		port,			/* serial port number */
        ModemResultCode		*result);</PRE>
<P>
Restores factory settings of modem. Returns [???] after successfully resetting (and writes MRC_OK to <EM>result</EM>) or non-zero if an error has occurred (and [???]).</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	modemC.goh</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	Modem must be in command mode when calling this routine.</P>
</DIV>
<DIV>
<A NAME="R_71.htm_IX_ModemHangup()">
 </A>
<H1 CLASS="refHeading">
ModemHangup()</H1>
<PRE CLASS="syntax">Boolean	ModemHangup(
        SerialPortNum		port,			/* serial port number */
        ModemResultCode		*result);</PRE>
<P>
Hangs up an existing data call. Returns [???] after successfully hanging up (and writes MRC_OK to <EM>result</EM>) or non-zero if an error has occurred (and [???]).</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	modemC.goh</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_71.htm#IX_ModemClose()">ModemClose()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_71.htm_IX_ModemInitModem()">
 </A>
<H1 CLASS="refHeading">
ModemInitModem()</H1>
<PRE CLASS="syntax">Boolean	ModemInitModem(
        SerialPortNum		port,			/* serial port number */
        word		init_string_length,
        const char		*init_string,	/* initialization string */
        ModemResultCode		*result);</PRE>
<P>
Initializes modem with modem command string. A lead &quot;AT&quot; need not be supplied. Returns [???] after successfully initializing (and writes MRC_OK to <EM>result</EM>) or non-zero if an error has occurred (and [???]).</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	modemC.goh</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	Modem must be in command mode when calling this routine.</P>
</DIV>
<DIV>
<A NAME="R_71.htm_IX_ModemOpen()">
 </A>
<H1 CLASS="refHeading">
ModemOpen()</H1>
<PRE CLASS="syntax">Boolean	ModemOpen(
        GeodeHandle		drHandle,			/* handle of serial driver */
        SerialPortNum		port,			/* serial port number */
        StreamOpenFlags		flags,			/* manner in which to open stream */
        word		input_buffer_size,
        word		output_buffer_size,
        word		timeout);			/* timeout if SOF_TIMEOUT */</PRE>
<P>
Opens the serial port to be used for a modem connection and places modem in command mode. Possible values for <EM>flags</EM> are SOF_TIMEOUT and SOF_NOBLOCK.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	modemC.goh</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_71.htm#IX_ModemDial()">ModemDial()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_71.htm_IX_ModemReset()">
 </A>
<H1 CLASS="refHeading">
ModemReset()</H1>
<PRE CLASS="syntax">Boolean	ModemReset(
        SerialPortNum		port,			/* serial port number */
        ModemResultCode		*result);</PRE>
<P>
Switches to command mode and resets the modem. Returns [???] after successfully resetting (and writes MRC_OK to <EM>result</EM>) or non-zero if an error has occurred (and [???]).</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	modemC.goh</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_71.htm#IX_ModemFactoryReset()">ModemFactoryReset()</A></CODE>.</P>
</DIV>
<HR>
<A NAME="R_72.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_72.htm_IX_ModemSetMessageDataNotify()">
 </A>
<H1 CLASS="refHeading">
ModemSetMessageDataNotify()</H1>
<PRE CLASS="syntax">void	ModemSetMessageDataNotify(
        SerialPortNum		port,		/* serial port number */
        Message		msg,		/* msg to be sent upon notification */
        optr		destination);	/* object to receive msg */</PRE>
<P>
Registers a message to be sent when when data is received from the modem during an active call. As with the serial driver's data notification, further notification will not be sent until the serial port has been read. [MEANING UNTIL THE STREAM HAS BEEN READ???]</P>
<P CLASS="refField"><STRONG>
Be Sure To:</STRONG>	Use the prototype for the message you are registering.</P>
<P>
@prototype void MODEM_DATA_NOTIFICATION();</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	modemC.goh</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_72.htm#IX_ModemSetRoutineDataNotify()">ModemSetRoutineDataNotify()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_72.htm_IX_ModemSetMessageEndCallNotify()">
 </A>
<H1 CLASS="refHeading">
ModemSetMessageEndCallNotify()</H1>
<PRE CLASS="syntax">void	ModemSetMessageEndCallNotify(
        SerialPortNum		port,		/* serial port number */
        Message		msg,		/* msg to be sent upon notification */
        optr		destination);	/* object to receive msg */</PRE>
<P>
Registers a message to be sent when a call has ended for any reason. To &quot;un-register,&quot; pass NullOptr in <EM>destination</EM>. </P>
<P CLASS="refField"><STRONG>
Be Sure To:</STRONG>	Use the prototype for the message you are registering.</P>
<P>
@prototype void MODEM_END_CALL_NOTIFICATION();</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	All platforms may not support this feature.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	modemC.goh</P>
</DIV>
<DIV>
<A NAME="R_72.htm_IX_ModemSetMessageResponseNotify()">
 </A>
<H1 CLASS="refHeading">
ModemSetMessageResponseNotify()</H1>
<PRE CLASS="syntax">void	ModemSetMessageResponseNotify(
        SerialPortNum		port,		/* serial port number */
        Message		msg,		/* msg to be sent upon notification */
        optr		destination);	/* object to receive msg */</PRE>
<P>
Registers a message to be sent when when a response is received from the modem (while the modem is in command mode). Response is passed in a memory block which the handler should free.</P>
<P CLASS="refField"><STRONG>
Be Sure To:</STRONG>	Use the prototype for the message you are registering.</P>
<P>
@prototype void MODEM_RESPONSE_NOTIFICATION();</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	modemC.goh</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_72.htm#IX_ModemSetRoutineResponseNotify()">ModemSetRoutineResponseNotify()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_72.htm_IX_ModemSetRoutineDataNotify()">
 </A>
<H1 CLASS="refHeading">
ModemSetRoutineDataNotify()</H1>
<PRE CLASS="syntax">void	ModemSetRoutineDataNotify(
        SerialPortNum		port,		/* serial port number */
        word		data,		/* data passed to callback */
        void _pascal (*NotifyRoutine) (word data));</PRE>
<P>
Registers a routine to be called when data is received from the modem during an active call. As with the serial driver's data notification, further notification will not be sent until the serial port has been read. [MEANING UNTIL THE STREAM HAS BEEN READ???]</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	modemC.goh</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_72.htm#IX_ModemSetMessageDataNotify()">ModemSetMessageDataNotify()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_72.htm_IX_ModemSetRoutineResponseNotify()">
 </A>
<H1 CLASS="refHeading">
ModemSetRoutineResponseNotify()</H1>
<PRE CLASS="syntax">void	ModemSetRoutineResponseNotify(
        SerialPortNum		port,		/* serial port number */
        word		data,		/* data passed to callback */
        void _pascal (*NotifyRoutine) (
        		word		data,
        		word		responseSize,
        		char		*response));</PRE>
<P>
Registers a routine to be called when a response is received from the modem (while modem is in command mode).</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	modemC.goh</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_72.htm#IX_ModemSetMessageResponseNotify()">ModemSetMessageResponseNotify()</A></CODE>.</P>
</DIV>
<HR>
<A NAME="R_73.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_73.htm_IX_NameArrayAdd()">
 </A>
<H1 CLASS="refHeading">
NameArrayAdd()</H1>
<PRE CLASS="syntax">word	NameArrayAdd(
        optr 		arr,				/* optr of name array */
        const char		* nameToAdd,				/* Name of new element */
        word		nameLength,				/* Length of name; pass zero if
						 * name string is null-terminated */</PRE>
<PRE CLASS="syntax">        NameArrayAddFlags		flags,				/* Described below */
        const	void	* data);				/* Copy this data to new element */</PRE>
<P>
This routine creates a new element in a name array, copying the passed name and data into the new element. If no element with the passed name exists, <CODE>
NameArrayAdd()</CODE>
 will create the element and return its token. If an element with the same name already exists, the existing element's reference count will be incremented and its token will be returned. The routine takes the following arguments:</P>
<DL>
<DT>
<CODE>
array</CODE>
</DT><DD>The optr of the name array.</DD>
<DT>
<CODE>
nameToAdd</DT><DD>
</CODE>
The name of the new element. This string may contain nulls.</DD>
<DT>
<CODE>
nameLength</DT><DD>
</CODE>
The length of the name string, in bytes. If you pass zero, <CODE>
NameArrayAdd()</CODE>
 will assume the string is null-terminated.</DD>
<DT>
<CODE>
flags</CODE>
</DT><DD>A record of <CODE>
NameArrayAddFlags</CODE>
, described below.</DD>
<DT>
<CODE>
data</CODE>
</DT><DD>The data to copy into the new element.</DD>
</DL>
<P CLASS="refField"><STRONG>
Structures:</STRONG>	The argument is passed a set of <CODE>
NameArrayAddFlags</CODE>
. Only one flag is currently defined:</P>
<DL>
<DT>
NAAF_SET_DATA_ON_REPLACE</DT><DD>
If an element with the specified name exists and this flag is set, the data passed will be copied into the data area of the existing element. If this flag is not set, the existing element will not be changed.</DD>
</DL>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	This routine may resize the name array; therefore, all pointers to the LMem heap are invalidated.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	chunkarr.h</P>
</DIV>
<DIV>
<A NAME="R_73.htm_IX_NameArrayAddHandles()">
 </A>
<H1 CLASS="refHeading">
NameArrayAddHandles()</H1>
<PRE CLASS="syntax">dword	NameArrayAddHandles(
        MemHandle 		mh,				/* Handle of LMem heap */
        ChunkHandle 		arr,				/* Chunk handle of name array */
        const char * 		nameToAdd,				/* Name of new element */
        word		nameLength,				/* Length of name; pass zero if
						 * name string is null-terminated */</PRE>
<PRE CLASS="syntax">        NameArrayAddFlags		flags,				/* Described below */
        const	void *	data);				/* Copy this data to new element */</PRE>
<P>
This routine is exactly like <CODE>
<A HREF="../../CRef/Routines/R_73.htm#IX_NameArrayAdd()">NameArrayAdd()</A></CODE>
 above, except that the name array is specified by its global and chunk handles (instead of with an optr).</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	This routine may resize the name array; therefore, all pointers to within the LMem heap are invalidated.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	chunkarr.h</P>
</DIV>
<DIV>
<A NAME="R_73.htm_IX_NameArrayChangeName()">
 </A>
<H1 CLASS="refHeading">
NameArrayChangeName()</H1>
<PRE CLASS="syntax">void	NameArrayChangeName(
        optr 		array,			/* optr of name array */
        word		token,			/* Token of element to be changed */
        const char * 		newName,			/* New name for element */
        word		nameLength);				/* Length of name in bytes; pass
						 * zero if name string is
						 * null-terminated */</PRE>
<P>
This routine changes the name of an element in a name array.</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	If the new name is longer than the old, the chunk will be resized, invalidating all pointers to within the LMem heap.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	chunkarr.h</P>
</DIV>
<DIV>
<A NAME="R_73.htm_IX_NameArrayChangeNameHandles()">
 </A>
<H1 CLASS="refHeading">
NameArrayChangeNameHandles()</H1>
<PRE CLASS="syntax">dword	NameArrayChangeNameHandles(
        MemHandle 		mh,				/* Handle of LMem heap */
        ChunkHandle 		array,				/* Chunk handle of name array */
        word		token,				/* Token of element to be changed */
        const char * 		newName,				/* New name for element */
        word		nameLength);				/* Length of name in bytes; pass
						 * zero if name string is
						 * null-terminated */</PRE>
<P>
This routine is exactly like <CODE>
<A HREF="../../CRef/Routines/R_73.htm#IX_NameArrayChangeName()">NameArrayChangeName()</A></CODE>
 above, except that the name array is specified by its global and chunk handles (instead of with an optr).</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	If the new name is longer than the old, the chunk will be resized, invalidating all pointers to within the LMem heap.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	chunkarr.h</P>
</DIV>
<DIV>
<A NAME="R_73.htm_IX_NameArrayCreate()">
 </A>
<H1 CLASS="refHeading">
NameArrayCreate()</H1>
<PRE CLASS="syntax">ChunkHandle 	NameArrayCreate(
        MemHandle 		mh,				/* Global handle of LMem heap */
        word		dataSize,				/* Size of data section for
						 * each element */</PRE>
<PRE CLASS="syntax">        word		headerSize);				/* Size of header; pass
						 * zero for default header */</PRE>
<P>
This routine creates a name array in the indicated LMem heap. It creates a <CODE>
NameArrayHeader</CODE>
 structure at the head of a new chunk. If you want to leave extra space before the start of the array, you can pass a larger header size; if you want to use the standard header, pass a header size of zero.</P>
<P>
You must specify the size of the data portion of each element when you create the array. The name portion will be variable sized.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	chunkarr.h</P>
<P CLASS="refField"><STRONG>
Tips and Tricks:</STRONG>	If you want extra space after the <CODE>
NameArrayHeader</CODE>
, you may want to create your own header structure, the first element of which is a <CODE>
NameArrayHeader</CODE>
. You can pass the size of this header to <CODE>
NameArrayCreate()</CODE>
 and access the data in your header via the structure fields.</P>
<P CLASS="refField"><STRONG>
Be Sure To:</STRONG>	Lock the block on the global heap before calling this routine (unless it is fixed). If you pass a header size, make sure it is larger than <CODE>
sizeof(NameArrayHeader)</CODE>
.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	chunkarr.h</P>
</DIV>
<DIV>
<A NAME="R_73.htm_IX_NameArrayCreateAt()">
 </A>
<H1 CLASS="refHeading">
NameArrayCreateAt()</H1>
<PRE CLASS="syntax">ChunkHandle 	NameArrayCreateAt(
        optr	array,	/* Turn this chunk into a name array */
        word	dataSize,	/* Size of data section of each element */
        word	headerSize); 	/* Size of header; pass zero for default header */</PRE>
<P>
This routine is just like <CODE>
<A HREF="../../CRef/Routines/R_73.htm#IX_NameArrayCreate()">NameArrayCreate()</A></CODE>
 above, except that the element array is created in a pre-existing chunk. The contents of that chunk will be destroyed.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	chunkarr.h</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	If the chunk isn't large enough, it will be resized. This will invalidate all pointers to chunks in that block.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	chunkarr.h</P>
</DIV>
<DIV>
<A NAME="R_73.htm_IX_NameArrayCreateAtHandles()">
 </A>
<H1 CLASS="refHeading">
NameArrayCreateAtHandles()</H1>
<PRE CLASS="syntax">ChunkHandle 	NameArrayCreateAtHandles(
        MemHandle 		mh,				/* Global handle of LMem heap */
        ChunkHandle 		chunk,				/* the chunk for the array */
        word		dataSize,				/* Size of data for each element */
        word		headerSize);				/* Size of header; pass
						 * zero for default header */</PRE>
<P>
This routine is exactly like <CODE>
<A HREF="../../CRef/Routines/R_73.htm#IX_NameArrayCreateAt()">NameArrayCreateAt()</A></CODE>
 above, except that the name array is specified by its global and chunk handles (instead of with an optr).</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	chunkarr.h</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	If the chunk isn't large enough, it will be resized. This will invalidate all pointers to chunks in that block.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	chunkarr.h</P>
</DIV>
<HR>
<A NAME="R_74.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_74.htm_IX_NameArrayFind()">
 </A>
<H1 CLASS="refHeading">
NameArrayFind()</H1>
<PRE CLASS="syntax">word	NameArrayFind(
        optr 		array,				/* optr to name array */
        const char		* nameToFind,				/* Find element with this name */
        word		nameLength,				/* Pass zero if name string is
						 * null-terminated */</PRE>
<PRE CLASS="syntax">        void *		returnData);				/* Copy data section into this
						 * buffer */</PRE>
<P>
This routine locates the element with the specified name. It returns the token of the element and copies its data section into the passed buffer. If there is no element with the specified name, the routine will return CA_NULL_ELEMENT. The routine takes the following arguments:</P>
<DL>
<DT>
<CODE>
array</CODE>
</DT><DD>The optr of the name array.</DD>
<DT>
<CODE>
nameToAdd</DT><DD>
</CODE>
The name of the element to find. This string may contain nulls.</DD>
<DT>
<CODE>
nameLength</DT><DD>
</CODE>
The length of the name string, in bytes. If you pass zero, <CODE>
NameArrayFind()</CODE>
 will assume the string is null-terminated.</DD>
<DT>
<CODE>
returnData</CODE>
</DT><DD>The data section of the element is written to this buffer.</DD>
</DL>
<P CLASS="refField"><STRONG>
Include:</STRONG>	chunkarr.h</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	You must make sure the <CODE>
returnData</CODE>
 buffer is large enough to hold an element's data portion; otherwise, data after the buffer will be overwritten.</P>
</DIV>
<DIV>
<A NAME="R_74.htm_IX_NameArrayFindHandles()">
 </A>
<H1 CLASS="refHeading">
NameArrayFindHandles()</H1>
<PRE CLASS="syntax">word	NameArrayFindHandles(
        MemHandle		mh,				/* Handle of LMem heap */
        ChunkHandle 		array,				/* Handle of name array */
        const char *		nameToFind,				/* Find element with this name */
        word		nameLength,				/* Pass zero if name string is
						 * null-terminated */</PRE>
<PRE CLASS="syntax">        void *		returnData);				/* Copy data section into this
						 * buffer */</PRE>
<P>
This routine is exactly like <CODE>
<A HREF="../../CRef/Routines/R_74.htm#IX_NameArrayFind()">NameArrayFind()</A></CODE>
 above, except that the name array is specified by its global and chunk handles (instead of with an optr).</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	chunkarr.h</P>
</DIV>
<DIV>
<A NAME="R_74.htm_IX_NEC() macro">
 </A>
<H1 CLASS="refHeading">
NEC()</H1>
<PRE CLASS="syntax">NEC(<EM>line</EM>)</PRE>
<P>
This macro defines a line of code that will only be compiled into the <EM>
non</EM>
-error-checking version of the geode. The <CODE>
line</CODE>
 parameter of the macro is the actual line of code. When the non-EC version of the program is compiled, the line will be treated as a normal line of code; when the EC version is compiled, the line will be ignored.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_1e.htm#IX_EC() macro">EC()</A></CODE>.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	ec.h</P>
</DIV>
<DIV>
<A NAME="R_74.htm_IX_ObjBlockGetOutput()">
 </A>
<H1 CLASS="refHeading">
ObjBlockGetOutput()</H1>
<PRE CLASS="syntax">optr	ObjBlockGetOutput(
        MemHandle mh);			/* handle of the subject object block */</PRE>
<P>
This routine returns the optr of the output destination object set for the specified object block. The output object is stored in the object block's header in the <CODE>
OLMBH_output</CODE>
 field. If the block has no output set, NullOptr will be returned.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	object.h</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Structs/S_2a.htm#IX_ObjLMemBlockHeader">ObjLMemBlockHeader</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_74.htm_IX_ObjBlockSetOutput()">
 </A>
<H1 CLASS="refHeading">
ObjBlockSetOutput()</H1>
<PRE CLASS="syntax">void	ObjBlockSetOutput(
        MemHandle		mh,			/* handle of the subject object block */
        optr		o);			/* optr of the new output object */</PRE>
<P>
This routine sets the <CODE>
OLMBH_output</CODE>
 field in the specified object block's header. The optr passed in <CODE>
o</CODE>
 will be set as the block's output.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	object.h</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Structs/S_2a.htm#IX_ObjLMemBlockHeader">ObjLMemBlockHeader</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_74.htm_IX_ObjCompAddChild()">
 </A>
<H1 CLASS="refHeading">
ObjCompAddChild()</H1>
<PRE CLASS="syntax">void	ObjCompAddChild(
        optr	obj,		/* optr of parent composite */
        optr	objToAdd,		/* optr of new child */
        word	flags,		/* CompChildFlags */
        word	masterOffset,		/* offset to master part */
        word	compOffset,		/* offset to comp field in master part */
        word	linkOffset);		/* offset to link field in master part */</PRE>
<P>
This routine adds the given object to an object tree as the child of another specified object. It returns nothing. You will not likely want to use this routine; instead, you will probably use the messages listed below under &quot;See Also.&quot; The parameters of this routine are</P>
<DL>
<DT>
<CODE>
obj</CODE>
</DT><DD>The optr of the parent composite object. The parent must be a composite; if it is not, an error will result.</DD>
<DT>
<CODE>
objToAdd</CODE>
</DT><DD>The optr of the child object. The child must have a link instance field (defined with <CODE>
@link</CODE>
).</DD>
<DT>
<CODE>
flags</CODE>
</DT><DD>A record of <CODE>
CompChildFlags</CODE>
. These flags indicate whether the object should initially be marked dirty as well as where in the parent's child list the new child should be placed (first, second, last, etc.).</DD>
<DT>
<CODE>
masterOffset</DT><DD>
</CODE>
The offset within the parent's instance chunk to the master group's offset. (The value that would appear in the parent class' <CODE>
Class_masterOffset</CODE>
 field in its <CODE>
ClassStruct</CODE>
 structure.)</DD>
<DT>
<CODE>
compOffset</CODE>
</DT><DD>The offset within the parent's instance chunk to the composite field.</DD>
<DT>
<CODE>
linkOffset</CODE>
</DT><DD>The offset within the parent's instance chunk to the link field.</DD>
</DL>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	This routine may resize and move LMem and Object blocks on the heap, thereby invalidating all segment addresses and pointers.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	metaC.goh</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE>MSG_VIS_ADD_CHILD</CODE>,
<CODE>MSG_GEN_ADD_CHILD</CODE>.</P>
</DIV>
<DIV>
<A NAME="R_74.htm_IX_ObjCompFindChildByNumber()">
 </A>
<H1 CLASS="refHeading">
ObjCompFindChildByNumber()</H1>
<PRE CLASS="syntax">optr	ObjCompFindChildByNumber(
        optr	obj,		/* parent's optr */
        word	childToFind,		/* zero-based child number */
        word	masterOffset,		/* offset to master part */
        word	compOffset,		/* offset to comp field in master part */
        word	linkOffset);		/* offset to link field in master part */</PRE>
<P>
This routine returns the optr of the passed object's child; the child is specified based on its position in the object's child list. You will not often use this routine, but you will probably use the messages listed under &quot;See Also&quot; instead. The routine's parameters are listed below:</P>
<DL>
<DT>
<CODE>
obj</CODE>
</DT><DD>The optr of the parent object.</DD>
<DT>
<CODE>
childToFind</DT><DD>
</CODE>
The zero-based number of the child to be found. For example, to return the first child's optr, pass zero or CCO_FIRST; to return the last child's optr, pass CCO_LAST.</DD>
<DT>
<CODE>
masterOffset</DT><DD>
</CODE>
The offset within the parent's instance chunk to the master group's offset. (The value that would appear in the parent class' <CODE>
Class_masterOffset</CODE>
 field in its <CODE>
ClassStruct</CODE>
 structure.)</DD>
<DT>
<CODE>
compOffset</CODE>
</DT><DD>The offset within the parent's instance chunk to the composite field.</DD>
<DT>
<CODE>
linkOffset</CODE>
</DT><DD>The offset within the parent's instance chunk to the link field.</DD>
</DL>
<P CLASS="refField"><STRONG>
Include:</STRONG>	metaC.goh</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE>MSG_GEN_FIND_CHILD</CODE>,
<CODE>MSG_VIS_FIND_CHILD</CODE>.</P>
</DIV>
<HR>
<A NAME="R_75.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_75.htm_IX_ObjCompFindChildByOptr()">
 </A>
<H1 CLASS="refHeading">
ObjCompFindChildByOptr()</H1>
<PRE CLASS="syntax">word	ObjCompFindChildByOptr(
        optr	obj,		/* parent's optr */
        optr	childToFind,		/* optr of child to find */
        word	masterOffset,		/* offset to master part */
        word	compOffset,		/* offset to comp field in master part */
        word	linkOffset);		/* offset to link field in master part */</PRE>
<P>
This routine returns the zero-based child number of an object given its optr and its parent's optr. The returned number represents the child's position in its parent's child list. For example, a return value of zero indicates the object is the parent's first child. You will not likely use this routine; instead, you will probably use the messages shown below under &quot;See Also.&quot;</P>
<P>
The parameters for this routine are listed below:</P>
<DL>
<DT>
<CODE>
obj</CODE>
</DT><DD>The optr of the parent object.</DD>
<DT>
<CODE>
childToFind</DT><DD>
</CODE>
The optr of the child whose number is to be returned. If the child is not found, the routine will return -1.</DD>
<DT>
<CODE>
masterOffset</DT><DD>
</CODE>
The offset within the parent's instance chunk to the master group's offset. (The value that would appear in the parent class' <CODE>
Class_masterOffset</CODE>
 field in its <CODE>
ClassStruct</CODE>
 structure.)</DD>
<DT>
<CODE>
compOffset</CODE>
</DT><DD>The offset within the parent's instance chunk to the composite field.</DD>
<DT>
<CODE>
linkOffset</CODE>
</DT><DD>The offset within the parent's instance chunk to the link field.</DD>
</DL>
<P CLASS="refField"><STRONG>
Include:</STRONG>	metaC.goh</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE>MSG_GEN_FIND_CHILD</CODE>,
<CODE>MSG_VIS_FIND_CHILD</CODE>.</P>
</DIV>
<DIV>
<A NAME="R_75.htm_IX_ObjCompMoveChild()">
 </A>
<H1 CLASS="refHeading">
ObjCompMoveChild()</H1>
<PRE CLASS="syntax">void	ObjCompMoveChild(
        optr	obj,		/* parent's optr */
        optr	objToMove,		/* optr of child to move */
        word	flags,		/* CompChildFlags */
        word	masterOffset,		/* offset to master part */
        word	compOffset,		/* offset to comp field in master part */
        word	linkOffset);		/* offset to link field in master part */</PRE>
<P>
This routine moves the specified child within its parent's child list. This routine will not move a child from one parent to another, but it can reorganize a parent's children. You will not likely use this routine, but you may often use the messages listed under &quot;See Also&quot; below.</P>
<P>
The parameters of this routine are shown below:</P>
<DL>
<DT>
<CODE>
obj</CODE>
</DT><DD>The optr of the parent object.</DD>
<DT>
<CODE>
objToMove</CODE>
</DT><DD>The optr of the child to be moved. If the optr does not point to a valid child, behavior is undefined and an error is likely.</DD>
<DT>
<CODE>
flags</CODE>
</DT><DD>A record of <CODE>
CompChildFlags</CODE>
 indicating the new position of the child and whether the link should be marked dirty.</DD>
<DT>
<CODE>
masterOffset</DT><DD>
</CODE>
The offset within the parent's instance chunk to the master group's offset. (The value that would appear in the parent class' <CODE>
Class_masterOffset</CODE>
 field in its <CODE>
ClassStruct</CODE>
 structure.)</DD>
<DT>
<CODE>
compOffset</CODE>
</DT><DD>The offset within the parent's instance chunk to the composite field.</DD>
<DT>
<CODE>
linkOffset</CODE>
</DT><DD>The offset within the parent's instance chunk to the link field.</DD>
</DL>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	This routine may cause LMem and/or Object Blocks to move or to shuffle their chunks, thereby invalidating any segment addresses or pointers.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	metaC.goh</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE>MSG_GEN_MOVE_CHILD</CODE>,
<CODE>MSG_VIS_MOVE_CHILD</CODE>.</P>
</DIV>
<HR>
<A NAME="R_76.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_76.htm_IX_ObjCompProcessChildren()">
 </A>
<H1 CLASS="refHeading">
ObjCompProcessChildren()</H1>
<PRE CLASS="syntax">Boolean	ObjCompProcessChildren(
        optr		obj,				/* parent's optr */
        optr		firstChild,				/* optr of first child to process */
        ObjCompCallType		stdCallback,				/* standard callback type */
        void 		* cbData,				/* data passed to callback */
        word		masterOffset,				/* offset to master part */
        word		compOffset,				/* offset to comp field */
        word		linkOffset);				/* offset to link field */
        Boolean _pascal (*callback) (optr parent, optr child, void *cbData));</PRE>
<P>
This routine performs a specific set of actions on all or some of an object's children. It is very rare that you will use this routine; typically, you should send a message to all of the parent's children. If, however, you use this routine, you must also write a callback routine that will be executed once for each affected child.</P>
<P>
<CODE>
ObjCompProcessChildren()</CODE>
 returns <CODE>
true</CODE>
 (nonzero) only if it was stopped before all children had been processed. The only two ways this could be returned is if an error occurs or if your callback returns <CODE>
true</CODE>
 when called.</P>
<P>
The parameters for this routine are</P>
<DL>
<DT>
<CODE>
obj</CODE>
</DT><DD>The optr of the composite whose children are to be processed.</DD>
<DT>
<CODE>
firstChild</CODE>
</DT><DD>The optr of the first child to be processed. This routine will begin with the passed child and continue with all subsequent children. Pass the optr of the composite's first child--retrieved with the routine <CODE>
<A HREF="../../CRef/Routines/R_74.htm#IX_ObjCompFindChildByNumber()">ObjCompFindChildByNumber()</A></CODE>
--to process all children.</DD>
<DT>
<CODE>
stdCallback</DT><DD>
</CODE>
A value of <CODE>
ObjCompCallType</CODE>
 indicating how the data in the buffer pointed to by <CODE>
cbData</CODE>
 will be passed to your callback routine. These values are detailed below.</DD>
<DT>
<CODE>
cbData</CODE>
</DT><DD>A pointer to a buffer in which data can be passed to your callback routine. This buffer can be altered by your callback.</DD>
<DT>
<CODE>
masterOffset</DT><DD>
</CODE>
The offset within the parent's instance chunk to the master group's offset. (The value that would appear in the parent class' <CODE>
Class_masterOffset</CODE>
 field in its <CODE>
ClassStruct</CODE>
 structure.)</DD>
<DT>
<CODE>
compOffset</CODE>
</DT><DD>The offset within the parent's instance chunk to the composite field.</DD>
<DT>
<CODE>
linkOffset</CODE>
</DT><DD>The offset within the parent's instance chunk to the link field.</DD>
<DT>
<CODE>
callback</DT><DD>
</CODE>
A pointer to the actual callback routine that will be executed once for each child. The callback should be in your geode's fixed memory. The parameters and return values for the callback routine are given below.</DD>
</DL>
<P>
The callback routine takes three parameters and returns a boolean value. It must be declared _pascal. The three parameters to the callback are listed below:</P>
<DL>
<DT>
<CODE>
parent</CODE>
</DT><DD>The optr of the parent composite.</DD>
<DT>
<CODE>
child</CODE>
</DT><DD>The optr of the current child being processed.</DD>
<DT>
<CODE>
cbData</CODE>
</DT><DD>A pointer to the buffer passed by the original caller of <CODE>
ObjCompProcessChildren()</CODE>
. What is actually in this buffer may depend on the value in the original <CODE>
sdtCallback</CODE>
 parameter; if the buffer is not saved and restored by <CODE>
ObjCompProcessChildren()</CODE>
 between children, each child may receive data altered by the previous child.</DD>
</DL>
<P>
The callback routine can access and alter the buffer pointed to by <CODE>
cbData</CODE>
, or it can query the child or do anything else with the exception of destroying the child. It should return a Boolean value: <CODE>
true</CODE>
 if <CODE>
ObjCompProcessChildren()</CODE>
 should be aborted, <CODE>
false</CODE>
 if it should not.</P>
<P>
The values you can pass to <CODE>
ObjCompProcessChildren()</CODE>
 in <CODE>
stdCallback</CODE>
 are of type <CODE>
ObjCompCallType</CODE>
. You can use one of the following values to specify how the buffer in <CODE>
cbData</CODE>
 will be passed on to the next child's callback routine:</P>
<DL>
<DT>
OCCT_SAVE_PARAMS_TEST_ABORT</DT><DD>
Save the buffer passed in <CODE>
cbData</CODE>
 before calling each child; abort the routine if the callback returns <CODE>
true</CODE>
.</DD>
<DT>
OCCT_SAVE_PARAMS_DONT_TEST_ABORT</DT><DD>
Save the buffer passed in <CODE>
cbData</CODE>
 before calling each child; do not check the return value of the callback before proceeding to the next child.</DD>
<DT>
OCCT_DONT_SAVE_PARAMS_TEST_ABORT</DT><DD>
Do not save the buffer in <CODE>
cbData</CODE>
, and abort if the callback routine returns <CODE>
true</CODE>
.</DD>
<DT>
OCCT_DONT_SAVE_PARAMS_DONT_TEST_ABORT</DT><DD>
Do not save the buffer in <CODE>
cbData</CODE>
, and do not check the callback routine's return value.</DD>
<DT>
OCCT_ABORT_AFTER_FIRST</DT><DD>
Abort the processing after only one child (typically used to call the <EM>
nth</EM>
 child).</DD>
<DT>
OCCT_COUNT_CHILDREN</DT><DD>
Counts the number of children rather than calling each.</DD>
</DL>
<P CLASS="refField"><STRONG>
Include:</STRONG>	metaC.goh</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE>@send</CODE>,
<CODE>@call</CODE>,
<CODE>MSG_META_SEND_CLASSED_EVENT</CODE>.</P>
</DIV>
<DIV>
<A NAME="R_76.htm_IX_ObjCompRemoveChild()">
 </A>
<H1 CLASS="refHeading">
ObjCompRemoveChild()</H1>
<PRE CLASS="syntax">void	ObjCompRemoveChild(
        optr	obj,		/* parent's optr */
        optr	objToRemove		/* optr of child to be removed */
        word	flags,		/* CompChildFlags */
        word	masterOffset,		/* offset to master part */
        word	compOffset,		/* offset to comp field in master part */
        word	linkOffset);		/* offset to link field in master part */</PRE>
<P>
This routine removes the given child from the specified parent composite. The child will be removed entirely from the object tree, but it will not be detached or freed. The parameters of this routine are listed below:</P>
<DL>
<DT>
<CODE>
obj</CODE>
</DT><DD>The optr of the parent composite.</DD>
<DT>
<CODE>
objToRemove</DT><DD>
</CODE>
The optr of the child to be removed.</DD>
<DT>
<CODE>
flags</CODE>
</DT><DD>A record of <CODE>
CompChildFlags</CODE>
 indicating whether the parent and child should be marked dirty after the operation.</DD>
<DT>
<CODE>
masterOffset</DT><DD>
</CODE>
The offset within the parent's instance chunk to the master group's offset. (The value that would appear in the parent class' <CODE>
Class_masterOffset</CODE>
 field in its <CODE>
ClassStruct</CODE>
 structure.)</DD>
<DT>
<CODE>
compOffset</CODE>
</DT><DD>The offset within the parent's instance chunk to the composite field.</DD>
<DT>
<CODE>
linkOffset</CODE>
</DT><DD>The offset within the parent's instance chunk to the link field.</DD>
</DL>
<P CLASS="refField"><STRONG>
Include:</STRONG>	metaC.goh</P>
</DIV>
<DIV>
<A NAME="R_76.htm_IX_ObjDecInteractibleCount()">
 </A>
<H1 CLASS="refHeading">
ObjDecInteractibleCount()</H1>
<PRE CLASS="syntax">void	ObjDecInteractibleCount(
        MemHandle mh);			/* subject object block */</PRE>
<P>
This routine decrements the given object block's interactable count. Do not decrement the interactable count without first incrementing it with <CODE>
<A HREF="../../CRef/Routines/R_79.htm#IX_ObjIncInteractibleCount()">ObjIncInteractibleCount()</A></CODE>
. Visible objects automatically decrement the interactable count in their <CODE>
MSG_VIS_CLOSE</CODE>
 handlers.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	object.h</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_79.htm#IX_ObjIncInteractibleCount()">ObjIncInteractibleCount()</A></CODE>,
<CODE>MSG_VIS_CLOSE</CODE>,
<CODE><A HREF="../../CRef/Structs/S_2a.htm#IX_ObjLMemBlockHeader">ObjLMemBlockHeader</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_76.htm_IX_ObjDecInUseCount()">
 </A>
<H1 CLASS="refHeading">
ObjDecInUseCount()</H1>
<PRE CLASS="syntax">void	ObjDecInUseCount(
        MemHandle mh);		/* subject object block */</PRE>
<P>
This routine decrements the given object block's in-use count. When the in-use count reaches zero, the block may safely be freed. You should not decrement the in-use count of a block without first incrementing it at some point with <CODE>
<A HREF="../../CRef/Routines/R_79.htm#IX_ObjIncInUseCount()">ObjIncInUseCount()</A></CODE>
.</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	Do not decrement the in-use count without incrementing it first. An error will result.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	object.h</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_79.htm#IX_ObjIncInUseCount()">ObjIncInUseCount()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_76.htm#IX_ObjDecInteractibleCount()">ObjDecInteractibleCount()</A></CODE>,
<CODE><A HREF="../../CRef/Structs/S_2a.htm#IX_ObjLMemBlockHeader">ObjLMemBlockHeader</A></CODE>.</P>
</DIV>
<HR>
<A NAME="R_77.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_77.htm_IX_ObjDeref()">
 </A>
<H1 CLASS="refHeading">
ObjDeref()</H1>
<PRE CLASS="syntax">void	* ObjDeref(
        optr	obj			/* optr to dereference */
        word	masterLevel);			/* specific master level to dereference */</PRE>
<P>
This routine dereferences the given optr and master level to reset the message parameter <CODE>
pself</CODE>
. Because many routines and messages may cause the calling object's instance chunk to move, the <CODE>
pself</CODE>
 parameter may become invalid. The two parameters to <CODE>
ObjDeref()</CODE>
 are</P>
<DL>
<DT>
<CODE>
obj</CODE>
</DT><DD>The optr of the object to be dereferenced; nearly always you will want to pass <CODE>
oself</CODE>
.</DD>
<DT>
<CODE>
masterLevel</DT><DD>
</CODE>
The master level of the part to be dereferenced. This is the offset into the instance chunk where the offset to the master part is stored. Since <CODE>
pself</CODE>
 points to the first byte of a master part, you must specify which master part you are dereferencing.</DD>
</DL>
<P>
For example, a visible object dereferencing its <CODE>
VisClass</CODE>
 instance data would call this routine as follows:</P>
<PRE>pself = ObjDeref(oself, 4);</PRE>
<P>
Note, however, the <CODE>
ObjDeref1()</CODE>
 and <CODE>
<A HREF="../../CRef/Routines/R_77.htm#IX_ObjDerefVis()">ObjDerefVis()</A></CODE>
 exist to dereference the Vis master part, and <CODE>
ObjDeref2()</CODE>
 and <CODE>
<A HREF="../../CRef/Routines/R_77.htm#IX_ObjDerefGen()">ObjDerefGen()</A></CODE>
 exist to dereference the Gen master part.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	object.h</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_77.htm#IX_ObjDeref1()">ObjDeref1()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_77.htm#IX_ObjDeref2()">ObjDeref2()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_77.htm_IX_ObjDerefHandles()">
 </A>
<H1 CLASS="refHeading">
ObjDerefHandles()</H1>
<PRE CLASS="syntax">void	* ObjDerefHandles(
        MemHandle		mh,					/* handle portion of optr */
        ChunkHandle		ch,					/* chunk portion of optr */
        word		masterLevel);					/* master level to dereference */</PRE>
<P>
This routine is exactly the same as <CODE>
<A HREF="../../CRef/Routines/R_77.htm#IX_ObjDeref()">ObjDeref()</A></CODE>
, above, except that the optr is specified as its separate handles.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	object.h</P>
</DIV>
<DIV>
<A NAME="R_77.htm_IX_ObjDeref1()">
 </A>
<H1 CLASS="refHeading">
ObjDeref1()</H1>
<PRE CLASS="syntax">void	* ObjDeref1(
        optr obj);			/* optr of object to be dereferenced */</PRE>
<P>
This routine is a special version of <CODE>
<A HREF="../../CRef/Routines/R_77.htm#IX_ObjDeref()">ObjDeref()</A></CODE>
 which dereferences the first master part of an object. Visible objects should use this routine or <CODE>
<A HREF="../../CRef/Routines/R_77.htm#IX_ObjDerefVis()">ObjDerefVis()</A></CODE>
 instead of <CODE>
<A HREF="../../CRef/Routines/R_77.htm#IX_ObjDeref()">ObjDeref()</A></CODE>
.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	object.h</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_77.htm#IX_ObjDeref()">ObjDeref()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_77.htm#IX_ObjDeref2()">ObjDeref2()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_77.htm_IX_ObjDeref1Handles()">
 </A>
<H1 CLASS="refHeading">
ObjDeref1Handles()</H1>
<PRE CLASS="syntax">void	*ObjDeref1Handles(
        MemHandle		mh,			/* handle portion of optr */
        ChunkHandle		ch,);			/* chunk handle portion of optr */</PRE>
<P>
This routine is exactly like <CODE>
ObjDeref1()</CODE>
, above, except that the optr is specified as its separate handles.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	object.h</P>
</DIV>
<DIV>
<A NAME="R_77.htm_IX_ObjDeref2()">
 </A>
<H1 CLASS="refHeading">
ObjDeref2()</H1>
<PRE CLASS="syntax">void	* ObjDeref2(
        optr	obj);		/* optr of object to be dereferenced */</PRE>
<P>
This routine is a specialized version of <CODE>
<A HREF="../../CRef/Routines/R_77.htm#IX_ObjDeref()">ObjDeref()</A></CODE>
 which dereferences the second master part of an object. Generic objects should use this routine or <CODE>
<A HREF="../../CRef/Routines/R_77.htm#IX_ObjDerefGen()">ObjDerefGen()</A></CODE>
 instead of <CODE>
<A HREF="../../CRef/Routines/R_77.htm#IX_ObjDeref()">ObjDeref()</A></CODE>
.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	object.h</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_77.htm#IX_ObjDeref()">ObjDeref()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_77.htm#IX_ObjDeref1()">ObjDeref1()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_77.htm_IX_ObjDeref2Handles()">
 </A>
<H1 CLASS="refHeading">
ObjDeref2Handles()</H1>
<PRE CLASS="syntax">void	* ObjDeref2Handles(
        MemHandle		mh,/			/* handle portion of optr */
        ChunkHandle		ch);			/* chunk portion of optr */</PRE>
<P>
This routine is exactly like <CODE>
ObjDeref2()</CODE>
, above, except that the optr is specified as its separate handles.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	object.h</P>
</DIV>
<DIV>
<A NAME="R_77.htm_IX_ObjDerefGen()">
 </A>
<H1 CLASS="refHeading">
ObjDerefGen()</H1>
<PRE CLASS="syntax">void	* ObjDerefGen(
        optr	obj);			/* generic object to be dereferenced */</PRE>
<P>
This routine is exactly the same as <CODE>
ObjDeref2()</CODE>
 and dereferences the Gen master part of a generic object.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	object.h</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_77.htm#IX_ObjDeref()">ObjDeref()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_77.htm#IX_ObjDeref2()">ObjDeref2()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_77.htm_IX_ObjDerefVis()">
 </A>
<H1 CLASS="refHeading">
ObjDerefVis()</H1>
<PRE CLASS="syntax">void	* ObjDerefVis(
        optr	obj);			/* visible object to be dereferenced */</PRE>
<P>
This routine is exactly the same as <CODE>
ObjDeref1()</CODE>
 and dereferences the Vis master part of a visible object or a visibly-realized generic object.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	object.h</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_77.htm#IX_ObjDeref()">ObjDeref()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_77.htm#IX_ObjDeref1()">ObjDeref1()</A></CODE>.</P>
</DIV>
<HR>
<A NAME="R_78.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_78.htm_IX_ObjDoRelocation()">
 </A>
<H1 CLASS="refHeading">
ObjDoRelocation()</H1>
<PRE CLASS="syntax">Boolean	ObjDoRelocation( /* returns <EM>true</EM> if error */
        ObjRelocationType		type,				/* type of relocation */
        MemHandle		block,				/* handle of info block */
        void		* sourceData,				/* source of relocation */
        void		* destData);				/* relocated value */</PRE>
<P>
This routine relocates a given word or dword argument and is used for resolving handles and pointers to movable objects. Most often, relocation and unrelocation occur when resources are loaded, swapped, or saved, and this is in most cases taken care of by the kernel.</P>
<P>
<CODE>
ObjDoRelocation()</CODE>
 takes four parameters:</P>
<DL>
<DT>
<CODE>
type</CODE>
</DT><DD>The type of relocation to be performed (<CODE>
RelocationType</CODE>
). This can be one of the three values shown below.</DD>
<DT>
<CODE>
block</CODE>
</DT><DD>The handle of the block containing the relocation.</DD>
<DT>
<CODE>
sourceData</CODE>
</DT><DD>A pointer to the source of the relocation; this pointer should be cast to the proper type (word or dword) when calling the routine.</DD>
<DT>
<CODE>
destData</CODE>
</DT><DD>A pointer to the value to be returned; this pointer should be cast appropriately when the routine is called. The exact type of return value depends on <CODE>
sourceData</CODE>
 and <CODE>
type</CODE>
, above.</DD>
</DL>
<P>
The type of relocation to be done affects the type of data passed in <CODE>
sourceData</CODE>
 and <CODE>
destData</CODE>
. The relocation type is passed in the type parameter and must be one of the following enumerations of <CODE>
RelocationType</CODE>
:</P>
<DL>
<DT>
RELOC_RELOC_HANDLE</DT><DD>
The relocation will be from a resource ID to a handle. The <CODE>
sourceData</CODE>
 pointer should be cast to type word, and the <CODE>
destData</CODE>
 pointer should be cast to type Handle.</DD>
<DT>
RELOC_RELOC_SEGMENT</DT><DD>
The relocation will be from a resource ID to a segment address. The <CODE>
sourceData</CODE>
 pointer should be cast to type word, and the <CODE>
destData</CODE>
 pointer should be cast to type Segment.</DD>
<DT>
RELOC_RELOC_ENTRY_POINT</DT><DD>
The relocation will be from either a resource ID or an entry number to an entry point. Both the <CODE>
sourceData</CODE>
 pointer and the <CODE>
destData</CODE>
 pointer should be cast to type dword.</DD>
</DL>
<P>
<CODE>
ObjDoRelocation()</CODE>
 returns an error flag that will be <CODE>
true</CODE>
 if an error occurs, <CODE>
false</CODE>
 otherwise.</P>
<P>
The relocation done by this routine can be undone with <CODE>
<A HREF="../../CRef/Routines/R_78.htm#IX_ObjDoUnRelocation()">ObjDoUnRelocation()</A></CODE>
.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	object.h</P>
</DIV>
<DIV>
<A NAME="R_78.htm_IX_ObjDoUnRelocation()">
 </A>
<H1 CLASS="refHeading">
ObjDoUnRelocation()</H1>
<PRE CLASS="syntax">Boolean	ObjDoUnRelocation( /* returns <EM>true</EM> if error */
        ObjRelocationType		type,				/* type of relocation */
        MemHandle		block,				/* handle of info block */
        void		* sourceData,				/* source of relocation */
        void		* destData);				/* relocated value */</PRE>
<P>
This routine unrelocates a given word or dword. It translates a handle, a segment address, or an entry point back into a resource ID. The translation done is the exact reverse of that done by <CODE>
<A HREF="../../CRef/Routines/R_78.htm#IX_ObjDoRelocation()">ObjDoRelocation()</A></CODE>
. See that routine (above) for more information.</P>
<P>
<CODE>
ObjDoUnRelocation()</CODE>
 returns an error flag that will be <CODE>
true</CODE>
 if an error occurs and <CODE>
false</CODE>
 if the unrelocation is successful. The unrelocated resource ID will be returned pointed to by the <CODE>
destData</CODE>
 pointer.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	object.h</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_78.htm#IX_ObjDoRelocation()">ObjDoRelocation()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_78.htm_IX_ObjDuplicateMessage()">
 </A>
<H1 CLASS="refHeading">
ObjDuplicateMessage()</H1>
<PRE CLASS="syntax">EventHandle ObjDuplicateMessage(
        EventHandle msg);				/* event to duplicate */</PRE>
<P>
This routine duplicates a prerecorded event, returning the event handle of the new event. Pass the handle of the event to be duplicated. You can then change information about the event with <CODE>
<A HREF="../../CRef/Routines/R_70.htm#IX_MessageSetDestination()">MessageSetDestination()</A></CODE>
.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	object.h</P>
</DIV>
<DIV>
<A NAME="R_78.htm_IX_ObjDuplicateResource()">
 </A>
<H1 CLASS="refHeading">
ObjDuplicateResource()</H1>
<PRE CLASS="syntax">MemHandle ObjDuplicateResource(
        MemHandle		blockToDup,					/* handle of resource; must
								 * <EM>not</EM> be loaded */</PRE>
<PRE CLASS="syntax">        GeodeHandle		owner,					/* owner of duplicate */
        ThreadHandle		burdenThread);					/* burden thread of duplicate */</PRE>
<P>
This routine duplicates an entire object resource block. The new block will be put on the &quot;saved blocks&quot; list so it gets saved to the geode's state file. Usually this is used by the UI to make editable copies of an application's UI resources to ensure the proper state information gets saved. This routine takes three parameters:</P>
<DL>
<DT>
<CODE>
blockToDup</CODE>
</DT><DD>The handle of the block to be duplicated. The block must not be resident in memory when <CODE>
ObjDuplicateResource()</CODE>
 is called. Also, it can only be a &quot;template&quot; resource--a resource that does not get used by the UI or the application directly, but only gets copied via this routine.</DD>
<DT>
<CODE>
owner</CODE>
</DT><DD>The owner geode of the new block. This should be the geode handle of the owning geode or zero to have the calling geode own it. If you pass an <CODE>
owner</CODE>
 of -1, the new block will be owned by the same geode that owns the original.</DD>
<DT>
<CODE>
burdenThread</CODE>
</DT><DD>
The thread that will run the block and handle its messages. This should be a thread handle or zero to have the calling thread run the block. Passing a <CODE>
burdenThread</CODE>
 of -1 makes the new resource have the same burden thread as the original.</DD>
</DL>
<P>
<CODE>
ObjDuplicateResource()</CODE>
 returns the handle of the newly created block, which will be unlocked and may or may not be resident in memory.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	object.h</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_79.htm#IX_ObjFreeDuplicate()">ObjFreeDuplicate()</A></CODE>,
<CODE>MSG_META_BLOCK_FREE</CODE>,
<CODE><A HREF="../../CRef/Routines/R_7b.htm#IX_ObjLockObjBlock()">ObjLockObjBlock()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_78.htm_IX_ObjEnableDetach()">
 </A>
<H1 CLASS="refHeading">
ObjEnableDetach()</H1>
<PRE CLASS="syntax">void	ObjEnableDetach(
        optr	obj);		/* object calling this routine */</PRE>
<P>
This routine acts as an object's handler for <CODE>
MSG_META_ACK</CODE>
. This handler decrements the acknowledgment count (incremented with <CODE>
<A HREF="../../CRef/Routines/R_79.htm#IX_ObjIncDetach()">ObjIncDetach()</A></CODE>
) and, if the count is zero, enables the detach mechanism so the object can be fully detached. Because the detach mechanism is implemented in <CODE>
MetaClass</CODE>
, it is highly unlikely you will ever call this routine.</P>
<P>
The lone parameter of this routine is the optr of the calling object (or, in the case of <CODE>
MSG_META_ACK</CODE>
, the object sending acknowledgment).</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	This routine may resize and/or move chunks and object blocks, thereby invalidating all pointers and segment addresses.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	metaC.goh</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE>MSG_META_DETACH</CODE>,
<CODE><A HREF="../../CRef/Routines/R_7a.htm#IX_ObjInitDetach()">ObjInitDetach()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_79.htm#IX_ObjIncDetach()">ObjIncDetach()</A></CODE>,
<CODE>MSG_META_ACK</CODE>.</P>
</DIV>
<HR>
<A NAME="R_79.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_79.htm_IX_ObjFreeChunk()">
 </A>
<H1 CLASS="refHeading">
ObjFreeChunk()</H1>
<PRE CLASS="syntax">void	ObjFreeChunk(
        optr	o);		/* optr of chunk to be freed */</PRE>
<P>
This routine frees the passed object's instance chunk. If the object came from a loaded resource, however, the object is resized to zero and marked dirty rather than actually freed.</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	The object must be fully detached, and its message queues must be empty before it can safely be freed. All this is handled by <CODE>
MSG_META_DETACH</CODE>
 and <CODE>
MSG_META_OBJ_FREE</CODE>
.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	object.h</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE>MSG_META_DETACH</CODE>,
<CODE>MSG_META_OBJ_FREE</CODE>,
<CODE><A HREF="../../CRef/Routines/R_7a.htm#IX_ObjInstantiate()">ObjInstantiate()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_79.htm_IX_ObjFreeChunkHandles()">
 </A>
<H1 CLASS="refHeading">
ObjFreeChunkHandles()</H1>
<PRE CLASS="syntax">void	ObjFreeChunkHandles(
        MemHandle		mh,			/* handle portion of optr */
        ChunkHandle		ch);			/* chunk portion of optr */</PRE>
<P>
This routine is the same as ObjFreeChunk(); the chunk is specified by its handles rather than by an optr.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	object.h</P>
</DIV>
<DIV>
<A NAME="R_79.htm_IX_ObjFreeDuplicate()">
 </A>
<H1 CLASS="refHeading">
ObjFreeDuplicate()</H1>
<PRE CLASS="syntax">void	ObjFreeDuplicate(
        MemHandle mh);			/* handle of duplicate block to be freed */</PRE>
<P>
This routine frees a block that had been saved with <CODE>
<A HREF="../../CRef/Routines/R_7c.htm#IX_ObjSaveBlock()">ObjSaveBlock()</A></CODE>
 or created with <CODE>
<A HREF="../../CRef/Routines/R_78.htm#IX_ObjDuplicateResource()">ObjDuplicateResource()</A></CODE>
. It must be passed the memory handle of the duplicated resource.</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	All objects in the duplicated resource must be properly detached to ensure that nothing tries to send messages to the objects in the block. Additionally, the block's in-use count and interactable count should be zero.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	object.h</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_78.htm#IX_ObjDuplicateResource()">ObjDuplicateResource()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_7c.htm#IX_ObjSaveBlock()">ObjSaveBlock()</A></CODE>,
<CODE><A HREF="../../CRef/Structs/S_2a.htm#IX_ObjLMemBlockHeader">ObjLMemBlockHeader</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_79.htm_IX_ObjFreeMessage()">
 </A>
<H1 CLASS="refHeading">
ObjFreeMessage()</H1>
<PRE CLASS="syntax">void	ObjFreeMessage(
        EventHandle event);				/* event to be freed */</PRE>
<P>
This routine frees an event handle and its associated event. This is rarely, if ever, used by anything other than the kernel. The kernel uses this routine to free events after they have been handled.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	object.h</P>
</DIV>
<DIV>
<A NAME="R_79.htm_IX_ObjFreeObjBlock()">
 </A>
<H1 CLASS="refHeading">
ObjFreeObjBlock()</H1>
<PRE CLASS="syntax">void	ObjFreeObjBlock(
        MemHandle block);			/* handle of the object block to be freed */</PRE>
<P>
This routine frees the specified object block. It first checks the block's in-use count to see if any external references to the block are being kept. If the in-use count is nonzero, <CODE>
ObjFreeObjBlock()</CODE>
 simply sets the block's auto-free bit and returns; the block will be freed the first time the in-use count reaches zero. If the in-use count is zero (no external references), the block will be freed immediately.</P>
<P>
If the object block passed is not run by the calling thread, the operation will be handled by a remote call in the object block's thread.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	object.h</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_79.htm#IX_ObjFreeDuplicate()">ObjFreeDuplicate()</A></CODE>,
<CODE>MSG_META_BLOCK_FREE</CODE>.</P>
</DIV>
<DIV>
<A NAME="R_79.htm_IX_ObjGetFlags()">
 </A>
<H1 CLASS="refHeading">
ObjGetFlags()</H1>
<PRE CLASS="syntax">ObjChunkFlags ObjGetFlags(
        optr	o);		/* optr of subject object */</PRE>
<P>
This routine returns the object flags associated with a given object. The object is specified by the passed optr, and the flags are stored in the object's <CODE>
ObjChunkFlags</CODE>
 record.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	object.h</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_7c.htm#IX_ObjSetFlags()">ObjSetFlags()</A></CODE>,
<CODE><A HREF="../../CRef/Structs/S_2a.htm#IX_ObjChunkFlags">ObjChunkFlags</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_79.htm_IX_ObjGetFlagsHandles()">
 </A>
<H1 CLASS="refHeading">
ObjGetFlagsHandles()</H1>
<PRE CLASS="syntax">ObjChunkFlags ObjGetFlagsHandles(
        Memhandle		mh,			/* handle portion of optr */
        ChunkHandle		ch);			/* chunk portion of optr */</PRE>
<P>
This routine is the same as <CODE>
<A HREF="../../CRef/Routines/R_79.htm#IX_ObjGetFlags()">ObjGetFlags()</A></CODE>
, but the object is specified with its handles rather than with its optr.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	object.h</P>
</DIV>
<DIV>
<A NAME="R_79.htm_IX_ObjGetMessageInfo()">
 </A>
<H1 CLASS="refHeading">
ObjGetMessageInfo()</H1>
<PRE CLASS="syntax">Message	ObjGetMessageInfo(
        EventHandle		event,				/* event to be queried */
        optr	 	* dest);				/* buffer for destination optr */</PRE>
<P>
This routine gets information about the specified <CODE>
event</CODE>
. The return value is the message number of the event. The <CODE>
dest</CODE>
 parameter is a pointer to an optr. This routine will return with the optr represinting the event's destination object.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	object.h</P>
</DIV>
<DIV>
<A NAME="R_79.htm_IX_ObjIncDetach()">
 </A>
<H1 CLASS="refHeading">
ObjIncDetach()</H1>
<PRE CLASS="syntax">void	ObjIncDetach(
        optr	obj);		/* optr of calling object */</PRE>
<P>
This routine increments the number of detach acknowledgments an object must receive before it can safely be detached. Each time the detaching object sends notification of its detachment, it must call <CODE>
ObjIncDetach()</CODE>
 to indicate that it must receive a corresponding detach acknowledgment (<CODE>
MSG_META_ACK</CODE>
).</P>
<P>
The calling object must have previously called <CODE>
<A HREF="../../CRef/Routines/R_7a.htm#IX_ObjInitDetach()">ObjInitDetach()</A></CODE>
. Since the detach mechanism is implemented in <CODE>
MetaClass</CODE>
, it is highly unlikely you will ever need to call this routine.<CODE>
 ObjIncDetach()</CODE>
 takes a single parameter: the optr of the calling object.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	metaC.goh</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE>MSG_META_DETACH</CODE>,
<CODE><A HREF="../../CRef/Routines/R_7a.htm#IX_ObjInitDetach()">ObjInitDetach()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_78.htm#IX_ObjEnableDetach()">ObjEnableDetach()</A></CODE>,
<CODE>MSG_META_ACK</CODE>.</P>
</DIV>
<DIV>
<A NAME="R_79.htm_IX_ObjIncInteractibleCount()">
 </A>
<H1 CLASS="refHeading">
ObjIncInteractibleCount()</H1>
<PRE CLASS="syntax">void	ObjIncInteractibleCount(
        MemHandle mh);			/* handle of object block */</PRE>
<P>
This routine increments the interactable count of the given object block. The interactable count maintains the number of objects currently visible to the user or about to be acted on by the user (e.g. via keyboard accelerator). The interactable count is maintained by the UI; only in extremely special cases may you need to increment or decrement the count. To decrement the count, use <CODE>
<A HREF="../../CRef/Routines/R_76.htm#IX_ObjDecInteractibleCount()">ObjDecInteractibleCount()</A></CODE>
.</P>
<P>
Visible objects increment the interactable count in their <CODE>
MSG_VIS_OPEN</CODE>
 handlers and decrement it in their <CODE>
MSG_VIS_CLOSE</CODE>
 handlers. This is built into <CODE>
VisClass</CODE>
.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	object.h</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_76.htm#IX_ObjDecInteractibleCount()">ObjDecInteractibleCount()</A></CODE>,
<CODE>MSG_VIS_OPEN</CODE>,
<CODE>MSG_VIS_CLOSE</CODE>,
<CODE><A HREF="../../CRef/Structs/S_2a.htm#IX_ObjLMemBlockHeader">ObjLMemBlockHeader</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_79.htm_IX_ObjIncInUseCount()">
 </A>
<H1 CLASS="refHeading">
ObjIncInUseCount()</H1>
<PRE CLASS="syntax">void	ObjIncInUseCount(
        MemHandle mh);			/* handle of object block */</PRE>
<P>
This routine increments the given object block's in-use count. The in-use count maintains the number of outside references to this object block which are stored elsewhere and which need to be removed before the block can safely be freed. If you store an optr to an object block, you should increment the in-use count of the block.</P>
<P>
When the reference to the block is removed, the in-use count should be decremented with <CODE>
<A HREF="../../CRef/Routines/R_76.htm#IX_ObjDecInUseCount()">ObjDecInUseCount()</A></CODE>
.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	object.h</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_76.htm#IX_ObjDecInUseCount()">ObjDecInUseCount()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_79.htm#IX_ObjIncInteractibleCount()">ObjIncInteractibleCount()</A></CODE>,
<CODE><A HREF="../../CRef/Structs/S_2a.htm#IX_ObjLMemBlockHeader">ObjLMemBlockHeader</A></CODE>.</P>
</DIV>
<HR>
<A NAME="R_7a.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_7a.htm_IX_ObjInitDetach()">
 </A>
<H1 CLASS="refHeading">
ObjInitDetach()</H1>
<PRE CLASS="syntax">void	ObjInitDetach(
        MetaMessages 		msg,
        optr		obj			/* object being detached */
        word		callerID,			/* an identifier token for the caller */
        optr		ackOD);			/* object to which ack is sent */</PRE>
<P>
Initialize the detach sequence for the specified object. The detach sequence severs all ties between the system and the object, allowing it to be destroyed without other objects or geodes trying to contact it. It is highly unlikely you will ever call this routine; typically, you will instead use <CODE>
MSG_META_DETACH</CODE>
 or one of the generic or visible object messages, which will call this routine. The parameters for this routine are</P>
<DL>
<DT>
<EM>msg</EM><CODE>
</DT><DD>The detach message.			</CODE>
</DD>
<DT>
<CODE>
obj</CODE>
</DT><DD>The optr of the object to be detached.</DD>
<DT>
<CODE>
callerID</CODE>
</DT><DD>The caller object's ID.</DD>
<DT>
<CODE>
ackOD</CODE>
</DT><DD>The optr of the caller object or another object which is to receive acknowledgment notification of the detach.</DD>
</DL>
<P CLASS="refField"><STRONG>
Include:</STRONG>	metaC.goh</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE>MSG_META_DETACH</CODE>,
<CODE>MSG_GEN_DESTROY</CODE>,
<CODE>MSG_VIS_REMOVE</CODE>,
<CODE><A HREF="../../CRef/Routines/R_79.htm#IX_ObjIncDetach()">ObjIncDetach()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_78.htm#IX_ObjEnableDetach()">ObjEnableDetach()</A></CODE>,
<CODE>MSG_META_ACK</CODE>.</P>
</DIV>
<DIV>
<A NAME="R_7a.htm_IX_ObjInitializeMaster()">
 </A>
<H1 CLASS="refHeading">
ObjInitializeMaster()</H1>
<PRE CLASS="syntax">void	ObjInitializeMaster(
        optr 		obj,				/* object to be initialized */
        ClassStruct		* class);				/* class in master group */</PRE>
<P>
This routine initializes the appropriate master part of the passed object, resizing the instance chunk if necessary. It takes two parameters:</P>
<DL>
<DT>
<CODE>
obj</CODE>
</DT><DD>The optr of the object whose master part is to be initialized.</DD>
<DT>
<CODE>
class</CODE>
</DT><DD>A pointer to the class definition of a class in the appropriate master group. This does not have to be the master class; it must only be a class in the master goup.</DD>
</DL>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	This routine may resize and/or move chunks or object blocks, thereby invalidating pointers and segment addresses.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	object.h</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_7c.htm#IX_ObjResizeMaster()">ObjResizeMaster()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_7a.htm#IX_ObjInitializePart()">ObjInitializePart()</A></CODE>,
<CODE><A HREF="../../CRef/Structs/S_6.htm#IX_ClassStruct">ClassStruct</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_7a.htm_IX_ObjInitializeMasterHandles()">
 </A>
<H1 CLASS="refHeading">
ObjInitializeMasterHandles()</H1>
<PRE CLASS="syntax">void	ObjInitializeMasterHandles(
        MemHandle		mh,				/* handle portion of optr */
        ChunkHandle		ch,				/* chunk portion of optr */
        ClassStruct		* class);				/* class in master group */</PRE>
<P>
This routine is the same as <CODE>
<A HREF="../../CRef/Routines/R_7a.htm#IX_ObjInitializeMaster()">ObjInitializeMaster()</A></CODE>
 except it specifies the object via its handles rather than its optr.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	object.h</P>
</DIV>
<DIV>
<A NAME="R_7a.htm_IX_ObjInitializePart()">
 </A>
<H1 CLASS="refHeading">
ObjInitializePart()</H1>
<PRE CLASS="syntax">void	ObjInitializePart(
        optr 	obj,			/* object to have a part initialized */
        word	masterOffset);			/* offset to master offset in chunk */</PRE>
<P>
This routine initializes all master parts of the given object down to and including the master part specified in <CODE>
masterOffset</CODE>
. It will resize the chunk if necessary and even resolve variant classes above the master group specified, if necessary. This routine takes two parameters:</P>
<DL>
<DT>
<CODE>
obj</CODE>
</DT><DD>The optr of the object to be initialized.</DD>
<DT>
<CODE>
masterOffset</DT><DD>
</CODE>
The offset within the parent's instance chunk to the master group's offset (the value that would appear in the parent class' <CODE>
Class_masterOffset</CODE>
 field in its <CODE>
ClassStruct</CODE>
 structure).</DD>
</DL>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	This routine may move and/or resize chunks or object blocks, thereby invalidating pointers and segment addresses.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	object.h</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_7c.htm#IX_ObjResizeMaster()">ObjResizeMaster()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_7a.htm#IX_ObjInitializeMaster()">ObjInitializeMaster()</A></CODE>,
<CODE>MSG_META_RESOLVE_VARIANT_SUPERCLASS</CODE>.</P>
</DIV>
<DIV>
<A NAME="R_7a.htm_IX_ObjInitializePartHandles()">
 </A>
<H1 CLASS="refHeading">
ObjInitializePartHandles()</H1>
<PRE CLASS="syntax">void	ObjInitializePartHandles(
        Memhandle		mh,					/* handle portion of optr */
        ChunkHandle		ch,					/* chunk portion of optr */
        word		masterOffset);					/* master group offset */</PRE>
<P>
This routine is the same as <CODE>
<A HREF="../../CRef/Routines/R_7a.htm#IX_ObjInitializePart()">ObjInitializePart()</A></CODE>
 except that it specifies the object via its handles rather than an optr.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	object.h</P>
</DIV>
<DIV>
<A NAME="R_7a.htm_IX_ObjInstantiate()">
 </A>
<H1 CLASS="refHeading">
ObjInstantiate()</H1>
<PRE CLASS="syntax">optr	ObjInstantiate(
        MemHandle		block,				/* block in which new object
						 * will be instantiated */</PRE>
<PRE CLASS="syntax">        ClassStruct		* class);				/* class of new object */</PRE>
<P>
This routine instantiates a new object, allocating the proper size instance chunk. It returns the optr of the new object; this optr can then be used to send setup messages or other messages (such as adding the object to an object tree, setting it usable, etc.).</P>
<P>
The new object's instance data will be initialized to all zeroes if it has no master parts (is a direct descendant of <CODE>
MetaClass</CODE>
). If it is a member of some master group, only enough space for the base structure (the master offsets and the class pointer) will be allocated. In either case, initialization of the instance data will occur at a later time.</P>
<P>
<CODE>
ObjInstantiate()</CODE>
 takes two parameters:</P>
<DL>
<DT>
<CODE>
block</CODE>
</DT><DD>The memory handle of an object block in which the object's instance chunk will be allocated. This block <EM>
must</EM>
 be an object block, though it need not be run by the caller's thread. If the block is run by another thread, the routine will be executed as a remote call.</DD>
<DT>
<CODE>
class</CODE>
</DT><DD>A pointer to the <CODE>
ClassStruct</CODE>
 structure of the class of the new object. This pointer will be set in the object's class pointer (the first four bytes of the instance chunk).</DD>
</DL>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	This routine, because it allocates a new chunk, may cause LMem and Object blocks to move or resize, thereby invalidating any pointers and segment addresses. Be sure to dereference pointers after calls to this routine.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	object.h</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_7a.htm#IX_ObjInstantiateForThread()">ObjInstantiateForThread()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_7a.htm_IX_ObjInstantiateForThread()">
 </A>
<H1 CLASS="refHeading">
ObjInstantiateForThread()</H1>
<PRE CLASS="syntax">optr	ObjInstantiateForThread(
        ThreadHandle		thread,				/* thread to run new object */
        ClassStruct		*class);				/* class of new object */</PRE>
<P>
This routine is similar to <CODE>
<A HREF="../../CRef/Routines/R_7a.htm#IX_ObjInstantiate()">ObjInstantiate()</A></CODE>
 except you pass the thread to run the new object rather than the memory handle to an object block (to store the new object). To specify the current thread, pass &quot;0&quot; in <EM>thread</EM>. This routine automatically allocates memory blocks as needed. It returns the optr to the new object.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	object.h</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_7a.htm#IX_ObjInstantiate()">ObjInstantiate()</A></CODE>.</P>
</DIV>
<HR>
<A NAME="R_7b.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_7b.htm_IX_ObjIsClassADescendant()">
 </A>
<H1 CLASS="refHeading">
ObjIsClassADescendant()</H1>
<PRE CLASS="syntax">Boolean	ObjIsClassADescendant(
        ClassStruct		* class1,				/* proposed ancestor */
        ClassStruct		* class2);				/* proposed descendant */</PRE>
<P>
This routine checks if <CODE>
class2</CODE>
 is a descendand of <CODE>
class1</CODE>
 and returns <CODE>
true</CODE>
 if it is.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	object.h</P>
</DIV>
<DIV>
<A NAME="R_7b.htm_IX_ObjIsObjectInClass()">
 </A>
<H1 CLASS="refHeading">
ObjIsObjectInClass()</H1>
<PRE CLASS="syntax">Boolean	ObjIsObjectInClass(
        optr		obj,				/* object to check */
        ClassStruct	* class);			/* proposed class */</PRE>
<P>
This routine checks to see if the passed object is a member of the specified
class. It checks superclasses as well, but if an unresolved variant class is
encountered, the variant will <EM>not</EM> be resolved. If you want to
search past variant class links, you should send <CODE>MSG_META_DUMMY</CODE>
to the object first. The two parameters for this routine are</P>
<DL>
<DT>
<CODE>
obj</CODE>
</DT><DD>The optr of the object to be checked. Its object block must be
locked down before this routine is called. (If the object's block might
not be locked down, perhaps you should send 
<A HREF="../../SysObjects/Meta/MetaClass_4.htm#IX_MSG_META_IS_OBJECT_IN_CLASS">MSG_META_IS_OBJECT_IN_CLASS</A> to the object instead of calling this
routine.)</DD>
<DT>
<CODE>
class</CODE>
</DT><DD>A pointer to the subject class' <CODE>
ClassStruct</CODE>
 definition.</DD>
</DL>
<P>
<CODE>
ObjIsObjectInClass()</CODE>
 returns <CODE>
true</CODE>
 if the object is in the class, <CODE>
false</CODE>
 (zero) if it is not.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	object.h</P>
</DIV>
<DIV>
<A NAME="R_7b.htm_IX_ObjIsObjectInClassHandles()">
 </A>
<H1 CLASS="refHeading">
ObjIsObjectInClassHandles()</H1>
<PRE CLASS="syntax">Boolean	ObjIsObjectInClassHandles(
        MemHandle		mh,				/* handle portion of optr */
        ChunkHandle		ch,				/* chunk portion of optr */
        ClassStruct		* class);				/* proposed class */</PRE>
<P>
This routine is just like <CODE>
<A HREF="../../CRef/Routines/R_7b.htm#IX_ObjIsObjectInClass()">ObjIsObjectInClass()</A></CODE>
 except the object is specified via its handles rather than its optr.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	object.h</P>
</DIV>
<DIV>
<A NAME="R_7b.htm_IX_ObjLinkFindParent()">
 </A>
<H1 CLASS="refHeading">
ObjLinkFindParent()</H1>
<PRE CLASS="syntax">optr	ObjLinkFindParent(
        optr	obj,		/* child's optr */
        word	masterOffset,		/* offset to master part with link field */
        word	linkOffset);		/* offset in master part to link field */</PRE>
<P>
This routine returns the optr of the specified object's parent. It must be passed the following:</P>
<DL>
<DT>
<EM>
obj</EM>
</DT><DD>The optr of the object whose parent is to be found.</DD>
<DT>
<CODE>
masterOffset</CODE></DT><DD>

The offset within the object's instance chunk to its master group's offset (the value that would appear in the <CODE>
Class_masterOffset</CODE>
 field in its <CODE>
ClassStruct</CODE>
 structure).</DD>
<DT>
<CODE>
linkOffset</CODE>
</DT><DD>The offset within the object's instance chunk to the link field.</DD>
</DL>
<P CLASS="refField"><STRONG>
Include:</STRONG>	metaC.goh</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE>MSG_VIS_FIND_PARENT</CODE>,
<CODE>MSG_GEN_FIND_PARENT</CODE>.</P>
</DIV>
<DIV>
<A NAME="R_7b.htm_IX_ObjLockObjBlock()">
 </A>
<H1 CLASS="refHeading">
ObjLockObjBlock()</H1>
<PRE CLASS="syntax">void	* ObjLockObjBlock(
        MemHandle mh);			/* handle of object block */</PRE>
<P>
This routine locks an object block, loading in the block if necessary. It must be passed the handle of the block, and it returns the locked block's segment address. When the caller is done using the block, it should unlock it with <CODE>
<A HREF="../../CRef/Routines/R_70.htm#IX_MemUnlock()">MemUnlock()</A></CODE>
.</P>
<P CLASS="refField"><STRONG>
Be Sure To:</STRONG>	Always unlock the block when you are done with it, with <CODE>
<A HREF="../../CRef/Routines/R_70.htm#IX_MemUnlock()">MemUnlock()</A></CODE>
.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	object.h</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_6d.htm#IX_MemLock()">MemLock()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_70.htm#IX_MemUnlock()">MemUnlock()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_7b.htm_IX_ObjMapSavedToState()">
 </A>
<H1 CLASS="refHeading">
ObjMapSavedToState()</H1>
<PRE CLASS="syntax">VMBlockHandle ObjMapSavedToState(
        MemHandle mh);			/* handle of object block */</PRE>
<P>
This routine returns the VM block handle of the state file block corresponding to the passed object block. If the specified object block has no state file equivalent, a null handle is returned.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	object.h</P>
</DIV>
<DIV>
<A NAME="R_7b.htm_IX_ObjMapStateToSaved()">
 </A>
<H1 CLASS="refHeading">
ObjMapStateToSaved()</H1>
<PRE CLASS="syntax">MemHandle ObjMapStateToSaved(
        VMBlockHandle		vmbh,			/* VM block handle of state block */
        GeodeHandle		gh);			/* handle of geode owning block */</PRE>
<P>
This routine takes a VM block handle and a geode handle and returns the memory block corresponding to the VM block, if any. The two parameters are</P>
<DL>
<DT>
<CODE>
vmbh</CODE>
</DT><DD>The VM block handle of the VM block to be mapped.</DD>
<DT>
<CODE>
gh</CODE>
</DT><DD>The geode handle of the owner of the block, or zero to use the calling geode's handle.</DD>
</DL>
<P>
If the block is found, <CODE>
ObjMapStateToSaved()</CODE>
 returns its handle. If the block is not found, it returns a null handle.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	object.h</P>
</DIV>
<DIV>
<A NAME="R_7b.htm_IX_ObjMarkDirty()">
 </A>
<H1 CLASS="refHeading">
ObjMarkDirty()</H1>
<PRE CLASS="syntax">void	ObjMarkDirty(
        optr 	o);	/* object to be marked dirty */</PRE>
<P>
This routine marks an object dirty, indicating that changes to it should be saved when its object block is saved. If you want changes to objects saved, you should mark the object dirty.</P>
<P CLASS="refField"><STRONG>
Tips and Tricks:</STRONG>	Often you do not need this routine because parameters or flags to other routines will set the object dirty automatically. If there is any doubt, however, you should use this routine.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	object.h</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Structs/S_2a.htm#IX_ObjChunkFlags">ObjChunkFlags</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_7c.htm#IX_ObjSetFlags()">ObjSetFlags()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_7b.htm_IX_ObjMarkDirtyHandles()">
 </A>
<H1 CLASS="refHeading">
ObjMarkDirtyHandles()</H1>
<PRE CLASS="syntax">void	ObjMarkDirtyHandles(
        MemHandle		mh,			/* handle portion of optr */
        ChunkHandle		ch);			/* chunk portion of optr */</PRE>
<P>
This routine is the same as <CODE>
<A HREF="../../CRef/Routines/R_7b.htm#IX_ObjMarkDirty()">ObjMarkDirty()</A></CODE>
 except that it specifies the object via handles rather than an optr.</P>
</DIV>
<DIV>
<A NAME="R_7b.htm_IX_ObjProcBroadcastMessage()">
 </A>
<H1 CLASS="refHeading">
ObjProcBroadcastMessage()</H1>
<PRE CLASS="syntax">void	ObjProcBroadcastMessage(
        EventHandle event);			/* the event to be broadcast */</PRE>
<P>
This routine broadcasts the given event to all threads which have message queues. It must be passed an encapsulated event (usually recorded with <CODE>
@record</CODE>
) and returns nothing. This is typically used for notification purposes.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	metaC.goh</P>
</DIV>
<DIV>
<A NAME="R_7b.htm_IX_ObjRelocateEntryPoint()">
 </A>
<H1 CLASS="refHeading">
ObjRelocateEntryPoint()</H1>
<PRE CLASS="syntax">void *	ObjRelocateEntryPoint(
        EntryPointRelocation *			relocData);</PRE>
</DIV>
<DIV>
<A NAME="R_7b.htm_IX_ObjRelocOrUnRelocSuper()">
 </A>
<H1 CLASS="refHeading">
ObjRelocOrUnRelocSuper()</H1>
<PRE CLASS="syntax">void	ObjRelocOrUnRelocSuper(
        optr 		oself,
        ClassStruct		*class,
        word		frame);</PRE>
<P>
Call this routine to relocate an object's superclass.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	object.h</P>
</DIV>
<HR>
<A NAME="R_7c.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_7c.htm_IX_ObjResizeMaster()">
 </A>
<H1 CLASS="refHeading">
ObjResizeMaster()</H1>
<PRE CLASS="syntax">void	ObjResizeMaster(
        optr	obj,		/* object to have its master part resized */
        word	masterOffset,		/* master offset of proper master part */
        word	newSize);		/* new size for the master part */</PRE>
<P>
This routine resizes a master part of an object's instance chunk. It is typically used to allocate space for a master part or to resize the master part to zero (as when the Vis part of a visible object is removed in <CODE>
MSG_VIS_CLOSE</CODE>
). This routine must be passed the following three parameters:</P>
<DL>
<DT>
<CODE>
obj</CODE>
</DT><DD>The optr of the object whose master part is to be resized.</DD>
<DT>
<CODE>
masterOffset</DT><DD>
</CODE>
The offset into the object's instance chunk where the offset to the master part is kept (this is the same offset held in the master class' <CODE>
Class_masterOffset</CODE>
 field).</DD>
<DT>
<CODE>
newSize</CODE>
</DT><DD>The new size of the master part. This can be found in the master class' <CODE>
Class_instanceSize</CODE>
 field.</DD>
</DL>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	This routine may resize and/or move chunks or object blocks, thereby invalidating stored segment addresses and pointers.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	object.h</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Structs/S_6.htm#IX_ClassStruct">ClassStruct</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_7a.htm#IX_ObjInitializeMaster()">ObjInitializeMaster()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_7a.htm#IX_ObjInitializePart()">ObjInitializePart()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_7c.htm_IX_ObjResizeMasterHandles()">
 </A>
<H1 CLASS="refHeading">
ObjResizeMasterHandles()</H1>
<PRE CLASS="syntax">void	ObjResizeMasterHandles(
        MemHandle		mh,				/* handle portion of optr */
        ChunkHandle		ch,				/* chunk portion of optr */
        word		masterOffset,				/* offset to master part */
        word		newSize);				/* new size of master part */</PRE>
<P>
This routine is the same as <CODE>
<A HREF="../../CRef/Routines/R_7c.htm#IX_ObjResizeMaster()">ObjResizeMaster()</A></CODE>
 except that the object is specified with its handles rather than its optr.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	object.h</P>
</DIV>
<DIV>
<A NAME="R_7c.htm_IX_ObjSaveBlock()">
 </A>
<H1 CLASS="refHeading">
ObjSaveBlock()</H1>
<PRE CLASS="syntax">void	ObjSaveBlock(
        MemHandle mh);			/*handle of block to be marked for saving */</PRE>
<P>
This routine sets up an object or LMem block to be saved to its owner's state file. The block's handle must be passed in <CODE>
mh</CODE>
. The block must be an object block.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	object.h</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_7b.htm#IX_ObjMapSavedToState()">ObjMapSavedToState()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_7b.htm#IX_ObjMapStateToSaved()">ObjMapStateToSaved()</A></CODE>.</P>
</DIV>

<DIV>
<A NAME="R_7c.htm_IX_ObjSetFlags()">
 </A>
<H1 CLASS="refHeading">
ObjSetFlags()</H1>
<PRE CLASS="syntax">void	ObjSetFlags(
        optr		o,				/* object whose flags will be set */
        ObjChunkFlags 		bitsToSet,				/* flags to set */
        ObjChunkFlags		bitsToClear);				/* flags to clear */</PRE>
<P>
This routine sets the chunk flags for the specified object. Flags that should be set are passed in <CODE>
bitsToSet</CODE>
, and flags that should be cleared are passed in <CODE>
bitsToClear</CODE>
. Typically, applications will not use this routine but will rather let the kernel maintain the object's flags.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	object.h</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_79.htm#IX_ObjGetFlags()">ObjGetFlags()</A></CODE>,
<CODE><A HREF="../../CRef/Structs/S_2a.htm#IX_ObjChunkFlags">ObjChunkFlags</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_7c.htm_IX_ObjSetFlagsHandles()">
 </A>
<H1 CLASS="refHeading">
ObjSetFlagsHandles()</H1>
<PRE CLASS="syntax">void	ObjSetFlagsHandles(
        MemHandle		mh,				/* handle portion of optr */
        ChunkHandle		ch,				/* chunk portion of optr */
        ObjChunkFlags		bitsToSet,				/* flags to set */
        ObjChunkFlags		bitsToClear);				/* flags to clear */</PRE>
<P>
This routine is the same as <CODE>
<A HREF="../../CRef/Routines/R_7c.htm#IX_ObjSetFlags()">ObjSetFlags()</A></CODE>
 except that the object is specified via its handles rather than its optr.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	object.h</P>
</DIV>
<DIV>
<A NAME="R_7c.htm_IX_ObjTestIfObjBlockRunByCurThread()">
 </A>
<H1 CLASS="refHeading">
ObjTestIfObjBlockRunByCurThread()</H1>
<PRE CLASS="syntax">Boolean	ObjTestIfObjBlockRunByCurThread(
        MemHandle mh);			/* handle of object block */</PRE>
<P>
This routine checks if the calling thread is running the specified object block. This routine can be used to determine if calls to objects in the block are across threads or internal to the calling thread. Pass this routine the handle of the object block to be checked--if the object block is a VM block, the thread for the VM file is checked rather than that for the block.</P>
<P>
If the block is run by the calling thread, the return value is <CODE>
true</CODE>
. If a different thread runs the block, the return is <CODE>
false</CODE>
 (zero).</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	object.h</P>
</DIV>
<DIV>
<A NAME="R_7c.htm_IX_ObjUnrelocateEntryPoint()">
 </A>
<H1 CLASS="refHeading">
ObjUnrelocateEntryPoint()</H1>
<PRE CLASS="syntax">void	ObjUnrelocateEntryPoint(
        EntryPointRelocation *			relocData,
        void *			entryPoint);</PRE>
</DIV>
<HR>
<A NAME="R_7d.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_7d.htm_IX_ObjVarAddData()">
 </A>
<H1 CLASS="refHeading">
ObjVarAddData()</H1>
<PRE CLASS="syntax">void	* ObjVarAddData(
        optr		obj,				/* object to add vardata to */
        VardataKey		dataType,				/* vardata type */
        word		dataSize);				/* vardata data size, if any */</PRE>
<P>
This routine adds or alters a variable data entry for the specified object. If the data type does not currently exist in the instance chunk, it will be allocated and added to the chunk. If it does exist, the extra data of the entry will be re-initialized to all zeroes.</P>
<P>
This routine returns a pointer to the extra data of the new or modified entry; if the entry has no extra data, an opaque pointer to the entry is passed, and you can use this pointer with <CODE>
<A HREF="../../CRef/Routines/R_7e.htm#IX_ObjVarDeleteDataAt()">ObjVarDeleteDataAt()</A></CODE>
. In either case, the object will be marked dirty.</P>
<P>
If it is possible that you are adding the object's first/only field of 
variable data, set the object's <CODE>OCF_VARDATA_RELOC</CODE> flag by means 
of the 
<A HREF="../../CRef/Routines/R_7c.htm#IX_ObjSetFlags()">ObjSetFlags()</A> 
routine or 
<A HREF="../../SysObjects/Meta/MetaClass_6.htm#IX_MSG_META_SET_FLAGS">MSG_META_SET_FLAGS</A>.</P>
<P>
The parameters of this routine are</P>
<DL>
<DT>
<CODE>
obj</CODE>
</DT><DD>The optr of the object affected. This should be the caller's optr.</DD>
<DT>
<CODE>
dataType</CODE>
</DT><DD>The <CODE>
VardataKey</CODE>
 word declaring the data type and its flags. The VDF_SAVE_TO_STATE flag must be properly set; the VDF_EXTRA_DATA flag is ignored, however, as the routine will set it properly.</DD>
<DT>
<CODE>
dataSize</CODE>
</DT><DD>The size of the extra data for this type. If the type has no extra data, pass zero.</DD>
</DL>
<P CLASS="refField"><STRONG>
Include:</STRONG>	object.h</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	This routine should be called only by the object whose vardata is affected. To operate on other objects' vardata remotely, use messages provided by <CODE>
MetaClass</CODE>
 (see below under &quot;See Also&quot;).</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE>MSG_META_ADD_VAR_DATA</CODE>,
<CODE><A HREF="../../CRef/Routines/R_7e.htm#IX_ObjVarDeleteDataAt()">ObjVarDeleteDataAt()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_7d.htm_IX_ObjVarAddDataHandles()">
 </A>
<H1 CLASS="refHeading">
ObjVarAddDataHandles()</H1>
<PRE CLASS="syntax">void	* ObjVarAddDataHandles(
        MemHandle		mh,				/* handle portion of optr */
        ChunkHandle		ch,				/* chunk portion of optr */
        VardataKey		dataType,				/* vardata type */
        word		dataSize);				/* vardata data size, if any */</PRE>
<P>
This routine is the same as <CODE>
<A HREF="../../CRef/Routines/R_7d.htm#IX_ObjVarAddData()">ObjVarAddData()</A></CODE>
 except that the object is specified via its handles rather than its optr.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	object.h</P>
</DIV>
<DIV>
<A NAME="R_7d.htm_IX_ObjVarCopyDataRange()">
 </A>
<H1 CLASS="refHeading">
ObjVarCopyDataRange()</H1>
<PRE CLASS="syntax">void	ObjVarCopyDataRange(
        optr	source,	/* the optr of the source object */
        optr	dest,	/* the optr of the destination (calling) object */
        word	rangeStart,	/* the smallest data type value to be copied */
        word	rangeEnd);	/* the largest data type value to be copied */</PRE>
<P>
This routine copies all the vardata entries within the specified range from the <CODE>
source</CODE>
 object to the <CODE>
dest</CODE>
 object. The range to be copied is specified by data types and is between <CODE>
rangeStart</CODE>
 and <CODE>
rangeEnd</CODE>
, inclusive. If any data entries are copied, the destination object will be marked dirty.</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	This routine should be called only by the destination object; it is against OOP doctrine for one object to alter another's instance data.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	object.h</P>
</DIV>
<DIV>
<A NAME="R_7d.htm_IX_ObjVarDeleteData()">
 </A>
<H1 CLASS="refHeading">
ObjVarDeleteData()</H1>
<PRE CLASS="syntax">Boolean	ObjVarDeleteData(
        optr		obj,				/* object to delete from */
        VardataKey		dataType);				/* data type to delete */</PRE>
<P>
This routine deletes a vardata entry from the specified object's instance chunk, if the entry exists. The entry is specified by its data type; to delete an entry specified by a pointer to it, use <CODE>
<A HREF="../../CRef/Routines/R_7e.htm#IX_ObjVarDeleteDataAt()">ObjVarDeleteDataAt()</A></CODE>
, below. It returns an error flag: <CODE>
true</CODE>
 if the entry was not found, <CODE>
false</CODE>
 if the entry was successfully deleted. The object will also be marked dirty by the routine.</P>
<P>
The parameters for this routine are</P>
<DL>
<DT>
<CODE>
obj</CODE>
</DT><DD>The optr of the object affected. This should be the caller's optr.</DD>
<DT>
<CODE>
dataType</CODE>
</DT><DD>The <CODE>
VardataKey</CODE>
 word declaring the data type and its flags. Both the VDF_SAVE_TO_STATE flag and the VDF_EXTRA_DATA flag are ignored.</DD>
</DL>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	This routine should be called only by the object whose vardata is affected. To operate on other objects' vardata remotely, use messages provided by <CODE>
MetaClass</CODE>
 (see below under &quot;See Also&quot;).</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	object.h</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE>MSG_META_DELETE_VAR_DATA</CODE>,
<CODE><A HREF="../../CRef/Routines/R_7e.htm#IX_ObjVarDeleteDataAt()">ObjVarDeleteDataAt()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_7d.htm_IX_ObjVarDeleteDataHandles()">
 </A>
<H1 CLASS="refHeading">
ObjVarDeleteDataHandles()</H1>
<PRE CLASS="syntax">Boolean	ObjVarDeleteDataHandles(
        MemHandle		mh,				/* handle portion of optr */
        ChunkHandle		ch,				/* chunk portion of optr */
        VardataKey		dataType);				/* data type to delete */</PRE>
<P>
This routine is the same as <CODE>
<A HREF="../../CRef/Routines/R_7d.htm#IX_ObjVarDeleteData()">ObjVarDeleteData()</A></CODE>
 except that the object is specified via its handles rather than its optr.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	object.h</P>
</DIV>
<HR>
<A NAME="R_7e.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_7e.htm_IX_ObjVarDeleteDataAt()">
 </A>
<H1 CLASS="refHeading">
ObjVarDeleteDataAt()</H1>
<PRE CLASS="syntax">void	ObjVarDeleteDataAt(
        optr	obj,			/* object to delete from */
        word	extraDataOffset);			/* offset to extra data to delete */</PRE>
<P>
This routine deletes the specified vardata entry from the given object's instance chunk. The vardata entry is specified by its pointer as returned by <CODE>
<A HREF="../../CRef/Routines/R_7d.htm#IX_ObjVarAddData()">ObjVarAddData()</A></CODE>
, <CODE>
<A HREF="../../CRef/Routines/R_7e.htm#IX_ObjVarFindData()">ObjVarFindData()</A></CODE>
, and <CODE>
<A HREF="../../CRef/Routines/R_7e.htm#IX_ObjVarDerefData()">ObjVarDerefData()</A></CODE>
. To delete an entry specified by its data type, use <CODE>
<A HREF="../../CRef/Routines/R_7d.htm#IX_ObjVarDeleteData()">ObjVarDeleteData()</A></CODE>
, above.</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	This routine should be called only by the object whose vardata is affected. To operate on other objects' vardata remotely, use messages provided by <CODE>
MetaClass</CODE>
 (see below under &quot;See Also&quot;).</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	object.h</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE>MSG_META_DELETE_VAR_DATA</CODE>,
<CODE><A HREF="../../CRef/Routines/R_7d.htm#IX_ObjVarDeleteData()">ObjVarDeleteData()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_7e.htm_IX_ObjVarDeleteDataAtHandles()">
 </A>
<H1 CLASS="refHeading">
ObjVarDeleteDataAtHandles()</H1>
<PRE CLASS="syntax">void	ObjVarDeleteDataAtHandles(
        MemHandle		mh,			/* handle portion of optr */
        ChunkHandle		ch,			/* chunk portion of optr */
        word	extraDataOffset);				/* offset to extra data to delete */</PRE>
<P>
This routine is the same as <CODE>
<A HREF="../../CRef/Routines/R_7e.htm#IX_ObjVarDeleteDataAt()">ObjVarDeleteDataAt()</A></CODE>
 except that the object is specified via its handles rather than its optr.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	object.h</P>
</DIV>
<DIV>
<A NAME="R_7e.htm_IX_ObjVarDeleteDataRange()">
 </A>
<H1 CLASS="refHeading">
ObjVarDeleteDataRange()</H1>
<PRE CLASS="syntax">void	ObjVarDeleteDataRange(
        optr 		obj,					/* object to delete from */
        word		rangeStart,					/* start of range */
        word		rangeEnd,					/* end of range */
        Boolean		useStateFlag);					/* save to state flag */</PRE>
<P>
This routine deletes all data entries within a given range for the passed object. The range is specified by beginning and ending data types and is inclusive. The four parameters to this routine are</P>
<DL>
<DT>
<CODE>
obj</CODE>
</DT><DD>The optr of the object whose data entries are to be deleted.</DD>
<DT>
<CODE>
rangeStart</CODE>
</DT><DD>The lowest number data type to be deleted. Both the VDF_SAVE_TO_STATE flag and the VDF_EXTRA_DATA flag are ignored.</DD>
<DT>
<CODE>
rangeEnd</CODE>
</DT><DD>The highest number data type to be deleted. Both the VDF_SAVE_TO_STATE flag and the VDF_EXTRA_DATA flag are ignored.</DD>
<DT>
<CODE>
useStateFlag</DT><DD>
</CODE>
A flag indicating whether entries with their VDF_SAVE_TO_STATE flags should be deleted. Pass <CODE>
true</CODE>
 (nonzero) to take the state flag into account; pass <CODE>
false</CODE>
 (zero) to delete all entries in the range.</DD>
</DL>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	This routine should be called only by the object whose vardata is affected. To operate on other objects' vardata remotely, use messages provided by <CODE>
MetaClass</CODE>
 (see below under &quot;See Also&quot;).</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	object.h</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE>MSG_META_DELETE_VAR_DATA</CODE>.</P>
</DIV>
<DIV>
<A NAME="R_7e.htm_IX_ObjVarDeleteDataRangeHandles()">
 </A>
<H1 CLASS="refHeading">
ObjVarDeleteDataRangeHandles()</H1>
<PRE CLASS="syntax">void	ObjVarDeleteDataRangeHandles(
        MemHandle		mh,					/* handle portion of optr */
        ChunkHandle		ch,					/* chunk portion of optr */
        word		rangeStart,					/* start of range */
        word		rangeEnd,					/* end of range */
        Boolean		useStateFlag);					/* save to state flag */</PRE>
<P>
This routine is the same as <CODE>
<A HREF="../../CRef/Routines/R_7e.htm#IX_ObjVarDeleteDataRange()">ObjVarDeleteDataRange()</A></CODE>
 except that the object is specified via its handles rather than its optr.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	object.h</P>
</DIV>
<DIV>
<A NAME="R_7e.htm_IX_ObjVarDerefData()">
 </A>
<H1 CLASS="refHeading">
ObjVarDerefData()</H1>
<PRE CLASS="syntax">void	* ObjVarDerefData(
        optr		obj,				/* object having data type */
        VardataKey		dataType);				/* data type to dereference */</PRE>
<P>
This routine is exactly like <CODE>
<A HREF="../../CRef/Routines/R_7e.htm#IX_ObjVarFindData()">ObjVarFindData()</A></CODE>
, below, except that it does not return a null pointer if the data type is not found. Do not use this routine unless you are absolutely sure the data type is in the object; otherwise, results are unpredictable.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
object.h </STRONG>
</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_7e.htm#IX_ObjVarFindData()">ObjVarFindData()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_7e.htm_IX_ObjVarDerefDataHandles()">
 </A>
<H1 CLASS="refHeading">
ObjVarDerefDataHandles()</H1>
<PRE CLASS="syntax">void	* ObjVarDerefDataHandles(
        MemHandle		mh,				/* handle portion of optr */
        ChunkHandle		ch,				/* chunk portion of optr */
        VardataKey		dataType);				/* data type to dereference */</PRE>
<P>
This routine is the same as <CODE>
<A HREF="../../CRef/Routines/R_7e.htm#IX_ObjVarDerefData()">ObjVarDerefData()</A></CODE>
 except that the object is specified via its handles rather than its optr.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
object.h </STRONG>
</P>
</DIV>
<DIV>
<A NAME="R_7e.htm_IX_ObjVarFindData()">
 </A>
<H1 CLASS="refHeading">
ObjVarFindData()</H1>
<PRE CLASS="syntax">void	* ObjVarFindData(
        optr		obj,				/* object to be checked */
        VardataKey		dataType);				/* data type to find */</PRE>
<P>
This routine searches an object's variable data for a given data type. If the type is found, <CODE>
ObjVarFindData()</CODE>
 returns a pointer to the entry's extra data; if the entry has no extra data, an opaque pointer is returned which may be used with <CODE>
<A HREF="../../CRef/Routines/R_7e.htm#IX_ObjVarDeleteDataAt()">ObjVarDeleteDataAt()</A></CODE>
. If the entry is not found, a null pointer is returned. The pointer returned by this routine must be used before any subsequent operations on the object's block; the pointer may be invalidated by other LMem or object operations.</P>
<P>
The two parameters of this routine are</P>
<DL>
<DT>
<CODE>
obj</CODE>
</DT><DD>The optr of the object affected. This should be the caller's optr.</DD>
<DT>
<CODE>
dataType</CODE>
</DT><DD>The <CODE>
VardataKey</CODE>
 word declaring the data type and its flags. Both the VDF_SAVE_TO_STATE flag and the VDF_EXTRA_DATA flag are ignored.</DD>
</DL>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	This routine should be called only by the object whose vardata is affected. To operate on other objects' vardata remotely, use messages provided by <CODE>
MetaClass</CODE>
 (see below under &quot;See Also&quot;).</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
object.h </STRONG>
</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE>MSG_META_GET_VAR_DATA</CODE>.</P>
</DIV>
<DIV>
<A NAME="R_7e.htm_IX_ObjVarFindDataHandles()">
 </A>
<H1 CLASS="refHeading">
ObjVarFindDataHandles()</H1>
<PRE CLASS="syntax">void	* ObjVarFindDataHandles(
        MemHandle		mh,				/* handle portion of optr */
        ChunkHandle		ch,				/* chunk portion of optr */
        VardataKey		dataType);				/* data type to find */</PRE>
<P>
This routine is the same as <CODE>
<A HREF="../../CRef/Routines/R_7e.htm#IX_ObjVarFindData()">ObjVarFindData()</A></CODE>
 except that the object is specified via its handles rather than its optr.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
object.h </STRONG>
</P>
</DIV>
<HR>
<A NAME="R_7f.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_7f.htm_IX_ObjVarScanData()">
 </A>
<H1 CLASS="refHeading">
ObjVarScanData()</H1>
<PRE CLASS="syntax">void	ObjVarScanData(
        optr		obj,					/* object to be scanned */
        word		numHandlers,					/* number of handlers in table */
        VarDataCHandler		* handlerTable,					/* pointer to handler table */
        void		* handlerData);					/* pointer to handler data */</PRE>
<P>
This routine scans an object's vardata and calls all the vardata handlers specified in the passed handler table. Pass it the following parameters:</P>
<DL>
<DT>
<CODE>
obj</CODE>
</DT><DD>The optr of the object whose variable data table is to be scanned.</DD>
<DT>
<CODE>
numHandlers</DT><DD>
</CODE>
The number of handlers specified in the passed handler table.</DD>
<DT>
<CODE>
handlerTable</DT><DD>
</CODE>
A pointer to a list of <CODE>
VarDataCHandler</CODE>
 structures. Each of these structures contains a vardata data type and a pointer to the routine that is to handle it. All the handler routines must be in the same segment as the handler table.</DD>
<DT>
<CODE>
handlerData</DT><DD>
</CODE>
A pointer to a buffer that is passed on to the handlers. This can contain any information of specific interest to the application or handlers.</DD>
</DL>
<P CLASS="refField"><STRONG>
<STRONG>
Vardata Handler Format:</STRONG><BR>
</STRONG>
A vardata handler routine must have the following format:</P>
<PRE>void _pascal (MemHandle mh, ChunkHandle chnk,
	VarDataEntry *extraData, word dataType,
	void *handlerData)</PRE>
<P>
The handler should not free the object chunk or destroy the object; it can do anything else it pleases. The handler returns nothing and takes the following parameters:</P>
<DL>
<DT>
<CODE>
mh:chnk</CODE>
</DT><DD>The memory handle and chunk handle of the object being referenced. Together, these comprise the optr of the object.</DD>
<DT>
<CODE>
extraData</CODE>
</DT><DD>A pointer to the data type's extra data, if it has any. This pointer may be parsed with the macros <CODE>
<A HREF="../../CRef/Routines/R_a0.htm#IX_VarDataTypePtr() macro">VarDataTypePtr()</A></CODE>
, <CODE>
<A HREF="../../CRef/Routines/R_a0.htm#IX_VarDataFlagsPtr() macro">VarDataFlagsPtr()</A></CODE>
, and <CODE>
<A HREF="../../CRef/Routines/R_a0.htm#IX_VarDataSizePtr() macro">VarDataSizePtr()</A></CODE>
.</DD>
<DT>
<CODE>
dataType</CODE>
</DT><DD>The data type of the data entry being handled. This is a record of type <CODE>
VardataKey</CODE>
.</DD>
<DT>
<CODE>
handlerData</DT><DD>
</CODE>
A pointer to a buffer passed through by <CODE>
ObjVarScanData()</CODE>
. This buffer may be used for passing additional data to the handlers.</DD>
</DL>
<P CLASS="refField"><STRONG>
Structures:</STRONG>	The <CODE>
VarDataCHandler</CODE>
 structure contains two elements:</P>
<PRE>typedef struct {
    word		VDCH_dataType;
    void	_pascal 	(*VDCH_handler) (
			MemHandle		mh,
			ChunkHandle		chnk,
			VarDataEntry		* extraData,
			word		dataType
			void		* handlerData);
} VarDataCHandler;</PRE>
<P>
The first element is the data type, a record containing the data type and the vardata flags. The second element is a far pointer to the handler routine for the type.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
object.h </STRONG>
</P>
</DIV>
<DIV>
<A NAME="R_7f.htm_IX_ObjVarScanDataHandles()">
 </A>
<H1 CLASS="refHeading">
ObjVarScanDataHandles()</H1>
<PRE CLASS="syntax">void	ObjVarScanDataHandles(
        MemHandle		mh,				/* handle portion of optr */
        ChunkHandle		ch,				/* chunk portion of optr */
        word		numHandlers,					/* number of handlers in table */
        VarDataCHandler		* handlerTable,					/* pointer to handler table */
        void		* handlerData);					/* pointer to handler data */</PRE>
<P>
This routine is the same as <CODE>
<A HREF="../../CRef/Routines/R_7f.htm#IX_ObjVarScanData()">ObjVarScanData()</A></CODE>
 except that the object is specified via its handles rather than its optr.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
object.h </STRONG>
</P>
</DIV>
<DIV>
<A NAME="R_7f.htm_IX_offsetof()">
 </A>
<H1 CLASS="refHeading">
offsetof()</H1>
<PRE CLASS="syntax">word	offsetof(<EM>struc</EM>, <EM>field</EM>);</PRE>
<P>
This macro returns the offset of the specified field within the specified structure.</P>
</DIV>
<DIV>
<A NAME="R_7f.htm_IX_OptrToChunk()">
 </A>
<H1 CLASS="refHeading">
OptrToChunk()</H1>
<PRE CLASS="syntax">ChunkHandle OptrToChunk(<EM>op</EM>);
        optr	<EM>op</EM>;</PRE>
<P>
This macro extracts the chunk handle portion of the given optr.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_d.htm#IX_ConstructOptr() macro">ConstructOptr()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_7f.htm#IX_OptrToHandle()">OptrToHandle()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_7f.htm_IX_OptrToHandle()">
 </A>
<H1 CLASS="refHeading">
OptrToHandle()</H1>
<PRE CLASS="syntax">MemHandle OptrToHandle(<EM>op</EM>);
        optr	<EM>op</EM>;</PRE>
<P>
This macro extracts the MemHandle portion of the given optr.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_d.htm#IX_ConstructOptr() macro">ConstructOptr()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_7f.htm#IX_OptrToChunk()">OptrToChunk()</A></CODE>.</P>
</DIV>
<HR>
<A NAME="R_80.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_80.htm_IX_ParallelClose()">
 </A>
<H1 CLASS="refHeading">
ParallelClose()</H1>
<PRE CLASS="syntax">StreamError ParallelClose(
        GeodeHandle 		driver,
        ParallelUnit 		unit,
        Boolean 		linger);</PRE>
<P>
Close the stream to a parallel port.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
streamC.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_80.htm_IX_ParallelGetError()">
 </A>
<H1 CLASS="refHeading">
ParallelGetError()</H1>
<PRE CLASS="syntax">StreamError	 	ParallelGetError (
        Handle 		driver,
        ParallelUnit		unit,
        StreamRoles 		roles,
        ParallelError *		errorCode);</PRE>
<P>
This routine returns any parallel-driver-specific error codes set by the last call to the parallel-driver.</P>
</DIV>
<DIV>
<A NAME="R_80.htm_IX_ParallelOpen()">
 </A>
<H1 CLASS="refHeading">
ParallelOpen()</H1>
<PRE CLASS="syntax">StreamError ParallelOpen(
        GeodeHandle 		driver,
        ParallelUnit 		unit,
        StreamOpenFlags 		flags,
        word		outBuffSize,
        word 		timeout);</PRE>
<P>
This routine opens a stream to the specified parallel port. It is passed the following arguments:</P>
<DL>
<DT>
<CODE>
driver</CODE>
</DT><DD>The <CODE>
GeodeToken</CODE>
 of the parallel driver.</DD>
<DT>
<CODE>
unit</CODE>
</DT><DD>The parallel port to open.</DD>
<DT>
<CODE>
flags</CODE>
</DT><DD>This specifies whether the call should fail if the port is busy, or wait for a time to see if it will become free.</DD>
<DT>
<CODE>
outBuffSize</CODE>
</DT><DD>The size of the stream buffer used for output to the parallel port.</DD>
<DT>
<CODE>
timeout</CODE>
</DT><DD>The number of clock ticks to wait for the port to become free. (This argument is ignored if <CODE>
flags</CODE>
 is not STREAM_OPEN_TIMEOUT.)</DD>
</DL>
<P>
If the routine is successful, it returns zero. If it is unsuccessful, it returns a member of the <CODE>
StreamError</CODE>
 enumerated type.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
streamC.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_80.htm_IX_ParallelSetError()">
 </A>
<H1 CLASS="refHeading">
ParallelSetError()</H1>
<PRE CLASS="syntax">StreamError ParallelSetError(
        Handle 		driver,
        ParallelUnit 		unit,
        StreamRoles		roles,
        ParallelError *		errorCode);</PRE>
<P>
This routine sets the device-specific error code for the specified parallel port.</P>
</DIV>
<DIV>
<A NAME="R_80.htm_IX_ParallelWrite()">
 </A>
<H1 CLASS="refHeading">
ParallelWrite()</H1>
<PRE CLASS="syntax">StreamError ParallelWrite(
        GeodeHandle 		driver,
        ParallelUnit 		unit,
        StreamBlocker 		blocker,
        word 		buffSize,
        const byte *		buffer,
        word *		numBytesWritten);</PRE>
<P>
Write data to a parallel port.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
streamC.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_80.htm_IX_ParallelWriteByte()">
 </A>
<H1 CLASS="refHeading">
ParallelWriteByte()</H1>
<PRE CLASS="syntax">StreamError ParallelWrite(
        GeodeHandle 		driver,
        ParallelUnit 		unit,
        StreamBlocker 		blocker,
        word 		buffSize,
        byte		dataByte);</PRE>
<P>
Write one byte of data to a parallel port.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
streamC.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_80.htm_IX_ParserParseString()">
 </A>
<H1 CLASS="refHeading">
ParserParseString()</H1>
<PRE CLASS="syntax">ParserScannerEvaluatorError ParserParseString(
        char		*textBuffer,
        byte		*tokenBuffer,
        CParserStruct		*parserParams,
        CParserReturnStruct		*retVal);</PRE>
<P>
Parse a string into a sequence of tokens.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
parse.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_80.htm_IX_ParserEvalExpression()">
 </A>
<H1 CLASS="refHeading">
ParserEvalExpression()</H1>
<PRE CLASS="syntax">ParserScannerEvaluatorError ParserEvalExpression(
        byte		*scratchBuffer,
        byte		*resultBuffer,
        word		bufSize,
        CEvalStruct		*evalParams);</PRE>
<P>
Evaluate a parsed expression.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
parse.h</STRONG>
</P>
</DIV>
<DIV>
<A NAME="R_80.htm_IX_ParserFormatExpression()">
 </A>
<H1 CLASS="refHeading">
ParserFormatExpression()</H1>
<PRE CLASS="syntax">ParserScannerEvaluatorError ParserFormatExpression(
        byte		*tokenBuffer,
        char		*textBuffer,
        CFormatStruct		*formatParams);</PRE>
<P>
Format an expression from parsed data.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
parse.h</STRONG>
</P>
</DIV>
<DIV>
<A NAME="R_80.htm_IX_PCB()">
 </A>
<H1 CLASS="refHeading">
PCB()</H1>
<PRE CLASS="syntax">#define PCB(return_type, pointer_name, args) \
        return_type _pascal (*pointer_name) args</PRE>
<P>
This macro is useful for declaring pointers to functions that use the pascal calling conventions. For example, to declare a pointer to a function which is passed two strings and returns an integer, one could write</P>
<PRE>PCB(int, func_ptr, (const char *, const char *));</PRE>
<P>
which would be expanded to</P>
<PRE>int _pascal (*func_ptr) (const char *, const char *);</PRE>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_4.htm#IX_CCB() macro">CCB()</A></CODE>.</P>
</DIV>
<HR>
<A NAME="R_81.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_81.htm_IX_PCCOMABORT()">
 </A>
<H1 CLASS="refHeading">
PCCOMABORT()</H1>
<PRE CLASS="syntax">void PCCOMABORT(void);</PRE>
<P>
This routine aborts the current file transfer operation being carried out by the PCCom library. It is the third entry point in the PCCom library.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
pccom.goh </STRONG>
</P>
</DIV>
<DIV>
<A NAME="R_81.htm_IX_PCCOMEXIT()">
 </A>
<H1 CLASS="refHeading">
PCCOMEXIT()</H1>
<PRE CLASS="syntax">PCComReturnType PCCOMEXIT();</PRE>
<P>
This routine kills a pccom thread such as those started by PCCOMINIT(). It is the second entry point in the PCCom library.</P>
<P CLASS="refField"><STRONG>
Structures:</STRONG>	</P>
<PRE CLASS="syntax">        typedef ByteEnum PCComReturnType;
        #define PCCRT_NO_ERROR 0
        #define PCCRT_CANNOT_LOAD_SERIAL_DRIVER 1
        #define PCCRT_CANNOT_CREATE_THREAD 2
        #define PCCRT_CANNOT_ALLOC_STREAM 3
        #define PCCRT_ALREADY_INITIALIZED 4</PRE>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
pccom.goh </STRONG>
</P>
</DIV>
<DIV>
<A NAME="R_81.htm_IX_PCCOMINIT()">
 </A>
<H1 CLASS="refHeading">
PCCOMINIT()</H1>
<PRE CLASS="syntax">PCComReturnType PCCOMINIT(
        SerialPortNum 		port,
        SerialBaud 		baud,
        word 		timeout,
        optr 		callbackOptr,
        PCComInitFlags 		flags);</PRE>
<P>
This entry point of the PCCom library spawns a new thread which monitors a serial port and acts as a passive pccom terminal. This routine is the first entry point in the PCCom library.</P>
<P>
This routine takes the following arguments:</P>
<DL>
<DT>
<EM>port</EM></DT><DD>A <CODE>
SerialPortNum</CODE>
 value specifying which serial port to use for the pccom connection. Pass -1 for the system default value: <CODE>
com1</CODE>
 for the Zoomer, <CODE>
com2</CODE>
 for the desktop product.</DD>
<DT>
<EM>baud</EM></DT><DD>A <CODE>
SerialBaud</CODE>
 value specifying what speed to use. Pass -1 for the system default value: 19200 baud for the Zoomer, 38400 baud for the desktop product.</DD>
<DT>
<EM>timeout</EM></DT><DD>Number of clock ticks (one tick is 1/60 second) to allow for connection.</DD>
<DT>
<EM>callbackOptr</DT><DD>
</EM>An object which will receive notification messages of certain events. A value of zero means no notification will be sent.</DD>
<DT>
<EM>flags</EM></DT><DD>If an object will be receiving notification messages, these flags determine what sort of notifications will be sent.</DD>
</DL>
<P CLASS="refField"><STRONG>
Structures:</STRONG>	</P>
<PRE CLASS="syntax">        typedef ByteEnum PCComReturnType;
        #define PCCRT_NO_ERROR 0
        #define PCCRT_CANNOT_LOAD_SERIAL_DRIVER 1
        #define PCCRT_CANNOT_CREATE_THREAD 2
        #define PCCRT_CANNOT_ALLOC_STREAM 3
        #define PCCRT_ALREADY_INITIALIZED 4
        &nbsp;
        typedef WordFlags PCComInitFlags;
        	/* send notifications when text is available for display */
        #define PCCIF_NOTIFY_OUTPUT 0x8000
        	/* send notification when the remote machine shuts down the
 * serial line */</PRE>
<PRE CLASS="syntax">        #define PCCIF_NOTIFY_EXIT 0x4000
        &nbsp;</PRE>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
pccom.goh </STRONG>
</P>
</DIV>
<DIV>
<A NAME="R_81.htm_IX_ProcCallFixedOrMovable_cdecl()">
 </A>
<H1 CLASS="refHeading">
ProcCallFixedOrMovable_cdecl()</H1>
<PRE CLASS="syntax">dword	ProcCallFixedOrMovable_cdecl(
        void 	(*routine),
        ...)</PRE>
<P>
This routine calls the routine pointed to, passing the other arguments through to the called routine. The called routine must use C calling conventions.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
resource.h </STRONG>
</P>
</DIV>
<DIV>
<A NAME="R_81.htm_IX_ProcCallFixedOrMovable_pascal()">
 </A>
<H1 CLASS="refHeading">
ProcCallFixedOrMovable_pascal()</H1>
<PRE CLASS="syntax">dword	ProcCallFixedOrMovable_pascal(
        ...,
        void 	(*routine))</PRE>
<P>
This routine calls the routine pointed to, passing the other arguments through to the called routine. The called routine must use Pascal calling conventions.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
resource.h </STRONG>
</P>
</DIV>
<DIV>
<A NAME="R_81.htm_IX_ProcGetLibraryEntry()">
 </A>
<H1 CLASS="refHeading">
ProcGetLibraryEntry()</H1>
<PRE CLASS="syntax">void *	ProcGetLibraryEntry(
        GeodeHandle		library,
        word		entryNumber)</PRE>
<P>
This routine returns the pointer to a library's entry-point.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
resource.h </STRONG>
</P>
</DIV>

<DIV>
<A NAME="R_81.htm_IX_ProcInfo()">
 </A>
<H1 CLASS="refHeading">
ProcInfo()</H1>
<PRE CLASS="syntax">ThreadHandle ProcInfo(
        GeodeHandle gh);		/* handle of geode to check */</PRE>
<P>
This routine returns the first thread of the process geode specified. If the geode is not a process, the routine will return a null handle.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
geode.h </STRONG>
</P>
</DIV>

<DIV>
<A NAME="R_81.htm_IX_PtrToOffset()">
 </A>
<H1 CLASS="refHeading">
PtrToOffset()</H1>
<PRE CLASS="syntax">word	PtrToOffset(<EM>ptr</EM>);
        dword	<EM>ptr</EM>;</PRE>
<P>
This macro returns just the lower 16 bits of the given dword. It is most useful for extracting the offset portion of a far pointer.</P>
</DIV>
<DIV>
<A NAME="R_81.htm_IX_PtrToSegment()">
 </A>
<H1 CLASS="refHeading">
PtrToSegment()</H1>
<PRE CLASS="syntax">word	PtrToSegment(<EM>ptr</EM>);
        dword	<EM>ptr</EM>;</PRE>
<P>
This macro returns just the upper 16 bits of the given dword. It is most useful for extracting the segment address of a far pointer.</P>
</DIV>


<DIV>
<A NAME="R_81.htm_IX_PutUpDialogViaUIThread()">
 </A>
<H1 CLASS="refHeading">
PutUpDialogViaUIThread()</H1>

<PRE CLASS="syntax">optr PutUpDialogViaUIThread(
	optr	dialogBoxTemplate );</PRE>
<P>
This routine displays a dialog using a template that you supply, and
runs it on the system's UI thread. It sends MSG_GEN_INTERACTION_INITIATE
to bring the dialog on screen. See the SDK_9000/Dialogs sample
application for an example of how to use this routine.
</P>

<P>
Use the routine <a href="R_94.htm#CREF_TakeDownDialogViaUIThread()">
TakeDownDialogViaUIThread()</a> to remove the duplicate dialog from
the screen and from memory.
</P>

<P CLASS="refField"><STRONG>
Pass:   </STRONG>
</P>
<DL>
<DT>
<EM>
dialogBoxTemplate</EM>
</DT><DD>Optr of the dialog you want to display. The dialog must be
set to GIA_SYS_MODAL and start off as not GS_USABLE.</DD>
<DT>
</DL>

<P CLASS="refField"><STRONG>
Return:</strong>
	Optr of the duplicated dialog object. Pass this to
<A HREF="#R_94.htm_CREF_TakeDownDialogViaUIThread()">
TakeDownDialogViaUIThread()</A> when you want to remove the dialog.

<P CLASS="refField"><STRONG>
Include:</STRONG>        <STRONG CLASS="fileName">
foam.goh</STRONG>
 </P>

<P CLASS="refField"><STRONG>
See Also:</STRONG>       
<a href="R_94.htm#IX_TakeDownDialogViaUIThread()">TakeDownDialogViaUIThread()</a>,
<a href="R_9e.htm#IX_UserCreateDialog()">UserCreateDialog()</a>
</P>
</DIV>

<HR>
<A NAME="R_82.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_82.htm_IX_qsort">
 </A>
<H1 CLASS="refHeading">
qsort</H1>
<PRE CLASS="syntax">extern void _pascal qsort(
        void *array, 
        word count, 
        word elementSize,
        PCB(int, compare, (const void *, const void *)));</PRE>
<P>
This is a standard quicksort routine. The callback routine must be decared _pascal.</P>
</DIV>
<DIV>
<A NAME="R_82.htm_IX_QueueGetMessage()">
 </A>
<H1 CLASS="refHeading">
QueueGetMessage()</H1>
<PRE CLASS="syntax">EventHandle QueueGetMessage(
        QueueHandle qh);			/* queue to query */</PRE>
<P>
This routine returns the next message on the given queue, blocking if the queue is empty. When a new message is added to the empty queue, this routine will unblock the thread and return the message. This routine is used almost exclusively by the kernel.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
geode.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_82.htm_IX_QueuePostMessage()">
 </A>
<H1 CLASS="refHeading">
QueuePostMessage()</H1>
<PRE CLASS="syntax">void	QueuePostMessage(
        QueueHandle		qh,			/* queue to add event to */
        EventHandle		event,			/* event to be added to queue */
        MessageFlags		flags);			/* MF_INSERT_AT_FRONT or zero */</PRE>
<P>
This routine adds the specified <CODE>
event</CODE>
 to the passed <CODE>
queue</CODE>
. The only valid flag for this routine is MF_INSERT_AT_FRONT, which will put the event in the first spot of the queue.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
geode.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_82.htm_IX_RangeEnum()">
 </A>
<A NAME="R_82.htm_IX_RangeEnumCallbackParams">
 </A>
<A NAME="R_82.htm_IX_RECP_&ldots;">
 </A>
<H1 CLASS="refHeading">
RangeEnum()</H1>
<PRE CLASS="syntax">Boolean	RangeEnum(
        CellFunctionParameters			* cfp,				/* cell function parameters */
        RangeEnumParams			* params);				/* special other parameters */</PRE>
<P>
This routine calls a callback routine for each cell in a specified range. This routine is passed pointers to two structures, both of which are shown below. It returns <EM>
false</EM>
 if all the cells were processed, <EM>
true</EM>
 if any of the cells caused the routine to abort before the end of the range was reached.</P>
<P CLASS="refField"><STRONG>
<STRONG>
Callback Parameters:</STRONG></STRONG>
 </P>
<P>
The callback routine, which must be declared _pascal, receives a <CODE>
RangeEnumCallbackParams</CODE>
 structure, which has the following definition:</P>
<PRE>typedef struct {
	RangeEnumParams			*RECP_params;		/* see below */
   /* current row, column, and cell data of cell */
	word			RECP_row;
	word			RECP_column;
	word			RECP_cellData;
} RangeEnumCallbackParams;</PRE>
<P>
The callback routine can do anything with the cell information. It should return <EM>
false </EM>
after successfully processing the cell; if an error occurs, or if it wants to abort the <CODE>
RangeEnum()</CODE>
, it should return <EM>
true</EM>
.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
cell.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_82.htm_IX_RangeExists()">
 </A>
<H1 CLASS="refHeading">
RangeExists()</H1>
<PRE CLASS="syntax">Boolean	RangeExists( /* returns non-zero if there are cells in range */
        CellFunctionParameters			* cfp,				/* see RangeEnum() */
        word			firstRow,				/* range delimiters */
        byte			firstColumn,
        word			lastRow,
        byte			lastColumn);</PRE>
<P>
This routine returns <EM>
true</EM>
 if there are any cells in the specified range. It is passed a pointer to the <CODE>
CellFunctionParameters</CODE>
 structure for the cell file, as well as the indices of the first and last row, and the first and last column, of the range to check.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
cell.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_82.htm_IX_RangeInsert()">
 </A>
<A NAME="R_82.htm_IX_RangeInsertParams">
 </A>
<A NAME="R_82.htm_IX_RIP_&ldots;">
 </A>
<H1 CLASS="refHeading">
RangeInsert()</H1>
<PRE CLASS="syntax">void	RangeInsert(
        CellFunctionParameters			* cfp,				/* see RangeEnum() */
        RangeInsertParams			* rep);				/* parameters structure */</PRE>
<P>
This routine shifts existing cells to make room for new ones. (It does not actually create new cells.) Which cells are shifted, and in what direction, is specified by the <CODE>
RangeInsertParams</CODE>
 structure:</P>
<DL>
<DT>
<CODE>
RIP_bounds</DT><DD></CODE>
A <CODE>
Rectangle</CODE>
 structure which specifies which cells should be shifted. The cells currently in this range will be shifted across or down, depending on the value of <CODE>
RIP_delta</CODE>
; the shifted cells displace more cells, and so on, to the edge of the visible portion of the cell file. To insert an entire row (which is much faster than inserting a partial row), set RIP<CODE>
_bounds.</CODE>
R<CODE>
_left</CODE>
 = 0 and RIP<CODE>
_bounds.</CODE>
R<CODE>
_right = </CODE>
LARGEST_COLUMN<CODE>
.</CODE>
</DD>
<DT>
<CODE>
RIP_delta</DT><DD></CODE>
A <CODE>
Point</CODE>
 structure which specifies how far the cells should be shifted and in which direction. If the range of cells is to be shifted horizontally, <CODE>
RIP_delta.</CODE>
P<CODE>
_x</CODE>
 should specify how far the cells should be shifted over, and <CODE>
RIP_delta.</CODE>
P<CODE>
_y</CODE>
 should be zero. If the cells are to be shifted vertically, <CODE>
RIP_delta.</CODE>
P<CODE>
_y</CODE>
 should specify how far the cells should be shifted over, and<CODE>
 RIP_delta.</CODE>
P<CODE>
_x</CODE>
 should be zero.</DD>
<DT>
<CODE>
RIP_cfp</DT><DD></CODE>
This is the address of the <CODE>
CellFunctionParameters</CODE>
 structure. You don't have to initialize this; the routine will do so automatically.</DD>
</DL>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
cell.h</STRONG>
 </P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	If cells are shifted off the &quot;visible&quot; portion of the cell file, you will be unable to access them by row or column numbers; but they will not be deleted. For this reason, you should free all such cells <EM>
before</EM>
 calling <CODE>
RangeInsert()</CODE>
. (You can find out if there are any cells at the edges by calling <CODE>
<A HREF="../../CRef/Routines/R_82.htm#IX_RangeExists()">RangeExists()</A></CODE>
.) For an explanation of the &quot;visible&quot; and &quot;scratch-pad&quot; portions of a cell file, see <A HREF="../../DataMgmt/Cell/CellLibrary_1.htm#99717">the Cell library documentation</A>.</P></DIV>
<HR>
<A NAME="R_83.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_83.htm_IX_realloc()">
 </A>
<H1 CLASS="refHeading">
realloc()</H1>
<PRE CLASS="syntax">void *	realloc(
        void *		blockPtr,				/* address of memory to resize */
        size_t		newSize);				/* New size of memory in bytes */</PRE>
<P>
The <CODE>
<A HREF="../../CRef/Routines/R_6a.htm#IX_malloc()">malloc()</A></CODE>
 family of routines is provided for Standard C compatibility. If a geode needs a small amount of fixed memory, it can call one of the routines. The kernel will allocate a fixed block to satisfy the geode's <CODE>
<A HREF="../../CRef/Routines/R_6a.htm#IX_malloc()">malloc()</A></CODE>
 requests; it will allocate memory from this block. When the block is filled, it will allocate another fixed malloc-block. When all the memory in the block is freed, the memory manager will automatically free the block.</P>
<P>
If a geode needs to change the size of a section of memory assigned to it by the <CODE>
<A HREF="../../CRef/Routines/R_6a.htm#IX_malloc()">malloc()</A></CODE>
 family of routines, it should use <CODE>
realloc()</CODE>
. <CODE>
realloc()</CODE>
 resizes the piece of memory specified and returns the memory's new base address.</P>
<P>
If the new size is smaller then the previous size, bytes will be cut off from the end. The request is guaranteed to succeed. Furthermore, the memory will not be moved; the address returned will be the same as the address passed.</P>
<P>
If the new size is larger than the previous size, <CODE>
realloc()</CODE>
 may move the data to accommodate the request. If so, it will return the new address. The new memory added will <EM>
not</EM>
 be zero-initialized. If <CODE>
realloc()</CODE>
 cannot fulfill the request, it will return a null pointer, and the memory will not be altered.</P>
<P>
Resizing a stretch of memory down to zero bytes is exactly the same as freeing it with <CODE>
<A HREF="../../CRef/Routines/R_2f.htm#IX_free()">free()</A></CODE>
. If you pass a null address to <CODE>
realloc()</CODE>
, it will allocate the memory the same way <CODE>
<A HREF="../../CRef/Routines/R_6a.htm#IX_malloc()">malloc()</A></CODE>
 does.</P>
<P>
The memory must be in a malloc-block assigned to the geode calling <CODE>
realloc()</CODE>
. If you want to resize memory in another geode's malloc-block, call <CODE>
<A HREF="../../CRef/Routines/R_36.htm#IX_GeoReAlloc()">GeoReAlloc()</A></CODE>
.</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	Pass exactly the same address as the one returned to you when you allocated the memory. If you pass a different address, the results are undefined.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_3.htm#IX_calloc()">calloc()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_2f.htm#IX_free()">free()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_6a.htm#IX_malloc()">malloc()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_36.htm#IX_GeoReAlloc()">GeoReAlloc()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_83.htm_IX_RecentContactsEraseStack()">
 </A>
<H1 CLASS="refHeading">
RecentContactsEraseStack()</H1>
<PRE CLASS="syntax">BooleanRecentContactsEraseStack(
        RecentContactsType 			rcType);</PRE>
<P>
This function erases all log entries of a certain type from the log. It returns zero if there was no error, non-zero otherwise. Pass one of RC_SENT_CALLS, RC_RECEIVED_CALLS, RC_MISSED_CALLS, RC_SENT_FAXES, RC_RECEIVED_FAXES, RC_SENT_SMS, or RC_RECEIVED_SMS. </P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
contlog.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_83.htm_IX_RecentContactsGetCount()">
 </A>
<H1 CLASS="refHeading">
RecentContactsGetCount()</H1>
<PRE CLASS="syntax">word 	RecentContactsGetCount(
        RecentContactsType 			rcType);</PRE>
<P>
This function returns the number of contacts of some type that have been made recently. Pass one of RC_SENT_CALLS, RC_RECEIVED_CALLS, RC_MISSED_CALLS, RC_SENT_FAXES, RC_RECEIVED_FAXES, RC_SENT_SMS, or RC_RECEIVED_SMS. </P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
contlog.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_83.htm_IX_RecentContactsGetEntry()">
 </A>
<H1 CLASS="refHeading">
RecentContactsGetEntry()</H1>
<PRE CLASS="syntax">word 	RecentContactsGetEntry(
        RecentContactsType 			rcType, 
        int 			item, 
        LogEntry 			*buffer);</PRE>
<P>
This function retrieves the entry log for a call. The call is identified by its call type and an index number. The call type is one of RC_SENT_CALLS, RC_RECEIVED_CALLS, RC_MISSED_CALLS, RC_SENT_FAXES, RC_RECEIVED_FAXES, RC_SENT_SMS, or RC_RECEIVED_SMS. The index number should be at least zero and less than the number returned by <CODE>
<A HREF="../../CRef/Routines/R_83.htm#IX_RecentContactsGetCount()">RecentContactsGetCount()</A></CODE>
. The function fills in the passed <CODE>
LogEntry</CODE>
 buffer with the entry's information. If there was an error, the function returns non-zero; otherwise, it returns zero.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
contlog.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_83.htm_IX_RecentContactsGetMissedCallsTotalCount()">
 </A>
<H1 CLASS="refHeading">
RecentContactsGetMissedCallsTotalCount()</H1>
<PRE CLASS="syntax">word	RecentContactsResetMissedCallsTotalCount();</PRE>
<P>
This function returns the number of calls missed since the last time <CODE>
RecentContactsGetMissedCallsTotalCount()</CODE>
 was called.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
contlog.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_83.htm_IX_RecentContactsGetNewCount()">
 </A>
<H1 CLASS="refHeading">
RecentContactsGetNewCount()</H1>
<PRE CLASS="syntax">word RecentContactsGetNewCount(
        RecentContactsType 			rcType);</PRE>
<P>
This function returns the number of contacts logged since the last time <CODE>
<A HREF="../../CRef/Routines/R_83.htm#IX_RecentContactsResetNewCount()">RecentContactsResetNewCount()</A></CODE>
 was called.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
contlog.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_83.htm_IX_RecentContactsResetMissedCallsTotalCount()">
 </A>
<H1 CLASS="refHeading">
RecentContactsResetMissedCallsTotalCount()</H1>
<PRE CLASS="syntax">voidRecentContactsResetMissedCallTotalsCount( );</PRE>
<P>
This function resets the number of missed calls as used by the <CODE>
<A HREF="../../CRef/Routines/R_83.htm#IX_RecentContactsGetMissedCallsTotalCount()">RecentContactsGetMissedCallsTotalCount()</A></CODE>
 function.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
contlog.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_83.htm_IX_RecentContactsResetNewCount()">
 </A>
<H1 CLASS="refHeading">
RecentContactsResetNewCount()</H1>
<PRE CLASS="syntax">voidRecentContactsResetNewCount(
        RecentContactsType 			rcType);</PRE>
<P>
This function resets the number of &quot;new&quot; contacts logged as used by the <CODE>
<A HREF="../../CRef/Routines/R_83.htm#IX_RecentContactsGetNewCount()">RecentContactsGetNewCount()</A></CODE>
 function.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
contlog.goh</STRONG>
 </P>
</DIV>

<DIV>
<A NAME="R_83.htm_IX_RespGetPDAHardwareInfo()">
 </A>
<H1 CLASS="refHeading">
RespGetPDAHardwareInfo()</H1>
<PRE CLASS="syntax">PDAHardwareInfo    RespGetPDAHardwareInfo(void);</PRE>
<P>
This routine gets information about the current PDA hardware, specifically  the type of PDA and whether or not it has a backlight. Use the following bit masks to extract the desired information from the <CODE>PDAHardwareInfo</CODE> bitfield:</P>

<PRE CLASS="syntax">
typedef ByteFlags PDAHardwareInfo;
/* 5 bits unused */
#define PDAHI_BACKLIGHT_AVAILABLE       (0x04)
#define PDAHI_PDA_TYPE                  (0x02 | 0x01)    /* PDAType */
</PRE>

<P>
The <CODE>PDAType</CODE> is enumerated as:
</P>

<PRE CLASS="syntax">
typedef ByteEnum PDAType;
#define PDAT_PC_EMULATOR        0x0
#define PDAT_N9000              0x1
#define PDAT_N9000i             0x2
</PRE>

<P>
This routine is only available on builds 4 or newer of the Nokia 9000i Communicator (see <A HREF = "../../Nokia9000/Versions/Update_1.htm">Versions</A> for more information).
</P>

<P CLASS="refField"><STRONG>
Include:</STRONG>   
respondr.goh
 </P>
</DIV>

<DIV>
<A NAME="R_83.htm_IX_SerialClose()">
 </A>
<H1 CLASS="refHeading">
SerialClose()</H1>
<PRE CLASS="syntax">StreamError SerialClose(
        GeodeHandle 		driver,
        SerialUnit 		unit,
        Boolean 		linger);</PRE>
<P>
Close the stream to a serial port.</P>
</DIV>
<DIV>
<A NAME="R_83.htm_IX_SerialCloseWithoutReset()">
 </A>
<H1 CLASS="refHeading">
SerialCloseWithoutReset()</H1>
<PRE CLASS="syntax">StreamError SerialClose(
        GeodeHandle 		driver,
        SerialUnit 		unit,
        Boolean 		linger);</PRE>
<P>
Close the stream to a serial port, without actually resetting the port.</P>
</DIV>
<DIV>
<A NAME="R_83.htm_IX_SerialFlush()">
 </A>
<H1 CLASS="refHeading">
SerialFlush()</H1>
<PRE CLASS="syntax">StreamError SerialFlush(
        GeodeHandle 		driver,
        SerialUnit		unit,
        StreamRoles 		roles);</PRE>
<P>
Flush all data pending in a serial port's input or output buffer (depending on the value of <CODE>
roles</CODE>
).</P>
</DIV>
<DIV>
<A NAME="R_83.htm_IX_SerialGetError()">
 </A>
<H1 CLASS="refHeading">
SerialGetError()</H1>
<PRE CLASS="syntax">StreamError	 	SerialGetError (
        Handle 		driver,
        SerialUnit		unit,
        StreamRoles 		roles,
        SerialError *		errorCode);</PRE>
<P>
This routine returns error information pertaining to the last call to a serial driver. The <CODE>
SerialError</CODE>
 codes returned may contain serial-driver-specific error codes not defined in the <CODE>
SerialError</CODE>
 enumerated type.</P>
</DIV>
<HR>
<A NAME="R_84.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_84.htm_IX_SerialGetFormat()">
 </A>
<H1 CLASS="refHeading">
SerialGetFormat()</H1>
<PRE CLASS="syntax">StreamError SerialGetFormat(
        GeodeHandle 		driver,
        SerialUnit 		unit,
        SerialFormat *		format,
        SerialMode *		mode,
        SerialBaud *		baud);</PRE>
<P>
Get the format of a stream to a specified serial port.</P>
</DIV>
<DIV>
<A NAME="R_84.htm_IX_SerialGetModem()">
 </A>
<H1 CLASS="refHeading">
SerialGetModem()</H1>
<PRE CLASS="syntax">StreamError SerialGetModem(
        GeodeHandle 		driver,
        SerialUnit		unit,
        SerialModem *		modem);</PRE>
<P>
Read a modem's hardware flow control bits.</P>
</DIV>
<DIV>
<A NAME="R_84.htm_IX_SerialOpen()">
 </A>
<H1 CLASS="refHeading">
SerialOpen()</H1>
<PRE CLASS="syntax">StreamError SerialOpen(
        GeodeHandle 		driver,
        SerialUnit 		unit,
        StreamOpenFlags 		flags,
        word 		inBuffSize,
        word		outBuffSize,
        word 		timeout);</PRE>
<P>
This routine opens a stream to the specified serial port. It is passed the following arguments:</P>
<DL>
<DT>
<CODE>
driver</CODE>
</DT><DD>The <CODE>
GeodeToken</CODE>
 of the serial driver.</DD>
<DT>
<CODE>
unit</CODE>
</DT><DD>The serial port to open.</DD>
<DT>
<CODE>
flags</CODE>
</DT><DD>This specifies whether the call should fail if the port is busy, or wait for a time to see if it will become free.</DD>
<DT>
<CODE>
inBuffSize</CODE>
</DT><DD>The size of the stream buffer used for input from the serial port.</DD>
<DT>
<CODE>
outBuffSize</CODE>
</DT><DD>The size of the stream buffer used for output to the serial port.</DD>
<DT>
<CODE>
timeout</CODE>
</DT><DD>The number of clock ticks to wait for the port to become free. (This argument is ignored if <CODE>
flags</CODE>
 is not STREAM_OPEN_TIMEOUT.)</DD>
</DL>
<P>
If the routine is successful, it returns zero. If it is unsuccessful, it returns a member of the <CODE>
StreamError</CODE>
 enumerated type.</P>
</DIV>
<DIV>
<A NAME="R_84.htm_IX_SerialQuery()">
 </A>
<H1 CLASS="refHeading">
SerialQuery()</H1>
<PRE CLASS="syntax">StreamError SerialQuery(
        GeodeHandle 		driver,
        SerialUnit 		unit,
        StreamRoles role,
        word *		bytesAvailable);</PRE>
<P>
Find out how much space is available in a serial buffer, or how much data is waiting to be read.</P>
</DIV>
<DIV>
<A NAME="R_84.htm_IX_SerialRead()">
 </A>
<H1 CLASS="refHeading">
SerialRead()</H1>
<PRE CLASS="syntax">StreamError SerialRead (
        Handle		driver,
        SerialUnit 		unit,
        StreamBlocker 		blocker,
        word 		buffSize,
        byte *		buffer,
        word *		numBytesRead);</PRE>
<P>
Read data from a serial port and write it to a passed buffer.</P>
</DIV>
<DIV>
<A NAME="R_84.htm_IX_SerialReadByte()">
 </A>
<H1 CLASS="refHeading">
SerialReadByte()</H1>
<PRE CLASS="syntax">StreamError SerialReadByte (
        Handle		driver,
        SerialUnit 		unit,
        StreamBlocker 		blocker,
        byte		*dataByte);</PRE>
<P>
Read a byte of data from a serial port and write it to a passed variable.</P>
</DIV>
<DIV>
<A NAME="R_84.htm_IX_SerialSetError()">
 </A>
<H1 CLASS="refHeading">
SerialSetError()</H1>
<PRE CLASS="syntax">StreamError SerialSetError (
        Handle 		driver,
        SerialUnit 		unit,
        StreamRoles 		roles,
        SerialError 		errorCode);</PRE>
<P>
This routine sets the serial-driver-specific error code for recovery with <CODE>
<A HREF="../../CRef/Routines/R_83.htm#IX_SerialGetError()">SerialGetError()</A></CODE>
.<CODE>
</CODE>
</P>
</DIV>
<DIV>
<A NAME="R_84.htm_IX_SerialSetFlowControl()">
 </A>
<H1 CLASS="refHeading">
SerialSetFlowControl()</H1>
<PRE CLASS="syntax">StreamError 	SerialSetFlowControl (
        Handle 		driver,
        SerialUnit 		unit,
        SerialFlowControl 		flow,
        SerialModem 		modem,
        SerialModemStatus 		status);</PRE>
<P>
This routine enables or disables software flow control. The flow argument has two flags, SFC_HARDWARE and SFC_SOFTWARE.</P>
</DIV>
<DIV>
<A NAME="R_84.htm_IX_SerialSetFormat()">
 </A>
<H1 CLASS="refHeading">
SerialSetFormat()</H1>
<PRE CLASS="syntax">StreamError SerialSetFormat(
        GeodeHandle 		driver,
        SerialUnit 		unit,
        SerialFormat 		format,
        SerialMode		mode,
        SerialBaud 		baud);</PRE>
<P>
Set the format for a stream to a specified serial port.</P>
</DIV>
<DIV>
<A NAME="R_84.htm_IX_SerialSetModem()">
 </A>
<H1 CLASS="refHeading">
SerialSetModem()</H1>
<PRE CLASS="syntax">StreamError SerialSetModem(
        GeodeHandle 		driver,
        SerialUnit		unit,
        SerialModem 		modem);</PRE>
<P>
Set a modem's hardware flow control bits.</P>
</DIV>
<DIV>
<A NAME="R_84.htm_IX_SerialWrite()">
 </A>
<H1 CLASS="refHeading">
SerialWrite()</H1>
<PRE CLASS="syntax">StreamError SerialWrite(
        GeodeHandle 		driver,
        SerialUnit 		unit,
        StreamBlocker 		blocker,
        word 		buffSize,
        const byte *		buffer,
        word *		numBytesWritten);</PRE>
<P>
Write data to a serial port.</P>
</DIV>
<DIV>
<A NAME="R_84.htm_IX_SerialWriteByte()">
 </A>
<H1 CLASS="refHeading">
SerialWriteByte()</H1>
<PRE CLASS="syntax">StreamError SerialWrite(
        GeodeHandle 		driver,
        SerialUnit 		unit,
        StreamBlocker 		blocker,
        word 		buffSize,
        byte		dataByte);</PRE>
<P>
Write one byte of data to a serial port.</P>
</DIV>
<HR>
<A NAME="R_85.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_85.htm_IX_SGC_MACHINE() macro">
 </A>
<H1 CLASS="refHeading">
SGC_MACHINE</H1>
<PRE CLASS="syntax">byte	SGC_MACHINE(<EM>val</EM>);
        dword	<EM>val</EM>;</PRE>
<P>
This macro is used to extract the machine type from a <CODE>
<A HREF="../../CRef/Routines/R_92.htm#IX_SysGetConfig()">SysGetConfig()</A></CODE>
 return value.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
system.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_85.htm_IX_SGC_PROCESSOR() macro">
 </A>
<H1 CLASS="refHeading">
SGC_PROCESSOR</H1>
<PRE CLASS="syntax">byte	SGC_PROCESSOR(<EM>val</EM>);
        dword	<EM>val</EM>;</PRE>
<P>
This macro is used to extract the processor type from a <CODE>
<A HREF="../../CRef/Routines/R_92.htm#IX_SysGetConfig()">SysGetConfig()</A></CODE>
 return value.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
system.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_85.htm_IX_SocketAccept()">
 </A>
<H1 CLASS="refHeading">
SocketAccept()</H1>
<PRE CLASS="syntax">Socket SocketAccept(
        Socket 		s,
        int 		timeout);</PRE>
<P>
To make a socket wait for and accept a connection, call <CODE>
SocketAccept()</CODE>
. The socket must be a listening socket (processed by <CODE>
<A HREF="../../CRef/Routines/R_89.htm#IX_SocketListen()">SocketListen()</A></CODE>
). Because the thread will block until a connection is made or <CODE>
SocketAccept()</CODE>
 times out, programs will normally not call this routine in their main execution thread. Instead, a separate thread handles accepting a connection and receiving data from the connection. </P>
<P>
If there are no connections to accept, <CODE>
SocketAccept()</CODE>
 will set the SE_LISTEN_QUEUE_EMPTY error. </P>
<P>
This routine takes the following arguments:</P>
<DL>
<DT>
<EM>
s</EM>
</DT><DD>A listening socket (processed by <CODE>
<A HREF="../../CRef/Routines/R_89.htm#IX_SocketListen()">SocketListen()</A></CODE>
).</DD>
<DT>
<EM>
timeout</EM>
</DT><DD>Time to wait for success, in 1/60 second ticks, or SOCKET_NO_TIMEOUT to try as long as possible.</DD>
</DL>
<P>
It returns a socket which should be used to send and receive data over the connection. If the return value is zero, an error occured. Call <CODE>
<A HREF="../../CRef/Routines/R_97.htm#IX_ThreadGetError()">ThreadGetError()</A></CODE>
 to find out what the error value was.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_89.htm#IX_SocketListen()">SocketListen()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_87.htm#IX_SocketConnect()">SocketConnect()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_97.htm#IX_ThreadGetError()">ThreadGetError()</A></CODE>.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
socket.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_85.htm_IX_SocketAddLoadOnMsg()">
 </A>
<H1 CLASS="refHeading">
SocketAddLoadOnMsg()</H1>
<PRE CLASS="syntax">SocketError SocketAddLoadOnMsg(
        SocketPort 		p,
        SocketLoadType 		slt,
        word 		disk,
        TCHAR 		*path);</PRE>
<P>
To make the Socket library load a program when receiving packets on a particular port, call <CODE>
SocketAddLoadOnMsg()</CODE>
. The Socket library will write out an entry to the GEOS.INI file in the [socket] category and with key &quot;LoadOnMsg&quot;. The Socket library consults these GEOS.INI file entries when it starts up and will act accordingly when it receives packets.</P>
<P>
This routine takes the following arguments:</P>
<DL>
<DT>
<EM>
p</EM>
</DT><DD>The port to monitor.</DD>
<DT>
<EM>
slt</EM>
</DT><DD>How to load the application--either by <CODE>
<A HREF="../../CRef/Routines/R_9e.htm#IX_UserLoadApplication()">UserLoadApplication()</A></CODE>
 or <CODE>
<A HREF="../../CRef/Routines/R_34.htm#IX_GeodeLoad()">GeodeLoad()</A></CODE>
.</DD>
<DT>
<EM>
disk</EM>
</DT><DD><CODE>
DiskHandle</CODE>
 of application to load. This may be a <CODE>
StandardPath</CODE>
 value.</DD>
<DT>
<EM>
path</EM>
</DT><DD>Buffer holding path of application to load.</DD>
</DL>
<P>
If successful, the routine will return SE_NORMAL (i.e., zero). Otherwise, it will return some other <CODE>
SocketError</CODE>
 value.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_85.htm#IX_SocketAddLoadOnMsgInDomain()">SocketAddLoadOnMsgInDomain()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_8a.htm#IX_SocketRemoveLoadOnMsg()">SocketRemoveLoadOnMsg()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_9e.htm#IX_UserLoadApplication()">UserLoadApplication()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_34.htm#IX_GeodeLoad()">GeodeLoad()</A></CODE>.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
socket.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_85.htm_IX_SocketAddLoadOnMsgInDomain()">
 </A>
<H1 CLASS="refHeading">
SocketAddLoadOnMsgInDomain()</H1>
<PRE CLASS="syntax">SocketError SocketAddLoadOnMsgInDomain(
        SocketPort 		p,
        SocketLoadType 		slt,
        word 		disk,
        TCHAR 		*path,
        TCHAR 		*domain);</PRE>
<P>
To make the Socket library load a program when receiving packets on a particular port within a particular domain, call <CODE>
SocketAddLoadOnMsgInDomain()</CODE>
. The Socket library will write out an entry to the GEOS.INI file in the [socket] category and with key &quot;LoadOnMsg&quot;. The Socket library consults these GEOS.INI file entries when it starts up and will act accordingly when it receives packets.</P>
<P>
This routine takes the following arguments:</P>
<DL>
<DT>
<EM>
p</EM>
</DT><DD>The port to monitor.</DD>
<DT>
<EM>
slt</EM>
</DT><DD>How to load the application--either by <CODE>
<A HREF="../../CRef/Routines/R_9e.htm#IX_UserLoadApplication()">UserLoadApplication()</A></CODE>
 or <CODE>
<A HREF="../../CRef/Routines/R_34.htm#IX_GeodeLoad()">GeodeLoad()</A></CODE>
.</DD>
<DT>
<EM>
disk</EM>
</DT><DD><CODE>
DiskHandle</CODE>
 of application to load. This may be a <CODE>
StandardPath</CODE>
 value.</DD>
<DT>
<EM>
path</EM>
</DT><DD>Buffer holding path of application to load.</DD>
<DT>
<EM>
domain</EM>
</DT><DD>Buffer holding name of the domain to monitor.</DD>
</DL>
<P>
If successful, the routine will return SE_NORMAL (i.e., zero). Otherwise, it will return some other <CODE>
SocketError</CODE>
 value.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_85.htm#IX_SocketAddLoadOnMsg()">SocketAddLoadOnMsg()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_8a.htm#IX_SocketRemoveLoadOnMsgInDomain()">SocketRemoveLoadOnMsgInDomain()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_9e.htm#IX_UserLoadApplication()">UserLoadApplication()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_34.htm#IX_GeodeLoad()">GeodeLoad()</A></CODE>.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
socket.goh</STRONG>
 </P>
</DIV>
<HR>
<A NAME="R_86.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_86.htm_IX_SocketBind()">
 </A>
<H1 CLASS="refHeading">
SocketBind()</H1>
<PRE CLASS="syntax">SocketError SocketBind(
        Socket 		s,
        SocketPort 		p,
        SocketBindFlags 		flags);</PRE>
<P>
Use the <CODE>
SocketBind()</CODE>
 routine to associate a socket with a port number on this side of the connection. </P>
<P>
For any given domain, normally only one socket on the machine may be bound to any port number. If you have used <CODE>
SocketBind()</CODE>
 to bind some other socket to this port, then you may only bind another socket to the port by setting the SBF_REUSE_PORT in the flags argument. If you have used <CODE>
<A HREF="../../CRef/Routines/R_86.htm#IX_SocketBindInDomain()">SocketBindInDomain()</A></CODE>
 to bind some other socket to this port, then you may not use <CODE>
SocketBind()</CODE>
 to bind another socket to the port.</P>
<P>
A given socket may only be bound to one port.</P>
<P>
This routine takes the following arguments:</P>
<DL>
<DT>
<EM>
s</EM>
</DT><DD>The socket to bind.</DD>
<DT>
<EM>
p</EM>
</DT><DD>The port to monitor.</DD>
<DT>
<EM>
flags</EM>
</DT><DD>Set the SBF_REUSE_PORT to bind the socket to the port even if another socket is bound to it. (You may not use this flag with datagram sockets.)</DD>
</DL>
<P>
If successful, the routine will return SE_NORMAL (i.e., zero). Otherwise, it will return some other <CODE>
SocketError</CODE>
 value. Be on the lookout for SE_SOCKET_ALREADY_BOUND, SE_PORT_IN_USE, or SE_BIND_CONFLICT.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_86.htm#IX_SocketBindInDomain()">SocketBindInDomain()</A></CODE>.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
socket.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_86.htm_IX_SocketBindInDomain()">
 </A>
<H1 CLASS="refHeading">
SocketBindInDomain()</H1>
<PRE CLASS="syntax">SocketError SocketBindInDomain(
        Socket 		s,
        SocketPort 		p,
        SocketBindFlags 		flags,
        TCHAR 		*domain);</PRE>
<P>
Use the <CODE>
SocketBindInDomain()</CODE>
 routine to associate a socket with a port number and domain on this side of the connection. </P>
<P>
For any given domain, normally only one socket on the machine may be bound to any port number in any given domain. If you have used <CODE>
SocketBindInDomain()</CODE>
 to bind some other socket to this port and domain, then you may only bind another socket to the port and domain by setting the SBF_REUSE_PORT in the flags argument. If you have used <CODE>
<A HREF="../../CRef/Routines/R_86.htm#IX_SocketBind()">SocketBind()</A></CODE>
 to bind some other socket to this port, then you may not use <CODE>
SocketBindInDomain()</CODE>
 to bind another socket to the port.</P>
<P>
A given socket may only be bound to one port.</P>
<P>
This routine takes the following arguments:</P>
<DL>
<DT>
<EM>
s</EM>
</DT><DD>The socket to bind</DD>
<DT>
<EM>
p</EM>
</DT><DD>The port to monitor</DD>
<DT>
<EM>
flags</EM>
</DT><DD>Set the SBF_REUSE_PORT to bind the socket to the port even if another socket is bound to it.</DD>
<DT>
<EM>
domain</EM>
</DT><DD>The domain to monitor</DD>
</DL>
<P>
If successful, the routine will return SE_NORMAL (i.e., zero). Otherwise, it will return some other <CODE>
SocketError</CODE>
 value. Be on the lookout for SE_SOCKET_ALREADY_BOUND, SE_PORT_IN_USE, or SE_BIND_CONFLICT.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_86.htm#IX_SocketBind()">SocketBind()</A></CODE>.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
socket.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_86.htm_IX_SocketCheckListen()">
 </A>
<H1 CLASS="refHeading">
SocketCheckListen()</H1>
<PRE CLASS="syntax">int SocketCheckListen(
        SocketPort 		p,
        TCHAR 		*domain,
        int 		bufsize);</PRE>
<P>
Use the <CODE>
SocketCheckListen()</CODE>
command on a port to find out the domain for the first connect request on
a listening socket--that is, the first connection request which has not yet
been accepted. You might think of this as a limited form of
&quot;caller ID&quot;--a chance to find out a bit about the incoming
connection before you accept it. If <CODE>SocketCheckListen()</CODE>
returns zero then you can call
<a href="R_97.htm#IX_ThreadGetError()"><CODE>ThreadGetError()</CODE></a>
to get the SocketError value. If it is SE_PORT_NOT_LISTENING, it means
that you have not passed it a port to which a socket is listening.</P>
<P>
This routine takes the following arguments:</P>
<DL>
<DT>
<EM>
p</EM>
</DT><DD>The port to check</DD>
<DT>
<EM>
domain</EM>
</DT><DD>Buffer to hold the domain name</DD>
<DT>
<EM>
bufsize</EM>
</DT><DD>The size of the <EM>
domain</EM>
 buffer</DD>
</DL>
<P>
It returns the length of the domain name. If the return value is zero, there was an error. Look out for SE_PORT_NOT_LISTENING, which signals that there is no socket bound to the port in question which is listening.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_86.htm#IX_SocketBind()">SocketBind()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_86.htm#IX_SocketBindInDomain()">SocketBindInDomain()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_89.htm#IX_SocketListen()">SocketListen()</A></CODE>.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
socket.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_86.htm_IX_SocketCheckReady()">
 </A>
<H1 CLASS="refHeading">
SocketCheckReady()</H1>
<PRE CLASS="syntax">int SocketCheckReady(
        SocketCheckRequest 		*requests,
        int 		numRequests,
        int 		timeout);</PRE>
<P>
To check one or more sockets to see if they have received data, received connection requests, or are ready to write, call <CODE>
SocketCheckReady()</CODE>
. It can check connections for incoming data or just incoming urgent data. </P>
<P>
For programs which need to poll many sockets, <CODE>
SocketCheckReady()</CODE>
 provides a tidy means to do this without spawning a thread for each socket.</P>
<P>
The <CODE>
SocketCheckReady()</CODE>
 routine takes an array of <CODE>
SocketCheckRequest</CODE>
 structures. Each one of these structures contains a socket and a condition. <CODE>
SocketCheckReady()</CODE>
 looks at each <CODE>
SocketCheckRequest</CODE>
 structure in the array and returns the index of the first structure whose socket meets the condition.</P>
<P>
Thus, to determine if a given socket is properly set-up so that you can send data through it, you would pass <CODE>
SocketCheckReady()</CODE>
 a one-element array (represented in pseudo-code):</P>
<PRE>{ mySocket, SC_WRITE, 0 }</PRE>
<P>
To check several sockets to see whether any of them had received any connection requests, pass <CODE>
SocketCheckReady()</CODE>
 an array of the form (represented in pseudo-code):</P>
<PRE>{ socket1, SC_ACCEPT, 0 },
{ socket2, SC_ACCEPT, 0 },
{ socket3, SC_ACCEPT, 0 }</PRE>
<P>
For any socket, you may check for one or more of the following conditions:</P>
<DL>
<DT>
SC_ACCEPT</DT><DD>
If a socket is listening for a connection, this condition indicates that another socket is in fact trying to connect to the listening socket.</DD>
<DT>
SC_READ</DT><DD>If a socket is connected, this condition indicates that a packet of data has come in and is ready to be read.</DD>
<DT>
SC_EXCEPTION</DT><DD>
If a socket is connected, this condition indicates that the socket has figured out that something has gone wrong with its connection.</DD>
<DT>
SC_URGENT</DT><DD>If a socket is connected, this condition indicates that it has received a packet of data that was marked urgent.</DD>
<DT>
SC_WRITE</DT><DD>This condition indicates that data may be sent through the socket.</DD>
</DL>
<P>
If you query a socket about a condition that does not apply to its current state (e.g., ask a non-listening socket if it is ready to accept), then <CODE>
SocketCheckReady()</CODE>
 will return SE_IMPROPER_CONDITION.</P>
<P>
This routine takes the following arguments:</P>
<DL>
<DT>
<EM>
requests</EM>
</DT><DD>The array of <CODE>
SocketCheckRequests</CODE>
 structures, as described above.</DD>
<DT>
<EM>
numRequests</DT><DD>
</EM>
Number of elements in the <EM>
requests</EM>
 array.</DD>
<DT>
<EM>
timeout</EM>
</DT><DD>Time to wait for success, in 1/60 second ticks, or SOCKET_NO_TIMEOUT to try as long as possible.</DD>
</DL>
<P>
The routine returns the index of the first <CODE>
SocketCheckRequest</CODE>
 to meet its conditions.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
socket.goh</STRONG>
 </P>
</DIV>
<HR>
<A NAME="R_87.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_87.htm_IX_SocketClose()">
 </A>
<H1 CLASS="refHeading">
SocketClose()</H1>
<PRE CLASS="syntax">SocketError SocketClose(
        Socket 		s);</PRE>
<P>
The <CODE>
SocketClose()</CODE>
 routine closes a socket and frees it. Use it to close and free a datagram socket. It is the routine to call when responding to a SE_CONNECTION_CLOSED exception. <CODE>
SocketClose()</CODE>
 may be used on a socket in any state, will shut down both outgoing and incoming data, cleans up, and frees the socket.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_87.htm#IX_SocketCloseSend()">SocketCloseSend()</A></CODE>.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
socket.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_87.htm_IX_SocketCloseDomainMedium()">
 </A>
<H1 CLASS="refHeading">
SocketCloseDomainMedium()</H1>
<PRE CLASS="syntax">SocketError 	SocketCloseDomainMedium(
        char 		*domain, 
        MediumAndUnit 		*mau,
        Boolean		force);</PRE>
<P>
This routine &quot;hangs up&quot; the hardware aspect of a socket connection. You may request that it only do so if there are no socket connections using the medium. If you force the medium closed with socket connections using the medium, the connections will receive no notification (they will just get SE_CONNECTION_RESET errors); therefore, you should force the medium closed only in extreme situations.</P>
<P>
This routine takes the following arguments:</P>
<DL>
<DT>
<EM>domain</EM></DT><DD>Pointer to a string holding the domain name.</DD>
<DT>
<EM>mau</EM></DT><DD>Pointer to a <CODE>
MediumAndUnit</CODE>
 structure specifying which medium to &quot;hang up&quot;.</DD>
<DT>
<EM>force</EM></DT><DD>Zero to leave the medium alone if there are active connections using it; non-zero to force the medium closed even with active connections.</DD>
</DL>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
socket.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_87.htm_IX_SocketCloseSend()">
 </A>
<H1 CLASS="refHeading">
SocketCloseSend()</H1>
<PRE CLASS="syntax">SocketError SocketCloseSend(
        Socket 		s)</PRE>
<P>
The <CODE>
SocketCloseSend()</CODE>
 routine only works with connected sockets. (You should always use <CODE>
<A HREF="../../CRef/Routines/R_87.htm#IX_SocketClose()">SocketClose()</A></CODE>
 to close a datagram socket.) It partially shuts down the socket, so that the socket can no longer send data. <CODE>
<A HREF="../../CRef/Routines/R_8a.htm#IX_SocketSend()">SocketSend()</A></CODE>
 will return SE_SOCKET_CLOSED if passed such a partially closed socket. However, you can still receive data via the socket--among other things, this means that you can use <CODE>
<A HREF="../../CRef/Routines/R_89.htm#IX_SocketRecv()">SocketRecv()</A></CODE>
 to check for an SE_CONNECTION_CLOSED exception. <CODE>
SocketCloseSend()</CODE>
 sends an SE_CONNECTION_CLOSED exception packet to the other side of the connection.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
socket.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_87.htm_IX_SocketConnect()">
 </A>
<H1 CLASS="refHeading">
SocketConnect()</H1>
<PRE CLASS="syntax">SocketError SocketConnect(
        Socket 		s,
        SocketAddress 		*addr,
        int 		timeout);</PRE>
<P>
To make a connection, call <CODE>
SocketConnect()</CODE>
. You will pass the socket created via <CODE>
<A HREF="../../CRef/Routines/R_87.htm#IX_SocketCreate()">SocketCreate()</A></CODE>
, the address to connect to, and a timeout value. </P>
<P>
You cannot form a true connection using a datagram socket. However, you can use <CODE>
SocketConnect()</CODE>
 with a datagram socket to specify a default destination address to use when sending packets.</P>
<P>
This routine takes the following arguments:</P>
<DL>
<DT>
<EM>
s</EM>
</DT><DD>The socket making the connection.</DD>
<DT>
<EM>
addr</EM>
</DT><DD>The address to connect to. This must be a primitive address returned by <CODE>
<A HREF="../../CRef/Routines/R_8a.htm#IX_SocketResolve()">SocketResolve()</A></CODE>
.</DD>
<DT>
<EM>
timeout</EM>
</DT><DD>Time to wait for success, in 1/60 second ticks, or SOCKET_NO_TIMEOUT to try as long as possible.</DD>
</DL>
<P>
The <CODE>
SocketConnect()</CODE>
 routine returns a <CODE>
SocketError</CODE>
 value. If the routine returns SE_NORMAL, then the connection was established successfully. If it returns SE_CONNECTION_REFUSED, the remote site wasn't prepared to accept the connection. If it returns SE_CONNECTION_ERROR, the connection didn't go through for some miscellaneous reason. If it returns SE_NON_UNIQUE_CONNECTION, then you're trying to create a connection that is identical to another connection: same source address, source port, destination address, destination port, and delivery type. There would be no way to tell these connections apart. If you try to open the same connection from both sides simultaneously, they may both fail with SE_NON_UNIQUE_CONNECTION.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
socket.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_87.htm_IX_SocketCreate()">
 </A>
<H1 CLASS="refHeading">
SocketCreate()</H1>
<PRE CLASS="syntax">Socket SocketCreate(
        SocketDeliveryType 			delivery);</PRE>
<P>
To create a new socket, call <CODE>
SocketCreate()</CODE>
. You will need to specify the socket's delivery type: SDT_DATAGRAM, SDT_SEQ_PACKET (sequential packets), or SDT_STREAM. If it returns zero, there was an error: call <CODE>
<A HREF="../../CRef/Routines/R_97.htm#IX_ThreadGetError()">ThreadGetError()</A></CODE>
 to get the error value, a <CODE>
SocketError</CODE>
.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
socket.goh</STRONG>
 </P>
</DIV>
<HR>
<A NAME="R_88.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_88.htm_IX_SocketGetAddressController()">
 </A>
<H1 CLASS="refHeading">
SocketGetAddressController()</H1>
<PRE CLASS="syntax">ClassStruct * SocketGetAddressController(
        char 			*domain)</PRE>
<P>
Given a domain name, you can create some UI gadgetry for choosing addresses within that domain. Call <CODE>
SocketGetAddressController()</CODE>
 to get the class of an appropriate controller.</P>
<P>
This routine takes a buffer containing the name of the domain for which to create a controller. It returns a <CODE>
ClassStruct</CODE>
 pointer which may be passed to <CODE>
<A HREF="../../CRef/Routines/R_7a.htm#IX_ObjInstantiate()">ObjInstantiate()</A></CODE>
.</P>
<P>
For API information about address controllers, see XXX XREF Socket chapter XXX.</P>
<P>
If the routine returns zero, there was an error. Call <CODE>
<A HREF="../../CRef/Routines/R_97.htm#IX_ThreadGetError()">ThreadGetError()</A></CODE>
 to find out what the error was (it will be a <CODE>
SocketError</CODE>
 value). Look out for SE_UNKNOWN_DOMAIN.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_88.htm#IX_SocketGetDomains()">SocketGetDomains()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_7a.htm#IX_ObjInstantiate()">ObjInstantiate()</A></CODE>.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
socket.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_88.htm_IX_SocketGetAddressMedium()">
 </A>
<H1 CLASS="refHeading">
SocketGetAddressMedium()</H1>
<PRE CLASS="syntax">SocketError SocketGetAddressMedium(
        SocketAddress 		*sa,
        MediumAndUnit 		*mau);</PRE>
<P>
To find out which port would be used to connect to a given address, call <CODE>
SocketGetAddressMedium()</CODE>
. The socket need not actually be connected. Depending on the medium to be used, you might try to connect to the other site via some other domain or to not make the connection at all.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
socket.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_88.htm_IX_SocketGetAddressSize()">
 </A>
<H1 CLASS="refHeading">
SocketGetAddressSize()</H1>
<PRE CLASS="syntax">int SocketGetAddressSize(
        char 		*domain);</PRE>
<P>
To find out the maximum address data size for a given domain, call <CODE>
SocketGetAddressSize()</CODE>
. This can be helpful when allocating memory large enough to handle a full address.</P>
<P>
This routine returns zero on error. Call ThreadGetError() to find out what the error was--if <CODE>
<A HREF="../../CRef/Routines/R_97.htm#IX_ThreadGetError()">ThreadGetError()</A></CODE>
 returns zero, then there wasn't really an error; this domain just doesn't require an address buffer.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
socket.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_88.htm_IX_SocketGetDomainMedia()">
 </A>
<H1 CLASS="refHeading">
SocketGetDomainMedia()</H1>
<PRE CLASS="syntax">ChunkHandle SocketGetDomainMedia(
        char 		*domain,
        optr 		mediaList);</PRE>
<P>
If you're ever curious to know which sort of hardware ports the user's machine uses to connect up to a given domain, call <CODE>
SocketGetDomainMedia()</CODE>
. This returns a chunk array of <CODE>
MediumType</CODE>
 structures. If you have a choice of domains to make a given connection, you might consider which medium would be used to make the connection.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
socket.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_88.htm_IX_SocketGetDomains()">
 </A>
<H1 CLASS="refHeading">
SocketGetDomains()</H1>
<PRE CLASS="syntax">ChunkHandle SocketGetDomains(
        optr 	domainList);</PRE>
<P>
The <CODE>
SocketGetDomains()</CODE>
 routine takes the optr of a chunk array and fills in said array with elements, each of which contains a string, each string being the name of a supported domain. This chunk array has a standard <CODE>
ChunkArrayHeader</CODE>
 header and variable sized elements. </P>
<P>
If the return value is zero, there was an error. Call <CODE>
<A HREF="../../CRef/Routines/R_97.htm#IX_ThreadGetError()">ThreadGetError()</A></CODE>
 to find out what it was.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
socket.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_88.htm_IX_SocketGetMediumAddress()">
 </A>
<H1 CLASS="refHeading">
SocketGetMediumAddress()</H1>
<PRE CLASS="syntax">SocketError SocketGetMediumAddress( 
        char 		*domain, 
        bye 		*buffer,
        int 		*bufsize, 
        MediumAndUnit 		*mau);</PRE>
<P>
This routine determines the local address of the connection using a particular medium. If another machine were to connect to this machine via that medium, this is the address it would use.</P>
<P>
This routine takes the following arguments:</P>
<DL>
<DT>
<EM>
domain</EM>
 </DT><DD>The domain name (a null-terminated string).</DD>
<DT>
<EM>
buffer</EM>
</DT><DD>Buffer to hold the address information.</DD>
<DT>
<EM>
bufsize</EM>
</DT><DD>Size of buffer, in bytes.</DD>
<DT>
<EM>
mau</EM>
</DT><DD>The medium.</DD>
</DL>
<P>
If the routine returns SE_NORMAL, then the address was computed successfully. The <EM>buffer</EM> buffer will be filled with as much of the address data as fit; the <EM>bufsize</EM> number will have changed to the total size of the address data--if this was larger than the size of <EM>buffer</EM>, then the address was truncated.</P>
</DIV>
<DIV>
<A NAME="R_88.htm_IX_SocketGetPeerName()">
 </A>
<H1 CLASS="refHeading">
SocketGetPeerName()</H1>
<PRE CLASS="syntax">SocketError SocketGetPeerName(
        Socket 		s,
        SocketAddress 		*addr);</PRE>
<P>
If a socket is connected, call <CODE>
SocketGetPeerName()</CODE>
 to get the address of the socket at the other end of the connection.</P>
<P>
This routine takes the following arguments:</P>
<DL>
<DT>
<EM>
s</EM>
</DT><DD>The connected socket to examine.</DD>
<DT>
<EM>
addr</EM>
</DT><DD>Buffer holding hollow <CODE>
SocketAddress</CODE>
 structure. The <CODE>
SA_domain</CODE>
, <CODE>
SA_domainSize</CODE>
, and <CODE>
SA_addressSize</CODE>
 fields should be initialized. The buffer should be large enough to hold a <CODE>
SocketAddress</CODE>
 structure and address data. </DD>
</DL>
<P>
It returns SE_NORMAL (i.e., zero) if there was no error; otherwise it will return some <CODE>
SocketError</CODE>
 value. The addr buffer will be filled in with address information. If either the domain name or address buffer isn't large enough to hold its string, the resulting truncated string will not be null-terminated.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
socket.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_88.htm_IX_SocketGetSocketName()">
 </A>
<H1 CLASS="refHeading">
SocketGetSocketName()</H1>
<PRE CLASS="syntax">SocketError SocketGetSocketName(
        Socket 		s,
        SocketAddress 		*addr);</PRE>
<P>
To find out the address used to represent the socket's own side of the connection, call <CODE>
SocketGetSocketName()</CODE>
.</P>
<P>
This routine takes the following arguments:</P>
<DL>
<DT>
<EM>
s</EM>
</DT><DD>The connected socket to examine.</DD>
<DT>
<EM>
addr</EM>
</DT><DD>Buffer holding hollow <CODE>
SocketAddress</CODE>
 structure. The <CODE>
SA_domain</CODE>
, <CODE>
SA_domainSize</CODE>
, and <CODE>
SA_addressSize</CODE>
 fields should be initialized. The buffer should be large enough to hold a <CODE>
SocketAddress</CODE>
 structure and address data. </DD>
</DL>
<P>
It returns SE_NORMAL (i.e., zero) if there was no error; otherwise it will return some <CODE>
SocketError</CODE>
 value. The addr buffer will be filled in with address information. If either the domain name or address buffer isn't large enough to hold its string, the resulting truncated string will not be null-terminated.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
socket.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_88.htm_IX_SocketGetIntSocketOption()">
 </A>
<H1 CLASS="refHeading">
SocketGetIntSocketOption()</H1>
<PRE CLASS="syntax">int 	SocketGetIntSocketOption(
        Socket		skt,
        SocketOption		opt);</PRE>
<P>
This routine checks one of a socket's options, returning the current setting for that option. The return value's meaning depends upon the passed </P>
<P>
This routine takes the following arguments:</P>
<DL>
<DT>
<EM>skt</EM></DT><DD>The socket to check.</DD>
<DT>
<EM>opt</EM></DT><DD>Which option to check. The following options are available:</DD>
<DT>
</DT><DD>SO_RECV_BUF: the maximum size of the socket's buffer for incoming data. A value of -1 means no limit.</DD>
<DT>
</DT><DD>SO_SEND_BUF: the maximum size of the socket's buffer for outgoing data. A value of -1 means no limit.</DD>
<DT>
</DT><DD>SO_INLINE: Non-zero if urgent data is forced into the same queue as regular data; zero to treat urgent data specially.</DD>
<DT>
</DT><DD>SO_NODELAY: Non-zero if domain driver should send all packets immediately; zero to allow the driver to save up packets to send as larger blocks.</DD>
<DT>
</DT><DD>SO_OWNER: Get the handle of the Socket's owning thread.</DD>
</DIV>
</DL>
<HR>
<A NAME="R_89.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_89.htm_IX_SocketInterrupt()">
 </A>
<H1 CLASS="refHeading">
SocketInterrupt()</H1>
<PRE CLASS="syntax">SocketError SocketInterrupt(
        Socket 		s);</PRE>
<P>
This routine attempts to interrupt a <CODE>
<A HREF="../../CRef/Routines/R_85.htm#IX_SocketAccept()">SocketAccept()</A></CODE>
 or a <CODE>
<A HREF="../../CRef/Routines/R_89.htm#IX_SocketRecv()">SocketRecv()</A></CODE>
 pending on the passed socket <EM>s</EM>.</P>
</DIV>
<DIV>
<A NAME="R_89.htm_IX_SocketInterruptResolve()">
 </A>
<H1 CLASS="refHeading">
SocketInterruptResolve()</H1>
<PRE CLASS="syntax">SocketError SocketInterruptResolve(
        TCHAR 		*domain,
        byte 		*address,
        int  		addrSize);</PRE>
<P>
This routine attempts to interrupt the resolution of the specified address.</P>
<P>
This routine takes the following arguments:</P>
<DL>
<DT>
<EM>
domain</EM>
</DT><DD>The name of the domain.</DD>
<DT>
<EM>
address</EM>
</DT><DD>The address which is being resolved.</DD>
<DT>
<EM>
addrSize</EM>
</DT><DD>The size of the <EM>address</EM> buffer.</DD>
</DL>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	This function is unreliable.  It may not interrupt the desired resolve call,if it executes before the resolve call has begun to be processed.  If may also cause other, parallel resolve in the same domain to be interrupted.</P>
</DIV>
<DIV>
<A NAME="R_89.htm_IX_SocketListen()">
 </A>
<H1 CLASS="refHeading">
SocketListen()</H1>
<PRE CLASS="syntax">SocketError SocketListen(
        Socket 		s,
        int 		qSize);</PRE>
<P>
To listen for incoming sequenced packet or stream connections, call <CODE>
SocketListen()</CODE>
. The socket must be bound to a port before it can listen. You may allow more than one connection through the port-specify the maximum number of connections as an argument to <CODE>
SocketListen()</CODE>
. </P>
<P>
This routine takes the following arguments:</P>
<DL>
<DT>
<EM>
s</EM>
</DT><DD>The <CODE>
Socket</CODE>
 which should listen for incoming connections. The socket should be bound to a port. </DD>
<DT>
<EM>
qSize</EM>
</DT><DD>The number of incoming connections which may be accepted via the socket.</DD>
</DL>
<P>
The <CODE>
SocketListen()</CODE>
 routine causes the passed socket to &quot;listen&quot; for accepting connections. If another socket is already listening at the port, the <CODE>
SocketListen()</CODE>
 routine will return SE_PORT_ALREADY_LISTENING.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_86.htm#IX_SocketBind()">SocketBind()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_85.htm#IX_SocketAccept()">SocketAccept()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_86.htm#IX_SocketCheckReady()">SocketCheckReady()</A></CODE>.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
socket.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_89.htm_IX_SocketOpenDomainMedium()">
 </A>
<H1 CLASS="refHeading">
SocketOpenDomainMedium()</H1>
<PRE CLASS="syntax">SocketError SocketOpenDomainMedium(
        SocketAddress 		*addr,
        int 		timeout);</PRE>
<P>
This routine opens a &quot;raw&quot; connection using the specified medium. Exactly what is meant by a &quot;raw&quot; connection depends upon the domain involved. In the case of TCP, this routine will dial the modem and create a PPP connection to the PPP server--but will not send any TCP packets.</P>
<P>
If there is already a &quot;raw&quot; connection, this routine will return SE_NORMAL, just as if it had just opened the connection. </P>
<P>
If the device's phone is busy, this routine will return SE_MEDIUM_BUSY.</P>
<P>
This routine takes the following arguments:</P>
<DL>
<DT>
addr</DT><DD>The address to connect to.</DD>
<DT>
timeout</DT><DD>How many 1/60 second ticks to wait for a connection. Pass SOCKET_NO_TIMEOUT to wait forever.</DD>
</DL>
<P>
When done with the connection, close it with <CODE>
<A HREF="../../CRef/Routines/R_87.htm#IX_SocketCloseDomainMedium()">SocketCloseDomainMedium()</A></CODE>
.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_87.htm#IX_SocketCloseDomainMedium()">SocketCloseDomainMedium()</A></CODE>.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
socket.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_89.htm_IX_SocketRecv()">
 </A>
<H1 CLASS="refHeading">
SocketRecv()</H1>
<PRE CLASS="syntax">int SocketRecv(
        Socket 		s,
        void 		*buffer,
        int 		bufSize,
        int 		timeout,
        SocketRecvFlags 		flags,
        SocketAddress 		*addr);</PRE>
<P>
The <CODE>
SocketRecv()</CODE>
 routine receives data from the socket. After filling the passed buffer with data, the socket will discard its copy of the received data to make room for the next piece of incoming data.</P>
<P>
To &quot;peek&quot; at the next packet of incoming data, call <CODE>
SocketRecv()</CODE>
 and pass the SRF_PEEK flag. This allows you to get the size of the next packet of incoming data and even to non-destructively look at the contents of that packet. </P>
<P>
When using packet-based delivery type sockets (sequenced packet or datagram delivery sockets), you can only receive whole packets-if you grab data from the socket, but don't grab all the data in the packet, the rest of the data will be lost. Thus, it's a good idea to establish a maximum packet size for sockets using these delivery types.If you're not sure how much room you'll need to receive a packet, call <CODE>
SocketRecv()</CODE>
 with the SRF_PEEK flag-this allows you to &quot;peek&quot; at the incoming data without causing the socket to discard its copy.</P>
<P>
The <CODE>
SocketRecv()</CODE>
 routine takes the following arguments:</P>
<DL>
<DT>
<EM>
s</EM>
</DT><DD>The socket from which to grab the data.</DD>
<DT>
<EM>
buffer</EM>
</DT><DD>Buffer to fill with data. </DD>
<DT>
<EM>
bufSize</EM>
</DT><DD>Size of the data buffer. If this smaller than the amount of data, and the socket delivery type is packet-based, the data that doesn't fit in the buffer will be lost; if the socket is a stream socket, then socket will retain the remaining data.</DD>
<DT>
<EM>
timeout</EM>
</DT><DD>How many 1/60 second ticks to wait for incoming data. Pass SOCKET_NO_TIMEOUT to wait forever.</DD>
<DT>
<EM>
flags</EM>
</DT><DD>This flags field allows you to specify some options. Set the SRF_ADDRESS flag if you want the address of the sending machine in <EM>
addr</EM>
. Set the SRF_URGENT flag to only receive a packet marked urgent. Set the SRF_PEEK flag to &quot;peek&quot; at the incoming packet, leaving it in the socket.</DD>
<DT>
<EM>
addr</EM>
<STRONG>
</DT><DD></STRONG>
If you pass the SRF_ADDRESS_FLAG, then pass an empty <CODE>
SocketAddress</CODE>
 buffer. Make sure the buffer has room for the address data after the <CODE>
SocketAddress</CODE>
 structure. The structure's <CODE>
SA_domain</CODE>
, <CODE>
SA_domainSize</CODE>
, and <CODE>
SA_addressSize</CODE>
 fields should be initialized. If either the domain or address buffer isn't long enough to hold its string, the resulting truncated string will not be null-terminated.</DD>
</DL>
<P>
The <CODE>
SocketRecv()</CODE>
 routine returns the size of the received buffer. If this size is zero, there may be an error in the connection. </P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
socket.goh</STRONG>
 </P>
</DIV>
<HR>
<A NAME="R_8a.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_8a.htm_IX_SocketRemoveLoadOnMsg()">
 </A>
<H1 CLASS="refHeading">
SocketRemoveLoadOnMsg()</H1>
<PRE CLASS="syntax">SocketError SocketRemoveLoadOnMsg(
        SocketPort p);</PRE>
<P>
If you've requested the Socket library to load a program when it senses packets coming to a port, you can undo that request by calling <CODE>
SocketRemoveLoadOnMsg()</CODE>
.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_85.htm#IX_SocketAddLoadOnMsg()">SocketAddLoadOnMsg()</A></CODE>.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
socket.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_8a.htm_IX_SocketRemoveLoadOnMsgInDomain()">
 </A>
<H1 CLASS="refHeading">
SocketRemoveLoadOnMsgInDomain()</H1>
<PRE CLASS="syntax">SocketError SocketRemoveLoadOnMsgInDomain(
        SocketPort 		p,
        TCHAR 		*domain);</PRE>
<P>
If you've requested the Socket library to load a program when it senses packets coming to a port in a given domain, you can undo that request by calling <CODE>
SocketRemoveLoadOnMsgInDomain()</CODE>
.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_85.htm#IX_SocketAddLoadOnMsgInDomain()">SocketAddLoadOnMsgInDomain()</A></CODE>.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
socket.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_8a.htm_IX_SocketResolve()">
 </A>
<H1 CLASS="refHeading">
SocketResolve()</H1>
<PRE CLASS="syntax">int SocketResolve( 
        char 		*domainName,
        byte 		*rawAddr,
        int 		addrSize,
        byte 		*result,
        int 		resultBuffSize );</PRE>
<P>
You cannot use an address with other Socket library routines unless that address is in its most primitive form. This primitive form is created by taking a higher-level form of the address and passing it to the <CODE>
SocketResolve()</CODE>
 routine. You will recall that addresses returned by the address controller will not be in their most primitive form. The primitive form of an address can be volatile: feel free to re-use them if making several connections over a short period of time, but re-resolve the address if it's been a long time since it was last resolved. Note that there can be a large overhead when it comes to resolving addresses.</P>
<P>
This routine takes the following arguments:</P>
<DL>
<DT>
<STRONG>
domainName</DT><DD>
</STRONG>
Buffer containing null-terminated domain name string.</DD>
<DT>
<STRONG>
rawAddr</STRONG>
</DT><DD>Buffer containing the unresolved form of the address. Normally, this will be the buffer at the end of a <CODE>
SACAddress</CODE>
 returned by a SocketAddressControl in response to <CODE>
MSG_SOCKET_ADDRESS_CONTROL_GET_ADDRESSES</CODE>
. </DD>
<DT>
</DT><DD>If you aren't resolving an address from a SocketAddressControl, but in fact need to construct a raw address from scratch, see the documentation for <CODE>
SACAddress</CODE>
.</DD>
<DT>
<STRONG>
addrSize</STRONG>
</DT><DD>Size of the <EM>
rawAddr</EM>
 buffer, normally the <CODE>
SACA_opaqueSize</CODE>
 field from a SACAddress returned by a SocketAddressControl in response to <CODE>
MSG_SOCKET_ADDRESS_CONTROL_GET_ADDRESSES</CODE>
.</DD>
<DT>
<STRONG>
result</STRONG>
</DT><DD>Buffer to hold the resolved address. This will normally be a buffer trailing a <CODE>
SocketAddress</CODE>
 structure.</DD>
<DT>
<STRONG>
resultBufferSize</DT><DD>
</STRONG>
Size of the <EM>
result</EM>
 buffer.</DD>
</DL>
<P>
It returns the size of the resolved address. If it returns zero, there was an error. Call <CODE>
<A HREF="../../CRef/Routines/R_97.htm#IX_ThreadGetError()">ThreadGetError()</A></CODE>
 to find out what the error was. Typical errors to look out for are SE_BUFFER_TOO_SMALL, SE_DESTINATION_UNREACHABLE, and SE_TEMPORARY_ERROR.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
socket.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_8a.htm_IX_SocketSend()">
 </A>
<H1 CLASS="refHeading">
SocketSend()</H1>
<PRE CLASS="syntax">SocketError SocketSend(
        Socket 		s,
        void 		*buffer,
        int 		bufSize,
        SocketSendFlags 		flags,
        SocketAddress 		*addr);</PRE>
<P>
The <CODE>
SocketSend()</CODE>
 routine sends data over a socket. It takes several arguments:</P>
<DL>
<DT>
<EM>
s</EM>
</DT><DD>The socket through which to send the data</DD>
<DT>
<EM>
buffer</EM>
</DT><DD>A buffer containing the data to send</DD>
<DT>
<EM>
bufSize</EM>
</DT><DD>The size of the data buffer.</DD>
<DT>
<EM>
flags</EM>
</DT><DD>Options to use when sending. Set SSF_ADDRESS if you're passing an address in <EM>
addr</EM>
. Set SSF_URGENT to mark the packet urgent.</DD>
<DT>
<EM>
addr</DT><DD>
</EM>
Address to which to send data.</DD>
<DT>
</DT><DD>If the socket is a sequenced packet or stream delivery type socket, then this optional address will be ignored.</DD>
<DT>
</DT><DD>If the socket is a datagram delivery type socket, specify the destination address of the packet here unless the socket has a default destination address as described below.</DD>
<DT>
</DT><DD>Datagram sockets can use the <CODE>
<A HREF="../../CRef/Routines/R_87.htm#IX_SocketConnect()">SocketConnect()</A></CODE>
 routine to specify a default destination address. If they have no default address, then you must specify the destination address for the packet here. If there is a default destination address and you pass this optional address and those addresses do not match, then the Socket library will generate a fatal error.</DD>
</DL>
<P>
Normally, <CODE>
SocketSend()</CODE>
 will return SE_NORMAL. If it detects an error, it may return some other <CODE>
SocketError</CODE>
 value.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
socket.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_8a.htm_IX_SocketSetIntSocketOption()">
 </A>
<H1 CLASS="refHeading">
SocketSetIntSocketOption()</H1>
<PRE CLASS="syntax">void	SocketSetIntSocketOption(
        Socket		skt,
        SocketOption		opt,
        int		newval);</PRE>
<P>
This routine changes the setting for one of a socket's options. </P>
<P>
This routine takes the following arguments:</P>
<DL>
<DT>
<EM>skt</EM></DT><DD>The socket.</DD>
<DT>
<EM>opt</EM></DT><DD>Which option to change. The following options are available:</DD>
<DT>
</DT><DD>SO_RECV_BUF: the maximum size of the socket's buffer for incoming data. A value of -1 means no limit.</DD>
<DT>
</DT><DD>SO_SEND_BUF: the maximum size of the socket's buffer for outgoing data. A value of -1 means no limit.</DD>
<DT>
</DT><DD>SO_INLINE: Non-zero if urgent data is forced into the same queue as regular data; zero to treat urgent data specially.</DD>
<DT>
</DT><DD>SO_NODELAY: Non-zero if domain driver should send all packets immediately; zero to allow the driver to save up packets to send as larger blocks.</DD>
<DT>
</DT><DD>SO_OWNER: Specify a new owning thread for the Socket.</DD>
<DT>
<EM>newval</EM></DT><DD>The new setting for the option. The meaning of this value depends on which option you are changing.</DD>
</DL>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
socket.goh</STRONG>
 </P>
</DIV>
<HR>
<A NAME="R_8b.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_8b.htm_IX_SoundAllocMusic()">
 </A>
<H1 CLASS="refHeading">
SoundAllocMusic()</H1>
<PRE CLASS="syntax">word	SoundAllocMusic( /* Returns a SOUND_ERROR_ value */
        const word 		*song, 
        word 		voices,
        MemHandle		*control );</PRE>
<P>
This routine takes a pointer to a fixed buffer of music and allocates a <CODE>
MemHandle</CODE>
 which may then be passed to <CODE>
<A HREF="../../CRef/Routines/R_8c.htm#IX_SoundPlayMusic()">SoundPlayMusic()</A></CODE>
 to play the music. The handle is returned in the address specified by <EM>
control</EM>
. <CODE>
SoundAllocMusic()</CODE>
 returns a non-zero value if it encounters an error trying to allocate the music block.</P>
<P>
If the music buffer is in a movable resource, you must initialize it using <CODE>
<A HREF="../../CRef/Routines/R_8c.htm#IX_SoundInitMusic()">SoundInitMusic()</A></CODE>
 instead of <CODE>
SoundAllocMusic()</CODE>
. The <EM>
voices</EM>
 argument is the number of voices in the buffer. </P>
</DIV>
<DIV>
<A NAME="R_8b.htm_IX_SoundAllocMusicNote()">
 </A>
<H1 CLASS="refHeading">
SoundAllocMusicNote()</H1>
<PRE CLASS="syntax">word SoundAllocMusicNote( /* Returns a SOUND_ERROR_... value. */
        InstrumentPatch				instrument, 
        word				instTable,
        word 				frequency, 
        word 				volume,
        SoundStreamDeltaTimeType				DeltaType, 
        word 				duration,
        MemHandle				*control);</PRE>
<P>
This routine allocates a <CODE>
MemHandle</CODE>
 which may be passed to <CODE>
<A HREF="../../CRef/Routines/R_8c.htm#IX_SoundPlayMusicNote()">SoundPlayMusicNote()</A></CODE>
. You must provide all information about the note: its frequency, volume, and duration. </P>
<P>
To play the note using a standard instrument, pass the instrument's value in <EM>
instrument</EM>
 and zero in <EM>
instTable</EM>
. To use a custom instrument, <EM>
instTable</EM>
:<EM>
instrument</EM>
 should be a pointer to the instrument. </P>
<P>
Specify the frequency in Hertz or use one of the constants such as MIDDLE_C_b to specify a standard note frequency. Volume ranges from zero to 0xffff--you may wish to use a constant value such as DYNAMIC_FFF if you want help trying to choose a loudness. The note's duration is determined by its delta type, one of SSDTT_MSEC, SSDTT_TICKS, and SSDTT_TEMPO. If you pass SSDTT_MSEC or SSDTT_TICKS, the duration is measured in milliseconds or ticks (each tick is one sixtieth of a second). If you pass SSDTT_TEMPO, you may set the size of your time unit when you call <CODE>
<A HREF="../../CRef/Routines/R_8c.htm#IX_SoundPlayMusicNote()">SoundPlayMusicNote()</A></CODE>
. The <EM>
duration</EM>
 determines how many time units the note should play. If the delta type is SSDTT_TICKS and <EM>
duration</EM>
 is 30, then the note will sound for half a second.</P>
<P>
The handle of the newly allocated note will be stored at the location specified by <EM>
control</EM>
. <CODE>
SoundAllocMusicNote()</CODE>
 returns non-zero if there is an error allocating the note.</P>
</DIV>
<DIV>
<A NAME="R_8b.htm_IX_SoundAllocMusicStream()">
 </A>
<H1 CLASS="refHeading">
SoundAllocMusicStream()</H1>
<PRE CLASS="syntax">word	SoundAllocMusicStream( /* Returns a SOUND_ERROR_... value */
        word 		streamType,
        word 		priority,
        word 		voices,
        word 		tempo,
        MemHandle		*control);</PRE>
<P>
This routine allocates a handle suitable for passing to <CODE>
<A HREF="../../CRef/Routines/R_8d.htm#IX_SoundPlayToMusicStream()">SoundPlayToMusicStream()</A></CODE>
. The handle will be returned at the address specified by control. <CODE>
SoundAllocMusicStream()</CODE>
 returns a non-zero value if there is an error allocating the handle.</P>
<P>
It is passed several arguments. The <CODE>
SoundStreamType</CODE>
 determines how much space to allocate for the stream and will determine how much data can be written to the stream at one time. If you pass SST_ONE_SHOT, it indicates that the stream will not be explicitly destroyed, and that your stream should destroy the stream when the song is done. You must specify how many voices there are in the music buffer. You must also pass a starting <EM>
tempo</EM>
 for the music stream.</P>
</DIV>
<DIV>
<A NAME="R_8b.htm_IX_SoundAllocSampleStream()">
 </A>
<H1 CLASS="refHeading">
SoundAllocSampleStream()</H1>
<PRE CLASS="syntax">word SoundAllocSampleStream( /* Returns a SOUND_ERROR_... value */
        MemHandle		*control);</PRE>
<P>
This routine allocates a sample stream handle. If the returned handle is <EM>
null</EM>
, the library was unavailable (i.e. some other thread has grabbed exclusive access).</P>
</DIV>
<DIV>
<A NAME="R_8b.htm_IX_SoundDisableSampleStream()">
 </A>
<H1 CLASS="refHeading">
SoundDisableSampleStream()</H1>
<PRE CLASS="syntax">void 	SoundDisableSampleStream(
        MemHandle 		mh);</PRE>
<P>
This routine disassociates the DAC player from the passed sample handle. Before you play more sounds using the handle, you will have to call <CODE>
SoundEnableSampleStream() </CODE>
again. </P>
</DIV>
<DIV>
<A NAME="R_8b.htm_IX_SoundEnableSampleStream()">
 </A>
<H1 CLASS="refHeading">
SoundEnableSampleStream()</H1>
<PRE CLASS="syntax">word	SoundEnableSampleStream( /* Returns a SOUND_ERROR_... value */
        MemHandle 		mh,
        SoundPriority		priority,
        word 		rate,
        word 		manufacturerID,
        DACSampleFormat		format);</PRE>
<P>
This routine associates a DAC player with the allocated sample handle. You must pass the sound handle, as returned by <CODE>
<A HREF="../../CRef/Routines/R_8b.htm#IX_SoundAllocSampleStream()">SoundAllocSampleStream()</A></CODE>
. You must also pass certain pieces of information about the sound you will be playing on the DAC device: the <EM>
priority</EM>
 with which to grab the DAC player (e.g. SP_STANDARD), the sampling rate, and the <EM>
format</EM>
 of the sample (as identified by a <EM>
manufacturerID</EM>
 and a <CODE>
DACSampleFormat</CODE>
 value).</P>
</DIV>
<HR>
<A NAME="R_8c.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_8c.htm_IX_SoundFreeMusic()">
 </A>
<H1 CLASS="refHeading">
SoundFreeMusic()</H1>
<PRE CLASS="syntax"><CODE>void</CODE> 	SoundFreeMusic(
        MemHandle 		mh);</PRE>
<P>
This routine frees up a music handle. The music must not be playing; call <CODE>
<A HREF="../../CRef/Routines/R_8d.htm#IX_SoundStopMusic()">SoundStopMusic()</A></CODE>
 if you are not sure. You may not use the music handle after calling this routine on it.</P>
</DIV>
<DIV>
<A NAME="R_8c.htm_IX_SoundFreeMusicNote()">
 </A>
<H1 CLASS="refHeading">
SoundFreeMusicNote()</H1>
<PRE CLASS="syntax">void SoundFreeMusicNote(
        MemHandle 		mh);</PRE>
<P>
This routine frees up the passed note handle. The note must not be playing when you call this routine; call <CODE>
<A HREF="../../CRef/Routines/R_8d.htm#IX_SoundStopMusicNote()">SoundStopMusicNote()</A></CODE>
 if you are not sure. You should not try to use the note's handle after freeing it.</P>
</DIV>
<DIV>
<A NAME="R_8c.htm_IX_SoundFreeMusicStream()">
 </A>
<H1 CLASS="refHeading">
SoundFreeMusicStream()</H1>
<PRE CLASS="syntax"><CODE>void</CODE> SoundFreeMusicStream(
        MemHandle 		mh);</PRE>
<P>
This routine frees up the music stream's token. No music must be playing via the stream; call <CODE>
<A HREF="../../CRef/Routines/R_8d.htm#IX_SoundStopMusicStream()">SoundStopMusicStream()</A></CODE>
 if you are not sure. Do not try to use the stream after calling this routine on it.</P>
</DIV>
<DIV>
<A NAME="R_8c.htm_IX_SoundFreeSampleStream()">
 </A>
<H1 CLASS="refHeading">
SoundFreeSampleStream()</H1>
<PRE CLASS="syntax">void 	SoundFreeSampleStream(
        MemHandle 		mh);</PRE>
<P>
This routine frees the passed sampled sound handle. You must not try to use this handle after calling this routine on it.</P>
</DIV>
<DIV>
<A NAME="R_8c.htm_IX_SoundGetExclusive()">
 </A>
<H1 CLASS="refHeading">
SoundGetExclusive()</H1>
<PRE CLASS="syntax">void	SoundGetExclusive(void);</PRE>
<P>
This routine grabs the exclusive semaphore for the sound library; if another thread has already grabbed the exclusive, this routine will wait until the exclusive is released. Sounds which are playing now will be permitted to finish, but from now on, only the thread calling this routine will be allowed to play new sounds. When done with the sound library exclusive, call <CODE>
<A HREF="../../CRef/Routines/R_8d.htm#IX_SoundReleaseExclusive()">SoundReleaseExclusive()</A></CODE>
.</P>
</DIV>
<DIV>
<A NAME="R_8c.htm_IX_SoundGetExclusiveNB()">
 </A>
<H1 CLASS="refHeading">
SoundGetExclusiveNB()</H1>
<PRE CLASS="syntax">Boolean	SoundGetExclusiveNB(void);</PRE>
<P>
This routine grabs the exclusive semaphore for the sound library, doing so even if some other thread has already grabbed the exclusive. Sounds which are playing now will be permitted to finish, but from now on, only the thread calling this routine will be allowed to play new sounds. This routine will return <EM>
true</EM>
 if another thread already has exclusive access.</P>
<P>
When done with the sound library exclusive, call <CODE>
<A HREF="../../CRef/Routines/R_8d.htm#IX_SoundReleaseExclusive()">SoundReleaseExclusive()</A></CODE>
. </P>
</DIV>
<DIV>
<A NAME="R_8c.htm_IX_SoundInitMusic()">
 </A>
<H1 CLASS="refHeading">
SoundInitMusic()</H1>
<PRE CLASS="syntax">void SoundInitMusic(
        MemHandle 		mh, 
        byte 		voices);</PRE>
<P>
This routine initializes a pre-defined simple music buffer structure. If the music buffer is stored in a fixed block, you can call <CODE>
<A HREF="../../CRef/Routines/R_8b.htm#IX_SoundAllocMusic()">SoundAllocMusic()</A></CODE>
 instead. This allows a music buffer stored in a block referenced by a pointer to be playable using <CODE>
<A HREF="../../CRef/Routines/R_8c.htm#IX_SoundPlayMusic()">SoundPlayMusic()</A></CODE>
.</P>
</DIV>
<DIV>
<A NAME="R_8c.htm_IX_SoundPlayMusic()">
 </A>
<H1 CLASS="refHeading">
SoundPlayMusic()</H1>
<PRE CLASS="syntax">word	SoundPlayMusic( /* Returns SOUND_ERROR_... value */
        MemHandle 		mh, 
        word		priority,
        word 		tempo, 
        EndOfSongFlags		flags);</PRE>
<P>
This routine plays a buffer of music previously initialized by <CODE>
<A HREF="../../CRef/Routines/R_8c.htm#IX_SoundInitMusic()">SoundInitMusic()</A></CODE>
 or allocated by <CODE>
<A HREF="../../CRef/Routines/R_8b.htm#IX_SoundAllocMusic()">SoundAllocMusic()</A></CODE>
. The priority value will determine whether your sound will play if other sounds are already occupying the voices--pass a value such as SP_STANDARD. The <EM>
tempo</EM>
 value will be used to determine the length of a 1/128th note. If your music buffer contained any notes whose lengths were measured by SSDTT_TEMPO delta type, then you should set this value accordingly. The <EM>
flags</EM>
 argument determines whether the music's handle should be automatically freed when the sound is done playing. You may pass either or both of the flags UNLOCK_ON_EOS or DESTROY_ON_EOS.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	sound.h</P>
</DIV>
<DIV>
<A NAME="R_8c.htm_IX_SoundPlayMusicNote()">
 </A>
<H1 CLASS="refHeading">
SoundPlayMusicNote()</H1>
<PRE CLASS="syntax">word 	SoundPlayMusicNote( /* Returns a SOUND_ERROR_... value */
        MemHandle 		mh,				/* handle of note */
        word 		priority, 
        word		tempo,				
        EndOfSongFlags		flags);			</PRE>
<P>
This routine plays a buffer of music previously allocated by <CODE>
<A HREF="../../CRef/Routines/R_8b.htm#IX_SoundAllocMusicNote()">SoundAllocMusicNote()</A></CODE>
--the return value of that function is passed as <EM>
mh</EM>
. The priority value will determine whether your sound will play if other sounds are already occupying the voices--pass a value such as SP_STANDARD. The <EM>
tempo</EM>
 value will be used to determine the length of a 1/128th note. If your note's delta type is SSDTT_TEMPO, then you should set this value accordingly. The <EM>
flags</EM>
 argument determines whether the notes's handle should be automatically freed when the note is done playing. You may pass either or both of the flags UNLOCK_ON_EOS or DESTROY_ON_EOS.</P>
<P>
This routine returns <EM>
true</EM>
 if the library was unavailable (i.e. if some other thread had grabbed the sound exclusive).</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	sound.h</P>
</DIV>
<HR>
<A NAME="R_8d.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_8d.htm_IX_SoundPlayToMusicStream()">
 </A>
<H1 CLASS="refHeading">
SoundPlayToMusicStream()</H1>
<PRE CLASS="syntax">word	SoundPlayToMusicStream( /* Returns a SOUND_ERROR_... value */
        MemHandle 		mh,
        const word		* song,
        word 		size);</PRE>
<P>
This routine plays a music buffer to a stream. Specify which stream to play to by means of the token returned by <CODE>
<A HREF="../../CRef/Routines/R_8b.htm#IX_SoundAllocMusicStream()">SoundAllocMusicStream()</A></CODE>
. To play music to the buffer, pass the size of the buffer you are playing and a pointer to the start of the piece. This piece of buffer must be made up of whole events--it should not start or end in the middle of an event (e.g. you can't specify that you want to play a note but not give its frequency, even if you plan to play another buffer to the stream that might begin with a frequency). </P>
<P>
If you don't know the size of the buffer, it may be all right--any data in the buffer after the GE_END_OF_SONG will be ignored.</P>
</DIV>
<DIV>
<A NAME="R_8d.htm_IX_SoundPlayToMusicStreamNB()">
 </A>
<H1 CLASS="refHeading">
SoundPlayToMusicStreamNB()</H1>
<PRE CLASS="syntax">word	SoundPlayToMusicStreamNB( /* Returns a SOUND_ERROR_... value */
        MemHandle 		mh,
        const word		* song,
        word 		size,
        word		*bytesWritten);</PRE>
<P>
This routine acts as <CODE>
<A HREF="../../CRef/Routines/R_8d.htm#IX_SoundPlayToMusicStream()">SoundPlayToMusicStream()</A></CODE>
, except in the case where the routine would block. If the music stream fills up, <CODE>
<A HREF="../../CRef/Routines/R_8d.htm#IX_SoundPlayToMusicStream()">SoundPlayToMusicStream()</A></CODE>
 blocks, waiting until there is more room in the stream;<CODE>
 SoundPlayToMusicStreamNB()</CODE>
 will instead exit, returning the number of bytes successfully written to the stream.</P>
</DIV>
<DIV>
<A NAME="R_8d.htm_IX_SoundPlayToSampleStream()">
 </A>
<H1 CLASS="refHeading">
SoundPlayToSampleStream()</H1>
<PRE CLASS="syntax">word SoundPlayToSampleStream( /* Returns a SOUND_ERROR_... value */
        MemHandle 				mh,
        word _far				* sample,
        word 				size,
        SampleFormatDescription				* format);</PRE>
<P>
This routine passes sampled sound data to a DAC player. You must pass a sample sound handle to this routine--to acquire such a handle, call <CODE>
<A HREF="../../CRef/Routines/R_8b.htm#IX_SoundAllocSampleStream()">SoundAllocSampleStream()</A></CODE>
. The sample sound handle must be associated with a DAC player--to so associate the handle, call <CODE>
<A HREF="../../CRef/Routines/R_8b.htm#IX_SoundEnableSampleStream()">SoundEnableSampleStream()</A></CODE>
. You must pass a pointer to the <EM>
sample</EM>
 data, along with the <EM>
size</EM>
 of the sample as measured in bytes. You may change the <EM>
format</EM>
 information which will determine how the DAC player handles the data.</P>
</DIV>
<DIV>
<A NAME="R_8d.htm_IX_SoundReallocMusic()">
 </A>
<H1 CLASS="refHeading">
SoundReallocMusic()</H1>
<PRE CLASS="syntax">word 	SoundReallocMusic( /* Returns a SOUND_ERROR_... value */
        MemHandle 		mh,
        word _far 		* song);</PRE>
<P>
This routine allows you to associate a new music buffer with an existing music handle. The new music buffer must not have more voices than was originally requested with <CODE>
<A HREF="../../CRef/Routines/R_8b.htm#IX_SoundAllocMusic()">SoundAllocMusic()</A></CODE>
. Do not call this routine with the handle of a sound that may be playing; call <CODE>
<A HREF="../../CRef/Routines/R_8d.htm#IX_SoundStopMusic()">SoundStopMusic()</A></CODE>
 on the handle if you are not sure. </P>
</DIV>
<DIV>
<A NAME="R_8d.htm_IX_SoundReallocMusicNote()">
 </A>
<H1 CLASS="refHeading">
SoundReallocMusicNote()</H1>
<PRE CLASS="syntax"><CODE>word </CODE>	SoundReallocMusicNote( /* Returns a SOUND_ERROR_... value */
        MemHandle 				mh,
        word 				freq,
        word 				vol,
        SoundStreamDeltaTimeType				timer,
        word 				durat,
        word				instrum,
        word				instTable);</PRE>
<P>
This routine allows you to associate new note values with an existing note handle. Do not call this routine with the handle of a note that may be playing; call <CODE>
<A HREF="../../CRef/Routines/R_8d.htm#IX_SoundStopMusicNote()">SoundStopMusicNote()</A></CODE>
 on the handle if you are not sure. </P>
</DIV>
<DIV>
<A NAME="R_8d.htm_IX_SoundReleaseExclusive()">
 </A>
<H1 CLASS="refHeading">
SoundReleaseExclusive()</H1>
<PRE CLASS="syntax">void	SoundReleaseExclusive(void);</PRE>
<P>
This routine releases the sound library exclusive semaphore. You will not need to call this routine unless your code calls <CODE>
<A HREF="../../CRef/Routines/R_8c.htm#IX_SoundGetExclusive()">SoundGetExclusive()</A></CODE>
 or <CODE>
<A HREF="../../CRef/Routines/R_8c.htm#IX_SoundGetExclusiveNB()">SoundGetExclusiveNB()</A></CODE>
. This routine allows other threads to play sounds. If another thread called <CODE>
<A HREF="../../CRef/Routines/R_8c.htm#IX_SoundGetExclusive()">SoundGetExclusive()</A></CODE>
 while your thread had the exclusive, it will now grab the exclusive.</P>
</DIV>
<DIV>
<A NAME="R_8d.htm_IX_SoundSampleDriverInfo()">
 </A>
<H1 CLASS="refHeading">
SoundSampleDriverInfo()</H1>
<PRE CLASS="syntax">void 	SoundSampleDriverInfo(
        word _far 					*voices,
        SoundDriverCapability _far 					*capability);</PRE>
<P>
This routine determines the machine's ability to play recorded sounds.</P>
</DIV>
<DIV>
<A NAME="R_8d.htm_IX_SoundStopMusic()">
 </A>
<H1 CLASS="refHeading">
SoundStopMusic()</H1>
<PRE CLASS="syntax">word 	SoundStopMusic( /* Returns a SOUND_ERROR_... value */
        MemHandle 		mh); 		/* Handle of music buffer */</PRE>
<P>
This routine stops the playing of a simple music buffer. It returns true if the library was unavailable (i.e. some other thread has grabbed the exclusive).</P>
</DIV>
<DIV>
<A NAME="R_8d.htm_IX_SoundStopMusicNote()">
 </A>
<H1 CLASS="refHeading">
SoundStopMusicNote()</H1>
<PRE CLASS="syntax">word 	SoundStopMusicNote( /* Returns a SOUND_ERROR_... value */
        MemHandle 		mh);</PRE>
<P>
This routine stops a note that is playing. Pass the handle of the note, as was returned by <CODE>
<A HREF="../../CRef/Routines/R_8b.htm#IX_SoundAllocMusicNote()">SoundAllocMusicNote()</A></CODE>
. This routine returns true if the sound library was unavailable (i.e. some other thread has grabbed the exclusive). </P>
</DIV>
<DIV>
<A NAME="R_8d.htm_IX_SoundStopMusicStream()">
 </A>
<H1 CLASS="refHeading">
SoundStopMusicStream()</H1>
<PRE CLASS="syntax">word 	SoundStopMusicStream( /* Returns a SOUND_ERROR_... value */
        MemHandle 		mh);</PRE>
<P>
This routine stops any music being played to the stream. All sounds are flushed from the stream. It takes one argument, the token of the sound stream, as returned by <CODE>
<A HREF="../../CRef/Routines/R_8b.htm#IX_SoundAllocMusicStream()">SoundAllocMusicStream()</A></CODE>
.</P>
</DIV>
<DIV>
<A NAME="R_8d.htm_IX_SoundSynthDriverInfo()">
 </A>
<H1 CLASS="refHeading">
SoundSynthDriverInfo()</H1>
<PRE CLASS="syntax">void 	SoundSynthDriverInfo(
        word _far 					*voices,
        SupportedEnvelopeFormat _far 					*format,
        SoundDriverCapability  _far 					*capability)</PRE>
<P>
This routine describes the machine's music playing ability.</P>
</DIV>
<HR>
<A NAME="R_8e.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_8e.htm_IX_SpeedDialGetNumber()">
 </A>
<H1 CLASS="refHeading">
SpeedDialGetNumber()</H1>
<PRE CLASS="syntax">int 	SpeedDialGetNumber(
        int		slot,
        TCHAR		*buf);</PRE>
<P>
This function gets the phone number associated with a Speed Dial number. The function fills in the passed <EM>
buf</EM>
 string with the phone number. If there is no such Speed Dial number, the function returns -1.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
contdb.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_8e.htm_IX_SpeedDialGetRecord()">
 </A>
<H1 CLASS="refHeading">
SpeedDialGetRecord()</H1>
<PRE CLASS="syntax">int 	SpeedDialGetRecord(
        int		slot,
        RecordID 		*rid,
        FieldID		*fid);</PRE>
<P>
This function returns the Contact and field corresponding to the passed Speed Dial number. If there is no such Speed Dial number, the function returns -1. This function takes the following arguments:</P>
<DL>
<DT>
<EM>slot</EM></DT><DD>The Speed Dial number.</DD>
<DT>
<EM>rid</EM> </DT><DD>Pointer to a <CODE>
RecordID</CODE>
 buffer. The function will fill this in with the <CODE>
RecordID</CODE>
 of the Contact record.</DD>
<DT>
<EM>fid</EM> </DT><DD>Pointer to a <CODE>
FieldID</CODE>
 buffer. The function will fill this buffer in with the <CODE>
FieldID</CODE>
 of the contact's field with the selected phone number.</DD>
</DL>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
contdb.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_8e.htm_IX_SpeedDialGetSlot()">
 </A>
<H1 CLASS="refHeading">
SpeedDialGetSlot()</H1>
<PRE CLASS="syntax">int 	SpeedDialGetSlot(
        RecordID 		rid,
        FieldID		fid);</PRE>
<P>
This function gets the Speed Dial number for the Contact phone number represented by the passed <CODE>
RecordID</CODE>
 and <CODE>
FieldID</CODE>
 numbers. If there is no such Speed Dial number, the function returns -1.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
contdb.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_8e.htm_IX_SpeedDialSetRecord()">
 </A>
<H1 CLASS="refHeading">
SpeedDialSetRecord()</H1>
<PRE CLASS="syntax">int 	SpeedDialSetSlot(
        int 		slot,
        RecordID 		rid,
        FieldID		fid);</PRE>
<P>
This function sets the Speed Dial number for the Contact phone number represented by the passed <CODE>
RecordID</CODE>
 and <CODE>
FieldID</CODE>
 numbers. If that Speed Dial slot was not previously empty, the function returns -1.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
contdb.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_8e.htm_IX_SpoolConvertPaperSize()">
 </A>
<H1 CLASS="refHeading">
SpoolConvertPaperSize()</H1>
<PRE CLASS="syntax">word 	SpoolConvertPaperSize(
        word		width,			/* width of paper */
        word		height,			/* height of paper */
        PageType 		pageType);			/* type of page */</PRE>
<P>
This routine converts a width and height into a page size number.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
spool.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_8e.htm_IX_SpollCreatePaperSize()">
 </A>
<H1 CLASS="refHeading">
SpoolCreatePaperSize()</H1>
<PRE CLASS="syntax">word	SpoolCreatePaperSize( /* Returns zero if failed */
        char	*paperSizeString,		/* descriptive name MAX_PAPER_STRING_LENGTH */
        word	width,		/* width of paper */
        word	height,		/* length of paper */
        PageLayout laytout,			/* page layout */
        PageType pageType);			/* page type */</PRE>
<P>
This routine defines and stores a new paper size for later use by the user. If successful, it will return a number representing the new paper size, a value between 128 and 255; if not successful, it will return zero.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
spool.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_8e.htm_IX_SpoolCreatePrinter()">
 </A>
<H1 CLASS="refHeading">
SpoolCreatePrinter()</H1>
<PRE CLASS="syntax">word	SpoolCreatePrinter( 	/* Returns printer number, or -1 if
                  there was an error */</PRE>
<PRE CLASS="syntax">        char 		*printerName,				/* name of printer */
        PrinterDriverType 		type); 				/* device type */</PRE>
<P>
Adds the printer to the list of currently installed printers and returns the new printer number. This routine is normally called from within the Preferences manager. If the routine returns 0xffff, then the printer already exists and thus could not be created.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
spool.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_8e.htm_IX_SpoolDelayJob()">
 </A>
<H1 CLASS="refHeading">
SpoolDelayJob()</H1>
<PRE CLASS="syntax">SpoolOpStatus 	SpoolDelayJob(
        word 	JobID);</PRE>
<P>
This routine moves a print job to the end of the print queue.</P>
</DIV>
<DIV>
<A NAME="R_8e.htm_IX_SpoolDeletePaperSize()">
 </A>
<H1 CLASS="refHeading">
SpoolDeletePaperSize()</H1>
<PRE CLASS="syntax">Boolean 	SpoolDeletePaperSize(
        word 	paperSizeNum,		/* size number to delete */
        PageType pageType);			/* page type */</PRE>
<P>
This routine deletes a user-defined paper size. It will return <EM>
true</EM>
 (i.e., non-zero) if there was an error.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
spool.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_8e.htm_IX_SpoolDeletePrinter()">
 </A>
<H1 CLASS="refHeading">
SpoolDeletePrinter()</H1>
<PRE CLASS="syntax">void 	SpoolDeletePrinter(
        int 	prtrNum);		/* printer number to delete */</PRE>
<P>
Deletes the requested printer from the system.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
spool.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_8e.htm_IX_SpoolDelJob()">
 </A>
<H1 CLASS="refHeading">
SpoolDelJob()</H1>
<PRE CLASS="syntax">SpoolOpStatus 	SpoolDelJob(
        word jobID);</PRE>
<P>
This routine deletes a printer job.</P>
</DIV>
<DIV>
<A NAME="R_8e.htm_IX_SpoolGetDefaultPageSizeInfo()">
 </A>
<H1 CLASS="refHeading">
SpoolGetDefaultPageSizeInfo()</H1>
<PRE CLASS="syntax">void	SpoolGetDefaultPageSizeInfo(
        PageSizeReport		*psr);</PRE>
<P>
This routine gets the dimensions of the system default page size.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
spool.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_8e.htm_IX_SpoolGetDefaultPrinter()">
 </A>
<H1 CLASS="refHeading">
SpoolGetDefaultPrinter()</H1>
<PRE CLASS="syntax">int 	SpoolGetDefaultPrinter(); /* Returns printer number */</PRE>
<P>
Returns the system-default printer, which is used (for example) by the <CODE>
PrintControlClass</CODE>
 as the default printer to print to.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
spool.goh</STRONG>
 </P>
</DIV>
<HR>
<A NAME="R_8f.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_8f.htm_IX_SpoolGetNumPaperSizes()">
 </A>
<A NAME="R_8f.htm_IX_NumPaperSizesInfo">
 </A>
<A NAME="R_8f.htm_IX_NPSI_&ldots;">
 </A>
<H1 CLASS="refHeading">
SpoolGetNumPaperSizes()</H1>
<PRE CLASS="syntax">void	SpoolGetNumPaperSizes(
        NumPaperSizesInfo		*sizesInfo, 
        PageType 		type);				</PRE>
<P>
Use this routine to find the number of paper sizes, both pre-defined and user-defined, that should appear in a paper size list. The number of paper sizes, along with the index of the default paper size will be returned in a Num</P>
<P CLASS="refField"><STRONG>
Structures:</STRONG>	</P>
<PRE CLASS="syntax">        typedef struct {
                word    NPSI_numSizes;
                word    NPSI_defaultSize;
        } NumPaperSizesInfo;</PRE>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
spool.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_8f.htm_IX_SpoolGetNumPrinters()">
 </A>
<H1 CLASS="refHeading">
SpoolGetNumPrinters()</H1>
<PRE CLASS="syntax">word	SpoolGetNumPrinters(
        PrinterDriverType		type,				   /* driver type */
        byte		localOnlyFlag); /* non-zero if only 
								* locally-defined printers should
								* be counted. */</PRE>
<P>
This routine returns the number of installed printers with the given type.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
spool.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_8f.htm_IX_SpoolGetPaperSize()">
 </A>
<A NAME="R_8f.htm_IX_PaperSizeInfo">
 </A>
<A NAME="R_8f.htm_IX_PSI_&ldots;">
 </A>
<H1 CLASS="refHeading">
SpoolGetPaperSize()</H1>
<PRE CLASS="syntax">void 	SpoolGetPaperSize(
        PaperSizeInfo		sizeInfo, 			/* This must be between 0 and the return 
					 	 * value of SpoolGetNumPaperSizes() */</PRE>
<PRE CLASS="syntax">        word		paperSizeNum,	 		/* a paper size number between
								0 and SpoolGetNumPaperSizes() */</PRE>
<PRE CLASS="syntax">        PageType 		*pageType);			/* page type*/</PRE>
<P>
Use this routine to determine the dimensions of a paper size.</P>
<P CLASS="refField"><STRONG>
Structures:</STRONG>	</P>
<PRE CLASS="syntax">        typedef struct {
            word        PSI_width;          /* width, in points */
            word        PSI_height;         /* height, in points */
            PageLayout  PSI_defaultLayout;
        } PaperSizeInfo;</PRE>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
spool.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_8f.htm_IX_SpoolGetPaperSizeOrder()">
 </A>
<A NAME="R_8f.htm_IX_PSOI_&ldots;">
 </A>
<A NAME="R_8f.htm_IX_PaperSizeOrderInfo">
 </A>
<H1 CLASS="refHeading">
SpoolGetPaperSizeOrder()</H1>
<PRE CLASS="syntax"><CODE>void</CODE>	SpoolGetPaperSizeOrder( 
        byte 		*order, 			/* buffer of size MAX_PAPER_SIZES */
						/* On return, this buffer will be 
						 * filled with the page size numbers
						 * arranged in the order 
						 * corresponding to their display */</PRE>
<PRE CLASS="syntax">        byte 		*userSizes,		 	/* buffer of size MAX_PAPER_SIZES */
						/* On return, will hold ordered 
						 * array of user paper sizes. */</PRE>
<PRE CLASS="syntax">        PaperSizeOrderInfo		*numBuf,			/* empty PaperSizeOrderInfo struct */</PRE>
<PRE CLASS="syntax">        PageType                    pageType);  /* What sort of paper we're interested in */</PRE>
<P>
This routine retrieves the paper size order array.</P>
<P CLASS="refField"><STRONG>
Structures:</STRONG>	</P>
<PRE CLASS="syntax">        typedef struct {
            word    PSOI_numOrdered;    /* number of ordered sizes */
            word    PSOI_numUnused;     /* number of unused sizes */
        } PaperSizeOrderInfo;</PRE>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
spool.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_8f.htm_IX_SpoolGetPaperString()">
 </A>
<H1 CLASS="refHeading">
SpoolGetPaperString()</H1>
<PRE CLASS="syntax">word	SpoolGetPaperString( /* true if error*/
        char	   *stringBuf,		/* empty buffer MAX_PAPER_STRING_LENGTH */
        word	   paperSizeNum,		/* returned name string */
        PageType	  prtrNum);		/* printer number */</PRE>
<P>
Use this routine to determine the string to be displayed for a specific paper size. Upon return, <CODE>
stringBuf</CODE>
 will have been filled with a null-terminated string describing the paper. The routine's return value is the length of the paper string, not including the null terminator.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
spool.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_8f.htm_IX_SpoolGetPrinterString()">
 </A>
<H1 CLASS="refHeading">
SpoolGetPrinterString()</H1>
<PRE CLASS="syntax">Boolean	SpoolGetPrinterString( /* Returns true if error */
        PrinterStringInfo	   *retInfo,					/* pass empty structure */
        word	  	printerNum);				/* printer number */</PRE>
<P>
This routine fills a buffer with the requested null-terminated printer name string. If the printer could not be found, the return value will be <CODE>
true</CODE>
 (set for error).</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
spool.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_8f.htm_IX_SpoolHurryJob()">
 </A>
<H1 CLASS="refHeading">
SpoolHurryJob()</H1>
<PRE CLASS="syntax">SpoolOpStatus 	SpoolHurryJob(
        word 	JobID);</PRE>
<P>
This routine moves a print job to the head of the print queue.</P>
</DIV>
<DIV>
<A NAME="R_8f.htm_IX_SpoolInfoParams">
 </A>
<A NAME="R_8f.htm_IX_SIP_&ldots;">
 </A>
<A NAME="R_8f.htm_IX_SpoolInfoQueueParams">
 </A>
<A NAME="R_8f.htm_IX_SIQP_&ldots;">
 </A>
<A NAME="R_8f.htm_IX_SpoolInfoJobParams">
 </A>
<A NAME="R_8f.htm_IX_SIJP_&ldots;">
 </A>
<A NAME="R_8f.htm_IX_JobStatus">
 </A>
<A NAME="R_8f.htm_IX_JS_&ldots;">
 </A>
<H1 CLASS="refHeading">
SpoolInfo()</H1>
<PRE CLASS="syntax">SpoolOpStatus 	SpoolInfo(
        SpoolInfoType 		infoType,
        SpoolInfoParams 		*params);</PRE>
<P>
This routine returns various types of information about the print queue's status. You may request information about the queue or about any job on the queue.</P>
<P CLASS="refField"><STRONG>
Structures:</STRONG>	</P>
<PRE CLASS="syntax">        typedef enum /* word */ {
            SIT_JOB_INFO    = 0,
            SIT_QUEUE_INFO  = 2
        } SpoolInfoType;</PRE>
<P>
The passed <CODE>
SpoolInfoType</CODE>
 specifies whether you seek information about the print queue or a single job on the queue.</P>
<PRE CLASS="syntax">        typedef union {
            SpoolInfoQueueParams    SIP_queueParams;
            SpoolInfoJobParams      SIP_jobParams;
        } SpoolInfoParams;</PRE>
<P>
The type of parameters used depend on the passed <CODE>
SpoolInfoType</CODE>
.</P>
<PRE CLASS="syntax">        typedef struct {
            Boolean 			SIQP_activityQuery;
            PrintPortInfo 			*SIQP_portInfo;
            MemHandle 			SIQP_retBlock;
            word 			SIQP_retNumJobs;
        } SpoolInfoQueueParams;</PRE>
<P>
This structure contains information about the print queue and the <CODE>
SIQP_retBlock</CODE>
 field points to a block of <CODE>
JobStatus</CODE>
 structures.</P>
<PRE CLASS="syntax">        typedef struct {
            word        SIJP_jobID;
            MemHandle   SIJP_retBlock;
        } SpoolInfoJobParams;</PRE>
<P>
This structure is used to pass the ID of the job to describe. The passed block will hold la <CODE>
JobStatus</CODE>
 on return.</P>
<PRE CLASS="syntax">        typedef struct {
            char JS_fname[13]; /* std DOS (8.3) spool filename */
            char JS_parent[FILE_LONGNAME_LENGTH+1]; /* parent app's name */
            char JS_documentName[FILE_LONGNAME_LENGTH+1]; /* document name */
            word JS_numPages;                   /* # pages in document */
            SpoolTimeStruct JS_time;            /* time spooled */
            byte JS_printing;                   /* TRUE/FALSE if we are printing */
        } JobStatus;</PRE>
<P>
Each <CODE>
JobStatus</CODE>
 structure describes a single print job.</P>
</DIV>
<HR>
<A NAME="R_90.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_90.htm_IX_SpoolModifyPriority()">
 </A>
<H1 CLASS="refHeading">
SpoolModifyPriority()</H1>
<PRE CLASS="syntax">SpoolOpStatus 	SpoolModifyPriority(
        word 		jobID,
        ThreadPriority 		priority);</PRE>
<P>
Use this routine to modify the priority of the thread that processes a print job's print queue.</P>
</DIV>
<DIV>
<A NAME="R_90.htm_IX_SpoolSetDefaultPageSizeInfo()">
 </A>
<H1 CLASS="refHeading">
SpoolSetDefaultPageSizeInfo()</H1>
<PRE CLASS="syntax">void	SpoolSetDefaultPageSizeInfo(
        PageSizeReport		*psr);</PRE>
<P>
Set the dimensions of the default system page.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
spool.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_90.htm_IX_SpoolSetDefaultPrinter()">
 </A>
<H1 CLASS="refHeading">
SpoolSetDefaultPrinter()</H1>
<PRE CLASS="syntax">void 	SpoolSetDefaultPrinter(
        int prtrNum);		/* printer number */</PRE>
<P>
Sets the system-default printer, used (for example) by <CODE>
PrintControlClass</CODE>
 as the default printer. This routine is normally called from within the Preferences manager.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
spool.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_90.htm_IX_SpoolSetDocSize()">
 </A>
<H1 CLASS="refHeading">
SpoolSetDocSize()</H1>
<PRE CLASS="syntax">void 	SpoolSetDocSize(
        Boolean 		open;			/* false if document is closed */
        PageSizeInfo 		* psr);			/* NULL if document is closed */</PRE>
<P>
This routine tells the application's PageSizeControl object the document's size.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
spool.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_90.htm_IX_SpoolSetPaperSizeOrder()">
 </A>
<H1 CLASS="refHeading">
SpoolSetPaperSizeOrder()</H1>
<PRE CLASS="syntax">void 	SpoolSetPaperSizeOrder(
        byte	*orderArray, 		/* Array of paper siaes. Each element is 
				 * a byte signifying:
				 * 0-127  : a pre-defined paper size, or
				 * 128-255: a user-defined paper size. */</PRE>
<PRE CLASS="syntax">        word 	number, 		/* number of entries in array */
        PageType pageType);			/* page type (paper, envelope, label) */</PRE>
<P>
This routine resets the order in which paper sizes are displayed to the user.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
spool.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_90.htm_IX_SpoolVerifyPrinterPort()">
 </A>
<H1 CLASS="refHeading">
SpoolVerifyPrinterPort()</H1>
<PRE CLASS="syntax">SpoolOpStatus SpoolVerifyPrinterPort(
        PrintPortInfo *portInfo);</PRE>
<P>
Use this routine to check for the existence of a printer port</P>
</DIV>
<DIV>
<A NAME="R_90.htm_IX_SpreadsheetInitFile()">
 </A>
<A NAME="R_90.htm_IX_SpreadsheetInitFileData">
 </A>
<A NAME="R_90.htm_IX_SIFD_&ldots;">
 </A>
<A NAME="R_90.htm_IX_SpreadsheetDrawFlags">
 </A>
<A NAME="R_90.htm_IX_SDF_DRAW_&ldots;">
 </A>
<H1 CLASS="refHeading">
SpreadsheetInitFile()</H1>
<PRE CLASS="syntax">VMBlockHandle SpreadsheetInitFile(
        const SpreadsheetInitFileData					* ifd);</PRE>
<P>
This routine initializes a VM file for use by the spreadsheet object. It allocates a spreadsheet map block in the file and initializes this block. The routine returns the map block's handle; applications will need to remember this handle. It does not change any existing blocks in the VM file.</P>
<P>
The <EM>
ifd</EM>
 parameter is pointer to a <CODE>
SpreadsheetInitFileData</CODE>
 structure containing the file handle and the number of rows and columns to allocate.</P>
<P CLASS="refField"><STRONG>
Structures:</STRONG>	The <STRONG CLASS="fileName">
SpreadsheetInitFileData</STRONG>
 structure is defined as follows:</P>
<PRE>typedef struct {
	word				SIFD_file;
	word				SIFD_numRows;
	word 				SIFD_numCols;
	SpreadsheetDrawFlags				SIFD_drawFlags;
} SpreadsheetInitFileData;</PRE>
<PRE>/* SpreadsheetDrawFlags:
 * SDF_DRAW_GRAPHICS
 * SDF_DRAW_NOTE_BUTTON
 * SDF_DRAW_HEADER_FOOTER_BUTTON
 * SDF_DRAW_GRID				*/</PRE>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
ssheet.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_90.htm_IX_StreamClose()">
 </A>
<H1 CLASS="refHeading">
StreamClose()</H1>
<PRE CLASS="syntax">StreamError StreamClose (
        GeodeHandle 		driver,
        StreamToken 		stream,
        Boolean 		linger);</PRE>
<P>
This routine shuts down a stream. It is passed the following arguments:</P>
<DL>
<DT>
<CODE>
driver</CODE>
</DT><DD>The <CODE>
GeodeToken</CODE>
 of the stream driver.</DD>
<DT>
<CODE>
stream</CODE>
</DT><DD>The <CODE>
StreamToken</CODE>
 of the stream.</DD>
<DT>
<CODE>
linger</CODE>
</DT><DD>Set <EM>
true</EM>
 (i.e., non-zero) if the data currently in the stream should be kept until it's read; set <EM>
false</EM>
 to flush the data immediately.</DD>
</DL>
<P>
If the routine is successful, it returns zero. If it is unsuccessful, it returns a member of the <CODE>
StreamError</CODE>
 enumerated type.</P>
</DIV>
<DIV>
<A NAME="R_90.htm_IX_StreamFlush()">
 </A>
<H1 CLASS="refHeading">
StreamFlush()</H1>
<PRE CLASS="syntax">StreamError StreamFlush (
        GeodeHandle 		driver,
        StreamToken 		stream);</PRE>
<P>
This routine flushes all the data pending in a stream. It is passed the following arguments:</P>
<DL>
<DT>
<CODE>
driver</CODE>
</DT><DD>The <CODE>
GeodeToken</CODE>
 of the stream driver.</DD>
<DT>
<CODE>
stream</CODE>
</DT><DD>The <CODE>
StreamToken</CODE>
 of the stream.</DD>
</DL>
<P>
If the routine is successful, it returns zero. If it is unsuccessful, it returns a member of the <CODE>
StreamError</CODE>
 enumerated type.</P>
</DIV>
<DIV>
<A NAME="R_90.htm_IX_StreamGetError()">
 </A>
<H1 CLASS="refHeading">
StreamGetError()</H1>
<PRE CLASS="syntax">StreamError	 	StreamGetError (
        Handle 		driver,
        StreamToken 		stream,
        StreamRoles 		roles,
        word *		errorCode);</PRE>
<P>
This routine returns any driver-specific error codes set by the last call to a stream routine. It takes the following arguments:</P>
<DL>
<DT>
<CODE>
driver</CODE>
</DT><DD>The <CODE>
GeodeToken</CODE>
 of the stream driver.</DD>
<DT>
<CODE>
stream</CODE>
</DT><DD>The <CODE>
StreamToken</CODE>
 of the stream.</DD>
<DT>
<CODE>
role</CODE>
</DT><DD>If this is STREAM_ROLES_WRITER, the routine will return the last error from a write operation. If it is STREAM_ROLES_READER, it will return the last error from a read operation.</DD>
<DT>
<CODE>
errorCode</CODE>
</DT><DD>A pointer to a word-sized variable. The device's error code is written to this variable.</DD>
</DL>
<P>
If the routine is successful, it returns zero and writes the device's last error code into the <CODE>
errorCode</CODE>
 variable. If it is unsuccessful, it returns a member of the <CODE>
StreamError</CODE>
 enumerated type.</P>
</DIV>
<HR>
<A NAME="R_91.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_91.htm_IX_StreamOpen()">
 </A>
<H1 CLASS="refHeading">
StreamOpen()</H1>
<PRE CLASS="syntax">StreamError	 StreamOpen (
        GeodeHandle 		driver,
        word 		buffSize,
        GeodeHandle		owner,
        HeapFlags 		heapFlags,
        StreamToken *		stream);</PRE>
<P>
This routine opens a stream. It is passed the following:</P>
<DL>
<DT>
<CODE>
driver</CODE>
</DT><DD>The <CODE>
GeodeToken</CODE>
 of the stream driver.</DD>
<DT>
<CODE>
buffSize</CODE>
</DT><DD>The size of the stream buffer, in bytes.</DD>
<DT>
<CODE>
owner</CODE>
</DT><DD>The geode which will own the stream.</DD>
<DT>
<CODE>
heapFlags</CODE>
</DT><DD>The flags for the creation of the buffer block.</DD>
<DT>
<CODE>
*stream</CODE>
</DT><DD>The stream token will be written here.</DD>
</DL>
<P>
If <CODE>
StreamOpen()</CODE>
 is successful, it returns zero and writes the stream's token to <CODE>
*stream</CODE>
. If it is unsuccessful, it returns a member of the <CODE>
StreamError</CODE>
 enumerated type.</P>
</DIV>
<DIV>
<A NAME="R_91.htm_IX_StreamQuery()">
 </A>
<H1 CLASS="refHeading">
StreamQuery()</H1>
<PRE CLASS="syntax">StreamError StreamQuery (
        GeodeHandle 		driver,
        StreamToken 		stream,
        StreamRoles 		role,
        word *		bytesAvailable);</PRE>
<P>
This routine finds out either how much free space is available in a stream's buffer, or how much data is waiting to be read. It is passed the following arguments:</P>
<DL>
<DT>
<CODE>
driver</CODE>
</DT><DD>The <CODE>
GeodeToken</CODE>
 of the stream driver.</DD>
<DT>
<CODE>
stream</CODE>
</DT><DD>The <CODE>
StreamToken</CODE>
 of the stream.</DD>
<DT>
<CODE>
role</CODE>
</DT><DD>If this is STREAM_ROLES_WRITER, the routine will return the amount of free space available in the stream buffer. If it is STREAM_ROLES_READER, it will return the amount of data waiting to be read.</DD>
<DT>
<CODE>
*bytesAvailable</DT><DD>
</CODE>
The routine will write the number of bytes available (for writing or reading) to this variable.</DD>
</DL>
<P>
If the routine is successful, it returns zero. If it is unsuccessful, it returns a member of the <CODE>
StreamError</CODE>
 enumerated type.</P>
</DIV>
<DIV>
<A NAME="R_91.htm_IX_StreamRead()">
 </A>
<H1 CLASS="refHeading">
StreamRead()</H1>
<PRE CLASS="syntax">StreamError StreamRead (
        GeodeHandle 		driver,
        StreamToken 		stream,
        StreamBlocker 		blocker,
        word 		buffSize,
        byte *		buffer,
        word *		numBytesRead);</PRE>
<P>
This routine reads data from a stream. The routine takes the following arguments:</P>
<DL>
<DT>
<CODE>
driver</CODE>
</DT><DD>The <CODE>
GeodeToken</CODE>
 of the stream driver.</DD>
<DT>
<CODE>
stream</CODE>
</DT><DD>The <CODE>
StreamToken</CODE>
 of the stream.</DD>
<DT>
<CODE>
blocker</CODE>
</DT><DD>Specify whether to block if there is not enough data waiting to be read.</DD>
<DT>
<CODE>
buffsize</CODE>
</DT><DD>Size of passed buffer (i.e. amount of data to read from stream).</DD>
<DT>
<CODE>
buffer</CODE>
</DT><DD>Pointer to buffer where data from stream will be written.</DD>
<DT>
<CODE>
*numBytesReadRead</DT><DD>
</CODE>
<CODE>
StreamRead()</CODE>
 will write to this variable the number of bytes actually read from the stream.</DD>
</DL>
<P>
If <CODE>
StreamRead()</CODE>
 is successful, it returns zero. If it is unsuccessful, or could not read all the data requested from the stream, it returns a member of the <CODE>
StreamError</CODE>
 enumerated type.</P>
</DIV>
<DIV>
<A NAME="R_91.htm_IX_StreamReadByte()">
 </A>
<H1 CLASS="refHeading">
StreamReadByte()</H1>
<PRE CLASS="syntax">StreamError StreamWriteByte (
        GeodeHandle 		driver,
        StreamToken 		stream,
        StreamBlocker 		blocker,
        byte *		dataByte);</PRE>
<P>
This routine reads a single byte from a stream. It takes the following arguments:</P>
<DL>
<DT>
<CODE>
driver</CODE>
</DT><DD>The <CODE>
GeodeToken</CODE>
 of the stream driver.</DD>
<DT>
<CODE>
stream</CODE>
</DT><DD>The <CODE>
StreamToken</CODE>
 of the stream.</DD>
<DT>
<CODE>
blocker</CODE>
</DT><DD>Specify whether to block if there is not enough room to write the data.</DD>
<DT>
<CODE>
*dataByte</CODE>
</DT><DD>Read a byte from the stream, and write it to this variable.</DD>
</DL>
<P>
If the routine is successful, it returns zero. If it is unsuccessful, it returns a member of the <CODE>
StreamError</CODE>
 enumerated type.</P>
</DIV>
<DIV>
<A NAME="R_91.htm_IX_StreamSetError()">
 </A>
<H1 CLASS="refHeading">
StreamSetError()</H1>
<PRE CLASS="syntax">StreamError StreamSetError(
        Handle 		driver,
        StreamToken 		stream,
        StreamRoles 		roles,
        word 		errorCode);</PRE>
<P>
This routine sets the device-specific error code for a stream; this code can later be recovered by <CODE>
<A HREF="../../CRef/Routines/R_90.htm#IX_StreamGetError()">StreamGetError()</A></CODE>
. It takes the following arguments:</P>
<DL>
<DT>
<CODE>
driver</CODE>
</DT><DD>The <CODE>
GeodeToken</CODE>
 of the stream driver.</DD>
<DT>
<CODE>
stream</CODE>
</DT><DD>The <CODE>
StreamToken</CODE>
 of the stream.</DD>
<DT>
<CODE>
role</CODE>
</DT><DD>Either STREAM_ROLES_WRITER or STREAM_ROLES_READER.</DD>
<DT>
<CODE>
errorCode</CODE>
</DT><DD>A 16-bit device-specific error code.<CODE>
</CODE>
</DD>
</DL>
<P>
If the routine is successful, it returns zero. If it is unsuccessful, it returns a member of the <CODE>
StreamError</CODE>
 enumerated type.</P>
</DIV>
<HR>
<A NAME="R_92.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_92.htm_IX_StreamWrite()">
 </A>
<H1 CLASS="refHeading">
StreamWrite()</H1>
<PRE CLASS="syntax">StreamError StreamWrite (
        GeodeHandle 		driver,
        StreamToken 		stream,
        StreamBlocker 		blocker,
        word 		buffSize,
        const byte *		buffer,
        word *		numBytesWritten);</PRE>
<P>
This routine writes data to a stream. The routine takes the following arguments:</P>
<DL>
<DT>
<CODE>
driver</CODE>
</DT><DD>The <CODE>
GeodeToken</CODE>
 of the stream driver.</DD>
<DT>
<CODE>
stream</CODE>
</DT><DD>The <CODE>
StreamToken</CODE>
 of the stream.</DD>
<DT>
<CODE>
blocker</CODE>
</DT><DD>Specify whether to block if there is not enough room to write all the data.</DD>
<DT>
<CODE>
buffsize</CODE>
</DT><DD>Size of passed data buffer (i.e. amount of data to write to stream).</DD>
<DT>
<CODE>
buffer</CODE>
</DT><DD>Pointer to data to write to stream.</DD>
<DT>
<CODE>
*numBytesWritten</DT><DD>
</CODE>
<CODE>
StreamWrite()</CODE>
 will write to this variable the number of bytes actually written to the stream.</DD>
</DL>
<P>
If <CODE>
StreamWrite()</CODE>
 is successful, it returns zero. If it is unsuccessful, or could not write all the data to the stream, it returns a member of the <CODE>
StreamError</CODE>
 enumerated type.</P>
</DIV>
<DIV>
<A NAME="R_92.htm_IX_StreamWriteByte()">
 </A>
<H1 CLASS="refHeading">
StreamWriteByte()</H1>
<PRE CLASS="syntax">StreamError StreamWriteByte (
        GeodeHandle 		driver,
        StreamToken 		stream,
        StreamBlocker 		blocker,
        byte 		dataByte);</PRE>
<P>
This routine writes a single byte to a stream. It takes the following arguments:</P>
<DL>
<DT>
<CODE>
driver</CODE>
</DT><DD>The <CODE>
GeodeToken</CODE>
 of the stream driver.</DD>
<DT>
<CODE>
stream</CODE>
</DT><DD>The <CODE>
StreamToken</CODE>
 of the stream.</DD>
<DT>
<CODE>
blocker</CODE>
</DT><DD>Specify whether to block if there is not enough room to write the data.</DD>
<DT>
<CODE>
dataByte</CODE>
</DT><DD>Write this byte to the stream.</DD>
</DL>
<P>
If the routine is successful, it returns zero. If it is unsuccessful, it returns a member of the <CODE>
StreamError</CODE>
 enumerated type.</P>
</DIV>
<DIV>
<A NAME="R_92.htm_IX_SysGetConfig()">
 </A>
<H1 CLASS="refHeading">
SysGetConfig()</H1>
<PRE CLASS="syntax">dword	SysGetConfig();</PRE>
<P>
This routine returns a set of values defining the system configuration. The returned dword contains four byte values, listed below from least significant byte to most significant byte:</P>
<DL>
<DT>
<STRONG>
configuration flags</DT><DD>
</STRONG>
This byte contains a record of <CODE>
SysConfigFlags</CODE>
 reflecting the system status. This record includes information on how the system was started, whether Swat is running it, whether the system was restarted, etc.</DD>
<DT>
<STRONG>
reserved byte</DT><DD>
</STRONG>
This byte contains reserved information unusable by applications.</DD>
<DT>
<STRONG>
processor type</DT><DD>
</STRONG>
This byte contains a value reflecting the processor type of the machine running GEOS. This is of type <CODE>
SysProcessorType</CODE>
 and is one of SPT_8088, SPT_8086, SPT_80186, SPT_80286, SPT_80386, or SPT_80486. Use the macro SGC_PROCESSOR() to extract this value from the returned dword.</DD>
<DT>
<STRONG>
machine type</DT><DD>
</STRONG>
This byte contains a value of <CODE>
SysMachineType</CODE>
 indicating the type of the machine running GEOS. It may be one of the following values: SMT_UNKNOWN, SMT_PC, SMT_PC_CONV, SMT_PC_JR, SMT_PC_XT, SMT_PC_XT_286, SMT_PC_AT, SMT_PS2_30, SMT_PS2_50, SMT_PS2_60, SMT_PS2_80, or SMT_PS1. Use the macro SGC_MACHINE() to extract this value from the returned dword.</DD>
</DL>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
system.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_92.htm_IX_SysGetDosEnvironment()">
 </A>
<H1 CLASS="refHeading">
SysGetDosEnvironment()</H1>
<PRE CLASS="syntax">Boolean	SysGetDosEnvironment( /* true if error (not found) */
        const char		* variable,				/* environment variable */
        char		* buffer,				/* buffer for return value */
        word		bufSize);				/* maximum return string length */</PRE>
<P>
This routine looks up a specified DOS environment variable in the environment buffer. It takes three parameters:</P>
<DL>
<DT>
<CODE>
variable</CODE>
</DT><DD>A pointer to the null-terminated character string representing the name of the variable to be searched for.</DD>
<DT>
<CODE>
buffer</CODE>
</DT><DD>A pointer to a locked or fixed buffer in which the variable's value will be returned.</DD>
<DT>
<CODE>
bufSize</CODE>
</DT><DD>The size of the passed buffer in bytes (the maximum number of characters that can be returned including the terminating null character).</DD>
</DL>
<P>
If the variable is not found, the error flag returned will be <CODE>
true</CODE>
.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
system.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_92.htm_IX_ErrorCheckingFlags:SysGetECLevel()">
 </A>
<A NAME="R_92.htm_IX_SysGetECLevel()">
 </A>
<A NAME="R_92.htm_IX_Error checking:SysGetECLevel()">
 </A>
<H1 CLASS="refHeading">
SysGetECLevel()</H1>
<PRE CLASS="syntax">ErrorCheckingFlags SysGetECLevel(
        MemHandle * checksumBlock);</PRE>
<P>
This routine checks the current error-checking level of the system. The returned record of <CODE>
ErrorCheckingFlags</CODE>
 describes which levels of error checking are turned on and which are off. If checksum error checking (ECF_BLOCK_CHECKSUM) is on, pass a pointer to the handle of a block on which the checksum will be done.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
ec.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_92.htm_IX_SysGetInfo()">
 </A>
<A NAME="R_92.htm_IX_SysGetInfoType">
 </A>
<A NAME="R_92.htm_IX_SGIT_&ldots;">
 </A>
<A NAME="R_92.htm_IX_Handles:finding number of">
 </A>
<A NAME="R_92.htm_IX_Heap:finding size of">
 </A>
<A NAME="R_92.htm_IX_Volumes (file system):finding number of">
 </A>
<A NAME="R_92.htm_IX_Geodes:finding number of">
 </A>
<A NAME="R_92.htm_IX_Libraries:finding number of">
 </A>
<A NAME="R_92.htm_IX_Drivers:finding number of">
 </A>
<A NAME="R_92.htm_IX_Performance:CPU speed">
 </A>
<H1 CLASS="refHeading">
SysGetInfo()</H1>
<PRE CLASS="syntax">dword	SysGetInfo(
        SysGetInfoType info);			/* type of information to retrieve */</PRE>
<P>
This routine returns general system information. Pass the type of information to be returned; the value returned depends on the type passed in <CODE>
info</CODE>
. Note that the largest returned value is a dword; many different return values should be cast to the appropriate type when calling <CODE>
SysGetInfo()</CODE>
.</P>
<P>
The <CODE>
info</CODE>
 parameter (of <CODE>
SysGetInfoType</CODE>
) can have one of the following values:</P>
<DL>
<DT>
SGIT_TOTAL_HANDLES</DT><DD>
Returns the total number of handles in the kernel's handle table.</DD>
<DT>
SGIT_HEAP_SIZE</DT><DD>
Returns the total heap size in bytes.</DD>
<DT>
SGIT_LARGEST_FREE_BLOCK</DT><DD>
Returns the size (in bytes) of the largest possible block that may be allocated at the moment.</DD>
<DT>
SGIT_TOTAL_COUNT</DT><DD>
Returns the total number of clock ticks since the current session of GEOS started (subtracts the initial system clock value from the current time).</DD>
<DT>
SGIT_NUMBER_OF_VOLUMES</DT><DD>
Returns the total number of volumes registered with the system.</DD>
<DT>
SGIT_TOTAL_GEODES</DT><DD>
Returns the total number of geodes currently loaded.</DD>
<DT>
SGIT_NUMBER_OF_PROCESSES</DT><DD>
Returns the total number of processes currently loaded.</DD>
<DT>
SGIT_NUMBER_OF_LIBRARIES</DT><DD>
Returns the total number of libraries currently loaded.</DD>
<DT>
SGIT_NUMBER_OF_DRIVERS</DT><DD>
Returns the total number of drivers currently loaded.</DD>
<DT>
SGIT_CPU_SPEED</DT><DD>
Returns the CPU speed of the processor. The value returned will be ten times the ratio of the CPU speed relative to a base XT processor.</DD>
<DT>
SGIT_SYSTEM_DISK</DT><DD>
Returns the disk handle of the disk on which GEOS (the GEOS.INI file) resides.</DD>
<DT>
SGIT_UI_PROCESS</DT>
</DL>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
sysstats.h</STRONG>
 </P>
</DIV>
<HR>
<A NAME="R_93.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_93.htm_IX_SysGetPenMode()">
 </A>
<A NAME="R_93.htm_IX_Pen input:SysGetPenMode()">
 </A>
<A NAME="R_93.htm_IX_Ink:SysGetPenMode()">
 </A>
<H1 CLASS="refHeading">
SysGetPenMode()</H1>
<PRE CLASS="syntax">Boolean	SysGetPenMode();</PRE>
<P>
This routine returns true if GEOS is running on a pen-based system, false if it is not.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
system.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_93.htm_IX_SysLocateFileInDosPath()">
 </A>
<H1 CLASS="refHeading">
SysLocateFileInDosPath()</H1>
<PRE CLASS="syntax">DiskHandle SysLocateFileInDosPath( /* sets thread's error value */
        const char		* fname,				/* file name */
        char		* buffer);				/* returned path of file */</PRE>
<P>
This routine searches for a specified file along the search path specified in the DOS environment variable PATH. The parameters are</P>
<DL>
<DT>
<CODE>
fname</CODE>
</DT><DD>A pointer to the null-terminated file name to search for.</DD>
<DT>
<CODE>
buffer</CODE>
</DT><DD>A pointer to a locked or fixed buffer into which the full path of the file will be placed.</DD>
</DL>
<P>
This routine returns the disk handle of the disk on which the file resides as well as the file's full path (with drive name) in the buffer pointed to by <CODE>
buffer</CODE>
. The path returned is a null-terminated character string. If the file could not be found, a null disk handle will be returned. The error value can be retrieved with <CODE>
<A HREF="../../CRef/Routines/R_97.htm#IX_ThreadGetError()">ThreadGetError()</A></CODE>
.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
system.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_93.htm_IX_SysNotify()">
 </A>
<A NAME="R_93.htm_IX_SysNotifyFlags">
 </A>
<A NAME="R_93.htm_IX_SNF_&ldots;">
 </A>
<H1 CLASS="refHeading">
SysNotify()</H1>
<PRE CLASS="syntax">word	SysNotify(
        SysNotifyFlags		flags,				/* options to offer user */
        const char 		* string1,				/* first string to display */
        const char 		* string2);				/* second string to display */</PRE>
<P>
This routine causes the kernel to put up a standard notification dialog box on the screen. This dialog box is white with a black border and is used nearly exclusively for error notification by the kernel. Pass this routine the following parameters:</P>
<DL>
<DT>
<CODE>
flags</CODE>
</DT><DD>A record of <CODE>
SysNotifyFlags</CODE>
 indicating the options the dialog presents to the user. These flags are shown below.</DD>
<DT>
<CODE>
string1</CODE>
</DT><DD>A pointer to a null-terminated character string put up in the dialog box (may be a null pointer).</DD>
<DT>
<CODE>
string2</CODE>
</DT><DD>A pointer to a second null-terminated string presented in the dialog box (may be a null pointer).</DD>
</DL>
<P>
The returned word is the user's response, based on the <CODE>
SysNotifyFlags</CODE>
 passed (see below).</P>
<P CLASS="refField"><STRONG>
Structures:</STRONG>	<CODE>
SysNotifyFlags</CODE>
 is a record of several flags; none, any, or all of the flags may be set at a time. The five flags are</P>
<DL>
<DT>
SNF_RETRY</DT><DD>Allow the user to retry the operation that brought up the notification box. If the user selects this option, it will be returned by the routine.</DD>
<DT>
SNF_EXIT</DT><DD>Allow the user to exit GEOS entirely. If the user selects this option, it will be returned by the routine after an SST_CLEAN_FORCED shutdown has been initiated.</DD>
<DT>
SNF_ABORT</DT><DD>Allow the user to abort the operation that brought up the notification box. If the user selects this option, it will be returned by the routine.</DD>
<DT>
SNF_CONTINUE</DT><DD>
Allow the user to continue the operation. If the user selects this option, it will be returned by the routine.</DD>
<DT>
SNF_REBOOT</DT><DD>
Allow the user to shut down and reboot GEOS directly. If the user selects this option, the routine will not return.</DD>
</DL>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
system.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_93.htm_IX_SysRegisterScreen()">
 </A>
<H1 CLASS="refHeading">
SysRegisterScreen()</H1>
<PRE CLASS="syntax">void	SysRegisterScreen(
        GeodeHandle		driver,
        WindowHandle		root);</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="R_93.htm_IX_SysSetECLevel()">
 </A>
<A NAME="R_93.htm_IX_ErrorCheckingFlags:SysSetECLevel()">
 </A>
<H1 CLASS="refHeading">
SysSetECLevel()</H1>
<PRE CLASS="syntax">void	SysSetECLevel(
        ErrorCheckingFlags		flags,					/* level of error checking */
        MemHandle		checksumBlock);					/* block to check, if any */	</PRE>
<P>
This routine sets the error-checking level of the software. Pass it a record of <CODE>
ErrorCheckingFlags</CODE>
 indicating which levels of error checking should be employed. If checksum checking (ECF_BLOCK_CHECKSUM) is turned on, also pass the handle of a block on which the checksum will be performed.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
ec.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_93.htm_IX_SysSetExitFlags()">
 </A>
<H1 CLASS="refHeading">
SysSetExitFlags()</H1>
<PRE CLASS="syntax">word	SysGetExitFlags(
        ExitFlags		bitsToSet,
        ExitFlags		bitsToClear);</PRE>
<P>
&nbsp;</P>
</DIV>
<HR>
<A NAME="R_94.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_94.htm_IX_SysShutdown()">
 </A>
<A NAME="R_94.htm_IX_SysShutdownType">
 </A>
<A NAME="R_94.htm_IX_SST_&ldots;  (SysShutdownType)">
 </A>
<H1 CLASS="refHeading">
SysShutdown()</H1>
<PRE CLASS="syntax">Boolean	SysShutdown(
        SysShutdownType type,
        ...);</PRE>
<P>
This routine causes the system to shut down, exiting to the native operating system (typically DOS). It takes variable parameters depending on the first parameter. The first parameter is the type of shutdown requested, and it determines the calling format of the routine. <CODE>
SysShutdown()</CODE>
 returns a Boolean value dependent on the type of shutdown.</P>
<P>
The parameters and calling format for this routine depend on the value in the <CODE>
type</CODE>
 parameter. The possible values (<CODE>
SysShutdownType</CODE>
) are listed below with the associated parameter and return information.</P>
<DL>
<DT CLASS="FIXME_WorListWide">
SST_CLEAN</DT><DD>Shut down all applications cleanly, allowing any that wish to to abort the shutdown. The routine will return <CODE>
true</CODE>
 if a system shutdown is already in progress at the time of the call. This type of shutdown will send <CODE>
MSG_META_CONFIRM_SHUTDOWN</CODE>
 to all objects registered on the MANUFACTURER_ID_GEOWORKS:GCNSLT_SHUTDOWN_CONTROL GCN list (but only if the shutdown is not cancelled). Each object on that list must return an acknowledgment of the shutdown. The parameter format and parameters are</DD>
<PRE>Boolean SysShutdown(
	SysShutdownType			type,
	optr			notificationOD,
	Message			msg);</PRE>
<DT>
<CODE>
notificationOD</DT><DD>
</CODE>
The optr of an object which will receive the message passed in <CODE>
msg</CODE>
 after the shutdown has been acknowledged. Pass a null optr to use the default notification (<CODE>
MSG_META_DETACH</CODE>
 sent to the UI).</DD>
<DT>
<CODE>
msg</CODE>
</DT><DD>The message to be sent to the object in <CODE>
notificationOD</CODE>
.</DD>
<DT CLASS="FIXME_WorListWide">
SST_CLEAN_FORCED</DT><DD>
Shut down all applications cleanly without the possibility of cancellation. This type takes no additional parameters and does not allow other geodes to abort the shutdown. It will return, but the return value will be meaningless.</DD>
<DT CLASS="FIXME_WorListWide">
SST_DIRTY</DT><DD>Attempt to exit device drivers and close all files without shutting down applications. Does not return. The parameters of this type are</DD>
<PRE>Boolean SysShutdown{
	SysShutdownType			type,		/* SST_DIRTY */
	const char			* reason);</PRE>
<DT CLASS="FIXME_WorListWide">
</DT><DD>The <CODE>
reason</CODE>
 parameter is a pointer to a text string presented to the user as a reason for the dirty shutdown. The string is null-terminated. Pass -1 if no reason is to be given.</DD>
<DT CLASS="FIXME_WorListWide">
SST_PANIC</DT><DD>Exit system device drivers (GA_SYSTEM) without exiting applications or closing files. This can be bad for the system and should be used only in emergency situations. This type of shutdown takes no additional parameters and does not return.</DD>
<DT CLASS="FIXME_WorListWide">
SST_REBOOT</DT><DD>
This is used by GEOS when the user hits <CODE>
Ctrl-Alt-Del</CODE>
. Applications should not call it.</DD>
<DT CLASS="FIXME_WorListWide">
SST_RESTART</DT><DD>
This is like SST_CLEAN_FORCED above, but it reloads GEOS after shutting down rather than exit completely. It takes no additional parameters; it will return TRUE if the system could not be restarted, FALSE if the shutdown has been initiated.</DD>
<DT CLASS="FIXME_WorListWide">
SST_FINAL</DT><DD>Perform the final phase of a shutdown. This routine is called <CODE>
only</CODE>
 by the UI when the SST_CLEAN_FORCED shutdown is complete. This type does not return, and it takes one additional parameter. The calling format and parameters of this type are</DD>
<PRE>Boolean SysShutdown(
	SysShutdownType			type,
	const char			* reason);</PRE>
<DT CLASS="FIXME_WorListWide">
</DT><DD>The <CODE>
reason</CODE>
 parameter is a character string explaining the reason (typically an error) for the final shutdown.</DD>
<DT CLASS="FIXME_WorListWide">
SST_SUSPEND</DT><DD>
Suspend system operation in preparation for task switching, and broadcast <CODE>
MSG_META_CONFIRM_SHUTDOWN</CODE>
 to all objects on the MANUFACTURER_ID_GEOWORKS:GCNSLT_SHUTDOWN_CONTROL GCN list (see <CODE>
MetaClass</CODE>
). All notified objects must return acknowledgment of the shutdown. This type of <CODE>
SysShutdown()</CODE>
 returns <CODE>
true</CODE>
 if another system shutdown is already in progress. It takes two additional parameters:</DD>
<PRE>Boolean SysShutdown(
	SysShutdownType			type,
	optr			notificationOD,
	Message			msg);</PRE>
<DT>
<CODE>
notificationOD</DT><DD>
</CODE>
The optr of an object which will receive the message passed in <CODE>
msg</CODE>
 after the shutdown has been acknowledged. Pass a null optr to use the default notification (<CODE>
MSG_META_DETACH</CODE>
 sent to the UI), though this is not usually the intent of the call.</DD>
<DT>
<CODE>
msg</CODE>
</DT><DD>The message to be sent to the object in <CODE>
notificationOD</CODE>
.</DD>
<DT CLASS="FIXME_WorListWide">
SST_CONFIRM_START</DT><DD>
Called by the recipient of <CODE>
MSG_META_CONFIRM_SHUTDOWN</CODE>
; this allows shutdown confirmation dialog boxes to be presented in order to the user. The caller of this type will be blocked until all previous callers have finished their confirmation procedure. When <CODE>
SysShutdown()</CODE>
 returns, the caller may present its confirmation dialog and continue or abort the shutdown. If <CODE>
SysShutdown()</CODE>
 returns <CODE>
true</CODE>
 from a call with this type, the caller should <EM>
not</EM>
 present the confirmation dialog to the user and need not call <CODE>
SysShutdown()</CODE>
 with SST_CONFIRM_END; another thread has already cancelled the shutdown. This type takes no additional parameters.</DD>
<DT CLASS="FIXME_WorListWide">
SST_CONFIRM_END</DT><DD>
The counterpart of SST_CONFIRM_START, this ends the confirmation sequence in an object's <CODE>
MSG_META_CONFIRM_SHUTDOWN</CODE>
 handler. It takes one additional parameter and returns nothing. The calling format is shown below:</DD>
<PRE>void	SysShutdown(
	SysShutdownType			type,
	Boolean			confirm);</PRE>
<DT CLASS="FIXME_WorListWide">
</DT><DD>The <CODE>
confirm</CODE>
 parameter should be TRUE if the shutdown is to be continued, FALSE if the shutdown should be aborted.</DD>
</DL>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
system.h</STRONG>
 </P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	Most applications should not call <CODE>
SysShutdown()</CODE>
. Any that do should do so with extreme care.</P>
</DIV>

<DIV>
<A NAME="R_94.htm_IX_SysStatistics()">
 </A>
<A NAME="R_94.htm_IX_Performance:SysStatistics()">
 </A>
<H1 CLASS="refHeading">
SysStatistics()</H1>
<PRE CLASS="syntax">void	SysStatistics(
        SysStats * stats);			/* returned statistics */</PRE>
<P>
This routine returns system performance statistics. Pass it a pointer to an empty <CODE>
SysStats</CODE>
 structure; the routine will fill in the appropriate fields. <CODE>
SysStats</CODE>
 has the following structure:</P>
<PRE>typedef struct {
    dword			SS_idleCount;
    SysSwapInfo			SS_swapOuts;
    SysSwapInfo			SS_swapIns;
    word			SS_contextSwitches;
    word			SS_interrupts;
    word			SS_runQueue;
} SysStats;</PRE>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
sysstats.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_94.htm_IX_SysUnlockBIOS()">
 </A>
<H1 CLASS="refHeading">
SysUnlockBIOS()</H1>
<PRE CLASS="syntax">void	SysUnlockBIOS(void);</PRE>
<P>
&nbsp;</P>
</DIV>

<DIV>
<A NAME="R_94.htm_IX_TakeDownDialogViaUIThread()">
 </A>
<H1 CLASS="refHeading">
TakeDownDialogViaUIThread()</H1>
<PRE CLASS="syntax">void	TakeDownDialogViaUIThread(
	optr		dialogBox );</PRE>
<P>
This will dismiss and destroy a dialog created with the routine
<a href="R_81.htm#IX_PutUpDialogViaUIThread()">PutUpDialogViaUIThread()</a>.
It dismisses the dialog by sending it MSG_GEN_GUP_INTERACTION_COMMAND
with the parameter IC_DISMISS.</P>

<P CLASS="refField"><STRONG>
Pass:   </STRONG>
</P>
<DL>
<DT>
<EM>
dialogBox</EM>
</DT><DD>Optr of the duplicate object to be dismissed and destroyed.
This is returned by the routine <a href="R_81.htm#IX_PutUpDialogViaUIThread()">
PutUpDialogViaUIThread()</a>.</DD>
<DT>
</DL>

<P CLASS="refField"><STRONG>
Include:</STRONG>        <STRONG CLASS="fileName">
foam.goh</STRONG>
 </P>

<P CLASS="refField"><STRONG>
See Also:</STRONG>       
<a href="R_81.htm#IX_PutUpDialogViaUIThread()">PutUpDialogViaUIThread()</a>,
<a href="R_9e.htm#IX_UserDestroyDialog()">UserDestroyDialog()</a>
 </P>
</DIV>

<HR>
<A NAME="R_95.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_95.htm_IX_TextSearchInString()">
 </A>
<H1 CLASS="refHeading">
TextSearchInString()</H1>
<PRE CLASS="syntax">char *	TextSearchInSTring(
        const char		*str1,
        conat char		*startPtr,
        const char		*endPtr,
        word		strSize,
        const char		*str2,
        word		str2Size,
        word		searchOptions,
        word		*matchLen);</PRE>
<P>
This routine searches in a single text chunk for a passed text string. If a match is found, a pointer to that match (and the length of the match) are returned in passed buffers. </P>
<P>
<EM>
str1</EM>
 is a pointer to the main string you will be searching in.</P>
<P>
<EM>
startPtr</EM>
 and <EM>
endPtr</EM>
 are pointers to locations within <EM>
str1</EM>
 to begin and end the search.</P>
<P>
<EM>
strSize</EM>
 stores the size of <EM>
str1</EM>
, or zero if null-terminated.</P>
<P>
<EM>
str2</EM>
 stores the match string, which may include wildcards (type <CODE>
WildCard</CODE>
).</P>
<P>
<EM>
str2Size</EM>
 stores the size of <EM>
str2</EM>
, or zero if null-terminated.</P>
<P>
<EM>
searchOptions</EM>
 stores the <CODE>
SearchOptions</CODE>
 to use by the search mechanism. The high byte should be zeroed.</P>
<P>
<EM>
matchLen</EM>
 stores a buffer to store the size of the matched word. (The matched word itself is returned by the routine.)</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
Objects/vTextC.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_95.htm_IX_TextSearchInHugeArray()">
 </A>
<H1 CLASS="refHeading">
TextSearchInHugeArray()</H1>
<PRE CLASS="syntax">dword	TextSearchInSTring(
        char		*str2,
        word		str2Size,
        dword		str1Size,
        dword		curOffset,
        dword		endOffset,
        FileHandle		hugeArrayFile,
        VMBlockHandle		hugeArrayBlock,
        word		searchOptions,
        word		*matchLen);</PRE>
<P>
This routine searches in a huge array for a passed text string. If a match is found, a dword offset to the match (and the length of the match) are returned in passed buffers. </P>
<P>
<EM>
str2</EM>
 stores the match string, which may include wildcards (type <CODE>
WildCard</CODE>
).</P>
<P>
<EM>
str2Size</EM>
 stores the size of <EM>
str2</EM>
, or zero if null-terminated.</P>
<P>
<EM>
str1Size</EM>
 stores the total length of the string being searched.</P>
<P>
<EM>
curOffset</EM>
 stores the offset from the start of str1 to the first character to check.</P>
<P>
<EM>
endOffset</EM>
 stores the offset from the start of str1 to the last character to check.</P>
<P>
<EM>
hugeArrayFile</EM>
 stores the file handle of the huge array.</P>
<P>
<EM>
hugeArrayBlock</EM>
 stores the VM block handle of the huge array.</P>
<P>
<EM>
searchOptions</EM>
 stores the <CODE>
SearchOptions</CODE>
 to use by the search mechanism. The high byte should be zeroed.</P>
<P>
<EM>
matchLen</EM>
 stores a buffer to store the size of the matched word. (The matched word itself is returned by the routine.)</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
Objects/vTextC.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_95.htm_IX_TGI_PRIORITY() macro">
 </A>
<H1 CLASS="refHeading">
TGI_PRIORITY()</H1>
<PRE CLASS="syntax">byte	TGI_PRIORITY(<EM>val</EM>);
        word	<EM>val</EM>;</PRE>
<P>
This macro extracts the thread priority from the value returned by <CODE>
<A HREF="../../CRef/Routines/R_97.htm#IX_ThreadGetInfo()">ThreadGetInfo()</A></CODE>
.</P>
</DIV>
<DIV>
<A NAME="R_95.htm_IX_TGI_RECENT_CPU_USAGE() macro">
 </A>
<H1 CLASS="refHeading">
TGI_RECENT_CPU_USAGE()</H1>
<PRE CLASS="syntax">byte	TGI_RECENT_CPU_USAGE(<EM>val</EM>);
        word	<EM>val</EM>;</PRE>
<P>
This macro extracts the recent CPU usage from the value returned by <CODE>
<A HREF="../../CRef/Routines/R_97.htm#IX_ThreadGetInfo()">ThreadGetInfo()</A></CODE>
.</P>
</DIV>
<DIV>
<A NAME="R_95.htm_IX_ThreadAllocSem()">
 </A>
<H1 CLASS="refHeading">
ThreadAllocSem()</H1>
<PRE CLASS="syntax">SemaphoreHandle ThreadAllocSem(
        word	value);			/* allowable locks on the semaphore */</PRE>
<P>
This routine allocates and initializes a new semaphore for private use by a multithreaded application. Pass the value with which to initialize the semaphore; this value represents the number of threads that can grab the semaphore before other grab attempts will block. Typically, the passed value will be one. The routine returns the handle of the new semaphore.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
sem.h</STRONG>
 </P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_98.htm#IX_ThreadPSem()">ThreadPSem()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_98.htm#IX_ThreadVSem()">ThreadVSem()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_96.htm#IX_ThreadFreeSem()">ThreadFreeSem()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_98.htm#IX_ThreadPTimedSem()">ThreadPTimedSem()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_95.htm_IX_ThreadAllocThreadLock()">
 </A>
<H1 CLASS="refHeading">
ThreadAllocThreadLock()</H1>
<PRE CLASS="syntax">ThreadLockHandle ThreadAllocThreadLock();</PRE>
<P>
This routine allocates a special semaphore called a thread lock. With a normal semaphore, a thread that grabs the semaphore twice without releasing it will deadlock; with a thread lock, a thread can grab it more than once in succession. The thread has to release it once for each time it grabs the thread lock, however.</P>
<P>
In all other aspects, however, the thread lock resembles a normal semaphore. <CODE>
ThreadAllocThreadLock()</CODE>
 returns the handle of the new thread lock.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
sem.h</STRONG>
 </P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_97.htm#IX_ThreadGrabThreadLock()">ThreadGrabThreadLock()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_98.htm#IX_ThreadReleaseThreadLock()">ThreadReleaseThreadLock()</A></CODE>.</P>
</DIV>
<HR>
<A NAME="R_96.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_96.htm_IX_ThreadAttachToQueue()">
 </A>
<H1 CLASS="refHeading">
ThreadAttachToQueue()</H1>
<PRE CLASS="syntax">void	ThreadAttachToQueue(
        QueueHandle		qh,				/* queue to attach */
        ClassStruct		* class);				/* primary class of thread */</PRE>
<P>
This routine attaches the calling thread to the passed event queue. This is used only for event-driven threads. Typically, this routine is called when a thread is created; attaching to queues is automatic in nearly all cases, and you will rarely need this routine.</P>
<P>
Pass the handle of the queue in <CODE>
qh</CODE>
 and a class pointer in <CODE>
class</CODE>
. The class will be attached to the event queue and will handle all messages sent directly to the thread. This class should nearly always be a subclass of <CODE>
ProcessClass</CODE>
.</P>
<P>
If a queue handle of zero is passed, the thread wants to &quot;reattach&quot; to the current queue. This is used typically during shutdown of event-driven threads, and it is nearly always taken care of automatically by <CODE>
ProcessClass</CODE>
.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
thread.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_96.htm_IX_ThreadCreate()">
 </A>
<A NAME="R_96.htm_IX_PRIORITY_&ldots;">
 </A>
<H1 CLASS="refHeading">
ThreadCreate()</H1>
<PRE CLASS="syntax">ThreadHandle ThreadCreate(
        word	priority,			/* Initial base priority of new thread */
        word	valueToPass,			/* Optional data to pass to new thread */
        word	(*startRoutine)(word valuePassed),
				/* Pointer to entry routine */</PRE>
<PRE CLASS="syntax">        word	stackSize,			/* Size of the stack for the new thread */
        GeodeHandle owner);				/* Geode that will own the new thread */</PRE>
<P>
This routine creates a new procedural thread for a process. If you need a new event-driven thread, send <CODE>
MSG_PROCESS_CREATE_EVENT_THREAD</CODE>
 to your process object instead.</P>
<P>
Pass the following parameters to this routine:</P>
<DL>
<DT>
<CODE>
priority</CODE>
</DT><DD>The priority of the new thread. Typically this will be one of the standard thread priorities (see below).</DD>
<DT>
<CODE>
valueToPass</DT><DD>
</CODE>
A word of optional data to be passed to the entry routine of the new thread. This can be used, for example, to indicate the thread's initial context or for initializing thread variables.</DD>
<DT>
<CODE>
startRoutine</DT><DD>
</CODE>
A pointer to the entry routine to be executed immediately for the thread. This may be in either fixed or movable memory. The segment must be a virtual segment. Note that if the routine is in movable memory, it may degrade heap performance for the life of the thread (its movable block will remain locked for extended stretches of time). The routine may return the thread's exit code or may call <CODE>
<A HREF="../../CRef/Routines/R_96.htm#IX_ThreadDestroy()">ThreadDestroy()</A></CODE>
 directly.</DD>
<DT>
<CODE>
stackSize</CODE>
</DT><DD>The stack size allocated for the thread. 512 bytes is typically enough for threads doing neither UI nor file system work; threads working with the file system will require 1 K. Threads working with UI objects will require 3 K.</DD>
<DT>
<CODE>
owner</CODE>
</DT><DD>The geode handle of the geode that will own the thread. If the calling thread's geode will own the new thread, it can call <CODE>
<A HREF="../../CRef/Routines/R_34.htm#IX_GeodeGetProcessHandle()">GeodeGetProcessHandle()</A></CODE>
 prior to calling <CODE>
ThreadCreate()</CODE>
.</DD>
</DL>
<P>
<CODE>
ThreadCreate()</CODE>
 returns the thread handle of the new thread. If an error occurs, the calling thread's error code will be set and a null handle returned; you should likely call <CODE>
<A HREF="../../CRef/Routines/R_97.htm#IX_ThreadGetError()">ThreadGetError()</A></CODE>
 to retrieve the error code after creating the new thread. A return of NO_ERROR_RETURNED from <CODE>
<A HREF="../../CRef/Routines/R_97.htm#IX_ThreadGetError()">ThreadGetError()</A></CODE>
 means no error occurred.</P>
<P>
The standard thread priorities that may be passed in the <CODE>
priority</CODE>
 parameter are listed below:</P>
<DL>
<DT>
PRIORITY_TIME_CRITICAL</DT><DD>
The highest priority of all; you should not use this in general because it will pre-empt nearly all other threads. (It may be useful, however, during debugging.)</DD>
<DT>
PRIORITY_HIGH</DT><DD>
A high priority; generally only used for highly important threads.</DD>
<DT>
PRIORITY_UI</DT><DD>
Another high priority; this is used for User Interface threads to provide quick response to user actions.</DD>
<DT>
PRIORITY_FOCUS</DT><DD>
A medium-level priority; this is used for whatever thread has the current input focus (whichever thread the user is currently working with).</DD>
<DT>
PRIORITY_STANDARD</DT><DD>
The standard application thread priority; you should typically use this when creating new threads.</DD>
<DT>
PRIORITY_LOW</DT><DD>
A low priority for tasks that can be done in the background.</DD>
<DT>
PRIORITY_LOWEST</DT><DD>
The lowest standard priority; it is used for threads that can take any amount of time to complete.</DD>
</DL>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
thread.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_96.htm_IX_ThreadDestroy()">
 </A>
<H1 CLASS="refHeading">
ThreadDestroy()</H1>
<PRE CLASS="syntax">void	ThreadDestroy(
        word	errorCode,	/* Error code to indicate cause of destruction */
        optr	ackObject,	/* Object to receive destruction acknowledgment */
        word	ackData);	/* Additional word of data to pass (as the low
			 * word of optr for source of MSG_META_ACK) */</PRE>
<P>
This routine causes the current (calling) thread to exit and then destroy itself. The thread is responsible for ensuring that it has no leftover resources allocated or semaphores locked.</P>
<P>
Pass it an error code or exit code meaningful to the application and the other threads in the application. This error code will be used by the debugger to determine the cause of the thread's exit; a null error code usually indicates successful completion of the thread's task.</P>
<P>
Pass also the optr of the object to receive acknowledgement of the thread's destruction. The object specified will receive <CODE>
MSG_META_ACK</CODE>
 after the calling thread is completely destroyed.</P>
<P CLASS="refField"><STRONG>
Be Sure To:</STRONG>	Always clean up before exiting a thread. Unlock locked resources, free allocated memory, etc. You do not have to do these things for the application's primary thread; the process object (the primary thread) will automatically clean up after itself.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
thread.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_96.htm_IX_ThreadFreeSem()">
 </A>
<H1 CLASS="refHeading">
ThreadFreeSem()</H1>
<PRE CLASS="syntax">void	ThreadFreeSem(
        SemaphoreHandle sem);			/* semaphore to be freed */</PRE>
<P>
This routine frees the specified semaphore that had been allocated with <CODE>
<A HREF="../../CRef/Routines/R_95.htm#IX_ThreadAllocSem()">ThreadAllocSem()</A></CODE>
. You must be sure that no threads are using the semaphore or will use it after it has been freed. Subsequent access attempts could cause illegal handle errors or worse.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
sem.h</STRONG>
 </P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_95.htm#IX_ThreadAllocSem()">ThreadAllocSem()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_98.htm#IX_ThreadPSem()">ThreadPSem()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_98.htm#IX_ThreadVSem()">ThreadVSem()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_98.htm#IX_ThreadPTimedSem()">ThreadPTimedSem()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_96.htm_IX_ThreadFreeThreadLock()">
 </A>
<H1 CLASS="refHeading">
ThreadFreeThreadLock()</H1>
<PRE CLASS="syntax">void	ThreadFreeThreadLock(
        ThreadLockHandle sem);				/* thread lock to be freed */</PRE>
<P>
This routine frees the specified thread lock that had been allocated with <CODE>
<A HREF="../../CRef/Routines/R_95.htm#IX_ThreadAllocThreadLock()">ThreadAllocThreadLock()</A></CODE>
. You must be sure that no threads are using or will use the thread lock after it has been freed. Subsequent attempts to grab or release the thread lock could cause illegal handle errors.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
sem.h</STRONG>
 </P>
</DIV>
<HR>
<A NAME="R_97.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_97.htm_IX_ThreadGetError()">
 </A>
<H1 CLASS="refHeading">
ThreadGetError()</H1>
<PRE CLASS="syntax">word	ThreadGetError(void)</PRE>
<P>
This routine returns the thread's current error value.</P>
</DIV>
<DIV>
<A NAME="R_97.htm_IX_Threads:finding priority">
 </A>
<A NAME="R_97.htm_IX_Threads:finding handle">
 </A>
<A NAME="R_97.htm_IX_ThreadGetInfo()">
 </A>
<A NAME="R_97.htm_IX_ThreadGetInfoType">
 </A>
<A NAME="R_97.htm_IX_TGIT_&ldots;">
 </A>
<A NAME="R_97.htm_IX_Event queues:from thread handle">
 </A>
<H1 CLASS="refHeading">
ThreadGetInfo()</H1>
<PRE CLASS="syntax">word	ThreadGetInfo(
        ThreadHandle		th,			/* thread to get information about */
        ThreadGetInfoType 		info);			/* type of information to get */</PRE>
<P>
This routine gets information about the specified thread. The information desired is specified in the <CODE>
info</CODE>
 parameter; the subject thread is specified in the <CODE>
th</CODE>
 parameter. If the thread handle passed is zero or a null handle, the routine will return information about the calling thread.</P>
<P>
The <CODE>
info</CODE>
 parameter is one of the following values of <CODE>
ThreadGetInfoType</CODE>
, specifying the type of information to be returned by <CODE>
ThreadGetInfo()</CODE>
:</P>
<DL>
<DT>
TGIT_PRIORITY_AND_USAGE</DT><DD>
The returned word will contain both the thread's priority and the thread's recent CPU usage. To extract the priority of the thread, use the macro TGI_PRIORITY; to extract the recent CPU usage, use the macro TGI_RECENT_CPU_USAGE.</DD>
<DT>
TGIT_THREAD_HANDLE</DT><DD>
Useful only when the <CODE>
th</CODE>
 parameter is zero, this will return the thread handle of the subject thread. If <CODE>
th</CODE>
 is zero, the handle of the calling thread will be returned.</DD>
<DT>
TGIT_QUEUE_HANDLE</DT><DD>
The returned word will contain the queue handle of the event-driven thread specified in <CODE>
th</CODE>
. If the thread specified is not event-driven, a null queue handle will be returned.</DD>
</DL>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
thread.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_97.htm_IX_ThreadGrabThreadLock()">
 </A>
<H1 CLASS="refHeading">
ThreadGrabThreadLock()</H1>
<PRE CLASS="syntax">void	ThreadGrabThreadLock(
        ThreadLockHandle sem);				/* thread lock to grab */</PRE>
<P>
This routine attempts to grab the thread lock for the calling thread. If the thread lock is currently held by another thread, the caller will block until the lock becomes available. If the caller already has the thread lock, it will grab the lock again and continue executing.</P>
<P CLASS="refField"><STRONG>
Be Sure To:</STRONG>	Thread locks must be released with <CODE>
<A HREF="../../CRef/Routines/R_98.htm#IX_ThreadReleaseThreadLock()">ThreadReleaseThreadLock()</A></CODE>
 once for each time they are grabbed.</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	This routine provides no deadlock protection for multiple threads. If multiple threads will be grabbing multiple thread locks, the locks should always be grabbed in the same order to minimize the potential for deadlock.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
sem.h</STRONG>
 </P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_95.htm#IX_ThreadAllocThreadLock()">ThreadAllocThreadLock()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_98.htm#IX_ThreadReleaseThreadLock()">ThreadReleaseThreadLock()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_97.htm_IX_ThreadHandleException()">
 </A>
<A NAME="R_97.htm_IX_ThreadException">
 </A>
<A NAME="R_97.htm_IX_TE_&ldots;  (ThreadException type)">
 </A>
<H1 CLASS="refHeading">
ThreadHandleException()</H1>
<PRE CLASS="syntax">void	ThreadHandleException(
        ThreadHandle		th,				/* thread to handle the exception */
        ThreadExceptions		exception,				/* exception to handle */
        void	(*handler)	());				/* pointer to handler */</PRE>
<P>
This routine allows a thread to set up a handler for a processor exception. This can be useful for debugging purposes. Pass the following three parameters:</P>
<DL>
<DT>
<CODE>
th</CODE>
</DT><DD>The handle of the thread to handle the exception. Pass zero for the current thread.</DD>
<DT>
<CODE>
exception</CODE>
</DT><DD>A <CODE>
ThreadException</CODE>
 type (see below).</DD>
<DT>
<CODE>
handler</CODE>
</DT><DD>A pointer to a handler in fixed or locked memory. Pass a null pointer to use the GEOS default exception handler.</DD>
</DL>
<P CLASS="refField"><STRONG>
Structures:</STRONG>	The <CODE>
ThreadException</CODE>
 type has the following values:</P>
<PRE>TE_DIVIDE_BY_ZERO
TE_OVERFLOW
TE_BOUND
TE_FPU_EXCEPTION
TE_SINGLE_STEP
TE_BREAKPOINT</PRE>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
thread.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_97.htm_IX_ThreadModify()">
 </A>
<H1 CLASS="refHeading">
ThreadModify()</H1>
<PRE CLASS="syntax">void	ThreadModify(
        ThreadHandle		th,					/* thread to modify */
        word		newBasePriority,					/* thread's new base priority */
        ThreadModifyFlags		flags);					/* flags (see below) */</PRE>
<P>
This routine modifies the priority of the specified thread. Use it to either set the base priority of the thread or reset the current CPU usage to zero. The parameters should have the following values:</P>
<DL>
<DT>
<CODE>
th</CODE>
</DT><DD>The thread handle; pass zero to change the priority of the calling thread.</DD>
<DT>
<CODE>
newBasePriority</DT><DD>
</CODE>
The new base priority of the thread. Use one of the standard priorities--see <CODE>
<A HREF="../../CRef/Routines/R_96.htm#IX_ThreadCreate()">ThreadCreate()</A></CODE>
--or use a value between zero and 255.</DD>
<DT>
<CODE>
flags</CODE>
</DT><DD>A record of <CODE>
ThreadModifyFlags</CODE>
; pass TMF_BASE_PRIO to change the thread's base priority or TMF_ZERO_USAGE to reset the thread's recent CPU usage to zero.</DD>
</DL>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	Unless the thread is timing-critical, you should not set the base priority to zero.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
thread.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_97.htm_IX_ThreadPrivAlloc()">
 </A>
<H1 CLASS="refHeading">
ThreadPrivAlloc()</H1>
<PRE CLASS="syntax">word	ThreadPrivAlloc(
        word		wordsRequested,					/* number of words to allocate */
        GeodeHandle		owner);					/* handle of geode to own data */</PRE>
<P>
This routine allocates a number of contiguous words in the private data of all geodes (loaded and yet-to-be loaded). It is exactly the same as <CODE>
<A HREF="../../CRef/Routines/R_35.htm#IX_GeodePrivAlloc()">GeodePrivAlloc()</A></CODE>
; see the entry for that routine.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
thread.h</STRONG>
 </P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_35.htm#IX_GeodePrivAlloc()">GeodePrivAlloc()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_97.htm_IX_ThreadPrivFree()">
 </A>
<H1 CLASS="refHeading">
ThreadPrivFree()</H1>
<PRE CLASS="syntax">void	ThreadPrivFree(
        word	range,			/* offset to first word to be freed */
        word	wordsRequested);			/* number of words to free */</PRE>
<P>
This routine frees a number of contiguous private-data words previously allocated with <CODE>
<A HREF="../../CRef/Routines/R_97.htm#IX_ThreadPrivAlloc()">ThreadPrivAlloc()</A></CODE>
. It is similar to <CODE>
<A HREF="../../CRef/Routines/R_35.htm#IX_GeodePrivFree()">GeodePrivFree()</A></CODE>
; see the entry for that routine for full information.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
thread.h</STRONG>
 </P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_35.htm#IX_GeodePrivFree()">GeodePrivFree()</A></CODE>.</P>
</DIV>
<HR>
<A NAME="R_98.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_98.htm_IX_ThreadPSem()">
 </A>
<H1 CLASS="refHeading">
ThreadPSem()</H1>
<PRE CLASS="syntax">SemaphoreError ThreadPSem(
        SemaphoreHandle sem);				/* semaphore to grab */</PRE>
<P>
This routine attempts to grab the passed semaphore via a &quot;P&quot; operation. If the semaphore has already been grabbed, the thread will block until the semaphore becomes available, even if it was grabbed by the same thread.</P>
<P>
<CODE>
ThreadPSem()</CODE>
 returns an error code of type <CODE>
SemaphoreError</CODE>
. The error code is intended to indicate abnormal return by the previous thread; if the semaphore never becomes available, the thread will block indefinitely and the routine will not return.</P>
<P CLASS="refField"><STRONG>
Be Sure To:</STRONG>	When the thread no longer needs the semaphore, it should release it with <CODE>
<A HREF="../../CRef/Routines/R_98.htm#IX_ThreadVSem()">ThreadVSem()</A></CODE>
.</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	This routine provides no deadlock protection. If threads will grab multiple common semaphores, they should always grab/release them in the same order, minimizing the chances for deadlock.</P>
<P>
A thread may not try to grab a particular semaphore twice without releasing it in between grabs. The thread will block on itself and will deadlock. If a thread may need to grab the semaphore twice in a row, it should use a thread lock instead (see <CODE>
<A HREF="../../CRef/Routines/R_95.htm#IX_ThreadAllocThreadLock()">ThreadAllocThreadLock()</A></CODE>
 for more information).</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
sem.h</STRONG>
 </P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_95.htm#IX_ThreadAllocSem()">ThreadAllocSem()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_98.htm#IX_ThreadVSem()">ThreadVSem()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_96.htm#IX_ThreadFreeSem()">ThreadFreeSem()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_98.htm#IX_ThreadPTimedSem()">ThreadPTimedSem()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_98.htm_IX_ThreadPTimedSem()">
 </A>
<H1 CLASS="refHeading">
ThreadPTimedSem()</H1>
<PRE CLASS="syntax">SemaphoreError ThreadPTimedSem(
        SemaphoreHandle		sem,				/* semaphore to grab */
        word		timeout);				/* ticks before timeout */</PRE>
<P>
This routine attempts to grab the passed semaphore via a &quot;P&quot; operation. If the semaphore has already been grabbed, the thread will block for at most the number of ticks specified in <CODE>
timeout</CODE>
.</P>
<P>
Often <CODE>
timeout</CODE>
 is passed as zero to indicate that if the semaphore isn't available right now, the thread will go on with some other action.</P>
<P CLASS="refField"><STRONG>
Be Sure To:</STRONG>	When the thread no longer needs the semaphore, it should release it with <CODE>
<A HREF="../../CRef/Routines/R_98.htm#IX_ThreadVSem()">ThreadVSem()</A></CODE>
.</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	This routine provides no deadlock protection. If threads will grab multiple common semaphores, they should always grab/release them in the same order, minimizing the chances for deadlock.</P>
<P>
A thread may not try to grab a particular semaphore twice without releasing it in between grabs. The thread will block on itself and will deadlock. If a thread may need to grab the semaphore twice in a row, it should use a thread lock instead, though there is no timeout equivalent for thread locks (see <CODE>
<A HREF="../../CRef/Routines/R_95.htm#IX_ThreadAllocThreadLock()">ThreadAllocThreadLock()</A></CODE>
 for more information).</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
sem.h</STRONG>
 </P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_95.htm#IX_ThreadAllocSem()">ThreadAllocSem()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_98.htm#IX_ThreadPSem()">ThreadPSem()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_98.htm#IX_ThreadVSem()">ThreadVSem()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_96.htm#IX_ThreadFreeSem()">ThreadFreeSem()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_98.htm_IX_ThreadReleaseThreadLock()">
 </A>
<H1 CLASS="refHeading">
ThreadReleaseThreadLock()</H1>
<PRE CLASS="syntax">void	ThreadReleaseThreadLock(
        ThreadLockHandle sem);				/* threadlock to release */</PRE>
<P>
This routine releases the specified thread lock previously grabbed with <CODE>
<A HREF="../../CRef/Routines/R_97.htm#IX_ThreadGrabThreadLock()">ThreadGrabThreadLock()</A></CODE>
. Pass the handle of the thread lock as returned by <CODE>
<A HREF="../../CRef/Routines/R_95.htm#IX_ThreadAllocThreadLock()">ThreadAllocThreadLock()</A></CODE>
.</P>
<P>
Do not try to release a thread lock that has not previously been grabbed. The results are unpredictable.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
sem.h</STRONG>
 </P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_95.htm#IX_ThreadAllocThreadLock()">ThreadAllocThreadLock()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_97.htm#IX_ThreadGrabThreadLock()">ThreadGrabThreadLock()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_98.htm_IX_ThreadVSem()">
 </A>
<H1 CLASS="refHeading">
ThreadVSem()</H1>
<PRE CLASS="syntax">void	ThreadVSem(
        SemaphoreHandle sem);				/* semaphore to release */</PRE>
<P>
This routine releases a semaphore that was grabbed with <CODE>
<A HREF="../../CRef/Routines/R_98.htm#IX_ThreadPSem()">ThreadPSem()</A></CODE>
 or <CODE>
<A HREF="../../CRef/Routines/R_98.htm#IX_ThreadPTimedSem()">ThreadPTimedSem()</A></CODE>
. Pass the handle of the semaphore as returned by <CODE>
<A HREF="../../CRef/Routines/R_95.htm#IX_ThreadAllocSem()">ThreadAllocSem()</A></CODE>
.</P>
<P>
Do not try to release a semaphore that has not previously been grabbed with one of the above routines. The results are unpredictable.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
sem.h</STRONG>
 </P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_95.htm#IX_ThreadAllocSem()">ThreadAllocSem()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_98.htm#IX_ThreadPSem()">ThreadPSem()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_96.htm#IX_ThreadFreeSem()">ThreadFreeSem()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_98.htm#IX_ThreadPTimedSem()">ThreadPTimedSem()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_98.htm_IX_TimerGetCount()">
 </A>
<H1 CLASS="refHeading">
TimerGetCount()</H1>
<PRE CLASS="syntax">dword	TimerGetCount();</PRE>
<P>
This routine returns the value of the system counter. The returned value is the number of ticks since GEOS started.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
timer.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_98.htm_IX_TimerGetDateAndTime()">
 </A>
<H1 CLASS="refHeading">
TimerGetDateAndTime()</H1>
<PRE CLASS="syntax">void	TimerGetDateAndTime(
        TimerDateAndTime * dateAndTime);						/* buffer for returned values */</PRE>
<P>
This routine returns the current time and date. Pass it a pointer to an empty <CODE>
TimerDateAndTime</CODE>
 structure to be filled in by the routine.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
timedate.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_98.htm_IX_TimerGetFileDateTime()">
 </A>
<H1 CLASS="refHeading">
TimerGetFileDateTime()</H1>
<PRE CLASS="syntax">TimerFileDateTime TimerGetFileDateTime();</PRE>
<P>
This routine returns the current time and date in a structure equivalent to a <CODE>
FileDateAndTime</CODE>
. As such, it is useful for constructing time stamps for files.</P>
</DIV>
<DIV>
<A NAME="R_98.htm_IX_TimerSetDateAndTime()">
 </A>
<H1 CLASS="refHeading">
TimerSetDateAndTime()</H1>
<PRE CLASS="syntax">void	TimerSetDateAndTime(
        word			flags,					/* which item to set */
        const TimerDateAndTime			* dateAndTime);					/* new values */</PRE>
<P>
This routine sets the current date and/or time of the system. Pass it the following:</P>
<DL>
<DT>
<CODE>
flags</CODE>
</DT><DD>A word of flags. Pass TIME_SET_DATE to set the day, month, and year; pass TIME_SET_TIME to set the hour, minute, and second. Pass both to set both.</DD>
<DT>
<CODE>
dateAndTime</DT><DD>
</CODE>
A pointer to a <CODE>
TimerDateAndTime</CODE>
 structure containing the information to be set.</DD>
</DL>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
timedate.h</STRONG>
 </P>
</DIV>
<HR>
<A NAME="R_99.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_99.htm_IX_TimerSleep()">
 </A>
<H1 CLASS="refHeading">
TimerSleep()</H1>
<PRE CLASS="syntax">void	TimerSleep(
        word	ticks);		/* number of ticks the thread should sleep */</PRE>
<P>
This routine invokes a &quot;sleep timer&quot; that will put the calling thread to sleep for the given number of ticks. At the end of the time, the thread will continue executing with the next instruction.</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	Do not use sleep timers as a substitute for semaphores for thread synchronization.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
timer.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_99.htm_IX_TimerStart()">
 </A>
: <A NAME="R_99.htm_IX_TimerType">
 </A>
<A NAME="R_99.htm_IX_TIMER_&ldots;">
 </A>
<A NAME="R_99.htm_IX_Power management:waking up by timer">
 </A>
<H1 CLASS="refHeading">
TimerStart()</H1>
<PRE CLASS="syntax">TimerHandle TimerStart(
        TimerType		timerType,				/* type of timer to start */
        optr		destObject,				/* object to receive notification
						 * message when timer expires */</PRE>
<PRE CLASS="syntax">        word		ticks,				/* amount of time to run */
        Message		msg,				/* notification message */
        word		interval,				/* interval for continual timers */
        word		* id);				/* buffer for returned timer ID */</PRE>
<P>
This routine starts a timer of any type. The timer will run for the specified number of ticks and then will send the given message to the destination object. The message is sent with the flags MF_FORCE_QUEUE, MF_CHECK_DUPLICATE and MF_REPLACE, so it will always be put in the recipient's queue and will always replace any duplicates already in the queue. Pass this routine the following:</P>
<DL>
<DT>
<CODE>
timerType</CODE>
</DT><DD>A value of <CODE>
TimerType</CODE>
 indicating the type of timer to start.</DD>
<DT>
<CODE>
destObject</CODE>
</DT><DD>The optr of the object that will be sent the specified message when the time is up.</DD>
<DT>
<CODE>
ticks</CODE>
</DT><DD>The number of ticks for the timer to run. (Sixty ticks equals one second.) For continual timers, this is the amount of time before the first timeout.</DD>
<DT>
<CODE>
msg</CODE>
</DT><DD>The message to be sent to the destination object when time is up.</DD>
<DT>
<CODE>
interval</CODE>
</DT><DD>For continual timers, the interval (number of ticks) at which to send out the message to the destination object. The timer will send the message once at the end of each interval. The first message will be sent <CODE>
ticks</CODE>
 ticks after the timer is started. The second message will be sent <CODE>
interval</CODE>
 ticks after that.</DD>
<DT>
<CODE>
id</CODE>
</DT><DD>A pointer to a word in which the timer's ID will be returned. You will need this ID for <CODE>
<A HREF="../../CRef/Routines/R_99.htm#IX_TimerStop()">TimerStop()</A></CODE>
.</DD>
</DL>
<P>
This routine returns the handle of the timer as well as an ID pointed to by the <CODE>
id</CODE>
 parameter. You will need the handle and the ID for <CODE>
<A HREF="../../CRef/Routines/R_99.htm#IX_TimerStop()">TimerStop()</A></CODE>
.</P>
<P CLASS="refField"><STRONG>
Structures:</STRONG>	
</P>
<P>
<CODE>
TimerType</CODE>
The <CODE>
TimerType</CODE>
 enumerated type defines what type of timer should be initiated. It has the following values:</P>
<DL>
<DT>
TIMER_ROUTINE_ONE_SHOT</DT><DD>
Start a timer that will call a routine and then free itself when the time is expired. This type is supported in assembly but not in C.</DD>
<DT>
TIMER_ROUTINE_CONTINUAL</DT><DD>
Start a timer that will call a routine once per time <EM>interval </EM>(starting after <EM>ticks</EM> ticks) until <CODE>
<A HREF="../../CRef/Routines/R_99.htm#IX_TimerStop()">TimerStop()</A></CODE>
 is called. </DD>
<DT>
TIMER_EVENT_ONE_SHOT</DT><DD>
Start a timer that will send a message to a given object, then free itself when time is expired.</DD>
<DT>
TIMER_EVENT_CONTINUAL</DT><DD>
Start a timer that will send a message to a given object once per time <EM>interval</EM> (starting after <EM>ticks</EM> ticks) until <CODE>
<A HREF="../../CRef/Routines/R_99.htm#IX_TimerStop()">TimerStop()</A></CODE>
 is called.</DD>
<DT>
TIMER_MS_ROUTINE_ONE_SHOT</DT><DD>
Start a timer that has millisecond accuracy. For this timer, the number of ticks will actually be the number of milliseconds. The timer will call a specified routine and then free itself when time is expired. This type is supported in assembly but not in C.</DD>
<DT>
TIMER_EVENT_REAL_TIME</DT><DD>
Start a timer that will call a routine at some particular date and time. On devices that support such a timer, this event will wake a sleeping machine.</DD>
</DL>
<P CLASS="refField"><STRONG>
Include:</STRONG>	timer.h</P>
</DIV>
<DIV>
<A NAME="R_99.htm_IX_TimerStop()">
 </A>
<H1 CLASS="refHeading">
TimerStop()</H1>
<PRE CLASS="syntax">Boolean	TimerStop(
        TimerHandle		th,			/* handle of timer to be stopped */
        word		id);			/* timer ID (returned by TimerStart() */</PRE>
<P>
This routine stops and destroys a timer that had been started with <CODE>
<A HREF="../../CRef/Routines/R_99.htm#IX_TimerStart()">TimerStart()</A></CODE>
. Pass it the timer handle and the ID as returned by that routine (the ID of a continual timer will always be zero).</P>
<P>
The returned error flag will be <CODE>
true</CODE>
 if the timer could not be found.</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	If you call <CODE>
TimerStop()</CODE>
 to stop a continual timer that sends its message across threads, there may be timer events left in the recipient's event queue. It is unsafe in this situation to assume that all timer events have been handled. To ensure the timer message has been handled, you can send the destination an &quot;all-safe&quot; message with the MF_FORCE_QUEUE flag.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
timer.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_99.htm_IX_TocDBLock()">
 </A>
<H1 CLASS="refHeading">
TocDBLock()</H1>
<PRE CLASS="syntax">void * TocDBLock(
        DBGroupAndItem 		thing);</PRE>
<P>
Use this routine to lock a name array maintained by a PrefTocList object.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
config.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_99.htm_IX_TocDBLockGetRef()">
 </A>
<H1 CLASS="refHeading">
TocDBLockGetRef()</H1>
<PRE CLASS="syntax">void * TocDBLockGetRef(
        DBGroupAndItem 		thing,
        optr		*refPtr);</PRE>
<P>
This routine locks a name array maintained by a PrefTocList object, returning the item's pointer and optr.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
config.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_99.htm_IX_TocFindCategory()">
 </A>
<H1 CLASS="refHeading">
TocFindCategory()</H1>
<PRE CLASS="syntax">Boolean TocFindCategory(
        TocCategoryStruct 		*cat);</PRE>
<P>
This routine searches a PrefTocList object's name lists for a given token.</P>
<P CLASS="refField"><STRONG>
Structures:</STRONG>	</P>
<PRE CLASS="syntax">        typedef struct {
        	TokenChars 		TCS_tokenChars;
        	DBGroupAndItem 		TCS_files; 					/* file name array */
        	DBGroupAndItem 		TCS_devices; 					/* device name array--only if
        								 * TCF_EXTENDED_DEVICE_DRIVERS
        								 * is set. */
        } TocCategoryStruct;</PRE>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
config.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_99.htm_IX_TocGetFileHandle()">
 </A>
<H1 CLASS="refHeading">
TocGetFileHandle()</H1>
<PRE CLASS="syntax">word TocGetFileHandle();</PRE>
<P>
Use this routine to get the handle of the file used by PrefTocLists to store their name array data.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
config.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_99.htm_IX_TocNameArrayAdd()">
 </A>
<H1 CLASS="refHeading">
TocNameArrayAdd()</H1>
<PRE CLASS="syntax">word TocNameArrayAdd(
        DBGroupAndItem 		array, 
        const char 		*nameToFind,
        const void 		*data);</PRE>
<P>
Use this routine to add a name to a name array maintained by a PrefTocList object.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
config.h</STRONG>
 </P>
</DIV>
<HR>
<A NAME="R_9a.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_9a.htm_IX_TocNameArrayFind()">
 </A>
<H1 CLASS="refHeading">
TocNameArrayFind()</H1>
<PRE CLASS="syntax">word TocNameArrayGetElement(
        DBGroupAndItem 		array, 
        word 		element,
        void 		*buffer);</PRE>
<P>
Use this routine to find a name in the name list maintained by a PrefTocList object.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
config.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_9a.htm_IX_TocNameArrayGetElement()">
 </A>
<H1 CLASS="refHeading">
TocNameArrayGetElement()</H1>
<PRE CLASS="syntax">word TocNameArrayGetElement(
        DBGroupAndItem 		array, 
        word 		element,
        void 		*buffer);</PRE>
<P>
Use this routine to retrieve a given element from a name array maintained by a PrefTocList object. </P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
config.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_9a.htm_IX_TocSortedNameArrayAdd()">
 </A>
<H1 CLASS="refHeading">
TocSortedNameArrayAdd()</H1>
<PRE CLASS="syntax">word TocSortedNameArrayAdd(
        word 		arr, 
        const char 		*nameToAdd,
        NameArrayAddFlags 		flags,
        const void 		*data);</PRE>
<P>
This routine adds a name to a sorted name array associated with a PrefTocList object. </P>
<P CLASS="refField"><STRONG>
Structures:</STRONG>	</P>
<PRE CLASS="syntax">        typedef WordFlags NameArrayAddFlags;
        #define NAAF_SET_DATA_ON_REPLACE 0x8000</PRE>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
config.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_9a.htm_IX_TocSortedNameArrayFind()">
 </A>
<A NAME="R_9a.htm_IX_SortedNameArrayAddFlags">
 </A>
<A NAME="R_9a.htm_IX_SNAAF_&ldots;">
 </A>
<H1 CLASS="refHeading">
TocSortedNameArrayFind()</H1>
<PRE CLASS="syntax">Boolean TocSortedNameArrayFind(
        word 				arr, 
        const char 				*nameToFind,
        SortedNameArrayFindFlags 				flags,
        void 				*buffer, 
        word 				*elementNum);</PRE>
<P>
This routine looks up a name in a sorted name array associated with a PrefTocList object.</P>
<P CLASS="refField"><STRONG>
Structures:</STRONG>	</P>
<PRE CLASS="syntax">        typedef WordFlags SortedNameArrayFindFlags;
        #define SNAFF_IGNORE_CASE 0x0080</PRE>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
config.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_9a.htm_IX_TocUpdateCategory()">
 </A>
<A NAME="R_9a.htm_IX_TocUpdateCategoryParams()">
 </A>
<A NAME="R_9a.htm_IX_TUCP_&ldots;">
 </A>
<A NAME="R_9a.htm_IX_TocUpdateAddCallback() prototype">
 </A>
<H1 CLASS="refHeading">
TocUpdateCategory()</H1>
<PRE CLASS="syntax">void TocUpdateCategory(
        TocUpdateCategoryParams *params);</PRE>
<P>
Use this routine to update a PrefTocList object based upon the files in a given directory with a given token.</P>
<P CLASS="refField"><STRONG>
Structures:</STRONG>	</P>
<PRE CLASS="syntax">        typedef struct {
        	TocUpdateCategoryFlags 				TUCP_flags;
        	TokenChars 				TUCP_tokenChars;
        	byte 				TUCP_fileArrayElementSize;
        &nbsp;
        	TocUpdateAddCallback 				*TUCP_addCallback;
        	byte 				TUCP_pad; /* Wants to be word-aligned */
        } TocUpdateCategoryParams;
        &nbsp;
        typedef word _pascal TocUpdateAddCallback(
        	const char *filename,
        	optr chunkArray);
        /* Return 0 if add aborted, else return offset of new element within
         * block */
        &nbsp;</PRE>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
config.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_9a.htm_IX_TOKEN_CHARS() macro">
 </A>
<H1 CLASS="refHeading">
TOKEN_CHARS()</H1>
<PRE CLASS="syntax">dword	TOKEN_CHARS(<EM>a</EM>, <EM>b</EM>, <EM>c</EM>, <EM>d</EM>)</PRE>
<P>
This macro creates a single dword value from four given characters. This is useful when creating a token characters value for a specific token. The first two characters passed may be chars, the second two should be cast to dwords. A simple example:</P>
<PRE>TOKEN_CHARS(`S', `A', (dword) `M', (dword) `P');</PRE>
</DIV>
<DIV>
<A NAME="R_9a.htm_IX_TokenCloseLocalTokenDB()">
 </A>
<H1 CLASS="refHeading">
TokenCloseLocalTokenDB()</H1>
<PRE CLASS="syntax">void	TokenCloseLocalTokenDB()</PRE>
<P>
This routine closes the local token database.</P>
</DIV>
<HR>
<A NAME="R_9b.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_9b.htm_IX_TokenDefineToken()">
 </A>
<H1 CLASS="refHeading">
TokenDefineToken()</H1>
<PRE CLASS="syntax">word	TokenDefineToken(
        dword		tokenChars,					/* four token characters */
        ManufacturerID		manufacturerID,					/* manufacturer ID for token */
        optr		monikerList,					/* optr of moniker list */
        TokenFlags		flags);					/* token flags */</PRE>
<P>
This routine adds a new token and moniker list to the token database. If the token already exists in the token DB, the old will be replaced with the new. This routine must only be called by a thread that can lock the block in which the passed moniker or moniker list resides. This routine must be passed the following parameters:</P>
<DL>
<DT>
<CODE>
tokenChars</CODE>
</DT><DD>The four token characters that identify this moniker or moniker list in the token database. Create this dword value from the four characters with the macro TOKEN_CHARS.</DD>
<DT>
<CODE>
manufacturerID</DT><DD>
</CODE>
The manufacturer ID number of the manufacturer responsible for the token database entry.</DD>
<DT>
<CODE>
monikerList</DT><DD>
</CODE>
The optr of the moniker list to be added to the token database.</DD>
<DT>
<CODE>
flags</CODE>
</DT><DD>A record of <CODE>
TokenFlags</CODE>
 indicating the relocation status of the moniker list.</DD>
</DL>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	This routine may legally move locked LMem blocks (token database items), thereby invalidating all pointers to token database items.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
token.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_9b.htm_IX_TokenGetTokenInfo()">
 </A>
<H1 CLASS="refHeading">
TokenGetTokenInfo()</H1>
<PRE CLASS="syntax">Boolean	TokenGetTokenInfo(
        dword		tokenChars,					/* four characters of token */
        ManufacturerID		manufacturerID,					/* manufacturer ID of token */
        TokenFlags		* flags);					/* returned token flags */</PRE>
<P>
This routine returns information about a specified token. Pass it the following:</P>
<DL>
<DT>
<CODE>
tokenChars</CODE>
</DT><DD>The four token characters that identify the token database entry. Create this dword from the four characters with the macro TOKEN_CHARS.</DD>
<DT>
<CODE>
manufacturerID</DT><DD>
</CODE>
The manufacturer ID number of the manufacturer responsible for the token database entry.</DD>
<DT>
<CODE>
flags</CODE>
</DT><DD>A pointer to an empty flags record; the flags set (if any) for the specified token (if it exists) will be returned here.</DD>
</DL>
<P>
This routine returns a non-zero value if the token was found in the token database. It returns zero if the token was not found.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
token.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_9b.htm_IX_TokenListTokens()">
 </A>
<H1 CLASS="refHeading">
TokenListTokens()</H1>
<PRE CLASS="syntax">dword	TokenListTokens(
        TokenRangeFlags 		tokenRangeFlags,
        word 		headerSize,
        ManufacturerID 		manufacturerID));</PRE>
<P>
This routine lists all the tokens in the token database. It allocates a new block on the global heap and writes in it an array of <CODE>
GeodeToken</CODE>
 structures. This routine returns the actual tokens, not the token groups.</P>
<P>
The returned dword consists of two values: The high word represents the number of tokens in the returned block and may be extracted with the macro <CODE>
<A HREF="../../CRef/Routines/R_9b.htm#IX_TokenListTokensCountFromDWord()">TokenListTokensCountFromDWord()</A></CODE>
. The low word represents the handle of the newly-allocated block and can be extracted with the macro <CODE>
<A HREF="../../CRef/Routines/R_9b.htm#IX_TokenListTokensHandleFromDWord()">TokenListTokensHandleFromDWord()</A></CODE>
.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
token.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_9b.htm_IX_TokenListTokensCountFromDWord()">
 </A>
<H1 CLASS="refHeading">
TokenListTokensCountFromDWord()</H1>
<PRE CLASS="syntax">word	TokenListTokensCountFromDWord(<EM>d</EM>);
        dword	<EM>d</EM>;</PRE>
<P>
This macro extracts the number of tokens from the value returned by <CODE>
<A HREF="../../CRef/Routines/R_9b.htm#IX_TokenListTokens()">TokenListTokens()</A></CODE>
.</P>
</DIV>
<DIV>
<A NAME="R_9b.htm_IX_TokenListTokensHandleFromDWord()">
 </A>
<H1 CLASS="refHeading">
TokenListTokensHandleFromDWord()</H1>
<PRE CLASS="syntax">word	TokenListTokensHandleFromDWord(<EM>d</EM>);
        dword	<EM>d</EM>;</PRE>
<P>
This routine extracts the MemHandle from the value returned by <CODE>
<A HREF="../../CRef/Routines/R_9b.htm#IX_TokenListTokens()">TokenListTokens()</A></CODE>
.</P>
</DIV>
<DIV>
<A NAME="R_9b.htm_IX_TokenLoadMonikerBlock()">
 </A>
<H1 CLASS="refHeading">
TokenLoadMonikerBlock()</H1>
<PRE CLASS="syntax">Boolean	TokenLoadMonikerBlock(
        dword		tokenChars,					/* four characters of token */
        ManufacturerID		manufacturerID,					/* manufacturer ID of token */
        DisplayType		displayType,					/* type of display for token */
        VisMonikerSearchFlags searchFlags,							/* flags for finding token */
        word		* blockSize,					/* returned block size */
        MemHandle		* blockHandle);					/* returned block handle */</PRE>
<P>
This routine loads a specified token's moniker, allocating a new global memory block for the moniker. The returned Boolean will be <CODE>
false</CODE>
 if the moniker was found, <CODE>
true</CODE>
 otherwise. Information about the moniker is returned in the values pointed to by <CODE>
blockSize</CODE>
 (the size of the newly allocated block) and <CODE>
blockHandle</CODE>
 (the handle of the new block). If the moniker is not found, both return pointers will be NULL and no block will be allocated.</P>
<P>
Pass this routine the following:</P>
<DL>
<DT>
<CODE>
tokenChars</CODE>
</DT><DD>The four token characters that identify the token database entry. Create this dword from the four characters with the macro TOKEN_CHARS.</DD>
<DT>
<CODE>
manufacturerID</DT><DD>
</CODE>
The manufacturer ID number of the manufacturer responsible for the token database entry.</DD>
<DT>
<CODE>
displayType</DT><DD>
</CODE>
A value of <CODE>
DisplayType</CODE>
 indicating the size of the display (used to indicate small-screen devices, primarily).</DD>
<DT>
<CODE>
searchFlags</DT><DD>
</CODE>
A record of <CODE>
VisMonikerSearchFlags</CODE>
 indicating what type of moniker is being requested.</DD>
<DT>
<CODE>
blockSize</CODE>
</DT><DD>A pointer to a word in which the new block's size will be returned.</DD>
<DT>
<CODE>
blockHandle</DT><DD>
</CODE>
A pointer to a handle in which the new block's handle will be returned.</DD>
</DL>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
token.h</STRONG>
 </P>
</DIV>
<HR>
<A NAME="R_9c.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_9c.htm_IX_TokenLoadMonikerBuffer()">
 </A>
<H1 CLASS="refHeading">
TokenLoadMonikerBuffer()</H1>
<PRE CLASS="syntax">Boolean	TokenLoadMonikerBuffer(
        dword		tokenChars,					/* four characters of token */
        ManufacturerID		manufacturerID,					/* manufacturer ID of token */
        DisplayType		displayType,					/* type of display for token */
        VisMonikerSearchFlags searchFlags,							/* flags for finding token */
        void		* buffer,					/* pointer to buffer for token */
        word		bufSize,					/* size of passed buffer */
        word		* bytesReturned);						/* number of bytes returned */</PRE>
<P>
This routine loads a specified token's moniker into a provided buffer. The return value will be <CODE>
false</CODE>
 if the moniker was found, <CODE>
true</CODE>
 otherwise. The size of the returned moniker will be returned in the word pointed to by the <CODE>
bytesReturned</CODE>
 parameter.</P>
<P>
Pass this routine the following:</P>
<DL>
<DT>
<CODE>
tokenChars</CODE>
</DT><DD>The four token characters that identify the token database entry. Create this dword from the four characters with the macro TOKEN_CHARS.</DD>
<DT>
<CODE>
manufacturerID</DT><DD>
</CODE>
The manufacturer ID number of the manufacturer responsible for the token database entry.</DD>
<DT>
<CODE>
displayType</DT><DD>
</CODE>
A value of <CODE>
DisplayType</CODE>
 indicating the size of the display (used to indicate small-screen devices, primarily).</DD>
<DT>
<CODE>
searchFlags</DT><DD>
</CODE>
A record of <CODE>
VisMonikerSearchFlags</CODE>
 indicating what type of moniker is being requested.</DD>
<DT>
<CODE>
buffer</CODE>
</DT><DD>A pointer to a locked or fixed buffer into which the moniker will be copied.</DD>
<DT>
<CODE>
bufSize</CODE>
</DT><DD>The size of the passed buffer; also the maximum size of the moniker that may be returned.</DD>
<DT>
<CODE>
bytesReturned</DT><DD>
</CODE>
The size of the moniker actually returned in the buffer.</DD>
</DL>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
token.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_9c.htm_IX_TokenLoadMonikerChunk()">
 </A>
<H1 CLASS="refHeading">
TokenLoadMonikerChunk()</H1>
<PRE CLASS="syntax">Boolean	TokenLoadMonikerChunk(
        dword		tokenChars,					/* four characters of token */
        ManufacturerID		manufacturerID,					/* manufacturer ID of token */
        DisplayType		displayType,					/* type of display for token */
        VisMonikerSearchFlags searchFlags,							/* flags for finding token */
        MemHandle		lmemBlock,					/* locked block for new chunk */
        word		* chunkSize,					/* returned new chunk size */
        ChunkHandle		* chunkHandle);					/* returned new chunk handle */</PRE>
<P>
This routine loads a specified token's moniker, allocating a new chunk in a local memory block for the moniker. The returned error flag will be <CODE>
true</CODE>
 if the moniker was not found, <CODE>
false</CODE>
 otherwise.</P>
<P>
Pass this routine the following:</P>
<DL>
<DT>
<CODE>
tokenChars</CODE>
</DT><DD>The four token characters that identify the token database entry. Create this dword from the four characters with the macro TOKEN_CHARS.</DD>
<DT>
<CODE>
manufacturerID</DT><DD>
</CODE>
The manufacturer ID number of the manufacturer responsible for the token database entry.</DD>
<DT>
<CODE>
displayType</DT><DD>
</CODE>
A value of <CODE>
DisplayType</CODE>
 indicating the size of the display (used to indicate small-screen devices, primarily).</DD>
<DT>
<CODE>
searchFlags</DT><DD>
</CODE>
A record of <CODE>
VisMonikerSearchFlags</CODE>
 indicating what type of moniker is being requested.</DD>
<DT>
<CODE>
lmemBlock</CODE>
</DT><DD>The MemHandle of the local memory block in which the new chunk will be allocated. If the block is locked, you must dereference the global handle after calling this routine.</DD>
<DT>
<CODE>
chunkSize</CODE>
</DT><DD>A pointer to a word in which the size of the allocated chunk will be returned.</DD>
<DT>
<CODE>
chunkhandle</DT><DD>
</CODE>
A pointer to a chunk handle in which the handle of the newly allocated chunk will be returned.</DD>
</DL>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	This routine can move chunks in the passed block, thereby invalidating pointers to any chunk in the block.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
token.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_9c.htm_IX_TokenLoadTokenBlock()">
 </A>
<H1 CLASS="refHeading">
TokenLoadTokenBlock()</H1>
<PRE CLASS="syntax">Boolean	TokenLoadTokenBlock(
        dword		tokenChars,					/* four characters of token */
        ManufacturerID		manufacturerID,					/* manufacturer ID of token */
        word		* blockSize,					/* returned size of new block */
        MemHandle		* blockHandle);					/* returned handle of block */</PRE>
<P>
This routine loads the specified token's <CODE>
TokenEntry</CODE>
 structure into a newly-allocated global memory block. If the token is not found, the returned error flag will be <CODE>
true</CODE>
; otherwise, it will be <CODE>
false</CODE>
.</P>
<P>
Pass this routine the following:</P>
<DL>
<DT>
<CODE>
tokenChars</CODE>
</DT><DD>The four token characters that identify the token database entry. Create this dword from the four characters with the macro TOKEN_CHARS.</DD>
<DT>
<CODE>
manufacturerID</DT><DD>
</CODE>
The manufacturer ID number of the manufacturer responsible for the token database entry.</DD>
<DT>
<CODE>
blockSize</CODE>
</DT><DD>A pointer to a word in which the size of the newly-allocated block will be returned.</DD>
<DT>
<CODE>
blockHandle</DT><DD>
</CODE>
A pointer to a global handle in which the handle of the newly-allocated block will be returned.</DD>
</DL>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
token.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_9c.htm_IX_TokenLoadTokenBuffer()">
 </A>
<H1 CLASS="refHeading">
TokenLoadTokenBuffer()</H1>
<PRE CLASS="syntax">Boolean	TokenLoadTokenBuffer(
        dword		tokenChars,					/* four characters of token */
        ManufacturerID		manufacturerID,					/* manufacturer ID of token */
        TokenEntry		* buffer);					/* buffer for returned token */</PRE>
<P>
This routine loads the specified token's <CODE>
TokenEntry</CODE>
 structure into a passed buffer. The returned error flag will be <CODE>
true</CODE>
 if the token was not found, <CODE>
false</CODE>
 otherwise. Pass this routine the following:</P>
<DL>
<DT>
<CODE>
tokenChars</CODE>
</DT><DD>The four token characters that identify the token database entry. Create this dword from the four characters with the macro TOKEN_CHARS.</DD>
<DT>
<CODE>
manufacturerID</DT><DD>
</CODE>
The manufacturer ID number of the manufacturer responsible for the token database entry.</DD>
<DT>
<CODE>
buffer</CODE>
</DT><DD>A pointer to a locked or fixed buffer into which the token entry will be copied.</DD>
</DL>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
token.h</STRONG>
 </P>
</DIV>
<HR>
<A NAME="R_9d.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_9d.htm_IX_TokenLoadTokenChunk()">
 </A>
<H1 CLASS="refHeading">
TokenLoadTokenChunk()</H1>
<PRE CLASS="syntax">Boolean	TokenLoadTokenChunk(
        dword		tokenChars,					/* four characters of token */
        ManufacturerID		manufacturerID,					/* manufacturer ID of token */
        MemHandle		lmemBlock,					/* handle of block for chunk */
        word		* chunkSize,					/* returned size of new chunk */
        ChunkHandle		* chunkHandle);					/* returned chunk handle */</PRE>
<P>
This routine loads the specified token's <CODE>
TokenEntry</CODE>
 structure into a newly-allocated chunk. The returned error flag will be <CODE>
true</CODE>
 if the token could not be found, <CODE>
false</CODE>
 otherwise.</P>
<P>
Pass this routine the following:</P>
<DL>
<DT>
<CODE>
tokenChars</CODE>
</DT><DD>The four token characters that identify the token database entry. Create this dword from the four characters with the macro TOKEN_CHARS.</DD>
<DT>
<CODE>
manufacturerID</DT><DD>
</CODE>
The manufacturer ID number of the manufacturer responsible for the token database entry.</DD>
<DT>
<CODE>
lmemBlock</CODE>
</DT><DD>The MemHandle of the local memory block in which the new chunk will be allocated. If the block is locked, you must manually dereference this handle after the routine call.</DD>
<DT>
<CODE>
chunksize</CODE>
</DT><DD>A pointer to a word in which the size of the newly-allocated chunk will be returned.</DD>
<DT>
<CODE>
chunkHandle</DT><DD>
</CODE>
A pointer to a chunk handle in which the handle of the newly-allocated chunk will be returned.</DD>
</DL>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	This routine can move chunks in the passed block, thereby invalidating pointers to any chunk in the block.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
token.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_9d.htm_IX_TokenLockTokenMoniker()">
 </A>
<H1 CLASS="refHeading">
TokenLockTokenMoniker()</H1>
<PRE CLASS="syntax">void	* TokenLockTokenMoniker(
        TokenMonikerInfo		tokenMonikerInfo);				/* The DB group and item numbers
        				 * as returned by TokenLookupMoniker() */</PRE>
<P>
This routine locks a token's moniker so it may be drawn; it returns a pointer to the locked chunk containing the moniker information. Pass it the structure returned by <CODE>
<A HREF="../../CRef/Routines/R_9d.htm#IX_TokenLookupMoniker()">TokenLookupMoniker()</A></CODE>
.</P>
<P CLASS="refField"><STRONG>
Be Sure To:</STRONG>	Unlock the moniker with <CODE>
<A HREF="../../CRef/Routines/R_9d.htm#IX_TokenUnlockTokenMoniker()">TokenUnlockTokenMoniker()</A></CODE>
 after you have finished drawing it.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
token.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_9d.htm_IX_TokenLookupMoniker()">
 </A>
<H1 CLASS="refHeading">
TokenLookupMoniker()</H1>
<PRE CLASS="syntax">Boolean	TokenLookupMoniker(
        dword		tokenChars,					/* four characters of token */
        ManufacturerID		manufacturerID,					/* manufacturer ID of token */
        DisplayType		displayType,					/* display type of token */
        VisMonikerSearchFlags searchFlags,							/* flags for finding token */
        TokenMonikerInfo *		tokenMonikerInfo);					/* DB group and item of token */</PRE>
<P>
This routine finds and retrieves a pointer to the specific moniker for the specified token, given also the token's display type and other attributes. Pass the following:</P>
<DL>
<DT>
<CODE>
tokenChars</CODE>
</DT><DD>The four token characters that identify this moniker or moniker list in the token database. Create this dword value from the four characters with the macro TOKEN_CHARS.</DD>
<DT>
<CODE>
manufacturerID</DT><DD>
</CODE>
The manufacturer ID number of the manufacturer responsible for the token database entry.</DD>
<DT>
<CODE>
displayType</DT><DD>
</CODE>
A value of <CODE>
DisplayType</CODE>
 indicating the size of the display (used to indicate small-screen devices, primarily).</DD>
<DT>
<CODE>
searchFlags</DT><DD>
</CODE>
A record of <CODE>
VisMonikerSearchFlags</CODE>
 indicating what type of moniker is being requested.</DD>
<DT>
<CODE>
tokenDBItem</DT><DD>
</CODE>
A pointer to an empty <CODE>
TokenMonikerInfo</CODE>
 structure, in which the token's group and item numbers will be returned.</DD>
</DL>
<P>
The return value is an error flag: it will be <CODE>
true</CODE>
 if the item could not be found in the token database, <CODE>
false</CODE>
 otherwise.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
token.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_9d.htm_IX_TokenOpenLocalTokenDB()">
 </A>
<H1 CLASS="refHeading">
TokenOpenLocalTokenDB()</H1>
<PRE CLASS="syntax">word	TokenOpenLocalTokenDB()</PRE>
<P>
This routine opens the local token database. It returns zero on success, and a <CODE>
VMStatus</CODE>
 error code on failure.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
token.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_9d.htm_IX_TokenRemoveToken()">
 </A>
<H1 CLASS="refHeading">
TokenRemoveToken</H1>
<PRE CLASS="syntax">Boolean	TokenRemoveToken(
        dword		tokenChars,					/* four characters of token */
        ManufacturerID		manufacturerID,					/* manufacturer ID of token */</PRE>
<P>
This routine removes the specified token and its moniker list from the token database. It returns an error flag: if the token could not be found, the returned flag is <CODE>
true</CODE>
; otherwise it is <CODE>
false</CODE>
. Pass the following:</P>
<DL>
<DT>
<CODE>
tokenChars</CODE>
</DT><DD>The four token characters that identify this moniker or moniker list in the token database. Create this dword value from the four characters with the macro TOKEN_CHARS.</DD>
<DT>
<CODE>
manufacturerID</DT><DD>
</CODE>
The manufacturer ID number of the manufacturer responsible for the token database entry.</DD>
</DL>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
token.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_9d.htm_IX_TokenUnlockTokenMoniker()">
 </A>
<H1 CLASS="refHeading">
TokenUnlockTokenMoniker()</H1>
<PRE CLASS="syntax">void	TokenUnlockTokenMoniker(
        void * moniker);</PRE>
<P>
This routine unlocks a moniker that had been locked with <CODE>
<A HREF="../../CRef/Routines/R_9d.htm#IX_TokenLockTokenMoniker()">TokenLockTokenMoniker()</A></CODE>
. Pass a pointer to the locked moniker, as returned by the locking routine.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
token.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_9d.htm_IX_ClipboardItemFormatID:TypeFromFormatID() macro">
 </A>
<A NAME="R_9d.htm_IX_TypeFromFormatID()">
 </A>
<H1 CLASS="refHeading">
TypeFromFormatID()</H1>
<PRE CLASS="syntax">word	TypeFromFormatID(id);
        ClipboardItemFormatID id;</PRE>
<P>
This macro extracts the word-sized format ID (of type <CODE>
ClipboardItemFormat</CODE>
) from a <CODE>
ClipboardFormatID</CODE>
 argument.</P>
</DIV>
<HR>
<A NAME="R_9e.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_9e.htm_IX_UserAllocObjBlock">
 </A>
<H1 CLASS="refHeading">
UserAllocObjBlock</H1>
<PRE CLASS="syntax">MemHandle 	UserAllocObjBlock(
        ThreadHandle 		threadHandle);</PRE>
<P>
This routine allocates a block of memory on the heap to be used for holding UI objects. It returns the handle of the block. It is passed one argument:</P>
<DL>
<DT>
<EM>threadHandle</EM> </DT><DD>
Handle of the thread which is to manage the block. Pass zero to use the current thread.</DD>
</DL>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
ui.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_9e.htm_IX_execOnStartup INI file field:UserAddAutoExec()">
 </A>
<A NAME="R_9e.htm_IX_UserAddAutoExec()">
 </A>
<H1 CLASS="refHeading">
UserAddAutoExec()</H1>
<PRE CLASS="syntax">void	UserAddAutoExec(
        const char *		appName);</PRE>
<P>
This routine adds an application to the list of those, like Welcome, that are automatically started by the UI when it loads. The application name will be added to the appropriate place in the GEOS.INI file. It is passed one argument:</P>
<DL>
<DT>
<CODE>
appName</CODE>
</DT><DD>This is a pointer to a null-terminated string containing the name of the application. The application must be in SP_APPLICATION or SP_SYS_APPLICATION.</DD>
</DL>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
ui.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_9e.htm_IX_UserCreateDialog()">
 </A>
<A NAME="R_9e.htm_IX_Dialog boxes:UserCreateDialog()">
 </A>
<H1 CLASS="refHeading">
UserCreateDialog()</H1>
<PRE CLASS="syntax">optr	UserCreateDialog(
        optr	dialogBox);</PRE>
<P>
This routine duplicates a template dialog box, attaches the dialog box to an application object, and sets it fully GS_USABLE so that it may be called with <CODE>
<A HREF="../../CRef/Routines/R_9e.htm#IX_UserDoDialog()">UserDoDialog()</A></CODE>
. Dialog boxes created in such a manner should be removed and destroyed with <CODE>
<A HREF="../../CRef/Routines/R_9e.htm#IX_UserDestroyDialog()">UserDestroyDialog()</A></CODE>
 when no longer needed.</P>
<DL>
<DT>
<EM>
dialogBox</EM>
</DT><DD>Optr to template dialog box (within a template object block). The block must be sharable, read-only and the top GenInteraction called with this routine must not be linked into any generic tree. The optr returned is a created, fully-usable dialog box.</DD>
</DL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_9e.htm#IX_UserDestroyDialog()">UserDestroyDialog()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_9e.htm_IX_InkDestinationInfo:UserCreateInkDestinationInfo()">
 </A>
<A NAME="R_9e.htm_IX_UserCreateInkDestinationInfo()">
 </A>
<A NAME="R_9e.htm_IX_GestureCallback() prototype">
 </A>
<H1 CLASS="refHeading">
UserCreateInkDestinationInfo()</H1>
<PRE CLASS="syntax">MemHandle 	UserCreateInkDestinationInfo(
        optr 		dest,
        GStateHandle 		gs,
        word		brushSize,
        GestureCallback		*callback);</PRE>
<P>
This routine creates an <CODE>
InkDestinationInfo</CODE>
 structure to be returned with MSG_META_QUERY_IF_PRESS_IS_INK. The callback routine must be declared _pascal.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
ui.goh</STRONG>
 </P>
<P CLASS="refField"><STRONG>
Structures:</STRONG>	</P>
<PRE CLASS="syntax">        typedef Boolean _pascal GestureCallback (
        	Point *arrayOfInkPoints, 
        	word numPoints, 
        	word numStrokes);</PRE>
</DIV>
<DIV>
<A NAME="R_9e.htm_IX_UserDestroyDialog()">
 </A>
<H1 CLASS="refHeading">
UserDestroyDialog()</H1>
<PRE CLASS="syntax">void	UserDestroyDialog(
        optr	dialogBox);</PRE>
<P>
This routine destroys the passed dialog box, usually created with <CODE>
<A HREF="../../CRef/Routines/R_9e.htm#IX_UserCreateDialog()">UserCreateDialog()</A></CODE>
. This routine may only be used to destroy dialog boxes occupying a single block; the block must also hold nothing other than the dialog box to be destroyed. It is for this reason that it is wise to only use this routine to destroy dialogs created with <CODE>
<A HREF="../../CRef/Routines/R_9e.htm#IX_UserCreateDialog()">UserCreateDialog()</A></CODE>
.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_9e.htm#IX_UserCreateDialog()">UserCreateDialog()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_9e.htm_IX_UserDoDialog()">
 </A>
<A NAME="R_9e.htm_IX_Dialog boxes:UserDoDialog()">
 </A>
<A NAME="R_9e.htm_IX_InteractionCommand">
 </A>
<A NAME="R_9e.htm_IX_IC_&ldots;">
 </A>
<H1 CLASS="refHeading">
UserDoDialog()</H1>
<PRE CLASS="syntax">InteractionCommand UserDoDialog(
        optr	dialogBox);</PRE>
<P>
<CODE>
UserDoDialog()</CODE>
 brings a pre-instantiated dialog box on-screen, blocking the calling thread until the user responds to the dialog. You must pass the optr of a GIV_DIALOG Interaction that is set both GIA_INITIATED_VIA_USER_DO_DIALOG and GIA_MODAL. </P>
<P>
This routine returns the <CODE>
InteractionCommand</CODE>
 of the particular response trigger selected by the user. This <CODE>
InteractionCommand</CODE>
 may be either a predefined type (such as IC_YES) or a custom one defined using IC_CUSTOM_START.</P>
<P>
The pre-defined <CODE>
InteractionCommand</CODE>
s are:</P>
<PRE>IC_NULL
IC_DISMISS
IC_APPLY
IC_RESET
IC_OK
IC_YES
IC_NO
IC_STOP
IC_EXIT
IC_HELP
IC_INTERACTION_COMPLETE</PRE>
<P>
This routine may return IC_NULL for those cases in which a system shutdown causes the dialog to be dismissed before the user has entered a response. </P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	This routine blocks the calling thread until the dialog box receives a MSG_GEN_GUP_INTERACTION_COMMAND. Since the application thread is blocked, it cannot be responsible for sending this message or for handling messages from the response triggers. </P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_9f.htm#IX_UserStandardDialog()">UserStandardDialog()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_9f.htm#IX_UserStandardDialogOptr()">UserStandardDialogOptr()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_9e.htm_IX_UserGetInterfaceLevel()">
 </A>
<A NAME="R_9e.htm_IX_UIInterfaceLevel">
 </A>
<A NAME="R_9e.htm_IX_UIIL_&ldots;">
 </A>
<H1 CLASS="refHeading">
UserGetInterfaceLevel()</H1>
<PRE CLASS="syntax">UIInterfaceLevel UserGetInterfaceLevel(void)</PRE>
<P>
This routine returns the current <CODE>
UIInterfaceLevel</CODE>
. This is a word-sized enumerated type. It has the following values:</P>
<PRE>UIIL_NOVICE
UIIL_BEGINNING_INTERMEDIATE
UIIL_ADVANCED_INTERMEDIATE
UIIL_ADVANCED
UIIL_GURU</PRE>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
ui.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_9e.htm_IX_UserLoadApplication()">
 </A>
<H1 CLASS="refHeading">
UserLoadApplication()</H1>
<PRE CLASS="syntax">extern GeodeHandle UserLoadApplication(
        AppLaunchFlags 		alf,
        Message 		attachMethod,
        MemHandle 		appLaunchBlock,
        char 		*filename,
        StandardPath 		sPath,
        GeodeLoadError 		*err);</PRE>
<P>
Loads an application.  Changes to standard application directory before attempting GeodeLoad on filename passed. Stores the filename being launched into the <CODE>
AppLaunchBlock</CODE>
, so that information needed to restore this application instance will be around later if needed.</P>
</DIV>
<HR>
<A NAME="R_9f.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_9f.htm_IX_UserRemoveAutoExec()">
 </A>
<A NAME="R_9f.htm_IX_execOnStartup INI file field:UserRemoveAutoExec()">
 </A>
<H1 CLASS="refHeading">
UserRemoveAutoExec()</H1>
<PRE CLASS="syntax">void	UserRemoveAutoExec(
        const char *		appName);</PRE>
<P>
This routine removes an application from the list of those to be launched on start-up. It is passed one argument:</P>
<DL>
<DT>
<CODE>
appName</CODE>
</DT><DD>This is a pointer to a null-terminated string containing the name of the application.</DD>
</DL>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
ui.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_9f.htm_IX_UserStandardDialog()">
 </A>
<A NAME="R_9f.htm_IX_Dialog boxes:UserStandardDialog()">
 </A>
<H1 CLASS="refHeading">
<A NAME="R_9f.htm_37754">
 </A>
UserStandardDialog()</H1>
<PRE CLASS="syntax">word	UserStandardDialog(
        char *			helpContext,
        char *			customTriggers,
        char *			arg2,
        char *			arg1,
        char *			string,
        CustomDialogBoxFlags 	dialogFlags);</PRE>
<P>
<CODE>
UserStandardDialog()</CODE>
 creates and displays either a custom dialog box or one of several pre-defined standard dialog boxes. </P>
<P>
Most often, you will use this routine to create a custom dialog box that conforms to a standardized dialog. In this case, pass the <CODE>
CustomDialogType</CODE>
 of SDBT_CUSTOM as the routine's final argument. You must then supply other parameters to create the custom dialog box.</P>
<P>
If instead you wish to use one of the pre-defined <CODE>
CustomDialogType </CODE>
types, you should pass that type as the final argument to this routine. Some of these standard types require you to pass string parameters. Other arguments should be passed as null.</P>
<P>
For custom dialog boxes you must pass a <CODE>
CustomDialogType</CODE>
 (CDT_WARNING, CDT_NOTIFICATION, CDT_QUESTION, or CDT_ERROR). This chooses the proper icon glyph to display within the dialog box. (For example, a CDT_WARNING dialog might contain a large exclamation-point glyph.) Make sure that you use CDBF_DIALOG_TYPE_OFFSET to pass this value. E.g.:</P>
<PRE>(GIT_AFFIRMATION &lt;&lt; CDBF_INTERACTION_TYPE_OFFSET) | (CDT_WARNING &lt;&lt; CDBF_DIALOG_TYPE_OFFSET)</PRE>
<P>
You should also pass a valid <CODE>
GenInteractionType</CODE>
. In most cases, this will be either GIT_NOTIFICATION, GIT_AFFIRMATION, or GIT_MULTIPLE_RESPONSE. Make sure that you use CDBF_INTERACTION_TYPE_OFFSET to pass this value. E.g.:</P>
<PRE>(GIT_AFFIRMATION &lt;&lt; CDBF_INTERACTION_TYPE_OFFSET) | (CDT_WARNING &lt;&lt; CDBF_DIALOG_TYPE_OFFSET)</PRE>
<P>
Also pass the routine a <CODE>
string</CODE>
 to display to the user. This <CODE>
string</CODE>
 may be either text or graphics based. The <CODE>
arg1</CODE>
 and <CODE>
arg2</CODE>
 strings may be used in conjunction with this string; if <CODE>
string</CODE>
 contains any ctrl-A or ctrl-B characters (ASCII value 1 and 2, respectively), then the string pointed to by <CODE>
arg1</CODE>
 or <CODE>
arg2</CODE>
 will be inserted in that place.</P>
<P>
If the <CODE>
CustomDialogType</CODE>
 is GIT_MULTIPLE_RESPONSE, you must also set up a Response Trigger Table with several trigger parameters. The customTrigger argument should be a pointer to a structure containing these parameters. Which type of structure depends on how many triggers there are:<CODE>
StandardDialog1ResponseTriggerTable</CODE>
, <CODE>
StandardDialog2ResponseTriggerTable</CODE>
, <CODE>
StandardDialog3ResponseTriggerTable</CODE>
, <CODE>
StandardDialog4ResponseTriggerTable</CODE>
. In each case, you will need to fill in fields specifying how many triggers there are and a moniker and response value for each trigger.</P>
<P>
The <CODE>
helpContext</CODE>
 value is used by the help system; this is the &quot;context&quot; name of the page of the geode's help to go to when the user asks for help with this dialog. A null pointer signals that the default help context should be used.</P>
<P>
This routine returns an InteractionCommand value. It will be IC_NULL if
the interaction was terminated by the system (such as in a system
shutdown).</P>
</DIV>
<DIV>
<A NAME="R_9f.htm_IX_UserStandardDialogOptr()">
 </A>
<H1 CLASS="refHeading">
UserStandardDialogOptr()</H1>
<PRE CLASS="syntax">word	UserStandardDialogOptr(
        char *		helpContext,
        void *		customTriggers,
        optr		arg2,
        optr		arg1,
        optr		string
        CustomDialogBoxFlags		dialogFlags);</PRE>
<P>
<CODE>UserStandardDialogOptr()</CODE> provides the same functionality as
<CODE>UserStandardDialog()</CODE> except that optrs to strings and string
parameters are passed instead of fptrs. This is useful for localized
strings in resource blocks.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_9f.htm#IX_UserStandardDialog()">UserStandardDialog()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_9e.htm#IX_UserDoDialog()">UserDoDialog()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_9f.htm_IX_UserStandardSound()">
 </A>
<A NAME="R_9f.htm_IX_StandardSoundType">
 </A>
<A NAME="R_9f.htm_IX_SST_&ldots;  (StandardSoundType type)">
 </A>
<H1 CLASS="refHeading">
UserStandardSound()</H1>
<PRE CLASS="syntax">word	UserStandardSound(
        StandardSoundType		type,
        ...);</PRE>
<P>
This routine plays a simple sequence of notes. It can be used to play a standard system sound, a single custom tone, or a sequence of tones.</P>
<P>
The routine takes a variable number of arguments. The first argument is a member of the <CODE>
StandardSoundType</CODE>
 enumerated type. This argument specifies what kind of tone or tones will be played. Depending on the <CODE>
StandardSoundType</CODE>
 passed, zero, one, or two additional arguments may be needed. <CODE>
StandardSoundType</CODE>
 contains the following members:</P>
<DL>
<DT>
SST_ERROR</DT><DD>This is the sound played when an &quot;Error&quot; dialog comes up. No further arguments are needed.</DD>
<DT>
SST_WARNING</DT><DD>
This is a general warning sound. No further arguments are needed.</DD>
<DT>
SST_NOTIFY</DT><DD>This is a general notification sound. No further arguments are needed.</DD>
<DT>
SST_NO_INPUT</DT><DD>
This is the sound played when a user's input is not going anywhere (e.g. when he clicks the mouse outside a modal dialog box).</DD>
<DT>
SST_KEY_CLICK</DT><DD>
This is the sound produced when the keyboard is pressed, or when the user clicks on a floating keyboard. No further arguments are required.</DD>
<DT>
SST_CUSTOM_SOUND</DT><DD>
Play a custom sampled sound. This requires one more argument, the memory handle of the sound to be played.</DD>
<DT>
SST_CUSTOM_BUFFER</DT><DD>
Play a custom buffer of instrumental sound. This requires one further argument, a pointer to the memory block containing the sound buffer. Note that the &quot;tempo&quot; value used to play this buffer will be one tick per thirty-second note, probably much faster than you would otherwise expect.</DD>
<DT>
SST_CUSTOM_NOTE</DT><DD>
By passing this argument, you can have a single custom note played. You must provide one further argument, the handle of the note (such as returned by <CODE>
<A HREF="../../CRef/Routines/R_8b.htm#IX_SoundAllocMusicNote()">SoundAllocMusicNote()</A></CODE>
).</DD>
</DL>
<P>The function returns a word-length token value.  This value is useful 
for stopping sounds with the 
<A NAME="R_9f.htm_#IX_UserStopStandardSound()">UserStopStandardSound()</A> routine.
</DIV>

<DIV>
<A NAME="R_9f.htm_IX_UserStopStandardSound()">
 </A>
<H1 CLASS="refHeading">
UserStopStandardSound()</H1>
<PRE CLASS="syntax">word	UserStandardSound(
        StandardSoundType		type,
        word				countID);</PRE>
<P>
This routine stops a sound that was started by <A HREF="#IX_UserStandardSound()">UserStandardSound</A>.</P>
<P>
The sound to stop is identified by its type and by the word-length token value returned by <A HREF="#IX_UserStandardSound()">UserStandardSound</A>.</P>

<P>This function will not stop SST_CUSTOM_... sounds.</P>
</DIV>


<HR>
<A NAME="R_a0.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_a0.htm_IX_UtilAsciiToHex32()">
 </A>
<A NAME="R_a0.htm_IX_Math:UtilAsciiToHex32()">
 </A>
<A NAME="R_a0.htm_IX_UtilAsciiToHexError">
 </A>
<A NAME="R_a0.htm_IX_UATH_&ldots;">
 </A>
<H1 CLASS="refHeading">
UtilAsciiToHex32()</H1>
<PRE CLASS="syntax">Boolean	UtilAsciiToHex32(
        const char *		string,
        dword *		value);</PRE>
<P>
This routine converts a null-terminated ASCII string into a 32-bit integer. The string may begin with a hyphen, indicating a negative number. Aside from that, the string may contain nothing but numerals until the null termination. It may not contain whitespace.</P>
<P>
If the routine is successful, it will return <EM>
false</EM>
 and write an equivalent signed long integer to <EM>
*value</EM>
. If it fails, it will return <EM>
true</EM>
 and write a member of the <CODE>
UtilAsciiToHexError</CODE>
 enumerated type to <EM>
*value</EM>
. This type contains the following members:</P>
<DL>
<DT>
UATH_NON_NUMERIC_DIGIT_IN_STRING</DT><DD>
This string contained a non-numeric character before the trailing null (other than the allowed leading hyphen).</DD>
<DT>
UATH_CONVERT_OVERFLOW</DT><DD>
The string specified a number to large to be expressed as a signed 32-bit integer.</DD>
</DL>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
system.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_a0.htm_IX_Math:UtilHex32ToAscii()">
 </A>
<A NAME="R_a0.htm_IX_UtilHex32ToAscii()">
 </A>
<H1 CLASS="refHeading">
UtilHex32ToAscii()</H1>
<PRE CLASS="syntax">word	UtilHex32ToAscii(
        char *		buffer,
        dword		value, 
        UtilHexToAsciiFlags 		flags);</PRE>
<P>
This routine converts a 32-bit unsigned integer to its ASCII representation and writes it to the specified buffer. It returns the length of the string (not counting the nulll termination, if any). The routine is passed the following arguments:</P>
<DL>
<DT>
<EM>
buffer</EM>
</DT><DD>This is a pointer to a character buffer. The buffer must be long enough to accommodate the largest string; that is, there must be ten bytes for the characters, plus one for the trailing null (if necessary).</DD>
<DT>
<CODE>
value</CODE>
</DT><DD>This is the value to convert to ASCII.</DD>
<DT>
<CODE>
flags</CODE>
</DT><DD>This is a record of <CODE>
UtilHexToAscii</CODE>
 flags. The following flags are available:</DD>
<DT>
UHTAF_INCLUDE_LEADING_ZEROS</DT><DD>
Pad the string with leading zeros to a length of ten total characters.</DD>
<DT>
UHTAF_NULL_TERMINATE</DT><DD>
Add a null to the end of the string. If this flag is set, the buffer must be at least 11 bytes long. If it is clear, the buffer may be ten bytes long.</DD>
</DL>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
system.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_a0.htm_IX_VarDataFlagsPtr() macro">
 </A>
<H1 CLASS="refHeading">
VarDataFlagsPtr()</H1>
<PRE CLASS="syntax">VarDataFlags 	VarDataFlagsPtr(
        void *	ptr);</PRE>
<P>
This macro fetches the flags of a variable data type when given a pointer to the extra data for the type. The flags are stored in a <CODE>
VarDataFlags</CODE>
 record. Only the flags VDF_EXTRA_DATA and/or VDF_SAVE_TO_STATE will be returned.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
object.h</STRONG>
 </P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	You must pass a pointer to the <EM>
beginning</EM>
 of the vardata entry's extra data space.</P>
</DIV>
<DIV>
<A NAME="R_a0.htm_IX_VarDataSizePtr() macro">
 </A>
<H1 CLASS="refHeading">
VarDataSizePtr()</H1>
<PRE CLASS="syntax">word	VarDataSizePtr(
        void *	ptr);</PRE>
<P>
This macro fetches the size of a variable data entry when given a pointer to the extra data for the type.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
object.h</STRONG>
 </P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	You must pass a pointer to the <EM>
beginning</EM>
 of the vardata entry's extra data space.</P>
</DIV>
<DIV>
<A NAME="R_a0.htm_IX_VarDataTypePtr() macro">
 </A>
<H1 CLASS="refHeading">
VarDataTypePtr()</H1>
<PRE CLASS="syntax">word	VarDataTypePtr(
        void *	ptr);</PRE>
<P>
This macro fetches the type of a variable data entry when given a pointer to the extra data of the entry. The type is stored in a <CODE>
VarDataFlags</CODE>
 record. All flags outside the VDF_TYPE section will be cleared.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
object.h</STRONG>
 </P>
<P CLASS="refField"><STRONG>
Warning:</STRONG>	You must pass a pointer to the <EM>
beginning</EM> of the vardata entry's extra data space.</P>
</DIV>

<DIV>
<A NAME="R_a0.htm_IX_VirtualSerialClose()">
 </A>
<H1 CLASS="refHeading">
VirtualSerialClose()</H1>
<PRE CLASS="syntax">VirtualSerialStatus 	VirtualSerialClose ( void  );</PRE>
<P>
Waits until all outgoing data is sent to remote unit, then flushes incoming data buffer and closes connection to remote unit. 
</P>
<P>
Returns VS_OK if data was successfully written.</P>
<P>
Returns VS_CLOSED if stream was already closed.</P>
<P CLASS="refField"><STRONG>
<STRONG>Warning:</STRONG></STRONG> This is a low-level routine whose use is discouraged in favor of <CODE>ModemClose()</CODE>. Do not call any Virtual Serial function except <CODE>VirtualSerialOpen()</CODE> after calling this function.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">vserlib.h</STRONG>
</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_a0.htm#IX_VirtualSerialOpen()">VirtualSerialOpen()</A></CODE>.</P>
</DIV>

<DIV>
<A NAME="R_a0.htm_IX_VirtualSerialFlush()">
 </A>
<H1 CLASS="refHeading">
VirtualSerialFlush()</H1>
<PRE CLASS="syntax">VirtualSerialStatus 	VirtualSerialFlush(
	 word 		flushMode);</PRE>
<P>
Flushes data from incoming buffer. The <EM>flushMode</EM> sets the operation direction. It may be:

<DL>
<DT>STREAM_READ
<DD>Flushes the incoming data buffer.
<DT>STREAM_WRITE
<DD>Is ignored. 
<DT>STREAM_BOTH
<DD>Same as STREAM_READ.
</DL>
<P>Returns VS_OK if the stream successfully flushed.
<P>Returns VS_CLOSED if the stream is not open.
</P>
<P CLASS="refField">
</P>
Include:	<STRONG CLASS="fileName">
vserlib.h </STRONG>
</P>
</DIV>

<DIV>
<A NAME="R_a0.htm_IX_VirtualSerialOpen()">
 </A>
<H1 CLASS="refHeading">
VirtualSerialOpen()</H1>
<PRE CLASS="syntax">VirtualSerialStatus	 VirtualSerialOpen(
	VSOpenFlags 		stream_open_mode,    /* Fail or wait if stream is busy */
	word 		input_buffer_size,    /* # of bytes 1...4096 of input buffer */
	word 		output_buffer_size,    /* Ignore. Automatically set to 4352 bytes. */
	word 		timeout);    /* # of ticks to wait and retry if the stream is busy. */</PRE>
<P>
This routine lets the client open a stream to the phone. Should the Virtual Phone data resource be in use and if <EM>stream_open_mode</EM> is set to SOF_NOBLOCK then the function fails immediately; otherwise, if <EM>stream_open_mode</EM> is set to SOF_TIMEOUT, the function will try again until it is either successful or <EM>timeout</EM> number of ticks (1 ... 32768) elapse. <EM>input_buffer_size</EM> is the size (in bytes 1...4096) of the input buffer. The <EM>output_buffer_size</EM> should be ignored, as the output buffer is set to 4352 bytes. 
<P>
Returns VS_OK if successful.</P>
<P>
Returns VS_DATA_RESOURCE_RESERVED if VP data resource is already in use. 
<P>
Returns VS_STREAM_ALREADY_OPEN if stream has already been opened by another client. 
<P>
Returns VS_CANNOT_ALLOC if cannot allocate memory for the streams buffer.
<P CLASS="refField"><STRONG>
<STRONG>Warning:</STRONG></STRONG> This is a low-level routine whose use is discouraged in favor of <CODE>ModemOpen()</CODE>. This routine must return VS_OK before client can start using other Virtual Serial functions. Outgoing data is not buffered in VirtualSerial library, but sent directly from calling client's buffer.</P>
</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
vserlib.h </STRONG>
</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_a0.htm#IX_VirtualSerialClose()">VirtualSerialClose()</A></CODE>.</P>
</DIV>



<DIV>
<A NAME="R_a0.htm_IX_VirtualSerialRead()">
 </A>
<H1 CLASS="refHeading">
VirtualSerialRead()</H1>
<PRE CLASS="syntax">VirtualSerialStatus 	VirtualSerialRead(
        VSBlockingMode		blocking_mode, /* to block or not to block */
        word		data_size, /* # of bytes of data to be read */
        byte		*ptr_to_buffer, /* buffer to hold data */
        word		*bytes_read); /* # of bytes actually read */</PRE>
<P>
Copies incoming data to buffer. If there is less than <EM>data_size</EM> number of bytes in the buffer and STREAM_BLOCK was specified in <EM>blocking_mode</EM>, will block until enough data becomes available; if there is less than <EM>data_size</EM> number of bytes in the buffer and STREAM_NO_BLOCK was specified, returns immediately with VS_SHORT_READ_WRITE.</P>
<P>
Returns VS_OK if data was successfully written.</P>
<P>
Returns VS_CLOSED if stream is not open.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
vserlib.h </STRONG>
</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_a0.htm#IX_VirtualSerialReadByte()">VirtualSerialReadByte()</A></CODE>.</P>
</DIV>

<DIV>
<A NAME="R_a0.htm_IX_VirtualSerialReadByte()">
 </A>
<H1 CLASS="refHeading">
VirtualSerialReadByte()</H1>
<PRE CLASS="syntax">VirtualSerialStatus 	VirtualSerialReadByte(
        VSBlockingMode		blockingMode, /* to block or not to block */
        byte		*dataByte); /* buffer to hold read data */</PRE>
     
<P>
This routine reads a byte from the stream into <EM>dataByte</EM>. If the stream is empty and <EM>blockingMode</EM> is set to STREAM_BLOCK then the routine will wait for the request to be filled, or if STREAM_NO_BLOCK is specified the routine will immediately return an error.
<P>
Returns VS_OK if data was successfully written to <EM>dataByte</EM>.</P>
<P>
Returns VS_SHORT_READ_WRITE if the data was not available and STREAM_NO_BLOCK was specified.
<P>
Returns VS_CLOSED if the stream is not open.
<P CLASS="refField"><STRONG>
<STRONG>Warning:</STRONG></STRONG> STREAM_BLOCK mode is dangerous to use: if the opposite end does
not send data this function will block forever.</P>

<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
vserlib.h </STRONG>
</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_a0.htm#IX_VirtualSerialRead()">VirtualSerialRead()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_a1.htm#IX_VirtualSerialWriteByte()">VirtualSerialWriteByte()</A></CODE>.</P>
</DIV>


<DIV>
<A NAME="R_a0.htm_IX_VirtualSerialSendDTR()">
 </A>
<H1 CLASS="refHeading">
VirtualSerialSendDTR()</H1>
<PRE CLASS="syntax">VirtualSerialStatus 	VirtualSendDTR(
        byte		DTR_status);</PRE>
<P>
Sends Data Terminal Ready status to modem. </P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
vserlib.h</STRONG>
<CODE>
</CODE>
</P>
</DIV>


<DIV>
<A NAME="R_a0.htm_IX_VirtualSerialSetFlowControl()">
 </A>
<H1 CLASS="refHeading">
VirtualSerialSetFlowControl()</H1>
<PRE CLASS="syntax">VirtualSerialStatus 	VirtualSerialSetFlowControl(
        VSFlowControl		flow_control_mode); /* software or hardware */</PRE>
<P>
Selects the flow control method used between the modem and the VirtualSerial Library. <EM>flow_control_mode</EM> can be set to either VSFC_SOFTWARE or VSFC_HARDWARE.</P>
<P>
Returns VS_OK if successfully set or VS_CLOSED if stream is not open.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
vserlib.h </STRONG>
<CODE>
</CODE>
</P>
</DIV>

<HR>
<A NAME="R_a1.htm"></A>
<DIV>
</DIV>


<DIV>
<A NAME="R_a1.htm_IX_VirtualSerialSetFormat()">
 </A>
<H1 CLASS="refHeading">
VirtualSerialSetFormat()</H1>
<PRE CLASS="syntax">VirtualSerialStatus 	VirtualSetFormat(
        VSSerialFormat		format,/* data format */
        VSSerialBaud		baud); /* baud rate */</PRE>
<P>
Sets the modem's data format and speed. Returns VS_OK if successfully set or VS_CLOSED if stream is not open.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
vserlib.h </STRONG>
<CODE>
</CODE>
</P>
</DIV>

<DIV>
<A NAME="R_a1.htm_IX_VirtualSerialSetNotify()">
 </A>
<H1 CLASS="refHeading">
VirtualSerialSetNotify()</H1>
<PRE CLASS="syntax">VirtualSerialStatus 	VirtualSerialSetNotify(
	VSNotifyType		notifyTpe,   /* Which events, and how they are received */
	optr 		destination,   /* Destination object */
	word 		method);   /* Message to pass to destination object */
</PRE>
<P>
This routine registers a notifier for any of the possible relevant events. The parameter <EM>notifyType</EM> is set to specify which events should result in the object <EM>destination</EM> being sent the message <EM>method</EM>.  The </EM>notifyType</EM> should be set by OR-ing one VSNT_, one VSNE_, and one VSNM_ parameter. <P>

The set of these parameters is:</P>
<DL>
<DT><CODE>VSNT_READER</CODE></DT>
	<DD>notify reader</DD>
<DT><CODE>VSNE_DATA</CODE></DT>
	<DD>data/space available notification</DD>
<DT><CODE>VSNE_MODEM</CODE></DT>
	<DD>notify when modem input signals change</DD>
<DT><CODE>VSNM_NONE</CODE></DT>
	<DD>disable notifier</DD>
<DT><CODE>VSNM_MESSAGE</CODE></DT>
	<DD>notify by sending a message cx:dx</DD>
</DL>

 For example, <CODE>notifyType = VSNT_READER | VSNE_DATA | VSNM_MESSAGE</CODE>: This will notify the reader for data available using messaging. 
<P>
This routine returns VS_OK if the notification is successfully registered.
<P>
Returns VS_NOT_SUPPORTED if the notifier is not supported.
<P>
Returns VS_CLOSED if the stream is not open.
<P CLASS="refField"><STRONG>
<STRONG>Warning:</STRONG></STRONG> This is a low-level routine whose use is discouraged in favor of <CODE>ModemSetRoutineDataNotify(),
	ModemSetMessageDataNotify(),
	ModemSetRoutineResponseNotify(),
	ModemSetMessageResponseNotify(),</CODE> and <CODE>
	ModemSetMessageEndCallNotify()</CODE>.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
vserlib.h </STRONG>
<CODE>
</CODE>
</P>
</DIV>




<DIV>
<A NAME="R_a1.htm_IX_VirtualSerialWrite()">
 </A>
<H1 CLASS="refHeading">
VirtualSerialWrite()</H1>
<PRE CLASS="syntax">VirtualSerialStatus 	VirtualSerialWrite(
        VSBlockingMode		blocking_mode, /* to block or not to block */
        word		buffer_size, /* # of bytes of data to write */
        const byte		*ptr_to_buffer, /* data to write to stream */
        word		*bytes_written); /* # of bytes actually written */</PRE>
<P>
Writes <EM>buffer_size</EM> number of bytes of data from the buffer to stream. If there is not enough space in the stream and STREAM_BLOCK was specified in <EM>blocking_mode</EM>, will block and wait until more space becomes available; if there is not enough space in the stream and STREAM_NO_BLOCK was specified, returns immediately with VS_SHORT_READ_WRITE.</P>
<P>
Returns VS_OK if data was successfully written.</P>
<P>
Returns VS_CLOSED if stream is not open.</P>
<P CLASS="refField"><STRONG>
<STRONG>Warning:</STRONG></STRONG> STREAM_BLOCK is dangerous to use: if the opposite end does not read its data, stream may be constantly full and routine will continue to block for a maximum of two minutes. After two minutes, routine returns VS_SHORT_READ_WRITE and discards the data.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
vserlib.h </STRONG>
</P>
</DIV>

<DIV>
<A NAME="R_a1.htm_IX_VirtualSerialWriteByte()">
 </A>
<H1 CLASS="refHeading">
VirtualSerialWriteByte()</H1>
<PRE CLASS="syntax">VirtualSerialStatus 	VirtualSerialWriteByte(
        VSBlockingMode		blockingMode, /* To block or not to block... */
        byte		dataByte); /* Data to write */</PRE>
     
<P>
This routine writes the byte  <EM>dataByte</EM> into the stream. If the stream is full and <EM>blockingMode</EM> is set to STREAM_BLOCK then the routine will wait for the request to be filled, or if STREAM_NO_BLOCK is specified the routine will immediately return an error.
<P>
Returns VS_OK if data was successfully written.</P>
<P>
Returns VS_SHORT_READ_WRITE if the space was not available and STREAM_NO_BLOCK was specified.
<P>
Returns VS_CLOSED if the stream is not open.
<P CLASS="refField"><STRONG>
<STRONG>Warning:</STRONG></STRONG> STREAM_BLOCK mode is dangerous to use: if the opposite
end does not read its data, the stream may be constantly full and this function will block for maximum of two minutes. After two minutes the routine returns VS_SHORT_READ_WRITE and discards the given data.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
vserlib.h </STRONG>
</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_a1.htm#IX_VirtualSerialWrite()">VirtualSerialWrite()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_a0.htm#IX_VirtualSerialReadByte()">VirtualSerialReadByte()</A></CODE>.</P>
</DIV>



<DIV>
<A NAME="R_a1.htm_IX_VisObjectHandlesInkReply()">
 </A>
<A NAME="R_a1.htm_IX_Ink:VisObjectHandlesInkReply()">
 </A>
<A NAME="R_a1.htm_IX_Pen input:VisObjectHandlesInkReply()">
 </A>
<H1 CLASS="refHeading">
VisObjectHandlesInkReply()</H1>
<PRE CLASS="syntax">void	VisObjectHandlesInkReply(void);</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="R_a1.htm_IX_Bitmaps:VisTextGraphicCompressGraphic()">
 </A>
<A NAME="R_a1.htm_IX_VisTextGraphicCompressGraphic()">
 </A>
<H1 CLASS="refHeading">
VisTextGraphicCompressGraphic()</H1>
<PRE CLASS="syntax">extern VMChain VisTextGraphicCompressGraphic(
        VisTextGraphic 		*graphic,
        FileHandle 		sourceFile,
        FileHandle 		destFile,
        BMFormat format,
        word xRes, 
        word yRes);</PRE>
<P>
This routine compresses the bitmaps in a VisTextGraphic.</P>
</DIV>
<DIV>
<A NAME="R_a1.htm_IX_VMAlloc()">
 </A>
<H1 CLASS="refHeading">
VMAlloc()</H1>
<PRE CLASS="syntax">VMBlockHandle 	VMAlloc(
        VMFileHandle		file,			
        word		size,			/* Size of a file in bytes */
        word		userID);			/* ID # to associate with block */</PRE>
<P>
This routine creates a VM block. The block is not initialized. Before you use the block, you must lock it with <CODE>
<A HREF="../../CRef/Routines/R_a3.htm#IX_VMLock()">VMLock()</A></CODE>
. If you pass a size of zero bytes, the VM block will be given an entry in the VM handle table, but no space in memory or in the file will be used; a global memory block will have to be assigned with <CODE>
<A HREF="../../CRef/Routines/R_a1.htm#IX_VMAttach()">VMAttach()</A></CODE>
.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
vm.h </STRONG>
</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_a1.htm#IX_VMAllocLMem()">VMAllocLMem()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_a1.htm#IX_VMAttach()">VMAttach()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_a1.htm_IX_VMAllocLMem()">
 </A>
<H1 CLASS="refHeading">
VMAllocLMem()</H1>
<PRE CLASS="syntax">VMBlockHandle 	VMAllocLmem(
        VMFileHandle		file,				
        LMemType		ltype,				/* Type of LMem heap to create */
        word		headerSize);				/* Size to leave for LMem header...
						 * pass zero for standard header */</PRE>
<P>
This routine allocates a VM block and initializes it to contain an LMem heap. You must pass the type of LMem heap to create. If you want a fixed data space, you must pass the total size to leave for a header (including the <CODE>
LMemBlockHeader</CODE>
); otherwise, pass a zero header size, indicating that only enough space for an <CODE>
LMemBlockHeader</CODE>
 should be left. You do not need to specify a block size, since the heap will automatically expand to accommodate chunk allocations.</P>
<P>
The block's user ID number is undefined. You will need to lock the block with <CODE>
<A HREF="../../CRef/Routines/R_a3.htm#IX_VMLock()">VMLock()</A></CODE>
 before accessing the chunks.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
vm.h </STRONG>
</P>
<P CLASS="refField"><STRONG>
<STRONG>Warning:</STRONG></STRONG>	When you access chunks, remember to pass the block's <EM>
global memory</EM>
 handle to the LMem routines (not the block's VM handle).</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_64.htm#IX_LMemInitHeap()">LMemInitHeap()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_a1.htm#IX_VMAlloc()">VMAlloc()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_a1.htm#IX_VMAttach()">VMAttach()</A></CODE>.</P>
</DIV>



<DIV>
<A NAME="R_a1.htm_IX_VMAttach()">
 </A>
<H1 CLASS="refHeading">
VMAttach()</H1>
<PRE CLASS="syntax">VMBlockHandle 	VMAttach(
        VMFileHandle		file,
        VMBlockHandle		vmBlock,
        MemHandle		mh);</PRE>
<P>
This routine attaches an existing global memory block to a VM block. It is passed the following arguments:</P>
<DL>
<DT>
<CODE>
file</CODE>
</DT><DD>The file's <CODE>
VMFileHandle</CODE>.</DD>
<DT>
<CODE>
vmBlock</CODE>
</DT><DD>The handle of the VM block to which the memory block should be attached. Any data associated with that block will be lost. If you pass a null <CODE>
VMBlockHandle</CODE>
, a new VM block will be allocated.</DD>
<DT>
<CODE>
mh</CODE>
</DT><DD>The handle of the global memory block to attach.</DD>
</DL>
<P>
The routine returns the handle of the VM block to which the memory block was attached.</P>
<P>
If you attach to a pre-existing VM block, its user ID will be preserved. If you create a new block (by passing a null <CODE>
vmBlock</CODE>
 argument), the user ID will be undefined.</P>
<P>
The block is automatically marked dirty.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
vm.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_a1.htm_IX_VMCheckForModifications()">
 </A>
<H1 CLASS="refHeading">
VMCheckForModifications()</H1>
<PRE CLASS="syntax">Boolean	VMCheckForModifications(
        VMFileHandle		file);</PRE>
<P>
This routine returns <EM>
true</EM>
 if the VM file has been dirtied or updated since the last full save.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
vm.h</STRONG>
 </P>
</DIV>
<HR>
<A NAME="R_a2.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_a2.htm_IX_VMClose()">
 </A>
<H1 CLASS="refHeading">
VMClose()</H1>
<PRE CLASS="syntax">word	VMClose(
        VMFileHandle	file,
        Boolean		noErrorFlag);</PRE>
<P>
This routine updates and closes a VM file. If it is successful, it returns
zero. If it fails, it returns a <CODE>VMStatus</CODE> error code.
Note that the routine closes the file even if it could not successfully
update the file; in this case, any changes since the last update will be
lost. For this reason, it is safest to call <CODE>
<A HREF="../../CRef/Routines/R_a4.htm#IX_VMUpdate()">VMUpdate()</A></CODE>
first, then (after the file has been successfully updated) call <CODE>
VMClose()</CODE>.</P>
<P>
If <EM>noErrorFlag</EM> is TRUE, <CODE>VMClose()</CODE> will fatal-error
if it could not succesfully update and close the file.
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
vm.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_a2.htm_IX_VMCompareVMChains()">
 </A>
<H1 CLASS="refHeading">
VMCompareVMChains()</H1>
<PRE CLASS="syntax">Boolean	VMCompareVMChains(
        VMFileHandle		sourceFile,
        VMChain		sourceChain,
        VMFileHandle		destFile,
        VMChain		destChain);</PRE>
<P>
This routine compares two VM chains or DB items. It returns <EM>
true</EM>
 if the two are identical; otherwise it returns <EM>
false</EM>
.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
vm.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_a2.htm_IX_VMCopyVMBlock()">
 </A>
<H1 CLASS="refHeading">
VMCopyVMBlock()</H1>
<PRE CLASS="syntax">VMBlockHandle 	VMCopyVMBlock(
        VMFileHandle		sourceFile,
        VMBlockHandle		sourceBlock,
        VMFileHandle		destFile);</PRE>
<P>
This routine creates a duplicate of a VM block in the specified destination file (which may be the same as the source file). It returns the duplicate block's handle. The duplicate will have the same user ID as the original block.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
vm.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_a2.htm_IX_VMCopyVMChain()">
 </A>
<H1 CLASS="refHeading">
VMCopyVMChain()</H1>
<PRE CLASS="syntax">VMChain 	VMCopyVMChain(
        VMFileHandle		sourceFile,
        VMChain		sourceChain,
        VMFileHandle		destFile);</PRE>
<P>
This routine creates a duplicate of a VM chain (or DB item) in the specified destination file (which may be the same as the source file). It returns the duplicate's <CODE>
VMChain</CODE>
 structure. All blocks in the duplicate will have the same user ID numbers as the corresponding original blocks.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
vm.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_a2.htm_IX_VMDetach()">
 </A>
<H1 CLASS="refHeading">
VMDetach()</H1>
<PRE CLASS="syntax">MemHandle 	VMDetach(
        VMFileHandle		file,
        VMBlockHandle		block,
        GeodeHandle		owner);			/* Pass zero to have block owned by 
					 * current thread's owner */</PRE>
<P>
This routine detaches a global memory block from a VM block. If the VM block is not currently in memory, <CODE>
VMDetach()</CODE>
 allocates a memory block and copies the VM block into it. If the VM block is dirty, <CODE>
VMDetach()</CODE>
 will update the block to the file before detaching it.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
vm.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_a2.htm_IX_VMDirty()">
 </A>
<H1 CLASS="refHeading">
VMDirty()</H1>
<PRE CLASS="syntax">void	VMDirty(
        MemHandle		mh);</PRE>
<P>
This routine marks a locked VM block as dirty.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
vm.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_a2.htm_IX_VMFind()">
 </A>
<H1 CLASS="refHeading">
VMFind()</H1>
<PRE CLASS="syntax">VMBlockHandle 	VMFind(
        VMFileHandle		file,
        VMBlockHandle		startBlock,
        word		userID);</PRE>
<P>
This routine finds a VM block with the specified user ID number. If the second argument is <CODE>
NullHandle</CODE>
 the routine will return the matching block with the lowest handle. If the second argument is non-null, it will return the first matching block whose handle is larger than the one passed (in numerical order).</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
vm.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_a2.htm_IX_VMFree()">
 </A>
<H1 CLASS="refHeading">
VMFree()</H1>
<PRE CLASS="syntax">void	VMFree(
        VMFileHandle		file,
        VMBlockHandle		block);</PRE>
<P>
This routine frees the specified VM block. If a global memory block is currently attached to the VM block, it is freed too.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
vm.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_a2.htm_IX_VMFreeVMChain()">
 </A>
<H1 CLASS="refHeading">
VMFreeVMChain()</H1>
<PRE CLASS="syntax">void	VMFreeVMChain(
        VMFileHandle		file,
        VMChain		chain);</PRE>
<P>
This routine frees the specified VM chain or DB item. If a chain is specified, all blocks in the chain will be freed.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
vm.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_a2.htm_IX_VMGetAttributes()">
 </A>
<H1 CLASS="refHeading">
VMGetAttributes()</H1>
<PRE CLASS="syntax">word	VMGetAttributes(
        VMFileHandle		file);</PRE>
<P>
Each VM file contains a set of <CODE>
VMAttributes</CODE>
 flags. These determine how the VM manager will treat the file. This routine returns the current flags.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
vm.h </STRONG>
</P>
<P CLASS="refField"><STRONG>
Tips and Tricks:</STRONG>	When the Document Control objects create files, they automatically initialize the attributes appropriately.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_a4.htm#IX_VMSetAttributes()">VMSetAttributes()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_a2.htm_IX_VMGetDirtyState()">
 </A>
<H1 CLASS="refHeading">
VMGetDirtyState()</H1>
<PRE CLASS="syntax">word	VMGetDirtyState(
        VMFileHandle		file);</PRE>
<P>
This routine finds out if a file has been dirtied. It returns a word-sized value. The upper byte of the return value is non-zero if the file has not been dirtied since the last save, auto-save, or update; the lower byte is non-zero if the file has not been dirtied since the last save. Thus, if the return value is zero, the file must be updated.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
vm.h</STRONG>
 </P>
<P CLASS="refField"><STRONG>
Tips and Tricks:</STRONG>	<CODE>
<A HREF="../../CRef/Routines/R_a4.htm#IX_VMUpdate()">VMUpdate()</A></CODE>
 is optimized for updating clean files. For this reason, it is faster to call <CODE>
<A HREF="../../CRef/Routines/R_a4.htm#IX_VMUpdate()">VMUpdate()</A></CODE>
 then it is to first check the dirty state, then call <CODE>
<A HREF="../../CRef/Routines/R_a4.htm#IX_VMUpdate()">VMUpdate()</A></CODE>
 only if the file is dirty.</P>
</DIV>
<HR>
<A NAME="R_a3.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_a3.htm_IX_VMGetMapBlock()">
 </A>
<H1 CLASS="refHeading">
VMGetMapBlock()</H1>
<PRE CLASS="syntax">VMBlockHandle 	VMGetMapBlock(
        VMFIleHandle		file);</PRE>
<P>
This routine returns the VM block handle of the file's map block.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
vm.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_a3.htm_IX_VMGrabExclusive()">
 </A>
<H1 CLASS="refHeading">
VMGrabExclusive()</H1>
<PRE CLASS="syntax">VMStartExclusiveReturnValue VMGrabExclusive(
        VMFileHandle		file,
        word		timeout,
        VMOperation		operation,
        VMOperation *		currentOperation);</PRE>
<P>
This routine gets exclusive access to a VM file for this thread.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
vm.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_a3.htm_IX_VMInfo()">
 </A>
<H1 CLASS="refHeading">
VMInfo()</H1>
<PRE CLASS="syntax">Boolean	VMInfo(
        VMFileHandle		file,
        VMBlockHandle		block,
        VMInfoStruct *		info</PRE>
<P>
This routine writes the memory handle, block size, and user ID number of the block. It returns <EM>
non-zero </EM>
if the handle is invalid or free.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
vm.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_a3.htm_IX_VMLock()">
 </A>
<H1 CLASS="refHeading">
VMLock()</H1>
<PRE CLASS="syntax">void *	VMLock(
        VMFileHandle		file,
        VMBlockHandle		block,
        MemHandle*		mh);</PRE>
<P>
This routine locks a VM block into the global heap. It returns the block's base address.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
vm.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_a3.htm_IX_VMMemBlockToVMBlock()">
 </A>
<H1 CLASS="refHeading">
VMMemBlockToVMBlock()</H1>
<PRE CLASS="syntax">VMBlockHandle 	VMMemBlockToVMBlock(
        MemHandle		mh,
        VMFileHandle*		file);</PRE>
<P>
This routine gets the VM block and file handles for a specified memory block. It returns the VM block handle and copies the VM file handle into <CODE>
*file</CODE>
.</P>
<P>
The memory handle passed must be the handle of a block which is attached to a VM file. If it is not, the results are undefined.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
vm.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_a3.htm_IX_VMModifyUserID()">
 </A>
<H1 CLASS="refHeading">
VMModifyUserID()</H1>
<PRE CLASS="syntax">void	VMModifyUserID(
        VMFileHandle		file,
        VMBlockHandle		block,
        word		userID);</PRE>
<P>
This routine changes a VM block's user ID number.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
vm.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_a3.htm_IX_VMOpen()">
 </A>
<A NAME="R_a3.htm_IX_VM_&ldots;">
 </A>
<H1 CLASS="refHeading">
VMOpen()</H1>
<PRE CLASS="syntax">VMFileHandle 	VMOpen(
        char *		name,				/* Name of file to open/create */
        VMAccessFlags		flags,
        VMOpenType		mode,
        word		compression);				/* Compaction threshold percentage 
						 * passed as an integer */</PRE>
<P>
This routine opens or creates a VM file. It returns the handle of the opened file. If it is unable to open the file, it returns a null <CODE>
VMFileHandle</CODE>
 and sets a <CODE>
VMStatus</CODE>
 error code which may be retrieved with <CODE>
<A HREF="../../CRef/Routines/R_97.htm#IX_ThreadGetError()">ThreadGetError()</A></CODE>
. <CODE>
VMOpen()</CODE>
 looks for the file in the thread's working directory (unless a temporary file is being created, as described below). The routine takes four arguments:</P>
<DL>
<DT>
<CODE>
name</DT><DD></CODE>
A pointer to a string containing the name of the file to open. The file will be opened in the thread's current working directory. If a temporary file is being opened, this buffer should contain the full path of the directory in which to create the file, followed by fourteen null bytes (counting the string-ending null). <CODE>
VMOpen()</CODE>
 will write the name of the temporary file in those trailing nulls.</DD>
<DT>
<CODE>
flags</DT><DD></CODE>
This specifies what kind of access to the file you need. The flags are described <A HREF="../../CRef/Structs/S_43.htm#IX_VMAccessFlags">in the C Structures Reference</A>.</DD>
<DT>
<CODE>
mode</DT><DD></CODE>
This specifies how the file should be opened. The types are described <A HREF="../../CRef/Structs/S_44.htm#IX_VMO_&ldots;  (VMOpenType type)">in the C Structures Reference</A>.</DD>
<DT>
<CODE>
compression</CODE>
 </DT><DD>The compaction threshold percentage, passed as an integer. For example, to set a compaction threshold of 50%, pass the integer 50. When the percentage of used space in the file drops below the compaction threshold, the VM manager will automatically compact the file. To use the system default threshold, pass a threshold of zero. The compaction threshold is set only when the file is created; this argument is ignored if an existing file is opened.</DD>
</DL>
<P>
You must also specify how the file should be opened. To do this, you pass a member of the <CODE>
VMOpenType</CODE>
 enumerated type.</P>
<P>
If for any reason <CODE>
VMOpen()</CODE>
 is unable to open the requested file, it will returns a null file handle. It will also set the error value for <CODE>
<A HREF="../../CRef/Routines/R_97.htm#IX_ThreadGetError()">ThreadGetError()</A></CODE>
. The possible error conditions are:</P>
<DL>
<DT>
VM_FILE_EXISTS</DT><DD>
<CODE>
VMOpen()</CODE>
 was passed VMO_CREATE_ONLY, but the file already exists.</DD>
<DT>
VM_FILE_NOT_FOUND</DT><DD>
<CODE>
VMOpen()</CODE>
 was passed VMO_OPEN, but the file does not exist.</DD>
<DT>
VM_SHARING_DENIED</DT><DD>
The file was opened by another geode, and access was denied.</DD>
<DT>
VM_OPEN_INVALID_VM_FILE</DT><DD>
<CODE>
VMOpen()</CODE>
 was instructed to open an invalid VM file (or a non-VM file).</DD>
<DT>
VM_CANNOT_CREATE</DT><DD>
<CODE>
VMOpen()</CODE>
 cannot create the file (but it does not already exist).</DD>
<DT>
VM_TRUNCATE_FAILED</DT><DD>
<CODE>
VMOpen()</CODE>
 was passed VMO_CREATE_TRUNCATE; the file exists, but could not be truncated.</DD>
<DT>
VM_WRITE_PROTECTED</DT><DD>
<CODE>
VMOpen()</CODE>
 was passed VMAF_FORCE_READ_WRITE, but the file was write-protected.</DD>
<DT>
VM_CANNOT_OPEN_SHARED_MULTIPLE</DT><DD>
<CODE>
VMOpen()</CODE>
 attempted to open a file marked GFHF_SHARED_MULTIPLE while passing the VMAF_DISALLOW_SHARED_MULTIPLE flag.</DD>
<DT>
VM_FILE_FORMAT_MISMATCH</DT><DD>
<CODE>
VMOpen()</CODE>
 attempted to create a VM file using a name that already belongs to a DOS file.</DD>
</DL>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
vm.h </STRONG>
</P>
<P CLASS="refField"><STRONG>
Tips and Tricks:</STRONG>	If you use the document control objects, they will take care of opening files as necessary; you will not need to call <CODE>
VMOpen()</CODE>
.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_2a.htm#IX_FileOpen()">FileOpen()</A></CODE>.</P>
</DIV>
<HR>
<A NAME="R_a4.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_a4.htm_IX_VMPreserveBlocksHandle()">
 </A>
<H1 CLASS="refHeading">
VMPreserveBlocksHandle()</H1>
<PRE CLASS="syntax">void	VMPreserveBlocksHandle(
        VMFileHandle		file,
        VMBlockHandle		block);</PRE>
<P>
Keep the same global memory block with this VM block until the block is explicitly detached or the VM block is freed.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
vm.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_a4.htm_IX_VMReleaseExclusive()">
 </A>
<H1 CLASS="refHeading">
VMReleaseExclusive()</H1>
<PRE CLASS="syntax">void VMReleaseExclusive(
        VMFileHandle 		file);</PRE>
<P>
This routine releases a thread's exclusive access to a VM file.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
vm.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_a4.htm_IX_VMRevert()">
 </A>
<H1 CLASS="refHeading">
VMRevert()</H1>
<PRE CLASS="syntax">void	VMRevert(
        VMFileHandle		file,);</PRE>
<P>
This routine reverts a file to its last-saved state.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
vm.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_a4.htm_IX_VMSave()">
 </A>
<H1 CLASS="refHeading">
VMSave()</H1>
<PRE CLASS="syntax">Boolean	VMSave(
        VMFileHandle		file);</PRE>
<P>
This routine updates and saves a file, freeing all backup blocks. If it encounters an error in the save operation, it will return <EM>
non-zero</EM>
. </P>
</DIV>
<DIV>
<A NAME="R_a4.htm_IX_VMSaveAs()">
 </A>
<H1 CLASS="refHeading">
VMSaveAs()</H1>
<PRE CLASS="syntax">VMFileHandle VMSaveAs(
        VMFileHandle		file,
        const char		*name,
        VMAccessFlags		flags.
        VMOpenType		mode,
        word		compression); /* compaction threshold */</PRE>
<P>
This routine saves a file under a new name. The old file is reverted to its last-saved condition. If it encounters an error in the save operation, it will return a null <CODE>
VMFileHandle</CODE>
 and set a <CODE>
VMStatus</CODE>
 error code<CODE>
 </CODE>
which may be retrieved with <CODE>
<A HREF="../../CRef/Routines/R_97.htm#IX_ThreadGetError()">ThreadGetError()</A></CODE>
.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
vm.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_a4.htm_IX_VMSetAttributes()">
 </A>
<H1 CLASS="refHeading">
VMSetAttributes()</H1>
<PRE CLASS="syntax">word	VMSetAttributes(
        VMFileHandle		file,				
        VMAttributes		attrToSet,				/* Turn these flags on... */
        VMAttributes		attrToClear);				/* after turning these flags off */</PRE>
<P>
This routine changes a VM file's <CODE>
VMAttributes</CODE>
 settings. The routine returns the new attribute settings.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
vm.h </STRONG>
</P>
<P CLASS="refField"><STRONG>
Tips and Tricks:</STRONG>	When the Document Control objects create files, they automatically initialize the attributes appropriately.</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	If you turn off VMA_BACKUP, make sure you do it right after a save or revert (when there are no backup blocks).</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_a2.htm#IX_VMGetAttributes()">VMGetAttributes()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="R_a4.htm_IX_VMSetExecThread()">
 </A>
<H1 CLASS="refHeading">
VMSetExecThread()</H1>
<PRE CLASS="syntax">void	VMSetExecThread(
        VMFileHandle		file,
        ThreadHandle		thread);</PRE>
<P>
Set which thread will execute methods of all objects in the file.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
vm.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_a4.htm_IX_VMSetMapBlock()">
 </A>
<H1 CLASS="refHeading">
VMSetMapBlock()</H1>
<PRE CLASS="syntax">void	VMSetMapBlock(
        VMFileHandle		file,
        VMBlockHandle		block);</PRE>
<P>
This routine sets the map block for a VM file. </P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
vm.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_a4.htm_IX_VMSetReloc()">
 </A>
<H1 CLASS="refHeading">
VMSetReloc()</H1>
<PRE CLASS="syntax">void	VMSetReloc(
        VMFileHandle		file,
        void (*reloc) 		(VMFileHandle					file,
        		 VMBlockHandle					block,
        		 MemHandle					mh,
        		 void					*data,
        		 VMRelocTypes					type));</PRE>
<P>
This routine sets a data-relocation routine for the VM file.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
vm.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_a4.htm_IX_VMUnlock()">
 </A>
<H1 CLASS="refHeading">
VMUnlock()</H1>
<PRE CLASS="syntax">void	VMUnlock(
        MemHandle		mh);</PRE>
<P>
This routine unlocks a locked VM block. Note that the block's <EM>
global memory handle</EM>
 is passed (not its VM handle).</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
vm.h </STRONG>
</P>
</DIV>
<DIV>
<A NAME="R_a4.htm_IX_VMUpdate()">
 </A>
<H1 CLASS="refHeading">
VMUpdate()</H1>
<PRE CLASS="syntax">word	VMUpdate(
        VMFileHandle		file);</PRE>
<P>
This routine updates dirty blocks to the disk.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
vm.h</STRONG>
 </P>
<P CLASS="refField"><STRONG>
Tips and Tricks:</STRONG>	<CODE>
VMUpdate()</CODE>
 is optimized for updating clean files to the disk. Therefore, it is faster to call <CODE>
VMUpdate()</CODE>
 whenever you think it might be necessary, than it is to check the dirty state and then call <CODE>
VMUpdate()</CODE>
 only if the file is actually dirty.</P>
</DIV>
<DIV>
<A NAME="R_a4.htm_IX_VMVMBlockToMemBlock()">
 </A>
<H1 CLASS="refHeading">
VMVMBlockToMemBlock()</H1>
<PRE CLASS="syntax">MemHandle 	VMVMBlockToMemBlock(
        VMFileHandle		file,
        VmBlockHandle		block);</PRE>
<P>
This routine returns the global handle of the memory block attached to a specified VM block. If no global block is currently attached, it will allocate and attach one.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
vm.h</STRONG>
 </P>
</DIV>
<HR>
<A NAME="R_a5.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_a5.htm_IX_WinAckUpdate()">
 </A>
<H1 CLASS="refHeading">
WinAckUpdate()</H1>
<PRE CLASS="syntax">void	WinAckUpdate(
        WindowHandle		win);</PRE>
<P>
This routine acknowledges that the application has received MSG_META_EXPOSED for the specified window, but chooses not to do any updating.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
win.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_a5.htm_IX_WinApplyRotation()">
 </A>
<H1 CLASS="refHeading">
WinApplyRotation()</H1>
<PRE CLASS="syntax">void	WinApplyRotation(
        WindowHandle		win,
        WWFixedAsDWord		angle,
        WinInvalFlag		flag);</PRE>
<P>
This routine applies the specified rotation to the window's transformation matrix.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
win.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_a5.htm_IX_WinApplyScale()">
 </A>
<H1 CLASS="refHeading">
WinApplyScale()</H1>
<PRE CLASS="syntax">void	WinApplyScale(
        WindowHandle		win,
        WWFixedAsDWord		xScale,
        WWFixedAsDWord		yScale,
        WinInvalFlag		flag);</PRE>
<P>
This routine applies the specified scale factor to the window's transformation matrix.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
win.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_a5.htm_IX_WinApplyTransform()">
 </A>
<H1 CLASS="refHeading">
WinApplyTransform()</H1>
<PRE CLASS="syntax">void	WinApplyTransform(
        WindowHandle		win,
        const TransMatrix *		tm,
        WinInvalFlag		flag);</PRE>
<P>
This routine concatenates the passed transformation matrix with the window's transformation matrix. The result will be the window's new transformation matrix.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
win.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_a5.htm_IX_WinApplyTranslation()">
 </A>
<H1 CLASS="refHeading">
WinApplyTranslation()</H1>
<PRE CLASS="syntax">void	WinApplyTranslation(
        WindowHandle		win,
        WWFixedAsDWord		xTrans,
        WWFixedAsDword		yTrans,
        WinInvalFlag		flag);</PRE>
<P>
This routine applies the specified translation to the window's transformation matrix.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
win.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_a5.htm_IX_WinApplyTranslationDWord()">
 </A>
<H1 CLASS="refHeading">
WinApplyTranslationDWord()</H1>
<PRE CLASS="syntax">void	WinApplyExtTranslation(
        WindowHandle		win,
        sdword		xTrans,
        sdword		yTrans,
        WinInvalFlag		flag);</PRE>
<P>
This routine applies the specified translation to the window's transformation matrix. The translations are specified as 32-bit integers.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
win.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_a5.htm_IX_WinChangeAck()">
 </A>
<H1 CLASS="refHeading">
WinChangeAck()</H1>
<PRE CLASS="syntax">WindowHandle WinChangeAck(
        WindowHandle		win,
        sword		x,
        sword		y,
        optr *		winOD);</PRE>
<P>
&nbsp;</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
win.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_a5.htm_IX_WinChangePriority()">
 </A>
<H1 CLASS="refHeading">
WinChangePriority()</H1>
<PRE CLASS="syntax">void	WinChangePriority(
        WindowHandle		win,
        WinPassFlags		flags,
        word		layerID);</PRE>
<P>
This routine changes the priority for the specified window.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
win.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_a5.htm_IX_WinClose()">
 </A>
<H1 CLASS="refHeading">
WinClose()</H1>
<PRE CLASS="syntax">void	WinClose(
        WindowHandle		win);</PRE>
<P>
This routine closes and frees the specified window.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
win.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_a5.htm_IX_WinDecRefCount()">
 </A>
<H1 CLASS="refHeading">
WinDecRefCount()</H1>
<PRE CLASS="syntax">void	WinDecRefCount(
        WindowHandle		win);</PRE>
<P>
This routine is part of the window closing mechanism.</P>
</DIV>
<DIV>
<A NAME="R_a5.htm_IX_WinEnsureChangeNotification()">
 </A>
<H1 CLASS="refHeading">
WinEnsureChangeNotification()</H1>
<PRE CLASS="syntax">void	WinEnsureChangeNotification(void);</PRE>
<P>
&nbsp;</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
win.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_a5.htm_IX_WinGeodeGetInputObj()">
 </A>
<H1 CLASS="refHeading">
WinGeodeGetInputObj()</H1>
<PRE CLASS="syntax">optr	WinGeodeGetInputObj(
        GeodeHandle		obj);</PRE>
<P>
This routine fetches the optr of the input object for the specified geode. If there is no such object, it returns a null optr.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
win.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_a5.htm_IX_WinGeodeGetParentObj()">
 </A>
<H1 CLASS="refHeading">
WinGeodeGetParentObj()</H1>
<PRE CLASS="syntax">optr	WinGeodeGetParentObj(
        GeodeHandle		obj);</PRE>
<P>
This routine fetches the optr of the parent object of the specified geode. If there is no such object, it returns a null optr.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
win.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_a5.htm_IX_WinGeodeSetActiveWin()">
 </A>
<H1 CLASS="refHeading">
WinGeodeSetActiveWin()</H1>
<PRE CLASS="syntax">void	WinGeodeSetActiveWin(
        GeodeHandle		gh,
        WindowHandle		win);</PRE>
<P>
This routine sets the active window for the specified geode.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
win.h</STRONG>
 </P>
</DIV>
<HR>
<A NAME="R_a6.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_a6.htm_IX_WinGeodeSetInputObj()">
 </A>
<H1 CLASS="refHeading">
WinGeodeSetInputObj()</H1>
<PRE CLASS="syntax">void	WinGeodeSetInputObj(
        GeodeHandle		gh,
        optr		iObj);</PRE>
<P>
This routine sets the input object for the specified geode.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
win.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_a6.htm_IX_WinGeodeSetParentObj()">
 </A>
<H1 CLASS="refHeading">
WinGeodeSetParentObj()</H1>
<PRE CLASS="syntax">void	WinGeodeSetParentObj(
        GeodeHandle		gh,
        optr		pObj);</PRE>
<P>
This routine sets the parent object for the specified geode.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
win.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_a6.htm_IX_WinGeodeSetPtrImage()">
 </A>
<H1 CLASS="refHeading">
WinGeodeSetPtrImage()</H1>
<PRE CLASS="syntax">void	WinGeodeSetPtrImage(
        GeodeHandle		gh,
        optr		ptrCh);</PRE>
<P>
This routine sets the pointer image for the specified geode.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
win.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_a6.htm_IX_WinGetInfo()">
 </A>
<H1 CLASS="refHeading">
WinGetInfo()</H1>
<PRE CLASS="syntax">dword	WinGetInfo(
        WindowHandle		win,
        WinInfoTypes		type,
        void *		data);</PRE>
<P>
This routine retrieves the private data from a GState.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
win.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_a6.htm_IX_WinGetTransform()">
 </A>
<H1 CLASS="refHeading">
WinGetTransform()</H1>
<PRE CLASS="syntax">void	WinGetTransform(
        WindowHandle		win,
        TransMatrix *		tm);</PRE>
<P>
This routine retrieves the transformation matrix for the specified window. It writes the matrix to <CODE>
*tm</CODE>
.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
win.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_a6.htm_IX_WinGetWinScreenBounds()">
 </A>
<H1 CLASS="refHeading">
WinGetWinScreenBounds()</H1>
<PRE CLASS="syntax">void	WinGetWinScreenBounds(
        WindowHandle		win,
        Rectangle *		bounds);</PRE>
<P>
This routine returns the bounds of the on-screen portion of a window (specified in screen co-ordinates). It writes the bounds to <EM>
*bounds</EM>
.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
win.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_a6.htm_IX_WinGrabChange()">
 </A>
<H1 CLASS="refHeading">
WinGrabChange()</H1>
<PRE CLASS="syntax">Boolean	WinGrabChange(
        WindowHandle		win,
        optr		newObj);</PRE>
<P>
This routine allows an object to grab pointer events. It returns zero if it was successful; otherwise it returns non-zero.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
win.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_a6.htm_IX_WinInvalReg()">
 </A>
<H1 CLASS="refHeading">
WinInvalReg()</H1>
<PRE CLASS="syntax">void	WinInvalReg(
        WindowHandle		win,
        const Region *		reg,
        word		axParam,
        word		bxParam,
        word		cxParam,
        word		dxParam);</PRE>
<P>
This routine invalidates the specified region or rectangle.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
win.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_a6.htm_IX_WinMove()">
 </A>
<H1 CLASS="refHeading">
WinMove()</H1>
<PRE CLASS="syntax">void	WinMove(
        WindowHandle		win,
        sword		xMove,
        sword		yMove,
        WinPassFlags		flags);</PRE>
<P>
This routine moves a window. If the WPF_ABS bit of <CODE>
flags</CODE>
 is set, the window's new position is specified relative to its parent's position. If it is clear, the window's new position is specified relative to its current position.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
win.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_a6.htm_IX_WinOpen()">
 </A>
<H1 CLASS="refHeading">
WinOpen()</H1>
<PRE CLASS="syntax">WindowHandle WinOpen(
        Handle		parentWinOrVidDr,
        optr		inputRecipient,
        optr		exposureRecipient,
        WinColorFlags		colorFlags,
        word		redOrIndex,
        word		green,
        word		blue,
        word		flags,
        word		layerID,
        GeodeHandle		owner,
        const Region *		winReg,
        word		axParam,
        word		bxParam,
        word		cxParam,
        word		dxParam);</PRE>
<P>
This routine allocates and initializes a window and (optionally) an associated GState.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
win.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_a6.htm_IX_WinReleaseChange()">
 </A>
<H1 CLASS="refHeading">
WinReleaseChange()</H1>
<PRE CLASS="syntax">void	WinReleaseChange(
        WindowHandle		win,
        optr		obj);</PRE>
<P>
This routine releases an object's grab on the change OD.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
win.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_a6.htm_IX_WinResize()">
 </A>
<H1 CLASS="refHeading">
WinResize()</H1>
<PRE CLASS="syntax">void	WinResize(
        WindowHandle		win,
        const Region *		reg,
        word		axParam,
        word		bxParam,
        word		cxParam,
        WinPassFlags		flags);</PRE>
<P>
This routine resizes a window. It can move it as well.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
win.h</STRONG>
 </P>
</DIV>
<HR>
<A NAME="R_a7.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="R_a7.htm_IX_WinScroll()">
 </A>
<H1 CLASS="refHeading">
WinScroll()</H1>
<PRE CLASS="syntax">void	WinScroll(
        WindowHandle		win,
        WWFixedAsDWord		xMove,
        WWFixedAsSWord		yMove,
        PointWWFixed *		scrollAmt);</PRE>
<P>
This routine scrolls a window.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
win.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_a7.htm_IX_WinSetInfo()">
 </A>
<H1 CLASS="refHeading">
WinSetInfo()</H1>
<PRE CLASS="syntax">void	WinSetInfo(
        WindowHandle		win,
        WinInfoType		type,
        dword		data);</PRE>
<P>
This routine sets some data for the specified window.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
win.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_a7.htm_IX_WinSetNullTransform()">
 </A>
<H1 CLASS="refHeading">
WinSetNullTransform()</H1>
<PRE CLASS="syntax">void	WinSetNullTransform(
        WindowHandle		win,
        WinInvalFlag		flag);</PRE>
<P>
This routine changes a window's transformation matrix to the null (or identity) matrix.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
win.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_a7.htm_IX_Mouse:WinSetPtrImage()">
 </A>
<A NAME="R_a7.htm_IX_WinSetPtrImage()">
 </A>
<H1 CLASS="refHeading">
WinSetPtrImage()</H1>
<PRE CLASS="syntax">void	WinSetPtrImage(
        WindowHandle		win,
        WinSetPtrImageLevel		ptrLevel,
        optr		ptrCh);</PRE>
<P>
This routine sets the pointer image within the range handled by the specified window.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
win.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_a7.htm_IX_WinSetTransform()">
 </A>
<H1 CLASS="refHeading">
WinSetTransform()</H1>
<PRE CLASS="syntax">void	WinSetTransform(
        WindowHandle		win,
        const TransMatrix *		tm,
        WinInvalFlag		flag);</PRE>
<P>
This routine replaces the window's transformation matrix with the one passed in <EM>
*tm</EM>
.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
win.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_a7.htm_IX_WinSuspendUpdate()">
 </A>
<H1 CLASS="refHeading">
WinSuspendUpdate()</H1>
<PRE CLASS="syntax">void	WinSuspendUpdate(
        WindowHandle		win);</PRE>
<P>
This routine suspends the sending of update messages to the window. The messages will be sent when <CODE>
<A HREF="../../CRef/Routines/R_a7.htm#IX_WinUnSuspendUpdate()">WinUnSuspendUpdate()</A></CODE>
 is called.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
win.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_a7.htm_IX_WinTransform()">
 </A>
<H1 CLASS="refHeading">
WinTransform()</H1>
<PRE CLASS="syntax">XYValueAsDWord 	WinTransform(
        WindowHandle		win,
        sword		x,
        sword		y);</PRE>
<P>
This routine translates the passed document coordinates into screen coordinates.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
win.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_a7.htm_IX_WinTransformDWord()">
 </A>
<H1 CLASS="refHeading">
WinTransformDWord()</H1>
<PRE CLASS="syntax">void	WinTransformDWord(
        WindowHandle		win,
        sdword		xCoord,
        sdword		yCoord,
        PointDWord *		screenCoordinates);</PRE>
<P>
This routine translates the passed document coordinates into screen coordinates. The translated coordinates are written to <CODE>
*screenCoordinates</CODE>
.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
win.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_a7.htm_IX_WinUnSuspendUpdate()">
 </A>
<H1 CLASS="refHeading">
WinUnSuspendUpdate()</H1>
<PRE CLASS="syntax">void	WinUnSuspendUpdate(
        WindowHandle		win);</PRE>
<P>
This routine cancels a previous <CODE>
<A HREF="../../CRef/Routines/R_a7.htm#IX_WinSuspendUpdate()">WinSuspendUpdate()</A></CODE>
 call.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
win.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_a7.htm_IX_WinUntransform()">
 </A>
<H1 CLASS="refHeading">
WinUntransform</H1>
<PRE CLASS="syntax">XYValueAsDWord 	WinUntransform(
        WindowHandle		win,
        sword		x,
        sword		y);</PRE>
<P>
This routine translates the passed screen coordinates into document coordinates.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
win.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_a7.htm_IX_WinUntransformDWord()">
 </A>
<H1 CLASS="refHeading">
WinUntransformDWord()</H1>
<PRE CLASS="syntax">void	WinUntransformDWord(
        WindowHandle		win,
        sdword		xCoord,
        sdword		yCoord,
        PointDWord *		documentCoordinates);</PRE>
<P>
This routine translates the passed screen coordinates into document coordinates. The translated coordinates are written to <CODE>
*documentCoordinates</CODE>
.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
win.h</STRONG>
 </P>
</DIV>
<DIV>
<H1 CLASS="refHeading">
WWFixedToFrac</H1>
<PRE CLASS="syntax">word	WWFixedToFrac(WWFixed wwf)</PRE>
<P>
This macro lets you address the fractional portion of a <CODE>
WWFixed</CODE>
 value. It is legal to use this to assign a value to the fractional protion; that is,</P>
<PRE>WWFixedToFrac(myWWFixed) = 5;</PRE>
<P>
is perfectly legal.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
geos.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="R_a7.htm_IX_WWFixedToInt">
 </A>
<H1 CLASS="refHeading">
WWFixedToInt</H1>
<PRE CLASS="syntax">word	WWFixedToInt(WWFixed wwf)</PRE>
<P>
This macro lets you address the intetgral portion of a <CODE>
WWFixed</CODE>
 value. It is legal to use this to assign a value to the integral protion; that is,</P>
<PRE>WWFixedToInt(myWWFixed) = 5;</PRE>
<P>
is perfectly legal.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
geos.h</STRONG>
 </P>
</DIV>
<HR>
This document is a single-page version of a <A HREF="index.htm">a multi-page document</A>, suitable for easy printing.
</BODY>
</HTML>
