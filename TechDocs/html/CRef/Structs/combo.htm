<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD>
<!-- This page was automatically generated from a bunch of smaller pages. -->
<META NAME="copyright" CONTENT="Copyright GEOWORKS">
<LINK REL="STYLESHEET" HREF="../../docHelpers/style.css">
<LINK REV="MADE" HREF="mailto:doc-feedback@geoworks.com">
<TITLE>GEOS C Structs Reference</TITLE>
</HEAD>
<BODY BGCOLOR="#ffffdf">
This document is a single-page version of a <A HREF="index.htm">a multi-page document</A>, suitable for easy printing.
<A NAME="index.htm"></A>
<DIV>
</DIV>
<H1>GEOS C Structs Reference</H1>
<P>
This document contains reference information for most of the 
GEOS system structs.  You may look up information in this and 
other GEOS SDK documentation by consulting 
<A HREF="../../docIndexes/bigIndex/indexA.htm">the index</A>.  If, instead, you wish to browse 
this reference, you may choose one of the links below; the text of each 
is the name of the first struct documented on its page of the document.</P>

<P CLASS="sectionlinks">
<STRONG>
&nbsp;&nbsp;<A HREF="#S_1.htm">AccessPointStandardProperty ...</A><BR>
&nbsp;&nbsp;<A HREF="#S_2.htm">AppLaunchFlags ...</A><BR>
&nbsp;&nbsp;<A HREF="#S_3.htm">BitmapMode ...</A><BR>
&nbsp;&nbsp;<A HREF="#S_4.htm">CellFunctionParameterFlags ...</A><BR>
&nbsp;&nbsp;<A HREF="#S_5.htm">Chars ...</A><BR>
&nbsp;&nbsp;<A HREF="#S_6.htm">ChunkArrayHeader ...</A><BR>
&nbsp;&nbsp;<A HREF="#S_7.htm">ClipboardItemHeader ...</A><BR>
&nbsp;&nbsp;<A HREF="#S_8.htm">Color ...</A><BR>
&nbsp;&nbsp;<A HREF="#S_9.htm">ColorFlag ...</A><BR>
&nbsp;&nbsp;<A HREF="#S_a.htm">CompSizeHintArgs ...</A><BR>
&nbsp;&nbsp;<A HREF="#S_b.htm">CustomDialogBoxFlags ...</A><BR>
&nbsp;&nbsp;<A HREF="#S_c.htm">DataStoreIndexCallbackParams ...</A><BR>
&nbsp;&nbsp;<A HREF="#S_d.htm">DateTimeFormat ...</A><BR>
&nbsp;&nbsp;<A HREF="#S_e.htm">DiskFindResult ...</A><BR>
&nbsp;&nbsp;<A HREF="#S_f.htm">DosNoDotFileName ...</A><BR>
&nbsp;&nbsp;<A HREF="#S_10.htm">EndOfSongFlags ...</A><BR>
&nbsp;&nbsp;<A HREF="#S_11.htm">EvalErrorData ...</A><BR>
&nbsp;&nbsp;<A HREF="#S_12.htm">FALSE ...</A><BR>
&nbsp;&nbsp;<A HREF="#S_13.htm">FileAttrs ...</A><BR>
&nbsp;&nbsp;<A HREF="#S_14.htm">FileDateAndTime ...</A><BR>
&nbsp;&nbsp;<A HREF="#S_15.htm">FileFromTransferBlockID ...</A><BR>
&nbsp;&nbsp;<A HREF="#S_16.htm">FontFamily ...</A><BR>
&nbsp;&nbsp;<A HREF="#S_17.htm">FontID ...</A><BR>
&nbsp;&nbsp;<A HREF="#S_18.htm">FontMaker ...</A><BR>
&nbsp;&nbsp;<A HREF="#S_19.htm">GCM_info ...</A><BR>
&nbsp;&nbsp;<A HREF="#S_1a.htm">GCNStandardListType ...</A><BR>
&nbsp;&nbsp;<A HREF="#S_1b.htm">GeodeToken ...</A><BR>
&nbsp;&nbsp;<A HREF="#S_1c.htm">GeoworksMediumID ...</A><BR>
&nbsp;&nbsp;<A HREF="#S_1d.htm">GeoWorksVisContentGCNListType ...</A><BR>
&nbsp;&nbsp;<A HREF="#S_1e.htm">GStringElement ...</A><BR>
&nbsp;&nbsp;<A HREF="#S_1f.htm">GStringErrorType ...</A><BR>
&nbsp;&nbsp;<A HREF="#S_20.htm">HeapCongestion ...</A><BR>
&nbsp;&nbsp;<A HREF="#S_21.htm">IMCFeatures ...</A><BR>
&nbsp;&nbsp;<A HREF="#S_22.htm">InkControlFeatures ...</A><BR>
&nbsp;&nbsp;<A HREF="#S_23.htm">InstrumentPatch ...</A><BR>
&nbsp;&nbsp;<A HREF="#S_24.htm">InstrumentTable ...</A><BR>
&nbsp;&nbsp;<A HREF="#S_25.htm">Language ...</A><BR>
&nbsp;&nbsp;<A HREF="#S_26.htm">LMemType ...</A><BR>
&nbsp;&nbsp;<A HREF="#S_27.htm">LocalNumericFormat ...</A><BR>
&nbsp;&nbsp;<A HREF="#S_28.htm">MediumUnitType ...</A><BR>
&nbsp;&nbsp;<A HREF="#S_29.htm">MixMode ...</A><BR>
&nbsp;&nbsp;<A HREF="#S_2a.htm">NULL ...</A><BR>
&nbsp;&nbsp;<A HREF="#S_2b.htm">OperatorType ...</A><BR>
&nbsp;&nbsp;<A HREF="#S_2c.htm">ParserFlags ...</A><BR>
&nbsp;&nbsp;<A HREF="#S_2d.htm">ParserTokenData ...</A><BR>
&nbsp;&nbsp;<A HREF="#S_2e.htm">Point ...</A><BR>
&nbsp;&nbsp;<A HREF="#S_2f.htm">ProtocolNumber ...</A><BR>
&nbsp;&nbsp;<A HREF="#S_30.htm">RangeSortFlags ...</A><BR>
&nbsp;&nbsp;<A HREF="#S_31.htm">ReleaseNumber ...</A><BR>
&nbsp;&nbsp;<A HREF="#S_32.htm">ScannerTokenCellData ...</A><BR>
&nbsp;&nbsp;<A HREF="#S_33.htm">SerialBaud ...</A><BR>
&nbsp;&nbsp;<A HREF="#S_34.htm">Socket ...</A><BR>
&nbsp;&nbsp;<A HREF="#S_35.htm">SocketError ...</A><BR>
&nbsp;&nbsp;<A HREF="#S_36.htm">SocketLoadType ...</A><BR>
&nbsp;&nbsp;<A HREF="#S_37.htm">SoundPlayFlags ...</A><BR>
&nbsp;&nbsp;<A HREF="#S_38.htm">SpecWidth ...</A><BR>
&nbsp;&nbsp;<A HREF="#S_39.htm">SpoolInfoType ...</A><BR>
&nbsp;&nbsp;<A HREF="#S_3a.htm">StandardDialog4ResponseTriggerTable ...</A><BR>
&nbsp;&nbsp;<A HREF="#S_3b.htm">StyleElementFlags ...</A><BR>
&nbsp;&nbsp;<A HREF="#S_3c.htm">SystemDrawMask ...</A><BR>
&nbsp;&nbsp;<A HREF="#S_3d.htm">TextMode ...</A><BR>
&nbsp;&nbsp;<A HREF="#S_3e.htm">TextReferenceType ...</A><BR>
&nbsp;&nbsp;<A HREF="#S_3f.htm">TimerHandle ...</A><BR>
&nbsp;&nbsp;<A HREF="#S_40.htm">TravelOption ...</A><BR>
&nbsp;&nbsp;<A HREF="#S_41.htm">UndoActionStruct ...</A><BR>
&nbsp;&nbsp;<A HREF="#S_42.htm">VChar ...</A><BR>
&nbsp;&nbsp;<A HREF="#S_43.htm">VisRulerType ...</A><BR>
&nbsp;&nbsp;<A HREF="#S_44.htm">VMOpenType ...</A><BR>
</STRONG>
</P> <!-- end of sectionlinks blob -->
<HR>
<A NAME="S_1.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="S_1.htm_IX_AccessPointStandardProperty">
 </A>
<H1 CLASS="refHeading">
AccessPointStandardProperty</H1>
<PRE CLASS="syntax">typedef enum {
        APSP_NAME = 0x0,
        APSP_PHONE = 0x2,
        APSP_USER = 0x4,
        APSP_SECRET = 0x6,
        APSP_ADDRESS = 0x8,
        APSP_MASK = 0xa,
        APSP_GATEWAY = 0xc,
        APSP_DNS1 = 0xe,
        APSP_DNS2 = 0x10,
        APSP_DATA_BITS = 0x12,
        APSP_STOP_BITS = 0x14,
        APSP_PARITY = 0x16,
        APSP_DUPLEX = 0x18,
        APSP_MODEM_INIT = 0x1a,
        APSP_BS = 0x1c,
        APSP_HOSTNAME = 0x1e,
        APSP_INTERNET_ACCPNT = 0x20,
        APSP_PROMPT_SECRET = 0x22,					/* This property is an integer */
        APSP_AUTOMATIC = 0x4000,
        APSP_UNDEFINED = 0xffff,

             /* The following are only available on build 4 or more recent
                of the Nokia 9000i Communicator. */

        APSP_USE_LOGIN_APP = 0x24,
        APSP_LOGIN_APP_NAME = 0x26,
        APSP_SCRIPT_NAME = 0x28,
        APSP_CCARD_NAME = 0x2a,
        APSP_CCARD_ACCESS = 0x2c,
        APSP_CCARD_ID = 0x2e,
        APSP_CCARD_PREFIX = 0x30,
        APSP_CCARD_SEQUENCE = 0x32,
        APSP_COMPRESSION = 0x34,  
} AccessPointStandardProperty;</PRE>
<P>
All of the property data associated with these standard properties are strings, except where noted.</P>
<P>
Any <CODE>
AccessPointStandardProperty</CODE>
 value can be combined (bitwise-OR'd) with APSP_AUTOMATIC to make an alternative form of the name.  This library puts no special interpretation on automatic names, but they are intended to represent values which are obtained from automatic configuration and not from the user.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	accpnt.goh</P>
</DIV>
<DIV>
<A NAME="S_1.htm_IX_AccessPointType">
 </A>
<H1 CLASS="refHeading">
AccessPointType</H1>
<PRE CLASS="syntax">typedef enum {
    APT_INTERNET = 0x1,
    APT_TERMINAL,
    APT_TELNET,
    APT_APP_LOCAL,
} AccessPointType;
#define APT_ALL (0)</PRE>
<P CLASS="refField"><STRONG>
Include:</STRONG>	accpnt.goh</P>
</DIV>
<DIV>
<A NAME="S_1.htm_IX_AUAF_&ldots;">
 </A>
<A NAME="S_1.htm_IX_AddUndoActionFlags">
 </A>
<H1 CLASS="refHeading">
AddUndoActionFlags</H1>
<PRE CLASS="syntax">typedef WordFlags AddUndoActionFlags;
#define AUAF_NOTIFY_BEFORE_FREEING											 		  			0x8000
#define AUAF_NOTIFY_IF_FREED_WITHOUT_BEING_PLAYED_BACK		 0x4000</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_1.htm_IX_AUAS_&ldots;">
 </A>
<A NAME="S_1.htm_IX_AddUndoActionStruct">
 </A>
<H1 CLASS="refHeading">
AddUndoActionStruct</H1>
<PRE CLASS="syntax">typedef struct {
UndoActionStruct 				AUAS_data;
optr 				AUAS_output;
AddUndoActionFlags 				AUAS_flags;
} AddUndoActionStruct;</PRE>
<P>
The &quot;undo&quot; structures work together to provide information vital to processes which will be working with undo events.</P>
</DIV>
<DIV>
<A NAME="S_1.htm_IX_AppAttachFlags">
 </A>
<A NAME="S_1.htm_IX_AAF_&ldots;">
 </A>
<H1 CLASS="refHeading">
AppAttachFlags</H1>
<PRE CLASS="syntax">typedef WordFlags AppAttachFlags;
#define AAF_RESTORING_FROM_STATE						0x8000
#define AAF_STATE_FILE_PASSED						0x4000
#define AAF_DATA_FILE_PASSED						0x2000</PRE>
<P>
These flags are passed to the process when the application is launching or being restored from a state file. The flags indicate whether the application is being launched from a state file, has a state file, and/or has a data file.</P>
<P>
Note that if AAF_RESTORING_FROM_STATE is set, then AAF_STATE_FILE_PASSED will also be set.</P>
</DIV>
<DIV>
<A NAME="S_1.htm_IX_AppInstanceReference">
 </A>
<A NAME="S_1.htm_IX_AIR_&ldots;">
 </A>
<H1 CLASS="refHeading">
AppInstanceReference</H1>
<PRE CLASS="syntax">typedef struct {
/* AIR_fileName:
 * Application being launched. Pathname is relative to application 
 * directory (which, of course, may be overriden with a direct path
 * to the application). */
PathName 				AIR_fileName;</PRE>
<PRE CLASS="syntax">/* AIR_stateFile:
 * State filename. File is assumed to be in standard directory for
 * GEOS state files. If the first byte is &quot;0&quot;, then there is no
 * state file for this application. This structure is copied into the
 * field as an aid in restarting applications, and if it comes across
 * one with this byte as 0, it will not restart it. */
FileLongName 				AIR_stateFile;</PRE>
<PRE CLASS="syntax">/* AIR_diskHandle:
 * Disk handle for app (passed in) IF 0, use System disk, if -1, use
 * AIR_diskName. In the field, if this is a placeholder structure, this
 * word is the handle of the application object we are waiting to detach. */
DiskHandle 				AIR_diskHandle;</PRE>
<PRE CLASS="syntax">/* AIR_savedDiskData:
 * Start of data stored by DiskSave when instance is saved to state file. */
byte 				AIR_savedDiskData[1];</PRE>
<PRE CLASS="syntax">} AppInstanceReference;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_1.htm_IX_AppLaunchBlock">
 </A>
<A NAME="S_1.htm_IX_ALB_&ldots;">
 </A>
<H1 CLASS="refHeading">
AppLaunchBlock</H1>
<PRE CLASS="syntax">typedef struct {
/* ALB_appRef:
 * Instance reference. Contains full pathname to application, as 
 * referenced from app directory, plus the name of a state file. 
 * Is enough info to launch application again, restored. (State file 
 * need not be passed to GeodeLoad) */
AppInstanceReference 				ALB_appRef;</PRE>
<PRE CLASS="syntax">/* ALB_appMode:
 * Application attach mode method. Should be one of the following:
 * MSG_GEN_PROCESS_RESTORE_FROM_STATE:
 * 	State file must be passed; no data file should be passed.
 * MSG_GEN_PROCESS_OPEN_APPLICATION:
 * 	State file normally should not be passed, although one could be to
 * 	accomplish ui templates. A data file may be passed into the 
 * 	application as well.
 * MSG_GEN_PROCESS_OPEN_ENGINE:
 * 	State file normally should not be passed. The data file on which the 
 * 	engine will operate must be passed. If zero, the default data file 
 * 	should be used (enforced by app, not GenProcessClass).*/
Message 				ALB_appMode;</PRE>
<PRE CLASS="syntax">/* ALB_launchFlags:
 * Miscellaneous flags to specify desired application launch type. */
AppLaunchFlags 				ALB_launchFlags;</PRE>
<PRE CLASS="syntax">/* ALB_diskHandle:
 * Disk handle for data path. (Set as application's current path in 
 * GenProcess' MSG_META_ATTACH handler.) */
MemHandle 				ALB_diskHandle;</PRE>
<PRE CLASS="syntax">/* ALB_path:
 * Data path for application to use as initial path. (Usually this is 
 * a directory of any data file passed.) (Set as application current
 * path in GenProcess' MSG_META_ATTACH handler.)
char 				ALB_path[PATH_BUFFER_SIZE];</PRE>
<PRE CLASS="syntax">/* ALB_dataFile:
 * Name of data file passed in to be opened (0 if none). Pathname is 
 * relative to above path. */
char 				ALB_dataFile[PATH_BUFFER_SIZE];</PRE>
<PRE CLASS="syntax">/* ALB_genParent:
 * Generic parent for new application (0 to put on default field). (Should 
 * be passed NULL to MSG_GEN_FIELD_LAUNCH_APPLICATION).
optr 				ALB_genParent;</PRE>
<PRE CLASS="syntax">/* ALB_userLoadAckOutput, ALB_userLoadAckMessage:
 * Together, these form an Action Descriptor which will be activated when 
 * the application has been launched (used in conjunction with 
 * ALF_SEND_LAUNCH_REQUEST_TO_UI_TO_HANDLE). (Set to NULL/0 if you don't 
 * want to send anything). 
 * The acknowledgement will come with three arguments: the GeodeHandle 
 * (non-NULL if successful), a word value which will be zero if there was
 * an error, and the word value set in ALB_userLoackAckID (below).*/
optr 				ALB_userLoadAckOutput;</PRE>
<PRE CLASS="syntax">Message 				ALB_userLoadAckMessage;
/* ALB_userLoadAckID:
 * ID sent out via above action descriptor, if any. */
word 				ALB_userLoadAckID;</PRE>
<PRE CLASS="syntax">/* ALB_extraData:
 * Extra data to send to process (possibly a handle to 
 * block containing arguments). */
word 				ALB_extraData;</PRE>
<PRE CLASS="syntax">} AppLaunchBlock;</PRE>
<P>
This structure is used when an application is first starting up. It is an argument of various messages which will be intercepted by system classes. The first fields (<CODE>
ALB_appRef</CODE>
, <CODE>
ALB_appMode</CODE>
, <CODE>
ALB_launchFlags</CODE>
, and <CODE>
ALB_uiLevel</CODE>
) are preserved in the application's state file. The other information must be set correctly on launch.</P>
</DIV>
<HR>
<A NAME="S_2.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="S_2.htm_IX_AppLaunchFlags">
 </A>
<A NAME="S_2.htm_IX_ALF_&ldots;">
 </A>
<H1 CLASS="refHeading">
AppLaunchFlags</H1>
<PRE CLASS="syntax">typedef ByteFlags AppLaunchFlags;
#define ALF_SEND_LAUNCH_REQUEST_TO_UI_TO_HANDLE											0x80
#define ALF_OPEN_IN_BACK											0x40</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_2.htm_IX_ApplicationStates">
 </A>
<A NAME="S_2.htm_IX_AS_&ldots;">
 </A>
<H1 CLASS="refHeading">
ApplicationStates</H1>
<PRE CLASS="syntax">typedef ByteFlags ApplicationStates;
#define AS_QUITTING								0x80
#define AS_DETACHING								0x40
#define AS_FOCUSABLE 								0x20
#define AS_MODELABLE 								0x10
#define AS_NOT_USER_INTERACTABLE 								0x08
#define AS_RECEIVED_APP_OBJECT_DETACH 								0x04
#define AS_ATTACHED_TO_STATE_FILE 								0x02
#define AS_ATTACHING 								0x01</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_2.htm_IX_ArcCloseType">
 </A>
<A NAME="S_2.htm_IX_ACT_&ldots;">
 </A>
<H1 CLASS="refHeading">
ArcCloseType</H1>
<PRE CLASS="syntax">typedef enum /* word */ {
ACT_OPEN,
ACT_CHORD,
ACT_PIE
} ArcCloseType;</PRE>
<P>
This structure is used when filling arcs.</P>
</DIV>
<DIV>
<A NAME="S_2.htm_IX_AreaAttr">
 </A>
<A NAME="S_2.htm_IX_AA_&ldots;">
 </A>
<H1 CLASS="refHeading">
AreaAttr</H1>
<PRE CLASS="syntax">typedef struct {
byte 		AA_colorFlag;
RGBValue 		AA_color;
SysDrawMask 		AA_mask;
ColorMapMode		AA_mapMode;
} AreaAttr;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_2.htm_IX_ArgumentStackElement">
 </A>
<A NAME="S_2.htm_IX_ASE_&ldots;">
 </A>
<H1 CLASS="refHeading">
ArgumentStackElement</H1>
<PRE CLASS="syntax">typedef struct {
EvalStackArgumentType ASE_type;
EvalStackArgumentData ASE_data;
} ArgumentStackElement;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_2.htm_IX_BBFixed">
 </A>
<A NAME="S_2.htm_IX_BBF_&ldots;">
 </A>
<H1 CLASS="refHeading">
BBFixed</H1>
<PRE CLASS="syntax">typedef struct {
byte BBF_frac;
byte BBF_int;
} BBFixed;</PRE>
<P>
This structure represents an 8.8 fixed point number.</P>
</DIV>
<DIV>
<A NAME="S_2.htm_IX_BBFixedAsWord">
 </A>
<H1 CLASS="refHeading">
BBFixedAsWord</H1>
<PRE CLASS="syntax">typedef word BBFixedAsWord;</PRE>
<P>
This structure represents an 8.8 fixed point number.</P>
</DIV>
<DIV>
<A NAME="S_2.htm_IX_Bitmap">
 </A>
<A NAME="S_2.htm_IX_B_&ldots;">
 </A>
<A NAME="S_2.htm_IX_BMT_MASK:bitmaps with masks">
 </A>
<A NAME="S_2.htm_IX_BMC_PACKBITS:uncompressing">
 </A>
<A NAME="S_2.htm_IX_PackBits compression">
 </A>
<H1 CLASS="refHeading">
<A NAME="S_2.htm_72157">
 </A>
Bitmap</H1>
<PRE CLASS="syntax">typedef struct {
word	B_width;				/* In bitmap pixels */
word	B_height;				/* In bitmap pixels */
byte	B_compact;				/* A BMCompact value */
byte	B_type;				/* A BMFormat | BMType value */
} Bitmap;</PRE>
<P>
This data structure provides some information about a simple graphics bitmap. It normally acts as the header for a set of bitmap data.</P>
<P>
The bitmap data itself is organized into scan lines. If the bitmap has a mask (if the BMT_MASK bit is set in the <CODE>
B_type</CODE>
 field), the first information for the scan line will be its mask information. There will be one bit of mask information for each pixel in the scan line (i.e. a number of bits equal to the bitmap width). The actual bitmap data for the scan line starts at the next byte boundary. For each pixel there will be a number of bits of color data, said number depending on the <CODE>
BMFormat</CODE>
 value in the <CODE>
B_type</CODE>
 field. The data for the next scan line will begin at the next byte boundary.</P>
<P>
Thus, a 7x7 bitmap depicting an inverse &quot;x&quot; might appear:</P>
<PRE>(Bitmap)		{7, 7, BMC_UNCOMPACTED, BMF_MONO };
(byte)[]		{0x82, 		/* 10000010 */
		 0x44, 		/* 01000100 */
		 0x28, 		/* 00101000 */
		 0x10, 		/* 00010000 */
		 0x28, 		/* 00101000 */
		 0x44, 		/* 01000100 */
		 0x82 }; 		/* 10000010 */</PRE>
<P>
A 3x3 color &quot;-&quot; shape with a a &quot;+&quot; shaped mask might appear:</P>
<PRE>(Bitmap)		{ 3, 3, BMC_UNCOMPACTED, 
		 (BMF_4BIT | BMT_MASK)};
(byte) []		{/* scan line 1: */
		 0x40, 		/* mask: 010 */
		 0, 0		/* data: 000 */

		 /* scan line 2: */
		 0xE0, 		/* mask: 111 */
		 0x43, 0x20, 		/* data: 432 */ 

		 /* scan line 3: */
		 0x40, 		/* mask: 010 */
		 0, 0 };		/* data: 000 */</PRE>
<P>
If standard BMC_PACKBITS compression is used, then the mask (if any) and color data for the bitmap is compressed using the Macintosh PackBits standard. Under this system, to uncompress the data for a scan line, follow the loop:</P>
<OL>
<LI>
Read a byte. </LI>
<LI FIXME_NumListOther>
If the byte read in step (1) is between -1 and -127, read the <EM>
next</EM>
 byte and copy it into the target buffer from +2 to +128 times. </LI>
<LI FIXME_NumListOther>
If the byte read in step (1) is between +1 and +127, read the next 1 to 127 bytes and copy them into the target buffer.</LI>
<LI FIXME_NumListOther>
If the byte read in step (1) is -128, ignore it.</LI>
<LI FIXME_NumListOther>
You're ready to read in the next batch of data; go back to step (1).</LI>
</OL>
<P>
Thus a 16x4 color &quot;=&quot; with a matching mask would appear:</P>
<PRE>(Bitmap) 	{15, 3, BMC_PACKBITS, BMF_4BIT | BMT_MASK } ;
(byte) []		{/* scan line 1: */
			/* mask: 2 repetitions of 0xff */
		 0xff, 0xff, 
			/* data: 16 repetitions of 0x14 */
		 0xf0, 0x14, 
		/* scan line 2: */
			/* mask: 2 repetitions of 0x00 */
			/* data: 16 repetitions of 0x00 */
			/* total: 18 repetitions of 0x00 */
		 0xee, 0x00, 
		/* scan line 3: */
			/* mask: 2 repetitions of 0x00 */
			/* data: 16 repetitions of 0x00 */
			/* total: 18 repetitions of 0x00 */
		 0xee, 0x00, 
		/* scan line 4: */</PRE>
<PRE>			/* mask: 2 repetitions of 0xff */</PRE>
<PRE>		 0xff, 0xff, </PRE>
<PRE>			/* data: 16 repetitions of 0x14 */</PRE>
<PRE>		 0xf0, 0x14};</PRE>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Structs/S_3.htm#IX_CBitmap">CBitmap</A></CODE>.</P>
</DIV>
<HR>
<A NAME="S_3.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="S_3.htm_IX_BitmapMode">
 </A>
<A NAME="S_3.htm_IX_BM_&ldots;">
 </A>
<H1 CLASS="refHeading">
BitmapMode</H1>
<PRE CLASS="syntax">typedef WordFlags BitmapMode;
#define BM_EDIT_MASK					0x0002
#define BM_CLUSTERED_DITHER					0x0001</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_3.htm_IX_BlockFromTransferBlockID() macro">
 </A>
<H1 CLASS="refHeading">
BlockFromTransferBlockID</H1>
<PRE CLASS="syntax">VMBlockHandle BlockFromTransferBlockID(id);
        TransferBlockID		id;</PRE>
<P>
This macro extracts the block handle from the given <CODE>
TransferBlockID</CODE>
 value.</P>
</DIV>
<DIV>
<A NAME="S_3.htm_IX_BlockIDFromFileAndBlock() macro">
 </A>
<H1 CLASS="refHeading">
BlockIDFromFileAndBlock</H1>
<PRE CLASS="syntax">TransferBlockID BlockIDFromFileAndBlock(f, b);
        VMFileHandle		f;
        VMBlockHandle		b;</PRE>
<P>
This macro creates a <CODE>
TransferBlockID</CODE>
 value from the given file and block handles.</P>
</DIV>
<DIV>
<A NAME="S_3.htm_IX_BLTMode">
 </A>
<H1 CLASS="refHeading">
BLTMode</H1>
<P>
See <CODE>
<A HREF="../../CRef/Routines/R_37.htm#IX_GrBitBlt()">GrBitBlt()</A></CODE>
.</P>
</DIV>
<DIV>
<A NAME="S_3.htm_IX_BMCompact">
 </A>
<A NAME="S_3.htm_IX_BMC_&ldots;">
 </A>
<H1 CLASS="refHeading">
BMCompact</H1>
<PRE CLASS="syntax">typedef ByteEnum ByteCompact;
#define BMC_UNCOMPACTED				0
#define BMC_PACKBITS				1
#define BMC_USER_DEFINED				0x80</PRE>
<P>
This data structure is used to specify what sort of compaction is used to store a graphics bitmap.</P>
</DIV>
<DIV>
<A NAME="S_3.htm_IX_BMDestroy">
 </A>
<H1 CLASS="refHeading">
BMDestroy</H1>
<P>
See entry for <CODE>
<A HREF="../../CRef/Routines/R_39.htm#IX_GrDestroyBitmap()">GrDestroyBitmap()</A></CODE>
.</P>
</DIV>
<DIV>
<A NAME="S_3.htm_IX_BMFormat">
 </A>
<A NAME="S_3.htm_IX_BMF_&ldots;">
 </A>
<H1 CLASS="refHeading">
BMFormat</H1>
<PRE CLASS="syntax">typedef ByteEnum BMFormat
#define BMF_MONO 0
#define BMF_4BIT 1
#define BMF_8BIT 2
#define BMF_24BIT 3
#define BMF_4CMYK 4</PRE>
<P>
This enumerated type determines a graphics bitmap's depth.</P>
</DIV>
<DIV>
<A NAME="S_3.htm_IX_BMType">
 </A>
<A NAME="S_3.htm_IX_BMT_&ldots;">
 </A>
<H1 CLASS="refHeading">
BMType</H1>
<PRE CLASS="syntax">typedef ByteFlags BMType;
#define BMT_PALETTE				0x40
#define BMT_HUGE 				0x20
#define BMT_MASK 				0x10
#define BMT_COMPLEX 				0x08
#define BMT_FORMAT 				0x07</PRE>
<P>
This structure is used to store various facts about a graphics bitmap.</P>
</DIV>
<DIV>
<A NAME="S_3.htm_IX_Boolean">
 </A>
<H1 CLASS="refHeading">
Boolean</H1>
<PRE CLASS="syntax">typedef word Boolean;</PRE>
<P>
Booleans represent true/false values. If the Boolean is <EM>
false</EM>
, it will evaluate to zero; otherwise, it will be non-zero.</P>
</DIV>
<DIV>
<A NAME="S_3.htm_IX_Button">
 </A>
<A NAME="S_3.htm_IX_BUTTON_&ldots;">
 </A>
<H1 CLASS="refHeading">
Button</H1>
<PRE CLASS="syntax">typedef ByteEnum Button;
#define BUTTON_0				0
#define BUTTON_1				1
#define BUTTON_2				2
#define BUTTON_3				3</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_3.htm_IX_ButtonInfo">
 </A>
<A NAME="S_3.htm_IX_BI_&ldots;">
 </A>
<H1 CLASS="refHeading">
ButtonInfo</H1>
<PRE CLASS="syntax">typedef ByteFlags ButtonInfo;
#define BI_PRESS				0x80
#define BI_DOUBLE_PRESS 				0x40
#define BI_B3_DOWN 				0x20
#define BI_B2_DOWN 				0x10
#define BI_B1_DOWN 				0x08
#define BI_B0_DOWN 				0x04
#define BI_BUTTON 				0x03</PRE>
<P>
This structure contains the state of a mouse's buttons.</P>
</DIV>
<DIV>
<A NAME="S_3.htm_IX_byte">
 </A>
<H1 CLASS="refHeading">
byte</H1>
<PRE CLASS="syntax">typedef unsigned char byte;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_3.htm_IX_ByteEnum">
 </A>
<H1 CLASS="refHeading">
ByteEnum</H1>
<PRE CLASS="syntax">typedef byte ByteEnum;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_3.htm_IX_ByteFlags">
 </A>
<H1 CLASS="refHeading">
ByteFlags</H1>
<PRE CLASS="syntax">typedef byte ByteFlags;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_3.htm_IX_CallbackType">
 </A>
<A NAME="S_3.htm_IX_CT_&ldots;  (CallbackType type)">
 </A>
<H1 CLASS="refHeading">
CallbackType</H1>
<PRE CLASS="syntax">typedef ByteEnum CallbackType;
#define CT_FUNCTION_TO_TOKEN					0
#define CT_NAME_TO_TOKEN 					1
#define CT_CHECK_NAME_EXISTS 					2
#define CT_CHECK_NAME_SPACE 					3
#define CT_EVAL_FUNCTION 					4
#define CT_LOCK_NAME 					5
#define CT_UNLOCK 					6
#define CT_FORMAT_FUNCTION 					7
#define CT_FORMAT_NAME 					8
#define CT_CREATE_CELL					9
#define CT_EMPTY_CELL 					10
#define CT_NAME_TO_CELL 					11
#define CT_FUNCTION_TO_CELL 					12
#define CT_DEREF_CELL 					13
#define CT_SPECIAL_FUNCTION 					14</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_3.htm_IX_CBitmap">
 </A>
<A NAME="S_3.htm_IX_CB_&ldots;">
 </A>
<H1 CLASS="refHeading">
CBitmap</H1>
<PRE CLASS="syntax">typedef struct {
Bitmap 	CB_simple;
word 	CB_startScan;
word 	CB_numScans;
word 	CB_devInfo;
word 	CB_data;
word 	CB_palette;
word 	CB_xres;
word	CB_yres;
} CBitmap;</PRE>
<P>
The CBitmap structure contains the information for a &quot;complex&quot; bitmap. Use the CBitmap structure to hold bitmaps which need to keep track of resolution information, a palette, or a mask.</P>
</DIV>
<HR>
<A NAME="S_4.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="S_4.htm_IX_CellFunctionParameterFlags">
 </A>
<A NAME="S_4.htm_IX_CFPF_&ldots;">
 </A>
<H1 CLASS="refHeading">
CellFunctionParameterFlags</H1>
<PRE CLASS="syntax">typedef ByteFlags CellFunctionParameterFlags;
#define CFPF_DIRTY 0x80 /* apps may read or change this. */
#define CFPF_NO_FREE_COUNT 0x07</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_4.htm_IX_CellFunctionParameters">
 </A>
<A NAME="S_4.htm_IX_CFP_&ldots;">
 </A>
<A NAME="S_4.htm_IX_N_ROW_BLOCKS">
 </A>
<H1 CLASS="refHeading">
CellFunctionParameters</H1>
<PRE CLASS="syntax">typedef struct {
CellFunctionParameterFlags				CFP_flags;
VMFileHandle				CFP_file;						/* File containing cells */
VMBlockHandle				CFP_rowBlocks[N_ROW_BLOCKS];
} CellFunctionParameters;</PRE>
<P>
This structure is used to pass specifics about a cell file to the cell library routines. Some of the data in the <CODE>
CellFunctionParameters</CODE>
 structure is opaque to the application; others may be examined or changed by the application. The <CODE>
CellFunctionParameters</CODE>
 structure contains the following fields:</P>
<DL>
<DT>
<CODE>
CFP_flags</CODE>
</DT><DD>The cell library uses this byte for miscellaneous bookkeeping. When you create the structure, initialize this field to zero. There is only one flag which you should check or change; that is the flag <CODE>
CFPF_dirty</CODE>
. The cell library routines set this bit whenever they change the <CODE>
CellFunctionParameters</CODE>
 structure, thus indicating that the structure ought to be resaved. After you save it, you may clear this bit.</DD>
<DT>
<CODE>
CFP_file</CODE>
</DT><DD>This field must contain the VM file handle of the cell file. This field must be set each time you open the file.</DD>
<DT>
<CODE>
CFP_rowBlocks</DT><DD>
</CODE>
This field is an array of VM block handles, one for every existing or potential row block. The length of this array is N_ROW_BLOCKS (defined in <STRONG CLASS="fileName">
cell.h</STRONG>
). When you create a cell file, initialize all of these handles to zero; do not access or change this field thereafter.</DD>
</DL>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
cell.h</STRONG>
 </P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	The cell library expects the <CODE>
CellFunctionParameters</CODE>
 structure to remain motionless for the duration of a call. Therefore, if you allocate it as a DB item in the cell file, you must <EM>
not</EM>
 have the structure be an ungrouped item.</P>
</DIV>
<DIV>
<A NAME="S_4.htm_IX_CellRange">
 </A>
<A NAME="S_4.htm_IX_CR_&ldots;  (CellRange structure)">
 </A>
<H1 CLASS="refHeading">
CellRange</H1>
<PRE CLASS="syntax">typedef struct {
CellReference			CR_start;
CellReference			CR_end;
} CellRange;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_4.htm_IX_CellReference">
 </A>
<A NAME="S_4.htm_IX_CR_&ldots;  (CellReference structure)">
 </A>
<H1 CLASS="refHeading">
CellReference</H1>
<PRE CLASS="syntax">typedef struct {
CellRowColumn			CR_row;
CellRowColumn			CR_column;
} CellReference;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_4.htm_IX_CellRowColumn">
 </A>
<A NAME="S_4.htm_IX_CRC_&ldots;">
 </A>
<H1 CLASS="refHeading">
CellRowColumn</H1>
<PRE CLASS="syntax">typedef WordFlags CellRowColumn;
#define CRC_ABSOLUTE				0x8000
#define CRC_VALUE				0x7fff</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_4.htm_IX_CharacterSet">
 </A>
<A NAME="S_4.htm_IX_CS_&ldots;">
 </A>
<A NAME="S_4.htm_IX_VC_IS&ldots;">
 </A>
<H1 CLASS="refHeading">
CharacterSet</H1>
<PRE CLASS="syntax">typedef ByteEnum CharacterSet;
#define CS_BSW				0
#define CS_CONTROL 				0xff
#define CS_UI_FUNCS 				0xfe
#define VC_ISANSI 				CS_BSW
#define VC_ISCTRL 				CS_CONTROL
#define VC_ISUI 				CS_UI_FUNCS</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_4.htm_IX_CharFlags">
 </A>
<A NAME="S_4.htm_IX_CF_&ldots;  (CharFlags)">
 </A>
<H1 CLASS="refHeading">
CharFlags</H1>
<PRE CLASS="syntax">typedef ByteFlags CharFlags;
#define CF_STATE_KEY				0x80
#define CF_EXTENDED 				0x10
#define CF_TEMP_ACCENT 				0x08
#define CF_FIRST_PRESS 				0x04
#define CF_REPEAT_PRESS 				0x02
#define CF_RELEASE 				0x01</PRE>
<P>
&nbsp;</P>
</DIV>
<HR>
<A NAME="S_5.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="S_5.htm_IX_Chars">
 </A>
<A NAME="S_5.htm_IX_C_&ldots;  (Chars type)">
 </A>
<H1 CLASS="refHeading">
Chars</H1>
<PRE CLASS="syntax">typedef ByteEnum Chars;
#define C_NULL				0x0 /* NULL */
#define C_CTRL_A				0x1 /* &lt;ctrl&gt;-A */
#define C_CTRL_B				0x2 /* &lt;ctrl&gt;-B */
#define C_CTRL_C				0x3 /* &lt;ctrl&gt;-C */
#define C_CTRL_D				0x4 /* &lt;ctrl&gt;-D */
#define C_CTRL_E				0x5 /* &lt;ctrl&gt;-E */
#define C_CTRL_F				0x6 /* &lt;ctrl&gt;-F */
#define C_CTRL_G				0x7 /* &lt;ctrl&gt;-G */
#define C_CTRL_H				0x8 /* &lt;ctrl&gt;-H */
#define C_TAB				0x9 /* TAB */
#define C_LINEFEED				0xa /* LINE FEED */
#define C_CTRL_K				0xb /* &lt;ctrl&gt;-K */
#define C_CTRL_L				0xc /* &lt;ctrl&gt;-L */
#define C_ENTER				0xd /* ENTER or CR */
#define C_SHIFT_OUT				0xe /* &lt;ctrl&gt;-N */
#define C_SHIFT_IN				0xf /* &lt;ctrl&gt;-O */
#define C_CTRL_P				0x10 /* &lt;ctrl&gt;-P */
#define C_CTRL_Q				0x11 /* &lt;ctrl&gt;-Q */
#define C_CTRL_R				0x12 /* &lt;ctrl&gt;-R */
#define C_CTRL_S				0x13 /* &lt;ctrl&gt;-S */
#define C_CTRL_T				0x14 /* &lt;ctrl&gt;-T */
#define C_CTRL_U				0x15 /* &lt;ctrl&gt;-U */
#define C_CTRL_V				0x16 /* &lt;ctrl&gt;-V */
#define C_CTRL_W				0x17 /* &lt;ctrl&gt;-W */
#define C_CTRL_X				0x18 /* &lt;ctrl&gt;-X */
#define C_CTRL_Y				0x19 /* &lt;ctrl&gt;-Y */
#define C_CTRL_Z				0x1a /* &lt;ctrl&gt;-Z */
#define C_ESCAPE				0x1b /* ESC */
#define C_NULL_WIDTH				0x19 /* null width character */
#define C_GRAPHIC				0x1a /* Graphic in text. */
#define C_THINSPACE				0x1b /* 1/4 width space */
#define C_ENSPACE				0x1c /* En-space, fixed width */
#define C_EMSPACE				0x1d /* Em-space, fixed width. */
#define C_NONBRKHYPHEN				0x1e /* Non breaking hyphen. */
#define C_OPTHYPHEN				0x1f /* Optional hyphen, only drawn at eol */
#define C_SPACE				` '
#define C_EXCLAMATION				`!'
#define C_QUOTE				`&quot;'
#define C_NUMBER_SIGN				`#'
#define C_DOLLAR_SIGN				`$'
#define C_PERCENT				`%'
#define C_AMPERSAND				`&amp;'
#define C_SNG_QUOTE				0x27
#define C_LEFT_PAREN				`('
#define C_RIGHT_PAREN				`)'
#define C_ASTERISK				`*'
#define C_PLUS				`+'
#define C_COMMA				`,'
#define C_MINUS				`-'
#define C_PERIOD				 '.'
#define C_SLASH				`/'
#define C_ZERO				`0'
#define C_ONE				`1'
#define C_TWO				`2'
#define C_THREE 				`3'
#define C_FOUR 				`4'
#define C_FIVE 				`5'
#define C_SIX 				`6'
#define C_SEVEN 				`7'
#define C_EIGHT 				`8'
#define C_NINE 				`9'
#define C_COLON 				`:'
#define C_SEMICOLON 				`;'
#define C_LESS_THAN 				`&lt;'
#define C_EQUAL 				`='
#define C_GREATER_THAN 				`&gt;'
#define C_QUESTION_MARK 				`?'
#define C_AT_SIGN				0x40
#define C_CAP_A 				`A'
#define C_CAP_B 				`B'
#define C_CAP_C 				`C'
#define C_CAP_D 				`D'
#define C_CAP_E 				`E'
#define C_CAP_F 				`F'
#define C_CAP_G 				`G'
#define C_CAP_H 				`H'
#define C_CAP_I 				`I'
#define C_CAP_J 				`J'
#define C_CAP_K 				`K'
#define C_CAP_L 				`L'
#define C_CAP_M 				`M'
#define C_CAP_N 				`N'
#define C_CAP_O 				`O'
#define C_CAP_P 				`P'
#define C_CAP_Q 				`Q'
#define C_CAP_R 				`R'
#define C_CAP_S 				`S'
#define C_CAP_T 				`T'
#define C_CAP_U 				`U'
#define C_CAP_V 				`V'
#define C_CAP_W 				`W'
#define C_CAP_X 				`X'
#define C_CAP_Y 				`Y'
#define C_CAP_Z 				`Z'
#define C_LEFT_BRACKET				`['
#define C_BACKSLASH				0x5c
#define C_RIGHT_BRACKET				`]'
#define C_ASCII_CIRCUMFLEX				`^'
#define C_UNDERSCORE				`_'
#define C_BACKQUOTE				``'
#define C_SMALL_A				`a'
#define C_SMALL_B				`b'
#define C_SMALL_C				`c'
#define C_SMALL_D 				`d'
#define C_SMALL_E 				`e'
#define C_SMALL_F 				`f'
#define C_SMALL_G 				`g'
#define C_SMALL_H 				`h'
#define C_SMALL_I 				`i'
#define C_SMALL_J 				`j'
#define C_SMALL_K 				`k'
#define C_SMALL_L 				`l'
#define C_SMALL_M 				`m'
#define C_SMALL_N 				`n'
#define C_SMALL_O 				`o'
#define C_SMALL_P 				`p'
#define C_SMALL_Q 				`q'
#define C_SMALL_R 				`r'
#define C_SMALL_S 				`s'
#define C_SMALL_T 				`t'
#define C_SMALL_U 				`u'
#define C_SMALL_V 				`v'
#define C_SMALL_W 				`w'
#define C_SMALL_X 				`x'
#define C_SMALL_Y 				`y'
#define C_SMALL_Z 				`z'
#define C_LEFT_BRACE 				`{'
#define C_VERTICAL_BAR 				`|'
#define C_RIGHT_BRACE 				`}'
#define C_ASCII_TILDE 				`~'
#define C_DELETE				0x7f
#define C_UA_DIERESIS				0x80
#define C_UA_RING				0x81
#define C_UC_CEDILLA				0x82
#define C_UE_ACUTE				0x83
#define C_UN_TILDE				0x84
#define C_UO_DIERESIS				0x85
#define C_UU_DIERESIS				0x86
#define C_LA_ACUTE				0x87
#define C_LA_GRAVE				0x88
#define C_LA_CIRCUMFLEX				0x89
#define C_LA_DIERESIS				0x8a
#define C_LA_TILDE				0x8b
#define C_LA_RING				0x8c
#define C_LC_CEDILLA				0x8d
#define C_LE_ACUTE				0x8e
#define C_LE_GRAVE				0x8f
#define C_LE_CIRCUMFLEX				0x90
#define C_LE_DIERESIS				0x91
#define C_LI_ACUTE				0x92
#define C_LI_GRAVE				0x93
#define C_LI_CIRCUMFLEX				0x94
#define C_LI_DIERESIS				0x95
#define C_LN_TILDE				0x96
#define C_LO_ACUTE				0x97
#define C_LO_GRAVE				0x98
#define C_LO_CIRCUMFLEX				0x99
#define C_LO_DIERESIS				0x9a
#define C_LO_TILDE				0x9b
#define C_LU_ACUTE				0x9c
#define C_LU_GRAVE				0x9d
#define C_LU_CIRCUMFLEX				0x9e
#define C_LU_DIERESIS				0x9f
#define C_DAGGER				0xa0
#define C_DEGREE				0xa1
#define C_CENT				0xa2
#define C_STERLING				0xa3
#define C_SECTION				0xa4
#define C_BULLET				0xa5
#define C_PARAGRAPH				0xa6
#define C_GERMANDBLS				0xa7
#define C_REGISTERED				0xa8
#define C_COPYRIGHT				0xa9
#define C_TRADEMARK				0xaa
#define C_ACUTE				0xab
#define C_DIERESIS				0xac
#define C_NOTEQUAL				0xad
#define C_U_AE				0xae
#define C_UO_SLASH				0xaf
#define C_INFINITY				0xb0
#define C_PLUSMINUS				0xb1
#define C_LESSEQUAL				0xb2
#define C_GREATEREQUAL				0xb3
#define C_YEN				0xb4
#define C_L_MU				0xb5
#define C_L_DELTA				0xb6
#define C_U_SIGMA				0xb7
#define C_U_PI				0xb8
#define C_L_PI				0xb9
#define C_INTEGRAL				0xba
#define C_ORDFEMININE				0xbb
#define C_ORDMASCULINE				0xbc
#define C_U_OMEGA				0xbd
#define C_L_AE				0xbe
#define C_LO_SLASH				0xbf
#define C_QUESTIONDOWN				0xc0
#define C_EXCLAMDOWN				0xc1
#define C_LOGICAL_NOT				0xc2
#define C_ROOT				0xc3
#define C_FLORIN				0xc4
#define C_APPROX_EQUAL				0xc5
#define C_U_DELTA				0xc6
#define C_GUILLEDBLLEFT				0xc7
#define C_GUILLEDBLRIGHT				0xc8
#define C_ELLIPSIS				0xc9
#define C_NONBRKSPACE				0xca
#define C_UA_GRAVE				0xcb
#define C_UA_TILDE				0xcc
#define C_UO_TILDE				0xcd
#define C_U_OE				0xce
#define C_L_OE				0xcf
#define C_ENDASH				0xd0
#define C_EMDASH				0xd1
#define C_QUOTEDBLLEFT				0xd2
#define C_QUOTEDBLRIGHT				0xd3
#define C_QUOTESNGLEFT				0xd4
#define C_QUOTESNGRIGHT				0xd5
#define C_DIVISION				0xd6
#define C_DIAMONDBULLET				0xd7
#define C_LY_DIERESIS				0xd8
#define C_UY_DIERESIS				0xd9
#define C_FRACTION				0xda
#define C_CURRENCY				0xdb
#define C_GUILSNGLEFT				0xdc
#define C_GUILSNGRIGHT				0xdd
#define C_LY_ACUTE				0xde
#define C_UY_ACUTE				0xdf
#define C_DBLDAGGER				0xe0
#define C_CNTR_DOT				0xe1
#define C_SNGQUOTELOW				0xe2
#define C_DBLQUOTELOW				0xe3
#define C_PERTHOUSAND				0xe4
#define C_UA_CIRCUMFLEX				0xe5
#define C_UE_CIRCUMFLEX				0xe6
#define C_UA_ACUTE				0xe7
#define C_UE_DIERESIS				0xe8
#define C_UE_GRAVE				0xe9
#define C_UI_ACUTE				0xea
#define C_UI_CIRCUMFLEX				0xeb
#define C_UI_DIERESIS				0xec
#define C_UI_GRAVE				0xed
#define C_UO_ACUTE				0xee
#define C_UO_CIRCUMFLEX				0xef
#define C_LOGO				0xf0
#define C_UO_GRAVE				0xf1
#define C_UU_ACUTE				0xf2
#define C_UU_CIRCUMFLEX				0xf3
#define C_UU_GRAVE				0xf4
#define C_LI_DOTLESS				0xf5
#define C_CIRCUMFLEX				0xf6
#define C_TILDE				0xf7
#define C_MACRON				0xf8
#define C_BREVE				0xf9
#define C_DOTACCENT				0xfa
#define C_RING				0xfb
#define C_CEDILLA				0xfc
#define C_HUNGARUMLAT				0xfd
#define C_OGONEK				0xfe
#define C_CARON				0xff
/*
 * common shortcuts for low 32 codes
 */</PRE>
<PRE CLASS="syntax">#define C_NUL				C_NULL
#define C_STX				C_CTRL_B
#define C_ETX				C_CTRL_C
#define C_BEL				C_CTRL_G
#define C_BS				C_CTRL_H
#define C_HT				C_CTRL_I
#define C_VT				C_CTRL_K
#define C_FF				C_CTRL_L
#define C_SO				C_CTRL_N
#define C_SI				C_CTRL_O
#define C_DC1				C_CTRL_Q
#define C_DC2				C_CTRL_R
#define C_DC3				C_CTRL_S
#define C_DC4				C_CTRL_T
#define C_CAN				C_CTRL_X
#define C_EM				C_CTRL_Y
#define C_ESC				C_ESCAPE
/*
 * Some alternative names
 */</PRE>
<PRE CLASS="syntax">#define C_CR				C_ENTER
#define C_CTRL_M				C_ENTER
#define C_CTRL_I				C_TAB
#define C_CTRL_J				C_LINEFEED
#define C_LF				C_LINEFEED
#define C_CTRL_N				C_SHIFT_OUT
#define C_CTRL_O				C_SHIFT_IN
#define C_FS				C_ENSPACE
#define C_FIELD_SEP				C_FS
#define C_HYPHEN				C_MINUS
#define C_GRAVE				C_BACKQUOTE
#define C_PARTIAL_DIFF				C_L_DELTA
#define C_SUM				C_U_SIGMA
#define C_PRODUCT				C_U_PI
#define C_RADICAL				C_ROOT
#define C_LOZENGE				C_DIAMONDBULLET</PRE>
<P>
Text characters may be represented by the standard C type char or by the GEOS type Chars. The difference shows up in debugging. If printing the value of a string as char, then the debugger will output ASCII text. If the string is treated as Chars, then the debugger will print out the constant names.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
char.h</STRONG>
 </P>
</DIV>
<HR>
<A NAME="S_6.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="S_6.htm_IX_ChunkArrayHeader">
 </A>
<H1 CLASS="refHeading">
ChunkArrayHeader</H1>
<PRE CLASS="syntax">typedef struct {
word	CAH_count;			/* # of elements in chunk array */
word	CAH_elementSize;			/* Size of each element (in bytes) */
word	CAH_curOffset;			/* For internal use only */
word	CAH_offset;			/* Offset from start of chunk to first element */
} ChunkArrayHeader;</PRE>
<P>
Every chunk array begins with a <CODE>
ChunkArrayHeader</CODE>
. This structure contains information about the chunk array. Applications should never change the contents of the <CODE>
ChunkArrayHeader</CODE>
; only the chunk array routines should do this. However, applications can examine the header if they wish.</P>
<P CLASS="refField"><STRONG>
Contents:</STRONG>	There are four word-length fields in the <CODE>
ChunkArrayHeader</CODE>:</P>
<DL>
<DT>
CAH<CODE>
_count</DT><DD></CODE>
This word contains the number of elements in the chunk array.</DD>
<DT>
CAH<CODE>
_elementSize</DT><DD>
</CODE>
This word contains the size of each element (in bytes). If the elements are variable-sized, <CODE>
CAH_elementSize</CODE>
 will be zero.</DD>
<DT>
CAH<CODE>
_curOffset</DT><DD>
</CODE>
This word is used by <CODE>
<A HREF="../../CRef/Routines/R_7.htm#IX_ChunkArrayEnum()">ChunkArrayEnum()</A></CODE>
 for bookkeeping.</DD>
<DT>
CAH<CODE>
_offset</DT><DD></CODE>
This is the offset from the start of the chunk to the first element in the array.</DD>
</DIV>
<DIV>
Chunk handles are offsets into a local memory heap. To find the current <A NAME="S_6.htm_IX_ChunkHandle">
 </A>
</DL>
<H1 CLASS="refHeading">
ChunkHandle</H1>
<PRE CLASS="syntax">typedef word ChunkHandle;</PRE>
<P>
location of a chunk in an LMem heap, combine the segment address of the heap with the chunk handle. From this location you can read the current offset of the chunk itself.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Structs/S_2b.htm#IX_optr">optr</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_63.htm#IX_LMemDeref()">LMemDeref()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="S_6.htm_IX_ChunkMapList">
 </A>
<H1 CLASS="refHeading">
ChunkMapList</H1>
<PRE CLASS="syntax">typedef struct {
word	CML_source;
word	CML_dest;
} ChunkMapList;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_6.htm_IX_ClassFlags">
 </A>
<A NAME="S_6.htm_IX_CLASSF_&ldots;">
 </A>
<H1 CLASS="refHeading">
ClassFlags</H1>
<PRE CLASS="syntax">typedef ByteFlags ClassFlags;
#define CLASSF_HAS_DEFAULT						0x80
#define CLASSF_MASTER_CLASS 						0x40
#define CLASSF_VARIANT_CLASS 						0x20
#define CLASSF_DISCARD_ON_SAVE 						0x10
#define CLASSF_NEVER_SAVED						0x08
#define CLASSF_HAS_RELOC 						0x04
#define CLASSF_C_HANDLERS 						0x02</PRE>
<P>
This record is stored in the <CODE>
ClassStruct</CODE>
 structure's <CODE>
Class_flags</CODE>
 field. These flags are internal and may not be set or retrieved directly. See the entry on <CODE>
@class</CODE>
 for more information about these flags.</P>
</DIV>
<DIV>
<A NAME="S_6.htm_IX_ClassStruct">
 </A>
<A NAME="S_6.htm_IX_Class_&ldots;">
 </A>
<H1 CLASS="refHeading">
ClassStruct</H1>
<PRE CLASS="syntax">typedef	struct	_ClassStruct {
struct _ClassStruct *Class_superClass;		/* superclass pointer */
word		Class_masterOffset;					/* offset to master offset in chunk */
word 		Class_methodCount;					/* number of methods in this class */
word 		Class_instanceSize;					/* size of entire master group */
word 		Class_vdRelocTable;					/* offset to vardata relocation table */
word 		Class_relocTable;					/* offset to relocation table */
ClassFlags 		Class_flags;					/* a record of ClassFlags */
byte 		Class_masterMessages;					/* internal flags for optimization */
} ClassStruct;</PRE>
<P>
This is the structure that defines a class. It is internal and used only very rarely by anything other than the kernel and the UI.</P>
</DIV>
<DIV>
<A NAME="S_6.htm_IX_ClipboardItemFlags">
 </A>
<A NAME="S_6.htm_IX_CIF_QUICK">
 </A>
<A NAME="S_6.htm_IX_TIF_NORMAL">
 </A>
<H1 CLASS="refHeading">
ClipboardItemFlags</H1>
<PRE CLASS="syntax">typedef WordFlags ClipboardItemFlags;
#define CIF_QUICK				0x4000
#define TIF_NORMAL				0x0000</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_6.htm_IX_ClipboardItemFormat">
 </A>
<A NAME="S_6.htm_IX_CIF_&ldots;">
 </A>
<H1 CLASS="refHeading">
ClipboardItemFormat</H1>
<PRE CLASS="syntax">typedef enum /* word */ {
CIF_TEXT,
CIF_GRAPHICS_STRING,
CIF_FILES,
CIF_SPREADSHEET,
CIF_INK,
CIF_GROBJ,
CIF_GEODEX,
CIF_BITMAP,
CIF_SOUND_SYNTH,
CIF_SOUND_SAMPLE
} ClipboardItemFormat;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_6.htm_IX_ClipboardItemFormatID">
 </A>
<H1 CLASS="refHeading">
ClipboardItemFormatID</H1>
<PRE CLASS="syntax">typedef dword ClipboardItemFormatID;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_6.htm_IX_ClipboardItemFormatInfo">
 </A>
<A NAME="S_6.htm_IX_CIFI_&ldots;">
 </A>
<H1 CLASS="refHeading">
ClipboardItemFormatInfo</H1>
<PRE CLASS="syntax">typedef struct {
ClipboardItemFormatID				CIFI_format;
word				CIFI_extra1;
word				CIFI_extra2;
VMChain				CIFI_vmChain;
GeodeToken				CIFI_renderer;
} ClipboardItemFormatInfo;</PRE>
<P>
&nbsp;</P>
</DIV>
<HR>
<A NAME="S_7.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="S_7.htm_IX_ClipboardItemHeader">
 </A>
<A NAME="S_7.htm_IX_CIH_&ldots;">
 </A>
<H1 CLASS="refHeading">
ClipboardItemHeader</H1>
<PRE CLASS="syntax">typedef struct {
optr				CIH_owner;
ClipboardItemFlags				CIH_flags;
ClipboardItemNameBuffer				CIH_name;
word				CIH_formatCount;
optr				CIH_sourceID;
FormatArray				CIH_formats;
dword				CIH_reserved;
} ClipboardItemHeader;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_7.htm_IX_ClipboardItemNameBuffer">
 </A>
<A NAME="S_7.htm_IX_CLIPBOARD_ITEM_NAME_LENGTH">
 </A>
<H1 CLASS="refHeading">
ClipboardItemNameBuffer</H1>
<PRE CLASS="syntax">typedef char ClipboardItemNameBuffer[CLIPBOARD_ITEM_NAME_LENGTH+1];</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_7.htm_IX_ClipboardQueryArgs">
 </A>
<H1 CLASS="refHeading">
ClipboardQueryArgs</H1>
<P>
See <CODE>
<A HREF="../../CRef/Routines/R_b.htm#IX_ClipboardQueryItem()">ClipboardQueryItem()</A></CODE>
.</P>
</DIV>
<DIV>
<A NAME="S_7.htm_IX_ClipboardQuickNotifyFlags">
 </A>
<A NAME="S_7.htm_IX_CQNF_&ldots;">
 </A>
<H1 CLASS="refHeading">
ClipboardQuickNotifyFlags</H1>
<PRE CLASS="syntax">typedef WordFlags ClipboardQuickNotifyFlags;
#define CQNF_ERROR						0x8000
#define CQNF_SOURCE_EQUAL_DEST 						0x4000
#define CQNF_MOVE 						0x2000
#define CQNF_COPY 						0x1000
#define CQNF_NO_OPERATION 						0x0800
#define CQNF_UNUSED 						0x04ff</PRE>
<P>
These flags give information about the success or failure of a quick transfer operation.</P>
</DIV>
<DIV>
<A NAME="S_7.htm_IX_ClipboardQuickTransferFeedback">
 </A>
<A NAME="S_7.htm_IX_CQTF_&ldots;">
 </A>
<H1 CLASS="refHeading">
ClipboardQuickTransferFeedback</H1>
<PRE CLASS="syntax">typedef enum {
CQTF_SET_DEFAULT,
CQTF_CLEAR_DEFAULT,
CQTF_MOVE,
CQTF_COPY,
CQTF_CLEAR
} ClipboardQuickTransferFeedback;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_7.htm_IX_ClipboardQuickTransferFlags">
 </A>
<H1 CLASS="refHeading">
ClipboardQuickTransferFlags</H1>
<P>
See <CODE>
<A HREF="../../CRef/Routines/R_c.htm#IX_ClipboardStartQuickTransfer()">ClipboardStartQuickTransfer()</A></CODE>
.</P>
</DIV>
<DIV>
<A NAME="S_7.htm_IX_ClipboardQuickTransferRegionInfo">
 </A>
<H1 CLASS="refHeading">
ClipboardQuickTransferRegionInfo</H1>
<P>
See <CODE>
<A HREF="../../CRef/Routines/R_c.htm#IX_ClipboardStartQuickTransfer()">ClipboardStartQuickTransfer()</A></CODE>
.</P>
</DIV>
<DIV>
<A NAME="S_7.htm_IX_ClipboardRequestArgs">
 </A>
<H1 CLASS="refHeading">
ClipboardRequestArgs</H1>
<P>
See entry for <CODE>
<A HREF="../../CRef/Routines/R_b.htm#IX_ClipboardRequestItemFormat()">ClipboardRequestItemFormat()</A></CODE>
.</P>
</DIV>
<DIV>
<A NAME="S_7.htm_IX_CMYKTransfer">
 </A>
<A NAME="S_7.htm_IX_CMYKT_&ldots;">
 </A>
<H1 CLASS="refHeading">
CMYKTransfer</H1>
<PRE CLASS="syntax">typedef struct {
byte	CMYKT_cyan[256];
byte	CMYKT_magenta[256];
byte	CMYKT_yellow[256];
byte	CMYKT_black[256];
} CMYKTransfer;</PRE>
<P>
&nbsp;</P>
</DIV>
<HR>
<A NAME="S_8.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="S_8.htm_IX_C_&ldots;  (Color type)">
 </A>
<A NAME="S_8.htm_IX_Color">
 </A>
<H1 CLASS="refHeading">
Color</H1>
<PRE CLASS="syntax">typedef ByteEnum Color;
#define C_BLACK				0
#define C_BLUE 				1
#define C_GREEN 				2
#define C_CYAN 				3
#define C_RED 				4
#define C_VIOLET 				5
#define C_BROWN 				6
#define C_LIGHT_GRAY 				7
#define C_DARK_GRAY 				8
#define C_LIGHT_BLUE 				9
#define C_LIGHT_GREEN 				10
#define C_LIGHT_CYAN 				11
#define C_LIGHT_RED 				12
#define C_LIGHT_VIOLET 				13
#define C_YELLOW 				14
#define C_WHITE 				15
&nbsp;
#define C_GRAY_0 				0x10
#define C_GRAY_7 				0x11
#define C_GRAY_13				0x12
#define C_GRAY_20				0x13
#define C_GRAY_27 				0x14
#define C_GRAY_33 				0x15
#define C_GRAY_40 				0x16
#define C_GRAY_47 				0x17
#define C_GRAY_53 				0x18
#define C_GRAY_60 				0x19
#define C_GRAY_68 				0x1a
#define C_GRAY_73 				0x1b
#define C_GRAY_80 				0x1c
#define C_GRAY_88 				0x1d
#define C_GRAY_93 				0x1e
#define C_GRAY_100 				0x1f
&nbsp;
#define C_UNUSED_0 				0x20
#define C_UNUSED_1 				0x21
#define C_UNUSED_2 				0x22
#define C_UNUSED_3 				0x23
#define C_UNUSED_4 				0x24
#define C_UNUSED_5 				0x25
#define C_UNUSED_6 				0x26
#define C_UNUSED_7 				0x27
&nbsp;
#define C_R0_G0_B0 				0x28
#define C_R0_G0_B1 				0x29
#define C_R0_G0_B2 				0x2a
#define C_R0_G0_B3 				0x2b
#define C_R0_G0_B4 				0x2c
#define C_R0_G0_B5 				0x2d
#define C_R0_G1_B0 				0x2e
#define C_R0_G1_B1 				0x2f
#define C_R0_G1_B2 				0x30
#define C_R0_G1_B3 				0x31
#define C_R0_G1_B4 				0x32
#define C_R0_G1_B5 				0x33
#define C_R0_G2_B0 				0x34
#define C_R0_G2_B1 				0x35
#define C_R0_G2_B2 				0x36
#define C_R0_G2_B3 				0x37
#define C_R0_G2_B4 				0x38
#define C_R0_G2_B5 				0x39
&nbsp;
#define C_R0_G3_B0 				0x3a
#define C_R0_G3_B1 				0x3b
#define C_R0_G3_B2 				0x3c
#define C_R0_G3_B3 				0x3d
#define C_R0_G3_B4 				0x3e
#define C_R0_G3_B5 				0x3f
#define C_R0_G4_B0 				0x40
#define C_R0_G4_B1 				0x41
#define C_R0_G4_B2 				0x42
#define C_R0_G4_B3 				0x43
#define C_R0_G4_B4 				0x44
#define C_R0_G4_B5 				0x45
#define C_R0_G5_B0 				0x46
#define C_R0_G5_B1 				0x47
#define C_R0_G5_B2 				0x48
#define C_R0_G5_B3 				0x49
#define C_R0_G5_B4 				0x4a
#define C_R0_G5_B5 				0x4b
&nbsp;
#define C_R1_G0_B0 				0x4c
#define C_R1_G0_B1 				0x4d
#define C_R1_G0_B2 				0x4e
#define C_R1_G0_B3 				0x4f
#define C_R1_G0_B4 				0x50
#define C_R1_G0_B5 				0x51
#define C_R1_G1_B0 				0x52
#define C_R1_G1_B1 				0x53
#define C_R1_G1_B2 				0x54
#define C_R1_G1_B3 				0x55
#define C_R1_G1_B4 				0x56
#define C_R1_G1_B5 				0x57
#define C_R1_G2_B0 				0x58
#define C_R1_G2_B1 				0x59
#define C_R1_G2_B2 				0x5a
#define C_R1_G2_B3 				0x5b
#define C_R1_G2_B4 				0x5c
#define C_R1_G2_B5 				0x5d
&nbsp;
#define C_R1_G3_B0 				0x5e
#define C_R1_G3_B1 				0x5f
#define C_R1_G3_B2 				0x60
#define C_R1_G3_B3 				0x61
#define C_R1_G3_B4 				0x62
#define C_R1_G3_B5 				0x63
#define C_R1_G4_B0 				0x64
#define C_R1_G4_B1 				0x65
#define C_R1_G4_B2 				0x66
#define C_R1_G4_B3 				0x67
#define C_R1_G4_B4 				0x68
#define C_R1_G4_B5 				0x69
#define C_R1_G5_B0 				0x6a
#define C_R1_G5_B1 				0x6b
#define C_R1_G5_B2 				0x6c
#define C_R1_G5_B3 				0x6d
#define C_R1_G5_B4 				0x6e
#define C_R1_G5_B5 				0x6f
&nbsp;
#define C_R2_G0_B0 				0x70
#define C_R2_G0_B1 				0x71
#define C_R2_G0_B2 				0x72
#define C_R2_G0_B3 				0x73
#define C_R2_G0_B4 				0x74
#define C_R2_G0_B5 				0x75
#define C_R2_G1_B0 				0x76
#define C_R2_G1_B1 				0x77
#define C_R2_G1_B2 				0x78
#define C_R2_G1_B3 				0x79
#define C_R2_G1_B4 				0x7a
#define C_R2_G1_B5 				0x7b
#define C_R2_G2_B0 				0x7c
#define C_R2_G2_B1 				0x7d
#define C_R2_G2_B2 				0x7e
#define C_R2_G2_B3 				0x7f
#define C_R2_G2_B4 				0x80
#define C_R2_G2_B5 				0x81
&nbsp;
#define C_R2_G3_B0 				0x82
#define C_R2_G3_B1 				0x83
#define C_R2_G3_B2 				0x84
#define C_R2_G3_B3 				0x85
#define C_R2_G3_B4 				0x86
#define C_R2_G3_B5 				0x87
#define C_R2_G4_B0 				0x88
#define C_R2_G4_B1 				0x89
#define C_R2_G4_B2 				0x8a
#define C_R2_G4_B3 				0x8b
#define C_R2_G4_B4 				0x8c
#define C_R2_G4_B5 				0x8d
#define C_R2_G5_B0 				0x8e
#define C_R2_G5_B1 				0x8f
#define C_R2_G5_B2 				0x90
#define C_R2_G5_B3 				0x91
#define C_R2_G5_B4 				0x92
#define C_R2_G5_B5 				0x93
&nbsp;
#define C_R3_G0_B0 				0x94
#define C_R3_G0_B1 				0x95
#define C_R3_G0_B2 				0x96
#define C_R3_G0_B3 				0x97
#define C_R3_G0_B4 				0x98
#define C_R3_G0_B5 				0x99
#define C_R3_G1_B0 				0x9a
#define C_R3_G1_B1 				0x9b
#define C_R3_G1_B2 				0x9c
#define C_R3_G1_B3 				0x9d
#define C_R3_G1_B4 				0x9e
#define C_R3_G1_B5 				0x9f
#define C_R3_G2_B0 				0xa0
#define C_R3_G2_B1 				0xa1
#define C_R3_G2_B2 				0xa2
#define C_R3_G2_B3 				0xa3
#define C_R3_G2_B4 				0xa4
#define C_R3_G2_B5 				0xa5
&nbsp;
#define C_R3_G3_B0 				0xa6
#define C_R3_G3_B1 				0xa7
#define C_R3_G3_B2 				0xa8
#define C_R3_G3_B3 				0xa9
#define C_R3_G3_B4 				0xaa
#define C_R3_G3_B5 				0xab
#define C_R3_G4_B0 				0xac
#define C_R3_G4_B1 				0xad
#define C_R3_G4_B2 				0xae
#define C_R3_G4_B3 				0xaf
#define C_R3_G4_B4 				0xb0
#define C_R3_G4_B5 				0xb1
#define C_R3_G5_B0 				0xb2
#define C_R3_G5_B1 				0xb3
#define C_R3_G5_B2 				0xb4
#define C_R3_G5_B3 				0xb5
#define C_R3_G5_B4 				0xb6
#define C_R3_G5_B5 				0xb7
&nbsp;
#define C_R4_G0_B0 				0xb8
#define C_R4_G0_B1 				0xb9
#define C_R4_G0_B2 				0xba
#define C_R4_G0_B3 				0xbb
#define C_R4_G0_B4 				0xbc
#define C_R4_G0_B5 				0xbd
#define C_R4_G1_B0 				0xbe
#define C_R4_G1_B1 				0xbf
#define C_R4_G1_B2 				0xc0
#define C_R4_G1_B3 				0xc1
#define C_R4_G1_B4 				0xc2
#define C_R4_G1_B5 				0xc3
#define C_R4_G2_B0 				0xc4
#define C_R4_G2_B1 				0xc5
#define C_R4_G2_B2 				0xc6
#define C_R4_G2_B3 				0xc7
#define C_R4_G2_B4 				0xc8
#define C_R4_G2_B5 				0xc9
&nbsp;
#define C_R4_G3_B0 				0xca
#define C_R4_G3_B1 				0xcb
#define C_R4_G3_B2 				0xcc
#define C_R4_G3_B3 				0xcd
#define C_R4_G3_B4 				0xce
#define C_R4_G3_B5 				0xcf
#define C_R4_G4_B0 				0xd0
#define C_R4_G4_B1 				0xd1
#define C_R4_G4_B2 				0xd2
#define C_R4_G4_B3 				0xd3
#define C_R4_G4_B4 				0xd4
#define C_R4_G4_B5 				0xd5
#define C_R4_G5_B0 				0xd6
#define C_R4_G5_B1 				0xd7
#define C_R4_G5_B2 				0xd8
#define C_R4_G5_B3 				0xd9
#define C_R4_G5_B4 				0xda
#define C_R4_G5_B5 				0xdb
&nbsp;
#define C_R5_G0_B0 				0xdc
#define C_R5_G0_B1 				0xdd
#define C_R5_G0_B2 				0xde
#define C_R5_G0_B3 				0xdf
#define C_R5_G0_B4 				0xe0
#define C_R5_G0_B5 				0xe1
#define C_R5_G1_B0 				0xe2
#define C_R5_G1_B1 				0xe3
#define C_R5_G1_B2 				0xe4
#define C_R5_G1_B3 				0xe5
#define C_R5_G1_B4 				0xe6
#define C_R5_G1_B5 				0xe7
#define C_R5_G2_B0 				0xe8
#define C_R5_G2_B1 				0xe9
#define C_R5_G2_B2 				0xea
#define C_R5_G2_B3 				0xeb
#define C_R5_G2_B4 				0xec
#define C_R5_G2_B5 				0xed
#define C_R5_G3_B0 				0xee
#define C_R5_G3_B1 				0xef
#define C_R5_G3_B2 				0xf0
#define C_R5_G3_B3 				0xf1
#define C_R5_G3_B4 				0xf2
#define C_R5_G3_B5 				0xf3
#define C_R5_G4_B0 				0xf4
#define C_R5_G4_B1 				0xf5
#define C_R5_G4_B2 				0xf6
#define C_R5_G4_B3 				0xf7
#define C_R5_G4_B4 				0xf8
#define C_R5_G4_B5 				0xf9
#define C_R5_G5_B0 				0xfa
#define C_R5_G5_B1 				0xfb
#define C_R5_G5_B2 				0xfc
#define C_R5_G5_B3 				0xfd
#define C_R5_G5_B4 				0xfe
#define C_R5_G5_B5 				0xff
&nbsp;
#define C_LIGHT_GREY				C_LIGHT_GRAY
#define C_DARK_GREY				C_DARK_GRAY
#define C_BW_GREY				0x84</PRE>
<P>
The <CODE>
Color</CODE>
 enumerated type is used to encode color index values. Normally, the constant name will give a hint as to the color's composition. If an application has carried out sophisticated palette operations, however, then C_RED might actually correspond to, say, a shade of green.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
color.h</STRONG>
 </P>
</DIV>
<HR>
<A NAME="S_9.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="S_9.htm_IX_CF_&ldots;  (ColorFlag type)">
 </A>
<A NAME="S_9.htm_IX_ColorFlag">
 </A>
<H1 CLASS="refHeading">
ColorFlag</H1>
<PRE CLASS="syntax">typedef ByteEnum ColorFlag;
#define CF_INDEX			0
#define CF_GRAY			1
#define CF_SAME			2
#define CF_RGB			0x80</PRE>
<P>
Several color-related commands accept colors in a variety of formats. The <CODE>
ColorFlag</CODE>
 enumerated type is used to specify how the color is being described. The <CODE>
ColorFlag</CODE>
 is normally used as part of a <CODE>
ColorQuad</CODE>
. See <CODE>
ColorQuad</CODE>
 for information about how to interpret color specifications using <CODE>
ColorFlag</CODE>
s.</P>
</DIV>
<DIV>
<A NAME="S_9.htm_IX_ColorMapMode">
 </A>
<A NAME="S_9.htm_IX_CMM_&ldots;">
 </A>
<A NAME="S_9.htm_IX_LAST_MAP_MODE">
 </A>
<H1 CLASS="refHeading">
ColorMapMode</H1>
<PRE CLASS="syntax">typedef ByteFlags ColorMapMode;
#define CMM_ON_BLACK 0x04				/* Set this bit if you're drawing on black */
#define CMM_MAP_TYPE 0x01				/* Either CMT_CLOSEST or CMT_DITHER) */
#define LAST_MAP_MODE				(CMM_MAP_TYPE | CMM_ON_BLACK)</PRE>
<P>
This structure defines how the system will try to simulate colors not in the palette. If the map type is CMT_CLOSEST, the closest available color will be used. If the map type is CMT_DITHER, the system will mix together two or more close colors in a dithered pattern. If you will be drawing against a black background, you may wish to set the CMM_ON_BLACK flag.</P>
</DIV>
<DIV>
<A NAME="S_9.htm_IX_ColorQuad">
 </A>
<A NAME="S_9.htm_IX_CQ_&ldots;">
 </A>
<H1 CLASS="refHeading">
ColorQuad</H1>
<PRE CLASS="syntax">typedef struct {
byte 		CQ_redOrIndex;
ColorFlag	 	CQ_info;
byte 		CQ_green;
byte 		CQ_blue;
} ColorQuad;</PRE>
<P>
This structure represents a color. The <CODE>
CQ_info</CODE>
 field determines how the color is being described. </P>
<P>
If the info field is CF_INDEX, then the color is being specified by its index, its place in the window's palette. The index is in the <CODE>
CQ_redOrIndex</CODE>
 field; the the <CODE>
CQ_green</CODE>
 and <CODE>
CQ_blue</CODE>
 fields are meaningless for this specification.</P>
<P>
If the info field is CF_RGB, then the color is specified by RGB (red, green, and blue) components. <CODE>
CQ_redOrIndex</CODE>
 contains the color's red component, a number ranging from 0 to 255. The <CODE>
CQ_green</CODE>
 and <CODE>
CQ_blue</CODE>
 fields contain the color's green and blue components, respectively.</P>
<P>
If the info field is CF_GRAY, then the color is being expressed as a grey scale. This is basically an optimized way of describing RGB colors where the red, green, and blue components are equal. The <CODE>
CQ_redOrIndex</CODE>
 field contains the brightess, a number between 0 and 255. The <CODE>
CQ_green</CODE>
 and <CODE>
CQ_blue</CODE>
 fields are ignored.</P>
<P>
When defining hatch patterns, it is possible have a CF_SAME info field. This means that the hatch lines should use the &quot;same&quot; color when drawing. That is, when hatching text, the text color will be used; when filling an area, the area color will be used. The <CODE>
CQ_redOrIndex</CODE>
, <CODE>
CQ_green</CODE>
, and <CODE>
CQ_blue</CODE>
 fields are all ignored.</P>
</DIV>
<DIV>
<A NAME="S_9.htm_IX_ColorQuadAsDWord">
 </A>
<H1 CLASS="refHeading">
ColorQuadAsDWord</H1>
<PRE CLASS="syntax">typedef dword ColorQuadAsDWord;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_9.htm_IX_ColorTransfer">
 </A>
<A NAME="S_9.htm_IX_CT_data[]">
 </A>
<H1 CLASS="refHeading">
ColorTransfer</H1>
<PRE CLASS="syntax">typedef struct {
RGBDelta				CT_data[125]; 
} ColorTransfer;</PRE>
<P>
This structure consists of a 5x5x5 matrix of <CODE>
RGBDelta</CODE>
 structures. This and be used to specify what sorts of adjustments to make to the color when displaying to a specific device. For instance, some color printers will wipe out certain colors if they try to use the amounts of ink suggested by the raw RGB values. The <CODE>
ColorTransfer</CODE>
 structure thus serves to hold an array of &quot;fudge factors&quot; to tell the printer to use more or less ink than the raw RGB values would suggest.</P>
</DIV>
<DIV>
<A NAME="S_9.htm_IX_ColorTransferData">
 </A>
<A NAME="S_9.htm_IX_CTD_&ldots;">
 </A>
<H1 CLASS="refHeading">
ColorTransferData</H1>
<PRE CLASS="syntax">typedef union {
MonoTransfer		CTD_mono;
RGBTransfer		CTD_rgb;
CMYKTransfer		CTD_cmyk;
} ColorTransferData;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_9.htm_IX_ColorTransferType">
 </A>
<A NAME="S_9.htm_IX_CTT_&ldots;">
 </A>
<H1 CLASS="refHeading">
ColorTransferType</H1>
<PRE CLASS="syntax">typedef ByteEnum ColorTransferType;
#define CTT_MONO				 0
#define CTT_RGB 				 1
#define CTT_CMYK 				 2</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_9.htm_IX_CommonParameters">
 </A>
<A NAME="S_9.htm_IX_CP_&ldots;">
 </A>
<H1 CLASS="refHeading">
CommonParameters</H1>
<PRE CLASS="syntax">typedef struct {
word	CP_row;
word	CP_column;
word	CP_maxRow;
word	CP_maxColumn;
void	* CP_callback;
void	* CP_cellParams; /* ptr to an instance of SpreadsheetClass */
} CommonParameters;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_9.htm_IX_CompChildFlags">
 </A>
<A NAME="S_9.htm_IX_CCF_&ldots;">
 </A>
<A NAME="S_9.htm_IX_CCO_&ldots;">
 </A>
<H1 CLASS="refHeading">
CompChildFlags</H1>
<PRE CLASS="syntax">typedef WordFlags CompChildFlags;
#define CCF_MARK_DIRTY				0x8000
#define CCF_REFERENCE				0x7fff
#define 		CCO_FIRST			0x0000
#define		CCO_LAST			0x7FFF
#define CCF_REFERENCE_OFFSET 0</PRE>
<P>
A record used when adding, moving, or removing children in an object tree. The record has one flag and a value, as follows:</P>
<DL>
<DT>
CCF_MARK_DIRTY</DT><DD>
A flag indicating whether the object should be marked dirty at the end of the operation.</DD>
<DT>
CCF_REFERENCE</DT><DD>
A child number; when adding or moving a child, this is the child number after which the new object should be inserted. It can be any number less than 32768, or it can be either of the two constants shown above (CCO_FIRST or CCO_LAST).</DD>
</DIV>
</DL>
<HR>
<A NAME="S_a.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="S_a.htm_IX_CompSizeHintArgs">
 </A>
<H1 CLASS="refHeading">
CompSizeHintArgs</H1>
<PRE CLASS="syntax">typedef struct {
            SpecWidth   CSHA_width;
            SpecHeight  CSHA_height;
            sword       CSHA_count;
} CompSizeHintArgs;
typedef WordFlags SpecWidth;
        #define SW_TYPE         0x8c00
        #define SW_DATA         0x03ff
        &nbsp;
typedef WordFlags SpecHeight;
        #define SH_TYPE         0x8c00
        #define SH_DATA         0x03ff
typedef ByteEnum SpecSizeType;
        #define SST_PIXELS                                0x0000
        #define SST_COUNT                                 0x0400
        #define SST_PCT_OF_FIELD_WIDTH    0x0800
        #define SST_PCT_OF_FIELD_HEIGHT   0x0c00
        #define SST_AVG_CHAR_WIDTHS       0x1000
        #define SST_WIDE_CHAR_WIDTHS      0x1400
        #define SST_LINES_OF_TEXT                 0x1800
        &nbsp;
        #define PCT_0   0x000
        #define PCT_5   0x033
        #define PCT_10  0x066
        #define PCT_15  0x099
        #define PCT_20  0x0cc
        #define PCT_25  0x100
        #define PCT_30  0x133
        #define PCT_35  0x166
        #define PCT_40  0x199
        #define PCT_45  0x1cc
        #define PCT_50  0x200
        #define PCT_55  0x233
        #define PCT_60  0x266
        #define PCT_65  0x299
        #define PCT_70  0x2cc
        #define PCT_75  0x300
        #define PCT_80  0x333
        #define PCT_85  0x366
        #define PCT_90  0x399
        #define PCT_95  0x3cc
        #define PCT_100 0x3ff</PRE>
<P>
This structure is used to define the sizes of various UI gadgets. <CODE>
CSHA_width</CODE>
 determines how the gadget's width should be calculated; <CODE>
CSHA_height</CODE>
 determines how the height should be calculated; <CODE>
CSHA_count</CODE>
 is the number of children in a particular line of the composite object (if that object is wrapping its children).</P>
<P>
This example sets the initial size of the composite (probably a GenPrimary) to be half the screen's height and half the screen's width.</P>
<PRE>HINT_INITIAL_SIZE = {
	SST_PCT_OF_FIELD_WIDTH | PCT_50,
	SST_PCT_OF_FIELD_HEIGHT | PCT_50,
	0 };</PRE>
<P>
This example sets the size of the composite to be 100 pixels high and 200 pixels wide.</P>
<PRE>HINT_FIXED_SIZE = {
	SST_PIXELS | 200,
	SST_PIXELS | 100,
	0 };</PRE>
<P>
This example sets the composite's minimum size to be 10 average characters wide and 20 percent of the screen height tall.</P>
<PRE>HINT_MINIMUM_SIZE = {
	SST_AVG_CHAR_WIDTHS | 10,
	SST_PCT_OF_FIELD_HEIGHT | PCT_20,
	0 };</PRE>
</DIV>
<DIV>
<A NAME="S_a.htm_IX_CountryType">
 </A>
<A NAME="S_a.htm_IX_CT_&ldots;  (CountryType type)">
 </A>
<H1 CLASS="refHeading">
CountryType</H1>
<PRE CLASS="syntax">typedef enum /* word */ {
CT_UNITED_STATES=1,
CT_CANADA,
CT_UNITED_KINGDOM,
CT_GERMANY,
CT_FRANCE,
CT_SPAIN,
CT_ITALY,
CT_DENMARK,
CT_NETHERLANDS,
} CountryType;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_a.htm_IX_CRangeEnumParams">
 </A>
<A NAME="S_a.htm_IX_CREP_&ldots;">
 </A>
<H1 CLASS="refHeading">
CRangeEnumParams</H1>
<PRE CLASS="syntax">typedef struct {
            RangeEnumParams         CREP_params;
            void                    *CREP_locals;
            PCB(RANGE_ENUM_CALLBACK_RETURN_TYPE, CREP_callback,
(RangeEnumCallbackParams));</PRE>
<PRE CLASS="syntax">} CRangeEnumParams;</PRE>
<P>
The <CODE>
CREP_callback</CODE>
 routine should be declared _pascal.</P>
</DIV>
<DIV>
<A NAME="S_a.htm_IX_CurrencyFormatFlags">
 </A>
<A NAME="S_a.htm_IX_CFF_&ldots;">
 </A>
<H1 CLASS="refHeading">
CurrencyFormatFlags</H1>
<PRE CLASS="syntax">typedef ByteFlags CurrencyFormatFlags;
#define CFF_LEADING_ZERO									0x20
#define CFF_SPACE_AROUND_SYMBOL 									0x10
#define CFF_USE_NEGATIVE_SIGN 									0x08
#define CFF_SYMBOL_BEFORE_NUMBER 									0x04
#define CFF_NEGATIVE_SIGN_BEFORE_NUMBER 									0x02
#define CFF_NEGATIVE_SIGN_BEFORE_SYMBOL 									0x01</PRE>
<P>
&nbsp;</P>
</DIV>
<HR>
<A NAME="S_b.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="S_b.htm_IX_CustomDialogBoxFlags">
 </A>
<A NAME="S_b.htm_IX_CDBF_&ldots;">
 </A>
<H1 CLASS="refHeading">
CustomDialogBoxFlags</H1>
<PRE CLASS="syntax">typedef WordFlags CustomDialogBoxFlags;
#define CDBF_SYSTEM_MODAL						0x8000
#define CDBF_DIALOG_TYPE						0x6000
#define CDBF_INTERACTION_TYPE						0x1e00
#define CDBF_DESTRUCTIVE_ACTION 0x0100
#define CDBF_DIALOG_TYPE_OFFSET         13
#define CDBF_INTERACTION_TYPE_OFFSET    9</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_b.htm_IX_CustomDialogType">
 </A>
<A NAME="S_b.htm_IX_CDT_&ldots;">
 </A>
<H1 CLASS="refHeading">
CustomDialogType</H1>
<PRE CLASS="syntax">typedef ByteEnum CustomDialogType;
#define CDT_QUESTION				0
#define CDT_WARNING				1
#define CDT_NOTIFICATION 				2
#define CDT_ERROR 				3</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_b.htm_IX_DACPlayFlags">
 </A>
<A NAME="S_b.htm_IX_DACPF_CATENATE">
 </A>
<H1 CLASS="refHeading">
DACPlayFlags</H1>
<PRE CLASS="syntax">typedef ByteFlags DACPlayFlags;
#define DACPF_CATENATE 0x80
&nbsp;</PRE>
</DIV>
<DIV>
<A NAME="S_b.htm_IX_DACReferenceByte">
 </A>
<A NAME="S_b.htm_IX_DACRB_&ldots;">
 </A>
<H1 CLASS="refHeading">
DACReferenceByte</H1>
<PRE CLASS="syntax">typedef enum {
 DACRB_NO_REFERENCE_BYTE,
 DACRB_WITH_REFERENCE_BYTE
} DACReferenceByte;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_b.htm_IX_DACSampleFormat">
 </A>
<A NAME="S_b.htm_IX_DACSF_&ldots;">
 </A>
<H1 CLASS="refHeading">
DACSampleFormat</H1>
<PRE CLASS="syntax">typedef enum {
 DACSF_8_BIT_PCM,
 DACSF_2_TO_1_ADPCM,
 DACSF_3_TO_1_ADPCM,
 DACSF_4_TO_1_ADPCM
} DACSampleFormat;</PRE>
<P>
This structure specifies what sort of sampling should be used when recording or playing a sampled sound.</P>
</DIV>
<DIV>
<A NAME="S_b.htm_IX_DashPairArray">
 </A>
<H1 CLASS="refHeading">
DashPairArray</H1>
<P CLASS="refField"><STRONG>
<STRONG>
See:</STRONG></STRONG>
<CODE>
	LineStyle</CODE>
</P>
</DIV>
<DIV>
<A NAME="S_b.htm_IX_DACSF_&ldots;">
 </A>
<H1 CLASS="refHeading">
DataStoreCreateParams</H1>
<PRE CLASS="syntax">typedef struct {
TCHAR				*DSCP_name;
DataStoreFlags				DSCP_flags;
FieldDescriptor				*DSCP_keyList;
word				DSCP_keyCount;
optr				DSCP_notifObject;
DataStoreOpenFlags				DSCP_openFlags;
} DataStoreCreateParams;</PRE>
<P>
Attributes to specify when creating a new datastore.</P>
</DIV>
<DIV>
<H1 CLASS="refHeading">
DatatStoreDataError</H1>
<PRE CLASS="syntax">typedef enum {
DSDE_NO_ERROR,
DSDE_INVALID_TOKEN,
DSDE_DATASTORE_LOCKED,
DSDE_ACCESS_DENIED,
DSDE_WRITE_ERROR,
DSDE_MEMORY_FULL,
DSDE_INVALID_RECORD_ID,
DSDE_INVALID_FIELD_ID,		
DSDE_INVALID_FIELD_NAME,			
DSDE_INVALID_FIELD_TYPE,
DSDE_INVALID_FIELD_CATEGORY,
DSDE_INVALID_FIELD_FLAGS,
DSDE_RECORD_BUFFER_NOT_EMPTY,
DSDE_RECORD_BUFFER_EMPTY,
DSDE_INVALID_FIELD_DATA,
DSDE_DATASTORE_READ_ONLY,		
DSDE_INVALID_RECORD_NUMBER,		
DSDE_INVALID_DATA_SIZE,
DSDE_FIELD_DOES_NOT_EXIST,		
DSDE_RECORD_READ_ONLY,			
DSDE_RECORD_NOT_FOUND,			
DSDE_READ_ERROR,				
DSDE_EXCEEDS_BUFFER_SIZE,
DSDE_TOO_MANY_FIELDS,
DSDE_RECORD_IN_USE,
DSDE_INVALID_BLOCK_HANDLE,
DSDE_INVALID_CHUNK_HANDLE,
DSDE_RECORD_LOCKED,
} DataStoreDataError;</PRE>
<P>
Error values returned by various DataStore routines.</P>
</DIV>
<DIV>
<H1 CLASS="refHeading">
DatatStoreError</H1>
<PRE CLASS="syntax">typedef enum {
DSE_NO_ERROR,
DSE_INVALID_TOKEN,
DSE_DATASTORE_LOCKED,
DSE_ACCESS_DENIED,
DSE_WRITE_ERROR,
DSE_MEMORY_FULL,
DSE_INVALID_RECORD_ID,
DSE_INVALID_NAME,
DSE_INVALID_KEY_LIST,
DSE_INVALID_FLAGS,
DSE_DUPLICATE_FIELD_NAME,	    /* duplicate field in create params */
DSE_CREATE_ERROR,
DSE_OPEN_ERROR,
DSE_CLOSE_ERROR,
DSE_UPDATE_ERROR,
DSE_DATASTORE_EXISTS,
DSE_DATASTORE_NOT_FOUND,
DSE_DATASTORE_ALREADY_OPEN,
DSE_PROTOCOL_ERROR,
DSE_CLOSE_WITH_LOCKED_RECORD,
DSE_INVALID_DATASTORE_FILE,
DSE_PRIVATE_DATASTORE,
DSE_BAD_SEARCH_PARAMS,
DSE_CANNOT_SET_NEXT_RECORD_ID_SMALLER,
DSE_NO_MATCH_FOUND,	    	    
DSE_NO_MORE_RECORDS,	    /* last record reached */
} DataStoreError;</PRE>
<P>
Error values returned by various DataStore routines.</P>
</DIV>
<HR>
<A NAME="S_c.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="S_c.htm_IX_DataStoreIndexCallbackParams">
 </A>
<H1 CLASS="refHeading">
DataStoreIndexCallbackParams</H1>
<PRE CLASS="syntax">typedef struct {
FieldID			DSICP_indexField;
SortOrder			DSICP_sortOrder;
void			*DSICP_cbData;
RecordHeader			*DSICP_rec1;
RecordHeader			*DSICP_rec2;
} DataStoreIndexCallbackParams;</PRE>
<P>
Set of parameters caller passes to callback in <CODE>
<A HREF="../../CRef/Routines/R_f.htm#IX_DataStoreBuildIndex()">DataStoreBuildIndex()</A></CODE>
.</P>
</DIV>
<DIV>
<A NAME="S_c.htm_IX_DatatStoreStructureError">
 </A>
<H1 CLASS="refHeading">
DatatStoreStructureError</H1>
<PRE CLASS="syntax">typedef enum {
DSSE_NO_ERROR,
DSSE_INVALID_TOKEN,
DSSE_DATASTORE_LOCKED,
DSSE_ACCESS_DENIED,
DSSE_WRITE_ERROR,
DSSE_MEMORY_FULL,
DSSE_TOO_MANY_FIELDS,
DSSE_INVALID_FIELD_ID,		
DSSE_INVALID_FIELD_NAME,			
DSSE_INVALID_FIELD_TYPE,
DSSE_INVALID_FIELD_CATEGORY,
DSSE_INVALID_FIELD_FLAGS,
DSSE_RECORD_BUFFER_NOT_EMPTY,
DSSE_FIELD_NAME_TOO_LONG,
DSSE_FIELD_NAME_EXISTS,
DSSE_FIELD_NOT_FOUND,
DSSE_TIME_STAMP_CANNOT_BE_ADDED,
DSSE_TIME_STAMP_CANNOT_BE_DELETED,
DSSE_INVALID_SORT_ORDER,
DSSE_NO_RECORDS_IN_DATASTORE,
DSSE_PARTIAL_INDEX_RETURNED,
DSSE_DELETE_PRIMARY_KEY,
DSSE_INDEX_RECORD_NUMBER_LIMIT_EXCEEDED, 
} DataStoreStructureError;</PRE>
<P>
Error values returned by various DataStore routines.</P>
</DIV>
<DIV>
<A NAME="S_c.htm_IX_DataStoreFlags">
 </A>
<H1 CLASS="refHeading">
DataStoreFlags</H1>
<PRE CLASS="syntax">typedef WordFlags DataStoreFlags;
#define DSF_PRIVATE				0x8000
#define DSF_TIMESTAMP				0x4000
#define DSF_BACKUP				0x2000
#define DSF_ARCHIVE				0x1000
#define DSF_NO_PRIMARY_KEY				0x1000</PRE>
<P>
Flags passed when creating a datastore.</P>
</DIV>
<DIV>
<A NAME="S_c.htm_IX_DataStoreChangeNotification">
 </A>
<H1 CLASS="refHeading">
DataStoreChangeNotification</H1>
<PRE CLASS="syntax">typedef struct {
TCHAR				DSCN_name[FILE_LONGNAME_BUFFER_SIZE];
DataStoreChangeType				DSCN_action;
RecordID				DSCN_record;
FieldID				DSCN_field;
} DataStoreChangeNotification;</PRE>
<P>
Structure sent with MSG_META_NOTIFY_WITH_DATA_BLOCK when the datastore has been modified.</P>
</DIV>
<DIV>
<A NAME="S_c.htm_IX_DataStoreChangeType">
 </A>
<H1 CLASS="refHeading">
DataStoreChangeType</H1>
<PRE CLASS="syntax">typedef enum {
DSCT_RECORD_ADDED,
DSCT_RECORD_CHANGED,
DSCT_RECORD_DELETED,
DSCT_FIELD_ADDED,
DSCT_FIELD_RENAMED,
DSCT_FIELD_DELETED,
DSCT_DATASTORE_CHANGED,
DSCT_NAME_CHANGED,
DSCT_NEXT_RECORD_ID_CHANGED,
} DataStoreChangeType;</PRE>
<P>
Datastore change notifications; see <CODE>
DataStoreChangeNotification</CODE>
 above.</P>
</DIV>
<DIV>
<A NAME="S_c.htm_IX_DataStoreDate">
 </A>
<H1 CLASS="refHeading">
DataStoreDate</H1>
<PRE CLASS="syntax">typedef struct {
word	DSD_year;
byte	DSD_month;
byte	DSD_day;
} DataStoreDate;</PRE>
<P>
Structure used to get and set data for date fields in a datastore.</P>
</DIV>
<DIV>
<A NAME="S_c.htm_IX_DataStoreOpenFlags">
 </A>
<H1 CLASS="refHeading">
DataStoreOpenFlags</H1>
<PRE CLASS="syntax">typedef ByteFlags DataStoreOpenFlags;
#define DSOF_EXCLUSIVE				0x80</PRE>
<P>
Flag passed when opening a datastore; gives exclusive access to the caller.</P>
</DIV>
<DIV>
<A NAME="S_c.htm_IX_DataStoreRecordEnumFlags">
 </A>
<H1 CLASS="refHeading">
DataStoreRecordEnumFlags</H1>
<PRE CLASS="syntax">typedef WordFlags DataStoreRecordEnumFlags;
#define DSREF_BACKWARDS				0x8000
#define DSREF_START_AT_END	0x4000</PRE>
<P>
Flags passed in <CODE>
<A HREF="../../CRef/Routines/R_14.htm#IX_DataStoreRecordEnum()">DataStoreRecordEnum()</A></CODE>
.</P>
</DIV>
<DIV>
<A NAME="S_c.htm_IX_DataStoreTime">
 </A>
<H1 CLASS="refHeading">
DataStoreTime</H1>
<PRE CLASS="syntax">typedef struct {
byte	DST_hour;
byte	DST_minute;
byte	DST_second;
} DataStoreTime;</PRE>
<P>
Structure used to get and set data for time fields in a datastore.</P>
</DIV>
<HR>
<A NAME="S_d.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="S_d.htm_IX_DateTimeFormat">
 </A>
<H1 CLASS="refHeading">
DateTimeFormat</H1>
<PRE CLASS="syntax">typedef enum /* word */ {
DTF_LONG,			/* Thursday, 7th August, 1997 */
DTF_LONG_CONDENSED,		/* Thu, 7 Aug, 1997           */
DTF_LONG_NO_WEEKDAY,		/* 7th August, 1997           */
DTF_LONG_NO_WEEKDAY_CONDENSED,	/* 7 Aug, 1997                */
DTF_SHORT,			/* 7.8.97                     */
DTF_ZERO_PADDED_SHORT,		/* 07.08.97                   */
DTF_MD_LONG,			/* Thursday, 7th August       */
DTF_MD_LONG_NO_WEEKDAY,		/* 7th August                 */
DTF_MD_SHORT,			/* 7.8                        */
DTF_MY_LONG,			/* August 1997                */
DTF_MY_SHORT,			/* 8.97                       */
DTF_MONTH,			/* August                     */
DTF_WEEKDAY,			/* Thursday                   */
DTF_HMS,			/* 02:05:06                   */
DTF_HM,				/* 02:05                      */
DTF_H,				/* 02                         */
DTF_MS,				/* 5:06                       */
DTF_HMS_24HOUR,			/* 14:05:06                   */
DTF_HM_24HOUR,			/* 14:05                      */
} DateTimeFormat;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_d.htm_IX_DayOfTheWeek">
 </A>
<A NAME="S_d.htm_IX_DOTW_&ldots;">
 </A>
<A NAME="S_d.htm_IX_Sunday">
 </A>
<A NAME="S_d.htm_IX_Monday">
 </A>
<A NAME="S_d.htm_IX_Tuesday">
 </A>
<A NAME="S_d.htm_IX_Wednesday">
 </A>
<A NAME="S_d.htm_IX_Thursday">
 </A>
<A NAME="S_d.htm_IX_Friday">
 </A>
<A NAME="S_d.htm_IX_Saturday">
 </A>
<H1 CLASS="refHeading">
DayOfTheWeek</H1>
<PRE CLASS="syntax">typedef enum {
DOTW_SUNDAY,
DOTW_MONDAY,
DOTW_TUESAY,
DOTW_WEDNESDAY,
DOTW_THURSDAY,
DOTW_FRIDAY,
DOTW_SATURDAY
} DayOfTheWeek;</PRE>
<P>
This enumerated type is used in the <CODE>
TimerDateAndTime</CODE>
 structure.</P>
</DIV>
<DIV>
<A NAME="S_d.htm_IX_DBGroup">
 </A>
<H1 CLASS="refHeading">
DBGroup</H1>
<PRE CLASS="syntax">typedef word DBGroup;</PRE>
<P>
This is the handle of a DB group. It is the VM handle of a DB group block. DB group handles do not change when a file is copied, or when it is closed and reopened.</P>
</DIV>
<DIV>
<A NAME="S_d.htm_IX_DBGroupAndItem">
 </A>
<H1 CLASS="refHeading">
DBGroupAndItem</H1>
<PRE CLASS="syntax">typedef	dword DBGroupAndItem;</PRE>
<P>
This is a dword which contains the group and item handles of a database item. The high word is the item's Group handle; the low word is the item's Item handle. <DIV>
<IMG SRC="DBGroupAndItem.gif">
</DIV>
</P>
<P>
Macros are provided to create and parse the <CODE>
DBGroupAndItem</CODE>
:</P>
<DL>
<DT>
<CODE>
DBCombineGroupAndItem()</DT><DD>
</CODE>
Creates a <CODE>
DBGroupAndItem</CODE>
 from given group and item handles.</DD>
<PRE>DBCombineGroupAndItem(group, item);</PRE>
<DT>
<CODE>
DBExtractGroupFromGroupAndItem()</DT><DD>
</CODE>
Extracts the <CODE>
DBGroup</CODE>
 from a given <CODE>
DBGroupAndItem</CODE>
.</DD>
<PRE><CODE>DBExtractGroupFromGroupAndItem(groupAndItem);</CODE></PRE>
<DT>
<CODE>
DBExtractItemFromGroupAndItem()</DT><DD>
</CODE>
Extracts the <CODE>
DBItem</CODE>
 from a given <CODE>
DBGroupAndItem</CODE>
.</DD>
<PRE>DBExtractItemFromGroupAndItem(groupAndItem);</PRE>
</DL>
<P CLASS="refField"><STRONG>
Include:</STRONG>	geos.h</P>
</DIV>
<DIV>
<A NAME="S_d.htm_IX_DBItem">
 </A>
<H1 CLASS="refHeading">
DBItem</H1>
<PRE CLASS="syntax">typedef word DBItem;</PRE>
<P>
This is the handle of a DB item. The <CODE>
DBItem</CODE>
 and <CODE>
DBGroup</CODE>
 together uniquely identify a DB item in a specified file.</P>
</DIV>
<DIV>
<A NAME="S_d.htm_IX_DBReturn">
 </A>
<A NAME="S_d.htm_IX_DBR_&ldots;">
 </A>
<H1 CLASS="refHeading">
DBReturn</H1>
<PRE CLASS="syntax">typedef struct {
word	DBR_group;
word	DBR_item;
word	unused1;
word	unused2;
} DBReturn;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_d.htm_IX_DefaultPrintSizes">
 </A>
<A NAME="S_d.htm_IX_paper&ldots;">
 </A>
<A NAME="S_d.htm_IX_document&ldots;">
 </A>
<H1 CLASS="refHeading">
DefaultPrintSizes</H1>
<PRE CLASS="syntax">typedef struct {
word	paperWidth;
word	paperHeight;
word	documentWidth;
word	documentHeight;
} DefaultPrintSizes;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_d.htm_IX_DevicePresent">
 </A>
<A NAME="S_d.htm_IX_DP_&ldots;">
 </A>
<H1 CLASS="refHeading">
DevicePresent</H1>
<PRE CLASS="syntax">typedef enum /* word */ {
DP_NOT_PRESENT=0xffff,
DP_CANT_TELL=0,
DP_PRESENT=1,
DP_INVALID_DEVICE=0xfffe
} DevicePresent;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_d.htm_IX_DirPathInfo">
 </A>
<H1 CLASS="refHeading">
DirPathInfo</H1>
<P>
See <CODE>
<A HREF="../../CRef/Routines/R_27.htm#IX_FileEnum()">FileEnum()</A></CODE>
.</P>
</DIV>
<DIV>
<A NAME="S_d.htm_IX_DiskCopyCallback">
 </A>
<H1 CLASS="refHeading">
DiskCopyCallback</H1>
<P>
See <CODE>
<A HREF="../../CRef/Routines/R_19.htm#IX_DiskCopy()">DiskCopy()</A></CODE>
.</P>
</DIV>
<DIV>
<A NAME="S_d.htm_IX_DiskCopyError">
 </A>
<A NAME="S_d.htm_IX_ERR_&ldots;">
 </A>
<H1 CLASS="refHeading">
DiskCopyError</H1>
<PRE CLASS="syntax">typedef enum /* word */ {
ERR_DISKCOPY_INSUFFICIENT_MEM=0xd0,
ERR_CANT_COPY_FIXED_DISKS,
ERR_CANT_READ_FROM_SOURCE,
ERR_CANT_WRITE_TO_DEST,
ERR_INCOMPATIBLE_FORMATS,
ERR_OPERATION_CANCELLED,
ERR_CANT_FORMAT_DEST,
} DiskCopyError;</PRE>
<P>
&nbsp;</P>
</DIV>
<HR>
<A NAME="S_e.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="S_e.htm_IX_DiskFindResult">
 </A>
<H1 CLASS="refHeading">
DiskFindResult</H1>
<P>
See <CODE>
<A HREF="../../CRef/Routines/R_19.htm#IX_DiskFind()">DiskFind()</A></CODE>
.</P>
</DIV>
<DIV>
<A NAME="S_e.htm_IX_DiskHandle">
 </A>
<H1 CLASS="refHeading">
DiskHandle</H1>
<PRE CLASS="syntax">typedef Handle DiskHandle;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_e.htm_IX_DiskInfoStruct">
 </A>
<A NAME="S_e.htm_IX_DIS_&ldots;  (DiskInfoStruct structure)">
 </A>
<H1 CLASS="refHeading">
DiskInfoStruct</H1>
<PRE CLASS="syntax">typedef struct {
word		DIS_blockSize;
sdword		DIS_freeSpace;
sdword		DIS_totalSpace;
VolumeName		DIS_name;
} DiskInfoStruct;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_e.htm_IX_DiskRestoreError">
 </A>
<H1 CLASS="refHeading">
DiskRestoreError</H1>
<P>
See <CODE>
<A HREF="../../CRef/Routines/R_1b.htm#IX_DiskRestore()">DiskRestore()</A></CODE>
.</P>
</DIV>
<DIV>
<A NAME="S_e.htm_IX_DisplayAspectRatio">
 </A>
<A NAME="S_e.htm_IX_DAR_&ldots;">
 </A>
<H1 CLASS="refHeading">
DisplayAspectRatio</H1>
<PRE CLASS="syntax">typedef ByteEnum DisplayAspectRatio;
#define DAR_NORMAL				0
#define DAR_SQUISHED				1
#define DAR_VERY_SQUISHED				2</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_e.htm_IX_DisplayClass">
 </A>
<A NAME="S_e.htm_IX_DC_&ldots;">
 </A>
<H1 CLASS="refHeading">
DisplayClass</H1>
<PRE CLASS="syntax">typedef ByteEnum DisplayClass;
#define DC_TEXT				0
#define DC_GRAY_1 				1
#define DC_GRAY_2 				2
#define DC_GRAY_4 				3
#define DC_GRAY_8 				4
#define DC_COLOR_2 				5
#define DC_COLOR_4 				6
#define DC_COLOR_8                              7
#define DC_CF_RGB 				8</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_e.htm_IX_DisplaySize">
 </A>
<A NAME="S_e.htm_IX_DS_&ldots;  (DisplaySize type)">
 </A>
<H1 CLASS="refHeading">
DisplaySize</H1>
<PRE CLASS="syntax">typedef ByteEnum DisplaySize;
#define DS_TINY				0
#define DS_STANDARD				1
#define DS_LARGE				2
#define DS_HUGE				3</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_e.htm_IX_DisplayType">
 </A>
<A NAME="S_e.htm_IX_DT_&ldots;">
 </A>
<H1 CLASS="refHeading">
DisplayType</H1>
<PRE CLASS="syntax">typedef ByteFlags DisplayType;
#define DT_DISP_SIZE					0xc0
#define DT_DISP_ASPECT_RATIO					0x30
#define DT_DISP_CLASS					0x0f</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_e.htm_IX_DistanceUnit">
 </A>
<A NAME="S_e.htm_IX_DU_&ldots;">
 </A>
<A NAME="S_e.htm_IX_LOCAL_DISTANCE_BUFFER_SIZE">
 </A>
<H1 CLASS="refHeading">
DistanceUnit</H1>
<PRE CLASS="syntax">typedef ByteEnum DistanceUnit;
#define DU_POINTS							 0
#define DU_INCHES 							 1
#define DU_CENTIMETERS							 2
#define DU_MILLIMETERS 							 3
#define DU_PICAS 							 4
#define DU_EUR_POINTS 							 5
#define DU_CICEROS							 6
#define DU_POINTS_OR_MILLIMETERS 							 7
#define DU_INCHES_OR_CENTIMETERS 							 8
#define LOCAL_DISTANCE_BUFFER_SIZE 							32</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_e.htm_IX_DocQuitStatus">
 </A>
<A NAME="S_e.htm_IX_DQS_&ldots;">
 </A>
<H1 CLASS="refHeading">
DocQuitStatus</H1>
<PRE CLASS="syntax">typedef enum /* word */ {
 DQS_OK,
 DQS_CANCEL,
 DQS_DELAYED,
 DQS_SAVE_ERROR
} DocQuitStatus;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_e.htm_IX_DocumentSize">
 </A>
<A NAME="S_e.htm_IX_leftMargin (DocumentSize structure)">
 </A>
<A NAME="S_e.htm_IX_topMargin (DocumentSize structure)">
 </A>
<A NAME="S_e.htm_IX_width (DocumentSize structure)">
 </A>
<A NAME="S_e.htm_IX_height (DocumentSize structure)">
 </A>
<H1 CLASS="refHeading">
DocumentSize</H1>
<PRE CLASS="syntax">typedef struct {
int	leftMargin;
int	topMargin;
int	width;
int	height;
} DocumentSize;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_e.htm_IX_DosCodePage">
 </A>
<A NAME="S_e.htm_IX_CODE_PAGE_&ldots;">
 </A>
<H1 CLASS="refHeading">
DosCodePage</H1>
<PRE CLASS="syntax">typedef enum /* word */ {
CODE_PAGE_US=437,
CODE_PAGE_MULTILINGUAL=850,
CODE_PAGE_PORTUGUESE=860,
CODE_PAGE_CANADIAN_FRENCH=863,
CODE_PAGE_NORDIC=865
} DosCodePage;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_e.htm_IX_DosDotFileName">
 </A>
<A NAME="S_e.htm_IX_DOS_DOT_DOS_FILE_NAME_SIZE">
 </A>
<H1 CLASS="refHeading">
DosDotFileName</H1>
<PRE CLASS="syntax">typedef char DosDotFileName[DOS_DOT_DOS_FILE_NAME_SIZE];</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_e.htm_IX_DosExecFlags">
 </A>
<A NAME="S_e.htm_IX_DEF_&ldots;">
 </A>
<H1 CLASS="refHeading">
DosExecFlags</H1>
<PRE CLASS="syntax">typedef ByteFlags DosExecFlags;
#define DEF_PROMPT					0x80			/* prompt user to return to GEOS */
#define DEF_FORCED_SHUTDOWN					0x40			/* force shutdown; no abort */
#define DEF_INTERACTIVE					0x20			/* program is interactive shell */</PRE>
<P>
Flags used with <CODE>
<A HREF="../../CRef/Routines/R_1c.htm#IX_DosExec()">DosExec()</A></CODE>
. <CODE>
<A HREF="../../CRef/Routines/R_1c.htm#IX_DosExec()">DosExec()</A></CODE>
 executes a DOS program based on these flags.</P>
</DIV>
<DIV>
<A NAME="S_e.htm_IX_DOS_DOT_FILE_NAME_LENGTH_ZT">
 </A>
<A NAME="S_e.htm_IX_DosFileInfoStruct">
 </A>
<A NAME="S_e.htm_IX_DFIS_&ldots;">
 </A>
<H1 CLASS="refHeading">
DosFileInfoStruct</H1>
<PRE CLASS="syntax">typedef struct {
 byte 	DFIS_attributes;
 dword 	DFIS_modTimeDate;
 dword 	DFIS_fileSize;
 char 	DFIS_name[DOS_DOT_FILE_NAME_LENGTH_ZT];
 word 	DFIS_pathInfo;
} DosFileInfoStruct;</PRE>
<P>
&nbsp;</P>
</DIV>
<HR>
<A NAME="S_f.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="S_f.htm_IX_DosNoDotFileName">
 </A>
<A NAME="S_f.htm_IX_DOS_NO_DOT_DOS_FILE_NAME_SIZE">
 </A>
<H1 CLASS="refHeading">
DosNoDotFileName</H1>
<PRE CLASS="syntax">typedef char DosNoDotFileName[DOS_NO_DOT_DOS_FILE_NAME_SIZE];</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_f.htm_IX_DrawMask">
 </A>
<H1 CLASS="refHeading">
DrawMask</H1>
<PRE CLASS="syntax">typedef byte DrawMask[8];</PRE>
<P>
The graphics system uses this structure for defining custom draw masks.</P>
</DIV>
<DIV>
<A NAME="S_f.htm_IX_DriveType">
 </A>
<A NAME="S_f.htm_IX_DRIVE_&ldots;">
 </A>
<H1 CLASS="refHeading">
 DriveType</H1>
<PRE CLASS="syntax">typedef ByteEnum DriveType;
#define DRIVE_5_25				0
#define DRIVE_3_5				1
#define DRIVE_FIXED				2
#define DRIVE_RAM				3
#define DRIVE_CD_ROM				4
#define DRIVE_8				5
#define DRIVE_UNKNOWN				0xf
} DriveType;</PRE>
<P>
Several routines (in particular, <CODE>
<A HREF="../../CRef/Routines/R_1d.htm#IX_DriveGetStatus()">DriveGetStatus()</A></CODE>
) provide information about drives used by the computer running GEOS. These routines return a member of the <CODE>
DriveTypes</CODE>
 enumerated type. Note that while the type is byte-length, all of the values are guaranteed to fit in four bits; thus, routines like <CODE>
<A HREF="../../CRef/Routines/R_1d.htm#IX_DriveGetStatus()">DriveGetStatus()</A></CODE>
 can return a <CODE>
DriveTypes</CODE>
 value in the low four bits and other flags in the high four bits of a single byte.</P>
</DIV>
<DIV>
<A NAME="S_f.htm_IX_DriverAttrs">
 </A>
<A NAME="S_f.htm_IX_DA_&ldots;">
 </A>
<H1 CLASS="refHeading">
DriverAttrs</H1>
<PRE CLASS="syntax">typedef WordFlags DriverAttrs;
#define DA_FILE_SYSTEM						0x8000
#define DA_CHARACTER						0x4000
#define DA_HAS_EXTENDED_INFO						0x2000</PRE>
<P>
This record contains flags that indicate a given driver's attributes. This record is stored in the driver's <CODE>
DriverInfoStruct</CODE>
 structure.</P>
</DIV>
<DIV>
<A NAME="S_f.htm_IX_DriverExtendedInfoStruct">
 </A>
<A NAME="S_f.htm_IX_DEIS_&ldots;">
 </A>
<H1 CLASS="refHeading">
DriverExtendedInfoStruct</H1>
<PRE CLASS="syntax">typedef struct {
DriverInfoStruct			DEIS_common;			/* The base driver info structure */
MemHandle			DEIS_resource;			/* Handle of driver's DriverExtendedInfo
						 * table. */
} DriverExtendedInfoStruct;</PRE>
<P>
This structure is used by Preferences to locate the names of devices supported by a particular driver.</P>
</DIV>
<DIV>
<A NAME="S_f.htm_IX_DriverExtendedInfoTable">
 </A>
<A NAME="S_f.htm_IX_DEIT_&ldots;">
 </A>
<H1 CLASS="refHeading">
DriverExtendedInfoTable</H1>
<PRE CLASS="syntax">typedef struct {
LMemBlockHeader			DEIT_common;
word			DEIT_numDevices;
ChunkHandle			DEIT_ChunkHandle;
word			DEIT_infoTable;
} DriverExtendedInfoTable;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_f.htm_IX_DriverInfoStruct">
 </A>
<A NAME="S_f.htm_IX_DIS_&ldots;  (DriverInfoStruct structure)">
 </A>
<H1 CLASS="refHeading">
DriverInfoStruct</H1>
<PRE CLASS="syntax">typedef struct {
 void (*DIS_strategy)();							/* Pointer to strategy routine */
 DriverAttrs		DIS_driverAttributes;					/* driver's attribute flags */
 DriverType		DIS_driverType;					/* driver's type */
} DriverInfoStruct;</PRE>
<P>
This structure defines the characteristics of a particular driver. In general, applications will not need to access this structure unless they use a driver directly.</P>
</DIV>
<DIV>
<A NAME="S_f.htm_IX_DriverType">
 </A>
<A NAME="S_f.htm_IX_DRIVER_TYPE_&ldots;">
 </A>
<H1 CLASS="refHeading">
DriverType</H1>
<PRE CLASS="syntax">typedef enum {
DRIVER_TYPE_VIDEO = 1,					/* Video drivers */
DRIVER_TYPE_INPUT,					/* Input (keyboard, mouse) drivers */
DRIVER_TYPE_MASS_STORAGE,					/* Disk/Drive drivers */
DRIVER_TYPE_STREAM,					/* Stream and port drivers */
DRIVER_TYPE_FONT,					/* Font drivers */
DRIVER_TYPE_OUTPUT,					/* Output (not video and printer) drivers */
DRIVER_TYPE_LOCALIZATION,					/* Localization drivers */
DRIVER_TYPE_FILE_SYSTEM,					/* File system drivers */
DRIVER_TYPE_PRINTER,					/* Printer drivers */
DRIVER_TYPE_SWAP,					/* Swap drivers */
DRIVER_TYPE_POWER_MANAGEMENT,					/* Power management drivers */
DRIVER_TYPE_TASK_SWITCH,					/* Task switch drivers */
DRIVER_TYPE_NETWORK					/* Network file system drivers */
} DriverType;</PRE>
<P>
This enumerated type has one value for each type of driver in the system. It is used primarily with <CODE>
<A HREF="../../CRef/Routines/R_35.htm#IX_GeodeUseDriver()">GeodeUseDriver()</A></CODE>
 and its associated routines. Each driver stores its type in its <CODE>
DriverInfoStruct</CODE>
 structure.</P>
</DIV>
<DIV>
<A NAME="S_f.htm_IX_DWFixed">
 </A>
<H1 CLASS="refHeading">
DWFixed</H1>
<PRE CLASS="syntax">typedef struct {
word WWF_frac;
dword WWF_int;
} DWFixed;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_f.htm_IX_dword">
 </A>
<H1 CLASS="refHeading">
dword</H1>
<PRE CLASS="syntax">typedef unsigned long dword;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_f.htm_IX_DWordFlags">
 </A>
<H1 CLASS="refHeading">
DWordFlags</H1>
<PRE CLASS="syntax">typedef dword DWordFlags;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_f.htm_IX_ElementArrayHeader">
 </A>
<A NAME="S_f.htm_IX_EAH_&ldots;">
 </A>
<H1 CLASS="refHeading">
ElementArrayHeader</H1>
<PRE CLASS="syntax">typedef struct {
ChunkArrayHeader			EAH_meta;			/* chunk array header structure */
word			EAH_freePtr;			/* First free element */
} ElementArrayHeader;</PRE>
<P>
Every element array must begin with an <CODE>
ElementArrayHeader</CODE>
. Since element arrays are special kinds of chunk arrays, the <CODE>
ElementArrayHeader</CODE>
 must itself begin with a <CODE>
ChunkArrayHeader</CODE>
. The structure contains one additional field, EAH<CODE>
_freePtr</CODE>
. This is used to keep track of the freed elements in the element array. Applications should not examine or change this field.</P>
</DIV>
<HR>
<A NAME="S_10.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="S_10.htm_IX_EOSF_&ldots;">
 </A>
<A NAME="S_10.htm_IX_UNLOCK_ON_EOS (EndOfSongFlags flag)">
 </A>
<A NAME="S_10.htm_IX_DESTROY_ON_EOS (EndOfSongFlags flag)">
 </A>
<H1 CLASS="refHeading">
EndOfSongFlags</H1>
<PRE CLASS="syntax">typedef ByteFlags EndOfSongFlags;
        #define EOSF_UNLOCK 0x0080 /* unlock block at EOS ? */
        #define EOSF_DESTROY 0x0040 /* destroy block at EOS ? */
        &nbsp;
        #define UNLOCK_ON_EOS EOSF_UNLOCK
        #define DESTROY_ON_EOS EOSF_DESTROY</PRE>
<P>
These flags determine what should be done with the memory block which stores a song structure after the song is done playing.</P>
</DIV>
<DIV>
<A NAME="S_10.htm_IX_EntryPointRelocation">
 </A>
<A NAME="S_10.htm_IX_EPR_&ldots;">
 </A>
<H1 CLASS="refHeading">
EntryPointRelocation</H1>
<PRE CLASS="syntax">typedef struct {
char	EPR_geodeName[GEODE_NAME_SIZE];
word	EPR_entryNumber;
} EntryPointRelocation;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_10.htm_IX_EnvelopeOrientation">
 </A>
<A NAME="S_10.htm_IX_EO_&ldots;">
 </A>
<H1 CLASS="refHeading">
EnvelopeOrientation</H1>
<PRE CLASS="syntax">typedef ByteEnum EnvelopeOrientation;
#define EO_PORTAIT_LEFT				0x00
#define EO_PORTAIT_RIGHT				0x01
#define EO_LANDSCAPE_UP				0x02
#define EO_LANDSCAPE_DOWN				0x03</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_10.htm_IX_EnvelopePath">
 </A>
<A NAME="S_10.htm_IX_EP_&ldots;  (EnvelopePath type)">
 </A>
<H1 CLASS="refHeading">
EnvelopePath</H1>
<PRE CLASS="syntax">typedef ByteEnum EnvelopePath;
#define EP_LEFT				0x00
#define EP_CENTER				0x01
#define EP_RIGHT				0x02</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_10.htm_IX_Errors">
 </A>
<A NAME="S_10.htm_IX_ERROR_&ldots;">
 </A>
<H1 CLASS="refHeading">
Errors</H1>
<PRE CLASS="syntax">#define ERROR_UNSUPPORTED_FUNCTION										1
#define ERROR_FILE_NOT_FOUND 										2
#define ERROR_PATH_NOT_FOUND 										3
#define ERROR_TOO_MANY_OPEN_FILES 										4
#define ERROR_ACCESS_DENIED 										5
#define ERROR_INSUFFICIENT_MEMORY 										8
#define ERROR_INVALID_VOLUME 										15
#define ERROR_IS_CURRENT_DIRECTORY 										16
#define ERROR_DIFFERENT_DEVICE 										17
#define ERROR_NO_MORE_FILES 										18
#define ERROR_WRITE_PROTECTED 										19
#define ERROR_UNKNOWN_VOLUME 										20
#define ERROR_DRIVE_NOT_READY 										21
#define ERROR_CRC_ERROR 										23
#define ERROR_SEEK_ERROR 										25
#define ERROR_UNKNOWN_MEDIA 										26
#define ERROR_SECTOR_NOT_FOUND 										27
#define ERROR_WRITE_FAULT 										29
#define ERROR_READ_FAULT 										30
#define ERROR_GENERAL_FAILURE 										31
#define ERROR_SHARING_VIOLATION 										32
#define ERROR_ALREADY_LOCKED 										33
#define ERROR_SHARING_OVERFLOW 										36
#define ERROR_SHORT_READ_WRITE 										128
#define ERROR_INVALID_LONGNAME 										129
#define ERROR_FILE_EXISTS 										130
#define ERROR_DOS_EXEC_IN_PROGRESS 										131
#define ERROR_FILE_IN_USE 										132
#define ERROR_ARGS_TOO_LONG 										133
#define ERROR_DISK_UNAVAILABLE 										134
#define ERROR_DISK_STALE 										135
#define ERROR_FILE_FORMAT_MISMATCH 										136
#define ERROR_CANNOT_MAP_NAME 										137
#define ERROR_DIRECTORY_NOT_EMPTY 										138
#define ERROR_ATTR_NOT_SUPPORTED 										139
#define ERROR_ATTR_NOT_FOUND 										140
#define ERROR_ATTR_SIZE_MISMATCH 										141
#define ERROR_ATTR_CANNOT_BE_SET 										142
#define ERROR_CANNOT_MOVE_DIRECTORY 										143
#define ERROR_PATH_TOO_LONG 										144
#define ERROR_ARGS_INVALID 										145
#define ERROR_CANNOT_FIND_COMMAND_INTERPRETER 										146
#define ERROR_NO_TASK_DRIVER_LOADED 										147</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_10.htm_IX_ErrorCheckingFlags">
 </A>
<A NAME="S_10.htm_IX_ECF_&ldots;">
 </A>
<H1 CLASS="refHeading">
ErrorCheckingFlags</H1>
<PRE CLASS="syntax">typedef WordFlags ErrorCheckingFlags;
#define ECF_REGION					0x8000
#define ECF_HEAP_FREE_BLOCKS 					0x4000
#define ECF_LMEM_INTERNAL 					0x2000
#define ECF_LMEM_FREE_AREAS 					0x1000
#define ECF_LMEM_OBJECT 					0x0800
#define ECF_BLOCK_CHECKSUM 					0x0400
#define ECF_GRAPHICS 					0x0200
#define ECF_SEGMENT 					0x0100
#define ECF_NORMAL 					0x0080
#define ECF_VMEM 					0x0040
#define ECF_APP 					0x0020
#define ECF_LMEM_MOVE 					0x0010
#define ECF_UNLOCK_MOVE 					0x0008
#define ECF_VMEM_DISCARD 					0x0004</PRE>
<P>
Error checking flags are used when setting the system's error-checking level with <CODE>
<A HREF="../../CRef/Routines/R_93.htm#IX_SysSetECLevel()">SysSetECLevel()</A></CODE>
. The flags above may be individually set or cleared. It is important to use error checking when debugging; it can help catch obscure bugs that might otherwise go unnoticed until after a product ships.</P>
</DIV>
<HR>
<A NAME="S_11.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="S_11.htm_IX_EvalErrorData">
 </A>
<A NAME="S_11.htm_IX_EED_&ldots;">
 </A>
<H1 CLASS="refHeading">
EvalErrorData</H1>
<PRE CLASS="syntax">typedef struct {
byte		EED_errorCode;				/* ParserScannerEvaluatorError */
} EvalErrorData;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_11.htm_IX_EvalFlags">
 </A>
<A NAME="S_11.htm_IX_EF_&ldots;  (EvalFlags)">
 </A>
<A NAME="S_11.htm_IX_EVAL_MAX_NESTED_LEVELS">
 </A>
<H1 CLASS="refHeading">
EvalFlags</H1>
<PRE CLASS="syntax">typedef ByteFlags EvalFlags;
#define EF_MAKE_DEPENDENCIES						0x80
#define EF_ONLY_NAMES 						0x40
#define EF_KEEP_LAST_CELL 						0x20
#define EF_NO_NAMES 						0x10
#define EF_ERROR_PUSHED 						0x08
#define EVAL_MAX_NESTED_LEVELS 32</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_11.htm_IX_EvalFunctionData">
 </A>
<A NAME="S_11.htm_IX_EFD_&ldots;">
 </A>
<H1 CLASS="refHeading">
EvalFunctionData</H1>
<PRE CLASS="syntax">typedef struct {
FunctionID		EFD_functionID;
word		EFD_nArgs;
} EvalFunctionData;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_11.htm_IX_EvalNameData">
 </A>
<A NAME="S_11.htm_IX_END_&ldots;">
 </A>
<H1 CLASS="refHeading">
EvalNameData</H1>
<PRE CLASS="syntax">typedef struct {
word 	END_name;
} EvalNameData;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_11.htm_IX_EvalOperatorData">
 </A>
<A NAME="S_11.htm_IX_EOD_&ldots;">
 </A>
<H1 CLASS="refHeading">
EvalOperatorData</H1>
<PRE CLASS="syntax">typedef struct {
OperatorType		EOD_opType;
} EvalOperatorData;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_11.htm_IX_EP_&ldots;  (EvalParameters structure)">
 </A>
<A NAME="S_11.htm_IX_EvalParameters">
 </A>
<H1 CLASS="refHeading">
EvalParameters</H1>
<PRE CLASS="syntax">typedef struct {
CommonParameters				EP_common;
EvalFlags				EP_flags;
word				EP_fpStack;
word				EP_depHandle;
word				EP_nestedLevel;
dword				EP_nestedAddresses[EVAL_MAX_NESTED_LEVELS];
} EvalParameters;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_11.htm_IX_EvalRangeData">
 </A>
<A NAME="S_11.htm_IX_ERD_&ldots;">
 </A>
<H1 CLASS="refHeading">
EvalRangeData</H1>
<PRE CLASS="syntax">typedef struct {
CellReference			ERD_firstCell;
CellReference			ERD_lastCell;
} EvalRangeData;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_11.htm_IX_EvalStackArgumentData">
 </A>
<A NAME="S_11.htm_IX_ESAD_&ldots;">
 </A>
<H1 CLASS="refHeading">
EvalStackArgumentData</H1>
<PRE CLASS="syntax">typedef union {
EvalStringData			ESAD_string;
EvalRangeData			ESAD_range;
EvalErrorData			ESAD_error;
} EvalStackArgumentData;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_11.htm_IX_EvalStackArgumentType">
 </A>
<A NAME="S_11.htm_IX_ESAT_&ldots;">
 </A>
<H1 CLASS="refHeading">
EvalStackArgumentType</H1>
<PRE CLASS="syntax">typedef ByteFlags EvalStackArgumentType;
#define ESAT_EMPTY					0x80
#define ESAT_ERROR 					0x40
#define ESAT_RANGE 					0x20
#define ESAT_STRING 					0x10
#define ESAT_NUMBER 					0x08
#define ESAT_NUM_TYPE 					0x03
#define ESAT_TOP_OF_STACK 					0
#define ESAT_NAME 					(ESAT_RANGE | ESAT_STRING)
#define ESAT_FUNCTION 					(ESAT_NUMBER | ESAT_STRING)</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_11.htm_IX_EvalStackOperatorData">
 </A>
<A NAME="S_11.htm_IX_ESOD_&ldots;">
 </A>
<H1 CLASS="refHeading">
EvalStackOperatorData</H1>
<PRE CLASS="syntax">typedef union {
EvalOperatorData			ESOD_operator;
EvalFunctionData			ESOD_function;
} EvalStackOperatorData;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_11.htm_IX_EvalStackOperatorType">
 </A>
<A NAME="S_11.htm_IX_ESOT_&ldots;">
 </A>
<H1 CLASS="refHeading">
EvalStackOperatorType</H1>
<PRE CLASS="syntax">typedef ByteEnum EvalStackOperatorType;
#define ESOT_OPERATOR				0
#define ESOT_FUNCTION 				1
#define ESOT_OPEN_PAREN 				2
#define ESOT_TOP_OF_STACK 				3</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_11.htm_IX_EvalStringData">
 </A>
<A NAME="S_11.htm_IX_ESD_&ldots;">
 </A>
<H1 CLASS="refHeading">
EvalStringData</H1>
<PRE CLASS="syntax">typedef struct {
word	ESD_length;
} EvalStringData;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_11.htm_IX_EventHandle">
 </A>
<H1 CLASS="refHeading">
EventHandle</H1>
<PRE CLASS="syntax">typedef Handle		EventHandle;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_11.htm_IX_ExitFlags">
 </A>
<A NAME="S_11.htm_IX_EF_&ldots;  (ExitFlags)">
 </A>
<H1 CLASS="refHeading">
ExitFlags</H1>
<PRE CLASS="syntax">typedef ByteFlags ExitFlags;
#define EF_PANIC				0x80
#define EF_RUN_DOS				0x40
#define EF_OLD_EXIT				0x20
#define EF_RESET				0x10
#define EF_RESTART				0x08</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_11.htm_IX_ExportControlFeatures">
 </A>
<A NAME="S_11.htm_IX_EXPORTCF_BASIC">
 </A>
<H1 CLASS="refHeading">
ExportControlFeatures</H1>
<PRE CLASS="syntax">typedef ByteFlags ExportControlFeatures;
#define EXPORTCF_BASIC						0x01</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_11.htm_IX_ExportControlToolboxFeatures">
 </A>
<A NAME="S_11.htm_IX_EXPORTCTF_DIALOG_BOX">
 </A>
<H1 CLASS="refHeading">
ExportControlToolboxFeatures</H1>
<PRE CLASS="syntax">typedef ByteFlags ExportControlToolboxFeatures;
#define EXPORTCTF_DIALOG_BOX						0x01</PRE>
<P>
&nbsp;</P>
</DIV>
<HR>
<A NAME="S_12.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="S_12.htm_IX_FALSE">
 </A>
<H1 CLASS="refHeading">
FALSE</H1>
<PRE CLASS="syntax">#define FALSE		 0
#define TRUE		(~0)	/* use as return value, not for comparisons */</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_12.htm_IX_FileAccess">
 </A>
<H1 CLASS="refHeading">
FieldCategory</H1>
<PRE CLASS="syntax">typedef ByteEnum FieldType
#define FC_NONE				0x0
#define FC_NAME				0x1
#define FC_DATE				0x2
#define FC_TELEPHONE				0x3
#define FC_ADDRESS				0x4
#define FC_EMAIL				0x5</PRE>
<P>
When you add a field to a datatstore, you define its <CODE>
FieldCategory</CODE>
. <CODE>
FieldCategory</CODE>
 is the type of information the data represents (not to be confused with <CODE>
FieldType</CODE>
; see below).</P>
</DIV>
<DIV>
<A NAME="S_12.htm_IX_FieldData">
 </A>
<H1 CLASS="refHeading">
FieldData</H1>
<PRE CLASS="syntax">typedef struct {
FieldType			FD_type;
FieldCategory			FD_category;
FieldFlags			FD_flags;
} FieldData;</PRE>
<P>
Structure used to get and set field information (see <CODE>
FieldDescriptor</CODE>
 below).</P>
</DIV>
<DIV>
<A NAME="S_12.htm_IX_FieldDescriptor">
 </A>
<H1 CLASS="refHeading">
FieldDescriptor</H1>
<PRE CLASS="syntax">typedef struct {
FieldData			FD_data;
TCHAR			*FD_name;
} FieldDescriptor;</PRE>
<P>
Structure used to get and set field information (see <CODE>
FieldData</CODE>
 above).</P>
</DIV>
<DIV>
<A NAME="S_12.htm_IX_FieldHeader">
 </A>
<H1 CLASS="refHeading">
FieldHeader</H1>
<PRE CLASS="syntax">typedef struct {
FieldID		FH_id;
word		FH_size;
} FieldHeader;</PRE>
<P>
Structure containing metadata about a variable-sized field (such as a string field); field data follows this header.</P>
</DIV>
<DIV>
<A NAME="S_12.htm_IX_FieldHeaderFixed">
 </A>
<H1 CLASS="refHeading">
FieldHeaderFixed</H1>
<PRE CLASS="syntax">typedef struct {
FieldID		FHF_id;
} FieldHeaderFixed;</PRE>
<P>
Structure containing metadata about a fixed-sized field; field data follows this header.</P>
</DIV>
<DIV>
<A NAME="S_12.htm_IX_FileAccess">
 </A>
<A NAME="S_12.htm_IX_FA_&ldots;  (FileAccess type)">
 </A>
<H1 CLASS="refHeading">
FieldType</H1>
<PRE CLASS="syntax">typedef ByteEnum FieldType
#define DSFT_FLOAT				0x0
#define DSFT_SHORT				0x1
#define DSFT_LONG				0x2
#define DSFT_TIMESTAMP				0x3
#define DSFT_DATE				0x4
#define DSFT_TIME				0x5
#define DSFT_STRING				0x6
#define DSFT_BINARY				0x7
#define DSFT_GRAPHICS				0x8
#define DSFT_INK				0x9</PRE>
<P>
When you add a field to a datatstore, you define its <CODE>
FieldType</CODE>
. <CODE>
FieldType</CODE>
 is the type of data the field contains (not to be confused with <CODE>
FieldCategory</CODE>
; see above). Note that fields of type DSFT_FLOAT expect data of type <CODE>
FloatNum</CODE>
.</P>
</DIV>
<DIV>
<A NAME="S_12.htm_IX_FileAccess">
 </A>
<A NAME="S_12.htm_IX_FA_&ldots;  (FileAccess type)">
 </A>
<H1 CLASS="refHeading">
FileAccess</H1>
<PRE CLASS="syntax">typedef ByteEnum FileAccess
#define FA_READ_ONLY				0
#define FA_WRITE_ONLY				1
#define FA_READ_WRITE				2</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_12.htm_IX_FileAccessFlags">
 </A>
<A NAME="S_12.htm_IX_FILE_&ldots;">
 </A>
<H1 CLASS="refHeading">
FileAccessFlags</H1>
<PRE CLASS="syntax">typedef ByteFlags FileAccessFlags;
#define FILE_DENY_RW 0x10
#define FILE_DENY_W 0x20
#define FILE_DENY_R 0x30
#define FILE_DENY_NONE 0x40
#define FILE_ACCESS_R 0x00
#define FILE_ACCESS_W 0x01
#define FILE_ACCESS_RW 0x02
#define FILE_NO_ERRORS 0x80</PRE>
<P>
When you open a file for bytewise access, you must pass a record of <CODE>
FileAccessFlags</CODE>
. The <CODE>
FileAccessFlags</CODE>
 record specifies two things: what kind of access the caller wants, and what type of access is permitted to other geodes. A set of <CODE>
FileAccessFlags</CODE>
 is thus a bit-wise &quot;or&quot; of two different values. The first specifies what kind of access the calling geode wants and has the following values:</P>
<DL>
<DT>
FILE_ACCESS_R</DT><DD>
The geode will only be reading from the file.</DD>
<DT>
FILE_ACCESS_W</DT><DD>
The geode will write to the file but will not read from it.</DD>
<DT>
FILE_ACCESS_RW</DT><DD>
The geode will read from and write to the file.</DD>
</DL>
<P>
The second part specifies what kind of access other geodes may have. Note that if you try to deny a permission which has already been given to another geode (e.g. you open a file with FILE_DENY_W when another geode has the file open for write-access), the call will fail. It has the following values:</P>
<DL>
<DT>
FILE_DENY_RW</DT><DD>
No geode may open the file for any kind of access, whether read, write, or read/write.</DD>
<DT>
FILE_DENY_R</DT><DD>
No geode may open the file for read or read/write access.</DD>
<DT>
FILE_DENY_W</DT><DD>
No geode may open the file for write or read/write access.</DD>
<DT>
FILE_DENY_NONE</DT><DD>
Other geodes may open the file for any kind of access.</DD>
</DL>
<P>
Two flags, one from each of these sets of values, are combined to make up a proper<CODE>
 </CODE>
<CODE>
FileAccessFlags</CODE>
<CODE>
 </CODE>
value. For example, to open the file for read-only access while prohibiting other geodes from writing to the file, you would pass the flags &quot;(FILE_ACCESS_R | FILE_DENY_W)&quot;.</P>
</DIV>
<DIV>
<A NAME="S_12.htm_IX_FileAccessRights">
 </A>
<A NAME="S_12.htm_IX_FILE_RIGHTS_SIZE">
 </A>
<H1 CLASS="refHeading">
FileAccessRights</H1>
<PRE CLASS="syntax">typedef char FileAccessRights[FILE_RIGHTS_SIZE];</PRE>
<P>
&nbsp;</P>
</DIV>
<HR>
<A NAME="S_13.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="S_13.htm_IX_FileAttrs">
 </A>
<A NAME="S_13.htm_IX_FA_&ldots;  (FileAttrs)">
 </A>
<A NAME="S_13.htm_IX_FILE_ATTR_&ldots;">
 </A>
<H1 CLASS="refHeading">
FileAttrs</H1>
<PRE CLASS="syntax">typedef ByteFlags FileAttrs;
#define FA_ARCHIVE						0x20
#define FA_SUBDIR 						0x10
#define FA_VOLUME 						0x8
#define FA_SYSTEM	 					0x4
#define FA_HIDDEN 						0x2
#define FA_RDONLY 						0x1
#define FILE_ATTR_NORMAL 						0
#define FILE_ATTR_READ_ONLY	 					FA_RDONLY
#define FILE_ATTR_HIDDEN 						FA_HIDDEN
#define FILE_ATTR_SYSTEM 						FA_SYSTEM
#define FILE_ATTR_VOLUME_LABEL 						FA_VOLUME</PRE>
<P>
Every DOS or GEOS file has certain attributes. These attributes mark such things as whether the file is read-only. With GEOS files, the attributes can be accessed by using the extended attribute FEA_FILE_ATTR. You can also access any file's standard attributes with the routines <CODE>
<A HREF="../../CRef/Routines/R_28.htm#IX_FileGetAttributes()">FileGetAttributes()</A></CODE>
 and <CODE>
<A HREF="../../CRef/Routines/R_2b.htm#IX_FileSetAttributes()">FileSetAttributes()</A></CODE>
; these routines work for both GEOS files and plain DOS files.</P>
<P>
The <CODE>
FileAttrs</CODE>
 field contains the following bits:</P>
<DL>
<DT>
FA_ARCHIVE</DT><DD>
This flag is set if the file requires backup. Backup programs typically clear this bit.</DD>
<DT>
FA_SUBDIR</DT><DD>This flag is set if the &quot;file&quot; is actually a directory. Geodes may not change this flag.</DD>
<DT>
FA_VOLUME</DT><DD>
This flag is set if the &quot;file&quot; is actually the volume label. This flag will be <EM>
off</EM>
 for all files a geode will ever see. Geodes may not change this flag.</DD>
<DT>
FA_SYSTEM</DT><DD>This flag is set if the file is a system file. Geodes should not change this bit.</DD>
<DT>
FA_HIDDEN</DT><DD>This flag is set if the file is hidden.</DD>
<DT>
FA_RDONLY</DT><DD>This flag is set if the file is read-only.</DD>
</DL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_28.htm#IX_FileGetAttributes()">FileGetAttributes()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_2b.htm#IX_FileSetAttributes()">FileSetAttributes()</A></CODE>.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
file.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="S_13.htm_IX_FileChangeNotificationData">
 </A>
<A NAME="S_13.htm_IX_FCND_&ldots;">
 </A>
<H1 CLASS="refHeading">
FileChangeNotificationData</H1>
<PRE CLASS="syntax">typedef struct {
PathName			FCND_pathname;
DiskHandle			FCND_diskHandle;
FileChangeType			FCND_changeType;
} FileChangeNotificationData;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_13.htm_IX_FileChangeType">
 </A>
<A NAME="S_13.htm_IX_FCT_&ldots;">
 </A>
<H1 CLASS="refHeading">
FileChangeType</H1>
<PRE CLASS="syntax">typedef ByteEnum FileChangeType;
#define FCT_CREATE				0
#define FCT_DELETE 				1
#define FCT_RENAME 				2
#define FCT_CONTENTS 				3
#define FCT_DISK_FORMAT 				4</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_13.htm_IX_FileCopyrightNotice">
 </A>
<A NAME="S_13.htm_IX_GFH_NOTICE_SIZE">
 </A>
<H1 CLASS="refHeading">
FileCopyrightNotice</H1>
<PRE CLASS="syntax">typedef char FileCopyrightNotice[GFH_NOTICE_SIZE];</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_13.htm_IX_FILE_CREATE_&ldots;  constants">
 </A>
<A NAME="S_13.htm_IX_FileCreateFlags">
 </A>
<A NAME="S_13.htm_IX_FCF_&ldots;">
 </A>
<H1 CLASS="refHeading">
FileCreateFlags</H1>
<PRE CLASS="syntax">typedef WordFlags FileCreateFlags;
#define FCF_NATIVE				0x8000
#define FCF_MODE				0x0300 /* Filled with FILE_CREATE_* constant */
#define FCF_ACCESS				0x00ff /* Filled with FileAccessFlags */</PRE>
<P>
The lower byte of this field is a <CODE>
FileAccessFlags</CODE>
 record. This specifies the file's permissions and exclusions. Note that you must request write or read/write permission when you create a file. The upper byte specifies how the file should be created. It contains the following possible values:</P>
<DL>
<DT>
FILE_CREATE_TRUNCATE</DT><DD>
If a file with the given name exists, it should be opened and truncated; that is, all data should be deleted.</DD>
<DT>
FILE_CREATE_NO_TRUNCATE</DT><DD>
If the file exists, it should be opened without being truncated.</DD>
<DT>
FILE_CREATE_ONLY</DT><DD>
If the file exists, the routine should fail and set the thread's error value to ERROR_FILE_EXISTS.</DD>
<DT>
FCF_NATIVE</DT><DD>
This flag is combined with one of the above flags if the file should be created in the device's native format; e.g. if it should be a DOS file instead of a GEOS file. The name passed must be an acceptable native file name. If a GEOS file with the specified name already exists, <CODE>
<A HREF="../../CRef/Routines/R_25.htm#IX_FileCreate()">FileCreate()</A></CODE>
 will fail with error condition ERROR_FILE_FORMAT_MISMATCH. Similarly, if the flag isn't set and a non-GEOS file with this name exists, <CODE>
<A HREF="../../CRef/Routines/R_25.htm#IX_FileCreate()">FileCreate()</A></CODE>
 will fail and return this error.</DD>
</DIV>
</DL>
<HR>
<A NAME="S_14.htm"></A>
<DIV>
</DIV>


<DIV>
<A NAME="S_14.htm_IX_FileDate">
 </A>
<H1 CLASS="refHeading">
FileDate</H1>
<PRE CLASS="syntax">typedef WordFlags FileDate;
#define FD_YEAR                 0xfe00
#define FD_MONTH                0x01e0
#define FD_DAY                  0x001f
#define FD_YEAR_OFFSET          9
#define FD_MONTH_OFFSET         5
#define FD_DAY_OFFSET           0</PRE>
<P>
A file's date stamp is stored in a 16-bit bitfield. This field contains entries for the year, month, and day.
Each field is identified by a mask and an offset. To access a field, simply clear all bits except those in the mask, then shift the bits to the right by the number of the offset. (Macros are provided to do this; they are described below.) <CODE>FileDate</CODE> contains the
following fields, identified by their masks:
</P>

<DL>
<DT>
<STRONG>
FD_YEAR </STRONG>
</DT><DD>This field records the year counting from the base year of 1980. It is offset by <CODE>FD_YEAR_OFFSET</CODE> bits.</DD>
<DT>
<STRONG>
FD_MONTH </STRONG>
</DT><DD>This field records the months as integers, with January as 1. It is offset by <CODE>FD_MONTH_OFFSET</CODE> bits.</DD>
<DT>
<STRONG>
FD_DAY </STRONG>
</DT><DD> This field records the day of the month. It is offset by
 <CODE>FD_DAY_OFFSET</CODE> bits.</DD>
</DL>

<P CLASS="refField"><STRONG>
Include:</STRONG>        <STRONG CLASS="fileName">
file.h</STRONG>
 </P>
<P CLASS="refField"><STRONG>
See Also:</STRONG>        <A HREF = "S_15.htm#IX_FileTime">FileTime</A>
 </P>
</DIV>






<DIV>
<A NAME="S_14.htm_IX_FileDateAndTime">
 </A>
<A NAME="S_14.htm_IX_FDAT_&ldots;">
 </A>
<A NAME="S_14.htm_IX_FDATExtract&ldots; () macros">
 </A>
<H1 CLASS="refHeading">
FileDateAndTime</H1>
<PRE CLASS="syntax">typedef DWordFlags FileDateAndTime;
#define FDAT_HOUR						0xf8000000
#define FDAT_MINUTE						0x07e00000
#define FDAT_2SECOND						0x001f0000
#define FDAT_YEAR 						0x0000fe00
#define FDAT_MONTH 						0x000001e0
#define FDAT_DAY 						0x0000001f
#define FDAT_HOUR_OFFSET					27
#define FDAT_MINUTE_OFFSET					21
#define FDAT_2SECOND_OFFSET					16
#define FDAT_YEAR_OFFSET 					9
#define FDAT_MONTH_OFFSET 					5
#define FDAT_DAY_OFFSET 					0
#define FDAT_BASE_YEAR 					1980</PRE>
<P>
Every GEOS file has two date and time stamps. One of them records the time the file was created, and one records the time the file was last modified. These stamps are recorded with the file's extended attributes; they are labeled FEA_CREATION and FEA_MODIFICATION, respectively. Non-GEOS files have a single date/time stamp, which records the time the file was last modified.</P>
<P>
The date/time stamps are stored in a 32-bit bitfield. This field contains entries for the year, month, day, hour, minute, and second. Each field is identified by a mask and an offset. To access a field, simply clear all bits except those in the mask, then shift the bits to the right by the number of the offset. (Macros are provided to do this; they are described below.) <CODE>
FileDateAndTime</CODE>
 contains the following fields, identified by their masks:</P>
<DL>
<DT>
FDAT_YEAR</DT><DD>This field records the year, counting from a base year of 1980. (The constant FDAT_BASE_YEAR is defined as 1980.) This field is at an offset of FDAT_YEAR_OFFSET bits from the low end of the value.</DD>
<DT>
FDAT_MONTH</DT><DD>
This field records the month as an integer, with January being one. It is located at an offset of FDAT_MONTH_OFFSET.</DD>
<DT>
FDAT_DAY</DT><DD>This field records the day of the month. It is located at an offset of FDAT_DAY_OFFSET.</DD>
<DT>
FDAT_HOUR</DT><DD>This field records the hour on a 24-hour clock, with zero being the hour after midnight. It is located at an offset of FDAT_HOUR_OFFSET.</DD>
<DT>
FDAT_MINUTE</DT><DD>
This field records the minute. It is located at an offset of FDAT_MINUTE_OFFSET.</DD>
<DT>
FDAT_2SECOND</DT><DD>
This field records the second, divided by two; that is, a field value of 15 indicates the 30th second. (It is represented this way to let the second fit into 5 bits, thus letting the entire value fit into 32 bits.) It is located at an offset of FDAT_2SECOND_OFFSET.</DD>
</DL>
<P>
Macros are provided to extract values from each of the fields of a <CODE>
FileDateAndTime</CODE>
 structure. The macros are listed below:</P>
<PRE CLASS="syntax">byte FDATExtractYear( /* returns year field, counted from 1980*/
        FileDateAndTime fdat);
word FDATExtractYearAD( /* returns year field + base year */
        FileDateAndTime fdat);
byte FDATExtractMonth( /* returns month field (1 = January, etc.) */
        FileDateAndTime fdat);
byte FDATExtractDay( /* returns day field */
        FileDateAndTime fdat);
byte FDATExtractHour( /* returns hour field */
        FileDateAndTime fdat);
byte FDATExtractMinute( /* returns minute field */
        FileDateAndTime fdat);
byte FDATExtract2Second( /* returns 2Second field */
        FileDateAndTime fdat);
byte FDATExtractSecond( /* returns number of seconds (2 * 2Second) */
        FileDateAndTime fdat);</PRE>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
file.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="S_14.htm_IX_FileDesktopInfo">
 </A>
<A NAME="S_14.htm_IX_FILE_DESKTOP_INFO_SIZE">
 </A>
<H1 CLASS="refHeading">
FileDesktopInfo</H1>
<PRE CLASS="syntax">typedef char FileDesktopInfo[FILE_DESKTOP_INFO_SIZE];
&nbsp;</PRE>
</DIV>
<DIV>
<A NAME="S_14.htm_IX_FileDirID">
 </A>
<H1 CLASS="refHeading">
FileDirID</H1>
<PRE CLASS="syntax">typedef dword FileDirID;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_14.htm_IX_FileFileID">
 </A>
<H1 CLASS="refHeading">
FileFileID</H1>
<PRE CLASS="syntax">typedef dword FileFileID;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_14.htm_IX_FileExclude">
 </A>
<A NAME="S_14.htm_IX_FE_&ldots;  (FileExclude)">
 </A>
<H1 CLASS="refHeading">
FileExclude</H1>
<PRE CLASS="syntax">typedef ByteEnum FileExclude;
#define FE_EXCLUSIVE				1
#define FE_DENY_WRITE 				2
#define FE_DENY_READ 				3
#define FE_NONE 				4</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_14.htm_IX_FileExtAttrDesc">
 </A>
<A NAME="S_14.htm_IX_FEAD_&ldots;">
 </A>
<H1 CLASS="refHeading">
FileExtAttrDesc</H1>
<PRE CLASS="syntax">typedef struct {
FileExtendedAttribute				FEAD_attr;			/* Attribute to get or set */
void			*FEAD_value;				/* Pointer to buffer/new value */
word			FEAD_size;				/* length of buffer/new value */
chr			*FEAD_name;				/* If FEAD_attr == FEA_CUSTOM,
							 * this points to null-
							 * terminated ASCII string with
							 * attribute's name; otherwise,
							 * this is ignored. */</PRE>
<PRE CLASS="syntax">} FileExtendedAttrDesc;</PRE>
<P>
The routines to get and set extended attributes can be passed the attribute FEA_MULTIPLE. In this case, they will also be passed the address of an array of <CODE>
FileExtAttrDesc</CODE>
 structures and the number of elements of the array. They will go through the array and read or write the appropriate information.</P>
<P>
<CODE>
<A HREF="../../CRef/Routines/R_27.htm#IX_FileEnum()">FileEnum()</A></CODE>
 can also be passed arrays of <CODE>
FileExtAttrDesc</CODE>
 structures. In this case, the number of elements in the array is not passed. Instead, each array ends with a <CODE>
FileExtAttrDesc</CODE>
 with a FEAD<CODE>
_attr</CODE>
 field set to FEA_END_OF_LIST.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Structs/S_14.htm#IX_FileExtendedAttribute">FileExtendedAttribute</A></CODE>.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
file.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="S_14.htm_IX_FileExtendedAttribute">
 </A>
<A NAME="S_14.htm_IX_FEA_&ldots;">
 </A>
<H1 CLASS="refHeading">
FileExtendedAttribute</H1>
<PRE CLASS="syntax">typedef enum /* word */ {
FEA_MODIFICATION,
FEA_FILE_ATTR,
FEA_SIZE,
FEA_FILE_TYPE,
FEA_FLAGS,
FEA_RELEASE,
FEA_PROTOCOL,
FEA_TOKEN,
FEA_CREATOR,
FEA_USER_NOTES,
FEA_NOTICE,
FEA_CREATION,
FEA_PASSWORD,
FEA_CUSTOM,
FEA_NAME,
FEA_GEODE_ATTR,
FEA_PATH_INFO,
FEA_FILE_ID,
FEA_DESKTOP_INFO,
FEA_DRIVE_STATUS,
FEA_DOS_NAME,
FEA_OWNER,
FEA_RIGHTS,
FEA_MULTIPLE = 0xfffe,
FEA_END_OF_LIST = 0xffff,
} FileExtendedAttribute;</PRE>
<P>
Every GEOS file has a set of extended attributes. These attributes can be recovered with <CODE>
<A HREF="../../CRef/Routines/R_29.htm#IX_FileGetPathExtAttributes()">FileGetPathExtAttributes()</A></CODE>
 or <CODE>
<A HREF="../../CRef/Routines/R_29.htm#IX_FileGetHandleExtAttributes()">FileGetHandleExtAttributes()</A></CODE>
. You can also use <CODE>
<A HREF="../../CRef/Routines/R_27.htm#IX_FileEnum()">FileEnum()</A></CODE>
 to search a directory for files with specified extended attributes.</P>
<P>
The above extended attributes have been implemented. More may be added with future releases of GEOS. The attributes are discussed at length in <A HREF="../../Files/FileSys/FileSys_d.htm#49785">the File System chapter</A>.</P><P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Structs/S_14.htm#IX_FileExtAttrDesc">FileExtAttrDesc</A></CODE>.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
file.h</STRONG>
 </P>
</DIV>
<HR>
<A NAME="S_15.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="S_15.htm_IX_FileFromTransferBlockID() macro">
 </A>
<H1 CLASS="refHeading">
FileFromTransferBlockID</H1>
<PRE CLASS="syntax">VMFileHandle FileFromTransferBlockID(id);
        TransferBlockID		id;</PRE>
<P>
This macro extracts the file handle from the given <CODE>
TransferBlockID</CODE>
 value.</P>
</DIV>
<DIV>
<A NAME="S_15.htm_IX_FileHandle">
 </A>
<H1 CLASS="refHeading">
FileHandle</H1>
<PRE CLASS="syntax">typedef Handle FileHandle;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_15.htm_IX_FILE_LONGNAME_BUFFER_SIZE">
 </A>
<A NAME="S_15.htm_IX_FileLongName">
 </A>
<H1 CLASS="refHeading">
FileLongName</H1>
<PRE CLASS="syntax">typedef char FileLongName[FILE_LONGNAME_BUFFER_SIZE];</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_15.htm_IX_FILE_OWNER_NAME_SIZE">
 </A>
<A NAME="S_15.htm_IX_FileOwnerName">
 </A>
<H1 CLASS="refHeading">
FileOwnerName</H1>
<PRE CLASS="syntax">typedef char FileOwnerName[FILE_OWNER_NAME_SIZE];</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_15.htm_IX_FilePassword">
 </A>
<A NAME="S_15.htm_IX_FILE_PASSWORD_SIZE">
 </A>
<H1 CLASS="refHeading">
FilePassword</H1>
<PRE CLASS="syntax">typedef char FilePassword[FILE_PASSWORD_SIZE];</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_15.htm_IX_FilePosMode">
 </A>
<A NAME="S_15.htm_IX_FILE_POS_&ldots;">
 </A>
<H1 CLASS="refHeading">
FilePosMode</H1>
<PRE CLASS="syntax">typedef ByteEnum FilePosMode;
#define FILE_POS_START				0
#define FILE_POS_RELATIVE				1
#define FILE_POS_END				2</PRE>
<P>
&nbsp;</P>
</DIV>

<DIV>
<A NAME="S_15.htm_IX_FileTime">
 </A>
<H1 CLASS="refHeading">
FileTime</H1>
<PRE CLASS="syntax">typedef WordFlags FileTime;
#define FT_HOUR                 0xf800
#define FT_MINUTE               0x07e0
#define FT_2SECOND              0x001f
#define FT_HOUR_OFFSET          11
#define FT_MINUTE_OFFSET        5
#define FT_2SECOND_OFFSET       0</PRE>
<P>
A file's time stamp is stored in a 16-bit bitfield. This field contains entries for the hour, minute, and second.
Each field is identified by a mask and an offset. To access a field, simply clear all bits except those in the mask, then shift the bits to the right by the number of the offset. <CODE>FileTime</CODE> contains the
following fields, identified by their masks:
</P>

<DL>
<DT>
<STRONG>
FT_HOUR </STRONG>
</DT><DD> This field records the hour on a 24-hour clock, with zero being the hour after midnight.. It is offset by <CODE>FT_HOUR_OFFSET</CODE> bits.</DD>
<DT>
<STRONG>
FT_MINUTE</STRONG>
</DT><DD>This field identifies the minutes. It is offset by <CODE>FT_MINUTE_OFFSET</CODE> bits.</DD>
<DT>
<STRONG>
FT_2SECOND </STRONG>
</DT><DD> This field records the second, divided by two; that is, a field value of 15 indicates the 30th second. (It is represented this way to let the second fit into 5 bits.) It is located at an offset of
 <CODE>FT_2SECOND_OFFSET</CODE> bits.</DD>
</DL>

<P CLASS="refField"><STRONG>
Include:</STRONG>        <STRONG CLASS="fileName">
file.h</STRONG>
 </P>
<P CLASS="refField"><STRONG>
See Also:</STRONG>        <A HREF = "S_14.htm#IX_FileDate">FileDate</A>
 </P>
</DIV>


<DIV>
<A NAME="S_15.htm_IX_FileUserNotes">
 </A>
<A NAME="S_15.htm_IX_GFH_USER_NOTES_BUFFER_SIZE">
 </A>
<H1 CLASS="refHeading">
FileUserNotes</H1>
<PRE CLASS="syntax">typedef char FileUserNotes[GFH_USER_NOTES_BUFFER_SIZE];</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_15.htm_IX_FindNoteHeader">
 </A>
<A NAME="S_15.htm_IX_FNH_&ldots;">
 </A>
<H1 CLASS="refHeading">
FindNoteHeader</H1>
<PRE CLASS="syntax">typedef struct {
word 	FNH_count;			/* The number of matching notes we've found */
} FindNoteHeader;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_15.htm_IX_FloatExponent">
 </A>
<A NAME="S_15.htm_IX_FE_&ldots;  (FloatExponent)">
 </A>
<H1 CLASS="refHeading">
FloatExponent</H1>
<PRE CLASS="syntax">typedef WordFlags FloatExponent;
#define FE_SIGN         0x8000
#define FE_EXPONENT     0x7fff</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_15.htm_IX_FloatNum">
 </A>
<A NAME="S_15.htm_IX_F_&ldots;">
 </A>
<H1 CLASS="refHeading">
FloatNum</H1>
<PRE CLASS="syntax">typedef struct {
        word    				F_mantissa_wd0;
        word    				F_mantissa_wd1;
        word    				F_mantissa_wd2;
        word    				F_mantissa_wd3;
        FloatExponent   				F_exponent;
} FloatNum;</PRE>
<P>
&nbsp;</P>
</DIV>




<DIV>
<A NAME="S_15.htm_IX_FontAttrs">
 </A>
<A NAME="S_15.htm_IX_FA_&ldots;  (FontAttrs)">
 </A>
<H1 CLASS="refHeading">
FontAttrs</H1>
<PRE CLASS="syntax">typedef ByteFlags FontAttrs;
#define FA_FIXED_WIDTH 				0x40
#define FA_ORIENT 				0x20
#define FA_OUTLINE 				0x10
#define FA_FAMILY 				0x0f
#define FA_FAMILY_OFFSET				0</PRE>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
font.h</STRONG>
 </P>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_15.htm_IX_FEF_&ldots;">
 </A>
<A NAME="S_15.htm_IX_FontEnumFlags">
 </A>
<H1 CLASS="refHeading">
FontEnumFlags</H1>
<PRE CLASS="syntax">typedef ByteFlags FontEnumFlags;
#define FEF_ALPHABETIZE				0x80		/* Alphabetize returned list of fonts */
#define FEF_FIXED_WIDTH				0x20		/* Return only fixed-width fonts */
#define FEF_FAMILY 				0x10		
#define FEF_STRING 				0x08		
#define FEF_DOWNCASE 				0x04		/* Returned font names will be lowercase */
#define FEF_BITMAPS 				0x02		/* Interested in bitmap fonts */
#define FEF_OUTLINES 				0x01		/* Interested in outline fonts */</PRE>
<P>
&nbsp;</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
font.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="S_15.htm_IX_FontEnumStruct">
 </A>
<A NAME="S_15.htm_IX_FES_&ldots;">
 </A>
<A NAME="S_15.htm_IX_FID_NAME_LEN">
 </A>
<H1 CLASS="refHeading">
FontEnumStruct</H1>
<PRE CLASS="syntax">typedef struct {
 FontIDs	 	FES_ID;
 char 		FES_name[FID_NAME_LEN];
} FontEnumStruct;</PRE>
<P>
&nbsp;</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
font.h</STRONG>
 </P>
</DIV>
<HR>
<A NAME="S_16.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="S_16.htm_IX_FontFamily">
 </A>
<A NAME="S_16.htm_IX_FF_&ldots;">
 </A>
<H1 CLASS="refHeading">
FontFamily</H1>
<PRE CLASS="syntax">typedef byte FontFamily;
#define FF_NON_PORTABLE					0x0007
#define FF_SPECIAL					0x0006
#define FF_MONO					0x0005
#define FF_SYMBOL					0x0004
#define FF_ORNAMENT					0x0003
#define FF_SCRIPT					0x0002
#define FF_SANS_SERIF					0x0001
#define FF_SERIF					0x0000</PRE>
<P>
&nbsp;</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
fontID.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="S_16.htm_IX_FontGroup">
 </A>
<A NAME="S_16.htm_IX_FG_&ldots;">
 </A>
<H1 CLASS="refHeading">
FontGroup</H1>
<PRE CLASS="syntax">typedef enum /* word */ {
#define FG_NON_PORTABLE					0x0e00
#define FG_SPECIAL					0x0c00
#define FG_MONO					0x0a00
#define FG_SYMBOL					0x0800
#define FG_ORNAMENT					0x0600
#define FG_SCRIPT					0x0400
#define FG_SANS_SERIF					0x0200
#define FG_SERIF					0x0000
} FontGroup;</PRE>
<P>
&nbsp;</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
fontID.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="S_16.htm_IX_FontIDRecord">
 </A>
<A NAME="S_16.htm_IX_FIDR_&ldots;">
 </A>
<H1 CLASS="refHeading">
FontIDRecord</H1>
<PRE CLASS="syntax">typedef WordFlags FontIDRecord;
#define FIDR_maker				0xf000
#define FIDR_ID				0x0fff
#define FIDR_maker_OFFSET					12
#define FIDR_ID_OFFSET					 0</PRE>
<P>
&nbsp;</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
font.h</STRONG>
 </P>
</DIV>
<HR>
<A NAME="S_17.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="S_17.htm_IX_FontID">
 </A>
<A NAME="S_17.htm_IX_FID_&ldots;">
 </A>
<H1 CLASS="refHeading">
FontID</H1>
<PRE CLASS="syntax">typedef word FontID;
#define FID_PRINTER_20CPI										0xfa05
#define FID_PRINTER_17CPI										0xfa04
#define FID_PRINTER_16CPI										0xfa03
#define FID_PRINTER_15CPI										0xfa02
#define FID_PRINTER_12CPI										0xfa01
#define FID_PRINTER_10CPI										0xfa00
#define FID_PRINTER_PROP_SANS										0xf200
#define FID_PRINTER_PROP_SERIF										0xf000
#define FID_BITSTREAM_LETTER_GOTHIC										0x3a03
#define FID_PS_LETTER_GOTHIC										0x2a03
#define FID_DTC_LETTER_GOTHIC										0x1a03
#define FID_BITSTREAM_PRESTIGE_ELITE										0x3a02
#define FID_PS_PRESTIGE_ELITE										0x2a02
#define FID_DTC_PRESTIGE_ELITE										0x1a02
#define FID_BITSTREAM_AMERICAN_TYPEWRITER										0x3a01
#define FID_PS_AMERICAN_TYPEWRITER										0x2a01
#define FID_DTC_AMERICAN_TYPEWRITER										0x1a01
#define FID_BITSTREAM_URW_MONO										0x3a00
#define FID_PS_COURIER										0x2a00
#define FID_DTC_URW_MONO										0x1a00
#define FID_BITSTREAM_FUN_DINGBATS										0x380d
#define FID_PS_FUN_DINGBATS										0x280d
#define FID_DTC_FUN_DINGBATS										0x180d
#define FID_BITSTREAM_CHEQ										0x380c
#define FID_PS_CHEQ										0x280c
#define FID_DTC_CHEQ										0x180c
#define FID_BITSTREAM_BUNDESBAHN_PI_3										0x380b
#define FID_PS_BUNDESBAHN_PI_3										0x280b
#define FID_DTC_BUNDESBAHN_PI_3										0x180b
#define FID_BITSTREAM_BUNDESBAHN_PI_2										0x380a
#define FID_PS_BUNDESBAHN_PI_2										0x280a
#define FID_DTC_BUNDESBAHN_PI_2										0x180a
#define FID_BITSTREAM_BUNDESBAHN_PI_1										0x3809
#define FID_PS_BUNDESBAHN_PI_1										0x2809
#define FID_DTC_BUNDESBAHN_PI_1										0x1809
#define FID_BITSTREAM_U_GREEK_MATH_PI										0x3808
#define FID_PS_U_GREEK_MATH_PI										0x2808
#define FID_DTC_U_GREEK_MATH_PI										0x1808
#define FID_BITSTREAM_U_NEWS_COMM_PI										0x3807
#define FID_PS_U_NEWS_COMM_PI										0x2807
#define FID_DTC_U_NEWS_COMM_PI										0x1807
#define FID_BITSTREAM_ACE_I										0x3806
#define FID_PS_ACE_I										0x2806
#define FID_DTC_ACE_I										0x1806
#define FID_BITSTREAM_SONATA										0x3805
#define FID_PS_SONATA										0x2805
#define FID_DTC_SONATA										0x1805
#define FID_BITSTREAM_CARTA										0x3804
#define FID_PS_CARTA										0x2804
#define FID_DTC_CARTA										0x1804
#define FID_BITSTREAM_MICR										0x3803
#define FID_PS_MICR										0x2803
#define FID_DTC_MICR										0x1803
#define FID_BITSTREAM_ZAPF_DINGBATS										0x3802
#define FID_PS_ZAPF_DINGBATS										0x2802
#define FID_DTC_ZAPF_DINGBATS										0x1802
#define FID_BITSTREAM_DINGBATS										0x3801
#define FID_PS_DINGBATS										0x2801
#define FID_DTC_DINGBATS										0x1801
#define FID_BITSTREAM_URW_SYMBOLPS										0x3800
#define FID_PS_SYMBOL										0x2800
#define FID_DTC_URW_SYMBOLPS										0x1800
#define FID_BITSTREAM_JUNIPER										0x367f
#define FID_PS_JUNIPER										0x267f
#define FID_DTC_JUNIPER										0x167f
#define FID_BITSTREAM_COTTONWOOD										0x367e
#define FID_PS_COTTONWOOD										0x267e
#define FID_DTC_COTTONWOOD										0x167e
#define FID_BITSTREAM_BANCO										0x367d
#define FID_PS_BANCO										0x267d
#define FID_DTC_BANCO										0x167d
#define FID_BITSTREAM_ARCADIA										0x367c
#define FID_PS_ARCADIA										0x267c
#define FID_DTC_ARCADIA										0x167c
#define FID_BITSTREAM_ZIPPER										0x367b
#define FID_PS_ZIPPER										0x267b
#define FID_DTC_ZIPPER										0x167b
#define FID_BITSTREAM_WEIFZ_RUNDGOTIFCH										0x367a
#define FID_PS_WEIFZ_RUNDGOTIFCH										0x267a
#define FID_DTC_WEIFZ_RUNDGOTIFCH										0x167a
#define FID_BITSTREAM_WASHINGTON										0x3679
#define FID_PS_WASHINGTON										0x2679
#define FID_DTC_WASHINGTON										0x1679
#define FID_BITSTREAM_VICTORIAN										0x3678
#define FID_PS_VICTORIAN										0x2678
#define FID_DTC_VICTORIAN										0x1678
#define FID_BITSTREAM_VEGAS										0x3677
#define FID_PS_VEGAS										0x2677
#define FID_DTC_VEGAS										0x1677
#define FID_BITSTREAM_VARIO										0x3676
#define FID_PS_VARIO										0x2676
#define FID_DTC_VARIO										0x1676
#define FID_BITSTREAM_VAG_RUNDSCHRIFT										0x3675
#define FID_PS_VAG_RUNDSCHRIFT										0x2675
#define FID_DTC_VAG_RUNDSCHRIFT										0x1675
#define FID_BITSTREAM_TRAJANUS										0x3674
#define FID_PS_TRAJANUS										0x2674
#define FID_DTC_TRAJANUS										0x1674
#define FID_BITSTREAM_TITUS										0x3673
#define FID_PS_TITUS										0x2673
#define FID_DTC_TITUS										0x1673
#define FID_BITSTREAM_TIME_SCRIPT										0x3672
#define FID_PS_TIME_SCRIPT										0x2672
#define FID_DTC_TIME_SCRIPT										0x1672
#define FID_BITSTREAM_THUNDERBIRD										0x3671
#define FID_PS_THUNDERBIRD										0x2671
#define FID_DTC_THUNDERBIRD										0x1671
#define FID_BITSTREAM_THOROWGOOD										0x3670
#define FID_PS_THOROWGOOD										0x2670
#define FID_DTC_THOROWGOOD										0x1670
#define FID_BITSTREAM_TARRAGON										0x366f
#define FID_PS_TARRAGON										0x266f
#define FID_DTC_TARRAGON										0x166f
#define FID_BITSTREAM_TANGO										0x366e
#define FID_PS_TANGO										0x266e
#define FID_DTC_TANGO										0x166e
#define FID_BITSTREAM_SYNCHRO										0x366d
#define FID_PS_SYNCHRO										0x266d
#define FID_DTC_SYNCHRO										0x166d
#define FID_BITSTREAM_SUPERSTAR										0x366c
#define FID_PS_SUPERSTAR										0x266c
#define FID_DTC_SUPERSTAR										0x166c
#define FID_BITSTREAM_STOP										0x366b
#define FID_PS_STOP										0x266b
#define FID_DTC_STOP										0x166b
#define FID_BITSTREAM_STILLA_CAPS										0x366a
#define FID_PS_STILLA_CAPS										0x266a
#define FID_DTC_STILLA_CAPS										0x166a
#define FID_BITSTREAM_STILLA										0x3669
#define FID_PS_STILLA										0x2669
#define FID_DTC_STILLA										0x1669
#define FID_BITSTREAM_STENTOR										0x3668
#define FID_PS_STENTOR										0x2668
#define FID_DTC_STENTOR										0x1668
#define FID_BITSTREAM_SQUIRE										0x3667
#define FID_PS_SQUIRE										0x2667
#define FID_DTC_SQUIRE										0x1667
#define FID_BITSTREAM_SPRINGFIELD										0x3666
#define FID_PS_SPRINGFIELD										0x2666
#define FID_DTC_SPRINGFIELD										0x1666
#define FID_BITSTREAM_SLIPSTREAM										0x3665
#define FID_PS_SLIPSTREAM										0x2665
#define FID_DTC_SLIPSTREAM										0x1665
#define FID_BITSTREAM_SINALOA										0x3664
#define FID_PS_SINALOA										0x2664
#define FID_DTC_SINALOA										0x1664
#define FID_BITSTREAM_SHELLEY										0x3663
#define FID_PS_SHELLEY										0x2663
#define FID_DTC_SHELLEY										0x1663
#define FID_BITSTREAM_SERPENTINE										0x3662
#define FID_PS_SERPENTINE										0x2662
#define FID_DTC_SERPENTINE										0x1662
#define FID_BITSTREAM_RUBBER_STAMP										0x3661
#define FID_PS_RUBBER_STAMP										0x2661
#define FID_DTC_RUBBER_STAMP										0x1661
#define FID_BITSTREAM_ROMIC										0x3660
#define FID_PS_ROMIC										0x2660
#define FID_DTC_ROMIC										0x1660
#define FID_BITSTREAM_RIALTO										0x365f
#define FID_PS_RIALTO										0x265f
#define FID_DTC_RIALTO										0x165f
#define FID_BITSTREAM_REVUE										0x365e
#define FID_PS_REVUE										0x265e
#define FID_DTC_REVUE										0x165e
#define FID_BITSTREAM_QUENTIN										0x365d
#define FID_PS_QUENTIN										0x265d
#define FID_DTC_QUENTIN										0x165d
#define FID_BITSTREAM_PRO_ARTE										0x365c
#define FID_PS_PRO_ARTE										0x265c
#define FID_DTC_PRO_ARTE										0x165c
#define FID_BITSTREAM_PRINCETOWN										0x365b
#define FID_PS_PRINCETOWN										0x265b
#define FID_DTC_PRINCETOWN										0x165b
#define FID_BITSTREAM_PRESIDENT										0x365a
#define FID_PS_PRESIDENT										0x265a
#define FID_DTC_PRESIDENT										0x165a
#define FID_BITSTREAM_PREMIER										0x3659
#define FID_PS_PREMIER										0x2659
#define FID_DTC_PREMIER										0x1659
#define FID_BITSTREAM_POST_ANTIQUA										0x3658
#define FID_PS_POST_ANTIQUA										0x2658
#define FID_DTC_POST_ANTIQUA										0x1658
#define FID_BITSTREAM_PLAZA										0x3657
#define FID_PS_PLAZA										0x2657
#define FID_DTC_PLAZA										0x1657
#define FID_BITSTREAM_PLAYBILL										0x3656
#define FID_PS_PLAYBILL										0x2656
#define FID_DTC_PLAYBILL										0x1656
#define FID_BITSTREAM_PICCADILLY										0x3655
#define FID_PS_PICCADILLY										0x2655
#define FID_DTC_PICCADILLY										0x1655
#define FID_BITSTREAM_PEIGNOT										0x3654
#define FID_PS_PEIGNOT										0x2654
#define FID_DTC_PEIGNOT										0x1654
#define FID_BITSTREAM_PAPYRUS										0x3653
#define FID_PS_PAPYRUS										0x2653
#define FID_DTC_PAPYRUS										0x1653
#define FID_BITSTREAM_PADDINGTION										0x3652
#define FID_PS_PADDINGTION										0x2652
#define FID_DTC_PADDINGTION										0x1652
#define FID_BITSTREAM_OKAY										0x3651
#define FID_PS_OKAY										0x2651
#define FID_DTC_OKAY										0x1651
#define FID_BITSTREAM_ODIN										0x3650
#define FID_PS_ODIN										0x2650
#define FID_DTC_ODIN										0x1650
#define FID_BITSTREAM_OCTOPUSS										0x364f
#define FID_PS_OCTOPUSS										0x264f
#define FID_DTC_OCTOPUSS										0x164f
#define FID_BITSTREAM_MOTTER_FEMINA										0x364e
#define FID_PS_MOTTER_FEMINA										0x264e
#define FID_DTC_MOTTER_FEMINA										0x164e
#define FID_BITSTREAM_MICROGRAMMA										0x364d
#define FID_PS_MICROGRAMMA										0x264d
#define FID_DTC_MICROGRAMMA										0x164d
#define FID_BITSTREAM_MACHINE										0x364c
#define FID_PS_MACHINE										0x264c
#define FID_DTC_MACHINE										0x164c
#define FID_BITSTREAM_LINOTEXT										0x364b
#define FID_PS_LINOTEXT										0x264b
#define FID_DTC_LINOTEXT										0x164b
#define FID_BITSTREAM_LIBERTY										0x364a
#define FID_PS_LIBERTY										0x264a
#define FID_DTC_LIBERTY										0x164a
#define FID_BITSTREAM_LAZYBONES										0x3649
#define FID_PS_LAZYBONES										0x2649
#define FID_DTC_LAZYBONES										0x1649
#define FID_BITSTREAM_LATIN_WIDE										0x3648
#define FID_PS_LATIN_WIDE										0x2648
#define FID_DTC_LATIN_WIDE										0x1648
#define FID_BITSTREAM_KNIGHTSBRIDGE										0x3647
#define FID_PS_KNIGHTSBRIDGE										0x2647
#define FID_DTC_KNIGHTSBRIDGE										0x1647
#define FID_BITSTREAM_KAPITELLIA										0x3646
#define FID_PS_KAPITELLIA										0x2646
#define FID_DTC_KAPITELLIA										0x1646
#define FID_BITSTREAM_KALLIGRAPHIA										0x3645
#define FID_PS_KALLIGRAPHIA										0x2645
#define FID_DTC_KALLIGRAPHIA										0x1645
#define FID_BITSTREAM_ICE_AGE										0x3644
#define FID_PS_ICE_AGE										0x2644
#define FID_DTC_ICE_AGE										0x1644
#define FID_BITSTREAM_ICONE										0x3643
#define FID_PS_ICONE										0x2643
#define FID_DTC_ICONE										0x1643
#define FID_BITSTREAM_HORNDON										0x3642
#define FID_PS_HORNDON										0x2642
#define FID_DTC_HORNDON										0x1642
#define FID_BITSTREAM_HORATIO										0x3641
#define FID_PS_HORATIO										0x2641
#define FID_DTC_HORATIO										0x1641
#define FID_BITSTREAM_HIGHLIGHT										0x3640
#define FID_PS_HIGHLIGHT										0x2640
#define FID_DTC_HIGHLIGHT										0x1640
#define FID_BITSTREAM_HADFIELD										0x363f
#define FID_PS_HADFIELD										0x263f
#define FID_DTC_HADFIELD										0x163f
#define FID_BITSTREAM_GLASER_STENCIL										0x363e
#define FID_PS_GLASER_STENCIL										0x263e
#define FID_DTC_GLASER_STENCIL										0x163e
#define FID_BITSTREAM_GILL_KAYO										0x363d
#define FID_PS_GILL_KAYO										0x263d
#define FID_DTC_GILL_KAYO										0x163d
#define FID_BITSTREAM_GALADRIEL										0x363c
#define FID_PS_GALADRIEL										0x263c
#define FID_DTC_GALADRIEL										0x163c
#define FID_BITSTREAM_FUTURA_DISPLAY										0x363b
#define FID_PS_FUTURA_DISPLAY										0x263b
#define FID_DTC_FUTURA_DISPLAY										0x163b
#define FID_BITSTREAM_FUTURA_C_BLACK										0x363a
#define FID_PS_FUTURA_C_BLACK										0x263a
#define FID_DTC_FUTURA_C_BLACK										0x163a
#define FID_BITSTREAM_FRANKFURTER										0x3639
#define FID_PS_FRANKFURTER										0x2639
#define FID_DTC_FRANKFURTER										0x1639
#define FID_BITSTREAM_FLORA										0x3638
#define FID_PS_FLORA										0x2638
#define FID_DTC_FLORA										0x1638
#define FID_BITSTREAM_FLANGE										0x3637
#define FID_PS_FLANGE										0x2637
#define FID_DTC_FLANGE										0x1637
#define FID_BITSTREAM_FLASH										0x3636
#define FID_PS_FLASH										0x2636
#define FID_DTC_FLASH										0x1636
#define FID_BITSTREAM_FLAMENCO										0x3635
#define FID_PS_FLAMENCO										0x2635
#define FID_DTC_FLAMENCO										0x1635
#define FID_BITSTREAM_FETTE_GOTILCH										0x3634
#define FID_PS_FETTE_GOTILCH										0x2634
#define FID_DTC_FETTE_GOTILCH										0x1634
#define FID_BITSTREAM_FETTE_FRAKTUR										0x3633
#define FID_PS_FETTE_FRAKTUR										0x2633
#define FID_DTC_FETTE_FRAKTUR										0x1633
#define FID_BITSTREAM_ENVIRO										0x3632
#define FID_PS_ENVIRO										0x2632
#define FID_DTC_ENVIRO										0x1632
#define FID_BITSTREAM_EINHORN										0x3631
#define FID_PS_EINHORN										0x2631
#define FID_DTC_EINHORN										0x1631
#define FID_BITSTREAM_ECKMANN										0x3630
#define FID_PS_ECKMANN										0x2630
#define FID_DTC_ECKMANN										0x1630
#define FID_BITSTREAM_DYNAMO										0x362f
#define FID_PS_DYNAMO										0x262f
#define FID_DTC_DYNAMO										0x162f
#define FID_BITSTREAM_DOM_CASUAL										0x362e
#define FID_PS_DOM_CASUAL										0x262e
#define FID_DTC_DOM_CASUAL										0x162e
#define FID_BITSTREAM_DAVIDA										0x362d
#define FID_PS_DAVIDA										0x262d
#define FID_DTC_DAVIDA										0x162d
#define FID_BITSTREAM_CROISSANT										0x362c
#define FID_PS_CROISSANT										0x262c
#define FID_DTC_CROISSANT										0x162c
#define FID_BITSTREAM_CRILLEE										0x362b
#define FID_PS_CRILLEE										0x262b
#define FID_DTC_CRILLEE										0x162b
#define FID_BITSTREAM_COUNTDOWN										0x362a
#define FID_PS_COUNTDOWN										0x262a
#define FID_DTC_COUNTDOWN										0x162a
#define FID_BITSTREAM_CORTEZ										0x3629
#define FID_PS_CORTEZ										0x2629
#define FID_DTC_CORTEZ										0x1629
#define FID_BITSTREAM_CONFERENCE										0x3628
#define FID_PS_CONFERENCE										0x2628
#define FID_DTC_CONFERENCE										0x1628
#define FID_BITSTREAM_COMPANY										0x3627
#define FID_PS_COMPANY										0x2627
#define FID_DTC_COMPANY										0x1627
#define FID_BITSTREAM_COLUMNA_SOLID										0x3626
#define FID_PS_COLUMNA_SOLID										0x2626
#define FID_DTC_COLUMNA_SOLID										0x1626
#define FID_BITSTREAM_CITY										0x3625
#define FID_PS_CITY										0x2625
#define FID_DTC_CITY										0x1625
#define FID_BITSTREAM_CIRKULUS										0x3624
#define FID_PS_CIRKULUS										0x2624
#define FID_DTC_CIRKULUS										0x1624
#define FID_BITSTREAM_CHURCHWARD_BRUSH										0x3623
#define FID_PS_CHURCHWARD_BRUSH										0x2623
#define FID_DTC_CHURCHWARD_BRUSH										0x1623
#define FID_BITSTREAM_CHROMIUM_ONE										0x3622
#define FID_PS_CHROMIUM_ONE										0x2622
#define FID_DTC_CHROMIUM_ONE										0x1622
#define FID_BITSTREAM_CHOC										0x3621
#define FID_PS_CHOC										0x2621
#define FID_DTC_CHOC										0x1621
#define FID_BITSTREAM_CHISEL										0x3620
#define FID_PS_CHISEL										0x2620
#define FID_DTC_CHISEL										0x1620
#define FID_BITSTREAM_CHESTERFIELD										0x361f
#define FID_PS_CHESTERFIELD										0x261f
#define FID_DTC_CHESTERFIELD										0x161f
#define FID_BITSTREAM_CAROUSEL										0x361e
#define FID_PS_CAROUSEL										0x261e
#define FID_DTC_CAROUSEL										0x161e
#define FID_BITSTREAM_CAMELLIA										0x361d
#define FID_PS_CAMELLIA										0x261d
#define FID_DTC_CAMELLIA										0x161d
#define FID_BITSTREAM_CABARET										0x361c
#define FID_PS_CABARET										0x261c
#define FID_DTC_CABARET										0x161c
#define FID_BITSTREAM_BUXOM										0x361b
#define FID_PS_BUXOM										0x261b
#define FID_DTC_BUXOM										0x161b
#define FID_BITSTREAM_BUSTER										0x361a
#define FID_PS_BUSTER										0x261a
#define FID_DTC_BUSTER										0x161a
#define FID_BITSTREAM_BOTTLENECK										0x3619
#define FID_PS_BOTTLENECK										0x2619
#define FID_DTC_BOTTLENECK										0x1619
#define FID_BITSTREAM_BLOCK										0x3618
#define FID_PS_BLOCK										0x2618
#define FID_DTC_BLOCK										0x1618
#define FID_BITSTREAM_BINNER										0x3617
#define FID_PS_BINNER										0x2617
#define FID_DTC_BINNER										0x1617
#define FID_BITSTREAM_BERNHARD_ANTIQUE										0x3616
#define FID_PS_BERNHARD_ANTIQUE										0x2616
#define FID_DTC_BERNHARD_ANTIQUE										0x1616
#define FID_BITSTREAM_BELSHAW										0x3615
#define FID_PS_BELSHAW										0x2615
#define FID_DTC_BELSHAW										0x1615
#define FID_BITSTREAM_BARCELONA										0x3614
#define FID_PS_BARCELONA										0x2614
#define FID_DTC_BARCELONA										0x1614
#define FID_BITSTREAM_BAUHAUS										0x3613
#define FID_PS_BAUHAUS										0x2613
#define FID_DTC_BAUHAUS										0x1613
#define FID_BITSTREAM_AUGUSTEA_OPEN										0x3612
#define FID_PS_AUGUSTEA_OPEN										0x2612
#define FID_DTC_AUGUSTEA_OPEN										0x1612
#define FID_BITSTREAM_AMERICAN_UNCIAL										0x3611
#define FID_PS_AMERICAN_UNCIAL										0x2611
#define FID_DTC_AMERICAN_UNCIAL										0x1611
#define FID_BITSTREAM_ULTE_SCHWABACHER										0x3610
#define FID_PS_ULTE_SCHWABACHER										0x2610
#define FID_DTC_ULTE_SCHWABACHER										0x1610
#define FID_BITSTREAM_ARNOLD_BOCKLIN										0x360f
#define FID_PS_ARNOLD_BOCKLIN										0x260f
#define FID_DTC_ARNOLD_BOCKLIN										0x160f
#define FID_BITSTREAM_ALGERIAN										0x360e
#define FID_PS_ALGERIAN										0x260e
#define FID_DTC_ALGERIAN										0x160e
#define FID_BITSTREAM_PUMP										0x360d
#define FID_PS_PUMP										0x260d
#define FID_DTC_PUMP										0x160d
#define FID_BITSTREAM_MARIAGE										0x360c
#define FID_PS_MARIAGE										0x260c
#define FID_DTC_MARIAGE										0x160c
#define FID_BITSTREAM_OLD_TOWN										0x360b
#define FID_PS_OLD_TOWN										0x260b
#define FID_DTC_OLD_TOWN										0x160b
#define FID_BITSTREAM_HOBO										0x360a
#define FID_PS_HOBO										0x260a
#define FID_DTC_HOBO										0x160a
#define FID_BITSTREAM_GOUDY_HEAVYFACE										0x3609
#define FID_PS_GOUDY_HEAVYFACE										0x2609
#define FID_DTC_GOUDY_HEAVYFACE										0x1609
#define FID_BITSTREAM_DATA_70										0x3608
#define FID_PS_DATA_70										0x2608
#define FID_DTC_DATA_70										0x1608
#define FID_BITSTREAM_LCD										0x3607
#define FID_PS_LCD										0x2607
#define FID_DTC_LCD										0x1607
#define FID_BITSTREAM_BALLOON										0x3606
#define FID_PS_BALLOON										0x2606
#define FID_DTC_BALLOON										0x1606
#define FID_BITSTREAM_BLIPPO_C_BLACK										0x3605
#define FID_PS_BLIPPO_C_BLACK										0x2605
#define FID_DTC_BLIPPO_C_BLACK										0x1605
#define FID_BITSTREAM_COOPER_C_BLACK										0x3604
#define FID_PS_COOPER_C_BLACK										0x2604
#define FID_DTC_COOPER_C_BLACK										0x1604
#define FID_BITSTREAM_COPPERPLATE										0x3603
#define FID_PS_COPPERPLATE										0x2603
#define FID_DTC_COPPERPLATE										0x1603
#define FID_BITSTREAM_STENCIL										0x3602
#define FID_PS_STENCIL										0x2602
#define FID_DTC_STENCIL										0x1602
#define FID_BITSTREAM_OLD_ENGLISH										0x3601
#define FID_PS_OLD_ENGLISH										0x2601
#define FID_DTC_OLD_ENGLISH										0x1601
#define FID_BITSTREAM_BROADWAY										0x3600
#define FID_PS_BROADWAY										0x2600
#define FID_DTC_BROADWAY										0x1600
#define FID_BITSTREAM_NUPITAL_SCRIPT										0x3430
#define FID_PS_NUPITAL_SCRIPT										0x2430
#define FID_DTC_NUPITAL_SCRIPT										0x1430
#define FID_BITSTREAM_MEDICI_SCRIPT										0x342f
#define FID_PS_MEDICI_SCRIPT										0x242f
#define FID_DTC_MEDICI_SCRIPT										0x142f
#define FID_BITSTREAM_CHARME										0x342e
#define FID_PS_CHARME										0x242e
#define FID_DTC_CHARME										0x142e
#define FID_BITSTREAM_CASCADE_SCRIPT										0x342d
#define FID_PS_CASCADE_SCRIPT										0x242d
#define FID_DTC_CASCADE_SCRIPT										0x142d
#define FID_BITSTREAM_LITHOS										0x342c
#define FID_PS_LITHOS										0x242c
#define FID_DTC_LITHOS										0x142c
#define FID_BITSTREAM_TEKTON										0x342b
#define FID_PS_TEKTON										0x242b
#define FID_DTC_TEKTON										0x142b
#define FID_BITSTREAM_VLADIMIR_SCRIPT										0x342a
#define FID_PS_VLADIMIR_SCRIPT										0x242a
#define FID_DTC_VLADIMIR_SCRIPT										0x142a
#define FID_BITSTREAM_VAN_DIJK										0x3429
#define FID_PS_VAN_DIJK										0x2429
#define FID_DTC_VAN_DIJK										0x1429
#define FID_BITSTREAM_SLOGAN										0x3428
#define FID_PS_SLOGAN										0x2428
#define FID_DTC_SLOGAN										0x1428
#define FID_BITSTREAM_SHAMROCK										0x3427
#define FID_PS_SHAMROCK										0x2427
#define FID_DTC_SHAMROCK										0x1427
#define FID_BITSTREAM_ROMAN_SCRIPT										0x3426
#define FID_PS_ROMAN_SCRIPT										0x2426
#define FID_DTC_ROMAN_SCRIPT										0x1426
#define FID_BITSTREAM_RAGE										0x3425
#define FID_PS_RAGE										0x2425
#define FID_DTC_RAGE										0x1425
#define FID_BITSTREAM_PRESENT_SCRIPT										0x3424
#define FID_PS_PRESENT_SCRIPT										0x2424
#define FID_DTC_PRESENT_SCRIPT										0x1424
#define FID_BITSTREAM_PHYLLIS_INITIALS										0x3423
#define FID_PS_PHYLLIS_INITIALS										0x2423
#define FID_DTC_PHYLLIS_INITIALS										0x1423
#define FID_BITSTREAM_PHYLLIS										0x3422
#define FID_PS_PHYLLIS										0x2422
#define FID_DTC_PHYLLIS										0x1422
#define FID_BITSTREAM_PEPITA										0x3421
#define FID_PS_PEPITA										0x2421
#define FID_DTC_PEPITA										0x1421
#define FID_BITSTREAM_PENDRY_SCRIPT										0x3420
#define FID_PS_PENDRY_SCRIPT										0x2420
#define FID_DTC_PENDRY_SCRIPT										0x1420
#define FID_BITSTREAM_PALETTE										0x341f
#define FID_PS_PALETTE										0x241f
#define FID_DTC_PALETTE										0x141f
#define FID_BITSTREAM_PALACE_SCRIPT										0x341e
#define FID_PS_PALACE_SCRIPT										0x241e
#define FID_DTC_PALACE_SCRIPT										0x141e
#define FID_BITSTREAM_NEVISON_CASUAL										0x341d
#define FID_PS_NEVISON_CASUAL										0x241d
#define FID_DTC_NEVISON_CASUAL										0x141d
#define FID_BITSTREAM_HILL										0x341c
#define FID_PS_HILL										0x241c
#define FID_DTC_HILL										0x141c
#define FID_BITSTREAM_LINOSCRIPT										0x341b
#define FID_PS_LINOSCRIPT										0x241b
#define FID_DTC_LINOSCRIPT										0x141b
#define FID_BITSTREAM_LINDSAY										0x341a
#define FID_PS_LINDSAY										0x241a
#define FID_DTC_LINDSAY										0x141a
#define FID_BITSTREAM_LE_GRIFFE										0x3419
#define FID_PS_LE_GRIFFE										0x2419
#define FID_DTC_LE_GRIFFE										0x1419
#define FID_BITSTREAM_KUNSTLERSCHREIBSCHRIFT										0x3418
#define FID_PS_KUNSTLERSCHREIBSCHRIFT										0x2418
#define FID_DTC_KUNSTLERSCHREIBSCHRIFT										0x1418
#define FID_BITSTREAM_JULIA_SCRIPT										0x3417
#define FID_PS_JULIA_SCRIPT										0x2417
#define FID_DTC_JULIA_SCRIPT										0x1417
#define FID_BITSTREAM_ISBELL										0x3416
#define FID_PS_ISBELL										0x2416
#define FID_DTC_ISBELL										0x1416
#define FID_BITSTREAM_ISADORA										0x3415
#define FID_PS_ISADORA										0x2415
#define FID_DTC_ISADORA										0x1415
#define FID_BITSTREAM_HOGARTH_SCRIPT										0x3414
#define FID_PS_HOGARTH_SCRIPT										0x2414
#define FID_DTC_HOGARTH_SCRIPT										0x1414
#define FID_BITSTREAM_HARLOW										0x3413
#define FID_PS_HARLOW										0x2413
#define FID_DTC_HARLOW										0x1413
#define FID_BITSTREAM_GLASTONBURY										0x3412
#define FID_PS_GLASTONBURY										0x2412
#define FID_DTC_GLASTONBURY										0x1412
#define FID_BITSTREAM_GILLIES_GOTHIC										0x3411
#define FID_PS_GILLIES_GOTHIC										0x2411
#define FID_DTC_GILLIES_GOTHIC										0x1411
#define FID_BITSTREAM_FREESTYLE_SCRIPT										0x3410
#define FID_PS_FREESTYLE_SCRIPT										0x2410
#define FID_DTC_FREESTYLE_SCRIPT										0x1410
#define FID_BITSTREAM_ENGLISCHE_SCHREIBSCHRIFT										0x340f
#define FID_PS_ENGLISCHE_SCHREIBSCHRIFT										0x240f
#define FID_DTC_ENGLISCHE_SCHREIBSCHRIFT										0x140f
#define FID_BITSTREAM_DEMIAN										0x340e
#define FID_PS_DEMIAN										0x240e
#define FID_DTC_DEMIAN										0x140e
#define FID_BITSTREAM_CANDICE										0x340d
#define FID_PS_CANDICE										0x240d
#define FID_DTC_CANDICE										0x140d
#define FID_BITSTREAM_BRONX										0x340c
#define FID_PS_BRONX										0x240c
#define FID_DTC_BRONX										0x140x
#define FID_BITSTREAM_BRODY										0x340b
#define FID_PS_BRODY										0x240b
#define FID_DTC_BRODY										0x140b
#define FID_BITSTREAM_BIBLE_SCRIPT										0x340a
#define FID_PS_BIBLE_SCRIPT										0x240a
#define FID_DTC_BIBLE_SCRIPT										0x140a
#define FID_BITSTREAM_ARISTON										0x3409
#define FID_PS_ARISTON										0x2409
#define FID_DTC_ARISTON										0x1409
#define FID_BITSTREAM_ANGLIA										0x3408
#define FID_PS_ANGLIA										0x2408
#define FID_DTC_ANGLIA										0x1408
#define FID_BITSTREAM_MISTRAL										0x3407
#define FID_PS_MISTRAL										0x2407
#define FID_DTC_MISTRAL										0x1407
#define FID_BITSTREAM_BALMORAL										0x3406
#define FID_PS_BALMORAL										0x2406
#define FID_DTC_BALMORAL										0x1406
#define FID_BITSTREAM_COMMERCIAL_SCRIPT										0x3405
#define FID_PS_COMMERCIAL_SCRIPT										0x2405
#define FID_DTC_COMMERCIAL_SCRIPT										0x1405
#define FID_BITSTREAM_KAUFMANN										0x3404
#define FID_PS_KAUFMANN										0x2404
#define FID_DTC_KAUFMANN										0x1404
#define FID_BITSTREAM_PARK_AVENUE										0x3403
#define FID_PS_PARK_AVENUE										0x2403
#define FID_DTC_PARK_AVENUE										0x1403
#define FID_BITSTREAM_BRUSH_SCRIPT										0x3402
#define FID_PS_BRUSH_SCRIPT										0x2402
#define FID_DTC_BRUSH_SCRIPT										0x1402
#define FID_BITSTREAM_VIVALDI										0x3401
#define FID_PS_VIVALDI										0x2401
#define FID_DTC_VIVALDI										0x1401
#define FID_BITSTREAM_ZAPF_CHANCERY										0x3400
#define FID_PS_ZAPF_CHANCERY										0x2400
#define FID_DTC_ZAPF_CHANCERY										0x1400
#define FID_BITSTREAM_AVANTE_GARDE_CONDENSED										0x323d
#define FID_PS_AVANTE_GARDE_CONDENSED										0x223d
#define FID_DTC_AVANTE_GARDE_CONDENSED										0x123d
#define FID_BITSTREAM_INSIGNIA										0x323c
#define FID_PS_INSIGNIA										0x223c
#define FID_DTC_INSIGNIA										0x123c
#define FID_BITSTREAM_INDUSTRIA										0x323b
#define FID_PS_INDUSTRIA										0x223b
#define FID_DTC_INDUSTRIA										0x123b
#define FID_BITSTREAM_DORIC_BOLD										0x323a
#define FID_PS_DORIC_BOLD										0x223a
#define FID_DTC_DORIC_BOLD										0x123a
#define FID_BITSTREAM_AKZINDENZ_GROTESK										0x3239
#define FID_PS_AKZINDENZ_GROTESK										0x2239
#define FID_DTC_AKZINDENZ_GROTESK										0x1239
#define FID_BITSTREAM_GROTESK										0x3238
#define FID_PS_GROTESK										0x2238
#define FID_DTC_GROTESK										0x1238
#define FID_BITSTREAM_TEMPO										0x3237
#define FID_PS_TEMPO										0x2237
#define FID_DTC_TEMPO										0x1237
#define FID_BITSTREAM_SYNTAX										0x3236
#define FID_PS_SYNTAX										0x2236
#define FID_DTC_SYNTAX										0x1236
#define FID_BITSTREAM_STONE_SANS										0x3235
#define FID_PS_STONE_SANS										0x2235
#define FID_DTC_STONE_SANS										0x1235
#define FID_BITSTREAM_SERIF_GOTHIC										0x3234
#define FID_PS_SERIF_GOTHIC										0x2234
#define FID_DTC_SERIF_GOTHIC										0x1234
#define FID_BITSTREAM_PRIMUS_ANTIQUA										0x3233
#define FID_PS_PRIMUS_ANTIQUA										0x2233
#define FID_DTC_PRIMUS_ANTIQUA										0x1233
#define FID_BITSTREAM_PRIMUS										0x3232
#define FID_PS_PRIMUS										0x2232
#define FID_DTC_PRIMUS										0x1232
#define FID_BITSTREAM_PRAXIS										0x3231
#define FID_PS_PRAXIS										0x2231
#define FID_DTC_PRAXIS										0x1231
#define FID_BITSTREAM_PANACHE										0x3230
#define FID_PS_PANACHE										0x2230
#define FID_DTC_PANACHE										0x1230
#define FID_BITSTREAM_OCR_B										0x322f
#define FID_PS_OCR_B										0x222f
#define FID_DTC_OCR_B										0x122f
#define FID_BITSTREAM_OCR_A										0x322e
#define FID_PS_OCR_A										0x222e
#define FID_DTC_OCR_A										0x122e
#define FID_BITSTREAM_NEWTEXT										0x322d
#define FID_PS_NEWTEXT										0x222d
#define FID_DTC_NEWTEXT										0x122d
#define FID_BITSTREAM_NEWS_GOTHIC										0x322c
#define FID_PS_NEWS_GOTHIC										0x222c
#define FID_DTC_NEWS_GOTHIC										0x122c
#define FID_BITSTREAM_NEUZEIT_GROTESK										0x322b
#define FID_PS_NEUZEIT_GROTESK										0x222b
#define FID_DTC_NEUZEIT_GROTESK										0x122b
#define FID_BITSTREAM_MIXAGE										0x322a
#define FID_PS_MIXAGE										0x222a
#define FID_DTC_MIXAGE										0x122a
#define FID_BITSTREAM_MAXIMA										0x3229
#define FID_PS_MAXIMA										0x2229
#define FID_DTC_MAXIMA										0x1229
#define FID_BITSTREAM_LUCIDA_SANS										0x3228
#define FID_PS_LUCIDA_SANS										0x2228
#define FID_DTC_LUCIDA_SANS										0x1228
#define FID_BITSTREAM_LITERA										0x3227
#define FID_PS_LITERA										0x2227
#define FID_DTC_LITERA										0x1227
#define FID_BITSTREAM_KABEL										0x3226
#define FID_PS_KABEL										0x2226
#define FID_DTC_KABEL										0x1226
#define FID_BITSTREAM_HOLSATIA										0x3225
#define FID_PS_HOLSATIA										0x2225
#define FID_DTC_HOLSATIA										0x1225
#define FID_BITSTREAM_HELVETICA_INSERAT										0x3224
#define FID_PS_HELVETICA_INSERAT										0x2224
#define FID_DTC_HELVETICA_INSERAT										0x1224
#define FID_BITSTREAM_NEUE_HELVETICA										0x3223
#define FID_PS_NEUE_HELVETICA										0x2223
#define FID_DTC_NEUE_HELVETICA										0x1223
#define FID_BITSTREAM_HELVETICA										0x3222
#define FID_PS_HELVETICA										0x2222
#define FID_DTC_HELVETICA										0x1222
#define FID_BITSTREAM_HAAS_UNICA										0x3221
#define FID_PS_HAAS_UNICA										0x2221
#define FID_DTC_HAAS_UNICA										0x1221
#define FID_BITSTREAM_GOUDY_SANS										0x3220
#define FID_PS_GOUDY_SANS										0x2220
#define FID_DTC_GOUDY_SANS										0x1220
#define FID_BITSTREAM_GOTHIC										0x321f
#define FID_PS_GOTHIC										0x221f
#define FID_DTC_GOTHIC										0x121f
#define FID_BITSTREAM_GILL_SANS										0x321e
#define FID_PS_GILL_SANS										0x221e
#define FID_DTC_GILL_SANS										0x121e
#define FID_BITSTREAM_GILL										0x321d
#define FID_PS_GILL										0x221d
#define FID_DTC_GILL										0x121d
#define FID_BITSTREAM_FUTURA										0x321c
#define FID_PS_FUTURA										0x221c
#define FID_DTC_FUTURA										0x121c
#define FID_BITSTREAM_FOLIO										0x321b
#define FID_PS_FOLIO										0x221b
#define FID_DTC_FOLIO										0x121b
#define FID_BITSTREAM_FLYER										0x321a
#define FID_PS_FLYER										0x221a
#define FID_DTC_FLYER										0x121a
#define FID_BITSTREAM_FETTE_MIDSCHRIFT										0x3219
#define FID_PS_FETTE_MIDSCHRIFT										0x2219
#define FID_DTC_FETTE_MIDSCHRIFT										0x1219
#define FID_BITSTREAM_FETTE_ENGSCHRIFT										0x3218
#define FID_PS_FETTE_ENGSCHRIFT										0x2218
#define FID_DTC_FETTE_ENGSCHRIFT										0x1218
#define FID_BITSTREAM_ERAS										0x3217
#define FID_PS_ERAS										0x2217
#define FID_DTC_ERAS										0x1217
#define FID_BITSTREAM_DIGI_GROTESK										0x3216
#define FID_PS_DIGI_GROTESK										0x2216
#define FID_DTC_DIGI_GROTESK										0x1216
#define FID_BITSTREAM_CORINTHIAN										0x3215
#define FID_PS_CORINTHIAN										0x2215
#define FID_DTC_CORINTHIAN										0x1215
#define FID_BITSTREAM_COMPACTA										0x3214
#define FID_PS_COMPACTA										0x2214
#define FID_DTC_COMPACTA										0x1214
#define FID_BITSTREAM_CLEARFACE_GOTHIC										0x3213
#define FID_PS_CLEARFACE_GOTHIC										0x2213
#define FID_DTC_CLEARFACE_GOTHIC										0x1213
#define FID_BITSTREAM_OPTIMA										0x3212
#define FID_PS_OPTIMA										0x2212
#define FID_DTC_OPTIMA										0x1212
#define FID_BITSTREAM_CHELMSFORD										0x3211
#define FID_PS_CHELMSFORD										0x2211
#define FID_DTC_CHELMSFORD										0x1211
#define FID_BITSTREAM_CASTLE										0x3210
#define FID_PS_CASTLE										0x2210
#define FID_DTC_CASTLE										0x1210
#define FID_BITSTREAM_BRITANNIC										0x320f
#define FID_PS_BRITANNIC										0x220f
#define FID_DTC_BRITANNIC										0x120f
#define FID_BITSTREAM_BERLINER_GROTESK										0x320e
#define FID_PS_BERLINER_GROTESK										0x220e
#define FID_DTC_BERLINER_GROTESK										0x120e
#define FID_BITSTREAM_BENGUIAT_GOTHIC										0x320d
#define FID_PS_BENGUIAT_GOTHIC										0x220d
#define FID_DTC_BENGUIAT_GOTHIC										0x120d
#define FID_BITSTREAM_AVANTE_GARDE										0x320c
#define FID_PS_AVANTE_GARDE										0x220c
#define FID_DTC_AVANTE_GARDE										0x120c
#define FID_BITSTREAM_ANZEIGEN_GROTESK										0x320b
#define FID_PS_ANZEIGEN_GROTESK										0x220b
#define FID_DTC_ANZEIGEN_GROTESK										0x120b
#define FID_BITSTREAM_ANTIQUE_OLIVE										0x320a
#define FID_PS_ANTIQUE_OLIVE										0x220a
#define FID_DTC_ANTIQUE_OLIVE										0x120a
#define FID_BITSTREAM_ALTERNATE_GOTHIC										0x3209
#define FID_PS_ALTERNATE_GOTHIC										0x2209
#define FID_DTC_ALTERNATE_GOTHIC										0x1209
#define FID_BITSTREAM_AKZIDENZ_GROTESK_BUCH										0x3208
#define FID_PS_AKZIDENZ_GROTESK_BUCH										0x2208
#define FID_DTC_AKZIDENZ_GROTESK_BUCH										0x1208
#define FID_BITSTREAM_AKZIDENZ_GROTESK										0x3207
#define FID_PS_AKZIDENZ_GROTESK										0x2207
#define FID_DTC_AKZIDENZ_GROTESK										0x1207
#define FID_BITSTREAM_AVENIR										0x3206
#define FID_PS_AVENIR										0x2206
#define FID_DTC_AVENIR										0x1206
#define FID_BITSTREAM_UNIVERS										0x3205
#define FID_PS_UNIVERS										0x2205
#define FID_DTC_UNIVERS										0x1205
#define FID_BITSTREAM_FRANKLIN_GOTHIC										0x3204
#define FID_PS_FRANKLIN_GOTHIC										0x2204
#define FID_DTC_FRANKLIN_GOTHIC										0x1204
#define FID_BITSTREAM_ANGRO										0x3203
#define FID_PS_ANGRO										0x2203
#define FID_DTC_ANGRO										0x1203
#define FID_BITSTREAM_EUROSTILE										0x3202
#define FID_PS_EUROSTILE										0x2202
#define FID_DTC_EUROSTILE										0x1202
#define FID_BITSTREAM_FRUTIGER										0x3201
#define FID_PS_FRUTIGER										0x2201
#define FID_DTC_FRUTIGER										0x1201
#define FID_BITSTREAM_URW_SANS										0x3200
#define FID_PS_URW_SANS										0x2200
#define FID_DTC_URW_SANS										0x1200
#define FID_BITSTREAM_GALLIARD_ROMAN_ITALIC										0x307e
#define FID_PS_GALLIARD_ROMAN_ITALIC										0x207e
#define FID_DTC_GALLIARD_ROMAN_ITALIC										0x107e
#define FID_BITSTREAM_GRANJON										0x307d
#define FID_PS_GRANJON										0x207d
#define FID_DTC_GRANJON										0x107d
#define FID_BITSTREAM_GARTH_GRAPHIC										0x307c
#define FID_PS_GARTH_GRAPHIC										0x207c
#define FID_DTC_GARTH_GRAPHIC										0x107c
#define FID_BITSTREAM_BAUER_BODONI										0x307b
#define FID_PS_BAUER_BODONI										0x207b
#define FID_DTC_BAUER_BODONI										0x107b
#define FID_BITSTREAM_BELWE										0x307a
#define FID_PS_BELWE										0x207a
#define FID_DTC_BELWE										0x107a
#define FID_BITSTREAM_CHARLEMAGNE										0x3079
#define FID_PS_CHARLEMAGNE										0x2079
#define FID_DTC_CHARLEMAGNE										0x1079
#define FID_BITSTREAM_TRAJAN										0x3078
#define FID_PS_TRAJAN										0x2078
#define FID_DTC_TRAJAN										0x1078
#define FID_BITSTREAM_ADOBE_GARAMOND										0x3077
#define FID_PS_ADOBE_GARAMOND										0x2077
#define FID_DTC_ADOBE_GARAMOND										0x1077
#define FID_BITSTREAM_ZAPF_INTERNATIONAL										0x3076
#define FID_PS_ZAPF_INTERNATIONAL										0x2076
#define FID_DTC_ZAPF_INTERNATIONAL										0x1076
#define FID_BITSTREAM_ZAPF_BOOK										0x3075
#define FID_PS_ZAPF_BOOK										0x2075
#define FID_DTC_ZAPF_BOOK										0x1075
#define FID_BITSTREAM_WORCESTER_ROUND										0x3074
#define FID_PS_WORCESTER_ROUND										0x2074
#define FID_DTC_WORCESTER_ROUND										0x1074
#define FID_BITSTREAM_WINDSOR										0x3073
#define FID_PS_WINDSOR										0x2073
#define FID_DTC_WINDSOR										0x1073
#define FID_BITSTREAM_WEISS										0x3072
#define FID_PS_WEISS										0x2072
#define FID_DTC_WEISS										0x1072
#define FID_BITSTREAM_WEIDEMANN										0x3071
#define FID_PS_WEIDEMANN										0x2071
#define FID_DTC_WEIDEMANN										0x1071
#define FID_BITSTREAM_WALBAUM										0x3070
#define FID_PS_WALBAUM										0x2070
#define FID_DTC_WALBAUM										0x1070
#define FID_BITSTREAM_VOLTA										0x306f
#define FID_PS_VOLTA										0x206f
#define FID_DTC_VOLTA										0x106f
#define FID_BITSTREAM_VENDOME										0x306e
#define FID_PS_VENDOME										0x206e
#define FID_DTC_VENDOME										0x106e
#define FID_BITSTREAM_VELJOVIC										0x306d
#define FID_PS_VELJOVIC										0x206d
#define FID_DTC_VELJOVIC										0x106d
#define FID_BITSTREAM_ADOBE_UTOPIA										0x306c
#define FID_PS_ADOBE_UTOPIA										0x206c
#define FID_DTC_ADOBE_UTOPIA										0x106c
#define FID_BITSTREAM_USHERWOOD										0x306b
#define FID_PS_USHERWOOD										0x206b
#define FID_DTC_USHERWOOD										0x106b
#define FID_BITSTREAM_URW_ANTIQUA										0x306a
#define FID_PS_URW_ANTIQUA										0x206a
#define FID_DTC_URW_ANTIQUA										0x106a
#define FID_BITSTREAM_TIMES_NEW_ROMAN										0x3069
#define FID_PS_TIMES_NEW_ROMAN										0x2069
#define FID_DTC_TIMES_NEW_ROMAN										0x1069
#define FID_BITSTREAM_TIMELESS										0x3068
#define FID_PS_TIMELESS										0x2068
#define FID_DTC_TIMELESS										0x1068
#define FID_BITSTREAM_TIFFANY										0x3067
#define FID_PS_TIFFANY										0x2067
#define FID_DTC_TIFFANY										0x1067
#define FID_BITSTREAM_TIEPOLO										0x3066
#define FID_PS_TIEPOLO										0x2066
#define FID_DTC_TIEPOLO										0x1066
#define FID_BITSTREAM_SWIFT										0x3065
#define FID_PS_SWIFT										0x2065
#define FID_DTC_SWIFT										0x1065
#define FID_BITSTREAM_STYMIE										0x3064
#define FID_PS_STYMIE										0x2064
#define FID_DTC_STYMIE										0x1064
#define FID_BITSTREAM_STRATFORD										0x3063
#define FID_PS_STRATFORD										0x2063
#define FID_DTC_STRATFORD										0x1063
#define FID_BITSTREAM_STONE_SERIF										0x3062
#define FID_PS_STONE_SERIF										0x2062
#define FID_DTC_STONE_SERIF										0x1062
#define FID_BITSTREAM_STONE_INFORMAL										0x3061
#define FID_PS_STONE_INFORMAL										0x2061
#define FID_DTC_STONE_INFORMAL										0x1061
#define FID_BITSTREAM_STEMPEL_SCHNEIDLER										0x3060
#define FID_PS_STEMPEL_SCHNEIDLER										0x2060
#define FID_DTC_STEMPEL_SCHNEIDLER										0x1060
#define FID_BITSTREAM_SOUVENIR										0x305f
#define FID_PS_SOUVENIR										0x205f
#define FID_DTC_SOUVENIR										0x105f
#define FID_BITSTREAM_SLIMBACH										0x305e
#define FID_PS_SLIMBACH										0x205e
#define FID_DTC_SLIMBACH										0x105e
#define FID_BITSTREAM_SERIFA										0x305d
#define FID_PS_SERIFA										0x205d
#define FID_DTC_SERIFA										0x105d
#define FID_BITSTREAM_SABON_ANTIQUA										0x305c
#define FID_PS_SABON_ANTIQUA										0x205c
#define FID_DTC_SABON_ANTIQUA										0x105c
#define FID_BITSTREAM_SABON										0x305b
#define FID_PS_SABON										0x205b
#define FID_DTC_SABON										0x105b
#define FID_BITSTREAM_ROMANA										0x305a
#define FID_PS_ROMANA										0x205a
#define FID_DTC_ROMANA										0x105a
#define FID_BITSTREAM_ROCKWELL										0x3059
#define FID_PS_ROCKWELL										0x2059
#define FID_DTC_ROCKWELL										0x1059
#define FID_BITSTREAM_RENAULT										0x3058
#define FID_PS_RENAULT										0x2058
#define FID_DTC_RENAULT										0x1058
#define FID_BITSTREAM_RALEIGH										0x3057
#define FID_PS_RALEIGH										0x2057
#define FID_DTC_RALEIGH										0x1057
#define FID_BITSTREAM_QUORUM										0x3056
#define FID_PS_QUORUM										0x2056
#define FID_DTC_QUORUM										0x1056
#define FID_BITSTREAM_PROTEUS										0x3055
#define FID_PS_PROTEUS										0x2055
#define FID_DTC_PROTEUS										0x1055
#define FID_BITSTREAM_PLANTIN										0x3054
#define FID_PS_PLANTIN										0x2054
#define FID_DTC_PLANTIN										0x1054
#define FID_BITSTREAM_PERPETUA										0x3053
#define FID_PS_PERPETUA										0x2053
#define FID_DTC_PERPETUA										0x1053
#define FID_BITSTREAM_PACELLA										0x3052
#define FID_PS_PACELLA										0x2052
#define FID_DTC_PACELLA										0x1052
#define FID_BITSTREAM_NOVARESE										0x3051
#define FID_PS_NOVARESE										0x2051
#define FID_DTC_NOVARESE										0x1051
#define FID_BITSTREAM_NIMROD										0x3050
#define FID_PS_NIMROD										0x2050
#define FID_DTC_NIMROD										0x1050
#define FID_BITSTREAM_NIKIS										0x304f
#define FID_PS_NIKIS										0x204f
#define FID_DTC_NIKIS										0x104f
#define FID_BITSTREAM_NAPOLEAN										0x304e
#define FID_PS_NAPOLEAN										0x204e
#define FID_DTC_NAPOLEAN										0x104e
#define FID_BITSTREAM_MODERN_NO_216										0x304d
#define FID_PS_MODERN_NO_216										0x204d
#define FID_DTC_MODERN_NO_216										0x104d
#define FID_BITSTREAM_MODERN										0x304c
#define FID_PS_MODERN										0x204c
#define FID_DTC_MODERN										0x104c
#define FID_BITSTREAM_MINISTER										0x304b
#define FID_PS_MINISTER										0x204b
#define FID_DTC_MINISTER										0x104b
#define FID_BITSTREAM_MESSIDOR										0x304a
#define FID_PS_MESSIDOR										0x204a
#define FID_DTC_MESSIDOR										0x104a
#define FID_BITSTREAM_MERIDIEN										0x3049
#define FID_PS_MERIDIEN										0x2049
#define FID_DTC_MERIDIEN										0x1049
#define FID_BITSTREAM_MEMPHIS										0x3048
#define FID_PS_MEMPHIS										0x2048
#define FID_DTC_MEMPHIS										0x1048
#define FID_BITSTREAM_MELIOR										0x3047
#define FID_PS_MELIOR										0x2047
#define FID_DTC_MELIOR										0x1047
#define FID_BITSTREAM_MARCONI										0x3046
#define FID_PS_MARCONI										0x2046
#define FID_DTC_MARCONI										0x1046
#define FID_BITSTREAM_MAGNUS										0x3045
#define FID_PS_MAGNUS										0x2045
#define FID_DTC_MAGNUS										0x1045
#define FID_BITSTREAM_MAGNA										0x3044
#define FID_PS_MAGNA										0x2044
#define FID_DTC_MAGNA										0x1044
#define FID_BITSTREAM_MADISON										0x3043
#define FID_PS_MADISON										0x2043
#define FID_DTC_MADISON										0x1043
#define FID_BITSTREAM_LUCIDA										0x3042
#define FID_PS_LUCIDA										0x2042
#define FID_DTC_LUCIDA										0x1042
#define FID_BITSTREAM_LUBALIN_GRAPH										0x3041
#define FID_PS_LUBALIN_GRAPH										0x2041
#define FID_DTC_LUBALIN_GRAPH										0x1041
#define FID_BITSTREAM_LIFE										0x3040
#define FID_PS_LIFE										0x2040
#define FID_DTC_LIFE										0x1040
#define FID_BITSTREAM_LEAWOOD										0x303f
#define FID_PS_LEAWOOD										0x203f
#define FID_DTC_LEAWOOD										0x103f
#define FID_BITSTREAM_KORINNA										0x303e
#define FID_PS_KORINNA										0x203e
#define FID_DTC_KORINNA										0x103e
#define FID_BITSTREAM_JENSON_OLD_STYLE										0x303d
#define FID_PS_JENSON_OLD_STYLE										0x203d
#define FID_DTC_JENSON_OLD_STYLE										0x103d
#define FID_BITSTREAM_JANSON										0x303c
#define FID_PS_JANSON										0x203c
#define FID_DTC_JANSON										0x103c
#define FID_BITSTREAM_JAMILLE										0x303b
#define FID_PS_JAMILLE										0x203b
#define FID_DTC_JAMILLE										0x103b
#define FID_BITSTREAM_ITALIA										0x303a
#define FID_PS_ITALIA										0x203a
#define FID_DTC_ITALIA										0x103a
#define FID_BITSTREAM_IMPRESSUM										0x3039
#define FID_PS_IMPRESSUM										0x2039
#define FID_DTC_IMPRESSUM										0x1039
#define FID_BITSTREAM_HOLLANDER										0x3038
#define FID_PS_HOLLANDER										0x2038
#define FID_DTC_HOLLANDER										0x1038
#define FID_BITSTREAM_HIROSHIGE										0x3037
#define FID_PS_HIROSHIGE										0x2037
#define FID_DTC_HIROSHIGE										0x1037
#define FID_BITSTREAM_HAWTHORN										0x3036
#define FID_PS_HAWTHORN										0x2036
#define FID_DTC_HAWTHORN										0x1036
#define FID_BITSTREAM_GOUDY										0x3035
#define FID_PS_GOUDY										0x2035
#define FID_DTC_GOUDY										0x1035
#define FID_BITSTREAM_GAMMA										0x3034
#define FID_PS_GAMMA										0x2034
#define FID_DTC_GAMMA										0x1034
#define FID_BITSTREAM_GALLIARD										0x3033
#define FID_PS_GALLIARD										0x2033
#define FID_DTC_GALLIARD										0x1033
#define FID_BITSTREAM_FRIZ_QUADRATA										0x3032
#define FID_PS_FRIZ_QUADRATA										0x2032
#define FID_DTC_FRIZ_QUADRATA										0x1032
#define FID_BITSTREAM_FENICE										0x3031
#define FID_PS_FENICE										0x2031
#define FID_DTC_FENICE										0x1031
#define FID_BITSTREAM_EXCELSIOR										0x3030
#define FID_PS_EXCELSIOR										0x2030
#define FID_DTC_EXCELSIOR										0x1030
#define FID_BITSTREAM_ESPRIT										0x302f
#define FID_PS_ESPRIT										0x202f
#define FID_DTC_ESPRIT										0x102f
#define FID_BITSTREAM_ELAN										0x302e
#define FID_PS_ELAN										0x202e
#define FID_DTC_ELAN										0x102e
#define FID_BITSTREAM_EGYPTIENNE										0x302d
#define FID_PS_EGYPTIENNE										0x202d
#define FID_DTC_EGYPTIENNE										0x102d
#define FID_BITSTREAM_EGIZIO										0x302c
#define FID_PS_EGIZIO										0x202c
#define FID_DTC_EGIZIO										0x102c
#define FID_BITSTREAM_EDWARDIAN										0x302b
#define FID_PS_EDWARDIAN										0x202b
#define FID_DTC_EDWARDIAN										0x102b
#define FID_BITSTREAM_EDISON										0x302a
#define FID_PS_EDISON										0x202a
#define FID_DTC_EDISON										0x102a
#define FID_BITSTREAM_DIGI_ANTIQUA										0x3029
#define FID_PS_DIGI_ANTIQUA										0x2029
#define FID_DTC_DIGI_ANTIQUA										0x1029
#define FID_BITSTREAM_DEMOS										0x3028
#define FID_PS_DEMOS										0x2028
#define FID_DTC_DEMOS										0x1028
#define FID_BITSTREAM_CUSHING										0x3027
#define FID_PS_CUSHING										0x2027
#define FID_DTC_CUSHING										0x1027
#define FID_BITSTREAM_CORONA										0x3026
#define FID_PS_CORONA										0x2026
#define FID_DTC_CORONA										0x1026
#define FID_BITSTREAM_CONGRESS										0x3025
#define FID_PS_CONGRESS										0x2025
#define FID_DTC_CONGRESS										0x1025
#define FID_BITSTREAM_CONCORDE_NOVA										0x3024
#define FID_PS_CONCORDE_NOVA										0x2024
#define FID_DTC_CONCORDE_NOVA										0x1024
#define FID_BITSTREAM_CONCORDE										0x3023
#define FID_PS_CONCORDE										0x2023
#define FID_DTC_CONCORDE										0x1023
#define FID_BITSTREAM_CLEARFACE										0x3022
#define FID_PS_CLEARFACE										0x2022
#define FID_DTC_CLEARFACE										0x1022
#define FID_BITSTREAM_CLARENDON										0x3021
#define FID_PS_CLARENDON										0x2021
#define FID_DTC_CLARENDON										0x1021
#define FID_BITSTREAM_CHELTENHAM										0x3020
#define FID_PS_CHELTENHAM										0x2020
#define FID_DTC_CHELTENHAM										0x1020
#define FID_BITSTREAM_CENTURY_OLD_STYLE										0x301f
#define FID_PS_CENTURY_OLD_STYLE										0x201f
#define FID_DTC_CENTURY_OLD_STYLE										0x101f
#define FID_BITSTREAM_CENTURY										0x301e
#define FID_PS_CENTURY										0x201e
#define FID_DTC_CENTURY										0x101e
#define FID_BITSTREAM_CENTENNIAL										0x301d
#define FID_PS_CENTENNIAL										0x201d
#define FID_DTC_CENTENNIAL										0x101d
#define FID_BITSTREAM_CAXTON										0x301c
#define FID_PS_CAXTON										0x201c
#define FID_DTC_CAXTON										0x101c
#define FID_BITSTREAM_ADOBE_CASLON										0x301b
#define FID_PS_ADOBE_CASLON										0x201b
#define FID_DTC_ADOBE_CASLON										0x101b
#define FID_BITSTREAM_CASLON										0x301a
#define FID_PS_CASLON										0x201a
#define FID_DTC_CASLON										0x101a
#define FID_BITSTREAM_CANDIDA										0x3019
#define FID_PS_CANDIDA										0x2019
#define FID_DTC_CANDIDA										0x1019
#define FID_BITSTREAM_BOOKMAN										0x3018
#define FID_PS_BOOKMAN										0x2018
#define FID_DTC_BOOKMAN										0x1018
#define FID_BITSTREAM_BASKERVILLE_HANDCUT										0x3017
#define FID_PS_BASKERVILLE_HANDCUT										0x2017
#define FID_DTC_BASKERVILLE_HANDCUT										0x1017
#define FID_BITSTREAM_BASKERVILLE										0x3016
#define FID_PS_BASKERVILLE										0x2016
#define FID_DTC_BASKERVILLE										0x1016
#define FID_BITSTREAM_BASILIA										0x3015
#define FID_PS_BASILIA										0x2015
#define FID_DTC_BASILIA										0x1015
#define FID_BITSTREAM_BARBEDOR										0x3014
#define FID_PS_BARBEDOR										0x2014
#define FID_DTC_BARBEDOR										0x1014
#define FID_BITSTREAM_AUREALIA										0x3013
#define FID_PS_AUREALIA										0x2013
#define FID_DTC_AUREALIA										0x1013
#define FID_BITSTREAM_NEW_ASTER										0x3012
#define FID_PS_NEW_ASTER										0x2012
#define FID_DTC_NEW_ASTER										0x1012
#define FID_BITSTREAM_ASTER										0x3011
#define FID_PS_ASTER										0x2011
#define FID_DTC_ASTER										0x1011
#define FID_BITSTREAM_AMERICANA										0x3010
#define FID_PS_AMERICANA										0x2010
#define FID_DTC_AMERICANA										0x1010
#define FID_BITSTREAM_AACHEN										0x300f
#define FID_PS_AACHEN										0x200f
#define FID_DTC_AACHEN										0x100f
#define FID_BITSTREAM_NICOLAS_COCHIN										0x300e
#define FID_PS_NICOLAS_COCHIN										0x200e
#define FID_DTC_NICOLAS_COCHIN										0x100e
#define FID_BITSTREAM_COCHIN										0x300d
#define FID_PS_COCHIN										0x200d
#define FID_DTC_COCHIN										0x100d
#define FID_BITSTREAM_ALBERTUS										0x300c
#define FID_PS_ALBERTUS										0x200c
#define FID_DTC_ALBERTUS										0x100c
#define FID_BITSTREAM_ACCOLADE										0x300b
#define FID_PS_ACCOLADE										0x200b
#define FID_DTC_ACCOLADE										0x100b
#define FID_BITSTREAM_PALATINO										0x300a
#define FID_PS_PALATINO										0x200a
#define FID_DTC_PALATINO										0x100a
#define FID_BITSTREAM_GOUDY_OLD_STYLE										0x3009
#define FID_PS_GOUDY_OLD_STYLE										0x2009
#define FID_DTC_GOUDY_OLD_STYLE										0x1009
#define FID_BITSTREAM_BERKELEY_OLD_STYLE										0x3008
#define FID_PS_BERKELEY_OLD_STYLE										0x2008
#define FID_DTC_BERKELEY_OLD_STYLE										0x1008
#define FID_BITSTREAM_ARSIS										0x3007
#define FID_PS_ARSIS										0x2007
#define FID_DTC_ARSIS										0x1007
#define FID_BITSTREAM_UNIVERSITY_ROMAN										0x3006
#define FID_PS_UNIVERSITY_ROMAN										0x2006
#define FID_DTC_UNIVERSITY_ROMAN										0x1006
#define FID_BITSTREAM_BEMBO										0x3005
#define FID_PS_BEMBO										0x2005
#define FID_DTC_BEMBO										0x1005
#define FID_BITSTREAM_GARAMOND										0x3004
#define FID_PS_GARAMOND										0x2004
#define FID_DTC_GARAMOND										0x1004
#define FID_BITSTREAM_GLYPHA										0x3003
#define FID_PS_GLYPHA										0x2003
#define FID_DTC_GLYPHA										0x1003
#define FID_BITSTREAM_BODONI										0x3002
#define FID_PS_BODONI										0x2002
#define FID_DTC_BODONI										0x1002
#define FID_BITSTREAM_CENTURY_SCHOOLBOOK										0x3001
#define FID_PS_CENTURY_SCHOOLBOOK										0x2001
#define FID_DTC_CENTURY_SCHOOLBOOK										0x1001
#define FID_BITSTREAM_URW_ROMAN										0x3000
#define FID_PS_TIMES_ROMAN										0x2000
#define FID_DTC_URW_ROMAN										0x1000
#define FID_WINDOWS										0x0a01
#define FID_BISON										0x0a00
#define FID_LED										0x0600
#define FID_PMSYSTEM										0x0203
#define FID_BERKELEY										0x0202
#define FID_UNIVERSITY										0x0201
#define FID_CHICAGO										0x0200
#define FID_ROMA										0x0001
#define FID_INVALID										0x0000</PRE>
<P>
Fonts are normally referenced by FontID.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
fontID.h</STRONG>
 </P>
</DIV>
<HR>
<A NAME="S_18.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="S_18.htm_IX_FontMaker">
 </A>
<A NAME="S_18.htm_IX_FM_&ldots;  (FontMaker)">
 </A>
<H1 CLASS="refHeading">
FontMaker</H1>
<PRE CLASS="syntax">typedef word FontMaker;
#define FM_PRINTER 				0xf000
#define FM_MICROLOGIC 				0xe000
#define FM_ATECH 				0xd000
#define FM_PUBLIC 				0xc000
#define FM_AGFA 				0x4000
#define FM_BITSTREAM 				0x3000
#define FM_ADOBE 				0x2000
#define FM_NIMBUSQ 				0x1000
#define FM_BITMAP 				0x0000</PRE>
<P>
&nbsp;</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
fontID.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="S_18.htm_IX_FontMap">
 </A>
<A NAME="S_18.htm_IX_FM_&ldots;  (FontMap)">
 </A>
<H1 CLASS="refHeading">
FontMap</H1>
<PRE CLASS="syntax">typedef byte FontMap;
#define FM_DONT_USE				0x00ff
#define FM_EXACT				0x0000</PRE>
<P>
&nbsp;</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
fontID.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="S_18.htm_IX_FontWeight">
 </A>
<A NAME="S_18.htm_IX_FW_&ldots;">
 </A>
<H1 CLASS="refHeading">
FontWeight</H1>
<PRE CLASS="syntax">typedef ByteEnum FontWeight;
#define FW_ULTRA_LIGHT					0
#define FW_EXTRA_LIGHT 					1
#define FW_LIGHT 					2
#define FW_BOOK 					3
#define FW_NORMAL 					4
#define FW_DEMI 					5
#define FW_BOLD 					6
#define FW_EXTRA_BOLD 					7
#define FW_ULTRA_BOLD 					8
#define FW_BLACK 					9</PRE>
<P>
&nbsp;</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
font.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="S_18.htm_IX_FontWidth">
 </A>
<A NAME="S_18.htm_IX_FWI_&ldots;">
 </A>
<H1 CLASS="refHeading">
FontWidth</H1>
<PRE CLASS="syntax">typedef 	ByteEnum FontWidth;
#define FWI_NARROW 					0
#define FWI_CONDENSED 					1
#define FWI_MEDIUM 					2
#define FWI_WIDE 					3
#define FWI_EXPANDED 					4</PRE>
<P>
&nbsp;</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
font.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="S_18.htm_IX_FormatArray">
 </A>
<A NAME="S_18.htm_IX_CLIPBOARD_MAX_FORMATS">
 </A>
<H1 CLASS="refHeading">
FormatArray</H1>
<PRE CLASS="syntax">typedef ClipboardItemFormatInfo FormatArray[CLIPBOARD_MAX_FORMATS];</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_18.htm_IX_FormatError">
 </A>
<H1 CLASS="refHeading">
FormatError</H1>
<PRE CLASS="syntax">typedef ByteEnum FormatError;
#define FMT_DONE												0
#define FMT_READY												1
#define FMT_RUNNING 												2
#define FMT_DRIVE_NOT_READY 												3
#define FMT_ERR_WRITING_BOOT 												4
#define FMT_ERR_WRITING_ROOT_DIR												5
#define FMT_ERR_WRITING_FAT 												6
#define FMT_ABORTED 												7
#define FMT_SET_VOLUME_NAME_ERR 												8
#define FMT_CANNOT_FORMAT_FIXED_DISKS_IN_CUR_RELEASE 												9
#define FMT_BAD_PARTITION_TABLE 												10
#define FMT_ERR_READING_PARTITION_TABLE 												11
#define FMT_ERR_NO_PARTITION_FOUND 												12
#define FMT_ERR_MULTIPLE_PRIMARY_PARTITIONS 												13
#define FMT_ERR_NO_EXTENDED_PARTITION_FOUND 												14
#define FMT_ERR_CANNOT_ALLOC_SECTOR_BUFFER 												15
#define FMT_ERR_DISK_IS_IN_USE 												16
#define FMT_ERR_WRITE_PROTECTED 												17
#define FMT_ERR_DRIVE_CANNOT_SUPPORT_GIVEN_FORMAT 												18
#define FMT_ERR_INVALID_DRIVE_SPECIFIED 												19
#define FMT_ERR_DRIVE_CANNOT_BE_FORMATTED 												20
#define FMT_ERR_DISK_UNAVAILABLE 												21</PRE>
</DIV>
<DIV>
<A NAME="S_18.htm_IX_FormatIDFromManufacturerAndType() macro">
 </A>
<H1 CLASS="refHeading">
FormatIDFromManufacturerAndType</H1>
<PRE CLASS="syntax">ClipboardItemFormatID FormatIDFromManufacturerAndType(man, typ)
        ManufacturerID		man;
        word		typ;</PRE>
<P>
This macro creates a <CODE>
ClipboardItemFormatID</CODE>
 dword value from the given manufacturer ID and format ID.</P>
</DIV>
<DIV>
<A NAME="S_18.htm_IX_FunctionID">
 </A>
<A NAME="S_18.htm_IX_FUNCTION_ID_&ldots;">
 </A>
<H1 CLASS="refHeading">
FunctionID</H1>
<PRE CLASS="syntax">typedef enum /* word */ {
FUNCTION_ID_ABS,
FUNCTION_ID_ACOS,
FUNCTION_ID_ACOSH,
FUNCTION_ID_AND,
FUNCTION_ID_ASIN,
FUNCTION_ID_ASINH,
FUNCTION_ID_ATAN,
FUNCTION_ID_ATAN2,
FUNCTION_ID_ATANH,
FUNCTION_ID_AVG, 
FUNCTION_ID_CHAR,
FUNCTION_ID_CHOOSE,
FUNCTION_ID_CLEAN,
FUNCTION_ID_CODE,
FUNCTION_ID_COLS,
FUNCTION_ID_COS,
FUNCTION_ID_COSH,
FUNCTION_ID_COUNT,
FUNCTION_ID_CTERM,
FUNCTION_ID_DATE,
FUNCTION_ID_DATEVALUE,
FUNCTION_ID_DAY,
FUNCTION_ID_DDB,
FUNCTION_ID_ERR,
FUNCTION_ID_EXACT,
FUNCTION_ID_EXP,
FUNCTION_ID_FACT,
FUNCTION_ID_FALSE,
FUNCTION_ID_FIND,
FUNCTION_ID_FV,
FUNCTION_ID_HLOOKUP,
FUNCTION_ID_HOUR,
FUNCTION_ID_IF,
FUNCTION_ID_INDEX,
FUNCTION_ID_INT,
FUNCTION_ID_IRR,
FUNCTION_ID_ISERR,
FUNCTION_ID_ISNUMBER,
FUNCTION_ID_ISSTRING,
FUNCTION_ID_LEFT,
FUNCTION_ID_LENGTH,
FUNCTION_ID_LN,
FUNCTION_ID_LOG,
FUNCTION_ID_LOWER,
FUNCTION_ID_MAX,
FUNCTION_ID_MID,
FUNCTION_ID_MIN,
FUNCTION_ID_MINUTE,
FUNCTION_ID_MOD,
FUNCTION_ID_MONTH,
FUNCTION_ID_N,
FUNCTION_ID_NA,
FUNCTION_ID_NOW,
FUNCTION_ID_NPV,
FUNCTION_ID_OR,
FUNCTION_ID_PI,
FUNCTION_ID_PMT,
FUNCTION_ID_PRODUCT,
FUNCTION_ID_PROPER,
FUNCTION_ID_PV,
FUNCTION_ID_RANDOM_N,
FUNCTION_ID_RANDOM,
FUNCTION_ID_RATE,
FUNCTION_ID_REPEAT,
FUNCTION_ID_REPLACE,
FUNCTION_ID_RIGHT,
FUNCTION_ID_ROUND,
FUNCTION_ID_ROWS,
FUNCTION_ID_SECOND,
FUNCTION_ID_SIN,
FUNCTION_ID_SINH,
FUNCTION_ID_SLN,
FUNCTION_ID_SQRT,
FUNCTION_ID_STD,
FUNCTION_ID_STDP,
FUNCTION_ID_STRING,
FUNCTION_ID_SUM,
FUNCTION_ID_SYD,
FUNCTION_ID_TAN,
FUNCTION_ID_TANH,
FUNCTION_ID_TERM,
FUNCTION_ID_TIME,
FUNCTION_ID_TIMEVALUE,
FUNCTION_ID_TODAY,
FUNCTION_ID_TRIM,
FUNCTION_ID_TRUE,
FUNCTION_ID_TRUNC,
FUNCTION_ID_UPPER,
FUNCTION_ID_VALUE,
FUNCTION_ID_VAR,
FUNCTION_ID_VARP,
FUNCTION_ID_VLOOKUP,
FUNCTION_ID_WEEKDAY,
FUNCTION_ID_YEAR,
FUNCTION_ID_FILENAME,
FUNCTION_ID_PAGE,
FUNCTION_ID_PAGES,
FUNCTION_ID_FIRST_EXTERNAL_FUNCTION=FUNCTION_ID_FIRST_EXTERNAL_FUNCTION_BASE
} FunctionID;</PRE>
<P>
&nbsp;</P>
</DIV>
<HR>
<A NAME="S_19.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="S_19.htm_IX_GCM_info">
 </A>
<A NAME="S_19.htm_IX_GCMI_&ldots;">
 </A>
<H1 CLASS="refHeading">
GCM_info</H1>
<PRE CLASS="syntax">typedef enum /* word */ {
GCMI_MIN_X,
GCMI_MIN_X_ROUNDED,
GCMI_MIN_Y,
GCMI_MIN_Y_ROUNDED,
GCMI_MAX_X,
GCMI_MAX_X_ROUNDED,
GCMI_MAX_Y,
GCMI_MAX_Y_ROUNDED,
} GCM_info;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_19.htm_IX_GCNDriveChangeNotificationType">
 </A>
<A NAME="S_19.htm_IX_GCNDCNT_&ldots;">
 </A>
<H1 CLASS="refHeading">
GCNDriveChangeNotificationType</H1>
<PRE CLASS="syntax">typedef enum {
GCNDCNT_CREATED,
GCNDCNT_DESTROYED
} GCNDriveChangeNotificationType;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_19.htm_IX_GCNExpressMenuNotificationType">
 </A>
<A NAME="S_19.htm_IX_GCNEMNT_&ldots;">
 </A>
<H1 CLASS="refHeading">
GCNExpressMenuNotificationType</H1>
<PRE CLASS="syntax">typedef enum {
GCNEMNT_CREATED,
GCNEMNT_DESTROYED
} GCNExpressMenuNotificationType;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_19.htm_IX_GCNListBlockHeader">
 </A>
<A NAME="S_19.htm_IX_GCNLBH_&ldots;">
 </A>
<H1 CLASS="refHeading">
GCNListBlockHeader</H1>
<PRE CLASS="syntax">typedef struct {
LMemBlockHeader			GCNLBH_lmemHeader;
ChunkHandle			GCNLBH_listOfLists;
} GCNListBlockHeader;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_19.htm_IX_GCNListElement">
 </A>
<A NAME="S_19.htm_IX_GCNLE_item[]">
 </A>
<H1 CLASS="refHeading">
GCNListElement</H1>
<PRE CLASS="syntax">typedef struct {
optr	GCNLE_item;
} GCNListElement;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_19.htm_IX_GCNListHeader">
 </A>
<A NAME="S_19.htm_IX_GCNLH_&ldots;">
 </A>
<H1 CLASS="refHeading">
GCNListHeader</H1>
<PRE CLASS="syntax">typedef struct {
ChunkArrayHeader				GCNLH_meta;
word				GCNLH_statusEvent;
MemHandle				GCNLH_statusData;
word				GCNLH_statusCount;
/* Start of GCNListOfListElements */
} GCNListHeader;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_19.htm_IX_GCNListOfListsElement">
 </A>
<A NAME="S_19.htm_IX_GCNLOLE_&ldots;">
 </A>
<H1 CLASS="refHeading">
GCNListOfListsElement</H1>
<PRE CLASS="syntax">typedef struct {
GCNListType			GCNLOLE_ID;
ChunkHandle			GCNLOLE_list;
} GCNListOfListsElement;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_19.htm_IX_GCNListOfListsHeader">
 </A>
<A NAME="S_19.htm_IX_GCNLOL_meta">
 </A>
<H1 CLASS="refHeading">
GCNListOfListsHeader</H1>
<PRE CLASS="syntax">typedef struct {
ChunkArrayHeader				GCNLOL_meta;
/* Start of GCNListOfListsElement's */
} GCNListOfListsHeader;
&nbsp;</PRE>
</DIV>
<DIV>
<A NAME="S_19.htm_IX_GCNListParams">
 </A>
<A NAME="S_19.htm_IX_GCNLP_&ldots;">
 </A>
<H1 CLASS="refHeading">
GCNListParams</H1>
<PRE CLASS="syntax">typedef struct {
GCNListType		GCNLP_ID;
optr		GCNLP_optr;
} GCNListParams;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_19.htm_IX_GCNListSendFlags">
 </A>
<A NAME="S_19.htm_IX_GCNLSF_&ldots;">
 </A>
<H1 CLASS="refHeading">
GCNListSendFlags</H1>
<PRE CLASS="syntax">typedef WordFlags GCNListSendFlags;
#define GCNLSF_SET_STATUS										0x8000
#define GCNLSF_IGNORE_IF_STATUS_TRANSITIONING										0x4000</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_19.htm_IX_GCNListType">
 </A>
<A NAME="S_19.htm_IX_GCNLT_&ldots;">
 </A>
<H1 CLASS="refHeading">
GCNListType</H1>
<PRE CLASS="syntax">typedef struct {
word	GCNLT_manuf;
word	GCNLT_type;
} GCNListType;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_19.htm_IX_GCNListTypeFlags">
 </A>
<A NAME="S_19.htm_IX_GCNLTF_&ldots;">
 </A>
<H1 CLASS="refHeading">
GCNListTypeFlags</H1>
<PRE CLASS="syntax">typedef WordFlags GCNListTypeFlags;
#define GCNLTF_SAVE_TO_STATE					0x8000</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_19.htm_IX_GCNShutdownControlType">
 </A>
<A NAME="S_19.htm_IX_GCNSCT_&ldots;">
 </A>
<H1 CLASS="refHeading">
GCNShutdownControlType</H1>
<PRE CLASS="syntax">typedef enum {
GCNSCT_SUSPEND,
GCNSCT_SHUTDOWN,
GCNSCT_UNSUSPEND
} GCNShutdownControlType;</PRE>
<P>
&nbsp;</P>
</DIV>
<HR>
<A NAME="S_1a.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="S_1a.htm_IX_GCNStandardListType">
 </A>
<A NAME="S_1a.htm_IX_GCNSLT_&ldots;">
 </A>
<H1 CLASS="refHeading">
GCNStandardListType</H1>
<PRE CLASS="syntax">typedef enum {
GCNSLT_FILE_SYSTEM,
GCNSLT_APPLICATION,
GCNSLT_DATE_TIME,
GCNSLT_DICTIONARY,
GCNSLT_EXPRESS_MENU,
GCNSLT_SHUTDOWN_CONTROL
} GCNStandardListType;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_1a.htm_IX_GenAppGCNListTypes">
 </A>
<H1 CLASS="refHeading">
GenAppGCNListTypes</H1>
<P>
In Goc, GenAppGCNListTypes values will be maintained other structures by other names. Standard GEOS list types are part of the GeoWorksGenAppGCNListType enumerated type.</P>
</DIV>
<DIV>
<A NAME="S_1a.htm_IX_GeneralEvent">
 </A>
<A NAME="S_1a.htm_IX_GE_&ldots;">
 </A>
<H1 CLASS="refHeading">
GeneralEvent</H1>
<PRE CLASS="syntax">typedef enum {
 GE_NO_EVENT=0, 				/* dummy event (NOP) */
 GE_END_OF_SONG=2, 				/* marks end of song */
 GE_SET_PRIORITY=4, 				/* changes sound priority */
 GE_SET_TEMPO=6, 				/* changes sound tempo */
 GE_SEND_NOTIFICATION=8, 				/* sends encoded message */
 GE_V_SEMAPHORE=10 				/* V's a specified semaphore*/
} GeneralEvent;</PRE>
<P>
These represent some of the miscellaneous events which can make up a music buffer.</P>
</DIV>
<DIV>
<A NAME="S_1a.htm_IX_GenTravelOption">
 </A>
<H1 CLASS="refHeading">
GenTravelOption</H1>
<P>
The <CODE>
GenClass</CODE>
 defines some values meant to be used in the place of a <CODE>
TravelOption</CODE>
 enumerated value. See <CODE>
TravelOption</CODE>
.</P>
</DIV>
<DIV>
<A NAME="S_1a.htm_IX_GeodeAttrs">
 </A>
<A NAME="S_1a.htm_IX_GA_&ldots;  (GeodeAttrs)">
 </A>
<H1 CLASS="refHeading">
GeodeAttrs</H1>
<PRE CLASS="syntax">typedef WordFlags GeodeAttrs;
#define GA_PROCESS 								0x8000
#define GA_LIBRARY 								0x4000
#define GA_DRIVER 								0x2000
#define GA_KEEP_FILE_OPEN 								0x1000
#define GA_SYSTEM 								0x0800
#define GA_MULTI_LAUNCHABLE 								0x0400
#define GA_APPLICATION 								0x0200
#define GA_DRIVER_INITIALIZED								0x0100
#define GA_LIBRARY_INITIALIZED 								0x0080
#define GA_GEODE_INITIALIZED 								0x0040
#define GA_USES_COPROC 								0x0020
#define GA_REQUIRES_COPROC 								0x0010
#define GA_HAS_GENERAL_CONSUMER_MODE								0x0008
#define GA_ENTRY_POINTS_IN_C 								0x0004</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_1a.htm_IX_GeodeDefaultDriverType">
 </A>
<A NAME="S_1a.htm_IX_GDDT_&ldots;">
 </A>
<H1 CLASS="refHeading">
GeodeDefaultDriverType</H1>
<PRE CLASS="syntax">typedef enum {
GDDT_FILE_SYSTEM = 0,					/* File system driver */
GDDT_KEYBOARD = 2,					/* Keyboard driver */
GDDT_MOUSE = 4,					/* Mouse driver */
GDDT_VIDEO = 6,					/* Video driver */
GDDT_MEMORY_VIDEO = 8,					/* Vidmem driver */
GDDT_POWER_MANAGEMENT = 10					/* Power management driver */
GDDT_TASK = 12					/* Task driver */
} GeodeDefaultDriverType;</PRE>
<P>
The default driver type has one value for each default driver type in GEOS. This type is used with <CODE>
<A HREF="../../CRef/Routines/R_34.htm#IX_GeodeGetDefaultDriver()">GeodeGetDefaultDriver()</A></CODE>
 and <CODE>
<A HREF="../../CRef/Routines/R_35.htm#IX_GeodeSetDefaultDriver()">GeodeSetDefaultDriver()</A></CODE>
.</P>
</DIV>
<DIV>
<A NAME="S_1a.htm_IX_GeodeGetInfoType">
 </A>
<H1 CLASS="refHeading">
GeodeGetInfoType</H1>
<P>
See <CODE>
<A HREF="../../CRef/Routines/R_34.htm#IX_GeodeGetInfo()">GeodeGetInfo()</A></CODE>
.</P>
</DIV>
<DIV>
<A NAME="S_1a.htm_IX_GeodeHandle">
 </A>
<H1 CLASS="refHeading">
GeodeHandle</H1>
<PRE CLASS="syntax">typedef Handle GeodeHandle;</PRE>
<P>
A standard handle that contains information about a loaded geode. When a geode has been loaded, it is referred to by its handle.</P>
</DIV>
<DIV>
<A NAME="S_1a.htm_IX_GeodeHeapVars">
 </A>
<A NAME="S_1a.htm_IX_GHV_&ldots;">
 </A>
<H1 CLASS="refHeading">
GeodeHeapVars</H1>
<PRE CLASS="syntax">typedef struct {
 word		GHV_heapSpace;
} GeodeHeapVars;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_1a.htm_IX_GeodeLoadError">
 </A>
<A NAME="S_1a.htm_IX_GLE_&ldots;">
 </A>
<H1 CLASS="refHeading">
GeodeLoadError</H1>
<PRE CLASS="syntax">typedef enum {
GLE_PROTOCOL_IMPORTER_TOO_RECENT,
GLE_PROTOCOL_IMPORTER_TOO_OLD,
GLE_FILE_NOT_FOUND,
GLE_LIBRARY_NOT_FOUND,
GLE_FILE_READ_ERROR,
GLE_NOT_GEOS_FILE,
GLE_NOT_GEOS_EXECUTABLE_FILE,
GLE_ATTRIBUTE_MISMATCH,
GLE_MEMORY_ALLOCATION_ERROR,
GLE_NOT_MULTI_LAUNCHABLE,
GLE_LIBRARY_PROTOCOL_ERROR,
GLE_LIBRARY_LOAD_ERROR,
GLE_DRIVER_INIT_ERROR,
GLE_LIBRARY_INIT_ERROR,
GLE_DISK_TOO_FULL,
GLE_FIELD_DETACHING,
} GeodeLoadError;</PRE>
<P>
These errors may be returned by routines that load geodes, including <CODE>
<A HREF="../../CRef/Routines/R_9e.htm#IX_UserLoadApplication()">UserLoadApplication()</A></CODE>
, <CODE>
<A HREF="../../CRef/Routines/R_35.htm#IX_GeodeUseLibrary()">GeodeUseLibrary()</A></CODE>
, <CODE>
<A HREF="../../CRef/Routines/R_35.htm#IX_GeodeUseDriver()">GeodeUseDriver()</A></CODE>
, and <CODE>
<A HREF="../../CRef/Routines/R_34.htm#IX_GeodeLoad()">GeodeLoad()</A></CODE>
.</P>
</DIV>
<HR>
<A NAME="S_1b.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="S_1b.htm_IX_GeodeToken">
 </A>
<A NAME="S_1b.htm_IX_GT_&ldots;">
 </A>
<H1 CLASS="refHeading">
GeodeToken</H1>
<PRE CLASS="syntax">typedef struct {
TokenChars			GT_chars;
ManufacturerID			GT_manufID;
} GeodeToken;</PRE>
<P>
Defines a token identifier. The <CODE>
GT_chars</CODE>
 field is four characters that identify the token; <CODE>
GT_manufID</CODE>
 is the identifying number of the manufacturer of the item being referenced.</P>
</DIV>
<DIV>
<A NAME="S_1b.htm_IX_GeosFileHeaderFlags">
 </A>
<A NAME="S_1b.htm_IX_GFHF_&ldots;">
 </A>
<H1 CLASS="refHeading">
GeosFileHeaderFlags</H1>
<PRE CLASS="syntax">typedef WordFlags GeosFileHeaderFlags;
#define GFHF_TEMPLATE						0x8000
#define GFHF_SHARED_MULTIPLE						0x4000
#define GFHF_SHARED_SINGLE						0x2000</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
GEOS<A NAME="S_1b.htm_IX_GeosFileType">
 </A>
<A NAME="S_1b.htm_IX_GFT_&ldots;">
 </A>
<H1 CLASS="refHeading">
GeosFileType</H1>
<PRE CLASS="syntax">typedef enum /* word */ {
GFT_NOT_GEOS_FILE,
GFT_EXECUTABLE,
GFT_VM,
GFT_DATA,
GFT_DIRECTORY,
GFT_LINK
} GeosFileType;</PRE>
<P>
 files are divided into several broad categories. You can find out a file's category by getting its FEA_FILE_TYPE extended attribute. This attribute is a member of the <CODE>
GeosFileType</CODE>
 enumerated type. This type has the following values:</P>
<DL>
<DT>
GFT_NOT_GEOS_FILE</DT><DD>
The file is not a GEOS file. This constant is guaranteed to be equal to zero.</DD>
<DT>
GFT_EXECUTABLE</DT><DD>
The file is executable; in other words, it is some kind of geode.</DD>
<DT>
GFT_VM</DT><DD>The file is a VM file.</DD>
<DT>
GFT_DATA</DT><DD>The file is a GEOS byte file (see below).</DD>
<DT>
GFT_DIRECTORY</DT><DD>
The file is a GEOS directory (not yet implemented).</DD>
<DT>
GFT_LINK</DT><DD>The file is a symbolic link (not yet implemented).</DD>
</DIV>
<DIV>
<A NAME="S_1b.htm_IX_GAGCNLT_&ldots;">
 </A>
<A NAME="S_1b.htm_IX_GeoWorksGenAppGCNListType">
 </A>
</DL>
<H1 CLASS="refHeading">
GeoWorksGenAppGCNListType</H1>
<PRE CLASS="syntax">typedef enum /* word */ {
GAGCNLT_SELF_LOAD_OPTIONS = 0x6800,
GAGCNLT_GEN_CONTROL_NOTIFY_STATUS_CHANGE,
GAGCNLT_APP_TARGET_NOTIFY_SELECT_STATE_CHANGE,
GAGCNLT_EDIT_CONTROL_NOTIFY_UNDO_STATE_CHANGE,
GAGCNLT_APP_TARGET_NOTIFY_TEXT_CHAR_ATTR_CHANGE,
GAGCNLT_APP_TARGET_NOTIFY_TEXT_PARA_ATTR_CHANGE,
GAGCNLT_APP_TARGET_NOTIFY_TEXT_TYPE_CHANGE,
GAGCNLT_APP_TARGET_NOTIFY_TEXT_SELECTION_CHANGE,
GAGCNLT_APP_TARGET_NOTIFY_TEXT_COUNT_CHANGE,
GAGCNLT_APP_TARGET_NOTIFY_STYLE_TEXT_CHANGE,
GAGCNLT_APP_TARGET_NOTIFY_STYLE_SHEET_TEXT_CHANGE,
GAGCNLT_APP_TARGET_NOTIFY_TEXT_STYLE_CHANGE,
GAGCNLT_APP_TARGET_NOTIFY_FONT_CHANGE,
GAGCNLT_APP_TARGET_NOTIFY_POINT_SIZE_CHANGE,
GAGCNLT_APP_TARGET_NOTIFY_FONT_ATTR_CHANGE,
GAGCNLT_APP_TARGET_NOTIFY_JUSTIFICATION_CHANGE,
GAGCNLT_APP_TARGET_NOTIFY_TEXT_FG_COLOR_CHANGE,
GAGCNLT_APP_TARGET_NOTIFY_TEXT_BG_COLOR_CHANGE,
GAGCNLT_APP_TARGET_NOTIFY_PARA_COLOR_CHANGE,
GAGCNLT_APP_TARGET_NOTIFY_BORDER_COLOR_CHANGE,
GAGCNLT_APP_TARGET_NOTIFY_SEARCH_SPELL_CHANGE,
GAGCNLT_APP_TARGET_NOTIFY_SEARCH_REPLACE_CHANGE,
GAGCNLT_APP_TARGET_NOTIFY_CHART_TYPE_CHANGE,
GAGCNLT_APP_TARGET_NOTIFY_CHART_GROUP_FLAGS,
GAGCNLT_APP_TARGET_NOTIFY_CHART_AXIS_ATTRIBUTES,
GAGCNLT_APP_TARGET_NOTIFY_CHART_MARKER_SHAPE,
GAGCNLT_APP_TARGET_NOTIFY_GROBJ_CURRENT_TOOL_CHANGE,
GAGCNLT_APP_TARGET_NOTIFY_GROBJ_BODY_SELECTION_STATE_CHANGE,
GAGCNLT_APP_TARGET_NOTIFY_GROBJ_AREA_ATTR_CHANGE,
GAGCNLT_APP_TARGET_NOTIFY_GROBJ_LINE_ATTR_CHANGE,
GAGCNLT_APP_TARGET_NOTIFY_GROBJ_TEXT_ATTR_CHANGE,
GAGCNLT_APP_TARGET_NOTIFY_STYLE_GROBJ_CHANGE,
GAGCNLT_APP_TARGET_NOTIFY_STYLE_SHEET_GROBJ_CHANGE,
GAGCNLT_APP_TARGET_NOTIFY_GROBJ_BODY_INSTRUCTION_FLAGS_CHANGE,
GAGCNLT_APP_TARGET_NOTIFY_GROBJ_GRADIENT_ATTR_CHANGE,
GAGCNLT_APP_TARGET_NOTIFY_RULER_TYPE_CHANGE,
GAGCNLT_APP_TARGET_NOTIFY_RULER_GRID_CHANGE,
GAGCNLT_TEXT_RULER_OBJECTS,
GAGCNLT_APP_TARGET_NOTIFY_BITMAP_CURRENT_TOOL_CHANGE,
GAGCNLT_APP_TARGET_NOTIFY_BITMAP_CURRENT_FORMAT_CHANGE,
GAGCNLT_APP_TARGET_NOTIFY_FLAT_FILE_FIELD_PROPERTIES_STATUS_CHANGE,
GAGCNLT_APP_TARGET_NOTIFY_FLAT_FILE_FIELD_LIST_CHANGE,
GAGCNLT_APP_TARGET_NOTIFY_FLAT_FILE_RCP_STATUS_CHANGE,
GAGCNLT_APP_TARGET_NOTIFY_FLAT_FILE_FIELD_APPEARANCE_CHANGE,
GAGCNLT_APP_TARGET_NOTIFY_FLAT_FILE_DUMMY_CHANGE_2,
GAGCNLT_APP_TARGET_NOTIFY_FLAT_FILE_DUMMY_CHANGE_3,
GAGCNLT_APP_NOTIFY_DOC_SIZE_CHANGE,
GAGCNLT_APP_NOTIFY_PAPER_SIZE_CHANGE,
GAGCNLT_APP_TARGET_NOTIFY_VIEW_STATE_CHANGE,
GAGCNLT_CONTROLLED_GEN_VIEW_OBJECTS,
GAGCNLT_APP_TARGET_NOTIFY_INK_STATE_CHANGE,
GAGCNLT_CONTROLLED_INK_OBJECTS,
GAGCNLT_APP_TARGET_NOTIFY_PAGE_STATE_CHANGE,
GAGCNLT_APP_TARGET_NOTIFY_DOCUMENT_CHANGE,
GAGCNLT_APP_TARGET_NOTIFY_DISPLAY_CHANGE,
GAGCNLT_APP_TARGET_NOTIFY_DISPLAY_LIST_CHANGE,
GAGCNLT_APP_TARGET_NOTIFY_SPLINE_MARKER_SHAPE,
GAGCNLT_APP_TARGET_NOTIFY_SPLINE_POINT,
GAGCNLT_APP_TARGET_NOTIFY_SPLINE_POLYLINE,
GAGCNLT_APP_TARGET_NOTIFY_SPLINE_SMOOTHNESS,
GAGCNLT_APP_TARGET_NOTIFY_SPLINE_OPEN_CLOSE_CHANGE,
GAGCNLT_APP_TARGET_NOTIFY_SPREADSHEET_ACTIVE_CELL_CHANGE,
GAGCNLT_APP_TARGET_NOTIFY_SPREADSHEET_EDIT_BAR_CHANGE,
GAGCNLT_APP_TARGET_NOTIFY_SPREADSHEET_SELECTION_CHANGE,
GAGCNLT_APP_TARGET_NOTIFY_SPREADSHEET_CELL_WIDTH_HEIGHT_CHANGE,
GAGCNLT_APP_TARGET_NOTIFY_SPREADSHEET_DOC_ATTR_CHANGE,
GAGCNLT_APP_TARGET_NOTIFY_SPREADSHEET_CELL_ATTR_CHANGE,
GAGCNLT_APP_TARGET_NOTIFY_SPREADSHEET_CELL_NOTES_CHANGE,
GAGCNLT_APP_TARGET_NOTIFY_SPREADSHEET_DATA_RANGE_CHANGE,
GAGCNLT_APP_TARGET_NOTIFY_TEXT_NAME_CHANGE,
GAGCNLT_FLOAT_FORMAT_CHANGE,
GAGCNLT_DISPLAY_OBJECTS_WITH_RULERS,
GAGCNLT_APP_TARGET_NOTIFY_APP_CHANGE,
GAGCNLT_APP_TARGET_NOTIFY_LIBRARY_CHANGE,
GAGCNLT_WINDOWS,
GAGCNLT_STARTUP_LOAD_OPTIONS
} GeoWorksGenAppGCNListType;</PRE>
<P>
&nbsp;</P>
</DIV>
<HR>
<A NAME="S_1c.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="S_1c.htm_IX_GMID_&ldots;">
 </A>
<A NAME="S_1c.htm_IX_GeoworksMediumID">
 </A>
<H1 CLASS="refHeading">
GeoworksMediumID</H1>
<PRE CLASS="syntax">typedef enum {
            GMID_INVALID = 0x0,
            GMID_SERIAL_CABLE, 				/* unit is SerialPortNum */
            GMID_INFRARED, 				/* unit is SerialPortNum */
            GMID_DATA_MODEM, 				/* unit is SerialPortNum */
            GMID_FAX_MODEM, 				/* unit is SerialPortNum */
            GMID_PRINTER, 				/* unit is printer name in mem block */
            GMID_PARALLEL_PORT, 				/* unit is ParallelPortNum */
            GMID_NETWORK, 				/* unit is NetID */
            GMID_LOOPBACK, 				/* no units */
            GMID_SM 				/* Small Message--no units */
} GeoworksMediumID;</PRE>
<P>
These values, together with MANUFACTURER_ID_GEOWORKS, form <CODE>
MediumType</CODE>
 values representing certain standard communications media.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
medium.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="S_1c.htm_IX_GeoWorksMetaGCNListType">
 </A>
<A NAME="S_1c.htm_IX_MGCNLT_&ldots;">
 </A>
<H1 CLASS="refHeading">
GeoWorksMetaGCNListType</H1>
<PRE CLASS="syntax">typedef enum /* word */ {
MGCNLT_ACTIVE_LIST = 0x00,
MGCNLT_APP_STARTUP = 0x02
} GeoWorksMetaGCNListType;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_1c.htm_IX_GeoWorksNotificationType">
 </A>
<A NAME="S_1c.htm_IX_GWNT_&ldots;">
 </A>
<H1 CLASS="refHeading">
GeoWorksNotificationType</H1>
<PRE CLASS="syntax">typedef enum {
GWNT_INK,
GWNT_GEN_CONTROL_NOTIFY_STATUS_CHANGE,
GWNT_SELECT_STATE_CHANGE,
GWNT_UNDO_STATE_CHANGE,
GWNT_STYLE_CHANGE,
GWNT_STYLE_SHEET_CHANGE,
GWNT_TEXT_CHAR_ATTR_CHANGE,
GWNT_TEXT_PARA_ATTR_CHANGE,
GWNT_TEXT_TYPE_CHANGE,
GWNT_TEXT_SELECTION_CHANGE,
GWNT_TEXT_COUNT_CHANGE,
GWNT_TEXT_STYLE_CHANGE,
GWNT_FONT_CHANGE,
GWNT_POINT_SIZE_CHANGE,
GWNT_FONT_ATTR_CHANGE,
GWNT_JUSTIFICATION_CHANGE,
GWNT_TEXT_FG_COLOR_CHANGE,
GWNT_TEXT_BG_COLOR_CHANGE,
GWNT_TEXT_PARA_COLOR_CHANGE,
GWNT_TEXT_BORDER_COLOR_CHANGE,
GWNT_SEARCH_REPLACE_ENABLE_CHANGE,
GWNT_SPELL_ENABLE_CHANGE,
GWNT_CHART_TYPE_CHANGE,
GWNT_CHART_GROUP_FLAGS,
GWNT_CHART_AXIS_ATTRIBUTES,
GWNT_GROBJ_CURRENT_TOOL_CHANGE,
GWNT_GROBJ_BODY_SELECTION_STATE_CHANGE,
GWNT_GROBJ_AREA_ATTR_CHANGE,
GWNT_GROBJ_LINE_ATTR_CHANGE,
GWNT_GROBJ_TEXT_ATTR_CHANGE,
GWNT_GROBJ_BODY_INSTRUCTION_FLAGS_CHANGE,
GWNT_GROBJ_GRADIENT_ATTR_CHANGE,
GWNT_RULER_TYPE_CHANGE,
GWNT_RULER_GRID_CHANGE,
GWNT_RULER_GUIDE_CHANGE,
GWNT_BITMAP_CURRENT_TOOL_CHANGE,
GWNT_BITMAP_CURRENT_FORMAT_CHANGE,
GWNT_FLAT_FILE_FIELD_PROPERTIES_STATUS_CHANGE,
GWNT_FLAT_FILE_FIELD_LIST_CHANGE,
GWNT_FLAT_FILE_RCP_STATUS_CHANGE,
GWNT_FLAT_FIELD_APPEARANCE_CHANGE,
GWNT_FLAT_FILE_DUMMY_CHANGE_2,
GWNT_FLAT_FILE_DUMMY_CHANGE_3,
GWNT_SPOOL_DOC_OR_PAPER_SIZE,
GWNT_VIEW_STATE_CHANGE,
GWNT_INK_HAS_TARGET,
GWNT_PAGE_STATE_CHANGE,
GWNT_DOCUMENT_CHANGE,
GWNT_DISPLAY_CHANGE,
GWNT_DISPLAY_LIST_CHANGE,
GWNT_SPLINE_MARKER_SHAPE,
GWNT_SPLINE_POINT,
GWNT_SPLINE_POLYLINE,
GWNT_SPLINE_SMOOTHNESS,
GWNT_SPLINE_OPEN_CLOSE_CHANGE,
GWNT_UNUSED_1,
GWNT_SPREADSHEET_ACTIVE_CELL_CHANGE,
GWNT_SPREADSHEET_EDIT_BAR_CHANGE,
GWNT_SPREADSHEET_SELECTION_CHANGE,
GWNT_SPREADSHEET_CELL_WIDTH_HEIGHT_CHANGE,
GWNT_SPREADSHEET_DOC_ATTR_CHANGE,
GWNT_SPREADSHEET_CELL_ATTR_CHANGE,
GWNT_SPREADSHEET_CELL_NOTES_CHANGE,
GWNT_SPREADSHEET_DATA_RANGE_CHANGE,
GWNT_FLOAT_FORMAT_CHANGE,
GWNT_MAP_APP_CHANGE,
GWNT_MAP_LIBRARY_CHANGE,
GWNT_TEXT_NAME_CHANGE,
GWNT_CARD_BACK_CHANGE,
GWNT_TEXT_OBJECT_HAS_FOCUS,
GWNT_TEXT_CONTEXT,
GWNT_TEXT_REPLACE_WITH_HWR,
GWNT_HELP_CONTEXT_CHANGE,
GWNT_FLOAT_FORMAT_INIT,
GWNT_HARD_ICON_BAR_FUNCTION,
GWNT_STARTUP_INDEXED_APP,
GWNT_SPOOL_PRINTING_COMPLETE,
GWNT_MODAL_WIN_CHANGE,
GWNT_SPREADSHEET_NAME_CHANGE,
GWNT_DOCUMENT_OPEN_COMPLETE,
GWNT_EMAIL_SCAN_INBOX,
GWNT_FOCUS_WINDOW_KBD_STATUS,
GWNT_TAB_DOUBLE_CLICK, 
GWNT_PAGE_INFO_STATE_CHANGE,
GWNT_CURSOR_POSITION_CHANGE,
GWNT_FAX_NEW_JOB_CREATED,
GWNT_FAX_NEW_JOB_COMPLETED,
GWNT_EMAIL_DATABASE_CHANGE,
GWNT_EMAIL_STATUS_CHANGE,
GWNT_EMAIL_PAGE_PANEL_UPDATE,
GWNT_PCCOM_DISPLAY_CHAR,
GWNT_PCCOM_DISPLAY_STRING,
GWNT_PCCOM_EXIT</PRE>
<PRE CLASS="syntax">} GeoWorksNotificationType;</PRE>
<P>
&nbsp;</P>
</DIV>
<HR>
<A NAME="S_1d.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="S_1d.htm_IX_GeoWorksvisContentGCNListType">
 </A>
<A NAME="S_1d.htm_IX_VCGCNLT_TARGET_NOTIFY_TEXT_PARA_ATTR_CHANGE">
 </A>
<H1 CLASS="refHeading">
GeoWorksVisContentGCNListType</H1>
<PRE CLASS="syntax">typedef enum {
VCGCNLT_TARGET_NOTIFY_TEXT_PARA_ATTR_CHANGE = 0x4a00,
 PADDING_VCGCNLT_INVALID_ITEM_000
} GeoWorksVisContentGCNListType;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_1d.htm_IX_GetMaskType">
 </A>
<A NAME="S_1d.htm_IX_GMT_&ldots;">
 </A>
<H1 CLASS="refHeading">
GetMaskType</H1>
<PRE CLASS="syntax">typedef ByteEnum GetMaskType;
#define GMT_ENUM				0
#define GMT_BUFFER				1</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_1d.htm_IX_GetPalType">
 </A>
<A NAME="S_1d.htm_IX_GPT_&ldots;">
 </A>
<H1 CLASS="refHeading">
GetPalType</H1>
<PRE CLASS="syntax">typedef ByteEnum GetPalType;
#define GPT_ACTIVE				0
#define GPT_CUSTOM				1
#define GPT_DEFAULT				2</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_1d.htm_IX_GFM_info">
 </A>
<H1 CLASS="refHeading">
GFM_info</H1>
<P>
See <CODE>
<A HREF="../../CRef/Routines/R_3f.htm#IX_GrFontMetrics()">GrFontMetrics()</A></CODE>
.</P>
</DIV>
<DIV>
<A NAME="S_1d.htm_IX_GOC_POINT macro">
 </A>
<H1 CLASS="refHeading">
GOC_POINT macro</H1>
<PRE CLASS="syntax">#define GOC_POINT(x,y) GOC_SW(x), GOC_SW(y)</PRE>
<P>
This macro is useful when statically declaring GStrings. A GString is basically an array of bytes; this macro takes two word-length values and breaks them up into four comma-seperated bytes. Thus, they help to make GString commands with variable number of point data appear readable. For example:</P>
<PRE>...
GSDrawPolyline(3),
  GOC_POINT(0,6), GOC_POINT(10,6), GOC_POINT(10,1),
GSFillPolygon(4,ODD_EVEN),
  GOC_POINT(5,1), GOC_POINT(9,0), 
  GOC_POINT(9,5), GOC_POINT(5,6),</PRE>
<PRE>...</PRE>
</DIV>
<DIV>
<A NAME="S_1d.htm_IX_GOC_SW(), GOC_WORD() macros">
 </A>
<H1 CLASS="refHeading">
GOC_SW(), GOC_WORD() macros</H1>
<PRE CLASS="syntax">#define GOC_SW(a)       GOC_WORD(a)
#define GOC_WORD(a)     ((a)&amp;0xff),(((a)&amp;0xff00)&gt;&gt;8)</PRE>
<P>
These macros are useful when you're statically defining a byte array which contains word-length values. Each macro breaks up a word-length value into two bytes, seperated by a comma.</P>
</DIV>
<DIV>
<A NAME="S_1d.htm_IX_GraphicPattern">
 </A>
<A NAME="S_1d.htm_IX_HP_&ldots;  (GraphicPattern structure)">
 </A>
<H1 CLASS="refHeading">
GraphicPattern</H1>
<PRE CLASS="syntax">typedef struct { 
PatternType 		HP_type;
byte 		HP_data;
} GraphicPattern;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_1d.htm_IX_GSControl">
 </A>
<A NAME="S_1d.htm_IX_GSC_&ldots;">
 </A>
<H1 CLASS="refHeading">
GSControl</H1>
<PRE CLASS="syntax">typedef WordFlags GSControl;
#define GSC_PARTIAL 				0x0200
#define GSC_ONE 				0x0100
#define GSC_MISC 				0x0080
#define GSC_LABEL 				0x0040
#define GSC_ESCAPE 				0x0020
#define GSC_NEW_PAGE 				0x0010
#define GSC_XFORM 				0x0008
#define GSC_OUTPUT 				0x0004
#define GSC_ATTR 				0x0002
#define GSC_PATH 				0x0001</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_1d.htm_IX_GSRetType">
 </A>
<A NAME="S_1d.htm_IX_GSRT_&ldots;">
 </A>
<H1 CLASS="refHeading">
GSRetType</H1>
<PRE CLASS="syntax">typedef ByteEnum GSRetType;
#define GSRT_COMPLETE				0
#define GSRT_FORM_FEED				1
#define GSRT_ONE 				2
#define GSRT_ESCAPE 				3
#define GSRT_OUTPUT 				4
#define GSRT_ELEMENT 				5
#define GSRT_FAULT 				0xff</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_1d.htm_IX_GState">
 </A>
<H1 CLASS="refHeading">
GState</H1>
<P>
GStates are always referenced by means of GStateHandles, and are documented there.</P>
</DIV>
<DIV>
<A NAME="S_1d.htm_IX_GStateHandle">
 </A>
<H1 CLASS="refHeading">
GStateHandle</H1>
<PRE CLASS="syntax">typedef Handle GStateHandle;</PRE>
<P>
GStates, or graphics states, are used to interpret graphics commands. Any graphics command that draws anything takes a GStateHandle as an argument. Each GState is associated with a window, and the graphics system uses the GState to determine which window the command should affect.</P>
<P>
The GState also holds considerable information determining how drawing commands will be carried out. For instance, it holds the line color. To draw a green line, first one routine set's the GState's line color to green. From then on (or until the line color is changed again), all lines drawn using that GState will be green. Thus, all commands that set color, pattern, or other drawing attributes take a GStateHandle argument.</P>
<P>
GStateHandles are also used when creating bitmaps and graphics strings. In this case, the associated window is fake; all drawing commands passed a GStateHandle representing a bitmap or graphics string will affect the data structure instead of being drawn to screen.</P>
</DIV>
<DIV>
<A NAME="S_1d.htm_IX_GStrings:GString type">
 </A>
<H1 CLASS="refHeading">
GString</H1>
<PRE CLASS="syntax">typedef void GString;</PRE>
<P>
A GString (short for &quot;Graphics Strings&quot;) represents a string of graphics commands. Each GString is made up of one or more GString elements, each of which corresponds to some standard graphics command.</P>
<P>
GStrings may be created by means of drawing to a GStateHandle returned by <CODE>
<A HREF="../../CRef/Routines/R_38.htm#IX_GrCreateState()">GrCreateState()</A></CODE>
, but quite often GStrings are declared explicitly. The GString's data is often set up using macros like <CODE>
<A HREF="../../CRef/Routines/R_4e.htm#IX_GSDrawLine() macro">GSDrawLine()</A></CODE>
. These macros will output an opcode (of type <CODE>
GStringElement</CODE>
) and format their macro arguments into data expected with the opcode.</P>
<P>
For instance,</P>
<PRE>GSDrawLine(72, 144, 216, 288);</PRE>
<P>
...would expand to the data:</P>
<PRE>(GStringElement)			GR_DRAW_LINE</PRE>
<PRE>GOC_SW(72), GOC_SW(144), GOC_SW(216), GOC_SW(288);</PRE>
<P>
...where GOC_SW() is a macro that breaks up a word-length value into two bytes. Fundamentally, a GString is just an array of bytes.</P>
<P>
Thus, these macros just represent data, though they look like normal kernel graphics commands.</P>
</DIV>
<HR>
<A NAME="S_1e.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="S_1e.htm_IX_GR_&ldots;">
 </A>
<A NAME="S_1e.htm_IX_GStringElement">
 </A>
<H1 CLASS="refHeading">
GStringElement</H1>
<PRE CLASS="syntax">typedef ByteEnum GStringElement;
/* The following elements are defined :
	(Miscellaneous GString opcodes:)
GR_END_STRING,</PRE>
<PRE CLASS="syntax">GR_COMMENT,					(data: variable (word (length of code), code))
GR_NULL_OP,
GR_SET_GSTRING_BOUNDS,					(data: 8 bytes 	(4 swords))
GR_LABEL,					(data: 2 bytes 	(word))
GR_ESCAPE,					(data: variable (word (size of code), code))
GR_NEW_PAGE,
	(Coordinate Transform opcodes:)
GR_APPLY_ROTATION,					(data: 4 bytes 	(WWFixed))</PRE>
<PRE CLASS="syntax">GR_APPLY_SCALE,					(data: 8 bytes 	(2 WWFixed))
GR_APPLY_TRANSLATION,					(data: 8 bytes 	(2 WWFixed))
GR_APPLY_TRANSFORM,					(data: 26 bytes	(4 WWFixed, 2 DWFixed))
GR_APPLY_TRANSLATION_DWORD,					(data: 8 bytes 	(2 sdwords))
GR_SET_TRANSFORM,					(data: 26 bytes (4 WWFixed, 2 DWFixed))
GR_SET_NULL_TRANSFORM,
GR_SET_DEFAULT_TRANSFORM,
GR_INIT_DEFAULT_TRANSFORM,
GR_SAVE_TRANSFORM,
GR_RESTORE_TRANSFORM,
	(Output opcodes:)
GR_DRAW_LINE,					(data: 8 bytes 	(4 swords))
GR_DRAW_LINE_TO,					(data: 4 bytes 	(2 swords))
GR_DRAW_REL_LINE_TO					(data: 8 bytes 	(2 WWFixed))
GR_DRAW_HLINE,					(data: 6 bytes 	(3 swords))
GR_DRAW_HLINE_TO,					(data: 2 bytes 	(sword))
GR_DRAW_VLINE,					(data: 6 bytes 	(3 swords))
GR_DRAW_VLINE_TO,					(data: 2 bytes 	(sword))
GR_DRAW_POLYLINE,					(data: variable (word (# of points), points)
GR_DRAW_ARC,					(data: 14 bytes	(ArcCloseType, 6 swords))
GR_DRAW_ARC_3POINT, 					(data: 14 bytes	(ArcCloseType, 6 swords))
GR_DRAW_ARC_3POINT_TO, 					(data: 10 bytes	(ArcCloseType, 4 swords))
GR_DRAW_REL_ARC_3POINT_TO, 					(data: 18 bytes	(ArcCloseType, 4 WWFixed))
GR_DRAW_RECT,					(data: 8 bytes 	(4 swords))
GR_DRAW_RECT_TO,					(data: 4 bytes 	(2 swords))
GR_DRAW_ROUND_RECT,					(data: 10 bytes	(word, 4 swords))
GR_DRAW_ROUND_RECT_TO,					(data: 6 bytes 	(word, 2 swords))
GR_DRAW_SPLINE,					(data: variable (word (# of points), points))
GR_DRAW_SPLINE_TO,					(data: variable (word (# of points), points))
GR_DRAW_CURVE,					(data: 16 bytes	(8 swords))
GR_DRAW_CURVE_TO, 					(data: 12 bytes	(6 swords))
GR_DRAW_REL_CURVE_TO, 					(data: 24 bytes	(6 WWFixed))
GR_DRAW_ELLIPSE,					(data: 8 bytes 	(4 swords))
GR_DRAW_POLYGON,					(data: variable (word (# of points), points))
GR_DRAW_POINT,					(data: 4 bytes 	(2 words))
GR_DRAW_POINT_CP,
GR_BRUSH_POLYLINE,					(data: variable (word (# of points), 2 bytes,
							points))</PRE>
<PRE CLASS="syntax">GR_DRAW_CHAR,					(data: 5 bytes) 	(Chars, 2 swords))
GR_DRAW_CHAR_CP,					(data: 1 byte) 	(Chars))
GR_DRAW_TEXT,					(data: variable (sword, sword, 
					 word (length of string), 
							string (not null terminated)))</PRE>
<PRE CLASS="syntax">GR_DRAW_TEXT_CP,					(data: variable (word (length of string),
					 		string (not null terminated)))</PRE>
<PRE CLASS="syntax">GR_DRAW_TEXT_PTR,					(data: 6 bytes 	(2 swords, (char *)))
GR_DRAW_TEXT_OPTR,					(data: 6 bytes 	(2 swords, optr))
GR_DRAW_PATH,					
GR_FILL_RECT,					(data: 8 bytes 	(4 swords))
GR_FILL_RECT_TO,					(data: 4 bytes 	(2 swords))
GR_FILL_ROUND_RECT,					(data: 10 bytes	(4 swords, word))
GR_FILL_ROUND_RECT_TO,					(data: 6 bytes 	(2 swords, word))
GR_FILL_ARC,					(data: 14 bytes (ArcCloseType, 6 swords))
GR_FILL_POLYGON,					(data: variable (word (# of points),
							RegionFillRule, points))</PRE>
<PRE CLASS="syntax">GR_FILL_ELLIPSE,					(data: 8 bytes 	(2 swords))
GR_FILL_PATH,					(data: 1 byte 	 (RegionFillRule))
GR_FILL_ARC_3POINT, 					(data: 14 bytes	(ArcCloseType, 6 swords))
GR_FILL_ARC_3POINT_TO 					(data: 10 bytes	(ArcCloseType, 4 swords))
GR_FILL_BITMAP, 					(data: 6 bytes 	(2 swords, word))
GR_FILL_BITMAP_CP, 					(data: 2 bytes 	(word))
GR_FILL_BITMAP_OPTR, 					
GR_DRAW_BITMAP,					(data: 6 bytes 	(2 swords, word))
GR_DRAW_BITMAP_CP,					(data: 2 bytes 	(word))
GR_DRAW_BITMAP_OPTR,					(data: 6 bytes 	(2 swords, optr))
GR_DRAW_BITMAP_PTR,					(data: 6 bytes 	(2 swords, *))
GSE_BITMAP_SLICE,					(data: variable)
	(Drawing Attribute opcodes:)
GR_SAVE_STATE,
GR_RESTORE_STATE,
GR_SET_MIX_MODE,					(data: 1 byte 	 (MixMode))
GR_MOVE_TO,					(data: 4 bytes 	(2 swords))
GR_REL_MOVE_TO,					(data: 8 bytes 	(2 WWFixed))
GR_CREATE_PALETTE,					
GR_DESTROY_PALETTE,
GR_SET_PALETTE_ENTRY,					(data: 4 bytes 	(Color, 3 bytes))
GR_SET_PALETTE,					(data: variable (word (# of entries), 
							entries (3 bytes each)))</PRE>
<PRE CLASS="syntax">GR_SET_LINE_COLOR,					(data: 3 bytes 	(3 bytes))
GR_SET_LINE_MASK,					(data: 1 byte 	 (SysDrawMask))
GR_SET_LINE_COLOR_MAP,					(data: 1 byte 	 (ColorMapMode))
GR_SET_LINE_WIDTH,					(data: 4 bytes 	(WWFixed))
GR_SET_LINE_JOIN,					(data: 1 byte 	 (LineJoin))
GR_SET_LINE_END,					(data: 1 byte 	 (LineEnd))
GR_SET_LINE_ATTR,					(data: 9 bytes 	(CF_RGB, 3 bytes, SysDrawMask,
						ColorMapMode, LineEnd, LineJoin, LineStyle)</PRE>
<PRE CLASS="syntax">GR_SET_MITER_LIMIT,					(data: 4 bytes 	(WWFixed))
GR_SET_LINE_STYLE,					(data: 2 bytes 	(LineStyle, index))
GR_SET_LINE_COLOR_INDEX,					(data: 1 byte 	 (Color))
GR_SET_CUSTOM_LINE_MASK,					(data: 8 bytes 	(8 bytes))
GR_SET_CUSTOM_LINE_STYLE,					(data: variable (word (index),
							word (# of on-off dash pairs),</PRE>
<PRE CLASS="syntax">							pairs (each pair is 2 bytes)))
GR_SET_AREA_COLOR,					(data: 3 bytes 	(3 bytes)
GR_SET_AREA_MASK,					(data: 1 byte 	 (SysDrawMask))
GR_SET_AREA_COLOR_MAP,					(data: 1 byte 	 (ColorMapMode))
GR_SET_AREA_ATTR,					(data: 6 bytes 	(CF_RGB, 3 bytes, SysDrawMask, 
							ColorMapMode))</PRE>
<PRE CLASS="syntax">GR_SET_AREA_COLOR_INDEX,					(data: 1 byte 	 (Color))
GR_SET_CUSTOM_AREA_MASK,					(data: 8 bytes 	(8 bytes))
GR_SET_AREA_PATTERN, 					(data: 2 bytes 	(GraphicPattern))
GR_SET_CUSTOM_AREA_PATTERN, 					(data: variable (GraphicPattern, 
							word (size of data)
							pattern data))</PRE>
<PRE CLASS="syntax">GR_SET_TEXT_COLOR,					(data: 3 bytes 	(3 bytes))
GR_SET_TEXT_MASK,					(data: 1 byte 	 (SysDrawMask))
GR_SET_TEXT_COLOR_MAP,					(data: 1 byte 	 (ColorMapMode))
GR_SET_TEXT_STYLE,					(data: 2 bytes 	(2 TextStyles))
GR_SET_TEXT_MODE,					(data: 2 bytes 	(2 TextModes))
GR_SET_TEXT_SPACE_PAD,					(data: 3 bytes 	(WBFixed))
GR_SET_TEXT_ATTR,					(data: 20 bytes	(CF_RGB, 3 bytes, SysDrawMask,
							ColorMapMode, 2 TextStyles, 
							2 TextModes, WBFixed, FontID, word))</PRE>
<PRE CLASS="syntax">GR_SET_FONT,					(data: 5 bytes 	(WBFixed, FontID))
GR_SET_TEXT_COLOR_INDEX,					(data: 1 byte 	 (Color))
GR_SET_CUSTOM_TEXT_MASK,					(data: 8 bytes 	()
GR_SET_TRACK_KERN,					(data: 2 bytes 	(sword))
GR_SET_FONT_WEIGHT, 					(data: 2 bytes 	(FontWeight))
GR_SET_FONT_WIDTH, 					(data: 2 bytes 	(FontWidth))
GR_SET_SUPERSCRIPT_ATTR, 					(data: 2 bytes 	(position, scale))
GR_SET_SUBSCRIPT_ATTR, 					(data: 2 bytes 	(position, scale))
GR_SET_TEXT_PATTERN, 					(data: 2 bytes 	(GraphicPattern))
GR_SET_CUSTOM_TEXT_PATTERN, 					(data: variable (GraphicPattern, 
							word (size of data),
							pattern data))</PRE>
<PRE CLASS="syntax">	(Path opcodes:)
GR_BEGIN_PATH,					(data: 1 byte 	 (PathCombineParam))
GR_END_PATH,					
GR_SET_CLIP_RECT,					(data: 8 bytes 	(4 swords))
GR_SET_WIN_CLIP_RECT,					(data: 8 bytes 	(4 swords))
GR_CLOSE_SUB_PATH,					
GR_SET_CLIP_PATH,					(data: 1 byte 	 (flags))
GR_SET_WIN_CLIP_PATH,					(data: 1 byte 	 (flags))
GR_SET_STROKE_PATH												*/</PRE>
<P>
Each Graphics String Element consists of a <CODE>
GStringElement</CODE>
 value specifying the type of element and the data associated with the element's operation. For instance, GR_DRAW_CHAR operations need six bytes of data: two bytes holding the <CODE>
Chars</CODE>
 value of the character to draw, and two signed words specifying the drawing coordinates.</P>
<P>
A good place to find out about the data associated with a particular <CODE>
GStringElement</CODE>
 type is the <CODE>
GS...()</CODE>
 macros defined in <STRONG CLASS="fileName">
gstring.h</STRONG>
.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Structs/S_1d.htm#IX_GOC_POINT macro">GOC_POINT</A></CODE>,
<CODE><A HREF="../../CRef/Structs/S_1d.htm#IX_GOC_SW(), GOC_WORD() macros">GOC_SW</A></CODE>.</P>
</DIV>
<HR>
<A NAME="S_1f.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="S_1f.htm_IX_GStringErrorType">
 </A>
<A NAME="S_1f.htm_IX_GSET_&ldots;">
 </A>
<H1 CLASS="refHeading">
GStringErrorType</H1>
<PRE CLASS="syntax">typedef enum /* word */ {
GSET_NO_ERROR,
GSET_DISK_FULL
} GStringErrorType;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_1f.htm_IX_GStringKillType">
 </A>
<H1 CLASS="refHeading">
GStringKillType</H1>
<P>
See <CODE>
<A HREF="../../CRef/Routines/R_39.htm#IX_GrDestroyGString()">GrDestroyGString()</A></CODE>
.</P>
</DIV>
<DIV>
<A NAME="S_1f.htm_IX_GStringSetPosType">
 </A>
<H1 CLASS="refHeading">
GStringSetPosType</H1>
<P>
See <CODE>
<A HREF="../../CRef/Routines/R_47.htm#IX_GrSetGStringPos()">GrSetGStringPos()</A></CODE>
.</P>
</DIV>
<DIV>
<A NAME="S_1f.htm_IX_GStringType">
 </A>
<A NAME="S_1f.htm_IX_GST_&ldots;">
 </A>
<H1 CLASS="refHeading">
GStringType</H1>
<PRE CLASS="syntax">typedef ByteEnum GStringType;
#define GST_CHUNK				0
#define GST_STREAM 				1
#define GST_VMEM 				2
#define GST_PTR 				3
#define GST_PATH 				4</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_1f.htm_IX_Handle">
 </A>
<H1 CLASS="refHeading">
Handle</H1>
<PRE CLASS="syntax">typedef word Handle;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_1f.htm_IX_HatchDash">
 </A>
<A NAME="S_1f.htm_IX_HD_o&ldots;">
 </A>
<H1 CLASS="refHeading">
HatchDash</H1>
<PRE CLASS="syntax">typedef struct {
WWFixed		HD_on;
WWFixed		HD_off;
} HatchDash;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_1f.htm_IX_HatchLine">
 </A>
<A NAME="S_1f.htm_IX_HL_&ldots;">
 </A>
<H1 CLASS="refHeading">
HatchLine</H1>
<PRE CLASS="syntax">typedef struct {
PointWWFixed		HL_origin;
WWFixed		HL_deltaX;
WWFixed		HL_deltaY;
WWFixed		HL_angle;
ColorQuad		HL_color;
word		HL_numDashes;
	/* array of HatchDash structures follows here */
} HatchLine;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_1f.htm_IX_HatchPattern">
 </A>
<A NAME="S_1f.htm_IX_HP_numLines">
 </A>
<H1 CLASS="refHeading">
HatchPattern</H1>
<PRE CLASS="syntax">typedef struct {
word HP_numLines;
/* array of HatchLine structures follows here */
} HatchPattern;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_1f.htm_IX_HAF_&ldots;">
 </A>
<A NAME="S_1f.htm_IX_HeapAllocFlags:with HeapAlloc()">
 </A>
<H1 CLASS="refHeading">
HeapAllocFlags</H1>
<PRE CLASS="syntax">typedef ByteFlags HeapAllocFlags;
#define HAF_ZERO_INIT					0x80
#define HAF_LOCK 					0x40
#define HAF_NO_ERR 					0x20
#define HAF_UI 					0x10
#define HAF_READ_ONLY 					0x08
#define HAF_OBJECT_RESOURCE 					0x04
#define HAF_CODE 					0x02
#define HAF_CONFORMING 					0x01
#define HAF_STANDARD					(0)
#define HAF_STANDARD_NO_ERR					(HAF_NO_ERR)
#define HAF_STANDARD_LOCK					(HAF_LOCK)
#define HAF_STANDARD_NO_ERR_LOCK (HAF_NO_ERR | HAF_LOCK)</PRE>
<P>
<CODE>
HeapAllocFlags</CODE>
 indicate how the block should be allocated and initialized. They are not stored and can not be retrieved. Only some of the flags can be passed with <CODE>
<A HREF="../../CRef/Routines/R_6e.htm#IX_MemReAlloc()">MemReAlloc()</A></CODE>
; these are noted below. The following flags are available:</P>
<DL>
<DT>
HAF_ZERO_INIT</DT><DD>
The memory manager should initialize the block to null bytes. This flag may be passed to <CODE>
<A HREF="../../CRef/Routines/R_6e.htm#IX_MemReAlloc()">MemReAlloc()</A></CODE>
 to cause new memory to be zero-initialized.</DD>
<DT>
HAF_LOCK</DT><DD>The memory manager should lock the block after allocating it. To get the block's address, call <CODE>
<A HREF="../../CRef/Routines/R_6b.htm#IX_MemDeref()">MemDeref()</A></CODE>
. This flag may be passed to <CODE>
<A HREF="../../CRef/Routines/R_6e.htm#IX_MemReAlloc()">MemReAlloc()</A></CODE>
.</DD>
<DT>
HAF_NO_ERR</DT><DD>
The memory manager should not return errors. If it cannot allocate block, GEOS will tell the user that there is no memory available and crash. Use of this flag is strongly discouraged. This flag may be passed to <CODE>
<A HREF="../../CRef/Routines/R_6e.htm#IX_MemReAlloc()">MemReAlloc()</A></CODE>
.</DD>
<DT>
HAF_UI</DT><DD>If both HAF_OBJECT_RESOURCE and HAF_UI are set, this block will be run by the application's UI thread.</DD>
<DT>
HAF_READ_ONLY</DT><DD>
The block's data will not be modified. Useful for the debugger.</DD>
<DT>
HAF_OBJECT_RESOURCE</DT><DD>
This block will be an object block.</DD>
<DT>
HAF_CODE</DT><DD>This block contains executable code.</DD>
<DT>
HAF_CONFORMING</DT><DD>
If the block contains code, the code may be run by a less privileged entity. If the block contains data, the data may be accessed or altered by a less privileged entity.</DD>
</DIV>
</DL>
<HR>
<A NAME="S_20.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="S_20.htm_IX_HC_&ldots;">
 </A>
<A NAME="S_20.htm_IX_HeapCongestion">
 </A>
<H1 CLASS="refHeading">
HeapCongestion</H1>
<PRE CLASS="syntax">typedef enum /* word */ {
HC_SCRUBBING,
HC_CONGESTED,
HC_DESPERATE
} HeapCongestion;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_20.htm_IX_HeapFlags">
 </A>
<A NAME="S_20.htm_IX_HF_&ldots;">
 </A>
<H1 CLASS="refHeading">
HeapFlags</H1>
<PRE CLASS="syntax">typedef ByteFlags HeapFlags;
#define HF_FIXED				0x80
#define HF_SHARABLE 				0x40
#define HF_DISCARDABLE 				0x20
#define HF_SWAPABLE 				0x10
#define HF_LMEM 				0x08
#define HF_DISCARDED 				0x02
#define HF_SWAPPED 				0x01
#define HF_STATIC 				(HF_DISCARDABLE | HF_SWAPABLE)
#define HF_DYNAMIC 				HF_SWAPABLE</PRE>
<P>
The following flags are available:</P>
<DL>
<DT>
HF_FIXED</DT><DD>
The block will not move from its place in the global heap until it is freed. If this flag is off, the memory manager may move the block while it is unlocked. If the flag is on, the block may not be locked, and HF_DISCARDABLE and HF_SWAPABLE must be off.</DD>
<DT>
HF_SHARABLE</DT><DD>
The block may be locked by threads belonging to geodes other than the block's owner.</DD>
<DT>
HF_DISCARDABLE</DT><DD>
The block may be discarded when unlocked.</DD>
<DT>
HF_SWAPABLE</DT><DD>
The block may be swapped to extended/expanded memory or to the disk swap space when it is unlocked.</DD>
<DT>
HF_LMEM</DT><DD>
The block contains a local memory heap. This flag is set automatically by <CODE>
<A HREF="../../CRef/Routines/R_64.htm#IX_LMemInitHeap()">LMemInitHeap()</A></CODE>
 and <CODE>
<A HREF="../../CRef/Routines/R_a1.htm#IX_VMAllocLMem()">VMAllocLMem()</A></CODE>
; applications should not need to set this flag.</DD>
<DT>
HF_DISCARDED</DT><DD>
The memory manager turns this bit on when it discards a block. The bit is turned off when the block is reallocated.</DD>
<DT>
HF_SWAPPED</DT><DD>
The memory manager turns this bit on when it swaps a block to extended/expanded memory or to the disk swap space. It turns the bit off when it swaps the block back into the global heap.</DD>
</DIV>
<DIV>
<A NAME="S_20.htm_IX_HugeArrayDirectory">
 </A>
<A NAME="S_20.htm_IX_HAD_&ldots;">
 </A>
</DL>
<H1 CLASS="refHeading">
HugeArrayDirectory</H1>
<PRE CLASS="syntax">typedef struct {
LMemBlockHeader			HAD_header;
VMBlockHandle			HAD_data;
ChunkHandle			HAD_dir;
VMBlockHandle			HAD_xdir;
VMBlockHandle			HAD_self;
word			HAD_size;
} HugeArrayDirectory;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_20.htm_IX_IACPCF_&ldots;">
 </A>
<A NAME="S_20.htm_IX_IACPConnectFlags">
 </A>
<H1 CLASS="refHeading">
IACPConnectFlags</H1>
<PRE CLASS="syntax">typedef WordFlags IACPConnectFlags;
#define IACPCF_OBEY_LAUNCH_MODEL 							0x0020
#define IACPCF_CLIENT_OD_SPECIFIED 							0x0010
#define IACPCF_FIRST_ONLY 							0x0008
#define IACPCF_SERVER_MODE 							0x0007</PRE>
<P>
&nbsp;</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
iacp.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="S_20.htm_IX_IACPServerFlags">
 </A>
<A NAME="S_20.htm_IX_IACPSF_&ldots;">
 </A>
<H1 CLASS="refHeading">
IACPServerFlags</H1>
<PRE CLASS="syntax">typedef ByteFlags IACPServerFlags;
#define IACPSF_MULTIPLE_INSTANCES 						0x80</PRE>
<P>
&nbsp;</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
iacp.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="S_20.htm_IX_IACPServerMode">
 </A>
<A NAME="S_20.htm_IX_IACPSM_&ldots;">
 </A>
<H1 CLASS="refHeading">
IACPServerMode</H1>
<PRE CLASS="syntax">IACPServerMode;
#define IACPSM_NOT_USER_INTERACTIBLE 							0
#define IACPSM_IN_FLUX 							1
#define IACPSM_USER_INTERACTIBLE 							2</PRE>
<P>
&nbsp;</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
iacp.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="S_20.htm_IX_IACPSide">
 </A>
<A NAME="S_20.htm_IX_IACPS_&ldots;">
 </A>
<H1 CLASS="refHeading">
IACPSide</H1>
<PRE CLASS="syntax">typedef enum {
IACPS_CLIENT,
IACPS_SERVER
} IACPSide;</PRE>
<P>
&nbsp;</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
iacp.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="S_20.htm_IX_ImageFlags">
 </A>
<A NAME="S_20.htm_IX_ImageBitSize">
 </A>
<A NAME="S_20.htm_IX_IBS_&ldots;">
 </A>
<A NAME="S_20.htm_IX_IF_&ldots;  (ImageFlags)">
 </A>
<H1 CLASS="refHeading">
ImageFlags</H1>
<PRE CLASS="syntax">typedef ByteFlags ImageFlags;
#define IF_IGNORE_MASK 				0x10
#define IF_BORDER				0x08
#define IF_BITSIZE				0x07 /* Should hold an ImageBitSize */
&nbsp;
#define IBS_1 			0
#define IBS_2 			1
#define IBS_4 			2
#define IBS_8 			3
#define IBS_16 			4</PRE>
<P>
&nbsp;</P>
</DIV>
<HR>
<A NAME="S_21.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="S_21.htm_IX_IMCFeatures">
 </A>
<A NAME="S_21.htm_IX_IMC_&ldots;">
 </A>
<H1 CLASS="refHeading">
IMCFeatures</H1>
<PRE CLASS="syntax">typedef ByteFlags IMCFeatures;
#define IMCF_MAP				0x01
#define IMC_DEFAULT_FEATURES							IMCF_MAP
#define IMC_DEFAULT_TOOLBOX_FEATURES							0
#define IMC_MAP_MONIKER_SIZE							1024</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_21.htm_IX_ImpexDataClasses">
 </A>
<A NAME="S_21.htm_IX_IDC_&ldots;">
 </A>
<H1 CLASS="refHeading">
ImpexDataClasses</H1>
<PRE CLASS="syntax">typedef WordFlags ImpexDataClasses;
#define IDC_TEXT				0x8000
#define IDC_GRAPHICS 				0x4000
#define IDC_SPREADSHEET 				0x2000
#define IDC_FONT 				0x1000</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_21.htm_IX_ImpexFileSelectionData">
 </A>
<A NAME="S_21.htm_IX_IFSD_&ldots;">
 </A>
<H1 CLASS="refHeading">
ImpexFileSelectionData</H1>
<PRE CLASS="syntax">typedef struct {
FileLongName				IFSD_selection;
PathName				IFSD_path;
word				IFSD_disk;
GenFileSelectorEntryFlags				IFSD_type;
} ImpexFileSelectionData;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_21.htm_IX_ImpexMapFlags">
 </A>
<A NAME="S_21.htm_IX_IMF_&ldots;">
 </A>
<H1 CLASS="refHeading">
ImpexMapFlags</H1>
<PRE CLASS="syntax">typedef ByteFlags ImpexMapFlags;
#define IMF_IMPORT				0x80
#define IMF_EXPORT				0x40</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_21.htm_IX_ImpexMapFileInfoHeader">
 </A>
<A NAME="S_21.htm_IX_IMFIH_&ldots;">
 </A>
<H1 CLASS="refHeading">
ImpexMapFileInfoHeader</H1>
<PRE CLASS="syntax">typedef struct {
LMemBlockHeader				IMFIH_base;
word				IMFIH_fieldChunk;
word				IMFIH_numFields;
} ImpexMapFileInfoHeader;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_21.htm_IX_ImpexTranslationParams">
 </A>
<A NAME="S_21.htm_IX_ITP_&ldots;">
 </A>
<H1 CLASS="refHeading">
ImpexTranslationParams</H1>
<PRE CLASS="syntax">typedef struct {
optr		ITP_impexOD;
Message		ITP_returnMsg;
word 		ITP_dataClass;
FileHandle 		ITP_transferVMFile;
VMChain 		ITP_transferVMChain;
dword 		ITP_internal;
} ImpexTranslationParams;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_21.htm_IX_ImportControlAttrs">
 </A>
<A NAME="S_21.htm_IX_ICA_IGNORE_INPUT">
 </A>
<H1 CLASS="refHeading">
ImportControlAttrs</H1>
<PRE CLASS="syntax">typedef WordFlags ImportControlAttrs;
#define ICA_IGNORE_INPUT 0x8000						/* ignore input while import occurs */</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_21.htm_IX_ImportControlToolboxFeatures">
 </A>
<A NAME="S_21.htm_IX_IMPORTCF_DIALOG_BOX">
 </A>
<H1 CLASS="refHeading">
ImportControlToolboxFeatures</H1>
<PRE CLASS="syntax">typedef ByteFlags ImportControlToolboxFeatures;
#define IMPORTCTF_DIALOG_BOX					0x01</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_21.htm_IX_IndexArrayBlockHeader">
 </A>
<H1 CLASS="refHeading">
IndexArrayBlockHeader</H1>
<PRE CLASS="syntax">typedef struct {
word	IALMBH_recCount;
word	IALMBH_array;
word	IALMBH_indexField;
word	IALMBH_sortOrder;
} IndexArrayBlockHeader;</PRE>
<P>
Format of a block containing a datastore index of <CODE>
RecordNum</CODE>
s (low word only); see <CODE>
<A HREF="../../CRef/Routines/R_f.htm#IX_DataStoreBuildIndex()">DataStoreBuildIndex()</A></CODE>
.</P>
</DIV>
<DIV>
<A NAME="S_21.htm_IX_InitFileCharConvert">
 </A>
<A NAME="S_21.htm_IX_IFCC_&ldots;">
 </A>
<H1 CLASS="refHeading">
InitFileCharConvert</H1>
<PRE CLASS="syntax">typedef ByteEnum InitFileCharConvert;
#define IFCC_INTACT				0		/* Leave all characters unchanged. */
#define IFCC_UPCASE				1		/* Make all characters upper case. */
#define IFCC_DOWNCASE				2		/* Make all characters lower case. */</PRE>
<P>
This enumerated type describes how <CODE>
InitFileRead...()</CODE>
 routines should handle incoming strings.</P>
</DIV>
<DIV>
<A NAME="S_21.htm_IX_InitFileReadFlags">
 </A>
<A NAME="S_21.htm_IX_IFRF_&ldots;">
 </A>
<H1 CLASS="refHeading">
InitFileReadFlags</H1>
<PRE CLASS="syntax">typedef WordFlags InitFileReadFlags;
#define IFRF_CHAR_CONVERT				0xc000			/* 2 bits: InitFileCharConvert type */
#define IFRF_READ_ALL	 			0x2000
#define IFRF_FIRST_ONLY	 			0x1000
#define IFRF_SIZE				0x0fff</PRE>
<P>
This record is used with the <CODE>
InitFileRead...()</CODE>
 routines. The IFRF_CHAR_CONVERT field is used to indicate whether strings being read should be upcased, downcased, or left unaltered--the type is designated by a value of <CODE>
InitFileCharConvert</CODE>
. The IFRF_SIZE field is used by routines that take a passed buffer; this field indicates the size of the buffer (the maximum number of bytes that can be returned by the routine).</P>
<P>
When setting this record, make sure you shift the IFRF_CHAR_CONVERT value left an offset of IFRF_CHAR_CONVERT_OFFSET.</P>
</DIV>
<DIV>
<A NAME="S_21.htm_IX_InkBackgroundType">
 </A>
<A NAME="S_21.htm_IX_IBT_&ldots;">
 </A>
<H1 CLASS="refHeading">
InkBackgroundType</H1>
<PRE CLASS="syntax">typedef enum {
IBT_NO_BACKGROUND = 0,
IBT_NARROW_LINED_PAPER = 2,
IBT_MEDIUM_LINED_PAPER = 4,
IBT_WIDE_LINED_PAPER = 6,
IBT_NARROW_STENO_PAPER = 8,
IBT_MEDIUM_STENO_PAPER = 10,
IBT_WIDE_STENO_PAPER = 12,
IBT_SMALL_GRID = 14,
IBT_MEDIUM_GRID = 16,
IBT_LARGE_GRID = 18,
IBT_SMALL_CROSS_SECTION = 20,
IBT_MEDIUM_CROSS_SECTION = 22,
IBT_LARGE_CROSS_SECTION = 24,
IBT_TO_DO_LIST = 26,
IBT_PHONE_MESSAGE = 28,
IBT_CUSTOM_BACKGROUND = 30
} InkBackgrountType;</PRE>
<P>
This enumerated type is a set of standard background pictures for use with the Ink Database routines.</P>
</DIV>
<HR>
<A NAME="S_22.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="S_22.htm_IX_InkControlFeatures">
 </A>
<A NAME="S_22.htm_IX_ICF_&ldots;  (InkControlFeatures)">
 </A>
<H1 CLASS="refHeading">
InkControlFeatures</H1>
<PRE CLASS="syntax">typedef ByteFlags InkControlFeatures;
#define ICF_PENCIL_TOOL				0x02
#define ICF_ERASER_TOOL				0x01</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_22.htm_IX_InkControlToolboxFeatures">
 </A>
<A NAME="S_22.htm_IX_ICTF_&ldots;">
 </A>
<H1 CLASS="refHeading">
InkControlToolboxFeatures</H1>
<PRE CLASS="syntax">typedef ByteFlags InkControlToolboxFeatures;
#define ICTF_PENCIL_TOOL				0x02
#define ICTF_ERASER_TOOL				0x01</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_22.htm_IX_InkDBDisplayInfo">
 </A>
<H1 CLASS="refHeading">
InkDBDisplayInfo</H1>
<P>
See <CODE>
<A HREF="../../CRef/Routines/R_5e.htm#IX_InkDBGetDisplayInfo()">InkDBGetDisplayInfo()</A></CODE>
.</P>
</DIV>
<DIV>
<A NAME="S_22.htm_IX_InkDBFrame">
 </A>
<A NAME="S_22.htm_IX_IDBF_&ldots;">
 </A>
<H1 CLASS="refHeading">
InkDBFrame</H1>
<PRE CLASS="syntax">typedef struct {
Rectangle IDBF_bounds;							/* bounds of data to save or coord at
							 * which to load data */</PRE>
<PRE CLASS="syntax">VMFileHandle IDBF_VMFile;							/* VM File to write to/read from */
DBGroupAndItem IDBF_DBGroupAndItem;							/* DB item to save to/load from */
word IDBF_DBExtra;							/* space to skip at start of block */
} InkDBFrame;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_22.htm_IX_InkFlags">
 </A>
<A NAME="S_22.htm_IX_IF_&ldots;  (InkFlags)">
 </A>
<H1 CLASS="refHeading">
InkFlags</H1>
<PRE CLASS="syntax">typedef ByteFlags InkFlags;
#define IF_HAS_TARGET						0x20
#define IF_DIRTY 						0x10
#define IF_ONLY_CHILD_OF_CONTENT 						0x08
#define IF_CONTROLLED 						0x04
#define IF_INVALIDATE_ERASURES 						0x02
#define IF_HAS_UNDO 						0x01</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_22.htm_IX_InkReturnValue">
 </A>
<A NAME="S_22.htm_IX_IRV_&ldots;">
 </A>
<H1 CLASS="refHeading">
InkReturnValue</H1>
<PRE CLASS="syntax">typedef enum {
IRV_NO_REPLY,
/* VisComp objects use VisCallChildUnderPoint to send
 * MSG_META_QUERY_IF_PRESS_IS_INK to its children, and
 * VisCallChildUnderPoint returns this value (0) if there was not child
 * under the point. No object should actually return this value. */</PRE>
<PRE CLASS="syntax">IRV_NO_INK,
/* Return this if the object wants to treat incoming event as mouse data. */</PRE>
<PRE CLASS="syntax">IRV_INK_WITH_STANDARD_OVERRIDE,
/* Return this if the object normally wants ink (the text object does this), 
 * but the user can force mouse events instead by pressing the pen and 
 * holding for some user-adjustable amount of time. */</PRE>
<PRE CLASS="syntax">IRV_WAIT
/* Return this value if the object under the point is run by a different
 * thread and you want to hold up input (don't do anything with the incoming
 * MSG_META_START_SELECT) `til obj sends MSG_GEN_APPLICATION_INK_QUERY_REPLY
 * to the applicaiton object. */</PRE>
<PRE CLASS="syntax">} InkReturnValue;</PRE>
<P>
This enumerated type is used by objects to let the system know whether incoming pointer events should be interpreted as mouse or pen data.</P>
</DIV>
<DIV>
<A NAME="S_22.htm_IX_InsertChildFlags">
 </A>
<A NAME="S_22.htm_IX_ICF_&ldots;  (InsertChildFlags)">
 </A>
<H1 CLASS="refHeading">
InsertChildFlags</H1>
<PRE CLASS="syntax">typedef WordFlags InsertChildFlags
#define ICF_MARK_DIRTY				0x8000
#define ICF_OPTIONS				0x0003</PRE>
<P>
This record specifies how children are to be added to an object tree.</P>
</DIV>
<DIV>
<A NAME="S_22.htm_IX_InsertChildOption">
 </A>
<A NAME="S_22.htm_IX_ICO_&ldots;">
 </A>
<H1 CLASS="refHeading">
InsertChildOption</H1>
<PRE CLASS="syntax">typedef ByteEnum InsertChildOption
#define ICO_FIRST					0
#define ICO_LAST					1
#define ICO_BEFORE_REFERENCE					2
#define ICO_AFTER_REFERENCE					3</PRE>
<P>
This enumerated type determines how a child is added and is used with the <CODE>
InsertChildFlags</CODE>
 record. It has four enumerations, as shown above.</P>
</DIV>
<HR>
<A NAME="S_23.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="S_23.htm_IX_Glockenspiel">
 </A>
<A NAME="S_23.htm_IX_Ocarina">
 </A>
<A NAME="S_23.htm_IX_Tinkle bell">
 </A>
<A NAME="S_23.htm_IX_Melodic tom">
 </A>
<A NAME="S_23.htm_IX_Hi tom">
 </A>
<A NAME="S_23.htm_IX_InstrumentPatch">
 </A>
<A NAME="S_23.htm_IX_IP_&ldots;">
 </A>
<H1 CLASS="refHeading">
InstrumentPatch</H1>
<PRE CLASS="syntax">typedef enum { 
#define IP_ACOUSTIC_GRAND_PIANO 				0
#define IP_BRIGHT_ACOUSTIC_PIANO 				1
#define IP_ELECTRIC_GRAND_PIANO 				2
#define IP_HONKY_TONK_PIANO 				3
#define IP_ELECTRIC_PIANO_1 				4
#define IP_ELECTRIC_PIANO_2 				5
#define IP_HARPSICORD 				6
#define IP_CLAVICORD 				7
#define IP_CELESTA	 			8
&nbsp;
#define IP_GLOCKENSPIEL 				9
#define IP_MUSIC_BOX 				10
#define IP_VIBRAPHONE 				11
#define IP_MARIMBA 				12
#define IP_XYLOPHONE 				13
#define IP_TUBULAR_BELLS 				14
#define IP_DULCIMER 				15
&nbsp;
#define IP_DRAWBAR_ORGAN 				16
#define IP_PERCUSSIVE_ORGAN 				17
#define IP_ROCK_ORGAN 				18
#define IP_CHURCH_ORGAN 				19
#define IP_REED_ORGAN 				20
#define IP_ACCORDION 				21
#define IP_HARMONICA 				22
#define IP_TANGO_ACCORDION 				23
&nbsp;
#define IP_ACOUSTIC_NYLON_GUITAR 				24
#define IP_ACOUSTIC_STEEL_GUITAR 				25
#define IP_ELECTRIC_JAZZ_GUITAR 				26
#define IP_ELECTRIC_CLEAN_GUITAR 				27
#define IP_ELECTRIC_MUTED_GUITAR 				28
#define IP_OVERDRIVEN_GUITAR 				29
#define IP_DISTORTION_GUITAR 				30
#define IP_GUITAR_HARMONICS 				31
&nbsp;
#define IP_ACOUSTIC_BASS 				32
#define IP_ELECTRIC_FINGERED_BASS 33
#define IP_ELECTRIC_PICKED_BASS 34
#define IP_FRETLESS_BASS 				35
#define IP_SLAP_BASS_1 				36
#define IP_SLAP_BASS_2 				37
#define IP_SYNTH_BASS_1 				38
#define IP_SYNTH_BASS_2 				39
&nbsp;
#define IP_VIOLIN 				40
#define IP_VIOLA 				41
#define IP_CELLO 				42
#define IP_CONTRABASS 				43
#define IP_TREMOLO_STRINGS 				44
#define IP_PIZZICATO_STRINGS 				45
#define IP_ORCHESTRAL_HARP 				46
#define IP_TIMPANI 				47
&nbsp;
#define IP_STRING_ENSEMBLE_1 				48
#define IP_STRING_ENSEMBLE_2 				49
#define IP_SYNTH_STRINGS_1 				50
#define IP_SYNTH_STRINGS_2 				51
#define IP_CHIOR_AAHS 				52
#define IP_VOICE_OOHS 				53
#define IP_SYNTH_VOICE 				54
#define IP_ORCHESTRA_HIT 				55
&nbsp;
#define IP_TRUMPET 				56
#define IP_TROMBONE 				57
#define IP_TUBA 				58
#define IP_MUTED_TRUMPET 				59
#define IP_FRENCH_HORN 				60
#define IP_BRASS_SECTION 				61
#define IP_SYNTH_BRASS_1 				62
#define IP_SYNTH_BRASS_2 				63
&nbsp;
#define IP_SOPRANO_SAX 				64
#define IP_ALTO_SAX 				65
#define IP_TENOR_SAX 				66
#define IP_BARITONE_SAX 				67
#define IP_OBOE 				68
#define IP_ENGLISH_HORN 				69
#define IP_BASSOON 				70
#define IP_CLARINET 				71
&nbsp;
#define IP_PICCOLO 				72
#define IP_FLUTE 				73
#define IP_RECORDER 				74
#define IP_PAN_FLUTE 				75
#define IP_BLOWN_BOTTLE 				76
#define IP_SHAKUHACHI 				77
#define IP_WHISTLE 				78
#define IP_OCARINA 				79
&nbsp;
#define IP_LEAD_SQUARE 				80
#define IP_LEAD_SAWTOOTH 				81
#define IP_LEAD_CALLIOPE 				82
#define IP_LEAD_CHIFF 				83
#define IP_LEAD_CHARANG 				84
#define IP_LEAD_VOICE 				85
#define IP_LEAD_FIFTHS 				86
#define IP_LEAD_BASS_LEAD 				87
&nbsp;
#define IP_PAD_NEW_AGE 				88
#define IP_PAD_WARM 				89
#define IP_PAD_POLYSYNTH 				90
#define IP_PAD_CHOIR 				91
#define IP_PAD_BOWED 				92
#define IP_PAD_METALLIC 				93
#define IP_PAD_HALO 				94
#define IP_PAD_SWEEP 				95
&nbsp;
#define IP_FX_RAIN 				96
#define IP_FX_SOUNDTRACK 				97
#define IP_FX_CRYSTAL 				98
#define IP_FX_ATMOSPHERE 				99
#define IP_FX_BRIGHTNESS 				100
#define IP_FX_GOBLINS 				101
#define IP_FX_ECHOES 				102
#define IP_FX_SCI_FI 				103
&nbsp;
#define IP_SITAR 				104
#define IP_BANJO 				105
#define IP_SHAMISEN 				106
#define IP_KOTO 				107
#define IP_KALIMBA 				108
#define IP_BAG_PIPE 				109
#define IP_FIDDLE 				110
#define IP_SHANAI 				111
&nbsp;
#define IP_TINKLE_BELL 				112
#define IP_AGOGO 				113
#define IP_STEEL_DRUMS 				114
#define IP_WOODBLOCK 				115
#define IP_TAIKO_DRUM 				116
#define IP_MELODIC_TOM 				117
#define IP_SYNTH_DRUM 				118
#define IP_REVERSE_CYMBAL 				119
&nbsp;
#define IP_GUITAR_FRET_NOISE 				120
#define IP_BREATH_NOISE 				121
#define IP_SEASHORE 				122
#define IP_BIRD_TWEET 				123
#define IP_TELEPHONE_RING 				124
#define IP_HELICOPTER 				125
#define IP_APPLAUSE 				126
#define IP_GUNSHOT 				127
&nbsp;
#define IP_ACOUSTIC_BASS_DRUM 				128
#define IP_BASS_DRUM_1 				129
#define IP_SIDE_STICK 				130
#define IP_ACOUSTIC_SNARE 				131
#define IP_HAND_CLAP 				132
#define IP_ELECTRIC_SNARE 				133
#define IP_LOW_FLOOR_TOM 				134
#define IP_CLOSED_HI_HAT 				135
&nbsp;
#define IP_HIGH_FLOOR_TOM 				136
#define IP_PEDAL_HI_HAT 				137
#define IP_LOW_TOM 				138
#define IP_OPEN_HI_HAT 				139
#define IP_LOW_MID_TOM 				140
#define IP_HI_MID_TOM 				141
#define IP_CRASH_CYMBAL_1 				142
#define IP_HIGH_TOM 				143
&nbsp;
#define IP_RIDE_CYMBAL_1 				144
#define IP_CHINESE_CYMBAL 				145
#define IP_RIDE_BELL 				146
#define IP_TAMBOURINE 				147
#define IP_SPLASH_CYMBAL 				148
#define IP_COWBELL 				149
#define IP_CRASH_CYMBAL_2 				150
#define IP_VIBRASLAP 				151
&nbsp;
#define IP_RIDE_CYMBAL_2 				152
#define IP_HI_BONGO 				153
#define IP_LOW_BONGO 				154
#define IP_MUTE_HI_CONGA 				155
#define IP_OPEN_HI_CONGA 				156
#define IP_LOW_CONGA 				157
#define IP_HI_TIMBALE 				158
#define IP_LOW_TIMBALE 				159
&nbsp;
#define IP_HIGH_AGOGO 				160
#define IP_LOW_AGOGO 				161
#define IP_CABASA 				162
#define IP_MARACAS 				163
#define IP_SHORT_WHISTLE 				164
#define IP_LONG_WHISTLE 				165
#define IP_SHORT_GUIRO 				166
#define IP_LONG_GUIRO 				167
&nbsp;
#define IP_CLAVES 				168
#define IP_HI_WOOD_BLOCK 				169
#define IP_LOW_WOOD_BLOCK 				170
#define IP_MUTE_CUICA 				171
#define IP_OPEN_CUICA 				172
#define IP_MUTE_TRIANGLE 				173
#define IP_OPEN_TRIANGLE 				174
} InstrumentPatch;</PRE>
<P>
These are standard simulated instruments. </P>
</DIV>
<HR>
<A NAME="S_24.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="S_24.htm_IX_IT_STANDARD_TABLE">
 </A>
<A NAME="S_24.htm_IX_InstrumentTable">
 </A>
<H1 CLASS="refHeading">
InstrumentTable</H1>
<PRE CLASS="syntax">typedef enum {
         IT_STANDARD_TABLE=0 			/* default table */
} InstrumentTable;</PRE>
<P>
The sound library uses this enumerated type to keep track of which table of simulated musical instruments to use.</P>
</DIV>
<DIV>
<A NAME="S_24.htm_IX_JobStatus">
 </A>
<A NAME="S_24.htm_IX_JS_&ldots;">
 </A>
<H1 CLASS="refHeading">
JobStatus</H1>
<PRE CLASS="syntax">typedef struct {
char			JS_fname[13];			/* std DOS (8.3) spool filename */
char			JS_parent[FILE_LONGNAME_LENGTH+1];
						/* parent app's name */</PRE>
<PRE CLASS="syntax">char			JS_documentName[FILE_LONGNAME_LENGTH+1];
						/* document name */</PRE>
<PRE CLASS="syntax">word			JS_numPages;			/* # pages in document */
SpoolTimeStruct			JS_time;			/* time spooled */
byte			JS_printing;			/* TRUE/FALSE if we are printing */
} JobStatus;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_24.htm_IX_Justification">
 </A>
<A NAME="S_24.htm_IX_J_&ldots;">
 </A>
<H1 CLASS="refHeading">
Justification</H1>
<PRE CLASS="syntax">typedef ByteEnum Justification;
#define J_LEFT			0
#define J_RIGHT			1
#define J_CENTER			2
#define J_FULL			3</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_24.htm_IX_KeyboardShortcut">
 </A>
<A NAME="S_24.htm_IX_KS_&ldots;">
 </A>
<H1 CLASS="refHeading">
KeyboardShortcut</H1>
<PRE CLASS="syntax">typedef ByteFlags KeyboardShortcut;
        #define KS_PHYSICAL     0x80    /* TRUE: match key, not character   */
        #define KS_ALT          0x40    /* TRUE: &lt;ALT&gt; must be pressed      */
        #define KS_CTRL         0x20    /* TRUE: &lt;CTRL&gt; must be pressed     */
        #define KS_SHIFT        0x10    /* TRUE: &lt;SHIFT&gt; must be pressed    */
        &nbsp;
        #define KS_CHAR_SET_PRINTABLE   (CS_BSW     &amp; 0x0f)
        #define KS_CHAR_SET_CONTROL     (CS_CONTROL &amp; 0x0f)</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_24.htm_IX_KeyboardType">
 </A>
<A NAME="S_24.htm_IX_KT_&ldots;">
 </A>
<H1 CLASS="refHeading">
KeyboardType</H1>
<PRE CLASS="syntax">typedef ByteEnum KeyboardType;
#define KT_NOT_EXTD				1
#define KT_EXTD				2
#define KT_BOTH				3</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_24.htm_IX_KeyMapType">
 </A>
<A NAME="S_24.htm_IX_KEYMAP_&ldots;">
 </A>
<H1 CLASS="refHeading">
KeyMapType</H1>
<PRE CLASS="syntax">typedef enum /* word */ {
KEYMAP_US_EXTD=1,
KEYMAP_US,
KEYMAP_UK_EXTD,
KEYMAP_UK,
KEYMAP_GERMANY_EXTD,
KEYMAP_GERMANY,
KEYMAP_SPAIN_EXTD,
KEYMAP_SPAIN,
KEYMAP_DENMARK_EXTD,
KEYMAP_DENMARK,
KEYMAP_BELGIUM_EXTD,
KEYMAP_BELGIUM,
KEYMAP_CANADA_EXTD,
KEYMAP_CANADA,
KEYMAP_ITALY_EXTD,
KEYMAP_ITALY,
KEYMAP_LATIN_AMERICA_EXTD,
KEYMAP_LATIN_AMERICA,
KEYMAP_NETHERLANDS,
KEYMAP_NETHERLANDS_EXTD,
KEYMAP_NORWAY_EXTD,
KEYMAP_NORWAY,
KEYMAP_PORTUGAL_EXTD,
KEYMAP_PORTUGAL,
KEYMAP_SWEDEN_EXTD,
KEYMAP_SWEDEN,
KEYMAP_SWISS_FRENCH_EXTD,
KEYMAP_SWISS_FRENCH,
KEYMAP_SWISS_GERMAN_EXTD,
KEYMAP_SWISS_GERMAN,
KEYMAP_FRANCE_EXTD,
KEYMAP_FRANCE,
} KeyMapType;</PRE>
<P>
&nbsp;</P>
</DIV>
<HR>
<A NAME="S_25.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="S_25.htm_IX_Language type">
 </A>
<A NAME="S_25.htm_IX_L_&ldots;">
 </A>
<H1 CLASS="refHeading">
Language</H1>
<PRE CLASS="syntax">typedef ByteEnum Language;
#define L_DEFAULT				0
#define L_GRAPHIC 				0
#define L_ENGLISH 				1
#define L_GERMAN 				2
#define L_FRENCH 				3
#define L_SPANISH 				4
#define L_ITALIAN 				5
#define L_DANISH 				6
#define L_DUTCH 				7</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_25.htm_IX_LargeMouseData">
 </A>
<A NAME="S_25.htm_IX_LMD_&ldots;">
 </A>
<H1 CLASS="refHeading">
LargeMouseData</H1>
<PRE CLASS="syntax">typedef struct {
PointDWFixed				LMD_location;
byte				LMD_buttonInfo;
UIFunctionsActive				LMD_uiFunctionsActive;
} LargeMouseData;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_25.htm_IX_LayerPriority">
 </A>
<A NAME="S_25.htm_IX_LAYER_PRIO_&ldots;">
 </A>
<H1 CLASS="refHeading">
LayerPriority</H1>
<PRE CLASS="syntax">typedef ByteEnum LayerPriority;
#define LAYER_PRIO_MODAL					 6
#define LAYER_PRIO_ON_TOP					 8
#define LAYER_PRIO_STD					12
#define LAYER_PRIO_ON_BOTTOM					14</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_25.htm_IX_LibraryCallType">
 </A>
<A NAME="S_25.htm_IX_LCT_&ldots;">
 </A>
<H1 CLASS="refHeading">
LibraryCallType</H1>
<PRE CLASS="syntax">typedef enum /* word */ {
LCT_ATTACH,				/* The library was just loaded. */
LCT_DETACH,				/* The library is about to be unloaded. */
LCT_NEW_CLIENT,				/* A new client of the library was just loaded. */
LCT_NEW_CLIENT_THREAD,				/* A new thread was just created for a
				 * current client of the library. */
LCT_CLIENT_THREAD_EXIT,				/* A thread was just exited for a current
				 * client of the library. */
LCT_CLIENT_EXIT,				/* Library's client is about to be unloaded. */
} LibraryCallType</PRE>
<P>
This type is used by library entry point routines. Library entry point routines take a value of this enumerated type to determine what, if anything, is to be done.</P>
</DIV>
<DIV>
<A NAME="S_25.htm_IX_LineAttr">
 </A>
<A NAME="S_25.htm_IX_LA_&ldots;">
 </A>
<H1 CLASS="refHeading">
LineAttr</H1>
<PRE CLASS="syntax">typedef struct {
byte 		LA_colorFlag;
RGBValue 		LA_color;
SysDrawMask 		LA_mask;
ColorMapMode 		LA_mapMode;
LineEnd 		LA_end;
LineJoin	 	LA_join;
LineStyle 		LA_style;
WWFixed 		LA_width;
} LineAttr;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_25.htm_IX_LineEnd">
 </A>
<A NAME="S_25.htm_IX_LE_&ldots;">
 </A>
<A NAME="S_25.htm_IX_LAST_LINE_END_TYPE">
 </A>
<H1 CLASS="refHeading">
LineEnd</H1>
<PRE CLASS="syntax">typedef ByteEnum LineEnd;
#define LE_BUTTCAP				0
#define LE_ROUNDCAP				1
#define LE_SQUARECAP 				2
#define LAST_LINE_END_TYPE				LE_SQUARECAP</PRE>
<P>
Line ends determine how the graphics system will draw the end of a line segment.</P>
</DIV>
<DIV>
<A NAME="S_25.htm_IX_LineJoin">
 </A>
<A NAME="S_25.htm_IX_LJ_&ldots;">
 </A>
<A NAME="S_25.htm_IX_LAST_LINE_JOIN_TYPE">
 </A>
<H1 CLASS="refHeading">
LineJoin</H1>
<PRE CLASS="syntax">typedef ByteEnum LineJoin;
#define LJ_MITERED					0
#define LJ_ROUND					1
#define LJ_BEVELED					2
#define LAST_LINE_JOIN_TYPE					LJ_BEVELED</PRE>
<P>
This enumerated type determines how the graphics system will draw corners of rectangles and polylines.</P>
</DIV>
<DIV>
<A NAME="S_25.htm_IX_MAX_DASH_ARRAY_PAIRS">
 </A>
<A NAME="S_25.htm_IX_DashPairArray">
 </A>
<A NAME="S_25.htm_IX_LineStyle">
 </A>
<A NAME="S_25.htm_IX_LS_&ldots;">
 </A>
<H1 CLASS="refHeading">
LineStyle</H1>
<PRE CLASS="syntax">typedef ByteEnum LineStyle;
#define LS_SOLID					0
#define LS_DASHED 					1
#define LS_DOTTED 					2
#define LS_DASHDOT 					3
#define LS_DASHDDOT 					4
#define LS_CUSTOM 					5
#define MAX_DASH_ARRAY_PAIRS 					5</PRE>
<P>
The <CODE>
LineStyle</CODE>
 type describes a line's &quot;dottedness.&quot; Lines using custom dashes will work with the <CODE>
DashPairArray</CODE>
 structure:</P>
<PRE>typedef word    DashPairArray[MAX_DASH_ARRAY_PAIRS*2];</PRE>
</DIV>
<DIV>
<A NAME="S_25.htm_IX_LMemBlockHeader">
 </A>
<A NAME="S_25.htm_IX_LMBH_&ldots;">
 </A>
<H1 CLASS="refHeading">
LMemBlockHeader</H1>
<PRE CLASS="syntax">typedef struct {
MemHandle		LMBH_handle;
word		LMBH_offset;
word		LMBH_flags;
LMemTypes		LMBH_lmemType;
word		LMBH_blockSize;
word		LMBH_nHandles;
word		LMBH_freeList;
word		LMBH_totalFree;
} LMemBlockHeader;</PRE>
<P>
This structure is found at the beginning of every block which contains an LMem heap. You can examine any of the fields by locking the block and casting its address to a <CODE>
*LMemBlockHeader</CODE>
. You should not, however, change any of the fields yourself; they are managed by the LMem routines.</P>
<P CLASS="refField"><STRONG>
Contents:</STRONG>	The header has the following fields:</P>
<DL>
<DT>
LMBH<CODE>
_handle</DT><DD>
</CODE>
The handle of this block.</DD>
<DT>
LMBH<CODE>
_offset</DT><DD>
</CODE>
The offset from the beginning of the block to the beginning of the heap.</DD>
<DT>
LMBH<CODE>
_flags</DT><DD>
</CODE>
The <CODE>
LocalMemoryFlags</CODE>
 currently set for the block. The flags are described in the entry for <CODE>
<A HREF="../../CRef/Routines/R_64.htm#IX_LMemInitHeap()">LMemInitHeap()</A></CODE>
.</DD>
<DT>
LMBH<CODE>
_lmemType</DT><DD>
</CODE>
The type of LMem heap in this block. This field is a member of the <CODE>
LMemType</CODE>
 enumerated type, described in the entry for <CODE>
<A HREF="../../CRef/Routines/R_64.htm#IX_LMemInitHeap()">LMemInitHeap()</A></CODE>
.</DD>
<DT>
LMBH<CODE>
_blockSize</DT><DD>
</CODE>
The total size of this block. This size may change in either direction as a result of chunk allocation and heap compaction.</DD>
<DT>
LMBH<CODE>
_nHandles</DT><DD>
</CODE>
The number of handles available in the chunk handle table. Not all of these chunks are necessarily allocated as owned or free chunks. The table grows automatically when necessary.</DD>
<DT>
LMBH<CODE>
_freeList</DT><DD>
</CODE>
The chunk handle of the first free chunk in the linked list of free chunks.</DD>
<DT>
LMBH<CODE>
_totalFree</DT><DD>
</CODE>
The total amount of free space in the LMem heap.</DD>
</DL>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	Do not change the settings of the <CODE>
LMemBlockHeader</CODE>
. They are automatically maintained by the LMem routines.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
lmem.h</STRONG>
 </P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_64.htm#IX_LMemInitHeap()">LMemInitHeap()</A></CODE>.</P>
</DIV>
<HR>
<A NAME="S_26.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="S_26.htm_IX_LMemType">
 </A>
<A NAME="S_26.htm_IX_LMEM_TYPE_&ldots;">
 </A>
<H1 CLASS="refHeading">
LMemType</H1>
<PRE CLASS="syntax">typdef enum {
LMEM_TYPE_GENERAL,
LMEM_TYPE_WINDOW,
LMEM_TYPE_OBJ_BLOCK,
LMEM_TYPE_GSTATE,
LMEM_TYPE_FONT_BLK,
LMEM_TYPE_GSTRING,
LMEM_TYPE_DB_ITEMS
} LMemType;</PRE>
<P>
LMem heaps are created for many different purposes. Some of these purposes require the heap to have special functionality. For this reason, when you create an LMem heap, you must specify what it will be used for. The following types are available:</P>
<DL>
<DT>
LMEM_TYPE_GENERAL</DT><DD>
The LMem heap will be used for general data storage, possibly including a chunk, name, or element array. When an application creates an LMem heap, it will almost always be of type &quot;General&quot; or &quot;Object.&quot;</DD>
<DT>
LMEM_TYPE_OBJ_BLOCK</DT><DD>
Objects are stored in object blocks, which are LMem heaps. An object block has some extra header information and contains one chunk which contains only flags. All the objects in the block are stored as chunks on the heap. Applications can directly create object blocks.</DD>
<DT>
LMEM_TYPE_WINDOW</DT><DD>
Windows are stored in memory as LMem heaps. The header contains information about the window; each region in the window is stored as a chunk. Applications will not directly create Window heaps.</DD>
<DT>
LMEM_TYPE_GSTATE</DT><DD>
A GState is an LMem heap. The GState information is in the header, and the application clip-rectangle is stored in a chunk. Applications do not directly create GState blocks; rather, they call a GState creation routine, which creates the block.</DD>
<DT>
LMEM_TYPE_FONT_BLOCK</DT><DD>
Font blocks are stored as LMem heaps. Applications do not create font blocks directly.</DD>
<DT>
LMEM_TYPE_GSTRING</DT><DD>
Whenever a GString is created or loaded, a GString LMem heap is created, and elements are added as chunks. The heap is created automatically by the GString routines; applications should not create GString blocks.</DD>
<DT>
LMEM_TYPE_DB_ITEMS</DT><DD>
The Virtual Memory mechanism provides routines to create and manage database items, short pieces of data which are dynamically allocated and are saved with the VM file. Applications do not directly allocate DB blocks; rather, they call DB routines, which see to it that the blocks are created. </DD>
</DL>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
lmem.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="S_26.htm_IX_LocalDistanceFlags">
 </A>
<A NAME="S_26.htm_IX_LDF_&ldots;">
 </A>
<H1 CLASS="refHeading">
LocalDistanceFlags</H1>
<PRE CLASS="syntax">typedef WordFlags LocalDistanceFlags;
#define LDF_FULL_NAMES							0x8000
#define LDF_PRINT_PLURAL_IF_NEEDED							0x4000</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_26.htm_IX_LocalCmpStringsDosToGeosFlags">
 </A>
<H1 CLASS="refHeading">
LocalCmpStringsDosToGeosFlags</H1>
<P>
See <CODE>
<A HREF="../../CRef/Routines/R_66.htm#IX_LocalCmpStringsDosToGeos()">LocalCmpStringsDosToGeos()</A></CODE>
.</P>
</DIV>
<DIV>
<A NAME="S_26.htm_IX_currencyFormatFlags (LocalCurrencyFormat structure field)">
 </A>
<A NAME="S_26.htm_IX_currencyDigits (LocalCurrencyFormat structure format)">
 </A>
<A NAME="S_26.htm_IX_thousandsSeperator (LocalCurrencyFormat structure field)">
 </A>
<A NAME="S_26.htm_IX_decimalSeperator (LocalCurrencyFormat structure field)">
 </A>
<A NAME="S_26.htm_IX_LocalCurrencyFormat">
 </A>
<A NAME="S_26.htm_IX_listSeperator (LocalCurrencyFormat structure field)">
 </A>
<H1 CLASS="refHeading">
LocalCurrencyFormat</H1>
<PRE CLASS="syntax">typedef struct {
byte	currencyFormatFlags;
byte	currencyDigits;
word	thousandsSeparator;
word	decimalSeparator;
word	listSeparator;
} LocalCurrencyFormat;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_26.htm_IX_LocalMemoryFlags">
 </A>
<A NAME="S_26.htm_IX_LMF_&ldots;">
 </A>
<A NAME="S_26.htm_IX_STD_LMEM_OBJECT_FLAGS">
 </A>
<H1 CLASS="refHeading">
LocalMemoryFlags</H1>
<PRE CLASS="syntax">typedef WordFlags LocalMemoryFlags;
#define LMF_HAS_FLAGS				0x8000
#define LMF_IN_RESOURCE 				0x4000
#define LMF_DETACHABLE 				0x2000
#define LMF_DUPLICATED 				0x1000
#define LMF_RELOCATED 				0x0800
#define LMF_AUTO_FREE 				0x0400
#define LMF_IN_LMEM_ALLOC 				0x0200
#define LMF_IS_VM				0x0100
#define LMF_NO_HANDLES 				0x0080
#define LMF_NO_ENLARGE 				0x0040
#define LMF_RETURN_ERRORS 				0x0020
#define LMF_DEATH_COUNT 				0x0007
#define STD_LMEM_OBJECT_FLAGS						(LMF_HAS_FLAGS | LMF_RELOCATED)</PRE>
<P>
When an LMem heap is allocated, certain flags are passed to indicate properties the heap should have. Some of the flags are passed only for system-created heaps. The flags are stored in a word-length record (<CODE>
LocalMemoryFlags</CODE>
); the record also contains flags indicating the current state of the heap. The <CODE>
LocalMemoryFlags</CODE>
 are listed below:</P>
<DL>
<DT>
LMF_HAS_FLAGS</DT><DD>
Set if the block has a chunk containing only flags. This flag is set for object blocks; it is usually cleared for general LMem heaps.</DD>
<DT>
LMF_IN_RESOURCE</DT><DD>
Set if the block has just been loaded from a resource and has not been changed since being loaded. This flag is set only for object blocks created by the compiler.</DD>
<DT>
LMF_DETACHABLE</DT><DD>
Set if the block is an object block which can be saved to a state file.</DD>
<DT>
LMF_DUPLICATED</DT><DD>
Set if block is an object block created by the <CODE>
<A HREF="../../CRef/Routines/R_78.htm#IX_ObjDuplicateResource()">ObjDuplicateResource()</A></CODE>
 routine. This flag should not be set by applications.</DD>
<DT>
LMF_RELOCATED</DT><DD>
Set if all the objects in the block have been relocated. The object system sets this when it has relocated all the objects in the block. </DD>
<DT>
LMF_AUTO_FREE</DT><DD>
This flag is used by several object routines. It indicates that if the block's in-use count drops to zero, the block may be freed. This flag should not be set by applications.</DD>
<DT>
LMF_IN_MEM_ALLOC</DT><DD>
This flag is used in error-checking code to prevent the heap from being validated while a chunk is being allocated. For internal use only--do not modify<EM>
.</EM>
</DD>
<DT>
LMF_IS_VM</DT><DD>
Set if the LMem heap is in a VM block and the block should be marked dirty whenever a chunk is marked dirty. This flag is automatically set by the VM code when an LMem heap is created in or attached to a VM file. This flag should not be set by applications.</DD>
<DT>
LMF_NO_HANDLES</DT><DD>
Set if block does not use chunk handles. A block can be set to simulate the C <CODE>
malloc() </CODE>
routine; in this case, chunks are not relocated after being created, so chunk handles are not needed. Ordinarily, these blocks are created by the <CODE>
<A HREF="../../CRef/Routines/R_6a.htm#IX_malloc()">malloc()</A></CODE>
 routine, not by applications.</DD>
<DT>
LMF_NO_ENLARGE</DT><DD>
Indicates that the local-memory routines should not enlarge this block to fulfill chunk requests. This guarantees that the block will not be moved by a chunk allocation request; however, it makes these requests more likely to fail.</DD>
<DT>
LMF_RETURN_ERRORS</DT><DD>
Set if local memory routines should return errors when allocation requests cannot be fulfilled. If the flag is not set, allocation routines will fatal-error if they cannot comply with requests. This flag is generally clear for expandable LMem blocks, since many system routines (such as <CODE>
<A HREF="../../CRef/Routines/R_7a.htm#IX_ObjInstantiate()">ObjInstantiate()</A></CODE>
) are optimized in such a way that they cannot deal with LMem allocation errors.</DD>
<DT>
LMF_DEATH_COUNT</DT><DD>
This field occupies the least significant three bits of the flag field. It means nothing if the value is zero. If it is non-zero, it indicates the number of remove-block messages left which must hit <CODE>
BlockDeathCommon</CODE>
 before it will free the block. This flag is used by error-checking code in the kernel.</DD>
<DT>
STD_LMEM_OBJ_FLAGS</DT><DD>
This is a constant which combines the LMF_HAS_FLAGS and LMF_RELOCATED flags. These flags should be set for all object blocks.</DD>
</DL>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
lmem.h</STRONG>
 </P>
</DIV>
<HR>
<A NAME="S_27.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="S_27.htm_IX_LocalNumericFormat">
 </A>
<A NAME="S_27.htm_IX_numberFormatFlags (LocalNumericFormat structure field)">
 </A>
<A NAME="S_27.htm_IX_decimalDigits (LocalNumericFormat structure field)">
 </A>
<A NAME="S_27.htm_IX_thousandsSeparator (LocalNumericFormat structure field)">
 </A>
<A NAME="S_27.htm_IX_decimalSeperator (LocalNumericFormat structure field)">
 </A>
<A NAME="S_27.htm_IX_listSeparator (LocalNumericFormat structure field)">
 </A>
<H1 CLASS="refHeading">
LocalNumericFormat</H1>
<PRE CLASS="syntax">typedef struct {
byte	numberFormatFlags;
byte	decimalDigits;
word	thousandsSeparator;
word	decimalSeparator;
word	listSeparator;
} LocalNumericFormat;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_27.htm_IX_endDouble (LocalQuotes structure field)">
 </A>
<A NAME="S_27.htm_IX_LocalQuotes">
 </A>
<A NAME="S_27.htm_IX_frontSingle (LocalQuotes structure field)">
 </A>
<A NAME="S_27.htm_IX_endSingle (LocalQuotes structure field)">
 </A>
<A NAME="S_27.htm_IX_frontDouble (LocalQuotes structure field)">
 </A>
<H1 CLASS="refHeading">
LocalQuotes</H1>
<PRE CLASS="syntax">typedef struct {
word	frontSingle;
word	endSingle;
word	frontDouble;
word	endDouble;
} LocalQuotes;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_27.htm_IX_ManufacturerFromFormatID() macro">
 </A>
<H1 CLASS="refHeading">
ManufacturerFromFormatID</H1>
<PRE CLASS="syntax">ManufacturerID ManufacturerFromFormatID(type);
        ClipboardItemFormatID			type;</PRE>
<P>
This macro extracts the manufacturer ID from the given clipboard format ID and manufacturer value.</P>
</DIV>
<DIV>
<A NAME="S_27.htm_IX_ManufacturerID">
 </A>
<A NAME="S_27.htm_IX_MANUFACTURER_ID_&ldots;">
 </A>
<H1 CLASS="refHeading">
ManufacturerID</H1>
<PRE CLASS="syntax">typedef word ManufacturerID
#define MANUFACTURER_ID_GEOWORKS									 0
#define MANUFACTURER_ID_APP_LOCAL									 1
#define MANUFACTURER_ID_DOS_LAUNCHER									 5
#define MANUFACTURER_ID_SDK									 8
#define MANUFACTURER_ID_GENERIC									10</PRE>
<P>
While <CODE>geode.h</CODE> defines many other <CODE>ManufacturerID</CODE>s for specific developers, the only one of these which is useful to know about when developing for the Nokia 9000i communicator is <CODE>MANUFACTURER_ID_NOKIA</CODE>.</P>
<P>
Each company should have its own manufacturer ID which is unique to the company and ensures that its applications' GeodeTokens do not conflict with those of other manufacturers. If you don't have a manufacturer ID but think you should, <A HREF = "mailto:orders@geoworks.com">contact</A> Geoworks Developer Support. </P>
</DIV>
<DIV>
<A NAME="S_27.htm_IX_MapColorToMono">
 </A>
<A NAME="S_27.htm_IX_CMT_&ldots;  (MapColorToMono types)">
 </A>
<H1 CLASS="refHeading">
MapColorToMono</H1>
<PRE CLASS="syntax">typedef ByteEnum MapColorToMono;
#define CMT_CLOSEST				0
#define CMT_DITHER 				1</PRE>
<P>
This type determines what the graphics system will do when trying to draw in an unavailable color. It will either draw in the closest color, or else mix two or more close colors to get as close as possible overall.</P>
</DIV>
<DIV>
<A NAME="S_27.htm_IX_MapListBlockHeader">
 </A>
<A NAME="S_27.htm_IX_MLBH_&ldots;">
 </A>
<H1 CLASS="refHeading">
MapListBlockHeader</H1>
<PRE CLASS="syntax">typedef struct {
LMemBlockHeader				MLBH_base;
word				MLBH_numDestFields;
word				MLBH_chunk1;
} MapListBlockHeader;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_27.htm_IX_leftMargin (MarginDimensions structure field)">
 </A>
<A NAME="S_27.htm_IX_topMargin (MarginDimensions structure field)">
 </A>
<A NAME="S_27.htm_IX_rightMargin (MarginDimensions structure field)">
 </A>
<A NAME="S_27.htm_IX_bottomMargin (MarginDimensions structure field)">
 </A>
<H1 CLASS="refHeading">
MarginDimensions</H1>
<PRE CLASS="syntax">typedef struct {
int	leftMargin;
int	topMargin;
int	rightMargin;
int	bottomMargin;
} MarginDimensions;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_27.htm_IX_MAX_FIELD_NAME_LENGTH">
 </A>
<H1 CLASS="refHeading">
MAX_FIELD_NAME_LENGTH</H1>
<PRE CLASS="syntax">#define MAX_FIELD_NAME_LENGTH					40</PRE>
<P>
Maximum size of a field name in a datastore. See <CODE>
<A HREF="../../CRef/Routines/R_f.htm#IX_DataStoreAddField()">DataStoreAddField()</A></CODE>
.</P>
</DIV>
<DIV>
<A NAME="S_27.htm_IX_MeasurementType">
 </A>
<A NAME="S_27.htm_IX_MEASURE_&ldots;">
 </A>
<H1 CLASS="refHeading">
MeasurementType</H1>
<PRE CLASS="syntax">typedef ByteEnum MeasurementType;
#define MEASURE_US				0
#define MEASURE_METRIC				1</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_27.htm_IX_MediaType">
 </A>
<A NAME="S_27.htm_IX_MEDIA_&ldots;">
 </A>
<H1 CLASS="refHeading">
MediaType</H1>
<PRE CLASS="syntax">typedef enum /* byte */ {
#define MEDIA_NONEXISTENT				0
#define MEDIA_160K 				1
#define MEDIA_180K 				2
#define MEDIA_320K 				3
#define MEDIA_360K 				4
#define MEDIA_720K 				5
#define MEDIA_1M2 				6
#define MEDIA_1M44 				7
#define MEDIA_2M88 				8
#define MEDIA_FIXED_DISK 				9
#define MEDIA_CUSTOM 				10
} MediaType;</PRE>
<P>
The <CODE>
MediaType</CODE>
 enumerated type indicates how a disk is formatted. A member of this enumerated type is returned by some disk-information routines (e.g. <CODE>
<A HREF="../../CRef/Routines/R_1d.htm#IX_DriveGetDefaultMedia()">DriveGetDefaultMedia()</A></CODE>
). A <CODE>
MediaType</CODE>
 value is also passed to <CODE>
<A HREF="../../CRef/Routines/R_1a.htm#IX_DiskFormat()">DiskFormat()</A></CODE>
, indicating how the disk should be formatted.</P>
</DIV>
<DIV>
<A NAME="S_27.htm_IX_MediumAndUnit">
 </A>
<H1 CLASS="refHeading">
MediumAndUnit</H1>
<PRE CLASS="syntax">typedef struct {
            MediumType 		MU_medium;
            MediumUnitType 		MU_unitType;
            word 		MU_unit;
} MediumAndUnit;</PRE>
<P>
This structure represents an instance of some communication medium-generally this corresponds to some hardware port or peripheral device.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
medium.h</STRONG>
 </P>
</DIV>
<HR>
<A NAME="S_28.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="S_28.htm_IX_MediumUnitType">
 </A>
<H1 CLASS="refHeading">
MediumUnitType</H1>
<PRE CLASS="syntax">typedef ByteEnum MediumUnitType;
        #define MUT_NONE      0x0
        #define MUT_INT       0x1
        #define MUT_MEM_BLOCK 0x2
        #define MUT_ANY       0x3</PRE>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
medium.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="S_28.htm_IX_MediumType">
 </A>
<H1 CLASS="refHeading">
MediumType</H1>
<PRE CLASS="syntax">typedef struct {
            word            MET_id;
            ManufacturerID  MET_manuf;
} MediumType;</PRE>
<P>
This structure represents a communication medium. Several standard media may be represented with a <CODE>
MET_manuf</CODE>
 of MANUFACTURER_ID_GEOWORKS and a <CODE>
GeoworksMediumID</CODE>
 in <CODE>
MET_id</CODE>
.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
medium.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="S_28.htm_IX_MemGetInfoType">
 </A>
<H1 CLASS="refHeading">
MemGetInfoType</H1>
<P>
See <CODE>
<A HREF="../../CRef/Routines/R_6c.htm#IX_MemGetInfo()">MemGetInfo()</A></CODE>
.</P>
</DIV>
<DIV>
<A NAME="S_28.htm_IX_MemHandle">
 </A>
<H1 CLASS="refHeading">
MemHandle</H1>
<PRE CLASS="syntax">typedef Handle MemHandle;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_28.htm_IX_Message">
 </A>
<A NAME="S_28.htm_IX_MSG_&ldots;">
 </A>
<H1 CLASS="refHeading">
Message</H1>
<PRE CLASS="syntax">typedef word Message;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_28.htm_IX_MessageError">
 </A>
<A NAME="S_28.htm_IX_MESSAGE_NO_&ldots;">
 </A>
<H1 CLASS="refHeading">
MessageError</H1>
<PRE CLASS="syntax">typedef enum /* word */ {
 MESSAGE_NO_ERROR,				/* no error was encountered */
 MESSAGE_NO_HANDLES				/* no handle could be allocated
				 * and MF_CAN_DISCARD_IF_DESPARATE
				 * was passed */</PRE>
<PRE CLASS="syntax">} MessageErrors;</PRE>
<P>
A <CODE>
MessageError</CODE>
 is returned by the assembly routine <CODE>
ObjMessage()</CODE>
 in assembly to indicate whether the message was successfully sent. This is not encountered by C applications.</P>
</DIV>
<DIV>
<A NAME="S_28.htm_IX_MessageFlags">
 </A>
<A NAME="S_28.htm_IX_MF_&ldots;">
 </A>
<H1 CLASS="refHeading">
MessageFlags</H1>
<PRE CLASS="syntax">typedef WordFlags MessageFlags;
#define MF_CALL							0x8000			/* @call */
#define MF_FORCE_QUEUE 							0x4000
#define MF_STACK							0x2000			/* @stack */
#define MF_CHECK_DUPLICATE 							0x0800
#define MF_CHECK_LAST_ONLY 							0x0400
#define MF_REPLACE 							0x0200
#define MF_CUSTOM							0x0100
#define MF_FIXUP_DS 							0x0080
#define MF_FIXUP_ES 							0x0040
#define MF_DISCARD_IF_NO_MATCH 							0x0020
#define MF_MATCH_ALL 							0x0010
#define MF_INSERT_AT_FRONT 							0x0008			/* puts at front of queue */
#define MF_CAN_DISCARD_IF_DESPERATE 							0x0004
#define MF_RECORD 							0x0002			/* @record */
#define MF_DISPATCH_DONT_FREE 							0x0002</PRE>
<P>
<CODE>
MessageFlags</CODE>
 are specified in the assembly routine <CODE>
ObjMessage()</CODE>
. Most of these flags are set properly by Goc and the kernel in C. See the reference entries for the Goc keywords <CODE>
@call</CODE>
 and <CODE>
@send</CODE>
.</P>
</DIV>
<DIV>
<A NAME="S_28.htm_IX_MessageHandle">
 </A>
<H1 CLASS="refHeading">
MessageHandle</H1>
<PRE CLASS="syntax">typedef Handle MessageHandle;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_28.htm_IX_MessageMethod()">
 </A>
<H1 CLASS="refHeading">
MessageMethod</H1>
<PRE CLASS="syntax">typedef void	 MessageMethod();</PRE>
<P>
Goc uses this type when building up method tables for classes.</P>
</DIV>
<DIV>
<A NAME="S_28.htm_IX_MinIncrementType">
 </A>
<A NAME="S_28.htm_IX_MIT_&ldots;">
 </A>
<H1 CLASS="refHeading">
MinIncrementType</H1>
<PRE CLASS="syntax">typedef union {
MinUSMeasure				MIT_US;
MinMetricMeasure				MIT_METRIC;
MinPointMeasure				MIT_POINT;
MinPicaMeasure				MIT_PICA;
} MinIncrementType;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_28.htm_IX_MinMetricMeasure">
 </A>
<A NAME="S_28.htm_IX_MMM_&ldots;">
 </A>
<H1 CLASS="refHeading">
MinMetricMeasure</H1>
<PRE CLASS="syntax">typedef ByteEnum MinMetricMeasure;
#define MMM_MILLIMETER					0
#define MMM_HALF_CENTIMETER					1
#define MMM_CENTIMETER 					2</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_28.htm_IX_MinPicaMeasure">
 </A>
<A NAME="S_28.htm_IX_MPM (MinPicaMeasure type)">
 </A>
<H1 CLASS="refHeading">
MinPicaMeasure</H1>
<PRE CLASS="syntax">typedef ByteEnum MinPicaMeasure;
#define MPM_PICA					0
#define MPM_INCH					1</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_28.htm_IX_MinPointMeasure">
 </A>
<H1 CLASS="refHeading">
MinPointMeasure</H1>
<PRE CLASS="syntax">typedef ByteEnum MinPointMeasure;
#define MPM_25_POINT					0
#define MPM_50_POINT					1
#define MPM_100_POINT					2</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_28.htm_IX_MinUSMeasure">
 </A>
<A NAME="S_28.htm_IX_MUSM_&ldots;">
 </A>
<H1 CLASS="refHeading">
MinUSMeasure</H1>
<PRE CLASS="syntax">typedef ByteEnum MinUSMeasure;
#define MUSM_EIGHTH_INCH					0
#define MUSM_QUARTER_INCH					1
#define MUSM_HALF_INCH 					2
#define MUSM_ONE_INCH 					3</PRE>
<P>
&nbsp;</P>
</DIV>
<HR>
<A NAME="S_29.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="S_29.htm_IX_MixMode">
 </A>
<A NAME="S_29.htm_IX_MM_&ldots;">
 </A>
<H1 CLASS="refHeading">
MixMode</H1>
<PRE CLASS="syntax">typedef ByteEnum MixMode;
#define MM_CLEAR			0	/* clear destination */
#define MM_COPY			1	/* new drawing is opaque */
#define MM_NOP 			2	/* no drawing */
#define MM_AND 			3	/* logical AND of new and old colors */
#define MM_INVERT 4				/* inverse of old color */
#define MM_XOR 			5	/* XOR of new and old colors */
#define MM_SET 			6	/* set destination black */
#define MM_OR 			7	/* logical OR of new and old colors */</PRE>
<P>
The <CODE>
MixMode</CODE>
 determines what the graphics system will do when drawing one thing on top of another.</P>
</DIV>
<DIV>
<A NAME="S_29.htm_IX_ModemResultCode">
 </A>
<H1 CLASS="refHeading">
ModemResultCode</H1>
<PRE CLASS="syntax">typedef enum {
MRC_NOT_SUPPORTED = 1,
MRC_DRIVER_IN_USE,
MRC_TIMEOUT,
MRC_UNKNOWN_RESPONSE,
MRC_OK,
RC_ERROR,
MRC_BUSY,
MRC_NO_DIALTONE,
MRC_NO_ANSWER,
MRC_NO_CARRIER,
MRC_CONNECT,
MRC_CONNECT_1200,
MRC_CONNECT_2400,
MRC_CONNECT_4800,
MRC_CONNECT_9600,
MRC_BLACKLISTED,
MRC_DELAYED,
} ModemResultCode;</PRE>
<P>
Error codes returned by modem routines.</P>
</DIV>
<DIV>
<A NAME="S_29.htm_IX_MonoTransfer">
 </A>
<A NAME="S_29.htm_IX_MT_gray[]">
 </A>
<H1 CLASS="refHeading">
MonoTransfer</H1>
<PRE CLASS="syntax">typedef struct {
byte MT_gray[256];
} MonoTransfer;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_29.htm_IX_MouseReturnFlags">
 </A>
<A NAME="S_29.htm_IX_MRF_&ldots;">
 </A>
<H1 CLASS="refHeading">
MouseReturnFlags</H1>
<PRE CLASS="syntax">typedef WordFlags MouseReturnFlags;
#define MRF_PROCESSED							0x8000
#define MRF_REPLAY 							0x4000
#define MRF_PREVENT_PASS_THROUGH 							0x2000
#define MRF_SET_POINTER_IMAGE 							0x1000
#define MRF_CLEAR_POINTER_IMAGE 							0x0800</PRE>
<P>
These flags are used in various parts of the system that work with mouse input. Which values are appropriate to pass will vary based on context.</P>
</DIV>
<DIV>
<A NAME="S_29.htm_IX_MouseReturnParams">
 </A>
<H1 CLASS="refHeading">
MouseReturnParams</H1>
<PRE CLASS="syntax">typedef struct {
word 				unused;
MouseReturnFlags 				flags;
optr 				ptrImage;
} MouseReturnParams;</PRE>
<P>
This structure is used in certain areas of the system which work with mouse input.</P>
</DIV>
<DIV>
<A NAME="S_29.htm_IX_NameArrayAddFlags">
 </A>
<A NAME="S_29.htm_IX_NAAF_SET_DATA_ON_REPLACE">
 </A>
<H1 CLASS="refHeading">
NameArrayAddFlags</H1>
<PRE CLASS="syntax">typedef WordFlags NameArrayAddFlags;
#define NAAF_SET_DATA_ON_REPLACE 0x8000</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_29.htm_IX_NameArrayElement">
 </A>
<A NAME="S_29.htm_IX_NAE_meta">
 </A>
<H1 CLASS="refHeading">
NameArrayElement</H1>
<PRE CLASS="syntax">typedef struct {
RefElementHeader NAE_meta;
} NameArrayElement;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_29.htm_IX_NameArrayHeader">
 </A>
<A NAME="S_29.htm_IX_NAH_&ldots;">
 </A>
<H1 CLASS="refHeading">
NameArrayHeader</H1>
<PRE CLASS="syntax">typedef struct{
ElementArrayHeader				NAH_meta;
word				NAH_dataSize;					/* Size of data section of
									 * each element */</PRE>
<PRE CLASS="syntax">} NameArrayHeader;</PRE>
<P>
Every name array must begin with a <CODE>
NameArrayHeader</CODE>
. Since name arrays are special kinds of element arrays, the <CODE>
NameArrayHeader</CODE>
 must itself begin with an <CODE>
ElementArrayHeader</CODE>
. The structure contains one additional field, <CODE>
NAH_dataSize</CODE>
. This field specifies how long the data section of every element is. Applications may examine this field, but they must not change it.</P>
</DIV>
<DIV>
<A NAME="S_29.htm_IX_NameArrayMaxElement">
 </A>
<A NAME="S_29.htm_IX_NAME_&ldots;">
 </A>
<A NAME="S_29.htm_IX_NAME_ARRAY_MAX_DATA_SIZE">
 </A>
<A NAME="S_29.htm_IX_NAME_ARRAY_MAX_NAME_SIZE">
 </A>
<H1 CLASS="refHeading">
NameArrayMaxElement</H1>
<PRE CLASS="syntax">typedef struct {
RefElementHeader NAME_meta;
byte NAME_data[NAME_ARRAY_MAX_DATA_SIZE];
char NAME_name[NAME_ARRAY_MAX_NAME_SIZE];
} NameArrayMaxElement;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_29.htm_IX_NO_ERROR_RETURNED">
 </A>
<H1 CLASS="refHeading">
NO_ERROR_RETURNED</H1>
<PRE CLASS="syntax">#define NO_ERROR_RETURNED				0</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_29.htm_IX_NoteType">
 </A>
<A NAME="S_29.htm_IX_NT_&ldots;  (NoteType type)">
 </A>
<H1 CLASS="refHeading">
NoteType</H1>
<PRE CLASS="syntax">typedef ByteEnum NoteType;
#define NT_INK			0
#define NT_TEXT			1</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_29.htm_IX_NotificationType">
 </A>
<A NAME="S_29.htm_IX_NT_&ldots;  (NotificationType structure)">
 </A>
<H1 CLASS="refHeading">
NotificationType</H1>
<PRE CLASS="syntax">typedef struct {
ManufacturerID			NT_manuf;
word			NT_type;
} NotificationType;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_29.htm_IX_NotifyInkHasTarget">
 </A>
<A NAME="S_29.htm_IX_NIHT_&ldots;">
 </A>
<H1 CLASS="refHeading">
NotifyInkHasTarget</H1>
<PRE CLASS="syntax">typedef struct {
optr	NIHT_optr;
} NotifyInkHasTarget;</PRE>
<P>
&nbsp;</P>
</DIV>
<HR>
<A NAME="S_2a.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="S_2a.htm_IX_NULL">
 </A>
<H1 CLASS="refHeading">
NULL</H1>
<PRE CLASS="syntax">#undef NULL
#define NULL		0</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_2a.htm_IX_NullChunk">
 </A>
<H1 CLASS="refHeading">
NullChunk</H1>
<PRE CLASS="syntax">#define NullChunk		((ChunkHandle) 0)</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_2a.htm_IX_NullClass">
 </A>
<H1 CLASS="refHeading">
NullClass</H1>
<PRE CLASS="syntax">#define NullClass		((ClassStruct *) 0)</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_2a.htm_IX_NullHandle">
 </A>
<H1 CLASS="refHeading">
NullHandle</H1>
<PRE CLASS="syntax">#define NullHandle		((Handle) 0)</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_2a.htm_IX_NullOptr">
 </A>
<H1 CLASS="refHeading">
NullOptr</H1>
<PRE CLASS="syntax">#define NullOptr		((optr) 0)</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_2a.htm_IX_NumberFormatFlags">
 </A>
<A NAME="S_2a.htm_IX_NFF_LEADING_ZERO">
 </A>
<H1 CLASS="refHeading">
NumberFormatFlags</H1>
<PRE CLASS="syntax">typedef ByteFlags NumberFormatFlags;
#define NFF_LEADING_ZERO				0x01</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_2a.htm_IX_NumberType">
 </A>
<A NAME="S_2a.htm_IX_NT_&ldots;  (NumberType type)">
 </A>
<H1 CLASS="refHeading">
NumberType</H1>
<PRE CLASS="syntax">typedef ByteEnum NumberType;
#define NT_VALUE				0
#define NT_BOOLEAN				1
#define NT_DATE_TIME				2</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_2a.htm_IX_ObjChunkFlags">
 </A>
<A NAME="S_2a.htm_IX_OCF_&ldots;">
 </A>
<H1 CLASS="refHeading">
ObjChunkFlags</H1>
<PRE CLASS="syntax">typedef ByteFlags ObjChunkFlags;
#define OCF_VARDATA_RELOC					0x10
#define OCF_DIRTY 					0x08
#define OCF_IGNORE_DIRTY 					0x04
#define OCF_IN_RESOURCE 					0x02
#define OCF_IS_OBJECT 					0x01</PRE>
<P>
This record is stored at the beginning of each chunk and gives specific information about the chunk. The flags are internal.</P>
</DIV>
<DIV>
<A NAME="S_2a.htm_IX_ObjLMemBlockHeader">
 </A>
<A NAME="S_2a.htm_IX_OLMBH_&ldots;">
 </A>
<H1 CLASS="refHeading">
ObjLMemBlockHeader</H1>
<PRE CLASS="syntax">typedef struct {
LMemBlockHeader			OLMBH_header;					/* standard LMem block header */
word			OLMBH_inUseCount;
word			OLMBH_interactibleCount;
optr			OLMBH_output;
word			OLMBH_resourceSize;
} ObjLMemBlockHeader;</PRE>
<P>
This is the standard Object Block header that begins every object block; you can set additional header fields with the <CODE>
@header</CODE>
 Goc keyword. The fields of this structure are</P>
<DL>
<DT>
<CODE>
OLMBH_header</DT><DD>
</CODE>
The standard LMem block header. See the <CODE>
LMemBlockHeader</CODE>
 structure type.</DD>
<DT>
<CODE>
OLMBH_inUseCount</DT><DD>
</CODE>
The &quot;in use&quot; count for the block. If not zero, then the block may not safely be freed.</DD>
<DT>
<CODE>
OLMBH_interactibleCount</DT><DD>
</CODE>
The &quot;interactable&quot; count for the block. If not zero, then one or more objects in the block are either visible to the user or about to be activated by the user (e.g. via keyboard shortcut). A block with a non-zero interactible count may not be swapped.</DD>
<DT>
<CODE>
OLMBH_output</DT><DD>
</CODE>
The optr of the object that will be notified about changes in resource status, such as in-use count changing to or from zero. Messages may also be sent to this output object via the <CODE>
TravelOption</CODE>
 TO_OBJ_BLOCK_OUTPUT.</DD>
<DT>
<CODE>
OLMBH_resourceSize</DT><DD>
</CODE>
The size of the object block (resource).</DD>
</DIV>
<DIV>
<A NAME="S_2a.htm_IX_ObjRelocation">
 </A>
<A NAME="S_2a.htm_IX_OR_&ldots;">
 </A>
</DL>
<H1 CLASS="refHeading">
ObjRelocation</H1>
<PRE CLASS="syntax">typedef struct {
ObjRelocationType				OR_type;
word				OR_offset;
} ObjRelocation;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_2a.htm_IX_ObjRelocationSource">
 </A>
<A NAME="S_2a.htm_IX_ORS_&ldots;">
 </A>
<A NAME="S_2a.htm_IX_RID_SOURCE_OFFSET">
 </A>
<H1 CLASS="refHeading">
ObjRelocationSource</H1>
<PRE CLASS="syntax">typedef ByteEnum ObjRelocationSource;
#define ORS_NULL								0
#define ORS_OWNING_GEODE 								1
#define ORS_KERNEL 								2
#define ORS_LIBRARY 								3
#define ORS_CURRENT_BLOCK 								4
#define ORS_VM_HANDLE 								5
#define ORS_OWNING_GEODE_ENTRY_POINT								6
#define ORS_NON_STATE_VM 								7
#define ORS_UNKNOWN_BLOCK 								8
#define ORS_EXTERNAL 								9
#define RID_SOURCE_OFFSET 								12</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_2a.htm_IX_ObjRelocationType">
 </A>
<A NAME="S_2a.htm_IX_RELOC_&ldots;">
 </A>
<H1 CLASS="refHeading">
ObjRelocationType</H1>
<PRE CLASS="syntax">typedef ByteEnum ObjRelocationType;
#define RELOC_END_OF_LIST						0
#define RELOC_RELOC_HANDLE						1
#define RELOC_RELOC_SEGMENT						2
#define RELOC_RELOC_ENTRY_POINT						3</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_2a.htm_IX_OperatorStackElement">
 </A>
<A NAME="S_2a.htm_IX_OSE_&ldots;">
 </A>
<H1 CLASS="refHeading">
OperatorStackElement</H1>
<PRE CLASS="syntax">typedef struct {
EvalStackOperatorType OSE_type;
EvalStackOperatorType OSE_data;
} OperatorStackElement;</PRE>
<P>
&nbsp;</P>
</DIV>
<HR>
<A NAME="S_2b.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="S_2b.htm_IX_OperatorType">
 </A>
<A NAME="S_2b.htm_IX_OP_&ldots;  (OperatorType)">
 </A>
<H1 CLASS="refHeading">
OperatorType</H1>
<PRE CLASS="syntax">typedef ByteEnum OperatorType;
#define OP_RANGE_SEPARATOR									0
#define OP_NEGATION 									1
#define OP_PERCENT 									2
#define OP_EXPONENTIATION 									3
#define OP_MULTIPLICATION 									4
#define OP_DIVISION 									5
#define OP_MODULO 									6
#define OP_ADDITION 									7
#define OP_SUBTRACTION 									8
#define OP_EQUAL 									9
#define OP_NOT_EQUAL 									10
#define OP_LESS_THAN 									11
#define OP_GREATER_THAN 									12
#define OP_LESS_THAN_OR_EQUAL 									13
#define OP_GREATER_THAN_OR_EQUAL 									14
#define OP_STRING_CONCAT 									15
#define OP_RANGE_INTERSECTION 									16
#define OP_NOT_EQUAL_GRAPHIC									17
#define OP_DIVISION_GRAPHIC 									18
#define OP_LESS_THAN_OR_EQUAL_GRAPHIC 									19
#define OP_GREATER_THAN_OR_EQUAL_GRAPHIC 									20
#define OP_PERCENT_MODULO 									21
#define OP_SUBTRACTION_NEGATION 									22</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_2b.htm_IX_optr">
 </A>
<H1 CLASS="refHeading">
optr</H1>
<PRE CLASS="syntax">typedef dword optr;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_2b.htm_IX_PageEndCommand">
 </A>
<A NAME="S_2b.htm_IX_PEC_&ldots;">
 </A>
<H1 CLASS="refHeading">
PageEndCommand</H1>
<PRE CLASS="syntax">typedef ByteEnum PageEndCommand;
        #define PEC_FORM_FEED 0
        #define PEC_NO_FORM_FEED 1</PRE>
<P>
This enumerated type is used to specify whether there should be a form feed at the end of a page. A form feed is almost always desired; however, a program such as a banner-printer might suppress the form feed.</P>
</DIV>
<DIV>
<A NAME="S_2b.htm_IX_PageLayout">
 </A>
<A NAME="S_2b.htm_IX_PL_&ldots;">
 </A>
<H1 CLASS="refHeading">
PageLayout</H1>
<PRE CLASS="syntax">typedef union {
PageLayoutPaper				PL_paper;
PageLayoutEnvelope				PL_envelope;
PageLayoutLabel				PL_label;
} PageLayout;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_2b.htm_IX_PageLayoutEnvelope">
 </A>
<A NAME="S_2b.htm_IX_PLE_&ldots;">
 </A>
<H1 CLASS="refHeading">
PageLayoutEnvelope</H1>
<PRE CLASS="syntax">typedef WordFlags PageLayoutEnvelope;
#define PLE_PATH				0x0040
#define PLE_ORIENTATION				0x0010
#define PLE_TYPE				0x0004</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_2b.htm_IX_PageLayoutLabel">
 </A>
<A NAME="S_2b.htm_IX_PLL_&ldots;">
 </A>
<H1 CLASS="refHeading">
PageLayoutLabel</H1>
<PRE CLASS="syntax">typedef WordFlags PageLayoutLabel;
#define PLL_ROWS				0x7e00			/* labels down */
#define PLL_COLUMNS				0x01f8			/* labels across */
#define PLL_TYPE				0x0004			/* PT_LABEL */</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_2b.htm_IX_PageLayoutPaper">
 </A>
<A NAME="S_2b.htm_IX_PLP_&ldots;">
 </A>
<H1 CLASS="refHeading">
PageLayoutPaper</H1>
<PRE CLASS="syntax">typedef WordFlags PageLayoutPaper;
#define PLP_ORIENTATION				0x0008
#define PLP_TYPE				0x0004</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_2b.htm_IX_PageSize">
 </A>
<A NAME="S_2b.htm_IX_PS_&ldots;">
 </A>
<H1 CLASS="refHeading">
PageSize</H1>
<PRE CLASS="syntax">typedef struct {
word		unused;
word		PS_width;
word		PS_height;
PageLayout		PS_layout;
} PageSize;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_2b.htm_IX_PageSizeCtrlAttrs">
 </A>
<A NAME="S_2b.htm_IX_PSCA_&ldots;">
 </A>
<H1 CLASS="refHeading">
PageSizeCtrlAttrs</H1>
<PRE CLASS="syntax">typedef WordFlags PageSizeCtrlAttrs;
#define PZCA_ACT_LIKE_GADGET					0x8000
#define PZCA_PAPER_SIZE					0x4000
#define PZCA_INITIALIZE					0x2000</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_2b.htm_IX_PSIZECF_&ldots;">
 </A>
<A NAME="S_2b.htm_IX_PageSizeCtrlFeatures">
 </A>
<H1 CLASS="refHeading">
PageSizeCtrlFeatures</H1>
<PRE CLASS="syntax">typedef ByteFlags PageSizeControlFeatures;
#define PSIZECF_MARGINS				0x04
#define PSIZECF_ALL 				0x02
#define PSIZECF_PAGE_TYPE				0x01</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_2b.htm_IX_PageSizeReport">
 </A>
<A NAME="S_2b.htm_IX_PSR_&ldots;">
 </A>
<H1 CLASS="refHeading">
PageSizeReport</H1>
<PRE CLASS="syntax">typedef struct {
dword 			PSR_width;
dword 			PSR_height;
PageLayout 			PSR_layout;
PCMarginParams			PSR_margins;
} PageSizeReport:</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_2b.htm_IX_PageType">
 </A>
<A NAME="S_2b.htm_IX_PT_&ldots;  (PageType type)">
 </A>
<H1 CLASS="refHeading">
PageType</H1>
<PRE CLASS="syntax">typedef enum {
PT_PAPER,
PT_ENVELOPE,
PT_LABEL
} PageType;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_2b.htm_IX_PaperOrientation">
 </A>
<A NAME="S_2b.htm_IX_PO_&ldots;">
 </A>
<H1 CLASS="refHeading">
PaperOrientation</H1>
<PRE CLASS="syntax">typedef ByteEnum PaperOrientation;
#define PO_PORTRAIT				0x00
#define PO_LANDSCAPE				0x01</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_2b.htm_IX_ParallelUnit">
 </A>
<A NAME="S_2b.htm_IX_PARALLEL_LPT&ldots;">
 </A>
<H1 CLASS="refHeading">
ParallelUnit</H1>
<PRE CLASS="syntax">typedef	enum
{
	PARALLEL_LPT1	= 0,
	PARALLEL_LPT2	= 2,
	PARALLEL_LPT3	= 4,
	PARALLEL_LPT4	= 6,
} ParallelUnit;</PRE>
<P>
&nbsp;</P>
</DIV>
<HR>
<A NAME="S_2c.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="S_2c.htm_IX_ParserFlags">
 </A>
<A NAME="S_2c.htm_IX_PF_&ldots;  (ParserFlags)">
 </A>
<H1 CLASS="refHeading">
ParserFlags</H1>
<PRE CLASS="syntax">typedef ByteFlags ParserFlags;
#define PF_HAS_LOOKAHEAD						0x80
#define PF_CONTAINS_DISPLAY_FUNC 						0x40
#define PF_OPERATORS 						0x20
#define PF_NUMBERS 						0x10
#define PF_CELLS 						0x08
#define PF_FUNCTIONS 						0x04
#define PF_NAMES 						0x02
#define PF_NEW_NAMES 						0x01</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_2c.htm_IX_ParserParameters">
 </A>
<A NAME="S_2c.htm_IX_PP_&ldots;">
 </A>
<H1 CLASS="refHeading">
ParserParameters</H1>
<PRE CLASS="syntax">typedef struct {
CommonParameters			PP_common;
word			PP_parserBufferSize;
ParserFlags 			PP_flags;
dword			PP_textPtr;
ScannerToken			PP_currentToken;
ScannerToken			PP_lookAheadToken;
byte			PP_error;				/* ParserScannerEvaluatorError */
word			PP_tokenStart;
word			PP_tokenEnd;
} ParserParameters;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_2c.htm_IX_ParserScannerEvaluatorError">
 </A>
<A NAME="S_2c.htm_IX_PSEE_&ldots;">
 </A>
<H1 CLASS="refHeading">
ParserScannerEvaluatorError</H1>
<PRE CLASS="syntax">typedef ByteEnum ParserScannerEvaluatorError;
/*
 * Scanner errors
 */
#define PSEE_BAD_NUMBER									0
#define PSEE_BAD_CELL_REFERENCE 									1
#define PSEE_NO_CLOSE_QUOTE 									2
#define PSEE_COLUMN_TOO_LARGE 									3
#define PSEE_ROW_TOO_LARGE 									4
#define PSEE_ILLEGAL_TOKEN 									5
/*
 * Parser errors
 */
#define PSEE_GENERAL 									6
#define PSEE_TOO_MANY_TOKENS 									7
#define PSEE_EXPECTED_OPEN_PAREN 									8
#define PSEE_EXPECTED_CLOSE_PAREN 									9
#define PSEE_BAD_EXPRESSION 									10
#define PSEE_EXPECTED_END_OF_EXPRESSION 									11
#define PSEE_MISSING_CLOSE_PAREN 									12
#define PSEE_UNKNOWN_IDENTIFIER 									13
#define PSEE_NOT_ENOUGH_NAME_SPACE 									14
/*
 * Serious evaluator errors
 */
#define PSEE_OUT_OF_STACK_SPACE 									15
#define PSEE_NESTING_TOO_DEEP 									16
/*
 * Evaluator errors that are returned as the result of formulas.
 * These are returned on the argument stack.
 */
#define PSEE_ROW_OUT_OF_RANGE 									17
#define PSEE_COLUMN_OUT_OF_RANGE 									18
#define PSEE_FUNCTION_NO_LONGER_EXISTS 									19
#define PSEE_BAD_ARG_COUNT 									20
#define PSEE_WRONG_TYPE 									21
#define PSEE_DIVIDE_BY_ZERO 									22
#define PSEE_UNDEFINED_NAME 									23
#define PSEE_CIRCULAR_REF 									24
#define PSEE_CIRCULAR_DEP 									25
#define PSEE_CIRC_NAME_REF 									26
#define PSEE_NUMBER_OUT_OF_RANGE 									27
#define PSEE_GEN_ERR 									28
#define PSEE_NA 									29
/*
 * Dependency errors
 */
#define PSEE_TOO_MANY_DEPENDENCIES 									30
#define PSEE_SSHEET_BASE 								0xc0
#define PSEE_FLOAT_BASE 								250
#define PSEE_APP_BASE 								230
#define PSEE_FLOAT_POS_INFINITY 								PSEE_FLOAT_BASE
#define PSEE_FLOAT_NEG_INFINITY 								(PSEE_FLOAT_BASE + 1)
#define PSEE_FLOAT_GEN_ERR 								(PSEE_FLOAT_BASE + 2)</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_2c.htm_IX_ParserToken">
 </A>
<A NAME="S_2c.htm_IX_PT_&ldots;  (ParserToken structure)">
 </A>
<H1 CLASS="refHeading">
ParserToken</H1>
<PRE CLASS="syntax">typedef struct {
ParserTokenType			PT_type;
ParserTokenData			PT_data;
} ParserToken;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_2c.htm_IX_ParserTokenCellData">
 </A>
<A NAME="S_2c.htm_IX_PTCD_&ldots;">
 </A>
<H1 CLASS="refHeading">
ParserTokenCellData</H1>
<PRE CLASS="syntax">typedef struct {
CellReference			PTCD_cellRef;
} ParserTokenCellData;</PRE>
<P>
&nbsp;</P>
</DIV>
<HR>
<A NAME="S_2d.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="S_2d.htm_IX_ParserTokenData">
 </A>
<A NAME="S_2d.htm_IX_PTD_&ldots;">
 </A>
<H1 CLASS="refHeading">
ParserTokenData</H1>
<PRE CLASS="syntax">typedef union {
ParserTokenNumberData 				PTD_number;
ParserTokenStringData 				PTD_string;
ParserTokenNameData 				PTD_name;
ParserTokenCellData 				PTD_cell;
ParserTokenFunctionData 				PTD_function;
ParserTokenOperatorData				PTD_operator;
} ParserTokenData;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_2d.htm_IX_ParserTokenFunctionData">
 </A>
<A NAME="S_2d.htm_IX_PTFD_functionID">
 </A>
<H1 CLASS="refHeading">
ParserTokenFunctionData</H1>
<PRE CLASS="syntax">typedef struct {
word		PTFD_functionID;
} ParserTokenFunctionData;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_2d.htm_IX_ParserTokenNameData">
 </A>
<A NAME="S_2d.htm_IX_PTND_name">
 </A>
<H1 CLASS="refHeading">
ParserTokenNameData</H1>
<PRE CLASS="syntax">typedef struct {
word		PTND_name;
} ParserTokenNameData;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_2d.htm_IX_ParserTokenNumberData">
 </A>
<A NAME="S_2d.htm_IX_PTND_value">
 </A>
<H1 CLASS="refHeading">
ParserTokenNumberData</H1>
<PRE CLASS="syntax">typedef struct {
FloatNum		PTND_value;
} ParserTokenNumberData;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_2d.htm_IX_ParserTokenOperatorData">
 </A>
<A NAME="S_2d.htm_IX_PTOD_operatorID">
 </A>
<H1 CLASS="refHeading">
ParserTokenOperatorData</H1>
<PRE CLASS="syntax">typedef struct {
OperatorType			PTOD_operatorID;
} ParserTokenOperatorData;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_2d.htm_IX_ParserTokenStringData">
 </A>
<A NAME="S_2d.htm_IX_PTSD_length">
 </A>
<H1 CLASS="refHeading">
ParserTokenStringData</H1>
<PRE CLASS="syntax">typedef struct {
word		PTSD_length;
} ParserTokenStringData;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_2d.htm_IX_ParserTokenType">
 </A>
<A NAME="S_2d.htm_IX_PARSER_TOKEN_&ldots;">
 </A>
<H1 CLASS="refHeading">
ParserTokenType</H1>
<PRE CLASS="syntax">typedef ByteEnum ParserTokenType;
#define PARSER_TOKEN_NUMBER 								0
#define PARSER_TOKEN_STRING 								1
#define PARSER_TOKEN_CELL 								2
#define PARSER_TOKEN_END_OF_EXPRESSION 								3
#define PARSER_TOKEN_OPEN_PAREN								4
#define PARSER_TOKEN_CLOSE_PAREN 								5
#define PARSER_TOKEN_NAME 								6
#define PARSER_TOKEN_FUNCTION 								7
#define PARSER_TOKEN_CLOSE_FUNCTION								8
#define PARSER_TOKEN_ARG_END 								9
#define PARSER_TOKEN_OPERATOR 								10</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_2d.htm_IX_PathCombineType">
 </A>
<A NAME="S_2d.htm_IX_PCT_&ldots;  (PathCombineType type)">
 </A>
<H1 CLASS="refHeading">
PathCombineType</H1>
<PRE CLASS="syntax">typedef enum /* word */ {
PCT_NULL,				/* wipe out old path */
PCT_REPLACE,				/* replace old path with upcoming path */
PCT_UNION,				/* union old path with new */
PCT_INTERSECTION 				/* intersect old path with new */
} PathCombineType;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_2d.htm_IX_PathName">
 </A>
<A NAME="S_2d.htm_IX_PATH_BUFFER_SIZE">
 </A>
<H1 CLASS="refHeading">
PathName</H1>
<PRE CLASS="syntax">typedef char PathName[PATH_BUFFER_SIZE];</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_2d.htm_IX_PT_ (PatternType type)">
 </A>
<A NAME="S_2d.htm_IX_PatternType">
 </A>
<H1 CLASS="refHeading">
PatternType</H1>
<PRE CLASS="syntax">typedef ByteEnum PatternType;
#define PT_SOLID				0
#define PT_SYSTEM_HATCH 				1
#define PT_SYSTEM_BITMAP 				2
#define PT_USER_HATCH 				3
#define PT_USER_BITMAP 				4
#define PT_CUSTOM_HATCH 				5
#define PT_CUSTOM_BITMAP 				6</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_2d.htm_IX_PCDocSizeParams">
 </A>
<A NAME="S_2d.htm_IX_PCDSP_&ldots;">
 </A>
<H1 CLASS="refHeading">
PCDocSizeParams</H1>
<PRE CLASS="syntax">typedef struct {
dword 	PCDSP_width;
dword 	PCDSP_height;
} PCDocSizeParams;</PRE>
<P>
Use this structure to communicate document sizes to a Print Control.</P>
</DIV>
<DIV>
<A NAME="S_2d.htm_IX_PCMarginParams">
 </A>
<A NAME="S_2d.htm_IX_PCMP_&ldots;">
 </A>
<H1 CLASS="refHeading">
PCMarginParams</H1>
<PRE CLASS="syntax">typedef struct {
word 	PCMP_left; 			/* left margin */
word 	PCMP_top; 			/* top margin */
word 	PCMP_right; 			/* right margin */
word 	PCMP_bottom; 			/* bottom margin */
} PCMarginParams</PRE>
<P>
This structure holds information about a document's or printer's margins.</P>
</DIV>
<DIV>
<A NAME="S_2d.htm_IX_PCProgressType">
 </A>
<A NAME="S_2d.htm_IX_PCPT_&ldots;">
 </A>
<H1 CLASS="refHeading">
PCProgressType</H1>
<PRE CLASS="syntax">typedef enum {
PCPT_PAGE,
PCPT_PERCENT,
PCPT_TEXT
} PCProgressType;</PRE>
<P>
&nbsp;</P>
</DIV>

<DIV>
<A NAME="S_2d.htm_IX_PDAType">
 </A>
<A NAME="S_2d.htm_IX_PDAT&ldots">
 </A>
<H1 CLASS="refHeading">
PDAType</H1>
<PRE CLASS="syntax">typedef ByteEnum PDAType;
#define PDAT_PC_EMULATOR        0x0
#define PDAT_N9000              0x1
#define PDAT_N9000i             0x2</PRE>

<P>
These values correspond to the different Nokia 9000 Communicator hardware platforms. They are only available on builds 4 or newer of the device (see <A HREF = "../../Nokia9000/Versions/Update_1.htm">Versions</A> for more information).
</P>

<P CLASS="refField"><STRONG>
Include:</STRONG>
respondr.goh 
 </P>

<P CLASS="refField"><STRONG>
See Also:</STRONG>       
<CODE>RespGetPDAHardwareInfo()</CODE>
 </P>
</DIV>

<HR>
<A NAME="S_2e.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="S_2e.htm_IX_Point">
 </A>
<A NAME="S_2e.htm_IX_P_&ldots;">
 </A>
<H1 CLASS="refHeading">
Point</H1>
<PRE CLASS="syntax">typedef struct {
sword P_x;
sword P_y;
} Point;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_2e.htm_IX_PointDWord">
 </A>
<A NAME="S_2e.htm_IX_PD_&ldots;  (PointDWord structure)">
 </A>
<H1 CLASS="refHeading">
PointDWord</H1>
<PRE CLASS="syntax">typedef struct {
sdword PD_x;
sdword PD_y;
} PointDWord;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_2e.htm_IX_PointDWFixed">
 </A>
<A NAME="S_2e.htm_IX_PDF_&ldots;">
 </A>
<H1 CLASS="refHeading">
PointDWFixed</H1>
<PRE CLASS="syntax">typedef struct {
DWFixed PDF_x;
DWFixed PDF_y;
} PointDWFixed;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_2e.htm_IX_PointerDef32">
 </A>
<A NAME="S_2e.htm_IX_PD_&ldots;  (PointerDef32 structure)">
 </A>
<H1 CLASS="refHeading">
PointerDef32</H1>
<PRE CLASS="syntax">typedef struct {
sbyte	PD_hotX;
sbyte	PD_hotY;
byte	PD_mask[CURSOR_IMAGE_SIZE_32];
byte	PD_image[CURSOR_IMAGE_SIZE_32];
} PointerDef32;
 STANDARD_CURSOR_IMAGE_SIZE = 32</PRE>
<P>
This structure defines a mouse pointer.</P>
</DIV>
<DIV>
<A NAME="S_2e.htm_IX_PointWWFixed">
 </A>
<A NAME="S_2e.htm_IX_PF_&ldots;  (PointWWFixed structure)">
 </A>
<H1 CLASS="refHeading">
PointWWFixed</H1>
<PRE CLASS="syntax">typedef struct {
WWFixed 	PF_x;
WWFixed 	PF_y;
} PointWWFixed;</PRE>
<P>
These structures are used to specify graphics point coordinates. Which point structure to use depends on size of the coordinate space and accuracy required.</P>
</DIV>
<DIV>
<A NAME="S_2e.htm_IX_PrintControlAttrs">
 </A>
<A NAME="S_2e.htm_IX_PCA_&ldots;">
 </A>
<H1 CLASS="refHeading">
PrintControlAttrs</H1>
<PRE CLASS="syntax">typedef WordFlags PrintControlAttrs;
#define PCA_MARK_APP_BUSY					0x2000			/* mark busy while printing */
#define PCA_VERIFY_PRINT					0x1000			/* verify before printing */
#define PCA_SHOW_PROGRESS					0x0800			/* show print progress dialog box */
#define PCA_PROGRESS_PERCENT					0x0400			/* show progress by percentage */
#define PCA_PROGRESS_PAGE					0x0200			/* show progress by page */
#define PCA_FORCE_ROTATION					0x0100			/* Force rotation of output */
#define PCA_COPY_CONTROLS					0x0080			/* Copy controls are available */
#define PCA_PAGE_CONTROLS					0x0040			/* Page range controls available */
#define PCA_QUALITY_CONTROLS					0x0020			/* Quality controls available */
#define PCA_USES_DIALOG_BOX					0x0010			/* Dialog box should appear */
#define PCA_GRAPHICS_MODE					0x0008			/* Supports graphics mode output */
#define PCA_TEXT_MODE					0x0004			/* Supports text mode output */
#define PCA_DEFAULT_QUALITY					0x0002			/* default print quality */</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_2e.htm_IX_PrintControlFeatures">
 </A>
<A NAME="S_2e.htm_IX_PRINTCF_&ldots;">
 </A>
<H1 CLASS="refHeading">
PrintControlFeatures</H1>
<PRE CLASS="syntax">typedef ByteFlags PrintControlFeatures;
#define PRINTCF_PRINT_TRIGGER					0x02			/* wants a print trigger */
#define PRINTCF_FAX_TRIGGER					0x01			/* wants a fax trigger */</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_2e.htm_IX_PrintControlStatus">
 </A>
<A NAME="S_2e.htm_IX_PCS_PRINT_BOX_&ldots;">
 </A>
<H1 CLASS="refHeading">
PrintControlStatus</H1>
<PRE CLASS="syntax">typedef enum {
PCS_PRINT_BOX_VISIBLE,
PCS_PRINT_BOX_NOT_VISIBLE
} PrintControlStatus;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_2e.htm_IX_PrintControlToolboxFeatures">
 </A>
<A NAME="S_2e.htm_IX_PRINTCTF_&ldots;">
 </A>
<H1 CLASS="refHeading">
PrintControlToolboxFeatures</H1>
<PRE CLASS="syntax">typedef ByteFlags PrintControlToolboxFeatures;
#define PRINTCTF_PRINT_TRIGGER						0x02		/* wants a print tool trigger */
#define PRINTCTF_FAX_TRIGGER						0x01		/* wants a fax tool trigger */</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_2e.htm_IX_PrinterDriverType">
 </A>
<A NAME="S_2e.htm_IX_PDT_&ldots;">
 </A>
<H1 CLASS="refHeading">
PrinterDriverType</H1>
<PRE CLASS="syntax">typedef enum PrinterDriverType;
PDT_PRINTER,
PDT_PLOTTER,
PDT_FACSIMILE,
PDT_CAMERA,
PDT_OTHER,
} PrinterDriverType;</PRE>
<P>
This enumerated type indeicates the type of printer driver that we are dealing with.</P>
</DIV>
<DIV>
<A NAME="S_2e.htm_IX_PrinterOutputModes">
 </A>
<A NAME="S_2e.htm_IX_POM_&ldots;">
 </A>
<A NAME="S_2e.htm_IX_PRINT_GRAPHICS">
 </A>
<A NAME="S_2e.htm_IX_PRINT_TEXT">
 </A>
<H1 CLASS="refHeading">
PrinterOutputModes</H1>
<PRE CLASS="syntax">typedef ByteFlags PrinterOutputModes;
#define POM_GRAPHICS_LOW					0x10
#define POM_GRAPHICS_MEDIUM					0x08
#define POM_GRAPHICS_HIGH					0x04
#define POM_TEXT_DRAFT					0x02
#define POM_TEXT_NLQ					0x01
#define PRINT_GRAPHICS =				(POM_GRAPHICS_LOW | POM_GRAPHICS_MEDIUM |
				 POM_GRAPHICS_HIGH )</PRE>
<PRE CLASS="syntax">#define PRINT_TEXT =				(POM_TEXT_DRAFT | POM_TEXT_NLQ)</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_2e.htm_IX_PrintQualityEnum">
 </A>
<A NAME="S_2e.htm_IX_PQT_&ldots;">
 </A>
<H1 CLASS="refHeading">
PrintQualityEnum</H1>
<PRE CLASS="syntax">typedef enum {
PQT_HIGH,
PQT_MEDIUM,
PQT_LOW
} PrintQualityEnum;</PRE>
<P>
&nbsp;</P>
</DIV>
<HR>
<A NAME="S_2f.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="S_2f.htm_IX_ProtocolNumber">
 </A>
<A NAME="S_2f.htm_IX_PN_&ldots;">
 </A>
<H1 CLASS="refHeading">
ProtocolNumber</H1>
<PRE CLASS="syntax">typedef struct {
word	PN_major;
word	PN_minor;
} ProtocolNumber;</PRE>
<P>
Defines the protocol level of a file, geode, or document. <CODE>
PN_major</CODE>
 represents significant compatibility comparisons, and <CODE>
PN_minor</CODE>
 represents less significant differences. If the major protocol is different between to items, they are incompatible. If the minor protocol is different, they may or may not be incompatible.</P>
</DIV>
<DIV>
<A NAME="S_2f.htm_IX_QueueHandle">
 </A>
<H1 CLASS="refHeading">
QueueHandle</H1>
<PRE CLASS="syntax">typedef Handle QueueHandle;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_2f.htm_IX_QuickSortParameters">
 </A>
<A NAME="S_2f.htm_IX_QSP_&ldots;">
 </A>
<H1 CLASS="refHeading">
QuickSortParameters</H1>
<PRE CLASS="syntax">typedef struct _QuickSortParameters {
word _pascal (*QSP_compareCallback) 							(void *			el1, 
							 void *			el2,</PRE>
<PRE CLASS="syntax">					 		 word 			valueForCallback));
void _pascal (*QSP_lockCallback) (void *el, word valueForCallback));
void _pascal (*QSP_unlockCallback) (void *el, word valueForCallback));
word 		QSP_insertLimit;
word 		QSP_medianLimit;
&nbsp;
/* These are set internally by the quicksort algorithm and should not
 * be set by the caller: */
word 		QSP_nLesser;
word 		QSP_nGreater;
 &nbsp;
} QuickSortParameters;</PRE>
<P>
This structure is passed to <CODE>
ArrayQuickSort</CODE>
. The fields have the following meanings:</P>
<DL>
<DT>
<CODE>
*</CODE>
QSP<CODE>
_compareCallback</DT><DD>
</CODE>
This routine is called to compare elements. It should be declared _pascal. It should return a positive value if <EM>
*el1</EM>
 ought to come before <EM>
*e2</EM>
 in the sorted list; a negative value if <EM>
*el1</EM>
 ought to come after <EM>
*e2</EM>
 in the sorted list; and zero if it doesn't matter which comes first.</DD>
<DT>
<CODE>
*</CODE>
QSP<CODE>
_lockCallback</DT><DD>
</CODE>
This routine is called before <CODE>
ArrayQuickSort</CODE>
 examines or changes any element. It should be declared _pascal. You can pass a null function pointer, indicating that no locking callback routine should be called.</DD>
<DT>
<CODE>
*</CODE>
QSP<CODE>
_lockCallback</DT><DD>
</CODE>
This routine is called after <CODE>
ArrayQuickSort</CODE>
 examines or changes any element. It should be declared _pascal. You can pass a null function pointer, indicating that no unlocking callback routine should be called.</DD>
<DT>
QSP<CODE>
_insertLimit</DT><DD>
</CODE>
If there are fewer than QSP<CODE>
_insertLimit</CODE>
 elements in a sublist, <CODE>
ArrayQuickSort</CODE>
 will use an insertion sort for that sublist, rather than a QuickSort.</DD>
<DT>
QSP<CODE>
_medianLimit</DT><DD>
</CODE>
If there are fewer than QSP<CODE>
_medianLimit</CODE>
 elements in a sublist, ArrayQuickSort will use the first element as a partition, instead of searching for the median element.</DD>
</DIV>
<DIV>
<A NAME="S_2f.htm_IX_RangeEnumCallbackParams">
 </A>
</DL>
<H1 CLASS="refHeading">
RangeEnumCallbackParams</H1>
<P>
See <CODE>
<A HREF="../../CRef/Routines/R_82.htm#IX_RangeEnum()">RangeEnum()</A></CODE>
.</P>
</DIV>
<DIV>
<A NAME="S_2f.htm_IX_RangeEnumFlags">
 </A>
<A NAME="S_2f.htm_IX_REF_&ldots;">
 </A>
<H1 CLASS="refHeading">
RangeEnumFlags</H1>
<PRE CLASS="syntax">typedef ByteFlags RangeEnumFlags;
#define REF_ALL_CELLS							0x80
#define REF_NO_LOCK							0x40
#define REF_COLUMN_FLAGS							0x20
#define REP_MATCH_COLUMN_FLAGS							0x10
#define REF_CELL_ALLOCATED							0x08
#define REF_CELL_FREED							0x04
#define REF_OTHER_ALLOC_OR_FREE							0x02
#define REF_COLUMN_FLAGS_MODIFIED							0x01</PRE>
<P>
These flags are used by <CODE>
<A HREF="../../CRef/Routines/R_82.htm#IX_RangeEnum()">RangeEnum()</A></CODE>
.</P>
</DIV>
<DIV>
<A NAME="S_2f.htm_IX_RangeEnumParams">
 </A>
<A NAME="S_2f.htm_IX_REP_&ldots;">
 </A>
<H1 CLASS="refHeading">
RangeEnumParams</H1>
<PRE CLASS="syntax">typedef struct {
PCB(RANGE_ENUM_CALLBACK_RETURN_TYPE, REP_callback,
										(RangeEnumCallbackParams));</PRE>
<PRE CLASS="syntax">Rectangle				REP_bounds;
byte				REP_columnFlags;
word				*REP_columnFlagsArray;
CellFunctionParameters				*REP_cfp;
byte				REP_matchFlags;
word				*REP_locals;
} RangeEnumParams;</PRE>
<P>
This structure is used by two routines, <CODE>
<A HREF="../../CRef/Routines/R_82.htm#IX_RangeEnum()">RangeEnum()</A></CODE>
 and <CODE>
<A HREF="../../CRef/Routines/R_4.htm#IX_CellGetExtent()">CellGetExtent()</A></CODE>
. When it is used by <CODE>
<A HREF="../../CRef/Routines/R_82.htm#IX_RangeEnum()">RangeEnum()</A></CODE>
, the structure specifies all the details about how <CODE>
<A HREF="../../CRef/Routines/R_82.htm#IX_RangeEnum()">RangeEnum()</A></CODE>
 will function. <CODE>
<A HREF="../../CRef/Routines/R_4.htm#IX_CellGetExtent()">CellGetExtent()</A></CODE>
 is passed a blank <CODE>
RangeEnumParams</CODE>
 structure; it fills in the <CODE>
REP_bounds</CODE>
 field.</P>
<P>
The callback routine, if any, should be declared _pascal.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
cell.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="S_2f.htm_IX_RangeInsertParams">
 </A>
<H1 CLASS="refHeading">
RangeInsertParams</H1>
<P>
See <CODE>
<A HREF="../../CRef/Routines/R_82.htm#IX_RangeInsert()">RangeInsert()</A></CODE>
.:</P>
</DIV>
<DIV>
<A NAME="S_2f.htm_IX_RangeSortError">
 </A>
<A NAME="S_2f.htm_IX_RSE_&ldots;">
 </A>
<H1 CLASS="refHeading">
RangeSortError</H1>
<PRE CLASS="syntax">typedef enum /* word */ {
RSE_NO_ERROR,
RSE_UNABLE_TO_ALLOC,
} RangeSortError;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_2f.htm_IX_RangeSortCellExistFlags">
 </A>
<A NAME="S_2f.htm_IX_RSCEF_&ldots;">
 </A>
<H1 CLASS="refHeading">
RangeSortCellExistFlags</H1>
<PRE CLASS="syntax">typedef ByteFlags RangeSortCellExistsFlags;
#define RSCEF_SECOND_CELL_EXISTS 0x02
#define RSCEF_FIRST_CELL_EXISTS 0x01</PRE>
<P>
&nbsp;</P>
</DIV>
<HR>
<A NAME="S_30.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="S_30.htm_IX_RangeSortFlags">
 </A>
<A NAME="S_30.htm_IX_RSF_&ldots;">
 </A>
<H1 CLASS="refHeading">
RangeSortFlags</H1>
<PRE CLASS="syntax">typedef ByteFlags RangeSortFlags;
#define RSF_SORT_ROWS						0x80
#define RSF_SORT_ASCENDING						0x40
#define RSF_IGNORE_CASE						0x20</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_30.htm_IX_RangeSortParams">
 </A>
<A NAME="S_30.htm_IX_RSP_&ldots;">
 </A>
<H1 CLASS="refHeading">
RangeSortParams</H1>
<PRE CLASS="syntax">typedef struct {
Rectangle		RSP_range;
Point		RSP_active;
dword		RSP_callback;
byte		RSP_flags; /* RangeSortFlags */
dword		RSP_cfp;
word		RSP_sourceChunk;
word		RSP_destChunk;
word		RSP_base;
dword		RSP_lockedEntry;
byte		RSP_cachedFlags;
} RangeSortParams;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_30.htm_IX_RecordHeader">
 </A>
<H1 CLASS="refHeading">
RecordHeader</H1>
<PRE CLASS="syntax">typedef struct {
RecordID		RH_id;
word		RH_size;
byte		RH_fieldCount;
} RecordHeader;</PRE>
<P>
Structure containing metadata about a record; first <CODE>
FieldHeader</CODE>
 follows.</P>
</DIV>
<DIV>
<A NAME="S_30.htm_IX_RecordID">
 </A>
<H1 CLASS="refHeading">
RecordID</H1>
<PRE CLASS="syntax">typedef dword RecordID;</PRE>
<P>
Uniquely identifies a record in a datastore; this value stays constant and does not change when other records are added or deleted.</P>
</DIV>
<DIV>
<A NAME="S_30.htm_IX_RecordNum">
 </A>
<H1 CLASS="refHeading">
RecordNum</H1>
<PRE CLASS="syntax">typedef dword RecordNum;</PRE>
<P>
Specifies relative place in the datastore; this value may change when other records are added or deleted.</P>
</DIV>
<DIV>
<A NAME="S_30.htm_IX_Rectangle">
 </A>
<A NAME="S_30.htm_IX_R_&ldots;">
 </A>
<H1 CLASS="refHeading">
Rectangle</H1>
<PRE CLASS="syntax">typedef struct {
sword	R_left;
sword	R_top;
sword	R_right;
sword	R_bottom;
} Rectangle;</PRE>
<P>
This structure represents a graphics rectangle.</P>
</DIV>
<DIV>
<A NAME="S_30.htm_IX_RectDWord">
 </A>
<A NAME="S_30.htm_IX_RD_&ldots;">
 </A>
<H1 CLASS="refHeading">
RectDWord</H1>
<PRE CLASS="syntax">typedef struct {
sdword	RD_left;
sdword	RD_top;
sdword	RD_right;
sdword	RD_bottom;
} RectDWord;</PRE>
<P>
This structure represents a graphics rectangle.</P>
</DIV>
<DIV>
<A NAME="S_30.htm_IX_RectRegion">
 </A>
<A NAME="S_30.htm_IX_RR_&ldots;">
 </A>
<H1 CLASS="refHeading">
RectRegion</H1>
<PRE CLASS="syntax">typedef struct {
word 	RR_y1M1;
word 	RR_eo1;	/* EOREGREC */
word 	RR_y2;
word 	RR_x1;
word 	RR_x2;
word 	RR_eo2;		/* EOREGREC */
word 	RR_eo3;		/* EOREGREC */
} RectRegion;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_30.htm_IX_RefElementHeader">
 </A>
<A NAME="S_30.htm_IX_REH_refCount">
 </A>
<H1 CLASS="refHeading">
RefElementHeader</H1>
<PRE CLASS="syntax">typedef struct {
 WordAndAHalf REH_refCount;
} RefElementHeader;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_30.htm_IX_Region">
 </A>
<A NAME="S_30.htm_IX_EOREGREC">
 </A>
<A NAME="S_30.htm_IX_EOREG_HIGH">
 </A>
<H1 CLASS="refHeading">
Region</H1>
<PRE CLASS="syntax">typedef word Region;
#define EOREGREC				0x8000
#define EOREG_HIGH				 0x80</PRE>
<P>
This structure represents a region of a graphics coordinate space.</P>
<P>
Regions are described in terms of a rectangular array (thus the similarity to bitmaps). Instead of specifying an on/off value for each pixel, however, regions assume that the region will be fairly undetailed and that the data structure can thus be treated in the manner of a sparse array. Only the cells in which the color value of a row changes are recorded. The tricky part here is keeping in mind that when figuring out whether or not a row is the same as a previous row, the system works its way up from the bottom, so that you should compare each row with the row beneath it to determine whether it needs an entry.</P>
<P>
The easiest region to describe is the null region, which is a special case described by a single word with the value EOREGREC (a constant whose name stands for <EM>
E</EM>
nd Of <EM>
REG</EM>
ion <EM>
REC</EM>
ord value). Describing a non-null region requires several numbers.</P>
<P>
The first four numbers of the region description give the bounds of the region. Next come one or more series of numbers. Each series describes a row, specifying which pixels of that row are part of the region. The only rows which need to be described are those which are different from the row below. The first number of each row description is the row number, its <EM>
y</EM>
 coordinate. The last number of each series is a special token, EOREGREC, which lets the kernel know that the next number of the description will be the start of another row. Between the row number and EOREGREC are the column numbers where the pixels toggle on and off. The first number after the row number corresponds to the first column in which the pixel is on; the next number is the first subsequent column in which the pixel is off; and so on.</P>
</DIV>
<DIV>
<A NAME="S_30.htm_IX_RegionFillRule">
 </A>
<A NAME="S_30.htm_IX_ODD_EVEN (RegionFillRule type)">
 </A>
<A NAME="S_30.htm_IX_WINDING (RegionFillRule type)">
 </A>
<H1 CLASS="refHeading">
RegionFillRule</H1>
<PRE CLASS="syntax">typedef ByteEnum RegionFillRule;
#define ODD_EVEN				0
#define WINDING				1</PRE>
<P>
This enumerated type determines how a path or region should be filled. Winding fill is more versatile, but requires that the path or polygon's edges run in the correct direction.</P>
</DIV>
<HR>
<A NAME="S_31.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="S_31.htm_IX_ReleaseNumber">
 </A>
<A NAME="S_31.htm_IX_RN_&ldots;">
 </A>
<H1 CLASS="refHeading">
ReleaseNumber</H1>
<PRE CLASS="syntax">typedef struct {
word	RN_major;
word	RN_minor;
word	RN_change;
word	RN_engineering;
} ReleaseNumber;</PRE>
<P>
Used to record what version a file, document, or geode is. This represents the release level; the most significant numbers are <CODE>
RN_major</CODE>
 and <CODE>
RN_minor</CODE>
. The other fields are typically used only internally to a manufacturer.</P>
</DIV>
<DIV>
<A NAME="S_31.htm_IX_RGBColorAsDWord">
 </A>
<A NAME="S_31.htm_IX_RGB_&ldots; () macros">
 </A>
<H1 CLASS="refHeading">
RGBColorAsDWord</H1>
<PRE CLASS="syntax">typedef dword RGBColorAsDWord;
RGB_RED(val) ( val &amp; 0xff)
RGB_GREEN(val) ( (val &gt;&gt; 8) &amp; 0xff )
RGB_BLUE(val) ( (val &gt;&gt; 16) &amp; 0xff )
RGB_INDEX(val) ( (val &gt;&gt; 24) &amp; 0xff )</PRE>
<P>
See the <CODE>
ColorQuad</CODE>
 data structure to find out the meanings of the fields.</P>
</DIV>
<DIV>
<A NAME="S_31.htm_IX_RGBDelta">
 </A>
<A NAME="S_31.htm_IX_RGBD_&ldots;">
 </A>
<H1 CLASS="refHeading">
RGBDelta</H1>
<PRE CLASS="syntax">typedef struct {
 byte RGBD_red;
 byte RGBD_green;
 byte RGBD_blue;
} RGBDelta;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_31.htm_IX_RGBTransfer">
 </A>
<A NAME="S_31.htm_IX_RGBT_&ldots;">
 </A>
<H1 CLASS="refHeading">
RGBTransfer</H1>
<PRE CLASS="syntax">typedef struct {
byte	RGBT_red[256];
byte	RGBT_green[256];
byte	RGBT_blue[256];
} RGBTransfer;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_31.htm_IX_RGBValue">
 </A>
<A NAME="S_31.htm_IX_RGB_&ldots;">
 </A>
<H1 CLASS="refHeading">
RGBValue</H1>
<PRE CLASS="syntax">typedef struct {
byte	RGB_red;
byte	RGB_green;
byte	RGB_blue;
} RGBValue;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_31.htm_IX_SACAddress">
 </A>
<H1 CLASS="refHeading">
SACAddress</H1>
<PRE CLASS="syntax">typedef struct {
        word                SACA_opaqueSize;
        /* label byte          SACA_opaque;    */
        /* user-readable form of address follows opaque address--use
         *   SACA_opaqueSize to compute the offset to this data. */
} SACAddress;</PRE>
<P>
The SocketAddressControl uses <CODE>
SACAddress</CODE>
 structures to provide information about addresses.</P>
<P>
Most programs won't need to look at the innards of this structure: they will just pass the opaque address information to <CODE>
<A HREF="../../CRef/Routines/R_8a.htm#IX_SocketResolve()">SocketResolve()</A></CODE>
 to make sure that the address is valid and reduce it to its primitive form. </P>
<P>
However, if you need to construct a &quot;raw&quot; address to pass to <CODE>
<A HREF="../../CRef/Routines/R_8a.htm#IX_SocketResolve()">SocketResolve()</A></CODE>
, you'll need to know the structure of the opaque address information. It's an <CODE>
ExtendedSACAddress</CODE>
 buffer followed by a null-terminated user-readable connection address string..</P>
<P>
The <CODE>
ExtendedSACAddress</CODE>
 buffer consists of:</P>
<UL>
<LI>
A word giving the size of the optional link information (zero if there is no link information).</LI>
<LI>
Link information, consisting of a <CODE>
LinkType</CODE>
 value (one of LT_ADDR, LT_ID, or LT_DEFAULT), and parameters to identify the link. If the <CODE>
LinkType</CODE>
 is LT_DEFAULT, then there are no further parameters. If the <CODE>
LinkType</CODE>
 is LT_ID, then there is a word-length <CODE>
LinkID</CODE>
 which acts as a permanent identifier for the link. If the <CODE>
LinkType</CODE>
 is LT_ADDR, the parameter is a string which will be appended to the user-readable connection address string, surrounded by parentheses.</LI>
</UL>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
sac.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="S_31.htm_IX_SampleFormat">
 </A>
<A NAME="S_31.htm_IX_SMID_&ldots;  (SampleFormat structure)">
 </A>
<H1 CLASS="refHeading">
SampleFormat</H1>
<PRE CLASS="syntax">typedef struct {
         DACSampleFormat SMID_format:15;
         DACReferenceByte SMID_reference:1;
} SampleFormat;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_31.htm_IX_SampleFormatDescription">
 </A>
<A NAME="S_31.htm_IX_SFD_&ldots;">
 </A>
<H1 CLASS="refHeading">
SampleFormatDescription</H1>
<PRE CLASS="syntax">typedef struct {
 word 	SFD_manufact;
 word 	SFD_format;
 word 	SFD_rate;
 word 	SFD_playFlags;
} SampleFormatDescription;</PRE>
<P>
This structure acts as a header for a sampled sound, giving format information needed to properly interpret the sound data.</P>
</DIV>
<DIV>
<A NAME="S_31.htm_IX_SansFace">
 </A>
<A NAME="S_31.htm_IX_SF_A_&ldots;">
 </A>
<H1 CLASS="refHeading">
SansFace</H1>
<PRE CLASS="syntax">typedef byte SansFace;
#define SF_A_CLOSED 0x0080
#define SF_A_OPEN 0x0000</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_31.htm_IX_sbyte">
 </A>
<H1 CLASS="refHeading">
sbyte</H1>
<PRE CLASS="syntax">typedef char sbyte;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_31.htm_IX_ScannerToken">
 </A>
<A NAME="S_31.htm_IX_ST_&ldots;">
 </A>
<H1 CLASS="refHeading">
ScannerToken</H1>
<PRE CLASS="syntax">typedef struct {
ScannerTokenType				ST_type;
ScannerTokenData				ST_data;
} ScannerToken;</PRE>
<P>
&nbsp;</P>
</DIV>
<HR>
<A NAME="S_32.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="S_32.htm_IX_ScannerTokenCellData">
 </A>
<A NAME="S_32.htm_IX_STCD_cellRef">
 </A>
<H1 CLASS="refHeading">
ScannerTokenCellData</H1>
<PRE CLASS="syntax">typedef struct {
CellReference			STCD_cellRef;
} ScannerTokenCellData;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_32.htm_IX_ScannerTokenData">
 </A>
<A NAME="S_32.htm_IX_STD_&ldots;">
 </A>
<H1 CLASS="refHeading">
ScannerTokenData</H1>
<PRE CLASS="syntax">typedef union {
ScannerTokenNumberData					STD_number;
ScannerTokenStringData					STD_string;
ScannerTokenCellData					STD_cell;
ScannerTokenIdentifierData					STD_identifier;
ScannerTokenOperatorData					STD_operator;
} ScannerTokenData;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_32.htm_IX_ScannerTokenIdentifierData">
 </A>
<A NAME="S_32.htm_IX_STID_start">
 </A>
<H1 CLASS="refHeading">
ScannerTokenIdentifierData</H1>
<PRE CLASS="syntax">typedef struct {
word		STID_start;
} ScannerTokenIdentifierData;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_32.htm_IX_ScannerTokenNumberData">
 </A>
<A NAME="S_32.htm_IX_STND_value">
 </A>
<H1 CLASS="refHeading">
ScannerTokenNumberData</H1>
<PRE CLASS="syntax">typedef struct {
FloatNum		STND_value;
} ScannerTokenNumberData;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_32.htm_IX_ScannerTokenOperatorData">
 </A>
<A NAME="S_32.htm_IX_STOD_operatorID">
 </A>
<H1 CLASS="refHeading">
ScannerTokenOperatorData</H1>
<PRE CLASS="syntax">typedef struct {
OperatorType			STOD_operatorID;
} ScannerTokenOperatorData;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_32.htm_IX_ScannerTokenStringData">
 </A>
<A NAME="S_32.htm_IX_STSD_&ldots;">
 </A>
<H1 CLASS="refHeading">
ScannerTokenStringData</H1>
<PRE CLASS="syntax">typedef struct {
word	STSD_start;
word	STSD_length;
} ScannerTokenStringData;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_32.htm_IX_ScannerTokenType">
 </A>
<A NAME="S_32.htm_IX_SCANNER_TOKEN_&ldots;">
 </A>
<H1 CLASS="refHeading">
ScannerTokenType</H1>
<PRE CLASS="syntax">typedef ByteEnum ScannerTokenType;
#define SCANNER_TOKEN_NUMBER 									0
#define SCANNER_TOKEN_STRING 									1
#define SCANNER_TOKEN_CELL 									2
#define SCANNER_TOKEN_END_OF_EXPRESSION 									3
#define SCANNER_TOKEN_OPEN_PAREN 									4
#define SCANNER_TOKEN_CLOSE_PAREN 									5
#define SCANNER_TOKEN_IDENTIFIER 									6
#define SCANNER_TOKEN_OPERATOR 									7
#define SCANNER_TOKEN_LIST_SEPARATOR									8</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_32.htm_IX_ScriptAttrAsWord">
 </A>
<H1 CLASS="refHeading">
ScriptAttrAsWord</H1>
<PRE CLASS="syntax">typedef word ScriptAttrAsWord;
/* 	High byte is a vertical offset, as a fraction of the font size.
	Low byte is a fractional scale to use.</PRE>
<PRE CLASS="syntax">	Thus, setting a subscript attr to 0x8020 would result in subscript
	characters being printed half a line down and at 1/4 normal size. */</PRE>
<P>
This structure specifies the offset and scale factor with which sub- and superscript characters should draw.</P>
</DIV>
<DIV>
<A NAME="S_32.htm_IX_ScriptFace">
 </A>
<A NAME="S_32.htm_IX_SF_&ldots;  (ScriptFace)">
 </A>
<H1 CLASS="refHeading">
ScriptFace</H1>
<PRE CLASS="syntax">typedef byte ScriptFace;
#define SF_CURSIVE 0x0080
#define SF_CALLIGRAPHIC 0x0000</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_32.htm_IX_sdword">
 </A>
<H1 CLASS="refHeading">
sdword</H1>
<PRE CLASS="syntax">typedef long sdword;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_32.htm_IX_SearchFlags">
 </A>
<H1 CLASS="refHeading">
SearchFlags</H1>
<PRE CLASS="syntax">typedef ByteFlags SearchFlags;
#define	SF_BACKWARDS	 		0x80
#define	SF_START_AT_END	 		0x40
#define	SF_IGNORE_CASE	 		0x20
#define	SF_NO_WILDCARDS	 		0x10
#define	SF_PARTIAL_WORD	 		0x08</PRE>
<P>
Flags to define search parameters; see <CODE>
SearchParams</CODE>
 and <CODE>
<A HREF="../../CRef/Routines/R_15.htm#IX_DataStoreStringSearch()">DataStoreStringSearch()</A></CODE>
.</P>
</DIV>
<DIV>
<A NAME="S_32.htm_IX_SearchParams">
 </A>
<H1 CLASS="refHeading">
SearchParams</H1>
<PRE CLASS="syntax">typedef struct {
SearchType		SP_searchType;
dword		SP_maxRecords;
FieldID		SP_startField;
FieldCategory	SP_category;
TCHAR		*SP_searchString;
SearchFlags		SP_flags;
} SearchParams;</PRE>
<P>
Structure for specifying search conditions when calling <CODE>
<A HREF="../../CRef/Routines/R_15.htm#IX_DataStoreStringSearch()">DataStoreStringSearch()</A></CODE>
.</P>
</DIV>
<DIV>
<A NAME="S_32.htm_IX_SearchType">
 </A>
 </A>
<H1 CLASS="refHeading">
SearchType</H1>
<PRE CLASS="syntax">typedef ByteEnum SearchType;
#define	ST_ALL	 		1	/* search all string fields */
#define	ST_FIELD			2	/* search by FieldID */
#define	ST_CATEGORY			3	/* search by FieldCategory */</PRE>
<P>
Values to specify in search parameters; see <CODE>
SearchParams</CODE>
 and <CODE>
<A HREF="../../CRef/Routines/R_15.htm#IX_DataStoreStringSearch()">DataStoreStringSearch()</A></CODE>
.</P>
</DIV>
<DIV>
<A NAME="S_32.htm_IX_segment">
 </A>
<H1 CLASS="refHeading">
segment</H1>
<PRE CLASS="syntax">typedef word segment;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_32.htm_IX_SemaphoreError">
 </A>
<A NAME="S_32.htm_IX_SE_&ldots;">
 </A>
<H1 CLASS="refHeading">
SemaphoreError</H1>
<PRE CLASS="syntax">typedef enum {
SE_NO_ERROR,					/* No error occurred */
SE_TIMEOUT,					/* The semaphore timed out before
					 * it could be grabbed by the thread */</PRE>
<PRE CLASS="syntax">SE_PREVIOUS_OWNER_DIED					/* The current holder of the semaphore
					 * exited abnormally */</PRE>
<PRE CLASS="syntax">} SemaphoreError;</PRE>
<P>
Determines the error encountered by semaphore and threadlock routines such as <CODE>
<A HREF="../../CRef/Routines/R_98.htm#IX_ThreadPSem()">ThreadPSem()</A></CODE>
 and <CODE>
<A HREF="../../CRef/Routines/R_98.htm#IX_ThreadPTimedSem()">ThreadPTimedSem()</A></CODE>
.</P>
<DL>
<DT>
SE_NO_ERROR</DT><DD>
No error occurred and the semaphore was grabbed properly.</DD>
<DT>
SE_TIMEOUT</DT><DD>
The time elapsed and the semaphore was not grabbed. If this value is returned, the thread should <EM>
not</EM>
 proceed with whatever protected operation was to happen. Instead, it should either attempt to grab the semaphore again or should proceed with other tasks.</DD>
<DT>
SE_PREVIOUS_OWNER_DIED</DT><DD>
The previous owner of the semaphore exited abnormally. If the thread currently holding the semaphore exited without releasing the semaphore, for example, this would be returned.</DD>
</DIV>
</DL>
<HR>
<A NAME="S_33.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="S_33.htm_IX_SerialBaud">
 </A>
<A NAME="S_33.htm_IX_SERIAL_BAUD_&ldots;">
 </A>
<H1 CLASS="refHeading">
SerialBaud</H1>
<PRE CLASS="syntax">typedef	enum
{
	SERIAL_BAUD_115200			= 1,
	SERIAL_BAUD_57600			= 2,
	SERIAL_BAUD_38400			= 3,
	SERIAL_BAUD_19200			= 6,
	SERIAL_BAUD_14400			= 8,
	SERIAL_BAUD_9600			= 12,
	SERIAL_BAUD_7200			= 16,
	SERIAL_BAUD_4800			= 24,
	SERIAL_BAUD_3600			= 32,
	SERIAL_BAUD_2400			= 48,
	SERIAL_BAUD_2000			= 58,
	SERIAL_BAUD_1800			= 64,
	SERIAL_BAUD_1200			= 96,
	SERIAL_BAUD_600			= 192,
	SERIAL_BAUD_300			= 384
} SerialBaud;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_33.htm_IX_SerialFormat">
 </A>
<A NAME="S_33.htm_IX_SERIAL_FORMAT_&ldots;">
 </A>
<H1 CLASS="refHeading">
SerialFormat</H1>
<PRE CLASS="syntax">typedef	ByteFlags SerialFormat;
#define	SERIAL_FORMAT_DLAB_OFFSET						(7)
#define	SERIAL_FORMAT_DLAB						(0x01 &lt;&lt; SERIAL_FORMAT_DLAB_OFFSET)
&nbsp;
#define	SERIAL_FORMAT_BREAK_OFFSET						(6)
#define	SERIAL_FORMAT_BREAK						(0x01 &lt;&lt; SERIAL_FORMAT_BREAK_OFFSET)
&nbsp;
#define	SERIAL_FORMAT_PARITY_OFFSET						(3)
#define	SERIAL_FORMAT_PARITY						(0x07 &lt;&lt; SERIAL_FORMAT_PARITY_OFFSET)
&nbsp;
#define	SERIAL_FORMAT_EXTRA_STOP_OFFSET (2)
#define	SERIAL_FORMAT_EXTRA_STOP						(0x01 &lt;&lt;	\ 
								SERIAL_FORMAT_EXTRA_STOP_OFFSET)</PRE>
<PRE CLASS="syntax">&nbsp;
#define	SERIAL_FORMAT_LENGTH_OFFSET						(0)
#define	SERIAL_FORMAT_LENGTH						(0x03 &lt;&lt; SERIAL_FORMAT_LENGTH_OFFSET)</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_33.htm_IX_SerialMode">
 </A>
<A NAME="S_33.htm_IX_SM_&ldots;">
 </A>
<H1 CLASS="refHeading">
SerialMode</H1>
<PRE CLASS="syntax">typedef	enum {
	SM_RAW,
	SM_RARE,
	SM_COOKED
} SerialMode;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
#define SERIAL_MODEM_RTS						(0x01 &lt;&lt; SERIAL_MODEM_RTS_OFFSET)<A NAME="S_33.htm_IX_SerialModem">
 </A>
<A NAME="S_33.htm_IX_SMC_&ldots;">
 </A>
<A NAME="S_33.htm_IX_SERIAL_MODEM_&ldots;">
 </A>
<H1 CLASS="refHeading">
SerialModem</H1>
<PRE CLASS="syntax">typedef	ByteFlags SerialModem;
#define    SMC_RTS      0x02    /* Request-To-Send (1 asserts it) */
#define    SMC_DTR      0x01    /* Data-Terminal Ready (1 asserts it) */
&nbsp;
#define SERIAL_MODEM_RTS_OFFSET						(1)

#define SERIAL_MODEM_DTR_OFFSET						(0)
#define SERIAL_MODEM_DTR						(0x01 &lt;&lt; SERIAL_MODEM_DTR_OFFSET)</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_33.htm_IX_SerialPortNum">
 </A>
<A NAME="S_33.htm_IX_SERIAL_COM&ldots;">
 </A>
<H1 CLASS="refHeading">
SerialPortNum</H1>
<PRE CLASS="syntax">typedef	enum
{
	SERIAL_COM1			= 0,
	SERIAL_COM2			= 2,
	SERIAL_COM3			= 4,
	SERIAL_COM4			= 6,
	SERIAL_COM5			= 8,
	SERIAL_COM6			= 10,
	SERIAL_COM7			= 12,
	SERIAL_COM8			= 14
} SerialPortNum;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_33.htm_IX_SemaphoreHandle">
 </A>
<H1 CLASS="refHeading">
SemaphoreHandle</H1>
<PRE CLASS="syntax">typedef Handle SemaphoreHandle;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_33.htm_IX_SerifFace">
 </A>
<A NAME="S_33.htm_IX_SF_&ldots;  (SerifFace)">
 </A>
<H1 CLASS="refHeading">
SerifFace</H1>
<PRE CLASS="syntax">typedef byte SerifFace;
#define SF_SLAB 0x00c0
#define SF_MODERN 0x0080
#define SF_TRANS 0x0040
#define SF_OLD 0x0000</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_33.htm_IX_SetPalType">
 </A>
<A NAME="S_33.htm_IX_SPT_&ldots;  (SetPalType type)">
 </A>
<H1 CLASS="refHeading">
SetPalType</H1>
<PRE CLASS="syntax">typedef ByteEnum SetPalType;
#define SPT_DEFAULT				0
#define SPT_CUSTOM				1</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_33.htm_IX_ShiftState">
 </A>
<A NAME="S_33.htm_IX_SS_&ldots;  (ShiftState)">
 </A>
<H1 CLASS="refHeading">
ShiftState</H1>
<PRE CLASS="syntax">typedef ByteFlags ShiftState;
#define SS_LALT				0x80
#define SS_RALT 				0x40
#define SS_LCTRL 				0x20
#define SS_RCTRL 				0x10
#define SS_LSHIFT 				0x08
#define SS_RSHIFT 				0x04
#define SS_FIRE_BUTTON_1 				0x02
#define SS_FIRE_BUTTON_2				0x01</PRE>
<P>
Modifiers which will be incorporated into input information. Corresponds to alt keys, control keys, shift keys, or special system modifiers. Note that these bits will only be set if not already accounted for; that is, if you are passed the character &quot;E&quot;, the shift modifiers of this structure will not be marked.</P>
</DIV>
<HR>
<A NAME="S_34.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="S_34.htm_IX_Socket">
 </A>
<H1 CLASS="refHeading">
Socket</H1>
<PRE CLASS="syntax">typedef word Socket;</PRE>
<P>
A Socket represents one side of a communication managed by the Socket library.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
socket.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="S_34.htm_IX_SocketAddress">
 </A>
<A NAME="S_34.htm_IX_SA_&ldots;">
 </A>
<H1 CLASS="refHeading">
SocketAddress</H1>
<PRE CLASS="syntax">typedef struct {
        SocketPort  SA_port;
        word        SA_domainSize; 					/*  size in bytes of SA_domain buffer */
        char        *SA_domain; 					/*  null terminated domain name */
        word        SA_addressSize; 					/*  size in bytes of address data */
} SocketAddress;</PRE>
<P>
Addresses are made up of a port number, a domain, and address data:</P>
<DL>
<DT>
<STRONG>
SA_port</STRONG>
</DT><DD>Port numbers identify a particular line of communication within a machine. Port numbers may be 32-bit or 16-bit, depending on the domain. They are specified via the <CODE>
SocketPort</CODE>
 structure.</DD>
<DT>
<STRONG>
SA_domain</STRONG>
, <STRONG>
SA_domainSize</DT><DD>
</STRONG>
The domain identifies the protocol of the network by which the addressed machine may be reached. The domain is specified by a string. <CODE>
SA_domain</CODE>
 is a pointer to the null-terminated domain name string and <CODE>
SA_domainSize</CODE>
 is the size of the buffer containing the domain name string.</DD>
<DT>
</DT><DD>Some routines are passed an empty <CODE>
SocketAddress</CODE>
 structure. This means that you should have allocated memory for SA_domain, and initialized <CODE>
SA_domain</CODE>
 and <CODE>
SA_domainSize</CODE>
.</DD>
<DT>
<STRONG>
SA_addressSize</STRONG>
, <STRONG>
Address Data</DT><DD>
</STRONG>
The format of the address data used to identify a machine within a domain depends on that domain. The <CODE>
SA_addressSize</CODE>
 field contains the size of the address data. The buffer containing the address data should fall immediately after the <CODE>
SocketAddress</CODE>
 structure.</DD>
<DT>
</DT><DD>Some routines are passed an empty <CODE>
SocketAddress</CODE>
 structure. This means that you should leave room for address data after the structure and initialize the <CODE>
SA_addressSize</CODE>
 field.</DD>
</DL>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
socket.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="S_34.htm_IX_SocketBindFlags">
 </A>
<A NAME="S_34.htm_IX_SBF_REUSE_PORT">
 </A>
<H1 CLASS="refHeading">
SocketBindFlags</H1>
<PRE CLASS="syntax">typedef WordFlags SocketBindFlags;
        #define SBF_REUSE_PORT  (0x8000) </PRE>
<P>
These flags are used to specify options when binding a socket to a port.</P>
<P>
There is only one flag: SBF_REUSE_PORT, requesting that the socket be bound to the port even if another socket is already bound to it. You may not use this flag with datagram sockets.</P>
</DIV>
<DIV>
<A NAME="S_34.htm_IX_SocketCheckRequest">
 </A>
<A NAME="S_34.htm_IX_SocketCondition">
 </A>
<A NAME="S_34.htm_IX_SCR_&ldots;">
 </A>
<A NAME="S_34.htm_IX_SC_&ldots;">
 </A>
<H1 CLASS="refHeading">
SocketCheckRequest</H1>
<PRE CLASS="syntax">typedef struct {
        word 		SCR_socket;
        SocketCondition 		SCR_condition;
        byte 		SCR_reserved;
} SocketCheckRequest;
typedef ByteEnum SocketCondition;
        #define SC_READ 			0x0 			/*  data arrived */
        #define SC_WRITE 			0x1 			/*  data can be written */
        #define SC_ACCEPT 			0x2 			/*  connect request arrived */
        #define SC_EXCEPTION 			0x3 			/*  an exception occurred */
        #define SC_URGENT 			0x4 			/*  urgent data arrived */</PRE>
<P>
A <CODE>
SocketCheckRequest</CODE>
 is used to query a socket about whether it is ready to carry out some operation. You will need to set two fields:</P>
<DL>
<DT>
<STRONG>
SCR_socket</STRONG>
</DT><DD>The socket to query.</DD>
<DT>
<STRONG>
SCR_condition</DT><DD>
</STRONG>
The operation to query about.</DD>
</DL>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
socket.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="S_34.htm_IX_SocketCondition">
 </A>
<H1 CLASS="refHeading">
SocketCondition</H1>
<P>
See <CODE>
SocketCheckRequest</CODE>
.</P>
</DIV>
<DIV>
typedef ByteEnum <A NAME="S_34.htm_IX_SocketDeliveryType">
 </A>
<A NAME="S_34.htm_IX_SDT_&ldots;">
 </A>
<H1 CLASS="refHeading">
SocketDeliveryType</H1>
<PRE CLASS="syntax">SocketDeliveryType;
        #define SDT_DATAGRAM 			0x0 		/*  unreliable packets */
        #define SDT_SEQ_PACKET 			0x1 		/*  reliable packets */
        #define SDT_STREAM 			0x2 		/*  reliable bytes */</PRE>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
socket.goh</STRONG>
 </P>
</DIV>
<HR>
<A NAME="S_35.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="S_35.htm_IX_SocketError">
 </A>
<H1 CLASS="refHeading">
SocketError</H1>
<PRE CLASS="syntax">typedef enum {
        SE_NORMAL = 0x0,
        /*  operation completed successfully */
        &nbsp;
        SE_OUT_OF_MEMORY,
        /*
         *  the net library was unable to allocate memory
         *  either there is no more system memory available, or a net-library
         *  specific upper bound on memory usage has been exceeded
         */
        &nbsp;
        SE_PORT_IN_USE,
        /*
         *  Another socket is already bound to this port, and the
         *  SBF_REUSE_PORT flag was not set.
         */
        &nbsp;
        SE_PORT_ALREADY_LISTENING,
        /*  Another socket is already listening on this port. */
        &nbsp;
        SE_SOCKET_IN_USE,
        /*
         *  The socket is already being used in a way inconsistent with the
         *  requested operation
         */
        &nbsp;
        SE_SOCKET_ALREADY_BOUND,
        /*  The socket is already bound to a port. */
        &nbsp;
        SE_SOCKET_NOT_BOUND,
        /*  The socket must be bound to a port for the requested operation. */
        &nbsp;
        SE_SOCKET_NOT_LISTENING,
        /*  The socket must be listening on a port for the requested operation. */
        &nbsp;
        SE_SOCKET_LISTENING,
        /*  A listening socket cannot be used for outgoing connections */
        &nbsp;
        SE_CONNECTION_REFUSED,
        /*  Nobody is listening on the remote port. */
        &nbsp;
        SE_CONNECTION_FAILED,
        /*  The connection is no longer valid, probably due to a 
         *  link failure. */
        &nbsp;
        SE_CONNECTION_CLOSED,
        /*  The connection has been closed from the other end. */
        &nbsp;
        SE_NON_UNIQUE_CONNECTION,
        /*  Another connection with the same endpoint addresses and ports exists. */
        &nbsp;
        SE_TIMED_OUT,
        /*
         *  The timeout period expired before the operation completed.  
         *  In some cases the protocol may enforce a shorter timeout then 
         *  the user-specified value, so this is possible even where
         *  SOCKET_NO_TIMEOUT is used.
         */
        &nbsp;
        SE_CANT_LOAD_DRIVER,
        /*  A driver required to establish the connection could 
         *  not be loaded. */
        &nbsp;
        &nbsp;
        SE_UNKNOWN_DOMAIN,
        /*  The requested domain is not known to the libarary. */
        &nbsp;
        SE_SYSTEM_SHUTDOWN,
        /*  The operation was aborted because GEOS is exiting */
        &nbsp;
        SE_SOCKET_NOT_CONNECTED,
        /*  The operation requires a connected socket */
        &nbsp;
        SE_SOCKET_ALREADY_CLOSED,
        /*  The send side of the socket is already closed */
        &nbsp;
        SE_SOCKET_BUSY,
        /*  Another thread is operating on the socket */
        &nbsp;
        SE_IMPROPER_CONDITION,
        /*
         *  The requested condition for SocketCheckReady is not valid
         *  for a socket in the current state
         */
        &nbsp;
        SE_INFO_NOT_AVAILABLE,
        /*  The driver could not provide the requested information */
        &nbsp;
        SE_DOMAIN_REQUIRES_16BIT_PORTS,
        /*
         *  The requested domain only allows 16 bit port numbers.  The
         *  SP_manuf field must be set to MANUFACTURER_ID_SOCKET_16BIT_PORT
         */
        &nbsp;
        &nbsp;
        SE_CONNECTION_ERROR,
        /*
         *  The connection was not made for some reason which does not have
         *  it's own specific SocketError
         */
        &nbsp;
            SE_MEDIUM_BUSY,
        /*  The medium required for the connection is not available */
        &nbsp;
            SE_DESTINATION_UNREACHABLE,
        /*  The requested destination is not available */
        &nbsp;
            SE_LINK_FAILED,
        /*
         *  The low level link used for this connection failed or could not be
         *  established
         */
        &nbsp;
            SE_INTERNAL_ERROR,
        /*
         *  The socket library received an impossible error code from the driver.
         *  Either the library or the driver has a bug.
         */
        &nbsp;
            SE_CLOSE_SEND_NOT_SUPPORTED,
        /*
         *  It is not possible to close only the send side of a socket in this
         *  domain.  Use SocketClose instead.
         */
        &nbsp;
        SE_BIND_CONFLICT,
        /*
         *  The same port cannot have both domain restricted and 
         *  domain unrestricted bindings.
         */
        &nbsp;
            SE_ALL_PORTS_BUSY,
        /*
         *  SocketConnect attempted to implicitly bind a socket, 
         *  but failed because all port numbers in the range used by 
         *  implicit binds were in use
         */
        &nbsp;
            SE_SOCKET_NOT_INTERRUPTIBLE,
        /*
         *  An operation which cannot be interrupted is in in progress on the
         *  socket
         */
        &nbsp;
            SE_INTERRUPT,
        /*  The operation was interrupted with SocketInterrupt */
        &nbsp;
            SE_PORT_NOT_LISTENING,
        /* No listening socket or LoadOnMsg request exists for this port */
        &nbsp;
            SE_LISTEN_QUEUE_EMPTY,
        /* No connections are pending for this port */
        &nbsp;
            SE_SOCKET_CLOSED,
        /* The socket must be open for sending to call either
         *  SocketGetSocketName or SocketGetPeerName */
        &nbsp;
        SE_BUFFER_TOO_SMALL,
        /*  Returned by SocketResolve to mean that buffer for resolved 
         *  address is too small */
        &nbsp;
        SE_TEMPORARY_ERROR,
        /* Returned by SocketResolve to indicate that address resolution 
         * is temporarily unavailable for external reasons( such as 
         * network down or server failure )*/
        &nbsp;
        SE_EXCEPTION,
        SE_URGENT = SE_EXCEPTION,
        /* Returned by SocketRecv to indicate that some urgent data 
         *  arrived on a reliable socket or an exception was received 
         * for a datagram socket 
         */
        &nbsp;
        SE_NOT_IMPLEMENTED,
        /* Returned by API functions which are not yet implemented */
        &nbsp;
        SE_CONNECTION_RESET
        /* The connection was reset by the peer, by the local driver (perhaps 
         * in response to SocketCloseDomainMedium()), or by the Socket library
         * because the Socket is freed when its owning thread exits. 
         */
} SocketError;</PRE>
<P>
Certain socket routines generate error values or generate thread errors under certain conditions. The error value will consist of a word-length value: a <CODE>
SocketError</CODE>
 value in the low byte, and perhaps a <CODE>
SpecSocketDrError</CODE>
 value in the high byte.</P>
</DIV>
<HR>
<A NAME="S_36.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="S_36.htm_IX_SocketLoadType">
 </A>
<A NAME="S_36.htm_IX_SLT_&ldots;">
 </A>
<H1 CLASS="refHeading">
SocketLoadType</H1>
<PRE CLASS="syntax">typedef enum {
        SLT_USER_LOAD_APPLICATION = 0x0,
        SLT_GEODE_LOAD,
} SocketLoadType;</PRE>
<P>
The Socket library has the ability to load an application when it senses packet coming in to a port. It uses the <CODE>
SocketLoadType</CODE>
 to determine how to load the application: via <CODE>
<A HREF="../../CRef/Routines/R_9e.htm#IX_UserLoadApplication()">UserLoadApplication()</A></CODE>
 or <CODE>
<A HREF="../../CRef/Routines/R_34.htm#IX_GeodeLoad()">GeodeLoad()</A></CODE>
.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
socket.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="S_36.htm_IX_SocketOption">
 </A>
<H1 CLASS="refHeading">
SocketOption</H1>
<PRE CLASS="syntax">typedef enum {
        SO_RECV_BUF = 0x0,                   /* receive buffer size     */
        SO_SEND_BUF = 0x2,                   /* send buffer size        */
        SO_INLINE = 0x4,                     /* inline urgent data      */
        SO_NODELAY = 0x6,                    /* send data immediately   */
        SO_OWNER = 0x8,                      /* which app owns socket   */
} SocketOption;</PRE>
<P>
Various options which may be changed on a per-Socket basis by means of the <CODE>
<A HREF="../../CRef/Routines/R_8a.htm#IX_SocketSetIntSocketOption()">SocketSetIntSocketOption()</A></CODE>
 routine.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
socket.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="S_36.htm_IX_SocketPort">
 </A>
<A NAME="S_36.htm_IX_SP_&ldots;">
 </A>
<H1 CLASS="refHeading">
SocketPort</H1>
<PRE CLASS="syntax">typedef struct {
        word		SP_port;				/*  16-bit port number */
        ManufacturerID		SP_manuf;				/*  16-bit manufacturer's ID */
} SocketPort;</PRE>
<P>
Port numbers identify a particular line of communication within a machine. Port numbers may be 32-bit or 16-bit, depending on the domain. They are specified via the <CODE>
SocketPort</CODE>
 structure, made up of a 16-bit <CODE>
ManufacturerID</CODE>
 and 16-bit token number. If the domain uses 16-bit socket numbers, then use MANUFACTURER_ID_SOCKET_16BIT_PORT as the <CODE>
ManufacturerID</CODE>
. If the domain allows 32-bit socket numbers, then you may use MANUFACTURER_ID_SOCKET_16BIT_PORT or some other <CODE>
ManufacturerID</CODE>
.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
socket.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="S_36.htm_IX_SocketRecvFlags">
 </A>
<A NAME="S_36.htm_IX_SRF_&ldots;">
 </A>
<H1 CLASS="refHeading">
SocketRecvFlags</H1>
<PRE CLASS="syntax">typedef WordFlags SocketRecvFlags;
        #define SRF_ADDRESS (0x8000) 					/*  return source address of data */
        #define SRF_URGENT (0x4000) 					/*  return urgent data, if any */
        #define SRF_PEEK (0x2000) 					/*  leave data in socket */</PRE>
<P>
These flags allow you to set options when receiving data from a socket. SRF_ADDRESS requests the address of the machine sending the data. SRF_URGENT requests that only urgent data be returned, if any. SRF_PEEK asks that the data be left on the socket. </P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
socket.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="S_36.htm_IX_SocketSendFlags">
 </A>
<A NAME="S_36.htm_IX_SSF_&ldots;">
 </A>
<H1 CLASS="refHeading">
SocketSendFlags</H1>
<PRE CLASS="syntax">typedef WordFlags SocketSendFlags;
        #define SSF_ADDRESS (0x8000) 						/*  an address is supplied */
        #define SSF_URGENT (0x4000) 						/*  this is urgent data */
        #define SSF_OPEN_LINK (0x2000)					 	/*  this datagram should open the
        						 *    link, if it is closed       */
        &nbsp;</PRE>
<P>
Use this structure to specify options when sending data over a socket. You may signal that you are specifying an address and/or that the packet sent should be marked urgent.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
socket.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="S_36.htm_IX_SortOrder">
 </A>
<H1 CLASS="refHeading">
SortOrder</H1>
<PRE CLASS="syntax">typedef ByteEnum SortOrder;
#define SO_ASCENDING				0
#define SO_DESCENDING				1</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_36.htm_IX_SoundDriverCapability">
 </A>
<A NAME="S_36.htm_IX_SDC_&ldots;">
 </A>
<A NAME="S_36.htm_IX_SoundDriverNoiseCapability">
 </A>
<A NAME="S_36.htm_IX_SDNC_&ldots;">
 </A>
<A NAME="S_36.htm_IX_SoundDriverWaveFormCapability">
 </A>
<A NAME="S_36.htm_IX_SDWFC_&ldots;">
 </A>
<A NAME="S_36.htm_IX_SoundDriverTimbreCapability">
 </A>
<A NAME="S_36.htm_IX_SDTC_&ldots;">
 </A>
<A NAME="S_36.htm_IX_SoundDriverEnvelopeCapability">
 </A>
<A NAME="S_36.htm_IX_SDEC_&ldots;">
 </A>
<H1 CLASS="refHeading">
SoundDriverCapability</H1>
<PRE CLASS="syntax">typedef WordFlags SoundDriverCapability;
#define SDC_NOISE 				0x8000
#define SDC_WAVEFORM 				0x6000
#define SDC_TIMBRE 				0x1800
#define SDC_ENVELOPE 				0x0600
&nbsp;
typedef WordFlags SoundDriverNoiseCapability;
#define SDNC_NO_NOISE 				0x0000
#define SDNC_WHITE_NOISE 				0x8000
&nbsp;
typedef WordFlags SoundDriverWaveFormCapability
#define SDWFC_NONE 				0x0000
#define SDWFC_SELECT 				0x2000
#define SDWFC_GENERATE 				0x4000
&nbsp;
typedef WordFlags SoundDriverTimbreCapability;
#define SDTC_TONE_GENERATOR 0x0000
#define SDTC_ADDITIVE 				0x0800
#define SDTC_MODULATOR 				0x1000
#define SDTC_SELECTIVE 				0x1800
&nbsp;
typedef WordFlags SoundDriverEnvelopeCapability;
#define SDEC_NONE 				0x0000
#define SDEC_ADSR 				0x0200
#define SDEC_DSP 				0x0400</PRE>
<P>
These fields encode information about what the sound driver is capable of in terms of music synthesis.</P>
</DIV>
<HR>
<A NAME="S_37.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="S_37.htm_IX_SoundPlayFlags">
 </A>
<A NAME="S_37.htm_IX_SPF_HIGH_PRIORITY">
 </A>
<H1 CLASS="refHeading">
SoundPlayFlags</H1>
<PRE CLASS="syntax">typedef WordFlags SoundPlayFlags;
#define SPF_HIGH_PRIORITY				0x8000</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_37.htm_IX_SoundPriority">
 </A>
<A NAME="S_37.htm_IX_SP_&ldots;  (SoundPriority type)">
 </A>
<H1 CLASS="refHeading">
SoundPriority</H1>
<PRE CLASS="syntax">typedef enum {
 SP_SYSTEM_LEVEL=10, 				/* most urgent */
 SP_ALARM=20,
 SP_STANDARD=30,
 SP_GAME=40,
 SP_BACKGROUND=50 				/* least urgent */
} SoundPriority;
&nbsp;
#define SP_IMMEDIATE 			-1
#define SP_THEME 			+1</PRE>
<P>
If the user's sound device can't play all requested sounds, it will use <CODE>
SoundPriority</CODE>
 values to determine which sounds are the most important.</P>
<P>
The highest priority sound you may construct using these values is (SP_SYSTME_LEVEL + SP_IMMEDIATE). The least priority sound would be (SP_BACKGROUND + SP_THEME).</P>
</DIV>
<DIV>
<A NAME="S_37.htm_IX_SoundStreamDeltaTimeType">
 </A>
<A NAME="S_37.htm_IX_SSDTT_&ldots;">
 </A>
<A NAME="S_37.htm_IX_Delta&ldots; () macros">
 </A>
<H1 CLASS="refHeading">
SoundStreamDeltaTimeType</H1>
<PRE CLASS="syntax">typedef enum {
 SSDTT_MSEC=8, 				/* wait for N mili seconds */
 SSDTT_TICKS=10, 				/* wait for N ticks */
 SSDTT_TEMPO=12, 				/* wait for N beats */
} SoundStreamDeltaTimeType;
/* The following macros may help when constructing music buffers */
#define DeltaTick(time)  				SSDTT_TICKS, time
#define DeltaMS(time)  				SSDTT_MSEC, time
#define DeltaTempo(time) 				SSDTT_TEMPO, time
&nbsp;</PRE>
<P>
These are the units by which you can specify a sound's duration: milliseconds, timer &quot;ticks&quot; (each 1/60 second), or by means of an independently supplied tempo.</P>
</DIV>
<DIV>
<A NAME="S_37.htm_IX_SoundStreamEvents">
 </A>
<A NAME="S_37.htm_IX_SSE_&ldots;">
 </A>
<H1 CLASS="refHeading">
SoundStreamEvents</H1>
<PRE CLASS="syntax">typedef enum {
 SSE_VOICE_ON=0, 				/* turn on voice event */
 SSE_VOICE_OFF=2, 				/* turn off voice event */
 SSE_CHANGE=4, 				/* change instrument */
 SSE_GENERAL=6 				/* system-specific event */
} SoundStreamEvents;
/* The following macros may help when constructing music buffers */
#define General(command)  SSE_GENERAL, command
&nbsp;
#define Rest(duration)  General(GE_NO_EVENT), DeltaTick(duration)
&nbsp;
#define VoiceOn(voice,freq,attack)  SSE_VOICE_ON, voice, freq, attack
#define VoiceOff(voice) SSE_VOICE_OFF, voice
#define ChangeEnvelope(voice, instrument, table)  \
					SSE_CHANGE, voice, instrument, table</PRE>
<PRE CLASS="syntax">&nbsp;
#define SoundNote(voice,freq,duration,attack)  \
	VoiceOn(voice, freq, attack), DeltaTempo(duration), VoiceOff(voice)</PRE>
<PRE CLASS="syntax">#define Staccato(voice,freq,duration,attack) \
 	VoiceOn(voice, freq, attack), DeltaTempo(((duration*0x03)/0x04)), \
 	VoiceOff(voice), DeltaTempo((duration/0x4))</PRE>
<PRE CLASS="syntax">#define Natural(voice,freq,duration,attack) \
	VoiceOn(voice, freq, attack), DeltaTempo(((duration*0x07)/0x08)),
	VoiceOff(voice), DeltaTempo((duration/0x8))</PRE>
<PRE CLASS="syntax">#define Legato(voice,freq,duration,attack)  \
	SoundNote(voice, freq, duration, attack)</PRE>
<P>
These are the &quot;events&quot; that make up a music buffer. </P>
</DIV>
<DIV>
<A NAME="S_37.htm_IX_SoundStreamSize">
 </A>
<A NAME="S_37.htm_IX_SSS_&ldots;  (SoundStreamSize type)">
 </A>
<H1 CLASS="refHeading">
SoundStreamSize</H1>
<PRE CLASS="syntax">typedef word SoundStreamSize;
#define SSS_ONE_SHOT 128 /* 128 bytes (very small) */
#define SSS_SMALL 256 /* 256 bytes */
#define SSS_MEDIUM 512 /* 512 bytes (nice size) */
#define SSS_LARGE 1024 </PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_37.htm_IX_SpecHeight">
 </A>
<A NAME="S_37.htm_IX_SH_&ldots;  (SpecHeight flags)">
 </A>
<H1 CLASS="refHeading">
SpecHeight</H1>
<PRE CLASS="syntax">typedef WordFlags SpecHeight;
#define SH_TYPE				0x8c00
#define SH_DATA				0x03ff</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_37.htm_IX_SpecSizeSpec">
 </A>
<A NAME="S_37.htm_IX_SSS_&ldots;  (SpecSizeSpec flags)">
 </A>
<H1 CLASS="refHeading">
SpecSizeSpec</H1>
<PRE CLASS="syntax">typedef WordFlags SpecSizeSpec;
#define SSS_TYPE				0x8c00
#define SSS_DATA				0x03ff</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_37.htm_IX_SST_&ldots;  (SpecSizeType type)">
 </A>
<A NAME="S_37.htm_IX_PCT_&ldots;  (SpecSizeType Percent constants)">
 </A>
<H1 CLASS="refHeading">
SpecSizeType</H1>
<PRE CLASS="syntax">typedef ByteEnum SpecSizeType;
#define SST_PIXELS						0x0000
#define SST_COUNT						0x0400
#define SST_PCT_OF_FIELD_WIDTH						0x0800
#define SST_PCT_OF_FIELD_HEIGHT						0x0c00
#define SST_AVG_CHAR_WIDTHS						0x1000
#define SST_WIDE_CHAR_WIDTHS						0x1400
#define SST_LINES_OF_TEXT						0x1800

</PRE>
</DIV>
<DIV>
<A NAME="S_37.htm_IX_SpecSocketDrError">
 </A>
<H1 CLASS="refHeading">
SpecSocketDrError</H1>
<PRE CLASS="syntax">typedef enum /*word*/ {
        SSDE_DEVICE_BUSY = 0x0100,      						/* serial port or modem 
							   driver in use */</PRE>
<PRE CLASS="syntax">        SSDE_DIAL_ERROR = 0x0200,
        SSDE_LINE_BUSY = 0x0300,        /* modem got a busy signal */
        SSDE_NO_DIALTONE = 0x0400,
        SSDE_NO_ANSWER = 0x0500,
        SSDE_NO_CARRIER = 0x0600,
        SSDE_BLACKLISTED = 0x0700,      /* used in GSM network */
        SSDE_DELAYED = 0x0800,          /* used in GSM network */
        SSDE_CALL_FAILED = 0x0900, 						/* couldn't dial for some reason */
        SSDE_NEG_FAILED = 0x0a00,
        SSDE_AUTH_REFUSED = 0x0b00,
        SSDE_AUTH_FAILED = 0x0c00,
        SSDE_LQM_FAILURE = 0x0d00,
        SSDE_LOOPED_BACK = 0x0e00,
        SSDE_IDLE_TIMEOUT = 0x0f00,
        SSDE_DEVICE_NOT_FOUND = 0x1000,
        SSDE_DEVICE_TIMEOUT = 0x1100,
        SSDE_DEVICE_ERROR = 0x1200,
        SSDE_NO_USERNAME = 0x1300, 						/* no username and password
							   prompting used */</PRE>
<PRE CLASS="syntax">        SSDE_CANCEL = 0x1400,           /* user cancelled */
        SSDE_INVALID_ACCPNT = 0x1500    /* invalid access point */
} SpecSocketDrError;</PRE>
<P>
Certain Socket library operations may return an error value as a <CODE>
SocketError</CODE>
 value. If the root cause of the error was a low-level communications failure, then the high byte of the returned error word may contain a <CODE>
SpecSocketDrError</CODE>
 value, with the <CODE>
SocketError</CODE>
 value in the low byte.</P>
</DIV>
<HR>
<A NAME="S_38.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="S_38.htm_IX_SpecWidth">
 </A>
<A NAME="S_38.htm_IX_SW_&ldots;">
 </A>
<H1 CLASS="refHeading">
SpecWidth</H1>
<PRE CLASS="syntax">typedef WordFlags SpecWidth
#define SW_TYPE				0x8c00
#define SW_DATA				0x03ff</PRE>
<PRE CLASS="syntax">&nbsp;
#define PCT_0				0x000
#define PCT_5				0x033
#define PCT_10				0x066
#define PCT_15				0x099
#define PCT_20				0x0cc
#define PCT_25				0x100
#define PCT_30				0x133
#define PCT_35				0x166
#define PCT_40				0x199
#define PCT_45				0x1cc
#define PCT_50				0x200
#define PCT_55				0x233
#define PCT_60				0x266
#define PCT_65				0x299
#define PCT_70				0x2cc
#define PCT_75				0x300
#define PCT_80				0x333
#define PCT_85				0x366
#define PCT_90				0x399
#define PCT_95				0x3cc
#define PCT_100				0x3ff</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_38.htm_IX_SpecWinSizePair">
 </A>
<A NAME="S_38.htm_IX_SWSP_&ldots;">
 </A>
<H1 CLASS="refHeading">
SpecWinSizePair</H1>
<PRE CLASS="syntax">typedef struct {
SpecWinSizeSpec				SWSP_x;
SpecWinSizeSpec				SWSP_y;</PRE>
<PRE CLASS="syntax">} SpecWinSizePair;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_38.htm_IX_SpecWinSizeSpec">
 </A>
<A NAME="S_38.htm_IX_SWSS_&ldots;">
 </A>
<H1 CLASS="refHeading">
SpecWinSizeSpec</H1>
<PRE CLASS="syntax">typedef WordFlags SpecWinSizeSpec;
#define SWSS_RATIO				0x8000
#define SWSS_SIGN				0x4000
#define SWSS_MANTISSA				0x3c00
#define SWSS_FRACTION				0x03ff</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_38.htm_IX_SpecialFunctions">
 </A>
<A NAME="S_38.htm_IX_SF_&ldots;  (SpecialFunctions type)">
 </A>
<H1 CLASS="refHeading">
SpecialFunctions</H1>
<PRE CLASS="syntax">typedef enum /* word */ {
SF_FILENAME,
SF_PAGE,
SF_PAGES,
} SpecialFunctions;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_38.htm_IX_SpoolError">
 </A>
<A NAME="S_38.htm_IX_SERROR_&ldots;">
 </A>
<H1 CLASS="refHeading">
SpoolError</H1>
<PRE CLASS="syntax">typedef enum /* word */ {
SERROR_NO_SPOOL_FILE,
SERROR_NO_PRINT_DRIVER,
SERROR_NO_PORT_DRIVER,
SERROR_NO_PRINTERS,
SERROR_NO_MODE_AVAIL,
SERROR_CANT_ALLOC_BITMAP,
SERROR_NO_VIDMEM_DRIVER,
SERROR_MANUAL_PAPER_FEED,
SERROR_CANT_LOAD_PORT_DRIVER,
SERROR_PORT_BUSY,
SERROR_TEST_NO_PAPER,
SERROR_TEST_OFFLINE,
SERROR_TEST_PARALLEL_ERROR,
SERROR_MISSING_COM_PORT,
SERROR_PRINT_ON_STARTUP
} SpoolError;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_38.htm_IX_SpoolFileName">
 </A>
<A NAME="S_38.htm_IX_SFN_&ldots;">
 </A>
<H1 CLASS="refHeading">
SpoolFileName</H1>
<PRE CLASS="syntax">typedef struct {
char	SFN_base[5];
char	SFN_num[3];
char	SFN_ext[5];
} SpoolFileName;</PRE>
<P>
&nbsp;</P>
</DIV>
<HR>
<A NAME="S_39.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="S_39.htm_IX_SpoolInfoType">
 </A>
<A NAME="S_39.htm_IX_SIT_&ldots;">
 </A>
<H1 CLASS="refHeading">
SpoolInfoType</H1>
<PRE CLASS="syntax">typedef enum /* word */ {
SIT_JOB_INFO,
SIT_QUEUE_INFO
} SpoolInfoType;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_39.htm_IX_SpoolOpStatus">
 </A>
<A NAME="S_39.htm_IX_SPOOL_&ldots;">
 </A>
<H1 CLASS="refHeading">
SpoolOpStatus</H1>
<PRE CLASS="syntax">typedef enum /* word */ {
SPOOL_OPERATION_SUCCESSFUL,
SPOOL_JOB_NOT_FOUND,
SPOOL_QUEUE_EMPTY,
SPOOL_QUEUE_NOT_EMPTY,
SPOOL_QUEUE_NOT_FOUND,
SPOOL_CANT_VERIFY_PORT,
SPOOL_OPERATION_FAILED
} SpoolOpStatus;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_39.htm_IX_SpoolTimeStruct">
 </A>
<A NAME="S_39.htm_IX_STS_&ldots;">
 </A>
<H1 CLASS="refHeading">
SpoolTimeStruct</H1>
<PRE CLASS="syntax">typedef struct {
byte	STS_second;			/* second of the minute (0-59) */
byte	STS_minute;			/* minute of the hour (0-59) */
byte	STS_hour;			/* hour of the day (0-23) */
} SpoolTimeStruct;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_39.htm_IX_SpoolVerifyAction">
 </A>
<A NAME="S_39.htm_IX_SVA_&ldots;">
 </A>
<H1 CLASS="refHeading">
SpoolVerifyAction</H1>
<PRE CLASS="syntax">typedef enum {
SVA_NO_MESSAGE,
SVA_WARNING,
SVA_PRINTING
} SpoolVerifyAction;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_39.htm_IX_StandardDialogBoxType">
 </A>
<A NAME="S_39.htm_IX_SDBT_&ldots;">
 </A>
<H1 CLASS="refHeading">
StandardDialogBoxType</H1>
<PRE CLASS="syntax">typedef enum {
SDBT_FILE_NEW_CANNOT_CREATE_TEMP_NAME,
SDBT_FILE_NEW_INSUFFICIENT_DISK_SPACE,
SDBT_FILE_NEW_ERROR,
SDBT_FILE_NEW_WRITE_PROTECTED,
SDBT_FILE_OPEN_SHARING_DENIED,
SDBT_FILE_OPEN_FILE_NOT_FOUND,
SDBT_FILE_OPEN_INVALID_VM_FILE,
SDBT_FILE_OPEN_INSUFFICIENT_DISK_SPACE,
SDBT_FILE_OPEN_ERROR,
SDBT_FILE_OPEN_READ_ONLY,
SDBT_FILE_OPEN_VM_DIRTY,
SDBT_FILE_OPEN_APP_MORE_RECENT_THAN_DOC,
SDBT_FILE_OPEN_DOC_MORE_RECENT_THAN_APP,
SDBT_FILE_SAVE_INSUFFICIENT_DISK_SPACE,
SDBT_FILE_SAVE_ERROR,
SDBT_FILE_SAVE_WRITE_PROTECTED,
SDBT_FILE_SAVE_AS_FILE_EXISTS,
SDBT_FILE_SAVE_AS_SHARING_DENIED,
SDBT_FILE_CLOSE_SAVE_CHANGES,
SDBT_FILE_CLOSE_ATTACH_DIRTY,
SDBT_FILE_REVERT_CONFIRM,
SDBT_FILE_REVERT_ERROR,
SDBT_FILE_ATTACH_DISK_NOT_FOUND,
SDBT_CANNOT_OPEN_VOLUME_SELECTED,
SDBT_QUERY_SAVE_AS_TEMPLATE,
SDBT_QUERY_SAVE_AS_EMPTY,
SDBT_QUERY_SAVE_AS_DEFAULT,
SDBT_QUERY_SAVE_AS_MULTI_USER,
SDBT_QUERY_SAVE_AS_PUBLIC,
SDBT_QUERY_RESET_EMPTY_FILE,
SDBT_QUERY_RESET_DEFAULT_FILE,
SDBT_CANNOT_OPEN_EMPTY_FILE
} StandardDialogBoxType;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_39.htm_IX_StandardDialogParams">
 </A>
<A NAME="S_39.htm_IX_SDP_&ldots;">
 </A>
<H1 CLASS="refHeading">
StandardDialogParams</H1>
<PRE CLASS="syntax">typedef struct {
word							 SDP_customFlags;
char							*SDP_customString;
char							*SDP_stringArg1;
char							*SDP_stringArg2;
StandardDialogResponseTriggerTable							*SDP_customTriggers;
} StandardDialogParams;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_39.htm_IX_StandardDialogOptrParams">
 </A>
<A NAME="S_39.htm_IX_SDOP_&ldots;">
 </A>
<H1 CLASS="refHeading">
StandardDialogOptrParams</H1>
<PRE CLASS="syntax">typedef struct {
word	SDOP_customFlags;
optr	SDOP_customString;
optr	SDOP_stringArg1;
optr	SDOP_stringArg2;
optr	SDOP_customTriggers;
} StandardDialogOptrParams;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_39.htm_IX_StandardDialogResponseTriggerEntry">
 </A>
<A NAME="S_39.htm_IX_SDRTE_&ldots;">
 </A>
<H1 CLASS="refHeading">
StandardDialogResponseTriggerEntry</H1>
<PRE CLASS="syntax">typedef struct {
optr	SDRTE_moniker;
word	SDRTE_responseValue;
} StandardDialogResponseTriggerEntry;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_39.htm_IX_StandardDialog1ResponseTriggerTable">
 </A>
<A NAME="S_39.htm_IX_SD1RTT_&ldots;">
 </A>
<H1 CLASS="refHeading">
StandardDialog1ResponseTriggerTable</H1>
<PRE CLASS="syntax">typedef struct {
 word							SD1RTT_numTriggers;
 StandardDialogResponseTriggerEntry							SD1RTT_trigger1;
} StandardDialog1ResponseTriggerTable;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_39.htm_IX_StandardDialog2ResponseTriggerTable">
 </A>
<A NAME="S_39.htm_IX_SD2RTT_&ldots;">
 </A>
<H1 CLASS="refHeading">
StandardDialog2ResponseTriggerTable</H1>
<PRE CLASS="syntax">typedef struct {
 word							SD2RTT_numTriggers;
 StandardDialogResponseTriggerEntry							SD2RTT_trigger1;
 StandardDialogResponseTriggerEntry							SD2RTT_trigger2;
} StandardDialog2ResponseTriggerTable;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_39.htm_IX_StandardDialog3ResponseTriggerTable">
 </A>
<A NAME="S_39.htm_IX_SD3RTT_&ldots;">
 </A>
<H1 CLASS="refHeading">
StandardDialog3ResponseTriggerTable</H1>
<PRE CLASS="syntax">typedef struct {
 word							SD3RTT_numTriggers;
 StandardDialogResponseTriggerEntry							SD3RTT_trigger1;
 StandardDialogResponseTriggerEntry							SD3RTT_trigger2;
 StandardDialogResponseTriggerEntry							SD3RTT_trigger3;
} StandardDialog3ResponseTriggerTable;</PRE>
<P>
&nbsp;</P>
</DIV>
<HR>
<A NAME="S_3a.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="S_3a.htm_IX_StandardDialog4ResponseTriggerTable">
 </A>
<A NAME="S_3a.htm_IX_SD4RTT_&ldots;">
 </A>
<H1 CLASS="refHeading">
StandardDialog4ResponseTriggerTable</H1>
<PRE CLASS="syntax">typedef struct {
 word								SD4RTT_numTriggers;
 StandardDialogResponseTriggerEntry 								SD4RTT_trigger1;
 StandardDialogResponseTriggerEntry 								SD4RTT_trigger2;
 StandardDialogResponseTriggerEntry 								SD4RTT_trigger3;
 StandardDialogResponseTriggerEntry 								SD4RTT_trigger4;
} StandardDialog4ResponseTriggerTable;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_3a.htm_IX_StandardPath">
 </A>
<A NAME="S_3a.htm_IX_SP_&ldots;  (StandardPath type)">
 </A>
<H1 CLASS="refHeading">
StandardPath</H1>
<PRE CLASS="syntax">typedef enum /* word */ {
SP_NOT_STANDARD_PATH=0,
SP_TOP=1,
SP_APPLICATION=3,
SP_DOCUMENT=5,
SP_SYSTEM=7,
SP_PRIVATE_DATA=9,
SP_STATE=11,
SP_FONT=13,
SP_SPOOL=15,
SP_SYS_APPLICATION=17,
SP_PUBLIC_DATA=19,
SP_MOUSE_DRIVERS=21,
SP_PRINTER_DRIVERS=23,
SP_FILE_SYSTEM_DRIVERS=25,
SP_VIDEO_DRIVERS=27,
SP_SWAP_DRIVERS=29,
SP_KEYBOARD_DRIVERS=31,
SP_FONT_DRIVERS=33,
SP_IMPORT_EXPORT_DRIVERS=35,
SP_TASK_SWITCH_DRIVERS=37,
SP_HELP_FILES=39,
SP_TEMPLATE=41,
SP_POWER_DRIVERS=43,
SP_DOS_ROOM=45,
SP_HWR=47,
SP_WASTE_BASKET=49,
SP_BACKUP=51,
SP_PAGER_DRIVERS=53
SP_DUMMY=256
} StandardPath;</PRE>
<P>
Most routines which are passed disk handles can also be passed members of the <CODE>
StandardPath</CODE>
 enumerated type. Standard paths let applications access files in a disk-independent manner. Standard paths are usually arranged in a certain hierarchy; for example, the STATE directory usually belongs to the PRIVDATA directory. However, this is entirely at the user's discretion; applications may not make any assumption about how the standard paths are arranged.</P>
</DIV>
<DIV>
<A NAME="S_3a.htm_IX_StandardSoundType">
 </A>
<H1 CLASS="refHeading">
StandardSoundType</H1>
<P>
See <CODE>
<A HREF="../../CRef/Routines/R_9f.htm#IX_UserStandardSound()">UserStandardSound()</A></CODE>
.</P>
</DIV>
<DIV>
<A NAME="S_3a.htm_IX_StreamBlocker">
 </A>
<A NAME="S_3a.htm_IX_STREAM_&ldots;  (StreamBlocker type)">
 </A>
<H1 CLASS="refHeading">
StreamBlocker</H1>
<PRE CLASS="syntax">typedef	enum{
	STREAM_BLOCK			= 2,
	STREAM_NO_BLOCK			= 0
} StreamBlocker;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_3a.htm_IX_StreamError">
 </A>
<A NAME="S_3a.htm_IX_STREAM_&ldots;  (StreamError type)">
 </A>
<H1 CLASS="refHeading">
StreamError</H1>
<PRE CLASS="syntax">typedef	enum{
	STREAM_WOULD_BLOCK,
	STREAM_CLOSING,
	STREAM_CANNOT_ALLOC,
	STREAM_BUFFER_TOO_LARGE,
	STREAM_CLOSED,
	STREAM_SHORT_READ_WRITE
} StreamError;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_3a.htm_IX_StreamOpenFlags">
 </A>
<A NAME="S_3a.htm_IX_STREAM_OPEN_&ldots;">
 </A>
<H1 CLASS="refHeading">
StreamOpenFlags</H1>
<PRE CLASS="syntax">typedef	enum {
	STREAM_OPEN_NO_BLOCK				= 0x01,
	STREAM_OPEN_TIMEOUT				= 0x02
} StreamOpenFlags</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_3a.htm_IX_StreamToken">
 </A>
<H1 CLASS="refHeading">
StreamToken</H1>
<PRE CLASS="syntax">typedef Handleword StreamToken;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_3a.htm_IX_StreamRoles">
 </A>
<A NAME="S_3a.htm_IX_STREAM_ROLES_&ldots;">
 </A>
<H1 CLASS="refHeading">
StreamRoles</H1>
<PRE CLASS="syntax">typedef	enum {
	STREAM_ROLES_WRITER				= 0,
	STREAM_ROLES_READER				= -1,
	STREAM_ROLES_BOTH				= -2
} StreamRoles;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_3a.htm_IX_StyleChunkDesc">
 </A>
<A NAME="S_3a.htm_IX_SCD_&ldots;">
 </A>
<H1 CLASS="refHeading">
StyleChunkDesc</H1>
<PRE CLASS="syntax">typedef struct {
VMFileHandle			SCD_vmFile;
word			SCD_vmBlockOrMemHandle;
ChunkHandle			SCD_chunk;
} StyleChunkDesc;</PRE>
<P>
&nbsp;</P>
</DIV>
<HR>
<A NAME="S_3b.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="S_3b.htm_IX_StyleElementFlags">
 </A>
<A NAME="S_3b.htm_IX_SEF_DISPLAY_IN_TOOLBOX">
 </A>
<H1 CLASS="refHeading">
StyleElementFlags</H1>
<PRE CLASS="syntax">typedef WordFlags StyleElementFlags;
#define SEF_DISPLAY_IN_TOOLBOX						0x8000</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_3b.htm_IX_StyleElementHeader">
 </A>
<A NAME="S_3b.htm_IX_SEH_&ldots;">
 </A>
<H1 CLASS="refHeading">
StyleElementHeader</H1>
<PRE CLASS="syntax">typedef struct {
NameArrayElement				SEH_meta;
word				SEH_baseStyle;
StyleElementFlags				SEH_flags;
dword				SEH_privateData;
} StyleElementHeader;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_3b.htm_IX_StyleSheetElementHeader">
 </A>
<A NAME="S_3b.htm_IX_SSEH_&ldots;">
 </A>
<H1 CLASS="refHeading">
StyleSheetElementHeader</H1>
<PRE CLASS="syntax">typedef struct {
 RefElementHeader				SSEH_meta;
 word				SSEH_style;
} StyleSheetElementHeader;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_3b.htm_IX_SupportedEnvelopeForamt">
 </A>
<A NAME="S_3b.htm_IX_SEF_&ldots;  (SupportedEnvelopeFormat type)">
 </A>
<H1 CLASS="refHeading">
SupportedEnvelopeFormat</H1>
<PRE CLASS="syntax">typedef enum {
 SEF_NO_FORMAT,
 SEF_SBI_FORMAT,
 SEF_CTI_FORMAT
} SupportedEnvelopeFormat;</PRE>
<P>
These values specify how a sound device can simulate musical instruments, if it can at all.</P>
</DIV>
<DIV>
<A NAME="S_3b.htm_IX_sword">
 </A>
<H1 CLASS="refHeading">
sword</H1>
<PRE CLASS="syntax">typedef signed short sword;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_3b.htm_IX_SysConfigFlags">
 </A>
<A NAME="S_3b.htm_IX_SCF_&ldots;">
 </A>
<H1 CLASS="refHeading">
SysConfigFlags</H1>
<PRE CLASS="syntax">typedef ByteFlags SysConfigFlags;
#define SCF_UNDER_SWAT				0x80
#define SCF_2ND_IC 				0x40
#define SCF_RTC 				0x20
#define SCF_COPROC 				0x10
#define SCF_RESTARTED 				0x08
#define SCF_CRASHED 				0x04
#define SCF_MCA 				0x02
#define SCF_LOGGING				0x01</PRE>
<P>
The above flags indicate the system configuration. Any or all of these flags may be set at a time; if a flag is set, the description is true. These flags are used by the kernel and can be retrieved with <CODE>
<A HREF="../../CRef/Routines/R_92.htm#IX_SysGetConfig()">SysGetConfig()</A></CODE>
.</P>
</DIV>
<DIV>
<A NAME="S_3b.htm_IX_SysDrawMask">
 </A>
<A NAME="S_3b.htm_IX_SDM_&ldots;  (SysDrawMask)">
 </A>
<H1 CLASS="refHeading">
SysDrawMask</H1>
<PRE CLASS="syntax">typedef ByteFlags SysDrawMask;
#define SDM_INVERSE				0x80
#define SDM_MASK				0x7f</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_3b.htm_IX_SysGetInfoType">
 </A>
<H1 CLASS="refHeading">
SysGetInfoType</H1>
<P CLASS="refField"><STRONG>
<STRONG>
See:</STRONG></STRONG>
	<CODE>
<A HREF="../../CRef/Routines/R_92.htm#IX_SysGetInfo()">SysGetInfo()</A></CODE>
.</P>
</DIV>
<DIV>
<A NAME="S_3b.htm_IX_SysMachineType">
 </A>
<A NAME="S_3b.htm_IX_SMT_&ldots;">
 </A>
<H1 CLASS="refHeading">
SysMachineType</H1>
<PRE CLASS="syntax">typedef ByteEnum SysMachineType;
#define SMT_UNKNOWN				0
#define SMT_PC 				1
#define SMT_PC_CONV 				2
#define SMT_PC_JR 				3
#define SMT_PC_XT 				4
#define SMT_PC_XT_286 				5
#define SMT_PC_AT 				6
#define SMT_PS2_30 				7
#define SMT_PS2_50 				8
#define SMT_PS2_60 				9
#define SMT_PS2_80 				10
#define SMT_PS1 				11</PRE>
<P>
A byte-sized value indicating the type of machine running GEOS. This value can be retrieved with <CODE>
<A HREF="../../CRef/Routines/R_92.htm#IX_SysGetConfig()">SysGetConfig()</A></CODE>
.</P>
</DIV>
<DIV>
<A NAME="S_3b.htm_IX_SysNotifyFlags">
 </A>
<H1 CLASS="refHeading">
SysNotifyFlags</H1>
<P CLASS="refField"><STRONG>
<STRONG>
See:</STRONG></STRONG>
	<CODE>
<A HREF="../../CRef/Routines/R_93.htm#IX_SysNotify()">SysNotify()</A></CODE>
.</P>
</DIV>
<DIV>
<A NAME="S_3b.htm_IX_SysProcessorType">
 </A>
<A NAME="S_3b.htm_IX_SPT_&ldots;  (SysProcessorType type)">
 </A>
<H1 CLASS="refHeading">
SysProcessorType</H1>
<PRE CLASS="syntax">typedef ByteEnum SysProcessorType;
#define SPT_8088				0
#define SPT_8086 				0
#define SPT_80186 				1
#define SPT_80286 				2
#define SPT_80386 				3
#define SPT_80486 				4</PRE>
<P>
This enumerated type is a byte that indicates the type of processor on the system running GEOS. It can be retrieved with <CODE>
<A HREF="../../CRef/Routines/R_92.htm#IX_SysGetConfig()">SysGetConfig()</A></CODE>
.</P>
</DIV>
<DIV>
<A NAME="S_3b.htm_IX_SysShutdownType">
 </A>
<H1 CLASS="refHeading">
SysShutdownType</H1>
<P CLASS="refField"><STRONG>
<STRONG>
See:</STRONG></STRONG>
	<CODE>
<A HREF="../../CRef/Routines/R_94.htm#IX_SysShutdown()">SysShutdown()</A></CODE>
.</P>
</DIV>
<DIV>
<A NAME="S_3b.htm_IX_SysStats">
 </A>
<A NAME="S_3b.htm_IX_SS_&ldots;  (SysStats struct)">
 </A>
<H1 CLASS="refHeading">
SysStats</H1>
<PRE CLASS="syntax">typedef struct {
dword 		SS_idleCount;				/* Idle ticks in the last second. */
SysSwapInfo	 	SS_swapOuts;				/* Outward-bound swap activity. */
SysSwapInfo 		SS_swapIns;				/* Inward-bound swap actividy. */
word 		SS_contextSwitches;				/* Context switches in last second. */
word 		SS_interrupts;				/* Interrupts in the last second. */
word 		SS_runQueue;				/* Runnable threads at end of
						 * last second. */</PRE>
<PRE CLASS="syntax">} SysStats;</PRE>
<P>
This structure is returned by <CODE>
<A HREF="../../CRef/Routines/R_94.htm#IX_SysStatistics()">SysStatistics()</A></CODE>
 and represents the current performance statistics of GEOS.</P>
</DIV>
<DIV>
<A NAME="S_3b.htm_IX_SysSwapInfo">
 </A>
<A NAME="S_3b.htm_IX_SSI_&ldots;">
 </A>
<H1 CLASS="refHeading">
SysSwapInfo</H1>
<PRE CLASS="syntax">typedef struct {
word 	SSI_paragraphs;			/* Number of paragraphs swapped. */
word 	SSI_blocks;			/* Number of blocks swapped. */
} SysSwapInfo;</PRE>
<P>
Structure used to represent current swap activity in <CODE>
SysStats</CODE>
 structure.</P>
</DIV>
<HR>
<A NAME="S_3c.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="S_3c.htm_IX_SystemDrawMask">
 </A>
<A NAME="S_3c.htm_IX_SDM_&ldots;  (SystemDrawMask type)">
 </A>
<A NAME="S_3c.htm_IX_SET_CUSTOM_PATTERN">
 </A>
<H1 CLASS="refHeading">
SystemDrawMask</H1>
<PRE CLASS="syntax">typedef ByteEnum SystemDrawMask;
#define SDM_TILE					0
#define SDM_SHADED_BAR 					1
#define SDM_HORIZONTAL 					2
#define SDM_VERTICAL 					3
#define SDM_DIAG_NE 					4
#define SDM_DIAG_NW 					5
#define SDM_GRID 					6
#define SDM_BIG_GRID 					7
#define SDM_BRICK 					8
#define SDM_SLANT_BRICK 					9
#define SDM_0 					89
#define SDM_12_5 					81
#define SDM_25 					73
#define SDM_37_5 					65
#define SDM_50 					57
#define SDM_62_5 					49
#define SDM_75 					41
#define SDM_87_5 					33
#define SDM_100 					25
#define SDM_CUSTOM 					0x7f
#define SET_CUSTOM_PATTERN 					SDM_CUSTOM</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_3c.htm_IX_SystemHatch">
 </A>
<A NAME="S_3c.htm_IX_SH_&ldots;  (SystemHatch type)">
 </A>
<H1 CLASS="refHeading">
SystemHatch</H1>
<PRE CLASS="syntax">typedef ByteEnum SystemHatch;
#define SH_VERTICAL				0
#define SH_HORIZONTAL 				1
#define SH_45_DEGREE 				2
#define SH_135_DEGREE 				3
#define SH_BRICK 				4
#define SH_SLANTED_BRICK 				5</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_3c.htm_IX_TargetLevel">
 </A>
<A NAME="S_3c.htm_IX_TL_&ldots;">
 </A>
<H1 CLASS="refHeading">
TargetLevel</H1>
<PRE CLASS="syntax">typedef enum /* word */ {
TL_TARGET				= 0,
TL_CONTENT,
TL_GENERIC_OBJECTS				= 1000,
TL_GEN_SYSTEM,
TL_GEN_FIELD,
TL_GEN_APPLICATION,
TL_GEN_PRIMARY,
TL_GEN_DISPLAY_CTRL,
TL_GEN_DISPLAY,
TL_GEN_VIEW,
TL_LIBRARY_LEVELS				= 2000,
TL_APPLICATION_OBJECTS				= 3000,
} TargetLevel;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_3c.htm_IX_TcpAccPntExtendedAddress">
 </A>
<H1 CLASS="refHeading">
TcpAccPntExtendedAddress</H1>
<PRE CLASS="syntax">typedef struct {
        word    TAPEA_linkSize;             /* 3 */
        byte    TAPEA_linkType;             /* LinkType (LT_ID) */
        word    TAPEA_accPntID;
} TcpAccPntExtendedAddress;</PRE>
<P>
This is the &quot;opaque&quot; representation of a TCP address; specifically, the form used to identify a TCP address by means of its access point ID.</P>
<P>
Set <CODE>
TAPEA_linkSize</CODE>
 to 3; set <CODE>
TAPEA_linkType</CODE>
 to LT_ID; set <CODE>
TAPEA_accPntID</CODE>
 to the access point ID number.</P>
</DIV>
<DIV>
<A NAME="S_3c.htm_IX_TcpNonAccPntExtendedAddress">
 </A>
<H1 CLASS="refHeading">
TcpNonAccPntExtendedAddress</H1>
<PRE CLASS="syntax">typedef struct {
   word    TNAPEA_linkSize;
   byte    TNAPEA_linkType;            /* LinkType (LT_ADDR) */
/* label byte TNAPEA_addr;     link address immed. followed by IP address */
} TcpNonAccPntExtendedAddress;</PRE>
<P>
This is the &quot;opaque&quot; representation of a TCP address; specifically, the form used to identify a TCP address which is not a known access point--you will need to specify a phone number to dial in addition to an IP address.</P>
<P>
Set <CODE>
TNAPEA_linkSize</CODE>
 to the size of the phone number string. Set <CODE>
TNAPEA_linkType</CODE>
 to LT_ADDR. Follow the structure witha null-terminated string consisting of the phone number to dial followed by the human-readable form of the IP address; for example &quot;15105551234acme.com&quot;.</P>
</DIV>
<DIV>
<A NAME="S_3c.htm_IX_TcpOnlyExtendedAddress">
 </A>
<H1 CLASS="refHeading">
TcpOnlyExtendedAddress</H1>
<PRE CLASS="syntax">typedef struct {
            word    TOEA_linkSize;              /* 0 */
        /*  label byte TOEA_ipAddr;             IP address  */
} TcpOnlyExtendedAddress;</PRE>
<P>
This is the &quot;opaque&quot; representation of a TCP address; specifically, the form used to identify a TCP address when a link address is not required.</P>
<P>
Set <CODE>
TOEA_linkSize</CODE>
 to 0; follow the structure with the IP address, expressed either as a null-terminated string; for example &quot;204.156.128.1&quot; or &quot;acme.com&quot;.</P>
</DIV>
<DIV>
<A NAME="S_3c.htm_IX_TestRectReturnType">
 </A>
<H1 CLASS="refHeading">
TestRectReturnType</H1>
<P>
See<CODE>
 GrTestRectInReg()</CODE>
.</P>
</DIV>
<DIV>
<A NAME="S_3c.htm_IX_TextAttr">
 </A>
<H1 CLASS="refHeading">
TextAttr</H1>
<PRE CLASS="syntax">typedef struct {
byte 			TA_colorFlag;
RGBValue 			TA_color;
SysDrawMask 			TA_mask;
GraphicPattern 			TA_pattern;
TextStyle 			TA_styleSet;
TextStyle 			TA_styleClear;
TextMode 			TA_modeSet;
TextMode 			TA_modeClear;
WBFixed 			TA_spacePad;
FontID			TA_font;
WBFixed 			TA_size;
sword 			TA_trackKern;
} TextAttr;</PRE>
<P>
&nbsp;</P>
</DIV>
<HR>
<A NAME="S_3d.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="S_3d.htm_IX_TextMode">
 </A>
<H1 CLASS="refHeading">
TextMode</H1>
<PRE CLASS="syntax">typedef ByteFlags TextMode;
#define TM_TRACK_KERN						0x40
#define TM_PAIR_KERN 						0x20
#define TM_PAD_SPACES 						0x10
#define TM_DRAW_BASE 						0x08
#define TM_DRAW_BOTTOM 						0x04
#define TM_DRAW_ACCENT 						0x02
#define TM_DRAW_OPTIONAL_HYPHENS 						0x01</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_3d.htm_IX_TextReference">
 </A>
<A NAME="S_3d.htm_IX_TR_&ldots;">
 </A>
<H1 CLASS="refHeading">
TextReference</H1>
<PRE CLASS="syntax">typedef struct {
TR_type		TextReferenceType;
TR_ref		TextReferenceUnion;</PRE>
<PRE CLASS="syntax">} TextReference;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_3d.htm_IX_TextReferenceBlock">
 </A>
<A NAME="S_3d.htm_IX_TRB_handle">
 </A>
<H1 CLASS="refHeading">
TextReferenceBlock</H1>
<PRE CLASS="syntax">typedef struct {
MemHandle		TRB_handle;
} TextReferenceBlock;</PRE>
<P>
This structure corresponds to a <CODE>
TextReferenceType</CODE>
 of TRT_BLOCK. It is used with MSG_VIS_TEXT_REPLACE_TEXT and MSG_VIS_TEXT_GET_TEXT_RANGE to reference text used by those messages.</P>
<P>
TRB_<CODE>
handle </CODE>
stores the handle of the text buffer. No entries need to be filled in to allocate a destination buffer. The heap allocation request will be made with the HAF_NO_ERR flag. If VTGRF_RESIZE is passed then either the passed block or the allocated block will be resized to accommodate the text.</P>
</DIV>
<DIV>
<A NAME="S_3d.htm_IX_TextReferenceBlockChunk">
 </A>
<A NAME="S_3d.htm_IX_TRBC_ref">
 </A>
<H1 CLASS="refHeading">
TextReferenceBlockChunk</H1>
<PRE CLASS="syntax">typedef struct {
optr		TRBC_ref;
} TextReferenceBlockChunk;</PRE>
<P>
This structure corresponds to a <CODE>
TextReferenceType</CODE>
 of TRT_OPTR. It is used with MSG_VIS_TEXT_REPLACE_TEXT and MSG_VIS_TEXT_GET_TEXT_RANGE to reference text used by those messages.</P>
<P>
TRBC_<CODE>
ref </CODE>
stores the optr to a text buffer (a group of character)s. The handle field of TRBC<CODE>
_ref</CODE>
 must be filled in. </P>
<P>
It is assumed that the LMem heap will be able to accommodate this allocation. The caller is responsible for ensuring that this is the case.</P>
<P>
If VTGRF_RESIZE is passed then either the passed block or the allocated block will be resized to accommodate the text.</P>
</DIV>
<DIV>
<A NAME="S_3d.htm_IX_TextReferenceDBItem">
 </A>
<A NAME="S_3d.htm_IX_TRDBI_&ldots;">
 </A>
<H1 CLASS="refHeading">
TextReferenceDBItem</H1>
<PRE CLASS="syntax">typedef struct {
FileHandle 		TRDBI_file;
DBItem		TRDBI_item;
DBGroup		TRDBI_group;
} TextReferenceDBItem;</PRE>
<P>
This structure corresponds to a <CODE>
TextReferenceType</CODE>
 of TRT_DB_ITEM. It is used with MSG_VIS_TEXT_REPLACE_TEXT and MSG_VIS_TEXT_GET_TEXT_RANGE to reference text used by those messages.</P>
<P>
TRDBI__<CODE>
file </CODE>
stores the VM file associated with this DB item.</P>
<P>
TRDBI_<CODE>
item</CODE>
 stores the DB item itself.</P>
<P>
TRDBI_<CODE>
group</CODE>
 stores the DB group the item belongs to.</P>
<P>
Both TRDBI_<CODE>
file</CODE>
 and TRDBI_<CODE>
group</CODE>
 must be filled in if you want a VM block to be allocated.</P>
<P>
If the TRDBI_<CODE>
group</CODE>
 field is set to DB_UNGROUPED then the item will be allocated ungrouped. TRDBI_group will hold the group in which the item was allocated on return.</P>
<P>
If VTGRF_RESIZE is passed then either the passed block or the allocated block will be resized to accommodate the text.</P>
</DIV>
<DIV>
<A NAME="S_3d.htm_IX_TextReferenceHugeArray">
 </A>
<A NAME="S_3d.htm_IX_TRHA_&ldots;">
 </A>
<H1 CLASS="refHeading">
TextReferenceHugeArray</H1>
<PRE CLASS="syntax">typedef struct {
FileHandle		TRHA_file;
word		TRHA_array;
} TextReferenceHugeArray;</PRE>
<P>
This structure corresponds to a <CODE>
TextReferenceType</CODE>
 of TRT_HUGE_ARRAY. It is used with MSG_VIS_TEXT_REPLACE_TEXT and MSG_VIS_TEXT_GET_TEXT_RANGE to reference text used by those messages.</P>
<P>
TRHA<CODE>
_file </CODE>
stores the VM file associated with this huge array.</P>
<P>
TRHA_<CODE>
array</CODE>
 stores the Huge Array.</P>
<P>
The TRHA_<CODE>
file</CODE>
 field must be set if you want a huge-array to be allocated.</P>
<P>
If VTGRF_RESIZE is passed then either the passed block or the allocated block will be resized to accommodate the text.</P>
</DIV>
<DIV>
<A NAME="S_3d.htm_IX_TextReferencePointer">
 </A>
<A NAME="S_3d.htm_IX_TRP_pointer">
 </A>
<H1 CLASS="refHeading">
TextReferencePointer</H1>
<PRE CLASS="syntax">typedef struct {
char _far 		*TRP_pointer;
} TextReferencePointer;</PRE>
<P>
This structure corresponds to a <CODE>
TextReferenceType</CODE>
 of TRT_POINTER. It is used with MSG_VIS_TEXT_REPLACE_TEXT and MSG_VIS_TEXT_GET_TEXT_RANGE to reference text used by those messages.</P>
<P>
TRP<CODE>
_pointer</CODE>
 stores the pointer to the text. This field must be filled in.</P>
<P>
VTGRF_RESIZE has no meaning with this sort of reference. VTGRF_ALLOCATE and VTGRF_ALLOCATE_ALWAYS are not valid flags to pass with this type of text reference. </P>
<P>
This reference is the safest way to copy text out of a text object. Since the caller allocates the block it can also handle errors in the allocation.</P>
</DIV>
<DIV>
<A NAME="S_3d.htm_IX_TextReferenceSegmentChunk">
 </A>
<A NAME="S_3d.htm_IX_TRSC_&ldots;">
 </A>
<H1 CLASS="refHeading">
TextReferenceSegmentChunk</H1>
<PRE CLASS="syntax">typedef struct {
ChunkHandle			TRSC_chunk;
Segment			TRSC_segment;
} TextReferenceSegmentChunk;</PRE>
<P>
This structure corresponds to a <CODE>
TextReferenceType</CODE>
 of TRT_SEGMENT_CHUNK. It is used with MSG_VIS_TEXT_REPLACE_TEXT and MSG_VIS_TEXT_GET_TEXT_RANGE to reference text used by those messages.</P>
<P>
TRSC_<CODE>
segment</CODE>
 stores the segment address of the text chunk. TRSC<CODE>
_chunk</CODE>
 stores the chunk offset to the text.</P>
<P>
It is assumed that the LMem heap will be able to accommodate this allocation. The caller is responsible for ensuring that this is the case.</P>
<P>
If VTGRF_RESIZE is passed then either the passed block or the allocated block will be resized to accommodate the text.</P>
</DIV>
<HR>
<A NAME="S_3e.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="S_3e.htm_IX_TextReferenceType">
 </A>
<A NAME="S_3e.htm_IX_TRT_&ldots;">
 </A>
<H1 CLASS="refHeading">
TextReferenceType</H1>
<PRE CLASS="syntax">typedef enum {
TRT_POINTER=0,				/* TextReferencePointer */
TRT_SEGMENT_CHUNK=2,				/* TextReferenceSegmentChunk */
TRT_OPTR=4,				/* TextReferenceBlockChunk */
TRT_BLOCK=6,				/* TextReferenceBlock */
TRT_VM_BLOCK=8,				/* TextReferenceVMBlock */
TRT_DB_ITEM=10,		/		* TextReferenceDBItem */
TRT_HUGE_ARRAY=12,				/* TextReferenceHugeArray */
} TextReferenceType;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_3e.htm_IX_TextReferenceUnion">
 </A>
<A NAME="S_3e.htm_IX_TRU_&ldots;">
 </A>
<H1 CLASS="refHeading">
TextReferenceUnion</H1>
<PRE CLASS="syntax">typedef union {
TextReferencePointer 					TRU_pointer;
TextReferenceSegmentChunk				 	TRU_segChunk;
TextReferenceBlockChunk 					TRU_blockChunk;
TextReferenceBlock	 				TRU_block;
TextReferenceVMBlock					TRU_vmBlock;
TextReferenceDBItem	 				TRU_dbItem;
TextReferenceHugeArray					TRU_hugeArray;
} TextReferenceUnion;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_3e.htm_IX_TextReferenceVMBlock">
 </A>
<A NAME="S_3e.htm_IX_TRVMB_&ldots;">
 </A>
<H1 CLASS="refHeading">
TextReferenceVMBlock</H1>
<PRE CLASS="syntax">typedef struct {
FileHandle 			TRVMB_file;
VMBlockHandle 			TRVMB_block;
} TextReferenceVMBlock;</PRE>
<P>
This structure corresponds to a <CODE>
TextReferenceType</CODE>
 of TRT_VM_BLOCK. It is used with MSG_VIS_TEXT_REPLACE_TEXT and MSG_VIS_TEXT_GET_TEXT_RANGE to reference text used by those messages.</P>
<P>
TRVMB<CODE>
_file </CODE>
stores the VM file associated with this VM block. This entry must be filled in if you want a VM block to be allocated.</P>
<P>
TRVMB<CODE>
_block</CODE>
 stores the VM block itself.</P>
<P>
If VTGRF_RESIZE is passed then either the passed block or the allocated block will be resized to accommodate the text.</P>
</DIV>
<DIV>
<A NAME="S_3e.htm_IX_TextStyle">
 </A>
<A NAME="S_3e.htm_IX_TS_&ldots;  (TextStyle)">
 </A>
<H1 CLASS="refHeading">
TextStyle</H1>
<PRE CLASS="syntax">typedef ByteFlags TextStyle;
#define TS_OUTLINE				0x40
#define TS_BOLD 				0x20
#define TS_ITALIC 				0x10
#define TS_SUPERSCRIPT 				0x08
#define TS_SUBSCRIPT 				0x04
#define TS_STRIKE_THRU 				0x02
#define TS_UNDERLINE 				0x01</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_3e.htm_IX_ThreadException">
 </A>
<A NAME="S_3e.htm_IX_TE_&ldots;  (ThreadException type)">
 </A>
<H1 CLASS="refHeading">
ThreadException</H1>
<PRE CLASS="syntax">typedef enum {
TE_DIVIDE_BY_ZERO=0,
TE_OVERFLOW=4,
TE_BOUND=8,
TE_FPU_EXCEPTION=12,
TE_SINGLE_STEP=16,
TE_BREAKPOINT=20
} ThreadException;</PRE>
<P>
Processor exceptions used primarily for debugging, these are used with <CODE>
<A HREF="../../CRef/Routines/R_97.htm#IX_ThreadHandleException()">ThreadHandleException()</A></CODE>
.</P>
</DIV>
<DIV>
<A NAME="S_3e.htm_IX_ThreadGetInfoType">
 </A>
<H1 CLASS="refHeading">
ThreadGetInfoType</H1>
<P>
See <CODE>
<A HREF="../../CRef/Routines/R_97.htm#IX_ThreadGetInfo()">ThreadGetInfo()</A></CODE>
.</P>
</DIV>
<DIV>
<A NAME="S_3e.htm_IX_ThreadHandle">
 </A>
<H1 CLASS="refHeading">
ThreadHandle</H1>
<PRE CLASS="syntax">typedef Handle ThreadHandle;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_3e.htm_IX_ThreadLockHandle">
 </A>
<H1 CLASS="refHeading">
ThreadLockHandle</H1>
<PRE CLASS="syntax">typedef Handle ThreadLockHandle;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
, these flags determine what aspect of the thread <A NAME="S_3e.htm_IX_ThreadModifyFlags">
 </A>
<A NAME="S_3e.htm_IX_TMF_&ldots;">
 </A>
<H1 CLASS="refHeading">
ThreadModifyFlags</H1>
<PRE CLASS="syntax">typedef ByteFlags ThreadModifyFlags;
#define TMF_BASE_PRIO				0x80
#define TMF_ZERO_USAGE				0x40</PRE>
<P>
Used with <CODE>
<A HREF="../../CRef/Routines/R_97.htm#IX_ThreadModify()">ThreadModify()</A></CODE>
is modified.</P>
</DIV>
<DIV>
<A NAME="S_3e.htm_IX_TimerCompressedDate">
 </A>
<H1 CLASS="refHeading">
TimerCompressedDate</H1>
<PRE CLASS="syntax">typedef WordFlags TimerCompressedDate;
#define TCD_YEAR 				0xfe00			/* years since 1980; e.g. 1988 is `8' */
#define TCD_MONTH				0x01e0			/* months (1 - 12) (0 illegal) */
#define TCD_DAY				0x001f			/* days (1-31) (0 illegal) */</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_3e.htm_IX_TimerDateAndTime">
 </A>
<A NAME="S_3e.htm_IX_TDAT_&ldots;">
 </A>
<H1 CLASS="refHeading">
TimerDateAndTime</H1>
<PRE CLASS="syntax">typedef struct {
word			TDAT_year;			/* Year */
word			TDAT_month;			/* Number of month (1 through 12) */
word			TDAT_day;			/* Number of day in month (1 through 31) */
DaysOfTheWeek			TDAT_dayOfWeek;			/* DayOfTheWeek enumeration */
word			TDAT_hours;			/* Hour of the day (0 through 23) */
word			TDAT_minutes;			/* Minute in the hour (0 through 59) */
word			TDAT_seconds;			/* Second in the minute (0 through 59) */
} TimerDateAndTime;</PRE>
<P>
This structure is used to keep track of the current time and date.</P>
</DIV>
<HR>
<A NAME="S_3f.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="S_3f.htm_IX_TimerHandle">
 </A>
<H1 CLASS="refHeading">
TimerHandle</H1>
<PRE CLASS="syntax">typedef Handle TimerHandle;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_3f.htm_IX_TimerType">
 </A>
<H1 CLASS="refHeading">
TimerType</H1>
<P CLASS="refField"><STRONG>
<STRONG>
See:</STRONG></STRONG>
	<CODE>
<A HREF="../../CRef/Routines/R_99.htm#IX_TimerStart()">TimerStart()</A></CODE>
.</P>
</DIV>
<DIV>
<A NAME="S_3f.htm_IX_ToggleState">
 </A>
<A NAME="S_3f.htm_IX_TS_&ldots;  (ToggleState)">
 </A>
<H1 CLASS="refHeading">
ToggleState</H1>
<PRE CLASS="syntax">typedef ByteFlags ToggleState;
#define TS_CAPSLOCK				0x80
#define TS_NUMLOCK				0x40
#define TS_SCROLLLOCK				0x20</PRE>
<P>
This structure describes the state of certain &quot;toggles&quot; which will affect how input is interpreted. These toggles correspond to the caps lock, num lock, and scroll lock keys.</P>
</DIV>
<DIV>
<A NAME="S_3f.htm_IX_TokenChars">
 </A>
<A NAME="S_3f.htm_IX_TOKEN_CHARS_LENGTH">
 </A>
<H1 CLASS="refHeading">
TokenChars</H1>
<PRE CLASS="syntax">typedef char TokenChars[TOKEN_CHARS_LENGTH]; /* TOKEN_CHARS_LENGTH=4 */</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_3f.htm_IX_TokenDBItem">
 </A>
<H1 CLASS="refHeading">
TokenDBItem</H1>
<PRE CLASS="syntax">typedef DBGroupAndItem TokenDBItem;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_3f.htm_IX_TokenEntry">
 </A>
<A NAME="S_3f.htm_IX_TE_&ldots;  (TokenEntry structure)">
 </A>
<H1 CLASS="refHeading">
TokenEntry</H1>
<PRE CLASS="syntax">typedef struct {
GeodeToken			TE_token;			/* A GeodeToken structure for this file */
TokenDBItem			TE_monikerList;			/* A list of monikers for this token */
TokenFlags			TE_flags;			/* Flags indicating relocation status */
ReleaseNumber			TE_release;			/* Release number of the token DB */
ProtocolNumber			TE_protocol;			/* Protocol number of the toke DB */
} TokenEntry;</PRE>
<P>
Used for the token entry in the map item of the token database, this structure identifies the structures and other information of each token. The <CODE>
TE_monikerList</CODE>
 field points to a chunk containing the item numbers of the chunks of the token.</P>
</DIV>
<DIV>
<A NAME="S_3f.htm_IX_TokenFlags">
 </A>
<A NAME="S_3f.htm_IX_TF_NEED_RELOCATION">
 </A>
<H1 CLASS="refHeading">
TokenFlags</H1>
<PRE CLASS="syntax">typedef WordFlags TokenFlags;
#define TF_NEED_RELOCATION				0x8000</PRE>
<P>
Used by token management routines, this flags record indicates whether the token has fields which must be relocated when the token is loaded or unloaded.</P>
</DIV>
<DIV>
<A NAME="S_3f.htm_IX_TokenMonikerInfo">
 </A>
<A NAME="S_3f.htm_IX_TMI_&ldots;">
 </A>
<H1 CLASS="refHeading">
TokenMonikerInfo</H1>
<PRE CLASS="syntax">typedef struct {
TokenDBItem 		TMI_moniker;
word 		TMI_fileFlag;			/* 0 if token is in shared token DB file; 
					 * Non-0 if it's in local file */
} TokenMonikerInfo;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_3f.htm_IX_TokenRangeFlags">
 </A>
<A NAME="S_3f.htm_IX_TRF_&ldots;">
 </A>
<H1 CLASS="refHeading">
TokenRangeFlags</H1>
<PRE CLASS="syntax">typedef WordFlags TokenRangeFlags;
#define TRF_ONLY_GSTRING	0x8000
#define TRF_ONLY_PASSED_MANUFID	0x4000
#define TRF_UNUSED		 0x3fff</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_3f.htm_IX_TransError">
 </A>
<A NAME="S_3f.htm_IX_TE_&ldots;  (TransError type)">
 </A>
<H1 CLASS="refHeading">
TransError</H1>
<PRE CLASS="syntax">typedef enum {
 TE_NO_ERROR, /* No error */
 TE_ERROR, /* General error */
 TE_INVALID_FORMAT, /* Format is invalid */
 TE_IMPORT_NOT_SUPPORTED, /* Format is not supported for export */
 TE_EXPORT_NOT_SUPPORTED, /* Format is not supported for export */
 TE_IMPORT_ERROR, /* General error during import */
 TE_EXPORT_ERROR, /* General error during export */
 TE_FILE_ERROR, /* Generic file error */
 TE_DISK_FULL, /* The disk is full */
 TE_FILE_OPEN, /* Error in opening a file */
 TE_FILE_READ, /* Error in reading from a file */
 TE_FILE_WRITE, /* Error in writing to a file */
 TE_FILE_TOO_LARGE, /* File is too large to process */
 TE_OUT_OF_MEMORY, /* Insufficient memory for import/export */
 TE_METAFILE_CREATION_ERROR, /* Error in creating the metafile */
 TE_EXPORT_FILE_EMPTY, /* File to be exported is empty */
 TE_CUSTOM /* Custom error message */
} TransError;</PRE>
<P>
This enumerated type contains error values the impex library may wish to generate when translating.</P>
</DIV>
<DIV>
<A NAME="S_3f.htm_IX_TransErrorInfo">
 </A>
<A NAME="S_3f.htm_IX_transError (TransErrorInfo structure field)">
 </A>
<A NAME="S_3f.htm_IX_customMsgHandle (TransErrorInfo structure field)">
 </A>
<H1 CLASS="refHeading">
TransErrorInfo</H1>
<PRE CLASS="syntax">typedef struct {
 TransError transError; 
 /* NOTE: customMsgHandle will be valid only if transError is TE_CUSTOM. */  
word customMsgHandle;
} TransErrorInfo; </PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_3f.htm_IX_TransferBlockID">
 </A>
<H1 CLASS="refHeading">
TransferBlockID</H1>
<PRE CLASS="syntax">typedef dword TransferBlockID;
#define BlockIDFromFileAndBlock(f,b) 								(((dword)(f) &lt;&lt; 16) | (b))
#define FileFromTransferBlockID(id) 								((VMFileHandle) ((id) &gt;&gt; 16))
#define BlockFromTransferBlockID(id) 								((VMBlockHandle) (id))</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_3f.htm_IX_TransMatrix">
 </A>
<A NAME="S_3f.htm_IX_TM_e&ldots;">
 </A>
<H1 CLASS="refHeading">
TransMatrix</H1>
<PRE CLASS="syntax">typedef struct {
WWFixed 		TM_e11;
WWFixed 		TM_e12;
WWFixed 		TM_e21;
WWFixed 		TM_e22;
DWFixed 		TM_e31;
DWFixed 		TM_e32;
} TransMatrix;</PRE>
<P>
The six variable elements of a coordinate transformation matrix.</P>
</DIV>
<HR>
<A NAME="S_40.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="S_40.htm_IX_VisTravelOption">
 </A>
<A NAME="S_40.htm_IX_TravelOption">
 </A>
<A NAME="S_40.htm_IX_GenTravelOption">
 </A>
<A NAME="S_40.htm_IX_TO_&ldots;">
 </A>
<H1 CLASS="refHeading">
TravelOption</H1>
<PRE CLASS="syntax">typedef enum {
 TO_NULL,
 TO_SELF,
 TO_OBJ_BLOCK_OUTPUT,
 TO_PROCESS
} TravelOption;
/* VisClass defines one other travel option: */
typedef enum {
 TO_VIS_PARENT=_FIRST_VisClass
} VisTravelOption;
/* GenClass defines some more travel options: */
typedef enum /* word */ {
 TO_GEN_PARENT=_FIRST_GenClass,
 TO_FOCUS,
 TO_TARGET,
 TO_MODEL,
 TO_APP_FOCUS,
 TO_APP_TARGET,
 TO_APP_MODEL,
 TO_SYS_FOCUS,
 TO_SYS_TARGET,
 TO_SYS_MODEL
} GenTravelOption;</PRE>
<P>
This enumerated type can be used to specify the recipient of a message. Note that the values set up in the <CODE>
TravelOption</CODE>
, <CODE>
VisTravelOption</CODE>
, and <CODE>
GenTravelOption</CODE>
 have been set up as descrete values.</P>
</DIV>
<DIV>
<A NAME="S_40.htm_IX_TRUE">
 </A>
<H1 CLASS="refHeading">
TRUE</H1>
<PRE CLASS="syntax">#define TRUE		-1	/* use as return value, not for comparisons */
#define FALSE		 0</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_40.htm_IX_TypeFromFormatID() macro">
 </A>
<H1 CLASS="refHeading">
TypeFromFormatID</H1>
<PRE CLASS="syntax">word	TypeFromFormatID(type);
        ClipboardItemFormatID			type;</PRE>
<P>
This macro extracts the format ID from the given clipboard format ID and manufacturer value.</P>
</DIV>
<DIV>
<A NAME="S_40.htm_IX_UIFunctionsActive">
 </A>
<A NAME="S_40.htm_IX_UIFA_&ldots;">
 </A>
<H1 CLASS="refHeading">
UIFunctionsActive</H1>
<PRE CLASS="syntax">typedef ByteFlags UIFunctionsActive;
#define UIFA_SELECT				0x80
#define UIFA_MOVE_COPY 				0x40
#define UIFA_FEATURES 				0x20
#define UIFA_CONSTRAIN 				0x10
#define UIFA_PREF_A 				0x08
#define UIFA_PREF_B 				0x04
#define UIFA_PREF_C 				0x02
#define UIFA_IN 				0x01
#define UIFA_ADJUST 				0x08
#define UIFA_EXTEND 				0x04
#define UIFA_MOVE 				0x08
#define UIFA_COPY 				0x04
#define UIFA_POPUP 				0x08
#define UIFA_PAN 				0x04</PRE>
<P>
These flags describe the context of the user's input, providing some modal information. </P>
</DIV>
<DIV>
<A NAME="S_40.htm_IX_UIInterfaceLevel">
 </A>
<H1 CLASS="refHeading">
UIInterfaceLevel</H1>
<P>
See <CODE>
<A HREF="../../CRef/Routines/R_9e.htm#IX_UserGetInterfaceLevel()">UserGetInterfaceLevel()</A></CODE>
.</P>
</DIV>
<DIV>
<A NAME="S_40.htm_IX_UndoActionDataFlags">
 </A>
<A NAME="S_40.htm_IX_UADF_&ldots;">
 </A>
<H1 CLASS="refHeading">
UndoActionDataFlags</H1>
<PRE CLASS="syntax">typedef struct {
dword 		UADF_flags;
word 		UADF_extraflags;
} UndoActionDataFlags;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_40.htm_IX_UndoActionDataPtr">
 </A>
<A NAME="S_40.htm_IX_UADP_&ldots;">
 </A>
<H1 CLASS="refHeading">
UndoActionDataPtr</H1>
<PRE CLASS="syntax">typedef struct {
void 		*UADP_ptr;
word 		UADP_size;
} UndoActionDataPtr;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_40.htm_IX_UndoActionDataType">
 </A>
<A NAME="S_40.htm_IX_UADT_&ldots;">
 </A>
<H1 CLASS="refHeading">
UndoActionDataType</H1>
<PRE CLASS="syntax">typedef enum /* word */ {
UADT_FLAGS,
UADT_PTR,
UADT_VM_CHAIN,
} UndoActionDataType;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_40.htm_IX_UndoActionDataUnion">
 </A>
<A NAME="S_40.htm_IX_UADU_&ldots;">
 </A>
<H1 CLASS="refHeading">
UndoActionDataUnion</H1>
<PRE CLASS="syntax">typedef union {
/* To find out the type of data stored in this
 * union, check the value of the UndoActionStruct's
 * UAS_dataType field. */
UndoActionDataFlags 				UADU_flags;
UndoActionDataPtr 				UADU_ptr;
UndoActionDataVMChain 				UADU_vmChain;
} UndoActionDataUnion;
#define NULL_UNDO_CONTEXT 0</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_40.htm_IX_UndoActionDataVMChain">
 </A>
<A NAME="S_40.htm_IX_UADVMC_&ldots;">
 </A>
<H1 CLASS="refHeading">
UndoActionDataVMChain</H1>
<PRE CLASS="syntax">typedef struct {
/* This structure is filled in by the code for
 * MSG_META_UNDO. VMChains passed to 
 * MSG_GEN_PROCESS_UNDO_ADD_ACTION should lie in the undo
 * file (which can be obtained by sending 
 * MSG_GEN_PROCESS_UNDO_GET_FILE). */
VMChain 			UADVMC_vmChain;
VMFileHandle 			UADVMC_file;
} UndoActionDataVMChain;</PRE>
<P>
&nbsp;</P>
</DIV>
<HR>
<A NAME="S_41.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="S_41.htm_IX_UndoActionStruct">
 </A>
<A NAME="S_41.htm_IX_UAS_&ldots;">
 </A>
<H1 CLASS="refHeading">
UndoActionStruct</H1>
<PRE CLASS="syntax">typedef struct {
UndoActionDataType 				UAS_dataType;
UndoActionDataUnion 				UAS_data;
dword 				UAS_appType;
} UndoActionStruct;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_41.htm_IX_UtilAsciiToHexError">
 </A>
<H1 CLASS="refHeading">
UtilAsciiToHexError</H1>
<P>
See <CODE>
UtilAsciiToHex32()</CODE>
.</P>
</DIV>
<DIV>
<A NAME="S_41.htm_IX_UtilHexToAsciiFlags">
 </A>
<A NAME="S_41.htm_IX_UHTAF_&ldots;">
 </A>
<H1 CLASS="refHeading">
UtilHexToAsciiFlags</H1>
<PRE CLASS="syntax">typedef WordFlags UtilHexToAsciiFlags;
#define UHTAF_INCLUDE_LEADING_ZEROS							0x0002
#define UHTAF_NULL_TERMINATE							0x0001</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_41.htm_IX_VarDataCHandler">
 </A>
<H1 CLASS="refHeading">
VarDataCHandler</H1>
<PRE CLASS="syntax">typedef	struct {
word	VDCH_dataType;
void	(*VDCH_handler) (MemHandle mh, ChunkHandle ch,
				VarDataEntry *extraData,
				word dataType, void *handlerData);</PRE>
<PRE CLASS="syntax">} VarDataCHandler;</PRE>
<P>
See <CODE>
<A HREF="../../CRef/Routines/R_7f.htm#IX_ObjVarScanData()">ObjVarScanData()</A></CODE>
.</P>
</DIV>
<DIV>
<A NAME="S_41.htm_IX_VarDataEntry">
 </A>
<A NAME="S_41.htm_IX_VDE_&ldots;">
 </A>
<H1 CLASS="refHeading">
VarDataEntry</H1>
<PRE CLASS="syntax">typedef struct {
word	VDE_dataType;			/* vardata data type */
word	VDE_entrySize;			/* size of extra data; this field only exists
				 * if the type has extra data. */</PRE>
<PRE CLASS="syntax">} VarDataEntry;
#define VDE_extraData				sizeof(VarDataEntry);</PRE>
<P>
Structure of a variable data entry. If the data type has no extra data, there will be no <CODE>
VDE_entrySize</CODE>
 field. The extra data begins at offset <CODE>
VDE_extraData</CODE>
, defined above.</P>
</DIV>
<DIV>
<A NAME="S_41.htm_IX_VarDataFlags">
 </A>
<A NAME="S_41.htm_IX_VDF_&ldots;">
 </A>
<H1 CLASS="refHeading">
VarDataFlags</H1>
<PRE CLASS="syntax">typedef WordFlags VarDataFlags;
#define VDF_TYPE				0xfffc				/* 14-bit data type */
#define VDF_EXTRA_DATA				0x0002				/* set if has extra data */
#define VDF_SAVE_TO_STATE				0x0001				/* set if type saved to state */</PRE>
<P>
This is a word record containing three fields. This word is stored in the vardata structure's <CODE>
VDE_dataType</CODE>
 field (see <CODE>
VarDataEntry</CODE>
, above).</P>
</DIV>
<DIV>
<A NAME="S_41.htm_IX_VardataKey">
 </A>
<H1 CLASS="refHeading">
VarDataKey</H1>
<PRE CLASS="syntax">typedef word VardataKey;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_41.htm_IX_VarObjRelocation">
 </A>
<A NAME="S_41.htm_IX_VOR_&ldots;">
 </A>
<H1 CLASS="refHeading">
VarObjRelocation</H1>
<PRE CLASS="syntax">typedef struct {
VarDataFlags			VOR_type;			/* type and tag */
word			VOR_offset;
} VarObjRelocation;</PRE>
<P>
&nbsp;</P>
</DIV>
<HR>
<A NAME="S_42.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="S_42.htm_IX_VChar">
 </A>
<A NAME="S_42.htm_IX_VC_&ldots;">
 </A>
<H1 CLASS="refHeading">
VChar</H1>
<PRE CLASS="syntax">typedef ByteEnum VChar;
#define VC_NULL				0x0 /* NULL */
#define VC_CTRL_A 				0x1 /* &lt;ctrl&gt;-A */
#define VC_CTRL_B 				0x2 /* &lt;ctrl&gt;-B */
#define VC_CTRL_C 				0x3 /* &lt;ctrl&gt;-C */
#define VC_CTRL_D 				0x4 /* &lt;ctrl&gt;-D */
#define VC_CTRL_E 				0x5 /* &lt;ctrl&gt;-E */
#define VC_CTRL_F 				0x6 /* &lt;ctrl&gt;-F */
#define VC_CTRL_G 				0x7 /* &lt;ctrl&gt;-G */
#define VC_CTRL_H 				0x8 /* &lt;ctrl&gt;-H */
#define VC_CTRL_I 				0x9 /* &lt;ctrl&gt;-I */
#define VC_CTRL_J 				0xa /* &lt;ctrl&gt;-J */
#define VC_CTRL_K 				0xb /* &lt;ctrl&gt;-K */
#define VC_CTRL_L 				0xc /* &lt;ctrl&gt;-L */
#define VC_CTRL_M 				0xd /* &lt;ctrl&gt;-M */
#define VC_CTRL_N 				0xe /* &lt;ctrl&gt;-N */
#define VC_CTRL_O 				0xf /* &lt;ctrl&gt;-O */
#define VC_CTRL_P 				0x10 /* &lt;ctrl&gt;-P */
#define VC_CTRL_Q 				0x11 /* &lt;ctrl&gt;-Q */
#define VC_CTRL_R				0x12 /* &lt;ctrl&gt;-R */
#define VC_CTRL_S 				0x13 /* &lt;ctrl&gt;-S */
#define VC_CTRL_T 				0x14 /* &lt;ctrl&gt;-T */
#define VC_CTRL_U 				0x15 /* &lt;ctrl&gt;-U */
#define VC_CTRL_V 				0x16 /* &lt;ctrl&gt;-V */
#define VC_CTRL_W 				0x17 /* &lt;ctrl&gt;-W */
#define VC_CTRL_X 				0x18 /* &lt;ctrl&gt;-X */
#define VC_CTRL_Y 				0x19 /* &lt;ctrl&gt;-Y */
#define VC_CTRL_Z 				0x1a /* &lt;ctrl&gt;-Z */
#define VC_ESCAPE 				0x1b /* ESC */
#define VC_BLANK 				0x20 /* space */
/*
 * Numeric keypad keys
 */</PRE>
<PRE CLASS="syntax">#define VC_NUMPAD_ENTER 				0xd /* only on PS/2 keyboards */
#define VC_NUMPAD_DIV 				`/' /* only on PS/2 keyboards */
#define VC_NUMPAD_MULT 				`*'
#define VC_NUMPAD_PLUS 				`+'
#define VC_NUMPAD_MINUS 				`-'
#define VC_NUMPAD_PERIOD 				`.'
#define VC_NUMPAD_0 				`0'
#define VC_NUMPAD_1 				`1'
#define VC_NUMPAD_2 				`2'
#define VC_NUMPAD_3 				`3'
#define VC_NUMPAD_4 				`4'
#define VC_NUMPAD_5 				`5'
#define VC_NUMPAD_6 				`6'
#define VC_NUMPAD_7 				`7'
#define VC_NUMPAD_8				`8'
#define VC_NUMPAD_9				`9'
/*
 * Extended keyboard codes -- non-ASCII
 */</PRE>
<PRE CLASS="syntax">#define VC_F1 				0x80 /* Function keys */
#define VC_F2 				0x81
#define VC_F3 				0x82
#define VC_F4 				0x83
#define VC_F5				0x84
#define VC_F6 				0x85
#define VC_F7 				0x86
#define VC_F8 				0x87
#define VC_F9 				0x88
#define VC_F10 				0x89
#define VC_F11 				0x8a /* only on PS/2 keyboards */
#define VC_F12 				0x8b /* only on PS/2 keyboards */
#define VC_F13 				0x8c /* non-standard key */
#define VC_F14 				0x8d /* non-standard key */
#define VC_F15 				0x8e /* non-standard key */
#define VC_F16 				0x8f /* non-standard key */
#define VC_UP 				0x90 /* Cursor keys */
#define VC_DOWN 				0x91
#define VC_RIGHT 				0x92
#define VC_LEFT 				0x93
#define VC_HOME 				0x94 /* Scroll commands */
#define VC_END 				0x95
#define VC_PREVIOUS 				0x96
#define VC_NEXT 				0x97
#define VC_INS 				0x98 /* INS */
#define VC_DEL 				0x9a /* DEL */
#define VC_PRINTSCREEN				0x9b /* from &lt;shift&gt;-NUMPAD_MULT */
#define VC_PAUSE 				0x9c /* from &lt;ctrl&gt;-NUMLOCK */
#define VC_BREAK 				0x9e /* from &lt;ctrl&gt;- or &lt;alt&gt;-combo */
#define VC_SYSTEMRESET 				0x9f /* &lt;ctrl&gt;-&lt;alt&gt;-&lt;del&gt; combo */
/*
* Joystick control keys (0xa0 - 0xa9)
*/
#define VC_JOYSTICK_0 				0xa0        ; joystick 0 degrees
#define VC_JOYSTICK_45 	 			0xa1        ; joystick 45 degrees
#define VC_JOYSTICK_90 				0xa2        ; joystick 90 degrees
#define VC_JOYSTICK_135 				0xa3        ; joystick 135 degrees
#define VC_JOYSTICK_180 				0xa4        ; joystick 180 degrees
#define VC_JOYSTICK_225 				0xa5        ; joystick 225 degrees
#define VC_JOYSTICK_270 				0xa6        ; joystick 270 degrees
#define VC_JOYSTICK_315 				0xa7        ; joystick 315 degrees
#define VC_FIRE_BUTTON_1				0xa8        ; fire button #1
#define VC_FIRE_BUTTON_2 				0xa9        ; fire button #2
&nbsp;
/*
 * Shift Keys			(0xe0 - 0xe7)
 */</PRE>
<PRE CLASS="syntax">#define VC_LALT 				0xe0
#define VC_RALT 				0xe1
#define VC_LCTRL 				0xe2
#define VC_RCTRL 				0xe3
#define VC_LSHIFT 				0xe4
#define VC_RSHIFT 				0xe5
#define VC_SYSREQ 				0xe6 /* Not on base PC keyboard */
#define VC_ALT_GR 				0xe7
/*
 * Toggle state keys (0xe8 - 0xef)
 */</PRE>
<PRE CLASS="syntax">#define VC_CAPSLOCK 				0xe8
#define VC_NUMLOCK 				0xe9
#define VC_SCROLLLOCK 				0xea
/*
 * Extended state keys (0xf0 - 0xf7)
 */</PRE>
<PRE CLASS="syntax">#define VC_INVALID_KEY 				0xff
#define VC_BACKSPACE 				VC_CTRL_H
#define VC_TAB 				VC_CTRL_I
#define VC_LF 				VC_CTRL_J
#define VC_ENTER 				VC_CTRL_M</PRE>
<P>
&nbsp;</P>
</DIV>
<HR>
<A NAME="S_43.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="S_43.htm_IX_VisRulerType">
 </A>
<A NAME="S_43.htm_IX_VRT_&ldots;">
 </A>
<H1 CLASS="refHeading">
VisRulerType</H1>
<PRE CLASS="syntax">typedef ByteEnum VisRulerType;
#define VRT_INCHES				0
#define VRT_CENTIMETERS				1
#define VRT_POINTS				2
#define VRT_PICAS				3
#define VRT_CUSTOM				CUSTOM_RULER_DEFINITION
#define VRT_NONE				NO_RULERS
#define VRT_DEFAULT				SYSTEM_DEFAULT</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_43.htm_IX_VisTextVariableType">
 </A>
<H1 CLASS="refHeading">
VisTextVariableType</H1>
<PRE CLASS="syntax">typedef enum {
 VTVT_PAGE_NUMBER,
 VTVT_PAGE_NUMBER_IN_SECTION,
 VTVT_NUMBER_OF_PAGES,
 VTVT_NUMBER_OF_PAGES_IN_SECTION,
 VTVT_SECTION_NUMBER,
 VTVT_NUMBER_OF_SECTIONS,
 VTVT_CREATION_DATE_TIME,
 VTVT_MODIFICATION_DATE_TIME,
 VTVT_CURRENT_DATE_TIME,
 VTVT_STORED_DATE_TIME,
} VisTextVariableType;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_43.htm_IX_VisTravelOption">
 </A>
<A NAME="S_43.htm_IX_VisTravelOption">
 </A>
<A NAME="S_43.htm_IX_VisTravelOption">
 </A>
<H1 CLASS="refHeading">
VisTravelOption</H1>
<P>
The <CODE>
VisClass</CODE>
 defines an enumerated value to be used in the place of a standard <CODE>
TravelOption</CODE>
. See the entry for <CODE>
TravelOption</CODE>
 to see all possible values.</P>
</DIV>
<DIV>
<A NAME="S_43.htm_IX_VisUpdateMode">
 </A>
<A NAME="S_43.htm_IX_VUM_&ldots;">
 </A>
<H1 CLASS="refHeading">
VisUpdateMode</H1>
<PRE CLASS="syntax">typedef ByteEnum VisUpdateMode;
#define VUM_MANUAL 							0
#define VUM_NOW 							1
#define VUM_DELAYED_VIA_UI_QUEUE 							2
#define VUM_DELAYED_VIA_APP_QUEUE							3</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_43.htm_IX_VMAccessFlags">
 </A>
<A NAME="S_43.htm_IX_VMAF_&ldots;">
 </A>
<H1 CLASS="refHeading">
VMAccessFlags</H1>
<PRE CLASS="syntax">typedef ByteFlags VMAccessFlags;
#define VMAF_FORCE_READ_ONLY										0x80
#define VMAF_FORCE_READ_WRITE 										0x40
#define VMAF_ALLOW_SHARED_MEMORY 										0x20
#define VMAF_FORCE_DENY_WRITE 										0x10
#define VMAF_DISALLOW_SHARED_MULTIPLE 										0x08
#define VMAF_USE_BLOCK_LEVEL_SYNCHRONIZATION 										0x04</PRE>
<P>
The <CODE>
VMAccessFlags</CODE>
 specify what kind of access to the file the caller wants. The following flags are available:</P>
<DL>
<DT>
VMAF_FORCE_READ_ONLY</DT><DD>
If set, the file will be opened read-only, even if the default would be to open the file read/write. Blocks in read-only files cannot be dirtied, and changes in memory blocks will not be updated to the disk VM blocks.</DD>
<DT>
VMAF_FORCE_READ_WRITE</DT><DD>
If set, the file will be opened for read/write access, even if the default would be to open the file for read-only access.</DD>
<DT>
VMAF_SHARED_MEMORY</DT><DD>
If set, the VM manager should try to use shared memory when locking VM blocks; that is, the same memory block will be used for a given VM block no matter which thread locks the block.</DD>
<DT>
VMAF_FORCE_DENY_WRITE</DT><DD>
If set, then open the file deny-write; that is, no other threads will be allowed to open the file for read/write access.</DD>
<DT>
VMAF_DISALLOW_SHARED_MULTIPLE</DT><DD>
If this flag is set, files with the file attribute GFHF_SHARED_MULTIPLE cannot be opened.</DD>
<DT>
VMAF_USE_BLOCK_LEVEL_SYNCHRONIZATION</DT><DD>
If set, the block-level synchronization mechanism of the VM manager is assumed to be sufficient; the more restrictive StartExclusive/EndExclusive mechanism is not used. This is primarily intended for system software.</DD>
</DIV>
<DIV>
<A NAME="S_43.htm_IX_VMAttributes">
 </A>
<A NAME="S_43.htm_IX_VMA_&ldots;">
 </A>
</DL>
<H1 CLASS="refHeading">
VMAttributes</H1>
<PRE CLASS="syntax">typedef ByteFlags VMAttributes;
#define VMA_SYNC_UPDATE								0x80
#define VMA_BACKUP 								0x40
#define VMA_OBJECT_RELOC 								0x20
#define VMA_PRESERVE_HANDLES 								0x10
#define VMA_NOTIFY_DIRTY 								0x08
#define VMA_NO_DISCARD_IF_IN_USE		 						0x04
#define VMA_COMPACT_OBJ_BLOCK 								0x02
#define VMA_SINGLE_THREAD_ACCESS		 						0x01
/*
 * Attributes that must be set for object blocks: */</PRE>
<PRE CLASS="syntax">#define VMA_OBJECT_ATTRS				(VMA_OBJECT_RELOC | VMA_PRESERVE_HANDLES |
				 VMA_NO_DISCARD_IF_IN_USE |
				 VMA_SINGLE_THREAD_ACCESS)</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_43.htm_IX_VMBlockHandle">
 </A>
<H1 CLASS="refHeading">
VMBlockHandle</H1>
<PRE CLASS="syntax">typedef word VMBlockHandle;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_43.htm_IX_VMChain">
 </A>
<H1 CLASS="refHeading">
VMChain</H1>
<PRE CLASS="syntax">typedef dword VMChain;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_43.htm_IX_VMChainLink">
 </A>
<A NAME="S_43.htm_IX_VMC_next">
 </A>
<H1 CLASS="refHeading">
VMChainLink</H1>
<PRE CLASS="syntax">typedef struct {
VMBlockHandle			VMC_next;
} VMChainLink;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_43.htm_IX_VMChainTree">
 </A>
<A NAME="S_43.htm_IX_VMCT_&ldots;">
 </A>
<H1 CLASS="refHeading">
VMChainTree</H1>
<PRE CLASS="syntax">typedef struct {
VMChainLink		VMCT_meta;
word		VMCT_offset;
word		VMCT_count;
} VMChainTree;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_43.htm_IX_VMFileHandle">
 </A>
<H1 CLASS="refHeading">
VMFileHandle</H1>
<PRE CLASS="syntax">typedef Handle VMFileHandle;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_43.htm_IX_VMInfoStruct">
 </A>
<H1 CLASS="refHeading">
VMInfoStruct</H1>
<PRE CLASS="syntax">typedef struct {
MemHandle		mh;
word		size;
word		userId;
} VMInfoStruct;</PRE>
<P>
&nbsp;</P>
</DIV>
<HR>
<A NAME="S_44.htm"></A>
<DIV>
</DIV>
<DIV>
<A NAME="S_44.htm_IX_VMOpenType">
 </A>
<A NAME="S_44.htm_IX_VMO_&ldots;  (VMOpenType type)">
 </A>
<H1 CLASS="refHeading">
VMOpenType</H1>
<PRE CLASS="syntax">typedef ByteEnum VMOpenType;
#define VMO_OPEN							0
#define VMO_TEMP_FILE							1
#define VMO_CREATE							2
#define VMO_CREATE_ONLY							3
#define VMO_CREATE_TRUNCATE							4
#define VMO_NATIVE_WITH_EXT_ATTRS							0x80</PRE>
<P>
The following types are available:</P>
<DL>
<DT>
VMO_TEMP_FILE</DT><DD>
If this is passed, the file will be a temporary data file. When you create a temporary file, you pass a directory path, not a file name. The path should be followed by fourteen null bytes, including the string's terminating null. The system will choose an appropriate file name and add it to the path string.</DD>
<DT>
VMO_CREATE_ONLY</DT><DD>
If this is passed, the document will be created. If a document with the specified name already exists in the working directory, <CODE>
<A HREF="../../CRef/Routines/R_a3.htm#IX_VMOpen()">VMOpen()</A></CODE>
 will return an error condition.</DD>
<DT>
VMO_CREATE</DT><DD>
If this is passed, the file will be created if it does not already exist; otherwise it will be opened.</DD>
<DT>
VMO_CREATE_TRUNCATE</DT><DD>
If this is passed, the file will be created if it does not already exist; otherwise, it will be opened and truncated (all data blocks will be freed).</DD>
<DT>
VMO_OPEN</DT><DD>
Open existing file. If file does not exist, return an error condition.</DD>
</DIV>
<DIV>
<A NAME="S_44.htm_IX_VMOperation">
 </A>
<A NAME="S_44.htm_IX_VMO_&ldots;  (VMOperation type)">
 </A>
</DL>
<H1 CLASS="refHeading">
VMOperation</H1>
<PRE CLASS="syntax">typedef enum {
VMO_READ,
VMO_INTERNAL,
VMO_SAVE,
VMO_SAVE_AS,
VMO_REVERT,
VMO_UPDATE,
VMO_WRITE
} VMOperation;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_44.htm_IX_VMRelocType">
 </A>
<A NAME="S_44.htm_IX_VMRT_&ldots;">
 </A>
<H1 CLASS="refHeading">
VMRelocType</H1>
<PRE CLASS="syntax">typedef enum {
VMRT_UNRELOCATE_BEFORE_WRITE,
VMRT_RELOCATE_AFTER_READ,
VMRT_RELOCATE_AFTER_WRITE,
VMRT_RELOCATE_FROM_RESOURCE,
VMRT_UNRELOCATE_FROM_RESOURCE,
} VMRelocType;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_44.htm_IX_VMStartExlusiveReturnValue">
 </A>
<A NAME="S_44.htm_IX_VMSERV_&ldots;">
 </A>
<H1 CLASS="refHeading">
VMStartExclusiveReturnValue</H1>
<PRE CLASS="syntax">typedef enum {
 VMSERV_NO_CHANGES,
 VMSERV_CHANGES,
 VMSERV_TIMEOUT
} VMStartExclusiveReturnValue;</PRE>
<P>
<CODE>
<A HREF="../../CRef/Routines/R_a3.htm#IX_VMGrabExclusive()">VMGrabExclusive()</A></CODE>
 returns a member of this enumerated type. It may have one of the following values:</P>
<DL>
<DT>
VMSERV_NO_CHANGES</DT><DD>
No other thread has changed this file since the last time this thread had access to the file.</DD>
<DT>
VMSERV_CHANGES</DT><DD>
The file may have been altered since the last time this thread had access to it; the thread should take appropriate actions (such as re-reading any cached data).</DD>
<DT>
VMSERV_TIMEOUT</DT><DD>
This call to <CODE>
<A HREF="../../CRef/Routines/R_a3.htm#IX_VMGrabExclusive()">VMGrabExclusive()</A></CODE>
 failed and timed out without getting access to the file.</DD>
</DIV>
<DIV>
<A NAME="S_44.htm_IX_VolumeName">
 </A>
<A NAME="S_44.htm_IX_VOLUME_BUFFER_SIZE">
 </A>
</DL>
<H1 CLASS="refHeading">
VolumeName</H1>
<PRE CLASS="syntax">typedef char VolumeName[VOLUME_BUFFER_SIZE];</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_44.htm_IX_WBFixed">
 </A>
<A NAME="S_44.htm_IX_WBF_&ldots;">
 </A>
<H1 CLASS="refHeading">
WBFixed</H1>
<PRE CLASS="syntax">typedef struct {
byte WBF_frac;
word WBF_int;
} WBFixed;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_44.htm_IX_wchar">
 </A>
<H1 CLASS="refHeading">
wchar</H1>
<PRE CLASS="syntax">typedef unsigned int wchar;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_44.htm_IX_WindowHandle">
 </A>
<H1 CLASS="refHeading">
WindowHandle</H1>
<PRE CLASS="syntax">typedef Handle WindowHandle;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_44.htm_IX_WinInfoType">
 </A>
<A NAME="S_44.htm_IX_WIT_&ldots;">
 </A>
<H1 CLASS="refHeading">
WinInfoType</H1>
<PRE CLASS="syntax">typedef enum /* word */ {
WIT_PRIVATE_DATA =0,
WIT_COLOR =2,
WIT_INPUT_OBJ =4,
WIT_EXPOSURE_OBJ =6,
WIT_STRATEGY =8,
WIT_FLAGS =10,
WIT_LAYER_ID =12,
WIT_PARENT_WIN =14,
WIT_FIRST_CHILD_WIN =16,
WIT_LAST_CHILD_WIN =18,
WIT_PREV_SIBLING_WIN =20,
WIT_NEXT_SIBLING_WIN =22,
WIT_PRIORITY=24,
} WinInfoType;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_44.htm_IX_WinInvalFlag">
 </A>
<A NAME="S_44.htm_IX_WIF_&ldots;">
 </A>
<H1 CLASS="refHeading">
WinInvalFlag</H1>
<PRE CLASS="syntax">typedef ByteEnum WinInvalFlag;
#define WIF_INVALIDATE					0
#define WIF_DONT_INVALIDATE					1</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_44.htm_IX_WinPassFlags">
 </A>
<A NAME="S_44.htm_IX_WPF_&ldots;">
 </A>
<H1 CLASS="refHeading">
WinPassFlags</H1>
<PRE CLASS="syntax">typedef WordFlags WinPassFlags;
#define WPF_CREATE_GSTATE						0x8000
#define WPF_ROOT 						0x4000
#define WPF_SAVE_UNDER 						0x2000
#define WPF_INIT_EXCLUDED 						0x1000
#define WPF_PLACE_BEHIND 						0x0800
#define WPF_PLACE_LAYER_BEHIND 						0x0400
#define WPF_LAYER 						0x0200
#define WPF_ABS 						0x0100
#define WPF_PRIORITY 						0x00ff</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_44.htm_IX_WinPriority">
 </A>
<A NAME="S_44.htm_IX_WIN_PRIO_&ldots;">
 </A>
<H1 CLASS="refHeading">
WinPriority</H1>
<PRE CLASS="syntax">typedef ByteEnum WinPriority;
#define WIN_PRIO_POPUP					 4
#define WIN_PRIO_MODAL 					 6
#define WIN_PRIO_ON_TOP 					 8
#define WIN_PRIO_COMMAND 					10
#define WIN_PRIO_STD 					12
#define WIN_PRIO_ON_BOTTOM 					14</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_44.htm_IX_word">
 </A>
<H1 CLASS="refHeading">
word</H1>
<PRE CLASS="syntax">typedef unsigned int word;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_44.htm_IX_WordAndAHalf">
 </A>
<A NAME="S_44.htm_IX_WAAH_&ldots;">
 </A>
<H1 CLASS="refHeading">
WordAndAHalf</H1>
<PRE CLASS="syntax">typedef struct {
word 	WAAH_low;
byte 	WAAH_high;
} WordAndAHalf;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_44.htm_IX_WordFlags">
 </A>
<H1 CLASS="refHeading">
WordFlags</H1>
<PRE CLASS="syntax">typedef word WordFlags;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_44.htm_IX_WWFixed">
 </A>
<A NAME="S_44.htm_IX_WWF_&ldots;">
 </A>
<H1 CLASS="refHeading">
WWFixed</H1>
<PRE CLASS="syntax">typedef struct {
word WWF_frac;
word WWF_int;
} WWFixed;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_44.htm_IX_WWFixedAsDWord">
 </A>
<H1 CLASS="refHeading">
WWFixedAsDWord</H1>
<PRE CLASS="syntax">typedef dword WWFixedAsDWord</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="S_44.htm_IX_XYOffset">
 </A>
<A NAME="S_44.htm_IX_XYO_&ldots;">
 </A>
<H1 CLASS="refHeading">
XYOffset</H1>
<PRE CLASS="syntax">typedef struct {
sword XYO_x;
sword XYO_y;
} XYOffset;</PRE>
<P>
A graphics coordinate offset.</P>
</DIV>
<DIV>
<A NAME="S_44.htm_IX_XYSize">
 </A>
<A NAME="S_44.htm_IX_XYS_&ldots;">
 </A>
<H1 CLASS="refHeading">
XYSize</H1>
<PRE CLASS="syntax">typedef struct {
word XYS_width;
word XYS_height;
} XYSize;</PRE>
<P>
A graphics size, in two dimensions.</P>
</DIV>
<DIV>
<A NAME="S_44.htm_IX_XYValueAsDWord">
 </A>
<H1 CLASS="refHeading">
XYValueAsDWord</H1>
<PRE CLASS="syntax">typedef dword XYValueAsDWord;</PRE>
<P>
A graphics size, in two dimensions, expressed as a DWord.</P>
</DIV>
<HR>
This document is a single-page version of a <A HREF="index.htm">a multi-page document</A>, suitable for easy printing.
</BODY>
</HTML>
