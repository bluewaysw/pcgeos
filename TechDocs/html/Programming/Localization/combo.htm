<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD>
<!-- This page was automatically generated from a bunch of smaller pages. -->
<META NAME="copyright" CONTENT="Copyright GEOWORKS">
<LINK REL="STYLESHEET" HREF="../../docHelpers/style.css">
<LINK REV="MADE" HREF="mailto:doc-feedback@geoworks.com">
<TITLE>Localization</TITLE>
</HEAD>
<BODY BGCOLOR="#ffffdf">
This document is a single-page version of a <A HREF="index.htm">a multi-page document</A>, suitable for easy printing.
<A NAME="index.htm"></A>



<H1 CLASS="chapterTitle">

<A NAME="index.htm_35552">
 </A>
Localization

</H1>
<P>
<A NAME="index.htm_IX_Localization">
 </A>
Localization is the means by which GEOS adapts to foreign environments. The kernel automatically accounts for such country-dependent items as currencies and keyboard layouts. Your geodes can work with foreign character sets and formatting preferences. Using the <CODE>
ResEdit</CODE>
 tool, anyone can quickly translate an executable's text into other languages. You should look over this chapter whether or not you're planning on distributing your software internationally. The chapter includes documentation for some functions which you're likely to use regardless.</P>
<P CLASS="sectionlinks">
<STRONG>
&nbsp;&nbsp;<A HREF="#Localization_1.htm">1 Localization Goals</A><BR>
&nbsp;&nbsp;<A HREF="#Localization_2.htm">2 How To Use Localization</A><BR>
&nbsp;&nbsp;<A HREF="#Localization_3.htm">3 Preparing for ResEdit</A><BR>
&nbsp;&nbsp;<A HREF="#Localization_4.htm">4 International Formats</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Localization_5.htm">4.1 Number and Measure</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Localization_6.htm">4.2 Currency</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Localization_7.htm">4.3 Quotation Marks</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Localization_8.htm">4.4 Dates and Times</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Localization_9.htm">4.5 Filters for Formats</A><BR>
&nbsp;&nbsp;<A HREF="#Localization_a.htm">5 Lexical Functions</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Localization_b.htm">5.1 Comparing Strings</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Localization_c.htm">5.2 String Length and Size</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Localization_d.htm">5.3 Casing</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Localization_e.htm">5.4 Character Categories</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Localization_f.htm">5.5 Lexical Values</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Localization_10.htm">5.6 DOS Text &amp; Code Pages</A><BR>
</STRONG>
</P> <!-- end of sectionlinks blob -->

<HR>
<A NAME="Localization_1.htm"></A>


<H2 CLASS="sectionTitle">
<A HREF="#index.htm">Localization</A>: 1 
Localization Goals</H2>
<P>
The benefit of Geoworks' experience with previous international products was designed into GEOS from the start. The kernel was designed with the following three goals of localization in mind:</P>
<UL>
<LI>
Ease of use<BR>
Localization should be easy to use. A cumbersome system would slow programmers and leave them reluctant to use the system.</LI>
<LI>
Integration with the kernel<BR>
Functions used by many geodes should be part of the kernel. This allows for shared code, using less memory and making developers' jobs easier.</LI>
<LI>
Economy<BR>
Anyone should be able to translate an executable's text without having to understand or access the source code.</LI>
</UL>
<P>
If you plan to release your software in other languages, you should code it for easy conversion later. Even if you have no such plans, there are still good reasons for using the localization features of GEOS.</P>
<UL>
<LI>
Stay Generic and Adaptable<BR>
By using localization code, your programs can work in a variety of environments without modification of source code. Even if you don't translate your geode into another language, users can still use it despite different keyboards and character sets.</LI>
<LI>
Respect user's preferences<BR>
Much of localization deals with user preferences which differ from country to country. Regardless of country, users may make changes using the Preferences desk tool and will no doubt appreciate having their preferences maintained.</LI>
<LI>
Conform to the system<BR>
You're probably going to end up using localization since much of GEOS is already localized. If your geodes are going to read DOS text files or alphabetize lists, you're going to use localized code; GEOS takes foreign character sets into account. Fortunately, localization functions are easy to use. In those situations where you don't absolutely have to use localized code, usually it's easier to use the localized functions than to write your own.</LI>


</UL>
<HR>
<A NAME="Localization_2.htm"></A>


<H2 CLASS="sectionTitle">
<A HREF="#index.htm">Localization</A>: 2 
How To Use Localization</H2>
<P>
Your localization workload will vary depending on whether you plan to release your software in other countries. If you don't plan on exporting your software, your only contact with localization will come when you use the common functions that are localized. If you plan on international distribution, you'll be using localization both when writing your geodes and later on, during the translation process, in the following steps:</P>
<UL>
<LI>
Use provided routines.<BR>
Several GEOS functions have been localized to handle foreign variations, and you should use these whether you plan international release or not. Most of these functions are concerned with &quot;International formats&quot; and character sets.</LI>
<LI>
Plan ahead for <CODE>
ResEdit</CODE>
.<BR>
You'll probably use the <CODE>
ResEdit</CODE>
 tool if you translate your software into other languages. You'll have to be careful about how you write your programs if <CODE>
ResEdit</CODE>
 is to work with them properly. Any text in your geode that the user may see will have to be translated. <CODE>
ResEdit</CODE>
 looks only at chunk is in localizable resources. You should also be prepared for the translations of any string to be longer than the original. You may want to provide instructions for translators. You may include these instructions within the body of your source code, close to the strings that will be translated.</LI>
<LI>
Use <CODE>
ResEdit</CODE>
.<BR>
The <CODE>
ResEdit</CODE>
 tool makes translation easy. It goes through an application's resources and checks all objects for strings and bitmaps, asking the translator to make any fitting changes. The translator never needs to see the source code and doesn't have to know how to program.</LI>
</UL>
<HR>
<A NAME="Localization_3.htm"></A>


<H2 CLASS="sectionTitle">
<A HREF="#index.htm">Localization</A>: 3 
Preparing for ResEdit

</H2>
<P>
<CODE>
ResEdit</CODE>
 is a GEOS program which speeds geode translations. This section won't tell you how to use the <CODE>
ResEdit</CODE>
 tool but will explain how to write your code if you want <CODE>
ResEdit</CODE>
 to work with it correctly.

</P>
<P>
<A NAME="Localization_3.htm_IX_Monikers:localizing">
 </A>
The important thing to remember is to put all text and bitmaps to be localized in localizable resources. <CODE>
ResEdit</CODE>
 looks for localizable objects only in non-code resources. The string or bitmap itself must be stored in a chunk, which you may insure by using either the <CODE>
@chunk</CODE>
 or <CODE>
@visMoniker</CODE>
 keywords. (If you're using assembly, you should use the <CODE>
LocalDefString</CODE>
 macro when setting up localizable strings.) Thus, your application icons are probably stored in the following way:</P>
<PRE>@start APPSCMONIKERRESOURCE, data
/* Application moniker: */
@visMoniker MyAppSCMoniker = { /* ... */}
@end APPSCMONIKERRESOURCE</PRE>
<P>
At first it might seem surprising that bitmaps should be localized, since pictures are supposed to be a sort of universal language. However, this attitude may seem less strange when you try to distribute software to a culture that finds pictures of yellow arrows offensive.</P>
<P>
Your application could keep its strings in a resource in the style illustrated in <A HREF="#Localization_3.htm_60394"> Storing Strings in Localizable Resources</A>
.</P>
<P CLASS="figTitle">
Code Display 8-1 <A NAME="Localization_3.htm_60394">
 </A>
Storing Strings in Localizable Resources</P>
<PRE>@start ErrorStrings, data;</PRE>
<PRE>@chunk char NoMonkeyError[] = 
	&quot;FTPOOMM failed: No monkey present. Acquire a monkey and try again.&quot;;</PRE>
<PRE>@chunk char NoPeanutError[] = 
	&quot;FTPOOMM failed: No peanuts present. Please insert peanuts and try again.&quot;;</PRE>
<PRE>@end ErrorStrings;</PRE>
<P>
When working with assembly language, this means that any object stored in a <CODE>
code</CODE>
 resource, <CODE>
idata</CODE>
, or <CODE>
udata</CODE>
 will be passed over in the search for localizable resources, and thus will not be localizable.</P>
<P>
<A NAME="Localization_3.htm_IX_@localize[;localize]">
 </A>
When you know you are storing your strings such that they are localizable, you can provide information which will be visible to the translator when they use the <CODE>
ResEdit</CODE>
 tool. Use the <CODE>
@localize</CODE>
 keyword (<CODE>
localize</CODE>
 in assembly) to set up this help text. The <CODE>
@localize</CODE>
 directive should directly follow the chunk it applies to.</P>
<P>
Remember the <CODE>
@localize</CODE>
 syntax:</P>
<PRE>	 @localize { &lt;string&gt; &lt;min&gt;-&lt;max&gt; };
	 @localize { &lt;string&gt; &lt;length&gt; };
	 @localize { &lt;string&gt; };
	 @localize &lt;string&gt;; 
 @localize not;</PRE>
<P CLASS="figTitle">
Code Display 8-2 <A NAME="Localization_3.htm_60394">
 </A>
Storing Strings in Localizable Resources</P>
<PRE>@start ErrorStrings, data</PRE>
<PRE>@chunk char NoMonkeyError[] = 
	&quot;FTPOOMM failed: No monkey present. Acquire a monkey and try again&quot;;</PRE>
<PRE>@localize &quot;The phrase 'acquire a monkey' appears in another string. Both should \
be translated in the same way.&quot;;</PRE>
<PRE>@end ErrorStrings</PRE>
<PRE>@object GenGlyphClass BossMon = {
	 GI_visMoniker = &quot;Boss&quot;;
	 @localize { &quot;This means hide the game because a boss is coming&quot; 3-6 }; } </PRE>
<P>
Another thing to keep in mind is that when strings are translated, they are likely to grow 33% to 50%. You have to remember to leave room for larger strings, both in memory and in UI. If you use the usual generic UI gadgetry, the geometry manager should stretch the various gadgets to fit any larger names. You should be careful that it doesn't have to stretch so far that components get lost off the edge of the screen. If you decide to get around this problem by constraining the size of some gadgetry, keep in mind that if you don't allow it to stretch, your new strings may not fit. </P>
<HR>
<A NAME="Localization_4.htm"></A>


<H2 CLASS="sectionTitle">
<A HREF="#index.htm">Localization</A>: 4 
International Formats</H2>
<P>
&quot;International Formats&quot; generally refers to formats which differ from country to country. In GEOS, it signifies those formats which the user can set in the International section of the Preferences desk tool. GEOS provides functions to work with International Formats.</P>
<P CLASS="subsectionLink">
<A HREF="#Localization_5.htm">Number and Measure</A></P>
<P CLASS="subsectionLink">
<A HREF="#Localization_6.htm">Currency</A></P>
<P CLASS="subsectionLink">
<A HREF="#Localization_7.htm">Quotation Marks</A></P>
<P CLASS="subsectionLink">
<A HREF="#Localization_8.htm">Dates and Times</A></P>
<P CLASS="subsectionLink">
<A HREF="#Localization_9.htm">Filters for Formats</A></P>
<HR>
<A NAME="Localization_5.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Localization</A>: 4.1 <A HREF="#Localization_4.htm">International Formats</A>: 
Number and Measure</H3>
<PRE>LocalGetNumericFormat(), LocalSetNumericFormat()
LocalGetMeasurementType(), LocalSetMeasurementType(), LocalAsciiToFixed(), LocalFixedToAscii(), LocalDistanceToAscii(), LocalDistanceFromAscii()</PRE>
<P>
<A NAME="Localization_5.htm_IX_Distances:formatting">
 </A>
<A NAME="Localization_5.htm_IX_Measurement type:formatting">
 </A>
<A NAME="Localization_5.htm_IX_Numbers:formatting">
 </A>
In the USA, 3.142 is a little more than three. In some other countries, it's a little over three thousand. This discrepancy arises from the fact that the decimal and thousands separators are interchanged--in some countries the &quot;.&quot; symbol takes the place of the &quot;,&quot; symbol when expressing numbers. To allow for local number formats, GEOS provides functions for retrieving and setting the user's preferences.</P>
<P>
The number format includes the thousands separator, decimal separator, list separator, and number of decimal digits, as shown in the figure below. The number format also contains a record, <A NAME="Localization_5.htm_IX_NumberFormatFlags">
 </A>
<CODE>
NumberFormatFlags</CODE>
, which holds one flag, NFF_LEADING_ZERO<A NAME="Localization_5.htm_IX_NFF_LEADING_ZERO">
 </A>
. This flag is on if the user wants a leading zero.</P>
<P>
There is no overall automatic formatting command for numbers. GEOS supports many internal numeric formats such as fixed point and floating point. If the corresponding math library doesn't contain a formatting command for the number format you're using, you will need to work directly with the localization functions.</P>
<P>
<A NAME="Localization_5.htm_IX_ASCII text:number strings">
 </A>
The <A NAME="Localization_5.htm_IX_LocalGetNumericFormat()">
 </A>
<CODE>
LocalGetNumericFormat()</CODE>
 routine returns the numeric format so you may use it to do your own formatting.<CODE>
 LocalSetNumericFormat()</CODE>
<A NAME="Localization_5.htm_IX_LocalSetNumericFormat()">
 </A>
 allows you to reset the user's preferences, though this is inadvisable as it overrides and erases the user's original settings.
<IMG SRC="Localization_5_numFormat.gif">

</P>
<P>
These routines use the <A NAME="Localization_5.htm_IX_LocalNumericFormat">
 </A>
<CODE>
LocalNumericFormat</CODE>
 structure to store the number format data. </P>
<P>
The <A NAME="Localization_5.htm_IX_LocalGetMeasurementType()">
 </A>
<CODE>
LocalGetMeasurementType()</CODE>
 and <A NAME="Localization_5.htm_IX_MeasurementType">
 </A>
<A NAME="Localization_5.htm_IX_LocalSetMeasurementType()">
 </A>
<CODE>
LocalSetMeasurementType()</CODE>
 routines work with the enumerated type <A NAME="Localization_5.htm_IX_MeasurementType">
 </A>
<CODE>
MeasurementType</CODE>
, of which there are two: <A NAME="Localization_5.htm_IX_MEASURE_US">
 </A>
MEASURE_US and <A NAME="Localization_5.htm_IX_MEASURE_METRIC">
 </A>
MEASURE_METRIC. <CODE>
LocalGetMeasurementType()</CODE>
 retrieves the user's current preferred measurement type; <CODE>
LocalSetMeasurementType()</CODE>
 sets the user's preference to the passed value. As with any command that resets the user's preference, <CODE>
LocalSetMeasurementType()</CODE>
 should never be used by most geodes.</P>
<P>
<A NAME="Localization_5.htm_IX_WWFixed:Formatting as Strings">
 </A>
The <A NAME="Localization_5.htm_IX_LocalAsciiToFixed()">
 </A>
<CODE>
LocalAsciiToFixed()</CODE>
 routine converts an ascii string (e.g. &quot;12.7&quot;) to a fixed point number.<CODE>
 LocalFixedToAscii()</CODE>
<A NAME="Localization_5.htm_IX_LocalFixedToAscii()">
 </A>
 performs the reverse.</P>
<P>
To convert between a string like &quot;72 pt&quot; and a number representing a distance, use the <A NAME="Localization_5.htm_IX_LocalDistanceFromAscii()">
 </A>
<CODE>
LocalDistanceFromAscii()</CODE>
 routine. <CODE>
LocalDistanceToAscii()</CODE>
<A NAME="Localization_5.htm_IX_LocalDistanceToAscii()">
 </A>
 goes the other way, constructing the string corresponding to a given distance. These routines use the <CODE>
DistanceUnit</CODE>
<A NAME="Localization_5.htm_IX_DistanceUnit">
 </A>
 enumerated type to specify the measurement units which are used as shown in the table below.</P>
<P>
When allocating strings to use as the targets for Local...ToAscii() routines, allocating a buffer of size <A NAME="Localization_5.htm_IX_LOCAL_DISTANCE_BUFFER_SIZE">
 </A>
LOCAL_DISTANCE_BUFFER_SIZE will be sufficient.</P>
<P FIXME_FigTablTitle>
Table 8-1 DistanceUnit types</P>
<P FIXME_FigTablHeader>
DistanceUnit value			# of Points 		Display Format			Entry Format(s)

</P>
<P FIXME_FigTableBody>
DU_POINTS<A NAME="Localization_5.htm_IX_DU_&ldots;">
 </A>
			   1.000		###.### pt			###.### pt	</P>
<P FIXME_FigTableBody>
DU_INCHES 			72.000		###.### in			###.### in		###.###&quot;	</P>
<P FIXME_FigTableBody>
DU_CENTIMETERS 			28.346		###.### cm			###.###cm	</P>
<P FIXME_FigTableBody>
DU_MILLIMETERS 			   2.835		###.### mm			###.###mm	</P>
<P FIXME_FigTableBody>
DU_PICAS 			12.000		###.### pi 			###.### pi	</P>
<P FIXME_FigTableBody>
DU_EUR_POINTS 			   1.065		###.### ep 			###.### ep		</P>
<P FIXME_FigTableBody>
DU_CICEROS			12.787		###,### ci 			###.### ci	</P>
<P FIXME_FigTableBody>
DU_POINTS_OR_MILLIMETERS and DU_INCHES_OR_CENTIMETERS: special cases</P>
<HR>
<A NAME="Localization_6.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Localization</A>: 4.2 <A HREF="#Localization_4.htm">International Formats</A>: 
Currency</H3>
<PRE>LocalGetCurrencyFormat(), LocalSetCurrencyFormat()</PRE>
<P>
<A NAME="Localization_6.htm_IX_Money:currency formats">
 </A>
<A NAME="Localization_6.htm_IX_Currency:formatting">
 </A>
These functions allow you to work with the currency format (see the figure below). This format consists of the currency symbol string, number of currency digits (which may be different from the number of digits for ordinary numbers), and the <A NAME="Localization_6.htm_IX_CurrencyFormatFlags">
 </A>
<CODE>
CurrencyFormatFlags</CODE>
 record. <A NAME="Localization_6.htm_IX_CFF_&ldots;">
 </A>
The flags in this structure determine whether the currency format includes space around the symbol, a negative sign, or a leading zero. There are flags to determine the relative order of the negative sign, currency symbol, and number. The currency symbol string may be of up to length <A NAME="Localization_6.htm_IX_CURRENCY_SYMBOL_LENGTH">
 </A>
CURRENCY_SYMBOL_LENGTH including the null terminator. <A NAME="Localization_6.htm_IX_LocalGetCurrencyFormat()">
 </A>
<CODE>
LocalGetCurrencyFormat()</CODE>
 also returns the separator characters from the numeric formats, eliminating the need for a separate call to <A NAME="Localization_6.htm_IX_LocalGetNumericFormat()">
 </A>
<CODE>
LocalGetNumericFormat()</CODE>
. <CODE>
LocalSetCurrencyFormat()</CODE>
<A NAME="Localization_6.htm_IX_LocalSetCurrencyFormat()">
 </A>
 allows the changing of the set preferences. Most parts of the currency format are stored in a <A NAME="Localization_6.htm_IX_LocalCurrencyFormat">
 </A>
<CODE>
LocalCurrencyFormat</CODE>
 structure when passed to or returned by these functions.
<IMG SRC="Localization_6_currencyFormat.gif">

</P>
<HR>
<A NAME="Localization_7.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Localization</A>: 4.3 <A HREF="#Localization_4.htm">International Formats</A>: 
Quotation Marks</H3>
<PRE>LocalGetQuotes(), LocalSetQuotes()</PRE>
<P>
<A NAME="Localization_7.htm_IX_' :localizing">
 </A>
<A NAME="Localization_7.htm_IX_&#34;:localizing">
 </A>
<A NAME="Localization_7.htm_IX_Quotation marks:localizing">
 </A>
In different countries, people use different types of quotation marks. Germans, for example, might use the » and « characters. Although traditionally, the only computer-generated quotation marks available are &quot; and &quot;, GEOS allows all geodes to use native quotation marks without extraordinary effort.</P>
<P>
If a user types in a quotation mark, the keyboard knows which character to print; thus, if you're using <CODE>
ResEdit</CODE>
 on a string, it's easy to have your translator type in the correct character. In these cases your geode will have no use for <A NAME="Localization_7.htm_IX_LocalGetQuotes()">
 </A>
<CODE>
LocalGetQuotes()</CODE>
 or <A NAME="Localization_7.htm_IX_LocalSetQuotes()">
 </A>
<CODE>
LocalSetQuotes()</CODE>
. On the other hand, if your program is going to construct a string which contains quotation marks, use the <CODE>
LocalGetQuotes()</CODE>
 routine; it will return the correct characters to use. If you want to reset the preferences, use the <CODE>
LocalSetQuotes()</CODE>
 routine.</P>
<P>
These routines work with the <A NAME="Localization_7.htm_IX_LocalQuotes">
 </A>
<CODE>
LocalQuotes</CODE>
 structure, which simply holds four characters to use as the four kinds of quotation mark.</P>
<HR>
<A NAME="Localization_8.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Localization</A>: 4.4 <A HREF="#Localization_4.htm">International Formats</A>: 
Dates and Times</H3>
<PRE>LocalFormatDateTime(), LocalParseDateTime(),
LocalGetDateTimeFormat(), LocalSetDateTimeFormat(),
LocalCustomFormatDateTime(), LocalCustomParseDateTime(), LocalCalcDaysInMonth(), LocalFormatFileDateTime()</PRE>
<P>
<CODE>
LocalFormatDateTime()</CODE>
<A NAME="Localization_8.htm_IX_Date:formatting">
 </A>
<A NAME="Localization_8.htm_IX_Time:formatting">
 </A>
<A NAME="Localization_8.htm_IX_LocalFormatDateTime()">
 </A>
 and <A NAME="Localization_8.htm_IX_LocalParseDateTime()">
 </A>
<CODE>
LocalParseDateTime()</CODE>
 allow display and parsing of date and time strings in a variety of formats. Passed the appropriate data, <CODE>
LocalFormatDateTime()</CODE>
 will return a string with the data appropriately formatted. <CODE>
LocalParseDateTime()</CODE>
 performs the reverse function, reading a string and attempting to extract information from it. The strings these functions use should be long enough to hold a formatted date or time. The predefined constant DATE_TIME_BUFFER_SIZE is the minimum recommended number of characters for one of these strings.
<IMG SRC="Localization_8_DateTimeFormat.gif">

</P>
<P>
Localization functions use <A NAME="Localization_8.htm_IX_DateTimeFormat">
 </A>
<CODE>
DateTimeFormat</CODE>
s to keep track of what sort of format is desired. If told to parse &quot;5:28&quot; as hours and minutes, <CODE>
LocalParseDateTime()</CODE>
 will (depending on the user's time format preferences) return 5 in the hours place and 28 in the minutes place. If told to parse &quot;5/28&quot; as hours and minutes, <CODE>
LocalParseDateTime()</CODE>
 would return an error. There are a variety of <CODE>
DateTimeFormats()</CODE>
 to choose from, and you should decide which format to use based on what information you want your application to display or read.</P>
<P>
Each <CODE>
DateTimeFormat</CODE>
 has a string associated with it that contains formatting information. This string consists of the characters of the format, with place-holding tokens for the fields of the date or time. These tokens are delimited by the special character &quot;|&quot;. For example, the date/time format string &quot;|HH|:|mm| |ap|&quot; would correspond to the formatted string &quot;10:37 am&quot;. The string for each <CODE>
DateTimeFormat</CODE>
 can be accessed or altered with the <A NAME="Localization_8.htm_IX_LocalGetDateTimeFormat()">
 </A>
<CODE>
LocalGetDateTimeFormat()</CODE>
 and <A NAME="Localization_8.htm_IX_LocalSetDateTimeFormat()">
 </A>
<CODE>
LocalSetDateTimeFormat()</CODE>
 commands. The recommended minimum size of a date/time format string is the constant DATE_TIME_FORMAT_SIZE.
<IMG SRC="Localization_8_DateTimeFormatString.gif">

</P>
<P>
If you don't wish to work through one of the standard <CODE>
DateTimeFormat</CODE>
 values, you can construct a string containing some date/time tokens and pass it as an argument to <A NAME="Localization_8.htm_IX_LocalCustomFormatDateTime()">
 </A>
<CODE>
LocalCustomFormatDateTime()</CODE>
, along with the appropriate date and time information. To parse a date/time using a custom format, use <A NAME="Localization_8.htm_IX_LocalCustomParseDateTime()">
 </A>
<CODE>
LocalCustomParseDateTime()</CODE>
.</P>
<P>
The <A NAME="Localization_8.htm_IX_Files:Formatting Date Strings">
 </A>
<A NAME="Localization_8.htm_IX_LocalFormatFileDateTime()">
 </A>
<CODE>
LocalFormatFileDateTime()</CODE>
 utility routine works in the same way as <CODE>
LocalFormatDateTime()</CODE>
, except it takes a <A NAME="Localization_8.htm_IX_FileDateAndTime:Printing">
 </A>
<CODE>
FileDateAndTime</CODE>
 argument. It is normally used to format the information returned by <CODE>
FileGetDateAndTime()</CODE>
 or <CODE>
TimerGetFileDateTime()</CODE>
.</P>
<P>
The <A NAME="Localization_8.htm_IX_LocalCalcDaysInMonth()">
 </A>
<CODE>
LocalCalcDaysInMonth()</CODE>
 utility routine takes a month number and returns the number of days in that month.

</P>
<P>
A number of constants have been set up to aid in the computation of the size of string necessary to hold a date/time or a date/time format string. These constants are <A NAME="Localization_8.htm_IX_DATE_TIME_BUFFER_SIZE">
 </A>
DATE_TIME_BUFFER_SIZE, <A NAME="Localization_8.htm_IX_DATE_TIME_FORMAT_SIZE">
 </A>
DATE_TIME_FORMAT_SIZE, MAX_MONTH_LENGTH<A NAME="Localization_8.htm_IX_MAX_MONTH_LENGTH">
 </A>
, <A NAME="Localization_8.htm_IX_MAX_DAY_LENGTH">
 </A>
MAX_DAY_LENGTH, <A NAME="Localization_8.htm_IX_MAX_YEAR_LENGTH">
 </A>
MAX_YEAR_LENGTH, MAX_WEEKDAY_LENGTH<A NAME="Localization_8.htm_IX_MAX_WEEKDAY_LENGTH">
 </A>
, <A NAME="Localization_8.htm_IX_MAX_SEPARATOR_LENGTH">
 </A>
MAX_SEPARATOR_LENGTH, and TOKEN_LENGTH<A NAME="Localization_8.htm_IX_TOKEN_LENGTH">
 </A>
.</P>
<HR>
<A NAME="Localization_9.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Localization</A>: 4.5 <A HREF="#Localization_4.htm">International Formats</A>: 
Filters for Formats</H3>
<PRE>LocalIsDateChar(), LocalIsTimeChar(), LocalIsNumChar()</PRE>
<P>
The generic UI allows for filters on text objects to keep users from typing inappropriate characters. For example, if the user were expected to type in a number, the &quot;~&quot; character would be ignored as that isn't part of the number format. If you want to use generic text objects, you can give them hints to accept only characters from certain formats. If you want to use the filtering functions for your own purposes, they are available globally. When passed a character, these functions will tell whether the character is a legal part of a format. <A NAME="Localization_9.htm_IX_LocalIsDateChar()">
 </A>
<CODE>
LocalIsDateChar()</CODE>
 returns TRUE if the passed character is part of the short date format, DTF_SHORT. <A NAME="Localization_9.htm_IX_LocalIsTimeChar()">
 </A>
<CODE>
LocalIsTimeChar()</CODE>
 returns TRUE when passed a number or time separator character. <A NAME="Localization_9.htm_IX_LocalIsNumChar()">
 </A>
<CODE>
LocalIsNumChar()</CODE>
 returns TRUE when passed a number character, a separator, or negative sign.</P>
<HR>
<A NAME="Localization_a.htm"></A>


<H2 CLASS="sectionTitle">
<A HREF="#index.htm">Localization</A>: 5 
Lexical Functions</H2>
<P>
Since different languages have different alphabets, GEOS has to allow for characters not in the standard English character set. <A NAME="Localization_a.htm_IX_Chars">
 </A>
You will find that character values are stored via the <CODE>
Chars</CODE>
 enumerated type. Thus, many standard procedures have been localized. Most of these functions have to do with the lexical value of characters, their place in a lexical, or alphabetic, ordering. These lexical values take the place of ASCII standard character values that you may be used to.</P>
<P CLASS="subsectionLink">
<A HREF="#Localization_b.htm">Comparing Strings</A></P>
<P CLASS="subsectionLink">
<A HREF="#Localization_c.htm">String Length and Size</A></P>
<P CLASS="subsectionLink">
<A HREF="#Localization_d.htm">Casing</A></P>
<P CLASS="subsectionLink">
<A HREF="#Localization_e.htm">Character Categories</A></P>
<P CLASS="subsectionLink">
<A HREF="#Localization_f.htm">Lexical Values</A></P>
<P CLASS="subsectionLink">
<A HREF="#Localization_10.htm">DOS Text &amp; Code Pages</A></P>
<HR>
<A NAME="Localization_b.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Localization</A>: 5.1 <A HREF="#Localization_a.htm">Lexical Functions</A>: 
Comparing Strings</H3>
<PRE>LocalCmpStrings(), LocalCmpStringsNoCase(), LocalCmpStringsNoSpace(), LocalCmpStringsNoSpaceCase(), LocalGetLanguage(), LocalCmpChars(), LocalCmpCharsNoCase()</PRE>
<P>
<CODE>
LocalCmpStrings()</CODE>
<A NAME="Localization_b.htm_IX_Strings:comparing">
 </A>
<A NAME="Localization_b.htm_IX_LocalCmpStrings()">
 </A>
 takes two strings as arguments and says which, if either, comes first alphabetically. <A NAME="Localization_b.htm_IX_LocalCmpStringsNoCase()">
 </A>
<CODE>
LocalCmpStringsNoCase()</CODE>
 does the same thing but is not case sensitive. <CODE>
LocalCmpStrings()</CODE>
 does a better job of ordering strings than assembly language instructions such as <A NAME="Localization_b.htm_IX_cmps:Compared to LocalCmpStrings()">
 </A>
<CODE>
cmps</CODE>
 that just compare ASCII values. Since the ASCII value of &quot;a&quot; places it after &quot;Z&quot;, it is advisable to use <CODE>
LocalCmpStrings()</CODE>
, which uses the localized lexical values. When comparing two strings for equality, assembly instructions like <CODE>
cmps</CODE>
 may be used safely.</P>
<P>
The <A NAME="Localization_b.htm_IX_LocalCmpStringsNoSpace()">
 </A>
<CODE>
LocalCmpStringsNoSpace()</CODE>
 and <CODE>
LocalCmpStringsNoSpaceCase()</CODE>
<A NAME="Localization_b.htm_IX_LocalCmpStringsNoSpaceCase()">
 </A>
 routines are like the <CODE>
LocalCmpStrings()</CODE>
 and <CODE>
LocalCmpStringsNoCase()</CODE>
 routines, except that spaces and punctuation marks are ignored. Note that if you are comparing only a certain number of characters that spaces and punctuation marks will not be included in this number.</P>
<P>
The sort order of the strings will depend on the language used when sorting them. To find out the current language used for sorting, call <CODE>
LocalGetLanguage()</CODE>
<A NAME="Localization_b.htm_IX_LocalGetLanguage()">
 </A>
.</P>
<P>
There are two assembly routines <A NAME="Localization_b.htm_IX_LocalCmpChars()">
 </A>
<CODE>
LocalCmpChars()</CODE>
 and <CODE>
LocalCmpCharsNoCase()</CODE>
<A NAME="Localization_b.htm_IX_LocalCmpCharsNoCase()">
 </A>
 which allow for the quick lexical comparison of two characters.</P>
<HR>
<A NAME="Localization_c.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Localization</A>: 5.2 <A HREF="#Localization_a.htm">Lexical Functions</A>: 
String Length and Size</H3>
<PRE>LocalStringLength(), LocalStringSize()</PRE>
<P>
<A NAME="Localization_c.htm_IX_Strings:size">
 </A>
There are two routines which determine how long a string is. <CODE>
LocalStringLength()</CODE>
<A NAME="Localization_c.htm_IX_LocalStringLength()">
 </A>
 returns the number of characters making up the string, not including the null terminator, if any.<CODE>
 LocalStringSize()</CODE>
<A NAME="Localization_c.htm_IX_LocalStringSize()">
 </A>
 returns the number of bytes in a string, again not counting any null terminators. Normally these two values will be the same, but any applications which want to support double byte character support will need separate functions to handle those characters that take more than one byte to represent.</P>
<HR>
<A NAME="Localization_d.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Localization</A>: 5.3 <A HREF="#Localization_a.htm">Lexical Functions</A>: 
Casing</H3>
<PRE><A NAME="Localization_d.htm_IX_LocalUpcaseChar()"> </A>LocalUpcaseChar(), <A NAME="IX_LocalDowncaseChar()"> </A>LocalDowncaseChar(), <A NAME="IX_LocalUpcaseString()"> </A>LocalUpcaseString(), <A NAME="IX_LocalDowncaseString()"> </A>LocalDowncaseString()</PRE>
<P>
<A NAME="Localization_d.htm_IX_Strings:case">
 </A>
These functions take a character or string and, if possible, transform it to upper or lower case. They work only on alphabetic characters; other characters will be returned unchanged. These functions can deal with all languages, understanding &quot;È&quot; is the upper case for &quot;è&quot;. If you're used to using ASCII, you might be tempted to write your own version of these casing functions by doing arithmetic operations with the lexical or ASCII values of characters, but chances are these will not work with other character sets and should be avoided.
<IMG SRC="Localization_d_casingSidebar.gif">

</P>
<HR>
<A NAME="Localization_e.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Localization</A>: 5.4 <A HREF="#Localization_a.htm">Lexical Functions</A>: 
Character Categories</H3>
<PRE><A NAME="Localization_e.htm_IX_LocalIsUpper()"> </A>isupper(), LocalIsUpper(), <A NAME="IX_LocalIsLower()"> </A>islower(), LocalIsLower(), isalpha(), <A NAME="IX_LocalIsAlpha()"> </A>LocalIsAlpha(), <A NAME="IX_LocalIsPunctuation()"> </A>ispunct(), LocalIsPunctuation(), isspace(), <A NAME="IX_LocalIsSpace()"> </A>LocalIsSpace(), isprint(), <A NAME="IX_LocalIsPrintable()"> </A>LocalIsPrintable(), 
iscntrl(), <A NAME="Localization_e.htm_IX_LocalIsControl()"> </A>LocalIsControl(), isdigit(), <A NAME="IX_LocalIsDigit()"> </A>LocalIsDigit(), isxdigit(), <A NAME="IX_LocalIsHexDigit()"> </A>LocalIsHexDigit(), <A NAME="IX_LocalIsGraphic()"> </A>isgraph(), LocalIsGraphic(), 
isalnum(), <A NAME="Localization_e.htm_IX_LocalIsAlphaNumeric()"> </A>LocalIsAlphaNumeric(), <A NAME="IX_LocalIsSymbol()"> </A>LocalIsSymbol()</PRE>
<P>
GEOS assembly provides some commonly used character predicates. C users use the standard C functions <CODE>
isupper()</CODE>
, <CODE>
islower()</CODE>
, etc. to access these predicates. Passed a character, each of these functions tells whether that character falls into a certain category. <CODE>
LocalIsUpper()</CODE>
 returns <EM>
true</EM>
 if the character is an uppercase alphabetic character; <CODE>
LocalIsLower()</CODE>
 returns <EM>
true</EM>
 if the character is lower case. <CODE>
LocalIsAlpha()</CODE>
 approves any alphabetic character. <CODE>
LocalIsPunctuation()</CODE>
 checks for punctuation marks. <CODE>
LocalIsSpace()</CODE>
 looks for white space (including spaces, tabs, and carriage returns), and <CODE>
LocalIsSymbol()</CODE>
 catches just about everything else. <CODE>
LocalIsControl()</CODE>
 detects control characters (e.g. Control-A). <CODE>
LocalIsDigit()</CODE>
 returns <EM>
true</EM>
 for decimal digits. <CODE>
LocalIsHexDigit()</CODE>
 approves hexadecimal digits (including the characters a-f, A-F). <CODE>
LocalIsAlphaNumeric()</CODE>
 detects alphabetic characters and decimal digits. <CODE>
LocalIsPrintable()</CODE>
 returns true when passed a character which takes up a space when printed, corresponding to the standard C function <CODE>
isprint()</CODE>
. <CODE>
LocalIsGraphic()</CODE>
 checks for displayable characters, in the manner of the standard C function <CODE>
isgraphic()</CODE>
.</P>
<HR>
<A NAME="Localization_f.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Localization</A>: 5.5 <A HREF="#Localization_a.htm">Lexical Functions</A>: 
Lexical Values</H3>
<PRE>LocalLexicalValue(), LocalLexicalValueNoCase()</PRE>
<P>
<A NAME="Localization_f.htm_IX_Strings:comparing">
 </A>
If for some reason you want to get the lexical value of a character, these functions will return it. <A NAME="Localization_f.htm_IX_LocalLexicalValue()">
 </A>
<CODE>
LocalLexicalValue()</CODE>
, passed a character, returns its lexical value. <A NAME="Localization_f.htm_IX_LocalLexicalValueNoCase()">
 </A>
<CODE>
LocalLexicalValueNoCase()</CODE>
 does the same thing but ignores case. If the lexical value for one character is lower than another, that character comes first alphabetically. For instance, &quot;a&quot; would have a lower lexical value than &quot;z.&quot; This ordering will be valid in any language using the same character set. </P>
<HR>
<A NAME="Localization_10.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Localization</A>: 5.6 <A HREF="#Localization_a.htm">Lexical Functions</A>: 
DOS Text &amp; Code Pages</H3>
<PRE>LocalDosToGeos(), LocalGeosToDos(), LocalDosToGeosChar(), LocalGeosToDosChar(), LocalCmpStringsDosToGeos(), LocalIsDosChar(), LocalCodePageToGeos(), LocalGeosToCodePage(), LocalCodePageToGeosChar(), LocalGeosToCodePageChar(), LocalGetCodePage(), LocalIsCodePageSupported()</PRE>
<P>
<A NAME="Localization_10.htm_IX_ASCII text">
 </A>
<A NAME="Localization_10.htm_IX_Strings:code pages">
 </A>
There are several functions which work with DOS-format text, converting it to and from GEOS format. Normally, converting DOS text files to GeoWrite documents is handled by Import/Export routines; for those occasions where your code needs to convert DOS text to GEOS format or vice versa, however, these functions should be sufficient. They are localized because DOS has its own version of localization which it implements as &quot;code pages.&quot; Each code page is a table of characters. Countries or regions with unusual characters have different code pages. If you haven't worked with code pages up to this point, you probably won't have to start now but can just rely on GEOS to use the native code page correctly. If your geode is going to allow computers from one country to communicate with those of another, you might need to use specialized functions.</P>
<P>
Assuming you want to use the code page native to the user's machine, you can use <A NAME="Localization_10.htm_IX_LocalDosToGeos()">
 </A>
<CODE>
LocalDosToGeos()</CODE>
 and <A NAME="Localization_10.htm_IX_LocalGeosToDos()">
 </A>
<CODE>
LocalGeosToDos()</CODE>
 to convert strings from one text format to the other. <A NAME="Localization_10.htm_IX_LocalDosToGeosChar()">
 </A>
<CODE>
LocalDosToGeosChar()</CODE>
 and <CODE>
LocalGeosToDosChar()</CODE>
<A NAME="Localization_10.htm_IX_LocalGeosToDosChar()">
 </A>
 work similarly, converting a single character.</P>
<P>
 <CODE>
LocalCmpStringsDosToGeos()</CODE>
<A NAME="Localization_10.htm_IX_LocalCmpStringsDosToGeos()">
 </A>
 takes two strings, converts one or both of them to GEOS format, then compares them, returning the same values as the regular string comparing functions. Pass a <CODE>
LocalCmpStringsDosToGeosFlags</CODE>
<A NAME="Localization_10.htm_IX_LocalCmpStringsDosToGeosFlags">
 </A>
 to specify which strings to convert before comparing.</P>
<P>
Each of these functions also takes a character as an argument. When a character in one format has no corresponding character in the format it's being converted to, the character argument will be substituted. At the same time a flag will be set to let your geode know that there were some characters that couldn't be converted nicely. <A NAME="Localization_10.htm_IX_LocalIsDosChar()">
 </A>
<CODE>
LocalIsDosChar()</CODE>
 checks a GEOS character to see if it maps into a DOS character. The <A NAME="Localization_10.htm_IX_MIN_MAP_CHAR">
 </A>
MIN_MAP_CHAR constant is the smallest value which may need to be mapped. If a character's value is below this constant, then it will be the same under any code page.</P>
<P>
If your geode is interested in which code page it's using, the <CODE>
LocalGetCodePage()</CODE>
<A NAME="Localization_10.htm_IX_LocalGetCodePage()">
 </A>
 instruction will tell you what the default code page is. If you want to use a code page other than the native one, the <CODE>
LocalCodePageToGeos()</CODE>
<A NAME="Localization_10.htm_IX_LocalCodePageToGeos()">
 </A>
, <A NAME="Localization_10.htm_IX_LocalGeosToCodePage()">
 </A>
<CODE>
LocalGeosToCodePage()</CODE>
, <CODE>
LocalCodePageToGeosChar()</CODE>
<A NAME="Localization_10.htm_IX_LocalCodePageToGeosChar()">
 </A>
, and <A NAME="Localization_10.htm_IX_LocalGeosToCodePageChar()">
 </A>
<CODE>
LocalGeosToCodePageChar()</CODE>
 behave as their default code page equivalents, except that each takes a code page as an argument to be used in conversion. A number of support code page values are enumerated in the <A NAME="Localization_10.htm_IX_DosCodePage">
 </A>
<CODE>
DosCodePage</CODE>
 type. To find out whether the user's environment supports a specific code page, call <CODE>
LocalIsCodePageSupported()</CODE>
<A NAME="Localization_10.htm_IX_LocalIsCodePageSupported()">
 </A>
.</P>
<P>
&nbsp;</P>
<HR>
This document is a single-page version of a <A HREF="index.htm">a multi-page document</A>, suitable for easy printing.
</BODY>
</HTML>
