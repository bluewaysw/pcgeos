<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD>
<!-- This page was automatically generated from a bunch of smaller pages. -->
<META NAME="copyright" CONTENT="Copyright GEOWORKS">
<LINK REL="STYLESHEET" HREF="../../docHelpers/style.css">
<LINK REV="MADE" HREF="mailto:doc-feedback@geoworks.com">
<TITLE>GEOS Programming</TITLE>
</HEAD>
<BODY BGCOLOR="#ffffdf">
This document is a single-page version of a <A HREF="index.htm">a multi-page document</A>, suitable for easy printing.
<A NAME="index.htm"></A>



<H1 CLASS="chapterTitle">

<A NAME="index.htm_97933">
 </A>
GEOS Programming

</H1>
<P FIXME_Bodyvi>
<A NAME="index.htm_41590">
 </A>
Because GEOS implements its own messaging and object system, standard C programming must be supplemented with GEOS-specific programming. This chapter describes the syntax and commands available to GEOS programmers in the Goc preprocessor.</P>
<P>

</P>
<P CLASS="sectionlinks">
<STRONG>
&nbsp;&nbsp;<A HREF="#GOCLanguage_1.htm">1 Basic Data Types and Structures</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#GOCLanguage_2.htm">1.1 Records and Enumerated Types</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#GOCLanguage_3.htm">1.2 Handles and Pointers</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#GOCLanguage_4.htm">1.3 Fixed Point Structures</A><BR>
&nbsp;&nbsp;<A HREF="#GOCLanguage_5.htm">2 Goc and C</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#GOCLanguage_6.htm">2.1 Goc File Types</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#GOCLanguage_7.htm">2.2 Conditional Code in Goc</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#GOCLanguage_8.htm">2.3 Macros in Goc</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#GOCLanguage_9.htm">2.4 Using Routine Pointers in Goc</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#GOCLanguage_a.htm">2.5 Esoteric Source-Code Management</A><BR>
&nbsp;&nbsp;<A HREF="#GOCLanguage_b.htm">3 The GEOS Object System</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#GOCLanguage_c.htm">3.1 GEOS Terminology</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#GOCLanguage_d.htm">3.2 Object Structures</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#GOCLanguage_e.htm">3.3 The GEOS Message System</A><BR>
&nbsp;&nbsp;<A HREF="#GOCLanguage_f.htm">4 Using Classes and Objects</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#GOCLanguage_10.htm">4.1 Defining a New Class or Subclass</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#GOCLanguage_11.htm">4.2 Non-relocatable Data</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#GOCLanguage_12.htm">4.3 Defining Methods</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#GOCLanguage_13.htm">4.4 Declaring Objects</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#GOCLanguage_14.htm">4.5 Sending Messages</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#GOCLanguage_15.htm">4.6 Managing Objects</A><BR>
</STRONG>
</P> <!-- end of sectionlinks blob -->

<HR>
<A NAME="GOCLanguage_1.htm"></A>


<H2 CLASS="sectionTitle">
<A HREF="#index.htm">GEOS Programming</A>: 1 
<A NAME="GOCLanguage_1.htm_64924">
 </A>
Basic Data Types and Structures</H2>
<P>
In addition to the standard data types available in C, the Goc preprocessor handles several other types specific to GEOS. These are all defined in the file <STRONG CLASS="fileName">
geos.h</STRONG>
. Some of these types, shown below, were carried over from the world of assembly language.
<IMG SRC="GOCLanguage_1_simpleTypes.gif">

</P>
<P>
<A NAME="GOCLanguage_1.htm_IX_Boolean">
 </A>
The Boolean type behaves as most Boolean types--any nonzero value represents a <CODE>
true</CODE>
 state, and zero represents the <CODE>
false</CODE>
 state. Throughout the documentation, <CODE>
true</CODE>
 and <CODE>
false</CODE>
 are taken to be these meanings. Note that the constants TRUE<A NAME="GOCLanguage_1.htm_IX_TRUE">
 </A>
 and FALSE<A NAME="GOCLanguage_1.htm_IX_FALSE">
 </A>
 are defined and may be used as return values from your functions and methods. Do not compare Boolean variables, however, against these constants. A Boolean may be <CODE>
true</CODE>
 without actually equaling the TRUE value.</P>
<P CLASS="subsectionLink">
<A HREF="#GOCLanguage_2.htm">Records and Enumerated Types</A></P>
<P CLASS="subsectionLink">
<A HREF="#GOCLanguage_3.htm">Handles and Pointers</A></P>
<P CLASS="subsectionLink">
<A HREF="#GOCLanguage_4.htm">Fixed Point Structures</A></P>
<HR>
<A NAME="GOCLanguage_2.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">GEOS Programming</A>: 1.1 <A HREF="#GOCLanguage_1.htm">Basic Data Types and Structures</A>: 
Records and Enumerated Types</H3>
<P>
GEOS<A NAME="GOCLanguage_2.htm_IX_Enumerated types">
 </A>
<A NAME="GOCLanguage_2.htm_IX_Flag records">
 </A>
 objects and routines make extensive use of flag records and enumerated types. A flag record is a byte, word, or dword in which each bit represents the state (on or off) of a particular attribute or function. An enumerated type is a byte or word in which each enumeration has a unique constant value. </P>
<P>
<A NAME="GOCLanguage_2.htm_IX_|">
 </A>
To define a flag record, you should use one of these types and then define the flags to be bits within the record. To set flags, OR them (bitwise OR) with the record; to clear them, AND their bitwise inverses (bitwise AND) with the record. Creating and working with flag records is shown in <A HREF="#GOCLanguage_2.htm_74482"> Flag Records and ByteEnums</A>
.</P>
<P>
There are two basic enumerated types: The standard enumerated type supported by your C compiler uses word-sized values. GEOS also allows byte-sized enumerated types with the<CODE>
 ByteEnum</CODE>
 type. Use of this type is shown in <A HREF="#GOCLanguage_2.htm_74482"> Flag Records and ByteEnums</A>
.
<IMG SRC="GOCLanguage_2_flagTypes.gif">

</P>
<P CLASS="figTitle">
Code Display 5-1 <A NAME="GOCLanguage_2.htm_74482">
 </A>
Flag Records and ByteEnums</P>
<PRE>/* Define flag records to be the optimized length for the number of flags. For
 * example, the sample type MyFlag has six flags and therefore should be a byte. 
 * Flag values should be constants equivalent to having a single bit set in the
 * flag record. */</PRE>
<PRE>typedef ByteFlags MyFlag;
#define MF_FIRST_FLAG			0x01
#define MF_SECOND_FLAG			0x02
#define MF_THIRD_FLAG			0x04
#define MF_FOURTH_FLAG			0x08
#define MF_FIFTH_FLAG			0x10
#define MF_SIXTH_FLAG			0x20</PRE>
<PRE>/* In a section of code, to set a flag, bitwise OR it with the record. To clear the
 * flag, bitwise AND its inverse with the record. You can set any number of flags
 * at a time as shown in the following examples. */</PRE>
<PRE>    ...
    MyFlag		myFlagsRecord;		/* Set up a variable of the flag record type */</PRE>
<PRE>	/* Set the second and fourth flag. */
    myFlagsRecord = MF_SECOND_FLAG | MF_FOURTH_FLAG;</PRE>
<PRE>	/* Set the first flag and then clear the fifth and sixth flags. */
    myFlagsRecord = (myFlagsRecord | MF_FIRST_FLAG) &amp; ~(MF_FIFTH_FLAG |
						    MF_SIXTH_FLAG);</PRE>
<PRE>/* The ByteEnum type can be used instead of the standard enumerated type, which
 * is implemented by most compilers as a word type. To define a ByteEnum, define
 * the type and then a unique constant value for each enumeration as in the
 * following example. */</PRE>
<PRE>typedef ByteEnum USCity;
#define USC_HARTFORD			0x00
#define USC_CHARLOTTE			0x01
#define USC_WICHITA			0x02
#define USC_PIERRE			0x03
#define USC_ORLANDO			0x04</PRE>
<HR>
<A NAME="GOCLanguage_3.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">GEOS Programming</A>: 1.2 <A HREF="#GOCLanguage_1.htm">Basic Data Types and Structures</A>: 
Handles and Pointers</H3>
<P>
Handles and pointers are present everywhere in GEOS--they are the essential elements that make dynamic linking and efficient memory management possible.</P>
<P>
GEOS<A NAME="GOCLanguage_3.htm_IX_Pointers">
 </A>
 pointers are all far pointers; that is, they are 32-bit addresses that reference specific locations in memory. They are normal C pointers and can be used as such. Two other pointer types are also used by GEOS: Object pointers (optrs) and segment pointers. Object pointers are described below; segment pointers are 16-bit addresses described in <A HREF="../../Memory/Heap/combo.htm">the Memory Management chapter</A>.</P>
<H4 CLASS="HeadingC">
Handles</H4>
<P>
<A NAME="GOCLanguage_3.htm_IX_Handles">
 </A>
Handles are 16-bit, unsigned values used for several purposes. They provide abstraction when the exact address of a data structure or other item is not known or is an inconsistent state. The kernel maintains a handle table to keep track of many of the handles in the system. Each entry in the handle table is 16 bytes that contains information about the item referenced by the handle; these 16 bytes are opaque to applications and libraries and can not be accessed or altered except by the kernel. Other handle types are managed in other tables by the kernel.</P>
<P>
Handles are used for the following primary purposes. For a full description of how handles are used, see <A HREF="../../Memory/Handles/combo.htm">the Handles chapter</A>.
<IMG SRC="GOCLanguage_3_handleTypes.gif">

</P>
<UL>
<LI>
Memory reference<BR>
<A NAME="GOCLanguage_3.htm_IX_Memory:handles">
 </A>
Entries for memory handles contain pointers to memory blocks; when the blocks move, the pointers are updated. However, the handle's integrity is preserved, and applications keep track of just the handle value.</LI>
<LI>
Virtual Memory reference<BR>
<A NAME="GOCLanguage_3.htm_IX_Virtual memory:handles">
 </A>
Entries for VM handles indirectly reference VM blocks similar to the way memory handles reference blocks of memory. VM handles may be used whether the VM block is resident in memory or not.</LI>
<LI>
File and disk reference<BR>
<A NAME="GOCLanguage_3.htm_IX_Disks:handles">
 </A>
<A NAME="GOCLanguage_3.htm_IX_Files:handles">
 </A>
Entries for file and disk handles contain information about the location and status of the referenced file/disk. They provide indirect access to files and disks in a manner similar to memory handles.</LI>
<LI>
Data structure implementation<BR>
<A NAME="GOCLanguage_3.htm_IX_GStates:handles">
 </A>
<A NAME="GOCLanguage_3.htm_IX_Windows:handles">
 </A>
<A NAME="GOCLanguage_3.htm_IX_Threads:handles">
 </A>
<A NAME="GOCLanguage_3.htm_IX_Queues, event:handles">
 </A>
<A NAME="GOCLanguage_3.htm_IX_Threads:lock handles">
 </A>
<A NAME="GOCLanguage_3.htm_IX_Messages:handles">
 </A>
<A NAME="GOCLanguage_3.htm_IX_Semaphores:handles">
 </A>
<A NAME="GOCLanguage_3.htm_IX_Geodes:handles">
 </A>
<A NAME="GOCLanguage_3.htm_IX_Timers:handles">
 </A>
Certain frequently-used system data structures require a storage format that provides for quick and convenient access at all times. These data structures (for example, threads, event queues, messages, timers, and semaphores) are stored in Handle Table entries.</LI>
<LI>
Optimization<BR>
The kernel will, if space permits, sometimes use Handle Table entries for optimized temporary storage. (For example, when passing parameters on the stack with messages, the kernel will occasionally use handles for storing the parameters.)</LI>
</UL>
<P>
<A NAME="GOCLanguage_3.htm_IX_NullHandle">
 </A>
<A NAME="GOCLanguage_3.htm_IX_NULL">
 </A>
The <CODE>
NullHandle</CODE>
 value (zero) is used to indicate a null handle.</P>
<P>
There are over a dozen different types of handles that can be used by any sort of geode. These are listed in <A HREF="../../Programming/GOCLanguage/GOCLanguage_3.htm">the GEOS Programming chapter</A>. All are 16-bit unsigned integers.</P>

<H4 CLASS="HeadingC">
Chunk Handles and Object Pointers</H4>
<P>
<A NAME="GOCLanguage_3.htm_IX_optr">
 </A>
<A NAME="GOCLanguage_3.htm_IX_Chunk handles">
 </A>
<A NAME="GOCLanguage_3.htm_IX_ChunkHandle">
 </A>
Objects and small data structures are stored in small memory pieces called chunks. Chunks are stored in memory blocks known as local memory heaps, and each local memory heap can contain several chunks. Each chunk is referenced by a combination of two handles: The MemHandle handle locates the local memory heap, and the ChunkHandle locates the chunk within the block.  A null chunk handle value is specified by <CODE>
NullChunk</CODE>
.</P>
<P>
Objects are referenced in the same way as chunks, but the handle and chunk handle are combined into a single structure called an Object Pointer, or optr. Each optr uniquely identifies a particular object in the system. Note that optrs are often used to reference non-object chunks and data structures. A null value is specified by <CODE>
NullOptr</CODE>
.</P>
<P>
GEOS provides several macros, all defined in <STRONG CLASS="fileName">
geos.h</STRONG>
, for creating and parsing optrs.</P>
<UL>
<LI>
<CODE>
ConstructOptr()<BR>
</CODE>
<A NAME="GOCLanguage_3.htm_IX_ConstructOptr() macro">
 </A>
This macro constructs an optr from a MemHandle and a ChunkHandle.</LI>
<LI>
<CODE>
OptrToHandle()<BR>
</CODE>
<A NAME="GOCLanguage_3.htm_IX_OptrToHandle() macro">
 </A>
This macro extracts the MemHandle portion of the given optr.</LI>
<LI>
<CODE>
OptrToChunk()<BR>
</CODE>
<A NAME="GOCLanguage_3.htm_IX_OptrToChunk() macro">
 </A>
This macro extracts the chunk handle portion of a given optr.</LI>
</UL>


<H4 CLASS="HeadingC">
Pointers</H4>
<P>
Pointers can be used normally as in C. All Goc-generated pointers are far pointers; that is, they are 32-bits long, composed of a 16-bit segment and a 16-bit offset.</P>
<P>
GEOS provides macros for extracting the segment and handle portions of pointers.</P>
<UL>
<LI>
<CODE>
PtrToSegment()<BR>
</CODE>
<A NAME="GOCLanguage_3.htm_IX_PtrToSegment()">
 </A>
This macro returns the segment portion of the given pointer (returned as type &quot;word&quot;).</LI>
<LI>
<CODE>
PtrToOffset()<BR>
</CODE>
<A NAME="GOCLanguage_3.htm_IX_PtrToOffset()">
 </A>
This macro returns the offset portion of the given pointer (returned as type &quot;word&quot;).</LI>
</UL>
<P>
GEOS automatically loads code resources when needed. However, when you call routines through pointers, you must take special measures to see to it that the routine is properly loaded into memory. This is discussed below in <A HREF="#GOCLanguage_9.htm_67927"> Using Routine Pointers in Goc</A>
.</P>

<HR>
<A NAME="GOCLanguage_4.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">GEOS Programming</A>: 1.3 <A HREF="#GOCLanguage_1.htm">Basic Data Types and Structures</A>: 
Fixed Point Structures</H3>
<P>
When you want to represent non-integral numbers (i.e., real numbers), you can use either the standard C floating-point format or the following special structures of GEOS for fixed point math. Note that fixed-point calculations are faster than the corresponding floating-point math, so if you want to optimize your code, you should use the GEOS fixed-point structures with the GEOS math routines.</P>
<P CLASS="figTitle">
Code Display 5-2 GEOS Data Structures</P>
<PRE><A NAME="GOCLanguage_4.htm_IX_Fixed point numbers"> </A>/* Fixed-Point Structures
 *    The following structures are used to represent fixed-point numbers:
 *    numbers with a fractional portion and an integral portion. Notice that
 *    there are several formats of fixed-point numbers; each uses a different
 *    number of bits for the parts of the number. Choose whichever is most
 *    appropriate (for optimization). */</PRE>
<PRE><A NAME="GOCLanguage_4.htm_IX_BBFixed"> </A>	/* BBFixed
	 * One byte integer, one byte fraction */
typedef struct {
    byte		BBF_frac;		/* fractional portion */
    byte		BBF_int;		/* integral portion */
} BBFixed;</PRE>
<PRE>	/* BBFixedAsWord
	 * Sometimes it is convenient to refer to a BBFixed value as type word.
	 * The BBFixedAsWord type is used for this purpose. */
<A NAME="GOCLanguage_4.htm_IX_BBFixedAsWord"> </A>typedef word		BBFixedAsWord;</PRE>
<PRE>	/* WBFixed
	 * One word integer, one byte fraction */
<A NAME="GOCLanguage_4.htm_IX_WBFixed"> </A>typedef struct {
    byte		WBF_frac;		/* fractional portion */
    word		WBF_int;		/* integral portion */
} WBFixed;</PRE>
<PRE>	/* WWFixed
	 * One word integer, one word fraction */
<A NAME="GOCLanguage_4.htm_IX_WWFixed"> </A>typedef struct {
    word		WWF_frac;		/* fractional portion */
    word		WWF_int;		/* integral portion */
} WWFixed;</PRE>
<PRE>	/* WWFixedAsDWord
	 * Sometimes it is convenient to refer to a WWFixed value as type dword.
	 * The WWFixedAsDWord type is used for this purpose. */
<A NAME="GOCLanguage_4.htm_IX_WWFixedAsDWord"> </A>typedef dword		WWFixedAsDWord;</PRE>
<PRE>	/* DWFixed
	 * two words (one dword) integer, one word fraction */
typedef struct {
    word		DWF_frac;		/* fractional portion */
    sdword		DWF_int;		/* integral portion */
<A NAME="GOCLanguage_4.htm_IX_DWFixed"> </A>} DWFixed;</PRE>
<PRE>/* Three-byte structure
 * The WordAndAHalf structure is used when you need a 24-bit value and you want to
 * optimize and avoid using a 32-bit value. */</PRE>
<PRE>typedef struct {
    word		WAAH_low;		/* the low 16 bits */
    byte		WAAH_high;		/* the high 8 bits */
} WordAndAHalf;</PRE>
<P>
<A NAME="GOCLanguage_4.htm_IX_WWFixed">
 </A>
Three special macros are also available to work with the <CODE>
WWFixed</CODE>
 type. These are listed below:</P>
<UL>
<LI>
<CODE>
MakeWWFixed<BR>
</CODE>
<A NAME="GOCLanguage_4.htm_IX_MakeWWFixed() macro">
 </A>
This macro creates a <CODE>
WWFixed</CODE>
 structure from a given floating-point number or dword number.</LI>
<LI>
<CODE>
WWFixedToFrac<BR>
</CODE>
<A NAME="GOCLanguage_4.htm_IX_WWFixedToFrac() macro">
 </A>
This macro produces the fractional portion of a <CODE>
WWFixed</CODE>
 structure.</LI>
<LI>
<CODE>
WWFixedToInt<BR>
</CODE>
<A NAME="GOCLanguage_4.htm_IX_WWFixedToInt() macro">
 </A>
This macro produces the integral portion of a <CODE>
WWFixed</CODE>
 structure.</LI>
</UL>
<P>
Two other macros are provided for use with <CODE>
WWFixedAsDword</CODE>
 structures:</P>
<UL>
<LI>
<CODE>
IntegerOf()<BR>
</CODE>
This macro returns the integral portion of a <CODE>
WWFixedAsDword</CODE>
 structure.</LI>
<LI>
<CODE>
FractionOf()<BR>
</CODE>
This macro returns the fractional portion of a <CODE>
WWFixedAsDword</CODE>
 structure.</LI>
</UL>
<HR>
<A NAME="GOCLanguage_5.htm"></A>


<H2 CLASS="sectionTitle">
<A HREF="#index.htm">GEOS Programming</A>: 2 
Goc and C</H2>
<P>
<A NAME="GOCLanguage_5.htm_IX_Goc:syntax">
 </A>
Goc is a superset of the standard C programming language. Goc actually acts as a sort of preprocessor before the code is run through a standard C compiler. There are several differences you must be aware of, though. These differences are covered in the following sections as well as throughout the documentation.</P>
<P CLASS="subsectionLink">
<A HREF="#GOCLanguage_6.htm">Goc File Types</A></P>
<P CLASS="subsectionLink">
<A HREF="#GOCLanguage_7.htm">Conditional Code in Goc</A></P>
<P CLASS="subsectionLink">
<A HREF="#GOCLanguage_8.htm">Macros in Goc</A></P>
<P CLASS="subsectionLink">
<A HREF="#GOCLanguage_9.htm">Using Routine Pointers in Goc</A></P>
<P CLASS="subsectionLink">
<A HREF="#GOCLanguage_a.htm">Esoteric Source-Code Management</A></P>
<HR>
<A NAME="GOCLanguage_6.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">GEOS Programming</A>: 2.1 <A HREF="#GOCLanguage_5.htm">Goc and C</A>: 
Goc File Types</H3>
<PRE>@include, @optimize</PRE>
<P>
When programming in Goc, you will use several different types of code files. Files ending in <STRONG CLASS="fileName">
.goh</STRONG>
 are the Goc equivalent of C <STRONG CLASS="fileName">
.h</STRONG>
 files--they contain routine headers, constants, and other included data and structures necessary for the program. Files ending in <STRONG CLASS="fileName">
.goc</STRONG>
 are the Goc equivalent of C <STRONG CLASS="fileName">
.c</STRONG>
 files--they contain code and data for the program. You should keep any Goc-specific code or header information strictly in the Goc files, and standard C code should be kept in C files. C code can also be put in <STRONG CLASS="fileName">
.goc</STRONG>
 and <STRONG CLASS="fileName">
.goh</STRONG>
 files, but for consistency, you should try to keep it separate.</P>
<P>
Not all of your program's header files need be <STRONG CLASS="fileName">
.goh</STRONG>
 files--if the header file contains only C constructions (structures, routine definitions, and so on), then you may leave it as a standard C <STRONG CLASS="fileName">
.h</STRONG>
 file, included by means of the #include directive.</P>
<P>
The rule of thumb is that if a header file contains any Goc code or includes a <STRONG CLASS="fileName">
.goh</STRONG>
 file, then it must be a <STRONG CLASS="fileName">
.goh</STRONG>
 file. Note also that <STRONG CLASS="fileName">
.goh</STRONG>
 files are allowed to contain simple standard C code; if you are not sure, then, you can make all your header files <STRONG CLASS="fileName">
.goh</STRONG>
.</P>
<P>
Standard C programs use the <CODE>
#include</CODE>
 directive to include header (<STRONG CLASS="fileName">
.h</STRONG>
) files. When using Goc, you can use this directive in standard <STRONG CLASS="fileName">
.c</STRONG>
 and <STRONG CLASS="fileName">
.h</STRONG>
 files; when including <STRONG CLASS="fileName">
.goh</STRONG>
 files in <STRONG CLASS="fileName">
.goc</STRONG>
 files, though, you have to use the <CODE>
@include</CODE>
 directive, which is Goc-specific. It has the same syntax as <CODE>
#include</CODE>
.</P>
<P>
<A NAME="GOCLanguage_6.htm_IX_@include[;include]">
 </A>
An example of using <CODE>
@include</CODE>
 comes from the Hello World application, which includes the <STRONG CLASS="fileName">
stdapp.goh</STRONG>
 file. (All GEOS applications will need to include this file to compile properly; it must be <CODE>
@include</CODE>
d before any standard C headers are <CODE>
#include</CODE>
d.) The line from Hello World is</P>
<PRE>@include &lt;stdapp.goh&gt;</PRE>
<P>
The syntax of this directive, as stated above, is the same as for the C directive <CODE>
#include</CODE>
. One exception is that the <CODE>
@include</CODE>
 directive will include a file just once, even if it is included by an included file--there is no need to conditionally include a file (checking first to make sure it hasn't already been included).</P>
<P>
If you will be including a Goc file in many different applications, or if it is very long and elaborate, it is a good idea to put the keyword <CODE>
@optimize</CODE>
 at the top of the file. This instructs the Goc preprocessor to generate a special stripped-down version of the file with a <CODE>
.poh</CODE>
 suffix. The compiler will then automatically keep the <CODE>
.poh</CODE>
 file up to date, and use it in compilations instead of the <CODE>
.goh</CODE>
 file. The <CODE>
.poh</CODE>
 file contains all the data of the <CODE>
.goh</CODE>
 file, but is somewhat faster to compile into an application; thus, by using the <CODE>
@optimize</CODE>
 keyword, you incur a longer compilation whenever you make a change to the <CODE>
.goh</CODE>
 file, but a shorter compilation time when the <CODE>
.goh</CODE>
 file is unchanged since the last compilation. You may choose to leave the <CODE>
@optimize</CODE>
 directive out while the header is being developed, then put it in when the header is fairly stable.</P>
<HR>
<A NAME="GOCLanguage_7.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">GEOS Programming</A>: 2.2 <A HREF="#GOCLanguage_5.htm">Goc and C</A>: 
<A NAME="GOCLanguage_7.htm_IX_code:conditional">
 </A>
Conditional Code in Goc</H3>
<PRE>@if, @ifdef, @ifndef, @endif</PRE>
<P>
<A NAME="GOCLanguage_7.htm_IX_@endif[;endif]">
 </A>
<A NAME="GOCLanguage_7.htm_IX_@ifndef[;ifndef]">
 </A>
<A NAME="GOCLanguage_7.htm_IX_@ifdef[;ifdef]">
 </A>
<A NAME="GOCLanguage_7.htm_IX_@if[;if]">
 </A>
Many C programs use the directives <CODE>
#if</CODE>
, <CODE>
#ifdef</CODE>
, <CODE>
#ifndef</CODE>
, and <CODE>
#endif</CODE>
 to define conditional code--code that should be compiled into the program only if certain conditions are met. When working with standard C code in your GEOS applications, you should still use these directives; when working with Goc code, however (in <STRONG CLASS="fileName">
.goh</STRONG>
 and <STRONG CLASS="fileName">
.goc</STRONG>
 files), you should use the Goc directives <CODE>
@if</CODE>
, <CODE>
@ifdef</CODE>
, <CODE>
@ifndef</CODE>
, and <CODE>
@endif</CODE>
.</P>
<P>
Goc conditionals are more limited than C conditionals. Conditional expressions may be based on numbers, names of macros, and the Boolean operators OR (<CODE>
||</CODE>
) and AND (<CODE>
&amp;&amp;</CODE>
). Some examples of Goc conditional expressions are shown below:</P>
<PRE>@ifdef (MyMacro)
	/* code compiled if MyMacro is defined */
@endif</PRE>
<PRE>@if 0
	/* code that will not be compiled at all */
@endif</PRE>
<PRE>@if defined(MyMacro) || MY_CONSTANT
	/* code compiled if either MyMacro is
	 * defined or MY_CONSTANT is not zero */
@endif</PRE>
<PRE>@ifndef 0
	/* code always compiled */
@endif</PRE>
<HR>
<A NAME="GOCLanguage_8.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">GEOS Programming</A>: 2.3 <A HREF="#GOCLanguage_5.htm">Goc and C</A>: 
<A NAME="GOCLanguage_8.htm_IX_macros">
 </A>
Macros in Goc</H3>
<PRE>@define</PRE>
<P>
The C programming language allows definition and use of macros, and most programmers use macros extensively. You can use the <CODE>
#define</CODE>
 directive in standard C code in your GEOS programs to define macros that use only standard C code.</P>
<P>
Similarly, you can use the <CODE>
@define</CODE>
 Goc directive to create macros in Goc. (Macros must be defined with <CODE>
@define</CODE>
; otherwise, the Goc processor will skip the <CODE>
#define</CODE>
 directive and process the macro as if it were standard code to be processed normally.)</P>
<P>
<A NAME="GOCLanguage_8.htm_IX_@define[;define]">
 </A>
Macros in Goc have a somewhat different syntax than standard C macros though they are very similar. Some examples of simple Goc macros follow below:</P>
<PRE>@define mlply(val1,val2)					val1 * val2
@define defChunk(a)				@chunk char a[] = &quot;text&quot;</PRE>
<P>
When using Goc macros in your code, you must preface them with the &quot;<CODE>
@</CODE>
&quot; Goc marker, indicating to the processor that it is a macro. If you do not preface the macro with &quot;<CODE>
@</CODE>
&quot;, then Goc will pass over it and will not process it, leaving it up to the C compiler--which will likely give an error. For example, using the second macro defined above (defChunk), you could create a number of chunks easily:</P>
<PRE>@defChunk(firstText)
@defChunk(secondText)
@defChunk(thirdText)</PRE>
<P>
The above would equate to the following:</P>
<PRE>@chunk char[] firstText = &quot;text&quot;;
@chunk char[] secondText = &quot;text&quot;;
@chunk char[] thirdText = &quot;text&quot;;</PRE>
<P>
Using &quot;defChunk&quot; without the &quot;<CODE>
@</CODE>
&quot; marker would most likely result in a compilation error in the C compiler.</P>
<HR>
<A NAME="GOCLanguage_9.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">GEOS Programming</A>: 2.4 <A HREF="#GOCLanguage_5.htm">Goc and C</A>: 
<A NAME="GOCLanguage_9.htm_67927">
 </A>
Using Routine Pointers in Goc</H3>
<PRE>ProcCallFixedOrMovable_cdecl(), ProcCallFixedOrMovable_pascal()</PRE>
<P>
Most GEOS code is kept in movable resources. If you call a routine explicitly from source code the Goc preprocessor generates appropriate directives to see to it that the resource is loaded into memory when it is called. However, if you call a routine with a routine-pointer, GEOS cannot take these precautions. Accordingly, when you are calling a routine with a pointer, you must either see to it that the resource is loaded, or use one of the two <CODE>
ProcCallFixedOrMovable</CODE>
 routines to instruct the kernel to lock the appropriate resource.</P>
<P>
If you know the routine is in a resource which is locked or fixed in memory, you can use the routine pointer exactly the way you would in standard C. This is usually because the calling routine is in the same resource as the routine or routines which may be called. </P>
<P>
<A NAME="GOCLanguage_9.htm_IX_ProcCallFixedOrMovable_cdecl()">
 </A>
<A NAME="GOCLanguage_9.htm_IX_ProcCallFixedOrMovable_pascal()">
 </A>
If you are not sure that the resource is loaded, you should call the routine with either <CODE>
ProcCallFixedOrMovable_cdecl()</CODE>
 or <CODE>
ProcCallFixedOrMovable_pascal()</CODE>
. Each of these routines is passed the following arguments:</P>
<UL>
<LI>
A pointer to the routine to be called</LI>
<LI>
All the arguments passed to the routine, in exactly the order which the routine expects.</LI>
</UL>
<P>
Both routines return whatever the called routine returns.</P>
<P>
If the routine to be called was defined with standard C calling conventions (the default), you should use <CODE>
ProcCallFixedOrMovable_cdecl()</CODE>
. If the routine was declared with the keyword <CODE>
_pascal</CODE>
, it uses Pascal's calling conventions; you must then use the routine <CODE>
ProcCallFixedOrMovable_pascal()</CODE>
. Most kernel and system-library routines are declared with Pascal's calling conventions.</P>
<P CLASS="figTitle">
Code Display 5-3 Using ProcCallFixedOrMovable_cdecl()</P>
<PRE>extern int
SomeRoutineCalledViaAPointer(int anArg, int anotherArg, const char *someText);</PRE>
<PRE>int (*funcPtr) (int, int, const char *);					/* A function pointer */</PRE>
<PRE>funcPtr = SomeRoutineCalledViaAPointer;</PRE>
<PRE>/* We want to do
 *	SomeRoutineCalledViaAPointer(1, 2, &quot;Franklin T. Poomm&quot;);
 * but we want to call it through the pointer, even though it's in another 
 * resource:
 */</PRE>
<PRE>ProcCallFixedOrMovable_cdecl(funcPtr,					/* The pointer to the routine */
				1, 2, &quot;Franklin T. Poomm&quot;);</PRE>
<HR>
<A NAME="GOCLanguage_a.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">GEOS Programming</A>: 2.5 <A HREF="#GOCLanguage_5.htm">Goc and C</A>: 
Esoteric Source-Code Management</H3>
<PRE>@optimize, @protominor</PRE>
<P>
There is a small number of Goc keywords which are used only to ease the burden of maintaining header files which will be used and shared often.</P>
<P>
<A NAME="GOCLanguage_a.htm_IX_@optimize[;optimize]">
 </A>
The <CODE>
@optimize</CODE>
 keyword is used to speed compilation of Goc header files. It may be placed at the top of a <STRONG CLASS="fileName">
.goh</STRONG>
 file. The directive instructs Goc to generate a specially processed <STRONG CLASS="fileName">
.poh</STRONG>
 file which contains all the information of the <STRONG CLASS="fileName">
.goh</STRONG>
 file, but is somewhat faster to compile. This <STRONG CLASS="fileName">
.poh</STRONG>
 file is automatically regenerated if the corresponding <STRONG CLASS="fileName">
.goh</STRONG>
 file has been changed since the last compilation. Its syntax is simple:</P>
<PRE>@optimize</PRE>
<P>
<A NAME="GOCLanguage_a.htm_IX_@protominor[;protominor]">
 </A>
The <CODE>
@protominor</CODE>
 keyword is used so that a single Goc header file may serve multiple versions of a Goc library. When creating a new version of an existing library, use the <CODE>
@protominor</CODE>
 keyword to declare new messages and variable data fields for a class. Suppose your original class declaration looked like so:</P>
<PRE>@class MyClass, SuperClass;
	@message void MSG_M_DO_THIS(void);
	@vardata void TEMP_M_DONE_FLAG;
@endc</PRE>
<P>
Having released this version of your class, you wished to release another version in which this class handled another message. You wanted to specify that this new message would only work with this new version of the library. This would be set up like so:</P>
<PRE>@class MyClass, SuperClass;
	@message void MSG_M_DO_THIS(void);
	@vardata void TEMP_M_DONE_FLAG;

	@protominor MyVersion20
	@message void MSG_M_DO_THAT(void);
@endc</PRE>
<P>
This keyword has the syntax:</P>
<PRE>@protominor &lt;name&gt;</PRE>
<DL>
<DT>
<STRONG>
name</STRONG>
</DT><DD>Name of the minor protocol. This name should correspond to an <CODE>
incminor</CODE>
 entry in the geode's .gp file.</DD>
</DL>
<P>
To do the equivalent version control with routines, use the <CODE>
incminor</CODE>
 .gp file directive.</P>
<HR>
<A NAME="GOCLanguage_b.htm"></A>


<H2 CLASS="sectionTitle">
<A HREF="#index.htm">GEOS Programming</A>: 3 
<A NAME="GOCLanguage_b.htm_27754">
 </A>
The GEOS Object System</H2>
<P>
GEOS<A NAME="GOCLanguage_b.htm_IX_Classes">
 </A>
 is almost entirely object-oriented. Its object system supports true object-oriented principles such as encapsulation, inheritance, and message dispatching through the kernel.</P>
<P>
The following section describes the class and object structures of GEOS, how to declare and define classes and objects, and how the messaging system and the kernel's message dispatcher work.</P>
<P CLASS="subsectionLink">
<A HREF="#GOCLanguage_c.htm">GEOS Terminology</A></P>
<P CLASS="subsectionLink">
<A HREF="#GOCLanguage_d.htm">Object Structures</A></P>
<P CLASS="subsectionLink">
<A HREF="#GOCLanguage_e.htm">The GEOS Message System</A></P>
<HR>
<A NAME="GOCLanguage_c.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">GEOS Programming</A>: 3.1 <A HREF="#GOCLanguage_b.htm">The GEOS Object System</A>: 
GEOS Terminology</H3>
<P>
Though you should be familiar with general object-oriented programming terms, there are quite a few for which the meaning is slightly different in GEOS, and there are others which are entirely new to GEOS. This section is divided into four categories: General Terms, Class Terms, Object Terms, and Messaging Terms.</P>

<H4 CLASS="HeadingC">
General Terms</H4>
<DL>
<DT>
<STRONG>
chunk</STRONG>
</DT><DD>A chunk is a small section of memory located in a Local Memory Heap. Object instance data is stored in a chunk, one chunk per object. Local Memory and chunks are described fully in <A HREF="../../Memory/LMem/combo.htm">the Local Memory chapter</A>.</DT><P CLASS="WorList">
<STRONG>
fptr</STRONG>
	<A NAME="GOCLanguage_c.htm_IX_Pointers:far pointers">
 </A>
<A NAME="GOCLanguage_c.htm_IX_fptr">
 </A>
An fptr is a &quot;far pointer&quot;--a 32-bit pointer to a specific location of memory. It is a standard C pointer.</P>
<DT>
<STRONG>
handle</STRONG>
	A handle is a 16-bit index into a Handle Table and is used to reference memory blocks. For more information, see <A HREF="../../Memory/Handles/combo.htm">the Handles chapter</A>.</DT><P CLASS="WorList">
<STRONG>
object block<BR>
</STRONG>
An object block is a specific type of Local Memory block that contains object chunks.</P>
<DT>
<STRONG>
optr</STRONG>
	An optr is a unique identifier for an object and is therefore also referred to as an &quot;Object Pointer.&quot; An optr is used to locate and access any object in the system, and because it is made up of handles and chunk handles, it will always stay the same even when the object moves in memory.</DD>
<DT>
<STRONG>
thread</STRONG>
</DT><DD><A NAME="GOCLanguage_c.htm_IX_Threads">
 </A>
A thread is a single executable entity that runs either procedural code or one or more objects. If a thread is &quot;event-driven,&quot; it executes code for a given set of objects, receiving messages and dispatching them to the proper objects.</DD>


</DL>
<H4 CLASS="HeadingC">
Class Terms</H4>
<DL>
<DT>
<STRONG>
class</STRONG>
</DT><DD>A class is the definition of a set of instance data structures and the methods that work on those structures. An object is called an &quot;instance&quot; of its class.</DD>
<DT>
<STRONG>
class tree</STRONG>
</DT><DD>A class tree represents the hierarchy of inheritance from superclass to subclass. If a message is not handled by a given class, it will be automatically passed up the class tree until it is handled or the root of the tree is reached, after which the message is discarded.</DD>
<DT>
<STRONG>
inheritance</STRONG>
</DT><DD>Inheritance is the term given to the way an object of a particular class has all the same instance variables and methods as an instance of the object's superclasses.</DD>
<DT>
<STRONG>
initialize</STRONG>
</DT><DD>Initialization of an object is when a master part (or master group) of the object's instance data is filled out. This occurs whenever a class in the master group not yet initialized in the object receives its first message.</DD>
<DT>
<STRONG>
master</STRONG>
</DT><DD>The term &quot;master&quot; is used in several cases, all related. A master class is generally considered the top class in a single class tree. Although the master class may have superclasses, it provides a conceptual break and creation of a new subtree.</DD>
<DT>
<STRONG>
master group</DT><DD>
</STRONG>
The section of an object's instance data belonging to a particular master class and all its subclasses is called a master group. A master group is initialized when the master class (or one of its subclasses) receives its first message.</DD>
<DT>
<STRONG>
resolve</STRONG>
</DT><DD><A NAME="GOCLanguage_c.htm_IX_Variant classes:resolving">
 </A>
Resolution of a variant class occurs when the variant's superclass is determined. Each instance of a variant class must be resolved individually.</DD>
<DT>
<STRONG>
subclass</STRONG>
</DT><DD>The term &quot;subclass&quot; is used to show relationships between classes. A subclass is defined on another class, from which it inherits instance data and methods. This other class is known as a &quot;superclass,&quot; below.</DD>
<DT>
<STRONG>
superclass</STRONG>
</DT><DD>The term &quot;superclass&quot; is used to show relationships between classes. A superclass passes on its instance data and methods to all classes defined as subclasses of it.</DD>
<DT>
<STRONG>
variant</STRONG>
</DT><DD><A NAME="GOCLanguage_c.htm_IX_Variant classes">
 </A>
A variant class may have different superclasses. However, an instance of a variant class may have only one superclass at any given moment. The use of variant classes can provide much the same functionality as the multiple inheritance found in some other object systems.</DD>


</DL>
<H4 CLASS="HeadingC">
Object Terms</H4>
<DL>
<DT>
<STRONG>
child</STRONG>
</DT><DD><A NAME="GOCLanguage_c.htm_IX_Objects:child objects">
 </A>
A child object is one that sits below another object in an object tree. The terms child, parent, and sibling are used only to show relationships between objects.</DD>
<DT>
<STRONG>
composite</STRONG>
</DT><DD><A NAME="GOCLanguage_c.htm_IX_Composite objects">
 </A>
A composite object is one that can have children. The composite has a &quot;composite link&quot; (an optr) to its first child and a &quot;sibling link&quot; to its next sibling. If it has no next sibling, the sibling link instead points to the object's parent object.</DD>
<DT>
<STRONG>
instance</STRONG>
</DT><DD>An instance is a particular manifestation of a class. This term is almost always interchangeable with &quot;object,&quot; though sometimes it specifically refers to the chunk containing the object's instance data rather than to the object as a whole.</DD>
<DT>
<STRONG>
link</STRONG>
</DT><DD>A link is typically an optr pointing to an object's next sibling in an object tree. It is also used more generally to refer to any optr linking two objects in an object tree (parent and child, or last sibling and parent).</DD>
<DT>
<STRONG>
object</STRONG>
</DT><DD>An object is a specific manifestation of a class. Typically, this term is interchangeable with &quot;instance&quot;; however, sometimes the term &quot;object&quot; refers to the combination of an object's methods and instance data whereas the term &quot;instance&quot; refers to just the object's instance data chunk.</DD>
<DT>
<STRONG>
object tree</STRONG>
</DT><DD>An object tree is a means of organizing objects into a hierarchy for display or organizational purposes. Do not confuse it with the &quot;class tree,&quot; the structure which represents class relationships. An object tree is made up of composite objects, each of which may have children or be the child of another object. The topmost object in the tree is called the &quot;root,&quot; and the bottommost objects are called the &quot;leaves&quot; or &quot;nodes.&quot; Non-composite objects may be placed in the tree as leaves but may not have children.</DD>
<DT>
<STRONG>
parent</STRONG>
</DT><DD>A parent object is one that has children in an object tree. The parent contains a composite link (an optr) to its first child and is pointed to by its last child.</DD>
<DT>
<STRONG>
state file</STRONG>
</DT><DD><A NAME="GOCLanguage_c.htm_IX_State files">
 </A>
A state file is a Virtual Memory file used to store the state of objects. Typically, object blocks will be written to or extracted from the state file. Generic UI objects have this functionality built in automatically; other objects may manage their own state saving by managing the state file.</DD>


</DL>
<H4 CLASS="HeadingC">
Messaging Terms</H4>
<DL>
<DT>
<STRONG>
blocking</STRONG>
</DT><DD><A NAME="GOCLanguage_c.htm_IX_Threads:blocking">
 </A>
A thread &quot;blocks&quot; when it must wait for resources or return values from messages sent to objects in another thread. Specifically, a thread blocks when one of its objects sends a message to another thread with the &quot;call&quot; command; if the &quot;send&quot; command is used, the thread will continue executing normally.</DD>
<DT>
<STRONG>
call</STRONG>
</DT><DD><A NAME="GOCLanguage_c.htm_IX_Messages:calling">
 </A>
<A NAME="GOCLanguage_c.htm_IX_@call[;call]">
 </A>
A message sent with the call command causes the calling thread to block until the message is handled by the recipient. If the recipient is in the calling thread, the code will be executed immediately.</DD>
<DT>
<STRONG>
dispatcher</STRONG>
</DT><DD><A NAME="GOCLanguage_c.htm_IX_Messages:dispatcher">
 </A>
The GEOS dispatcher is internal to the kernel and passes messages on to their proper recipients. The dispatcher will dynamically locate the proper object and method and will invoke the method.</DD>
<DT>
<STRONG>
message</STRONG>
</DT><DD>A message is a directive, query, or other instruction sent from one object to another. Messages may take parameters and may return information.</DD>
<DT>
<STRONG>
method</STRONG>
</DT><DD>A method, also called a &quot;message handler,&quot; is the code invoked by a message. A method may do anything a normal function or procedure may do, including alter instance data. It is poor style and highly discouraged for one object's method to alter another object's instance data directly.</DD>
<DT>
<STRONG>
send</STRONG>
</DT><DD>A message sent with the send command will be placed in the recipient's event queue and will not cause the sender to block. Messages that return information or pass pointers should never be dispatched with the send command; use the call command in those cases.</DD>

</DL>
<HR>
<A NAME="GOCLanguage_d.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">GEOS Programming</A>: 3.2 <A HREF="#GOCLanguage_b.htm">The GEOS Object System</A>: 
<A NAME="GOCLanguage_d.htm_41493">
 </A>
Object Structures</H3>
<P>
<A NAME="GOCLanguage_d.htm_IX_Objects">
 </A>
You do not need to know what data structures are used to store objects and classes; understanding them can make programming GEOS much easier, however.</P>
<P>
Each object is implemented in two parts: the instance data chunk and the class definition. Although both are integral parts of the object and they are interconnected, they are stored in different places.</P>
<P>
An object's instance data is stored in an instance chunk. This instance chunk is sometimes referred to as the object itself, but this isn't quite accurate--the instance chunk contains only the object's data along with a pointer to its class structure. The structure of the instance chunk is given in <A HREF="#GOCLanguage_d.htm_97259"> Instance Chunk Structures</A>
.</P>
<P>
An object's class structure contains all the code for the class. Since the class code may be accessed by many objects, the class definition resides in a geode's fixed memory resource. Every class (except the root, <CODE>
MetaClass</CODE>
) has a pointer to its superclass so it can inherit that class' methods and structures.</P>
<P>
All objects of a given class use the same code--the class' code--for their functions. They dynamically access this code so the code blocks need to be in memory only once, no matter how many objects are actively using them. Additionally, each class dynamically accesses its superclass' code, so any class may be accessed by all the objects of the subclasses as well. Class structures are shown in <A HREF="#GOCLanguage_d.htm_58645"> Class Structure and Class Trees</A>
.</P>

<H4 CLASS="HeadingC">
<A NAME="GOCLanguage_d.htm_97259">
 </A>
Instance Chunk Structures</H4>
<P>
<A NAME="GOCLanguage_d.htm_IX_Local memory:storing instance data">
 </A>
<A NAME="GOCLanguage_d.htm_IX_Instance data:structure">
 </A>
<A NAME="GOCLanguage_d.htm_IX_Chunks:instance chunk structure">
 </A>
Each object's instance data is stored in a Local Memory chunk. Several chunks are stored in one memory block, called a local memory heap. (See <A HREF="../../Memory/LMem/combo.htm">the Local Memory chapter</A>.) This local memory heap, containing objects, is known as an <EM>object block</EM>
.</P>
<P>
Each object block has a special header type that distinguishes it from normal local memory heaps. After the header in the block is the chunk handle table: a table containing offsets to each object in the block. Following the chunk handle table are the objects.</P>
<P>
<A NAME="GOCLanguage_d.htm_IX_optr">
 </A>
Each object is referenced by an object pointer, or optr. The optr contains two items: the global memory handle of the object block and the chunk handle of the object. Note that because the optr is made up of handles, an object must be locked before its instance data can be accessed. The GEOS kernel takes care of this automatically when executing methods. 
<IMG SRC="GOCLanguage_d_optr.gif">

</P>
<P>
Only the object's instance data is stored in the chunk pointed to by the optr; the method table and code used by the object are stored in the class' data structures, not the object's. To reconcile this separation of code and data, every object's first four bytes of instance data are a pointer to the object's class definition. This pointer is traversed by the kernel automatically and should not be altered or accessed by applications. </P>
<P>
Included in an object's instance chunk are certain fields generated and filled by either Goc or the kernel. Following these fields is the object's instance data, grouped by master part. It's unlikely you'll ever have to know the actual structures used in the instance chunk because the kernel automatically calculates the proper offsets to individual instance data fields. However, understanding the underlying structures may help in understanding how the object system of GEOS works.</P>
<P>
<A NAME="GOCLanguage_d.htm_IX_Master groups">
 </A>
Instance data within an instance chunk is stored in &quot;master parts&quot; or &quot;master groups.&quot; A master group is simply a number of instance data fields grouped according to their appropriate master class levels. Master classes are detailed in <A HREF="#GOCLanguage_d.htm_63826"> Master Classes</A>
.
<IMG SRC="GOCLanguage_d_objectAndClass.gif">

</P>
<P>
A class designated as a master class resembles a normal class in all respects save one: it determines how instance data is grouped in a chunk. Each master class is the head of a class subtree; all the classes below it in the class tree (down to the next master class) are considered to be in that master class' group. Instance data for all classes in the master group are lumped together in the instance chunk; each master group's instance data within the chunk is accessed via a special offset stored within the chunk.</P>
<P>
The first four bytes of an object's chunk contain a pointer to the object's class structure. The class structure (described in <A HREF="#GOCLanguage_d.htm_58645"> Class Structure and Class Trees</A>
) resides in fixed memory. (A variant-class object has a slightly different structure; this is detailed in <A HREF="#GOCLanguage_d.htm_43589"> Variant Classes</A>
.)</P>
<P>
An object that has no master classes in its class ancestry (unusual) has its instance data directly following its class pointer. Objects belonging to master classes or their subclasses, however, are somewhat more complex. This distinction can be mostly ignored by application and library programmers (with the exception of deciding which classes should be master classes and which should not).
<IMG SRC="GOCLanguage_d_objectStructures.gif">

</P>
<P>
Each master part of the chunk is located by an offset inserted directly after the object's class pointer in the chunk. The position of the word containing this offset is then stored in the master class structure so the class can find its instance data later. The combination of the class pointer and the various master offsets make up the object's &quot;base structure.&quot; When a typical object is instantiated, the base structure is all that is created.</P>
<P>
Each master part is left unallocated (for efficiency) until it is first accessed via a message sent to a class in the master group. When a class in the master group receives its first message, the entire master part of the chunk is allocated and initialized. This means that an object's chunk remains as small as possible until it absolutely must grow larger. Some classes even detect when a master part of the object will no longer be needed and actually remove (shrink to zero) the unwanted instance data from the chunk (<CODE>
GenClass</CODE>
 does this by shrinking the Vis master part to zero size when a gadget is taken off the screen).</P>
<P>
Any object may have &quot;variable data&quot; instance data fields; these are fields that may be added or removed dynamically to keep from having unused space in the instance chunk. Generic UI hints are &quot;variable data&quot; (also called <EM>
vardata</EM>
)--if an object has the hint, it appears in its instance chunk, if the object does not have the hint, the chunk does not have unused space in it.</P>
<P>
Vardata entries are stored all together at the end of the instance chunk, regardless of their master groups. An object with two master groups and three variable data fields, for example, would look like that shown in the figure below. Variable data and its use are discussed in full in <A HREF="#GOCLanguage_10.htm_54822"> Defining and Working With Variable Data Fields</A>
.
<IMG SRC="GOCLanguage_d_masterGroups.gif">

</P>


<H4 CLASS="HeadingC">
<A NAME="GOCLanguage_d.htm_63826">
 </A>
Master Classes</H4>
<P>
<A NAME="GOCLanguage_d.htm_IX_Master classes">
 </A>
A master class provides a conceptual break between levels within a class tree. Each master class is the head of a class subtree, and all its subclasses are considered to be in its &quot;master group.&quot
<IMG SRC="GOCLanguage_d_vardata.gif">


<IMG SRC="GOCLanguage_d_sampleInstance.gif">

</P>
<P>
The purpose of making a class a master class is to separate its instance data from that of its superclass. Each master group's instance data is lumped together in one section of the object's instance chunk and is not initialized until a class in the master group is accessed. The initialization (allocation of extra memory within the instance chunk) occurs automatically.</P>
<P>
As shown in the figures below, an object of <CODE>
RookClass</CODE>
 would have an instance chunk with two master groups, one for the <CODE>
PieceClass</CODE>
 master class and one for the <CODE>
GamePcClass </CODE>
master class. The first of the two master parts represents the instance data for <CODE>
PieceClass</CODE>
 only; the second master part represents the object's instance data for all of <CODE>
GamePcClass</CODE>
, <CODE>
ChessClass</CODE>
, and <CODE>
RookClass</CODE>
.</P>
<P>
The functionality of master classes is required to implement GEOS variant classes (see <A HREF="#GOCLanguage_d.htm_43589"> Variant Classes</A>
). A variant class allows a single class to have a version of &quot;multiple inheritance&quot; in that it can have different superclasses depending on the system context.

</P>


<H4 CLASS="HeadingC">
<A NAME="GOCLanguage_d.htm_58645">
 </A>
Class Structure and Class Trees</H4>
<P>
<A NAME="GOCLanguage_d.htm_IX_Class_&ldots;">
 </A>
For the most part, you won't ever need or want to know the internal structure of a class as implemented in memory. The class structure is created and partially filled by the Goc preprocessor and Glue linker; the remainder is filled by the kernel when the class is loaded. It's unlikely you will need to know the actual class structures; you won't ever have to manually build a class unless your program dynamically creates it (not a common procedure for typical applications).
<IMG SRC="GOCLanguage_d_classTree.gif">

</P>
<P>
This section will describe how the class is implemented and how class trees are structured and managed. However, it will not discuss creating new classes during execution.</P>
<P>
Classes are implemented with special data structures and code blocks. Each class is defined within and exported by a particular geode; when the geode is loaded the class definition and its code are loaded into the geode's fixed memory. All references to the class are then relocated by the kernel into pointers. For example, if a class is defined by a library, that library's &quot;core block&quot; (the special information kept about it by the kernel) contains an absolute pointer to the class' definition in a fixed memory resource owned by the library. Any applications then using that class load the library. The kernel examines the library's core block for the proper pointer and uses it each time the application references that class.

</P>
<P>
Because of this, each class is loaded into memory just once; all objects that use the class use the same class structure and code. Each object has a pointer in its instance chunk directly to the class structure; each class contains a pointer to its superclass' class structure. Using these pointers, the kernel can travel up an object's class tree to access any appropriate code. </P>
<P>
<A NAME="GOCLanguage_d.htm_IX_ClassStruct">
 </A>
A class is a combination of data structure and code. The data structure (<CODE>
ClassStruct</CODE>
) contains information about the class, its superclass, its methods, and the structure and size of its instance data. The code consists of methods (message handlers). A diagram of the data structure is given below.
<IMG SRC="GOCLanguage_d_ClassStruct.gif">

</P>

<H5 CLASS="HeadingD">
Class_superClass</H5>
<P>
Every class has as its first four bytes a pointer to its superclass. This points to the superclass' <CODE>
ClassStruct</CODE>
 structure in all cases except two: The root of any class tree has a null superclass pointer, indicating that the root has no superclass. <A NAME="GOCLanguage_d.htm_IX_Variant classes:detecting">
 </A>
Variant classes have the integer 1 (one) always, indicating that the superclass is determined in a special manner. For more information on variant classes, see <A HREF="#GOCLanguage_d.htm_43589"> Variant Classes</A>
.</P>
<P>
Class trees are constructed when classes are defined; a new class is created as the subclass of some existing class, and its <CODE>
Class_superClass</CODE>
 pointer is automatically set to point to the superclass. There is no need to point down the tree; messages are always passed to superclasses and never to subclasses. </P>


<H5 CLASS="HeadingD">
Class_masterOffset</H5>
<P>
<CODE>
Class_masterOffset</CODE>
<A NAME="GOCLanguage_d.htm_IX_Instance data:master offsets">
 </A>
<A NAME="GOCLanguage_d.htm_IX_Master classes:offset">
 </A>
 stores the offset indicating how far into the instance chunk the object's offset to this class' master part is. Note that use of this offset is entirely internal; individual classes do not have to figure out where their instance data is within the chunk (they may, however, have to know what master level each class is).</P>
<P>
The master offset is used primarily because an object can have some of its master parts initialized and others uninitialized. If only one master part of the object had been initialized, the location of the instance data in the chunk may be different than if all master parts had been initialized.</P>


<H5 CLASS="HeadingD">
Class_methodCount</H5>
<P>
<CODE>
Class_methodCount</CODE>
 stores the total number of methods referenced in the class' method table. This is the total number of methods defined for this class only; other methods defined in other classes (even in the same master group) are stored in the method tables of those classes.</P>


<H5 CLASS="HeadingD">
Class_instanceSize
<IMG SRC="GOCLanguage_d__masterOffset.gif">

</H5>
<P>
<CODE>
Class_instanceSize</CODE>
<A NAME="GOCLanguage_d.htm_IX_Instance data:structure">
 </A>
 holds the number of bytes to be allocated whenever an object of this class is instantiated. If the class is a master class or a subclass of a master class, this is the size of the master part. If the class has no master class above it, this is the number of bytes to allocate for the entire object (including superclass pointer).</P>


<H5 CLASS="HeadingD">
Class_vdRelocTable</H5>
<P>
<CODE>
Class_vdRelocTable</CODE>
<A NAME="GOCLanguage_d.htm_IX_Relocatable data:information in ClassStruct">
 </A>
 is a near pointer (16 bit offset) to the variable-data relocation information. The relocation information contains the type of relocation to be done for each data type. There is one entry in the variable data relocation table for each relocatable field in each particular variable-data type. Variable data (also called <EM>
vardata</EM>
) is described in full in <A HREF="#GOCLanguage_10.htm_54822"> Defining and Working With Variable Data Fields</A>
.</P>


<H5 CLASS="HeadingD">
Class_relocTable</H5>
<P>
<CODE>
Class_relocTable</CODE>
 is a near pointer (16 bit offset) to the relocation information for the non-variable data instance fields of the class. The relocation information contains the type of relocation done for each relocatable instance field (other than variable-data entries). A relocatable instance field is one which must be updated when the object is loaded--pointers, offsets, etc. The entry in the relocation table is defined with the <CODE>
@reloc</CODE>
 keyword, described on <A HREF="#GOCLanguage_10.htm_52446"> @reloc    &lt;iname&gt;, [(&lt;count&gt;, &lt;struct&gt;)] &lt;ptrType&gt;;</A>
.</P>


<H5 CLASS="HeadingD">
<A NAME="GOCLanguage_d.htm_11068">
 </A>
Class_flags</H5>
<P>
<CODE>
Class_flags</CODE>
<A NAME="GOCLanguage_d.htm_IX_CLASSF_&ldots;">
 </A>
 contains seven flags (shown below) that determine the characteristics of the class. Declarers for these flags are used in the <CODE>
@classdecl</CODE>
 declaration (see <A HREF="#GOCLanguage_10.htm_18289"> Defining a New Class or Subclass</A>
).</P>
<DL>
<DT>
CLASSF_HAS_DEFAULT</DT><DD>
This flag indicates that the class has a special default method to handle unrecognized messages (typically, this handler simply passes the unrecognized message on to the superclass). This flag is not implemented in C. This flag is set by declaring the class as <CODE>
hasDefault</CODE>
.</DD>
<DT>
CLASSF_MASTER_CLASS</DT><DD>
<A NAME="GOCLanguage_d.htm_IX_Master classes:class flag">
 </A>
This flag is set if the class is a master class. This flag is set by declaring the class as <CODE>
master</CODE>
.</DD>
<DT>
CLASSF_VARIANT_CLASS</DT><DD>
<A NAME="GOCLanguage_d.htm_IX_Variant classes:class flag">
 </A>
This flag is set if the class is a variant class. This flag is set by declaring the class as <CODE>
variant</CODE>
 (all variants must also be declared as masters).</DD>
<DT>
CLASSF_DISCARD_ON_SAVE</DT><DD>
<A NAME="GOCLanguage_d.htm_IX_Instance data:discardable">
 </A>
This flag indicates the instance data for the class can be discarded when the object is saved. This flag applies only to master classes and will be heeded only when the master group is immediately above a variant-master group. This flag is set by declaring the class <CODE>
discardOnSave</CODE>
.</DD>
<DT>
CLASSF_NEVER_SAVED</DT><DD>
This flag indicates objects of this class are never saved to a state file or loaded in from a resource. Goc will not build a relocation table for a class with this flag set. This flag is set by declaring the class <CODE>
neverSaved</CODE>
.</DD>
<DT>
CLASSF_HAS_RELOC</DT><DD>
<A NAME="GOCLanguage_d.htm_IX_Objects:relocating">
 </A>
This flag indicates that the class has a special routine for relocating and unrelocating objects of the class when they are loaded from or written to disk. This flag is set by declaring the class <CODE>
hasReloc</CODE>
.</DD>
<DT>
CLASSF_C_HANDLERS</DT><DD>
This flag indicates the class' methods are written in C rather than in assembly. This flag is set by the compiler and should not be set by applications.</DD>


</DL>
<H5 CLASS="HeadingD">
Class_masterMessages</H5>
<P>
<CODE>
Class_masterMessages</CODE>
 contains a number of flags set by Goc indicating whether this class has methods for messages defined within a given master level. It is used to optimize the search for a method to handle a message. These flags are internal and should not be used by programmers.</P>


<H5 CLASS="HeadingD">
The Method Table</H5>
<P>
<A NAME="GOCLanguage_d.htm_IX_Methods:storage">
 </A>
Every class has a method table, a table that indicates the location of the code to be executed when a certain message is received. The method table is in three parts and begins at the byte labelled <CODE>
Class_methodTable</CODE>
 (this is simply a label, not a specific data field).</P>
<P>
The first part of the method table is a list of messages the class can handle. Each entry in this list is two bytes and contains the message number of a message handled by the class.</P>
<P>
The second part of the method table is a list of pointers to methods. Each entry in this list is a pointer (four bytes) which points to a specific routine in a code block. If the code is in a fixed block, the pointer will be a far pointer; if the code is in a moveable or discardable block, the pointer will be a far pointer containing a <EM>
virtual segment</EM>
. (A virtual segment, something you do not need to know about, is a handle shifted right four bits with the top four bits set. Since this represents an illegal segment address, GEOS recognizes it as a virtual segment and will take the necessary actions to lock the block into memory before access and unlock it after access. Manipulation of the bits in the virtual segment is completely internal to GEOS.)</P>
<P>
The kernel searches the message list until it comes across the appropriate message number and notes the message's position in the table. It then looks at the corresponding position in the pointer list. If the pointer there is a virtual segment and offset, it will load the appropriate code block, lock it, and execute the code. If the pointer points to fixed memory, the code will be executed immediately. (If the message number is not found in the table, the kernel will either execute the class' default handler or pass the message on to the class' superclass.)</P>



<H4 CLASS="HeadingC">
<A NAME="GOCLanguage_d.htm_43589">
 </A>
Variant Classes</H4>
<P>
<A NAME="GOCLanguage_d.htm_IX_Variant classes">
 </A>
A variant class is one which has no set superclass. The variant's superclass is determined at run-time based on context and other criteria. Note that <EM>
objects</EM>
 may not be variant--only classes may be variant. An object always has a specific class to which it belongs, and its class pointer <EM>
always</EM>
 points to that class' <CODE>
ClassStruct</CODE>
 structure. In addition, every variant class <EM>
must</EM>
 also be a master class.</P>
<P>
A variant class, however, may have different superclasses at different times. This functionality provides a form of &quot;multiple inheritance&quot;: the class may inherit the instance data and functions of different classes depending on its attributes and desired features. Note, however, that a variant class may have only one superclass at any given moment.</P>
<P>
<A NAME="GOCLanguage_d.htm_IX_Specific user interface:variant classes">
 </A>
The most visible example of a variant class is <CODE>
GenClass</CODE>
 and how a generic object is resolved into its specific UI's appropriate representation. Each generic object (for example, a GenTrigger), is a subclass of the master class <CODE>
GenClass</CODE>
. All the instance data belonging to <CODE>
GenTriggerClass</CODE>
 and <CODE>
GenClass</CODE>
, therefore, is stored in the Gen master part of the instance chunk.</P>
<P>
<CODE>
GenClass</CODE>
<A NAME="GOCLanguage_d.htm_IX_GenClass:variant behavior">
 </A>
, however, is a variant class, meaning that it does not know its superclass when the object is instantiated. Each generic object's class will be linked directly to another class provided by the specific UI in use: the specific UI's class provides the visual representation while the generic UI class provides the object's functionality. In this way, the object can actually perform many of its generic functions without having a visual representation.</P>
<P>
The resolution of the superclass comes when the generic object is displayed on the screen: the kernel sees that the object has no superclass and looks into its instance data and class structure. The kernel then determines what the appropriate specific UI class will be for the object's class and provides the superclass link necessary. It also then initializes the superclass' master part of the object (in this case, the master part belonging to <CODE>
VisClass</CODE>
), updating all the master part offsets in the instance chunk's master offset fields.</P>
<P>
You can see from the above discussion that <CODE>
GenClass</CODE>
 must know at least something about its potential superclasses. In fact, all variant classes must know at least the topmost class of all its potential superclasses. The definition of <CODE>
GenClass</CODE>
 is</P>
<PRE>@class GenClass, VisClass, master, variant;</PRE>
<P>
The <CODE>
@class</CODE>
 keyword declares the new class, <CODE>
GenClass</CODE>
. <CODE>
GenClass</CODE>
 is to be a variant class and therefore must also be a master class. All the superclasses of <CODE>
GenClass</CODE>
 will be related to <CODE>
VisClass</CODE>
; this means that all specific UI classes which may act as Gen's superclass must be subclassed from <CODE>
VisClass</CODE>
. (Another way of looking at the definition is that <CODE>
GenClass</CODE>
 is an <EM>
eventual</EM>
 subclass of <CODE>
VisClass</CODE>
--you have no way of knowing beforehand how many class layers may be between the two, however.)</P>
<P>
The variant must specify an eventual superclass so the kernel knows how many master offset fields it must allocate when an instance of the variant is created. For example, a GenTrigger has two master groups: that of <CODE>
GenClass</CODE>
, and that of <CODE>
VisClass</CODE>
. Because the <CODE>
GenClass</CODE>
 master group is necessarily below the <CODE>
VisClass</CODE>
 master group in the class hierarchy (after the superclass link has been resolved), the <CODE>
GenClass</CODE>
 master offset in the instance chunk must be after the <CODE>
VisClass</CODE>
 master offset. If the definition did not specify <CODE>
VisClass</CODE>
 as an eventual superclass, no master offset field would be allocated for it, and the <CODE>
Class_masterOffset</CODE>
 field of <CODE>
GenClass</CODE>
' Class structure would not be able to hold any particular value.</P>
<P>
As stated at the beginning of this section, there are no &quot;variant objects.&quot; Every object belongs to a specific class, and the object's class can never change. All instances of a variant class, however, can be resolved to different superclasses due to the way the superclass of each variant is resolved. One example of this is the generic-to-specific mapping of the GenInteraction object.</P>
<P>
<A NAME="GOCLanguage_d.htm_IX_GenInteractionClass:variant behavior">
 </A>
All GenInteractions are of class <CODE>
GenInteractionClass</CODE>
; this never changes. <CODE>
GenInteractionClass</CODE>
, however, is a subclass of <CODE>
GenClass</CODE>
, a variant class. This means that the class tree of the GenInteraction object is only partially completed; before the GenInteraction is resolved, it looks like the simplified diagram below.
<IMG SRC="GOCLanguage_d_variantObject.gif">

</P>
<P>
The GenInteraction object may be resolved into one of several different specific UI classes. For example, the <STRONG CLASS="fileName">
motif.geo</STRONG>
 library has several classes for GenInteractions; among them are the classes that implement menus, dialog boxes, and grouping interactions. These classes are all specialized subclasses of <CODE>
VisClass</CODE>
, the eventual superclass of <CODE>
GenClass</CODE>
.
<IMG SRC="GOCLanguage_d_variantResolved.gif">

</P>
<P>
The class tree of the GenInteraction is not complete. A class tree must have links all the way back to <CODE>
MetaClass</CODE>
 for it to be complete; this only goes to <CODE>
GenClass</CODE>
. <CODE>
GenClass</CODE>
 has a special value in its <CODE>
Class_superClass</CODE>
 field, 0001h:0000h. This represents a reserved &quot;pointer&quot; that indicates to the kernel that the class is a master class.</P>
<P>
The superclass of the variant can be different for every instance because the superclass pointer is actually stored in the object's instance chunk rather than in the class' <CODE>
ClassStruct</CODE>
 structure. This also allows a class tree to have more than one variant class in its hierarchy; for example, one variant could be resolved to be the subclass of another variant. The tree must always be headed by <CODE>
MetaClass</CODE>
.</P>
<P>
The superclass pointer for the variant is stored in the variant's master group instance data. Not all master groups have superclass pointers; only those for variant classes. After the GenInteraction is resolved, the pointer (the first four bytes of the Gen master part) points to the proper superclass for this object (in this case, <CODE>
OLMenuWinClass</CODE>
). The object, with its full class tree, is shown in the figure above.</P>


<H4 CLASS="HeadingC">
An In-Depth Example</H4>
<P>
<A NAME="GOCLanguage_d.htm_IX_GenTriggerClass:variant behavior">
 </A>
<A NAME="GOCLanguage_d.htm_IX_Master classes:in example">
 </A>
This section gives an example of a GenTrigger object after its variant part has been resolved. This example provides in-depth diagrams of the class and instance structures for those programmers who wish to understand them. There is no need to know them, however; you will not likely ever need to access the internals of either a class structure or an instance structure.</P>
<P>
The GenTrigger taken as an example is the &quot;New Game&quot; trigger of the TicTac sample application. This trigger is the only child of the Game menu GenInteraction; it is shown below. The code defining the trigger is given in <A HREF="#GOCLanguage_d.htm_87649"> TicTac's New Game Trigger</A>
.
<IMG SRC="GOCLanguage_d_newgameTrigger.gif">

</P>
<P CLASS="figTitle">
Code Display 5-4 <A NAME="GOCLanguage_d.htm_87649">
 </A>
TicTac's New Game Trigger</P>
<PRE>/* The TicTacNewTrigger has a moniker and an output. All its other instance data
 * is set to the GenClass defaults. The content of these fields is not important
 * for this example, however. */</PRE>
<PRE>@object GenTriggerClass TicTacNewTrigger = {
    GI_visMoniker = &quot;New Game&quot;;
    GTI_destination = TicTacBoard;					/* Send the action message to the
					 * TicTac game board object. */
    GTI_actionMsg = MSG_TICTAC_NEW_GAME; 	/* The action message. */
}</PRE>

<IMG SRC="GOCLanguage_d_newgameInstance.gif">


<H5 CLASS="HeadingD">
The GenTrigger's Instance Chunk</H5>
<P>
The GenTrigger object has two master parts, just like the GenInteraction object shown in <A HREF="#GOCLanguage_d.htm_43589"> Variant Classes</A>
: the Gen master part holds the instance data for <CODE>
GenClass</CODE>
 and <CODE>
GenTriggerClass</CODE>
. The Vis master part holds the instance data for <CODE>
VisClass</CODE>
 and <A NAME="GOCLanguage_d.htm_IX_OLButtonClass">
 </A>
<CODE>
OLButtonClass</CODE>
. The <CODE>
MetaClass</CODE>
 instance data consists only of the object's class pointer and has no master part.</P>
<P>
The trigger's instance chunk's basic structure consists of the class pointer (four bytes) followed by two words of offset into the chunk. The first offset gives the location of the Vis master part, and the second gives the location of the Gen master part. After the offsets are the master parts themselves, and if the trigger had any variable data, it would appear at the end of the chunk.
<IMG SRC="GOCLanguage_d_newgameClassTree.gif">

</P>
<P>
Each master part has the master class' instance fields first, followed by those of its subclasses. All the fields that belong to <CODE>
VisClass</CODE>
 begin VI_..., all those that belong to <CODE>
OLButtonClass</CODE>
 begin OLBI_..., etc.</P>
<P>
Notice also the first four bytes of the Gen master part: they contain a pointer to the &quot;superclass&quot; of <CODE>
GenClass</CODE>
 for the trigger. Although the trigger typically does not have different forms in any given specific UI (as the GenInteraction does), it will have a different class for each specific UI it encounters. For example, the OSF/Motif class is <CODE>
OLButtonClass</CODE>
; another specific UI will use a different class for GenTriggers.</P>


<H5 CLASS="HeadingD">
The GenTrigger's Full Class Tree</H5>
<P>
Since <CODE>
GenClass</CODE>
 is a variant, it has a superclass pointer of 0001h:0000h. This special value (with an illegal segment address) indicates to the kernel that this object's <CODE>
GenClass</CODE>
 superclass is stored in the instance chunk itself. The superclass is stored in the first four bytes of the Gen master part, as shown in the previous section.</P>


<H5 CLASS="HeadingD">
GenTriggerClass' ClassStruct Structure
<IMG SRC="GOCLanguage_d_newgameSubClass.gif">

</H5>
<P>
Because all classes have the same class structure, only <CODE>
GenTriggerClass</CODE>
 will be examined here. The class structure and the instance chunk structure are closely linked in several ways.</P>
<P>
As shown in the diagram, the instance chunk points directly to the class. The class points to its superclass, thereby providing inheritance of all the methods and structures of classes higher in the class tree such as <CODE>
GenClass</CODE>
.</P>
<P>
The class structure contains some information about the instance chunk's format, specifically <CODE>
Class_masterOffset</CODE>
 and <CODE>
Class_instanceSize</CODE>
. <CODE>
Class_masterOffset</CODE>
 gives the offset into the instance chunk where the offset to the master part is stored. <CODE>
Class_instanceSize</CODE>
 contains the size of the master part so the kernel can quickly allocate the needed space when the master part is initialized.</P>
<P>
The method table resides at the end of the class, and it has entries for each message handled by the class. <CODE>
GenTriggerClass</CODE>
 handles seven messages (stored in <CODE>
Class_methodCount</CODE>
); any message received by this trigger and not recognized by <CODE>
GenTriggerClass</CODE>
 is passed up the class tree for handling. Thus, a MSG_GEN_SET_NOT_ENABLED sent to the trigger will be passed on to <CODE>
GenClass</CODE>
 and will be handled there.</P>
<P>
<A NAME="GOCLanguage_d.htm_IX_Method table">
 </A>
The method table has two parts: The first part is a listing of message numbers, and the second part is a listing of pointers to the method code. When the object receives a message, the kernel scans the first part to see if the class handles the message. If it does, the kernel then scans the second part of the table to get the pointer to the code. It then executes the code there as if that code were a function called by the object's code.</P>


<H5 CLASS="HeadingD">
How a Message Is Handled</H5>
<P>
<A NAME="GOCLanguage_d.htm_IX_Messages:handling with variant classes">
 </A>
Most aspects of messages and messaging are described in the following section. This section, however, describes how the kernel finds and executes the code when a message is sent to the GenTrigger. The message is <CODE>
MSG_GEN_SET_USABLE</CODE>
 (handled by <CODE>
GenClass</CODE>
).</P>
<P>
Messages are sent directly to an object using its optr. That is, when you send a message to this particular GenTrigger, you send it directly to TicTacNewTrigger, not to some monolithic &quot;case&quot; statement run by your application. Since the object's optr uniquely identifies the location of the object's instance chunk in memory, the kernel can quickly access the code for the handler.</P>
<P>
When <CODE>
MSG_GEN_SET_USABLE</CODE>
 is sent to the TicTacNewTrigger, for example, the kernel looks in the object's instance chunk for its class pointer. It follows this pointer and then looks in <CODE>
GenTriggerClass</CODE>
' <CODE>
ClassStruct</CODE>
 structure. It scans the first part of the class' method table for <CODE>
MSG_GEN_SET_USABLE</CODE>
. If the message is not there (and it isn't), the kernel will then follow the class' <CODE>
Class_superClass</CODE>
 pointer and look in <CODE>
GenClass</CODE>
' <CODE>
ClassStruct</CODE>
 structure. It then scans the first part of <CODE>
GenClass</CODE>
' method table for the message. <CODE>
GenClass</CODE>
 has an entry for <CODE>
MSG_GEN_SET_USABLE</CODE>
, and therefore the kernel checks the second part of the method table for the code pointer. It follows this pointer to the method's entry point and begins executing the code there.</P>


<HR>
<A NAME="GOCLanguage_e.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">GEOS Programming</A>: 3.3 <A HREF="#GOCLanguage_b.htm">The GEOS Object System</A>: 
<A NAME="GOCLanguage_e.htm_57260">
 </A>
The GEOS Message System</H3>
<P>
<A NAME="GOCLanguage_e.htm_IX_Messages">
 </A>
Because objects are independent entities, they must have some means of communicating with other objects in the system. As shown in the example of the calculator and requestor objects in <A HREF="../../Intro/Overview/combo.htm">the Overview chapter</A>, communication is implemented through the use of messages and methods.</P>
<H4 CLASS="HeadingC">
The Messaging Process</H4>
<P>
When an object needs to notify another object of some event, retrieve data from another object, or send data to another object, it sends a message to that object. Sending a message is similar to calling a function in C in that the message can take parameters (including pointers) and give return values. However, messages are also quite different from function calls in the multithreaded environment of GEOS.</P>
<P>
<A NAME="GOCLanguage_e.htm_IX_Threads:event queues">
 </A>
Each object block in the system is associated with a single thread of execution. Each thread that runs objects (some run only procedural code) has an <EM>
event queue</EM>
, a queue in which messages are stored until they can be handled. Every message sent to an object from another thread gets put in the object's thread's event queue. (Messages sent between objects within the same thread are not handled via the queue unless forced that way.) Thus, a single thread's event queue can have messages for many different objects. For most single-thread applications, the programmer will not have to worry about synchronization issues.</P>
<P>
<A NAME="GOCLanguage_e.htm_IX_Messages:calling">
 </A>
The sender of a message has to be aware of synchronization issues raised by having multiple threads in the system. Essentially, you can send a message two ways: The first, &quot;calling&quot; the message, allows the use of return values and acts almost exactly like a function call in C. This places the message in the recipient's event queue and then halts the sender until the return values are received. The sender &quot;goes to sleep&quot; until the message has been processed and is then awoken by the kernel, thus ensuring the message is handled before the sender executes another line of code. The call option should also be used when passing pointers; otherwise, the item pointed to may move before the message can be handled, invalidating the pointer.</P>
<P>
<A NAME="GOCLanguage_e.htm_IX_Messages:sending">
 </A>
The second, &quot;sending&quot; the message, is used primarily when synchronization is not an issue. For example, if the message merely notifies the recipient of some condition or event, or if it sends data with no expectation of a return value, the send option can be used. Essentially, the sender will send off the message and then forget about it, continuing on with its own business. (The exception to this is an object sending a message to another object in the same thread; then the message is handled immediately, as if it had been called.)</P>
<P>
When an object sends a message, the message actually first gets passed to the kernel (this is all automatic). The kernel will put the message into the proper thread's event queue and, if necessary, put the sender's thread temporarily to sleep. When the recipient's thread is ready to handle the message, the kernel pulls it from the event queue.</P>
<P>
The kernel then locates and loads the recipient object into memory (if necessary). The recipient's object block will be loaded and locked, and the object will be locked while processing the event. (Note, however, that it is possible for the object to move if the recipient makes a call to <CODE>
LMemAlloc()</CODE>
 or does something else that can cause shuffling of the object chunks.) The kernel will follow the object's class pointer to its class and will scan the method table. If the class can handle the message, the proper method code will be executed. If the class can not handle the message, the kernel will follow the superclass pointer and check the method table there. The message will continue up the class tree like this until either it is handled or it reaches the root and returns unprocessed.</P>
<P>
After the method code has been executed, the kernel collects any return values and wakes up the caller thread again if necessary. To the caller, it's as if the message were handled instantaneously (with the call option). Senders are never blocked; only messages called (with the call option) may block the caller's thread. If a message is sent to an object in the same thread, however, it will be executed as a call and will be handled immediately, unless the sender explicitly states that it should go through the message queue.</P>
<P>
<A NAME="GOCLanguage_e.htm_IX_Deadlock">
 </A>
Be careful, though, if you are writing code in multiple threads (for example, if you subclass UI objects and write new method code for them). You have to make sure that two threads never call each other; this can lead to deadlock if the calls happen to overlap. The easiest way to deal with this is to have one thread always send a message requesting a return message with any needed return values. The other thread will then send off a return message with the data. For example, a UI object may require information from an application's object. The UI object sends <CODE>
MSG_REQUEST_INFORMATION</CODE>
 (or something similar). The application's object then receives that message and responds with a <CODE>
MSG_RETURNING_REQUESTED_INFORMATION</CODE>
 (or something similar). With this scheme, the application's object is free to use call whenever it wants, but the UI object must always use send.</P>


<H4 CLASS="HeadingC">
Message Structures and Conventions</H4>
<P>
A message is simply a 16-bit number determined at compile time. Specifically, it is an enumerated type--this ensures that no two messages in the same class can have the same number.</P>
<P>
An event is an opaque structure containing the message number and information about the recipient, the sender, parameters, and return values. When an object sends a message, the kernel automatically builds out the event structure (generally stored in the handle table for speed and efficiency). You will never have to know the structure of an event.</P>

<HR>
<A NAME="GOCLanguage_f.htm"></A>


<H2 CLASS="sectionTitle">
<A HREF="#index.htm">GEOS Programming</A>: 4 
<A NAME="GOCLanguage_f.htm_64505">
 </A>
Using Classes and Objects</H2>
<P>
The previous sections dealt with the internals of the GEOS object system. This section describes how you can create classes and objects and manage them during execution using Goc keywords and kernel routines. Almost all Goc keywords begin with &quot;<CODE>
@</CODE>
&quot; (one notable exception is <CODE>
gcnList</CODE>
).</P>
<P>
All the most useful keywords available in Goc are shown in <A HREF="#GOCLanguage_f.htm_29101"> Goc Keywords</A>
. This display is for initial reference; all the keywords are detailed in depth in the following sections of this chapter and in the Routines Book.</P>
<P CLASS="figTitle">
Code Display 5-5 <A NAME="GOCLanguage_f.htm_29101">
 </A>
Goc Keywords</P>
<PRE>	/* Including .goh files */
@include &lt;fname&gt;;</PRE>
<PRE>	/* Defining New Classes and Subclasses */
@class	&lt;cname&gt;, &lt;super&gt; [, master [, variant]];
@endc</PRE>
<PRE>	/* Declaring a class */
@classdecl &lt;cname&gt; [, &lt;cflags&gt;];</PRE>
<PRE>	/* Defining messages for a class */
@message &lt;retType&gt; &lt;mname&gt;([@stack] &lt;param&gt;*);
@reserveMessages &lt;num&gt;;
@exportMessages &lt;expName&gt;, &lt;num&gt;;
@importMessage &lt;expName&gt;, &lt;messageDef&gt;;
@alias(&lt;protoMsg&gt;) &lt;messageDef&gt;;
@prototype &lt;messageDef&gt;;</PRE>
<PRE>	/* Defining instance data fields for a class */
@instance &lt;insType&gt; &lt;iname&gt; [ = &lt;default&gt;];
gcnList(&lt;manufID&gt;, &lt;ltype&gt;) = &lt;oname&gt; [, &lt;oname&gt;]*;
@instance @composite &lt;iname&gt; [ = &lt;linkName&gt;];
@instance @link &lt;iname&gt; [ = &lt;default&gt;];
@instance @visMoniker &lt;iname&gt; [ = &lt;default&gt;];
@instance @kbdAccelerator &lt;iname&gt; [ = &lt;default&gt;];
@reloc &lt;iname&gt;, [ (&lt;count&gt;, &lt;struct&gt;), ] &lt;ptrType&gt;;
@noreloc &lt;iname&gt;;
@default &lt;iname&gt; = &lt;default&gt;;</PRE>
<PRE>	/* Defining vardata fields for a class */
@vardata &lt;type&gt; &lt;vname&gt;;
@vardataAlias (&lt;origName&gt;) &lt;newType&gt; &lt;newName&gt;;
@reloc &lt;vname&gt;, &lt;fn&gt;, [ (&lt;count&gt;, &lt;struct&gt;), ] &lt;ptrType&gt;;</PRE>
<PRE>	/* Defining methods (message handlers) */
@method [ &lt;hname&gt;, ] &lt;cname&gt;[, &lt;mname&gt;+];
@method [ &lt;hname&gt;, ] &lt;cname&gt;, _reloc;</PRE>
<PRE>	/* Defining library code */
@optimize
@deflib &lt;libname&gt;
@endlib</PRE>
<PRE>	/* Defining resources */
@start &lt;segname&gt; [ , &lt;flags&gt; ];
@header &lt;type&gt; [ = &lt;init&gt; ];
@end &lt;segname&gt;
@chunk &lt;type&gt; &lt;name&gt; [ = &lt;init&gt; ];
@localize &lt;string&gt;;
@localize { &lt;string&gt; &lt;length&gt;};
@localize { &lt;string&gt; &lt;minLength&gt;-&lt;maxLength&gt; };
@localize not;
@chunkArray &lt;stype&gt; &lt;aname&gt; [ = {&lt;init&gt;} ];
@elementArray &lt;stype&gt; &lt;aname&gt; [ = {&lt;init&gt;} ];
@extern &lt;type&gt; &lt;name&gt;;
@gstring &lt;name&gt; = {[&lt;command&gt; [, &lt;command&gt;]+]} ;</PRE>
<PRE>	/* Declaring an object */
@object &lt;class&gt; &lt;name&gt; &lt;flags&gt;* = {
    [&lt;fieldName&gt; = &lt;init&gt;];*
    [&lt;varName&gt; [ = &lt;init&gt; ]]*;
}</PRE>
<PRE>	/* Accessing an object's instance data from one of its methods */
@self-&gt;&lt;iname&gt;</PRE>
<PRE>	/* Sending and calling messages */
@send [&lt;flags&gt;,+] &lt;obj&gt;::[{&lt;cast&gt;}] &lt;msg&gt;(&lt;params&gt;*);
&lt;ret&gt; = @call [&lt;flags&gt;,+] [{&lt;cast&gt;}] &lt;obj&gt;::[{&lt;cast2&gt;}]&lt;msg&gt;(&lt;params&gt;*);
@callsuper();
@callsuper &lt;obj&gt;::&lt;class&gt;::&lt;msg&gt;(&lt;params&gt;*) [&lt;flags&gt;,];
&lt;event&gt; = @record &lt;obj&gt;::&lt;msg&gt;(&lt;params&gt;*);
@dispatch [noFree] &lt;nObj&gt;::&lt;nMsg&gt;::&lt;event&gt;;
&lt;ret&gt; = @dispatchcall [noFree] [{&lt;cast&gt;}] &lt;nobj&gt;::&lt;nMsg&gt;::&lt;event&gt;;</PRE>
<PRE>	/* Using conditional code */
@if &lt;cond&gt;
@if defined(&lt;item&gt;)
@ifdef &lt;cond&gt;
@ifndef &lt;cond&gt;</PRE>
<PRE>	/* Creating Goc macros */
@define &lt;mname&gt; &lt;macro&gt;</PRE>
<PRE>	/* Esoteric Source-Code Management */
@optimize
@protominor &lt;name&gt;</PRE>
<P CLASS="subsectionLink">
<A HREF="#GOCLanguage_10.htm">Defining a New Class or Subclass</A></P>
<P CLASS="subsectionLink">
<A HREF="#GOCLanguage_11.htm">Non-relocatable Data</A></P>
<P CLASS="subsectionLink">
<A HREF="#GOCLanguage_12.htm">Defining Methods</A></P>
<P CLASS="subsectionLink">
<A HREF="#GOCLanguage_13.htm">Declaring Objects</A></P>
<P CLASS="subsectionLink">
<A HREF="#GOCLanguage_14.htm">Sending Messages</A></P>
<P CLASS="subsectionLink">
<A HREF="#GOCLanguage_15.htm">Managing Objects</A></P>
<HR>
<A NAME="GOCLanguage_10.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">GEOS Programming</A>: 4.1 <A HREF="#GOCLanguage_f.htm">Using Classes and Objects</A>: 
<A NAME="GOCLanguage_10.htm_18289">
 </A>
Defining a New Class or Subclass</H3>
<PRE>@class, @classdecl, @endc, @default, @uses</PRE>
<P>
<A NAME="GOCLanguage_10.htm_IX_@endc[;endc]">
 </A>
<A NAME="GOCLanguage_10.htm_IX_@class[;class]">
 </A>
You can create new classes in GEOS by using the Goc keywords <CODE>
@class</CODE>
 and <CODE>
@endc</CODE>
. These frame the class definition as shown in <A HREF="#GOCLanguage_10.htm_73551"> Defining Classes</A>
; the <CODE>
@endc</CODE>
 keyword takes no parameters, but <CODE>
@class</CODE>
 takes the following parameters:</P>
<PRE>@class    &lt;cname&gt;, &lt;super&gt; [, master [, variant]];</PRE>
<DL>
<DT>
<STRONG>
cname</STRONG>
</DT><DD>This is the name of the new class.</DD>
<DT>
<STRONG>
super</STRONG>
</DT><DD>This is the class name of the superclass.</DD>
<DT>
<STRONG>
master</STRONG>
</DT><DD><A NAME="GOCLanguage_10.htm_IX_Master classes:class flag">
 </A>
<A NAME="GOCLanguage_10.htm_IX_master (class flag)">
 </A>
When included, this word makes the new class a master class.</DD>
<DT>
<STRONG>
variant</STRONG>
</DT><DD><A NAME="GOCLanguage_10.htm_IX_Variant classes:class flag">
 </A>
<A NAME="GOCLanguage_10.htm_IX_variant (class flag)">
 </A>
When included, this word makes the new class a variant class. All variant classes must also be declared master classes.</DD>
</DL>
<P>
<A NAME="GOCLanguage_10.htm_IX_@classdecl[;classdecl]">
 </A>
Every class must have a class structure (<CODE>
ClassStruct</CODE>
) in memory. This is created and filled automatically by Goc and the kernel; however, you must use the <CODE>
@classdecl</CODE>
 keyword to make sure the structure gets built. Only one <CODE>
@classdecl</CODE>
 statement may be used for each class, however--Goc will give an error if the class is declared twice. This is also shown in <A HREF="#GOCLanguage_10.htm_73551"> Defining Classes</A>
, and its parameters are as follows:</P>
<PRE>@classdecl    &lt;cname&gt; [, &lt;cflags&gt;];</PRE>
<DL>
<DT>
<STRONG>
cname</STRONG>
</DT><DD>This is the name of the class being declared.</DD>
<DT>
<STRONG>
cflags</STRONG>
</DT><DD>These are optional flags, described below.</DD>
</DL>
<P>
The optional flags that can be used with a class declaration determine how objects of the class get shut down (see <A HREF="#GOCLanguage_d.htm_11068"> Class_flags</A>
). The flags you can use with <CODE>
@classdecl</CODE>
 are</P>
<DL>
<DT>
<CODE>
neverSaved</CODE>
<A NAME="GOCLanguage_10.htm_IX_neverSaved (class flag)">
 </A>
</DT><DD>This flag indicates that objects of this class will neither be written to a state file nor be loaded in from a resource. This flag should only be used for classes whose objects will only be created at run-time (not declared in the <STRONG CLASS="fileName">
.goc</STRONG>
 file) and for process classes.</DD>
<DT>
<CODE>
discardOnSave</DT><DD>
</CODE>
<A NAME="GOCLanguage_10.htm_IX_discardOnSave (class flag)">
 </A>
This flag applies only to master classes. Objects of this class will never be saved to a state file and must be re-initialized each time they are loaded. If you want an object simply to revert to its default configuration each time it is loaded, use the flag <CODE>
ignoreDirty</CODE>
 instead in the object's declaration (see <CODE>
@object</CODE>
, in <A HREF="#GOCLanguage_13.htm_72656"> Declaring an Object</A>
).</DD>
</DL>
<P>
In addition, any variant class can have a default superclass. The variant is resolved at compile-time to have the default superclass as its superclass. To set a default superclass for a variant class, add a line with the following structure in the class definition:</P>
<PRE>@default &lt;varRoot&gt; = &lt;super&gt;;</PRE>
<DL>
<DT>
<STRONG>
varRoot</STRONG>
</DT><DD>The name of the variant class with &quot;Class&quot; removed. (For example, GenClass would be specified as &quot;Gen.&quot;)</DD>
<DT>
<STRONG>
super</STRONG>
</DT><DD>The name of the superclass to set as the default.</DD>
</DL>
<P>
<A NAME="GOCLanguage_10.htm_IX_@uses[;uses]">
 </A>
Sometimes a variant class will know that it will be the subclass of a specific class, though it doesn't know (at compile time) just how that ancestry will be traced. You can use the <CODE>
@uses</CODE>
 directive to let the compiler know this; that way, the variant class can define handlers for the &quot;used&quot; class. For example, if you know that variant class <CODE>
MyVariantClass</CODE>
 will always be resolved as a descendant of <CODE>
MyAncestorClass</CODE>
, you can put the directive
<IMG SRC="GOCLanguage_10_usesSidebar.gif">

</P>
<PRE>@uses MyAncestorClass;</PRE>
<P>
in the definition of <CODE>
MyVariantClass</CODE>
. The general format is</P>
<PRE>@uses &lt;class&gt;;</PRE>
<DL>
<DT>
<STRONG>
class</STRONG>
</DT><DD>The class which will always be an ancestor to this class.</DD>
</DL>
<P CLASS="figTitle">
Code Display 5-6 <A NAME="GOCLanguage_10.htm_73551">
 </A>
Defining Classes</P>
<PRE>/* The @class keyword defines a new class or subclass. @endc ends the class
 * definition, and @classdecl must be put somewhere in the code to make sure Glue
 * will link the class structure into the compiled geode.*/</PRE>
<PRE>@class	MyNewClass, VisClass;
    /* Message declarations would go here. See @message.
     * Instance data field declarations would go here. See @instance
     * 						and @vardata. */
@endc
@classdecl MyNewClass, neverSaved;</PRE>
<PRE>@class	MyTriggerClass, GenTriggerClass;
    /* New messages for this subclass are defined here. */
    /* New instance data fields for this subclass are defined here. */
@endc
@classdecl MyTriggerClass;</PRE>
<PRE>/* When defining a variant class (which must also be a master class), you can
 * set a superclass for the variant at compile-time using @default. */</PRE>
<PRE>@class	MyNewVariantClass, MetaClass, master, variant;
    @default		MyNewVariant = VisClass;
@endc	MyNewVariantClass
@classdecl MyNewVariantClass;</PRE>

<H4 CLASS="HeadingC">
<A NAME="GOCLanguage_10.htm_26398">
 </A>
Defining New Messages for a Class</H4>
<PRE>@message, @stack, @reserveMessages, @exportMessages, @importMessage, @alias, @prototype</PRE>
<P>
As discussed in <A HREF="#GOCLanguage_e.htm_57260"> The GEOS Message System</A>
, messages are simply 16-bit numbers allocated as an enumerated type. When a new class is defined, a constant is automatically created representing the first message number for the class. This constant is then used as the first number in the enumeration of messages.</P>
<P>
<A NAME="GOCLanguage_10.htm_IX_Messages:ranges">
 </A>
The constant is built off the class' superclass. <CODE>
MetaClass</CODE>
 has the first 16384 messages reserved for its use. Each master level gets 8192, and the first master class of a level gets 2048 of these. All other classes are allocated 512 message spots. Thus, a master class subclassed directly off <CODE>
MetaClass</CODE>
 would have 2048 messages beginning with number #16384 (since the numbering is zero-based). A subclass of this would have 512 messages beginning with number #18432.</P>
<P>
This numbering scheme ensures that no two classes at different levels in the class hierarchy will have the same message number. Specifically, a class will never have the same message number as one of its sub- or superclasses.</P>
<P>
New messages must be defined in the class definition between the <CODE>
@class</CODE>
 and <CODE>
@endc</CODE>
 keywords (see above). They are defined much like normal function calls and follow the normal C calling conventions (see <A HREF="#GOCLanguage_10.htm_43720"> Defining Messages</A>
 for examples). If your class uses messages from its superclass, you do <EM>
not</EM>
 have to declare these messages in your class definition--they are inherited automatically. This is true even if you are subclassing the method to alter its functionality.</P>
<P>
<A NAME="GOCLanguage_10.htm_IX_@message[;message]">
 </A>
To define a new message, use the <CODE>
@message</CODE>
 keyword. This keyword takes the following parameters:</P>
<PRE>@message   &lt;retType&gt; &lt;mname&gt;(&lt;param&gt;*);</PRE>
<DL>
<DT>
<STRONG>
retType</STRONG>
</DT><DD>This is the data type of the return value of the message. It can be any standard C or GEOS data type (excluding structures), or a pointer to a structure. If this message has multiple return values, you must do as in C function calls and pass pointers to buffers for the return information.</DD>
<DT>
<STRONG>
mname</STRONG>
</DT><DD>This is the name of the message. By convention, it will be <CODE>
MSG_</CODE>
 followed by a shortened version of the name of the class and then some useful name (e.g., <CODE>
MSG_META_INITIALIZE</CODE>
).</DD>
<DT>
<STRONG>
param</STRONG>
</DT><DD>This represents one or more parameters. Messages may have no parameters, one parameter, or several parameters. Parameter definition is essentially the same as definition of function parameters; see <A HREF="#GOCLanguage_10.htm_43720"> Defining Messages</A>
 for examples. </DD>
</DL>
<P>
	NOTE: When defining a function with no parameters, it is best to declare it with &quot;void&quot; between the parentheses. This will make sure Goc gives an error if the function is called with arguments.</P>

<H5 CLASS="HeadingD">
Messages for Use with Assembly Code</H5>
<P>
<A NAME="GOCLanguage_10.htm_IX_@stack[;stack]">
 </A>
 The <CODE>
@stack</CODE>
 keyword indicates that parameters are passed on the stack; it is important to note that because of calling conventions, parameters passed on the stack must be listed in the message definition <EM>
in reverse order</EM>
 from the way the handler pops them from the stack. This keyword is used only when the message may be handled by an assembly language method; its format is shown below:</P>
<PRE>@message &lt;retType&gt; &lt;mname&gt;(@stack &lt;param&gt;*);</PRE>
<P>
All the parameters shown in the formats are the same as in the normal <CODE>
@message</CODE>
 format.</P>
<P CLASS="figTitle">
Code Display 5-7 <A NAME="GOCLanguage_10.htm_43720">
 </A>
Defining Messages</P>
<PRE>	/* Each message is defined for a class within the class definition. */
@class	MyTriggerClass, GenTriggerClass;
	/* All the new messages MyTriggerClass can handle are defined here. */
@message void MSG_MYTRIG_SET_COLOR(colors colorIndex);
@message optr MSG_MYTRIG_RETURN_OPTR( void );
@message void MSG_MYTRIG_COLLECT_PARAMS(byte bParam, word wParam, char * string);
	/* Instance data fields would be defined here. */</PRE>
<PRE>@endc
@classdecl MyTriggerClass;</PRE>


<H5 CLASS="HeadingD">
Exporting, Importing, and Reserving Message Ranges</H5>
<P>
<A NAME="GOCLanguage_10.htm_IX_Messages:importing">
 </A>
<A NAME="GOCLanguage_10.htm_IX_Messages:exporting">
 </A>
As discussed above, message numbers are assigned based on the class' location in the class tree. No message number will ever conflict with messages defined in the class' superclasses. However, the assignment scheme opens up the possibility that classes on the same level in the class tree could have conflicting message numbers, as shown below.
<IMG SRC="GOCLanguage_10_messageNumbers.gif">

</P>
<P>
Normally, this is not a problem. If subclasses are to receive the same message and handle it differently, the message can typically be defined in the superclass and simply be intercepted by the subclasses. Sometimes, however, different subclasses will need to have different definitions for the same messages. For example, a class supplied by a library may be used by several applications; if the applications each create a subclass, these subclasses can import particular messages that will be the same for all the subclasses in all the applications.</P>
<P>
Goc therefore allows a class to export a range of message numbers which subclasses can import and create specific definitions for. This allows you greater control over what aspects of the class you can define.</P>
<P>
<A NAME="GOCLanguage_10.htm_IX_@importMessage[;importMessage]">
 </A>
<A NAME="GOCLanguage_10.htm_IX_@exportMessages[;exportMessages]">
 </A>
To export a range of messages, use the <CODE>
@exportMessages</CODE>
 keyword. This will set aside several message numbers which can then be imported by subclasses using the <CODE>
@importMessage</CODE>
 keyword.<A NAME="GOCLanguage_10.htm_IX_Messages:reserving ranges">
 </A>
</P>
<P>
<A NAME="GOCLanguage_10.htm_IX_@reserveMessages[;reserveMessages]">
 </A>
Another potential problem is upgrading your program from release to release. If you create classes that may grow in the future, you may want to reserve a number of message spots to ensure that those spots can be filled in later. Nothing is done with the spots; they are simply place holders for future upgrades. You can use the <CODE>
@reserveMessages</CODE>
 keyword to reserve a range of any size. The parameters of these three keywords are shown below:</P>
<PRE>@reserveMessages    &lt;num&gt;;
@exportMessages     &lt;expName&gt;, &lt;num&gt;;
@importMessage	      &lt;expName&gt;, &lt;messageDef&gt;;</PRE>
<DL>
<DT>
<STRONG>
num</STRONG>
</DT><DD>This is the number of messages in the exported range.</DD>
<DT>
<STRONG>
expName</STRONG>
</DT><DD>This is the name of the exported range. This is used when importing messages to ensure that the proper numbers are used.</DD>
<DT>
<STRONG>
messageDef</DT><DD>
</STRONG>
This is a standard message definition line, the same as would be found with the <CODE>
@message</CODE>
 keyword (though <CODE>
@message</CODE>
 is left out).</DD>
</DL>
<P>
Note that you do not <EM>
need</EM>
 to reserve messages for upgrades; any class can always have messages tacked on to the end of its class definition. If you want to group the messages logically, however, you should reserve ranges where you expect additions to be made.</P>


<H5 CLASS="HeadingD">
Aliasing Messages</H5>
<P>
<A NAME="GOCLanguage_10.htm_IX_@alias[;alias]">
 </A>
The <CODE>
@alias</CODE>
 keyword allows a single message to have more than one pass/return format.<A NAME="GOCLanguage_10.htm_IX_@prototype[;prototype]">
 </A>
 The <CODE>
@prototype</CODE>
 keyword allows quick, clean, and convenient repetition of a single format for many different messages; it also allows a class to create a prototype so users of a message can have their own messages with the same format.</P>
<P>
<CODE>
@alias</CODE>
 is used when a single method takes conditional parameters. For example, a method may take a word value in a certain case and a dword value in another (dependent upon a passed flag). Each condition must be accounted for in its own message format. Rather than create a message and a method for each case, you can create a single assembly-language method for all the different pass/return formats; then, you can use <CODE>
@alias</CODE>
 to make several messages refer to the same method, each using a different format.</P>
<PRE>@alias(&lt;protoMsg&gt;) &lt;msgDef&gt;;</PRE>
<DL>
<DT>
<STRONG>
protoMsg</STRONG>
</DT><DD>The name of the original message. The new message may have different pass/return values but will invoke the same method code and will have the same message number.</DD>
<DT>
<STRONG>
msgDef</STRONG>
</DT><DD>The new message definition. It follows the same format as messages defined with the <CODE>
@message</CODE>
 keyword (with <CODE>
@message</CODE>
 left off).</DD>
</DL>
<P>
In addition, if you have a single pass/return format for many messages, you can use the <CODE>
@prototype</CODE>
 keyword as coding shorthand. For example, if an object has ten messages that all take two parameters and return a single value, you can set up the format with the <CODE>
@prototype</CODE>
 keyword and then use a simpler format for definition of your messages. An example is shown in <A HREF="#GOCLanguage_10.htm_26009"> Aliasing Messages</A>
, and the parameters of this keyword are shown below.</P>
<PRE>@prototype &lt;msgDef&gt;;</PRE>
<DL>
<DT>
<STRONG>
msgDef</STRONG>
</DT><DD>This is the standard message definition. For the message name, use something like &quot;<CODE>
MY_PROTOTYPE</CODE>
&quot; that you can insert later into the definitions of your real messages. All other parts of the message definition are the same as would be declared with <CODE>
@message</CODE>
 (with <CODE>
@message</CODE>
 left off).</DD>
</DL>
<P CLASS="figTitle">
Code Display 5-8 <A NAME="GOCLanguage_10.htm_26009">
 </A>
Aliasing Messages</P>
<PRE>	/* MyClass in this example uses both prototype and aliased messages. */
@class MyClass, MetaClass;
	/* The following is a normal message declaration. The register that this
	 * parameter uses is specified because the handler (method) is written in
	 * assembly language. */
@message void MSG_MESSAGE_WITH_WORD(byte flag = cl, word value = dx);</PRE>
<PRE>	/* The following message invokes the same method as the alias above.
	 * It has the same message number but passes a different sized parameter
	 * in different registers. */
@alias(MSG_MESSAGE_WITH_WORD) void MSG_MESSAGE_WITH_DWORD(byte flag = cl,
							dword value = dx:bp);</PRE>
<PRE>	/* The following message is not used. Its pass and return values can
	 * be used elsewhere, however, to ensure that all handlers of this message
	 * type are given the same format. */
@prototype int MSG_MYCLASS_PROTO(int a, int b);</PRE>
<PRE>	/* The following have the same return values and parameters
	 * as the prototype above. */
@message(MSG_MYCLASS_PROTO) MSG_MY_CLASS_ADD;
@message(MSG_MYCLASS_PROTO) MSG_MY_CLASS_SUBTRACT;
@message(MSG_MYCLASS_PROTO) MSG_MY_CLASS_MULTIPLY;</PRE>
<PRE>@endc
@classdecl MyClass;</PRE>



<H4 CLASS="HeadingC">
<A NAME="GOCLanguage_10.htm_87922">
 </A>
Defining Instance Data Fields</H4>
<PRE>@instance, @composite, @link, @visMoniker, @kbdAccelerator</PRE>
<P>
<A NAME="GOCLanguage_10.htm_IX_@instance[;instance]">
 </A>
<A NAME="GOCLanguage_10.htm_IX_Instance data:Goc syntax">
 </A>
Instance data fields are all defined with the <CODE>
@instance</CODE>
 keyword. Other keywords may be included in the <CODE>
@instance</CODE>
 declaration for special types of data. All instance data definitions must appear between the class' <CODE>
@class</CODE>
 and <CODE>
@endc</CODE>
 keywords (see above under class definition).</P>
<P>
The <CODE>
@instance</CODE>
 keyword is used to define normal instance data. If you have data that must be added or removed dynamically (such as hints), use the <CODE>
@vardata</CODE>
 keyword, described in <A HREF="#GOCLanguage_10.htm_54822"> Defining and Working With Variable Data Fields</A>
. Also, if you have data that requires relocation (such as pointers to fixed data) when the object is loaded, use the <CODE>
@reloc</CODE>
 keyword.</P>
<P>
The format of the <CODE>
@instance</CODE>
 keyword is as follows:</P>
<PRE>@instance    &lt;insType&gt;    &lt;iname&gt; = &lt;default&gt;;</PRE>
<DL>
<DT>
<STRONG>
insType</STRONG>
</DT><DD>A standard C or GEOS data or structure type representing the data type of the instance field.</DD>
<DT>
<STRONG>
iname</STRONG>
</DT><DD>The name of the instance field.</DD>
<DT>
<STRONG>
default</STRONG>
</DT><DD>The default value of the instance field if it is not filled in when an object of this class is instantiated. The value must, of course, be appropriate for the data type.</DD>
</DL>
<P>
Goc has several special types of instance data fields that you can declare along with <CODE>
@instance</CODE>
 to make object definition easier. The format for using one of the special types is shown below (with examples in <A HREF="#GOCLanguage_10.htm_99888"> Declaring Instance Data Fields</A>
). Each of the types is also described below.</P>
<PRE>@instance    &lt;specType&gt; &lt;iname&gt;;</PRE>
<DL>
<DT>
<STRONG>
specType</STRONG>
</DT><DD>This is the keyword (one of those shown in the list below) that defines the special type of this field.</DD>
<DT>
<STRONG>
iname</STRONG>
</DT><DD>This is the name of the instance field.</DD>
</DL>
<P>
The special types are given here:</P>
<DL>
<DT>
<CODE>
@composite</CODE>
<A NAME="GOCLanguage_10.htm_IX_@composite[;composite]">
 </A>
</DT><DD>This field is used when objects of the class being defined are allowed to have children. The <CODE>
@composite</CODE>
 field will actually contain an optr to the first child object in an object tree. Since most objects in object trees are subclassed from <CODE>
VisClass</CODE>
 or <CODE>
GenClass</CODE>
, you will most likely never use the <CODE>
@composite</CODE>
 keyword. Both <CODE>
VisCompClass</CODE>
 and <CODE>
GenClass</CODE>
 have <CODE>
@composite</CODE>
 fields predefined. The <CODE>
@composite</CODE>
 type has a special format, shown below:</DD>
<PRE>@instance  @composite &lt;iname&gt; = &lt;linkName&gt;;</PRE>
<DT>
</DT><DD>where <CODE>
iname</CODE>
 is the name of the instance field and <CODE>
linkName</CODE>
 is the name of the field designated as <CODE>
@link</CODE>
 (below). Note that there must be a <CODE>
@link</CODE>
 field in every class that has a <CODE>
@composite</CODE>
 field. See <A HREF="#GOCLanguage_15.htm_95668"> Managing Object Trees</A>
 for more information on object trees and the composite and link fields.</DD>
<DT>
<CODE>
@link</CODE>
<A NAME="GOCLanguage_10.htm_IX_@link[;link]">
 </A>
</DT><DD>This field is used by objects that can be children in an object tree. Where the <CODE>
@composite</CODE>
 field points to the first child, the <CODE>
@link</CODE>
 field points to the next sibling. If there is no next sibling, this field will point back to the parent object. Since most objects in object trees are subclassed from <CODE>
VisClass</CODE>
 or <CODE>
GenClass</CODE>
, you will most likely never use the <CODE>
@link</CODE>
 keyword. Both <CODE>
VisClass</CODE>
 and <CODE>
GenClass</CODE>
 have <CODE>
@link</CODE>
 fields predefined.</DD>
<DT>
<CODE>
@visMoniker</DT><DD>
</CODE>
<A NAME="GOCLanguage_10.htm_IX_Chunks:declaring with @visMoniker">
 </A>
This field is designated as holding a pointer to a visual moniker chunk for the object. It is used in <CODE>
GenClass</CODE>
--see <A HREF="../../SysObjects/Gen/combo.htm">the GenClass chapter</A>for information on the <CODE>
GI_visMoniker</CODE>
 field. The moniker or moniker list must be in the same resource as the generic object using that moniker since only the chunk's handle is stored. A moniker list can store full object pointers to its monikers, so monikers referenced by a list need not be in the same resource as that list; thus if an object's moniker is specified via a list, then while the list must be in the same resource as the object, the monikers themselves need not be.</DD>
<DT>
<CODE>
@kbdAccelerator</DT><DD>
</CODE>
This field contains a character sequence that, when typed by the user, causes the object to execute its default operation. For example, a keyboard accelerator could invoke a trigger implemented as a menu item. It is used in <CODE>
GenClass</CODE>
 only.</DD>
</DL>
<P CLASS="figTitle">
Code Display 5-9 <A NAME="GOCLanguage_10.htm_99888">
 </A>
Declaring Instance Data Fields</P>
<PRE>/* GenClass is a good example of many of the different types of fields. */</PRE>
<PRE>@class	GenClass, VisClass, master, variant;</PRE>
<PRE>	/* The GenClass messages are defined here. */</PRE>
<PRE>    @instance @link GI_link;
    @instance @composite GI_comp = GI_link;
    @instance @visMoniker GI_visMoniker;
    @instance @kbdAccelerator GI_kbdAccelerator;
    @instance byte GI_attrs = 0;
    @instance byte GI_states = (GS_USABLE|GS_ENABLED);</PRE>
<PRE>	/* Hints and other variable data fields are defined with @vardata. */</PRE>
<PRE>@endc</PRE>


<H4 CLASS="HeadingC">
New Defaults for Subclassed Instance Data Fields</H4>
<PRE>@default</PRE>
<P>
Recall that when defining an instance data field you can set up a default value for that field. When creating a subclass, you may wish to specify that the subclass should have a different default value for a given field than the superclass does. Use the <CODE>
@default</CODE>
 keyword to do this:</P>
<PRE>@default &lt;iname&gt; = &lt;default&gt;;</PRE>
<DL>
<DT>
<STRONG>
iname</STRONG>
</DT><DD>The name of the instance field.</DD>
<DT>
<STRONG>
default</STRONG>
</DT><DD>The new default value of the instance field if it is not filled in when an object of this class is instantiated. The value must, of course, be appropriate for the data type. You may use <CODE>
@default</CODE>
 as part of this value; this @default will be treated as the value of the superclass. (If this seems confusing, try looking at the example.)</DD>
</DL>
<P>
For example, a subclass of GenInteraction could set GIV_DIALOG as its default value for the GenInteraction instance field <CODE>
GII_visibility</CODE>
:</P>
<PRE>@default GII_visibility = GIV_DIALOG;</PRE>
<P>
A generic class might want to have the same value for its <CODE>
GI_states</CODE>
 field as its superclass, except with the GS_USABLE flag turned off:</P>
<PRE>@default GI_states = @default &amp; ~GS_USABLE;</PRE>


<H4 CLASS="HeadingC">
<A NAME="GOCLanguage_10.htm_54822">
 </A>
Defining and Working With Variable Data Fields</H4>
<PRE>@vardata, @vardataAlias, ObjVarAddData(), ObjVarDeleteData(), ObjVarDeleteDataAt(), ObjVarScanData(), ObjVarFindData(), ObjVarDerefData(), ObjVarDeleteDataRange(), ObjVarCopyDataRange(), MSG_META_ADD_VAR_DATA, MSG_META_DELETE_VAR_DATA, MSG_META_INITIALIZE_VAR_DATA, MSG_META_GET_VAR_DATA</PRE>
<P>
<A NAME="GOCLanguage_10.htm_IX_Variable data:Goc syntax">
 </A>
Most classes will have well-defined instance data fields; each object in the class will have the same data structures, and all the instance chunks will look relatively similar and will be the same size.</P>
<P>
Many classes, however, will also use &quot;variable data,&quot; or instance fields that may be added or removed dynamically. This allows objects within the same class to have more or less instance data than other objects in the class. One example of variable data is the use of hints in generic UI objects. Because each object in a given class may or may not have hints, the objects can actually have different instance sizes. Variable data instance fields are defined with the use of the <CODE>
@vardata</CODE>
 keyword.</P>
<P>
Using variable data, however, is somewhat more complex than using standard instance data. You must use special kernel routines or messages to get a pointer to the data; then you can use the pointer to access the field.</P>
<P>
Variable data is stored together at the end of the instance chunk in &quot;data entries.&quot; Each entry consists of a primary word and optional extra data. The primary word represents a data type defined by the keyword <CODE>
@vardata</CODE>
. This type is created automatically by Goc when the <CODE>
@vardata</CODE>
 keyword is used.
<IMG SRC="GOCLanguage_10_messageNumbers.gif">

</P>
<P>
Each data entry is associated with a master class level and is considered part of the instance data for that master level (despite being stored at the end of the instance chunk). Thus, when a master part of an object is destroyed, the variable data entries associated with that master class will also be destroyed. For example, when a UI object is set not usable (taken off the screen), its Vis master part is removed from the instance chunk; any variable data entries associated with <CODE>
VisClass</CODE>
 will also be destroyed.</P>
<P>
Variable data may also be tagged for saving to the state file. That is, you can set up individual data entries to be saved to a state file and to be reinstated when the object is loaded from the state file. For more information about state saving, see <A HREF="#GOCLanguage_15.htm_73804"> Saving Object State</A>
.</P>
<P>
Variable data may be defined in an object's declaration in your <STRONG CLASS="fileName">
.goc</STRONG>
 file or may be added and removed during execution. This gives the potential for using variable data as temporary storage in an object's instance chunk; however, temporary data used in this manner should be kept small to avoid slowing down the system--constantly resizing instance chunks to add and remove vardata fields makes more work for the memory manager.</P>
<P>
<A NAME="GOCLanguage_10.htm_IX_@vardata[;vardata]">
 </A>
To define a variable data type in a given class, use the <CODE>
@vardata</CODE>
 keyword as follows (an example is given in <A HREF="#GOCLanguage_10.htm_61839"> Defining Variable Data</A>
):</P>
<PRE>@vardata    &lt;type&gt; &lt;vname&gt;;</PRE>
<DL>
<DT>
<STRONG>
type</STRONG>
</DT><DD>This is the data type of any extra data associated with the variable data. It must be a standard C or GEOS data type. If the type <CODE>
void</CODE>
 is specified, no extra data will be added to the data entry when it is created. (An instance data field may be declared as an array, just as in standard C.)</DD>
<DT>
<STRONG>
vname</STRONG>
</DT><DD>This is the name of the variable data type. This name is used whenever referring to the vardata entry. Note that no two variable data types should have the same name, even if they're in different classes. Doing so will cause a compilation error. It's a good practice to put the class name within the data type name.</DD>
</DL>
<P CLASS="figTitle">
Code Display 5-10 Examples of Instance Data Declarations</P>
<PRE>/* These are some data fields for MyDataClass.
 */</PRE>
<PRE>    @instance		ChunkHandle		MDI_aChunk;
    @instance		HelloInfoFlags		MDI_flags;
    @instance		byte		MDI_lotsOfNumbers[32];</PRE>
<P>
<A NAME="GOCLanguage_10.htm_IX_@vardataAlias[;vardataAlias]">
 </A>
Some vardata types may have varying amounts of extra data. For example, one type may have either a word or a dword of extra data. To allow this, you can set up an alias with the new type attached using the keyword <CODE>
@vardataAlias</CODE>
:</P>
<PRE>@vardataAlias  (&lt;origName&gt;) &lt;newType&gt; &lt;newName&gt;;</PRE>
<DL>
<DT>
<STRONG>
origName</STRONG>
</DT><DD>This is the name of the original variable data field already defined with <CODE>
@vardata</CODE>
.</DD>
<DT>
<STRONG>
newType</STRONG>
</DT><DD>This is the data type of the new variable data field, a standard C or GEOS data type.</DD>
<DT>
<STRONG>
newName</STRONG>
</DT><DD>This is the name of the new variable data field. In essence, the original and new fields will have the same data type word but will have different extra data size.</DD>
</DL>
<P>
<A NAME="GOCLanguage_10.htm_IX_VarDataFlags">
 </A>
As noted earlier, the data type field in the data entry has two flags associated with it. These flags are each one bit:</P>
<DL>
<DT>
VDF_EXTRA_DATA</DT><DD>
<A NAME="GOCLanguage_10.htm_IX_VDF_EXTRA_DATA">
 </A>
This flag indicates that this data type carries extra data.</DD>
<DT>
VDF_SAVE_TO_STATE</DT><DD>
<A NAME="GOCLanguage_10.htm_IX_VDF_SAVE_TO_STATE">
 </A>
This flag indicates that this particular data entry should be saved along with all the other object's instance data when the state is saved. It should likewise be restored when the object is restored from the state file. Unless set <CODE>
off</CODE>
 explicitly, this flag will be set for every data type defined in a <STRONG CLASS="fileName">
.goc</STRONG>
 or <STRONG CLASS="fileName">
.goh</STRONG>
 file.</DD>
</DL>
<P>
The bitmask VDF_TYPE is a bitwise OR of VDF_EXTRA_DATA and VDF_SAVE_TO_STATE. You can use it to mask out all but those bits.</P>
<P CLASS="figTitle">
Code Display 5-11 <A NAME="GOCLanguage_10.htm_61839">
 </A>
Defining Variable Data</P>
<PRE>/* Hints are defined with the @vardata command, as is shown in GenClass. Only a
 * small portion of the hints for GenClass are shown here. Those with structures
 * or data types (not &quot;void&quot;) have extra data fields associated with them. */</PRE>
<PRE>@class GenClass, VisClass, master, variant;
	/* Messages are defined here. */
	/* Followed by instance data defined with @instance. */
    @vardata void HINT_CENTER_MONIKER;
    @vardata SpecSizeSpec HINT_CUSTOM_CHILD_SPACING;
    @vardata char[] ATTR_GEN_INIT_FILE_KEY;</PRE>
<PRE>	/* Relocatable instance fields (see the next section) are defined with
	 * @reloc. This field contains an object pointer that must be resolved
	 * when the GenClass object is loaded. */
    @instance @link GI_link;
	@reloc GI_link, optr;
    @vardata DestinationClassArgs ATTR_GEN_DESTINATION_CLASS;
	@reloc ATTR_GEN_DESTINATION_CLASS, 0, optr;
@endc</PRE>
<P>
The kernel provides a number of routines an object may use to add, remove, and change its own vardata entries. Note that all these routines must be called from within the object containing the variable data entries; since variable data is instance data, it is against OOP doctrine for one object to alter another object's variable data directly.</P>
<P>
Instead, <CODE>
MetaClass</CODE>
 provides vardata messages that can be sent by one object to another to add, remove, change, or retrieve vardata entries of another object. The kernel routines and <CODE>
MetaClass</CODE>
 messages are outlined below:</P>
<UL>
<LI>
<CODE>
ObjVarAddData()<BR>
</CODE>
<A NAME="GOCLanguage_10.htm_IX_ObjVarAddData()">
 </A>
This routine adds an new entry for the passed data type or replaces the extra data associated with a particular data type entry.</LI>
<LI>
<CODE>
ObjVarDeleteData()<BR>
</CODE>
<A NAME="GOCLanguage_10.htm_IX_ObjVarDeleteData()">
 </A>
This routine deletes the entry for a particular data type when passed the data type.</LI>
<LI>
<CODE>
ObjVarDeleteDataAt()<BR>
</CODE>
<A NAME="GOCLanguage_10.htm_IX_ObjVarDeleteDataAt()">
 </A>
This routine deletes a particular data entry when passed the entry's pointer as returned by <CODE>
ObjVarAddData()</CODE>
, <CODE>
ObjVarFindData()</CODE>
, or <CODE>
ObjVarDerefData()</CODE>
.</LI>
<LI>
<CODE>
ObjVarScanData()<BR>
</CODE>
<A NAME="GOCLanguage_10.htm_IX_ObjVarScanData()">
 </A>
This routine causes the kernel to scan all data entries in an object's variable data and call any &quot;handler routines&quot; listed for them. This process is described below.</LI>
<LI>
<CODE>
ObjVarFindData()<BR>
</CODE>
<A NAME="GOCLanguage_10.htm_IX_ObjVarFindData()">
 </A>
This routine searches for and returns (if possible) a pointer to a data entry of the passed data type.</LI>
<LI>
<CODE>
ObjVarDerefData()<BR>
</CODE>
<A NAME="GOCLanguage_10.htm_IX_ObjVarDerefData()">
 </A>
This routine returns a pointer to a data entry when passed the object's optr and the data type. If the entry does not exist, this routine will call on the object to create and initialize the entry. Such variable data then behaves much like instance data. The object containing the vardata is responsible for creating the entry and then initializing it upon receipt of a <CODE>
MSG_META_INITIALIZE_VAR_DATA</CODE>
, described below.</LI>
<LI>
<CODE>
ObjVarDeleteDataRange()<BR>
</CODE>
<A NAME="GOCLanguage_10.htm_IX_ObjVarDeleteDataRange()">
 </A>
This routine deletes all data entries with types in the passed range.</LI>
<LI>
<CODE>
ObjVarCopyDataRange()<BR>
</CODE>
<A NAME="GOCLanguage_10.htm_IX_ObjVarCopyDataRange()">
 </A>
This routine copies all data entries within the passed range from one object's instance chunk to another`s. If any entries are copied, the destination object will be marked dirty for saving. This routine must be called by the destination object; it is bad policy for one object to alter another object's instance data. This routine is primarily for copying hints from one UI object to another and is not commonly used by applications.</LI>
</UL>
<P>
The four messages (in <CODE>
MetaClass</CODE>
) that can be used to add, delete, and alter variable data entries remotely are listed below. Classes will never need to intercept and subclass these messages because the proper functionality is implemented in <CODE>
MetaClass</CODE>
.</P>
<DL>
<DT>
<CODE>
MSG_META_ADD_VAR_DATA</DT><DD>
</CODE>
<A NAME="GOCLanguage_10.htm_IX_MSG_META_ADD_VAR_DATA">
 </A>
Adds a new vardata type to the recipient object. If the type already exists, the passed type replaces the old one.</DD>
<DT>
<CODE>
MSG_META_DELETE_VAR_DATA</DT><DD>
</CODE>
<A NAME="GOCLanguage_10.htm_IX_MSG_META_DELETE_VAR_DATA">
 </A>
Deletes a vardata type from the recipient's instance data. If the type does not exist, nothing is done.</DD>
<DT>
<CODE>
MSG_META_INITIALIZE_VAR_DATA</DT><DD>
</CODE>
<A NAME="GOCLanguage_10.htm_IX_MSG_META_INITIALIZE_VAR_DATA">
 </A>
Used when something is trying to access an object's vardata field remotely but the field has not yet been added to the object or initialized. The object must create and/or initialize the vardata field at this point.</DD>
<DT>
<CODE>
MSG_META_GET_VAR_DATA</DT><DD>
</CODE>
<A NAME="GOCLanguage_10.htm_IX_MSG_META_GET_VAR_DATA">
 </A>
Returns the extra data set for the passed data type.</DD>
</DL>
<P>
In addition to supporting variable data structures, GEOS allows you to set up &quot;handlers&quot; for different variable data types. Handlers are routines that process a given data entry; for example, each generic UI object stores a number of hints. Specific UI classes, when attached to the generic object, have a specific routine to handle each hint supported. Some specific UIs do nothing with certain hints; these specific UIs do not have handlers for those hints.</P>
<P>
<A NAME="GOCLanguage_10.htm_IX_VarDataCHandler tables">
 </A>
Handlers are associated with data types through the use of a <CODE>
VarDataCHandler</CODE>
 table. This is a table that you set up in your <STRONG CLASS="fileName">
.goc</STRONG>
 file that contains pairings of routine names with <CODE>
@vardata</CODE>
 field names. An example of the <CODE>
VarDataCHandler</CODE>
 table is shown in <A HREF="#GOCLanguage_10.htm_98877"> Variable Data Handlers</A>
.</P>
<P>
A handler is simply a normal C routine or function and is defined as such. The handler should be declared as an <CODE>
_pascal</CODE>
 routine.The table pairs the handler with the <CODE>
@vardata</CODE>
 data type, and when <CODE>
ObjVarScanData()</CODE>
 is called, all handlers for all data types are called in order. This is true for the object's class and all its superclasses since variable data is inherited just as normal instance data is. The handler can do almost anything appropriate with the exception of destroying the object or adding or deleting variable data from the object.</P>
<P CLASS="figTitle">
Code Display 5-12 <A NAME="GOCLanguage_10.htm_98877">
 </A>
Variable Data Handlers</P>
<PRE>	/* This example is taken from the C VarData sample application. */</PRE>
<PRE>/* This is a VarDataCHandler. It is called by the ObjVarScanData() routine when
 * the data type corresponding to this routine in the VarDataCHandlerTable
 * is encountered. The parameters indicated are passed.
 *
 * This particular handler is actually used for several different data types
 * (see VarDataCHandlerTable below). The data type can be distinguished by
 * the `dataType' parameter. 
 *
 * NOTE: VarDataInteractionHintHandler, like any handler used in a 
 * VarDataCHandler structure, must be declared _pascal. */</PRE>
<PRE>void _pascal VarDataInteractionHintHandler(MemHandle mh, ChunkHandle chnk, 
		void *data, word dataType, HandlerData *handlerData) {</PRE>
<PRE>    if (dataType == HINT_ORIENT_CHILDREN_HORIZONTALLY) {
	handlerData-&gt;HD_flags.has_horiz = 1;
    } else if (dataType == HINT_ORIENT_CHILDREN_VERTICALLY) {
	handlerData-&gt;HD_flags.has_vert = 1;
    } else if (dataType == HINT_ALLOW_CHILDREN_TO_WRAP) {
	handlerData-&gt;HD_flags.has_allow_wrap = 1;
    } else if ((dataType == HINT_WRAP_AFTER_CHILD_COUNT) &amp;&amp;
		(((WrapAfterChildCountData *) data)-&gt;WACCE_childCount == 2)) {
	handlerData-&gt;HD_flags.has_wrap_after = 1;
    }
}</PRE>
<PRE>/* This is the VarDataCHandler Table. It consists of data type/VarDataCHandler
 * pairs. The VarDataCHandlers are far routines. */</PRE>
<PRE>static VarDataCHandler varDataInteractionHandlerTable[] = {
    {HINT_ORIENT_CHILDREN_HORIZONTALLY, VarDataInteractionHintHandler},
    {HINT_ORIENT_CHILDREN_VERTICALLY, VarDataInteractionHintHandler},
    {HINT_ALLOW_CHILDREN_TO_WRAP, VarDataInteractionHintHandler},
    {HINT_WRAP_AFTER_CHILD_COUNT, VarDataInteractionHintHandler}
};</PRE>


<H4 CLASS="HeadingC">
Defining Relocatable Data</H4>
<PRE>@reloc</PRE>
<P>
<A NAME="GOCLanguage_10.htm_IX_Relocatable data:goc syntax">
 </A>
Some objects and classes may have instance data fields that must be resolved when the object is loaded and linked at run-time. For example, if the object contains an optr to another object, that optr must be updated when the object is loaded and resolved since the global memory handle can't be known at compile-time.</P>
<P>
<A NAME="GOCLanguage_10.htm_IX_@reloc[;reloc]">
 </A>
For some special instance fields, this happens automatically. For example, the <CODE>
@composite</CODE>
 and <CODE>
@link</CODE>
 fields as well as optrs are automatically resolved. However, if you add your own instance fields requiring relocation, you will have to set them up with the <CODE>
@reloc</CODE>
 keyword. This is true for both static and variable data.</P>
<P>
This keyword uses two formats. The first listed here is for normal, static instance data, and the second is used with variable data.</P>
<PRE><A NAME="GOCLanguage_10.htm_52446"> </A>@reloc    &lt;iname&gt;, [(&lt;count&gt;, &lt;struct&gt;)] &lt;ptrType&gt;;</PRE>
<DL>
<DT>
<STRONG>
iname</STRONG>
</DT><DD>This is the name of the relocatable instance field.</DD>
<DT>
<STRONG>
count</STRONG>
</DT><DD>If the instance variable is an array of relocatable data or structures containing relocatable fields, this is the number of elements in the array.</DD>
<DT>
<STRONG>
struct</STRONG>
</DT><DD>If the relocatable data is an array of structures, this represents the name of the field within each structure that requires relocation.</DD>
<DT>
<STRONG>
ptrType</STRONG>
</DT><DD>This is the type of relocatable data contained in the field. It may be one of <CODE>
optr</CODE>
, <CODE>
ptr</CODE>
, or <CODE>
handle</CODE>
.</DD>
<PRE>@reloc &lt;vname&gt;, &lt;fn&gt;, [(&lt;count&gt;, &lt;struct&gt;)] ptrType;</PRE>
<DT>
<STRONG>
vname</STRONG>
</DT><DD>This is the name of the variable data type.</DD>
<DT>
<STRONG>
fn</STRONG>
</DT><DD>This is the name of the field within the variable data's extra data. If there is no extra data with this data type, put a zero rather than a name.</DD>
<DT>
<STRONG>
count</STRONG>
</DT><DD>If the instance variable is an array of relocatable data or structures containing relocatable fields, this is the number of elements in the array.</DD>
<DT>
<STRONG>
struct</STRONG>
</DT><DD>If the relocatable data is an array of structures, this represents the name of the field within each structure that requires relocation.</DD>
<DT>
<STRONG>
ptrType</STRONG>
</DT><DD>This is the type of relocatable data contained in the field. It may be one of <CODE>
optr</CODE>
, <CODE>
ptr</CODE>
, or <CODE>
handle</CODE>
.</DD>

</DL>
<HR>
<A NAME="GOCLanguage_11.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">GEOS Programming</A>: 4.2 <A HREF="#GOCLanguage_f.htm">Using Classes and Objects</A>: 
Non-relocatable Data</H3>
<PRE><A NAME="GOCLanguage_11.htm_IX_@noreloc[;noreloc]"> </A>@noreloc</PRE>
<P>
To force an instance data field which would normally be relocatable (e.g., an optr) to not be relocatable, use the <CODE>
@noreloc</CODE>
 keyword. Use this keyword together with the name of the field to be marked non-relocatable directly after defining the instance field itself as shown in <A HREF="#GOCLanguage_11.htm_83062"> Use of the @noreloc Keyword</A>
.</P>
<P CLASS="figTitle">
Code Display 5-13 <A NAME="GOCLanguage_11.htm_83062">
 </A>
Use of the @noreloc Keyword</P>
<PRE>	@instance optr MCI_ruler;				/* Normally MCI_ruler would be reloc... */
	@noreloc MCI_ruler;				/* ...but now it isn't. */</PRE>
<HR>
<A NAME="GOCLanguage_12.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">GEOS Programming</A>: 4.3 <A HREF="#GOCLanguage_f.htm">Using Classes and Objects</A>: 
Defining Methods</H3>
<PRE>@method, @extern</PRE>
<P>
<A NAME="GOCLanguage_12.htm_IX_Methods:goc syntax">
 </A>
Methods are the routines executed when an object receives a message. Each class understands a certain set of messages; each of these has a place in the class' method table and corresponds to one method.</P>
<P>
<A NAME="GOCLanguage_12.htm_IX_@method[;method]">
 </A>
Although methods are class-specific, they are not defined between the <CODE>
@class</CODE>
 and <CODE>
@endc</CODE>
 of class definition. Instead, their declaration line links them to a single class and to a specific message. Goc, Glue, and GEOS build each class' method table automatically; you do not have to create the table yourself.</P>
<P>
<A NAME="GOCLanguage_12.htm_28438">
 </A>
To define a method, use the <CODE>
@method</CODE>
 keyword. This has the following structure:</P>
<PRE>@method    [&lt;hname&gt;,] &lt;cname&gt;[, &lt;mname&gt;]+;</PRE>
<DL>
<DT>
<STRONG>
hname</STRONG>
</DT><DD>The handler name, if any. If you wish to use the method as a function, it must have a handler name. If you do not provide a handler name, Goc will create one for you. This name is useful for setting breakpoints when debugging. If you do not provide a name, Goc constructs the name by concatenating the class name (with the -Class suffix, if any, removed) with the message name (with the MSG_- prefix, if any, removed). For example, Goc would call <CODE>
MyClass</CODE>
' handler for <CODE>
MSG_DO_SOMETHING</CODE>
 &quot;MyDO_SOMETHING&quot;.</DD>
<DT>
<STRONG>
cname</STRONG>
</DT><DD>The name of the class to which this method belongs. Each method may belong to only one class.</DD>
<DT>
<STRONG>
mname</STRONG>
</DT><DD>The name of the message that invokes this method. The plus symbol indicates that one method may be invoked by more than one message as long as they all have the <EM>
same</EM>
 parameters and return values. At least one message must be specified. </DD>
<DT>
</DT><DD><A NAME="GOCLanguage_12.htm_IX__reloc[;reloc]">
 </A>
There is a special Goc keyword, <CODE>
_reloc</CODE>
, used in place of a message name when writing a method for <CODE>
MSG_META_RELOC</CODE>
 and <CODE>
MSG_META_UNRELOC</CODE>
. A method handling <CODE>
_reloc</CODE>
 will handle both <CODE>
MSG_META_RELOC</CODE>
 and <CODE>
MSG_META_UNRELOC</CODE>
; the method code can check the value of its message argument to find out which message is being handled.</DD>
</DL>
<P>
Note that the name of the method (the handler name) is optional. Parameters and return values are not put in the method declaration--these are defined with <CODE>
@message</CODE>
 as discussed in <A HREF="#GOCLanguage_e.htm_57260"> The GEOS Message System</A>
.</P>
<P>
If you will wish to call the method as a routine occasionally, your compiler will probably require that you provide a prototype for the routine. If your <CODE>
@message</CODE>
 declaration looks like</P>
<PRE>@message word MSG_MC_DO_SOMETHING(word thing);</PRE>
<P>
and your <CODE>
@method</CODE>
 declaration looks like</P>
<PRE>@method DoSomething, MyClass, MSG_MC_DO_SOMETHING {
/* Code Here */ }</PRE>
<P>
Then your protoype should look like</P>
<PRE>extern word _pascal DoSomething(optr oself,
					  MyMessages message,
					  word thing);</PRE>
<P>
The name of the type <CODE>
MyMessages</CODE>
 is constructed automatically by taking the name of the class, removing the &quot;Class&quot; suffix, and replacing said suffix with &quot;Messages&quot;.</P>
<P>
<A NAME="GOCLanguage_12.htm_IX_@extern:with methods[;extern:with methods]">
 </A>
Normally, all of a class' methods will be coded in the same code file in which the class is declared with <CODE>
@classdecl</CODE>
. If, however, you find you need to declare a class' methods in a different file, you can use the <CODE>
@extern</CODE>
 keyword to indicate a method is defined and/or used in a different object file. Goc will give no error if <CODE>
@extern</CODE>
 is used and the method exists nowhere; Glue, however, will give a linking error in such a case. There is no such requirement, however, if you are putting only the class definition (the definitions between <CODE>
@class</CODE>
 and <CODE>
@endc</CODE>
) in a different file. In this case, you can put the class definition in a <STRONG CLASS="fileName">
.goh</STRONG>
 header file and the method code in the same <STRONG CLASS="fileName">
.goc</STRONG>
 file as the <CODE>
@classdecl</CODE>
 statement; you must <CODE>
@include</CODE>
 the <STRONG CLASS="fileName">
.goh</STRONG>
 file, but you won't need to use the <CODE>
@extern</CODE>
 directive (as long as the method code is in the same file as the <CODE>
@classdecl</CODE>
 directive).</P>
<P>
The format for using <CODE>
@extern</CODE>
 is as follows:</P>
<PRE>/* In the file in which the class is declared with  * @classdecl:
 */
    @extern method &lt;cname&gt;, &lt;mname&gt;+;</PRE>
<PRE>/* In the file containing the method code: */
    @extern method &lt;cname&gt;, &lt;mname&gt;+ {
        ...method code goes here...
    }</PRE>
<DL>
<DT>
<STRONG>
cname</STRONG>
</DT><DD>The name of the class for which the method is defined.</DD>
<DT>
<STRONG>
mname</STRONG>
</DT><DD>The name of the message which invokes the method. Note that external method definitions, like normal method definitions, can handle more than one message.</DD>
</DL>
<P>
Three parameters are passed automatically with messages and do not have to be declared in the <CODE>
@message</CODE>
 definition. They are important to know when writing methods, however, because they can greatly simplify your code. These are standard parameters for all classes except <CODE>
ProcessClass</CODE>
 and its subclasses below:</P>
<DL>
<DT>
<STRONG>
pself</STRONG>
</DT><DD><A NAME="GOCLanguage_12.htm_IX_ObjDerefGen():with pself">
 </A>
<A NAME="GOCLanguage_12.htm_IX_ObjDerefVis():with pself">
 </A>
<A NAME="GOCLanguage_12.htm_IX_pself">
 </A>
A far pointer to the object's instance data. <EM>pself</EM> points to the master group for the class for which the handler is defined. Note that this pointer may be invalidated by message calls so it is preferable to use the GOC directive, <CODE>
@self</CODE>
, instead. Unlike <EM>pself</EM>, <CODE>
@self</CODE>
 is always valid.</DD>
<DT>
<STRONG>
oself</STRONG>
</DT><DD><A NAME="GOCLanguage_12.htm_IX_oself">
 </A>
An optr to the object's instance data. It contains the global memory handle and chunk handle of the instance chunk. This can be used for routines that act on the object's instance data.</DD>
<DT>
<STRONG>
message</STRONG>
</DT><DD><A NAME="GOCLanguage_12.htm_IX_message (method parameter)">
 </A>
The message number of the message being handled.</DD>
</DL>
<P>
<A NAME="GOCLanguage_12.htm_IX_ProcessClass:oself and pself">
 </A>
As mentioned, <CODE>
ProcessClass</CODE>
 is a special type of class. It has no true instance data because it uses the standard PC structure of an application (idata, udata, etc.). It only has one standard parameter to each of its methods: the message that was sent to it. This is because the &quot;instance data&quot; of <CODE>
ProcessClass</CODE>
 includes all the global variables of your program. They are accessed automatically, no <EM>oself</EM> or <CODE>
@self</CODE>
 is required.</P>
<P CLASS="figTitle">
Code Display 5-14 <A NAME="GOCLanguage_12.htm_36801">
 </A>
A Class Definition</P>
<PRE>/* The class ValClass defines four messages that invoke four different methods. The
 * entire class is shown in this example; it will function properly if coded this
 * way. Note that the methods have the class name in their declaration line
 * and thus do not appear within the class definition. */</PRE>
<PRE>@class ValClass, MetaClass;</PRE>
<PRE>@instance int value;			/* instance data value: an uninitialized integer */</PRE>
<PRE>	/* message declarations 
	 * All four messages will be handled by this class. They return
	 * the types shown and take the parameters defined. */
@message int MSG_VAL_GET_VALUE();
@message void MSG_VAL_SET_VALUE(int newValue);
@message void MSG_VAL_NEGATE_VALUE();
@message Boolean MSG_VAL_IS_VALUE_BIGGER_THAN(int newValue);</PRE>
<PRE>@endc
@classdecl ValClass;			/* the class structure must be put in memory */</PRE>
<PRE>	/* Method Declarations
	 * Each of the four methods is a single line of code. Note that the
	 * parameters are automatically defined in the message definition and do
	 * not need to be restated in the method definition. The same is true of
	 * the return type. Note also that the class and message names appear in
	 * the @method line. */</PRE>
<PRE>@method	ValGetValue, MyClass, MSG_VAL_GET_VALUE {
    return(@self-&gt;value);
}</PRE>
<PRE>@method	ValSetValue, MyClass, MSG_VAL_SET_VALUE {
    @self-&gt;value = newValue;
}</PRE>
<PRE>@method	ValNegateVal, MyClass, MSG_VAL_NEGATE_VALUE {
    @self-&gt;value *= -1;
}</PRE>
<PRE>@method	 ValClass, MSG_VAL_IS_VALUE_BIGGER_THAN {
	/* This handler's name will automatically be created to be
	 * ValVAL_IS_VALUE_BIGGER_THAN. You can use this name as a
	 * C function call from within the same thread. */
    return(@self-&gt;value &gt; newValue);
}</PRE>
<P>
You may sometimes wish to call a method with normal C call-and-return conventions, rather than by sending a message. To do so, you will have to declare the method as a routine as well as a method. The declaration should have the following format:</P>
<PRE>extern &lt;type&gt; _pascal &lt;MethodName&gt;(
	optr					oself,
	&lt;TruncatedClassName&gt;Messages					message,
	&lt;type1&gt;					&lt;arg1&gt;,
	&lt;type2&gt;					&lt;arg2&gt;)</PRE>
<DL>
<DT>
<STRONG>
type</STRONG>
</DT><DD>This is the type returned by the method. It may be any data type.</DD>
<DT>
<STRONG>
MethodName</DT><DD>
</STRONG>
This is the name of the method. If you will be calling a method as a routine, you must give the method a name when you declare it (see <A HREF="#GOCLanguage_12.htm_28438"> To define a method, use the @method keyword. This has the following structure:</A>
). Use the same name here.</DD>
<DT>
<STRONG>
TruncatedClassName</DT><DD>
</STRONG>
This is the name of the class, without the word &quot;Class&quot;. The type of this argument is the truncated class name followed (with no space) by the word &quot;Messages&quot;. Thus, for &quot;HelloCounterClass&quot;, the truncated class name would be &quot;HelloCounter&quot;, and the type of this field would be &quot;HelloCounterMessages&quot;.</DD>
<DT>
<STRONG>
type</STRONG>
<EM>
n</EM>
<STRONG>
, arg</STRONG>
<EM>
n</EM>
 </DT><DD>Use these fields to declare each of the arguments passed to the message. Be sure to use exactly the same arguments, and in the same order, as in the message declaration.</DD>
</DL>
<P CLASS="figTitle">
Code Display 5-15 Declaring a Method As a Routine</P>
<PRE>@message int MSG_HELLO_COUNTER_RECALCULATE_VALUE( \
				HelloPriority 		priority, \
				word 		randomDatum, \
				char 		aLetter);</PRE>
<PRE>extern int _pascal HelloCounterRecalculateValue(
			optr			oself,
			HelloCounterMessages			message,
			HelloPriority			priority,
			word			randomDatum,
			char			aLetter);</PRE>
<PRE>@method	HelloCounterRecalculate, HelloCounterClass, \ 
		MSG_HELLO_COUNTER_RECALCULATE_VALUE {</PRE>
<PRE>	/* method code goes here... */</PRE>
<PRE>}</PRE>
<HR>
<A NAME="GOCLanguage_13.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">GEOS Programming</A>: 4.4 <A HREF="#GOCLanguage_f.htm">Using Classes and Objects</A>: 
<A NAME="GOCLanguage_13.htm_87013">
 </A>
Declaring Objects</H3>
<P>
<A NAME="GOCLanguage_13.htm_IX_Objects:goc syntax">
 </A>
In GEOS programs, you can instantiate objects in two ways: You can declare them in your source code with the <CODE>
@object</CODE>
 keyword, or you can instantiate them and fill in their instance data during execution. In most cases, you will probably do the former, especially with generic UI objects.</P>
<P>
Additionally, you can create resources and chunks with the <CODE>
@start, @end</CODE>
, <CODE>
@header</CODE>
, and <CODE>
@chunk</CODE>
 keywords. GEOS libraries also need an additional set of declarations in their definition (<STRONG CLASS="fileName">
.goh</STRONG>
) files; these declarations (<CODE>
@deflib</CODE>
 and <CODE>
@endlib</CODE>
) indicate that the code contained between them is part of the specified library.</P>

<H4 CLASS="HeadingC">
Defining Library Code</H4>
<PRE>@deflib, @endlib</PRE>
<P>
<A NAME="GOCLanguage_13.htm_IX_Libraries:@deflib in library header files">
 </A>
<A NAME="GOCLanguage_13.htm_IX_Header files:goc library files">
 </A>
<A NAME="GOCLanguage_13.htm_IX_@endlib[;endlib]">
 </A>
<A NAME="GOCLanguage_13.htm_IX_@deflib[;deflib]">
 </A>
If your geode is a library, it will likely have a number of <STRONG CLASS="fileName">
.goh</STRONG>
 files. Each of these files contains some portion of the library's code and is included by applications that use the library. The library code must be delimited by the two keywords <CODE>
@deflib</CODE>
 and <CODE>
@endlib</CODE>
, which have the following formats:</P>
<PRE>@deflib &lt;libname&gt;
@endlib</PRE>
<DL>
<DT>
<STRONG>
libname</STRONG>
</DT><DD>The permanent name of the library with the extender stripped off. For example, the UI library's name is ui.lib, and the format would then be</DD>
<PRE>@deflib ui
    /* library code here */
@endlib</PRE>
</DL>
<P>
Note that these two keywords are only necessary in files that define classes in the library. Files that have just code or data used in the library do not require them (though they are allowed).</P>


<H4 CLASS="HeadingC">
Declaring Segment Resources and Chunks</H4>
<PRE>@start, @end, @header, @chunk, @gstring, @chunkArray, @elementArray, @extern</PRE>
<P>
<A NAME="GOCLanguage_13.htm_IX_Resources:goc syntax">
 </A>
There are essentially three types of resources in GEOS: code resources containing routines and methods, object blocks containing object instance chunks (and often data chunks), and data resources containing only data chunks. Code resources are created automatically, and no declaration is required for them (unless you require special segments; then you should use the <EM>
pragmas</EM>
 appropriate for your C compiler).</P>
<P>
<A NAME="GOCLanguage_13.htm_IX_@header[;header]">
 </A>
<A NAME="GOCLanguage_13.htm_IX_@end[;end]">
 </A>
<A NAME="GOCLanguage_13.htm_IX_@start[;start]">
 </A>
Object blocks or other LMem resources are declared with <CODE>
@start</CODE>
 and <CODE>
@end</CODE>
. You can set a special header on a local memory resource with the <CODE>
@header</CODE>
 keyword. These are described below, and an example of declaring the resource block is given in <A HREF="#GOCLanguage_13.htm_91725"> Declaring Data Resources</A>
. Note that the <CODE>
@header</CODE>
 keyword must come between the <CODE>
@start</CODE>
 and <CODE>
@end</CODE>
 delimiters.</P>
<PRE>@start    &lt;segname&gt; [, &lt;flags&gt;];
@header   &lt;type&gt; [= &lt;init&gt;];
@end     &lt;segname&gt;</PRE>
<DL>
<DT>
<STRONG>
segname</STRONG>
</DT><DD>This is the name of the resource segment.</DD>
<DT>
<STRONG>
flags</STRONG>
</DT><DD>These are optional flags that determine two characteristics of the resource. If the flag <A NAME="GOCLanguage_13.htm_IX_data (@start flag)">
 </A>
<CODE>
data</CODE>
 is set, the block will be set to a data resource--the default is an object block. If the flag <CODE>
notDetachable</CODE>
<A NAME="GOCLanguage_13.htm_IX_notDetachable (@start flag)">
 </A>
 is set, the resource block will never be saved to a state file.</DD>
<DT>
<STRONG>
type</STRONG>
</DT><DD>This is the name of a structure type that will act as the header structure for the resource block. It must be some permutation of either <CODE>
LMemBlockHeader</CODE>
 (for non object blocks) or <CODE>
ObjLMemBlockHeader</CODE>
 (for object blocks).</DD>
<DT>
<STRONG>
init</STRONG>
</DT><DD>This is an initializer for the new header type. Typically, some data fields will be added on to the end of one of the standard LMem block headers. These fields may be filled in with initializer data with this optional argument.</DD>
</DL>
<P>
The resource elements (objects or chunks, for example) are also declared <A NAME="GOCLanguage_13.htm_IX_Chunks:declaring with @chunk">
 </A>
<A NAME="GOCLanguage_13.htm_IX_@chunk[;chunk]">
 </A>
within the <CODE>
@start</CODE>
 and <CODE>
@end</CODE>
 delimiters. The <CODE>
@chunk</CODE>
 keyword declares a data chunk and is shown below. For the <CODE>
@object</CODE>
 keyword, see the next section.</P>
<PRE>@chunk    &lt;type&gt; &lt;name&gt; [= &lt;init&gt;];</PRE>
<DL>
<DT>
<STRONG>
type</STRONG>
</DT><DD>This is the data type that will be held in the chunk.</DD>
<DT>
<STRONG>
name</STRONG>
</DT><DD>This is the name of the chunk. You may use this name as you would a variable name to reference the chunk.</DD>
<DT>
<STRONG>
init</STRONG>
</DT><DD>This is initializer data in the standard C format. If initializing a structure, make sure you put the data within curly braces.</DD>
</DL>
<P>
<A NAME="GOCLanguage_13.htm_Chunks">
 </A>
<A NAME="GOCLanguage_13.htm_GStrings">
 </A>
<A NAME="GOCLanguage_13.htm_@gstring[;gstring]">
 </A>
There is a special-case syntax for the declaration of a chunk which contains GString data. A GString is a stored series of graphics commands, discussed in detail in <A HREF="../../Graphics/Environment/Environment_15.htm">the Graphics Environment chapter</A>. Its syntax may be summarized:</P><PRE>@gstring &lt;name&gt; = { &lt;init&gt; };</PRE>
<DL>
<DT>
<STRONG>
name</STRONG>
</DT><DD>This is the name of the chunk. You may use this name as you would a variable name to reference the chunk.</DD>
<DT>
<STRONG>
init</STRONG>
</DT><DD>The is the initializer data. It is a series of bytes. Normally, a GString's data set up in a <CODE>
@gstring</CODE>
 chunk is set up by means of the <CODE>
GS...()</CODE>
 macros.</DD>
</DL>
<A NAME="GOCLanguage_13.htm_IX_Chunks:declaring with @chunkArray">
 </A>
<A NAME="GOCLanguage_13.htm_IX_@chunkArray[;chunkArray]">
 </A>
<A NAME="GOCLanguage_13.htm_IX_Chunks:declaring with @elementArray">
 </A>
<A NAME="GOCLanguage_13.htm_IX_@elementArray[;elementArray]">
 </A>
<P>
Two other types of resource elements may also be defined, both of which are 
array types. The <CODE>
@chunkArray</CODE>
 keyword declares a chunk array structure, 
and the <CODE>
@elementArray</CODE>
 keyword declares an element array structure. See <A HREF="../../Memory/LMem/combo.htm">the Local Memory chapter</A>, for information on the structure and usage of chunk and element arrays. These static arrays must <EM>not</EM> appear 
in a resource marked <CODE>data</CODE>; the resource may be marked 
<CODE>notDetachable</CODE> or may be unmarked.  In the <CODE>.gp</CODE> file, 
the resource should be marked <CODE>lmem</CODE>, optionally 
<CODE>read-only</CODE>.
The formats for the keywords are described below:</P>

<PRE>@chunkArray &lt;stype&gt; &lt;aname&gt; = {&lt;init&gt;};</PRE>
<PRE>@elementArray &lt;stype&gt; &lt;aname&gt; [ = {&lt;init&gt;} ];</PRE>
<DL>
<DT>
<STRONG>
stype</STRONG>
</DT><DD>This is the type of structure stored in the array.</DD>
<DT>
<STRONG>
aname</STRONG>
</DT><DD>This is the name of the array.</DD>
<DT>
<STRONG>
init</STRONG>
</DT><DD>This is any initializer data. If there is no initializer data (i.e., you want to declare an empty chunk array), you'll want a code snippet like the following:</DD>
<PRE>@chunk ChunkArrayHeader &lt;aname&gt; = {0,
    sizeof(&lt;stype&gt;), 0, sizeof(ChunkArrayHeader) };</PRE>
</DL>

<P>Here is an example showing two statically declared chunk arrays:</P>
<PRE>
#define CELL_DATA_LENGTH 15

typedef char CellDataStruct[CELL_DATA_LENGTH];

@chunkArray CellDataStruct headerDataArray = {
    "no", "Description",  "type", " $/lb"
};

@chunkArray CellDataStruct coffeeDataArray = {
    "0", "House Blend",  "PEET", "$ 6.95",
    "1", "Mocha-Java",   "PEET", "$10.75",
    "2", "Garuda Blend", "PEET", "$ 9.25",
    "3", "Italian Dark", "DARK", "$ 8.75",
    "4", "French Roast", "DARK", "$ 8.75",
    "5", "Sumatra",      "PACF", "$ 8.95",
    "6", "Sulawesi-Kal", "PACF", "$11.55",
    "7", "Java",         "PACF", "$ 8.75",
    "8", "Aged Java",    "PACF", "$ 9.75",
    "9", "Mexican",      "AMER", "$ 7.55"
};

</PRE>

<P>
One other keyword,<A NAME="GOCLanguage_13.htm_IX_@extern[;extern]">
 </A>
 <A NAME="GOCLanguage_13.htm_IX_Glue:externally declared chunks">
 </A>
<CODE>
@extern</CODE>
, allows you to use chunks from a different compilation session. The <CODE>
@extern</CODE>
 keyword can be used to reference remote (external) chunks, objects, and visual monikers. If the item referenced by <CODE>
@extern</CODE>
 is not actually defined anywhere, Glue will return an error when it tries to link the item. (Note also that Glue can not link through an external item; only one layer of external linkage is allowed. Thus, one object could not have an <CODE>
@extern</CODE>
 to a chunk that had an <CODE>
@extern</CODE>
 to a visMoniker.) Children in object trees may not be defined with <CODE>
@extern</CODE>
; Goc will produce an error in this case. The format of this keyword is as follows:</P>
<PRE>@extern chunk &lt;cname&gt;;
@extern object &lt;oname&gt;;
@extern visMoniker &lt;vmname&gt;;</PRE>
<DL>
<DT>
<STRONG>
cname</STRONG>
</DT><DD>This is the name of a chunk.</DD>
<DT>
<STRONG>
oname</STRONG>
</DT><DD>This is the name of an object.</DD>
<DT>
<STRONG>
vmname</STRONG>
</DT><DD>This is the name of a visMoniker chunk.</DD>
</DL>
<P CLASS="figTitle">
Code Display 5-16 <A NAME="GOCLanguage_13.htm_91725">
 </A>
Declaring Data Resources</P>
<PRE>/* This example declares a data block with three different chunks in it and
 * its own header type. */</PRE>
<PRE>typedef struct {
    LMemBlockHeader			MLMBH_meta;       /* basic header structure */
    int			MLMBH_numEntries;  /* the number of entries in the block */
} StudentBlockHeader;</PRE>
<PRE>@start StudentBlock, data;					/* data flag indicates LMem block */
@header StudentBlockHeader = 1;					/* initialize new header fields */</PRE>
<PRE>/* The three chunks are defined below. Each represents a single field associated
 * with a single student; that is why the header's MLMBH_numEntries field contains
 * one (rather than three). */</PRE>
<PRE>@chunk	char	firstName[] = &quot;John&quot;;
@chunk	char	lastName[] = &quot;Student&quot;;
@chunk	int	grade = 6;</PRE>
<PRE>@end StudentBlock					/* end of resource block */</PRE>


<H4 CLASS="HeadingC">
<A NAME="GOCLanguage_13.htm_72656">
 </A>
Declaring an Object</H4>
<PRE>@object, @default, @specificUI, gcnList</PRE>
<P>
<A NAME="GOCLanguage_13.htm_IX_Chunks:declaring with @object">
 </A>
The <A NAME="GOCLanguage_13.htm_IX_@object[;object]">
 </A>
<CODE>
@object</CODE>
 keyword is much like the <CODE>
@chunk</CODE>
 keyword in its use. It allocates a chunk in a resource segment and fills it with initializer data. However, it also does much more in that it creates an object of a specified class and fills it with default data if no initializer data is specified.</P>
<P>
The <CODE>
@object</CODE>
 keyword, like <CODE>
@chunk</CODE>
, must be used between the delimiters <CODE>
@start</CODE>
 and <CODE>
@end</CODE>
 (see above). However, it must be used in an object block (it can not be used in a data resource segment). Its format is below, and several examples are shown in <A HREF="#GOCLanguage_13.htm_99194"> Declaring Objects with @object</A>
.</P>
<PRE>@object   &lt;class&gt; &lt;name&gt; = &lt;flags&gt;* {
    &lt;fieldName&gt; = &lt;init&gt;;*
    &lt;varName&gt; [= &lt;init&gt;];*
};</PRE>
<DL>
<DT>
<STRONG>
class</STRONG>
</DT><DD>The class of the object. It must be a valid class defined either by GEOS or by your own code.</DD>
<DT>
<STRONG>
name</STRONG>
</DT><DD>The name of the object. The object's name will be used when sending messages to it.</DD>
<DT>
<STRONG>
flags</STRONG>
</DT><DD>Currently only one flag is allowed for objects:<A NAME="GOCLanguage_13.htm_IX_ignoreDirty:object flag">
 </A>
 <CODE>
ignoreDirty</CODE>
. When set, it will cause the object to ignore when changes have been made to its instance data; this means it will always be restored from a state file in the same way as it is defined in the code file. This flag should <EM>
not</EM>
 be set for any generic objects.</DD>
<DT>
<STRONG>
fieldName</STRONG>
</DT><DD>The name of an instance data field defined for the class.</DD>
<DT>
<STRONG>
varName</STRONG>
</DT><DD>The name of a variable data instance field. If the variable data field has extra data, you can initialize it with the optional argument.</DD>
<DT>
<STRONG>
init</STRONG>
</DT><DD>This is initializer data for the instance data field. If you want default values in the field, you can either leave the field out of the <CODE>
@object</CODE>
 declaration or use the keyword <CODE>
@default</CODE>
 for the initializer. When declaring variable data, though, be aware that if the extra data is a structure, the initializer must be enclosed in curly braces.</DD>
</DL>
<P>
GEOS supports special instance data fields as described in <A HREF="#GOCLanguage_10.htm_87922"> Defining Instance Data Fields</A>
. These are declared as normal fields and are described below. Also, generic hints are implemented as variable data, so they are added to an object in the same way as other variable data types.</P>

<H5 CLASS="HeadingD">
Object Trees</H5>
<P>
All objects declared in a static tree (e.g., your application's generic tree) should be in the same source file. If they are in different files, then they may be joined into a single tree only by dynamically adding objects from one file as children to objects of the other.</P>
<P>
Note that if one file contains a tree of objects, then you may incorporate the whole tree by simply dynamically adding the top object in the file to the main tree. You won't have to add each object individually.</P>
<P>
If an object declared in one source file will send a message to an object in another source file, you must include an <CODE>
@extern</CODE>
 line in the source file containing the sending object: </P>
<PRE>@extern object ReceivingObjectName;</PRE>
<P>
The message itself should be sent in the following manner (with variations possible if you will be using <CODE>
@call</CODE>
, passing arguments, or what have you):</P>
<PRE>optr ROOptr;
ROOptr = GeodeGetOptrNS(@ReceivingObjectName);
@send ROOptr::MSG_DO_SOMETHING(0, 0);</PRE>
<P>
<CODE>
GeodeGetOptrNS()</CODE>
<A NAME="GOCLanguage_13.htm_IX_Multi-launchability:optrs and">
 </A>
<A NAME="GOCLanguage_13.htm_IX_optr:and multiply launchable geodes">
 </A>
<A NAME="GOCLanguage_13.htm_IX_GeodeGetOptrNS()">
 </A>
 returns the object pointer for the object. In the case of a multiply-launchable program, Goc has no way of knowing which program's @ReceivingObjectName should receive the message--by using <CODE>
GeodeGetOptrNS()</CODE>
, you ensure that the object getting the message will be in the same geode as the object calling the routine.</P>


<H5 CLASS="HeadingD">
<A NAME="GOCLanguage_13.htm_92931">
 </A>
Declaring Children</H5>
<P>
If an object is to be part of an object tree, its class (or one of its superclasses) <EM>
must</EM>
 have at least an <CODE>
@link</CODE>
 instance data field as does <CODE>
GenClass</CODE>
. If the object is to be allowed to have children, it must also have a field of type <CODE>
@composite</CODE>
. These allow Goc to automatically and correctly link the tree together.</P>
<P>
As described in <A HREF="#GOCLanguage_10.htm_87922"> Defining Instance Data Fields</A>
, the <CODE>
@composite</CODE>
 field points to the first child of an object, and the <CODE>
@link</CODE>
 field points either to the object's next sibling or back to the parent if there is no next sibling. However, all child declaration is done completely in the composite field when using <CODE>
@object</CODE>
. The format is as follows:</P>
<PRE>&lt;fname&gt; = &lt;childName&gt; [, &lt;childname&gt;]* ;</PRE>
<DL>
<DT>
<STRONG>
fname</STRONG>
</DT><DD>This is the name of the field defined with <CODE>
@composite</CODE>
 in the class definition.</DD>
<DT>
<STRONG>
childName</DT><DD>
</STRONG>
This is the name of an object to be a child of this object. The star symbol indicates that one or more children may be included in the declaration line--they should be separated by commas, and each child must also be declared with an <CODE>
@object</CODE>
 declaration.</DD>
</DL>
<P>
There are many examples of this in the sample applications. Some simple examples are shown below.</P>
<PRE>GI_comp = @TicTacPrimary;</PRE>
<PRE>GI_comp = @TicTacView, @TicTacGameMenu;</PRE>
<PRE>VCI_comp = @TTX1, @TTX2, @TTX3, @TTX4, @TTX5, @TTO1,
		 @TTO2, @TTO3, @TTO4, @TTO5;</PRE>


<H5 CLASS="HeadingD">
Declaring Visual Monikers</H5>
<P>
<A NAME="GOCLanguage_13.htm_IX_@visMoniker[;visMoniker]">
 </A>
For an object to have a visual moniker, it must have an instance data field of type <CODE>
@visMoniker</CODE>
 as <CODE>
GenClass</CODE>
 does (see <A HREF="#GOCLanguage_10.htm_87922"> Defining Instance Data Fields</A>
). If you are in fact working with GenClass' GI_visMoniker field, you might want to consult its description in <A HREF="../../SysObjects/Gen/combo.htm">the GenClass chapter</A>.</P><P>
<A NAME="GOCLanguage_13.htm_IX_Visual monikers:goc syntax">
 </A>
Visual monikers may take many forms, and the declaration line changes depending on which form you are using. The form ranges from a simple text field to a complex list of possible monikers based on video resolution. Each of these forms and the declaration line for it is given below.</P>
<P>
The following form is used for simple text strings (shown with example):</P>
<PRE>&lt;fname&gt; = &lt;string&gt;;
GI_visMoniker = &quot;One&quot;;</PRE>
<DL>
<DT>
<STRONG>
fname</STRONG>
</DT><DD>The name of the moniker's instance data field.</DD>
<DT>
<STRONG>
string</STRONG>
</DT><DD>A string of text enclosed in quotation marks. This string is the visual moniker for the object.</DD>
</DL>
<P>
The following form is used for text strings that have a keyboard navigation character. A keyboard navigation character can be a character enclosed in single quotation marks, a numerical constant, or a text string representing some constant defined with <CODE>
#define</CODE>
. If it's a text string, the string is passed on for the C compiler to parse. The form is shown below with an example.</P>
<PRE>&lt;fname&gt; = &lt;nav&gt;, &lt;string&gt;;
GI_visMoniker = 'V', &quot;View&quot;;</PRE>
<DL>
<DT>
<STRONG>
fname</STRONG>
</DT><DD>The name of the moniker's instance data field.</DD>
<DT>
<STRONG>
nav</STRONG>
</DT><DD>A keyboard navigation character represented as described above.</DD>
<DT>
<STRONG>
string</STRONG>
</DT><DD>A text string enclosed in quotation marks.</DD>
</DL>
<P>
The following form is used when a list of monikers is required. Most frequently, this form is used when defining an application's icons; one moniker for each potential screen resolution will be included in the list. The form is shown below, along with an example.</P>
<PRE>&lt;fname&gt; = list { &lt;nameList&gt; };
GI_visMoniker = list {
 @DocDirButtonSCMoniker,
 @DocDirButtonSMMoniker,
 @DocDirButtonSCGAMoniker
}</PRE>
<DL>
<DT>
<STRONG>
fname</STRONG>
</DT><DD>This is the name of the moniker's instance data field.</DD>
<DT>
<STRONG>
nameList</STRONG>
</DT><DD>This is a list of resource data chunk names separated by commas. Each chunk can be defined with the <CODE>
@chunk</CODE>
 or <CODE>
@visMoniker</CODE>
 keyword.</DD>
</DL>
<P>
It is possible when declaring a list of visual monikers to have each moniker within a chunk or to declare each moniker with the <CODE>
@visMoniker</CODE>
 keyword. If used on its own line, this keyword takes the form</P>
<PRE>@visMoniker &lt;fname&gt; = &lt;init&gt;;</PRE>
<P>
<A NAME="GOCLanguage_13.htm_IX_@localize[;localize]">
 </A>
The fields are the name of the moniker (same as that specified in the moniker list) and the moniker data. The visual moniker will be put in its own chunk just as if the moniker had been declared with the <CODE>
@chunk</CODE>
 keyword, but using <CODE>
@visMoniker</CODE>
 often is clearer and easier.</P>
<P>
Visual monikers and strings presented by a program's UI are often accompanied by localization information. By placing a <CODE>
@localize</CODE>
 keyword after a <CODE>
@visMoniker</CODE>
 or <CODE>
@chunk</CODE>
 construction, you can provide instructions for whoever uses the ResEdit program to localize your program (i.e., to translate its strings into a foreign language). This keyword can use any syntax from the following list:</P>
<PRE>@localize { &lt;string&gt; &lt;min&gt;-&lt;max&gt; };
@localize { &lt;string&gt; &lt;length&gt; };
@localize { &lt;string&gt; };
@localize &lt;string&gt;; 
@localize not;</PRE>
<DL>
<DT>
<STRONG>
string</STRONG>
</DT><DD>A string of explanatory text. It should describe the moniker or chunk's contents.</DD>
<DT>
<STRONG>
min</STRONG>
</DT><DD>Minimum length of the moniker text or string.</DD>
<DT>
<STRONG>
max</STRONG>
</DT><DD>Maximum length of the moniker text or string.</DD>
<DT>
<STRONG>
length</STRONG>
</DT><DD>Length of the moniker text or string.</DD>
<DT>
<STRONG>
not</STRONG>
</DT><DD>Keyword specifying that the moniker or chunk is not localizable.</DD>


</DL>
<H5 CLASS="HeadingD">
Declaring GCN List Assignments</H5>
<P>
GEOS<A NAME="GOCLanguage_13.htm_IX_General change notification:goc syntax">
 </A>
 employs a &quot;General Change Notification&quot; (GCN) system which allows objects to register for notification of certain types of events. For example, some applications may want to notify for changes in the file system (file deletes, moves, copies, etc.); some objects may require notification each time the selection changes (e.g., a PointSizeControl object needs to know when the user changes a text selection). For further information, see <A HREF="../../Kernel/GCN/combo.htm">the General Change Notification chapter</A>.</P><P>
<A NAME="GOCLanguage_13.htm_IX_gcnList() keyword">
 </A>
While many objects will add themselves to and remove themselves from GCN lists dynamically, others will need to be placed on certain GCN lists in their definitions. For this, the <CODE>
gcnList</CODE>
 keyword (the only one not preceded by the marker <CODE>
@</CODE>
) is used. Its format is shown below:</P>
<PRE>gcnList(&lt;manufID&gt;, &lt;ltype&gt;) = &lt;oname&gt;,+;</PRE>
<DL>
<DT>
<STRONG>
manufID</STRONG>
</DT><DD>This is the manufacturer ID of the manufacturer responsible for creating the particular list type. It is used to differentiate different manufacturers who may use the same list type enumerator. In many cases, this will be the type MANUFACTURER_ID_GEOWORKS.</DD>
<DT>
<STRONG>
ltype</STRONG>
</DT><DD>This is the name of the GCN list. Most that you will use are defined by GenApplication and begin GAGCNLT_.... All the list types are defined in the GenApplication chapter in the Objects book.</DD>
<DT>
<STRONG>
oname</STRONG>
</DT><DD>This is a list of objects that should be on the GCN list. The objects are separated by commas.</DD>


</DL>
<H5 CLASS="HeadingD">
Declaring Keyboard Accelerators</H5>
<P>
<A NAME="GOCLanguage_13.htm_IX_Keyboard accelerators:goc syntax">
 </A>
A keyboard accelerator acts as a &quot;hot key,&quot; invoking the object's default action when pressed. <A NAME="GOCLanguage_13.htm_IX_@kbdAccelerator[kbdAccelerator]">
 </A>
The accelerator character is defined in an instance field declared with <CODE>
@kbdAccelerator</CODE>
 as shown in <A HREF="#GOCLanguage_10.htm_87922"> Defining Instance Data Fields</A>
. The form of declaration follows.</P>
<PRE>&lt;fname&gt; = [@specificUI] &lt;mod&gt;* &lt;key&gt;;</PRE>
<DL>
<DT>
<STRONG>
fname</STRONG>
</DT><DD>This is the name of the <CODE>
@kbdAccelerator</CODE>
 instance data field.</DD>
<DT>
<CODE>
@specificUI</CODE>
<A NAME="GOCLanguage_13.htm_IX_@specificUI[;specificUI]">
 </A>
</DT><DD>This is a Goc keyword that, when used in this declaration, allows your program to use a key combination reserved for the specific UI. This can have undefined consequences and is strongly discouraged.</DD>
<DT>
<STRONG>
mod</STRONG>
</DT><DD>This is a modifier key. You may put any or all of the modifiers here, separated by spaces. The four modifiers are <A NAME="GOCLanguage_13.htm_IX_alt (keyboard accelerator modifier)">
 </A>
<CODE>
alt</CODE>
, <A NAME="GOCLanguage_13.htm_IX_control (keyboard accelerator modifier)">
 </A>
<CODE>
control</CODE>
, <CODE>
ctrl</CODE>
<A NAME="GOCLanguage_13.htm_IX_ctrl (keyboard accelerator modifier)">
 </A>
, and <A NAME="GOCLanguage_13.htm_IX_shift (keyboard accelerator modifier)">
 </A>
<CODE>
shift</CODE>
.</DD>
<DT>
<STRONG>
key</STRONG>
</DT><DD>This is either a character enclosed in single quotes (e.g., `k') or a numeric key constant (e.g., C_CTRL_A or 0x57).<A NAME="GOCLanguage_13.htm_IX_Keyboard accelerators:goc syntax">
 </A>
</DD>


</DL>
<H5 CLASS="HeadingD">
Using Default Values</H5>
<P>
Often an object will be declared with the default values of an instance data field. Other times, especially with generic UI object attributes, an object will have the default values with one or two modifications. In the first case, the instance data field does not need to be addressed at all; the default value will be used if no declaration is made.</P>
<P>
<A NAME="GOCLanguage_13.htm_IX_@default[;default]">
 </A>
In the second case, however, you must use the <CODE>
@default</CODE>
 keyword to get the default values. If modifications are made and <CODE>
@default</CODE>
 is not used, all default values will be lost. This is normally used only with bitfield-type attributes, and modifications are made with bitwise operators. The use of <CODE>
@default</CODE>
 is shown below.</P>
<PRE>&lt;fname&gt; = @default [&lt;op&gt; [~]&lt;attr&gt;]*;</PRE>
<DL>
<DT>
<STRONG>
fname</STRONG>
</DT><DD>This is the name of the instance data field.</DD>
<DT>
<STRONG>
op</STRONG>
</DT><DD>This is a bitwise operator. If adding an attribute to the default, use the bitwise OR operator (|); if removing an attribute, use the bitwise AND operator (&amp;) with the inverse of the attribute (see below). One operator is required for each attribute added or removed. The priorities of the operators are the same as in the standard C programming language.</DD>
<DT>
<STRONG>
~</STRONG>
</DT><DD>This is the bitwise operator NOT. If removing an attribute using the bitwise AND operator, you should include the NOT symbol in front of the attribute.</DD>
<DT>
<STRONG>
attr</STRONG>
</DT><DD>This is the name of the attribute being added or removed.</DD>
</DL>
<P CLASS="figTitle">
Code Display 5-17 <A NAME="GOCLanguage_13.htm_99194">
 </A>
Declaring Objects with @object</P>
<PRE>	/* This example shows the use of @start, @object, @visMoniker, and @end.
	 * It is taken from the TicTac sample application. */</PRE>
<PRE>@start AppResource;
	/* The AppResource resource block contains the TicTacApp
	 * object and its visual moniker chunk. */</PRE>
<PRE>@object GenApplicationClass TicTacApp = {
    GI_visMoniker = list { @TicTacTextMoniker };
    GI_comp = @TicTacPrimary;
    gcnList(MANUFACTURER_ID_GEOWORKS,GAGCNLT_WINDOWS) = @TicTacPrimary;
}</PRE>
<PRE>@visMoniker TicTacTextMoniker = &quot;TicTacToe&quot;;
@end AppResource</PRE>
<PRE>@start Interface;
	/* The Interface resource declares TicTac's primary window and other UI
	 * gadgetry. Only the GenView from this application is shown. */
@object GenViewClass TicTacView = {
    GVI_content = @TicTacBoard;					/* A relocatable optr field */
    GVI_docBounds = {0, 0, BOARD_WIDTH, BOARD_HEIGHT};
					/* A Rectangle structure */
    GVI_color = { C_BLUE, 0, 0, 0 };					/* A ColorQuad structure */
    GVI_horizAttrs = @default | GVDA_NO_LARGER_THAN_CONTENT
			    | GVDA_NO_SMALLER_THAN_CONTENT
			    &amp; ~GVDA_SCROLLABLE;
		/* The NO_LARGER and NO_SMALLER attributes are set in the
		 * field, and SCROLLABLE is cleared. The SCROLLABLE attribute
		 * is not set by default for the GenView; it is shown here
		 * for illustration. */
    GVI_vertAttrs = @default | GVDA_NO_LARGER_THAN_CONTENT
			   | GVDA_NO_SMALLER_THAN_CONTENT;
}</PRE>
<PRE>@end Interface</PRE>


<HR>
<A NAME="GOCLanguage_14.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">GEOS Programming</A>: 4.5 <A HREF="#GOCLanguage_f.htm">Using Classes and Objects</A>: 
Sending Messages</H3>
<PRE>@send, @call, @callsuper, @record, @dispatch, @dispatchcall, TravelOption, ObjDuplicateMessage(), ObjFreeMessage(), ObjGetMessageInfo()</PRE>
<P>
Often you will have to send messages to objects throughout the system. You can send messages in several ways, but the two most basic and most frequently used involve the keywords <CODE>
@call</CODE>
 and <CODE>
@send</CODE>
.</P>
<P>
If a message is being sent across threads, you must be aware of synchronization issues. If the message does not cross thread boundaries, the kernel will link the code directly as if it were a function call. (This is an implementation difference only; you do not have to specify anything different in your code.)</P>
<P>
<A NAME="GOCLanguage_14.htm_IX_@send[;send]">
 </A>
The <CODE>
@send</CODE>
 keyword causes the kernel to put the specified message into the recipient's event queue. Messages sent with <CODE>
@send</CODE>
 may not give return values and may not take pointers to locked memory as arguments. The sender then continues executing without ever knowing whether the message was properly handled or not.</P>
<P>
<A NAME="GOCLanguage_14.htm_IX_@call[;call]">
 </A>
The <CODE>
@call</CODE>
 keyword is used when the message being sent must return information to the sender. It is also used when the message must be handled immediately, before the sender is allowed to continue executing. In essence, the sender is &quot;put to sleep&quot; until the message has been processed, at which time the sender is woken up and may continue executing. If the message sent with <CODE>
@call</CODE>
 is not handled (passed up the recipient's class tree and still not handled), it will return as if it had been; no error message will be returned.</P>
<P>
The formats for <CODE>
@send</CODE>
 and <CODE>
@call</CODE>
 are similar. Use them like function calls. Their format is given below:</P>
<PRE>@send [,&lt;flags&gt;]+ \
		&lt;obj&gt;::[{&lt;cast2&gt;}]&lt;msg&gt;(&lt;params&gt;*);</PRE>
<PRE>&lt;ret&gt; = @call [,&lt;flags&gt;]+ [{&lt;cast&gt;}] &lt;obj&gt;::\
			[{&lt;cast2&gt;}]&lt;msg&gt;(&lt;params&gt;*);</PRE>
<DL>
<DT>
<STRONG>
flags</STRONG>
</DT><DD>This is a list of flags separated by the commas. The allowed flags are shown below.</DD>
<DT>
<STRONG>
obj</STRONG>
</DT><DD>This is the name of the object to which the message will be sent. It can also be an optr variable.</DD>
<DT>
<STRONG>
msg</STRONG>
</DT><DD>This is the name of the message being sent.</DD>
<DT>
<STRONG>
params</STRONG>
</DT><DD>This is a list of parameters, built exactly as it would be for a standard C function call.</DD>
<DT>
<STRONG>
ret</STRONG>
</DT><DD>This is a variable that will hold the return value, if any. Note that this is valid only with <CODE>
@call</CODE>
 because <CODE>
@send</CODE>
 does not return anything.</DD>
<DT>
<STRONG>
cast</STRONG>
</DT><DD>If a message name is put here, Goc will automatically cast the return type to whatever type is returned by <CODE>
cast</CODE>
.</DD>
<DT>
<STRONG>
cast2</STRONG>
</DT><DD>If a message name is put here, Goc will assume that the message is passed the same arguments as message <CODE>
cast2</CODE>
.</DD>
</DL>
<P>
The flags allowed for these keywords are listed below. They are rarely used but are available.</P>
<DL>
<DT>
<CODE>
forceQueue</CODE>
<A NAME="GOCLanguage_14.htm_IX_forceQueue message flag">
 </A>
</DT><DD><A NAME="GOCLanguage_14.htm_IX_Event queues:@call and @send flags">
 </A>
This flag will cause the message to be placed in the recipient's event queue, even if it could have been handled by a direct call. Do not use this flag with <CODE>
@call</CODE>
.</DD>
<DT>
<CODE>
checkDuplicate</DT><DD>
</CODE>
<A NAME="GOCLanguage_14.htm_IX_checkDuplicate message flag">
 </A>
This flag makes the kernel check if a message of the same name is already in the recipient's event queue. For this flag to work, <CODE>
forceQueue</CODE>
 must also be passed. Events are checked from first (next-to-be-processed) to last. If the message is a duplicate, it will be dropped; however the <EM>
replace</EM>
 flag, described below, can change this behavior.</DD>
<DT>
<CODE>
checkLastOnly</DT><DD>
</CODE>
<A NAME="GOCLanguage_14.htm_IX_checkLastOnly message flag">
 </A>
This flag works with <CODE>
checkDuplicate</CODE>
, causing it to check only the last message in the event queue.</DD>
<DT>
<CODE>
replace</CODE>
<A NAME="GOCLanguage_14.htm_IX_replace message flag">
 </A>
</DT><DD>This flag modifies <CODE>
checkDuplicate</CODE>
 and <CODE>
checkLastOnly</CODE>
 by superseding the duplicate (old) event with the new one. The new event will be put in the duplicate's position in the event queue. If a duplicate is found but the <CODE>
replace</CODE>
 flag is not passed, the duplicate will be dropped.</DD>
<DT>
<CODE>
insertAtFront</DT><DD>
</CODE>
<A NAME="GOCLanguage_14.htm_IX_insertAtFront message flag">
 </A>
This puts the message at the front of the recipient's event queue.</DD>
<DT>
<CODE>
canDiscardIfDesperate</DT><DD>
</CODE>
<A NAME="GOCLanguage_14.htm_IX_canDiscardIfDesperate message flag">
 </A>
This flag indicates that this event may be discarded if the system is running extremely low on handles and requires more space immediately.</DD>
</DL>
<P>
The <CODE>
@call</CODE>
 command can also be used within an expression in the same way a function call could. For example, the following conditional expression is valid:</P>
<PRE>if (@call MyObj::MSG_MYOBJ_TEST()) {
    /* conditional code */
}</PRE>
<P>
The result of the message call will be evaluated in the if statement. Note that this may not be done with <CODE>
@send</CODE>
 because it returns nothing.</P>

<H4 CLASS="HeadingC">
Nested Message Calls

</H4>
<P>
Because of the way Goc processes message calls, it is impossible to nest messages on a single line. For example, this call is illegal:</P>
<PRE>@send Obj1::MSG_THATS_PASSED_AN_INT(\
		@call Obj2::MSG_THAT_RETURNS_INT());</PRE>
<P>
Any such call will generate a compile-time error. Instead, you should use temporary variables to break this up into several lines, e.g.:</P>
<PRE>int i;</PRE>
<PRE>i = @call Obj2::MSG_THAT_RETURNS_INT();</PRE>
<PRE>@send Obj2::MSG_THATS_PASSED_AN_INT(i);</PRE>


<H4 CLASS="HeadingC">
Sending a Message to an Object's Superclass</H4>
<P>
<A NAME="GOCLanguage_14.htm_IX_@callsuper[;callsuper]">
 </A>
<A NAME="GOCLanguage_14.htm_IX_Superclass:sending messages to">
 </A>
Often you may wish to send a message directly to an object's superclass to ensure that default behavior is implemented. Use the <CODE>
@callsuper</CODE>
 keyword with the following format:</P>
<PRE>@callsuper &lt;obj&gt;::&lt;class&gt;::&lt;msg&gt;(&lt;pars&gt;*) [&lt;flgs&gt;+];</PRE>
<DL>
<DT>
<STRONG>
obj</STRONG>
</DT><DD>This is the object to send the message to, as in <CODE>
@call</CODE>
 and <CODE>
@send</CODE>
. The object block must already be locked, and must be run by the current thread of execution. (Usually an object uses <CODE>
@callsuper()</CODE>
 to send a message to itself.)</DD>
<DT>
<STRONG>
class</STRONG>
</DT><DD>This is the class whose superclass should receive the message.</DD>
<DT>
<STRONG>
msg</STRONG>
</DT><DD>This is the message name.</DD>
<DT>
<STRONG>
pars</STRONG>
</DT><DD>This is the parameter list, same as <CODE>
@call</CODE>
 and <CODE>
@send</CODE>
.</DD>
<DT>
<STRONG>
flgs</STRONG>
</DT><DD>This is the flags list, same as <CODE>
@call</CODE>
 and <CODE>
@send</CODE>
.</DD>
</DL>
<P>
When used on a line by itself (with no parameters or return values), <CODE>
@callsuper()</CODE>
 passes a received message on to the superclass. This is used quite often when a subclass wants to alter existing behavior rather than replace it.</P>


<H4 CLASS="HeadingC">
Encapsulating a Message</H4>
<P>
By encapsulating messages, you can set up events to be sent out at a later time. An encapsulated message can include the message to be sent, the object it should be sent to, and the parameters that should be passed. Using encapsulated messages can sometimes simplify coding.</P>
<P>
<A NAME="GOCLanguage_14.htm_IX_@record[;record]">
 </A>
Messages can be encapsulated with the <CODE>
@record</CODE>
 keyword and later dispatched with <A NAME="GOCLanguage_14.htm_IX_@dispatch[;dispatch]">
 </A>
<CODE>
@dispatch</CODE>
 and <A NAME="GOCLanguage_14.htm_IX_@dispatchcall[;dispatchcall]">
 </A>
<CODE>
@dispatchcall</CODE>
. (Though the use of <CODE>
@record</CODE>
 does not necessitate a later <CODE>
@dispatch</CODE>
--there are other uses for an encapsulated event.) In addition, when the event is dispatched, you can override the values set in the encapsulated event to change the destination or the message. You can also cast the return value to another type if necessary. The formats of these three keywords are as follows:</P>
<PRE>&lt;event&gt; = @record &lt;obj&gt;::[{&lt;cast&gt;}]&lt;msg&gt;(&lt;params&gt;*);</PRE>
<DL>
<DT>
<STRONG>
event</STRONG>
</DT><DD>The handle of the recorded event, of type <CODE>
EventHandle</CODE>
.</DD>
<DT>
<STRONG>
obj</STRONG>
</DT><DD>The object set to receive the message when it is dispatched. This field may be set to <CODE>
null</CODE>
 if the destination is determined when the message is dispatched.</DD>
<DT>
<STRONG>
cast</STRONG>
</DT><DD>The name of a message; if this is present, the event will have the same argument types as the specified message.</DD>
<DT>
<STRONG>
msg</STRONG>
</DT><DD>The message set to be sent when the event is dispatched. This field may be set to <CODE>
null</CODE>
 if the message is determined when it is dispatched.</DD>
<DT>
<STRONG>
params</STRONG>
</DT><DD>The parameter list (same as in <CODE>
@call</CODE>
 and <CODE>
@send</CODE>
) that will be sent with the dispatched message.</DD>
</DL>
<P>
<A NAME="GOCLanguage_14.htm_IX_ObjGetMessageInfo()">
 </A>
<A NAME="GOCLanguage_14.htm_IX_ObjDuplicateMessage()">
 </A>
<A NAME="GOCLanguage_14.htm_IX_ObjFreeMessage()">
 </A>
You may create a copy of a recorded message by means of the <CODE>
ObjDuplicateMessage()</CODE>
 routine. To free it, call <CODE>
ObjFreeMessage()</CODE>
. To discover the Message and destination object associated with a recorded event, call <CODE>
ObjGetMessageInfo()</CODE>
.</P>
<P>
The <CODE>
@dispatch</CODE>
 keyword is used to dispatch an encapsulated event to its destination. This is similar to <CODE>
@send</CODE>
 in that it can have no return values. If the event has return values, use <CODE>
@dispatchcall</CODE>
 (below).</P>
<PRE>@dispatch [noFree] \
		&lt;nObj&gt;::[{&lt;cast&gt;}]&lt;nMsg&gt;::&lt;event&gt;;</PRE>
<DL>
<DT>
<STRONG>
noFree</STRONG>
</DT><DD>This flag indicates that the event's handle should not be freed after the event has been dispatched. This is useful if the same encapsulated event is to be used more than once.</DD>
<DT>
<STRONG>
nObj</STRONG>
</DT><DD>This is an override destination. If the destination in the encapsulated event is null, then an object must be set here. Any object set will override that in the encapsulated message. If no override object is desired, set this to <CODE>
null</CODE>
.</DD>
<DT>
<STRONG>
nMsg</STRONG>
</DT><DD>This is an override message. If set, this message will be sent rather than that in the encapsulated event. If no override message is desired, set this to <CODE>
null</CODE>
. Any override will be sent with the same parameters as set in the encapsulated event.</DD>
<DT>
<STRONG>
event</STRONG>
</DT><DD>This is the handle of the encapsulated event. This may not be a classed event.</DD>
</DL>
<P>
The <CODE>
@dispatchcall</CODE>
 keyword works exactly like the <CODE>
@dispatch</CODE>
 keyword above except that it allows the use of return values. The sender will be &quot;put to sleep&quot; if necessary while the recipient processes the message and will be &quot;woken up&quot; when the message returns.</P>
<PRE>&lt;ret&gt; = @dispatchcall [noFree] [{&lt;cast&gt;}] &lt;nObj&gt;::\
                                    &lt;nMsg&gt;::&lt;event&gt;;</PRE>
<DL>
<DT>
<STRONG>
ret</STRONG>
</DT><DD>This is a variable that will contain the return value of the message.</DD>
<DT>
<STRONG>
other parameters</DT><DD>
</STRONG>
All the other parameters are the same as those in <CODE>
@dispatch</CODE>
.</DD>


</DL>
<H4 CLASS="HeadingC">
Using Expressions with Messages</H4>
<P>
All message-sending keywords described in the previous sections--<CODE>
@call</CODE>
, <CODE>
@send</CODE>
, <CODE>
@record</CODE>
, <CODE>
@dispatch</CODE>
, and <CODE>
@dispatchcall</CODE>
--can take expressions in place of a destination object's name. Additionally, the <CODE>
@dispatch</CODE>
 and <CODE>
@dispatchcall</CODE>
 keywords can take expressions in place of the message name. However, if an expression is used for the message, you must use a cast type to make sure Goc knows the return and parameter types. Note, however, that casts in this case use curly braces rather than parentheses.</P>


<H4 CLASS="HeadingC">
Casting Message Call and Return Types</H4>
<P>
Goc allows you to cast a message's pass and return values. This is best explained by example:</P>
<PRE>{
 int swapInt;
 char c;</PRE>
<PRE> c = @call {MSG_1} object:: {MSG_2} MSG_X(swapInt);</PRE>
<PRE>}</PRE>
<P>
In this case, MSG_2 takes an integer argument and MSG_1 returns a char. The casts tell Goc how MSG_X will receive parameters and return results. Goc needs the casts in those cases where MSG_X doesn't appear explicitly (perhaps it has been stored as an integer), and thus Goc would not be able to parse the parameters or return values.</P>
<P>
When Goc tries to determine proper parameters and returns, it will look to the following sources when available. When trying to figure out parameters, it will look first for MSG_2, then MSG_X, and MSG_1 last. The first one Goc finds will determine the parameters.</P>
<P>
<CODE>
@send</CODE>
 and <CODE>
@record</CODE>
 don't support return values, but on a <CODE>
@call</CODE>
, Goc will figure out return values by looking at MSG_1, MSG_X, and finally MSG_2.</P>
<P>
 In this case, Goc will pass to fn's method like MSG_CAST_2 but will return values as MSG_CAST_1 does:</P>
<PRE>Message fn = GetMessageToCall();
c = @call {MSG_CAST_1} myObj:: {MSG_CAST_2} fn(x);</PRE>
<P>
 Now we pass to MSG_B like MSG_CAST_2, but return like MSG_B:</P>
<PRE> c = @call myObj:: {MSG_CAST_2} MSG_B(swapInt);</PRE>


<H4 CLASS="HeadingC">
Classed Events and <A NAME="GOCLanguage_14.htm_40477">
 </A>
Travel Options</H4>
<PRE>MSG_META_SEND_CLASSED_EVENT, TravelOption</PRE>
<P>
<A NAME="GOCLanguage_14.htm_IX_MSG_META_SEND_CLASSED_EVENT">
 </A>
<A NAME="GOCLanguage_14.htm_IX_TravelOption">
 </A>
<A NAME="GOCLanguage_14.htm_IX_GenTravelOption">
 </A>
<A NAME="GOCLanguage_14.htm_IX_TO_&ldots;">
 </A>
You do not always need to specifically include an object as a destination for your message. In many cases, you may be able to generically address your message using a <EM>
classed event</EM>
. A classed event consists of a pre-defined <CODE>
TravelOption</CODE>
 enumerated type and an EventHandle recorded using the @record Goc construct. The event in this case does not contain a specific object, but rather an object class. </P>
<P>
The <CODE>
TravelOption</CODE>
 acts as a navigator, determining along what path the message should be delivered. The object class within the classed event acts as a filter, determining if the object sent the message is an object of that class. If the object first encountered along the path dictated by the <CODE>
TravelOption</CODE>
 is not a matching class, the classed event is passed to the next object on that path. When the class finally matches, the message will be handled by that object.</P>
<P>
The classed event is originally dispathed from the object by sending MSG_META_SEND_CLASSED_EVENT. This message is usually sent by an object to itself. The travel options available depend on the class(es) of the object receiving the message. That is, the object receiving the message must be a sub-class of one of the following:</P>
<UL>
<LI>
<CODE>
MetaClass</CODE>
 (Usable by all GEOS object classes)</LI>
</UL>
<DL>
<DT>
TO_NULL</DT><DD>Indicates that no object is to receive the message. The default case in this case is to destroy the classed event that is dispatched,</DD>
<DT>
TO_SELF</DT><DD>Indicates that the message should be delivered to itself. If it is not handled there, it will be destroyed. </DD>
<DT>
TO_OBJ_BLOCK_OUTPUT</DT><DD>
Each GEOS object block contains a default output stored in the object block header.This <CODE>
TravelOption</CODE>
 indicates that the message should be delivered to the object block's output optr.</DD>
<DT>
TO_PROCESS</DT><DD>Indicates that the message should be delivered to the application's <CODE>
ProcessClass</CODE>
 object. </DD>
<UL>
<LI>
<CODE>
GenClass</CODE>
 (Usable by all generic objects)<BR>
For a discussion of the Focus, Target and Model hierarchies, see <A HREF="../../SysObjects/Input/Input_11.htm#95885">the Input chapter</A>.</LI></UL>
<DT>
TO_GEN_PARENT</DT><DD>
Indicates that the message should be delivered the object's generic parent.</DD>
<DT>
TO_FOCUS</DT><DD>Indicates that the message should be delivered along the object's focus hierarchy, following the focus links from child to child.</DD>
<DT>
TO_TARGET</DT><DD>Indicates that the message should be delivered along the object's target hierarchy, following the target links from child to child.</DD>
<DT>
TO_MODEL</DT><DD>Indicates that the message should be delivered along the object's model hierarchy, following the model links from child to child.</DD>
<DT>
TO_APP_FOCUS</DT><DD>
	Indicates that the message should be delivered along the focus hierarchy, starting at the root GenApplication object and following the focus links from child to child.</DD>
<DT>
TO_APP_TARGET</DT><DD>
	Indicates that the message should be delivered along the target hierarchy, starting at the root GenApplication object and following the target links from child to child.</DD>
<DT>
TO_APP_MODEL</DT><DD>
	Indicates that the message should be delivered along the model hierarchy, starting at the root GenApplication object and following the model links from child to child.</DD>
<DT>
TO_SYS_FOCUS</DT><DD>
	Indicates that the message should be delivered along the focus hierarchy, starting at the root GenSystem object and following the focus links from child to child.</DD>
<DT>
TO_SYS_TARGET</DT><DD>
	Indicates that the message should be delivered along the target hierarchy, starting at the root GenSystem object and following the target links from child to child.</DD>
<DT>
TO_SYS_MODEL</DT><DD>
	Indicates that the message should be delivered along the model hierarchy, starting at the root GenSystem object and following the model links from child to child.</DD>
<UL>
<LI>
<CODE>
VisClass</CODE>
 (Usable by all visible objects)</LI>
</UL>
<DT>
TO_VIS_PARENT</DT><DD>
Indicates that the message should be delivered to the object's visible parent.</DD>
<UL>
<LI>
<CODE>
GenApplicationClass</CODE>
 (Usable by all Application objects)</LI>
</UL>
<DT>
TO_PRINT_CONTROL</DT><DD>
Indicates that the object should be delivered to the application object's print control object.</DD>
</DL>
<P>
To send a classed event, you must first record the event, specifying the message to send and the object class to handle the message. Then you must send MSG_META_SEND_CLASSED_EVENT--usually to yourself-- passing that handle and a <CODE>
TravelOption</CODE>
.</P>
<PRE>&lt;event&gt; = @record &lt;objClass&gt;::&lt;msg&gt;</PRE>
<PRE>@send self::MSG_META_SEND_CLASSED_EVENT(&lt;event&gt;, 
						&lt;TravelOption&gt;);</PRE>
<P CLASS="figTitle">
Code Display 5-18 Sending a Classed Event</P>
<PRE>/*
 * First record the Classed event. In this case, we want an object of class 
 * `MyFooClass' to handle MSG_FOO. We will send this classed event along the  
 * target hierarchy. We want to begin the path at the application object, so we 
 * will use the TO_APP_TARGET TravelOption.
 */</PRE>
<PRE>event = @record MyFooClass::MSG_FOO;</PRE>
<PRE>/*
 * Then dispatch the classed event using MSG_META_SEND_CLASSED_EVENT.
 */</PRE>
<PRE>@send self::MSG_META_SEND_CLASSED_EVENT(event, TO_APP_TARGET);</PRE>


<H4 CLASS="HeadingC">
Message Shortcuts</H4>
<P>
All messages, when received, contain three basic parameters: the message number (<CODE>
message</CODE>
), the optr of the recipient (<CODE>
oself</CODE>
), and a far pointer to the recipient's locked instance chunk (<CODE>
pself</CODE>
). This allows several shortcuts and shorthand formats for use within methods:</P>
<PRE>@callsuper;</PRE>
<P>
When used in a method as above, the <CODE>
@callsuper</CODE>
 keyword passes the received message up to the object's superclass. Use this whenever subclassing a message when the default functionality must be preserved.</P>
<PRE><A NAME="GOCLanguage_14.htm_IX_self (messaging shortcut)"> </A>&lt;ret&gt; = @call self::&lt;msg&gt;(&lt;params&gt;*);</PRE>
<P>
Any object can send a message to itself using <CODE>
@call</CODE>
 and &quot;self&quot; as the destination. The remainder of the command is the same as a normal <CODE>
@call</CODE>
.</P>
<PRE><A NAME="GOCLanguage_14.htm_IX_process (messaging shortcut)"> </A>&lt;ret&gt; = @call process::&lt;msg&gt;(&lt;params&gt;*);</PRE>
<P>
Any object can send a message to its Process object with <CODE>
@call</CODE>
 and &quot;process&quot; as the destination. (The Process object is the object of class <CODE>
ProcessClass</CODE>
.) The remainder of the command is the same as a normal <CODE>
@call</CODE>
.</P>
<PRE><A NAME="GOCLanguage_14.htm_IX_application (messaging shortcut)"> </A>&lt;ret&gt; = @call application::&lt;msg&gt;(&lt;params&gt;*);</PRE>
<P>
Any object can send a message to its Application object (of class <CODE>
GenApplicationClass</CODE>
) with <CODE>
@call</CODE>
 and &quot;application&quot; as the destination. The remainder of the command is the same as a normal <CODE>
@call</CODE>
.</P>
<PRE><A NAME="GOCLanguage_14.htm_IX_@visParent (messaging shortcut)[;visParent (messaging shortcut)]"> </A>&lt;ret&gt; = @call @visParent::&lt;msg&gt;(&lt;params&gt;*);</PRE>
<P>
Any object in a visible tree can use <CODE>
@visParent</CODE>
 as the destination of an <CODE>
@call</CODE>
 command. The message will be sent to the object's parent in the visible object tree. The remainder of the command is the same as a normal <CODE>
@call</CODE>
.</P>
<PRE><A NAME="GOCLanguage_14.htm_IX_@genParent (messaging shortcut)[;genParent (messaging shortcut)]"> </A>&lt;ret&gt; = @call @genParent::&lt;msg&gt;(&lt;params&gt;*);</PRE>
<P>
Any object in a generic tree can use <CODE>
@genParent</CODE>
 as the destination of an <CODE>
@call</CODE>
 command. The message will be sent to the object's parent in the generic object tree. The remainder of the command is the same as a normal <CODE>
@call</CODE>
.</P>
<PRE><A NAME="GOCLanguage_14.htm_IX_@visChildren (messaging shortcut)[;visChildren (messaging shortcut)]"> </A>@send @visChildren::&lt;msg&gt;(&lt;params&gt;*);</PRE>
<P>
Any composite object in a visible object tree (therefore a subclass of <CODE>
VisCompClass</CODE>
) can send a message that will be dispatched at once to all of its children. Any message sent with <CODE>
@visChildren</CODE>
 as the destination must be dispatched with the <CODE>
@send</CODE>
 keyword and therefore can have no return value.</P>
<PRE><A NAME="GOCLanguage_14.htm_IX_@genChildren (messaging shortcut)[;genChildren (messaging shortcut)]"> </A>@send @genChildren::&lt;msg&gt;(&lt;params&gt;*);</PRE>
<P>
Any composite object in a generic object tree (therefore a subclass of <CODE>
GenClass</CODE>
) can send a message that will be dispatched at once to all of its children. Any message sent with <CODE>
@genChildren</CODE>
 as the destination must be dispatched with the <CODE>
@send</CODE>
 keyword and therefore can have no return value.</P>
<P>
<A NAME="GOCLanguage_14.htm_IX_@:Goc object pointer shortcut">
 </A>
In addition to the above shortcuts, you may also pass the optr of an object using <CODE>
@&lt;obj&gt;</CODE>
, where <CODE>
&lt;obj&gt;</CODE>
 represents the name of the object. This syntax gets translated by Goc into <CODE>
(optr)&amp;&lt;obj&gt;</CODE>
; this is similar to using the ampersand (&amp;) to pass a pointer.</P>

<HR>
<A NAME="GOCLanguage_15.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">GEOS Programming</A>: 4.6 <A HREF="#GOCLanguage_f.htm">Using Classes and Objects</A>: 
<A NAME="GOCLanguage_15.htm_54024">
 </A>
Managing Objects</H3>
<P>
<A NAME="GOCLanguage_15.htm_IX_Objects:goc syntax">
 </A>
In addition to knowing how to declare objects and classes, you need to know how to manage objects during execution. This includes instantiating new objects, deleting objects, saving object state, and moving objects around object trees.</P>
<P>
Both the kernel and <CODE>
MetaClass</CODE>
 (the topmost class in any class hierarchy) have routines and methods to create, manage, and destroy objects. You will probably not have to or want to use all these routines and methods, but understanding what they do and how they work can help you understand the object system as a whole.</P>

<H4 CLASS="HeadingC">
Creating New Objects</H4>
<PRE>ObjDuplicateResource(), ObjInstantiate(), MSG_META_INITIALIZE, MSG_GEN_COPY_TREE</PRE>
<P>
<A NAME="GOCLanguage_15.htm_IX_Objects:creating">
 </A>
You can introduce objects to the system in four basic ways. Each of these has benefits and drawbacks, and each has an appropriate place and time for use. It is unlikely, however, that you will use all four different means.</P>

<H5 CLASS="HeadingD">
Storing Objects in a Resource Block</H5>
<P>
This is a common and simple way to introduce objects to the system. The Hello World sample application uses this method of creating and loading objects. Resource blocks are contained in your geode's executable file (the <STRONG CLASS="fileName">
.geo</STRONG>
 file) and are automatically loaded when accessed. These resources may also be tagged for saving to state files automatically.</P>
<P>
Setting up an object resource is simply a matter of defining the resource and using the <CODE>
@object</CODE>
 keyword to define each object in the resource. The object resource block is automatically created and put in your executable file. Each object defined with <CODE>
@object</CODE>
 is allocated a chunk and a chunk handle within the resource block. Because both the chunk handle and the handle of the resource block are known, accessing individual objects in the resource is simple. In essence, when you set up an object resource, you don't need to worry about bringing the objects into the system or shutting them down.</P>
<P>
Using a resource for objects has limitations. Objects loaded from resources are always loaded with the same characteristics. This can be a problem if you need to have several different copies of a certain set of objects, and each copy can be changed. In this case, you would duplicate the resource (see below) before accessing the objects within it.</P>
<P>
For an example of objects defined by means of declaring them with the <CODE>
@object</CODE>
 keyword within an object resource, see <A HREF="#GOCLanguage_13.htm_99194"> Declaring Objects with @object</A>
.</P>
<P>
To define an object resource, you must know what objects you'll require before your geode is launched. Some complex programs will dynamically instantiate individual objects or entire trees without knowing previously what objects will be required. To do this, you'll need to use <CODE>
ObjInstantiate()</CODE>
 (see below) for instantiating individual objects.</P>


<H5 CLASS="HeadingD">
Duplicating an Object Block Resource</H5>
<P>
This is another common method employed by both the User Interface and applications. It provides the simplicity of the object resource model (above) while allowing you to have several different copies of the resource. Thus, it's perfect if you want to use templates for your object blocks (this is what the Document Control object does, as shown in the Tutorial application (see APPL\TUTORIAL\MCHRT4\MCHRT.GOC)).</P>
<P>
<A NAME="GOCLanguage_15.htm_IX_Object blocks">
 </A>
First, you must set up an object resource in your code file with <CODE>
@start</CODE>
, <CODE>
@end</CODE>
, and <CODE>
@object</CODE>
. In the <STRONG CLASS="fileName">
.gp</STRONG>
 file, mark the resource <EM>
discard-only</EM>
. The objects in such a &quot;template&quot; resource should not be linked to any object outside the block. Generic object branches created in this manner should have their topmost object marked as not usable (~GS_USABLE); this is because it is illegal for a generic object to be usable without having a generic parent. Instead of accessing these objects directly, you should duplicate the resource block. (A resource can not be both duplicated and used directly.) <A NAME="GOCLanguage_15.htm_IX_ObjDuplicateResource()">
 </A>
This is done with <CODE>
ObjDuplicateResource()</CODE>
, which allocates a new block on the heap, sets it up properly, and copies the resource directly into it.</P>
<P>
You are returned a handle to the new object block, which you can then modify any way you like. Because all the chunk handles of all the objects will be the same as in the source block, you can easily access any object in the duplicate. Once copied, the duplicate objects may be added to your generic tree and then set GS_USABLE. And, by using <CODE>
ObjDuplicateResource()</CODE>
 more than once on the same resource, you can have several different, possibly modified versions of the resource at once.</P>
<P>
As with using resource blocks, however, you must know the configuration of all your template objects beforehand. You may still need to add new objects to the resource or dynamically create other objects. This is the primary drawback of this method.</P>
<P>
Additionally, if you duplicate resource blocks, you should also free them when they're not needed any more. Generic objects in the block should be set not usable and then removed from the tree before the resource is freed. Freeing should be done by sending <CODE>
MSG_META_BLOCK_FREE</CODE>
 to any object in the block or by calling <CODE>
ObjFreeObjBlock()</CODE>
. Use of the kernel routine <CODE>
ObjFreeDuplicate()</CODE>
 is not recommended as it requires all objects in the block to be thoroughly clean of any ties to the system. (<CODE>
MSG_META_BLOCK_FREE</CODE>
 and <CODE>
ObjFreeObjBlock()</CODE>
 ensure that the objects have had adequate time to relinquish these ties first.)</P>


<H5 CLASS="HeadingD">
Instantiating an Individual Object</H5>
<P>
The most complex of these three options, this can provide the flexibility needed for all cases. The actual act of instantiating an object is not difficult or very complex. However, it is time and labor intensive and requires several steps that are not necessary when using object resources. In addition, cleaning up after objects created in this manner is more complex.</P>
<P>
To create a new object on the fly, you first must set up a place to put it. To do this, allocate a memory block on the global heap (you can instead use an existing object block, of course) and set it up with the proper flags and header to be an object block. There is no need to lock the chosen block on the heap. The block is now set up to receive the new object.</P>
<P>
<A NAME="GOCLanguage_15.htm_IX_ObjInstantiate()">
 </A>
To actually create the new object, call the kernel routine <CODE>
ObjInstantiate()</CODE>
. This will lock the block on the heap, create a chunk in the object block and zero the instance chunk. If the object is of a class with master parts, the instance chunk will remain uninitialized until the first time a class in the master group receives any message. If the class is a direct descendant of <CODE>
MetaClass</CODE>
, the instance chunk will be immediately initialized to default values with <CODE>
MSG_META_INITIALIZE</CODE>
. If you want to change or add to the default data of this type of object, subclass <CODE>
MSG_META_INITIALIZE</CODE>
; be sure to call the superclass first. To initialize any master group of an object, send it a classed event that will be handled by a class in that master level.

</P>
<P>
After calling <CODE>
ObjInstantiate()</CODE>
, the block will be automatically unlocked. An example of instantiating a new object is shown in <A HREF="#GOCLanguage_15.htm_91091"> Instantiating an Object</A>
. Generic objects created this way may then be added to a generic tree and set usable. They may be destroyed using <CODE>
MSG_GEN_DESTROY</CODE>
.</P>
<P CLASS="figTitle">
Code Display 5-19 <A NAME="GOCLanguage_15.htm_91091">
 </A>
Instantiating an Object</P>
<PRE>/* This sample of code belongs to a sample GenInteraction object (the object would
 * have to be a subclass of GenInteractionClass). It does several things:
 *	1.	It instantiates a new GenTrigger object. The new
 *		GenTrigger will be added to the same object block
 *		containing the GenInteraction handling the message.
 *	2.	It adds the new GenTrigger as a child of the
 *		SampInteraction (the handling object).
 *	3.	It sets the GenTrigger usable and enabled. */</PRE>
<PRE>@method SampInteractionClass, MSG_SAMP_INTERACTION_CREATE_TRIGGER {
    optr 		newTrig;</PRE>
<PRE>    newTrig = ObjInstantiate(OptrToHandle(oself),
				(ClassStruct *)&amp;GenTriggerClass);
	/* The two parameters are the handle of an object block and the
	 * pointer to a class definition. The object block is the same
	 * one containing the GenInteraction, whose optr is contained in
	 * the standard oself parameter. The class structure pointer points
	 * to the class definition of GenTriggerClass. */</PRE>
<PRE>	/* Now set the trigger as the last child of the GenInteraction. */
    @call self::MSG_GEN_ADD_CHILD(newTrig, (CCF_MARK_DIRTY | CCF_LAST);</PRE>
<PRE>	/* Now set the trigger usable and enabled. */
    @call newTrig::MSG_GEN_SET_USABLE(VUM_DELAYED_VIA_UI_QUEUE);
    @call newTrig::MSG_GEN_SET_ENABLED(VUM_NOW);
}</PRE>


<H5 CLASS="HeadingD">
Copying a Generic Tree</H5>
<P>
<A NAME="GOCLanguage_15.htm_IX_MSG_GEN_COPY_TREE">
 </A>
The fourth way to create new objects is by using the message <CODE>
MSG_GEN_COPY_TREE</CODE>
. This, when sent to a generic object in a generic tree, copies an entire generic tree below and including the object into another, pre-existing object block.</P>
<P>
This is an easy way to copy generic trees, one of the more common purposes of creating new objects. However, it only works with the generic objects (with a superclass <CODE>
GenClass</CODE>
). Trees created using <CODE>
MSG_GEN_COPY_TREE</CODE>
 can be destroyed with <CODE>
MSG_GEN_DESTROY</CODE>
.</P>
<P>
For an example of <CODE>
MSG_GEN_COPY_TREE</CODE>
 use, see the SDK_C\GENTREE sample application.</P>



<H4 CLASS="HeadingC">
Working With Object Blocks</H4>
<PRE>ObjIncInUseCount(), ObjDecInUseCount(), ObjLockObjBlock(), ObjFreeObjBlock(), ObjFreeDuplicate(), ObjTestIfObjBlockRunByCurThread(), ObjBlockSetOutput(), ObjBlockGetOutput()</PRE>
<P>
Once you have an object block created, either with <CODE>
ObjDuplicateResource()</CODE>
 or with the memory routines, there are several things you can do with it. It may be treated as a normal memory block, but there are also several routines for use specifically with object blocks:</P>
<P>
<CODE>
ObjIncInUseCount()</CODE>
<A NAME="GOCLanguage_15.htm_IX_ObjIncInUseCount()">
 </A>
 and <A NAME="GOCLanguage_15.htm_IX_ObjDecInUseCount()">
 </A>
<CODE>
ObjDecInUseCount()</CODE>
 increment and decrement an object block's in-use count (used to ensure the block can't be freed while an object is still receiving messages). <A NAME="GOCLanguage_15.htm_IX_ObjLockObjBlock()">
 </A>
<CODE>
ObjLockObjBlock()</CODE>
 locks the object block on the global heap. <A NAME="GOCLanguage_15.htm_IX_ObjFreeObjBlock()">
 </A>
<CODE>
ObjFreeObjBlock()</CODE>
 frees any object block. <A NAME="GOCLanguage_15.htm_IX_ObjFreeDuplicate()">
 </A>
<CODE>
ObjFreeDuplicate()</CODE>
 is the low-level routine which frees an object block created with <CODE>
ObjDuplicateResource()</CODE>
. <CODE>
ObjTestIfObjBlockRunByCurThread()</CODE>
<A NAME="GOCLanguage_15.htm_IX_ObjTestIfObjBlockRunByCurThread()">
 </A>
 returns a Boolean value indicating whether the calling thread runs a given object block. <CODE>
ObjBlockSetOutput()</CODE>
<A NAME="GOCLanguage_15.htm_IX_ObjBlockSetOutput()">
 </A>
 and <A NAME="GOCLanguage_15.htm_IX_ObjBlockGetOutput()">
 </A>
<CODE>
ObjBlockGetOutput()</CODE>
 set and return the optr of the object set to receive output messages (i.e., messages sent with travel option TO_OBJ_BLOCK_OUTPUT) from all the objects within the object block.</P>


<H4 CLASS="HeadingC">
Working With Individual Objects</H4>
<PRE>ObjIsObjectInClass(), ObjIsClassADescendant(), ObjGetFlags(), ObjGetFlagsHandles(), ObjSetFlags(), ObjSetFlagsHandles(), ObjDoRelocation(), ObjDoUnRelocation(), ObjResizeMaster(), ObjInitializeMaster(), ObjInitializePart()</PRE>
<P>
The kernel supplies several routines for working with and modifying individual object chunks and object data. These are all described fully in the Routine Reference Book; most are not commonly used by applications.</P>
<P>
<CODE>
ObjIsObjectInClass()</CODE>
<A NAME="GOCLanguage_15.htm_IX_ObjIsObjectInClass()">
 </A>
 takes a class and an optr and returns whether the object is a member of the class. <A NAME="GOCLanguage_15.htm_IX_ObjIsClassADescendant()">
 </A>
A related message, <CODE>
ObjIsClassADescendant()</CODE>
 determines whether a given class is a subclass of another. <A NAME="GOCLanguage_15.htm_IX_ObjGetFlags()">
 </A>
<CODE>
ObjGetFlags()</CODE>
 returns the object flags for a given object instance chunk; <A NAME="GOCLanguage_15.htm_IX_ObjSetFlags()">
 </A>
<CODE>
ObjSetFlags()</CODE>
 sets the flags to passed values. <A NAME="GOCLanguage_15.htm_IX_ObjGetFlagsHandles()">
 </A>
<A NAME="GOCLanguage_15.htm_IX_ObjSetFlagsHandles()">
 </A>
<CODE>
ObjGetFlagsHandles()</CODE>
 and <CODE>
ObjSetFlagsHandles()</CODE>
 refer to objects by means of handles instead of optrs. <CODE>
ObjDoRelocation()</CODE>
<A NAME="GOCLanguage_15.htm_IX_Relocatable data:kernel routines">
 </A>
<A NAME="GOCLanguage_15.htm_IX_ObjDoRelocation()">
 </A>
 processes any passed instance data fields in the object declared as relocatable; <A NAME="GOCLanguage_15.htm_IX_ObjDoUnRelocation()">
 </A>
<CODE>
ObjDoUnRelocation()</CODE>
 returns the passed relocatable fields to their index values.</P>
<P>
<CODE>
ObjInitializeMaster()</CODE>
<A NAME="GOCLanguage_15.htm_IX_ObjInitializeMaster()">
 </A>
 causes the system to build out a particular master group's instance data for an object. <A NAME="GOCLanguage_15.htm_IX_ObjInitializePart()">
 </A>
<CODE>
ObjInitializePart()</CODE>
 causes the system to build all master groups above and including the passed level. (This will also resolve variant classes.) <A NAME="GOCLanguage_15.htm_IX_ObjResizeMaster()">
 </A>
<CODE>
ObjResizeMaster()</CODE>
 resizes a given master part of the instance chunk, causing the chunk to be resized.</P>


<H4 CLASS="HeadingC">
<A NAME="GOCLanguage_15.htm_95668">
 </A>
Managing Object Trees</H4>
<PRE>ObjLinkFindParent(), ObjCompAddChild(), ObjCompRemoveChild(), ObjCompMoveChild(), ObjCompFindChildByOptr(), ObjCompFindChildByNumber(), ObjCompProcessChildren()</PRE>
<P>
Many objects will be part of object trees. Nearly all generic UI and visible objects exist as members of trees for organizational purposes. Object trees can be useful, powerful, and convenient mechanisms for organizing your objects.</P>
<P>
An object tree is made up of &quot;composite&quot; objects--objects which may or may not have children. The distinguishing characteristic of a composite object is that it has one instance data field declared with the <CODE>
@composite</CODE>
 keyword and another declared with the <CODE>
@link</CODE>
 keyword. The <CODE>
@composite</CODE>
 field contains a pointer to the object's first child in the tree, and the <CODE>
@link</CODE>
 field contains a pointer to the object's next sibling. </P>
<P>
If you set up an object resource block containing composite objects, it's very easy to set up an object tree. Your generic UI objects are declared in a tree with the GenApplication object at its head. Additionally, it's easy to alter an object tree once it's been created. The kernel provides several routines, and <CODE>
MetaClass</CODE>
 uses several messages for adding, removing, and moving objects to, from, and within trees.</P>
<UL>
<LI>
<CODE>
ObjLinkFindParent()<BR>
</CODE>
<A NAME="GOCLanguage_15.htm_IX_ObjLinkFindParent()">
 </A>
This routine finds the optr of the calling object's direct parent. The kernel traverses the link fields until it returns to the parent object.</LI>
<LI>
<CODE>
ObjCompFindChildByOptr()<BR>
</CODE>
<A NAME="GOCLanguage_15.htm_IX_ObjCompFindChildByOptr()">
 </A>
This routine returns the number of the child (first, second, third, etc.) whose optr is passed. The child must exist and must be a child of the calling object.</LI>
<LI>
<CODE>
ObjCompFindChildByNumber()<BR>
</CODE>
<A NAME="GOCLanguage_15.htm_IX_ObjCompFindChildByNumber()">
 </A>
This routine returns the optr of the child whose number (first, second, etc.) is passed.</LI>
<LI>
<CODE>
ObjCompAddChild()<BR>
</CODE>
<A NAME="GOCLanguage_15.htm_IX_ObjCompAddChild()">
 </A>
This routine takes an object's optr and adds it to the caller's list of children. Depending on the flags passed, the child may be inserted in any child position (first, second, etc.).</LI>
<LI>
<CODE>
ObjCompMoveChild()<BR>
</CODE>
<A NAME="GOCLanguage_15.htm_IX_ObjCompMoveChild()">
 </A>
This routine takes a child object and moves it to a new position. However, it will still remain a child of the calling object. If you want to move the child to be a child of a different object, you must first remove it from the tree altogether and then add it to the other parent.</LI>
<LI>
<CODE>
ObjCompRemoveChild()<BR>
</CODE>
<A NAME="GOCLanguage_15.htm_IX_ObjCompRemoveChild()">
 </A>
This routine removes a child object from the object tree.</LI>
<LI>
<CODE>
ObjCompProcessChildren()<BR>
</CODE>
<A NAME="GOCLanguage_15.htm_IX_ObjCompProcessChildren()">
 </A>
This routine calls a callback routine for each child of the calling object in turn. The callback routine may do virtually anything (except destroy the object or free its chunk or something similar).</LI>
</UL>
<P>
By using the above routines, you can fully manipulate any object tree and the objects within it.
<IMG SRC="GOCLanguage_15_objTree.gif">

</P>


<H4 CLASS="HeadingC">
<A NAME="GOCLanguage_15.htm_57162">
 </A>
Detaching and Destroying Objects</H4>
<PRE>MSG_META_DETACH, MSG_META_DETACH_COMPLETE, MSG_META_ACK, MSG_META_OBJ_FLUSH_INPUT_QUEUE, MSG_META_OBJ_FREE, MSG_META_FINAL_OBJ_FREE, ObjInitDetach(), ObjIncDetach(), ObjEnableDetach(), ObjFreeChunk(), ObjFreeChunkHandles()</PRE>
<P>
<A NAME="GOCLanguage_15.htm_IX_Objects:detaching">
 </A>
While creating objects is actually quite simple, detaching and destroying them can be quite involved. For this reason, GEOS does most of the work for you, and in most cases you won't have to worry about what happens when your application is shut down or saved to a state file. However, if you instantiate individual objects of your own classes, you should be very careful about how your objects are detached from the system and destroyed.

</P>
<P>
Detaching objects involves severing all of the object's ties with the rest of the system. Destruction of an object entails actually removing the object's instance chunk and related structures, making sure that it has handled all its waiting messages.</P>
<P>
Throughout its life, an object is likely to become involved with a number of other things--other objects, drivers, files, streams, the memory manager, the kernel--and each of these things may send the object messages from time to time. The task, when detaching an object from the system, is to sever all the object's ties with the outside world, to make sure that no other entity will ever try to contact the object again.</P>
<P>
<A NAME="GOCLanguage_15.htm_IX_Active list:and detaching">
 </A>
To those unfamiliar with these problems, they can be overwhelming. However, GEOS takes care of them for you in most situations. All generic and visible objects, all objects in object trees, and all objects that maintain an &quot;active list&quot; will automatically (in nearly all cases) have the detach functionality built in by <CODE>
MetaClass</CODE>
.</P>

<H5 CLASS="HeadingD">
The Detach Sequence</H5>
<P>
<A NAME="GOCLanguage_15.htm_IX_MSG_META_DETACH">
 </A>
When an object receives <CODE>
MSG_META_DETACH</CODE>
, it begins the detach sequence to sever all its ties with other entities in the system. It must first notify all its children and all the objects on its various notification lists that it will be going away (most often, all its children, by association, will also be detached). It then must clear its message queues. Finally, it must acknowledge its detachment to the object that originally sent <CODE>
MSG_META_DETACH</CODE>
. Each of these phases is described in detail below and is implemented by <CODE>
MetaClass</CODE>
. You have to do none of this work unless your object is truly a special case.</P>
<P>
Detaching in conjunction with destruction is somewhat intricate because not only must the object notify all other interested parties, but it must also receive acknowledgment of the notice. Otherwise, the notification and some other message could be sent at the same time, and the object could be destroyed before the notification can be handled. (Destruction is discussed in the following section.)</P>
<P>
Because any object may be put in the position of being detached and then immediately destroyed, it must send out notification and then wait until all the notices have been acknowledged before continuing with other tasks. The kernel and <CODE>
MetaClass</CODE>
 implement a mechanism for this using four kernel routines. Again, you do not need to do this since all classes have <CODE>
MetaClass</CODE>
 as their root.</P>
<P>
<A NAME="GOCLanguage_15.htm_IX_ObjInitDetach()">
 </A>
First the object being detached (in its <CODE>
MSG_META_DETACH</CODE>
 handler) calls the routine <CODE>
ObjInitDetach()</CODE>
. This tells the kernel that the object is initiating a detach sequence and that the acknowledgment mechanism must be set up. The kernel will allocate a variable data entry to hold a count of the number of notices sent and acknowledgments received.</P>
<P>
<A NAME="GOCLanguage_15.htm_IX_ObjIncDetach()">
 </A>
After this, the object must send a <CODE>
MSG_META_DETACH</CODE>
 or its equivalent to each of its children and each of the objects on its &quot;active list.&quot; With each notice sent, the object <EM>
must</EM>
 call <CODE>
ObjIncDetach()</CODE>
, which increments the notice count.</P>
<P>
<A NAME="GOCLanguage_15.htm_IX_ObjEnableDetach()">
 </A>
After sending all the notices, the object then calls the kernel routine <CODE>
ObjEnableDetach()</CODE>
. This notifies the kernel that all the notices have been sent and that the object is waiting for the acknowledgments.</P>
<P>
<A NAME="GOCLanguage_15.htm_IX_MSG_META_ACK">
 </A>
Acknowledgment comes in the form of <CODE>
MSG_META_ACK</CODE>
 and is received by the object being detached. <CODE>
MSG_META_ACK</CODE>
 is handled by <CODE>
MetaClass</CODE>
 and will decrement the notice count, essentially saying there are one fewer notices left to be received. <A NAME="GOCLanguage_15.htm_IX_MSG_META_DETACH_COMPLETE">
 </A>
When the final <CODE>
MSG_META_ACK</CODE>
 is received (setting the notice count to zero) and <CODE>
ObjEnableDetach()</CODE>
 has <EM>
also</EM>
 been called, the kernel will automatically send a <CODE>
MSG_META_DETACH_COMPLETE</CODE>
 to the object. This assures the object that it will never receive another message from another entity in the system.</P>
<P>
The final step in the detach sequence is acknowledging that the object has been detached. In its <CODE>
MSG_META_DETACH_COMPLETE</CODE>
 handler, the object should send a <CODE>
MSG_META_ACK</CODE>
 to the object that originated the detach sequence. This will allow that object to continue with its detach sequence if it was involved in one; without this step, only leaves of object trees could ever be detached. This final step is provided in default handlers in <CODE>
MetaClass</CODE>
 and is inherited by all objects.</P>
<P>
<A NAME="GOCLanguage_15.htm_IX_ObjFreeChunkHandles()">
 </A>
<A NAME="GOCLanguage_15.htm_IX_ObjFreeChunk()">
 </A>
To free a chunk, perhaps a chunk used to store an object, use the <CODE>
ObjFreeChunk()</CODE>
 routine. Normally this will free the chunk; however if the chunk is storing an object from a resource, the chunk will instead be dirtied and resized to zero. To free a chunk referenced by handles, call <CODE>
ObjFreeChunkHandles()</CODE>
 instead.</P>


<H5 CLASS="HeadingD">
The Destruction Sequence</H5>
<P>
<A NAME="GOCLanguage_15.htm_IX_Objects:destruction">
 </A>
<A NAME="GOCLanguage_15.htm_IX_MSG_META_OBJ_FREE">
 </A>
The destruction sequence must be initiated from outside and will begin when the object receives a <CODE>
MSG_META_OBJ_FREE</CODE>
. Often, the <CODE>
MSG_META_OBJ_FREE</CODE>
 will be sent by the object to itself.</P>
<P>
The destruction sequence consists of three steps: First, the object must clear out its message queues; even though it is detached and can not receive new messages, there may be some left over in the queue (an error if it occurs). Second, it must finish executing its code and working with its instance data. Third, it must free its instance chunk. Each of these steps is described below.</P>
<P>
Even though the object has notified the rest of the system that it is going away, it still must flush its message queues of any unhandled messages. These messages could have been received between the time the original <CODE>
MSG_META_OBJ_FREE</CODE>
 was received and notification was sent out (due to interrupts or context switching). <A NAME="GOCLanguage_15.htm_IX_MSG_META_OBJ_FLUSH_INPUT_QUEUE">
 </A>
To clear its message queues, the object must send itself a <CODE>
MSG_META_OBJ_FLUSH_INPUT_QUEUE</CODE>
, which will ensure that any messages in the queues are handled appropriately before the object shuts down. This step is handled automatically by the <CODE>
MSG_META_OBJ_FREE</CODE>
 handler in <CODE>
MetaClass</CODE>
. You should never have to send this message, and indeed its use is discouraged.</P>
<P>
To the outside world, the second and third steps seem like a single step. However, <CODE>
MSG_META_OBJ_FREE</CODE>
 can not simply free the instance chunk after the queues are cleared; it must be able to access the instance chunk until all the method code has been executed. <A NAME="GOCLanguage_15.htm_IX_MSG_META_FINAL_OBJ_FREE">
 </A>
So, <CODE>
MSG_META_OBJ_FREE</CODE>
 sends the final message to the object, <CODE>
MSG_META_FINAL_OBJ_FREE</CODE>
, and then exits. <CODE>
MSG_META_FINAL_OBJ_FREE</CODE>
 waits a short while and then frees the object's chunk. This ensures that <CODE>
MSG_META_OBJ_FREE</CODE>
 has finished and the chunk is not being used by any code.</P>


<H5 CLASS="HeadingD">
Possible Pitfalls</H5>
<P>
If you're not careful, you can cause the detach mechanism to fail by instantiating an object on the fly and saving that object's optr. If the object is then detached and you don't account for the saved optr, you could later send a message to a nonexistent object. This has undefined results and can be nearly impossible to track down.</P>
<P>
Note that objects created within resources and by <CODE>
ObjDuplicateResource()</CODE>
 will almost always automatically be taken care of by the detach mechanism. Objects you create with <CODE>
ObjInstantiate()</CODE>
 are the ones to be careful with.</P>



<H4 CLASS="HeadingC">
<A NAME="GOCLanguage_15.htm_73804">
 </A>
Saving Object State</H4>
<PRE>ObjSaveBlock(), ObjMarkDirty(), ObjMapSavedToState(), ObjMapStateToSaved()</PRE>
<P>
Object state saving is almost entirely contained within the system. For the most part, only UI objects are saved to state files; however, you can mark other object blocks for saving. State saving is described in full in <A HREF="../../Kernel/Geodes/Geodes_5.htm#76203">the Applications and Geodes chapter</A>.</P>
<HR>
This document is a single-page version of a <A HREF="index.htm">a multi-page document</A>, suitable for easy printing.
</BODY>
</HTML>
