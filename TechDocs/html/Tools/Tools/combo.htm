<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD>
<!-- This page was automatically generated from a bunch of smaller pages. -->
<META NAME="copyright" CONTENT="Copyright GEOWORKS">
<LINK REL="STYLESHEET" HREF="../../docHelpers/style.css">
<LINK REV="MADE" HREF="mailto:doc-feedback@geoworks.com">
<TITLE>Using Tools</TITLE>
</HEAD>
<BODY BGCOLOR="#ffffdf">
This document is a single-page version of a <A HREF="index.htm">a multi-page document</A>, suitable for easy printing.
<A NAME="index.htm
"></A>



<H1 CLASS="chapterTitle">

<A NAME="index.htm
_97933">
 </A>
Using Tools

</H1>
<P>
This chapter gives a reference of the tools included in this development kit. This chapter is not intended to teach you how to use the tools; it provides a reference only. To learn how to use most of the tools, see the Tutorial included in the development kit and the First Steps chapter in the Concepts book.</P>

<P CLASS="sectionlinks">
<STRONG>
&nbsp;&nbsp;<A HREF="#TTools_1.htm">1 Tools Summary</A><BR>
&nbsp;&nbsp;<A HREF="#TTools_2.htm">2 Typical Development Session</A><BR>
&nbsp;&nbsp;<A HREF="#TTools_3.htm">3 File Types</A><BR>
&nbsp;&nbsp;<A HREF="#TTools_4.htm">4 Esp</A><BR>
&nbsp;&nbsp;<A HREF="#TTools_5.htm">5 Glue</A><BR>
&nbsp;&nbsp;<A HREF="#TTools_6.htm">6 Goc</A><BR>
&nbsp;&nbsp;<A HREF="#TTools_7.htm">7 Grev</A><BR>
&nbsp;&nbsp;<A HREF="#TTools_8.htm">8 mkmf</A><BR>
&nbsp;&nbsp;<A HREF="#TTools_9.htm">9 pccom</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#TTools_a.htm">9.1 PCCOM Background</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#TTools_b.htm">9.2 Running PCCOM on the Target</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#TTools_c.htm">9.3 File Transfer Protocol of PCCOM</A><BR>
&nbsp;&nbsp;<A HREF="#TTools_d.htm">10 pcget</A><BR>
&nbsp;&nbsp;<A HREF="#TTools_e.htm">11 pcs</A><BR>
&nbsp;&nbsp;<A HREF="#TTools_f.htm">12 pcsend</A><BR>
&nbsp;&nbsp;<A HREF="#TTools_10.htm">13 pmake</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#TTools_11.htm">13.1 Copyright Notice and Acknowledgment</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#TTools_12.htm">13.2 How to Customize pmake</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#TTools_13.htm">13.3 Command Line Arguments</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#TTools_14.htm">13.4 Contents of a Makefile</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#TTools_15.htm">13.5 Advanced pmake Techniques</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#TTools_16.htm">13.6 The Way Things Work</A><BR>
&nbsp;&nbsp;<A HREF="#TTools_17.htm">14 Swat Stub</A><BR>
&nbsp;&nbsp;<A HREF="#dumpgeo.htm">15 dumpgeo</A><BR>
&nbsp;&nbsp;<A HREF="#cvtpcx.htm">16 cvtpcx</A><BR>
&nbsp;&nbsp;<A HREF="#pvm.htm">17 pvm</A><BR>
</STRONG>
</P> <!-- end of sectionlinks blob -->

<HR>
<A NAME="TTools_1.htm
"></A>


<H2 CLASS="sectionTitle">
<A HREF="#index.htm">Using Tools</A>: 1 
Tools Summary</H2>
<P>
The tools provided in this kit are listed below. Each is described in full in the following sections.</P>
<DL>
<DT>
<STRONG>
pmake</STRONG>
 </DT><DD>&quot;Make&quot; utility which has knowledge of Goc. The <CODE>
pmake</CODE>
 tool manages geode compilation and linking, making appropriate calls to Goc and Glue.</DD>
<DT>
<STRONG>
Goc</STRONG>
 </DT><DD>C preprocessor which is aware of programming constructs specific to GEOS programming. The Goc tool looks for special keywords (such as @class and @object) and creates the proper GEOS data structures so that the geode will work correctly after being compiled and linked. Chances are you won't call Goc directly but will instead use <CODE>
pmake</CODE>
, which will call Goc in turn.</DD>
<DT>
<STRONG>
Esp</STRONG>
</DT><DD>Assembler with awareness of GEOS programming constructs. Also includes support for creating enumerated types, complicated records, and more. Chances are you won't call Esp directly but will instead use <CODE>
pmake</CODE>
, which will call Esp in turn.</DD>
<DT>
<STRONG>
Glue</STRONG>
</DT><DD>GEOS linker. This determines how the program's resources should be set up and how those resources can be relocated. It determines file offsets and how to access library functions. As with Goc, you probably won't call Glue directly but will instead use it through <CODE>
pmake</CODE>
.</DD>
<DT>
<STRONG>
grev</STRONG>
 </DT><DD>Revision number generator. This is a handy utility for generating revision numbers for geodes, which may be used to keep track of library protocols. The <CODE>
pmake</CODE>
 program uses grev to keep track of incremental changes; if you make large changes to a geode at some point, you can use grev to modify your geode's revision file to reflect your changes.</DD>
<DT>
<STRONG>
mkmf</STRONG>
 </DT><DD>Makefile maker. Creates a MAKEFILE which will in turn be used by <CODE>
pmake</CODE>
 to determine how to create the geode's files.</DD>
<DT>
<STRONG>
pccom</STRONG>
 </DT><DD>Communication manager. Sets up communication over serial lines. This manages data transfer and protocols when sending files between machines or debugging.</DD>
<DT>
<STRONG>
pcs</STRONG>
 </DT><DD>Geode downloader. Sends geodes from the development machine to their proper directory on the target machine.</DD>
<DT>
<STRONG>
pcsend</STRONG>
 </DT><DD>File downloader. Sends an arbitrary file from the development machine to an arbitrary directory on the target machine.</DD>
<DT>
<STRONG>
pcget</STRONG>
</DT><DD>File uploader. Retrieves an arbitrary file on the target machine, transferring it to any directory on the development machine.</DD>
<DT>
<STRONG>
Swat</STRONG>
 </DT><DD>GEOS debugger. This program runs on the development machine, monitoring GEOS programs running on the target machine.</DD>
</DL>
<HR>
<A NAME="TTools_2.htm
"></A>


<H2 CLASS="sectionTitle">
<A HREF="#index.htm">Using Tools</A>: 2 
Typical Development Session</H2>
<P>
The Tutorial shows in detail how to write, compile, download, and debug an application. As a quick guide, however, the following list recaps the steps in a typical development session:</P>
<OL>
<LI>
On the development machine, use a text editor (perhaps the one that came with your compiler) to write or edit the source (.c and .goc files, perhaps .asm or .ui files if you have the Esp assembler), header (.h and .goh files, perhaps .def files if you have the Esp assembler), and Glue parameters (.gp files) for your geode.The source files for the geode should be arranged within your development directory.</LI>
<LI>
If you have never compiled the geode before or have added or included new files since the last compilation, you must run <CODE>
mkmf</CODE>
 to create or update the MAKEFILE.</LI>
<LI>
If you have added or included new files since the last compilation, you should execute <CODE>
pmake depend</CODE>
 so that the compiler will know which files need to be remade if one is altered.</LI>
<LI>
Run <CODE>
pmake</CODE>
. This compiles and links the geode's source files, using directions provided by the MAKEFILE.</LI>
<LI>
To test the geode, either run it on the target machine or run <CODE>
swat</CODE>
 from the development machine to debug it.</LI>
</OL>
<HR>
<A NAME="TTools_3.htm
"></A>


<H2 CLASS="sectionTitle">
<A HREF="#index.htm">Using Tools</A>: 3 
File Types</H2>
<P>
You may be curious to know what sorts of files you'll be working with. If you have to work with someone else's code, then being able to find your away around their files (knowing which are sources, which are objects, and which are chaff) can be very useful.</P>
<DL>
<DT>
<STRONG>
*.goc</STRONG>
<A NAME="TTools_3.htm
_IX_.goc files[;goc files]">
 </A>
 </DT><DD>These are Goc source files. You will write these files. They contain both standard C code and GEOS constructs (such as objects and messages).</DD>
<DT>
<STRONG>
*.goh</STRONG>
<A NAME="TTools_3.htm
_IX_.goh files[;goh files]">
 </A>
</DT><DD>These are Goc header files. You will write these files and include others. They provide definitions used by your .goc files (in the same relation as between standard C source and header files). Unlike standard C header files, these are included using the @include Goc keyword.</DD>
<DT>
<STRONG CLASS="fileName">
*.poh</STRONG>
<A NAME="TTools_3.htm
_IX_.ph files[;ph files]">
 </A>
<A NAME="TTools_3.htm
_IX_.poh files[;poh files]">
 </A>
, <STRONG CLASS="fileName">
*.ph</STRONG>
</DT><DD>These are files generated to optimize the @inclusion of .goh files. Goc will automatically generate these when they don't already exist.</DD>
<DT>
<STRONG CLASS="fileName">
*.doh</STRONG>
<A NAME="TTools_3.htm
_IX_.dh files[;dh files]">
 </A>
<A NAME="TTools_3.htm
_IX_.doh files[;doh files]">
 </A>
, <STRONG CLASS="fileName">
*.dh</STRONG>
</DT><DD>These are files generated to optimize the @inclusion of .goh files. They contain dependency information.</DD>
<DT>
<STRONG>
*.c</STRONG>
<A NAME="TTools_3.htm
_IX_.c files[;c files]">
 </A>
</DT><DD>These are standard C source files. You may write these as source files, using only standard ANSI C constructions. The Goc preprocessor will create .c files from .goc files. Thus, if you see two files with the same prefix, but one has the .c suffix and the other has the .goc suffix, then you know that the first was created from the second.</DD>
<DT>
</DT><DD>Note that Goc will create the generated .c file in the directory where it is invoked. Thus if your development tree contains files PROG\DIR1\CODE.GOC and PROG\DIR2\CODE.GOC, then if you convert these using Goc from the PROG directory, then one of the generated .c files will overwrite the other. Thus, you should never give .goc files the same prefix, even if they are in different directories.</DD>
<DT>
<STRONG>
*.h</STRONG>
<A NAME="TTools_3.htm
_IX_.h files[;h files]">
 </A>
</DT><DD>These are standard C header files. You may write these and include them using the ANSI C #include directive.</DD>
<DT>
<STRONG>
*.asm</STRONG>
<A NAME="TTools_3.htm
_IX_.asm files[;asm files]">
 </A>
</DT><DD>These are standard GEOS assembly source files, which may be assembled with the Esp assembler, if you have it. They may contain both standard assembly and Esp constructs.</DD>
<DT>
<STRONG>
*.def</STRONG>
<A NAME="TTools_3.htm
_IX_.def files[;def files]">
 </A>
 </DT><DD>These are standard GEOS assembly header files, which you may write or include if you have access to the Esp assembler.</DD>
<DT>
<STRONG>
*.mk, makefile</DT><DD>
</STRONG>
<A NAME="TTools_3.htm
_IX_Makefiles">
 </A>
<A NAME="TTools_3.htm
_IX_.mk files[;mk files]">
 </A>
These are &quot;makefiles,&quot; files which contain scripts which the <CODE>
pmake</CODE>
 tool will interpret and use to automatically compile and link your geode. In a source directory there will be a file called MAKEFILE (created with the <CODE>
mkmf</CODE>
 tool) and probably a file called DEPENDS.MK (created by calling <CODE>
pmake</CODE>
 <CODE>
depend</CODE>
). If you wish to customize how your geode is made, you will probably write a file called LOCAL.MK, containing your custom makefile script. The INCLUDE directory contains several .mk files, which will be #included by other makefiles.</DD>
<DT>
<STRONG>
*.gp</STRONG>
<A NAME="TTools_3.htm
_IX_.gp files[;gp files]">
 </A>
 </DT><DD><A NAME="TTools_3.htm
_IX_Geode parameters files">
 </A>
<A NAME="TTools_3.htm
_IX_Glue parameters files">
 </A>
These are &quot;Glue parameter&quot; or &quot;geode parameter&quot; files, which will give the Glue linker information necessary when linking a geode. You will write this file. The <CODE>
pmake</CODE>
 program assumes that a geode's .gp file will have name <EM>geode</EM>.GP, where <EM>geode</EM> is taken from the name of the directory containing the geode's source (e.g. in the example above, <CODE>
pmake</CODE>
 would expect the .gp file to be named PROG.GP).</DD>
<DT>
<STRONG>
*.ldf </STRONG>
<A NAME="TTools_3.htm
_IX_.ldf files[;ldf files]">
 </A>
</DT><DD><A NAME="TTools_3.htm
_IX_Library definition files">
 </A>
These are library definition files. Glue uses these files when linking your geode; they determine how your calls to a GEOS library will be encoded. If you are writing a library, then you will create one of these files by means of a <CODE>
pmake lib</CODE>
. The <CODE>
pmake</CODE>
 program looks for .ldf files in the INCLUDE\LDF directory.</DD>
<DT>
<STRONG>
*.rev</STRONG>
<A NAME="TTools_3.htm
_IX_.rev files[;rev files]">
 </A>
 </DT><DD><A NAME="TTools_3.htm
_IX_Revision files">
 </A>
This is a revision file, used to keep track of a program's revision and protocol levels (useful for tracking compatibility). The <CODE>
pmake</CODE>
 tool will look for a file with name <CODE>
geode</CODE>
.REV, where <EM>geode</EM> is taken from the name of the directory containing the geode's source (e.g. in the example above, <CODE>
pmake</CODE>
 would expect the .rev file to be named PROG.REV). The <CODE>
pmake</CODE>
 program uses <CODE>
grev</CODE>
 to create and maintain the .rev file; you should use grev yourself when you need to signal a major revision.</DD>
<DT>
<STRONG CLASS="fileName">
*.rsc</STRONG>
<A NAME="TTools_3.htm
_IX_.rsc files[;rsc files]">
 </A>
</DT><DD>Localization resource file. This file contains information which will be used by the ResEdit localization tool.</DD>
<DT>
<STRONG>
*.obj</STRONG>
<A NAME="TTools_3.htm
_IX_Object files">
 </A>
<A NAME="TTools_3.htm
_IX_.obj files[;obj files]">
 </A>
</DT><DD>These are object files. These are files created by a C compiler or Esp which may be linked to form an executable. The <CODE>
pmake</CODE>
 program uses Glue to link the object files.</DD>
<DT>
<STRONG>
*.ebj</STRONG>
<A NAME="TTools_3.htm
_IX_.ebj files[;ebj files]">
 </A>
</DT><DD>These are error-checking object files. GEOS supports the notion of &quot;error-checking code.&quot; When you write your programs, you can mark some commands as &quot;error checking commands.&quot; These commands might make sure that a routine is passed valid arguments or perhaps purposefully destroy some information which was not guaranteed preserved by a routine. Such commands may prove time-consuming but are useful for making sure that an application is robust. The <CODE>
pmake</CODE>
 program will create two versions of your application--one which includes the EC (Error Checking) code, and one which doesn't. Run the EC program to check for correctness, but use the non-EC version when the program should be fast (i.e. this is the version you should give to your customers).</DD>
<P>
The .obj files will be linked to form a non-EC executable; .ebj files to form an EC executable.</P>
<DT>
<STRONG>
*.geo</STRONG>
<A NAME="TTools_3.htm
_IX_Geode files">
 </A>
<A NAME="TTools_3.htm
_IX_.geo files[;geo files]">
 </A>
</DT><DD>This is a Geode, a GEOS executable (either an application, library, or driver), the end result of your efforts. These are the files containing the code for GEOS programs which the user will interact with. They are created by linking together a number of .obj files, with additional information provided by a .gp file. You will place these files in your GEOS testing directory on your target machine (along with *ec.geo files, described below).</DD>
<DT>
<STRONG>
*ec.geo</STRONG>
<A NAME="TTools_3.htm
_IX_ec.geo files">
 </A>
<A NAME="TTools_3.htm
_IX_EC files">
 </A>
</DT><DD>This is an error checking geode. (See above for quick descriptions of error checking code and geodes.) They are created by linking together a number of .obj and .ebj files, with additional information provided by a .gp file.</DD>
<DT>
<STRONG>
*.sym</STRONG>
<A NAME="TTools_3.htm
_IX_Symbol files">
 </A>
<A NAME="TTools_3.htm
_IX_.sym files[;sym files]">
 </A>
</DT><DD>This is a symbol file, containing symbolic debugging information which the Swat debugger can use to access the geode's data structures.</DD>
<DT>
<STRONG>
*ec.sym</STRONG>
<A NAME="TTools_3.htm
_IX_ec.sym files">
 </A>
 </DT><DD>This is the symbol file of the error checking version of a geode.</DD>
<DT>
<STRONG>
tmp*.*</STRONG>
<A NAME="TTools_3.htm
_IX_tmp files">
 </A>
</DT><DD>These are temporary files which <CODE>
pmake</CODE>
 will create and destroy while making your executable. The <CODE>
pmake</CODE>
 program uses these files to pass arguments to the other tools. Thus, if you see a file of this name in your directory and you didn't create it, you can assume that <CODE>
pmake</CODE>
 was interrupted in a recent make and was unable to erase the file (and thus it is safe for you to erase it).</DD>
<DT>
<STRONG>
.tcl</STRONG>
, <STRONG>
.tlc</STRONG>
</DT><DD>These are Tcl files, files containing Tool Command Language source code, used by the Swat debugging tool. The <STRONG CLASS="fileName">
.tcl</STRONG>
 files contain Tcl source code, the <STRONG CLASS="fileName">
.tlc</STRONG>
 files contain compiled Tcl code. The source code may be edited by any text editor and Swat will interpret it; compiled code runs more quickly, but can only be changed by editing the source code and re-compiling.</DD>
</DL>
<P>
If you are writing a GEOS C application, you will write the following types of files:</P>
<UL>
<LI>
Source files: .goc files, optional .c files.</LI>
<LI>
Glue parameters file: <EM>geode</EM>.GP.</LI>
<LI>
Optional header files: .goh files, .h files.</LI>
<LI>
Optional custom make file: LOCAL.MK.</LI>
</UL>
<P>
After you have made your geode the first time (creating a makefile with <CODE>
mkmf</CODE>
, a dependencies file with <CODE>
pmake depend</CODE>
, and the geode itself with <CODE>
pmake</CODE>
), your directory should contain the following additional file types:</P>
<UL>
<LI>
Intermediary C files: .c files (made by transforming .goc files).</LI>
<LI>
Makefile: MAKEFILE </LI>
<LI>
Dependencies file: DEPEND.MK </LI>
<LI>
Revision file: <EM>geode</EM>.REV. </LI>
<LI>
Object files: .obj and .ebj files.</LI>
<LI>
Symbol files: .sym files</LI>
<LI>
Geodes: .geo files.</LI>
</UL>
<HR>
<A NAME="TTools_4.htm
"></A>


<H2 CLASS="sectionTitle">
<A HREF="#index.htm">Using Tools</A>: 4 
Esp</H2>
<P>
Esp (pronounced &quot;esp&quot;) is the GEOS assembler. It creates object files from Esp code--said code using a superset of MASM syntax. These object files may then be linked by means of the Glue tool.</P>
<P>
Most users will never call Esp directly, instead going through <CODE>
pmake</CODE>
, which will make the proper calls to Esp for the most common cases.</P>
<P>
Esp takes the following options:</P>
<DL>
<DT>
<STRONG>
-2</STRONG>
</DT><DD>Code produced should be DBCS--characters will be two bytes instead of one.</DD>
<DT>
<STRONG>
-I</STRONG>
 <STRONG>
directory</STRONG>
</DT><DD>Specifies an additional directory in which to look for included files.</DD>
<DT>
<STRONG>
-o </STRONG>
<STRONG>
filename</STRONG>
</DT><DD>Name to give to created object file.</DD>
<DT>
<STRONG>
-w </STRONG>
<STRONG>
warntype</STRONG>
 </DT>
<DT>
-<STRONG>
W</STRONG>
 <STRONG>
warntype</STRONG>
</DT><DD>			Turn warnings off or on</DD>
<DL>
<DT>
<STRONG>
unref</STRONG>
 </DT><DD>Warn if a symbol that can only be used during this assembly isn't.</DD>
<DT>
<STRONG>
field</STRONG>
 </DT><DD>Warn if structure field used with . operator when lhs isn't of the type that contains the field	</DD>
<DT>
<STRONG>
shadow</STRONG>
 </DT><DD>Warn if a local variable or procedure overrides a definition in a larger scope</DD>
<DT>
<STRONG>
private</STRONG>
 </DT><DD>Warn if a private method or instance variable is used outside a method handler or friend function related to the class that defined the thing</DD>
<DT>
<STRONG>
unreach</STRONG>
 	Warn about code that cannot be reached. This is very simplistic</DT><DD>
unknown Warn if a far call is made to a routine whose segment is unknown</DD>
<DT>
<STRONG>
record</STRONG>
 </DT><DD>Warn if a record initializer doesn't contain all the fields of the record</DD>
<DT>
<STRONG>
fall_thru</STRONG>
 </DT><DD>Warn if a function falls into another one without a .fall_thru directive</DD>
<DT>
<STRONG>
inline_data</STRONG>
 </DT><DD> Warn if a variable is defined where execution can reach</DD>
<DT>
<STRONG>
unref_local</STRONG>
 </DT><DD>Warn if a local label isn't ever referenced	</DD>
<DT>
<STRONG>
jmp</STRONG>
 </DT><DD>Warn if out-of-range jumps are transformed into short jumps around near jumps</DD>
<DT>
<STRONG>
assume</STRONG>
 </DT><DD>Warn when override is generated based on segment assumptions</DD>
<DT>
<STRONG>
all</STRONG>
</DT><DD>Used to turn all warnings on or off.</DD>
</DL>
<DT>
<STRONG>
-M</STRONG>
</DT><DD>This assembly is just for the purpose of determining what the source file's dependencies is. Instead of creating an object file, Esp will create a temporary file which the dependencies maker will use to determine the dependencies.</DD>
<DT>
<STRONG>
-d</STRONG>
</DT><DD>Activate's Esp debugging mode. Useful only when trying to track down a bug in Esp.</DD>
</DL>
<HR>
<A NAME="TTools_5.htm
"></A>


<H2 CLASS="sectionTitle">
<A HREF="#index.htm">Using Tools</A>: 5 
<A NAME="TTools_5.htm
_18145">
 </A>y/combo.htm"
Glue</H2>
<P>
<A NAME="TTools_5.htm
_IX_Glue">
 </A>
Glue is the GEOS linker. It creates GEOS or DOS executables from object files. (It can also create GEOS VM and font files, if you have the appropriate tools.) These object files may have been created by a C compiler, or by the Esp assembler. To create the executables, Glue must create a combined file, resolve external declarations, determine how to call libraries, and apportion the code and data into resources. Glue will also create a .sym file--a file containing symbolic debugging information which the Swat debugger will use for viewing the geode's data.</P>
<P>
Most users will never call Glue directly, instead going through <CODE>
pmake</CODE>
, which will make the proper calls to Glue for the most common cases. If you use the default makefiles, the variable LINKFLAGS will determine which arguments Glue receives; thus, by creating a local makefile that modifies this variable's value, you can pass more flags to glue. See <A HREF="#TTools_12.htm_65382"> How to Customize pmake</A>
 for help in creating a local makefile.</P>
<P>
The Glue application takes the following arguments:</P>
<PRE>glue @file
glue &lt;flags&gt; &lt;objFile&gt;+ [-l&lt;objFile&gt;]*</PRE>
<DL>
<DT>
<EM>
@file</EM>
</DT><DD>The Glue linker should take its arguments from the file <EM>
file</EM>
 in addition to those on the command line. This may come in handy if you often use the same long string of options. Since you may need to pass Glue more arguments than may be input on the command line, sometimes this option is necessary.</DD>
<P>
Note that if you use this option, then all arguments must be included in the file--there should be no others on the command line itself.</P>
<P>
The <CODE>
pmake</CODE>
 program uses this option to pass arguments to Glue.</P>
<DT>d/combo.htm"
<STRONG>
-D</STRONG>
<STRONG>
var</STRONG>
<STRONG>
</DT><DD></STRONG>
Defines the variable <EM>
var</EM>
; used with <CODE>
ifdef</CODE>
 statements within the .gp file to allow for conditional linking (see <A HREF="../../LRef/GPKey/index.htm">the GP file keyword reference</A>
 for the syntax of Glue's ifdef statements). </DD>
<DT>
<STRONG>
-L</STRONG>
 <STRONG>
path</STRONG>
</DT><DD>Specifies where Glue looks for .ldf (library definition) files. These files are placed in a standard directory by the system makefiles on a &quot;<CODE>
pmake</CODE>
 lib�.</DD>
<DT>
<STRONG>
-N</STRONG>
 <STRONG>
string</STRONG>
 </DT><DD>Specify a copyright notice.  This string must be 32 characters or less.</DD>
<DT>
<STRONG>
-Oe</STRONG>
 </DT><DD>Creating DOS executable (&quot;.exe&quot;) file. Of course, this option is not valid if the object files contain GEOS directives which will not work outside GEOS.</DD>
<DT>
<STRONG>
-Oc</STRONG>
</DT><DD>Creating DOS command (&quot;.com&quot;) file. Of course, this option is not valid if the object files contains GEOS directives which will not work outside of GEOS.</DD>M/combo.htm"
<DT>
<STRONG>
-Og</STRONG>
 <STRONG>
file</STRONG>
</DT><DD>Creating GEOS executable (&quot;.geo&quot;) file. You must provide the name of the geode's Glue parameters file (the .GP file). For information about setting up a parameter file, see <A HREF="../../Intro/HelloWorld/index.htm">the Hello World chapter</A>.</DD>
<P>
When creating a .geo file, you may pass any of the following options:</P>
<DL>
<DT>
<STRONG>
-E</STRONG>
</DT><DD>Link Error checking version of geode.</DD>
<DT>
<STRONG>
-R</STRONG>
 <STRONG>
number</STRONG>
 </DT><DD>Specify release number of geode (e.g. 3.2.1.0).</DD>
<DT>
<STRONG>
-P</STRONG>
 <STRONG>
number</STRONG>
</DT><DD>Specify protocol number of geode (e.g. 1.0).</DD>
<DT>
<STRONG>
-T</STRONG>
 <STRONG>
number</STRONG>
 </DT><DD>File type.</DD>
<DT>
<STRONG>
-l</STRONG>
 </DT><DD>Creating a library; Glue should create .ldf file.</DD>
</DL>
<DT>
<STRONG>
-Ov</STRONG>
</DT><DD>Creating GEOS Virtual Memory (.vm) file. Using this option, you may create .vm storage files as set up by the Esp assembler. You may pass the following options when creating .vm files (if you don't know the meaning of some of these terms, see <A HREF="../../Memory/VM/index.htm">the Virtual Memory chapter</A>):</DD>
<DL>
<DT>
<STRONG>
-A</STRONG>
 <STRONG>
number</STRONG>
 </DT><DD><CODE>
VMAttributes</CODE>
 to use for the file.</DD>
<DT>
<STRONG>
-C</STRONG>
 <STRONG>
number</STRONG>
 </DT><DD>Compaction threshold.</DD>
<DT>
<STRONG>
-M</STRONG>
 <STRONG>
string</STRONG>
 </DT><DD>Map block segment name.</DD>
<DT>
<STRONG>
-P</STRONG>
 <STRONG>
number</STRONG>
 </DT><DD>Protocol number (e.g. 2.5.0.3).</DD>
<DT>
<STRONG>
-R</STRONG>
 <STRONG>
number</STRONG>
 </DT><DD>Release number (e.g. 12.3).</DD>
<DT>
<STRONG>
-i</STRONG>
 <STRONG>
name</STRONG>
 </DT><DD>A .geo file from which to get the table of imported libraries. This allows the VM file to be opened by that geode and objects in the file to be used.</DD>
<DT>
<STRONG>
-t</STRONG>
 <STRONG>
token</STRONG>
 </DT><DD>File token</DD>
<DT>
<STRONG>
-c</STRONG>
 <STRONG>
token</STRONG>
 </DT><DD>Creator's manufacturer token.</DD>
<DT>
<STRONG>
-l</STRONG>
 <STRONG>
string</STRONG>
</DT><DD>File's long name.</DD>
<DT>
<STRONG>
-u</STRONG>
 <STRONG>
notes</STRONG>
</DT><DD>File's user notes.</DD>
</DL>
<DT>
<STRONG>
-N</STRONG>
 <STRONG>
string</STRONG>
</DT><DD>Copyright notice which will be embedded in header of .GEO or .VM files.</DD>
<DT>
<STRONG>
-G</STRONG>
 <STRONG>
number</STRONG>
</DT><DD>You should never have to use this option. This specifies a non-standard GEOS release number (e.g. 1.3); if this release used a different VM header than GEOS 2.0, Glue will still construct the proper header as long as this option is passed. Since the default release number is 2, developers for 2.X do not need this option.</DD>
<DT>
<STRONG>
-Wall</STRONG>
</DT><DD>Requests that Glue output all optional warnings.</DD>
<DT>
<STRONG>
-Wunref</STRONG>
</DT><DD>Requests that Glue output optional unreferenced global symbol warnings.</DD>
<DT>
<STRONG>
-d</STRONG>
 </DT><DD>Dump memory. Normally used only when debugging Glue.</DD>
<DT>
<STRONG>
-m</STRONG>
</DT><DD>Provide memory map in output. This information gives information about the sizes of various parts of the geode. This information proves especially helpful when making geodes work with small devices.</DD>
<DT>
<STRONG>
-nll</STRONG>
</DT><DD>Disables the output of line numbers for local memory segments for any application with 163 resources or more.</DD>
<DT>
<STRONG>
-o </STRONG>
<STRONG>
file</STRONG>
</DT><DD>Specify name of output file (e.g. WOROPRO.GEO).</DD>
<DT>
<STRONG>
-q</STRONG>
</DT><DD>Leave the symbolic information behind even if an error was encountered. Normally, this flag is used only when debugging Glue.</DD>
<DT>
<STRONG>
-r</STRONG>
</DT><DD><A NAME="TTools_5.htm
_Multi-launchability">
 </A>
Maps segment relocations to non-shared resources to resource IDs. This is normally used only by multi-launchable C applications. When running more than one instance of a multi-launchable application, the system only uses one copy of the read-only portion of the application. The system makes separate copies of the writable data for each instance of the application. This can lead to conflict when the relocation instructions for the read-only data uses the handle or segment of a writable resource; which copy should be responsible for providing these addresses? If you don't pass this flag and Glue detects the above situation, Glue will simply refuse to make the application multi-launchable. This flag instructs Glue to instead use the resource ID of the writable resource where it would normally use the segment or handle of that resource.</DD>
<DT>
</DT><DD>If you use this option, make sure that if you use the address of a variable in a resource other than dgroup that you use <CODE>
GeodeGetOptrNS()</CODE>
 and lock down or dereference the handle of the returned optr.</DD>
<DT>
<STRONG>
-s</STRONG>
 <STRONG>
file</STRONG>
 </DT><DD>Specify name of symbol file (the .SYM file).</DD>
<DT>
<STRONG>
-z</STRONG>
 </DT><DD>Output localization information.</DD>
</DL>
<HR>
<A NAME="TTools_6.htm
"></A>


<H2 CLASS="sectionTitle">
<A HREF="#index.htm">Using Tools</A>: 6 
Goc</H2>
<P>
<A NAME="TTools_6.htm
_IX_Goc">
 </A>
Goc is the GEOS C preprocessor, which will turn your .goc file into something a regular C compiler can understand. It will traverse the .goc file, detect Goc keywords (e.g. @class, @object), turn these keywords into appropriate pieces of code, and write the resulting file out to a .c file. Note that Goc acts as a simple filter, and will only make changes where it detects Goc constructs; it won't touch your regular C code at all.</P>
<P>
Under normal circumstances, you will not invoke Goc directly. Instead, <CODE>
pmake</CODE>
 will make calls to Goc when compiling .goc files.</P>
<P>
If for some reason you do need to invoke Goc directly, you may wish to know about its command line arguments:</P>
<PRE>goc @file
goc [args] &lt;file&gt;</PRE>
<DL>
<DT>
<STRONG>
@</STRONG>
<STRONG>
file</STRONG>
</DT><DD>Command-line arguments are stored in a file--Goc will read this file and treat the contents as its arguments. If you use this option, then all the arguments must be in the file--no others may appear on the command line itself.</DD>
<DT>
<STRONG>
-</STRONG>
<A NAME="TTools_6.htm
_IX_- (Hyphen):Goc command-line argument">
 </A>
</DT><DD>Redirect output to standard out.</DD>
<DT>
<STRONG>
-C</STRONG>
<STRONG>
segment</STRONG>
</DT><DD>Specify segment for class structures to reside.</DD>
<DT>
<STRONG>
-D</STRONG>
<STRONG>
macro</STRONG>
</DT><DD>Set variable macro to one (e.g. &quot;-D__GEOS__&quot;)</DD>
<DT>
<STRONG>
-D</STRONG>
<STRONG>
macro</STRONG>
<STRONG>
=</STRONG>
<STRONG>
value</DT><DD>
</STRONG>
Set variable macro to value.</DD>
<DT>
<STRONG>
-I</STRONG>
 <STRONG>
dir</STRONG>
</DT><DD>Specify additional include directory</DD>
<DT>
<STRONG>
-I- </STRONG>
</DT><DD>Turn off relative inclusion.</DD>
<DT>
<STRONG>
-L</STRONG>
 <STRONG>
name</STRONG>
</DT><DD>Specify name of library being compiled. Must match argument to @deflib Goc keyword in library's .goh file, if it has one.</DD>
<DT>
<STRONG>
-M</STRONG>
 </DT><DD>Help <CODE>
pmake</CODE>
 generate dependency information.</DD>
<DT>
<STRONG>
-cb</STRONG>
 </DT><DD>Generate information for Borland compiler.</DD>
<DT>
<STRONG>
-d</STRONG>
 </DT><DD>Turn on all debugging information.</DD>
<DT>
<STRONG>
-dd</STRONG>
 </DT><DD>Output @default debugging information. (See <A HREF="../../Programming/GOCLanguage/GOCLanguage_13.htm">the GOC Language chapter</A>
 to find out what @default means).</DD>
<DT>
<STRONG>
-dl</STRONG>
 </DT><DD>Output lexical analyzer debugging information.</DD>
<DT>
<STRONG>
-dm</STRONG>
</DT><DD>Output message parameter definition debugging information.</DD>
<DT>
<STRONG>
-ds</STRONG>
</DT><DD>Output symbolic debugging information.</DD>
<DT>
<STRONG>
-du</STRONG>
 </DT><DD>Output Goc-specific debugging information.</DD>
<DT>
<STRONG>
-dy</STRONG>
 </DT><DD>Output parser debugging information.</DD>
<DT>
<STRONG>
-l</STRONG>
</DT><DD>Do localization work.</DD>
<DT>
<STRONG>
-o</STRONG>
 <STRONG>
file</STRONG>
</DT><DD>Specify name of output file.</DD>
<DT>
<STRONG>
-p</STRONG>
 </DT><DD>For Geoworks use only.</DD>
<DT>
<STRONG>
-X</STRONG>
</DT><DD>Ignore @optimize flags</DD>
</DL>
<HR>
<A NAME="TTools_7.htm
"></A>


<H2 CLASS="sectionTitle">
<A HREF="#index.htm">Using Tools</A>: 7 
<A NAME="TTools_7.htm
_73219">
 </A>
Grev</H2>
<P>
GEOS<A NAME="TTools_7.htm
_IX_Grev">s/combo.htm"
 </A>
 supports two version numbers for each geode. The first of these is the release number, used to uniquely identify the release of the geode. The protocol number tracks the external interface of the file. This is used to determine what versions of related geodes can be used together. The kernel will use these numbers to prevent loading of incompatible executable files.</P>
<P>
The grev utility generates proper revision numbers. Normally, it is called automatically by <CODE>
pmake</CODE>
, so if you are just making a small change to a file, you need not call it directly. However, you may wish to. When using grev, you must think about how major a change you are making; a large change means that you should change an earlier number of the release number. A change from 1.2.3.4 to 2.0.0.0 should signal a larger step than a change to 1.2.3.5.</P>
<P>
The <CODE>
pmake</CODE>
 program uses grev to automatically create revision numbers for geodes; it passes these values to Glue, which in turn places the protocol and revision numbers in the .geo and .sym files.</P>
<P>
There are three widely used methods for incrementing release numbers with respect to public releases (for which a specific release number is desired for marketing, say &quot;2.0.0&quot;). The problem comes because it is not known until after a release has been built whether it will be <EM>
the</EM>
 release or not (since bugs may be found).</P>
<P>
The first method is to keep separate public release numbers and internal release numbers. This is awkward and confusing and is generally done when it is too late to do anything else.</P>
<P>
The second method is to number successive revisions &quot;1.14.0.12&quot;, &quot;1.14.0.13&quot;, &quot;1.14.0.14&quot; and so on until the final revision is made which is numbered &quot;2.0.0.0&quot;. The problem with this is that one never quite knows whether or not a revision is the final one (since bugs may be found).</P>
<P>
The third method is to number successive revisions &quot;2.0.0.12&quot;, &quot;2.0.0.13&quot;, &quot;2.0.0.14&quot; and so on. The released &quot;2.0.0&quot; revision is then the last engineering revision starting with &quot;2.0.0.X&quot;. The disadvantage of this method is that it can seem non-obvious at first and requires a little bookkeeping to know the engineering number of the released version.</P>
<P>
The protocol number is changed whenever the external interface for the file changes. For the kernel and for libraries the protocol reflects the order as well as the parameters and behavior of external entry points. For applications the protocol reflects the object names, types and attributes. Changes that do not affect the external interface (changing the implementation of a routine, changing the moniker or hints of an object) do not change the protocol number.</P>
<P>
The major protocol number reflects incompatible changes in interface, such as rearranging the order of entry points. The minor protocol number reflects upwardly compatible changes in the protocol (such as adding an entry point at the end of a jump table or using a bit formerly marked as &quot;reserved&quot;).</P>
<P>
Each executable file contains protocol compatibility information (a protocol number) for all other executable files on which it depends. For example, a simple application might be compatible with kernel protocol &quot;34.2&quot; and UI protocol &quot;19.7&quot;. Thus the application is compatible with kernels &quot;34.2&quot; through &quot;34.65535&quot; and with UIs &quot;19.7&quot; through &quot;19.65535&quot;.</P>
<P>
A protocol number is also stored with each state file to determine if the state can be recovered by the currently running application.</P>
<P>
The grev tool uses a file (normally marked with a .rev suffix) in the geode's development directory to keep track of the revision number. The file is organized chronologically, with later entries at the beginning of the file. It contains</P>
<UL>
<LI>
one line for each compilation, denoting the revision number (which is incremented on each compilation), optional user name, the date, and an optional comment. By default, <CODE>
pmake</CODE>
 will only change the last part of the release number.</LI>
<LI>
one line for each protocol change, denoting the protocol number, optional user name, the date, and an optional comment.</LI>
</UL>

<P>
<HR>
<P>

<H4>Using the grev utility:</H4>
<P>
In the Nokia 9000i SDK version 2 (refer to
<A HREF = "../../Nokia9000/Versions/index.htm">versions</A>),
the .rev file may be in the local or in the 
&quot;Installed&quot; branch. It is suggested that developers keep a local .rev file so that they don't have to make revisions to the branch by hand. 
<P>
The <CODE>grev</CODE> utility uses the following syntax:</P>
<PRE>
     grev &lt<EM>option</EM>&gt &lt<EM>rev filename</EM>&gt [&lt<EM>comment</EM>&gt|-P|-R] -s
</PRE>

It is necessary to pass the <STRONG>-s</STRONG> flag to save the protocol
change. There are few circumstances where this flag is not needed.
<P>

&lt<EM>options</EM>&gt may be one of the following:
<DL><DD>
<DL>
<DT>
<STRONG>
new </STRONG>
<STRONG>
file</STRONG>
<STRONG>
 [&quot;</STRONG>
<STRONG>
comment</STRONG>
<STRONG>
&quot;|-P|-R]</DT><DD>
</STRONG>
Create a new revision record, listing comment as an initial revision for the base (0.0.0.0 release, 0.0 protocol). This command may only be executed in the geode's development directory. The -P option causes grev to give minimal output, printing only the protocol number. The -R option causes grev to print only the revision number. These last two options are normally used by <CODE>
pmake</CODE>
 to extract the relevant numbers.</DD>
<DT>
<STRONG>
info </STRONG>
<STRONG>
file</STRONG>
</DT><DD>Print the current release and protocol from the revision file.</DD>
<DT>
<STRONG>
getproto</STRONG>
 <STRONG>
file</DT><DD>
</STRONG>
Print only the current protocol from the revision file.</DD>
<DT>
<STRONG>
newprotomajor </STRONG>
<STRONG>
file</STRONG>
<STRONG>
 [&quot;</STRONG>
<STRONG>
comment</STRONG>
<STRONG>
&quot;|-P|-R]</STRONG>
 </DT>
<DT>
<STRONG>
NPM </STRONG>
<STRONG>
file</STRONG>
<STRONG>
 [&quot;</STRONG>
<STRONG>
comment</STRONG>
<STRONG>
&quot;|-P|-R]</DT><DD>
</STRONG>
Increase the major protocol number by one, setting the minor number to zero. The comment argument is listed as the reason for the change in the file. The -P and -R options work as they do for <CODE>
grev new</CODE>
.</DD>
<DT>
<STRONG>
newprotominor </STRONG>
<STRONG>
file</STRONG>
<STRONG>
 [&quot;</STRONG>
<STRONG>
comment</STRONG>
<STRONG>
&quot;|-P|-R]</STRONG>
 </DT>
<DT>
<STRONG>
npm </STRONG>
<STRONG>
file</STRONG>
<STRONG>
 [&quot;</STRONG>
<STRONG>
comment</STRONG>
<STRONG>
&quot;|-P|-R]</DT><DD>
</STRONG>
Increase the minor protocol number by one. The comment string is listed as the reason for the change in the file. The -P and -R options work as they do for <CODE>
grev new</CODE>
.</DD>
<DT>
<STRONG>
newrev </STRONG>
<STRONG>
file</STRONG>
<STRONG>
 </STRONG>
<STRONG>
number1.number2.number3 </STRONG>
<STRONG>
[&quot;</STRONG>
<STRONG>
comment</STRONG>
<STRONG>
&quot;|-P|-R]</DT><DD>
</STRONG>
Increase release number from A.B.C.D to <EM>number1</EM>.<EM>number2</EM>.number3.0. The comment is listed as the reason for the change. The -P and -R options work as they do for <CODE>
grev new</CODE>
.</DD>
<DT>
<STRONG>
newchange </STRONG>
<STRONG>
file</STRONG>
<STRONG>
 [&quot;</STRONG>
<STRONG>
comment</STRONG>
<STRONG>
&quot;|-P|-R]</STRONG>
 </DT><DD>
Up release number from A.B.C.D to A.B.C+1.0. The comment is listed as the reason for the change. The -P and -R options work as they do for <CODE>
grev new</CODE>
.</DD>
<DT>
<STRONG>
neweng </STRONG>
<STRONG>
file</STRONG>
<STRONG>
 [&quot;</STRONG>
<STRONG>
comment</STRONG>
<STRONG>
&quot;|-P|-R]</STRONG>
 </DT><DD>
Increase release number from A.B.C.D to A.B.C.D+1. The comment is listed as the reason for the change. The -P and -R options work as they do for <CODE>
grev new</CODE>
.</DD>
</DL>
</DL>

&lt<EM>rev filename</EM>&gt is the name of the revision file (ending in .REV).
<P>
&lt<EM>comment</EM>&gt is an optional comment embedded in quotes.
<P>
<STRONG>-P</STRONG> causes <CODE>grev</CODE> to give minimal output, printing only the protocol number. This flag is normally used by <CODE>pmake</CODE> to extract to protocol number.
<P>
<STRONG>-R</STRONG> causes <CODE>grev</CODE> to print only the revision number. <CODE>pmake</CODE> uses this flag to extract the version number.
<P>
<STRONG>-s</STRONG>, as noted above, causes the change to be saved to 
the revision file. If this flag is not passed, the change will only be 
displayed to the screen.

<HR>
<A NAME="TTools_8.htm
"></A>
m/combo.htm"

<H2 CLASS="sectionTitle">
<A HREF="#index.htm">Using Tools</A>: 8 
mkmf</H2>
<P>
<A NAME="TTools_8.htm
_IX_Mkmf">
 </A>
The mkmf tool exists to create a file named MAKEFILE. The <CODE>
pmake</CODE>
 program will use this file as a sort of script, using it to determine how to compile and link the geode. However, makefiles can get rather complicated, so it is best to create them using mkmf instead of by hand.</P>
<P>
For information about customizing this boilerplate makefile, see <A HREF="#TTools_10.htm_28191"> pmake</A>
.</P>
<P>
The mkmf tool uses the following rules to build the makefile:</P>
<UL>
<LI>
The geode name is taken from the name of the directory in which you run mkmf. Among other things, this means that if you change the name of your development directory, you should also run mkmf again.</LI>
<LI>
Any file in the current directory or its subdirectories will be considered a source file if it has one of the following suffixes: .asm, .def, .ui, .c, .h, .goc, or .goh (except that .c files which are generated from .goc files will not be considered sources).</LI>
<LI>
For each .asm, .c, or .goc file, an .obj file with corresponding name will be added to the makefile variable OBJS.</LI>
<LI>
If there are subdirectories, then each subdirectory is considered to hold the source for a <EM>
module</EM>
 of the program, and <CODE>
mkmf</CODE>
 will work with the files in this subdirectory as a unit. The module's name will be added to the CMODULES variable if it contains .c or .goc files; if it contains .asm files, then it will be added to the MODULES list. When using <CODE>
pmake</CODE>
, each module will be considered something that can be made, a sort of intermediate step towards making the whole geode. If you do not wish the files in a subdirectory to be incorporated in the program, create a file in the directory called NO_MKMF. This file need have no contents.</LI>
</UL>
<HR>
<A NAME="TTools_9.htm
"></A>


<H2 CLASS="sectionTitle">
<A HREF="#index.htm">Using Tools</A>: 9 
<A NAME="TTools_9.htm
_45273">
 </A>
pccom</H2>
<P>
<A NAME="TTools_9.htm
_IX_Pccom">
 </A>
The <CODE>
pccom</CODE>
 tool manages communication between the development and target machines. It assumes that the machines are connected by a single serial line. All I/O is interrupt-driven with XON/XOFF flow control active on the development machine and obeyed on the target machine.</P>
<P>
Note that it is possible to use some features of pccom from within GEOS. For more information about this, see <A HREF="../../Communication/PCCom/index.htm">the PCCom Library documentation</A>.</P>
<P CLASS="subsectionLink">
<A HREF="#TTools_a.htm">PCCOM Background</A></P>
<P CLASS="subsectionLink">
<A HREF="#TTools_b.htm">Running PCCOM on the Target</A></P>
<P CLASS="subsectionLink">
<A HREF="#TTools_c.htm">File Transfer Protocol of PCCOM</A></P>
<HR>
<A NAME="TTools_a.htm
"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Using Tools</A>: 9.1 <A HREF="#TTools_9.htm">pccom</A>: 
PCCOM Background</H3>
<P>
PCCOM is used in two primary situations. First, it is used by GEOS software developers when transferring files or when debugging an application. In this situation, the developer runs PCCOM on the target machine and then runs PCS, PCSEND, or PCGET, on the host machine. All of these programs know how to interact with PCCOM.</P>
<P>
Second, it is used by DOS programs when transferring files to and from Zoomer devices or other devices that require remote file manipulation. In this case, the host machine runs a program which copies escape character sequences to the appropriate serial port, prompting PCCOM to act.</P>
<HR>
<A NAME="TTools_b.htm
"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Using Tools</A>: 9.2 <A HREF="#TTools_9.htm">pccom</A>: 
Running PCCOM on the Target</H3>
<P>
PCCOM is a DOS program that monitors the serial port and responds to commands received on the line. All I/O is interrupt driven with XON/XOFF flow control active on the host machine and obeyed on the target machine.</P>
<P>
PCCOM uses the PTTY environment variable of DOS, if it exists. This variable contains communications settings detailing baud rate, COM port, and communications interrupt level. You can override the PTTY settings with command-line options to PCCOM when running it. The following command-line options are allowed:</P>
<DL>
<DT>
/b:baud</DT><DD>Specify the baud used for file transfer and serial communications. The baud parameter may be one of the following values: 300, 1200, 2400, 9600, 19200, or 38400. Unambiguous abbreviations may be used (e.g. 9 for 9600 baud or 38 for 38400 baud). The default baud rate is 19200 bps.</DD>
<DT>
/c:port	Specify the COM port used for serial communications. The parameter may be one of 1, 2, 3, or 4. The COM ports for Zoomer are</DT><DD>
COM 1		the built-in serial port (this is the default).<BR>
COM 2		the infrared transceiver.</DD>
<DT>
/i:interrupt</DT><DD>Specify interrupts that should be ignored by PCCOM. This is useful if peripherals share an interrupt number that may confuse PCCOM. The interrupt parameter is one or more numbers of the interrupt(s) to be ignored, in hexadecimal.</DD>
<DT>
/I:irq</DT><DD>Specify the IRQ level for serial line communications. This parameter is rarely required. The irq parameter is the number of the IRQ level to be used.</DD>

</DL>
<H4 CLASS="HeadingC">
Quitting PCCOM</H4>
<P>
PCCOM may be quit either directly or remotely. To quit PCCOM directly, simply hit the Enter key (or the q key) on the machine on which PCCOM is running. If it does not quit on the first keystroke, hit the key again.</P>
<P>
To quit PCCOM remotely, issue the quit escape sequence &lt;Esc&gt;EX through the serial line from the host machine. See below for a description of the commands that can be issued remotely.</P>


<H4 CLASS="HeadingC">
Remote PCCOM Commands</H4>
<P>
PCCOM doesn't care what machine originates a remote command; its sole purpose is to evaluate and execute commands received through the serial port it's monitoring. Thus, a command sent by one Zoomer to another will exact the same response as a command sent by a development host machine to a target development machine.</P>
<P>
On some computers (depending on BIOS), commands are copied from DOS to the serial port using the &quot;echo&quot; command. (If the computer executing remote commands has a different BIOS, you may get an error like &quot;write fault error writing to device com#&quot;; in this case, you must make sure that the characters sent to the serial port in the end are the same as those shown in the table below.) For example, to send the &quot;quit&quot; command to the remote machine, you could use the DOS command</P>
<PRE>C:&gt;echo <EM>Esc</EM>EX &gt; com1</PRE>
<P>
where <CODE>
Esc</CODE>
 (in italics) represents the Escape character (0x1B).</P>
<P>
No matter what method you use to send the character sequences to the serial port, the following commands may be executed remotely. Sending and receiving files remotely is more involved and is therefore discussed in the next section; it is not complicated, however.</P>
<P>
All arguments to PCCOM remote commands must end with a delimiter character--an exlamation mark by default. Because of this, file operation commands will not work on files with exclamation points in their names by default. However, there is a PCCom command to use a different delimiter character. </P>
<TABLE BORDER="1">
<TR><TH>
Command</TH><TH>Sequence</TH><TH>Description</TH></TR>
<TR><TD>
Send File</TD><TD>&lt;Esc&gt;XF&lt;Ctrl-A&gt;<BR>(&lt;Esc&gt;XF&lt;0x01&gt;)</TD><TD>
Send a file from the host to the remote machine using the PCCOM file transfer protocol (see below). </TD></TR>
<TR><TD>
Get File</TD><TD>&lt;Esc&gt;XF&lt;Ctrl-D&gt;<BR>(&lt;Esc&gt;XF&lt;0x04&gt;)</TD><TD>
	Retrieve a file from the remote machine using the PCCOM file transfer protocol (see below).</TD></TR>
<TR><TD>
Turn EchoBack On</TD><TD>&lt;Esc&gt;EBon!</TD><TD>Turn EchoBack on.All text displayed on the target machine will also display on the host machine. Carriage returns are marked by semicolon (&quot;;&quot;) characters.</TD></TR>
<TR><TD>
Turn EchoBack Off</TD><TD>&lt;Esc&gt;EBoff!</TD><TD>Turn EchoBack off.</TD></TR>
<TR><TD>
Display EchoBack State</TD><TD>&lt;Esc&gt;EB!</TD><TD>Display a string signalling whether EchoBack is turned on. If it's turned on, &quot;Echoback = off&quot; appears on the target machine. If it's turned on, &quot;Echoback = on&quot; appears.</TD></TR>
<TR><TD>
Turn Acknowledge On</TD><TD>&lt;Esc&gt;AKon!</TD><TD>Whenever a transaction is complete, the host will display &quot;Ack Received.&quot; or &quot;Nak Recieved.&quot; as appropriate.</TD></TR>
<TR><TD>
Turn Acknowledge Off</TD><TD>&lt;Esc&gt;AKoff!</TD><TD>Turn off acknowledgement.</TD></TR>
<TR><TD>
Display Acknowledge State</TD><TD>&lt;Esc&gt;AK!</TD><TD>Display a string signalling whether Acknowledge is turned on. If it's turned on, &quot;ACK/NAK = on&quot; appears on the target machine; otherwise &quot;ACK/NAK = off&quot; appears.</TD></TR>
<TR><TD>
Send Ack Signal</TD><TD>&lt;Esc&gt;ACK</TD><TD>Sends an Ack signal, just as is sent by the target machine when acknowledgements are turned on.</TD></TR>
<TR><TD>
Send NAK Signal</TD><TD>&lt;Esc&gt;NAK</TD><TD>Sends a NAK signal, just as is sent by the target machine when acknowledgements are turned on.</TD></TR>
<TR><TD>
Copy File</TD><TD>&lt;Esc&gt;CP<EM>src</EM>!<EM>dest</EM>!</TD><TD>
Copy the file named in the src argument to the file named in the dest argument. File name arguments may be full or relative paths with or without drive letters. This is equivalent to the DOS COPY command.</TD></TR>
<TR><TD>
Move File</TD><TD>&lt;Esc&gt;MV<EM>src</EM>!<EM>dest</EM>!</TD><TD>
Move the file named in the src argument to the file named in the dest argument. File name arguments may be full or relative paths; no drive letters are allowed. This is equivalent to the DOS MOVE command.</TD></TR>
<TR><TD>
Delete File</TD><TD>&lt;Esc&gt;RF<EM>file</EM>!</TD><TD>Remove the named file; the file argument may be a full path or a file in the current directory. This is equivalent to the DOS DEL command.</TD></TR>
<TR><TD>
Change Drive</TD><TD>&lt;Esc&gt;CD<EM>drive</EM>:!</TD><TD>
Change the working volume to the drive named in the drive argument. This is equivalent to changing the drive in DOS by typing the drive letter followed by a colon (e.g. C:).</TD></TR>
<TR><TD>
Change Directory</TD><TD>&lt;Esc&gt;CD<EM>dir</EM>!</TD><TD>Change the working directory to that named. The dir argument may be a full or relative path; no drive letter is allowed. This is the equivalent of the DOS CD command.</TD></TR>
<TR><TD>
Show Current Path</TD><TD>&lt;Esc&gt;CD!</TD><TD>Print the current directory's path. This is equivalent to the DOS CD command with no arguments passed.	</TD></TR>
<TR><TD>
List Files in Dir</TD><TD>&lt;Esc&gt;LS</TD><TD>List files in the current working directory. This is equivalent to the DOS DIR command with no arguments.</TD></TR>
<TR><TD>
List Files with Details</TD><TD>&lt;Esc&gt;LM</TD><TD>List files in the current working directory, together with the file's DOS attributes, the long name of each GEOS file, and the release number associated with each GEOS file.<BR>
The DOS attributes are shown with the following flags:<BR>
a: 						archive<BR>
d:						 sub directory<BR>
v: 						volume file<BR>
s: 						system<BR>
h: 						hidden<BR>
r: 						read only</TD></TR>
<TR><TD>
List Files, Full Details</TD><TD>&lt;Esc&gt;LL</TD><TD>List files in the current directory with all information returned by LM, described above, and the token of the creating geode and the document token. Tokens consist of four characters and a <CODE>
ManufacturerID</CODE>
--most <CODE>
ManufacturerID</CODE>
 values will appear as a number, but PCCom will translate those values that it knows about into a mnemonic code:<BR>
GEO:						Geoworks<BR>
APP:						Application Local<BR>
PLM:						Palm Computing<BR>
WIZ:						SchoolView<BR>
CLB:						Creative Labs<BR>
DSL:						DOS Launcher<BR>
AOL: 						America Online<BR>
ITU:						Intuit<BR>
SDK:						Default SDK<BR>
AGD:						Association of GEOS Developers</TD></TR>
<TR><TD>
Display Free Space</TD><TD>&lt;Esc&gt;FS<EM>d</EM>:!</TD><TD>Display the free space on the drive named by the <EM>
d</EM>
 argument.</TD></TR>
<TR><TD></TD><TD>&lt;Esc&gt;FS!</TD><TD>Display the free space on the current drive.</TD></TR>
<TR><TD>
Display Drives</TD><TD>&lt;Esc&gt;AD</TD><TD>Display available drives. The target machine will display one line for each drive, showing the drive's letter and DOS name.</TD></TR>
<TR><TD>
Create Directory</TD><TD>&lt;Esc&gt;MD<EM>dir</EM>!</TD><TD>Create a new directory according to the <EM>
dir</EM>
 argument. The dir argument may be a full or relative path. This is the equivalent of the DOS MKDIR command.</TD></TR>
<TR><TD>
Delete Directory</TD><TD>&lt;Esc&gt;RD<EM>dir</EM>!</TD><TD>Remove the directory named in the <EM>
dir</EM>
 argument. The dir argument may be a full or relative path; this is equivalent to the DOS RMDIR and RD commands.</TD></TR>
<TR><TD>
Clear Screen</TD><TD>&lt;Esc&gt;cl</TD><TD>Clear the screen of the target machine. This is equivalent to the DOS CLS command.</TD></TR>
<TR><TD>
Display Delimiter</TD><TD>&lt;Esc&gt;DD</TD><TD>Displays the current delimiter character (`!' by default).</TD></TR>
<TR><TD>
Change Delimiter</TD><TD>&lt;Esc&gt;DX	&lt;char&gt;&lt;old delimiter&gt;</TD><TD>Use a different character as the delimiter. By default, the exclamation mark (`!') is the delimiter character. The character delimiter must lie between the ascii values of 0x21 (exclamation mark) and 0x7e (tilde).</TD></TR>
<TR><TD>
Exit PCCOM</TD><TD>&lt;Esc&gt;EX</TD><TD>Exit PCCOM on the remote machine.</TD></TR>
</TABLE>

<H4 CLASS="HeadingC">
Sending and Receiving Files</H4>
<P>
If you are using the GEOS SDK, you will do most of your file sending and receiving using the programs PCS, PCSEND, and PCGET. These programs send commands to the serial port, and then follow them by either providing or receiving packaged file data. These three programs are detailed below; following them is a section of the file transfer protocol of PCCOM if you are writing your own remote-access program(s).</P>

<H5 CLASS="HeadingD">
PCGET</H5>
<P>
If PCCOM is running on the target machine, the PCGET program can be executed on the host to retrieve a file from the target. This simple program merely retrieves the file and copies it into the host's working directory under the same name.</P>
<P>
PCGET takes the following arguments; only the file name is required. The other arguments are optional and may be used to override the settings in the host machine's PTTY environment variable (see above, under &quot;Running PCCOM on the Target (or on the Zoomer)&quot;).</P>
<PRE>pcget [/b:<EM>baud</EM>][/c:<EM>port</EM>][/I:<EM>irq</EM>] <EM>file</EM></PRE>
<DL>
<DT>
/b:baud</DT><DD>Specify the baud used for file transfer. The baud parameter may be one of the following values: 300, 1200, 2400, 9600, 19200, or 38400. Unambiguous abbreviations may be used (e.g. 9 for 9600 baud or 38 for 38400 baud). The default baud rate is 19200 bps.</DD>
<DT>
/c:port	Specify the COM port used. The port parameter may be one of 1, 2, 3, or 4. The COM ports for Zoomer are</DT><DD>
COM 1		the built-in serial port (this is the default),<BR>
COM 2		the infrared transceiver.</DD>
<DT>
/I:irq</DT><DD>Specify the IRQ level for the transfer. This parameter is rarely required. The irq parameter is the number of the IRQ level to be used.</DD>
<DT>
file</DT><DD>Specify the file to be retrieved. The file parameter may be a full or a relative path or a simple file name. The file will be copied from the target to the host into the host's current working directory, with the same name.</DD>


</DL>
<H5 CLASS="HeadingD">
PCSEND</H5>
<P>
If PCCOM is running on the target (remote) machine, PCSEND may be executed on the host machine to download a file to the target. PCSEND will only send a single file, though it may send the file to any directory on the target. To send multiple files, or to download specific geodes to their proper locations in the GEOS 2.0 directory tree, use the PCS program instead.</P>
<P>
The command line options of PCSEND are shown below. Only the file to be sent is required; if no other argument is passed, the file will be sent to the target's current working directory.</P>
<PRE>pcsend [/b:<EM>baud</EM>][/c:<EM>port</EM>][/I:<EM>irq</EM>] <EM>file</EM> [/d:<EM>dest</EM>]</PRE>
<DL>
<DT>
/b:baud</DT><DD>Specify the baud used for file transfer. The baud parameter may be one of the following values: 300, 1200, 2400, 9600, 19200, or 38400. Unambiguous abbreviations may be used (e.g. 9 for 9600 baud or 38 for 38400 baud). The default baud rate is 19200 bps.</DD>
<DT>
/c:port	Specify the COM port used. The port parameter may be one of 1, 2, 3, or 4. The COM ports for Zoomer are</DT><DD>
COM 1		the built-in serial port (this is the default),<BR>
COM 2		the infrared transceiver.</DD>
<DT>
/I:irq</DT><DD>Specify the IRQ level for the transfer. This parameter is rarely required. The irq parameter is the number of the IRQ level to be used.</DD>
<DT>
file</DT><DD>Specify the file to be sent. The file parameter may be a full or a relative path or a simple file name. The file will be downloaded to the target machine's current working directory, unless the /d parameter is also passed (see below).</DD>
<DT>
/d:dest</DT><DD>Specify a full or relative destination path for the file.</DD>


</DL>
<H5 CLASS="HeadingD">
PCS</H5>
<P>
If PCCOM is running on the target machine, PCS may be executed on the host machine to send multiple files to predetermined directories on the target. PCS is most often used by GEOS developers using the GEOS development kit, when they are downloading their recently-compiled geodes to the target for debugging.</P>
<P>
The PCS program makes use of a list of constraints-tokens and their source and destination files and directories-located in the files ROOT_DIR\INCLUDE\PCS.PAT and ROOT_DIR\INCLUDE\SEND on the SDK host machine. (ROOT_DIR is a DOS environment variable set up by the SDK installation program indicating the top directory into which the SDK files were installed.) The format of these two files is described at the end of this section.</P>
<P>
The command-line parameters of PCS are shown below. Note that a file name is not used by PCS; instead, if no token or directory is given, PCS will download all appropriate files in the current working directory. As with PCSEND and PCGET, the baud, COM port, and IRQ level arguments are all optional and may be used to override the settings in the PTTY environment variable.</P>
<PRE>pcs [/n][/S<EM>f</EM>][/t][/b:<EM>b</EM>][/c:<EM>p</EM>][/I:<EM>i</EM>][<EM>dir</EM>|<EM>file</EM>|<EM>token</EM>]</PRE>
<DL>
<DT>
/n</DT><DD>If /n is specified, PCS will send non-EC geodes only. Without this argument, PCS will send only EC geodes.</DD>
<DT>
/Sf</DT><DD>Specify a file containing a list of files to be sent. The file argument is the name of the file.</DD>
<DT>
/t</DT><DD>If the /t argument is used anywhere on the command line, file names specified at the end of the command (see the last argument) will be interpreted as tokens. A token may equate to numerous files as defined in the SEND file.</DD>
<DT>
/b:b</DT><DD>Specify the baud used for file transfer. The baud parameter may be one of the following values: 300, 1200, 2400, 9600, 19200, or 38400. Unambiguous abbreviations may be used (e.g. 9 for 9600 baud or 38 for 38400 baud). The default baud rate is 19200 bps.</DD>
<DT>
/c:p	Specify the COM port used. The port parameter may be one of 1, 2, 3, or 4. The COM ports for Zoomer are</DT><DD>
COM 1		the built-in serial port (this is the default),<BR>
COM 2		the infrared transceiver.</DD>
<DT>
/I:i</DT><DD>Specify the IRQ level for the transfer. This parameter is rarely required. The irq parameter is the number of the IRQ level to be used.</DD>
<DT>
dir|file|token</DT><DD>
Specify a directory containing the geodes to be downloaded, the files to be downloaded, or tokens to be interpreted. If no directory, file, or token is specified, PCS will download the appropriate files in the current working directory. If a directory is specified, PCS will download all the appropriate files in that directory. If file names are specified (multiple files and/or directories may be specified), all affected files will be send.</DD>
</DL>
<P>
If the /t argument appears anywhere in the command line (see above), this set of arguments will be interpreted as tokens. See directly below for token use and interpretation.</P>
<P>
When using a token, PCS looks in the ROOT_DIR\INCLUDE\SEND file for the token to determine which files should be sent. Generally, all executables associated with an application, library, or mechanism are sent when the appropriate token is passed. Look in the SEND file to find out what the accepted tokens are and what they send.</P>
<P>
For example, if the SEND file contained the lines</P>
<PRE>PC	DRIVER/VIDEO/DUMB/HGC/HGC					GEO</PRE>
<PRE>PCB	DRIVER/VIDEO/DUMB/HGC/HGC					GEO</PRE>
<PRE>PCB	DRIVER/MOUSE/LOGIBUS/LOGIBUS					GEO</PRE>
<P>
then typing</P>
<PRE>pcs /t pc</PRE>
<P>
would send just the HGCEC.GEO file to the proper directory on the target. Typing</P>
<PRE>pcs /t pcb</PRE>
<P>
would download both HGCEC.GEO and LOGIBUSE.GEO to their proper directories. A listing of all the supported tokens can be found in the SEND file.</P>


<HR>
<A NAME="TTools_c.htm
"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Using Tools</A>: 9.3 <A HREF="#TTools_9.htm">pccom</A>: 
File Transfer Protocol of PCCOM</H3>
<P>
If you need to create your own file transfer program or module, you can use the basic PCCOM commands and a special transfer protocol to send or receive files over the serial link. This is useful, for example, if you have an existing Windows or DOS program to which you would like the to add the ability to transfer files to or from the Zoomer (or another unit running PCCOM).</P>

<H4 CLASS="HeadingC">
Sending a File to the Remote Machine</H4>
<P>
Sending a file to the remote machine involves the steps below. A file may be sent by any program that can access the serial port.</P>
<OL>
<LI>
Notify PCCOM that a file is on its way.<BR>
Send the Send File escape character sequence to the serial port, notifying PCCOM that a file is about to be sent to it. The escape sequence is &lt;Esc&gt;XF&lt;Ctrl-A&gt; (&lt;Esc&gt;XF&lt;0x01&gt;).</LI>
<LI>
Send the destination file name.<BR>
Send the name PCCOM should use for the file when saving it. The name is a string of sequential characters ending with a null byte. If sending the file to the target machine's target directory, this will just be the file's name; if sending to a different directory, this string should instead be the full pathname. Thus, to do the equivalent of &quot;pcsend yuyuhack.sho /d:b:\geoworks\document&quot;, this string would consist of &quot;b:\geoworks\document\yuyuhack.sho&quot;.<BR>
If a timeout occurs while sending the filename, a NAK_QUIT will be returned and the remote machine will abort the file-send operation.</LI>
<LI>
Wait for acknowledgment of the name transfer.<BR>
PCCOM will send a 0xFF character or a SYNC byte to acknowledge acceptance of the file name. If you do not receive this character, an error has likely occurred.</LI>
<LI>
Send the file size.<BR>
The file size should be encoded as a dword value. Send the low byte first.</LI>
<LI>
Send a packet.<BR>
Once you have received the SYNC or 0xFF byte, you can safely begin sending packets of data to PCCOM. A packet has the following format (sequence of bytes, with the first listed being the first sent):</LI>
<PRE>BLOCK_START				( = 1 )
data
BLOCK_END				( = 2 )
CRC				( checksum value )</PRE>
<P>
The data between BLOCK_START and the checksum value (CRC) may be up to 1 K. In order to avoid PCCOM confusion between a normal data byte and a BLOCK_START or BLOCK_END, a third element--BLOCK_QUOTE--is used.</P>
<P>
Any time you have a data byte equal to 1, 2, or 3, you must quote it by inserting a BLOCK_QUOTE byte before it and then adding three to its value. Thus, if you had a data sequence consisting of the following</P>
<PRE>100, 42, 2, 3, 16</PRE>
<P>
you would send the following sequence of bytes to transfer the data:</P>
<PRE>&lt;Esc&gt;FX1					( alert PCCOM a
					  file is coming )
&lt;null-terminated file name&gt;
&lt;wait for SYNC byte&gt;
BLOCK_START					( = 1 )
100
42
BLOCK_QUOTE					( = 3 )
5					( = 2 + 3 )
BLOCK_QUOTE					( = 3 )
6					( = 3 + 3 )
16
BLOCK_END					( = 2 )
CRC					( checksum value )</PRE>
<P>
The CRC word is two bytes of checksum value as calculated using the table and code shown in &quot;Calculating Checksum Values,&quot; below. The CRC value is based upon the data bytes only. The low byte is transmitted first. You should use this code to ensure that your checksums will match PCCOM's.</DD>
<LI>
Optionally, the first packet may contain the filename and file size.<BR>
In the first (and only the first) packet, it is possible to send a data block containing the file's name. If such a block is received by pccom or the PCCom library, then this filename will take precedence over the filename that was sent before the packets. Since the first filename may have been corrupted by noise, this provides a surer backup. The file size is passed as a dword value, low byte first.</LI>
<P>
	This data block should have the following data:</P>
<PRE>&quot;!PCCom File Transfer Filename Block! &quot;  &lt;no NULL&gt;
&lt;null-terminated file name&gt; &lt;null&gt; &lt;dword file size&gt;</PRE>
<P>
	The CRC for this block should be one higher than it would normally be--this signals that this block is of this special format.</P>
<LI>
Wait for a SYNC byte acknowledgment.<BR>
After each packet, you must make sure PCCOM responds positively with another SYNC byte. If the SYNC is not received, the packet likely failed. If the packet succeeded, continue sending packets as above (waiting for a SYNC after each) until done transferring the data.</LI>

<P>
	If, instead of receiving a SYNC value, you receive a NAK_QUIT value, the target machine has aborted to an unrecoverable error, and there is little point in continuing to send data over the serial line.</P>
<P>
	A NAK byte signals that the target machine had an error but that it may be possible to continue the send operation by re-sending the block.</P>
<P>
	When sending an optional filename packet, as described in step six, normally one does not re-send the packet it if it fails to send.</P>
<LI>
Repeat steps five and seven as many times as necessary to transfer the entire file.</LI>
<LI>
Send two zero bytes.<BR>
To make it absolutely clear that the file transfer has finished, send two zero bytes.</LI>
</OL>


<H4 CLASS="HeadingC">
Retrieving a File Remotely</H4>
<P>
Retrieving a file from a machine running PCCOM is straightforward and uses the same file transfer protocol shown above for sending a file. The sequence of commands is different, however, and is listed below.</P>
<OL>
<LI>
Notify PCCOM that you're getting a file.<BR>
Send the Get File escape character sequence to the serial port, notifying PCCOM that it should get ready to send a file. The escape sequence is &lt;Esc&gt;XF&lt;Ctrl-D&gt; (&lt;Esc&gt;XF&lt;0x04&gt;).</LI>
<LI>
Send the source file name.<BR>
Send the name of the file to be retrieved. The name is a string of sequential characters ending with a null byte. </LI>
<LI>
Wait for SYNC byte signifying acknowledgment of the name transfer.<BR>
PCCOM will send a 0xFF character or a SYNC byte to acknowledge acceptance of the file name. If you do not receive this character, an error has likely occurred (e.g., the file name wasn't successfully transmitted).</LI>
<LI>
Wait for another SYNC byte signifying file found.<BR>
PCCOM will send a SYNC byte to acknowledge that the desired file was found.</LI>
<LI>
Wait for RECV_COMMAND byte.<BR>
PCCOM will send a RECV_COMMAND byte signifying the file was successfully opened.</LI>
<LI>
Receive destination file name.<BR>
This null-terminated string contains the place to write the file on the host machine. This path string may be up to size PATH_BUFFER_SIZE (defined in file.h).</LI>
<LI>
Send a SYNC byte to acknowledge receipt of the destination file name.<BR>
By sending a SYNC byte, the host acknowledges that it has received the destination file name and is ready to continue the transfer.</LI>
<LI>
Receive the file size.<BR>
The next data received will be the file's size, expressed as a dword, with the low byte sent first.</LI>
<LI>
Receive packets.<BR>
After you receive thefile size from PCCOM, you will begin receiving data packets. Each packet you receive will follow the same format as described above for sending a file. Be aware of the BLOCK_QUOTE requirements when receiving the data (described in sending a file).</LI>
<P>
You will receive a checksum word at the end of each block's data. If the sent checksum matches the one you calculate from the received data, send a SYNC byte to the serial port (0xFF); otherwise send a NAK value. Calculate all your checksum values with the table and code presented in &quot;Calculating Checksum Values,&quot; below. </P>
<P>
	When retrieving files, there will never be a file name packet such as described in step six of the file-sending procedure. Thus, you need not check to see whether a block whose CRC is off by one in fact contains a file name; you should not acknowledge this block.</P>
<LI>
Receive two zero bytes.<BR>
These make it clear that the file transfer has been completed.</LI>
<LI>
Send an ACK byte.<BR>
This acknowledges the end of the file transfer.</LI>
<LI>
Repeat steps 4 through 11 until END_COMMAND byte received.<BR>
If the filename passed to pcget contained wildcard characters and there is more than one matching file, PCCom will send all of them, using the protocol outlined in steps 4 through 11. If in step 4 an END_COMMAND byte is received instead of a SYNC byte, all files have been sent.</LI>
</OL>


<H4 CLASS="HeadingC">
Calculating Checksum Values</H4>
<P>
The CRC word that accompanies each block of transferred data must be calculated using the same code as PCCOM or you will probably have only unsuccessful transmissions. The code used by PCCOM is shown on the next page, and you may include it in your own file transfer program. PCSEND, PCGET, and PCS also use the same checksum calculation code. This checksum should be based only on the data itself; do not include the BLOCK_START, BLOCK_QUOTE, or BLOCK_END characters in your calculations.</P>
<P CLASS="figTitle">
Code Display 9-1 PCCOM Checksums</P>
<PRE>/**********************************************************************
 *		CalcCRC						*
 **********************************************************************
 * SUMMARY:		Calculate the CRC on a block of data.
 * PASS:		char *buf		Pointer to the data buffer
 *		short size		Size of the data buffer
 *		short checksum		Previous checksum (0 at first)
 * RETURN:		CRC value (2 bytes)
 **********************************************************************/</PRE>
<PRE>short	crcTable[] = { 
    0x0000, 0x1021, 0x2042, 0x3063, 0x4084, 0x50a5, 0x60c6, 0x70e7,
    0x8108, 0x9129, 0xa14a, 0xb16b, 0xc18c, 0xd1ad, 0xe1ce, 0xf1ef,
    0x1231, 0x0210, 0x3273, 0x2252, 0x52b5, 0x4294, 0x72f7, 0x62d6,
    0x9339, 0x8318, 0xb37b, 0xa35a, 0xd3bd, 0xc39c, 0xf3ff, 0xe3de,
    0x2462, 0x3443, 0x0420, 0x1401, 0x64e6, 0x74c7, 0x44a4, 0x5485,
    0xa56a, 0xb54b, 0x8528, 0x9509, 0xe5ee, 0xf5cf, 0xc5ac, 0xd58d,
    0x3653, 0x2672, 0x1611, 0x0630, 0x76d7, 0x66f6, 0x5695, 0x46b4,
    0xb75b, 0xa77a, 0x9719, 0x8738, 0xf7df, 0xe7fe, 0xd79d, 0xc7bc,
    0x48c4, 0x58e5, 0x6886, 0x78a7, 0x0840, 0x1861, 0x2802, 0x3823,
    0xc9cc, 0xd9ed, 0xe98e, 0xf9af, 0x8948, 0x9969, 0xa90a, 0xb92b,
    0x5af5, 0x4ad4, 0x7ab7, 0x6a96, 0x1a71, 0x0a50, 0x3a33, 0x2a12,
    0xdbfd, 0xcbdc, 0xfbbf, 0xeb9e, 0x9b79, 0x8b58, 0xbb3b, 0xab1a,
    0x6ca6, 0x7c87, 0x4ce4, 0x5cc5, 0x2c22, 0x3c03, 0x0c60, 0x1c41,
    0xedae, 0xfd8f, 0xcdec, 0xddcd, 0xad2a, 0xbd0b, 0x8d68, 0x9d49,
    0x7e97, 0x6eb6, 0x5ed5, 0x4ef4, 0x3e13, 0x2e32, 0x1e51, 0x0e70,
    0xff9f, 0xefbe, 0xdfdd, 0xcffc, 0xbf1b, 0xaf3a, 0x9f59, 0x8f78,
    0x9188, 0x81a9, 0xb1ca, 0xa1eb, 0xd10c, 0xc12d, 0xf14e, 0xe16f,
    0x1080, 0x00a1, 0x30c2, 0x20e3, 0x5004, 0x4025, 0x7046, 0x6067,
    0x83b9, 0x9398, 0xa3fb, 0xb3da, 0xc33d, 0xd31c, 0xe37f, 0xf35e,
    0x02b1, 0x1290, 0x22f3, 0x32d2, 0x4235, 0x5214, 0x6277, 0x7256,
    0xb5ea, 0xa5cb, 0x95a8, 0x8589, 0xf56e, 0xe54f, 0xd52c, 0xc50d,
    0x34e2, 0x24c3, 0x14a0, 0x0481, 0x7466, 0x6447, 0x5424, 0x4405,
    0xa7db, 0xb7fa, 0x8799, 0x97b8, 0xe75f, 0xf77e, 0xc71d, 0xd73c,
    0x26d3, 0x36f2, 0x0691, 0x16b0, 0x6657, 0x7676, 0x4615, 0x5634,
    0xd94c, 0xc96d, 0xf90e, 0xe92f, 0x99c8, 0x89e9, 0xb98a, 0xa9ab,
    0x5844, 0x4865, 0x7806, 0x6827, 0x18c0, 0x08e1, 0x3882, 0x28a3,
    0xcb7d, 0xdb5c, 0xeb3f, 0xfb1e, 0x8bf9, 0x9bd8, 0xabbb, 0xbb9a,
    0x4a75, 0x5a54, 0x6a37, 0x7a16, 0x0af1, 0x1ad0, 0x2ab3, 0x3a92,
    0xfd2e, 0xed0f, 0xdd6c, 0xcd4d, 0xbdaa, 0xad8b, 0x9de8, 0x8dc9,
    0x7c26, 0x6c07, 0x5c64, 0x4c45, 0x3ca2, 0x2c83, 0x1ce0, 0x0cc1,
    0xef1f, 0xff3e, 0xcf5d, 0xdf7c, 0xaf9b, 0xbfba, 0x8fd9, 0x9ff8,
    0x6e17, 0x7e36, 0x4e55, 0x5e74, 0x2e93, 0x3eb2, 0x0ed1, 0x1ef0
};</PRE>
<PRE>unsigned short		IncCRC(unsigned short crc, char c){
    return ((crc &lt;&lt; 8) ^ crcTable[((crc &gt;&gt; 8) ^ c) &amp; 0xff]);
}</PRE>
<PRE>short		CalcCRC(char *buf, short size, short checksum){
/* The CRC is for the data part of the packet only. 
 * The CRC value is passed low byte first. */
    for (;size &gt; 0; size--){
 	checksum = IncCRC(checksum, *buf++);
    }
    return checksum;
}</PRE>


<H4 CLASS="HeadingC">
Testing the Connection</H4>
<P>
If the other side of a PCCom connection exits, you will get no notification. One way to test the connection to make sure that's still open is to send a &lt;Esc&gt;AKon! command. This requests that the other side of the connection send an &lt;Esc&gt;ACK at completion of each command. Note that the other side will try to acknowledge of the &lt;Esc&gt;AKon!, so that gives you a quick indicator that the other side is active. Assuming you don't want to stay in this mode, send an &lt;Esc&gt;AKoff!.</P>

<HR>
<A NAME="TTools_d.htm
"></A>


<H2 CLASS="sectionTitle">
<A HREF="#index.htm">Using Tools</A>: 10 
pcget</H2>
<P>
<A NAME="TTools_d.htm
_IX_Pcget">
 </A>
Once you have pccom running on the target machine, you can invoke <CODE>
pcget</CODE>
 on the development machine to yank a file from the target machine to the development machine.</P>
<P>
Normally you would just type</P>
<PRE>pcget goemon.gif</PRE>
<P>
to retrieve a file from the target machine's current directory or </P>
<PRE>pcget ..\clipart\jigen.gif</PRE>
<P>
to retrieve it from another directory. To use different speed settings than the <CODE>
pccom</CODE>
 tool would normally use (the <CODE>
pccom</CODE>
 tool's settings are normally determined by the PTTY environment variable), you may pass /b, /c, and /I flags, as you did when invoking the <CODE>
pccom</CODE>
 tool. The /b flag sets the baud rate (e.g. &quot;/b:19400&quot;); the /c: flag sets the com port (e.g. &quot;/c:3&quot;), and the /I flag sets the IRQ level (e.g. &quot;/I:3&quot;). Note that these flags may be indicated with &quot;-&quot; instead of &quot;/&quot;).</P>
<HR>
<A NAME="TTools_e.htm
"></A>


<H2 CLASS="sectionTitle">
<A HREF="#index.htm">Using Tools</A>: 11 
pcs</H2>
<P>
<A NAME="TTools_e.htm
_IX_PCS.PAT file">
 </A>
<A NAME="TTools_e.htm
_IX_Pcs">
 </A>
Once you have pccom running on the target machine, invoke <CODE>
pcs</CODE>
 on the development machine to send your geode's executable to the proper place on the target machine. The pcs tool figures out which files to send (and which directory to send them to) via a number of rules set up in the ROOT_DIR\INCLUDE\PCS.PAT file. Thus it knows to send applications (files that end in .GEO) to the target machine's WORLD directory. (Note that the &quot;/&quot; and &quot;-&quot; characters in the flags below are interchangeable--hyphens are used with the n, S, and t flags by tradition.)</P>
<DL>
<DT>
<STRONG>
/I:</STRONG>
<STRONG>
IRQ</STRONG>
</DT><DD>Communicate at a different interrupt level than <CODE>
pccom</CODE>
 is presently using (this is a dangerous option).</DD>
<DT>
<STRONG>
-S </STRONG>
<STRONG>
file</STRONG>
</DT><DD>Send all files mentioned in the file <EM>file</EM>.</DD>
<DT>
<STRONG>
/b:</STRONG>
<STRONG>
baudRate</DT><DD>
</STRONG>
Communicate at a different speed than <CODE>
pccom</CODE>
 is presently using (this is a dangerous option).</DD>
<DT>
<STRONG>
/c:</STRONG>
<STRONG>
portNum</DT><DD>
</STRONG>
Communicate via a different COM port than <CODE>
pccom</CODE>
 is presently using (this is a dangerous option).</DD>
<DT>
<STRONG>
-h</STRONG>
 </DT><DD>Get help.</DD>
<DT>
<STRONG>
-n</STRONG>
</DT><DD>Send non-Error Checking version instead of EC.</DD>
<DT>
<STRONG>
-t </STRONG>
<STRONG>
token</STRONG>
</DT><DD>Send all files associated with the named token (see below).</DD>
</DL>
<P>
<A NAME="TTools_e.htm
_IX_SEND file">
 </A>
When using a token, pcs looks up the token in the INCLUDE\SEND file to determine which files should be sent. Generally all executables associated with an application, library, or mechanism are sent when the appropriate token is passed. Look in the SEND file to find out what the accepted tokens are and what they send. Suppose your send file consisted of the following lines:</P>
<PRE>PC		DRIVER/VIDEO/DUMB/HGC/HGC 					GEO
HGCAT 		DRIVER/VIDEO/DUMB/HGC/HGC 					GEO
PCB 		DRIVER/VIDEO/DUMB/HGC/HGC 					GEO
PCB 		DRIVER/MOUSE/LOGIBUS/LOGIBUS 					GEO
PCS 		DRIVER/VIDEO/DUMB/HGC/HGC 					GEO
PCS 		DRIVER/MOUSE/LOGISER/LOGISER 					GEO</PRE>
<P>
Typing </P>
<PRE>pcs -t pc</PRE>
<P>
would send the file DRIVER\VIDEO\DUMB\HGC\HGCEC.GEO (HGC.GEO if sending non-EC). Typing &quot;pcs -S pcb&quot; would send that file, and also DRIVER\MOUSE\LOGIBUS\LOGIBUSE.GEO (or LOGIBUS.GEO). </P>

<HR>
<A NAME="TTools_f.htm
"></A>


<H2 CLASS="sectionTitle">
<A HREF="#index.htm">Using Tools</A>: 12 
pcsend</H2>
<P>
<A NAME="TTools_f.htm
_IX_Pcsend">
 </A>
The <CODE>
pcsend</CODE>
 tool sends files from the development machine to the target machine (assuming that the target machine is running pccom). Normally you use pcs to send geodes between machines, as that tool has knowledge of where geodes belong; pcsend is for those cases where the pcs tool's automatic behavior is undesirable. With pcsend, you can specify source and destination explicitly.</P>
<P>
Normally you will invoke pcsend by typing something like:</P>
<PRE>pcsend zenigata.pcx</PRE>
<P>
or (to send to a directory other than the target PC's current directory):</P>
<PRE>pcsend zenigata.pcx /d:..\clipart</PRE>
<P>
In addition to the /d option, you may also pass /b, /c, or  /I options to override the speed, port, and/or IRQ values in the PTTY environment variable. (You may use &quot;-&quot; instead of &quot;/&quot; when passing these flags.)</P>
<PRE>pcsend sendslow.com /b:2400</PRE>
<HR>
<A NAME="TTools_10.htm
"></A>


<H2 CLASS="sectionTitle">
<A HREF="#index.htm">Using Tools</A>: 13 
<A NAME="TTools_10.htm
_28191">
 </A>
pmake</H2>
<P>
<A NAME="TTools_10.htm
_IX_PMake">
 </A>
The <CODE>
pmake</CODE>
 program is a make utility. This means that it takes a directory of sources and a makefile which contains knowledge of how to turn these sources into geodes. If there were no <CODE>
pmake</CODE>
, then you would have to type goc, bcc, and glue each time.</P>
<P>
The <CODE>
pmake</CODE>
 program will work correctly if you have set up your files correctly. This means that you must have a makefile. You should run <CODE>
mkmf</CODE>
 to generate a makefile that knows how to generate geodes. If you are an experienced C programmer, you may have come up with some customizations that you use with your make utility. We still suggest that you work from a standard makefile (which knows about Goc and Glue), but include your customizations in a <STRONG CLASS="fileName">
local.mk</STRONG>
 file (see <A HREF="#TTools_12.htm_65382"> How to Customize pmake</A>
).</P>
<P>
When you have just added or removed source files from a geode, you will have to generate new dependency information, which <CODE>
pmake</CODE>
 will use when doing other makes. You can use <CODE>
pmake</CODE>
 to generate this information (it will make an appropriate call to the <CODE>
makedpnd</CODE>
 program; it will store the result in <STRONG CLASS="fileName">
depends.mk</STRONG>
):</P>
<PRE><A NAME="TTools_10.htm
_IX_Depend target"> </A>pmake depend</PRE>
<P>
Once you have created your source and make files, all you need to do to invoke <CODE>
pmake</CODE>
 is type</P>
<PRE>pmake</PRE>
<P>
The <CODE>
pmake</CODE>
 tool can be used to construct a specific target. Thus, if you need to generate an .OBJ file but do not need the rest of the geode, you may type something like:</P>
<PRE>pmake sdtrk.obj</PRE>
<P>
The system makefiles have been set up with knowledge of some special targets. If you are making a library and wish to install it in the proper directory so that all applications may use it, then signal this to <CODE>
pmake</CODE>
:</P>
<PRE><A NAME="TTools_10.htm
_IX_Lib target"> </A>pmake lib</PRE>
<P>
The <CODE>
pmake</CODE>
 program does have command-line arguments, but these are used only rarely; they are detailed below.</P>
<P CLASS="subsectionLink">
<A HREF="#TTools_11.htm">Copyright Notice and Acknowledgment</A></P>
<P CLASS="subsectionLink">
<A HREF="#TTools_12.htm">How to Customize pmake</A></P>
<P CLASS="subsectionLink">
<A HREF="#TTools_13.htm">Command Line Arguments</A></P>
<P CLASS="subsectionLink">
<A HREF="#TTools_14.htm">Contents of a Makefile</A></P>
<P CLASS="subsectionLink">
<A HREF="#TTools_15.htm">Advanced pmake Techniques</A></P>
<P CLASS="subsectionLink">
<A HREF="#TTools_16.htm">The Way Things Work</A></P>
<HR>
<A NAME="TTools_11.htm
"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Using Tools</A>: 13.1 <A HREF="#TTools_10.htm">pmake</A>: 
Copyright Notice and Acknowledgment</H3>
<P>
The <CODE>
pmake</CODE>
 tool comes under the following copyright notice:</P>
<P>
Copyright&#169; 1988, 1989 by the Regents of the University of California<BR>
Copyright&#169; 1988, 1989 by Adam de Boor<BR>
Copyright&#169; 1989 by Berkeley Softworks</P>
<P>
Permission to use, copy, modify, and distribute this software (<CODE>
pmake</CODE>
) and its documentation for any non-commercial purpose and without fee is hereby granted, provided that the above copyright notice appears in all copies. The University of California, Berkeley Softworks, and Adam de Boor make no representations about the suitability of this software for any purpose. It is provided &quot;as is&quot; without express or implied warranty.</P>
<P>
The <CODE>e/combo.htm"
pmake</CODE>
 program for the PC uses the SPAWNO routines by Ralf Brown to minimize memory use while shelling to DOS and running other programs.</P>
<HR>
<A NAME="TTools_12.htm
"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Using Tools</A>: 13.2 <A HREF="#TTools_10.htm">pmake</A>: 
<A NAME="TTools_12.htm
_65382">
 </A>
How to Customize pmake</H3>
<P>
For most applications, executing <CODE>
mkmf</CODE>
 will generate a perfect makefile. However, you may be creating an unusual geode or have some makefile definitions which you want to include. Fortunately, there are ways to customize your make environment without having to build a MAKEFILE from scratch.</P>
<P>
<A NAME="TTools_12.htm
_IX_local.mk makefile">
 </A>
Makefiles can #include other makefiles. If you have a file named LOCAL.MK in your make directory, then the standard makefile generated by mkmf will include it; if you wish to customize your makes, you can create a LOCAL.MK file and fill it with appropriate make directives.</P>
<P>
Depending on how much customization you need to do, you may wish to read on to find out about makefile syntax. However, there are several simple things you can do without learning too much about makefiles.</P>
<PRE># Pass extra flags to Goc:
<A NAME="TTools_12.htm
_IX_GOCFLAGS makefile variable"> </A>GOCFLAGS		+= <EM>flag1 flag2</EM></PRE>
<PRE># Pass extra flags to your C compiler:
<A NAME="TTools_12.htm
_IX_CCOMFLAGS makefile variable"> </A>CCOMFLAGS		+= <EM>flag1 flag2</EM></PRE>
<PRE># Pass extra flags to the Esp assembler (if you have
# that tool):
<A NAME="TTools_12.htm
_IX_ASMFLAGS makefile variable"> </A>ASMFLAGS		+= <EM>flag1 flag2</EM></PRE>
<PRE># Pass extra flags to the Glue linker:
<A NAME="TTools_12.htm
_IX_LINKFLAGS makefile variable"> </A>LINKFLAGS 		+= <EM>flag1 flag2</EM></PRE>
<PRE># Look somewhere special for .GOC files
# (This pattern applies to any suffix):
.PATH.GOC 		: $(ROOT_DIR)\<EM>DIR1</EM> \<EM>DIR2</EM></PRE>
<PRE># Specify geode name:
<A NAME="TTools_12.htm
_IX_GEODE makefile variable"> </A>GEODE 		= NAME</PRE>
<PRE># Set NO_EC variable (which signals that we don't
# want to make an Error Checking version):
<A NAME="TTools_12.htm
_IX_NO_EC makefile variable"> </A>NO_EC 		= 1</PRE>
<PRE># If your preprocessor is not reachable via the 
# Path environment variable:
<A NAME="TTools_12.htm
_IX_CPP makefile variable"> </A>CPP 		= <EM>vol</EM>:\<EM>path</EM>\<EM>name</EM></PRE>
<PRE># If your C compiler is not reachable via the Path
# environment variable:
<A NAME="TTools_12.htm
_IX_CCOM makefile variable"> </A>CCOM 		= <EM>vol</EM>:\<EM>path</EM>\<EM>name</EM></PRE>
<PRE># Include some other make file
#include &quot;OTHERMF.MK&quot;
# Include the standard makefile directives
# This will include INCLUDE\GEODE.MK:
#include &lt;$(SYSMAKEFILE)&gt;</PRE>

<H7 CLASS="CodeTitle Script">


Sample local.mk Files</H7>
<PRE>---FINGER\LOCAL.MK
# Local Makefile for FPaint
#  FPaint is stored in a directory called FINGER. This would normally confuse
#  pmake, which expects the geode name to be the same as the directory name.
#  Let us, therefore, alert pmake to the geode's real name:
GEODE		= FPAINT
# This was the only thing we wanted to change, so include standard definitions:
#include &lt;$(SYSMAKEFILE)&gt;</PRE>
<PRE>---PROMO\LOCAL.MK
# Local Makefile for Promo
#  Promo uses some clip art that isn't in or below its source directory, so we
#  tell pmake where to look for it:
.PATH.GOH 	: $(CSOURCE_PATHS) $(CINCLUDE_DIR) $(ROOT_DIR)\LOGOART
# This program contains no Error Checking code (See 
# <A HREF="../../Programming/GOCLanguage/index.htm">the GOC Programming chapter</A> for information
# about EC code. So we tell pmake not to bother making an Error Checking
# version:
NO_EC = 1
# Include the standard system makefile:
#include &lt;$(SYSMAKEFILE)&gt;</PRE>

<HR>
<A NAME="TTools_13.htm
"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Using Tools</A>: 13.3 <A HREF="#TTools_10.htm">pmake</A>: 
Command Line Arguments</H3>
<P>
The <CODE>
pmake</CODE>
 program comes with a wide variety of flags to choose from. They must be passed in the following order: flags (if any), variable assignments (if any), target (if any).</P>
<PRE>pmake [flags] [variables] [target]</PRE>
<P>
The flags are as follows:</P>
<DL>
<DT>
<STRONG>
-d</STRONG>
 <STRONG>
info</STRONG>
</DT><DD>This causes <CODE>
pmake</CODE>
 to print out debugging information that may prove useful to you. The <EM>info</EM> parameter is a string of single characters that tell <CODE>
pmake</CODE>
 what aspects you are interested in. Most of these options will make little sense to you unless you've dealt with Make before. Just remember where this table is and come back to it as you read on. The characters and the information they produce are as follows:</DD>
<DL>
<DT>
<STRONG>
*</STRONG>
</DT><DD>All debugging information.</DD>
<DT>
<STRONG>
c</STRONG>
</DT><DD>Conditional evaluation.</DD>
<DT>
<STRONG>
d</STRONG>
 </DT><DD>The searching and caching of directories.</DD>
<DT>
<STRONG>
m</STRONG>
</DT><DD>The making of each target: what target is being examined; when it was last modified; whether it is out-of-date; etc.</DD>
<DT>
<STRONG>
p</STRONG>
</DT><DD>Makefile parsing.</DD>
<DT>
<STRONG>
r</STRONG>
</DT><DD>Remote execution.</DD>
<DT>
<STRONG>
s</STRONG>
</DT><DD>The application of suffix-transformation rules. </DD>
<DT>
<STRONG>
t</STRONG>
</DT><DD>The maintenance of the list of targets.</DD>
<DT>
<STRONG>
v</STRONG>
</DT><DD>Variable assignment.</DD>
</DL>
<P>
Of these, the &quot;m&quot; and &quot;s&quot; flags will be most useful.</P>
<DT>
<STRONG>
-f</STRONG>
 <STRONG>
file</STRONG>
</DT><DD>Specify a makefile to read different from the default (MAKEFILE). If <EM>file </EM>is &quot;-&quot;, <CODE>
pmake</CODE>
 uses the standard input. This is useful for making &quot;quick and dirty&quot; makefiles.</DD>
<DT>
<STRONG>
-h</STRONG>
</DT><DD>Prints out a summary of the various flags <CODE>
pmake</CODE>
 accepts. It can also be used to find out what level of concurrence was compiled into the version of <CODE>
pmake</CODE>
 you are using (look at -J and -L) and various other information on how <CODE>
pmake</CODE>
 is configured.</DD>
<DT>
<STRONG>
-i</STRONG>
 </DT><DD>If you give this flag, <CODE>
pmake</CODE>
 will ignore non-zero status returned by any of its shells. It's like placing a &quot;-&quot; before all the commands in the makefile.</DD>
<DT>
<STRONG>
-k</STRONG>
 </DT><DD>This is similar to -i in that it allows <CODE>
pmake</CODE>
 to continue when it sees an error, but unlike -i where <CODE>
pmake</CODE>
 continues blithely as if nothing went wrong, -k causes it to recognize the error and only continue work on those things that don't depend on the target, either directly or indirectly (through depending on something that depends on it), whose creation returned the error. (The &quot;k&quot; is for &quot;keep going&quot;.)</DD>
<DT>
<STRONG>
-n</STRONG>
 </DT><DD>This flag tells <CODE>
pmake</CODE>
 not to execute the commands needed to update the out-of-date targets in the makefile. Rather, <CODE>
pmake</CODE>
 will simply print the commands it would have executed and exit. This is particularly useful for checking the correctness of a makefile. If <CODE>
pmake</CODE>
 doesn't do what you expect it to, it's a good chance the makefile is wrong.</DD>
<DT>
<STRONG>
-p</STRONG>
 <STRONG>
number</STRONG>
 </DT><DD>You should never have to use this option; it is used for debugging <CODE>
pmake</CODE>
. This causes <CODE>
pmake</CODE>
 to print its input in a reasonable form, though not necessarily one that would make immediate sense to anyone but a <CODE>
pmake</CODE>
 expert. The <EM>
number </EM>
is a bitwise-or of 1 and 2 where 1 means it should print the input before doing any processing and 2 says it should print it after everything has been re-created. Thus &quot;-p 3&quot;would print it twice--once before processing and once after (you might find the difference between the two interesting). </DD>
<DT>
<STRONG>
-q</STRONG>
</DT><DD>If you give <CODE>
pmake</CODE>
 this flag, it will not try to re-create anything. It will just query to see if anything is out-of-date and exit non-zero if so.</DD>
<DT>
<STRONG>
-s</STRONG>
 </DT><DD>This silences <CODE>
pmake</CODE>
, preventing it from printing commands before they're executed. It is the equivalent of putting an &quot;@&quot; before every command in the makefile.</DD>
<DT>
<STRONG>
-t</STRONG>
 </DT><DD>Rather than try to re-create a target, <CODE>
pmake</CODE>
 will simply &quot;touch&quot; it so as to make it appear up-to-date. If the target didn't exist before, it will when <CODE>
pmake</CODE>
 finishes, but if the target did exist, it will appear to have been updated.</DD>
<DT>
<STRONG>
-D</STRONG>
 <STRONG>
var</STRONG>
 </DT><DD>Allows you to define a variable to have 1 as its value. The variable is a global variable, not a command-line variable. This is useful mostly for people who are used to the C compiler arguments and those using conditionals, which are described in <A HREF="#TTools_15.htm_42979"> Conditional Statements</A>
, below.</DD>
<DT>
<STRONG>
-I</STRONG>
 <STRONG>
directory</STRONG>
 </DT><DD>Tells <CODE>
pmake</CODE>
 another place to search for included makefiles.</DD>
<DT>
<STRONG>
-W</STRONG>
 </DT><DD>Suppresses <CODE>
pmake</CODE>
's warnings. Note that tools which <CODE>
pmake</CODE>
 invokes (Goc, Glue, etc.) may still print out warnings of their own.</DD>
</DL>
<HR>
<A NAME="TTools_14.htm
"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Using Tools</A>: 13.4 <A HREF="#TTools_10.htm">pmake</A>: 
Contents of a Makefile</H3>
<P>
The <CODE>
pmake</CODE>
 program takes as input a file that tells</P>
<UL>
<LI>
which files depend on which other files and </LI>
<LI>
what to do about files that are &quot;out-of-date.&quot; </LI>
</UL>
<P>
This file is known as a &quot;makefile&quot; and is usually kept in the top-most directory of the system to be built. While you can call the makefile anything you want, <CODE>
pmake</CODE>
 will look for MAKEFILE in the current directory if you don't tell it otherwise. To specify a different makefile, use the -f flag (e.g. &quot;pmake -f program.mk&quot;).</P>
<P>
A makefile has four different types of lines in it:</P>
<UL>
<LI>
File dependency specifications</LI>
<LI>
Creation commands</LI>
<LI>
Variable assignments</LI>
<LI>
Comments, include statements and conditional directives</LI>
</UL>
<P>
Any line may be continued over multiple lines by ending it with a backslash (&quot;\&quot;). The backslash, following newline and any initial whitespace on the following line are compressed into a single space before the input line is examined by pmake.</P>

<H4 CLASS="HeadingC">
Dependency Lines</H4>
<P>
<A NAME="TTools_14.htm
_IX_Dependency lines (makefiles)">
 </A>
In any system, there are dependencies between the files that make up the system. For instance, in a program made up of several C source files and one header file, the C files will need to be re-compiled should the header file be changed. For a document of several chapters and one macro file, the chapters will need to be reprocessed if any of the macros changes. These are dependencies and are specified by means of dependency lines in the makefile.</P>
<P>
<A NAME="TTools_14.htm
_IX_Source:meaning in makefiles">
 </A>
<A NAME="TTools_14.htm
_IX_Target:when making">
 </A>
<A NAME="TTools_14.htm
_IX_Targets in makefiles">
 </A>
On a dependency line, there are <EM>
targets</EM>
 and <EM>
sources</EM>
, separated by a one- or two-character operator. The targets &quot;depend&quot; on the sources and are usually created from them. Any number of targets and sources may be specified on a dependency line. All the targets in the line are made to depend on all the sources. Targets and sources need not be actual files, but every source must be either an actual file or another target in the makefile. If you run out of room, use a backslash at the end of the line to continue onto the next one.</P>
<P>
Any file may be a target and any file may be a source, but the relationship between the two (or however many) is determined by the &quot;operator&quot; that separates them. Three types of operators exist: one specifies that the datedness of a target is determined by the state of its sources, while another specifies other files (the sources) that need to be dealt with before the target can be re-created. The third operator is very similar to the first, with the additional condition that the target is out-of-date if it has no sources. These operations are represented by the colon, the exclamation point and the double-colon, respectively, and are mutually exclusive (to represent a colon in a target, you must precede it with a backslash: &quot;\:&quot;). Their exact semantics are as follows:</P>
<DL>
<DT>
<A NAME="TTools_14.htm
_IX_\::in makefiles">
 </A>
: </DT><DD>If a colon is used, a target on the line is considered to be &quot;out-of-date&quot; (and in need of creation) if </DD>
<UL>
<LI>
the target doesn't exist or </LI>
<LI>
any of the sources has been modified more recently than the target.</LI>
</UL>
<P>Under this operator, steps will be taken to re-create the target only if it is found to be out-of-date by using these two rules.</P>
<DT>
<A NAME="TTools_14.htm
_IX_!:in makefiles">
 </A>
! </DT><DD>If an exclamation point is used, the target will always be re-created, but this will not happen until all of its sources have been examined and re-created, if necessary.</DD>
<DT>
<A NAME="TTools_14.htm
_IX_\:\: in makefiles">
 </A>
:: </DT><DD>If a double-colon is used, a target is out-of-date if</DD>
<UL>
<LI>
the target has no sources, </LI>
<LI>
any of the sources has been modified more recently than the target, or</LI>
<LI>
the target doesn't exist.</LI>
</UL>
<P>
If the target is out-of-date according to these rules, it will be re-created. This operator also does something else to the targets, as described in <A HREF="#TTools_14.htm_38184"> Shell Commands</A>).</P>
</DL>
<P>
Suppose there are three C files (<STRONG CLASS="fileName">
a.c</STRONG>
, <STRONG CLASS="fileName">
b.c</STRONG>
 and <STRONG CLASS="fileName">
c.c</STRONG>
) each of which includes the file <STRONG CLASS="fileName">
defs.h</STRONG>
. The dependencies between the files could then be expressed as follows:</P>
<PRE>PROGRAM.EXE 			: A.OBJ B.OBJ C.OBJ
A.OBJ B.OBJ C.OBJ 			: DEFS.H
A.OBJ 			: A.C
B.OBJ 			: B.C
C.OBJ 			: C.C</PRE>
<P>
You may be wondering at this point, where A.OBJ, B.OBJ and C.OBJ came in and why they depend on defs.h and the C files don't. The reason is quite simple: PROGRAM.EXE cannot be made by linking together .c files--it must be made from .obj files. Likewise, if you change DEFS.H, it isn't the .c files that need to be re-created, it's the .obj files. If you think of dependencies in these terms--which files (targets) need to be created from which files (sources)-- you should have no problems.</P>
<P>
An important thing to notice about the above example is that all the .obj files appear as targets on more than one line. This is perfectly all right: the target is made to depend on all the sources mentioned on all the dependency lines. For example, A.OBJ depends on both DEFS.H and A.C.</P>
<P>
The order of the dependency lines in the makefile is important: the first target on the first dependency line in the makefile will be the one that gets made if you don't say otherwise. That's why PROGRAM.EXE comes first in the example makefile, above.

</P>
<P>
Both targets and sources may contain the standard C-Shell wildcard characters ({, }, *, ?, [, and ]), but the square braces may only appear in the final component (the file portion) of the target or source. The characters mean the following things:</P>
<DL>
<DT>
<A NAME="TTools_14.htm
_IX_} in makefiles">
 </A>
<A NAME="TTools_14.htm
_IX_{ in makefiles">
 </A>
{ } </DT><DD>These enclose a comma-separated list of options and cause the pattern to be expanded once for each element of the list. Each expansion contains a different element. For example, </DD>
<PRE>SRC\{WHIFFLE,BEEP,FISH}.C</PRE>
<P>
expands to the three words &quot;SRC\WHIFFLE.C&quot;, &quot;SRC\BEEP.C&quot;, and &quot;SRC\FISH.C&quot;. These braces may be nested and, unlike the other wildcard characters, the resulting words need not be actual files. All other wildcard characters are expanded using the files that exist when <CODE>
pmake</CODE>
 is started.</P>
<DT>
<A NAME="TTools_14.htm
_IX_*:in makefile">
 </A>
* </DT><DD>This matches zero or more characters of any sort. </DD>
<PRE>SRC\*.C</PRE>
<P>
will expand to the same three words as above as long as <STRONG CLASS="fileName">
src</STRONG>
 contains those three files (and no other files that end in .c).</P>
<DT>
<A NAME="TTools_14.htm
_IX_&qmark;:in makefiles">
 </A>
? </DT><DD>Matches any single character.</DD>
<DT>
<A NAME="TTools_14.htm
_IX_]:in makefiles">
 </A>
<A NAME="TTools_14.htm
_IX_[:in makefiles">
 </A>
[ ] </DT><DD>This is known as a character class and contains either a list of single characters, or a series of character ranges ([a-z], for example means all characters between a and z), or both. It matches any single character contained in the list. E.g. [A-Za-z] will match all letters, while [0123456789] will match all numbers.</DD>


</DL>
<H4 CLASS="HeadingC">
<A NAME="TTools_14.htm
_38184">
 </A>
Shell Commands</H4>
<P>
<A NAME="TTools_14.htm
_IX_Shell commands in makefiles">
 </A>
At this point, you may be wondering how files are re-created. The re-creation is accomplished by commands you place in the makefile. These commands are passed to the shell to be executed and are expected to do what's necessary to update the target file. (The <CODE>
pmake</CODE>
 program doesn't actually check to see if the target was created. It just assumes it's there.)</P>
<P>
Shell commands in a makefile look a lot like shell commands you would type, with one important exception: each command in a makefile <EM>
must</EM>
 be preceded by at least one tab.</P>
<P>
Each target has associated with it a shell script made up of one or more of these shell commands. The creation script for a target should immediately follow the dependency line for that target. While any given target may appear on more than one dependency line, only one of these dependency lines may be followed by a creation script, unless the &quot;::&quot; operator was used on the dependency line.</P>
<P>
If the double-colon was used, each dependency line for the target may be followed by a shell script. That script will only be executed if the target on the associated dependency line is out-of-date with respect to the sources on that line, according to the rules given earlier. </P>
<P>
To expand on the earlier makefile, you might add commands as follows:</P>
<PRE>PROGRAM.EXE : A.OBJ B.OBJ C.OBJ
	BCC A.OBJ B.OBJ C.OBJ -o PROGRAM.EXE
A.OBJ B.OBJ C.OBJ : DEFS.H
A.OBJ : A.C
	bcc -c A.C
B.OBJ : B.C
	bcc -c B.C
C.OBJ : C.C
	bcc -c C.C</PRE>
<P>
Something you should remember when writing a makefile is that the commands will be executed if the <EM>
target</EM>
 on the dependency line is out-of-date, not the sources. In this example, the command &quot;bcc -c a.c&quot; will be executed if <STRONG CLASS="fileName">
a.obj</STRONG>
 is out-of-date. Because of the &quot;:&quot; operator, this means that should <STRONG CLASS="fileName">
a.c</STRONG>
 or <STRONG CLASS="fileName">
defs.h</STRONG>
 have been modified more recently than <STRONG CLASS="fileName">
a.obj</STRONG>
, the command will be executed (<STRONG CLASS="fileName">
a.obj</STRONG>
 will be considered out-of-date).</P>
<P>
There is another way in which makefile commands differ from regular shell commands. The first two characters after the initial whitespace are treated specially. If they are any combination of &quot;<A NAME="TTools_14.htm
_IX_@:in makefiles">
 </A>
@&quot; and &quot;<A NAME="TTools_14.htm
_IX_- (Hyphen):in makefiles">
 </A>
-&quot;, they cause <CODE>
pmake</CODE>
 to do things differently.</P>
<P>
In most cases, shell commands are printed before they're actually executed. This is to keep you informed of what's going on. If an &quot;@&quot; appears, however, this echoing is suppressed. In the case of an <CODE>
echo</CODE>
 command, perhaps &quot;echo Linking index&quot; it would be rather messy to output </P>
<PRE>echo Linking index
Linking index</PRE>
<P>
The other special character is the dash (&quot;-&quot;). Shell commands finish with a certain &quot;exit status.&quot; This status is made available by the operating system to whatever program invoked the command. Normally this status will be zero if everything went ok and non-zero if something went wrong. For this reason, <CODE>
pmake</CODE>
 will consider an error to have occurred if one of the shells it invokes returns a non-zero status. When it detects an error, <CODE>
pmake</CODE>
's usual action is to abort whatever it's doing and exit with a non-zero status itself. This behavior can be altered, however, by placing a &quot;-&quot; at the front of a command (e.g. &quot;-copy index index.old&quot;) . In such a case, the non-zero status is simply ignored and <CODE>
pmake</CODE>
 keeps going.</P>
<P>
<A NAME="TTools_14.htm
_IX_`  (Backquote):In shell commands">
 </A>
<A NAME="TTools_14.htm
_IX_COMMAND.COM">
 </A>
If the system call should be made through the DOS COMMAND.COM, precede the shell command with a backquote (`).</P>


<H4 CLASS="HeadingC">
Variables</H4>
<P>
<A NAME="TTools_14.htm
_IX_Variables in makefiles">
 </A>
The <CODE>
pmake</CODE>
 program has the ability to save text in variables to be recalled later at your convenience. Variables in <CODE>
pmake</CODE>
 are used much like variables in the shell and, by tradition, consist of all upper-case letters. Variables are assigned using lines of the form</P>
<PRE><EM>VARIABLE</EM> <A NAME="TTools_14.htm
_IX_=:in makefiles"> </A>= <EM>value</EM></PRE>
<P>
append using lines of the form</P>
<PRE><EM>VARIABLE</EM> <A NAME="TTools_14.htm
_IX_+=:in makefiles"> </A>+= <EM>value</EM></PRE>
<P>
conditionally assigned (if the variable isn't already defined) by using lines of the form</P>
<PRE><EM>VARIABLE</EM> <A NAME="TTools_14.htm
_IX_&qmark;=:in makefiles"> </A>?= <EM>value</EM></PRE>
<P>
and assigned with expansion (i.e. the value is expanded (see below) before being assigned to the variable--useful for placing a value at the beginning of a variable, or other things) by using lines of the form</P>
<PRE><EM>VARIABLE</EM> <A NAME="TTools_14.htm
_IX_\:=:in makefiles"> </A>:= <EM>value</EM></PRE>
<P>
Any whitespace before <EM>
value</EM>
 is stripped off. When appending, a space is placed between the old value and the values being appended.</P>
<P>
The final way a variable may be assigned is using lines of the form</P>
<PRE><EM>VARIABLE</EM> <A NAME="TTools_14.htm
_IX_!=:in makefiles"> </A>!= <EM>shell-command</EM></PRE>
<P>
or, if the shell command requires the use of the command.com interpreter, </P>
<PRE><EM>VARIABLE</EM> != <A NAME="TTools_14.htm
_IX_`  (Backquote):with !="> </A>`<EM>shell-command</EM></PRE>
<P>
In this case, shell-command has all its variables expanded (see below) and is passed off to a shell to execute. The output of the shell is then placed in the variable. Any newlines (other than the final one) are replaced by spaces before the assignment is made. This is typically used to find the current directory via a line like:</P>
<PRE>CURRENT_DIR != `cd</PRE>
<P>
The value of a variable may be retrieved by enclosing the variable name in parentheses or curly braces and preceding the whole thing with a dollar sign. For example, to set the variable CFLAGS to the string &quot;-I\NIHON\LIB\LIBC -O&quot;, you would place a line</P>
<PRE>CFLAGS = -I\NIHON\LIB\LIBC -O</PRE>
<P>
<A NAME="TTools_14.htm
_IX_$(VAR) expressions">
 </A>
in the makefile and use the expression</P>
<PRE>$(CFLAGS)</PRE>
<P>
 wherever you would like the string &quot;-I\NIHON\LIB\LIBC -O&quot; to appear. This is called variable expansion.</P>
<P>
There are two different times at which variable expansion occurs: When parsing a dependency line, the expansion occurs immediately upon reading the line. Variables in shell commands are expanded when the command is executed. Variables used inside another variable are expanded whenever the outer variable is expanded (the expansion of an inner variable has no effect on the outer variable. That is, if the outer variable is used on a dependency line and in a shell command, and the inner variable changes value between when the dependency line is read and the shell command is executed, two different values will be substituted for the outer variable).</P>
<P>
Variables come in four flavors, though they are all expanded the same and all look about the same. They are (in order of expanding scope)</P>
<UL>
<LI>
local variables.</LI>
<LI>
command-line variables.</LI>
<LI>
global variables.</LI>
<LI>
environment variables.</LI>
</UL>
<P>
The classification of variables doesn't matter much, except that the classes are searched from the top (local) to the bottom (environment) when looking up a variable. The first one found wins.</P>

<H5 CLASS="HeadingD">
<A NAME="TTools_14.htm
_52663">
 </A>
Local Variables</H5>
<P>
<A NAME="TTools_14.htm
_IX_Local variables">
 </A>
Each target can have as many as seven local variables. These are variables that are only &quot;visible&quot; within that target's shell script and contain such things as the target's name, all of its sources (from all its dependency lines), those sources that were out-of-date, etc. Four local variables are defined for all targets. They are</P>
<DL>
<DT>
<A NAME="TTools_14.htm
_IX_.TARGET makefile local variable[;TARGET]">
 </A>
.TARGET </DT><DD><A NAME="TTools_14.htm
_IX_Targets:.TARGET local variable">
 </A>
The name of the target.</DD>
<DT>
<A NAME="TTools_14.htm
_IX_.OODATE makefile local variable[;OODATE]">
 </A>
.OODATE </DT><DD>The list of the sources for the target that were considered out-of-date. The order in the list is not guaranteed to be the same as the order in which the dependencies were given.</DD>
<DT>
<A NAME="TTools_14.htm
_IX_.ALLSRC makefile local variable[;ALLSRC]">
 </A>
.ALLSRC</DT><DD>The list of all sources for this target in the order in which they were given.</DD>
<DT>
<A NAME="TTools_14.htm
_IX_.PREFIX makefile local variable[;PREFIX]">
 </A>
.PREFIX </DT><DD>The target without its suffix and without any leading path. For example, for the target ..\..\LIB\FSREAD.C<STRONG CLASS="fileName">
,</STRONG>
 this variable would contain FSREAD.</DD>
</DL>
<P>
One other local variable, .IMPSRC, is set only for certain targets under special circumstances. It is discussed below.</P>
<P>
Two of these variables may be used in sources as well as in shell scripts. These are .TARGET and .PREFIX. The variables in the sources are expanded once for each target on the dependency line, providing what is known as a &quot;dynamic source,&quot; allowing you to specify several dependency lines at once. For example,</P>
<PRE>$(OBJS) : $(.PREFIX).c</PRE>
<P>
will create a dependency between each object file and its corresponding C source file.</P>


<H5 CLASS="HeadingD">
Command-line Variables</H5>
<P>
<A NAME="TTools_14.htm
_IX_Command-line Variables">
 </A>
Command-line variables are set when <CODE>
pmake</CODE>
 is first invoked by giving a variable assignment as one of the arguments. For example,</P>
<PRE>pmake &quot;CFLAGS = -I\NIHON\LIB\LIBC -O&quot;</PRE>
<P>
would make CFLAGS be a command-line variable with the given value. Any assignments to CFLAGS in the makefile will have no effect, because once it is set, there is (almost) nothing you can do to change a command-line variable. Command-line variables may be set using any of the four assignment operators, though only = and ?= behave as you would expect them to, mostly because assignments to command-line variables are performed before the makefile is read, thus the values set in the makefile are unavailable at the time. += is the same as = because the old value of the variable is sought only in the scope in which the assignment is taking place. The := and ?= operators will work if the only variables used are in the environment. </P>


<H5 CLASS="HeadingD">
Global Variables</H5>
<P>
<A NAME="TTools_14.htm
_IX_Global variables">
 </A>
Global variables are those set or appended in the makefile. There are two classes of global variables: those you set and those <CODE>
pmake</CODE>
 sets. The ones you set can have any name you want them to have, except they may not contain a colon or an exclamation point. The variables <CODE>
pmake</CODE>
 sets (almost) always begin with a period and contain only upper-case letters. The variables are as follows:</P>
<DL>
<DT>
<A NAME="TTools_14.htm
_IX_.PMAKE makefile variable[;PMAKE makefile variable]">
 </A>
.PMAKE</DT><DD>The name by which <CODE>
pmake</CODE>
 was invoked is stored in this variable. For compatibility, the name is also stored in the MAKE variable.</DD>
<DT>
<A NAME="TTools_14.htm
_IX_.MAKEFLAGS global variable[;MAKEFLAGS global variable]">
 </A>
.MAKEFLAGS </DT><DD>
All the relevant flags with which <CODE>
pmake</CODE>
 was invoked. This does not include such things as &quot;-f&quot; or variable assignments. Again for compatibility, this value is stored in the MFLAGS variable as well.</DD>
</DL>
<P>
Two other variables, .INCLUDES and .LIBS, are covered in the section on special targets (See <A HREF="#TTools_14.htm_16472"> Special Targets</A>
).</P>
<P>
Global variables may be deleted using lines of the form:</P>
<PRE><A NAME="TTools_14.htm
_IX_#undef makefile directive[;undef makefile directive]"> </A>#undef <EM>variable</EM></PRE>
<P>
The &quot;#&quot; must be the first character on the line. Note that this may only be done to global variables.</P>


<H5 CLASS="HeadingD">
Environment Variables</H5>
<P>
<A NAME="TTools_14.htm
_IX_Environment variables within PMake">
 </A>
Environment variables are passed by the shell that invoked <CODE>
pmake</CODE>
 and are given by <CODE>
pmake</CODE>
 to each shell it invokes. They are expanded like any other variable, but they cannot be altered in any way.</P>
<P>
<A NAME="TTools_14.htm
_IX_PMAKE environment variable">
 </A>
One special environment variable, PMAKE, is examined by <CODE>
pmake</CODE>
 for command-line flags, variable assignments, etc. that it should always use. This variable is examined before the actual arguments to <CODE>
pmake</CODE>
 are. In addition, all flags given to <CODE>
pmake</CODE>
, either through the PMAKE variable or on the command line, are placed in this environment variable and exported to each shell <CODE>
pmake</CODE>
 executes. Thus recursive invocations of <CODE>
pmake</CODE>
 automatically receive the same flags as the top-most one.</P>
<P>
Many other standard environment variables are defined and described in the Include\GEOS.MK included Makefile.</P>
<P>
Using all these variables, you can compress the sample makefile even more:</P>
<PRE>OBJS = A.OBJ B.OBJ C.OBJ
PROGRAM.EXE : $(OBJS)
	BCC $(.ALLSRC) -o $(.TARGET)
$(OBJS) : DEFS.H
A.OBJ : A.C
	BCC -c A.C
B.OBJ : B.C
	BCC -c B.C
C.OBJ : C.C
	BCC -c C.C</PRE>
<P>
In addition to variables which <CODE>
pmake</CODE>
 will use, you can set environment variables which shell commands may use using the pmake_set directive.</P>
<PRE>.C.EBJ :
pmake_set CL = $(CCOMFLAGS) /Fo$(.TARGET)
$(CCOM) $(.IMPSRC)</PRE>
<P>
You might use the above sequence to set up an argument list in the CL environment variable if your compiler (invoked with CCOM) needed its arguments in such a variable and was unable to take arguments in a file.</P>



<H4 CLASS="HeadingC">
Comments</H4>
<P>
<A NAME="TTools_14.htm
_IX_Comments:In makefiles">
 </A>
Comments in a makefile start with a &quot;#&quot; character and extend to the end of the line. They may appear anywhere you want them, except where they might be misinterpreted as a shell command.</P>


<H4 CLASS="HeadingC">
Transformation Rules</H4>
<P>
<A NAME="TTools_14.htm
_IX_Transformation rules in makefiles">
 </A>
As you know, a file's name consists of two parts: a base name, which gives some hint as to the contents of the file, and a suffix, which usually indicates the format of the file. Over the years, as DOS has developed, naming conventions, with regard to suffixes, have also developed that have become almost incontrovertible. For example, a file ending in .C is assumed to contain C source code; one with a .OBJ suffix is assumed to be a compiled, relocatable object file that may be linked into any program. One of the best aspects of <CODE>
pmake</CODE>
 comes from its understanding of how the suffix of a file pertains to its contents and their ability to do things with a file based solely on its suffix. This ability comes from something known as a transformation rule. A transformation rule specifies how to change a file with one suffix into a file with another suffix.</P>
<P>
A transformation rule looks much like a dependency line, except the target is made of two known suffixes stuck together. Suffixes are made known to <CODE>
pmake</CODE>
 by placing them as sources on a dependency line whose target is the special target .SUFFIXES. For example:</P>
<PRE>.SUFFIXES 			: .obj .c
.c.obj 			:
	$(CCOM) $(CFLAGS) -c $(.IMPSRC)</PRE>
<P>
The creation script attached to the target is used to transform a file with the first suffix (in this case, .c) into a file with the second suffix (here, .obj). In addition, the target inherits whatever attributes have been applied to the transformation rule. The simple rule above says that to transform a C source file into an object file, you compile it using your C compiler with the -c flag.</P>
<P>
This rule is taken straight from the system makefile. Many transformation rules (and suffixes) are defined there; you should look there for more examples (type &quot;pmake -h&quot; to find out where it is).</P>
<P>
There are some things to note about the transformation rule given above:</P>
<OL>
<LI>
<A NAME="TTools_14.htm
_IX_Implied source">
 </A>
<A NAME="TTools_14.htm
_IX_.IMPSRC makefile variable[;IMPSRC]">
 </A>
The .IMPSRC variable. This variable is set to the &quot;implied source&quot; (the file from which the target is being created; the one with the first suffix), which, in this case, is the .c file.</LI>
<LI>
<A NAME="TTools_14.htm
_IX_CFLAGS">
 </A>
The CFLAGS variable. Almost all of the transformation rules in the system makefile are set up using variables that you can alter in your makefile to tailor the rule to your needs. In this case, if you want all your C files to be compiled with the -g flag, to provide information for Swat or CodeView, you would set the CFLAGS variable to contain -g (&quot;CFLAGS = -g&quot;) and <CODE>
pmake</CODE>
 would take care of the rest.</LI>
</OL>
<P>
To give you a quick example, the makefile could be changed to this:</P>
<PRE>OBJS = A.OBJ B.OBJ C.OBJ</PRE>
<PRE>PROGRAM .EXE			: $(OBJS)</PRE>
<PRE>	$(CCOM) -o $(.TARGET) $(.ALLSRC)</PRE>
<PRE>$(OBJS) 			: DEFS.H</PRE>
<P>
The transformation rule given above takes the place of the 6 lines.</P>
<PRE>A.OBJ : A.C
	BCC -c A.C
B.OBJ : B.C
	BCC -c B.C
C.OBJ : C.C
	BCC -c C.C</PRE>
<P>
Now you may be wondering about the dependency between the .obj and .c files--it's not mentioned anywhere in the new makefile. This is because it isn't needed: one of the effects of applying a transformation rule is the target comes to depend on the implied source (hence the name).</P>
<P>
For a more detailed example, Suppose you have a makefile like this:</P>
<PRE>A.EXE 			: A.OBJ B.OBJ
	$(CCOM) $(.ALLSRC)</PRE>
<P>
and a directory set up like this:</P>
<P>
total 4</P>
<PRE>MAKEFILE 		  34	09-07-89 		12:43a
A        C		 119	10-03-89 		 7:39p
A        OBJ 		201	09-07-89 		12:43a
B        C		  69	09-07-89 		12:43a</PRE>
<P>
While just typing &quot;<CODE>
pmake</CODE>
&quot; will do the right thing, it's much more informative to type &quot;<CODE>
pmake</CODE>
 <CODE>
-ds</CODE>
&quot; This will show you what <CODE>
pmake</CODE>
 is up to as it processes the files. In this case, <CODE>
pmake</CODE>
 prints the following:</P>
<PRE>Suff_FindDeps (A.EXE)
	using existing source A.OBJ
	applying .OBJ -&gt; .EXE to &quot;A.OBJ&quot;
Suff_FindDeps (A.OBJ)
	trying A.C...got it
	applying .C -&gt; .OBJ to &quot;A.C&quot;
Suff_FindDeps (B.OBJ)
	trying B.C...got it
	applying .C -&gt; .OBJ to &quot;B.C&quot;
Suff_FindDeps (A.C)
	trying A.Y...not there
	trying A.L...not there
	trying A.C,V...not there
	trying A.Y,V...not there
	trying A.L,V...not there
Suff_FindDeps (B.C)
	trying B.Y...not there
	trying B.L...not there
	trying B.C,V...not there
	trying B.Y,V...not there
	trying B.L,V...not there
--- A.OBJ ---
bcc -c A.C
--- B.OBJ ---
bcc -c B.C
--- A.EXE ---
bcc A.OBJ B.OBJ</PRE>
<P>
<A NAME="TTools_14.htm
_IX_Suff_FindDeps() routine">
 </A>
<EM>
Suff_FindDeps</EM>
 is the name of a function in <CODE>
pmake</CODE>
 that is called to check for implied sources for a target using transformation rules. The transformations it tries are, naturally enough, limited to the ones that have been defined (a transformation may be defined multiple times, by the way, but only the most recent one will be used). You will notice, however, that there is a definite order to the suffixes that are tried. This order is set by the relative positions of the suffixes on the .SUFFIXES line--the earlier a suffix appears, the earlier it is checked as the source of a transformation. Once a suffix has been defined, the only way to change its position is to remove all the suffixes (by having a .SUFFIXES dependency line with no sources) and redefine them in the order you want. (Previously-defined transformation rules will be automatically redefined as the suffixes they involve are re-entered.) </P>
<P>
Another way to affect the search order is to make the dependency explicit. In the above example, a.exe depends on a.obj and b.obj. Since a transformation exists from .obj to .exe, <CODE>
pmake</CODE>
 uses that, as indicated by the &quot;using existing source a.obj&quot; message.</P>
<P>
The search for a transformation starts from the suffix of the target and continues through all the defined transformations, in the order dictated by the suffix ranking, until an existing file with the same base (the target name minus the suffix and any leading directories) is found. At that point, one or more transformation rules will have been found to change the one existing file into the target. </P>
<P>
For example, ignoring what's in the system makefile for now, say you have a makefile like this:</P>
<PRE>.SUFFIXES : .EXE .OBJ .C .Y .L
.L.C :
	LEX $(.IMPSRC)
	MOVE LEX.YY.C $(.TARGET)
.Y.C :
	YACC $(.IMPSRC)
	MOVE Y.TAB.C $(.TARGET)
.C.OBJ :
	BCC -L $(.IMPSRC)
.OBJ.EXE :
	BCC -o $(.TARGET) $(.IMPSRC)</PRE>
<P>
and the single file jive.l. If you were to type <CODE>
pmake -rd ms jive.exe</CODE>
, you would get the following output for jive.exe:</P>
<PRE>Suff_FindDeps (JIVE.EXE)
trying JIVE.OBJ...not there
trying JIVE.C...not there
trying JIVE.Y...not there
trying JIVE.L...got it
applying .L -&gt; .C to &quot;JIVE.L&quot;
applying .C -&gt; .OBJ to &quot;JIVE.C&quot;
applying .OBJ -&gt; .EXE to &quot;JIVE.OBJ&quot;</PRE>
<P>
The <CODE>
pmake</CODE>
 tool starts with the target jive.exe, figures out its suffix (.exe) and looks for things it can transform to a .exe file. In this case, it only finds .obj, so it looks for the file JIVE.OBJ.</P>
<P>
It fails to find it, so it looks for transformations into a .obj file. Again it has only one choice: .c. So it looks for JIVE.C and fails to find it. At this point it can create the .c file from either a .y file or a .l file. Since .y came first on the .SUFFIXES line, it checks for jive.y first, but can't find it, so it looks for jive.l. At this point, it has defined a transformation path as follows: .l-&gt;.c-&gt; .obj-&gt; .exe and applies the transformation rules accordingly. For completeness, and to give you a better idea of what <CODE>
pmake</CODE>
 actually did with this three-step transformation, this is what <CODE>
pmake</CODE>
 printed for the rest of the process:</P>
<PRE>Suff_FindDeps (JIVE.OBJ)
using existing source JIVE.C
applying .C -&gt; .OBJ to &quot;JIVE.C&quot;
Suff_FindDeps (JIVE.C)
using existing source JIVE.L
applying .L -&gt; .C to &quot;JIVE.L&quot;
Suff_FindDeps (JIVE.L)
Examining JIVE.L...modified 17:16:01 Oct 4,
 1987...up-to-date
Examining JIVE.C...non-existent...out-of-date
--- JIVE.C ---
LEX JIVE.L
...meaningless lex output deleted...
MV LEX.YY.C JIVE.C
Examining JIVE.OBJ...non-existent...out-of-date
--- JIVE.OBJ ---
bcc -c JIVE.C
Examining JIVE.EXE...non-existent...out-of-date
--- JIVE.EXE ---
bcc -o JIVE.EXE JIVE.OBJ</PRE>


<H4 CLASS="HeadingC">
Including Other Makefiles</H4>
<P>
<A NAME="TTools_14.htm
_IX_#include makefile directive[;include makefile directive]">
 </A>
Just as for programs, it is often useful to extract certain parts of a makefile into another file and just include it in other makefiles somehow. Many compilers allow you to use something like</P>
<PRE>#include &quot;defs.h&quot;</PRE>
<P>
to include the contents of defs.h in the source file. The <CODE>
pmake</CODE>
 program allows you to do the same thing for makefiles, with the added ability to use variables in the filenames. An include directive in a makefile looks either like this</P>
<PRE>#include &lt;file&gt;</PRE>
<P>
or like this</P>
<PRE>#include &quot;file&quot;</PRE>
<P>
The difference between the two is where <CODE>
pmake</CODE>
 searches for the file: the first way, <CODE>
pmake</CODE>
 will look for the file only in the system makefile directory (to find out what that directory is, give <CODE>
pmake</CODE>
 the -h flag).</P>
<P>
For files in double-quotes, the search is more complex; <CODE>
pmake</CODE>
 will look in the following places in the given order:</P>
<OL>
<LI>
The directory of the makefile that's including the file.</LI>
<LI>
The current directory (the one in which you invoked <CODE>
pmake</CODE>
).</LI>
<LI>
The directories given by you using -I flags, in the order in which you gave them.</LI>
<LI>
Directories given by .PATH dependency lines.</LI>
<LI>
The system makefile directory.</LI>
</OL>
<P>
You are free to use <CODE>
pmake</CODE>
 variables in the filename--<CODE>
pmake</CODE>
 will expand them before searching for the file. You must specify the searching method with either angle brackets or double-quotes <EM>
outside</EM>
 of a variable expansion. That is, the following</P>
<PRE>SYSTEM= &lt;command.mk&gt;
#include $(SYSTEM)</PRE>
<P>
won't work; instead use the following:</P>
<PRE>SYSTEM= command.mk
#include &lt;$(SYSTEM)&gt;</PRE>


<H4 CLASS="HeadingC">
Saving Commands</H4>
<P>
<A NAME="TTools_14.htm
_IX_...  (Ellipsis) in makefiles">
 </A>
There may come a time when you will want to save certain commands to be executed when everything else is done, by inserting an ellipsis &quot;...&quot; in the Makefile. Commands saved in this manner are only executed if <CODE>
pmake</CODE>
 manages to re-create everything without an error.</P>


<H4 CLASS="HeadingC">
Target Attributes</H4>
<P>
<A NAME="TTools_14.htm
_IX_Target attributes in makefiles">
 </A>
The <CODE>
pmake</CODE>
 tool allows you to give attributes to targets by means of special sources. Like everything else <CODE>
pmake</CODE>
 uses, these sources begin with a period and are made up of all upper-case letters. By placing one (or more) of these as a source on a dependency line, you are &quot;marking&quot; the target(s) with that attribute.</P>
<P>
Any attributes given as sources for a transformation rule are applied to the target of the transformation rule when the rule is applied.</P>
<DL>
<DT>
<A NAME="TTools_14.htm
_IX_.DONTCARE makefile attribute[;DONTCARE]">
 </A>
.DONTCARE </DT><DD>If a target is marked with this attribute and <CODE>
pmake</CODE>
 can't figure out how to create it, it will ignore this fact and assume the file isn't really needed or actually exists and <CODE>
pmake</CODE>
 just can't find it. This may prove wrong, but the error will be noted later on, not when <CODE>
pmake</CODE>
 tries to create the target so marked. This attribute also prevents <CODE>
pmake</CODE>
 from attempting to touch the target if given the &quot;-t&quot; flag.</DD>
<DT>
<A NAME="TTools_14.htm
_IX_.EXEC makefile attribute[;EXEC]">
 </A>
.EXEC </DT><DD>This attribute causes its shell script to be executed while having no effect on targets that depend on it. This makes the target into a sort of subroutine. EXEC sources don't appear in the local variables of targets that depend on them (nor are they touched if <CODE>
pmake</CODE>
 is given the -t flag).</DD>
<DT>
<A NAME="TTools_14.htm
_IX_.IGNORE makefile attribute[;IGNORE]">
 </A>
.IGNORE </DT><DD>Giving a target the .IGNORE attribute causes <CODE>
pmake</CODE>
 to ignore errors from any of the target's commands, as if they all had &quot;-&quot; before them.</DD>
<DT>
<A NAME="TTools_14.htm
_IX_.MAKE makefile attribute[;MAKE]">
 </A>
.MAKE </DT><DD>The .MAKE attribute marks its target as being a recursive invocation of <CODE>
pmake</CODE>
. This forces <CODE>
pmake</CODE>
 to execute the script associated with the target (if it's out-of-date) even if you gave the -n or -t flag. By doing this, you can start at the top of a system and type</DD>
<PRE>pmake -n</PRE>
<P>
and have it descend the directory tree (if your makefiles are set up correctly), printing what it would have executed if you hadn't included the -n flag.</P>
<DT>
<A NAME="TTools_14.htm
_IX_.NOTMAIN makefile attribute[;NOTMAIN]">
 </A>
.NOTMAIN </DT><DD>Normally, if you do not specify a target to make in any other way, <CODE>
pmake</CODE>
 will take the first target on the first dependency line of a makefile as the target to create. That target is known as the &quot;Main Target&quot; and is labeled as such if you print the dependencies out using the -p flag. Giving a target, this attribute tells <CODE>
pmake</CODE>
 that the target is definitely not the Main Target. This allows you to place targets in an included makefile and have <CODE>
pmake</CODE>
 create something else by default.</DD>
<DT>
<A NAME="TTools_14.htm
_IX_.PRECIOUS makefile attribute[;PRECIOUS]">
 </A>
.PRECIOUS </DT><DD>When <CODE>
pmake</CODE>
 is interrupted (by someone typing control-C at the keyboard), it will attempt to clean up after itself by removing any half-made targets. If a target has the .PRECIOUS attribute, however, <CODE>
pmake</CODE>
 will leave it alone. A side effect of the &quot;::&quot; operator is to mark the targets as .PRECIOUS.</DD>
<DT>
<A NAME="TTools_14.htm
_IX_.SILENT makefile attribute[;SILENT]">
 </A>
.SILENT</DT><DD>Marking a target with this attribute keeps its commands from being printed when they're executed, just as if they had an &quot;@&quot; in front of them.</DD>
<DT>
<A NAME="TTools_14.htm
_IX_.USE makefile attribute[;USE]">
 </A>
.USE </DT><DD>By giving a target this attribute, you turn it into <CODE>
pmake</CODE>
's equivalent of a macro. When the target is used as a source for another target, the other target acquires the commands, sources and attributes (except .USE) of the source. If the target already has commands, the .USE target's commands are added to the end. If more than one .USE-marked source is given to a target, the rules are applied sequentially.</DD>
<P>
The typical .USE rule will use the sources of the target to which it is applied (as stored in the .ALLSRC variable for the target) as its &quot;arguments.&quot; Several system makefiles (not to be confused with <EM>
the</EM>
 system makefile) make use of these .USE rules to make developing easier (they're in the default, system makefile directory).</P>

</DL>
<H4 CLASS="HeadingC">
<A NAME="TTools_14.htm
_16472">
 </A>
Special Targets</H4>
<P>
<A NAME="TTools_14.htm
_IX_Special targets in makefiles">
 </A>
There are certain targets that have special meaning to <CODE>
pmake</CODE>
. When you use one on a dependency line, it is the only target that may appear on the left-hand-side of the operator. As for the attributes and variables, all the special targets begin with a period and consist of upper-case letters only. The targets are as follows:</P>
<DL>
<DT>
<A NAME="TTools_14.htm
_IX_.BEGIN makefile special target[;BEGIN]">
 </A>
.BEGIN</DT><DD>Any commands attached to this target are executed before anything else is done. You can use it for any initialization that needs doing.</DD>
<DT>
<A NAME="TTools_14.htm
_IX_.DEFAULT makefile special target[;DEFAULT]">
 </A>
.DEFAULT </DT><DD>This is sort of a .USE rule for any target (that was used only as a source) that <CODE>
pmake</CODE>
 can't figure out any other way to create. It's only &quot;sort of&quot; a .USE rule because only the shell script attached to the .DEFAULT target is used. The .IMPSRC variable of a target that inherits .DEFAULT's commands is set to the target's own name.</DD>
<DT>
<A NAME="TTools_14.htm
_IX_.END makefile special target[;END]">
 </A>
.END </DT><DD>This serves a function similar to .BEGIN, in that commands attached to it are executed once everything has been re-created (so long as no errors occurred). It also serves the extra function of being a place on which <CODE>
pmake</CODE>
 can hang commands you put off to the end. Thus the script for this target will be executed before any of the commands you save with the ellipsis marker.</DD>
<DT>
<A NAME="TTools_14.htm
_IX_.IGNORE makefile special target[;IGNORE]">
 </A>
.IGNORE </DT><DD>This target marks each of its sources with the .IGNORE attribute. If you don't give it any sources, then it is like giving the -i flag when you invoke <CODE>
pmake</CODE>
--errors are ignored for all commands.</DD>
<DT>
<A NAME="TTools_14.htm
_IX_.INCLUDES makefile special target[;INCLUDES]">
 </A>
.INCLUDES </DT><DD>The sources for this target are taken to be suffixes that indicate a file that can be included in a program source file. The suffix must already be declared with .SUFFIXES. Any suffix so marked will have the directories on its search path (see .PATH, below) placed in the .INCLUDES variable, each preceded by a &quot;-I&quot; flag. This variable can then be used as an argument for the compiler in the normal fashion. The &quot;.h&quot; suffix is already marked in this way in the system makefile. For example, if you have </DD>
<PRE>.SUFFIXES 			: .PCX
.PATH.PCX 			: \CLIPART
.INCLUDES 			: .PCX</PRE>
<P>
<CODE>
pmake</CODE>
 places &quot;-I\CLIPART&quot; in the .INCLUDES variable and you can say </P>
<PRE>bcc $(.INCLUDES) -c xprogram.c</PRE>
<P>
(Note: the .<CODE>
INCLUDES</CODE>
 variable is not actually filled in until the entire makefile has been read.)</P>
<DT>
<A NAME="TTools_14.htm
_IX_.INTERRUPT makefile special target[;INTERRUPT]">
 </A>
.INTERRUPT </DT><DD>When <CODE>
pmake</CODE>
 is interrupted, it will execute the commands in the script for this target, if it exists.</DD>
<DT>
<A NAME="TTools_14.htm
_IX_.LIBS makefile special target[;LIBS]">
 </A>
.LIBS </DT><DD>This does for libraries what .INCLUDES does for include files, except the flag used is &quot;-L&quot;, as required by those linkers that allow you to tell them where to find libraries. The variable used is .LIBS.</DD>
<DT>
<A NAME="TTools_14.htm
_IX_.MAIN makefile special target[;MAIN]">
 </A>
.MAIN </DT><DD><A NAME="TTools_14.htm
_IX_Main target">
 </A>
If you didn't give a target (or targets) to create when you invoked <CODE>
pmake</CODE>
, it will take the sources of this target as the targets to create.</DD>
<DT>
<A NAME="TTools_14.htm
_IX_.MAKEFLAGS makefile special target[;MAKEFLAGS]">
 </A>
.MAKEFLAGS </DT><DD>This target provides a way for you to always specify flags for <CODE>
pmake</CODE>
 when the makefile is used. The flags are just as they would be typed to the shell (except you can't use shell variables unless they're in the environment), though the -f and -r flags have no effect.</DD>
<DT>
<A NAME="TTools_14.htm
_IX_.PATH makefile special target[;PATH]">
 </A>
.PATH </DT><DD>If you give sources for this target, <CODE>
pmake</CODE>
 will take them as directories in which to search for files it cannot find in the current directory. If you give no sources, it will clear out any directories added to the search path before. </DD>
<DT>
.PATH<EM>suffix </EM></DT><DD>
This does a similar thing to .PATH, but it does it only for files with the given suffix. The suffix must have been defined already. Look at <A HREF="#TTools_15.htm_60745"> Search Paths</A>
 for more information.</DD>
<DT>
<A NAME="TTools_14.htm
_IX_.PRECIOUS makefile special target[;PRECIOUS]">
 </A>
.PRECIOUS</DT><DD>Similar to .IGNORE, this gives the .PRECIOUS attribute to each source on the dependency line, unless there are no sources, in which case the .PRECIOUS attribute is given to every target in the file.</DD>
<DT>
<A NAME="TTools_14.htm
_IX_.RECURSIVE makefile special target[;RECURSIVE]">
 </A>
.RECURSIVE </DT><DD>This target applies the .MAKE attribute to all its sources. It does nothing if you don't give it any sources.</DD>
<DT>
<A NAME="TTools_14.htm
_IX_.SILENT makefile special target[;SILENT]">
 </A>
.SILENT</DT><DD>When you use .SILENT as a target, it applies the .SILENT attribute to each of its sources. If there are no sources on the dependency line, then it is as if you gave <CODE>
pmake</CODE>
 the -s flag and no commands will be echoed.</DD>
<DT>
<A NAME="TTools_14.htm
_IX_.SUFFIXES makefile special target[;SUFFIXES]">
 </A>
.SUFFIXES </DT><DD>This is used to give new file suffixes for <CODE>
pmake</CODE>
 to handle. Each source is a suffix <CODE>
pmake</CODE>
 should recognize. If you give a .SUFFIXES dependency line with no sources, <CODE>
pmake</CODE>
 will forget about all the suffixes it knew.</DD>
</DL>
<P>
In addition to these targets, a line of the form</P>
<PRE><EM>attribute</EM> : <EM>sources</EM></PRE>
<P>
applies the attribute to all the targets listed as sources .</P>


<H4 CLASS="HeadingC">
Modifying Variable Expansion</H4>
<P>
Variables need not always be expanded verbatim. The <CODE>
pmake</CODE>
 program defines several modifiers that may be applied to a variable's value before it is expanded. You apply a modifier by placing it after the variable name with a colon between the two, like so:</P>
<PRE>${<EM>VARIABLE</EM>:<EM>modifier</EM>}</PRE>
<P>
Each modifier is a single character followed by something specific to the modifier itself. You may apply as many modifiers as you want--each one is applied to the result of the previous and is separated from the previous by another colon.</P>
<P>
There are several ways to modify a variable's expansion:</P>
<DL>
<DT>
<STRONG>
:M</STRONG>
<A NAME="TTools_14.htm
_IX_\:M makefile variable expansion[;M]">
 </A>
<STRONG>
pattern </STRONG>
</DT><DD>This is used to select only those words (a word is a series of characters that are neither spaces nor tabs) that match the given pattern. The pattern is a wildcard pattern like that used by the shell, where * means zero or more characters of any sort; ? is any single character; [abcd] matches any single character that is one of &quot;a&quot;, &quot;b&quot;, &quot;c&quot; or &quot;d&quot; (there may be any number of characters between the brackets); [0-9] matches any single character that is between &quot;0&quot; and &quot;9&quot; (i.e. any digit--this form may be freely mixed with the other bracket form), and `\' is used to escape any of the characters &quot;*&quot;, &quot;?&quot;, &quot;[&quot; or &quot;:&quot;, leaving them as regular characters to match themselves in a word. </DD>
<DT>
</DT><DD>Remember that the pattern matcher requires you to prefix certain characters with a backslash, including backslash itself. this can lead to some impressive search strings, because <CODE>
pmake</CODE>
 also requires that backslashes be preceded with backslashes:</DD>
<PRE>	#if !empty(CURRENT_DIR:M*\\\\APPL\\\\*)</PRE>
<P>
The above line checks to see if the current directory matches the form &quot;*\APPL\*&quot;. (The pattern matcher is passed the string &quot;*\\APPL\\*&quot;.)</P>
<DT>
<STRONG>
:N</STRONG>
<A NAME="TTools_14.htm
_IX_\:N makefile variable expansion[;N]">
 </A>
<STRONG>
pattern</STRONG>
 </DT><DD>This is identical to :M except it substitutes all words that don't match the given pattern. </DD>
<DT>
<STRONG>
:X</STRONG>
<A NAME="TTools_14.htm
_IX_\:X makefile variable expansion[;X]">
 </A>
<STRONG>
pattern </STRONG>
</DT><DD>This is like :M except that it returns only part of the matching string. You mark which part of the string you are interested in by enclosing it within backslashed square brackets (&quot;\[&quot; and &quot;\]&quot;) (however, due to the backslash rules, you must actually use &quot;\\[&quot; and &quot;\\]&quot;.)</DD>
<PRE>	DEVEL_DIR 	:= \
	 $(CURRENT_DIR:X<A NAME="TTools_14.htm
_IX_\\[*\\\\$(ROOT_DIR\\:T)\\\\*\\]\\\\*) makefile example"> </A>\\[*\\\\$(ROOT_DIR:T)\\\\*\\]\\\\*)</PRE>
<P>
The above line returns part of the CURRENT_DIR string, specifically the directory just under the root directory. Free of backslashes, it's searching for [*\$(ROOT_DIR:T)\*]\*. If there is a subdirectory below the development directory, then this will strip off the lower layers.</P>
<DT>
<STRONG>
:S/</STRONG>
<A NAME="TTools_14.htm
_IX_\:S makefile string substitution[;S]">
 </A>
<STRONG>
search-string</STRONG>
<STRONG>
/</STRONG>
<STRONG>
replacement-string</STRONG>
<STRONG>
/[g]</DT><DD>
</STRONG>
This causes the first occurrence of <EM>search-string</EM> in the variable to be replaced by <EM>replacement-string</EM>, unless the &quot;g&quot; flag is given at the end, in which case all occurrences of the string are replaced. The substitution is performed on each word in the variable in turn. If search-string begins with a caret (&quot;^&quot;), the string must match starting at the beginning of the word. If search-string ends with a dollar sign (&quot;$&quot;), the string must match to the end of the word (these two may be combined to force an exact match). If a backslash precedes these two characters, however, they lose their special meaning. Variable expansion also occurs in the normal fashion inside both the search-string and the replacement-string, except that a backslash is used to prevent the expansion of a &quot;$&quot;, not another dollar sign, as is usual. Note that search-string is just a string, not a pattern, so none of the usual regular-expression/wildcard characters have any special meaning save &quot;^&quot; and &quot;$&quot;. In the replacement string, the &quot;&amp;&quot; character is replaced by the search-string unless it is preceded by a backslash. Thus, &quot;:S/[A-D]/&amp;&amp;/&quot; will find the string &quot;[A-D]&quot; and replace it with the string &quot;[A-D][A-D]&quot;. You are allowed to use any character except colon or exclamation point to separate the two strings. This so-called delimiter character may be placed in either string by preceding it with a backslash.</DD>
<DT>
<STRONG>
:T</STRONG>
<A NAME="TTools_14.htm
_IX_\:T makefile variable expansion[;T]">
 </A>
 </DT><DD>Replaces each word in the variable expansion by its last component (its &quot;tail&quot;). For example, given</DD>
<PRE>		OBJS = ..\LIB\A.OBJ B \USR\LIB\LIBM.A
		TAILS = $(OBJS:T)</PRE>
<P>
the variable TAILS would expand to &quot;a.obj b libm.a&quot; .</P>
<DT>
<STRONG>
:H </STRONG>
<A NAME="TTools_14.htm
_IX_\:H makefile variable expansion[;H]">
 </A>
</DT><DD>This is similar to :T, except that every word is replaced by everything but the tail (the &quot;head&quot;). Using the same definition of OBJS, the string &quot;$(OBJS:H)&quot; would expand to &quot;..\LIB \USR\LIB&quot; Note that the final slash on the heads is removed and anything without a head is replaced by a single period.</DD>
<DT>
<STRONG>
:E</STRONG>
<A NAME="TTools_14.htm
_IX_\:E makefile variable expansion[;E]">
 </A>
 </DT><DD>This replaces each word with its suffix (&quot;extension&quot;), so &quot;$(OBJS:E)&quot; would give you &quot;.OBJ .A&quot; .</DD>
<DT>
<STRONG>
:R</STRONG>
<A NAME="TTools_14.htm
_IX_\:R makefile variable expansion[;R]">
 </A>
 </DT><DD>This replaces each word with everything but the suffix (thus returning the &quot;root&quot; of the word). &quot;$(OBJS:R)&quot; expands to &quot;..\LIB\A B \USR\LIB\LIBM&quot;.</DD>
</DL>
<P>
<A NAME="TTools_14.htm
_IX_=:$(V\:s=r) expressions">
 </A>
In addition, another style of substitution is also supported. This looks like:</P>
<PRE>$(<EM>VARIABLE</EM>:<EM>search-string</EM>=<EM>replacement</EM>)</PRE>
<P>
It must be the last modifier in the chain. The search is anchored at the end of each word, so only suffixes or whole words may be replaced.</P>

<HR>
<A NAME="TTools_15.htm
"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Using Tools</A>: 13.5 <A HREF="#TTools_10.htm">pmake</A>: 
Advanced pmake Techniques</H3>
<P>
This section is devoted to those facilities in <CODE>
pmake</CODE>
 that allow you to do a great deal in a makefile with very little work, as well as do some things you couldn't do in make without a great deal of work (and perhaps the use of other programs). The problem with these features is that they must be handled with care, or you will end up with a mess.</P>

<H4 CLASS="HeadingC">
<A NAME="TTools_15.htm
_60745">
 </A>
Search Paths</H4>
<P>
<A NAME="TTools_15.htm
_IX_Search paths in makefiles">
 </A>
The <CODE>
pmake</CODE>
 tool supports the dispersal of files into multiple directories by allowing you to specify places to look for sources with .PATH targets in the makefile. The directories you give as sources for these targets make up a &quot;search path.&quot; Only those files used exclusively as sources are actually sought on a search path, the assumption being that anything listed as a target in the makefile can be created by the makefile and thus should be in the current directory.</P>
<P>
<A NAME="TTools_15.htm
_IX_.PATH[;PATH]">
 </A>
There are two types of search paths in <CODE>
pmake</CODE>
: one is used for all types of files (including included makefiles) and is specified with a plain .PATH target (e.g. &quot;.PATH : RCS&quot;), while the other is specific to a certain type of file, as indicated by the file's suffix. A specific search path is indicated by immediately following the .PATH with the suffix of the file. For instance</P>
<PRE>.PATH.H : \GEOSDEV\DEVEL\APPL\WORPRO \GEOSDEV\DEVEL</PRE>
<P>
would tell <CODE>
pmake</CODE>
 to look in the directories \GEOSDEV\DEVEL\APPL\WORPRO and \GEOSDEV\DEVEL for any files whose suffix is .H.</P>
<P>
The current directory is always consulted first to see if a file exists. Only if it cannot be found are the directories in the specific search path, followed by those in the general search path, consulted.</P>
<P>
A search path is also used when expanding wildcard characters. If the pattern has a recognizable suffix on it, the path for that suffix will be used for the expansion. Otherwise the default search path is employed.</P>
<P>
When a file is found in some directory other than the current one, all local variables that would have contained the target's name (.ALLSRC and .IMPSRC) will instead contain the path to the file, as found by <CODE>
pmake</CODE>
. Thus if you have a file ..\LIB\MUMBLE.C and a makefile</P>
<PRE>.PATH.c : ..\LIB
MUMBLE.EXE 			: MUMBLE.C
	$(CCOM) -o $(.TARGET) $(.ALLSRC)</PRE>
<P>
the command executed to create MUMBLE.EXE would be &quot;bcc -o MUMBLE ..\LIB\MUMBLE.C&quot;</P>
<P>
If a file exists in two directories on the same search path, the file in the first directory on the path will be the one <CODE>
pmake</CODE>
 uses. So if you have a large system spread over many directories, it would behoove you to follow a naming convention that avoids such conflicts.</P>
<P>
Something you should know about the way search paths are implemented is that each directory is read, and its contents cached, exactly once--when it is first encountered--so any changes to the directories while <CODE>
pmake</CODE>
 is running will not be noted when searching for implicit sources, nor will they be found when <CODE>
pmake</CODE>
 attempts to discover when the file was last modified, unless the file was created in the current directory. </P>


<H4 CLASS="HeadingC">
<A NAME="TTools_15.htm
_42979">
 </A>
Conditional Statements</H4>
<P>
<A NAME="TTools_15.htm
_IX_Conditional statements in makefiles">
 </A>
<A NAME="TTools_15.htm
_IX_#endif makefile directive[;endif makefile directive]">
 </A>
<A NAME="TTools_15.htm
_IX_#else makefile directive[;else makefile directive]">
 </A>
<A NAME="TTools_15.htm
_IX_#elif makefile directive[;elif makefile directive]">
 </A>
<A NAME="TTools_15.htm
_IX_#if makefile directive[;if makefile directive]">
 </A>
Like a C compiler, <CODE>
pmake</CODE>
 allows you to configure the makefile using conditional statements. A conditional looks like this:</P>
<PRE>#if <EM>&lt;Boolean expression&gt;
&lt;lines&gt;
</EM>#elif <EM>&lt;another Boolean expression&gt;
&lt;more lines&gt;
</EM>#else
<EM>&lt;still more lines&gt;
</EM>#endif</PRE>
<P>
They may be nested to a depth of 30 and may occur anywhere (except in a comment, of course). The &quot;#&quot; must be the very first character on the line.</P>
<P>
<A NAME="TTools_15.htm
_IX_<=:in makefiles">
 </A>
<A NAME="TTools_15.htm
_IX_<:in makefiles">
 </A>
<A NAME="TTools_15.htm
_IX_>=:in makefiles">
 </A>
<A NAME="TTools_15.htm
_IX_>:in makefiles">
 </A>
<A NAME="TTools_15.htm
_IX_!=:in makefiles">
 </A>
<A NAME="TTools_15.htm
_IX_==:in makefiles">
 </A>
<A NAME="TTools_15.htm
_IX_!:in makefiles">
 </A>
<A NAME="TTools_15.htm
_IX_||:in makefiles">
 </A>
<A NAME="TTools_15.htm
_IX_&&:in makefiles">
 </A>
Each Boolean expression is made up of terms that look like function calls, the standard C Boolean operators &amp;&amp;, ||, and !, and the standard relational operators ==, !=, &gt;, &gt;=, &lt;, and &lt;=, with == and != being overloaded to allow string comparisons as well. The &amp;&amp; operator represents logical AND; || is logical OR and ! is logical NOT. The arithmetic and string operators take precedence over all three of these operators, while NOT takes precedence over AND, which takes precedence over OR. This precedence may be overridden with parentheses, and an expression may be parenthesized to any level. Each Boolean term looks like a call on one of four functions:</P>
<DL>
<DT>
<A NAME="TTools_15.htm
_IX_make() conditional">
 </A>
<STRONG>
make</STRONG>
 </DT><DD>The syntax is make(<EM>target</EM>) where <EM>target</EM> is a target in the makefile. This is <EM>
true</EM>
 if the given target was specified on the command line or as the source for a .MAIN target (note that the sources for .MAIN are only used if no targets were given on the command line).</DD>
<DT>
<STRONG>
defined</STRONG>
<A NAME="TTools_15.htm
_IX_defined() conditional">
 </A>
 </DT><DD>The syntax is defined(<EM>variable</EM>) and is true if <EM>variable</EM> is defined. Certain variables are defined in the system makefile that identify the system on which <CODE>
pmake</CODE>
 is being run.</DD>
<DT>
<STRONG>
exists</STRONG>
<A NAME="TTools_15.htm
_IX_exists()conditional">
 </A>
 </DT><DD>The syntax is exists(<EM>file</EM>) and is true if the file can be found on the global search path (i.e. that defined by .PATH targets, not by .PATH<EM>suffix</EM> targets).</DD>
<DT>
<STRONG>
empty</STRONG>
<A NAME="TTools_15.htm
_IX_empty() conditional">
 </A>
</DT><DD>This syntax is much like the others, except the string inside the parentheses is of the same form as you would put between parentheses when expanding a variable, complete with modifiers. The function returns true if the resulting string is empty. (Note: an undefined variable in this context will cause at the very least a warning message about a malformed conditional, and at the worst will cause the process to stop once it has read the makefile. If you want to check for a variable being defined or empty, use the expression </DD>
<PRE>	!defined(<EM>var</EM>) || empty(var)</PRE>
<DT>
</DT><DD>as the definition of || will prevent the empty() from being evaluated and causing an error, if the variable is undefined). This can be used to see if a variable contains a given word, for example:</DD>
<PRE>		#if !empty(<EM>var</EM>:M<EM>word</EM>)</PRE>
</DL>
<P>
The arithmetic and string operators may only be used to test the value of a variable. The left-hand side must contain the variable expansion, while the right-hand side contains either a string, enclosed in double-quotes, or a number. The standard C numeric conventions (except for specifying an octal number) apply to both sides. For example, </P>
<PRE>#if $(OS) == 4.3
#if $(MACHINE) == &quot;sun3&quot;
#if $(LOAD_ADDR) &lt; 0xc000</PRE>
<P>
are all valid conditionals. In addition, the numeric value of a variable can be tested as a Boolean as follows:</P>
<PRE>#if $(LOAD)</PRE>
<P>
would see if LOAD contains a non-zero value and</P>
<PRE>#if !$(LOAD)</PRE>
<P>
would test if LOAD contains a zero value.</P>
<P>
<A NAME="TTools_15.htm
_IX_#ifnmake makefile directive[;ifnmake makefile directive]">
 </A>
<A NAME="TTools_15.htm
_IX_#ifmake makefile directive[;ifmake makefile directive]">
 </A>
<A NAME="TTools_15.htm
_IX_#ifndef makefile directive[;ifndef makefile directive]">
 </A>
<A NAME="TTools_15.htm
_IX_#ifdef makefile directive[;ifdef makefile directive]">
 </A>
In addition to the bare #if, there are other forms that apply one of the first two functions to each term. They are as follows:</P>
<PRE>ifdef		defined
ifndef		!defined
ifmake		make
ifnmake		!make</PRE>
<P>
There are also the &quot;else if&quot; forms: elif, elifdef, elifndef, elifmake, and elifnmake.</P>

<HR>
<A NAME="TTools_16.htm
"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Using Tools</A>: 13.6 <A HREF="#TTools_10.htm">pmake</A>: 
The Way Things Work</H3>
<P>
When <CODE>
pmake</CODE>
 reads the makefile, it parses sources and targets into nodes in a graph. The graph is directed only in the sense that <CODE>
pmake</CODE>
 knows which way is up. Each node contains not only links to all its parents and children (the nodes that depend on it and those on which it depends, respectively), but also a count of the number of its children that have already been processed.</P>
<P>
The most important thing to know about how <CODE>
pmake</CODE>
 uses this graph is that the traversal is breadth-first and occurs in two passes.</P>
<P>
After <CODE>
pmake</CODE>
 has parsed the makefile, it begins with the nodes the user has told it to make (either on the command line, or via a .MAIN target, or by the target being the first in the file not labeled with the .NOTMAIN attribute) placed in a queue. It continues to take the node off the front of the queue, mark it as something that needs to be made, pass the node to Suff_FindDeps() (mentioned earlier) to find any implicit sources for the node, and place all the node's children that have yet to be marked at the end of the queue. If any of the children is a .USE rule, its attributes are applied to the parent, then its commands are appended to the parent's list of commands and its children are linked to its parent. The parent's unmade-children counter is then decremented (since the .USE node has been processed). This allows a .USE node to have children that are .USE nodes, and the rules will be applied in sequence. If the node has no children, it is placed at the end of another queue to be examined in the second pass. This process continues until the first queue is empty.</P>
<P>
At this point, all the leaves of the graph are in the examination queue; <CODE>
pmake</CODE>
 removes the node at the head of the queue and sees if it is out-of-date. If it is, it is passed to a function that will execute the commands for the node asynchronously. When the commands have completed, all the node's parents have their unmade-children counter decremented and, if the counter is then zero, they are placed on the examination queue. Only those parents that were marked on the downward pass are processed in this way. Thus <CODE>
pmake</CODE>
 traverses the graph back up to the nodes the user instructed it to create. When the examination queue is empty and no shells are running to create a target, <CODE>
pmake</CODE>
 is finished.</P>
<P>
Once all targets have been processed, <CODE>
pmake</CODE>
 executes the commands attached to the .END target, either explicitly or through the use of an ellipsis in a shell script. If there were no errors during the entire process but there are still some targets unmade (<CODE>
pmake</CODE>
 keeps a running count of how many targets are left to be made), there is a cycle in the graph. The <CODE>
pmake</CODE>
 program does a depth-first traversal of the graph to find all the targets that weren't made and prints them out one by one.</P>
<HR>
<A NAME="TTools_17.htm
"></A>


<H2 CLASS="sectionTitle">
<A HREF="#index.htm">Using Tools</A>: 14 
Swat Stub</H2>
<P>
The swat stub runs on the target machine, passing information between a running GEOS session and Swat on the host machine. It has one flag:</P>
<DL>
<DT>
<STRONG>
/H</STRONG>
:<STRONG>
hardware</STRONG>
	</DT><DD>
Specify special hardware for sending signals. The only possible argument is <STRONG>
P</STRONG>
 for sending via a serial port in a PCMCIA card.</DD>
</DL>
<HR>
<A NAME="dumpgeo.htm
"></A>
<H2 CLASS="sectionTitle">
<A HREF="#index.htm">Using Tools</A>: 15
dumpgeo</H2>



Use <CODE>dumpgeo</CODE> to display core information about the content of a .GEO file.
<P>
<EM>Common usage</EM>
<PRE>
	dumpgeo mygeode.geo
</PRE>
<P>
<CODE>dumpgeo</CODE> takes the following optional flags:

<DL>
<DT><STRONG>
-t </STRONG>
	<DD>Will also print brief information about the library and resource tables in the geode.
<DT><STRONG>
-r[id] </STRONG>
	<DD>Prints detailed relocation tables.
<DT><STRONG>
-d[id] </STRONG>
	<DD>Prints a binary dump of the resources in the geode.
</DL>


<HR>
<A NAME="cvtpcx.htm
"></A>
<H2 CLASS="sectionTitle">
<A HREF="#index.htm">Using Tools</A>: 16 
cvtpcx</H2>
<P>

<CODE> cvtpcx.exe</CODE> is an application that converts PCX graphics files to the GEOS icon format, either as a .ui or a .goh file.  There are two kinds of possible conversions. The PCX file may be converted to a single icon resource. Or the PCX file may contain the same icon image in a variety of different formats arranged in a predefined grid arrangement. The cvtpcx utility will convert each of these formats into its own icon resource within a single .goh or .ui file. For more information, refer to the bottom of this document. 
<P>
The source PCX file may have at most a 16-color (4 bit) color lookup table. Use a program like Paint Shop Pro to reduce the number of colors to 2-16 colors and save it in PCX format.
<P>
The syntax for <CODE>cvtpcx</CODE> is
<PRE class = "syntax">
     cvtpcx &lt<EM>options</EM>&gt &lt<EM>filename</EM>&gt 
</PRE>

If no &lt<EM>options</EM>&gt are specified, then this utility will convert the PCX file &lt<EM>filename</EM>&gt to single GEOS icon in a file called &quot;mkr.ui&quot; and display information about the icon. 
<P>
<HR>
<P>
<H4>&lt<EM>options</EM>&gt for either single icons or icons in a grid</H4>
These options specify the parameters for converting and saving the icon file.
<P>

<DL>
<DT><STRONG>         -o&lt<EM>filename</EM>&gt         </STRONG>
<DD> The file name for the moniker(s). 
<DT><STRONG>    -G</STRONG>
<DD> Produce .goh output instead of .ui.
<DT><STRONG>     -g </STRONG>
<DD> Do not put resulting bitmaps in gstrings. The bitmap
                        is still in a chunk, but no gstring opcodes surround it.
<DT><STRONG>     -j </STRONG>
<DD> Only output the gstring (don't create a moniker or
                        put the gstring in a chunk)
<DT><STRONG>     -2</STRONG>
<DD> Use 2.0 constants in the resulting gstring/bitmap.
<DT><STRONG>     -f </STRONG>
<DD> Uses GrFillBitmap instead of GrDrawBitmap for all
                        monochrome bitmaps.  Also implies the use of 2.0
                        constants, since this will not work prior to
                        version 2.0 as GrFillBitmap didn't exist.
<DT><STRONG>     -t </STRONG>
<DD> Cause the bitmap to be drawn relative to the
                        current pen position if the program decides to
                        optimize the moniker by drawing the bitmap somewhere
                        other than 0,0. All monikers destined for the
                        token database should be created with this flag.
<DT><STRONG> -m&lt<EM>pixel</EM>&gt           </STRONG>
<DD> Pixel to be masked out. Any pixel containing the color &lt<EM>pixel</EM>&gt  (a decimal number) will be given a 0 bit in the mask for the color bitmap. Defaults to none.
<DT><STRONG>     -u </STRONG>
<DD> Insist the resulting bitmaps remain uncompacted. By
                        default, cvtpcx will determine if it's worthwhile and
                        automatically compact each bitmap for you.
</DL>


<P>
<H4>Converting single icons:</H4>
A rectangle of the PCX image plane is converted into a single GEOS icon. The resulting file will have no start/end resource directives. The possible options include:
<P>

<DL>
<DT><STRONG> -n&lt<EM>filename</EM>&gt </STRONG>
<DD> Name the moniker &quot;&lt<EM>filename</EM>&gtMoniker&quot;
<DT><STRONG> -N </STRONG>
<DD> map the colors to the indices for the Nokia device.
<DT><STRONG> -w &lt<EM>width</EM>&gt </STRONG>
<DD> width to make GEOS icon bitmap. The input will be trimmed
                        or extended (but masked) as necessary to accommodate
                        this. Defaults to Standard size (48)
<DT><STRONG> -h&lt<EM>height</EM>&gt </STRONG>
<DD> height to make GEOS icon bitmap. The input will be trimmed
                        or extended (masked) as necessary to accommodate
                        this. Defaults to Standard size (30)
<DT><STRONG> -S&lt<EM>style</EM>&gt </STRONG>
<DD> &lt<EM>style</EM>&gt is one of the defined moniker styles: text,
                        abbrevText, graphicText, icon, or tool. It defaults to
                        icon. (The &quot;-S&quot; option is only for 2.0 and above.)
<DT><STRONG> -s&lt<EM>size</EM>&gt </STRONG>
<DD> &lt<EM>size</EM>&gt is one of the defined moniker sizes: large,
                        standard, or tiny. It defaults to standard.
<DT><STRONG> -a&lt<EM>aspect</EM>&gt </STRONG>
<DD>&lt<EM>aspect</EM>&gt is one of the defined aspectRatio values:
                        normal (vga), squished (ega) or verySquished (cga).
                        Defaults to squished.
<DT><STRONG> -b&lt<EM>aspect</EM>&gt </STRONG>
<DD> Forces creation of a single bitplane (B&W) icon,
                        even if the source is 16 colors. Any pixel that isn't
                        black (pixel 0) is set to 0 in the resulting bitmap.
                        Black pixels are, of course, set to 1.
<DT><STRONG> -B </STRONG>
<DD> Similar to <STRONG>-b</STRONG>, but any pixel that isn't white (pixel 15)
                        or the mask (set by &quot;-m&quot;) is set to 1.
</DL>


<P>


<H4>Icons in a grid:</H4>
A grid is a sequence of the same icon in a variety of formats which are laid out from the left to the right. These formats share a common top edge, have a one pixel margin between icons, and a one pixel margin around the grid as a whole. There are 11 formats and three predefined grids.

<P>
The 11 predefined icon formats are:
<TABLE WIDTH = "100%" BORDER = 3>
<TR>
<TD>Abbr</TD>
<TD>Color</TD>
<TD>Aspect</TD>
<TD>Size</TD>
<TD>Style</TD>
<TD>Width</TD>
<TD>Height</TD>
</TR>
<TR>
<TD> LC </TD>
<TD>4-bit </TD>
<TD> normal </TD>
<TD> large </TD>
<TD> icon </TD>
<TD>64 </TD>
<TD>40 </TD>
</TR>
<TR>
<TD> LM </TD>
<TD> Mono </TD>
<TD> normal </TD>
<TD> large </TD>
<TD> icon </TD>
<TD>64 </TD>
<TD>40 </TD>
</TR>
<TR>
<TD> SC </TD>
<TD> 4-bit </TD>
<TD> normal </TD>
<TD> standard </TD>
<TD> icon </TD>
<TD>48 </TD>
<TD>30 </TD>
</TR>
<TR>
<TD> SM </TD>
<TD> mono </TD>
<TD> normal </TD>
<TD> standard </TD>
<TD> icon </TD>
<TD>48 </TD>
<TD>30 </TD>
</TR>
<TR>
<TD> LCGA </TD>
<TD> Mono </TD>
<TD> verySquished </TD>
<TD> large </TD>
<TD> icon </TD>
<TD>64 </TD>
<TD>18 </TD>
</TR>
<TR>
<TD> SCGA </TD>
<TD> Mono </TD>
<TD> verySquished </TD>
<TD> tiny </TD>
<TD> icon </TD>
<TD>48 </TD>
<TD>14 </TD>
</TR>
<TR>
<TD> YC </TD>
<TD> 4-bit </TD>
<TD> normal </TD>
<TD> tiny </TD>
<TD> icon </TD>
<TD>32 </TD>
<TD>20 </TD>
</TR>
<TR>
<TD> YM </TD>
<TD> Mono </TD>
<TD> normal </TD>
<TD> tiny </TD>
<TD> icon </TD>
<TD>32 </TD>
<TD>20 </TD>
</TR>
<TR>
<TD> TC </TD>
<TD> 4-bit </TD>
<TD> normal </TD>
<TD> tiny </TD>
<TD> tool </TD>
<TD>15 </TD>
<TD>15 </TD>
</TR>
<TR>
<TD> TM </TD>
<TD> Mono </TD>
<TD> normal </TD>
<TD> tiny </TD>
<TD> tool </TD>
<TD>15 </TD>
<TD>15 </TD>
</TR>
<TR>
<TD> TCGA </TD>
<TD> Mono </TD>
<TD> verySquished </TD>
<TD> tiny </TD>
<TD> tool </TD>
<TD>15 </TD>
<TD>10 </TD>
</TR>
</TABLE>
<P>

The three grid layouts are:

<P>
<TABLE WIDTH = "100%" BORDER  = 3>
<TR>
<TD>Grid Flag</TD>
<TD>Formats within Grid</TD>
</TR>
<TR>
<TD> <STRONG> -l </STRONG> </TD>
<TD> LC, LM, SC, SM, LCGA, SCGA </TD>
</TR>
<TR>
<TD><STRONG> -L </STRONG> </TD>
<TD> LC, LM, SC, SM, LCGA, SCGA, YC, YM, TM, TCGA
            (the YC and YM icons are used for application icons on
            handheld devices, while the TM and TCGA icons are used
            for the Presentation Manager system menu)</TD>
</TR>
<TR>
<TD><STRONG> -z </STRONG> </TD>
<TD> TC, TM, TCGA</TD>
</TR>
 </TABLE>
<P>

When the cvtpcx utility converts a grid to a GEOS icon resource file, it creates one file which contains a series of monikers which correspond to the formats in the grid. For example, a PCX file which is a  <STRONG>-l</STRONG> grid will be converted to a GEOS header file which has a moniker with a LC format, followed by a moniker in a LM format, followed by a moniker in a SC format... etc. Each moniker is created with its own start/end resource directives.
<P>
The following options modify where in the PCX image plane the grid starts, how to name the monikers, which formats to not use, and how the GEOS file will be created.
<P>

  <DL>
<DT><STRONG> -x&lt<EM>xoffset</EM>&gt           </STRONG>
<DD> Specifies the left edge of the grid in the PCX image plane (the X coordinate of the 1-pixel margin to the left of the left-most icon in the grid.)
<DT><STRONG> -y&lt<EM>yoffset</EM>&gt           </STRONG>
<DD> Specifies the top edge of the grid (the Y coordinate of the 1-pixel margin to the top of the top-
                        most icon in the grid.)
<DT><STRONG> -n&lt<EM>moniker name</EM>&gt           </STRONG>
<DD> Allows specifying the core name to give the moniker.
                        The name for each moniker in a grid is formed as: <BR>
		<CODE>&lt<EM>moniker name</EM>&gt&lt<EM>format 
		abbrev</EM>&gtMoniker</CODE>
<BR>
For instance <CODE>-nHello</CODE> would create &quot;HelloLCMoniker&quot;
                        for the leftmost icon in the &quot;-l&quot; grid.
<DT><STRONG> -d&lt<EM>format(s)</EM>&gt           </STRONG>
<DD> This flag indicates that the no moniker for the formats in the comma-separated list &lt<EM>format(s)</EM>&gt should be created for that grid.
<DT><STRONG> -r&lt<EM>resource</EM>&gt            </STRONG>
<DD> Specifies the string (other than the default &quot;App&quot;)
                        to begin the name of each resource. The resource
                        names are of the form<BR>
<CODE>&lt<EM>resource</EM>&gt&lt<EM>format abbrev</EM>&gtMonikerResource</CODE>.<BR>
The resource name is all uppercase for GOC output.
<DT><STRONG> -R</STRONG>
<DD> Don't put out resource start/end directives; just produce the monikers, one after another.
</DL>





<HR>



<P>
Examples of cvtpcx:
<P>
The following converts the single icon &quot;old_icon.pcx&quot; to a .goh icon called &quot;test.goh.&quot; The options for this icon specify that this icon  uses GEOS 2.0 constants, is defined with <CODE>GrFillBitmap()</CODE>, uses Nokia colors, and will be drawn relative to the pen's location.
<PRE>
         cvtpcx -2 -f -t -N -G -otest.goh old_icon.pcx
</PRE>

The following converts the grid &quot;grid_icon.pcx&quot; in the <STRONG>-l</STRONG> grid arrangement into a .goh file with monikers for all the formats in a <STRONG>-l</STRONG> grid, with the exception of the LC format. The &quot;<STRONG>-m11</STRONG>&quot; option specifies that yellow pixels (those with the color 11) will be masked out. The output has the name &quot;mkrconverted_grid_icon.goh&quot;.
<PRE>
        cvtpcx -l -2 -f -t -g -G -dLC -m11 -nconverted_grid_icon grid_icon.pcx
</PRE>




<HR>
<A NAME="pvm.htm
"></A>
<H2 CLASS="sectionTitle">
<A HREF="#index.htm">Using Tools</A>: 17 
pvm</H2>
This document is a single-page version of a <A HREF="index.htm">a multi-page document</A>, suitable for easy printing.
</BODY>
</HTML>
