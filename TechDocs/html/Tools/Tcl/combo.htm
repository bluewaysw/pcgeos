<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD>
<!-- This page was automatically generated from a bunch of smaller pages. -->
<META NAME="copyright" CONTENT="Copyright GEOWORKS">
<LINK REL="STYLESHEET" HREF="../../docHelpers/style.css">
<LINK REV="MADE" HREF="mailto:doc-feedback@geoworks.com">
<TITLE>Tool Command Language</TITLE>
</HEAD>
<BODY BGCOLOR="#ffffdf">
This document is a single-page version of a <A HREF="index.htm">a multi-page document</A>, suitable for easy printing.
<A NAME="index.htm"></A>



<H1 CLASS="chapterTitle">

<A NAME="index.htm_97933">
 </A>
Tool Command Language

</H1>

<P>
<A NAME="index.htm_IX_Swat:Tcl (Tool Command Language)">
 </A>
This chapter is designed to provide information about the Tool Command Language, abbreviated Tcl, (the language in which Swat commands are written) so that new commands can be written and old commands modified. This chapter contains the following main sections:</P>
<UL>
<LI>
Using This Chapter<BR>
Discussion of the situations warranting the construction of a new command in the Tool Command Language.</LI>
<LI>
Background and Description<BR>
Discussion of history of Tool Command Language and general overview of the language.</LI>
<LI>
Syntax and Structure<BR>
Description of the syntax and structure of the Tool Command Language.</LI>
<LI>
Commands<BR>
List of all built-in commands for the language.</LI>
<LI>
Coding<BR>
Descriptions and examples of coding conventions, techniques, and tricks.</LI>
<LI>
Installation<BR>
Steps to take in order to be able to use a newly written command to help debug an application.</LI>
</UL>

<P>
<STRONG>
&nbsp;&nbsp;<A HREF="#TTCL_1.htm">1 Using This Chapter</A><BR>
&nbsp;&nbsp;<A HREF="#TTCL_2.htm">2 Copyright Information</A><BR>
&nbsp;&nbsp;<A HREF="#TTCL_3.htm">3 Background and Description</A><BR>
&nbsp;&nbsp;<A HREF="#TTCL_4.htm">4 Syntax and Structure</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#TTCL_5.htm">4.1 Basic Command Syntax</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#TTCL_6.htm">4.2 Expressions</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#TTCL_7.htm">4.3 Lists</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#TTCL_8.htm">4.4 Command Results</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#TTCL_9.htm">4.5 Procedures</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#TTCL_a.htm">4.6 Variables</A><BR>
&nbsp;&nbsp;<A HREF="#TTCL_b.htm">5 Commands</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#TTCL_c.htm">5.1 Notation</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#TTCL_d.htm">5.2 Built-in Commands</A><BR>
&nbsp;&nbsp;<A HREF="#TTCL_e.htm">6 Coding</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#TTCL_f.htm">6.1 Swat Data Structure Commands</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#TTCL_10.htm">6.2 Examples</A><BR>
&nbsp;&nbsp;<A HREF="#TTCL_11.htm">7 Using a New Command</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#TTCL_12.htm">7.1 Compilation</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#TTCL_13.htm">7.2 Autoloading</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#TTCL_14.htm">7.3 Explicit Loading</A><BR>
</STRONG>
</P> <!-- end of sectionlinks blob -->

<HR>
<A NAME="TTCL_1.htm"></A>


<H2 CLASS="sectionTitle">
<A HREF="#index.htm">Tool Command Language</A>: 1 
Using This Chapter</H2>
<P>
This chapter provides the information needed to write a new Swat command in Tcl. But, new commands need only be written in certain situations. Some of the situations in which it is advantageous to write a new Swat command in Tcl are:</P>
<UL>
<LI>
There is complex task that is being repeated often. For example, if one is continually examining a certain piece of data in memory but has to go through many steps to do so, then it is helpful to write a single command to perform all of the needed steps.</LI>
<LI>
When a new data-structure is created for an application. For example, if one creates a look-up table for the application, then a Tcl command should be written to examine that table in particular.</LI>
</UL>
<P>
The existing Swat commands should take care of the bulk of debugging, but sometimes an extra command can help.</P>
<HR>
<A NAME="TTCL_2.htm"></A>


<H2 CLASS="sectionTitle">
<A HREF="#index.htm">Tool Command Language</A>: 2 
Copyright Information</H2>
<P>
<A NAME="TTCL_2.htm_IX_Tcl:copyright information">
 </A>
The following sections of this chapter fall under the copyright below: Background and Description, Syntax and Structure, and Commands.</P>
<P>
Copyright &#169; 1987 Regents of the University of California</P>
<P>
Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies. The University of California makes no representations about the suitability of this software for any purpose. It is provided &quot;as is&quot; without express or implied warranty.</P>
<HR>
<A NAME="TTCL_3.htm"></A>


<H2 CLASS="sectionTitle">
<A HREF="#index.htm">Tool Command Language</A>: 3 
Background and Description</H2>
<P>
The Tool Command Language is abbreviated as Tcl and is pronounced &quot;tickle&quot;. It was developed and written by Professor John Ousterhout at the University of California at Berkeley. Tcl is a combination of two main parts: a language and a library.</P>
<DL>
<DT>
<STRONG>
Language</STRONG>
</DT><DD>The Tcl language is a textual language intended primarily for issuing commands to interactive programs such as text editors, illustrators, shells, and most importantly debuggers. It has a set syntax and is programmable, thus allowing users to create more powerful commands than the built-in command set listed in <A HREF="../../Tools/SwatRef/index.htm">the Swat Command Reference</A>.</DD>
<DT>
<STRONG>
Library</STRONG>
</DT><DD>Tcl also includes a library which can be imbedded in an application, as it is in Swat. This library includes a parser for the Tcl language, routines to implement the Tcl built-in commands, and procedures allowing an application to extend Tcl with additional commands.</DD>
</DL>
<HR>
<A NAME="TTCL_4.htm"></A>


<H2 CLASS="sectionTitle">
<A HREF="#index.htm">Tool Command Language</A>: 4 
Syntax and Structure</H2>
<P>
<A NAME="TTCL_4.htm_IX_Tcl:syntax">
 </A>
Tcl supports only one type of data: <EM>
strings</EM>
. All commands, all arguments to commands, all command results, and all variable values are strings. Where commands require numeric arguments or return numeric results, the arguments and results are passed as strings. Many commands expect their string arguments to have certain formats, but this interpretation is up to the individual commands. For example, arguments often contain Tcl command strings, which may get executed as part of the commands. The easiest way to understand the Tcl interpreter is to remember that everything is just an operation on a string. In many cases Tcl constructs will look similar to more structured constructs from other languages. However, the Tcl constructs are not structured at all; they are just strings of characters, and this gives them a different behavior than the structures they may look like.</P>
<P>
Although the exact interpretation of a Tcl string depends on who is doing the interpretation, there are three common forms that strings take: <EM>
commands</EM>
, <EM>
expressions</EM>
, and <EM>
lists</EM>
. This section will have the following main parts:</P>
<UL>
<LI>
Basic Command Syntax<BR>
Description of the syntax common to all Tcl code: comments, argument grouping, command grouping, variable substitution, backslash substitution.</LI>
<LI>
Expressions<BR>
Details on interpretation of expressions by Tcl.</LI>
<LI>
Lists<BR>
Details on interpretation of lists by Tcl.</LI>
<LI>
Command Results<BR>
What type of results a command can return.</LI>
<LI>
Procedures<BR>
The structure and building of procedures in Tcl.</LI>
<LI>
Variables<BR>
Variable declaration and description.</LI>
</UL>
<P CLASS="subsectionLink">
<A HREF="#TTCL_5.htm">Basic Command Syntax</A></P>
<P CLASS="subsectionLink">
<A HREF="#TTCL_6.htm">Expressions</A></P>
<P CLASS="subsectionLink">
<A HREF="#TTCL_7.htm">Lists</A></P>
<P CLASS="subsectionLink">
<A HREF="#TTCL_8.htm">Command Results</A></P>
<P CLASS="subsectionLink">
<A HREF="#TTCL_9.htm">Procedures</A></P>
<P CLASS="subsectionLink">
<A HREF="#TTCL_a.htm">Variables</A></P>
<HR>
<A NAME="TTCL_5.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Tool Command Language</A>: 4.1 <A HREF="#TTCL_4.htm">Syntax and Structure</A>: 
Basic Command Syntax</H3>
<P>
The Tcl language has syntactic similarities to both Unix and Lisp. However, the interpretation of commands is different in Tcl than in either of those other two systems. A Tcl command string consists of one or more commands separated by newline characters. Each command consists of a collection of fields separated by white space (spaces or tabs). The first field must be the name of a command, and the additional fields, if any, are arguments that will be passed to that command. For example, the command:</P>
<PRE>var a 22</PRE>
<P>
has three fields: the first, <CODE>
var</CODE>
, is the name of a Tcl command, and the last two, <CODE>
a</CODE>
 and <CODE>
22</CODE>
, will be passed as arguments to the <CODE>
var</CODE>
 command. The command name may refer to a built-in Tcl command, an application specific command, or a command procedure defined with the built-in <CODE>
proc</CODE>
 command. Arguments are passed literally as text strings. Individual commands may interpret those strings in any fashion they wish. The <CODE>
var </CODE>
command, for example, will treat its first argument as the name of a variable and its second argument as a string value to assign to that variable. For other commands, arguments may be interpreted as integers, lists, file names, or Tcl commands.</P>

<H4 CLASS="HeadingC">
Comments</H4>
<P>
<A NAME="TTCL_5.htm_IX_Comments:in Tcl code">
 </A>
<A NAME="TTCL_5.htm_IX_Tcl:comments">
 </A>
If the first non-blank character in a command is <CODE>
#</CODE>
 (a number sign), then everything from the # up through the next newline character is treated as comment and discarded by the parser.</P>


<H4 CLASS="HeadingC">
Argument Grouping</H4>
<P>
Normally each argument field ends at the next white space (tabs or spaces), but curly braces (&quot;{&quot; and &quot;}&quot;) may be used to group arguments in different ways. If an argument field begins with a left brace, then the argument is not terminated by white space; it ends at the matching right brace. Tcl will strip off the outermost layer of braces before passing the argument to the command. For example, in the command:</P>
<PRE>var a {b c}</PRE>
<P>
the <CODE>
var</CODE>
 command will receive two arguments: <CODE>
a</CODE>
 and<CODE>
 b  c</CODE>
. The matching right brace need not be on the same line as the left brace; in this case the newline will be included in the argument field along with any other characters up to the matching right brace. In many cases an argument field to one command consists of a Tcl command string that will be executed later; braces allow complex command structures to be built up without confusion. For example, the <CODE>
eval</CODE>
 command takes one argument, which is a command string; <CODE>
eval</CODE>
 invokes the Tcl interpreter to execute the command string. The command:</P>
<PRE>eval {
       var a 22
       var b 33
}</PRE>
<P>
will assign the value 22 to <CODE>
a</CODE>
 and 33 to <CODE>
b</CODE>
.</P>
<P>
Tcl braces act like quote characters in most other languages, in that they prevent any special interpretation of the characters between the left brace and the matching right brace.</P>
<P>
When an argument is in braces, then command, variable, and backslash substitutions do not occur in the normal fashion; all Tcl does is to strip off the outer layer of braces and pass the contents to the command. Braces are only significant in a command field if the first character of the field is a left brace. Otherwise neither left nor right braces in the field will be treated specially (except as part of variable substitution).</P>


<H4 CLASS="HeadingC">
Command Grouping</H4>
<P>
Normally, each command occupies one line (the command is terminated by a newline character). Thus, the string:</P>
<PRE>var a 22
var b 33</PRE>
<P>
will be interpreted as two separate commands. However, brackets may be used to group commands in ways other than one-command-per-line. If the first character of a command is an open bracket, then the command is not terminated by a newline character; instead, it consists of all the characters up to the matching close bracket. Newline characters inside a bracketed command are treated as white space (they will act as argument separators for arguments that are not enclosed in braces). For example, the string:</P>
<PRE>[var a
22] [var b 33]</PRE>
<P>
will have the same effect as the previous example.</P>


<H4 CLASS="HeadingC">
Command Substitution</H4>
<P>
If an open bracket occurs in any of the fields of a command, then command substitution occurs. All of the text up to the matching close bracket is treated as a Tcl command and executed immediately. The result of that command is substituted for the bracketed text. For example, consider the command:</P>
<PRE>var a [var b]</PRE>
<P>
When the <CODE>
var</CODE>
 command has only a single argument, it is the name of a variable and <CODE>
var</CODE>
 returns the contents of that variable. In this case, if variable <CODE>
b</CODE>
 has the value <CODE>
test</CODE>
, then the command above is equivalent to the command:</P>
<PRE>var a test</PRE>
<P>
Brackets can be used in more complex ways. for example, if the variable<CODE>
 b</CODE>
 has the value <CODE>
tmp</CODE>
 and the variable <CODE>
c</CODE>
 has the value <CODE>
val</CODE>
, then the command:</P>
<PRE>var a test[var b].[var c]</PRE>
<P>
is equivalent to the command:</P>
<PRE>var a testtmp.val</PRE>
<P>
If a field is enclosed in braces then the brackets and the characters between them are not interpreted specially; they are passed through to the argument verbatim.</P>


<H4 CLASS="HeadingC">
Variable Substitution</H4>
<P>
<A NAME="TTCL_5.htm_IX_Dollar sign:in Tcl">
 </A>
<A NAME="TTCL_5.htm_IX_$:in Tcl">
 </A>
The dollar sign ($) may be used as a special shorthand form for substituting variables. If $ appears in an argument that is not enclosed in braces then variable substitution will occur. The characters after the $, up to the first character that is not a number, letter, or underscore, are taken as a variable name and the string value of that variable is substituted for the name. Or, if the dollar sign is followed by an open curly brace, then the variable name consists of all the characters up to the next close curly brace. For example, if variable <CODE>
outfile</CODE>
 has the value <CODE>
test</CODE>
, then the command:</P>
<PRE>var a $outfile.c</PRE>
<P>
is equivalent to the command:</P>
<PRE>var a test.c</PRE>
<P>
 and the command:</P>
<PRE>var a abc${outfile}tmp</PRE>
<P>
is equivalent to the command:</P>
<PRE>var a abctesttmp</PRE>
<P>
Variable substitution does not occur in arguments that are enclosed in braces: the dollar sign and variable name are passed through to the argument verbatim.</P>
<P>
The dollar sign abbreviation is simply a shorthand form. <CODE>
$a</CODE>
 is completely equivalent to<CODE>
 [var a]</CODE>
; it is provided as a convenience to reduce typing.</P>


<H4 CLASS="HeadingC">
Backslash Substitution</H4>
<P>
<A NAME="TTCL_5.htm_IX_\ backslash substitution:in Tcl[;backslash substitution]">
 </A>
Backslashes may be used to insert non-printing characters into command fields and also to insert braces, brackets, and dollar signs into fields without them being interpreted specially as previously described. The backslash sequences understood by the Tcl interpreter are listed below. In each case, the backslash sequence is replaced by the given character.</P>
<P>
For example, in the command:</P>
<PRE>var a \{x\[\ yz\141</PRE>
<P>
the second argument to <CODE>
var</CODE>
 is <CODE>
{x[   yza</CODE>
 (note the &lt;space&gt; as part of the argument).</P>
<P>
If a backslash is followed by something other than one of the options listed below, then the backslash is transmitted to the argument field without any special processing, and the Tcl scanner continues normal processing with the next character. For example, in the command:</P>
<PRE>var \*a \\\{test</PRE>
<P>
the first argument will be <CODE>
\*a</CODE>
 and the second <CODE>
\{test</CODE>
.
<IMG SRC="BackslashSequences.gif">

</P>
<P>
If an argument is enclosed in braces, then backslash sequences inside the argument are parsed but no substitution occurs. In particular, backslashed braces are not counted in locating the matching right brace that terminates the argument. for example, in the command:</P>
<PRE>var a {\{abc}</PRE>
<P>
the second argument to var will be <CODE>
\{abc</CODE>
.</P>
<P>
The backslash mechanism is not sufficient to generate any argument structure; it only covers the most common cases. To produce particularly complicated arguments it will probably be easiest to use the <CODE>
format</CODE>
 command along with command substitution.</P>

<HR>
<A NAME="TTCL_6.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Tool Command Language</A>: 4.2 <A HREF="#TTCL_4.htm">Syntax and Structure</A>: 
Expressions</H3>
<P>
The second major interpretation applied to strings in Tcl is as <EM>
expressions</EM>
. Several commands, such as <CODE>
expr</CODE>
, <CODE>
for</CODE>
, and <CODE>
if</CODE>
, treat some of their arguments as expressions and call the Tcl expression processor (Tcl_Expr) to evaluate them. A Tcl expression has C-like syntax and evaluates to an integer result. Expressions may contain integer values, variable names in $ notation (the variables' values must be integer strings), commands (embedded in brackets) that produce integer string results, parentheses for grouping, and operators. Numeric values, whether they are passed directly or through variable or command substitution, may be specified either in decimal (the normal case), in octal (if the first character of the value of the first character is 0 (zero)), or in hexadecimal (if the first two characters of the value are 0x). The valid operators are listed below, grouped in decreasing order of precedence.<BR>
<IMG SRC="ValidOperators.gif">

</P>
<P>
See a C manual for more details on the results produced by each operator. All of the binary operators group left to right within the same precedence level. for example, the expression:</P>
<PRE>(4*2)&lt;7</PRE>
<P>
evaluates to zero. Evaluating the expression string:</P>
<PRE>($a+3)&lt;[var b]</PRE>
<P>
will cause the values of the variables<CODE>
 a</CODE>
 and <CODE>
b</CODE>
 to be examined; the result will be 1 if<CODE>
 b</CODE>
 is greater than <CODE>
a</CODE>
 by at least 3; otherwise the result will be 0.</P>
<P>
In general it is safest to enclose an expression in braces when entering it in a command; otherwise, if the expression contains any white space then the Tcl interpreter will split it among several arguments. For example, the command:</P>
<PRE>expr $a + $b</PRE>
<P>
results in three arguments being passed to <CODE>
expr</CODE>
: <CODE>
$a</CODE>
, <CODE>
+</CODE>
, and <CODE>
$b</CODE>
. In addition, if the expression is not in braces then the Tcl interpreter will perform variable and command substitution immediately (it will happen in the command parser rather than in the expression parser). In many cases the expression is being passed to a command that will evaluate the expression later (or even many times if, for example, the expression is to be used to decide when to exit a loop). usually the desired goal is to re-do the variable or command substitutions each time the expression is evaluated, rather than once and for all at the beginning. For an example of a mistake, the command:</P>
<PRE>for {var i 1} $i&lt;=10 {var i [expr $i+1]} {body...}</PRE>
<P>
is probably intended to iterate over all values of <CODE>
i</CODE>
 from 1 to 10. After each iteration of the body of the loop, for will pass its second argument to the expression evaluator to see whether or not to continue processing. Unfortunately, in this case the value of <CODE>
i</CODE>
 in the second argument will be substituted once and for all when the for command is parsed. If <CODE>
i</CODE>
 was 0 before the for command was invoked then <CODE>
for</CODE>
's second argument will be <CODE>
0&lt;=10</CODE>
 which will always evaluate to 1, even though<CODE>
 i</CODE>
's value eventually becomes greater than 10. In the above case the loop will never terminate. By placing the expression in braces, the substitution of <CODE>
i</CODE>
's value will be delayed; it will be re-done each time the expression is evaluated, which is probably the desired result:</P>
<PRE>for {var i 1} {$i&lt;=10} {var i [expr $i+1]} {body...}</PRE>
<HR>
<A NAME="TTCL_7.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Tool Command Language</A>: 4.3 <A HREF="#TTCL_4.htm">Syntax and Structure</A>: 
Lists</H3>
<P>
<A NAME="TTCL_7.htm_IX_Lists in Swat:Tcl syntax">
 </A>
The third major way that strings are interpreted in Tcl is a <EM>
list</EM>
. A list is just a string with a list-like structure consisting of fields separated by white space. For example, the string:</P>
<PRE>Al Sue Anne John</PRE>
<P>
is a list with four elements or fields. Lists have the same basic structure as command strings, except that a newline character in a list is treated as a field separator just like a space or tab. Conventions for braces and backslashes are the same for lists as for commands. For example, the string:</P>
<PRE>a b\ c {d e {f g h}}</PRE>
<P>
is a list with three elements: <CODE>
a</CODE>
,<CODE>
 b c</CODE>
, and <CODE>
d e {f g h}</CODE>
. Note the space between the <CODE>
b</CODE>
 and<CODE>
 c</CODE>
. Whenever an element is extracted from a list, the same rules about backslashes and braces are applied as for commands. Thus in the above example when the third element is extracted from the list, the result is:</P>
<PRE>d e {f g h}</PRE>
<P>
(when the field was extracted, all that happened was to strip off the outermost layer of braces). Command substitution is never made on a list (at least, not by the list-processing commands; the list can always be passed to the Tcl interpreter for evaluation).</P>
<P>
The Tcl commands <CODE>
concat</CODE>
, <CODE>
foreach</CODE>
, <CODE>
index</CODE>
, <CODE>
length</CODE>
, <CODE>
list</CODE>
, and <CODE>
range</CODE>
 allow you to build lists, extract elements from them, search them, and perform other list-related functions.</P>
<HR>
<A NAME="TTCL_8.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Tool Command Language</A>: 4.4 <A HREF="#TTCL_4.htm">Syntax and Structure</A>: 
Command Results</H3>
<P>
Each command produces two results: a <EM>
code</EM>
 and a <EM>
string</EM>
. The code indicates whether the command completed successfully or not, and the string gives additional information. The valid codes are defined as follows:</P>
<DL>
<DT>
TCL_OK</DT><DD>This is the normal return code, and indicates that the command completed successfully. The string gives the commands's return value.</DD>
<DT>
TCL_ERROR</DT><DD>
<A NAME="TTCL_8.htm_IX_Errors:Tcl errors">
 </A>
Indicates that an error occurred; the string gives a message describing the error.</DD>
<DT>
TCL_RETURN</DT><DD>
Indicates that the return command has been invoked, and that the current procedure should return immediately. The string gives the return value that procedure should return.</DD>
<DT>
TCL_BREAK</DT><DD>
Indicates that the break command has been invoked, so the innermost loop should abort immediately. The string should always be empty.</DD>
<DT>
TCL_CONTINUE</DT><DD>
Indicates that the continue command has been invoked, so the innermost loop should go on to the next iteration. The string should always be empty.</DD>
</DL>
<P>
Tcl programmers do not normally need to think about return codes, since TCL_OK is almost always returned. If anything else is returned by a command, then the Tcl interpreter immediately stops processing commands and returns to its caller. If there are several nested invocations of the Tcl interpreter in progress, then each nested command will usually return the error to its caller, until eventually the error is reported to the top-level application code. The application will then display the error message for the user.</P>
<P>
In a few cases, some commands will handle certain &quot;error&quot; conditions themselves and not return them upwards. For example, the <CODE>
for</CODE>
 command checks for the TCL_BREAK code; if it occurs, then <CODE>
for</CODE>
 stops executing the body of the loop and returns TCL_OK to its caller. The <CODE>
for</CODE>
 command also handles TCL_CONTINUE codes and the procedure interpreter handles TCL_RETURN codes. The <CODE>
catch</CODE>
 command allows Tcl programs to catch errors and handle them without aborting command interpretation any further.</P>
<HR>
<A NAME="TTCL_9.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Tool Command Language</A>: 4.5 <A HREF="#TTCL_4.htm">Syntax and Structure</A>: 
Procedures</H3>
<P>
Tcl allows one to extend the command interface by defining procedures. A Tcl procedure can be invoked just like any other Tcl command (it has a name and it receives one or more arguments). The only difference is that its body is not a piece of C code linked into the program; it is a string containing one or more other Tcl commands. See the <CODE>
proc</CODE>
 command for information on how to define procedures and what happens when they are invoked.</P>
<HR>
<A NAME="TTCL_a.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Tool Command Language</A>: 4.6 <A HREF="#TTCL_4.htm">Syntax and Structure</A>: 
Variables</H3>
<P>
Tcl allows the definition of variables and the use of their values either through $-style variable substitution, the <CODE>
var</CODE>
 command, or a few other mechanisms. Variables need not be declared: a new variable will automatically be created each time a new variable name is used. Variables may be either global or local. If a variable name is used when a procedure is not being executed, then it automatically refers to a global invocation of the procedure. Local variables are deleted whenever a procedure exits. The <CODE>
global</CODE>
 command may be used to request that a name refer to a global variable for the duration of the current procedure (somewhat analogous to <CODE>
extern</CODE>
 in C).</P>
<HR>
<A NAME="TTCL_b.htm"></A>


<H2 CLASS="sectionTitle">
<A HREF="#index.htm">Tool Command Language</A>: 5 
Commands</H2>
<P>
The Tcl library provides the following built-in commands, which will be available to any application using Tcl. In addition to these built-in commands, there may be additional commands defined in Swat, plus commands defined as Tcl procedures.</P>
<P CLASS="subsectionLink">
<A HREF="#TTCL_c.htm">Notation</A></P>
<P CLASS="subsectionLink">
<A HREF="#TTCL_d.htm">Built-in Commands</A></P>
<HR>
<A NAME="TTCL_c.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Tool Command Language</A>: 5.1 <A HREF="#TTCL_b.htm">Commands</A>: 
Notation</H3>
<P>
The descriptions of the Tcl commands will follow the following notational conventions:</P>
<UL>
<LI>
<CODE>
command (alternative1|alternative2|...|alternativeN)<BR>
()</CODE>
 The parentheses enclose a set of alternatives separated by a vertical line. For example, the expression <CODE>
quit (cont|leave)</CODE>
 means that either <CODE>
quit cont</CODE>
 or <CODE>
quit leave </CODE>
can be used.</LI>
<LI>
<CODE>
command [optional_argument]<BR>
[] </CODE>
The brackets enclose optional arguments to the command. For example, the command <CODE>
alias [&lt;word[&lt;command&gt;]&gt;]</CODE>
 could have zero, one, or two arguments because the &lt;<EM>command</EM>&gt; and &lt;<EM>word&gt;</EM> arguments are optional. Another example would be the command <CODE>
objwalk [&lt;addr&gt;]</CODE>
, which may take zero arguments if it is meant to use the default address, and one argument if the user gives it a particular address to look at.</LI>
<LI>
<CODE>
command &lt;type_of_argument&gt;<BR>
&lt; &gt;</CODE>
 The angled brackets enclose the type of an argument rather than the actual string to be typed. For example, <CODE>
&lt;addr&gt;</CODE>
 indicates an address expression and <CODE>
&lt;argument&gt;</CODE>
 indicates some sort of argument, but <CODE>
(addr|type)</CODE>
 means either the string <CODE>
addr</CODE>
 or the string <CODE>
type</CODE>
.</LI>
<LI>
<CODE>
*    +<BR>
</CODE>
An asterisk following any of the previous constructs indicates zero or more repetitions of the construct may be typed. An addition sign indicates one or more repetitions of the construct may be used. For example, <CODE>
unalias</CODE>
 <CODE>
word</CODE>
* can be the <CODE>
unalias</CODE>
 command by itself, or it can be followed by a list of words to be unaliased.</LI>
</UL>
<HR>
<A NAME="TTCL_d.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Tool Command Language</A>: 5.2 <A HREF="#TTCL_b.htm">Commands</A>: 
Built-in Commands</H3>
<P>
The built-in Tcl commands are as follows:</P>

<H4 CLASS="refHeading">
<A NAME="TTCL_d.htm_IX_bc Tcl command">
 </A>
bc</H4>
<PRE CLASS="syntax">bc list &lt;proc&gt;
bc disasm &lt;proc&gt;
bc compile &lt;proc&gt;
bc fcompile &lt;file&gt; [&lt;nohelp&gt;]
bc fload &lt;file&gt;
bc fdisasm &lt;file&gt;
bc debug [1|0]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;bc compile poof&quot;    </DT><DD>
Compiles the body of the procedure &quot;poof&quot; and replaces the existing procedure with its compiled form.</DD>
<DT>
&quot;bc fcomp bptutils.tcl&quot; </DT><DD>
Creates the file &quot;bptutils.tlc&quot; that contains a stream of compiled Tcl that will do exactly what sourcing bptutils.tcl does, except the resulting procedures will be compiled Tcl, not interpreted Tcl.</DD>
<DT>
&quot;bc fload bptutils.tlc&quot; </DT><DD>
Loads a file containing a stream of compiled Tcl code.</DD>
</DL>
<P>
The &quot;bc&quot; command allows you to create and examine compiled Tcl code. Compiled Tcl is not nearly as readable or changeable as interpreted Tcl code, but it's 30-50% faster.</P>

<P>
The &quot;list&quot; subcommand doesn't work. </P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/Tcl/TTCL_d.htm#IX_source Tcl command">source</A>.



<H4 CLASS="refHeading">
<A NAME="TTCL_d.htm_IX_break Tcl command">
 </A>
break</H4>
<PRE CLASS="syntax">break</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;break&quot;</DT><DD>Break out of the current loop.</DD>
</DL>
<P>
Breaks out of the current loop or the current nested interpreter.</P>

<UL>
<LI>
Only the closest-enclosing loop can be exited via this command. </LI>
<LI>
This command may be invoked only inside the body of a loop command such as <CODE>
for</CODE>
 or <CODE>
foreach</CODE>
. It returns a TCL_BREAK code to signal the innermost containing loop command to return immediately.</LI>
<LI>
If you've entered a nested interpreter, e.g. by calling a function in the patient, use this to exit the interpreter and restore the registers to what they were before you made the call.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/Tcl/TTCL_d.htm#IX_continue Tcl command">continue</A>,
<A HREF="../../Tools/Tcl/TTCL_d.htm#IX_for Tcl command">for</A>.



<H4 CLASS="refHeading">
<A NAME="TTCL_d.htm_IX_case Tcl command">
 </A>
case</H4>
<PRE CLASS="syntax">case &lt;string&gt; [in] [&lt;pat&gt; &lt;body&gt;]+</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;[case $c in</DT>
<DT>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{[0-9]} {</DT>
<DT>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# do something with digit</DT>
<DT>
&nbsp;&nbsp;&nbsp;}</DT>
<DT>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default {</DT>
<DT>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# do something with non-digit</DT>
<DT>
&nbsp;&nbsp;&nbsp;}</DT>
<DT>
&nbsp;&nbsp;]&quot; </DT><DD>
Do one of two things depending on whether the character in $c is a digit.</DD>
</DL>
<P>
Perform one of a set of actions based on whether a string matches one or more patterns.</P>

<UL>
<LI>
Compares each of the &lt;<EM>pattern</EM>&gt; arguments to the given &lt;<EM>string</EM>&gt;, executing &lt;<EM>body</EM>&gt; following the first &lt;<EM>pattern</EM>&gt; to match. &lt;<EM>pattern</EM>&gt; uses shell wildcard characters as for the string match command, but may also contain alternatives, which are separated by a vertical bar, thus allowing a &lt;<EM>body</EM>&gt; to be executed under one of several circumstances. In addition, if one &lt;<EM>pattern</EM>&gt; (or element thereof) is the string default, the associated &lt;<EM>body</EM>&gt; will be executed if none of the other patterns matches. For example, the following:</LI>
<PRE>[case $test in
 a|b {return 1}
 {default|[DE]a*} {return 0}
 ?c {return -1}]</PRE>
<P>
	will return 1 if variable <CODE>
test</CODE>
 contains <CODE>
a</CODE>
 or <CODE>
b</CODE>
, -1 if it contains a two-letter string whose second letter is <CODE>
c</CODE>
, and 0 in all other cases, including the ones where <CODE>
test</CODE>
's first two letters are either <CODE>
Da</CODE>
 or <CODE>
Ea</CODE>
.</P>
<LI>
Each &lt;pat&gt; argument is a list of patterns of the form described for the &quot;string match&quot; command. </LI>
<LI>
Each &lt;pat&gt; argument must be accompanied by a &lt;body&gt; to execute. </LI>
<LI>
If a &lt;pat&gt; contains the special pattern &quot;default,&quot; the associated &lt;body&gt; will be executed if no other pattern matches. The difference between &quot;default&quot; and &quot;*&quot; is a pattern of &quot;*&quot; causes the &lt;body&gt; to be executed regardless of the patterns in the remaining &lt;pat&gt; arguments, while &quot;default&quot; postpones the decision until all the remaining patterns have been checked.</LI>
<LI>
You can give the literal &quot;in&quot; argument if you wish to enhance the readability of your code.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/Tcl/TTCL_d.htm#IX_string Tcl command">string</A>,
<A HREF="../../Tools/Tcl/TTCL_d.htm#IX_if Tcl command">if</A>.



<H4 CLASS="refHeading">
<A NAME="TTCL_d.htm_IX_catch Tcl command">
 </A>
catch</H4>
<PRE CLASS="syntax">catch &lt;command&gt; [&lt;varName&gt;]</PRE>
<P>
Executes a command, retaining control even if the command generates an error (which would otherwise cause execution to unwind completely).</P>
<UL>
<LI>
The <CODE>
catch</CODE>
 command may be used to prevent errors from aborting command interpretation. <CODE>
catch</CODE>
 calls the Tcl interpreter recursively to execute &lt;<EM>command</EM>&gt;, and always returns a TCL_OK code, regardless of any errors that might occur while executing &lt;<EM>command</EM>&gt;. The return value from <CODE>
catch</CODE>
 is a decimal string giving the code returned by the Tcl interpreter after executing &lt;<EM>command</EM>&gt;. This will be zero (TCL_OK) if there were no errors in command; otherwise it will have a non-zero value corresponding to one of the exceptional return codes. If the &lt;<EM>varName</EM>&gt; argument is given, then it gives the name of a variable; <CODE>
catch</CODE>
 will set the value of the variable to the string returned from command (either a result or an error message).</LI>
<LI>
This returns an integer that indicates how &lt;command&gt; completed:</LI>
<DL>
<DT>
            <STRONG>
0</STRONG>
</DT><DD>Completed successfully; $&lt;varName&gt; contains the result of the command.</DD>
<DT>
           <STRONG>
 1</STRONG>
</DT><DD>Generated an error; $&lt;varName&gt; contains the error message.</DD>
<DT>
           <STRONG>
 2</STRONG>
 </DT><DD>Executed &quot;return&quot;; $&lt;varName&gt; contains the argument passed to &quot;return.&quot;</DD>
<DT>
            <STRONG>
3</STRONG>
 </DT><DD>Executed &quot;break&quot;; $&lt;varName&gt; is empty.</DD>
<DT>
            <STRONG>
4</STRONG>
 </DT><DD>Executed &quot;continue&quot;; $&lt;varName&gt; is empty.</DD>
</DL>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/Tcl/TTCL_d.htm#IX_protect Tcl command">protect</A>.



<H4 CLASS="refHeading">
<A NAME="TTCL_d.htm_IX_concat Tcl command">
 </A>
<A NAME="TTCL_d.htm_IX_Lists in Swat:concat Tcl command">
 </A>
concat</H4>
<PRE CLASS="syntax">
concat &lt;arg1&gt;+</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;concat $list1 $list2&quot; </DT><DD>
Merges the lists in $list1 and $list2 into a single list whose elements are the elements of the two lists.</DD>
</DL>
<P>
Concatenates multiple list arguments into a single list.</P>
<UL>
<LI>
This command treats each argument as a list and concatenates them into a single list. It permits any number of arguments. For example, the command</LI>
<PRE>concat a b {c d e} {f {g h}}</PRE>
<P>
	will return <CODE>
a b c d e f {g h}</CODE>
 as its result.</P>
<LI>
There is a sometimes-subtle difference between this in the &quot;list&quot; command: Given two lists, &quot;concat&quot; will form a list whose n elements are the combined elements of the two component lists, while &quot;list&quot; will form a list whose 2 elements are the two lists. For example,</LI>
<PRE> concat a b {c d e} {f {g h}}</PRE>
<P>
	 yields the list </P>
<PRE>a b c d e f {g h}</PRE>
<P>
	but</P>
<PRE>list a b {c d e} {f {g h}}</PRE>
<P>
	yields</P>
<PRE>a b {c d e} {f {g h}}</PRE>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/Tcl/TTCL_d.htm#IX_list Tcl command">list</A>.

<H4 CLASS="refHeading">
<A NAME="TTCL_d.htm_IX_continue Tcl command">
 </A>
continue</H4>
<PRE CLASS="syntax">
continue</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;continue&quot;</DT><DD>Return to the top of the enclosing loop.</DD>
</DL>
<P>
Skips the rest of the commands in the current loop iteration, continuing at the top of the loop.</P>
<UL>
<LI>
Only the closest-enclosing loop can be continued via this command. </LI>
<LI>
The &lt;next&gt; clause of the &quot;for&quot; command is not part of the current iteration, i.e. it will be executed even if you execute this command.</LI>
<LI>
This command may be invoked only inside the body of a loop command such as <CODE>
for</CODE>
 or <CODE>
foreach</CODE>
. It returns a TCL_CONTINUE code to signal the innermost containing loop command to skip the remainder of the loop's body but continue with the next iteration of the loop. </LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/Tcl/TTCL_d.htm#IX_break Tcl command">break</A>,
<A HREF="../../Tools/Tcl/TTCL_d.htm#IX_for Tcl command">for</A>.

<H4 CLASS="refHeading">
<A NAME="TTCL_d.htm_IX_defsubr Tcl command">
 </A>
defsubr</H4>
<PRE CLASS="syntax">
defsubr &lt;name&gt; &lt;args&gt; &lt;body&gt;</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;defsubr poof {arg1 args} {return [list $arg1 $args]}&quot;</DT><DD>
Defines a procedure poof that takes 1 or more arguments and merges them into a list of two elements.</DD>
</DL>
<P>
This is the same as the &quot;proc&quot; command, except the new procedure's name may not be abbreviated when it is invoked.</P>
<UL>
<LI>Refer to the documentation for <CODE>
proc</CODE>
 for more information. </LI>
</UL>

<H4 CLASS="refHeading">
<A NAME="TTCL_d.htm_IX_error Tcl command">
 </A>
error</H4>
<PRE CLASS="syntax">
error &lt;message&gt;</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;error {invalid argument}&quot; </DT><DD>
Generates an error, giving the not-so-helpful message &quot;invalid argument&quot; to the caller's caller.</DD>
</DL>
<UL>
<LI>
Unless one of the procedures in the call stack has executed a &quot;catch&quot; command, all procedures on the stack will be terminated with &lt;message&gt; (and an indication of an error) being the result of the final one so terminated. </LI>
<LI>
Any commands protected by the &quot;protect&quot; command will be executed.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/Tcl/TTCL_d.htm#IX_return Tcl command">return</A>,
<A HREF="../../Tools/Tcl/TTCL_d.htm#IX_catch Tcl command">catch</A>.

<H4 CLASS="refHeading">
<A NAME="TTCL_d.htm_IX_eval Tcl command">
 </A>
eval</H4>
<PRE CLASS="syntax">
eval &lt;body&gt;</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;eval $mangled_command&quot; </DT><DD>
Evaluate the command contained in $mangled_command and return its result.</DD>
</DL>
<P>
Evaluates the passed string as a command and returns the result of that evaluation.</P>
<UL>
<LI>
<CODE>
eval</CODE>
 takes one argument, which is a Tcl command (or collection of Tcl commands separated by newlines in the usual way). <CODE>
eval</CODE>
 evaluates &lt;<EM>body</EM>&gt; by passing it to the Tcl interpreter recursively, and returns the result of the last command. If an error occurs inside &lt;<EM>body</EM>&gt; then <CODE>
eval</CODE>
 returns that error. </LI>
<LI>
This command is useful when one needs to cobble together a command from arguments or what have you. For example, if one of your arguments is a list of arguments to pass to another command, the only way to accomplish that is to say something like &quot;eval [concat random-command $args]&quot;, which will form a list whose first element is the command to be executed, and whose remaining elements are the arguments for the command. &quot;eval&quot; will then execute that list properly.</LI>
<LI>
If the executed command generates an error, &quot;eval&quot; will propagate that error just like any other command.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/Tcl/TTCL_d.htm#IX_concat Tcl command">concat</A>,
<A HREF="../../Tools/Tcl/TTCL_d.htm#IX_list Tcl command">list</A>.


<H4 CLASS="refHeading">
<A NAME="TTCL_d.htm_IX_expr Tcl command">
 </A>
expr</H4>
<PRE CLASS="syntax">
expr &lt;expression&gt; [float]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;expr 36*25&quot; </DT><DD>Multiplies 36 by 25 and returns the result.</DD>
<DT>
 &quot;expr $i/6 float&quot; </DT><DD>
Divides the number in $i by 6 using floating- point arithmetic; the result is a real number.</DD>
<DT>
&quot;expr 7.2*10 float&quot;</DT><DD>
Multiplies 7.2 by 10. Note that though the answer (72) is an integer, we need to pass the &quot;float&quot; keyword to make sure that the expression is interpreted correctly.</DD>
</DL>
<P>
Evaluates an arithmetic expression and returns its value.</P>
<UL>
<LI>
Most C operators are supported with the standard operator precedence. </LI>
<LI>
If you use a Tcl variable in the expression, the variable may only contain a number; it may not contain an expression. </LI>
<LI>
The result of any Tcl command, in square brackets (&quot;[ ]&quot;) must be a number; it may not be an expression. </LI>
<LI>
All the C and Esp radix specifiers are allowed. </LI>
<LI>
Bitwise and boolean operators (!, &amp;, ^, |, &amp;&amp;, ||, &gt;&gt;, &lt;&lt;, ~) are not permitted when the expression is being evaluated using floating-point arithmetic.</LI>
</UL>



<H4 CLASS="refHeading">
<A NAME="TTCL_d.htm_IX_file Tcl command">
 </A>
file</H4>
<PRE CLASS="syntax">
file dirname &lt;name&gt;
file exists &lt;name&gt;
file extension &lt;name&gt;
file isdirectory &lt;name&gt;
file isfile &lt;name&gt;
file readable &lt;name&gt;
file rootname &lt;name&gt;
file tail &lt;name&gt;
file writable &lt;name&gt;
file match &lt;pattern&gt;
file newer &lt;name1&gt; &lt;name2&gt;</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;file match /pcgeos/tcl/*.tcl&quot; </DT><DD>
Looks for all files/directories in /pcgeos/tcl whose name ends with &quot;.tcl&quot;.</DD>
<DT>
 &quot;file isdir $path&quot; </DT><DD>
See if the path stored in $path refers to a directory.</DD>
<DT>
 &quot;file tail $path&quot; </DT><DD>
Return the final component of the path stored in $path</DD>
</DL>
<P>
Performs various checks and manipulations of file and directory names.</P>
<UL>
<LI>
The forward slash is the path separator for this command.</LI>
<LI>
The predicate subcommands (executable, exists, isdirectory, isfile, owned, readable, and writable) all return 1 if the path meets the requirements, or 0 if it doesn't. </LI>
<LI>
&quot;file match&quot; takes a <EM>
pattern</EM>
 made from the same components as are described for &quot;string match&quot;. It is <EM>
not</EM>
 the same as the standard DOS wildcarding, where `.' serves to separate the root pattern from the extension pattern. For this command &quot;*.*&quot; would match only files that actually have an extension. </LI>
<LI>
&quot;file dirname&quot; returns the directory portion of <EM>
name</EM>
. If <EM>
name</EM>
 has no directory portion, this returns &quot;.&quot; </LI>
<LI>
&quot;file rootname&quot; returns all leading directory components of <EM>
name</EM>
, plus the text before its extension, without the &quot;.&quot; that separates the name from the extension. </LI>
<LI>
&quot;file tail&quot; returns all of the characters in <EM>
name</EM>
 after the final forward slash, or <EM>
name</EM>
 if it contains no forward slashes.</LI>
<LI>
&quot;file newer&quot; returns 1 if <EM>
name1</EM>
 was modified after <EM>
name2</EM>
. It returns 0 otherwise.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/Tcl/TTCL_d.htm#IX_string Tcl command">string</A>.



<H4 CLASS="refHeading">
<A NAME="TTCL_d.htm_IX_for Tcl command">
 </A>
for</H4>
<PRE CLASS="syntax">
for &lt;start&gt; &lt;test&gt; &lt;next&gt; &lt;body&gt;</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;for {var i 0} {$i &lt; 10} {var i [expr $i+1]} {echo $i}&quot;</DT><DD>
 Prints the numbers from 0 to 9.</DD>
</DL>
<P>
This is Tcl's main looping construct. It functions similarly to the &quot;for&quot; in C.</P>
<UL>
<LI>
&lt;start&gt; is a Tcl command string (which may involve multiple commands over multiple lines, if desired) that is executed once at the very start of the loop. It is always executed. If it returns an error, or contains a &quot;break&quot; command, no part of the loop will execute. </LI>
<LI>
&lt;test&gt; is an arithmetic expression that is passed to the &quot;expr&quot; command. If the result is non-zero, the &lt;body&gt; is executed. </LI>
<LI>
&lt;next&gt; is a Tcl command string (which may involve multiple commands over multiple lines, if desired) that is executed at the end of each iteration before &lt;test&gt; is evaluated again. If it returns an error, or contains a &quot;break&quot; command, no part of the loop will execute. </LI>
<LI>
You can exit the loop prematurely by executing the &quot;break&quot; command in any of the three Tcl command strings (&lt;start&gt;, &lt;next&gt;, or &lt;body&gt;). </LI>
<LI>
So long as there's no error, &quot;for&quot; always returns the empty string as its result.</LI>
<LI>
If a <CODE>
continue</CODE>
 command is invoked within &lt;<EM>body</EM>&gt; then any remaining commands in the current execution of &lt;<EM>body</EM>&gt; are skipped; processing continues by invoking the Tcl interpreter on &lt;<EM>next</EM>&gt;, then evaluating &lt;<EM>test</EM>&gt;, and so on. If a <CODE>
break</CODE>
 command is invoked within &lt;<EM>body</EM>&gt;, then the <CODE>
for</CODE>
 command will return immediately. The operation of <CODE>
break</CODE>
 and <CODE>
continue</CODE>
 are similar to the corresponding statements in C. </LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/Tcl/TTCL_d.htm#IX_foreach Tcl command">foreach</A>,
<A HREF="../../Tools/Tcl/TTCL_d.htm#IX_break Tcl command">break</A>,
<A HREF="../../Tools/Tcl/TTCL_d.htm#IX_continue Tcl command">continue</A>.



<H4 CLASS="refHeading">
<A NAME="TTCL_d.htm_IX_foreach Tcl command">
 </A>
foreach</H4>
<PRE CLASS="syntax">
foreach &lt;varname&gt; &lt;list&gt; &lt;body&gt;</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;foreach el $list {echo poof = $el}&quot; </DT><DD>
Prints each element of the list $list preceded by the profound words &quot;poof = &quot;</DD>
</DL>
<P>
This is a looping construct to easily iterate over all the elements of a list.</P>
<UL>
<LI>
&lt;body&gt; is evaluated once for each element in &lt;list&gt;. Before each evaluation, the next element is placed in the variable &lt;varName&gt;. </LI>
<LI>
You can exit the loop prematurely by executing the &quot;break&quot; command. </LI>
<LI>
As long as there's no error, &quot;foreach&quot; always returns the empty string.</LI>
<LI>
The <CODE>
break</CODE>
 and <CODE>
continue</CODE>
 statements may be invoked inside &lt;<EM>body</EM>&gt;, with the same effect as in the <CODE>
for</CODE>
 command.</LI>
</UL>

<H4 CLASS="refHeading">
<A NAME="TTCL_d.htm_IX_format Tcl command">
 </A>
format</H4>
<PRE CLASS="syntax">format &lt;formatString&gt; [&lt;arg&gt; ]*</PRE>
<P>
<A NAME="TTCL_d.htm_IX_format Tcl command">
 </A>
This command generates a formatted string in the same way as the C <CODE>
sprintf</CODE>
 procedure (it uses <CODE>
sprintf</CODE>
 in its implementation). &lt;<EM>formatString</EM>&gt; indicates how to format the result, using<EM> %</EM> fields as in <CODE>
sprintf</CODE>
, and the additional arguments, if any, provide values to be substituted into the result. All of the <CODE>
sprintf</CODE>
 options are valid; see the <CODE>
sprintf</CODE>
 procedure in a C manual for more details. Each &lt;<EM>arg</EM>&gt; must match the expected type from the <EM>%</EM> field in &lt;<EM>formatString</EM>&gt;; the <CODE>
format</CODE>
 command converts each argument to the correct type (floating, integer, etc.) before passing it to <CODE>
sprintf</CODE>
 for formatting. The only unusual conversion is for<EM> %c</EM>; in this case the argument must be a decimal string, which will then be converted to the corresponding ASCII character value. <CODE>
format</CODE>
 does backslash substitution on its &lt;<EM>formatString</EM>&gt; argument, so backslash sequences in &lt;<EM>formatString</EM>&gt; will be handled correctly even if the argument is in braces. The return value from <CODE>
format</CODE>
 is the formatted string.</P>


<H4 CLASS="refHeading">
<A NAME="TTCL_d.htm_IX_global Tcl command">
 </A>
global</H4>
<PRE CLASS="syntax">
global &lt;varname&gt;+</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;global attached&quot; </DT><DD>
When next the &quot;attached&quot; variable is fetched or set, get it from the global scope, not the local one.</DD>
</DL>
<P>
Declares the given variables to be from the global scope.</P>
<UL>
<LI>
For the duration of the procedure in which this command is executed (but not in any procedure it invokes), the global variable of the given name will be used when the variable is fetched or set. </LI>
<LI>
If no global variable of the given name exists, the setting of that variable will define it in the global scope.</LI>
<LI>
This command is ignored unless a Tcl procedure is being interpreted. If so, then it declares the given &lt;<EM>varname</EM>&gt;'s to be global variables rather than local ones. For the duration of the current procedure (and only while executing in the current procedure), any reference to any of the &lt;<EM>varname</EM>&gt; values will be bound to a global variable instead of a local one.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/Tcl/TTCL_d.htm#IX_var Tcl command">var</A>.



<H4 CLASS="refHeading">
<A NAME="TTCL_d.htm_IX_if Tcl command">
 </A>
if</H4>
<PRE CLASS="syntax">
if &lt;test&gt; [then] &lt;trueBody&gt; <BR>
             (elif &lt;test&gt; [(then)] &lt;trueBody&gt;)* <BR>
             [[else] &lt;falseBody&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;if {$v &gt; 3} {echo yes} {echo no}&quot; </DT><DD>
Prints &quot;yes&quot; if $v is greater than 3, else it prints &quot;no&quot;.</DD>
<DT>
&quot;if {$v &gt; 3} then {echo yes} else {echo no}&quot; </DT><DD>
Ditto.</DD>
<DT>
&quot;if {$v &gt; 3} then {echo yes} elif {$v == 3} {echo maybe} else {echo no}&quot;</DT>
</DL>
<P>
This is Tcl's conditional, as you'd expect from its name.</P>
<UL>
<LI>
The &quot;then&quot; and &quot;else&quot; keywords are optional, intended to delineate the different sections of the command and make the whole easier to read. </LI>
<LI>
The &quot;elif&quot; keyword is <EM>
mandatory</EM>
 if you want to perform additional tests. </LI>
<LI>
The &lt;expr&gt; arguments are normal Tcl expressions. If the result is non-zero, the appropriate &lt;truebody&gt; is executed. If none of the &lt;expr&gt; arguments evaluates non-zero, &lt;falsebody&gt; is executed. </LI>
<LI>
If a &lt;truebody&gt; is empty and the test evaluated non-zero, &quot;if&quot; will return the result of the test. Otherwise &quot;if&quot; returns the result from last command executed in whichever &lt;truebody&gt; or &lt;falsebody&gt; argument was finally executed. It returns an empty string if no &lt;expr&gt; evaluated non-zero and no &lt;falsebody&gt; was given.</LI>
<LI>
The <CODE>
if</CODE>
 command evaluates &lt;<EM>test</EM>&gt; as an expression in the same way that <CODE>
expr</CODE>
 evaluates its argument. If the result is non-zero then &lt;<EM>trueBody</EM>&gt; is called by passing it to the Tcl interpreter. Otherwise &lt;<EM>falseBody</EM>&gt; is executed by passing it to the Tcl interpreter. &lt;<EM>falseBody</EM>&gt; is also optional; if it isn't specified then the command does nothing if &lt;<EM>test</EM>&gt; evaluates to zero. The return value from <CODE>
if</CODE>
 is the value of the last command executed in &lt;<EM>trueBody</EM>&gt; or &lt;<EM>falseBody</EM>&gt; or the empty string if &lt;<EM>test</EM>&gt; evaluates to zero and &lt;<EM>falseBody</EM>&gt; isn't specified. Alternative test conditions can be added by adding &lt;<EM>elif</EM>&gt; arguments. </LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/Tcl/TTCL_d.htm#IX_expr Tcl command">expr</A>.



<H4 CLASS="refHeading">
<A NAME="TTCL_d.htm_IX_index Tcl command">
 </A>
index</H4>
<PRE CLASS="syntax">
index &lt;value&gt; &lt;index&gt; [chars]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;index {a b c} 1&quot; 	</DT><DD>
Extracts &quot;b&quot; from the list.</DD>
<DT>
&quot;index {hi mom} 3 char&quot; </DT><DD>
Extracts &quot;m&quot; from the string.</DD>
</DL>
<P>
&quot;index&quot; is used to retrieve a single element or character from a list or string.</P>
<UL>
<LI>
Elements and characters are numbered from 0. </LI>
<LI>
If you request an element or character from beyond the end of the &lt;list&gt; or &lt;string&gt;, you'll receive an empty list or string as a result.</LI>
<LI>
If the &lt;<EM>chars</EM>&gt; keyword isn't specified, then <CODE>
index</CODE>
 treats &lt;<EM>value</EM>&gt; as a list and returns the &lt;<EM>index</EM>&gt;'th field from it. In extracting the field, <CODE>
index</CODE>
 observes the same rules concerning braces and backslashes as the Tcl command interpreter; however, variable substitution and command substitution do not occur. If the &lt;<EM>chars</EM>&gt; keyword is specified (or any abbreviation of it), then &lt;<EM>value</EM>&gt; is treated as a string and the command returns the &lt;<EM>index</EM>&gt;'th character from it (or the empty string if there aren't at least &lt;<EM>index</EM>&gt;+1 characters in the string).
</LI>
</UL>

<H4 CLASS="refHeading">
<A NAME="TTCL_d.htm_IX_info Tcl command">
 </A>
info</H4>
<PRE CLASS="syntax">
info args &lt;procname&gt; [&lt;pattern&gt;]
info arglist &lt;procname&gt;
info body &lt;procname&gt;
info cmdcount
info commands [&lt;pattern&gt;]
info default &lt;procname&gt; &lt;arg&gt; &lt;varname&gt;
info globals [&lt;pattern&gt;]
info locals [&lt;pattern&gt;]
info procs [&lt;pattern&gt;]
info vars [&lt;pattern&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;info args fmtval&quot;</DT><DD> Retrieves the names of the arguments for the &quot;fmtval&quot; command so you know in what order to pass things.</DD>
<DT>
&quot;info body print-frame&quot;</DT><DD> Retrieves the string that is the body of the &quot;print-frame&quot; Tcl procedure.</DD>
<DT>
&quot;info commands <EM>
reg</EM>
&quot; </DT><DD>Retrieves a list of commands whose names contain the string &quot;reg&quot;.</DD>
</DL>
<P>
This command provides information about a number of data structures maintained by the Tcl interpreter.</P>
<UL>
<LI>
All the &lt;pattern&gt; arguments are standard wildcard patterns as are used for the &quot;string match&quot; and &quot;case&quot; commands. See &quot;string&quot; for a description of these patterns. </LI>
<LI>
&quot;info args&quot; returns the complete list of arguments for a Tcl procedure, or only those matching the &lt;pattern&gt;, if one is given. The arguments are returned in the order in which they must be passed to the procedure. </LI>
<LI>
&quot;info arglist&quot; returns the complete list of arguments, and their default values, for a Tcl procedure. </LI>
<LI>
&quot;info body&quot; returns the command string that is the body of the given Tcl procedure. </LI>
<LI>
&quot;info cmdcount&quot; returns the total number of commands the Tcl interpreter has executed in its lifetime.</LI>
<LI>
&quot;info commands&quot; returns the list of all known commands, either built-in or as Tcl procedures, known to the interpreter. You may also specify a pattern to restrict the commands to those whose names match the pattern. </LI>
<LI>
&quot;info default&quot; returns non-zero if the argument named &lt;arg&gt; for the given Tcl procedure has a default value. If it does, that default value is stored in the variable whose name is &lt;varname&gt;. </LI>
<LI>
&quot;info globals&quot; returns the list of all global variables accessible within the current variable scope (i.e. only those that have been declared global with the &quot;global&quot; command, unless you issue this command from the command-line, which is at the global scope), or those that match the given pattern. </LI>
<LI>
&quot;info locals&quot; returns the list of all local variables, or those that match the given pattern.</LI>
<LI>
&quot;info procs&quot; returns the list of all known Tcl procedures, or those that match the given pattern. </LI>
<LI>
&quot;info vars&quot; returns the list of all known Tcl variables in the current scope, either local or global. You may also give a pattern to restrict the list to only those that match.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/Tcl/TTCL_d.htm#IX_proc Tcl command">proc</A>,
<A HREF="../../Tools/SwatRef/SR_9.htm#IX_defcmd Swat command">defcmd</A>,
<A HREF="../../Tools/SwatRef/SR_9.htm#IX_defcommand Swat command">defcommand</A>,
<A HREF="../../Tools/Tcl/TTCL_d.htm#IX_defsubr Tcl command">defsubr</A>.



<H4 CLASS="refHeading">
<A NAME="TTCL_d.htm_IX_Strings in Swat:computing length">
 </A>
<A NAME="TTCL_d.htm_IX_Lists in Swat:length Tcl command">
 </A>
<A NAME="TTCL_d.htm_IX_length Tcl command">
 </A>
length</H4>
<PRE CLASS="syntax">
length &lt;value&gt; [&lt;chars&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;length $args&quot; </DT><DD>
Returns the number of elements in the list $args</DD>
<DT>
&quot;length $str char&quot; </DT><DD>
Returns the number of characters in the string $str</DD>
</DL>
<P>
Determines the number of characters in a string, or elements in a list.</P>
<UL>
<LI>
If (<EM>chars</EM>) isn't specified, <CODE>
length</CODE>
 treats &lt;<EM>value</EM>&gt; as a list and returns the number of elements in the list. If &lt;<EM>chars</EM>&gt; is specified (or any abbreviation of it), then <CODE>
length</CODE>
 treats &lt;<EM>value</EM>&gt; as a string and returns the number of characters in it (not including the terminating null character).</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/Tcl/TTCL_d.htm#IX_index Tcl command">index</A>,
<A HREF="../../Tools/Tcl/TTCL_d.htm#IX_range Tcl command">range</A>.



<H4 CLASS="refHeading">
<A NAME="TTCL_d.htm_IX_Lists in Swat:list Tcl command">
 </A>
<A NAME="TTCL_d.htm_IX_list Tcl command">
 </A>
list</H4>
<PRE CLASS="syntax">
list &lt;arg&gt;+</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;list a b {c d e} {f {g h}}&quot; </DT><DD>
Returns the list &quot;a b {c d e} {f {g h}}&quot;</DD>
</DL>
<P>
Joins any number of arguments into a single list, applying quoting braces and backslashes as necessary to form a valid Tcl list.</P>
<UL>
<LI>
If you use the &quot;index&quot; command on the result, the 0th element will be the first argument that was passed, the 1st element will be the second argument that was passed, etc. </LI>
<LI>
The difference between &quot;list&quot; and &quot;concat&quot; is subtle. Given the above arguments, &quot;concat&quot; would return &quot;a b c d e f {g h}&quot;.</LI>
<LI>
This command returns a list comprised of all the &lt;<EM>args</EM>&gt;. It also adds braces and backslashes as necessary, so that the <CODE>
index</CODE>
 command may be used on the result to re-extract the original arguments, and also so that <CODE>
eval</CODE>
 may be used to execute the resulting list, with &lt;<EM>arg1</EM>&gt; comprising the command's name and the other &lt;<EM>args&gt;</EM> comprising its arguments. </LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/Tcl/TTCL_d.htm#IX_concat Tcl command">concat</A>,
<A HREF="../../Tools/Tcl/TTCL_d.htm#IX_index Tcl command">index</A>,
<A HREF="../../Tools/Tcl/TTCL_d.htm#IX_range Tcl command">range</A>.



<H4 CLASS="refHeading">
<A NAME="TTCL_d.htm_IX_Tcl:defining procedures">
 </A>
<A NAME="TTCL_d.htm_IX_proc Tcl command">
 </A>
proc</H4>
<PRE CLASS="syntax">
proc &lt;name&gt; &lt;args&gt; &lt;body&gt;</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;proc poof {{arg1 one} args} {return [list $arg1 $args]}&quot;</DT><DD>
 Defines a procedure poof that takes 0 or more arguments and merges them into a list of two elements. If no argument is given, the result will be the list {one {}}</DD>
</DL>
<P>
Defines a new Tcl procedure that can be invoked by typing a unique abbreviation of the procedure name.</P>
<UL>
<LI>
Any existing procedure or built-in command with the same name is overridden. </LI>
<LI>
&lt;name&gt; is the name of the new procedure and can consist of pretty much any character (even a space or tab, if you enclose the argument in braces). </LI>
<LI>
&lt;args&gt; is the (possibly empty) list of formal parameters the procedure accepts. Each element of the list can be either the name of local variable, to which the corresponding actual parameter is assigned before the first command of the procedure is executed, or a two-element list, the first element of which is the local variable name, as above, and the second element of which is the value to assign the variable if no actual parameter is given. </LI>
<LI>
If the final formal parameter is named &quot;args&quot;, the remaining actual parameters from that position on are cobbled into a list and assigned to the local variable $args. This allows a procedure to receive a variable number of arguments (even 0, in which case $args will be the empty list). </LI>
<LI>
If the only formal parameter is &quot;noeval&quot;, all the actual parameters are merged into a list and assigned to $noeval. Moreover, neither command- nor variable-substitution is performed on the actual parameters. </LI>
<LI>
The return value for the procedure is specified by executing the &quot;return&quot; command within the procedure. If no &quot;return&quot; command is executed, the return value for the procedure is the empty string.</LI>
<LI>
Whenever the new command is invoked, the contents of &lt;<EM>body</EM>&gt; will be executed by the Tcl interpreter. &lt;<EM>args</EM>&gt; specifies the formal arguments to the procedure. It consists of a list, possibly empty, each of whose elements specifies one argument. Braces and backslashes may be used in the usual way to specify complex default values.</LI>
<LI>
When &lt;<EM>name</EM>&gt; (or a unique abbreviation of same) is invoked, a local variable will be created for each of the formal arguments to the procedure; its value will be the value of corresponding argument in the invoking command or the argument's default value. Arguments with default values need not be specified in a procedure invocation. However, there must be enough actual arguments for all the formal arguments that don't have defaults, and there must not be any extra actual arguments (unless the &quot;args&quot; keyword was used). </LI>
<LI>
When &lt;<EM>body</EM>&gt; is being executed, variable names normally refer to local variables, which are created automatically when referenced and deleted when the procedure returns. One local variable is automatically created for each of the procedure's arguments. Global variables can only be accessed by invoking the <CODE>
global</CODE>
 command.</LI>
<LI>
The <CODE>
proc</CODE>
 command itself returns the null string. </LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/Tcl/TTCL_d.htm#IX_defsubr Tcl command">defsubr</A>,
<A HREF="../../Tools/Tcl/TTCL_d.htm#IX_return Tcl command">return</A>.



<H4 CLASS="refHeading">
<A NAME="TTCL_d.htm_IX_protect Tcl command">
 </A>
protect</H4>
<PRE CLASS="syntax">
protect &lt;body&gt; &lt;cleanup&gt;</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;protect {</DT>
<DT>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var s [stream open $file w]<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# do stuff with the stream<BR>
&nbsp;}&nbsp;{<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch {stream close $s}<BR>
<BR>
&nbsp;}&quot; </DT><DD>
Perform some random operations on a file making sure the stream gets closed, even if the user types control-C.</DD>
</DL>
<P>
Allows one to ensure that clean-up for a sequence of commands will always happen, even if the user types control-C to interrupt the command.</P>
<UL>
<LI>
Since the interrupt can come at any time during the &lt;body&gt;, the &lt;cleanup&gt; command string should not rely on any particular variables being set. Hence the &quot;catch&quot; command used in the &lt;cleanup&gt; clause of the example. </LI>
<LI>
The &lt;cleanup&gt; clause will also be executed if any command in the &lt;body&gt; generates an error. </LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/Tcl/TTCL_d.htm#IX_catch Tcl command">catch</A>.



<H4 CLASS="refHeading">
<A NAME="TTCL_d.htm_IX_range Tcl command">
 </A>
<A NAME="TTCL_d.htm_IX_Lists in Swat:range Tcl command">
 </A>
range</H4>
<PRE CLASS="syntax">
range &lt;value&gt; &lt;first&gt; &lt;last&gt; [chars] </PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;range {a b c} 1 end&quot; </DT><DD>
Returns {b c} (element 1 to the end)</DD>
<DT>
&quot;range {hi mom} 3 end chars&quot; </DT><DD>
Returns &quot;mom&quot;</DD>
</DL>
<P>
Extracts a range of characters from a string, or elements from a list.</P>
<UL>
<LI>
If you give an ending index that is greater than the number of elements in the list (characters in the string), it will be adjusted to be the index of the last element (character). </LI>
<LI>
If you give a starting index that is greater than the number of elements in the list (characters in the string), the result will be the empty list (string). </LI>
<LI>
You can give &lt;end&gt; as &quot;end&quot; (without the quotation marks, of course) to indicate the extraction should go to the end of the list (string). </LI>
<LI>
The range is inclusive, so &quot;range {a b c} 0 0&quot; returns &quot;a&quot;. </LI>
<LI>
Neither index may be less than 0 or &quot;range&quot; will generate an error.</LI>
<LI>
 Return a range of fields or characters from value.   If the <EM>chars</EM> keyword, or any abbreviation of it, is specified, then <CODE>
range</CODE>
 treats &lt;value&gt; as a character string and returns characters &lt;<EM>first</EM>&gt; through &lt;<EM>last</EM>&gt; of it, inclusive. If &lt;<EM>last</EM>&gt; is less than &lt;<EM>first</EM>&gt; then an empty string is returned. Note: <CODE>
range value </CODE>
<EM CLASS="CodeArgsAsTyped">first first</EM> does not always produce the same results as<CODE>
 index value </CODE>
<EM CLASS="CodeArgsAsTyped">first</EM>
(although it often does for simple fields that are not enclosed in braces); it does, however, produce exactly the same results as <CODE>
list [index value first]</CODE>
.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/Tcl/TTCL_d.htm#IX_index Tcl command">index</A>.



<H4 CLASS="refHeading">
<A NAME="TTCL_d.htm_IX_return Tcl command">
 </A>
return</H4>
<PRE CLASS="syntax">
return [&lt;value&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;return $val&quot; 		</DT><DD>
Returns the string in $val as the value for the current Tcl procedure.</DD>
</DL>
<P>
Causes an immediate return from the current Tcl procedure, with or without a value.</P>
<UL>
<LI>
Every Tcl procedure returns a string for a value. If the procedure was called via command substitution (having been placed between square brackets as the argument to another command), the return value takes the place of the command invocation. </LI>
<LI>
Execution of the current procedure terminates immediately, though any &lt;cleanup&gt; clause for a containing &quot;protect&quot; command will still be executed. </LI>
<LI>
If no &quot;return&quot; command is invoked within a Tcl procedure, the procedure returns the empty string by default.</LI>
<LI>
This command may be invoked only when a procedure call is in progress. It causes the current procedure to return immediately. If &lt;<EM>value</EM>&gt; is specified, it will be the return value from the procedure. Otherwise the current procedure will return the empty string.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/Tcl/TTCL_d.htm#IX_error Tcl command">error</A>,
<A HREF="../../Tools/Tcl/TTCL_d.htm#IX_proc Tcl command">proc</A>,
<A HREF="../../Tools/Tcl/TTCL_d.htm#IX_defsubr Tcl command">defsubr</A>,
<A HREF="../../Tools/SwatRef/SR_9.htm#IX_defcommand Swat command">defcommand</A>,
<A HREF="../../Tools/SwatRef/SR_9.htm#IX_defcmd Swat command">defcmd</A>.



<H4 CLASS="refHeading">
<A NAME="TTCL_d.htm_IX_scan Tcl command">
 </A>
scan</H4>
<PRE CLASS="syntax">
scan &lt;string&gt; &lt;format&gt; [&lt;varname1&gt; ]*</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;scan $input {my name is %s} name&quot; </DT><DD>
Trims the leading string &quot;my name is &quot; from the string in $input and stores the rest of the string within the variable $name</DD>
</DL>
<P>
&quot;scan&quot; parses fields from an input string, given the string and a format string that defines the various types of fields. The fields are assigned to variables within the caller's scope.</P>
<UL>
<LI>
The &lt;format&gt; string consists of literal text, which must be matched explicitly, and field definitions. The &lt;varName&gt; arguments are names of variables to which each successive field value is assigned. </LI>
<LI>
A single whitespace character (space or tab) will match any number of whitespace characters in the input string. Fields are specified as for the standard C library routine &quot;sscanf&quot;:</LI>
<DL>
<DT>
           <STRONG>
 %c</STRONG>
 </DT><DD>A single character. The field value stored is the decimal number of the ASCII code for the character scanned. So if the character were a space, the variable would receive the string &quot;32&quot;.</DD>
<DT>
             <STRONG>
%d</STRONG>
 </DT><DD>A signed decimal integer is parsed and stored. </DD>
<DT>
             <STRONG>
%o</STRONG>
 </DT><DD>An octal integer is parsed and stored, as a decimal number.</DD>
<DT>
             <STRONG>
%x</STRONG>
 </DT><DD>A hexadecimal integer is parsed and stored, as a decimal number.</DD>
<DT>
              <STRONG>
%i</STRONG>
 </DT><DD>A signed integer, following the standard C radix-specification standard, is parsed and stored as a decimal number.</DD>
<DT>
              <STRONG>
%f</STRONG>
 </DT><DD>A floating-point number is parsed as a &quot;float&quot; and stored without exponent, unless the exponent is less than -4.</DD>
<DT>
              <STRONG>
%s</STRONG>
 </DT><DD>A whitespace-terminated string is parsed and stored.</DD>
<DT>
              <STRONG>
%[&lt;char-class&gt;]</STRONG>
	</DT><DD>
 A string consisting only of the characters in the given character class (see &quot;string match&quot; for details on character classes) is parsed and stored. The normal leading-whitespace skipping is suppressed.</DD>
<DT>
             <STRONG>
%%</STRONG>
 </DT><DD>Matches a single percent sign in the input. </DD>
</DL>
<LI>
If the % of a field specifier is followed by an *, the field is parsed as usual, consuming characters from the string, but the result is not stored anywhere and you should not specify a variable to receive the value. </LI>
<LI>
The maximum length of a field may be specified by giving a decimal number between the % and the field-type character. So &quot;%10s&quot; will extract out a string of at most 10 characters. </LI>
<LI>
There is a limit of 5 fields. </LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/Tcl/TTCL_d.htm#IX_format Tcl command">format</A>.



<H4 CLASS="refHeading">
<A NAME="TTCL_d.htm_IX_source Tcl command">
 </A>
source</H4>
<PRE CLASS="syntax">
source &lt;fileName&gt;</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;source coolness&quot; </DT><DD>
Evaluates all commands within the file &quot;coolness.tcl&quot; in the current directory.</DD>
</DL>
<P>
Reads and evaluates commands from a file.</P>
<UL>
<LI>
If &lt;file&gt; has no extension and doesn't exist, &quot;source&quot; will append &quot;.tcl&quot; to the end and try and read that file.</LI>
<LI>
The return value of <CODE>
source</CODE>
 is the return value of the last command executed from the file. If an error occurs in executing the contents of the file, then the <CODE>
source</CODE>
 command will return that error.</LI>
</UL>

<H4 CLASS="refHeading">
<A NAME="TTCL_d.htm_IX_string Tcl command">
 </A>
string</H4>
<PRE CLASS="syntax">
string compare&lt;string1&gt; &lt;string2&gt; [no_case]
string first&lt;substring&gt; &lt;string&gt; [no_case]
string last&lt;substring&gt; &lt;string&gt; [no_case]
string match&lt;string&gt; &lt;pattern&gt;
string subst &lt;string&gt; &lt;search&gt; &lt;replace&gt; [global] </PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;if {[string c [index $args 1] all] == 0}&quot; </DT><DD>
Do something if the 2nd element of the list in $args is the string &quot;all&quot;.</DD>
<DT>
&quot;while {[string m [index $args 0] -*]}&quot; </DT><DD>
Loop while the first element of the list in $args begins with a hyphen.</DD>
</DL>
<P>
Examine strings in various ways.</P>
<UL>
<LI>
&quot;string subst&quot; searches &lt;string&gt; for occurrences of &lt;search&gt; and replaces them with &lt;replace&gt;. If 5th argument is given as &quot;global&quot; (it may be abbreviated), then all (non-overlapping) occurrences of &lt;search&gt; will be replaced. If 5th argument is absent, only the first occurrence will be replaced. </LI>
<LI>
&quot;string compare&quot; compares the two strings character-by-character. It returns -1, 0, or 1 depending on whether &lt;string1&gt; is lexicographically less than, equal to, or greater than &lt;string2&gt;. If the no_case parameter is passed than it does a case insensitive compare. </LI>
<LI>
&quot;string first&quot; searches &lt;string&gt; for the given &lt;substring&gt;. If it finds it, it returns the index of the first character in the first such match. If &lt;substring&gt; isn't part of &lt;string&gt;, it returns -1. If the no_case parameter is passed it does the search ignoring case. </LI>
<LI>
&quot;string last&quot; is much like &quot;string first&quot;, except it returns the index of the first character of the last match for the &lt;substring&gt; within &lt;string&gt;. If there is no match, it returns -1. </LI>
<LI>
&quot;string match&quot; compares &lt;string&gt; against &lt;pattern&gt; and returns 1 if the two match, or 0 if they do not. For the strings to match, their contents must be identical, except that the following special sequences may appear in &lt;pattern&gt; with the following results:</LI>
<DL>
<DT>
           * </DT><DD>Matches any sequence of characters, including none.</DD>
<DT>
            ? </DT><DD>Matches any single character</DD>
<DT>
           [&lt;char-class&gt;] </DT><DD>
Matches a single character within the given set. The elements of the set are specified as single characters, or as ranges of the form &lt;start&gt;-&lt;end&gt;. Thus [0-9x] matches a single character that is a numeric digit or the letter x.</DD>
<DT>
           [^&lt;char-class&gt;] </DT><DD>
Matches a single character <EM>
not</EM>
 within the given set.</DD>
<DT>
           \* </DT><DD>Matches an asterisk.</DD>
<DT>
           \? </DT><DD>Matches a question mark.</DD>
<DT>
           \[ </DT><DD>Matches an open-bracket.</DD>
</DL>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/Tcl/TTCL_d.htm#IX_case Tcl command">case</A>.



<H4 CLASS="refHeading">
<A NAME="TTCL_d.htm_IX_uplevel Tcl command">
 </A>
uplevel</H4>
<PRE CLASS="syntax">
uplevel &lt;level&gt; &lt;body&gt;<BR>
uplevel &lt;function&gt; &lt;body&gt;</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;uplevel print-frame {var found1}&quot;</DT><DD>
Sets $found to 1 within the variables belonging to the nearest invocation of print-frame on the call stack.</DD>
<DT>
&quot;uplevel 0 {var foo-table}&quot; </DT><DD>
Retrieves the value of the global variable foo-table.</DD>
<DT>
&quot;uplevel 1 {var found 1}&quot; </DT><DD>
Sets $found to 1 within the scope of the procedure that called the one executing the &quot;uplevel&quot; command.</DD>
</DL>
<P>
Provides access to the variables of another procedure for fairly specialized purposes.</P>
<UL>
<LI>
&lt;level&gt; is a signed integer with the following meaning:</LI>
<DL>
<DT>
 &gt; 0 </DT><DD>Indicates the number of scopes to go up. For example, if you say &quot;uplevel 1 {var foo 36}&quot;, you would modify (or create) the variable &quot;foo&quot; in your caller's scope.</DD>
<DT>
 &lt;= 0 </DT><DD>Indicates the number of scopes to go down from the global one. &quot;uplevel 0 &lt;body&gt;&quot; will execute &lt;body&gt; in the top-most scope, which means that no local variables are involved, and any variables created by the commands in &lt;body&gt; persist as global variables.</DD>
</DL>
<LI>
&lt;function&gt; is the name of a function known to be somewhere on the call stack. If the named function isn't on the call stack anywhere, &quot;uplevel&quot; generates an error. </LI>
<LI>
&lt;body&gt; may be spread over multiple arguments, allowing the command to be executed to use variables local to the current procedure as arguments without having to use the &quot;list&quot; command to form the &lt;body&gt;.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/Tcl/TTCL_d.htm#IX_global Tcl command">global</A>.



<H4 CLASS="refHeading">
<A NAME="TTCL_d.htm_IX_var Tcl command">
 </A>
var</H4>
<PRE CLASS="syntax">
var &lt;varname&gt;
var (&lt;name&gt; &lt;value&gt;)+</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;echo [var poof]&quot; </DT><DD>
Prints the value stored in the variable &quot;poof&quot;</DD>
<DT>
&quot;var a b c d&quot; </DT><DD>Assigns the string &quot;b&quot; to the variable &quot;a&quot;, and the string &quot;d&quot; to the variable &quot;c&quot;.</DD>
<DT>
&quot;var yes $no no $yes&quot; </DT><DD>
Exchanges the values of the &quot;yes&quot; and &quot;no&quot; variables </DD>
</DL>
<P>
This is the means by which variables are defined in Tcl. Less often, it is also used to retrieve the value of a variable (usually that's done via variable substitution).</P>
<UL>
<LI>
If you give only one argument, the value of that variable will be returned. If the variable has never been given a value, the variable will be created and assigned the empty string, then the empty string will be returned. </LI>
<LI>
You can set the value of a variable by giving the value as the second argument, after the variable name. No value is returned by the &quot;var&quot; command in this case. </LI>
<LI>
You can assign values to multiple variables &quot;in parallel&quot; by giving successive name/value pairs. </LI>
<LI>
If invoked in a procedure on a variable that has not been declared global (using the &quot;global&quot; command), this applies to the local variable of the given name, even if it has no value yet.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/Tcl/TTCL_d.htm#IX_global Tcl command">global</A>.


<HR>
<A NAME="TTCL_e.htm"></A>


<H2 CLASS="sectionTitle">
<A HREF="#index.htm">Tool Command Language</A>: 6 
Coding</H2>
<P>
This section provides information about the features and commands of Tcl that are important to know when using Swat, and the features and commands of Swat that are important to know when using Tcl. These features should be kept in mind while programming in Tcl because, if used properly, they make programming, debugging, and understanding existing commands much easier.This section will contain the following parts:</P>
<UL>
<LI>
Swat Data Structures<BR>
Descriptions of the major data structures and the commands that access them.</LI>
<LI>
Examples</LI>
</UL>
<P CLASS="subsectionLink">
<A HREF="#TTCL_f.htm">Swat Data Structure Commands</A></P>
<P CLASS="subsectionLink">
<A HREF="#TTCL_10.htm">Examples</A></P>
<HR>
<A NAME="TTCL_f.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Tool Command Language</A>: 6.1 <A HREF="#TTCL_e.htm">Coding</A>: 
<A NAME="TTCL_f.htm_90509">
 </A>
Swat Data Structure Commands</H3>
<PRE>symbol, type, patient, handle, brk, cbrk, event, thread, src, cache, table</PRE>
<P>
<A NAME="TTCL_f.htm_IX_Tcl:data structures">
 </A>
This section contains information about Swat's built-in data structures and the commands that access them. These commands  examine and modify vital information about the state of GEOS while it is running under Swat. </P>

<DIV>
<H4 CLASS="refHeading">
<A NAME="TTCL_f.htm_IX_Breakpoints">
 </A>
<A NAME="TTCL_f.htm_IX_brk Tcl structure:command reference">
 </A>
brk</H4>
<PRE CLASS="syntax">brk &lt;addr&gt; [&lt;command&gt;]
brk pset &lt;addr&gt; [&lt;command&gt;]
brk aset &lt;addr&gt; [&lt;command&gt;]
brk tset &lt;addr&gt; [&lt;command&gt;]
brk clear &lt;break&gt;*
brk delete &lt;break&gt;*
brk enable &lt;break&gt;*
brk disable &lt;break&gt;*
brk address &lt;break&gt;
brk list [&lt;addr&gt;]
brk debug [&lt;flag&gt;]
brk isset &lt;addr&gt;
brk cond &lt;break&gt; &lt;condition&gt;*
brk cmd &lt;break&gt; [&lt;command&gt;]
brk delcmd &lt;break&gt; [&lt;command&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>

<DL><DT>&quot;brk WinOpen&quot; </DT><DD>
Sets the machine to stop unconditionally when any thread calls WinOpen.</DD>

<DT><A NAME="TTCL_f.htm_IX_Patients:specific breakpoints"> </A> &quot;brk pset WinOpen&quot; </DT><DD>
Sets the machine to stop when any thread for the current patient calls WinOpen.</DD>

<DT><A NAME="TTCL_f.htm_IX_Threads:specific breakpoints"> </A> &quot;brk tset WinOpen&quot;</DT><DD>
 Sets the machine to stop when any thread for the current patient calls WinOpen, and deletes the breakpoint when the machine next stops.</DD>

<DT> &quot;brk enable 1 3-5&quot; </DT><DD>
Re-enables breakpoints 1, 3, 4, and 5</DD>

<DT> &quot;brk clear 2-&quot;</DT><DD>
Clears all breakpoints from number 2 onward.</DD>

<DT><A NAME="TTCL_f.htm_IX_Breakpoints:conditional"> </A> &quot;brk cond 3 cx=42&quot; </DT><DD>
Sets breakpoint 3 to be conditional, stopping when the machine reaches the breakpoint's address with CX being 42.</DD>

<DT> &quot;brk cond 2 (ss:0)!=1b80h&quot; </DT><DD>
Sets breakpoint 2 to be conditional, stopping when the machine reaches the breakpoint's address with the word at ss:0 not being 1b80h. Note that the &quot;ss&quot; is the value of the <CODE>ss</CODE> register when the &quot;brk cond&quot; command is executed, not when the breakpoint is reached.</DD>
</DL>

<P>Allows you to specify that execution should stop when it reaches a particular point. These breakpoints can be conditional, and can execute an arbitrary Tcl command, which can say whether the machine is to remain stopped, or continue on its way.</P>
<UL>

<LI>Once you've set a breakpoint, &quot;brk&quot; will return to you a token for that breakpoint that begins with &quot;brk&quot; and ends with a number. When you refer to the breakpoint, you can use either the full name (as you'll usually do from a Tcl procedure), or just the number.</LI>

<LI>Breakpoints have four attributes: the address at which they are set, the condition set on their being recognized, the Tcl command string to execute when they are recognized, and the Tcl command string to execute when they are deleted.</LI>

<LI>The condition is set either when the breakpoint is set, using the &quot;cbrk&quot; command, or after you've set the breakpoint, by invoking the &quot;brk cond&quot; command.</LI>

<LI> A breakpoint's condition is evaluated (very quickly) on the PC and can check only word registers (the 8 general registers, the three segment registers other than CS, and the current thread; each register may be checked only once in a condition) and a single word of memory. Each &lt;condition&gt; argument is of the form &quot;&lt;reg&gt;&lt;op&gt;&lt;value&gt;&quot;. &lt;reg&gt; is one of the 16-bit machine registers, &quot;thread&quot; (for the current thread), or the address of a word of memory to check, enclosed in parentheses. &lt;op&gt; is a relational operator taken from the following set:
<DL><DT>=</DT><DD>equal-to</DD>
<DT>!=</DT><DD>not-equal-to</DD>
<DT>&gt; &lt; &gt;= &lt;=</DT><DD>unsigned greater-than, less-than, greater-or-equal, and
      less-or-equal</DD>
<DT>+&gt; +&lt; +&gt;= +&lt;=</DT><DD>signed greater-than, less-than, greater-or-equal, and
      less-or-equal</DD>
</DL>
<BR>
<A NAME="TTCL_f.htm_IX_Handles:in breakpoint locations"> </A> &lt;value&gt; is a regular Swat address expression. If it is handle-relative, and the &lt;reg&gt; is one of the three non-CS segment registers, the condition will be for the segment of that handle and will change automatically as the handle's memory shifts about on the heap. Similar things will happen if you specify a number as the &lt;value&gt; for a segment register and the number is the current segment of a block on the heap. </LI>

<LI>If you give no &lt;condition&gt; argument to the &quot;brk cond&quot; command, you will remove any condition the breakpoint might have, making it, therefore, unconditional. </LI>

<LI>If a breakpoint is given an associated &lt;command&gt; string, it will be evaluated before the breakpoint is taken. If the result of the evaluation is an error, a non-numeric string, or a numeric string that's non-zero, the breakpoint will be taken. Otherwise, the machine will be allowed to continue (so long as no other breakpoint command or other part of Swat insists that it remain stopped). You can use this to simply print out information when execution reaches the breakpoint address without interrupting the machine's execution.</LI>

<LI>The global variable &quot;breakpoint&quot; contains the name of the breakpoint whose command is being evaluated while that command is being evaluated. </LI>

<LI> You can change the command associated with a breakpoint with the &quot;brk cmd&quot; command. If you give no &lt;command&gt; argument, then no command will be executed and the breakpoint will always be taken, so long as any associated condition is also met. </LI>

<LI> If a breakpoint has both a condition and a command, the command will not be executed until the condition has been met, unless there's another breakpoint at the same address with a different, or no, condition.</LI>

<LI>You can set a breakpoint to last only during the next continuation of the machine by calling &quot;brk tset&quot;. The breakpoint thus set will be removed when next the machine comes to a full stop, regardless of why it stopped (i.e. if it hits a different breakpoint, the temporary breakpoint will still be removed). The breakpoint will only be taken if the thread executing when it is hit is owned by the patient that was current when the breakpoint was set.</LI>

<LI>Each &lt;break&gt; argument to the &quot;brk clear&quot;, &quot;brk enable&quot; and &quot;brk disable&quot; commands can be either a single breakpoint token (or number), or a range of the form &lt;start&gt;-&lt;end&gt;, where either &lt;start&gt; or &lt;end&gt; may be absent. If &lt;start&gt; is missing, the command affects all breakpoints from number 1 to &lt;end&gt;. If &lt;end&gt; is missing, the command affects all breakpoints from &lt;start&gt; to the last one in existence.</LI>

<LI>If you give no &lt;break&gt; argument to &quot;brk clear&quot;, &quot;brk enable&quot; or &quot;brk disable&quot;, the command will apply to all breakpoints that are specific to the current patient, i.e. that were set with the &quot;brk pset&quot; command, unless the current patient is the kernel, in which case they will apply to all breakpoints that are specific to no patient (i.e. those set with the &quot;brk aset&quot; or &quot;brk &lt;addr&gt;&quot; commands).</LI>

<LI><A NAME="TTCL_f.htm_IX_Address expressions in Swat:of breakpoints"> </A>&quot;brk address&quot; returns the address expression for where the breakpoint is set. This will usually be of the form ^h&lt;handle-id&gt;:&lt;offset&gt;, with both &lt;handle-id&gt; and &lt;offset&gt; in hex (followed by an &quot;h&quot;, of course). If the breakpoint is set at an absolute address, you will get back only a single hex number, being the linear address at which the breakpoint is set.</LI>

<LI>If you type &quot;brk list&quot; with no argument, Swat will print out a listing of the currently-active breakpoints. If you give an &lt;addr&gt; (address expression) argument, however, you'll be returned a list of the breakpoints set at the given address. If there are no breakpoints there, the list will be empty.</LI><LI> As a shortcut, you can invoke &quot;brk isset&quot; to see if any breakpoints are set at the given address, if you're not interested in which ones they are.</LI>
</UL>
</DIV>
<H4 CLASS="refHeading">
<A NAME="TTCL_f.htm_IX_cache Tcl structure">
 </A>
<A NAME="TTCL_f.htm_83544">
 </A>
cache</H4>
<PRE CLASS="syntax">cache create (lru|fifo) &lt;maxSize&gt; [&lt;flushProc&gt;]
cache destroy &lt;cache&gt; [flush|noflush]
cache lookup &lt;cache&gt; &lt;key&gt;
cache enter &lt;cache&gt; &lt;key&gt;
cache invalone &lt;cache&gt; &lt;entry&gt;
cache invalall &lt;cache&gt; [flush|noflush]
cache key &lt;cache&gt; &lt;entry&gt;
cache size &lt;cache&gt;
cache maxsize &lt;cache&gt;
cache setmaxsize &lt;cache&gt; &lt;maxSize&gt;
cache getval &lt;cache&gt; &lt;entry&gt;
cache setval &lt;cache&gt; &lt;entry&gt; &lt;value&gt;</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG></P>
<DL>
<DT>
&quot;var cache [cache create lru 10]&quot;</DT><DD>
Creates a cache of 10 items that are flushed on a least-recently-used basis. The returned token is saved for later use.</DD>
<DT>
&quot;var entry [cache lookup $cache mom]&quot;</DT><DD>
Sees if an entry with the key &quot;mom&quot; is in the cache and saves its entry token if so.</DD>
<DT>
&quot;echo mom=[cache getval $cache $entry]&quot;</DT><DD>
Retrieves the value stored in the entry for &quot;mom&quot; and echoes it.</DD>
<DT>
&quot;cache invalone $cache $entry&quot;</DT><DD>
Flushes the entry just found from the cache.</DD>
<DT>
&quot;cache destroy $cache&quot;</DT><DD>
Destroys the cache.</DD>
</DL>
<P>
The cache command, as the name implies, maintains a cache of data that is keyed by strings. When a new entry is added to an already-full cache, an existing entry is automatically flushed based on the usage message with which the cache was created: <EM>
lru</EM>
 (last recently used) or <EM>
fifo</EM>
 (first in, first out). If <EM>
lru</EM>
, the least-recently-used entry is flushed; if <EM>
fifo</EM>
, the oldest entry is flushed.</P>
<UL>
<LI>
Unlike the &quot;table&quot; command, the &quot;cache&quot; command returns tokens for entries, not their values. This allows entries to be individually flushed or their values altered.</LI>
<LI>
If a &lt;flushProc&gt; is specified when the cache is created, the procedure will be called each time an entry is flushed from the cache. It will be called &quot;&lt;flushProc&gt; &lt;cache&gt; &lt;entry&gt;&quot; where &lt;cache&gt; is the token for the cache, and &lt;entry&gt; is the token for the entry being flushed.</LI>
<LI>
If the maximum size of a full cache is reduced, entries will be flushed from the cache to bring it down to the new maximum size. The &lt;flushProc&gt; will be called for each of them.</LI>
<LI>
If the values stored in the cache entries should not be freed when the cache is destroyed, pass &quot;noflush&quot; to &quot;cache destroy&quot;. The default is to flush (and hence call the &lt;flushProc&gt;) all entries from the cache before it is destroyed.</LI>
<LI>
If the values stored in the cache entries should not be freed when the cache is flushed, pass &quot;noflush&quot; to &quot;cache invalall&quot;. The default is to call the &lt;flushProc&gt; for each entry in the cache before it is actually flushed.</LI>
<LI>
If an entry is not found in the cache, &quot;cache lookup&quot; will return an empty string.</LI>
<LI>
When an entry is created, &quot;cache enter&quot; returns a 2-list containing the entry token as its first element, and an integer, as its second element, that is either non-zero or 0, to tell if the entry is new or was already present, respectively.</LI>
</UL>



<H4 CLASS="refHeading">
<A NAME="TTCL_f.htm_IX_cbrk Tcl structure:command reference">
 </A>
<A NAME="TTCL_f.htm_IX_Breakpoints:conditional">
 </A>
cbrk</H4>
<PRE CLASS="syntax">
cbrk &lt;addr&gt; &lt;condition&gt;*
cbrk aset &lt;addr&gt; &lt;condition&gt;*
cbrk tset &lt;addr&gt; &lt;condition&gt;*
cbrk clear &lt;break&gt;*
cbrk delete &lt;break&gt;*
cbrk enable &lt;break&gt;*
cbrk disable &lt;break&gt;*
cbrk address &lt;break&gt;
cbrk list [&lt;addr&gt;]
cbrk debug [&lt;flag&gt;]
cbrk isset &lt;addr&gt;
cbrk cond &lt;break&gt; &lt;condition&gt;*
cbrk cmd &lt;break&gt; [&lt;command&gt;]
cbrk delcmd &lt;break&gt; [&lt;command&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;cbrk WinOpen di=1b80h&quot;</DT><DD>
Stops the machine when execution reaches WinOpen() with <CODE>
di</CODE>
 set to 1b80h.</DD>
</DL>
<P>
Allows you to set fast conditional breakpoints.</P>
<UL>
<LI>
All these subcommands function the same as for the &quot;brk&quot; command, with the exception of the &quot;aset&quot; and &quot;tset&quot; commands, which expect the condition for the breakpoint, rather than an associated command. </LI>
<LI>
There are a limited number of these sorts of breakpoints that can be set in the PC (currently 8), so they should be used mostly for heavily-travelled areas of code (e.g. inner loops, or functions like <CODE>
ObjCallMethodTable()</CODE>
 in the kernel). </LI>
<LI>
For more information on the subcommands and the format of arguments, see the documentation for the &quot;brk&quot; command.</LI>
</UL>



<H4 CLASS="refHeading">
<A NAME="TTCL_f.htm_IX_event Tcl structure">
 </A>
<A NAME="TTCL_f.htm_75960">
 </A>
event</H4>
<PRE CLASS="syntax">event &lt;subcommand&gt;</PRE>
<P>
The <CODE>
event</CODE>
 command provides access to Swat's internal events. The subcommands are as follows:</P>
<DL>
<DT>
<CODE>
handle &lt;eventName&gt; &lt;handler&gt; [&lt;data&gt;]</CODE>
</DT><DD>
The &lt;<EM>handler</EM>&gt; procedure is invoked each time an event of type &lt;<EM>eventName</EM>&gt; is dispatched. The handler receives two arguments: an event-specific piece of data, and the given &lt;<EM>data</EM>&gt;. A handler procedure should be declared</DD>
<PRE>proc &lt;handler&gt; {arg data} {&lt;body&gt;}</PRE>

<P>The <CODE>
handle</CODE>
 subcommand returns an &lt;event&gt; for later use in deleting it. The &lt;<EM>handler</EM>&gt; should return one of <CODE>
event_handled</CODE>
, <CODE>
event_not_handled</CODE>
, or <CODE>
event_stop_handling</CODE>
. If it returns <CODE>
event_stop_handling</CODE>
, the event will not be dispatched to any other handlers of the event.</P>
<DT>
<CODE>
delete &lt;event&gt;</CODE>
</DT><DD>
Deletes the given event handler given by the <CODE>
event handle</CODE>
 command.</DD>
<DT>
<CODE>
dispatch &lt;eventName&gt; &lt;arg&gt;</CODE></DT><DD>
Dispatches the given event with the given &lt;<EM>arg</EM>&gt; to all handlers of that event. If &lt;<EM>eventName</EM>&gt; is a pre-defined event type, &lt;<EM>arg</EM>&gt; will be converted to the appropriate type before being dispatched. Otherwise it is passed as a string.</DD>
<DT>
<CODE>
create</CODE>
</DT><DD>Returns a number that represents a new event type. Handlers may then be defined for and events dispatched of the new type.</DD>
<DT>
<CODE>
list</CODE>
</DT><DD>Lists all Tcl-registered events by event-name and handler function.</DD>
<P>
The events which are currently defined are:</P>
<DL>
<DT>
FULLSTOP</DT><DD>
Generated when patient stops for a while. Argument is string telling why the patient stopped.</DD>
<DT>
CONTINUE</DT><DD>
<A NAME="TTCL_f.htm_IX_Stepping through code:swat events">
 </A>
Generated just before the patient is continued. The argument is non-zero if going to single-step.</DD>
<DT>
TRACE</DT><DD>Generated when the execution of a source line completes and the patient is in line-trace mode.</DD>
<DT>
START</DT><DD>Generated when a new patient/thread is created. Argument is patient token of the patient involved.</DD>
<DT>
STACK</DT><DD>Current stack frame has changed. The argument is non-zero if the stack change comes from a change in patients/threads or zero if the change comes from actually going up or down the stack in the current patient.</DD>
<DT>
DETACH</DT><DD>Detaching from the PC. The argument is always zero.</DD>
<DT>
RESET</DT><DD>Returning to the top level. The argument is always zero.</DD>
<DT>
ATTACH</DT><DD>Attached to the PC. The argument is always zero.</DD>
<DT>
RELOAD</DT><DD>Kernel was reloaded. The argument is always zero.</DD>
<DT>
CHANGE</DT><DD>Current patient has changed. The argument is the token for the previous patient.</DD>
<DT>
STEP</DT><DD><A NAME="TTCL_f.htm_IX_Stepping through code:swat events">
 </A>
Machine has stepped a single instruction. The argument is the value to pass to <CODE>
patient stop</CODE>
 if you wish the machine to stay stopped.</DD>
<DT>
STOP</DT><DD>Machine has hit a breakpoint. The argument is the value to pass to <CODE>
patient stop</CODE>
 if you wish the machine to stay stopped.</DD>
<DT>
INT</DT><DD>Machine has hit some other interrupt that's being caught. The argument is the interrupt number. The machine will remain stopped unless it is continued with continue-patient.</DD>

</DL>
</DL>
<H4 CLASS="refHeading">
<A NAME="TTCL_f.htm_IX_handle Tcl structure">
 </A>
<A NAME="TTCL_f.htm_91007">
 </A>
handle</H4>
<PRE CLASS="syntax">
handle lookup &lt;id&gt;
handle find &lt;address&gt;
handle all
handle nointerest &lt;interest-record&gt;
handle interest &lt;handle&gt; &lt;proc&gt; [&lt;data&gt;+]
handle segment &lt;handle&gt;
handle size &lt;handle&gt;
handle state &lt;handle&gt;
handle owner &lt;handle&gt;
handle patient &lt;handle&gt;
handle other &lt;handle&gt;
handle id &lt;handle&gt;
handle isthread &lt;handle&gt;
handle iskernel &lt;handle&gt;
handle isfile &lt;handle&gt;
handle isvm &lt;handle&gt;
handle ismem &lt;handle&gt;</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;handle lookup [read-reg bx]&quot;</DT><DD>
get the handle token for the handle whose ID is in the BX register.</DD>
<DT>
&quot;handle interest $h ob-interest-proc [concat si=$chunk $message]&quot;</DT><DD>
call ob-interest-proc, passing the list {si=$chunk $message}, whenever the state of the handle whose token is in $h changes.</DD>
<DT>
<A NAME="TTCL_f.htm_Handle">
 </A>
&quot;handle patient $h&quot;</DT><DD>
get the token for the patient that owns the handle whose token is in $h</DD>
<DT>
&quot;handle all&quot;</DT><DD>
get the list of the ID's of all handles currently in Swat's handle table.</DD>
</DL>
<P>
The &quot;handle&quot; command provides access to the structures Swat uses to track memory and thread allocation on the PC.</P>
<UL>
<LI>
As with most other commands that deal with Swat structures, you use this one by calling a lookup function (the &quot;lookup&quot; and &quot;find&quot; subcommands) to obtain a token that you use for further manipulations. A handle token is also returned by a few other commands, such as addr-parse.</LI>
<LI>
Handle tokens are valid only until the machine is continued. If you need to keep the token for a while, you will need to register interest in the handle using the &quot;interest&quot; subcommand. Most handles tokens will simply be cached while the machine is stopped and flushed from the cache when the machine continues. Only those handles for which all state changes must be known remain in Swat's handle table. For example, when a conditional breakpoint has been registered with the stub using the segment of a handle, the condition for that breakpoint must be updated immediately should the memory referred to by the handle be moved, swapped or discarded. Keeping the number of tracked handles low reduces the number of calls the stub must make to tell Swat about handle-state changes.</LI>
<LI>
The &lt;id&gt; passed to the &quot;lookup&quot; subcommand is an integer. Its default radix is decimal, but you can specify the radix to use in all the usual ways. The value returned is the token to use to obtain further information about the handle.</LI>
<LI>
&quot;handle size&quot; returns the number of bytes allocated to the handle.</LI>
<LI>
&quot;handle segment&quot; returns the handle's segment (if it's resident) in decimal, as it's intended for use by Tcl programs, not people.</LI>
<LI>
&quot;handle owner&quot; returns the token of the handle that owns the given handle, not its ID.</LI>
<LI>
&quot;handle all&quot; returns a list of handle ID numbers not a list of handle tokens. The list is only those handles currently known to Swat.</LI>
<LI>
&quot;handle interest&quot; tells Swat you wish to be informed when the handle you pass changes state in some way. The procedure &lt;proc&gt; will be called with two or more arguments. The first is the token of the handle whose state has changed, and the second is the state change the handle has undergone, taken from the following set of strings:</LI>
<DL>
<DT>
<STRONG>
swapin</STRONG>
</DT><DD>Block swapped in from disk/memory</DD>
<DT>
<STRONG>
load</STRONG>
</DT><DD>Resource freshly loaded from disk</DD>
<DT>
<STRONG>
swapout</STRONG>
</DT><DD>Block swapped to disk/memory</DD>
<DT>
<STRONG>
discard</STRONG>
</DT><DD>Block discarded</DD>
<DT>
<STRONG>
resize</STRONG>
</DT><DD>Block changed size and maybe moved</DD>
<DT>
<STRONG>
move</STRONG>
</DT><DD>Block moved on heap</DD>
<DT>
<STRONG>
free</STRONG>
</DT><DD>Block has been freed</DD>
<DT>
<STRONG>
fchange</STRONG>
</DT><DD>Block's <CODE>
HeapFlags</CODE>
 changed</DD>
</DL>
<P>
Any further arguments are taken from the &lt;data&gt;+ arguments provided when you expressed interest in the handle. This subcommand returns a token for an interest record that you pass to &quot;handle nointerest&quot; when you no longer care about the handle. When the block is freed (the state change is &quot;free&quot;), there is no need to call &quot;handle nointerest&quot; as the interest record is automatically deleted.</P>
<LI>
&quot;handle state&quot; returns an integer indicating the state of the handle. The integer is a mask of bits that mean different things:<BR>

<IMG SRC="StateBlockInfo.gif"></LI>

<P>
When the integer is AND-ed with the mask for Type (0xf8000), the following values indicate the following types of handles:<BR>
<IMG SRC="StateBlockType.gif">

</P>
<LI>
&quot;handle other&quot; returns the handle's otherInfo field. Note: This isn't necessarily the otherInfo field from the PC. E.g., for resource handles, it's the symbol token of the module for the handle.</LI>
</UL>

<H4 CLASS="refHeading">
<A NAME="TTCL_f.htm_IX_Patients:patient Tcl structure">
 </A>
<A NAME="TTCL_f.htm_IX_patient Tcl structure">
 </A>
<A NAME="TTCL_f.htm_45242">
 </A>
patient</H4>
<PRE CLASS="syntax">
patient find &lt;name&gt;
patient name [&lt;patient&gt;]
patient fullname [&lt;patient&gt;]
patient data [&lt;patient&gt;]
patient threads [&lt;patient&gt;]
patient resources [&lt;patient&gt;] 
patient libs [&lt;patient&gt;]
patient path [&lt;patient&gt;]
patient all
patient stop [&lt;addr&gt;]</PRE>

<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
 &quot;patient find geos&quot; </DT><DD>
Returns the patient token for the kernel, if it's been loaded yet.</DD>
<DT>
 &quot;patient fullname $p&quot;</DT><DD>
 Returns the permanent name for the patient whose token is stored in the variable p.</DD>
<DT>
 &quot;patient stop $data&quot; </DT><DD>
Tells the dispatcher of the STEP event that it should keep the machine stopped when the STEP event has been handled by everyone.</DD>
</DL>
<P>
This command provides access to the various pieces of information that are maintained for each patient (geode) loaded by GEOS.</P>
<UL>
<LI>
Subcommands may be abbreviated uniquely.</LI>
<LI>
Swat always has the notion of a &quot;current patient&quot;, whose name is displayed in the prompt. It is this patient that is used if you do not provide a token to one of the subcommands that accepts a patient token.</LI>
<LI>
&quot;patient name&quot; returns the name of a patient. The name is the non- extension portion of the geode's permanent name. It will have a number added to it if more than one instance of the geode is active on the PC. Thus, if two GeoWrites are active, there will be two patients in Swat: &quot;write&quot; and &quot;write2&quot;.</LI>
<LI>
&quot;patient fullname&quot; returns the full permanent name of the patient. It is padded with spaces to make up a full 12-character string. This doesn't mean you can obtain the non-extension part by extracting the 0th element of the result with the &quot;index&quot; command, however; you'll have to use the &quot;range&quot; command to get the first 8 characters, then use &quot;index&quot; to trim the trailing spaces off, if you want to.</LI>
<LI>
<A NAME="TTCL_f.htm_IX_Threads:current within patient">
 </A>
&quot;patient data&quot; returns a three-element list: {&lt;name&gt; &lt;fullname&gt; &lt;thread-number&gt;} &lt;name&gt; and &lt;fullname&gt; are the same as returned by the &quot;name&quot; and &quot;fullname&quot; subcommands. &lt;thread-number&gt; is the number of the current thread for the patient. Each patient has a single thread that is the one the user looked at most recently, and that is its current thread. The current thread of the current patient is, of course, the current thread for the whole debugger.</LI>
<LI>
&quot;patient threads&quot; returns a list of tokens, one for each of the patient's threads, whose elements can be passed to the &quot;thread&quot; command to obtain more information about the patient's threads (such as their numbers, handle IDs, and the contents of their registers).</LI>
<LI>
&quot;patient resources&quot; returns a list of tokens, one for each of the patient's resources, whose elements can be passed to the &quot;handle&quot; command to obtain more information about the patient's resources (for example, their names and handle IDs).</LI>
<LI>
&quot;patient libs&quot; returns a list of patient tokens, one for each of the patient's imported libraries. The kernel has all the loaded device drivers as its &quot;imported&quot; libraries.</LI>
<LI>
&quot;patient path&quot; returns the absolute path of the patient's executable.</LI>
<LI>
&quot;patient all&quot; returns a list of the tokens of all the patients known to Swat.</LI>
<LI>
&quot;patient stop&quot; is used only in STEP, STOP and START event handlers to indicate you want the machine to remain stopped once the event has been dispatched to all interested parties. &lt;addr&gt; is the argument passed in the STEP and STOP events. A START event handler should pass nothing.</LI>
<LI>
A number of other commands provide patient tokens. &quot;patient find&quot; isn't the only way to get one.</LI>
</UL>



<H4 CLASS="refHeading">
<A NAME="TTCL_f.htm_IX_Source code:src Tcl structure">
 </A>
<A NAME="TTCL_f.htm_IX_src Tcl structure">
 </A>
<A NAME="TTCL_f.htm_12400">
 </A>
src</H4>
<PRE CLASS="syntax">
src line &lt;addr&gt;
src read &lt;file&gt; &lt;line&gt;
src cache [&lt;max&gt;]
src addr &lt;file&gt; &lt;line&gt; [&lt;patient&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;src line cs:ip&quot;</DT><DD>
Returns a two-list holding the source-line number, and the absolute path of the file in which it lies (not in this order), that encompasses CS:IP.</DD>
<DT>
&quot;src read /pcgeos/appl/sdk_c/hello/hello.goc 64&quot;</DT><DD>
Reads the single given source line from the given file.</DD>
<DT>
&quot;src addr icdecode.c 279&quot;</DT><DD>
Returns an address-list for the start of the code produced for the given line.</DD>
<DT>
&quot;src cache 10&quot;</DT><DD>
Allow 10 source files to be open at a time. This is the default.</DD>
</DL>
<P>
The &quot;src&quot; command allows the Tcl programmer to manipulate the source- line maps contained in all the geodes' symbol files.</P>
<UL>
<LI>
The &quot;src line&quot; commands returns its list as {&lt;file&gt; &lt;line&gt;}, with the &lt;file&gt; being absolute. If no source line can be found, the empty list is returned.</LI>
<LI>
The &lt;file&gt; given to the &quot;src read&quot; command must be absolute, as the procedure using this command may well be wrong as to Swat's current directory. Typically this name will come from the return value of a &quot;src line&quot; command, so you needn't worry.</LI>
<LI>
The line returned by &quot;src read&quot; contains no tabs and does not include the line terminator for the line (the &lt;lf&gt; for UNIX, or the &lt;cr&gt;&lt;lf&gt; pair for MS-DOS).</LI>
<LI>
&quot;src addr&quot; returns an address-list, as returned from &quot;addr-parse&quot;, not an address expression, as you would <EM>
pass</EM>
 to &quot;addr-parse&quot;. If the &lt;file&gt; and &lt;line&gt; cannot be mapped to an address, the result will be the empty list.</LI>
<LI>
The &lt;file&gt; given to &quot;src addr&quot; must be the name that was given to the assembler/compiler. This includes any leading path if the file wasn't in the current directory when the assembler/compiler was run.</LI>
<LI>
&quot;src cache&quot; returns the current (or new) number of open files that are cached.</LI>
</UL>



<H4 CLASS="refHeading">
<A NAME="TTCL_f.htm_IX_symbol Tcl structure">
 </A>
<A NAME="TTCL_f.htm_39641">
 </A>
symbol</H4>

<PRE CLASS="syntax">
symbol find &lt;class&gt; &lt;name&gt; [&lt;scope&gt;]
symbol faddr &lt;class&gt; &lt;addr&gt;
symbol match &lt;class&gt; &lt;pattern&gt;
symbol scope &lt;symbol&gt;
symbol name &lt;symbol&gt;
symbol fullname &lt;symbol&gt;
symbol class &lt;symbol&gt;
symbol type &lt;symbol&gt;
symbol get &lt;symbol&gt;
symbol patient &lt;symbol&gt;
symbol tget &lt;symbol&gt;
symbol addr &lt;symbol&gt;
symbol foreach &lt;scope&gt; &lt;class&gt; &lt;callback&gt; [&lt;data&gt;]</PRE>

<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;symbol find type LMemType&quot;</DT><DD>
Locate a type definition named LMemType</DD>
<DT>
&quot;symbol faddr proc cs:ip&quot;</DT><DD>
Locate the procedure in which CS:IP lies.</DD>
<DT>
&quot;symbol faddr {proc label} cs:ip&quot;</DT><DD>
Locate the procedure or label just before cs:ip.</DD>
<DT>
&quot;symbol fullname $sym&quot;</DT><DD>
Fetch the full name of the symbol whose token is in the $sym variable.</DD>
<DT>
&quot;symbol scope $sym&quot;</DT><DD>
Fetch the token of the scope containing the passed symbol. This will give the structure containing a structure field, or the procedure containing a local variable, for example.</DD>
</DL>
<P>
Provides information on the symbols for all currently-loaded patients. Like many of Swat's commands, this operates by using a lookup function (the &quot;find&quot;, &quot;faddr&quot;, &quot;match&quot;, or &quot;foreach&quot; subcommands) to obtain a token for a piece of data that's internal to Swat. Given this token, you then use the other subcommands (such as &quot;name&quot; or &quot;get&quot;) to obtain information about the symbol you looked up.</P>
<UL>
<LI>
There are many types of symbols that have been grouped into classes that may be manipulated with this command. For a list of the symbol types and their meaning, type &quot;help symbol-types&quot;. The type of a symbol can be obtained with the &quot;symbol type&quot; command.</LI>
<LI>
The symbol classes are as follows:</LI>
<DL>
<DT>
<STRONG>
type</STRONG>
</DT><DD>describes any structured type: typedef, struct, record, etype, union. Symbols of this class may also be used in place of type tokens (see the &quot;type&quot; command).</DD>
<DT>
<STRONG>
field</STRONG>
</DT><DD>describes a field in a structured type: field, bitfield.</DD>
<DT>
<STRONG>
enum</STRONG>
</DT><DD>describes a member of an enumerated type: enum, message.</DD>
<DT>
<STRONG>
const</STRONG>
</DT><DD>a constant defined with EQU: <EM>
const</EM>
.</DD>
<DT>
<STRONG>
var</STRONG>
</DT><DD>describes any variable symbol: var, chunk, locvar, class, masterclass, variantclass.</DD>
<DT>
<STRONG>
locvar</STRONG>
 </DT><DD>describes any local variable symbol: locvar, locstatic.</DD>
<DT>
<STRONG>
scope</STRONG>
</DT><DD>describes any symbol that holds other symbols within it: module, proc, blockstart, struct, union, record, etype.</DD>
<DT>
<STRONG>
proc</STRONG>
</DT><DD>describes only proc symbols.</DD>
<DT>
<STRONG>
label</STRONG>
</DT><DD>describes any code-related symbol: label, proc, loclabel.</DD>
<DT>
<STRONG>
onstack</STRONG>
</DT><DD>describes only symbols created by the directive.</DD>
<DT>
<STRONG>
module</STRONG>
 </DT><DD>describes only segment/group symbols.</DD>
<DT>
<STRONG>
profile</STRONG>
</DT><DD>describes a symbol that marks where profiling code was inserted by a compiler or assembler.</DD>
</DL>
<LI>
The &lt;class&gt; argument for the &quot;find&quot;, &quot;faddr&quot; and &quot;match&quot; subcommands may be a single class, or a space-separated list of classes. For example, &quot;symbol faddr {proc label} CS:IP&quot; would find the symbol closest to CS:IP (but whose address is still below or equal to CS:IP) that is either a procedure or a label.</LI>
<LI>
The &quot;symbol find&quot; command locates a symbol given its name (which may be a symbol path).</LI>
<LI>
The &quot;symbol faddr&quot; command locates a symbol that is closest to the passed address.</LI>
<LI>
A symbol's &quot;fullname&quot; is the symbol path, from the current patient, that uniquely identifies the symbol. Thus if a procedure-local variable belongs to the current patient, the fullname would be<BR>
 &lt;segment&gt;::&lt;procedure&gt;::&lt;name&gt;<BR>
 where &lt;segment&gt; is the segment holding the &lt;procedure&gt;, which is the procedure for which the local variable named &lt;name&gt; is defined.</LI>
<LI>
<A NAME="TTCL_f.htm_IX_Patients:name in symbols">
 </A>
You can force the prepending of the owning patient to the fullname by passing &lt;with-patient&gt; as a non-empty argument (&quot;yes&quot; or &quot;1&quot; are both fine arguments, as is &quot;with-patient&quot;).</LI>
<LI>
The &quot;symbol get&quot; commands provides different data for each symbol class, as follows:</LI>
<DL>
<DT>
var, locvar, chunk: {&lt;addr&gt; &lt;sclass&gt; &lt;type&gt;}</DT><DD>
&lt;addr&gt; is the symbol's address as for the &quot;addr&quot; subcommand, &lt;sclass&gt; is the storage class of the variable and is one of static (a statically allocated variable), lmem (an lmem chunk), local (a local variable below the frame pointer), param (a local variable above the frame pointer), or reg (a register variable; address is the machine register number -- and index into the list returned by the &quot;current-registers&quot; command).</DD>
<DT>
<A NAME="TTCL_f.htm_IX_Objects:as Tcl symbols">
 </A>
object class: {&lt;addr&gt; &lt;sclass&gt; &lt;type&gt; &lt;flag&gt; &lt;super&gt;}</DT><DD>
first three elements same as for other variables. &lt;flag&gt; is &quot;variant&quot; if the class is a variant class, &quot;master&quot; if the class is a master class, or empty if the class is nothing special. &lt;super&gt; is the symbol token of the class's superclass.</DD>
<DT>
label-class: {&lt;addr&gt; (near|far)}</DT><DD>
&lt;addr&gt; is the symbol's address as for the &quot;addr&quot; subcommand. The second element is &quot;near&quot; or &quot;far&quot; depending on the type of label involved.</DD>
<DT>
field-class: {&lt;bit-offset&gt; &lt;bit-width&gt; &lt;field-type&gt; &lt;struct-type&gt;}</DT><DD>
&lt;bit-offset&gt; is the offset of the field from the structure/union/record's base expressed in bits. &lt;bit-width&gt; is the width of the field, in bits. &lt;field-type&gt; is the type for the field itself, while &lt;struct-type&gt; is the token for the containing structured type.</DD>
<DT>
const: {&lt;value&gt;}</DT><DD>
&lt;value&gt; is just the symbol's value.</DD>
<DT>
enum-class: {&lt;value&gt; &lt;etype&gt;}</DT><DD>
&lt;value&gt; is the symbol's value. &lt;etype&gt; is the enumerated type's symbol.</DD>
<DT>
blockstart, blockend: {&lt;addr&gt;}</DT><DD>
&lt;addr&gt; is the address bound to the symbol.</DD>
<DT>
onstack: {&lt;addr&gt; &lt;data&gt;}</DT><DD>
&lt;addr&gt; is the address at which the ON_STACK was declared. &lt;data&gt; is the arguments given to the ON_STACK directive.</DD>
<DT>
module: {&lt;patient&gt;}</DT><DD>
&lt;patient&gt; is the token for the patient owning the module.</DD>
</DL>
<LI>
A related command, &quot;symbol tget&quot; will fetch the type token for symbols that have data types (var-, field- and enum-class symbols).</LI>
<LI>
&quot;symbol addr&quot; can be used to obtain the address of symbols that actually have one (var-, locvar- and label-class symbols). For locvar symbols, the address is an offset from the frame pointer (positive or negative). For var- and label-class symbols (remember that a procedure is a label-class symbols), the returned integer is the offset of the symbol within its segment.</LI>
<LI>
&quot;symbol patient&quot; returns the token of the patient to which the symbol belongs.</LI>
<LI>
&quot;symbol foreach&quot; will call the &lt;callback&gt; procedure for each symbol in &lt;scope&gt; (a symbol token) that is in one of the classes given in the list &lt;class&gt;. The first argument will be the symbol token itself, while the second argument will be &lt;data&gt;, if given. If &lt;data&gt; wasn't provided, &lt;callback&gt; will receive only 1 argument. &lt;callback&gt; should return 0 to continue iterating, or non-zero to stop. A non-integer return is assumed to mean stop. &quot;symbol foreach&quot; returns whatever the last call to &lt;callback&gt; returned.</LI>
<LI>
By default, &quot;symbol scope&quot; will return the physical scope of the symbol. The physical scope of a symbol is the symbol for the segment in which the symbol lies, in contrast to the lexical scope of a symbol, which is where the name of the symbol lies. The two scopes correspond for all symbols but static variables local to a procedure. To obtain the lexical scope of a symbol, pass &lt;lexical&gt; as a non-zero number.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/Tcl/TTCL_f.htm#IX_type Tcl structure">type</A>.



<H4 CLASS="refHeading">
<A NAME="TTCL_f.htm_IX_table Tcl structure">
 </A>
<A NAME="TTCL_f.htm_19266">
 </A>
table</H4>
<PRE CLASS="syntax">
table create [&lt;initBuckets&gt;]
table destroy &lt;table&gt;
table enter &lt;table&gt; &lt;key&gt; &lt;value&gt;
table lookup &lt;table&gt; &lt;key&gt;
table remove &lt;table&gt; &lt;key&gt;</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;var kitchen [table create 32]&quot;</DT><DD>
Create a new table with 32 hash buckets initially.</DD>
<DT>
&quot;table enter $t tbrk3 {1 2 3}&quot;</DT><DD>
Enter the value &quot;1 2 3&quot; under the key &quot;tbrk3&quot; in the table whose token is stored in the variable t.</DD>
<DT>
&quot;table lookup $t tbrk4&quot; </DT><DD>
Fetch the value, if any, stored under the key &quot;tbrk4&quot; in the table whose token is stored in the variable t.</DD>
<DT>
&quot;table remove $t tbrk3&quot; </DT><DD>
Remove the data stored in the table, whose token is stored in the variable t, under the key &quot;tbrk3&quot;</DD>
<DT>
&quot;table destroy $t&quot; </DT><DD>
Destroy the table $t and all the data stored in it.</DD>
</DL>

<PRE>(mess1:0) 159 =&gt; <STRONG>var yearTable [table create]
</STRONG>(mess1:0) 160 =&gt; <STRONG>table enter $yearTable synclavier 1979
</STRONG>(mess1:0) 161 =&gt; <STRONG>table enter $yearTable moog 1966
</STRONG>(mess1:0) 162 =&gt; <STRONG>table lookup $yearTable synclavier
</STRONG>1979
(mess1:0) 163 =&gt; <STRONG>var yearTable
</STRONG>1403188
(mess1:0) 164 =&gt; <STRONG>table lookup 1403188 moog
</STRONG>1966
(mess1:0) 165 =&gt; <STRONG>table remove $yearTable synclavier
</STRONG>(mess1:0) 166 =&gt; <STRONG>table lookup $yearTable synclavier
</STRONG>nil
(mess1:0) 167 =&gt; <STRONG>table destroy $yearTable</STRONG></PRE>
<P>
The &quot;table&quot; command is used to create, manipulate and destroy hash tables. The entries in the table are keyed on strings and contain strings, as you'd expect from Tcl.</P>
<UL>
<LI>
The &lt;<EM>
initBuckets</EM>
&gt; parameter to &quot;table create&quot; is set based on the number of keys you expect the table to have at any given time. The number of buckets will automatically increase to maintain hashing efficiency, should the need arise, so &lt;<EM>
initBuckets</EM>
&gt; isn't a number that need be carefully chosen. It's best to start with the default (16) or perhaps a slightly larger number.</LI>
<LI>
If no data are stored in the table under &lt;<EM>
key</EM>
&gt;, &quot;table lookup&quot; will return the string &quot;nil&quot;, for which you can test with the &quot;null&quot; command.</LI>
</UL>



<H4 CLASS="refHeading">
<A NAME="TTCL_f.htm_IX_Threads:thread Tcl structure">
 </A>
<A NAME="TTCL_f.htm_IX_thread Tcl structure">
 </A>
<A NAME="TTCL_f.htm_IX_Registers:value within thread">
 </A>
<A NAME="TTCL_f.htm_31438">
 </A>
thread</H4>
<PRE CLASS="syntax">
thread id &lt;thread&gt;
thread register &lt;thread&gt; &lt;regName&gt;
thread handle &lt;thread&gt;
thread endstack &lt;thread&gt;
thread number &lt;thread&gt;
thread all</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;thread register $t cx&quot; </DT><DD>
Fetches the value for the CX register for the given thread.
</DD>
<DT>
&quot;thread number $t&quot;</DT><DD>
Fetches number swat assigned to thread when it was first encountered.</DD>
</DL>
<PRE>(mess1:0) 145 =&gt; <STRONG>patient threads
</STRONG>2667104
(mess1:0) 146 =&gt; <STRONG>thread id 2667104
</STRONG>11184
(mess1:0) 147 =&gt; <STRONG>thread all
</STRONG>767532 756068 1348520 1348868 1349216 1349748 1350236 1402096 1079392 2667104
(mess1:0) 148 =&gt; <STRONG>thread handle 756068
</STRONG>880428
(mess1:0) 149 =&gt; <STRONG>thread number 756068
</STRONG>0</PRE>
<P>
Returns information about a thread, given its thread token. Thread tokens can be obtained via the &quot;patient threads&quot; command, or the &quot;handle other&quot; command applied to a thread handle's token.</P>
<UL>
<LI>
Subcommands may be abbreviated uniquely.
</LI>
<LI>
&quot;thread id&quot; returns the handle ID, in decimal, of the thread's handle. This is simply a convenience.
</LI>
<LI>
&quot;thread register&quot; returns the contents of the given register in the thread when it was suspended. All registers except &quot;pc&quot; are returned as a single decimal number. &quot;pc&quot; is returned as two hexadecimal numbers separated by a colon, being the cs:ip for the thread. Note that GEOS doesn't actually save the AX and BX registers when it suspends a thread, at least not where Swat can consistently locate them. These registers will always hold 0xadeb unless the thread is the current thread for the machine (as opposed to the current thread for swat).</LI>
<LI>
&quot;thread handle&quot; returns the token for the thread's handle.</LI>
<LI>
<A NAME="TTCL_f.htm_IX_Stack:thread stack size">
 </A>
&quot;thread endstack&quot; returns the maximum value SP can hold for the thread, when it is operating off its own stack. Swat maintains this value so it knows when to give up trying to decode the stack. </LI>
<LI>
&quot;thread number&quot; returns the decimal number Swat assigned the thread when it first encountered it. The first thread for each patient is given the number 0 with successive threads being given the highest thread number known for the patient plus one. </LI>
<LI>
&quot;thread all&quot; returns a list of tokens for all the threads known to Swat (for all patients).</LI>
</UL>

<H4 CLASS="refHeading">
<A NAME="TTCL_f.htm_IX_type Tcl structure">
 </A>
<A NAME="TTCL_f.htm_75688">
 </A>
type</H4>
<PRE CLASS="syntax">
type &lt;basic-type-name&gt; 
type make array &lt;length&gt; &lt;base-type&gt;
type make pstruct (&lt;field&gt; &lt;type&gt;)+
type make struct (&lt;field&gt; &lt;type&gt; &lt;bit-offset&gt; &lt;bit-length&gt;)+
type make union (&lt;field&gt; &lt;type&gt;)+
type make &lt;ptr-type&gt; &lt;base-type&gt;
type delete &lt;type&gt;
type size &lt;type&gt;
type class &lt;type&gt;
type name &lt;type&gt; &lt;var-name&gt; &lt;expand&gt;
type aget &lt;array-type&gt;
type fields &lt;struct-type&gt;
type members &lt;enum-type&gt;
type pget &lt;ptr-type&gt;
type emap &lt;num&gt; &lt;enum-type&gt;
type signed &lt;type&gt;
type field &lt;struct-type&gt; &lt;offset&gt;
type bfget &lt;bitfield-type&gt; </PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
 &quot;type word&quot; </DT><DD>Returns a type token for a word (2-byte unsigned quantity).</DD>
<DT>
 &quot;type make array 10 [type char]&quot;</DT><DD>
 Returns a type token for a 10-character array.</DD>
<DT>
<A NAME="TTCL_f.htm_IX_optr:returning Tcl type token for">
 </A>
 &quot;type make optr [symbol find type GenBase]&quot;</DT><DD>
 Returns a type token for an optr (4-byte global/local handle pair) to a &quot;GenBase&quot; structure.</DD>
</DL>
<P>
Provides access to the type descriptions by which all PC-based data are manipulated in Swat, and allows a Tcl procedure to obtain information about a type for display to the user, or for its own purposes. As with other Swat commands, this works by calling one subcommand to obtain an opaque &quot;type token&quot;, which you then pass to other commands.</P>
<UL>
<LI>
Type tokens and symbol tokens for type-class symbols may be freely interchanged anywhere in Swat.</LI>
<LI>
 There are 11 predefined basic types that can be given as the &lt;basic-type-name&gt; argument in &quot;type &lt;basic-type-name&gt;&quot;. They are: byte (single-byte unsigned integer), char (single-byte character), double (eight-byte floating-point), dword (four-byte unsigned integer), float (four-byte floating-point), int (two-byte signed integer), long (four-byte signed integer), sbyte (single-byte signed integer), short (two-byte signed integer), void (nothing. useful as the base type for a pointer type), and word (two-byte unsigned integer)</LI>
<LI>
Most type tokens are obtained, via the &quot;symbol get&quot; and &quot;symbol tget&quot; commands, from symbols that are defined for a loaded patient. These are known as &quot;external&quot; type descriptions. &quot;Internal&quot; type descriptions are created with the &quot;type make&quot; command and should be deleted, with &quot;type delete&quot; when they are no longer needed.</LI>
<LI>
<A NAME="TTCL_f.htm_IX_Structures:creating">
 </A>
An internal structure type description can be created using either the &quot;pstruct&quot; (packed structure) or &quot;struct&quot; subcommands. Using &quot;pstruct&quot; is simpler, but you have no say in where each field is placed (they are placed at sequential offsets with no padding between fields), and all fields must be a multiple of 8 bits long. The &quot;struct&quot; subcommand is more complex, but does allow you to specify bitfields.</LI>
<LI>
&quot;type make pstruct&quot; takes 1 or more pairs of arguments of the form &quot;&lt;field&gt; &lt;type&gt;&quot;, where &lt;field&gt; is the name for the field and &lt;type&gt; is a type token giving the data type for the field. All fields must be specified for the structure in this call; fields cannot be appended to an existing type description.</LI>
<LI>
&quot;type make struct&quot; takes 1 or more 4-tuples of arguments of the form &quot;&lt;field&gt; &lt;type&gt; &lt;bit-offset&gt; &lt;bit-length&gt;&quot;. &lt;field&gt; is the name of the field, and &lt;type&gt; is its data type. &lt;bit-offset&gt; is the offset, in bits, from the start of the structure (starting with 0, as you'd expect). &lt;bit-length&gt; is the length of the field, in bits (starting with 1, as you'd expect). For a bitfield, &lt;type&gt; should be the field within which the bitfield is defined. For example, the C declaration: </LI>
<PRE> struct {
     word a:6;
     word b:10;
     word c;
  }</PRE>
<P>would result in the command &quot;type make struct a [type word] 0 6 b [type word] 6 10 c [type word] 16 16&quot;, because a and b are defined within a word type, and c is itself a word.</P>
<LI>
<A NAME="TTCL_f.htm_IX_Unions in Swat:creating">
 </A>
&quot;type make union&quot; is similar to &quot;type make pstruct&quot;, except all fields start at offset 0. Like &quot;pstruct&quot;, this cannot be used to hold bitfields, except by specifying a type created via &quot;type make struct&quot; command as the &lt;type&gt; for one of the fields.</LI>
<LI>
<A NAME="TTCL_f.htm_IX_Arrays in Swat:creating">
 </A>
&quot;type make array &lt;length&gt; &lt;base-type&gt;&quot; returns a token for an array of &lt;length&gt; elements of the given &lt;base-type&gt;, which may be any valid type token, including another array type.</LI>
<LI>
&quot;type make &lt;ptr-type&gt; &lt;base-type&gt;&quot; returns a token for a pointer to the given &lt;base-type&gt;. There are several different classes of pointers in GEOS:</LI>
<DL>
<DT>
          <STRONG>
nptr</STRONG>
 </DT><DD>a near pointer. 16-bits. points to something in the same segment as the pointer itself.</DD>
<DT>
          <STRONG>
fptr</STRONG>
</DT><DD>a far pointer. 32-bits. segment in high word, offset in the low.</DD>
<DT>
          <STRONG>
sptr</STRONG>
 </DT><DD>a segment pointer. 16-bits. contains a segment only.</DD>
<DT>
          <STRONG>
lptr</STRONG>
 </DT><DD>an lmem pointer. 16-bits. contains a local-memory &quot;chunk handle&quot;. data pointed to is assumed to be in the same segment as the lptr itself, but requires two indirections to get to it.</DD>
<DT>
           <STRONG>
hptr</STRONG>
</DT><DD>a handle pointer. 16-bits. a GEOS handle.</DD>
<DT>
           <STRONG>
optr</STRONG>
 </DT><DD>an object pointer. 32-bits. contains a GEOS memory handle in the high word, and a GEOS local-memory chunk handle in the low.</DD>
<DT>
           <STRONG>
vptr</STRONG>
</DT><DD>a VM pointer. Its 32 bits contain a GEOS file handle in the high word and a GEOS VM block handle in the low word.</DD>
<DT>
           <STRONG>
vfptr</STRONG>
</DT><DD>a virtual far pointer. Its 32 bits contain a virtual segment in the high word and an offset in the low.</DD>
</DL>
<LI>
&quot;type delete&quot; is used to delete a type description created by &quot;type make&quot;. You should do this whenever possible to avoid wasting memory.</LI>
<LI>
Any type created by the &quot;type make&quot; command is subject to garbage collection unless it is registered with the garbage collector. If you need to keep a type description beyond the end of the command being executed, you must register it. See the &quot;gc&quot; command for details.</LI>
<LI>
&quot;type size&quot; returns the size of the passed type, in bytes.</LI>
<LI>
&quot;type class&quot; returns the class of a type, a string in the following set:</LI>
<DL>
<DT>
<STRONG>
char</STRONG>
 </DT><DD>for the basic &quot;char&quot; type only.</DD>
<DT>
<STRONG>
int</STRONG>
 </DT><DD>any integer, signed or unsigned.</DD>
<DT>
<STRONG>
struct</STRONG>
 </DT><DD>a structure, record, or union.</DD>
<DT>
<STRONG>
enum</STRONG>
 </DT><DD>an enumerated type.</DD>
<DT>
<STRONG>
array</STRONG>
</DT><DD>an array, of course,</DD>
<DT>
<STRONG>
pointer</STRONG>
 </DT><DD>a pointer to another type.</DD>
<DT>
<STRONG>
void</STRONG>
 </DT><DD>nothingness. Often a base for a pointer.</DD>
<DT>
<STRONG>
function</STRONG>
</DT><DD> a function, used solely as a base for a pointer.</DD>
<DT>
<STRONG>
float</STRONG>
 </DT><DD>a floating-point number.</DD>
</DL>
<LI>
 Each type class has certain data associated with it that can only be obtained by using the proper subcommand.</LI>
<LI>
<A NAME="TTCL_f.htm_IX_Arrays in Swat:examining">
 </A>
&quot;type aget&quot; applies only to an array-class type token. It returns a four-element list: {&lt;base-type&gt; &lt;low&gt; &lt;high&gt; &lt;index-type&gt;} &lt;base-type&gt; is the type token describing elements of the array. &lt;low&gt; is the lower bound for an index into the array (currently always 0), &lt;high&gt; is the inclusive upper bound for an index into the array, and &lt;index-type&gt; is a token for the data type that indexes the array (currently always [type int]).</LI>
<LI>
&quot;type fields&quot; applies only to a struct-class type token. It returns a list of four-tuples {&lt;name&gt; &lt;offset&gt; &lt;length&gt; &lt;type&gt;}, one for each field in the structure. &lt;offset&gt; is the <EM>
bit</EM>
 offset from the start of the structure, while &lt;length&gt; is the length of the field, again in <EM>
bits</EM>
. &lt;type&gt; is the token for the data type of the field, and &lt;name&gt; is, of course, the field's name.</LI>
<LI>
&quot;type members&quot; applies only to an enum-class type token. It returns a list of {&lt;name&gt; &lt;value&gt;} pairs for the members of the enumerated type. </LI>
<LI>
&quot;type pget&quot; applies only to a pointer-class type token. It returns the type of pointer (&quot;near&quot;, &quot;far&quot;, &quot;seg&quot;, &quot;lmem&quot;, &quot;handle&quot;, or &quot;object&quot;) and the token for the type to which it points.</LI>
<LI>
&quot;type bfget&quot; returns a three-list for the given bitfield type: {&lt;offset&gt; &lt;width&gt; &lt;is-signed&gt;}</LI>
<LI>
&quot;type signed&quot; returns non-zero if the type is signed. If the &lt;type&gt; is not an int-class type, it is considered unsigned.</LI>
<LI>
&quot;type emap&quot; can be used to map an integer to its corresponding enumerated constant. If no member of the enumerated type described by &lt;type&gt; has the value indicated, &quot;nil&quot; is returned, else the name of the matching constant is returned.</LI>
<LI>
&quot;type field&quot; maps an offset into the passed struct-class type into a triple of the form {&lt;name&gt; &lt;length&gt; &lt;ftype&gt;}, where &lt;name&gt; can be either a straight field name, or a string of the form &lt;field&gt;.&lt;field&gt;... with as many .&lt;field&gt; clauses as necessary to get to the smallest field in the nested structure &lt;type&gt; that covers the given byte &lt;offset&gt; bytes from the start of the structure. &lt;length&gt; is the <EM>
bit</EM>
 length of the field, and &lt;ftype&gt; is its type.</LI>
<LI>
&quot;type name&quot; produces a printable description of the given type, using C syntax. &lt;varname&gt; is the name of the variable to which the type belongs. It will be placed at the proper point in the resulting string. If &lt;expand&gt; is non-zero, structured types (including enumerated types) are expanded to display their fields (or members, as the case may be).</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_10.htm#IX_gc Swat command">gc</A>,
<A HREF="../../Tools/Tcl/TTCL_f.htm#IX_symbol Tcl structure">symbol</A>,
<A HREF="../../Tools/SwatRef/SR_2e.htm#IX_value Swat command">value</A>.


<HR>
<A NAME="TTCL_10.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Tool Command Language</A>: 6.2 <A HREF="#TTCL_e.htm">Coding</A>: 
Examples</H3>
<P>
This section will contain a few examples of Tcl code for Swat commands, showing the use of some of included Tcl commands. A good way to view the code for a particular procedure is to type:</P>
<PRE>info body &lt;procname&gt;</PRE>
<P>
on the Swat command line. This will print out the body of the given &lt;<EM>procname</EM>&gt; . One thing to watch out for, however, is the case when a procedure has not been loaded into Swat yet (i.e. it has not been used yet). If this is the case, Swat will have no information about the procedure and will thus print nothing. The command must be loaded into Swat either with the <CODE>
load</CODE>
 command, or by just typing the command name which will usually autoload the command. (See <A HREF="#TTCL_11.htm_14348"> Using a New Command</A>
.) Then the<CODE>
 info body &lt;procname&gt;</CODE>
 command can be used.</P>
<P>
Some code examples:</P>

<P CLASS="figCaption">
<A NAME="TTCL_10.htm_63244">
 </A>
The <A NAME="TTCL_10.htm_IX_whatat Swat command:Tcl source">
 </A>
Whatat Command</P>
<PRE>[<A NAME="TTCL_10.htm_IX_defcommand Swat command:in example"> </A>defcommand whatat {addr} output
{Given an address, print the name of the variable at that address}
{
 <A NAME="TTCL_10.htm_IX_var Tcl command:in example"> </A>var a [<A NAME="IX_symbol Tcl structure:in example"> </A>sym faddr var $addr]
	<A NAME="TTCL_10.htm_IX_if Tcl command:in example"> </A>if {[<A NAME="IX_null Swat command:in example"> </A>null $a]}{
	 <A NAME="TTCL_10.htm_IX_echo Swat command:in example"> </A>echo *nil*
	} else {
	 echo [sym name $a]
 }
}]</PRE>
<P CLASS="figCaption">
This example shows the code of the <CODE>
whatat</CODE>
 command. Note the use of the <CODE>
sym</CODE>
 (an abbreviation for <CODE>
symbol</CODE>
) command to find the address of the given variable <EM CLASS="CodeArgsAsTyped">&lt;addr&gt;</EM> of class <EM CLASS="CodeArgsAsTyped">&lt;var&gt;</EM>.</P>
<P CLASS="figCaption">
<A NAME="TTCL_10.htm_IX_bytes Swat command:Tcl source">
 </A>
The Bytes Command</P>
<PRE CLASS="SwatDisplay">1	<A NAME="TTCL_10.htm_IX_var Tcl command:in example"> </A>var addr [<A NAME="IX_get-address Swat command:in example"> </A>get-address $addr ds:si]
2	var base [<A NAME="TTCL_10.htm_IX_index Tcl command:in example"> </A>index [addr-parse $addr] 1]
3	<A NAME="TTCL_10.htm_IX_echo Swat command:in example"> </A>echo {Addr: +0 +1 +2 +3 +4 +5 +6 +7 +8 +9 +a +b +c +d +e +f}
4	#fetch the bytes themselves
5	var bytes [<A NAME="TTCL_10.htm_IX_value Swat command:in example"> </A>value fetch $addr [<A NAME="IX_Arrays in Swat:in example"> </A><A NAME="IX_type Tcl structure:in example"> </A>type make array $num [type byte]]]
6	#
	# $s is the index of the first byte to display on this row, $e is the
	# index of the last one. $e can get &gt; $num. The loop handles this case.
	#
	var s 0 e [<A NAME="TTCL_10.htm_IX_expr Tcl command:in example"> </A>expr 16-($base&amp;0xf)-1]
	#
	# $pre can only be non-zero for the first line, so set it once here.
	# We'll set it to zero when done with the first line.
	# $post can be non-zero only for the last line, but we can't just
	# set it to zero and let the loop handle it, as the first may be the
	# last, so...
	#
	var pre [expr 16-($e-$s)-1]
	if {$e &gt; $num} {
	var post [expr $e-($num-1)]
	} else {
	var post 0
	} 

	[<A NAME="TTCL_10.htm_IX_for Tcl command:in example"> </A>for {var start [expr {$base&amp;~0xf}]}
	{$s &lt; $num}
	{var start [expr $start+16]}
	{
28	#extract the bytes we want
29	var bs [<A NAME="TTCL_10.htm_IX_range Tcl command:in example"> </A>range $bytes $s $e]

30	echo [<A NAME="TTCL_10.htm_IX_format Tcl command:in example"> </A>format {%04xh: %*s%s%*s &quot;%*s%s%*s&quot;} $start
	[expr $pre*3] {}
	[<A NAME="TTCL_10.htm_IX_map Swat command:in example"> </A>map i $bs {format %02x $i}]
	[expr $post*3] {}
	$pre {}
	[<A NAME="TTCL_10.htm_IX_mapconcat Swat command:in example"> </A>mapconcat i $bs {
	if {$i &gt;= 32 &amp;&amp; $i &lt; 127} {
	format %c $i
	} else {
	format .
	}
	}]
	$post {}]
	var s [expr $e+1] e [expr $e+16] pre 0
	if {$e &gt;= $num} {
	var post [expr $e-($num-1)]
	}
	}]
	<A NAME="TTCL_10.htm_IX_set-address Swat command:in example"> </A>set-address $addr+$num-1
	<A NAME="TTCL_10.htm_IX_set-repeat Swat command:in example"> </A>set-repeat [format {$0 {%s} $2} $addr+$num]</PRE>
<P CLASS="figCaption">
This example shows the code for the <CODE>
bytes</CODE>
 commands. Notice the use of the <CODE>
type</CODE>
 command on the fifth line, and the <CODE>
range</CODE>
 command on the twenty-ninth line.</P>
<HR>
<A NAME="TTCL_11.htm"></A>


<H2 CLASS="sectionTitle">
<A HREF="#index.htm">Tool Command Language</A>: 7 
<A NAME="TTCL_11.htm_14348">
 </A>
Using a New Command</H2>
<P>
<A NAME="TTCL_11.htm_IX_Files:loading Tcl files">
 </A>
Once a new command is written, it needs to be loaded into Swat so that it can be used. Depending on how the command is to be used, you may be interested in any of the following topics:</P>
<UL>
<LI>
Compilation</LI>
<LI>
Autoloading</LI>
<LI>
Explicit loading</LI>
</UL>
<P CLASS="subsectionLink">
<A HREF="#TTCL_12.htm">Compilation</A></P>
<P CLASS="subsectionLink">
<A HREF="#TTCL_13.htm">Autoloading</A></P>
<P CLASS="subsectionLink">
<A HREF="#TTCL_14.htm">Explicit Loading</A></P>
<HR>
<A NAME="TTCL_12.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Tool Command Language</A>: 7.1 <A HREF="#TTCL_11.htm">Using a New Command</A>: 
Compilation</H3>
<P>
It is possible to byte-compile a Tcl script. The <CODE>
bc</CODE>
 Tcl command creates a .TLC file containing compiled Tcl code--this code will run faster than normal Tcl code. When loading, Swat will load a .TLC file instead of a .TCL file where possible. Making changes to compiled Tcl functions involves changing the source code and re-compiling.</P>
<HR>
<A NAME="TTCL_13.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Tool Command Language</A>: 7.2 <A HREF="#TTCL_11.htm">Using a New Command</A>: 
Autoloading</H3>
<P>
<A NAME="TTCL_13.htm_IX_autoload Swat command">
 </A>
If the development environment has been set up properly, there should already exist the <STRONG CLASS="fileName">
/pcgeos/Tools/swat/lib</STRONG>
 directory on the workstation. This directory will contain all of the code files for the built-in Swat commands. To autoload a new command, copy its code file to the <STRONG CLASS="fileName">
/pcgeos/Tools/swat/lib</STRONG>
 directory and add its name to the <STRONG CLASS="fileName">
autoload.</STRONG>
tcl file in the directory. This will load the command into Swat every time Swat is started. For example, say the command <CODE>
blitzburp</CODE>
 has just been written to examine a new data structure. First, copy the file containing its code (say <STRONG CLASS="fileName">
blitz.</STRONG>
tcl) into the<STRONG CLASS="fileName">
 /pcgeos/Tools/swat/lib</STRONG>
 directory. Next, edit the <STRONG CLASS="fileName">
autoload.</STRONG>
tcl file and add <EM>
one</EM>
 of the following lines:</P>
<PRE>[autoload blitzburp 0 blitz]</PRE>
<PRE>[autoload blitzburp 1 blitz]</PRE>
<P>
This will ensure that <STRONG CLASS="fileName">
blitz.tcl</STRONG>
 will be loaded when the command <CODE>
blitzburp</CODE>
 is first used. The 0 indicates that the command must be typed exactly, and the 1 indicates that the interpreter will not evaluate arguments passed to the command. (<A HREF="../../Tools/SwatRef/SR_4.htm#IX_autoload Swat command:command reference">Full reference information</A>
is available for the <CODE>
autoload</CODE>
 command.)</P>
<HR>
<A NAME="TTCL_14.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">Tool Command Language</A>: 7.3 <A HREF="#TTCL_11.htm">Using a New Command</A>: 
Explicit Loading</H3>
<P>
<A NAME="TTCL_14.htm_IX_load Swat command">
 </A>
Another way to load a command into Swat is to use the <CODE>
load</CODE>
 command from the Swat command line. This command is simply <CODE>
load &lt;path&gt;/&lt;filename&gt;</CODE>
. If no path is given, then the &lt;<EM>file</EM>&gt; is loaded from the directories specified in the <CODE>
load-path</CODE>
 variable. The <CODE>
load</CODE>
 command will load the given file (a Tcl procedure or subroutine) into Swat for subsequent use, and it is mostly used to load infrequently accessed files. (See <A HREF="../../Tools/SwatRef/SR_18.htm#IX_load Swat command:command reference"></A>
, for more information on the <CODE>
load</CODE>
 command.)</P>
<HR>
This document is a single-page version of a <A HREF="index.htm">a multi-page document</A>, suitable for easy printing.
</BODY>
</HTML>
