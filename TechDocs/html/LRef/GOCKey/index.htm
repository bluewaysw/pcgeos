<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD>

<!-- $Id: index.htm,v 1.9 97/11/20 16:54:24 nfiedler Exp $ -->
<META NAME="copyright" CONTENT="Copyright 1997 GEOWORKS">
<!-- <META NAME="description" CONTENT=""> -->
<!-- <META NAME="keywords" CONTENT=""> -->
<LINK REL="STYLESHEET" HREF="../../docHelpers/style.css">
<LINK REV="MADE" HREF="mailto:isv-feedback@geoworks.com">

<TITLE> GOC Keywords</TITLE></HEAD>
<BODY BGCOLOR="#ffffff">
<DIV>
<!-- This blob is a bunch of standard links: up, back, index, etc. -->
<!-- up to top -->|&nbsp;<A HREF="../../index.htm"><IMG SRC="../../docImages/upTop.gif" ALT="Up: " BORDER="0">GEOS SDK TechDocs</A>
<!-- up to parent -->| <A HREF="../../index.htm"><IMG SRC="../../docImages/up.gif" ALT="Up" BORDER="0"></A>
<!-- down to first child --> 
<!-- to previous --> 
<!-- to next --> 
<HR>
<!-- That blob was a bunch of standard links: up, back, index, etc. -->
</DIV>
<DIV>
<H1 CLASS="chapterTitle">
<A NAME="IX_Goc:syntax">
 </A>
<A NAME="97933">
 </A>
GOC Keywords<A NAME="IX_.goc files:Goc syntax">
 </A>
<A NAME="IX_.goh files:Goc syntax">
 </A>
<DIV>
</DIV>
</H1>
<DIV>
<H1 CLASS="refHeading">
@alias</H1>
<PRE CLASS="syntax">@alias(&lt;<EM>protoMsg</EM>&gt;) &lt;<EM>messageDef</EM>&gt;;</PRE>
<P>
<A NAME="IX_Messages:with optional parameters">
 </A>
<A NAME="IX_@alias[;alias]">
 </A>
The @alias keyword is used for messages which take conditional parameters in an assembly handler. For example, if the assembly handler takes a word parameter normally and a dword only if a certain flag is set, you will need to have two C messages with the two different parameters. The @alias keyword allows this. Its arguments are shown below:</P>
<DL>
<DT>
<CODE>
protoMsg</CODE>
</DT><DD>The name of the existing message that the alias will reference.</DD>
<DT>
<CODE>
messageDef</CODE>
</DT><DD>The new message definition. This is a standard message definition as would follow the @message keyword.</DD>
<PRE>@message void MSG_MY_MSG(word par);
@alias(MSG_MY_MSG) void MSG_MY_SECOND_MSG(dword par);</PRE>
</DL>
<P CLASS="refField">
See Also:	@message</P>
</DIV>
<DIV>
<H1 CLASS="refHeading">
@call</H1>
<PRE CLASS="syntax">&lt;<EM>ret</EM>&gt; = @call [,&lt;<EM>flags</EM>&gt;] [{&lt;<EM>cast_ret</EM>&gt;}] \
&lt;<EM>obj</EM>&gt;::[{&lt;<EM>cast_par</EM>&gt;}]&lt;<EM>msg</EM>&gt;(&lt;<EM>param</EM>&gt;*);</PRE>
<P>
<A NAME="IX_@call[;call]">
 </A>
<A NAME="IX_Messages:calling">
 </A>
The @call keyword sends the specified message to the specified object and makes the caller wait until the message is processed before continuing. The arguments of @call are shown below:</P>
<DL>
<DT>
<CODE>
ret</CODE>
</DT><DD>A variable for receiving the return value of the message as defined by @message. This has the same usage as a typical function return value.</DD>
<DT>
<CODE>
flags</CODE>
</DT><DD>Flags that determine how the message affects the recipient's event queue. The allowable flags are shown below. (The comma is required before each flag.) </DD>
<DT>
<CODE>
cast_ret</CODE>
</DT><DD>A message to cast the message return value to. When Goc determines what type of value should be returned, it uses the return value of the <EM>cast_ret</EM> message if this field is used. The curly braces are required around this field.</DD>
<DT>
<CODE>
obj</CODE>
</DT><DD>The name of the recipient object, or a variable representing the optr of the recipient.</DD>
<DT>
<CODE>
cast_par</CODE>
 </DT><DD>A message to cast the message parameters to. When Goc determines what type of values should be passed to the message, should be returned, it uses the parameters of the <EM>cast_par</EM> message if this field is used. The curly braces are required around this field.</DD>
<DT>
<CODE>
msg</CODE>
</DT><DD>The name of the message to be sent, or an expression representing the message number. If an expression is used, you must cast the message to a certain type with the <CODE>
cast</CODE>
 parameter.</DD>
<DT>
<CODE>
param</CODE>
</DT><DD>Expressions or constants passed to the message. Parameters passed to messages are specified in the same way as if they were being passed directly to a function or routine in C.</DD>
</DL>
<P>
The flags allowed with @call are shown below:</P>
<DL>
<DT>
<STRONG>
forceQueue</DT><DD>
</STRONG>
<A NAME="IX_forceQueue message flag">
 </A>
This flag will cause the message to be placed in the recipient's event queue, even if it could have been handled by a direct call.</DD>
<DT>
<STRONG>
checkDuplicate</DT><DD>
</STRONG>
<A NAME="IX_checkDuplicate message flag">
 </A>
This flag makes the kernel check if a message of the same name is already in the recipient's event queue. For this flag to work, <CODE>
forceQueue</CODE>
 must also be passed. Note that due to implementation constraints, events will be checked from last to first rather than from first to last.</DD>
<DT>
<STRONG>
checkLastOnly</DT><DD>
</STRONG>
<A NAME="IX_checkLastOnly message flag">
 </A>
This flag works like <CODE>
checkDuplicate</CODE>
, above, except that it checks only the last message in the event queue.</DD>
<DT>
<STRONG>
replace</DT><DD></STRONG>
<A NAME="IX_replace message flag">
 </A>
This flag modifies <CODE>
checkDuplicate</CODE>
 and <CODE>
checkLastOnly</CODE>
 by superseding the duplicate (old) event with the new one. The new event will be put in the duplicate's position in the event queue. If a duplicate is found but the <CODE>
replace</CODE>
 flag is not passed, the duplicate will be dropped and the new event will be put at the end of the queue.</DD>
<DT>
<STRONG>
insertAtFront</DT><DD>
</STRONG>
<A NAME="IX_insertAtFront message flag">
 </A>
This puts the message at the front of the recipient's event queue. Note that this flag will supersede the <CODE>
replace</CODE>
 flag.</DD>
<DT>
<STRONG>
canDiscardIfDesperate</DT><DD>
</STRONG>
<A NAME="IX_canDiscardIfDesperate message flag">
 </A>
This flag indicates that this event may be discarded if the system is running extremely low on handles and requires more space immediately.</DD>
</DL>
<P>
Additionally, @call alows the use of several special expressions in place of the recipient:</P>
<DL>
<DT>
<STRONG>
self</STRONG>
<A NAME="IX_self (messaging shortcut)">
 </A>
</DT><DD>Send the message to the object issuing the @call command. e.g.</DD>
<PRE>@call self::MSG_VIS_DRAW(flags, gstate);</PRE>
<DT>
<STRONG>
process</STRONG>
<A NAME="IX_process (messaging shortcut)">
 </A>
</DT><DD>Send the message to the object's associated Process object. e.g.</DD>
<PRE>@call process::MSG_HELLO_RESPOND();</PRE>
<DT>
<STRONG>
application</STRONG>
<A NAME="IX_application (messaging shortcut)">
 </A>
</DT><DD>Send the message to the object's associated GenApplication object.</DD>
<PRE>attr = @call application::MSG_GEN_GET_ATTRIBUTES();</PRE>
<DT>
<STRONG>
@genParent</STRONG>
</DT><DD>Send the message to the object's generic parent in a generic object tree.</DD>
<DT>
<STRONG>
@visParent</STRONG>
</DT><DD>Send the message to the object's visible parent in a visible object tree.</DD>
</DL>
<P>
If you need to send a message to an object's superclass, use the @callsuper keyword rather than @call.</P>
<PRE>gstate = @call myObj::MSG_META_CUT();
retVal = @call {MSG_MY_MSG} myObj::MSG_OTHER_MSG();
retVal = @call myObj::MSG_MY_MSG(10, param1);</PRE>
<P CLASS="refField">
See Also:	@send, @callsuper, @message, @method, @object</P>
</DIV>
<DIV>
<H1 CLASS="refHeading">
@callsuper</H1>
<PRE CLASS="syntax">&lt;<EM>ret</EM>&gt; = @callsuper [{&lt;<EM>cast_ret</EM>&gt;}] \
&lt;<EM>obj</EM>&gt;::&lt;<EM>class</EM>&gt;::[{&lt;<EM>cast_par</EM>&gt;}]&lt;<EM>msg</EM>&gt;(&lt;<EM>param</EM>&gt;*) [&lt;<EM>flags</EM>&gt;]+;</PRE>
<PRE CLASS="syntax">@callsuper;</PRE>
<P>
<A NAME="IX_@callsuper[;callsuper]">
 </A>
The @callsuper keyword does two things: The most useful is to pass a received message on to the superclass to ensure default behavior is preserved; the second, and less used, acts just like @call but sends the message to the recipient's superclass rather than the recipient's class. This is rarely used but can be used if only default behavior is required of the message. Its arguments are shown below:</P>
<DL>
<DT>
<CODE>
ret</CODE>
</DT><DD>Same as @call.</DD>
<DT>
<CODE>
obj</CODE>
</DT><DD>Same as @call.</DD>
<DT>
<CODE>
cast_ret</DT><DD></CODE>
Same as @call<CODE>
.</CODE>
</DD>
<DT>
<CODE>
class</CODE>
</DT><DD>The name of the object's superclass that should receive the message. It is possible to send the message to the highest superclass.</DD>
<DT>
<CODE>
cast_par</CODE>
 </DT><DD>Same as @call<CODE>
.</CODE>
</DD>
<DT>
<CODE>
msg</CODE>
</DT><DD>Same as @call.</DD>
<DT>
<CODE>
param</CODE>
</DT><DD>Same as @call.</DD>
<DT>
<CODE>
flags</CODE>
</DT><DD>Same as @call.</DD>
<PRE>(void) @callsuper myObj::MySupClass::MSG_MY_MSG();</PRE>
</DL>
<P CLASS="refField">
See Also:	@call, @send, @message, @method</P>
</DIV>
<DIV>
<H1 CLASS="refHeading">
@chunk</H1>
<PRE CLASS="syntax">@chunk	&lt;<EM>type</EM>&gt; &lt;<EM>name</EM>&gt; [= &lt;<EM>init</EM>&gt;];</PRE>
<P>
<A NAME="IX_@chunk[;chunk]">
 </A>
<A NAME="IX_Chunks:@chunk keyword">
 </A>
The @chunk keyword declares a resource chunk containing data of some kind. Data can be of any GEOS or C data type or structure, including a string of characters. The chunk must be declared between the resource delimiters @start and @end. Its arguments are described below:</P>
<DL>
<DT>
<CODE>
type</CODE>
</DT><DD>The data type or structure type of the chunk.</DD>
<DT>
<CODE>
name</CODE>
</DT><DD>The name of the chunk--how it will be referenced by other entities.</DD>
<DT>
<CODE>
init</CODE>
</DT><DD>Initializer data, if any, to initialize the chunk to.</DD>
</DL>
<P>
If you will need to access the chunk from another executable file, you must declare it in the other file with @extern. Objects are declared with @object.</P>
<PRE>typedef struct {
    int     a;
    int     b;
} MyStruct;</PRE>
<PRE>typedef char    MyString[13];</PRE>
<PRE>@start MyDataResource, data;
@chunk word			MyWordChunk;
@chunk MyStruct			MyMSChunk = {5, 10};
@chunk MyString			MyStringChunk = &quot;My string&quot;;
@end MyDataResource;</PRE>
<P CLASS="refField">
See Also:	@start, @end, @object, @extern</P>
</DIV>
<DIV>
<H1 CLASS="refHeading">
@chunkArray</H1>
<PRE CLASS="syntax">@chunkArray 	&lt;<EM>stype</EM>&gt; &lt;<EM>aname</EM>&gt; [= {&lt;<EM>init</EM>&gt;}];</PRE>
<P>
<A NAME="IX_Chunk arrays">
 </A>
<A NAME="IX_@chunkArray[;chunkArray]">
 </A>
The @chunkArray keyword declares a Chunk Array, a special kind of chunk. Only uniform-element-size chunk arrays may be declared with this keyword. It has the following arguments:</P>
<DL>
<DT>
<EM>stype</EM></DT><DD>This is the type of each element in the Chunk Array. It may be any standard C or Goc type, or any derived type.</DD>
<DT>
<EM>aname</EM></DT><DD>This is the name of the Chunk Array.</DD>
<DT>
<EM>init</EM></DT><DD>You may declare the initializer values for a chunk array. If you do not set any initial values, the Chunk Array will be created with no elements.</DD>
<PRE>@chunkArray int			someints;</PRE>
<PRE>@chunkArray dword			somedwords = {123456789, 
					6021023, 
					31415926};</PRE>
</DL>
<P CLASS="refField">
See Also:	@chunk, @elementArray</P>
</DIV>
<DIV>
<H1 CLASS="refHeading">
@class</H1>
<PRE CLASS="syntax">@class	&lt;<EM>cname</EM>&gt;, &lt;<EM>super</EM>&gt; [, master [, variant]];</PRE>
<P>
<A NAME="IX_@class[;class]">
 </A>
<A NAME="IX_Classes:@class keyword">
 </A>
The @class keyword begins a class definition. All instance data and messages for the class are declared between @class and @endc. The arguments of @class are listed below:</P>
<DL>
<DT>
<CODE>
cname</CODE>
</DT><DD>Name of the class being declared.</DD>
<DT>
<CODE>
super</CODE>
</DT><DD>Name of the superclass.</DD>
<DT>
<CODE>
master</CODE>
</DT><DD>Use of this term designates this class as a master class.</DD>
<DT>
<CODE>
variant</CODE>
</DT><DD>Use of this term designates this class as a variant class.</DD>
<PRE>@class MyTriggerClass, GenTriggerClass;
@endc</PRE>
<PRE>@class MyMasterVarClass, MetaClass, master, variant;
@endc</PRE>
</DL>
<P CLASS="refField">
See Also:	@endc, @classdecl</P>
</DIV>
<DIV>
<H1 CLASS="refHeading">
@classdecl</H1>
<PRE CLASS="syntax">@classdecl &lt;<EM>cname</EM>&gt; [, neverSaved];</PRE>
<P>
<A NAME="IX_Classes:@classdecl keyword">
 </A>
<A NAME="IX_@classdecl[;classdecl]">
 </A>
<A NAME="IX_neverSaved (class flag)">
 </A>
The @classdecl keyword defines a given class structure in memory. Every new class that will be used by an application must appear in an @classdecl declaration. The arguments for this keyword are shown below:</P>
<DL>
<DT>
<CODE>
cname</CODE>
</DT><DD>The name of the class being declared.</DD>
<DT>
<CODE>
neverSaved</CODE>
</DT><DD>Using this term indicates that objects of this class are never saved along with state information.</DD>
<PRE>@classdecl MyTriggerClass;
@classdecl MyProcessClass, neverSaved;</PRE>
</DL>
<P CLASS="refField">
See Also:	@class</P>
</DIV>
<DIV>
<H1 CLASS="refHeading">
@composite</H1>
<PRE CLASS="syntax">@instance @composite &lt;<EM>iname</EM>&gt; = &lt;<EM>linkFieldName</EM>&gt;;</PRE>
<P>
<A NAME="IX_@composite[;composite]">
 </A>
The @composite keyword appears as a subcommand of @instance. It is a type of instance data--it indicates that an object of this class can have several children and that the @composite instance data field will be an optr to the first of its children. The arguments of the @composite keyword are given below:</P>
<DL>
<DT>
<CODE>
iname</CODE>
</DT><DD>The name of the instance data field.</DD>
<DT>
<CODE>
linkFieldName</DT><DD>
</CODE>
The name of the @link instance data field for this class.</DD>
<PRE>@class GenTrigWithKidsClass, GenTriggerClass;
    /* GI_link is the GenClass sibling link field. */
    @instance @composite GTWKI_comp = GI_link;
@endc</PRE>
</DL>
<P CLASS="refField">
See Also:	@instance, @link</P>
</DIV>
<DIV>
<H1 CLASS="refHeading">
@default</H1>
<PRE CLASS="syntax">&lt;fname&gt; = @default [&lt;op&gt; [~]&lt;attr&gt;]*; /* to use default value of
                          instance data field */</PRE>
<PRE CLASS="syntax">@default &lt;<EM>varRoot</EM>&gt; = &lt;<EM>super</EM>&gt;; /* to specify default superclass of 
                 a variant class */</PRE>
<PRE CLASS="syntax">@default &lt;fname&gt; = &lt;value&gt;; /* to specify a default value for an instance
data field defined by a superclass. */</PRE>
<PRE CLASS="syntax">&lt;fname&gt; = @default;</PRE>
<P>
<A NAME="IX_@default[;default]">
 </A>
The @default keyword can be used in several ways: to specify the default value of an instance data field, to represent the default value of an object's instance data field, or to specify the default superclass of a variant class. It may also be used when defining a class to specify a default value to use with an instance data field defined by a superclass.</P>
<P>
The @default keyword is most commonly used when modifying default instance data values of bitfield-type fields. The defaults are set in the @class definition and may be modified in the @object declaration. The arguments of @default are shown below:</P>
<DL>
<DT>
<CODE>
fname</CODE>
</DT><DD>The name of the instance data field. Typically, this is a record.</DD>
<DT>
<CODE>
op</CODE>
</DT><DD>A bitwise operator character. If setting certain bits, use the OR operator (|); if removing certain bits, use the AND operator (&amp;).</DD>
<DT>
<CODE>
attr</CODE>
</DT><DD>The name of the attribute bit to set or remove. If removing attribute bits, place the logical NOT character (~) in front of the attribute.</DD>
<PRE>@object GenPrimaryClass MyPrimary {
    GI_states = @default &amp; ~GENS_MAXIMIZED;
    GI_attrs = @default | GENA_TARGETABLE;
}</PRE>
</DL>
<P>
The @default keyword can also be used to specify the default superclass of a variant class. In this case, it has the following arguments:</P>
<DL>
<DT>
<EM>varRoot</EM></DT><DD>The name of the variant class, with the word &quot;Class&quot; removed. (e.g. the root of &quot;MyVariantClass&quot; is &quot;MyVariant&quot;.)</DD>
<DT>
<EM>super</EM></DT><DD>The default superclass for this variant class.</DD>
</DL>
<P>
To specify a class' default value for an instance data field when that instance data field is defined by a superclass, @default has the following arguments:</P>
<DL>
<DT>
<EM>fname</EM></DT><DD>The name of the instance data field.</DD>
<DT>
<EM>value</EM></DT><DD>The class' default value for the field.</DD>
</DL>
<P>
To represent an object's default value for an instance data field, @default has the following arguments:</P>
<DL>
<DT>
<EM>fname</EM></DT><DD>The name of the instance data field.</DD>
</DL>
<P CLASS="refField">
See Also:	@object, @instance, @class</P>
</DIV>
<DIV>
<H1 CLASS="refHeading">
@define</H1>
<PRE CLASS="syntax">@define &lt;<EM>mname</EM>&gt;[(&lt;<EM>pdef</EM>&gt;)] &lt;<EM>macro</EM>&gt;</PRE>
<P>
<A NAME="IX_@define[;define]">
 </A>
<A NAME="IX_macros:@define keyword">
 </A>
The @define directive defines a Goc macro. You can define C macros with the #define directive; macros that use Goc operators, keywords, or code must be defined with @define. Similarly, macros defined with @define must be later used with the &quot;@&quot; marker preceeding them; otherwise, the Goc processor will scan over the macro and will not evaluate it. The arguments of @define are listed below:</P>
<DL>
<DT>
<CODE>
mname</CODE>
</DT><DD>The macro name. This can be used later as @<CODE>
mname</CODE>
 to invoke the macro.</DD>
<DT>
<CODE>
pdef</CODE>
</DT><DD>The optional parameter definition, as with C macros.</DD>
<DT>
<CODE>
macro</CODE>
</DT><DD>The macro.</DD>
<PRE>@define MyChunk(a) @chunk char[] a = &quot;text&quot;;
@define MyText(a,b) @chunk char[] a = &quot;b&quot;;</PRE>
<PRE>/* You can later use these macros as follows: */</PRE>
<PRE>@MyChunk(Text1)
@MyText(Text2, newText)</PRE>
<PRE>/* This will evaluate to the following: */</PRE>
<PRE>@chunk char[] Text1 = &quot;text&quot;;
@chunk char[] Text2 = &quot;newText&quot;;</PRE>
</DIV>
<DIV>
</DL>
<H1 CLASS="refHeading">
@deflib</H1>
<PRE CLASS="syntax">@deflib &lt;<EM>libName</EM>&gt;</PRE>
<P>
<A NAME="IX_@deflib[;deflib]">
 </A>
<A NAME="IX_Libraries:@deflib keyword">
 </A>
Most Goc libraries will have a <STRONG CLASS="fileName">
.goh</STRONG>
 header file. This file should begin with a @deflib directive. This will see to it that no library header file is included more than once in a given compilation. The file must end with an @endlib directive. The @deflib directive takes the following argument:</P>
<DL>
<DT>
<EM>libName</EM></DT><DD>This is the name of the header file, with the <STRONG CLASS="fileName">
.goh</STRONG>
 extension stripped off. For example, if the library's header file is <STRONG CLASS="fileName">
hellolib.goh</STRONG>
, the file would begin with</DD>
<PRE>@deflib		hellolib</PRE>
</DL>
<P CLASS="refField">
See Also:	@endlib</P>
</DIV>
<DIV>
<H1 CLASS="refHeading">
@dispatch</H1>
<PRE CLASS="syntax">@dispatch &lt;<EM>event</EM>&gt;;</PRE>
<P>
<A NAME="IX_Events:dispatching recorded">
 </A>
<A NAME="IX_@dispatch[;dispatch]">
 </A>
The @dispatch keyword sends a previously-encapsulated message. This keyword
is analogous to @send; use @dispatchcall if the event must be processed
immediately. The encapsulated event must have been defined with @record.
The arguments of @dispatch are given below:</P>
<DL>
<DT><EM>event</EM></DT>
<DD>The name of the encapsulated event, defined earlier with @record. This
must not be a classed event.</DD>
<PRE>@dispatch myEvent;</PRE>
</DL>
To change the recorded destination of the message, use the
<a href="../../CRef/Routines/R_70.htm#IX_MessageSetDestination()">
<CODE>MessageSetDestination()</CODE></a> routine.
<P CLASS="refField">
See Also:	@record, @send, @dispatchcall</P>
</DIV>

<DIV>
<H1 CLASS="refHeading">
@dispatchcall</H1>
<PRE CLASS="syntax">&lt;ret&gt; = @dispatchcall (&lt;<EM>nMsg</EM>&gt;) &lt;<EM>event</EM>&gt;;</PRE>
<P>
<A NAME="IX_Events:dispatching recorded">
 </A>
<A NAME="IX_@dispatchcall[;dispatchcall]">
 </A>
The @dispatchcall keyword sends a previously-encapsulated message. This
keyword is analogous to @call; use @dispatch if the event can be sent with
no return values. The encapsulated event must have been defined with
@record. The arguments of @dispatchcall are given below:</P>
<DL>
<DT><EM>nMsg</EM></DT>
<DD>An override message to be sent. Encapsulated messages can store the
message number to be sent; this will override the stored value.</DD>
<DT><EM>event</EM></DT>
<DD>The name of the encapsulated event, defined earlier with @record.</DD>
<PRE>retVal = @dispatchcall (myMsg) myEvent;</PRE>
</DL>
To change the recorded destination of the message, use the
<a href="../../CRef/Routines/R_70.htm#IX_MessageSetDestination()">
<CODE>MessageSetDestination()</CODE></a> routine.
<P CLASS="refField">
See Also:	@record, @send, @dispatch</P>
</DIV>
<DIV>
<H1 CLASS="refHeading">
@elementArray</H1>
<PRE CLASS="syntax">@elementArray 	&lt;<EM>stype</EM>&gt; &lt;<EM>aname</EM>&gt; [= {&lt;<EM>init</EM>&gt;}];</PRE>
<P>
<A NAME="IX_@elementArray[;elementArray]">
 </A>
<A NAME="IX_Element arrays:@elementArray keyword">
 </A>
The @elementArray keyword declares a Element Array, a special kind of Chunk Array. It has the following arguments:</P>
<DL>
<DT>
<EM>stype</EM></DT><DD>This is the type of each element in the Element Array. It may be any standard C or Goc type, or any derived type.</DD>
<DT>
<EM>aname</EM></DT><DD>This is the name of the Element Array.</DD>
<DT>
<EM>init</EM></DT><DD>You may declare the initializer values for a chunk array. If you do not set any initial values, the Element Array will be created with no elements.</DD>
</DL>
<P CLASS="refField">
See Also:	@chunk, @chunkArray</P>
</DIV>
<DIV>
<H1 CLASS="refHeading">
@end</H1>
<PRE CLASS="syntax">@end	&lt;<EM>segname</EM>&gt;</PRE>
<P>
<A NAME="IX_@end[;end]">
 </A>
The @end keyword denotes the end of a resource block definition that had been started with @start. Its one argument is the name of the resource segment.</P>
<PRE>@start MenuResource;
@end MenuResource;</PRE>
<P CLASS="refField">
See Also:	@start, @header, @object, @chunk</P>
</DIV>
<DIV>
<H1 CLASS="refHeading">
@endc</H1>
<PRE CLASS="syntax">@endc</PRE>
<P>
<A NAME="IX_@endc[;endc]">
 </A>
The @endc keyword denotes the end of a class definition begun with @class. It has no arguments.</P>
<P CLASS="refField">
See Also:	@class</P>
</DIV>
<DIV>
<H1 CLASS="refHeading">
@endif</H1>
<PRE CLASS="syntax">@endif</PRE>
<P>
<A NAME="IX_@endif[;endif]">
 </A>
The @endif directive denotes the end of a block of conditionally-compiled code. It is used with @if, @ifdef, and @ifndef.</P>
<P CLASS="refField">
See Also:	@if, @ifdef, @ifndef</P>
</DIV>
<DIV>
<H1 CLASS="refHeading">
@endlib</H1>
<PRE CLASS="syntax">@endlib</PRE>
<P>
<A NAME="IX_@endlib[;endlib]">
 </A>
Most Goc libraries will have a <STRONG CLASS="fileName">
.goh</STRONG>
 header file. This file should end with an @endlib directive. This will see to it that no library header file is included more than once in a given compilation. The file must begin with an @deflib directive.</P>
<P CLASS="refField">
See Also:	@deflib</P>
</DIV>
<DIV>
<H1 CLASS="refHeading">
@exportMessages</H1>
<PRE CLASS="syntax">@exportMessages &lt;<EM>expname</EM>&gt;, &lt;<EM>num</EM>&gt;;</PRE>
<P>
<A NAME="IX_@exportMessages[;exportMessages]">
 </A>
<A NAME="IX_Messages:exporting">
 </A>
<A NAME="IX_Exported messages:@exportMessages keyword">
 </A>
The @exportMessages keyword sets aside a number of message spots so the messages may be declared elsewhere. This allows users of the class to declare messages that are guaranteed to be unique across all subclasses. Exported messages are declared with the @importMessage keyword. The arguments of @exportMessages are shown below:</P>
<DL>
<DT>
<CODE>
expname</CODE>
</DT><DD>Name of the range being exported.</DD>
<DT>
<CODE>
num</CODE>
</DT><DD>Number of message spots to be exported.</DD>
<PRE>@exportMessages MetaUIMessages, 50;
@exportMessages MyExportedMessages, 12;</PRE>
</DL>
<P CLASS="refField">
See Also:	@importMessage, @reserveMessages, @message</P>
</DIV>
<DIV>
<H1 CLASS="refHeading">
@extern</H1>
<PRE CLASS="syntax">@extern	&lt;<EM>type</EM>&gt; &lt;<EM>name</EM>&gt;;
@extern	method &lt;<EM>cname</EM>&gt;, &lt;<EM>manme</EM>&gt;+</PRE>
<P>
<A NAME="IX_Methods:@extern keyword">
 </A>
<A NAME="IX_@extern[;extern]">
 </A>
The @extern keyword allows code in a given compilation session to access objects, chunks, monikers, and methods defined in another compilation session. The compiler will assume the element exists and will be linked by the Glue linker. If Glue is unable to locate and link the external resource element, it will respond with an error. The arguments of @extern are given below:</P>
<DL>
<DT>
<CODE>
type</CODE>
</DT><DD>The type of resource element being referenced. This must be one of <CODE>
object</CODE>
, <CODE>
chunk</CODE>
, <CODE>
visMoniker</CODE>
, or <CODE>
method</CODE>
.</DD>
<DT>
<CODE>
name</CODE>
</DT><DD>The name of the element being referenced.</DD>
<PRE>@extern chunk MyChunk;
@extern object MyBlueTrigger;
@extern visMoniker GAL_visMoniker;</PRE>
</DL>
<P>
If @extern is being used to declare a method which is in a different file from the class declaration, it has the following arguments:</P>
<DL>
<DT>
<EM>cname</EM></DT><DD>The name of the class for which the method is defined.</DD>
<DT>
<EM>mname+</EM></DT><DD>The name of the message which invokes the method. As with normal method declarations, there must be at least one message which invokes the method.</DD>
</DL>
<P>
<A NAME="IX_Source code:multiple source files">
 </A>
Some confusion has arisen about when to use <CODE>
@extern</CODE>
. The following notes will hopefully prove useful.</P>
</DIV>
<DIV>
<H5 CLASS="HeadingD">
Classes</H5>
<P>
Your class' definition should not be broken up over files. If you wish to keep your class definition in a file separate from your other code, this file should be a <STRONG CLASS="fileName">
.goh</STRONG>
 file.</P>
<P>
If your class is <EM>
declared</EM>
 (@classdecl) in a file other than where it is <EM>
defined</EM>
 (@class), then the declaring file should <CODE>
@include</CODE>
 the defining file.</P>
<P>
Normally the declaring file contains all method definitions for the class. If any method definitions are in another file, then both files will need an <CODE>
@extern </CODE>
keyword like so:</P>
<P>
In file containing class declaration:</P>
<PRE> @extern method MyClass, MSG_MY_DO_SOMETHING;</PRE>
<P>
In file containing method code:</P>
<PRE>@extern method MyClass,
			MSG_MY_DO_SOMETHING(word myArg)
{ /* Method code here */ }</PRE>
</DIV>
<DIV>
<H5 CLASS="HeadingD">
Object Trees</H5>
<P>
All objects declared in a static tree (e.g., your application's generic tree) should be in the same source file. If they are in different files, then they may be joined into a single tree only by dynamically adding objects from one file as children to objects of the other.</P>
<P>
Note that if one file contains a tree of objects, then you may incorporate the whole tree by simply dynamically adding the top object in the file to the main tree. You won't have to add each object individually.</P>
<P>
If an object declared in one source file will send a message to an object in another source file, you must include an <CODE>
@extern</CODE>
 line in the source file containing the sending object: </P>
<PRE>@extern object ReceivingObjectName;</PRE>
<P>
The message itself should be sent in the following manner (with variations possible if you will be using <CODE>
@call</CODE>
, passing arguments, or what have you):</P>
<PRE>optr ROOptr;
ROOptr = GeodeGetOptrNS(@ReceivingObjectName);
@send ROOptr::MSG_DO_SOMETHING(0, 0);</PRE>
<P CLASS="refField">
See Also:	@chunk, @object, @visMoniker</P>
<DIV>
<H1 CLASS="refHeading">
gcnList</H1>
<PRE CLASS="syntax">gcnList(&lt;<EM>manufID</EM>&gt;,&lt;<EM>lname</EM>&gt;) = &lt;<EM>oname</EM>&gt; [, &lt;<EM>oname</EM>&gt;]*;</PRE>
<P>
<A NAME="IX_gcnList() keyword">
 </A>
The gcnList keyword, which does not have the keyword marker @ preceeding it, puts the listed objects onto the specified notification list. GCN lists are specified by both manufacturer ID and list type. The arguments of the gcnList keyword are given below:</P>
<DL>
<DT>
<CODE>
manufID</CODE>
</DT><DD>The manufacturer ID number of the GCN list type. Often this will be MANUFACTURER_ID_GEOWORKS.</DD>
<DT>
<CODE>
lname</CODE>
</DT><DD>The list type, or list name, of the GCN list.</DD>
<DT>
<CODE>
oname</CODE>
</DT><DD>A listing of all the objects that will be included on the GCN list. Separate objects with commas.</DD>
<PRE>@object GenApplicationClass HelloApp = {
    GI_comp = HelloPrimary;
    gcnList(MANUFACTURER_ID_GEOWORKS, GAGCNLT_WINDOWS) =
						HelloPrimary;
}</PRE>
</DL>
<P CLASS="refField">
See Also:	@object</P>
</DIV>
<DIV>
<H1 CLASS="refHeading">
@genChildren</H1>
<PRE CLASS="syntax">@send @genChildren::<EM>&lt;msg&gt;</EM>(<EM>&lt;params&gt;</EM>);</PRE>
<P>
<A NAME="IX_@genChildren (messaging shortcut)[;genChildren]">
 </A>
Any composite object in a generic object tree (therefore a subclass of <CODE>
GenClass</CODE>
) can send a message that will be dispatched at once to all of its children. Note that any message sent with @genChildren as the destination must be dispatched with the <CODE>
@send</CODE>
 keyword and therefore can have no return value and can not pass pointers in its parameters.</P>
</DIV>
<DIV>
<H1 CLASS="refHeading">
@genParent</H1>
<PRE CLASS="syntax">[@send | @call] @genParent::<EM>&lt;msg&gt;</EM>(<EM>&lt;params&gt;</EM>);</PRE>
<P>
<A NAME="IX_@genParent (messaging shortcut)[;genParent]">
 </A>
Any composite object in a generic object tree (therefore a subclass of <CODE>
GenClass</CODE>
) can use the @genParent address to send a message to its generic parent. This can be used with either @send or @call.</P>
</DIV>
<DIV>
<H1 CLASS="refHeading">
@gstring</H1>
<PRE CLASS="syntax">@gstring &lt;<EM>gsname</EM>&gt; = {[&lt;command&gt; [, &lt;command&gt;]+]}</PRE>
<P>
<A NAME="IX_@gstring[;gstring]">
 </A>
<A NAME="IX_GStrings:@gstring keyword">
 </A>
The @gstring keyword lets you declare a chunk containing GString data in Goc source code.</P>
<DL>
<DT>
<EM>gsname</EM></DT><DD>The name of the chunk which will contain the GString.</DD>
<DT>
<EM>command</EM></DT><DD>This may be any command which could be put in a GString. This is actually a series of bytes. Normally, the <CODE>
GS...()</CODE>
 macros are used to specify the bytes.</DD>
</DL>
<P>
An example:</P>
<PRE>@gstring MultPrimContentOneGraphic = {
	GSSetGStringBounds(10,10,48,64),
	GSSetTextColorIndex(C_VIOLET),
	GSSetFont(FID_DTC_URW_SANS, 54.0),
	GSSetTextStyle(TS_ITALIC, ~TS_ITALIC),
	GSDrawText(10, 10), &quot;1&quot;,
	GSEndString()
};</PRE>
<P>
The <CODE>
GSSetGStringBounds()</CODE>
 command has been set up to optimize use of this GString: the programmer has pre-computed the drawing bounds of the GString. The graphics system will use the pre-computed bounds to speed up clipping.</P>
<P>
The <CODE>
GSEndString()</CODE>
 command signals that the GString is done. In all but the rarest cases, all GStrings should end with an end-gstring command.</P>
</DIV>
<DIV>
<H1 CLASS="refHeading">
@header</H1>
<PRE CLASS="syntax">@header	&lt;<EM>type</EM>&gt; [= &lt;<EM>init</EM>&gt;];</PRE>
<P>
<A NAME="IX_@header[;header]">
 </A>
The @header keyword sets the header of an object or data resource segment to a custom structure. The structure must begin with an LMemBlockHeader or ObjLMemBlockHeader. The arguments of @header are given below:</P>
<DL>
<DT>
<CODE>
type</CODE>
</DT><DD>The name of the structure set as the new header type.</DD>
<DT>
<CODE>
init</CODE>
</DT><DD>Any initializer data for the fields added to your structure.</DD>
<PRE>typedef struct {
    LMemBlockHeader  meta;
    int     a;
    int     b;
} MyLMemBlockHeader;</PRE>
<PRE>@start MyDataResource, data;</PRE>
<PRE>@header MyLMemBlockHeader = 10, 12;</PRE>
<PRE>@end MyDataResource;</PRE>
</DL>
<P CLASS="refField">
See Also:	@start, @end, @object, @chunk</P>
</DIV>
<DIV>
<H1 CLASS="refHeading">
@if</H1>
<PRE CLASS="syntax">@if (&lt;<EM>cond</EM>&gt;)</PRE>
<P>
<A NAME="IX_@if[;if]">
 </A>
The @if directive denotes the beginning of a conditionally-compiled block of code. If the expression detailed in <CODE>
cond</CODE>
 equates to <CODE>
true</CODE>
, then the code between the @if directive and the first corresponding @endif directive will be compiled with the rest of the code.</P>
<DL>
<DT>
<CODE>
cond</CODE>
</DT><DD>The expression determining whether the code is to be compiled or not. This expression is based on numerical values, names of macros, and Boolean operators (|| and &amp;&amp;).</DD>
<PRE>@if 0
	/* code not compiled */
@endif</PRE>
<PRE>@if MyMacro
	/* code compiled if MyMacro is defined */
@endif</PRE>
<PRE>@if defined(MyMacro) || MY_CONDITION
	/* code compiled either if MyMacro is defined or
	 * if MY_CONDITION is non-zero */
@endif</PRE>
</DL>
<P CLASS="refField">
See Also:	@ifdef, @ifndef, @endif</P>
</DIV>
<DIV>
<H1 CLASS="refHeading">
@ifdef</H1>
<PRE CLASS="syntax">@ifdef &lt;<EM>item</EM>&gt;</PRE>
<P>
<A NAME="IX_@ifdef[;ifdef]">
 </A>
The @ifdef directive is similar to the @if directive in use, except the condition it evaluates is based solely on whether the <CODE>
item</CODE>
 is defined or not (if <CODE>
item</CODE>
 is defined, the following code is compiled).</P>
<P CLASS="refField">
See Also:	@if, @ifndef, @endif</P>
</DIV>
<DIV>
<H1 CLASS="refHeading">
@ifndef</H1>
<PRE CLASS="syntax">@ifndef &lt;<EM>item</EM>&gt;</PRE>
<P>
<A NAME="IX_@ifndef[;ifndef]">
 </A>
The @ifndef directive is similar to the @ifdef directive in use, except the condition it evaluates is based solely on whether <CODE>
item</CODE>
 is not defined (if <CODE>
item</CODE>
 is not defined, the following code is compiled).</P>
<P CLASS="refField">
See Also:	@if, @ifdef, @endif</P>
</DIV>
<DIV>
<H1 CLASS="refHeading">
@importMessage</H1>
<PRE CLASS="syntax">@importMessage &lt;<EM>expname</EM>&gt;, &lt;<EM>messageDef</EM>&gt;;</PRE>
<P>
<A NAME="IX_@importMessage[;importMessage]">
 </A>
<A NAME="IX_Messages:importing">
 </A>
The @importMessage keyword declares a message with a reserved message number set aside earlier by @exportMessages. The arguments of this keyword are given below:</P>
<DL>
<DT>
<CODE>
expname</CODE>
</DT><DD>Name of the range exported with @exportMessages.</DD>
<DT>
<CODE>
messageDef</CODE>
</DT><DD>Standard message definition--exactly the same as would follow the @message keyword for message declaration.</DD>
<PRE>@importMessage MyExportedMessages, word MSG_MY_MSG(
					byte param1, byte param2);</PRE>
</DL>
<P CLASS="refField">
See Also:	@exportMessages, @reserveMessages, @message</P>
</DIV>
<DIV>
<H1 CLASS="refHeading">
@include</H1>
<PRE CLASS="syntax">@include &lt;<EM>fname</EM>&gt;</PRE>
<P>
<A NAME="IX_@include[;include]">
 </A>
The @include directive is used to include Goc files into a code file. It is similar to the #include directive in C. Its only argument is a file name (<CODE>
fname</CODE>
) enclosed in either angled brackets or quotation marks. If you use quotation marks, the compiler will look first in the file's own directory; if you use angled brackets, it will look first in the standard include directories.</P>
<PRE>@include &lt;stdapp.goh&gt;
@include &quot;Art/mkrGenDoc&quot;</PRE>
<P CLASS="refField">
See Also:	@extern</P>
</DIV>
<DIV>
<H1 CLASS="refHeading">
@instance</H1>
<PRE CLASS="syntax">@instance &lt;<EM>insType</EM>&gt; &lt;<EM>iname</EM>&gt; = &lt;<EM>default</EM>&gt;;</PRE>
<P>
<A NAME="IX_@instance[;instance]">
 </A>
<A NAME="IX_Instance data:Goc syntax">
 </A>
<A NAME="IX_Instance data:@instance keyword">
 </A>
The @instance keyword declares an instance data field for a class. This keyword will appear between the class delimeters @class and @endc. Its arguments are shown below:</P>
<DL>
<DT>
<CODE>
insType</CODE>
</DT><DD>The data type of the instance data field. Must be a valid C data type or data structure. (Note--special types may also be used; see discussion below.)</DD>
<DT>
<CODE>
iname</CODE>
</DT><DD>The name of the instance data field.</DD>
<DT>
<CODE>
default</CODE>
</DT><DD>The default value of the field if it is not declared explicitly in the instance of the class.</DD>
</DL>
<P>
The Goc preprocessor allows the use of several special types of instance data fields. To use these special types, insert the proper keyword (type name) in place of the <CODE>
insType</CODE>
 argument above and do not include a default value for the field (<CODE>
default</CODE>
). The possible special types and their meanings are given in the list below (see the individual keyword entries for more detail):</P>
<DL>
<DT>
<STRONG>
@composite</DT><DD>
</STRONG>
This field will point to the first child in an object hierarchy. Note that this keyword has a special format. Rather than being allowed a default value, set the <CODE>
default</CODE>
 argument in the declaration to be the same as the name of the corresponding @link field. This is important; otherwise, your program will not compile properly.</DD>
<DT>
<STRONG>
@link</STRONG>
</DT><DD>This field will point to the next sibling object in an object hierarchy or will point to the parent.</DD>
<DT>
<STRONG>
@visMoniker</DT><DD>
</STRONG>
This field will contain a visual moniker or a pointer to a visual moniker resource chunk.</DD>
<DT>
<STRONG>
@kbdAccelerator</DT><DD>
</STRONG>
This field will contain a keyboard accelerator character.</DD>
</DL>
<P>
Note that if you want to declare instance data fields for variable-sized data, you should use the @vardata keyword rather than @instance.</P>
<PRE>@instance int				myInteger = 10;</PRE>
<PRE>typedef struc {
    int     a;
    int     b;
} MyStruc;
@instance MyStruc				strucField = {7, 11};</PRE>
<PRE>@instance @visMoniker 				GI_moniker;</PRE>
<PRE>@instance @link				VI_link;
@instance @composite 				VCI_comp = VI_link;</PRE>
<PRE>@instance @kbdAccelerator GI_kbdAcc;</PRE>
<P CLASS="refField">
See Also:	@vardata, @visMoniker, @link, @composite, @kbdAccelerator</P>
</DIV>
<DIV>
<H1 CLASS="refHeading">
@kbdAccelerator</H1>
<PRE CLASS="syntax">@instance @kbdAccelerator &lt;<EM>iname</EM>&gt;;</PRE>
<P>
<A NAME="IX_@kbdAccelerator[;kbdAccelerator]">
 </A>
<A NAME="IX_Keyboard accelerators:goc syntax">
 </A>
<A NAME="IX_Keyboard accelerators:@kbdAccerlerator keyword">
 </A>
The @kbdAccelerator keyword follows @instance to create an instance data field that will contain a keyboard accelerator. The <CODE>
iname</CODE>
 argument is the name of the instance data field.</P>
<PRE>@instance @kbdAccelerator GI_kbdAcc;</PRE>
<P CLASS="refField">
See Also:	@instance</P>
</DIV>
<DIV>
<H1 CLASS="refHeading">
@link</H1>
<PRE CLASS="syntax">@instance @link &lt;<EM>iname</EM>&gt;;</PRE>
<P>
<A NAME="IX_@link[;link]">
 </A>
The @link keyword follows @instance to define a link instance data field pointing to the object's next sibling in the object hierarchy. The <CODE>
iname</CODE>
 argument is the name of the instance data field. Note that the name of the link field must be set as the default value of the corresponding @composite field.</P>
<PRE>@instance @link GI_link;
@instance @composite GI_comp = GI_link;</PRE>
<P CLASS="refField">
See Also:	@instance, @composite</P>
</DIV>
<DIV>
<H1 CLASS="refHeading">
@localize</H1>
<PRE CLASS="syntax">@localize { &lt;string&gt; &lt;min&gt;-&lt;max&gt; };
@localize { &lt;string&gt; &lt;length&gt; };
@localize { &lt;string&gt; };
@localize &lt;string&gt;;
@localize not;</PRE>
<P>
<A NAME="IX_@localize">
 </A>
This keyword is used to specify instructions for translators. When appearing under a <CODE>
@visMoniker</CODE>
 or <CODE>
@chunk</CODE>
 construction, this keyword specifies a string which the ResEdit program will show to translators localizing the geode.</P>
<P>
For example:</P>
<PRE>@visMoniker FakeItemMoniker = &quot;Data:&quot;;</PRE>
<PRE>@localize &quot;This string will appear at the head of the list&quot;;</PRE>
<P>
The arguments of this keyword are as follows:</P>
<DL>
<DT>
<STRONG>
string</STRONG>
 </DT><DD>The explanatory string.</DD>
<DT>
<STRONG>
min</STRONG>
</DT><DD>The minimum length of the moniker or chunk's text.</DD>
<DT>
<STRONG>
max</STRONG>
</DT><DD>The maximum length of the moniker or chunk's text.</DD>
<DT>
<STRONG>
length</STRONG>
</DT><DD>The length of the moniker or chunk's text.</DD>
<DT>
<STRONG>
not</STRONG>
</DT><DD>Keyword specifying that the moniker or chunk can not be localized.</DD>
</DIV>
<DIV>
</DL>
<H1 CLASS="refHeading">
@message</H1>
<PRE CLASS="syntax">@message	&lt;<EM>retType</EM>&gt; &lt;<EM>mname</EM>&gt;([@stack] &lt;<EM>param</EM>&gt;*);</PRE>
<P>
<A NAME="IX_@message[;message]">
 </A>
<A NAME="IX_Messages:defining in Goc">
 </A>
<A NAME="IX_Messages:@message keyword">
 </A>
The @message keyword defines a message and its parameters and return values. This keyword will appear within a class definition (i.e., between @class and @endc). The message defined with @message will automatically be valid for the class for which it is defined as well as for subclasses of that class. The arguments of this keyword are shown below:</P>
<DL>
<DT>
<CODE>
retType</CODE>
</DT><DD>The data type of the value returned by this message. This must be a standard C or GEOS data type or pointer.</DD>
<DT>
<CODE>
mname</CODE>
</DT><DD>The name of the message. Typically, this will be the prefix &quot;MSG_&quot; followed by a shortened version of the class name, followed by a short name for the message.</DD>
<DT>
<CODE>
@stack</DT><DD>This keyword may be used if the message might be sent from assembly language code instead of Goc. It indicates that the arguments will be passed on the stack; the handler will pop them off the stack in </CODE>
<A NAME="IX_@stack[;stack]">
 </A>
<EM>
reverse order</EM>
<CODE>
 from the way they are listed in the declaration.</CODE>
</DD>
<DT>
<CODE>
param*</CODE>
</DT><DD>The parameters for this message, of which there may be none or several. All the parameters must appear inside the parentheses. Parameters are defined in a similar manner as for functions and routines; each one consists of a data type followed by the name of the parameter of that type.</DD>
<PRE>@message void MSG_TRIGGER_PUSHED(int push1);</PRE>
<PRE>@message word MSG_MY_MSG(byte firstParam, word secParam,
					long thirdParam);</PRE>
</DL>
<P CLASS="refField">
See Also:	@method, @reserveMessages, @exportMessages, @importMessage, @record</P>
</DIV>
<DIV>
<H1 CLASS="refHeading">
@method</H1>
<PRE CLASS="syntax">@method	[&lt;<EM>hname</EM>&gt;,] &lt;<EM>cname</EM>&gt;, &lt;<EM>mname</EM>&gt;+ [{&lt;code&gt;}];</PRE>
<P>
<A NAME="IX_Methods:goc syntax">
 </A>
<A NAME="IX_Methods:@method keyword">
 </A>
<A NAME="IX_@method[;method]">
 </A>
The @method keyword begins definition of a method (message handler). Its arguments are listed below:</P>
<DL>
<DT>
<CODE>
hname</CODE>
</DT><DD>The method name, if any. If no method name is given, one will be created by removing &quot;Class&quot; from the class name and &quot;MSG_&quot; from the message name and concatenating the two.</DD>
<DT>
<CODE>
cname</CODE>
</DT><DD>The name of the class to which the method belongs. Each method belongs to only one class.</DD>
<DT>
<CODE>
mname</CODE>
+</DT><DD>The name(s) of the message(s) handled by this method. There must be at least one message which invokes this method. There may be more than one, as long as they all have the same parameters.</DD>
<DT>
<EM>code</EM></DT><DD>Goc procedural code to handle the message. If there is no code, <EM>hname</EM> is assumed to be the name of an existing routine which should be used as the method.</DD>
<PRE>@method   MyClass, MSG_MY_MSG {
    /* method code goes here */
}</PRE>
<PRE>@method   MyClassMethod, MyClass, MSG_MY_MSG {
    /* method code goes here */
}</PRE>
</DL>
<P CLASS="refField">
See Also:	@message</P>
</DIV>
<DIV>
<H1 CLASS="refHeading">
@noreloc</H1>
<PRE CLASS="syntax">@noreloc <EM>&lt;iname&gt;</EM>;</PRE>
<P>
<A NAME="IX_@noreloc[;noreloc]">
 </A>
<A NAME="IX_Relocatable data:@noreloc keyword">
 </A>
The @noreloc keyword specifies that an instance data field (defined in the previous program statement) is not relocatable. Normally optr fields are assumed to be relocatable and will be automatically relocated by the system when shutting down and coming back from a shutdown; by means of the @noreloc, this automatic behavior can be turned off for a given field.</P>
</DIV>
<DIV>
<H1 CLASS="refHeading">
@object</H1>
<PRE CLASS="syntax">@object	&lt;class&gt; &lt;name&gt; &lt;flags&gt;* = {
    [&lt;fieldName&gt; = &lt;init&gt;;]*
    [&lt;varName&gt; [= &lt;init&gt;];]*
}</PRE>
<P>
<A NAME="IX_@object[;object]">
 </A>
<A NAME="IX_Objects:defining">
 </A>
<A NAME="IX_Objects:goc syntax">
 </A>
<A NAME="IX_Objects:@object keyword">
 </A>
The @object keyword defines an object in an object resource block. It must appear between @start and @end. Its arguments are defined below:</P>
<DL>
<DT>
<CODE>
class</CODE>
</DT><DD>The name of the class of the object.</DD>
<DT>
<CODE>
name</CODE>
</DT><DD>The name of the object.</DD>
<DT>
<CODE>
flags</CODE>
</DT><DD>Flags associated with the object; currently only <CODE>
ignoreDirty</CODE>
 is supported. When set, this flag indicates that changes to the object should not be saved to a state file. </DD>
<DT>
<CODE>
fieldName</CODE>
</DT><DD>The name of an instance data field defined with @instance. Any number of such fields may be specified.</DD>
<DT>
<CODE>
varName</CODE>
</DT><DD>The name of an instance data field defined with @vardata. Any number of such fields may be specified.</DD>
<DT>
<CODE>
init</CODE>
</DT><DD>Initializer data for a normal instance data field or for the extra data of a variable data field. If a variable data field has no extra data, no initializer should be specified.</DD>
</DL>
<P>
Many fields may be specified in the object declaration. Each field reference must be defined in a class in the object's class ancestry. Additionally, not all fields must be set. If a field is not specified within the @object declaration, the field will be set to its default value as defined by the class.</P>
<PRE>@start MyObjectResource;</PRE>
<PRE>@object GenTriggerClass MyTrigger ignoreDirty = {
    GI_visMoniker = &quot;MyTrigger's Moniker&quot;;
}</PRE>
<PRE>@object GenApplicationClass MyApp = {
    GI_comp = MyPrimary;
    gcnList(MANUFACTURER_ID_GEOWORKS, GAGCNLT_WINDOWS) =
							MyPrimary;
}</PRE>
<PRE>@object GenPrimaryClass MyPrimary = {
    GI_comp = MyMenu, MyInteraction, MyView;
    GI_visMoniker = &quot;My Primary's Moniker&quot;;</PRE>
<PRE>}</PRE>
<PRE>@object MyClass NewObject = {
    NO_instance1 = 1;
    NO_instance6 = `C';
}</PRE>
<PRE>@end MyObjectResource;</PRE>
<P CLASS="refField">
See Also:	@start, @end, @extern, @class, @instance, @vardata</P>
</DIV>
<DIV>
<H1 CLASS="refHeading">
@optimize</H1>
<PRE CLASS="syntax">@optimize</PRE>
<P>
<A NAME="IX_@optimize[;optimize]">
 </A>
<A NAME="IX_.poh files[;poh files]">
 </A>
This directive may be placed at the top of a <STRONG CLASS="fileName">
.goh</STRONG>
 file. The directive instructs Goc to generate a specially processed <STRONG CLASS="fileName">
.poh</STRONG>
 file which contains all the information of the <STRONG CLASS="fileName">
.goh</STRONG>
 file, but is somewhat faster to compile. This <STRONG CLASS="fileName">
.poh</STRONG>
 file is automatically regenerated if the corresponding <STRONG CLASS="fileName">
.goh</STRONG>
 file has been changed since the last compilation.</P>
</DIV>
<DIV>
<H1 CLASS="refHeading">
@protominor</H1>
<PRE CLASS="syntax">@protominor &lt;prototypeName&gt;</PRE>
<P>
<A NAME="IX_@protominor[;protominor]">
 </A>
When creating a new version of an existing library, use the <CODE>
@protominor</CODE>
 keyword to declare new messages and variable data fields for a class. Suppose your original class declaration looked like so:</P>
<PRE>@class MyClass, SuperClass;
	@message void MSG_M_DO_THIS(void);
	@vardata void TEMP_M_DONE_FLAG;
@endc</PRE>
<P>
Having released this version of your class, you wished to release another version in which this class handled another message. You wanted to specify that this new message would only work with this new version of the library. This would be set up like so:</P>
<PRE>@class MyClass, SuperClass;
	@message void MSG_M_DO_THIS(void);
	@vardata void TEMP_M_DONE_FLAG;
	@protominor MyVersion20
	@message void MSG_M_DO_THAT(void);
@endc</PRE>
<P>
You would also need to add an &quot;incminor&quot; line to the end of your .gp file:</P>
<PRE>incminor 	MyVersion20</PRE>
<P>
To do the equivalent version control with routines, use the <CODE>
incminor</CODE>
 .gp file directive.</P>
<P CLASS="refField">
See Also:	<CODE>
@protoreset</CODE>
 </P>
</DIV>
<DIV>
<H1 CLASS="refHeading">
@protoreset</H1>
<PRE CLASS="syntax">@protoreset</PRE>
<P>
The <CODE>
@protoreset</CODE>
 keyword signals that the rest of a file should ignore any previous <CODE>
@protominor</CODE>
 statements. </P>
<PRE>@class MyFirstClass, SuperClass;
	@message void MSG_M1_DO_THIS(void);
	@vardata void TEMP_M1_DONE_FLAG;
@endc
	@protominor MyVersion20
	@message void MSG_M1_DO_THAT(void);
	@protoreset</PRE>
<PRE>@class MySecondClass, SuperClass;
	@instance word M2I_token;
	@vardata void ATTR_M2_IGNORE_TOKEN;
	@protominor MyVersion20
	@vardata word ATTR_M2_ALTERNATE_TOKEN;
@endc</PRE>
</DIV>
<DIV>
<H1 CLASS="refHeading">
@prototype</H1>
<PRE CLASS="syntax">@prototype &lt;<EM>messageDef</EM>&gt;;</PRE>
<P>
<A NAME="IX_@prototype[;prototype]">
 </A>
<A NAME="IX_Messages:prototyping">
 </A>
The @prototype keyword allows multiple messages to have the same pass and return parameters. Use @prototype to define the pass and return values, then use @message to declare the messages that have these parameters. The messages defined with @message will have different message numbers and will invoke different methods. The <CODE>
messageDef</CODE>
 argument is a standard message definition.</P>
<PRE>@prototype word MSG_MY_PROTO(byte param1);</PRE>
<PRE>@message(MSG_MY_PROTO) MSG_MY_MSG;
@message(MSG_MY_PROTO) MSG_MY_SECOND_MSG;</PRE>
<P CLASS="refField">
See Also:	@alias, @message</P>
</DIV>
<DIV>
<H1 CLASS="refHeading">
@record</H1>
<PRE CLASS="syntax">&lt;<EM>event</EM>&gt; = @record &lt;<EM>obj</EM>&gt;::&lt;<EM>msg</EM>&gt;(&lt;<EM>param</EM>&gt;*);</PRE>
<P>
<A NAME="IX_@record[;record]">
 </A>
<A NAME="IX_Events:recording">
 </A>
The @record keyword encapsulates an event for later use with @dispatch or @dispatchcall. The arguments of @record are as follows:</P>
<DL>
<DT>
<CODE>
event</CODE>
</DT><DD>The name of the event. This name will be used with @dispatch and @dispatchcall later.</DD>
<DT>
<CODE>
obj</CODE>
</DT><DD>The name of the object, or an expression representing the object that will receive the message. This may be set to <CODE>
null</CODE>
 to indicate that the recipient will be determined when the message is sent.</DD>
<DT>
<CODE>
msg</CODE>
</DT><DD>The name of the message, or an expression representing the message that will be sent. This may be set to <CODE>
null</CODE>
 to indicate that the message will be determined when it it sent.</DD>
<DT>
<CODE>
param</CODE>
</DT><DD>This is a list of parameters that will be sent with the message when it is dispatched.</DD>
<PRE>myEvent = @record myObj::MSG_VIS_VUP_CREATE_GSTATE();</PRE>
</DL>
<P CLASS="refField">
See Also:	@dispatch, @dispatchcall, @call, @send</P>
</DIV>
<DIV>
<H1 CLASS="refHeading">
@reloc</H1>
<PRE CLASS="syntax">@reloc	&lt;<EM>iname</EM>&gt;, [(&lt;<EM>count</EM>&gt;, &lt;<EM>struct</EM>&gt;)] &lt;<EM>ptrType</EM>&gt;;
@reloc	&lt;iname&gt;, &lt;fn&gt;, [(&lt;<EM>count</EM>&gt;, &lt;<EM>struct</EM>&gt;)] &lt;<EM>ptrType</EM>&gt;;</PRE>
<P>
<A NAME="IX_@reloc[;reloc]">
 </A>
<A NAME="IX_Relocatable data:@reloc keyword">
 </A>
The @reloc keyword designates an instance data field that contains data requiring relocation on startup. Note that this does not include instance fields declared with the @composite and @link fields, but it does include any handle or pointer fields you may have. Note that there are two different formats for the use of @reloc. The first represents a normal instance field; the second represents a variable data instance field (see @vardata). This is <EM>
not</EM>
 used with @instance or @vardata but stands alone.</P>
<P>
The arguments of @reloc are shown below:</P>
<DL>
<DT>
<CODE>
iname</CODE>
</DT><DD>The name of the relocatable instance data field.</DD>
<DT>
<CODE>
count</CODE>
</DT><DD>If the instance variable is an array of relocatable data or structures containing relocatable fields, this is the number of elements in the array.</DD>
<DT>
<CODE>
struct</CODE>
</DT><DD>If the relocatable data is an array of structures, this represents the name of the field within each structure that requires relocation.</DD>
<DT>
<CODE>
ptrType</CODE>
</DT><DD>This is the type of pointer in the relocatable field. This must be one of <CODE>
optr</CODE>
 (object pointer), <CODE>
ptr</CODE>
 (far pointer), or <CODE>
handle</CODE>
.</DD>
<DT>
<CODE>
fn</CODE>
</DT><DD>This is the name of the field within the extra data of the variable data. If no extra data will be associated with this relocatable field, then put a zero (0) rather than a field name.</DD>
<PRE>@reloc MO_myHandle, handle;
@reloc MO_myVarHandle, 0, handle;
@reloc MO_myTable, (10, MyStruct), ptr;</PRE>
</DL>
<P CLASS="refField">
See Also:	@instance, @vardata</P>
</DIV>
<DIV>
<H1 CLASS="refHeading">
_reloc</H1>
<PRE CLASS="syntax">@method [&lt;hname&gt;,] &lt;cname&gt;, _reloc { &lt;code&gt;};</PRE>
<P>
<A NAME="IX__reloc">
 </A>
<A NAME="IX_Relocatable data:_reloc keyword">
 </A>
<A NAME="IX_MSG_META_RELOCATE:_reloc keyword">
 </A>
<A NAME="IX_MSG_META_UNRELOCATE:_reloc keyword">
 </A>
The _reloc keyword is used to write relocation handlers for classes, if you need to relocate-unrelocate instance data when it's either read in or saved to state.</P>
<P>
The arguments of _reloc are show below:</P>
<DL>
<DT>
<EM>code</EM></DT><DD>Code to execute when the object block is loaded in or saved out to state.	, in which case instance data may need to be relocated or unrelocated by hand.	</DD>
</DIV>
<DIV>
</DL>
<H1 CLASS="refHeading">
@reserveMessages</H1>
<PRE CLASS="syntax">@reserveMessages &lt;<EM>number</EM>&gt;;</PRE>
<P>
<A NAME="IX_@reserveMessages[;reserveMessages]">
 </A>
<A NAME="IX_Messages:reserving ranges">
 </A>
The @reserveMessages keyword reserves the given number of message spots. Messages are numbered sequentially according to the order of their declaration; this keyword allows one or more numbers to be skipped in the numbering process, allowing application upgrades without making earlier versions obsolete. The single argument is the number of message spots to skip.</P>
<PRE>@reserveMessages 25;</PRE>
<P CLASS="refField">
See Also:	@exportMessages, @importMessage, @message</P>
</DIV>
<DIV>
<H1 CLASS="refHeading">
@send</H1>
<PRE CLASS="syntax">@send	[&lt;<EM>flags</EM>&gt;+] [(&lt;<EM>cast_ret</EM>&gt;)] &lt;<EM>obj</EM>&gt;::[{&lt;<EM>cast_par</EM>&gt;}]&lt;<EM>msg</EM>&gt;(&lt;<EM>param</EM>&gt;*);</PRE>
<P>
<A NAME="IX_@send[;send]">
 </A>
<A NAME="IX_Messages:sending">
 </A>
The @send keyword sends a given message to the specified object. The message will be sent and the sender's thread will continue executing without waiting for a response. If return values or synchronization is important, use the @call keyword. The parameters of @send are shown below:</P>
<DL>
<DT>
<CODE>
flags</CODE>
</DT><DD>Flags that determine how the message affects the recipient's event queue. The allowable flags are shown below. (The comma is required before each flag.)</DD>
<DT>
<CODE>
cast_ret</CODE>
</DT><DD>A message to cast the message return value to. When Goc determines what type of value should be returned, it uses the return value of the <EM>cast_ret</EM> message if this field is used. The curly braces are required around this field.</DD>
<DT>
<CODE>
obj</CODE>
</DT><DD>The name of the recipient object, or an optr to the object.</DD>
<DT>
<CODE>
cast_par</CODE>
 </DT><DD>A message to cast the message parameters to. When Goc determines what type of values should be passed to the message, should be returned, it uses the parameters of the <EM>cast_par</EM> message if this field is used. The curly braces are required around this field.</DD>
<DT>
<CODE>
msg</CODE>
</DT><DD>The name of the message to be sent, or an expression representing the message number. If an expression is used, you must cast the message to a certain type with the <CODE>
cast</CODE>
 argument .</DD>
<DT>
<CODE>
param</CODE>
</DT><DD>Expressions or constants passed to the message. Parameters passed to messages are specified in the same way as if they were being passed directly to a function or routine in C. Note that pointers may <EM>
not</EM>
 be passed with @send but handles may; if you must pass a pointer, use @call.</DD>
</DL>
<P>
The flags allowed with @send are shown below:</P>
<DL>
<DT>
<STRONG>
forceQueue</DT><DD>
</STRONG>
This flag will cause the message to be placed in the recipient's event queue, even if it could have been handled by a direct call.</DD>
<DT>
<STRONG>
checkDuplicate</DT><DD>
</STRONG>
This flag makes the kernel check if a message of the same name is already in the recipient's event queue. For this flag to work, <CODE>
forceQueue</CODE>
 must also be passed. Note that due to implementation constraints, events will be checked from last to first rather than from first to last.</DD>
<DT>
<STRONG>
checkLastOnly</DT><DD>
</STRONG>
This flag works like <CODE>
checkDuplicate</CODE>
, above, except that it checks only the last message in the event queue.</DD>
<DT>
<STRONG>
replace</STRONG>
<CODE>
</DT><DD></CODE>
This flag modifies <CODE>
checkDuplicate</CODE>
 and <CODE>
checkLastOnly</CODE>
 by superseding the duplicate (old) event with the new one. The new event will be put in the duplicate's position in the event queue. If a duplicate is found but the <CODE>
replace</CODE>
 flag is not passed, the duplicate will be dropped and the new event will be put at the end of the queue.</DD>
<DT>
<STRONG>
insertAtFront</DT><DD>
</STRONG>
This puts the message at the front of the recipient's event queue. Note that this flag will supersede the <CODE>
replace</CODE>
 flag.</DD>
<DT>
<STRONG>
canDiscardIfDesperate</DT><DD>
</STRONG>
This flag indicates that this event may be discarded if the system is running extremely low on handles and requires more space immediately.</DD>
<PRE>@send, forceQueue MyObj::MSG_MY_MSG(10, x);
@send MyObj::MSG_SET_ATTR(attributesParam);</PRE>
</DL>
<P CLASS="refField">
See Also:	@call, @callsuper, @message, @method</P>
</DIV>
<DIV>
<H1 CLASS="refHeading">
@specificUI</H1>
<PRE CLASS="syntax">&lt;fname&gt;	= [@specificUI] &lt;mod&gt;* &lt;key&gt;;</PRE>
<P>
<A NAME="IX_@specificUI[;specificUI]">
 </A>
<A NAME="IX_Keyboard accelerators:@specificUI keyword">
 </A>
The @specificUI keyword is used when setting a keyboard accelerator instance field in an object declaration. It tells the UI to allow the use of the keystrokes specified, even if they are normally reserved for the specific UI. The keyword itself takes no arguments; those shown are for the <CODE>
GenClass</CODE>
 instance data field <CODE>
GI_kbdAccelerator</CODE>
. These are</P>
<DL>
<DT>
<CODE>
fname</CODE>
</DT><DD>The name of the instance data field defined with @instance.</DD>
<DT>
<CODE>
mod</CODE>
</DT><DD>Modifier keys; must be one or more of <CODE>
control</CODE>
, <CODE>
ctrl</CODE>
, <CODE>
shift</CODE>
, <CODE>
alt</CODE>
.</DD>
<DT>
<CODE>
key</CODE>
</DT><DD>The accelerator character. Must be either a numeric value of a keyboard key or a letter enclosed in single quotation marks.</DD>
<PRE>@object MyClass MyObject {
    GI_kbdAccelerator = ctrl shift `k';
}</PRE>
</DL>
<P CLASS="refField">
See Also:	<CODE>
GenClass</CODE>
, @kbdAccelerator, @instance</P>
</DIV>
<DIV>
<H1 CLASS="refHeading">
@stack</H1>
<PRE CLASS="syntax">@message	&lt;<EM>retType</EM>&gt; &lt;<EM>mname</EM>&gt;([@stack] &lt;<EM>param</EM>&gt;*);</PRE>
<P>
<CODE>
This keyword may be used if the message might be sent from assembly language code instead of Goc. It indicates that the arguments will be passed on the stack; the handler will pop them off the stack in </CODE>
<EM>
reverse order</EM>
<CODE>
 from the way they are listed in the declaration.</CODE>
</P>
<P CLASS="refField">
See Also:	@message</P>
</DIV>
<DIV>
<H1 CLASS="refHeading">
@start</H1>
<PRE CLASS="syntax">@start	&lt;segname&gt; [, &lt;flag&gt;];</PRE>
<P>
<A NAME="IX_@start[;start]">
 </A>
<A NAME="IX_Resources:goc syntax">
 </A>
<A NAME="IX_Resources:@start">
 </A>
The @start keyword indicates the beginning of a resource block. The end of the block is denoted by the keyword @end. The arguments of @start are listed below:</P>
<DL>
<DT>
<CODE>
segname</CODE>
</DT><DD>The name of the resource segment.</DD>
<DT>
<CODE>
flags</CODE>
</DT><DD>Optional flag. The flag <CODE>
data</CODE>
, when set, indicates the block will be a data resource rather than an object resource. The flag <CODE>
notDetachable</CODE>
, when set, indicates the block should not be saved to a state file. </DD>
<PRE>@start MenuResource;
@end MenuResource;</PRE>
<PRE>@start MyDialogResource, notDetachable;
@end MenuResource;</PRE>
<PRE>@start MyStringResource, data;
@end MyStringResource;</PRE>
</DL>
<P CLASS="refField">
See Also:	@end, @header, @object, @chunk</P>
</DIV>
<DIV>
<H1 CLASS="refHeading">
@uses</H1>
<PRE CLASS="syntax">@uses &lt;<EM>class</EM>&gt;;</PRE>
<P>
<A NAME="IX_@uses[;uses]">
 </A>
<A NAME="IX_Variant classes:@uses keyword">
 </A>
<A NAME="IX_Methods:@uses keyword and variant classes">
 </A>
If you know that a variant class will always be resolved to be a subclass of some particular class, you can declare this with the @uses keyword. This will let the variant class define handlers for the &quot;used&quot; superclass. The keyword uses the following argument:</P>
<DL>
<DT>
<EM>class</EM></DT><DD>A class which will always be a superclass of the defined variant class.</DD>
</DL>
<P CLASS="refField">
Warnings:	You must make sure that the variant class's inheritance is always resolved such that the used class is one of its ancestor classes.</P>
<P CLASS="refField">
See Also:	@class</P>
</DIV>
<DIV>
<H1 CLASS="refHeading">
@vardata</H1>
<PRE CLASS="syntax">@vardata	&lt;<EM>type</EM>&gt; &lt;<EM>vname</EM>&gt;;</PRE>
<P>
<A NAME="IX_@vardata[;vardata]">
 </A>
<A NAME="IX_Variable data:Goc syntax">
 </A>
<A NAME="IX_Variable data:@vardata keyword">
 </A>
The @vardata keyword creates a vardata data type for a class. Each type created with @vardata can be simply the name of the type, or it can have additional data (a single structure). The arguments of @vardata are given @defaultbelow:</P>
<DL>
<DT>
<CODE>
type</CODE>
</DT><DD>This is the data type or structure type of the data field. If no extra data is to be associated with this field, then put the word <CODE>
void</CODE>
 in place of a type.</DD>
<DT>
<CODE>
vname</CODE>
</DT><DD>This is the name of the variable data instance field.</DD>
<PRE>@vardata		dword		MY_FIRST_VAR_DATA;</PRE>
<PRE>typedef struc {
    int     a;
    int     b;
} MyStruc;</PRE>
<PRE>@vardata		MyStruc		MY_SECOND_VAR_DATA;
@vardata		void		MY_THIRD_VAR_DATA;</PRE>
</DL>
<P CLASS="refField">
See Also:	@vardataAlias, @instance</P>
</DIV>
<DIV>
<H1 CLASS="refHeading">
@vardataAlias</H1>
<PRE CLASS="syntax">@vardataAlias (&lt;<EM>origName</EM>&gt;) &lt;<EM>newType</EM>&gt; &lt;<EM>newName</EM>&gt;;</PRE>
<P>
<A NAME="IX_@vardataAlias[;vardataAlias]">
 </A>
<A NAME="IX_Variable data:with varying amounts of extra data">
 </A>
The @vardataAlias keyword allows you to set up variable data fields with varying amounts of extra data. That is, a single variable data field in the instance chunk could have two different sizes and two different names. The arguments of @vardataAlias are listed below:</P>
<DL>
<DT>
<CODE>
origName</CODE>
</DT><DD>The name of the original variable data field defined with @vardata.</DD>
<DT>
<CODE>
newType</CODE>
</DT><DD>The new type or structure associated with this variable data field. If no extra data is to be associated with this alias, then put the word <CODE>
void</CODE>
 instead of a type.</DD>
<DT>
<CODE>
newName</CODE>
</DT><DD>The new name of the variable data field that uses the new type.</DD>
<PRE>/* defined in GenTriggerClass */</PRE>
<PRE>@vardata word ATTR_GEN_TRIGGER_ACTION_DATA;</PRE>
<PRE>/* A special GenTrigger that uses a different data
 * type is defined in the application: */</PRE>
<PRE>@object GenTriggerClass MyTrigger = {
    GTI_actionMsg = MSG_MY_APPS_MESSAGE;
    GTI_destination = process;
    @vardataAlias (ATTR_GEN_TRIGGER_ACTION_DATA)
			dword ATTR_MY_TRIGGER_SPECIAL_DATA;</PRE>
</DL>
<P CLASS="refField">
See Also:	@vardata, @instance</P>
</DIV>
<DIV>
<H1 CLASS="refHeading">
@visChildren</H1>
<PRE CLASS="syntax">@send @visChildren::<EM>&lt;msg&gt;</EM>(<EM>&lt;params&gt;</EM>);</PRE>
<P>
<A NAME="IX_@visChildren (messaging shortcut)[;visChildren]">
 </A>
Any composite object in a visible object tree (therefore a subclass of <CODE>
VisCompClass</CODE>
) can send a message that will be dispatched at once to all of its children. Note that any message sent with @visChildren as the destination must be dispatched with the <CODE>
@send</CODE>
 keyword and therefore can have no return value.</P>
</DIV>
<DIV>
<H1 CLASS="refHeading">
@visMoniker</H1>
<PRE CLASS="syntax">@instance @visMoniker &lt;<EM>iname</EM>&gt;;</PRE>
<P>
<A NAME="IX_@visMoniker[;visMoniker]">
 </A>
<A NAME="IX_Monikers:@visMoniker keyword">
 </A>
The @visMoniker keyword follows @instance to create an instance data field for a visual moniker. The <CODE>
iname</CODE>
 argument is the name of the instance data field.</P>
<PRE>@instance @visMoniker GI_visMoniker;</PRE>
<P CLASS="refField">
See Also:	@instance, <CODE>
GenClass</CODE>
</P>
</DIV>
<DIV>
<H1 CLASS="refHeading">
@visParent</H1>
<PRE CLASS="syntax">@send @visParent::<EM>&lt;msg&gt;</EM>(<EM>&lt;params&gt;</EM>);</PRE>
<P>
<A NAME="IX_@visParent (messaging shortcut)[;visParent]">
 </A>
Any object in a visible tree can use <CODE>
@visParent</CODE>
 as the destination of an <CODE>
@call</CODE>
 command. The message will be sent to the object's parent in the visible object tree. The remainder of the command is the same as a normal <CODE>
@call</CODE>
.<CODE>
</CODE>
</P>
</DIV>
</DIV>
</DIV>
<HR>
<!-- This blob is a bunch of standard links: up, back, index, etc. -->
<!-- up to top -->|&nbsp;<A HREF="../../index.htm"><IMG SRC="../../docImages/upTop.gif" ALT="Up: " BORDER="0">GEOS SDK TechDocs</A>
<!-- up to parent -->| <A HREF="../../index.htm"><IMG SRC="../../docImages/up.gif" ALT="Up" BORDER="0"></A>
<!-- down to first child --> 
<!-- to previous --> 
<!-- to next --> 
<HR>
<!-- That blob was a bunch of standard links: up, back, index, etc. -->
</BODY>
</HTML>
