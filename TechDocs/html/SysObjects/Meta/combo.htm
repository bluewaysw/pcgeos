<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD>
<!-- This page was automatically generated from a bunch of smaller pages. -->
<META NAME="copyright" CONTENT="Copyright GEOWORKS">
<LINK REL="STYLESHEET" HREF="../../docHelpers/style.css">
<LINK REV="MADE" HREF="mailto:doc-feedback@geoworks.com">
<TITLE>MetaClass</TITLE>
</HEAD>
<BODY BGCOLOR="#ffffdf">
This document is a single-page version of a <A HREF="index.htm">a multi-page document</A>, suitable for easy printing.
<A NAME="index.htm"></A>



<H1 CLASS="chapterTitle">

<A NAME="index.htm_97933">
 </A>
MetaClass

</H1>
<P>
<CODE>
MetaClass</CODE>
<A NAME="index.htm_IX_MetaClass">
 </A>
 is the ancestor class of every GEOS object. <CODE>
MetaClass</CODE>
 is the location of basic messages and their handlers. Basic functionality for all objects--instantiation, initialization, detach, and destruction--is implemented within this class.</P>
<P>
<A NAME="index.htm_IX_MI_base">
 </A>
The only instance data field defined for <CODE>
MetaClass</CODE>
 is the object's class pointer (the field is named <CODE>
MI_base</CODE>
). <CODE>
MetaClass</CODE>
 has no other inherent data fields. You will never need to access the class pointer directly.</P>
<P>
<CODE>
MetaClass</CODE>
 also serves as a sort of placeholder for certain messages. Application writers familiar with mouse input, for instance, know that <CODE>
MSG_META_START_SELECT</CODE>
 signals a mouse click. This message is actually defined at the <CODE>
MetaClass</CODE>
 level, though <CODE>
MetaClass</CODE>
<P CLASS="sectionlinks">
<STRONG>
&nbsp;&nbsp;<A HREF="#MetaClass_1.htm">1 Special Messages</A><BR>
&nbsp;&nbsp;<A HREF="#MetaClass_2.htm">2 Utility Messages</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#MetaClass_3.htm">2.1 Object Creation and Destruction</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#MetaClass_4.htm">2.2 Class Messages</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#MetaClass_5.htm">2.3 Object Management Messages</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#MetaClass_6.htm">2.4 User Interface Utility Meta Messages</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#MetaClass_7.htm">2.5 Event Messages</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#MetaClass_8.htm">2.6 Variable Data Messages</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#MetaClass_9.htm">2.7 Notification Messages</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#MetaClass_a.htm">2.8 Options Messages</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#MetaClass_b.htm">2.9 Suspending and Unsuspending</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#MetaClass_c.htm">2.10 Help Files</A><BR>
&nbsp;&nbsp;<A HREF="#MetaClass_d.htm">3 Exported Message Ranges</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#MetaClass_e.htm">3.1 Window Messages</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#MetaClass_f.htm">3.2 Input Messages</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#MetaClass_10.htm">3.3 UI Messages</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#MetaClass_11.htm">3.4 Standard GCN Messages</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#MetaClass_12.htm">3.5 IACP Meta Messages</A><BR>
</STRONG>
</P> <!-- end of sectionlinks blob -->

<HR>
<A NAME="MetaClass_1.htm"></A>


<H2 CLASS="sectionTitle">
<A HREF="#index.htm">MetaClass</A>: 1 
Special Messages</H2>
<PRE>MSG_META_NULL, MSG_META_DUMMY</PRE>
<P>
The following two messages are mainly place holders. They ensure that no message will have the value zero or one. (When a message is called, a value of zero equates to null.) These are not used by applications or objects in general.</P>

<H6 CLASS="RefETitle">
<A NAME="MetaClass_1.htm_IX_MSG_META_NULL">
 </A>
MSG_META_NULL</H6>
<PRE CLASS="syntax">void	MSG_META_NULL();</PRE>
<P>
This message has no handler and is unused. It essentially ensures that no other message will ever have the value zero.</P>
<P CLASS="refField">
Interception:	Don't.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_1.htm_IX_MSG_META_DUMMY">
 </A>
MSG_META_DUMMY</H6>
<PRE CLASS="syntax">void	MSG_META_DUMMY();</PRE>
<P>
<A NAME="MetaClass_1.htm_IX_Variant classes:resolving">
 </A>
This message has no handler. You should not subclass this message to provide one. Certain object mechanisms, such as the resolution of a variant class, are activated by the object's receipt of <CODE>
MSG_META_DUMMY</CODE>
.</P>
<P CLASS="refField">
Interception:	Don't.</P>

<HR>
<A NAME="MetaClass_2.htm"></A>


<H2 CLASS="sectionTitle">
<A HREF="#index.htm">MetaClass</A>: 2 
Utility Messages</H2>
<P>
<CODE>
MetaClass</CODE>
 also provides a number of other messages that are used throughout the system. These messages have been separated into loosely-defined categories and listed in the sections below.</P>
<P CLASS="subsectionLink">
<A HREF="#MetaClass_3.htm">Object Creation and Destruction</A></P>
<P CLASS="subsectionLink">
<A HREF="#MetaClass_4.htm">Class Messages</A></P>
<P CLASS="subsectionLink">
<A HREF="#MetaClass_5.htm">Object Management Messages</A></P>
<P CLASS="subsectionLink">
<A HREF="#MetaClass_6.htm">User Interface Utility Meta Messages</A></P>
<P CLASS="subsectionLink">
<A HREF="#MetaClass_7.htm">Event Messages</A></P>
<P CLASS="subsectionLink">
<A HREF="#MetaClass_8.htm">Variable Data Messages</A></P>
<P CLASS="subsectionLink">
<A HREF="#MetaClass_9.htm">Notification Messages</A></P>
<P CLASS="subsectionLink">
<A HREF="#MetaClass_a.htm">Options Messages</A></P>
<P CLASS="subsectionLink">
<A HREF="#MetaClass_b.htm">Suspending and Unsuspending</A></P>
<P CLASS="subsectionLink">
<A HREF="#MetaClass_c.htm">Help Files</A></P>
<HR>
<A NAME="MetaClass_3.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">MetaClass</A>: 2.1 <A HREF="#MetaClass_2.htm">Utility Messages</A>: 
Object Creation and Destruction</H3>
<P>
<A NAME="MetaClass_3.htm_IX_Threads:creation and destruction messages">
 </A>
<A NAME="MetaClass_3.htm_IX_Objects:destroying">
 </A>
<A NAME="MetaClass_3.htm_IX_Objects:creating">
 </A>
These messages handle creation, destruction, and initialization of all objects. The function and use of many of these messages are given in <A HREF="../../Programming/GOCLanguage/combo.htm"></A>.</P>

<H6 CLASS="RefETitle">
<A NAME="MetaClass_3.htm_IX_MSG_META_INITIALIZE">
 </A>
MSG_META_INITIALIZE</H6>
<PRE CLASS="syntax">void	MSG_META_INITIALIZE();</PRE>
<P>
<A NAME="MetaClass_3.htm_IX_Instance data:initializing">
 </A>
Every object class should provide a handler for this message which should call the superclass and then perform any initialization of the instance data required. This message is not delivered to statically declared objects because they are already initialized.</P>
<P>
Note that <CODE>
GenClass</CODE>
 and <CODE>
VisClass</CODE>
 have a default handler that sets up the Gen and Vis parts automatically. </P>
<P>
This message is not delivered to objects whose only master part is <CODE>
MetaClass</CODE>
 itself. </P>
<P CLASS="refField">
Source:	Object system itself, often in the middle of attempting to deliver another message to an object that hasn't yet been initialized.</P>
<P CLASS="refField">
Destination:	Object whose instance data is not yet initialized.</P>
<P CLASS="refField">
Parameters:	None.</P>
<P CLASS="refField">
Return:	Nothing.</P>
<P CLASS="refField">
Interception:	Any class wishing to have default instance data values other than all zeros should intercept this message to fill in the initial values for its instance data. For classes other than master classes, standard procedure is to call the superclass first, then perform any additional instance data initialization necessary. Master classes should <EM>
not</EM>
 call the superclass, as <CODE>
MSG_META_INITIALIZE</CODE>
 is unique among messages in that it is sent only to classes within the particular master group that needs to be initialized. Handlers of <CODE>
MSG_META_INITIALIZE</CODE>
 should limit their activities to just stuffing instance data--specifically, object messaging is not allowed (though scanning vardata is OK). Object classes that inherit instance data (all but <CODE>
MetaClass</CODE>
) should call <CODE>
MSG_META_INITIALIZE</CODE>
 on their superclass to initialize that portion of their instance data. In addition, they must initialize their own portion of the instance data (start by assuming it's all zeros). The order won't matter, so long as the handler doesn't depend on the inherited instance data having any particular value. When in doubt, call the superclass first.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_3.htm_IX_MSG_META_ATTACH">
 </A>
MSG_META_ATTACH</H6>
<PRE CLASS="syntax">void 	MSG_META_ATTACH();</PRE>
<P>
<A NAME="MetaClass_3.htm_IX_Active list:MSG_META_ATTACH">
 </A>
This message is used for two different purposes: It can be sent to any geode that has a process aspect when the geode is first loaded. It can also be sent in the object world to notify objects on an &quot;active list&quot; that the application has been brought back up from a state file. As the method is used for different purposes, the data passed varies based on usage. Because of this difference in parameters, normally C applications will use one of the aliases for this message (<CODE>
MSG_META_ATTACH_PROCESS</CODE>
,<CODE>
 MSG_META_ATTACH_THREAD</CODE>
, <CODE>
MSG_META_ATTACH_GENPROCESSCLASS</CODE>
, <CODE>
MSG_META_ATTACH_OBJECT,</CODE>
 and<CODE>
 MSG_META_ATTACH_GENAPPLICATION</CODE>
, each described below.)</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_3.htm_IX_MSG_META_ATTACH_PROCESS">
 </A>
MSG_META_ATTACH_PROCESS</H6>
<PRE CLASS="syntax">@alias (MSG_META_ATTACH)
 void 	MSG_META_ATTACH_PROCESS(
        word 	value1,
        word 	value2);</PRE>
<P>
<A NAME="MetaClass_3.htm_IX_ProcessClass:attaching">
 </A>
<A NAME="MetaClass_3.htm_IX_Geodes:attaching">
 </A>
This message is sent to any geode which has a process when the geode is first loaded. By default, the handler for this message does nothing.</P>
<P CLASS="refField">
Source:	<CODE>
GeodeLoad()</CODE>
 kernel routine.</P>
<P CLASS="refField">
Destination:	Newly created Process object (but not GenProcess object).</P>
<P CLASS="refField">
Parameters:	<EM>value1</EM>	Upper half of <CODE>
GeodeLoad()</CODE>
 <EM>appInfo</EM> argument.</P>
<DL>
<DT>
<EM>value2</EM></DT><DD>Lower half of <CODE>
GeodeLoad()</CODE>
 <EM>appInfo</EM> argument.</DD>
</DL>
<P CLASS="refField">
Return:	Nothing.</P>
<P CLASS="refField">
Interception:	No default handling provided, so if you are spawning an extra process and that process needs to do some initialization, then intercept this message.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_3.htm_IX_MSG_META_ATTACH_GENPROCESSCLASS">
 </A>
MSG_META_ATTACH_GENPROCESSCLASS</H6>
<PRE CLASS="syntax">@alias (MSG_META_ATTACH)
 void 	MSG_META_ATTACH_GENPROCESSCLASS(
        MemHandle appLaunchBlock);</PRE>
<P>
<A NAME="MetaClass_3.htm_IX_GenProcessClass:attaching">
 </A>
This message is sent to the GenProcess object when the geode is first loaded. By default, the handler for this message calls <CODE>
MSG_PROCESS_STARTUP_UI_THREAD</CODE>
, which checks to see if there are any resources of the application which are marked as &quot;ui-object&quot; (they are marked this way in the <STRONG CLASS="fileName">
.gp</STRONG>
 file), that is, to be run by a UI thread. If so, it then calls <CODE>
MSG_PROCESS_CREATE_UI_THREAD</CODE>
 to create that thread, then marks the &quot;ui-object&quot; blocks as run by that thread.</P>
<P>
The handler next calls one of the following messages:</P>
<DL>
<DT>
<CODE>
MSG_GEN_PROCESS_OPEN_APPLICATION</DT><DD>
</CODE>
For applications which are being started up regularly (that is, not restoring from a state file) and will appear on screen.</DD>
<DT>
<CODE>
MSG_GEN_PROCESS_OPEN_ENGINE</DT><DD>
</CODE>
For those applications that will operate in engine mode (i.e. non-visual).</DD>
<DT>
<CODE>
MSG_GEN_PROCESS_RESTORE_FROM_STATE</DT><DD>
</CODE>
For applications which are restoring from state. This is the case for applications that were running at the previous shutdown.</DD>
</DL>
<P CLASS="refField">
Source:	<CODE>
GeodeLoad()</CODE>
 kernel routine.</P>
<P CLASS="refField">
Destination:	Newly created <CODE>
GenProcessClass</CODE>
 (or subclass thereof) object.</P>
<P CLASS="refField">
Parameters:	<EM>appLaunchBlock</EM>	Block handle to block of structure <CODE>
AppLaunchBlock</CODE>
.</P>
<P CLASS="refField">
Return:	Nothing.</P>
<DL>
<DT>
Note that the passed <CODE>
AppLaunchBlock</CODE>
 is destroyed.</DT>
</DL>
<P CLASS="refField">
Interception:	No default handling provided, so if you are spawning an extra process and that process needs to do some initialization, then intercept this message.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_3.htm_IX_MSG_META_ATTACH_GENAPPLICATION">
 </A>
MSG_META_ATTACH_GENAPPLICATION</H6>
<PRE CLASS="syntax">@alias (MSG_META_ATTACH)
 void 	MSG_META_ATTACH_PROCESS(
        MemHandle 	bh1,
        MemHandle 	bh2);</PRE>
<P>
<A NAME="MetaClass_3.htm_IX_GenApplicationClass:attaching">
 </A>
This message is sent to the GenApplication object by <CODE>
GenProcessClass</CODE>
 when the application starts up (either for the first time, or when being restored from a state file).</P>
<P CLASS="refField">
Source:	GenProcess object.</P>
<P CLASS="refField">
Destination:	GenApplication object.</P>
<P CLASS="refField">
Parameters:	<EM>bh1</EM>	Block handle to block containing <CODE>
AppLaunchBlock</CODE>
 parameters.</P>
<DL>
<DT>
<EM>bh2</EM></DT><DD>Extra state block from state file, or NULL if none. This is the same block as returned from <CODE>
MSG_GEN_PROCESS_CLOSE_APPLICATION</CODE>
 in some previous detach operation.</DD>
</DL>
<P CLASS="refField">
Return:	Nothing.</P>
<DL>
<DT>
Note that the <CODE>
AppLaunchBlock</CODE>
 is destroyed.</DT>
</DL>
<P CLASS="refField">
Interception:	Not generally required, since the default handler broadcasts the message out to everything on the application's active lists. This act causes the interface for the application to come up on screen.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_3.htm_IX_MSG_META_ATTACH_OBJECT">
 </A>
MSG_META_ATTACH_OBJECT</H6>
<PRE CLASS="syntax">@alias (MSG_META_ATTACH)
 void 	MSG_META_ATTACH_OBJECT(
        word	 	flags,
        MemHandle 		appLaunchBlock,
        MemHandle 		extraState);</PRE>
<P>
<A NAME="MetaClass_3.htm_IX_Active list:MSG_META_ATTACH_OBJECT">
 </A>
This message is sent to any object on the GenApplication object's active lists, or on one of those object's active lists. Note that this will not happen until the GenApplication is set usable by the GenProcess object.</P>
<P CLASS="refField">
Source:	<CODE>
GenApplicationClass</CODE>
 object.</P>
<P CLASS="refField">
Destination:	Any object.</P>
<P CLASS="refField">
Parameters:	<EM>flags</EM>	Flags providing state information.</P>
<DL>
<DT>
<EM>appLaunchBlock</EM></DT><DD>Handle of <CODE>
AppLaunchBlock</CODE>
, or NULL if none.</DD>
<DT>
<EM>extraState</EM> </DT><DD>Handle of extra state block, or NULL if none. This is the same block as returned from <CODE>
MSG_GEN_PROCESS_CLOSE_APPLICATION</CODE>
, in some previous detach.</DD>
</DL>
<P CLASS="refField">
Return:	Nothing.</P>
<P CLASS="refField">
Interception:	Standard UI objects defined as needing to be placed on an active list will intercept this message to do whatever it is that they needed to do when the application is first loaded. Objects intercepting this message should call the superclass, in case it expects to receive this notification itself.</P>
<P CLASS="refField">
Warnings:	If the specific UI uses this mechanism, then the <CODE>
GenProcessClass</CODE>
 will have already destroyed the <CODE>
AppLaunchBlock</CODE>
 and extra state block by the time the <CODE>
MSG_META_ATTACH</CODE>
 is sent to objects on its active list.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_3.htm_IX_MSG_META_ATTACH_THREAD">
 </A>
MSG_META_ATTACH_THREAD</H6>
<PRE CLASS="syntax">@alias (MSG_META_ATTACH)
 void 	MSG_META_ATTACH_THREAD();</PRE>
<P>
This message is sent to any thread spawned by <CODE>
MSG_PROCESS_CREATE_EVENT_THREAD</CODE>
.</P>
<P CLASS="refField">
Source:	Kernel.</P>
<P CLASS="refField">
Destination:	Newly created thread, specifically the class designated to handle the thread's messages (a subclass of <CODE>
ProcessClass</CODE>
).</P>
<P CLASS="refField">
Parameters:	None.</P>
<P CLASS="refField">
Return:	Nothing.</P>
<P CLASS="refField">
Interception:	No default handling provided, so if you are spawning an extra process and that process needs to do some initialization, then intercept this message.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_3.htm_IX_MSG_META_APP_STARTUP">
 </A>
MSG_META_APP_STARTUP</H6>
<PRE CLASS="syntax">void	MSG_META_APP_STARTUP(
        MemHandle		appLaunchBlock);</PRE>
<P>
This message is related to MSG_META_ATTACH; the message is sent by the generic UI to the GenApplication object before it sends MSG_META_ATTACH to it. MSG_META_ATTACH is only sent when the application is becoming available to the user; if an application should be opened as a server without presenting any UI to the user, MSG_META_APP_STARTUP will be the only message sent to the application object upon start-up.</P>
<P>
The default handler for this message will pass it on to all members of the MGCNLT_APP_STARTUP list.</P>
<P CLASS="refField">
Source:	<CODE>
GenProcessClass</CODE>
; forwarded by <CODE>
GenApplicationClass</CODE>
 to other objects. This message is sent upon application start-up before the UI for an application has been attached.</P>
<P CLASS="refField">
Destination:	Any object that needs to be notified when the application is launched, regardless of whether the user will be interacting with the application.</P>
<P CLASS="refField">
Parameters:	<EM>
appLaunchBlock</EM>
	Handle of an <CODE>
AppLaunchBlock</CODE>
.</P>
<P CLASS="refField">
Return:	The <CODE>
AppLaunchBlock</CODE>
 is preserved.</P>
<P CLASS="refField">
Interception:	Usually intercepted by any object on the MGCNLT_APP_STARTUP list.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_3.htm_IX_MSG_META_UPDATE_WINDOW">
 </A>
MSG_META_UPDATE_WINDOW</H6>
<PRE CLASS="syntax">void	MSG_META_UPDATE_WINDOW(
        UpdateWindowFlags		updateFlags,
        VisUpdateMode		updateMode);</PRE>
<P>
This message is sent as part of the system's window update mechanism. Typically, this message is sent to windowed objects on the GAGNLT_WINDOWS list when the GenApplication object becomes GS_USABLE. </P>
<P>
The message passes a bitfield of <CODE>
UpdateWindowFlags</CODE>
. These flags determine the type of action prompting the window update.</P>
<DL>
<DT>
UWF_ATTACHING</DT><DD>
If set, the message is being sent because the application is attaching.</DD>
<DT>
UWF_DETACHING</DT><DD>
If set, the message is being sent because the application is detaching.</DD>
<DT>
UWF_RESTORING_FROM_STATE</DT><DD>
If set, the application is restoring from state. This flag will only be set if UWF_ATTACHING is also set.</DD>
<DT>
UWF_FROM_WINDOWS_LIST</DT><DD>
If set, the message is being sent because the object is on the GAGCNLT_WINDOWS list, and not because it was later built on demand. This flag will only be set if UWF_ATTACHING is also set. </DD>
</DL>
<P CLASS="refField">
Source:	Window update mechanism.</P>
<P CLASS="refField">
Destination:	Entries on the Application's GAGCNLT_WINDOWS list.</P>
<P CLASS="refField">
Parameters:	<EM>
updateFlags</EM>
	<CODE>
UpdateWindowFlags</CODE>
.</P>
<DL>
<DT>
<EM>
updateMode</EM>
</DT><DD><CODE>
VisUpdateMode</CODE>
.</DD>
</DL>
<P CLASS="refField">
Interception:	Generally not intercepted.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_3.htm_IX_MSG_META_DETACH">
 </A>
MSG_META_DETACH</H6>
<PRE CLASS="syntax">void	MSG_META_DETACH(
        word	callerID,
        optr	caller);</PRE>
<P>
<A NAME="MetaClass_3.htm_IX_Active list:MSG_META_DETACH">
 </A>
This message severs the links between an object and the rest of the system. The exact way this is handled depends on the object being detached. For full information on detaching objects, see <A HREF="../../Programming/GOCLanguage/combo.htm">the GEOS Programming chapter</A>.</P><P>
The &quot;state&quot; of the object is left intact, in case an image of the object needs to be saved away in a state file for later re-creation. <CODE>
MSG_META_DETACH</CODE>
 sent to an application's process will start the process by which it is detached from the system, and then exited. <CODE>
MSG_META_DETACH</CODE>
 is asynchronous, in that it need not complete its job immediately upon being called. Rather, it may take as much time, invoking and waiting for the completion of subsidiary detaches (say of child objects needing to perform special actions to detach, or of threads created earlier), before it responds with <CODE>
MSG_META_ACK</CODE>
 to let its caller know that the detach has completed.</P>
<P CLASS="refField">
Source:	Kernel, other objects relaying detach message.</P>
<P CLASS="refField">
Destination:	GenProcess, GenApplication, objects on active lists.</P>
<P CLASS="refField">
Parameters:	<CODE>callerID</CODE>
A number of your choosing. This number will be passed back to
<EM>caller</EM> in MSG_META_ACK in the <EM>callID</EM> parameter.
</P>
<DL>
<DT>
<EM>caller</EM> </DT><DD>Object which should be sent a <CODE>
MSG_META_ACK</CODE>
 when detaching object has finished.</DD>
</DL>
<P CLASS="refField">
Return:	Nothing.</P>
<P CLASS="refField">
Interception:	Intercepted as a means of finding out that the application is shutting down. Call the superclass in case it needs such notification.<BR>
If you create additional threads, or object classes which need to be notified when the application is about to be exited, you may need to extend the detach mechanism by intercepting <CODE>
MSG_META_DETACH</CODE>
 in a subclass of an object already receiving that message, such as GenApplication, GenControl, GenInteraction dialogs, etc. You must make sure that all objects you've sent <CODE>
MSG_META_DETACH</CODE>
 to have responded with a <CODE>
MSG_META_ACK</CODE>
 before your object can reply with <CODE>
MSG_META_ACK</CODE>
. Remember that your superclass may be sending <CODE>
MSG_META_DETACH</CODE>
. The kernel provides some default behavior in <CODE>
MetaClass</CODE>
, and some utility routines, to make this a simpler task. The default handler for <CODE>
MSG_META_DETACH</CODE>
, for instance, at a leaf object (one which doesn't propagate the <CODE>
MSG_META_DETACH</CODE>
), performs the required response (sending a <CODE>
MSG_META_ACK</CODE>
). Thus, leaf objects can just intercept <CODE>
MSG_META_DETACH</CODE>
 for notification purposes, then call the superclass, and worry no more. The utility routines<CODE>
 ObjInitDetach()</CODE>
 and <CODE>
ObjEnableDetach()</CODE>
 work in conjunction with a default <CODE>
MSG_META_ACK</CODE>
 handler in <CODE>
MetaClass</CODE>
 to keep track of how many outstanding acknowledgments are being waited for, and call <CODE>
MSG_META_DETACH_COMPLETE</CODE>
 on your object once all acknowledgments have returned (the count reaches zero). The default handler for <CODE>
MSG_META_DETACH_COMPLETE</CODE>
 then generates the acknowledgment response required of your object to complete its detach. You may optionally call the superclass before sending the detach message to your children and dependents, depending on which order you want things to detach in. The call to the superclass must happen between the <CODE>
ObjInitDetach()</CODE>
 and <CODE>
ObjEnableDetach()</CODE>
, however.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_3.htm_IX_MSG_META_DETACH_COMPLETE">
 </A>
MSG_META_DETACH_COMPLETE</H6>
<PRE CLASS="syntax">void	MSG_META_DETACH_COMPLETE();</PRE>
<P>
This message is sent to an object being detached when all of its children and active participants have acknowledged the detach. For full information on detaching objects, see <A HREF="../../Programming/GOCLanguage/combo.htm">the GEOS Programming chapter</A>.</P><P>
<CODE>
MSG_META_DETACH_COMPLETE</CODE>
 is sent to the object which called <CODE>
ObjInitDetach()</CODE>
. This will happen when as many acknowledgments have been received as <CODE>
ObjIncDetach()</CODE>
 was called, and <CODE>
ObjEnableDetach()</CODE>
 was called. The <CODE>
MetaClass</CODE>
 handler for this message sends <CODE>
MSG_META_ACK</CODE>
 to the OD passed to the <CODE>
ObjInitDetach()</CODE>
 call. This message is provided so that an object will know when all of its children have detached. Note that this message is received only if <CODE>
ObjInitDetach()</CODE>
 has been called for this object. Note also that your superclass may call <CODE>
ObjInitDetach()</CODE>
 without your knowing.</P>
<P CLASS="refField">
Source:	<CODE>
MetaClass</CODE>
 handler for <CODE>
MSG_META_ACK</CODE>
, if detach count has dropped to zero (i.e. no outstanding requests), for objects that are detach nodes only (make use of <CODE>
ObjInitDetach()</CODE>
 or <CODE>
ObjEnableDetach()</CODE>
).</P>
<P CLASS="refField">
Destination:	Self.</P>
<P CLASS="refField">
Parameters:	None.</P>
<P CLASS="refField">
Return:	Nothing.</P>
<P CLASS="refField">
Interception:	This is a handy message to intercept when using the <CODE>
ObjInitDetach()</CODE>
 mechanism and need to know when all objects asked to detach have responded. Calling the superclass at this point in time will cause an <CODE>
MSG_META_ACK</CODE>
 to go back to whatever object sent the <CODE>
MSG_META_DETACH</CODE>
 to this object originally. There is no requirement to call the superclass at this time, and in fact this is a way to prolong the detach cycle for this object-- by simply starting up another <CODE>
ObjInitDetach()</CODE>
 sequence, for instance.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_3.htm_IX_MSG_META_DETACH_ABORT">
 </A>
MSG_META_DETACH_ABORT</H6>
<PRE CLASS="syntax">void	MSG_META_DETACH_ABORT();</PRE>
<P>
This message causes a detach to be aborted. This can cause some very complex synchronization problems and should not be used lightly. You will find very little call to use it.</P>
<P CLASS="refField">
Source:	Renegade object on active list, after having received <CODE>
MSG_META_DETACH</CODE>
, as an alternative to replying with <CODE>
MSG_META_ACK</CODE>
.</P>
<P CLASS="refField">
Destination:	The optr passed in <CODE>
MSG_META_DETACH</CODE>
.</P>
<P CLASS="refField">
Interception:	Handled by GenField to deal with applications that refuse to die, and GenSystem for Fields that have problem applications. Other than that, any detach node wishing to provide this service will have to figure out a way to do it itself.</P>
<P CLASS="refField">
Parameters:	None.</P>
<P CLASS="refField">
Return:	Nothing.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_3.htm_IX_MSG_META_APP_SHUTDOWN">
 </A>
MSG_META_APP_SHUTDOWN</H6>
<PRE CLASS="syntax">void	MSG_META_APP_SHUTDOWN(
        word		callerID,
        optr		ackOD);</PRE>
<P>
This message is the complement to MSG_META_APP_STARTUP. This message is sent to objects on the MGCNLT_APP_STARTUP list before an application exits but after the UI for the application is detached. Essentially, it operates in the same manner as MSG_META_DETACH except that the receiving object sends MSG_META_SHUTDOWN_ACK when its shutdown is complete.</P>
<P CLASS="refField">
Source:	Sent by <CODE>
GenProcessClass</CODE>
 after detaching the UI but before exiting the application; if the UI was never attached (i.e. it handled MSG_META_APP_STARTUP but not MSG_META_ATTACH) the UI will obviously not be detached.</P>
<P CLASS="refField">
Destination:	Any object that needs to be notified when the application is about to exit.</P>
<P CLASS="refField">
Parameters:	<EM>
callerID</EM>
	Word of data for caller's use.</P>
<DL>
<DT>
<EM>
ackOD</EM>
</DT><DD>Optr of object to be sent MSG_META_SHUTDOWN_ACK.</DD>
</DL>
<P CLASS="refField">
Interception:	Usually intercepted by objects on the MGCNLT_APP_STARTUP list.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_3.htm_IX_MSG_META_SHUTDOWN_COMPLETE">
 </A>
MSG_META_SHUTDOWN_COMPLETE</H6>
<PRE CLASS="syntax">void	MSG_META_SHUTDOWN_COMPLETE();</PRE>
<P>
This message is sent to the object that initiated the detach sequence after it has received MSG_META_SHUTDOWN_ACK for each <CODE>
ObjIncDetach()</CODE>
 that was previously called. This message is only sent if <CODE>
ObjInitDetach() </CODE>
was previously called passing the message MSG_META_APP_SHUTDOWN.</P>
<P>
The default handler for this message sends MSG_META_SHUTDOWN_ACK to the object passed in the original <CODE>
ObjInitDetach()</CODE>
 call.</P>
<P CLASS="refField">
Source:	<CODE>
MetaClass</CODE>
 handler for MSG_META_SHUTDOWN_ACK if detach count reaches zero (i.e. no outstanding requests), for objects that are shutdown nodes only (i.e. make use of <CODE>
ObjInitDetach()</CODE>
.)</P>
<P CLASS="refField">
Destination:	The object sends this message to itself.</P>
<P CLASS="refField">
Interception:	Intercept if you are using the<CODE>
 ObjInitDetach()</CODE>
 mechanism and need to be notified when all objects have been notified of the detach.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_3.htm_IX_MSG_META_SHUTDOWN_ACK">
 </A>
MSG_META_SHUTDOWN_ACK</H6>
<PRE CLASS="syntax">void	MSG_META_SHUTDOWN_ACK(
        word		callerID,
        optr		ackOD);</PRE>
<P>
This message is sent back in response to a MSG_META_APP_SHUTDOWN. This message serves to notify the object the object has fulfilled the request.</P>
<P CLASS="refField">
Source:	Object having received MSG_META_APP_SHUTDOWN. The default handler will dispatch MSG_META_SHUTDOWN_ACK after <CODE>
MetaClass</CODE>
 has processed MSG_META_APP_SHUTDOWN. (You could, of course, intercept MSG_META_APP_SHUTDOWN and send MSG_META_SHUTDOWN_ACK yourself in your handler.)</P>
<P CLASS="refField">
Destination:	Optr passed in MSG_META_APP_SHUTDOWN.</P>
<P CLASS="refField">
Parameters:	<EM>
callerID</EM>
	Data passed in MSG_META_APP_SHUTDOWN.</P>
<DL>
<DT>
<EM>
ackOD</EM>
</DT><DD>Object which has completed shutting down.</DD>
</DL>
<P CLASS="refField">
Interception:	<CODE>
MetaClass</CODE>
 provides default handling for this message when using the <CODE>
ObjInitDetach()</CODE>
 mechanism. Objects not using this mechanism will want to intercept this message if there is a need to know when the object has completed shutting down.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_3.htm_IX_MSG_META_ACK">
 </A>
MSG_META_ACK</H6>
<PRE CLASS="syntax">void	MSG_META_ACK(
        word	callerID,
        optr	caller);</PRE>
<P>
This message acknowledges a detach message. It is sent by objects that have been notified of another object's detach. The default handler for <CODE>
MSG_META_DETACH</CODE>
 simply sends <CODE>
MSG_META_ACK</CODE>
 back to the object that sent the detach message.</P>
<P CLASS="refField">
Source:	Object having received <CODE>
MSG_META_DETACH</CODE>
 (default handler in <CODE>
MetaClass</CODE>
 will reflexively respond to any <CODE>
MSG_META_DETACH</CODE>
 with a <CODE>
MSG_META_ACK</CODE>
, though you can change this behavior either by using <CODE>
ObjInitDetach()</CODE>
 or by not letting the message get to the <CODE>
MetaClass</CODE>
 handler, and responding yourself with a <CODE>
MSG_META_ACK</CODE>
 sometime later).</P>
<P CLASS="refField">
Destination:	The optr passed in <CODE>
MSG_META_DETACH.</CODE>
</P>
<P CLASS="refField">
Interception:	<CODE>
MetaClass</CODE>
 provides default handling of this message, for objects using the <CODE>
ObjInitDetach()</CODE>
 mechanism. Objects <EM>
not</EM>
 using this mechanism will want to intercept this if there is a need to know when the object asked to detach earlier has completed its detach.<BR>
<CODE>
MSG_META_ACK</CODE>
 is normally inherited from <CODE>
MetaClass</CODE>
 which calls <CODE>
ObjEnableDetach()</CODE>
. This routine decrements the detach count, and when that count reaches zero, sends a <CODE>
MSG_META_DETACH_COMPLETE</CODE>
 to the object itself.</P>
<P CLASS="refField">
Warnings:	If you are expecting a <CODE>
MSG_META_ACK</CODE>
 back from anything, make sure you are using the mechanism initiated with <CODE>
ObjInitDetach()</CODE>
 yourself, or you should handle <CODE>
MSG_META_ACK</CODE>
 to prevent <CODE>
MetaClass</CODE>
 from assuming you <EM>
are</EM>
 using such a mechanism.</P>
<P CLASS="refField">
Parameters:	<EM>callerID</EM> 	data passed to <CODE>
MSG_META_ACK</CODE>
</P>
<DL>
<DT>
<EM>caller</EM> </DT><DD>object which has completed detaching</DD>
</DL>
<P CLASS="refField">
Return:	Nothing.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_3.htm_IX_MSG_META_BLOCK_FREE">
 </A>
MSG_META_BLOCK_FREE</H6>
<PRE CLASS="syntax">void	MSG_META_BLOCK_FREE();</PRE>
<P>
This message initiates a sequence which will free an entire object block when received by any object within that block. The block will be freed when its in-use count reaches zero and the message queues for the block have been cleared.</P>
<P>
This is a fairly low-level operation, and should be performed only after the objects in the block have been removed from any tree(s) they are attached to, and are otherwise &quot;shut down.&quot; For generic objects, this generally means first calling <CODE>
MSG_GEN_SET_NOT_USABLE</CODE>
, then <CODE>
MSG_GEN_REMOVE_CHILD</CODE>
 before using this message. For Visible objects, <CODE>
MSG_VIS_REMOVE</CODE>
 will both visually shut down the visible tree, and then remove it from its parent.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any object within a block that is ready to have a low-level delete performed on it (i.e. isn't on screen, isn't linked to objects in other blocks, etc.).</P>
<P CLASS="refField">
Interception:	Unnecessary, as <CODE>
MetaClass</CODE>
 does the right thing.</P>
<P CLASS="refField">
Parameters:	None.</P>
<P CLASS="refField">
Return:	Nothing.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_3.htm_IX_MSG_META_OBJ_FREE">
 </A>
MSG_META_OBJ_FREE</H6>
<PRE CLASS="syntax">void	MSG_META_OBJ_FREE();</PRE>
<P>
This message initiates a sequence which will free an object. The object will be freed after its message queues have been flushed.</P>
<P>
This is a fairly low-level operation, and should be performed only after the object has been removed from any tree it is attached to and is otherwise &quot;shut down.&quot; Consider using <CODE>
MSG_GEN_DESTROY</CODE>
 for generic objects, <CODE>
MSG_VIS_DESTROY</CODE>
 for visible ones.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any object within a block that is ready to have a low-level delete performed on it (i.e. isn't on screen, isn't linked to objects in other blocks, etc.).</P>
<P CLASS="refField">
Interception:	Unnecessary, as <CODE>
MetaClass</CODE>
 does the right thing.</P>
<P CLASS="refField">
Parameters:	None.</P>
<P CLASS="refField">
Return:	Nothing.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_3.htm_IX_MSG_META_DEC_BLOCK_REF_COUNT">
 </A>
MSG_META_DEC_BLOCK_REF_COUNT</H6>
<PRE CLASS="syntax">void	MSG_META_DEC_BLOCK_REF_COUNT(
        MemHandle		block1,
        MemHandle		block2);</PRE>
<P>
This message is a utility message to call <CODE>
MemDecRefCount()</CODE>
 on one or two memory handles. </P>
<P>
This message is useful for IACP, which initializes the reference count to the number of servers returned by <CODE>
IACPConnect()</CODE>
 and records this message as the message to be returned. After each server has processed its information, the reference count will return to zero and the handles will be freed.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any object.</P>
<P CLASS="refField">
Parameters:	<EM>
block1</EM>
	Handle of a block whose reference count should be decremented, or 0 if none.</P>
<DL>
<DT>
<EM>
block2</EM>
</DT><DD>Handle of a block whose reference count should be decremented, or 0 if none.</DD>
</DL>
<P CLASS="refField">
Interception:	Generally not intercepted.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_3.htm_IX_MSG_META_OBJ_FLUSH_INPUT_QUEUE">
 </A>
MSG_META_OBJ_FLUSH_INPUT_QUEUE</H6>
<PRE CLASS="syntax">void	MSG_META_OBJ_FLUSH_INPUT_QUEUE(
        EventHandle event,
        ObjFlushInputQueueNextStop nextStop,
        MemHandle 	objBlock);</PRE>
<P>
This message clears out the message queues associated with an object. This is rarely, if ever called from within an application, and there is little call to subclass it.</P>
<P>
This queue-flushing mechanism is used in the Window, Object, and Object Block death mechanisms. Objects that implement their own &quot;hold up input&quot; queues must redirect this message through that queue, so that it is flushed as well.</P>
<P CLASS="refField">
Source:	Kernel (<CODE>
WinClose()</CODE>
,<CODE>
 WinSetInfo()</CODE>
, <CODE>
ObjFreeObjBlock()</CODE>
, <CODE>
MSG_META_OBJ_FREE</CODE>
, or <CODE>
MSG_META_BLOCK_FREE).</CODE>
</P>
<P CLASS="refField">
Destination:	Should first be sent to the Kernel's Input Manager (See the routine <CODE>
ImInfoInputProcess()</CODE>
). The message is then relayed first to the System Input Object (usually the <CODE>
GenSystemClass</CODE>
 object), then to the Geode Input Object (usually a <CODE>
GenApplicationClass</CODE>
 object), and finally to the owning process, which dispatches the passed event.</P>
<P CLASS="refField">
Parameters:	<EM>event</EM> 	Event to dispatch upon conclusion of flush.</P>
<DL>
<DT>
<EM>objBlock</EM> </DT><DD>Block Handle that flushing is being performed for (generally the handle of the destination object in the above event). This is the block from which the &quot;OWNING GEODE&quot;, as referenced in the <CODE>
ObjFlushInputQueueNextStop</CODE>
 enumerated type, is determined.</DD>
<DT>
nextStop </DT><DD><CODE>
ObjFlushInputQueueNextStop</CODE>
 (Zero should be passed in call to first object, from there is sequenced by default <CODE>
MetaClass</CODE>
 handler)</DD>
</DL>
<P CLASS="refField">
Return:	Nothing.</P>
<P CLASS="refField">
Structures:	</P>
<PRE><A NAME="MetaClass_3.htm_IX_OFIQNS_&ldots;"> </A><A NAME="IX_ObjFlushInputQueueNextStop"> </A>typedef enum {
	OFIQNS_SYSTEM_INPUT_OBJ,
	OFIQNS_INPUT_OBJ_OF_OWNING_GEODE,
	OFIQNS_PROCESS_OF_OWNING_GEODE,
	OFIQNS_DISPATCH
} ObjFlushInputQueueNextStop;</PRE>
<P CLASS="refField">
Interception:	Default <CODE>
MetaClass</CODE>
 handler implements relay of message from one object to the next, and dispatches the passed event. <EM>
Must</EM>
 be intercepted by any input-flow controlling objects (System object, VisContent) which implement &quot;hold-up&quot; queues that hold up input-related messages. The handlers in such cases should pipe this method through the hold-up queue as it does with the other messages, and finish up when it comes out by sending this message, with all data intact, to the superclass for continued default processing.</P>

<HR>
<A NAME="MetaClass_4.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">MetaClass</A>: 2.2 <A HREF="#MetaClass_2.htm">Utility Messages</A>: 
Class Messages</H3>
<P>
<A NAME="MetaClass_4.htm_IX_Classes:class messages">
 </A>
These messages are utilities that identify the class of a particular object. You should not subclass these. Their use is shown in <A HREF="../../Programming/GOCLanguage/combo.htm">the GEOS Programming chapter</A>.</P>
<H6 CLASS="RefETitle">
<A NAME="MetaClass_4.htm_IX_MSG_META_GET_CLASS">
 </A>
MSG_META_GET_CLASS</H6>
<PRE CLASS="syntax">ClassStruct * MSG_META_GET_CLASS();</PRE>
<P>
This message returns a pointer to the <CODE>
ClassStruct</CODE>
 structure of the recipient object's class.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any object.</P>
<P CLASS="refField">
Parameters:	None.</P>
<P CLASS="refField">
Return:	The object's class.</P>
<P CLASS="refField">
Interception:	Don't.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_4.htm_IX_MSG_META_IS_OBJECT_IN_CLASS">
 </A>
MSG_META_IS_OBJECT_IN_CLASS</H6>
<PRE CLASS="syntax">Boolean	MSG_META_IS_OBJECT_IN_CLASS(
        ClassStruct * class);</PRE>
<P>
This message determines whether the recipient object is a member of a given class (or a subclass of the given class). If the return is <CODE>
true</CODE>
, the object is in the class. If <CODE>
false</CODE>
, the object is not in the class. If a variant class is encountered (when checking to see if the object is an instance of a subclass of the passed class), the object will not be grown out past that class in the search. If you want to do a complete search past variant classes, send a <CODE>
MSG_META_DUMMY</CODE>
 first.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any object.</P>
<P CLASS="refField">
Parameters:	<CODE>
class</CODE>
 	Class to see if object is a member of.</P>
<P CLASS="refField">
Return:	Returns <EM>
true</EM>
 if object is a member of the passed class (or a subclass), <EM>
false</EM>
 otherwise.</P>
<P CLASS="refField">
Interception:	Don't.</P>

<HR>
<A NAME="MetaClass_5.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">MetaClass</A>: 2.3 <A HREF="#MetaClass_2.htm">Utility Messages</A>: 
Object Management Messages</H3>
<P>
<A NAME="MetaClass_5.htm_IX_Instance data:resolving">
 </A>
These messages fill in and resolve an object's instance data. They should usually not be subclassed, and will be sent by applications infrequently (if ever).</P>

<H6 CLASS="RefETitle">
<A NAME="MetaClass_5.htm_IX_MSG_META_RESOLVE_VARIANT_SUPERCLASS">
 </A>
MSG_META_RESOLVE_VARIANT_SUPERCLASS</H6>
<PRE CLASS="syntax">ClassStruct * MSG_META_RESOLVE_VARIANT_SUPERCLASS(
        word	MasterOffset);</PRE>
<P>
<A NAME="MetaClass_5.htm_IX_Variant classes:resolving">
 </A>
This message is sent by the object system when it needs to know the run-time superclass of a particular object's variant master class. The system sends this message to the object when it first attempts to deliver a message to the superclass of a variant class. The object must examine itself and determine what its superclass for that master level should be.</P>
<P CLASS="refField">
Source:	Object system.</P>
<P CLASS="refField">
Destination:	Any object with a variant class in its class hierarchy.</P>
<P CLASS="refField">
Interception:	Because variant master classes tend to be strictly administrative in nature, providing useful and very generic functionality to their subclasses, all immediate children of a variant master class will need to intercept this message and return the appropriate class pointer.</P>
<P CLASS="refField">
Parameters:	<EM>MasterOffset</EM>	Master offset of the level being resolved. If you know there's a variant class above your own, you will need to examine this to determine if it is your master level whose variant is being resolved, or the one above you.</P>
<P CLASS="refField">
Return:	Superclass to use.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_5.htm_IX_@reloc:MSG_META_RELOCATE">
 </A>
<A NAME="MetaClass_5.htm_IX_MSG_META_RELOCATE">
 </A>
MSG_META_RELOCATE</H6>
<PRE CLASS="syntax">Boolean 	MSG_META_RELOCATE(
        word		vMRelocType,
        word		frame);</PRE>
<P>
<A NAME="MetaClass_5.htm_IX_Relocatable data">
 </A>
This message is sent by the object system to evaluate and resolve all of the object's relocatable instance data fields (pointers, optrs, etc.). Note that this only applies if the class' CLASSF_HAS_RELOC flag is set.</P>
<P>
NOTE: The calling of this method is non-standard in that it does not pass through the class's method table. Rather, the handler address is placed after the method table and a direct call is issued. This means a relocation routine should not be bound to <CODE>
MSG_META_RELOCATE</CODE>
 but should rather be bound to <CODE>
@reloc</CODE>
, which Goc understands to mean the handler is for both <CODE>
MSG_META_RELOCATE</CODE>
 and <CODE>
MSG_META_UNRELOCATE</CODE>
.</P>
<P>
Note also that relocation-by-routine happens in addition to (but before) any relocation due to the class' relocation table. To suppress relocation-by-table, you should initialize the class record with the CLASSF_HAS_RELOC flag to prevent Goc from generating a table for the class.</P>
<P CLASS="refField">
Source:	Kernel, when loading in object block, general resources, or object blocks stored in VM file format.</P>
<P CLASS="refField">
Destination:	Individual object needing relocations beyond what the kernel can do automatically (or that simply request for this message to be sent by having their CLASSF_HAS_RELOC bit set)</P>
<P CLASS="refField">
Interception:	Intercepted by any class needing to perform special relocations on its instance data. Superclass should be called, in case a superclass also needs to perform this operation on its own instance data.</P>
<P CLASS="refField">
Parameters:	<EM>vmRelocType</EM> 	Type giving some context to the relocation.</P>
<DL>
<DT>
<EM>
frame</EM>
</DT><DD>Frame to pass to<CODE>
 ObjRelocOrUnRelocSuper()</CODE>
.</DD>
</DL>
<P CLASS="refField">
Return:	If an error occurred, this will return <EM>
true</EM>
.</P>
<P CLASS="refField">
Structures:	</P>
<PRE><A NAME="MetaClass_5.htm_IX_VMRT_&ldots;"> </A><A NAME="IX_VMRelocType"> </A>typedef enum {
	VMRT_UNRELOCATE_BEFORE_WRITE,
	VMRT_RELOCATE_AFTER_READ,
	VMRT_RELOCATE_AFTER_WRITE,
	VMRT_RELOCATE_FROM_RESOURCE,
	VMRT_UNRELOCATE_FROM_RESOURCE
} VMRelocType;</PRE>
<P CLASS="refField">
Warnings:	This method may not call <CODE>
LMemAlloc()</CODE>
, <CODE>
LMemReAlloc()</CODE>
, or <CODE>
LMemFree()</CODE>
.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_5.htm_IX_@reloc:MSG_META_UNRELOCATE">
 </A>
<A NAME="MetaClass_5.htm_IX_MSG_META_UNRELOCATE">
 </A>
MSG_META_UNRELOCATE</H6>
<PRE CLASS="syntax">Boolean 	MSG_META_UNRELOCATE(
        word		vMRelocType,
        word		frame);</PRE>
<P>
This message causes an object to unresolve all its relocatable instance data fields, returning them to special index values.</P>
<P CLASS="refField">
Source:	Kernel, when loading in object block, general resources, or object blocks stored in VM file format.</P>
<P CLASS="refField">
Destination:	Individual object needing relocations beyond what the kernel can do automatically (or that simply request for this message to be sent by having their CLASSF_HAS_RELOC bit set).</P>
<P CLASS="refField">
Interception:	Intercepted by any class needing to perform special relocations on its instance data. Superclass should be called, in case a superclass also needs to perform this operation on its own instance data.</P>
<P CLASS="refField">
Parameters:	<EM>vmRelocType</EM> 	Type giving some context to the relocation.</P>
<DL>
<DT>
<EM>
frame</EM>
</DT><DD>Frame to pass to <CODE>
ObjRelocOrUnRelocSuper()</CODE>
.</DD>
</DL>
<P CLASS="refField">
Return:	If an error occurred, this will return <EM>
true</EM>
.</P>
<P CLASS="refField">
Structures:	</P>
<PRE>typedef enum {
	VMRT_UNRELOCATE_BEFORE_WRITE,
	VMRT_RELOCATE_AFTER_READ,
	VMRT_RELOCATE_AFTER_WRITE,
	VMRT_RELOCATE_FROM_RESOURCE,
	VMRT_UNRELOCATE_FROM_RESOURCE
} VMRelocType;</PRE>
<P CLASS="refField">
Warnings:	This method may not call <CODE>
LMemAlloc()</CODE>
, <CODE>
LMemReAlloc()</CODE>
, or <CODE>
LMemFree()</CODE>
.</P>

<HR>
<A NAME="MetaClass_6.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">MetaClass</A>: 2.4 <A HREF="#MetaClass_2.htm">Utility Messages</A>: 
User Interface Utility Meta Messages</H3>
<P>
These messages are used primarily by the User Interface. You will have very little need to subclass or send them.</P>

<H6 CLASS="RefETitle">
<A NAME="MetaClass_6.htm_IX_MSG_META_SET_FLAGS">
 </A>
MSG_META_SET_FLAGS</H6>
<PRE CLASS="syntax">void 	MSG_META_SET_FLAGS(
        ChunkHandle 	objChunk,
        ObjChunkFlags 	bitsToSet,
        ObjChunkFlags 	bitsToClear);</PRE>
<P>
<A NAME="MetaClass_6.htm_IX_Chunk flags">
 </A>
This message sets the chunk flags for an object. The chunk flags determine how the object is handled with regard to state saving, dirty state, etc.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any object.</P>
<P CLASS="refField">
Interception:	Unnecessary, as <CODE>
MetaClass</CODE>
 does the right thing.</P>
<P CLASS="refField">
Parameters:	<EM>objChunk</EM> 	chunk to set flags for.</P>
<DL>
<DT>
<EM>bitsToSet</EM> </DT><DD>bits to set.</DD>
<DT>
<EM>bitsToClear</EM></DT><DD>bits to clear.</DD>
</DL>
<P CLASS="refField">
Return:	Nothing.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_6.htm_IX_MSG_META_GET_FLAGS">
 </A>
MSG_META_GET_FLAGS</H6>
<PRE CLASS="syntax">word 	MSG_META_GET_FLAGS( /* low byte = ObjChunkFlags */
        ChunkHandle 	ch);</PRE>
<P>
This message returns the chunk flags for the object. This works just like the <CODE>
ObjGetFlags()</CODE>
 routine, but can be used when the object queried is being run by a different thread.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any object.</P>
<P CLASS="refField">
Interception:	Unnecessary, as <CODE>
MetaClass</CODE>
 does the right thing.</P>
<P CLASS="refField">
Parameters:	<EM>objChunk</EM> 	chunk to get flags for.</P>
<P CLASS="refField">
Return:	Word with <CODE>
ObjChunkFlags</CODE>
 in low byte, zero in high byte.<A NAME="MetaClass_6.htm_IX_Chunk flags">
 </A>
</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_6.htm_IX_MSG_META_QUIT">
 </A>
MSG_META_QUIT</H6>
<PRE CLASS="syntax">void 	MSG_META_QUIT();</PRE>
<P>
<A NAME="MetaClass_6.htm_IX_GenApplicationClass:MSG_META_QUIT">
 </A>
This message, when sent to a GenApplication object, initiates the shutdown sequence for the application. All affected objects are notified.</P>
<P>
GenApplication does some error checking for multiple quits or detaches and then starts this sequence by passing <CODE>
MSG_META_QUIT</CODE>
(QL_BEFORE_UI) to the process. The default process handler for <CODE>
MSG_META_QUIT</CODE>
 varies depending on the <CODE>
QuitLevel</CODE>
, which is passed in, but only when sent to the process (see <CODE>
MSG_META_QUIT_PROCESS</CODE>
 alias, below).</P>
<P>
<A NAME="MetaClass_6.htm_IX_QL_&ldots;">
 </A>
<A NAME="MetaClass_6.htm_IX_QuitLevel">
 </A>
The method handler for each level of quit should then send <CODE>
MSG_META_QUIT_ACK</CODE>
 with the same <CODE>
QuitLevel</CODE>
 when it is done. The default behavior for a process' <CODE>
MSG_META_QUIT</CODE>
 responses are:</P>
<DL>
<DT>
QL_BEFORE_UI</DT><DD>
Sends <CODE>
MSG_META_QUIT_ACK</CODE>
 to self via queue.</DD>
<DT>
QL_UI</DT><DD>Sends <CODE>
MSG_GEN_APPLICATION_INITIATE_UI_QUIT</CODE>
(0) to the GenApplication.</DD>
<DT>
QL_AFTER_UI</DT><DD>
 Sends <CODE>
MSG_META_QUIT_ACK</CODE>
 to self via queue.</DD>
<DT>
QL_DETACH</DT><DD> Sends <CODE>
MSG_META_DETACH</CODE>
 to self via queue.</DD>
<DT>
QL_AFTER_DETACH</DT><DD>
Sends <CODE>
MSG_META_QUIT_ACK</CODE>
 to self via queue.</DD>
</DL>
<P>
<A NAME="MetaClass_6.htm_IX_Active list:MSG_META_QUIT">
 </A>
The generic UI objects are first asked to quit via <CODE>
MSG_GEN_APPLICATION_INITIATE_UI_QUIT</CODE>
 when sent to a GenApplication (active list). It will cause <CODE>
MSG_META_QUIT</CODE>
 to be sent to all objects on the active list that are marked as desiring them. These objects on the active list can handle the <CODE>
MSG_META_QUIT</CODE>
 any way they please. The process will be notified by a <CODE>
MSG_META_QUIT_ACK</CODE>
 with the <CODE>
QuitLevel</CODE>
 set to QL_UI.</P>
<P>
If you need to send MSG_META_QUIT from within a handler for MSG_GEN_PROCESS_OPEN_APPLICATION, make sure to send it after calling the superclass in your OPEN_APPLICATION handler. If this is undesirable, you may encapsulate MSG_META_QUIT and send it via MSG_META_FLUSH_INPUT_QUEUE. (This is needed to avoid the system thinking that a valid IACP connection is open, aborting the quit.)</P>
<P CLASS="refField">
Source:	Unrestricted. If you need to send MSG_META_QUIT within your MSG_GEN_PROCESS_OPEN_APPLICATION handler, please follow the guidelines illustrated above.</P>
<P CLASS="refField">
Destination:	GenApplication object (note that this message has aliases so that it may be sent to a Process object, or any object).</P>
<P CLASS="refField">
Parameters:	None.</P>
<P CLASS="refField">
Return:	Nothing.</P>
<P CLASS="refField">
Interception:	Unlikely.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_6.htm_IX_MSG_META_QUIT_PROCESS">
 </A>
MSG_META_QUIT_PROCESS</H6>
<PRE CLASS="syntax">@alias (MSG_META_QUIT)
 void 	MSG_META_QUIT_PROCESS(
        word		quitLevel,
        ChunkHandle 		ackODChunk);</PRE>
<P>
<A NAME="MetaClass_6.htm_IX_ProcessClass:MSG_META_QUIT_PROCESS">
 </A>
For information about the quit mechanism, see <CODE>
MSG_META_QUIT</CODE>
, above.</P>
<P>
The process's <CODE>
MSG_META_QUIT_ACK</CODE>
 handler is what causes this walking down the <CODE>
QuitList</CODE>
; It provides the following behavior for each <CODE>
QuitLevel</CODE>
:</P>
<DL>
<DT>
QL_BEFORE_UI</DT><DD>
Sends <CODE>
MSG_META_QUIT</CODE>
(QL_UI) to self.</DD>
<DT>
QL_UI</DT><DD>Sends <CODE>
MSG_META_QUIT</CODE>
(QL_AFTER_UI) to self.</DD>
<DT>
QL_AFTER_UI</DT><DD>
Sends <CODE>
MSG_META_QUIT</CODE>
(QL_DETACH) to self.</DD>
<DT>
QL_DETACH</DT><DD>Sends <CODE>
MSG_META_QUIT</CODE>
(QL_AFTER_DETACH) to self.</DD>
<DT>
QL_AFTER_DETACH</DT><DD>
Sends <CODE>
MSG_GEN_PROCESS_FINISH_DETACH</CODE>
 to self.</DD>
</DL>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Process object.</P>
<P CLASS="refField">
Parameters:	<EM>quitLevel</EM> 	What stage of quitting we are in.</P>
<DL>
<DT>
<EM>ackODChunk</EM> </DT><DD>Acknowledgment OD to be passed on to <CODE>
MSG_META_QUIT_ACK</CODE>
.</DD>
</DL>
<P CLASS="refField">
Return:	Nothing.</P>
<P CLASS="refField">
Interception:	Unlikely.</P>
<P CLASS="refField">
Warnings:	You cannot abort the quit at the QL_DETACH stage or later.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_6.htm_IX_MSG_META_QUIT_OBJECT">
 </A>
MSG_META_QUIT_OBJECT</H6>
<PRE CLASS="syntax">@alias (MSG_META_QUIT)
 void 	MSG_META_QUIT_OBJECT(
        optr 	obj);</PRE>
<P>
For information about the quit mechanism, see <CODE>
MSG_META_QUIT</CODE>
, above.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Process object.</P>
<P CLASS="refField">
Parameters:	<EM>obj</EM> 	Object to send <CODE>
MSG_META_QUIT_ACK</CODE>
 to.</P>
<P CLASS="refField">
Return:	Nothing.</P>
<P CLASS="refField">
Interception:	Unlikely.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_6.htm_IX_MSG_META_QUIT_ACK">
 </A>
MSG_META_QUIT_ACK</H6>
<PRE CLASS="syntax">void 	MSG_META_QUIT_ACK(
        word 		quitLevel,
        word 		abortFlag);</PRE>
<P>
This message is sent to a Process object in response to a <CODE>
MSG_META_QUIT</CODE>
. The Process object handles this message by continuing the quit sequence.</P>
<P CLASS="refField">
Source:	Any object having received <CODE>
MSG_META_QUIT</CODE>
</P>
<P CLASS="refField">
Destination:	OD passed in <CODE>
MSG_META_QUIT</CODE>
.</P>
<P CLASS="refField">
Parameters:	<EM>quitLevel</EM>	<CODE>
QuitLevel</CODE>
 acknowledging (if responding to a process).</P>
<DL>
<DT>
<EM>abortFlag</EM> </DT><DD>(non-zero if you want to abort the quit).</DD>
</DL>
<P CLASS="refField">
Return:	Nothing.</P>
<P CLASS="refField">
Warnings:	For processes that subclass <CODE>
MSG_META_QUIT</CODE>
, you cannot abort the quit at the QL_DETACH stage or later.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_6.htm_IX_MSG_META_FINISH_QUIT">
 </A>
MSG_META_FINISH_QUIT</H6>
<PRE CLASS="syntax">void 	MSG_META_FINISH_QUIT(
        Boolean		abortFlag);</PRE>
<P>
This message is sent to the object that initiated MSG_META_QUIT and has received MSG_META_QUIT_ACK from each party notified. This message informs the object that it has finished sending out all MSG_META_QUIT messages and can go on with quitting (or aborting the quit if that is the case).</P>
<P CLASS="refField">
Source:	Object that initiated MSG_META_QUIT.</P>
<P CLASS="refField">
Destination:	Any object.</P>
<P CLASS="refField">
Parameters:	<EM>abortFlag</EM> 	(non-zero if you want to abort the quit).</P>

<HR>
<A NAME="MetaClass_7.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">MetaClass</A>: 2.5 <A HREF="#MetaClass_2.htm">Utility Messages</A>: 
Event Messages</H3>
<P>
<A NAME="MetaClass_7.htm_IX_Classed events:MetaClass dispatchers">
 </A>
These messages are used to send classed events to other objects. A classed event is typically an event stored earlier with the Goc keyword <CODE>
@record</CODE>
.</P>

<H6 CLASS="RefETitle">
<A NAME="MetaClass_7.htm_IX_MSG_META_DISPATCH_EVENT">
 </A>
MSG_META_DISPATCH_EVENT</H6>
<PRE CLASS="syntax">Boolean	MSG_META_DISPATCH_EVENT(
        AsmPassReturn 	*retVals,
        EventHandle 	eventHandle,
        MessageFlags msgFlags););</PRE>
<P>
This message causes an object to <CODE>
@send</CODE>
 or <CODE>
@call</CODE>
 a message of another object. This is useful for getting one object run by a different thread to call yet another object or to send a reply to the first object. This message can cause complex synchronization problems if not used with extreme care.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any object.</P>
<P CLASS="refField">
Interception:	Unnecessary, as <CODE>
MetaClass</CODE>
 does the right thing.</P>
<P CLASS="refField">
Parameters:	<EM>retValue</EM>	structure to hold return values.</P>
<DL>
<DT>
<EM>eventHandle</EM></DT><DD>Event which will be sent.</DD>
<DT>
<EM>msgFlags</EM> </DT><DD>flags which will determine how message is sent.</DD>
</DL>
<P CLASS="refField">
Return:	If MF_CALL specified, then carry flag return value will be returned.</P>
<P CLASS="refField">
Structures:	</P>
<PRE><A NAME="MetaClass_7.htm_IX_AsmPassReturn"> </A>typedef struct {
	word 	ax;
	word 	cx;
	word 	dx;
	word 	bp;
} AsmPassReturn;</PRE>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_7.htm_IX_MSG_META_SEND_CLASSED_EVENT">
 </A>
MSG_META_SEND_CLASSED_EVENT</H6>
<PRE CLASS="syntax">void	MSG_META_SEND_CLASSED_EVENT(
        EventHandle	 	event,
        TravelOption 		whereTo);</PRE>
<P>
<A NAME="MetaClass_7.htm_IX_Classed events:sending">
 </A>
This message sends a previously recorded classed event to a certain type of destination defined in the <CODE>
TravelOption</CODE>
 argument <CODE>
whereTo</CODE>
.</P>
<P>
This message's interesting behavior is actually added by the User Interface, which defines <CODE>
GenTravelOption</CODE>
 types. The default behavior provided here in <CODE>
MetaClass</CODE>
 is to destroy the event if TO_NULL is passed, else to deliver the event to itself if it is capable of handling it (the object is a member of the class stored with the event). The event is always freed, whether or not it is deliverable.</P>
<P>
<CODE>
MetaClass</CODE>
 recognizes the following <CODE>
TravelOption</CODE>
 values:</P>
<DL>
<DT>
	TO_NULL</DT><DD>
TO_SELF<BR>
TO_OBJ_BLOCK_OUTPUT<BR>
TO_PROCESS</DD>
<DT>
TO_OBJ_BLOCK_OUTPUT sends the event to the object block's output set in its block header.</DT>
</DL>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any object.</P>
<P CLASS="refField">
Interception:	By default, <CODE>
MetaClass</CODE>
 handlers deal with just the most primitive of the <CODE>
TravelOption</CODE>
 values. Object classes can add new <CODE>
TravelOption</CODE>
 types, but must then intercept this message to implement them (calling the superclass if it doesn't recognize the <CODE>
TravelOption</CODE>
 passed).</P>
<P CLASS="refField">
Parameters:	<EM>event</EM>	Classed event, probably created using <CODE>
@record</CODE>
.</P>
<DL>
<DT>
<EM>whereTo</EM></DT><DD><CODE>
TravelOption</CODE>
 describing target of message.</DD>
</DL>
<P CLASS="refField">
Return:	Nothing.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_7.htm_IX_MSG_META_GET_OBJ_BLOCK_OUTPUT">
 </A>
MSG_META_GET_OBJ_BLOCK_OUTPUT</H6>
<PRE CLASS="syntax">optr	MSG_META_GET_OBJ_BLOCK_OUTPUT();</PRE>
<P>
This message returns the output optr of an object block that contains the object sent the message.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any object (except a process object).</P>
<P CLASS="refField">
Return:	Optr of the block's output field.</P>
<P CLASS="refField">
Interception:	Generally not intercepted.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_7.htm_IX_MSG_META_SET_OBJ_BLOCK_OUTPUT">
 </A>
MSG_META_SET_OBJ_BLOCK_OUTPUT</H6>
<PRE CLASS="syntax">void	MSG_META_SET_OBJ_BLOCK_OUTPUT(
        optr		output);</PRE>
<P>
This message sets the object block output--the block containing the object sent the message-- to the passed optr. </P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any object (except a process object).</P>
<P CLASS="refField">
Parameters:	<EM>
output</EM>
	Optr of the object to act as the block's output.</P>
<P CLASS="refField">
Interception:	Generally not intercepted.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_7.htm_IX_MSG_META_GET_OPTR">
 </A>
MSG_META_GET_OPTR</H6>
<PRE CLASS="syntax">optr	MSG_META_GET_OPTR();</PRE>
<P>
<A NAME="MetaClass_7.htm_IX_optr:accessing">
 </A>
This message returns the object's optr. This is useful when combined with <CODE>
MSG_GEN_GUP_CALL_OBJECT_OF_CLASS</CODE>
 to get the optr of an object of a given class somewhere up in a Generic Tree.</P>
<P>
Note: <CODE>
MSG_GEN_GUP_CALL_OBJECT_OF_CLASS</CODE>
 dies if an object of the class doesn't exist. Use <CODE>
MSG_GEN_GUP_TEST_FOR_OBJECT_OF_CLASS</CODE>
 before using <CODE>
MSG_GEN_GUP_CALL_OBJECT_OF_CLASS</CODE>
 if there is some question as to whether an object of a given class exists.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any object.</P>
<P CLASS="refField">
Interception:	Unlikely.</P>
<P CLASS="refField">
Parameters:	None.</P>
<P CLASS="refField">
Return:	The object's optr.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_7.htm_IX_MSG_META_GET_TARGET_AT_TARGET_LEVEL">
 </A>
MSG_META_GET_TARGET_AT_TARGET_LEVEL</H6>
<PRE CLASS="syntax">void	MSG_META_GET_TARGET_AT_TARGET_LEVEL(
        GetTargetParams *retValue,
        TargetLevel level);</PRE>
<P>
<A NAME="MetaClass_7.htm_IX_Target:accessing">
 </A>
This message returns the <CODE>
GetTargetParams</CODE>
 structure containing, among other things, the current target object at a given target level. The <CODE>
MetaClass</CODE>
 handler simply returns information about the current object since it is assumed to be the current target. <CODE>
GenClass</CODE>
 and <CODE>
VisClass</CODE>
 handlers will handle this message and pass it down the travel hierarchy. If you intercept this message, you should correctly pass this message down as well, either explicitly or by calling the superclass. See <A HREF="../../SysObjects/Input/combo.htm">the Input chapter</A>, for information on target.</P><P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any object.</P>
<P CLASS="refField">
Interception:	Must be handled by target nodes to correctly pass the request on down to the next target below current node in hierarchy.</P>
<P CLASS="refField">
Parameters:	<EM>level</EM> 	Zero for leaf, otherwise <CODE>
TargetLevel</CODE>
, as defined by UI.</P>
<DL>
<DT>
<EM>retValue</EM> </DT><DD>Structure to hold return value.</DD>
</DL>
<P CLASS="refField">
Return:	Nothing returned explicitly.</P>
<DL>
<DT>
<EM>retValue</EM> </DT><DD>Filled with return values.</DD>
</DL>
<P CLASS="refField">
Structures:	</P>
<PRE><A NAME="MetaClass_7.htm_IX_GTP_&ldots;  (GetTargetParams)"> </A><A NAME="IX_GetTargetParams"> </A>typedef struct {
	ClassStruct 				*GTP_class;
	optr 				GTP_target;
} GetTargetParams;</PRE>

<HR>
<A NAME="MetaClass_8.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">MetaClass</A>: 2.6 <A HREF="#MetaClass_2.htm">Utility Messages</A>: 
Variable Data Messages</H3>
<P>
<A NAME="MetaClass_8.htm_IX_Variable data">
 </A>
Variable data is instance data that can appear or not appear within the object's instance chunk. For information on variable data and how these three messages are used, see <A HREF="../../Programming/GOCLanguage/combo.htm">the GEOS Programming chapter</A>.</P>
<H6 CLASS="RefETitle">
<A NAME="MetaClass_8.htm_IX_MSG_META_ADD_VAR_DATA">
 </A>
MSG_META_ADD_VAR_DATA</H6>
<PRE CLASS="syntax">void	MSG_META_ADD_VAR_DATA(@stack
        word	dataType,
        word	dataSize,
        word	*data)</PRE>
<P>
This message adds a variable data type to the recipient object's instance data. If the variable data field was already present, this will change its value. This is useful for adding hints to generic objects at run-time.</P>
<P>
If it is possible that you are adding the object's first/only field of 
variable data, set the object's <CODE>OCF_VARDATA_RELOC</CODE> flag by means 
of the 
<A HREF="../../CRef/Routines/R_7c.htm#IX_ObjSetFlags()">ObjSetFlags()</A> 
routine or 
<A HREF="../../SysObjects/Meta/MetaClass_6.htm#IX_MSG_META_SET_FLAGS">MSG_META_SET_FLAGS</A>.</P>
<P>
Note that the object will be marked dirty even if nothing was changed.</P>
<P>
NOTE: The <EM>dataType</EM> should have VDF_SAVE_TO_STATE set as desired. VDF_EXTRA_DATA is ignored; it will be set correctly by this routine.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any object.</P>
<P CLASS="refField">
Interception:	Generally not intercepted; default <CODE>
MetaClass</CODE>
 handling performs the desired function.</P>
<P CLASS="refField">
Parameters:	<EM>dataType</EM> 	Data type (e.g. ATTR_PRINT_CONTROL_APP_UI).</P>
<DL>
<DT>
<EM>dataSize</EM> </DT><DD>Size of data, if any.</DD>
<DT>
<EM>data</EM></DT><DD>If no extra data, NULL. If <EM>dataSize</EM> is non-zero, then this may be a pointer to data to initialize data with.</DD>
</DL>
<P CLASS="refField">
Return:	Nothing. Object marked dirty even if data type already exists.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_8.htm_IX_MSG_META_DELETE_VAR_DATA">
 </A>
MSG_META_DELETE_VAR_DATA</H6>
<PRE CLASS="syntax">Boolean	MSG_META_DELETE_VAR_DATA(
        word	dataType);</PRE>
<P>
This message removes a particular variable data entry from the recipient object's instance data. This is useful for removing hints from generic objects at run-time.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any object.</P>
<P CLASS="refField">
Interception:	Generally not intercepted; default <CODE>
MetaClass</CODE>
 handling performs the desired function.</P>
<P CLASS="refField">
Parameters:	<EM>dataType</EM> 	Data type to delete. <CODE>
VarDataFlags</CODE>
 ignored.</P>
<P CLASS="refField">
Return:	Returns <CODE>
false</CODE>
 if data deleted, <CODE>
true</CODE>
 if data was not found. Object marked dirty if data type found and deleted.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_8.htm_IX_MSG_META_INITIALIZE_VAR_DATA">
 </A>
MSG_META_INITIALIZE_VAR_DATA</H6>
<PRE CLASS="syntax">word	MSG_META_INITIALIZE_VAR_DATA(
        word	dataType);</PRE>
<P>
This message is sent to an object any time the <CODE>
ObjVarDerefData()</CODE>
 routine is called and the data type is not found. It should be subclassed by any object that defines a variable type that will be used with <CODE>
ObjVarDerefData()</CODE>
. The object must create and initialize the data and return its offset.</P>
<P>
Sent to an object having a variable data entry which code somewhere is attempting to access via <CODE>
ObjVarDerefData()</CODE>
. It is the object that defines the variable data entry type's responsibility to create the data entry and initialize it at this time, and to return a pointer to the extra data (if any), as returned by <CODE>
ObjVarAddData()</CODE>
.</P>
<P CLASS="refField">
Source:	<CODE>
ObjVarDerefData()</CODE>
 routine. Should not be used as a replacement for <CODE>
ObjVarAddData()</CODE>
, or <CODE>
MSG_ADD_VAR_DATA_ENTRY</CODE>
, but may be used any time code is ready to access a particular piece of variable data instance data, knows that the variable data has not yet been created, and wishes to ensure that it does exist.</P>
<P CLASS="refField">
Destination:	Any object stored in an LMem Object block.</P>
<P CLASS="refField">
Interception:	Required by any class which defines a variable data entry type that needs to be initialized before usage. Objects handling this message should first compare the passed data type against variable data types it understands, and pass any unknown types onto the superclass for handling.</P>
<P CLASS="refField">
Parameters:	Variable data type.</P>
<P CLASS="refField">
Return:	Offset to extra data created (or, if no extra data, the start of data entry plus the size of <CODE>
VarDataEntry</CODE>
). Normally, this would just be the offset returned by the call to <CODE>
ObjVarAddData()</CODE>
.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_8.htm_IX_MSG_META_GET_VAR_DATA">
 </A>
MSG_META_GET_VAR_DATA</H6>
<PRE CLASS="syntax">word MSG_META_GET_VAR_DATA( /* returns size of data returned in buf;
              * -1 if not found */</PRE>
<PRE CLASS="syntax">        word 	dataType,
        word 	bufSize,
        void 	*buf);</PRE>
<P>
This message fetches variable data of a given type from an object.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any object.</P>
<P CLASS="refField">
Interception:	Generally not intercepted; default <CODE>
MetaClass</CODE>
 handling performs the desired function.</P>
<P CLASS="refField">
Parameters:	<EM>dataType</EM>	The variable data category to return.</P>
<DL>
<DT>
<EM>bufSize</EM> </DT><DD>Size available to return data.</DD>
<DT>
<EM>buf</EM> </DT><DD>Pointer to buffer to hold returned data.</DD>
</DL>
<P CLASS="refField">
Return:	The size of the data returned. If the vardata entry was not found, then message will return -1.</P>
<DL>
<DT>
<EM>buf</EM> </DT><DD>Filled with vardata's data, if any.</DD>

</DL>
<HR>
<A NAME="MetaClass_9.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">MetaClass</A>: 2.7 <A HREF="#MetaClass_2.htm">Utility Messages</A>: 
Notification Messages</H3>
<P>
<A NAME="MetaClass_9.htm_IX_General change notification">
 </A>
These messages are used by the various notification mechanisms throughout the system.</P>

<H6 CLASS="RefETitle">
<A NAME="MetaClass_9.htm_IX_MSG_META_NOTIFY">
 </A>
MSG_META_NOTIFY</H6>
<PRE CLASS="syntax">void	MSG_META_NOTIFY(
        ManufacturerID manufID,
        word	notificationType,
        word 	data);</PRE>
<P>
This message notifies the recipient that some change or action has taken place. The object must have registered for the notification. The type of change that has occurred depends on the <CODE>
notificationType</CODE>
 argument.</P>
<P>
One word of notification data is allowed, but this should not reference a handle which must at some point be destroyed. See <CODE>
MSG_META_NOTIFY_WITH_DATA_BLOCK</CODE>
 for such requirements.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any object, or any of the <CODE>
GCNListSend()</CODE>
 routines.</P>
<P CLASS="refField">
Interception:	No general requirements, though particular notification types may place restrictions or requirements on such handling.</P>
<P CLASS="refField">
Parameters:	<EM>manufID</EM>	Manufacturer ID associated with notification type.</P>
<DL>
<DT>
<EM>notificationType</EM></DT><DD>What sort of notification is being announced. This value depends on the Manufacturer ID for that notification list. A list of valid types for the Geoworks Manufacturer ID is indicated by the <CODE>
GeoWorksNotificationType</CODE>
 enumerated type. </DD>
<DT>
<EM>data</EM> </DT><DD>One word of data, which will be placed in a vardata field. If more than one word is necessary, use <CODE>
MSG_META_NOTIFY_WITH_DATA_BLOCK</CODE>
, below.</DD>
</DL>
<P CLASS="refField">
Return:	Nothing.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_9.htm_IX_MSG_META_NOTIFY_WITH_DATA_BLOCK">
 </A>
MSG_META_NOTIFY_WITH_DATA_BLOCK</H6>
<PRE CLASS="syntax">void	MSG_META_NOTIFY_WITH_DATA_BLOCK(
        ManufacturerID manufID,
        word	notificationType,
        MemHandle data);</PRE>
<P>
This message acts like <CODE>
MSG_META_NOTIFY</CODE>
, but it also carries a handle of a block of data. It is absolutely imperative that if this message is subclassed, the object call its superclass in the handler.</P>
<P>
The data block must be set up to use the Block &quot;reference count&quot; mechanism, i.e. be sharable and initialized with <CODE>
MemInitRefCount()</CODE>
. Details on the count are noted below.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any object, or any of the GCNListSend... routines</P>
<P CLASS="refField">
Interception:	Message <EM>
must</EM>
 eventually arrive at the <CODE>
MetaClass</CODE>
 handler, with the handle to the data block with the reference count intact, in order for the block to be freed when no longer referenced. Failure to do so will result in garbage being left on the heap, which will kill the system with repetitive occurrences.</P>
<P CLASS="refField">
Parameters:	<EM>manufID</EM> 	Manufacturer ID associated with notification type.</P>
<DL>
<DT>
<EM>notificationType</EM> </DT><DD>What sort of notification is being announced.</DD>
<DT>
<EM>data</EM> </DT><DD>SHARABLE data block having a &quot;reference count&quot; initialized via <CODE>
MemInitRefCount()</CODE>
.</DD>
</DL>
<P>
NOTE on data block reference counts:<BR>
The reference count should hold the total number of references of this data block. This count should be incremented before sending a message holding a reference to this block (using <CODE>
MemIncRefCount()</CODE>
). Any messages passing such reference either must have a <CODE>
MetaClass</CODE>
 handler which decrements this count and frees the block if it reaches zero or must call <CODE>
MemDecRefCount() </CODE>
(which does exactly that). <CODE>
GCNListSend()</CODE>
 and similar functions add in the number of optrs in any list to which a message referring to this block is sent. Thus, when creating a block which will only be sent using <CODE>
GCNListSend()</CODE>
, this count should be initialized to zero. If the block is to be sent to one or more objects or <CODE>
GCNListSend()</CODE>
 calls, the calling routine should call <CODE>
MemIncRefCount()</CODE>
 before making the calls, being sure to call <CODE>
MemIncRefCount()</CODE>
 additionally for any objects that the message is sent to, and then call <CODE>
MemDecRefCount ()</CODE>
 after the calls, to balance the increment call at the start.</P>
<P CLASS="refField">
Return:	Nothing.</P>
<P CLASS="refField">
Warnings:	This message must eventually reach the default <CODE>
MetaClass</CODE>
 handler, so that the block can be freed when no longer referenced.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_9.htm_IX_MSG_META_GCN_LIST_ADD">
 </A>
MSG_META_GCN_LIST_ADD</H6>
<PRE CLASS="syntax">Boolean	MSG_META_GCN_LIST_ADD(@stack
        optr			dest,
        word 		listType,
        ManufacturerID 		listManuf);</PRE>
<P>
This message adds the passed object to a particular notification list. It returns <CODE>
true</CODE>
 if the object was successfully added, <CODE>
false</CODE>
 otherwise. This message is the equivalent of <CODE>
GCNListAdd()</CODE>
 for individual object GCN list.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Object providing GCN services.</P>
<P CLASS="refField">
Interception:	Unnecessary, as <CODE>
MetaClass</CODE>
 does the right thing.</P>
<P CLASS="refField">
Parameters:	<EM>dest</EM> 	Object to be added to list.</P>
<DL>
<DT>
<EM>listType</EM> </DT><DD><CODE>
GCNListType</CODE>
 to add object to.</DD>
<DT>
<EM>listManuf</EM> </DT><DD>Manufacturer ID associated with GCN list.</DD>
</DL>
<P CLASS="refField">
Return:	Returns <EM>
true</EM>
 if optr added, <EM>
false</EM>
 otherwise.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_9.htm_IX_MSG_META_GCN_LIST_REMOVE">
 </A>
MSG_META_GCN_LIST_REMOVE</H6>
<PRE CLASS="syntax">Boolean	MSG_META_GCN_LIST_REMOVE(@stack
        optr	dest,
        word	listType,
        ManufacturerID listManuf);</PRE>
<P>
This message removes the passed object from a particular notification list. It returns <CODE>
true</CODE>
 if the object was successfully removed, <CODE>
false</CODE>
 otherwise. This message is the equivalent of <CODE>
GCNListRemove()</CODE>
 for an individual object's GCN list.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Object providing GCN services.</P>
<P CLASS="refField">
Interception:	Unnecessary, as <CODE>
MetaClass</CODE>
 does the right thing.</P>
<P CLASS="refField">
Parameters:	<EM>dest</EM> 	Object to be removed from list.</P>
<DL>
<DT>
<EM>listType</EM> </DT><DD>Which list to remove object from.</DD>
<DT>
<EM>listManuf</EM></DT><DD>Manufacturer ID associated with GCN list.</DD>
</DL>
<P CLASS="refField">
Return:	Returns <CODE>
true</CODE>
 if optr found and removed, otherwise returns <CODE>
false</CODE>
.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_9.htm_IX_MSG_META_GCN_LIST_SEND">
 </A>
MSG_META_GCN_LIST_SEND</H6>
<PRE CLASS="syntax">void	MSG_META_GCN_LIST_SEND(@stack
        GCNListSendFlags 		flags,
        EventHandle		event,
        MemHandle 		block,
        word		listType,
        ManufacturerID 		listManuf);</PRE>
<P>
This message sends the given event to all objects in a particular notification list. The event will be freed after being sent. This message is the equivalent of <CODE>
GCNListSend()</CODE>
 for an individual object GCN list.</P>
<P CLASS="refField">
Parameters:	<EM>flags</EM>	Flags to pass on to GCNListSend().</P>
<DL>
<DT>
<EM>event</EM> </DT><DD>Classed event to send to the list.</DD>
<DT>
<EM>block</EM> </DT><DD>Handle of extra data block, if used, else NULL. This block must have a reference count, which may be initialized with <CODE>
MemInitRefCount() </CODE>
and incremented for any new usage with <CODE>
MemIncRefCount()</CODE>
. Methods in which they are passed are considered such a new usage, and must have <CODE>
MetaClass</CODE>
 handlers which call <CODE>
MemDecRefCount()</CODE>
. </DD>
<DT>
<EM>listType</EM> </DT><DD>Which GCN list to send event to.</DD>
<DT>
<EM>listManuf</EM> </DT><DD>Manufacturer ID associated with GCN list.</DD>
</DL>
<P CLASS="refField">
Return:	Nothing.</P>
<P CLASS="refField">
Structures:	</P>
<PRE><A NAME="MetaClass_9.htm_IX_GCNLSF_&ldots;"> </A><A NAME="IX_GCNListSendFlags"> </A>typedef WordFlags GCNListSendFlags;
/* These flags may be combined using | and &amp;:
	GCNLSF_SET_STATUS,
	GCNLSF_IGNORE_IF_STATUS_TRANSITIONING */</PRE>
<DL>
<DT>
GCNLSF_SET_STATUS</DT><DD>
Additionally saves the message as the list's current &quot;status.&quot; The &quot;status&quot; message is automatically sent to any object adding itself to the list at a later point in time.</DD>
<DT>
GCNLSF_IGNORE_IF_STATUS_TRANSITIONING</DT><DD>
Optimization bit used to avoid lull in status when transitioning between two different sources--such as when the source is the current target object, and one has just lost, and another may soon gain, the exclusive. (The bit should be set only when sending the &quot;null,&quot; &quot;lost,&quot; or &quot;not selected&quot; status, as this is the event that should be discarded if another non-null status comes along shortly). Implementation is <EM>
not</EM>
 provided by the kernel primitive routines, which ignore this bit, but may be provided by objects managing their own GCN lists. GenApplication responds to this bit by delaying the request until after the UI and application queues have been cleared, and then only sets the status as indicated if no other status has been set since the first request. Other objects may use their own logic to implement this optimization as is appropriate. Mechanisms which can not tolerate the delayed status setting nature of this optimization, or require that all changes are registered, should not pass this bit set.</DD>


</DL>
<H6 CLASS="RefETitle">
<A NAME="MetaClass_9.htm_IX_MSG_META_GCN_LIST_FIND_ITEM">
 </A>
MSG_META_GCN_LIST_FIND_ITEM</H6>
<PRE CLASS="syntax">Boolean	MSG_META_GCN_LIST_FIND_ITEM(@stack
        optr		dest,
        word		listType,
        ManufacturerID		listManuf);</PRE>
<P>
This message checks whether an object is on a particular GCN list.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any object providing GCN services.</P>
<P CLASS="refField">
Parameters:	<EM>
dest</EM>
	Optr of object that we are checking.</P>
<DL>
<DT>
<EM>
listType</EM>
</DT><DD><CODE>
GCNListType</CODE>
.</DD>
<DT>
<EM>
listManuf</EM>
</DT><DD><CODE>
ManufacturerID</CODE>
.</DD>
</DL>
<P CLASS="refField">
Return:	<EM>
true</EM>
 if object is on the GCN list.</P>
<P CLASS="refField">
Interception:	Unnecessary.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_9.htm_IX_MSG_META_GCN_LIST_DESTROY">
 </A>
MSG_META_GCN_LIST_DESTROY</H6>
<PRE CLASS="syntax">void	MSG_META_GCN_LIST_DESTROY();</PRE>
<P>
This message completely destroys the GCN setup for the caller. It frees all GCN lists, cached events, and overhead data storage. This should only be used when the object is being freed. You will likely never handle or call this message.</P>
<P CLASS="refField">
Source:	Object providing GCN services, often in handler for <CODE>
MSG_META_FINAL_OBJ_FREE</CODE>
.</P>
<P CLASS="refField">
Destination:	Self.</P>
<P CLASS="refField">
Interception:	Unnecessary, as <CODE>
MetaClass</CODE>
 does the right thing.</P>
<P CLASS="refField">
Parameters:	Nothing.</P>
<P CLASS="refField">
Return:	Nothing.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_9.htm_IX_MSG_META_NOTIFY_OBJ_BLOCK_INTERACTIBLE">
 </A>
MSG_META_NOTIFY_OBJ_BLOCK_INTERACTIBLE</H6>
<PRE CLASS="syntax">void	MSG_META_NOTIFY_OBJ_BLOCK_INTERICTABLE(
        MemHandle objBlock);</PRE>
<P>
This message is sent to an object block's output object when the block changes from being not in-use to being in-use. An object may handle this message to monitor changes of in-use status.</P>
<P CLASS="refField">
Source:	Kernel.</P>
<P CLASS="refField">
Destination:	Object which is set as the output of an object block resource either by <CODE>
ObjBlockSetOutput()</CODE>
, or by being pre-defined in an application resource.</P>
<P CLASS="refField">
Interception:	May be intercepted to learn about change in object block interactable status. No default handling is provided, though you may wish to pass the message onto the superclass in case it is interested in this data as well.</P>
<P CLASS="refField">
Parameters:	<EM>objBlock</EM> 	Handle of object block.</P>
<P CLASS="refField">
Return:	Nothing.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_9.htm_IX_MSG_META_NOTIFY_OBJ_BLOCK_NOT_INTERACTIBLE">
 </A>
MSG_META_NOTIFY_OBJ_BLOCK_NOT_INTERACTIBLE</H6>
<PRE CLASS="syntax">void	MSG_META_NOTIFY_OBJ_BLOCK_NOT_INTERACTIBLE(
        MemHandle objBlock);</PRE>
<P>
This message is sent to an object block's output object when the block changes from being not in-use to being in-use. An object may handle this message to monitor changes of in-use status.</P>
<P CLASS="refField">
Source:	Kernel.</P>
<P CLASS="refField">
Destination:	Object which is set as the output of an Object Block resource either by <CODE>
ObjBlockSetOutput()</CODE>
, or by being pre-defined in an application resource.</P>
<P CLASS="refField">
Interception:	May be intercepted to learn about change in object block interactable status. No default handling is provided, though you may wish to pass the message onto the superclass in case it is interested in this data as well.</P>
<P CLASS="refField">
Parameters:	<EM>objBlock</EM> 	Handle of object block.</P>
<P CLASS="refField">
Return:	Nothing.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_9.htm_IX_MSG_META_VM_FILE_DIRTY">
 </A>
MSG_META_VM_FILE_DIRTY</H6>
<PRE CLASS="syntax">void	MSG_META_VM_FILE_DIRTY(
        FileHandle file);</PRE>
<P>
<A NAME="MetaClass_9.htm_IX_Virtual memory:notification">
 </A>
This message is sent to all processes that have a VM file open when a block in the file becomes marked dirty for the first time. This is useful if many processes may be sharing a VM file. The VM file must be marked VMA_NOTIFY_DIRTY in its attributes.</P>
<P CLASS="refField">
Source:	Kernel VM code.</P>
<P CLASS="refField">
Destination:	<CODE>
ProcessClass</CODE>
 object.</P>
<P CLASS="refField">
Interception:	May be intercepted at process to do whatever is desired on this occurrence of this event. Default behavior in <CODE>
GenProcessClass</CODE>
 sends notification to the current model <CODE>
GenDocumentGroupClass</CODE>
 object.</P>
<P CLASS="refField">
Parameters:	<EM>file</EM> 	Handle open to the VM file, from the receiving process's perspective.</P>
<P CLASS="refField">
Return:	Nothing.</P>

<HR>
<A NAME="MetaClass_a.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">MetaClass</A>: 2.8 <A HREF="#MetaClass_2.htm">Utility Messages</A>: 
Options Messages</H3>
<P>
<A NAME="MetaClass_a.htm_IX_Initialization file:working with option">
 </A>
These messages are used by the User Interface when working with the GEOS.INI files. You will probably never need to subclass or call these messages.</P>

<H6 CLASS="RefETitle">
<A NAME="MetaClass_a.htm_IX_MSG_META_SAVE_OPTIONS">
 </A>
MSG_META_SAVE_OPTIONS</H6>
<PRE CLASS="syntax">void	MSG_META_SAVE_OPTIONS();</PRE>
<P>
<A NAME="MetaClass_a.htm_IX_Active list:MSG_META_SAVE_OPTIONS">
 </A>
This message saves an object's options to the .INI file for an object. It is sent via the UI's active list mechanism.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	GenApplication object, which in turn broadcasts to everything on list of objects having options needing to be saved</P>
<P CLASS="refField">
Interception:	Objects having options to save should intercept this. Superclass should be called in case any of the superclasses needs similar notification.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_a.htm_IX_MSG_META_LOAD_OPTIONS">
 </A>
MSG_META_LOAD_OPTIONS</H6>
<PRE CLASS="syntax">void	MSG_META_SAVE_OPTIONS();</PRE>
<P>
This message loads the object's setting from the .INI file.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any object.</P>
<P CLASS="refField">
Interception:	Any object that should load its options should intercept this. Behavior is currently implemented for Generic UI objects.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_a.htm_IX_MSG_META_RESET_OPTIONS">
 </A>
MSG_META_RESET_OPTIONS</H6>
<PRE CLASS="syntax">void	MSG_META_RESET_OPTIONS();</PRE>
<P>
This message resets the object's settings from the .INI file to their initial state.</P>
<P CLASS="refField">
Source:	Unrestricted. Sent to all objects on the GAGCNLT_SELF_LOAD_OPTIONS and GAGCNLT_STARTUP_LOAD_OPTIONS lists.</P>
<P CLASS="refField">
Destination:	Any object.</P>
<P CLASS="refField">
Interception:	Any object that wants to reset its options should intercept this. Behavior is currently implemented for Generic UI objects.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_a.htm_IX_MSG_META_GET_INI_CATEGORY">
 </A>
MSG_META_GET_INI_CATEGORY</H6>
<PRE CLASS="syntax">void	MSG_META_GET_INI_CATEGORY(
        char	*buf);</PRE>
<P>
This message returns the .INI file category of the object.</P>
<P CLASS="refField">
Source:	Unrestricted, though generally self.</P>
<P CLASS="refField">
Destination:	Object having options.</P>
<P CLASS="refField">
Interception:	Default handler walks up tree, eventually finding name of application. Can be intercepted at any level to change the category for a branch.</P>
<P CLASS="refField">
Parameters:	<EM>buf</EM> 	The buffer for .INI category string. This buffer size cannot store more than 64 bytes.</P>
<P CLASS="refField">
Return:	Nothing returned explicitly.</P>
<DL>
<DT>
<EM>buf</EM> </DT><DD>String filled with category string.</DD>

</DL>
<HR>
<A NAME="MetaClass_b.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">MetaClass</A>: 2.9 <A HREF="#MetaClass_2.htm">Utility Messages</A>: 
Suspending and Unsuspending</H3>
<P>
<CODE>
MSG_META_SUSPEND</CODE>
 and <CODE>
MSG_META_UNSUSPEND</CODE>
 work together to allow objects to optimize recalculation when doing a series of actions. These messages are implemented by various objects in the system (such as the text object and the grobj body). This mechanism is used by <CODE>
GenControlClass</CODE>
 to optimize recalculation stemming from multiple controller outputs.</P>
<P>
An object typically implements these messages by keeping a suspend count and a record of the calculations that were aborted because the object was suspended. When the suspend count reaches zero, the object will perform the calculations. </P>
<P>
An object implementing this mechanism should always call its superclass since multiple class levels could be implementing this mechanism.</P>

<H6 CLASS="RefETitle">
 <A NAME="MetaClass_b.htm_IX_MSG_META_SUSPEND">
 </A>
MSG_META_SUSPEND</H6>
<PRE CLASS="syntax">void 	MSG_META_SUSPEND();</PRE>
<P>
Suspend calculation in an object.</P>
<P CLASS="refField">
Source:	Normally sent by a controller object but can be sent by anything.</P>
<P CLASS="refField">
Destination:	Any object that implements the mechanism described above.</P>
<P CLASS="refField">
Interception:	An object that wants to implement the mechanism described above.</P>
<P CLASS="refField">
Parameters:	None.</P>
<P CLASS="refField">
Return:	Nothing.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_b.htm_IX_MSG_META_UNSUSPEND">
 </A>
MSG_META_UNSUSPEND </H6>
<PRE CLASS="syntax">void 	MSG_META_UNSUSPEND();</PRE>
<P>
Unsuspend calculation in an object.</P>
<P CLASS="refField">
Source:	Normally sent by a controller object but can be sent by anything.</P>
<P CLASS="refField">
Destination:	Any object that implements the mechanism described above.</P>
<P CLASS="refField">
Interception:	An object that wants to implement the mechanism described above.</P>
<P CLASS="refField">
Parameters:	None.</P>
<P CLASS="refField">
Return:	Nothing.</P>

<HR>
<A NAME="MetaClass_c.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">MetaClass</A>: 2.10 <A HREF="#MetaClass_2.htm">Utility Messages</A>: 
Help Files</H3>
<PRE>MSG_META_GET_HELP_FILE, MSG_META_SET_HELP_FILE, MSG_META_BRING_UP_HELP</PRE>
<P>
These help messages are contained within MetaClass to allow help files within any object in the GEOS system.</P>

<H6 CLASS="RefETitle">
<A NAME="MetaClass_c.htm_IX_MSG_META_GET_HELP_FILE">
 </A>
MSG_META_GET_HELP_FILE</H6>
<PRE CLASS="syntax">void	MSG_META_GET_HELP_FILE(
        char		*buf);</PRE>
<P>
This message returns the name of the help file attached to the object sent this message. If no help file is found, the default <CODE>
MetaClass</CODE>
 handler walks up the tree.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Object in object tree containing help.</P>
<P CLASS="refField">
Parameters:	<EM>
buf</EM>
	Pointer to buffer to store the help file name.</P>
<P CLASS="refField">
Return:	Buffer filled in.</P>
<P CLASS="refField">
Interception:	The default handler walks up the tree; you may intercept to change the help file for a branch.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_c.htm_IX_MSG_META_SET_HELP_FILE">
 </A>
MSG_META_SET_HELP_FILE</H6>
<PRE CLASS="syntax">void	MSG_META_SET_HELP_FILE(
        char		*buf);</PRE>
<P>
This message sets the help file for the object sent this message.</P>
<P CLASS="refField">
Source:	Unrestricted, though generally an object sends this to itself.</P>
<P CLASS="refField">
Destination:	An object within a tree.</P>
<P CLASS="refField">
Parameters:	<EM>
buf</EM>
	Pointer to help file name. This buffer's size must be at least FILE_LONGNAME_BUFFER_SIZE.</P>
<P CLASS="refField">
Interception:	Generally not intercepted.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_c.htm_IX_MSG_META_BRING_UP_HELP">
 </A>
MSG_META_BRING_UP_HELP</H6>
<PRE CLASS="syntax">void	MSG_META_BRING_UP_HELP();</PRE>
<P>
This message finds a help context for the current object tree and sends a notification to bring up help with that context.</P>
<P CLASS="refField">
Source:	Unrestricted, though generally an object sends this to itself.</P>
<P CLASS="refField">
Destination:	An object within a tree.</P>
<P CLASS="refField">
Interception:	The default handler for this message walks up the visual tree (not the generic tree) eventually finding a <CODE>
GenClass</CODE>
 object with ATTR_GEN_HELP_CONTEXT. You may intercept at any level to change the help context for a branch.</P>

<HR>
<A NAME="MetaClass_d.htm"></A>


<H2 CLASS="sectionTitle">
<A HREF="#index.htm">MetaClass</A>: 3 
Exported Message Ranges</H2>
<P>
<CODE>
MetaClass</CODE>
<A NAME="MetaClass_d.htm_IX_Exported messages">
 </A>
 exports a number of ranges of messages for use by its subclasses (such as <CODE>
GenClass</CODE>
 and <CODE>
VisClass</CODE>
) for various purposes. In most cases, you will not need to use any of these ranges for your own messages. The names of these ranges, however, are listed below. For information on exporting and importing message ranges, see <A HREF="../../Programming/GOCLanguage/combo.htm">the GEOS Programming chapter</A>.</P><UL>
<LI>
<A NAME="MetaClass_d.htm_IX_MetaWindowMessages">
 </A>
MetaWindowMessages<BR>
These messages alert a window's input object and output descriptor to certain important events. For example, <CODE>
MSG_META_EXPOSED</CODE>
 announces that part of a window has been exposed and needs to be redrawn.</LI>
<LI>
<A NAME="MetaClass_d.htm_IX_MetaInputMessages">
 </A>
MetaInputMessages<BR>
These are very low-level messages, and will only be used by those geodes which wish to circumvent the Input Manager. To work with the Input Manager correctly, see the selection messages in the MetaUIMessages range.</LI>
<LI>
<A NAME="MetaClass_d.htm_IX_MetaUIMessages">
 </A>
MetaUIMessages<BR>
These messages may be used by objects which will interact with the UI. While messages for working with the Input Manager and Clipboard are detailed in this chapter, information on other messages may be found in <A HREF="../../Files/Documents/combo.htm">the Documents chapter</A>.</LI><LI>
<A NAME="MetaClass_d.htm_IX_MetaSpecificUIMessages">
 </A>
MetaSpecificUIMessages<BR>
These messages are internal.</LI>
<LI>
<A NAME="MetaClass_d.htm_IX_MetaApplicationMessages">
 </A>
MetaApplicationMessages<BR>
These messages don't have any meaning attached to them; no class defined in the system or any library has a handler for any of these messages. Any object class defined within an application may have a handler for any of these messages.<BR>
This message range was set up so that two or more classes defined within an application could agree on some message numbers. <BR>
Thus, your application could contain the header listed below, and then write handlers for the message in two completely unrelated application-defined classes:</LI>
</UL>
<PRE> @importMessage MetaApplicationMessages, 
	type0 MSG_MYAPP_DO_SOMETHING(
		type1		arg1,
		type2		arg2);</PRE>
<PRE>/* ... */
@method MyProcessClass, MSG_MYAPP_DO_SOMETHING
/* ...Insert Handler here */</PRE>
<PRE>/* ... */
@method MyDocumentClass, MSG_MYAPP_DO_SOMETHING
/* ...Insert Handler here */</PRE>
<UL>
<LI>
<A NAME="MetaClass_d.htm_IX_MetaGrObjMessages">
 </A>
MetaGrObjMessages<BR>
This message range is reserved for notification messages associated with the graphic object library.</LI>
<LI>
<A NAME="MetaClass_d.htm_IX_MetaPrintMessages">
 </A>
MetaPrintMessages<BR>
For information on these messages, see <A HREF="../../Communication/Printing/combo.htm">the Printing chapter</A>.</LI><LI>
<A NAME="MetaClass_d.htm_IX_MetaSearchSpellMessages">
 </A>
MetaSearchSpellMessages<BR>
These messages are sent out by the SearchReplace and Spell controllers. For information on these messages, see <A HREF="../../UI/Text/combo.htm">the Text Objects chapter</A>.</LI><LI>
<A NAME="MetaClass_d.htm_IX_MetaGCNMessages">
 </A>
MetaGCNMessages<BR>
There are several system-defined General Change Notification lists which objects may belong to. This message range holds those messages which will be sent to objects on system-defined lists.</LI>
<LI>
<A NAME="MetaClass_d.htm_IX_MetaTextMessages">
 </A>
MetaTextMessages<BR>
See <A HREF="../../UI/Text/combo.htm">the Text Objects chapter</A>.</LI><LI>
<A NAME="MetaClass_d.htm_IX_MetaStyleMessages">
 </A>
MetaStyleMessages<BR>
See <A HREF="../../SysObjects/Controllers/combo.htm"></A>
.</LI>
<LI>
<A NAME="MetaClass_d.htm_IX_MetaColorMessages">
 </A>
MetaColorMessages<BR>
See <A HREF="../../SysObjects/Controllers/combo.htm">the Controllers chapter</A>.</LI><LI>
<A NAME="MetaClass_d.htm_IX_MetaFloatMessages">
 </A>
MetaFloatMessages<BR>
These messages are sent out by the FloatFormat controller. For information on these messages, see <A HREF="../../SysObjects/Controllers/combo.htm">the Controllers chapter</A>.</LI><LI>
<A NAME="MetaClass_d.htm_IX_MetaIACPMessages">
 </A>
MetaIACPMessages<BR>
These messages are used to communicate to other objects using the Inter-Application Communication Protocol. IACP is discussed in <A HREF="../../Kernel/Geodes/combo.htm">the Applications and Geodes chapter</A>.</LI></UL>
<P CLASS="subsectionLink">
<A HREF="#MetaClass_e.htm">Window Messages</A></P>
<P CLASS="subsectionLink">
<A HREF="#MetaClass_f.htm">Input Messages</A></P>
<P CLASS="subsectionLink">
<A HREF="#MetaClass_10.htm">UI Messages</A></P>
<P CLASS="subsectionLink">
<A HREF="#MetaClass_11.htm">Standard GCN Messages</A></P>
<P CLASS="subsectionLink">
<A HREF="#MetaClass_12.htm">IACP Meta Messages</A></P>
<HR>
<A NAME="MetaClass_e.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">MetaClass</A>: 3.1 <A HREF="#MetaClass_d.htm">Exported Message Ranges</A>: 
Window Messages</H3>
<P>
<A NAME="MetaClass_e.htm_IX_Windows:imported messages">
 </A>
Because many objects, both Generic UI objects and others, work together to control the behavior of the system windows, a number of messages have been set up in an exported range so that they may be shared among classes.</P>

<H4 CLASS="HeadingC">
Window Update Messages</H4>
<P>
The following messages are sent to objects responsible for updating views, and if you subclass content objects, you may wish to intercept these messages.</P>

<H6 CLASS="RefETitle">
<A NAME="MetaClass_e.htm_IX_MSG_META_EXPOSED">
 </A>
MSG_META_EXPOSED</H6>
<PRE CLASS="syntax">@importMessage MetaWindowMessages, void MSG_META_EXPOSED(
        WindowHandle win);</PRE>
<P>
This message is sent to a Window's exposure object any time a portion of the window is visible on screen, has become invalid, and needs to be redrawn. Correct response is to create a GState on the passed window, call <CODE>
GrBeginUpdate()</CODE>
 with it, redraw the window, and finish by calling <CODE>
GrEndUpdate()</CODE>
 and freeing the GState. Drawing will be clipped to the invalid area of the window at the time that <CODE>
GrBeginUpdate()</CODE>
 is called. Invalidations occurring during the redraw will result in the reduction in the size of the update region, and result in another <CODE>
MSG_META_EXPOSED</CODE>
 being generated, to repair the new &quot;invalid&quot; area.</P>
<P CLASS="refField">
Source:	Window system.</P>
<P CLASS="refField">
Destination:	Individual window's exposure object; View's output descriptor.</P>
<P CLASS="refField">
Interception:	Required, in order for window to be properly updated. Note that <CODE>
VisContentClass</CODE>
 provides default handler which creates GState, calls <CODE>
GrBeginUpdate()</CODE>
, calls <CODE>
MSG_VIS_DRAW</CODE>
 on itself, then calls <CODE>
GrEndUpdate()</CODE>
.</P>
<P CLASS="refField">
Parameters:	<CODE>
win</CODE>
	Window handle which may be passed to <CODE>
GrCreateGState()</CODE>
.</P>
<P CLASS="refField">
Return:	Nothing.</P>



<H4 CLASS="HeadingC">
Messages Sent to Objects Further Up the Input Hierarchy</H4>
<P>
The following messages are part of the high level windowing mechanism. Most of these messages are passed around at the GenSystem level, and most object classes defined by applications will not intercept them. Instead, system objects will intercept these messages and pass appropriate messages on to application objects.</P>

<H6 CLASS="RefETitle">
<A NAME="MetaClass_e.htm_IX_MSG_META_WIN_CHANGE">
 </A>
MSG_META_WIN_CHANGE</H6>
<PRE CLASS="syntax">@importMessage MetaWindowMessages, void 	MSG_META_WIN_CHANGE();</PRE>
<P>
Sent to the System Input Object (Normally the UI's GenSystem obj), when the pointer position, as passed to the window system in calls to <CODE>
WinMovePtr()</CODE>
, has possibly moved outside of the window that it was in. The object should respond by calling <CODE>
WinChangeAck()</CODE>
, which will cause enter and leave events to be generated for all windows affected by the pointer's change. </P>
<P CLASS="refField">
Source:	Window system (<CODE>
WinMovePtr()</CODE>
).</P>
<P CLASS="refField">
Destination:	System Input object (usually the GenSystem object).</P>
<P CLASS="refField">
Interception:	Must be handled via call to <CODE>
WinChangeAck()</CODE>
.</P>
<P CLASS="refField">
Parameters:	None.</P>
<P CLASS="refField">
Return:	Nothing.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_e.htm_IX_MSG_META_IMPLIED_WIN_CHANGE">
 </A>
MSG_META_IMPLIED_WIN_CHANGE</H6>
<PRE CLASS="syntax">@importMessage MetaWindowMessages, void 	MSG_META_IMPLIED_WIN_CHANGE(
        optr 		inputObj,
        WindowHandle 		ptrWin);</PRE>
<P>
Sent to the System Input Object (Normally the UI's GenSystem obj) in response to a call to <CODE>
WinChangeAck()</CODE>
, to inform it which window the mouse has moved into. The system input object is responsible for passing this message on to the Input object of affected geodes. </P>
<P CLASS="refField">
Source:	Window system (<CODE>
WinChageAck()</CODE>
).</P>
<P CLASS="refField">
Destination:	Initially System Input Object (usually the <CODE>
GenSystemClass</CODE>
 object), though is relayed on to Geode Input Object (usually a <CODE>
GenApplicationClass</CODE>
 object).</P>
<P CLASS="refField">
Interception:	May be intercepted to learn when an implied window change has occurred, but subclasses should not change any default functionality.</P>
<P CLASS="refField">
Parameters:	<EM>inputObj</EM>	Window which has implied grab (or zero if there is no implied grab).</P>
<DL>
<DT>
<EM>ptrWin</EM></DT><DD>Window that pointer is in.</DD>
</DL>
<P CLASS="refField">
Return:	Nothing.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_e.htm_IX_MSG_META_RAW_UNIV_ENTER">
 </A>
MSG_META_RAW_UNIV_ENTER</H6>
<PRE CLASS="syntax">@importMessage MetaWindowMessages, void 	MSG_META_RAW_UNIV_ENTER(
        optr 		inputObj,
        WindowHandle 		ptrWin);</PRE>
<P>
This message is generated by the window system whenever the mouse crosses into a window. This message is sent to the window's input object. This is sent whenever the mouse pointer crosses a window boundary, regardless of any existing window grab. </P>
<P CLASS="refField">
Source:	Window system (<CODE>
WinChangeAck()</CODE>
).</P>
<P CLASS="refField">
Destination:	Initially System input object (usually the <CODE>
GenSystemClass</CODE>
 object), though is relayed on to Geode Input Object (usually a <CODE>
GenApplicationClass</CODE>
 object), and finally onto individual Window's Input Object.</P>
<P CLASS="refField">
Interception:	May be intercepted to track current status of whether mouse is within window or not. Specific UIs rely on these messages to control auto-raise, click-to-raise arming, and correct implied and active mouse grab interaction behavior.</P>
<P CLASS="refField">
Parameters:	<EM>inputObj</EM> 	Input Object of window method refers to.</P>
<DL>
<DT>
<EM>ptrWin</EM> </DT><DD>Window that method refers to.</DD>
</DL>
<P CLASS="refField">
Return:	Nothing.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_e.htm_IX_MSG_META_RAW_UNIV_LEAVE">
 </A>
MSG_META_RAW_UNIV_LEAVE</H6>
<PRE CLASS="syntax">@importMessage MetaWindowMessages, void 	MSG_META_RAW_UNIV_LEAVE(
        optr 		inputObj,
        WindowHandle 		ptrWin);</PRE>
<P>
This message is generated by the window system whenever the mouse crosses out of a window. This message is sent to the window's input object. This is sent whenever the mouse pointer crosses a window boundary, regardless of any existing window grab. </P>
<P CLASS="refField">
Source:	Window system (<CODE>
WinChangeAck()</CODE>
).</P>
<P CLASS="refField">
Destination:	Initially System Input Object (usually the <CODE>
GenSystemClass</CODE>
 object), though is relayed on to Geode Input Object (usually a <CODE>
GenApplicationClass</CODE>
 object), and finally onto individual Window's Input Object.</P>
<P CLASS="refField">
Interception:	May be intercepted to track current status of whether mouse is within window or not. Specific UIs rely on these messages to control auto-raise, click-to-raise arming, and correct implied and active mouse grab interaction behavior.</P>
<P CLASS="refField">
Parameters:	<EM>inputObj</EM> 	Input Object of window method refers to.</P>
<DL>
<DT>
<EM>ptrWin</EM> </DT><DD>Window that method refers to.</DD>
</DL>
<P CLASS="refField">
Return:	Nothing.</P>


<HR>
<A NAME="MetaClass_f.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">MetaClass</A>: 3.2 <A HREF="#MetaClass_d.htm">Exported Message Ranges</A>: 
Input Messages</H3>
<P>
<A NAME="MetaClass_f.htm_IX_Input:raw messages">
 </A>
These messages contain &quot;raw&quot; input events; events which have not yet been processed by the Input Manager. Most applications intercepting input events should intercept events which have been so processed, as described in <A HREF="#MetaClass_10.htm_36279"> UI Messages</A>
.</P>

<H6 CLASS="RefETitle">
<A NAME="MetaClass_f.htm_IX_MSG_META_MOUSE_BUTTON">
 </A>
MSG_META_MOUSE_BUTTON</H6>
<PRE CLASS="syntax">@importMessage MetaInputMessages, void MSG_META_BUTTON(
        word 	xPosition,
        word 	yPosition,
        word 	inputState); </PRE>
<P>
This message is sent out on any button press or release.</P>
<P CLASS="refField">
Parameters:	<EM>xPosition</EM>	X-coordinate of mouse event.</P>
<DL>
<DT>
<EM>yPosition</EM> </DT><DD>Y-coordinate of mouse event.</DD>
<DT>
<EM>inputState</EM></DT><DD>High byte is a ShiftState; low byte is ButtonInfo.</DD>
</DL>
<P CLASS="refField">
Return:	Nothing.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_f.htm_IX_MSG_META_MOUSE_PTR">
 </A>
MSG_META_MOUSE_PTR</H6>
<PRE CLASS="syntax">@importMessage MetaInputMessages, void MSG_META_PTR(
        word 	xPosition,
        word 	yPosition,
        word 	inputState); </PRE>
<P>
This message is sent out on any mouse movement.</P>
<P CLASS="refField">
Parameters:	<EM>xPosition</EM>	X-coordinate of mouse event.</P>
<DL>
<DT>
<EM>yPosition</EM> </DT><DD>Y-coordinate of mouse event.</DD>
<DT>
<EM>inputState</EM></DT><DD>High byte is a ShiftState; low byte is ButtonInfo.</DD>
</DL>
<P CLASS="refField">
Return:	Nothing.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_f.htm_IX_MSG_META_KBD_CHAR">
 </A>
MSG_META_KBD_CHAR</H6>
<PRE CLASS="syntax">@importMessage MetaInputMessages, void MSG_META_KBD_CHAR(
        word 	character,
        word 	flags, /* low byte = CharFlags, high byte = ShiftState */
        word 	state);/* low byte = ToggleState, high byte = scan code */</PRE>
<P>
<A NAME="MetaClass_f.htm_IX_Keyboard input">
 </A>
This is the message sent out on any keyboard press or release. To determine whether the message is in response to a press or a release, check the CF_RELEASE bit of the <CODE>
flags</CODE>
 field.</P>
<P CLASS="refField">
Parameters:	<EM>character</EM> 	Low byte contains <CODE>
Char</CODE>
 value of incoming character.</P>
<DL>
<DT>
<EM>flags</EM> </DT><DD>High byte is <CODE>
ShiftState</CODE>
; low byte is <CODE>
CharFlags</CODE>
.</DD>
<DT>
<EM>state</EM> </DT><DD>High byte is raw PC scan code; low byte is <CODE>
ToggleState</CODE>
.</DD>
</DL>
<P CLASS="refField">
Return:	Nothing.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_f.htm_IX_MSG_META_MOUSE_DRAG">
 </A>
MSG_META_MOUSE_DRAG</H6>
<PRE CLASS="syntax">@importMessage MetaInputMessages, void MSG_META_MOUSE_DRAG(
        word 	xPosition,
        word 	yPosition,
        word 	inputState);</PRE>
<P>
This is a very low-level message, signalling that the user is dragging the mouse.</P>
<P CLASS="refField">
Parameters:	<EM>xPosition</EM>	X-coordinate of mouse event.</P>
<DL>
<DT>
<EM>yPosition</EM> </DT><DD>Y-coordinate of mouse event.</DD>
<DT>
<EM>inputState</EM></DT><DD>High byte is a <CODE>
ShiftState</CODE>
; low byte is <CODE>
ButtonInfo</CODE>
.</DD>
</DL>
<P CLASS="refField">
Return:	Nothing.</P>

<HR>
<A NAME="MetaClass_10.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">MetaClass</A>: 3.3 <A HREF="#MetaClass_d.htm">Exported Message Ranges</A>: 
<A NAME="MetaClass_10.htm_36279">
 </A>
UI Messages</H3>
<P>
<A NAME="MetaClass_10.htm_IX_Clipboard:MetaUIMessages">
 </A>
The User Interface generates many messages which may alert objects to events which will allow them to work with the user. These events include those generated from the actions of input devices and clipboard-related events.</P>

<H4 CLASS="HeadingC">
Clipboard Messages</H4>
<P>
<A NAME="MetaClass_10.htm_IX_Clipboard:MSG_META_CLIPBOARD_&ldots;">
 </A>
The following messages are used to implement common clipboard functions.</P>

<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_CLIPBOARD_CUT">
 </A>
MSG_META_CLIPBOARD_CUT</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, void 	MSG_META_CLIPBOARD_CUT();</PRE>
<P>
This message is sent to an object which is supposed to be the destination of a clipboard operation. <CODE>
MSG_META_CLIPBOARD_CUT</CODE>
 should register the current selection with the UI as the new clipboard item, but also delete the current selection. </P>
<P CLASS="refField">
Source:	Sent by anyone to perform clipboard operation.</P>
<P CLASS="refField">
Destination:	Object which will support clipboard operations. By default, a GenEditControl sends this message to the targeted object.</P>
<P CLASS="refField">
Interception:	May be intercepted to add clipboard support to existing class that doesn't currently have clipboard support or to enhance or replace functionality of object that does support the clipboard.</P>
<P CLASS="refField">
Parameters:	None.</P>
<P CLASS="refField">
Return:	Nothing.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_CLIPBOARD_COPY">
 </A>
MSG_META_CLIPBOARD_COPY</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, void 	MSG_META_CLIPBOARD_COPY();</PRE>
<P>
This message is sent to an object which is supposed to be the destination of a clipboard operation. <CODE>
MSG_META_CLIPBOARD_COPY</CODE>
 should be handled by registering the current selection with UI as the new clipboard item.</P>
<P CLASS="refField">
Source:	Sent by anyone to perform clipboard operation.</P>
<P CLASS="refField">
Destination:	Object which will support clipboard operations. By default, a GenEditControl sends this message to the targeted object.</P>
<P CLASS="refField">
Interception:	May be intercepted to add clipboard support to existing class that doesn't currently have clipboard support or to enhance or replace functionality of object that does support the clipboard.</P>
<P CLASS="refField">
Parameters:	None.</P>
<P CLASS="refField">
Return:	Nothing.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_CLIPBOARD_PASTE">
 </A>
MSG_META_CLIPBOARD_PASTE</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, void 	MSG_META_CLIPBOARD_PASTE();</PRE>
<P>
This message is sent to an object which is supposed to be the destination of a clipboard operation. <CODE>
MSG_META_CLIPBOARD_PASTE</CODE>
 should replace the current selection with the current clipboard item, which can be obtained from the UI.</P>
<P CLASS="refField">
Source:	Sent by anyone to perform clipboard operation.</P>
<P CLASS="refField">
Destination:	Object which will support clipboard operations. By default, a GenEditControl sends this message to the targeted object.</P>
<P CLASS="refField">
Interception:	May be intercepted to add clipboard support to existing class that doesn't currently have clipboard support or to enhance or replace functionality of object that does support the clipboard.</P>
<P CLASS="refField">
Parameters:	None.</P>
<P CLASS="refField">
Return:	Nothing.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_CLIPBOARD_NOTIFY_QUICK_TRANSFER_FEEDBACK">
 </A>
MSG_META_CLIPBOARD_NOTIFY_QUICK_TRANSFER_FEEDBACK</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, void 	MSG_META_CLIPBOARD_NOTIFY_QUICK_TRANSFER_FEEDBACK(
        ClipboardQuickNotifyFlags flags);</PRE>
<P>
<A NAME="MetaClass_10.htm_IX_Quick-transfer:MSG_META_CLIPBOARD_NOTIFY_QUICK_TRANSFER_&ldots;">
 </A>
This message is sent to the source of a quick transfer item when a potential destination provides feedback to the user indicating whether a move, a copy or no operation will occur. The default behavior is determined by the destination, but the user may be able to override with the MOVE or COPY override keys.</P>
<P CLASS="refField">
Source:	Sent by quick-transfer mechanism.</P>
<P CLASS="refField">
Destination:	Sent to optr passed to <CODE>
ClipboardStartQuickTransfer()</CODE>
. Handled if the quick-transfer source needs to know what quick-transfer operation a potential destination will perform. Handler need not call superclass.</P>
<P CLASS="refField">
Interception:	Message sent directly to destination, no need to intercept.</P>
<P CLASS="refField">
Parameters:	<EM>flags</EM> 	Quick transfer cursor action specified by source (see <CODE>
ClipboardSetQuickTransferFeedback()</CODE>
).</P>
<P CLASS="refField">
Return:	Nothing.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_CLIPBOARD_NOTIFY_QUICK_TRANSFER_CONCLUDED">
 </A>
MSG_META_CLIPBOARD_NOTIFY_QUICK_TRANSFER_CONCLUDED</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, void 	MSG_META_CLIPBOARD_NOTIFY_QUICK_TRANSFER_FEEDBACK(
        ClipboardQuickNotifyFlags 	flags);</PRE>
<P>
This message is sent to the source of a quick transfer item when the operation is completed. The <CODE>
ClipboardQuickNotifyFlags</CODE>
 are set by any <CODE>
MSG_META_END_MOVE_COPY</CODE>
 handler. This is only sent out if the source requests notification with the CQTF_NOTIFICATION flag passed to <CODE>
ClipboardStartQuickTransfer()</CODE>
.</P>
<P CLASS="refField">
Source:	Sent by quick-transfer mechanism.</P>
<P CLASS="refField">
Destination:	Sent to optr passed to <CODE>
ClipboardStartQuickTransfer()</CODE>
. Handled if the quick-transfer source needs to know what quick-transfer operation was performed. Handler need not call superclass.</P>
<P CLASS="refField">
Interception:	Message sent directly to source of transfer; no need to intercept.</P>
<P CLASS="refField">
Parameters:	<EM>flags</EM> 	Quick transfer cursor action specified by source (see <CODE>
ClipboardSetQuickTransferFeedback()</CODE>
).</P>
<P CLASS="refField">
Return:	Nothing.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_CLIPBOARD_NOTIFY_TRANSFER_ITEM_FREED">
 </A>
MSG_META_CLIPBOARD_NOTIFY_TRANSFER_ITEM_FREED</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, void 	MSG_META_CLIPBOARD_NOTIFY_TRANSFER_ITEM_FREED(
        VMFileHandle 	itemFile,
        VMBlockHandle 	itemBlock);</PRE>
<P>
Sent to all ODs in Transfer Notify List to help maintain integrity of transfer items from VM files other than the UI's transfer VM file. Only sent if VM file handle of transfer item that is being freed is different from UI's transfer VM file handle. If a transfer item from a VM file other than the UI's transfer VM file is registered, the VM blocks in that transfer item cannot be freed and the VM file cannot be closed until notification is sent saying that the transfer item has been freed. Registrars of such transfer items should keep track of the VM file handle and VM block handle of the item to check against the info sent by this message.</P>
<P CLASS="refField">
Source:	Sent by the clipboard mechanism.</P>
<P CLASS="refField">
Destination:	Sent to optrs on transfer notification list, added with <CODE>
ClipboardAddToNotificationList()</CODE>
. Handled if clipboard changes need to be monitored.</P>
<P CLASS="refField">
Interception:	Unlikely.</P>
<P CLASS="refField">
Parameters:	<EM>itemFile</EM> 	File containing the transfer item.</P>
<DL>
<DT>
<EM>itemBlock</EM></DT><DD>Block containing the transfer item.</DD>
</DL>
<P CLASS="refField">
Return:	Nothing.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_CLIPBOARD_NOTIFY_NORMAL_TRANSFER_ITEM_CHANGED">
 </A>
MSG_META_CLIPBOARD_NOTIFY_NORMAL_TRANSFER_ITEM_CHANGED</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, void 	MSG_META_CLIPBOARD_NOTIFY_NORMAL_TRANSFER_ITEM_CHANGED();</PRE>
<P>
Sent to all ODs in Transfer Notify List to help with updating of Cut, Copy, and Paste button states. Recipients can call <CODE>
ClipboardQueryItem()</CODE>
 to check if the new normal transfer item contains formats that the recipient supports. If not, Paste button can be disabled.</P>
<P CLASS="refField">
Source:	Sent by the clipboard mechanism, relayed by GenEditControl.</P>
<P CLASS="refField">
Destination:	Sent to optrs on transfer notification list, added with <CODE>
ClipboardAddToNotificationList()</CODE>
. Handled if clipboard changes need to be monitored.</P>
<P CLASS="refField">
Interception:	Unlikely.</P>
<P CLASS="refField">
Parameters:	None.</P>
<P CLASS="refField">
Return:	Nothing.</P>



<H4 CLASS="HeadingC">
Undo Messages</H4>
<P>
<A NAME="MetaClass_10.htm_IX_Undo:MSG_META_UNDO_&ldots;">
 </A>
These messages implement the &quot;undo&quot; mechanism which allows objects to store a chain of actions which can later be undone. </P>

<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_UNDO">
 </A>
MSG_META_UNDO</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, void 	MSG_META_UNDO(
        AddUndoActionStruct 	*data);</PRE>
<P>
This message is sent to an object which is supposed to be the destination of a clipboard operation.</P>
<P CLASS="refField">
Source:	Sent by anyone to perform clipboard operation.</P>
<P CLASS="refField">
Destination:	Object which will support clipboard operations. By default, a GenEditControl sends this message to the targeted object.</P>
<P CLASS="refField">
Interception:	May be intercepted to add clipboard support to existing class that doesn't currently have clipboard support or to enhance or replace functionality of object that does support the clipboard.</P>
<P CLASS="refField">
Parameters:	None.</P>
<P CLASS="refField">
Return:	Nothing.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_UNDO_FREEING_ACTION">
 </A>
MSG_META_UNDO_FREEING_ACTION</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, void 	MSG_META_UNDO_FREEING_ACTION(
        AddUndoActionStruct 	*data);</PRE>
<P>
This message is sent to an object which is supposed to be the destination of a clipboard operation. This message is used to undo those actions which may free an important block of memory.</P>
<P CLASS="refField">
Source:	Sent by anyone to perform clipboard operation.</P>
<P CLASS="refField">
Destination:	Object which will support clipboard operations. By default, a GenEditControl sends this message to the targeted object.</P>
<P CLASS="refField">
Interception:	May be intercepted to add clipboard support to existing class that doesn't currently have clipboard support or to enhance or replace functionality of object that does support the clipboard.</P>
<P CLASS="refField">
Parameters:	None.</P>
<P CLASS="refField">
Return:	Nothing.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_SELECT_ALL">
 </A>
MSG_META_SELECT_ALL</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, void 	MSG_META_SELECT_ALL();</PRE>
<P>
This message is sent to an object which is supposed to be the destination of a clipboard operation.</P>
<P CLASS="refField">
Source:	Sent by anyone to perform clipboard operation.</P>
<P CLASS="refField">
Destination:	Object which will support clipboard operations. By default, a GenEditControl sends this message to the targeted object.</P>
<P CLASS="refField">
Interception:	May be intercepted to add clipboard support to existing class that doesn't currently have clipboard support or to enhance or replace functionality of object that does support the clipboard.</P>
<P CLASS="refField">
Parameters:	None.</P>
<P CLASS="refField">
Return:	Nothing.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_DELETE">
 </A>
MSG_META_DELETE</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, void 	MSG_META_DELETE();</PRE>
<P>
This message is sent to an object which is supposed to be the destination of a clipboard operation. </P>
<P CLASS="refField">
Source:	Sent by anyone to perform clipboard operation.</P>
<P CLASS="refField">
Destination:	Object which will support clipboard operations. By default, a GenEditControl sends this message to the targeted object.</P>
<P CLASS="refField">
Interception:	May be intercepted to add clipboard support to existing class that doesn't currently have clipboard support or to enhance or replace functionality of object that does support the clipboard.</P>
<P CLASS="refField">
Parameters:	None.</P>
<P CLASS="refField">
Return:	Nothing.</P>



<H4 CLASS="HeadingC">
Input Messages</H4>
<P>
<A NAME="MetaClass_10.htm_IX_Input">
 </A>
These are perhaps the most often intercepted messages, allowing objects to detect input events.</P>

<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_GAINED_MOUSE_EXCL">
 </A>
MSG_META_GAINED_MOUSE_EXCL</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, void 	MSG_META_GAINED_MOUSE_EXCL();</PRE>
<P>
<A NAME="MetaClass_10.htm_IX_Exclusive grab:notification">
 </A>
The object will receive this message when it has received the mouse exclusive.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_LOST_MOUSE_EXCL">
 </A>
MSG_META_LOST_MOUSE_EXCL</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, void 	MSG_META_LOST_MOUSE_EXCL();</PRE>
<P>
The object will receive this message when it has lost the mouse exclusive.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_GAINED_KBD_EXCL">
 </A>
MSG_META_GAINED_KBD_EXCL</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, void 	MSG_META_GAINED_KBD_EXCL();</PRE>
<P>
<A NAME="MetaClass_10.htm_IX_Keyboard:exclusive notification">
 </A>
The object will receive this message when it has received the keyboard exclusive.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_LOST_KBD_EXCL">
 </A>
MSG_META_LOST_KBD_EXCL</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, void 	MSG_META_LOST_KBD_EXCL();</PRE>
<P>
The object will receive this message when it has lost the keyboard exclusive.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_GAINED_PRESSURE_EXCL">
 </A>
MSG_META_GAINED_PRESSURE_EXCL</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, void 	MSG_META_GAINED_PRESSURE_EXCL();</PRE>
<P>
The object will receive this message when it has received the pressure exclusive, meaning it will get certain low-level mouse events.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_LOST_PRESSURE_EXCL">
 </A>
MSG_META_LOST_PRESSURE_EXCL</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, void 	MSG_META_LOST_PRESSURE_EXCL();</PRE>
<P>
The object will receive this message when it has lost the pressure exclusive.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_GAINED_DIRECTION_EXCL">
 </A>
MSG_META_GAINED_DIRECTION_EXCL</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, void 	MSG_META_GAINED_DIRECTION_EXCL();</PRE>
<P>
The object will receive this message when it has received the direction exclusive, meaning it will get certain low-level mouse events.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_LOST_DIRECTION_EXCL">
 </A>
MSG_META_LOST_DIRECTION_EXCL</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, void 	MSG_META_LOST_DIRECTION_EXCL();</PRE>
<P>
The object will receive this message when it has lost the direction exclusive.</P>



<H4 CLASS="HeadingC">
Hierarchical Messages</H4>
<P>
These messages allow object to detect changes in the makeup of the three hierarchies which affect the paths of input and actions within the system: the Focus, Target, and Model hierarchies. These hierarchies are discussed in <A HREF="../../SysObjects/Input/combo.htm">the Input chapter</A>.</P>
<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_GRAB_FOCUS_EXCL">
 </A>
MSG_META_GRAB_FOCUS_EXCL</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, void 	MSG_META_GRAB_FOCUS_EXCL();</PRE>
<P>
<A NAME="MetaClass_10.htm_IX_Focus:exclusive">
 </A>
<A NAME="MetaClass_10.htm_IX_Exclusive grab:MSG_META_GRAB_FOCUS_EXCL">
 </A>
May be passed to any visible or generic object to cause it to become the active focus within its focus level. The leaf object in the hierarchy which gains the focus exclusive will automatically be given the keyboard exclusive, and will thereby receive <CODE>
MSG_META_KBD_CHAR</CODE>
 events that follow.</P>
<P>
Commonly sent to text objects and other gadgets to switch the current focus. May also be passed to GenPrimarys, GenDisplays, independently realizable GenInteractions, GenDisplayControl, GenViews, etc. (windowed things) to cause them to become the active focus window within their level of the focus hierarchy, if possible (specific UI's having real-estate focus, for instance, would ignore this request).</P>
<P>
Note that the object will not actually gain the focus exclusive until <EM>
all</EM>
 other nodes above it in the hierarchy also have the focus in their levels.</P>
<P>
This is the message equivalent of HINT_DEFAULT_FOCUS on generic objects.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_RELEASE_FOCUS_EXCL">
 </A>
MSG_META_RELEASE_FOCUS_EXCL</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, void 	MSG_META_RELEASE_FOCUS_EXCL();</PRE>
<P>
Opposite of <CODE>
MSG_META_GRAB_FOCUS_EXCL</CODE>
. If the object does not currently have the exclusive, nothing will be done.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_GET_FOCUS_EXCL">
 </A>
MSG_META_GET_FOCUS_EXCL</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, Boolean 	MSG_META_GET_FOCUS_EXCL(
        optr 	*focusObject);</PRE>
<P>
May be sent to any visible or generic object which is a focus node, to get current focus object directly below the node, if any, regardless of whether current node is active (has the exclusive itself).</P>
<P>
Focus nodes in Generic UI library: GenSystem, GenField, GenApplication, GenPrimary, GenDisplayGroup, GenDisplay, GenView, GenInteraction (independently displayable only). Focus nodes in Visible UI library: VisContent.</P>
<P CLASS="refField">
Parameters:	<EM>focusObject</EM> 	This will be filled with return value, the focus object below the object receiving the message.</P>
<P CLASS="refField">
Return:	Will return <EM>
true</EM>
 if message responded to. Will return <EM>
false</EM>
 if the message was sent to an object which is not a focus node.</P>
<DL>
<DT>
<EM>focusObject</EM> </DT><DD>The focus node under the object receiving the message.</DD>
</DL>
<P CLASS="refField">
Warnings:	This is a bad way to go about sending a message to currently active objects. For example, if you call from the application thread to the UI thread to find out which is the current focus gadget and then send a message to it, it is possible for the active gadget to change between the two calls. Use <CODE>
MSG_META_SEND_CLASSED_EVENT</CODE>
 for this type of operation if at all possible.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_GRAB_TARGET_EXCL">
 </A>
MSG_META_GRAB_TARGET_EXCL</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, void 	MSG_META_GRAB_TARGET_EXCL();</PRE>
<P>
<A NAME="MetaClass_10.htm_IX_Target:exclusive">
 </A>
May be passed to any visible or generic object to cause it to become the active target within the target level that it is in. The active target hierarchy is the path for the transmission of messages via TO_TARGET request of <CODE>
MSG_META_SEND_CLASSED_EVENT</CODE>
.</P>
<P>
Commonly sent to text objects and views to switch which is the current target. May also be passed to GenPrimarys, GenDisplays, independently realizable GenInteractions, GenDisplayControl, GenViews, etc. (windowed things) to cause them to become the active target window within their level f the target hierarchy.</P>
<P>
The specific UI will automatically grab the Target exclusive for an object on any mouse press within the object if it is marked as GA_TARGETABLE. </P>
<P>
Note that the object will not actually gain the target exclusive until <EM>
all</EM>
 other nodes above it in the hierarchy also have the target exclusive within their levels. This is the message equivalent of HINT_DEFAULT_TARGET.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_RELEASE_TARGET_EXCL">
 </A>
MSG_META_RELEASE_TARGET_EXCL</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, void 	MSG_META_RELEASE_TARGET_EXCL();</PRE>
<P>
Opposite of <CODE>
MSG_META_GRAB_TARGET_EXCL</CODE>
. If the object does not currently have the exclusive, nothing will be done.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_GET_TARGET_EXCL">
 </A>
MSG_META_GET_TARGET_EXCL</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, <STRONG>void</STRONG> 	MSG_META_GET_TARGET_EXCL(
        optr targetObject);</PRE>
<P>
May be sent to any visible or generic object which is a target node, to get the current target object directly below the node, if any, regardless of whether the current node is active (has the exclusive itself).</P>
<P>
Target nodes in Generic UI library: GenSystem, GenField, GenApplication, GenPrimary, GenDisplay, GenView, GenInteraction (independently displayable only). Target nodes in Visible UI library: VisContent.</P>
<P CLASS="refField">
Parameters:	<EM>targetObject</EM> 	This will be filled with return value, the target object below the object receiving the message.</P>
<P CLASS="refField">
Return:	Will return <EM>
true</EM>
 if message responded to. Will return <EM>
false</EM>
 if the message was sent to an object which is not a target node.</P>
<DL>
<DT>
<EM>targetObject</EM> </DT><DD>The target node under the object receiving the message.</DD>
</DL>
<P CLASS="refField">
Warnings:	This is a bad way to go about sending a message to currently active objects. For example, if you call from the application thread to the UI thread to find out which is the current target display, and then send a message to it, it is possible for the active display to change between the two calls. Use MSG_META_SEND_CLASSED_EVENT for this type of operation if at all possible.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_GRAB_MODEL_EXCL">
 </A>
MSG_META_GRAB_MODEL_EXCL</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, void 	MSG_META_GRAB_MODEL_EXCL();</PRE>
<P>
<A NAME="MetaClass_10.htm_IX_Model:exclusive">
 </A>
May be passed to any visible or generic object to cause it to become the active model within the model level that it is in. The active model hierarchy is the override path for the transmission of messages via TO_MODEL of <CODE>
MSG_META_SEND_CLASSED_EVENT</CODE>
. (If no model hierarchy exists, the messages will be sent down the Target hierarchy.)</P>
<P>
Note that the object will not actually gain the model exclusive until <EM>
all</EM>
 other nodes above it in the hierarchy also have the model exclusive within their levels. This is the message equivalent of HINT_MAKE_DEFAULT_MODEL.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_RELEASE_MODEL_EXCL">
 </A>
MSG_META_RELEASE_MODEL_EXCL</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, void 	MSG_META_RELEASE_MODEL_EXCL();</PRE>
<P>
Opposite of <CODE>
MSG_META_GRAB_MODEL_EXCL</CODE>
. If the object does not currently have the exclusive, nothing will be done.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_GET_MODEL_EXCL">
 </A>
MSG_META_GET_MODEL_EXCL</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, void 	MSG_META_GET_MODEL_EXCL(
        optr targetObject);</PRE>
<P>
May be sent to any visible or generic object which is a model node, to get current model object directly below the node, if any, regardless of whether current node is active (has the exclusive itself).</P>
<P>
Model nodes in Generic UI library: GenSystem, GenApplication, GenDocumentControl, GenDocumentGroup.</P>
<P CLASS="refField">
Parameters:	<EM>modelObject</EM> 	This will be filled with return value, the target object below the object receiving the message.</P>
<P CLASS="refField">
Return:	Will return <EM>
true</EM>
 if message responded to. Will return <EM>
false</EM>
 if the message was sent to an object which is not a target node.</P>
<DL>
<DT>
<EM>modelObject</EM> </DT><DD>The target node under the object receiving the message.</DD>
</DL>
<P CLASS="refField">
Warnings:	This is a bad way to go about sending a message to currently active objects. For example, if you call from the application thread to the UI thread to find out which is the current model display, and then send a message to it, it is possible for the active display to change between the two calls. Use MSG_META_SEND_CLASSED_EVENT for this type of operation if at all possible.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_GAINED_FOCUS_EXCL">
 </A>
MSG_META_GAINED_FOCUS_EXCL</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, void 	MSG_META_GAINED_FOCUS_EXCL();</PRE>
<P>
See description for this and other gained/lost exclusive messages below.</P>
<P>
<A NAME="MetaClass_10.htm_IX_Focus:exclusive notification">
 </A>
Special note on <CODE>
MSG_META_GAINED_FOCUS_EXCL</CODE>
 and <CODE>
MSG_META_LOST_FOCUS_EXCL</CODE>
: If the object receiving <CODE>
MSG_META_GAINED_FOCUS_EXCL</CODE>
 is the leaf object in the hierarchy, meaning that it is either not a node itself, or if it is a node, does not have any object below it which has grabbed the exclusive, then the object will automatically be granted the <CODE>
MSG_META_GAINED_KBD_EXCL</CODE>
 as well, and thereby receive any <CODE>
MSG_META_KBD_CHAR</CODE>
 messages which are generated. The object will receive <CODE>
MSG_META_LOST_KBD_EXCL</CODE>
 before MSG_META_LOST_FOCUS_EXCL.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_LOST_FOCUS_EXCL">
 </A>
MSG_META_LOST_FOCUS_EXCL</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, void 	MSG_META_LOST_FOCUS_EXCL();</PRE>
<P>
See description for this and other gained/lost exclusive messages below.</P>
<P>
Special note on <CODE>
MSG_META_GAINED_FOCUS_EXCL</CODE>
 and <CODE>
MSG_META_LOST_FOCUS_EXCL</CODE>
: If the object receiving <CODE>
MSG_META_GAINED_FOCUS_EXCL</CODE>
 is the leaf object in the hierarchy, meaning that it is either not a node itself, or if it is a node, does not have any object below it which has grabbed the exclusive, then the object will automatically be granted the <CODE>
MSG_META_GAINED_KBD_EXCL</CODE>
 as well, and thereby receive any <CODE>
MSG_META_KBD_CHAR</CODE>
 messages which are generated. The object will receive <CODE>
MSG_META_LOST_KBD_EXCL</CODE>
 before MSG_META_LOST_FOCUS_EXCL.</P>
<P CLASS="refField">
Tips and Tricks:	If you intercept this message and call the superclass, be aware that the superclass' handler does some of the focus-releasing tasks by sending messages. This can lead to synchronization problems if your method's code looks like the following:</P>
<PRE>			@callsuper();
			call self::MSG_GEN_APPLY();</PRE>
<P>
To make sure that the superclass is finished updating the focus before carrying out any operations which rely upon a valid focus, you would change the above code to read:</P>
<PRE>			@callsuper();
			@send ,forceQueue ,insertAtFront self::MSG_GEN_APPLY();</PRE>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_GAINED_SYS_FOCUS_EXCL">
 </A>
MSG_META_GAINED_SYS_FOCUS_EXCL</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, void MSG_META_GAINED_SYS_FOCUS_EXCL();</PRE>
<P>
See description for this and other gained/lost exclusive messages below.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_LOST_SYS_FOCUS_EXCL">
 </A>
MSG_META_LOST_SYS_FOCUS_EXCL</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, void MSG_META_LOST_SYS_FOCUS_EXCL();</PRE>
<P>
See description for this and other gained/lost exclusive messages below.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_GAINED_TARGET_EXCL">
 </A>
MSG_META_GAINED_TARGET_EXCL</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, void MSG_META_GAINED_TARGET_EXCL();</PRE>
<P>
See description for this and other gained/lost exclusive messages below.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_LOST_TARGET_EXCL">
 </A>
MSG_META_LOST_TARGET_EXCL</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, void MSG_META_LOST_TARGET_EXCL();</PRE>
<P>
See description for this and other gained/lost exclusive messages below.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_GAINED_SYS_TARGET_EXCL">
 </A>
MSG_META_GAINED_SYS_TARGET_EXCL</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, void MSG_META_GAINED_SYS_TARGET_EXCL();</PRE>
<P>
See description for this and other gained/lost exclusive messages below.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_LOST_SYS_TARGET_EXCL">
 </A>
MSG_META_LOST_SYS_TARGET_EXCL</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, void MSG_META_LOST_SYS_TARGET_EXCL();</PRE>
<P>
See description for this and other gained/lost exclusive messages below.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_GAINED_MODEL_EXCL">
 </A>
MSG_META_GAINED_MODEL_EXCL</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, void 	MSG_META_GAINED_MODEL_EXCL();</PRE>
<P>
See description for this and other gained/lost exclusive messages below.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_LOST_MODEL_EXCL">
 </A>
MSG_META_LOST_MODEL_EXCL</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, void MSG_META_LOST_MODEL_EXCL();</PRE>
<P>
See description for this and other gained/lost exclusive messages below.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_GAINED_SYS_MODEL_EXCL">
 </A>
MSG_META_GAINED_SYS_MODEL_EXCL</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, void MSG_META_GAINED_SYS_MODEL_EXCL();</PRE>
<P>
See description for this and other gained/lost exclusive messages below.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_LOST_SYS_MODEL_EXCL">
 </A>
MSG_META_LOST_SYS_MODEL_EXCL</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, void MSG_META_LOST_SYS_MODEL_EXCL();</PRE>
<P>
These paired gained/lost messages for the Focus, Target, and Model hierarchies are sent, always in the order GAINED, then at some point LOST, to objects on the hierarchy. The GAINED message is sent only when the object in question and all nodes in the hierarchy above that object have gained the exclusive from the node above them, all the way up to the application object. </P>
<P>
In other words, just grabbing the exclusive from the next node up doesn't always guarantee you'll get a GAINED message; the node you're grabbing from must have itself received a GAINED message but not yet the LOST message. Your object will receive the LOST message if it has either released the exclusive, or the node from which you grabbed the exclusive itself received a LOST message.</P>
<P>
The GAINED_SYS and LOST_SYS messages behave similarly, except that an object can only gain the SYS_EXCL (System exclusive) if it and all nodes above it to the GenSystem object have the grab from the next node up. An object will never receive a GAINED_SYS_EXCL message if it has not already received an (Application) GAINED_EXCL message also. Similarly, an object will always receive a LOST_SYS_EXCL message before it receives an (Application) LOST_EXCL message.</P>
<P CLASS="refField">
Source:	Do <EM>
not</EM>
 send these messages to objects yourself, unless you are implementing or extending the above mechanism. These messages should be sent only by the node object which is above the object receiving the message.</P>
<P CLASS="refField">
Destination:	Any <CODE>
MetaClass</CODE>
 object which has grabbed and not yet released the focus exclusive.</P>
<P CLASS="refField">
Interception:	Generic UI objects, <CODE>
VisTextClass</CODE>
, and all node objects provide default behavior for processing this message. If you intercept above any of these levels, be sure to call the superclass to let these objects know the exclusive has been gained.</P>



<H4 CLASS="HeadingC">
Miscellaneous Input Messages</H4>

<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_GRAB_KBD">
 </A>
MSG_META_GRAB_KBD</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, void MSG_META_GRAB_KBD();</PRE>
<P>
This message grabs the keyboard for an object. The grab will not be taken away from another object if it currently has the keyboard grab. To forcefully grab the keyboard in this case, use MSG_META_FORCE_GRAB_KBD.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_FORCE_GRAB_KBD">
 </A>
MSG_META_FORCE_GRAB_KBD</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, void MSG_META_FORCE_GRAB_KBD();</PRE>
<P>
This message forcefully grabs the keyboard for an object, tasking the grab away from another object, if necessary.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_RELEASE_KBD">
 </A>
MSG_META_RELEASE_KBD</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, void MSG_META_RELEASE_KBD();</PRE>
<P>
This message releases the keyboard grab for an object.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_RELEASE_FT_EXCL">
 </A>
MSG_META_RELEASE_FT_EXCL</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, void 	MSG_META_RELEASE_FT_EXCL();</PRE>
<P>
<A NAME="MetaClass_10.htm_IX_Exclusive grab:releasing all">
 </A>
This message releases exclusive(s) that the object may have on the Focus and Target hierarchies.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_GAINED_DEFAULT_EXCL">
 </A>
MSG_META_GAINED_DEFAULT_EXCL</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, void 	MSG_META_GAINED_DEFAULT_EXCL();</PRE>
<P>
This message notifies a GenTrigger that it has gained the default exclusive.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_LOST_DEFAULT_EXCL">
 </A>
MSG_META_LOST_DEFAULT_EXCL</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, void 	MSG_META_LOST_DEFAULT_EXCL();</PRE>
<P>
This message notifies a GenTrigger that it has lost the default exclusive.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_GAINED_FULL_SCREEN_EXCL">
 </A>
MSG_META_GAINED_FULL_SCREEN_EXCL</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, void MSG_META_GAINED_FULL_SCREEN_EXCL();</PRE>
<P>
This message is sent to GenFields or GenApplications upon gain of the &quot;full-screen&quot; exclusive. The full-screen exclusive grants the object the top screen-dominating object at its level.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_LOST_FULL_SCREEN_EXCL">
 </A>
MSG_META_LOST_FULL_SCREEN_EXCL</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, void MSG_META_LOST_FULL_SCREEN_EXCL();</PRE>
<P>
This message is sent to GenFields or GenApplications upon loss of the &quot;full-screen&quot; exclusive. The full-screen exclusive grants the object the top screen-dominating object at its level.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_MOUSE_BUMP_NOTIFICATION">
 </A>
MSG_META_MOUSE_BUMP_NOTIFICATION</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, void 	MSG_META_MOUSE_BUMP_NOTIFICATION(
        sword 	xBump,
        sword 	yBump);</PRE>
<P>
This message is an event that the input manager places in the input queue to notify the UI that it has bumped the mouse position past this point in the queue. This method is sent only when <CODE>
IMBumpMouse()</CODE>
 is called.</P>
<P CLASS="refField">
Parameters:	<EM>xBump</EM> 	Horizontal relative bump.</P>
<DL>
<DT>
<EM>yBump</EM> </DT><DD>Vertical relative bump.</DD>


</DL>
<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_FUP_KBD_CHAR">
 </A>
MSG_META_FUP_KBD_CHAR</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, Boolean 	MSG_META_FUP_KBD_CHAR(
        word 	character,
        word 	flags,
        word 	state);</PRE>
<P>
<A NAME="MetaClass_10.htm_IX_Keyboard input:passing on">
 </A>
When a leaf object in the focus hierarchy gets a MSG_META_KBD_CHAR, and does not care about the character, it sends this message to itself to see if a parent object wants to handle it.</P>
<P CLASS="refField">
Parameters:	<EM>character</EM> 	The low byte contains a <CODE>
Char</CODE>
 value.</P>
<DL>
<DT>
<EM>flags</EM> </DT><DD>High byte is a <CODE>
ShiftState</CODE>
 field; low byte is a <CODE>
CharFlags</CODE>
 field.</DD>
<DT>
<EM>state</EM> </DT><DD>High byte is the raw PC scan code; low byte is a <CODE>
ToggleState</CODE>
 field.</DD>
</DL>
<P CLASS="refField">
Return:	Will return <EM>
true</EM>
 if the character was handled by someone (and should not be used elsewhere).</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_PRE_PASSIVE_KBD_CHAR">
 </A>
MSG_META_PRE_PASSIVE_KBD_CHAR</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, KbdReturnFlags 	MSG_META_PRE_PASSIVE_KBD_CHAR(
        word 	character,
        word 	flags,
        word 	state);</PRE>
<P>
This message sends a keyboard character to any object requesting preview of the keyboard events.</P>
<P CLASS="refField">
Parameters:	<EM>character</EM> 	The low byte contains a <CODE>
Char</CODE>
 value.</P>
<DL>
<DT>
<EM>flags</EM> </DT><DD>High byte is a <CODE>
ShiftState</CODE>
 field; low byte is a <CODE>
CharFlags</CODE>
 field.</DD>
<DT>
<EM>state</EM> </DT><DD>High byte is the raw PC scan code; low byte is a <CODE>
ToggleState</CODE>
 field.</DD>
</DL>
<P CLASS="refField">
Return:	Flags field specifying what should happen to event.</P>
<P CLASS="refField">
Structures:	</P>
<PRE><A NAME="MetaClass_10.htm_IX_KbdReturnFlags"> </A>typedef WordFlags 	KbdReturnFlags;</PRE>
<PRE>#define <A NAME="MetaClass_10.htm_IX_KRF_PREVENT_PASS_THROUGH"> </A>KRF_PREVENT_PASS_THROUGH 0x8000
/* Set for passive keyboard routines if event should
 * be destroyed and not passed on to implied or
 * default grab. */</PRE>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_POST_PASSIVE_KBD_CHAR">
 </A>
MSG_META_POST_PASSIVE_KBD_CHAR</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, KbdReturnFlags 	MSG_META_POST_PASSIVE_KBD_CHAR(
        word 	character,
        word 	flags,
        word 	state);</PRE>
<P>
This message passes keyboard characters to all objects having registered interest in getting keyboard events after they have been handled.</P>
<P CLASS="refField">
Parameters:	<EM>character</EM> 	The low byte contains a <CODE>
Char</CODE>
 value.</P>
<DL>
<DT>
<EM>flags</EM> </DT><DD>High byte is a <CODE>
ShiftState</CODE>
 field; low byte is a <CODE>
CharFlags</CODE>
 field.</DD>
<DT>
<EM>state</EM> </DT><DD>High byte is the raw PC scan code; low byte is a <CODE>
ToggleState</CODE>
 field.</DD>
</DL>
<P CLASS="refField">
Return:	Flags field specifying what should happen to event.</P>
<P CLASS="refField">
Structures:	</P>
<PRE>typedef WordFlags 	KbdReturnFlags;</PRE>
<PRE>#define KRF_PREVENT_PASS_THROUGH 0x8000
/* Set for passive keyboard routines if event should
 * be destroyed and not passed on to implied or
 * default grab. */</PRE>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_QUERY_IF_PRESS_IS_INK">
 </A>
MSG_META_QUERY_IF_PRESS_IS_INK</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, void 	MSG_META_QUERY_IF_PRESS_IS_INK(
        InkReturnParams 		*retVal,
        sword 		xPosition,
        sword 		yPosition);</PRE>
<P>
<A NAME="MetaClass_10.htm_IX_Ink:detecting">
 </A>
Return whether or not a <CODE>
MSG_META_START_SELECT</CODE>
 should be passed on to the object, or whether it should be intercepted and turned into ink.</P>
<P CLASS="refField">
Source:	Sent by any object (usually VisComp) to determine if one of its children wants ink.</P>
<P CLASS="refField">
Destination:	Any object in the Vis linkage that may be clicked on with the mouse.</P>
<P CLASS="refField">
Interception:	The default handler returns IRV_NO_INK (filling in the <CODE>
inkType</CODE>
 field of the <EM>
retVal</EM>
 argument). Objects that want presses to be turned into ink need to return IRV_DESIRES_INK. Some objects that need to do work on another thread (such as a GenView) to determine whether the press should be ink or not can return IRV_WAIT, which holds up the <CODE>
MSG_META_START_SELECT</CODE>
 until a <CODE>
MSG_GEN_APPLICATION_INK_QUERY_REPLY</CODE>
 is sent to the application object. By default, clicks on VisComp-derived objects will <EM>
not</EM>
 be ink. To change this, set <CODE>
VisCompMakePressesInk()</CODE>
 as the handler for this message.</P>
<P CLASS="refField">
Parameters:	<EM>retVal	</EM>Empty structure which will be filled with return value information.</P>
<DL>
<DT>
<EM>xPosition</EM> </DT><DD><EM>
x</EM>
-coordinate of selection start.</DD>
<DT>
<EM>yPosition</EM> </DT><DD><EM>
y</EM>
-coordinate of selection start.</DD>
</DL>
<P CLASS="refField">
Return:	Indication whether object thinks the press was ink.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_LARGE_QUERY_IF_PRESS_IS_INK">
 </A>
MSG_META_LARGE_QUERY_IF_PRESS_IS_INK</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, void MSG_META_LARGE_QUERY_IF_PRESS_IS_INK(
        InkReturnParams		*retVal,
        LargeMouseData		*largeMouseDataStruct);</PRE>
<P>
This message is sent by the system to children with the VCNA_LARGE_DOCUMENT_MODEL bit set to determines whether or not a MSG_META_LARGE_START_SELECT should be processed as ink.</P>
<P CLASS="refField">
Source:	Sent by any object (usually VisComp) to determine if one of its children wants ink.</P>
<P CLASS="refField">
Destination:	Any object in the Vis linkage that may be clicked on with the mouse.</P>
<P CLASS="refField">
Parameters:	<EM>
retVal</EM>
	Pointer to an <CODE>
InkReturnParams</CODE>
 structure that will be filled in by the handler for this message.</P>
<DL>
<DT>
<EM>
largeMouseDataStruct</DT><DD>
</EM>
Pointer to a <CODE>
LargeMouseData</CODE>
 struct that stores information about the large mouse event.</DD>
</DL>
<P CLASS="refField">
Interception:	The default handler returns IRV_NO_INK. Objects that want presses to be turned into ink need to return IRV_DESIRES_INK. Some objects that need to do work on another thread (such as a VisContent) to determine whether the press should be ink or not can return IRV_WAIT, which holds up the <CODE>
MSG_META_LARGE_START_SELECT</CODE>
 until a <CODE>
MSG_GEN_APPLICATION_INK_QUERY_REPLY</CODE>
 is sent to the application object. </P>



<H4 CLASS="HeadingC">
Mouse Input Messages</H4>
<P>
The following messages allow an application to detect the nature and behavior of pointing devices within the system.</P>

<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_START_SELECT">
 </A>
MSG_META_START_SELECT</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, void 	MSG_META_START_SELECT(
        MouseReturnParams 		*retVal,
        sword 		xPosition,
        sword 		yPosition,
        word 		inputState);</PRE>
<P>
For description of this and other button messages, see below.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_END_SELECT">
 </A>
MSG_META_END_SELECT</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, void 	MSG_META_END_SELECT(
        MouseReturnParams 		*retVal,
        sword 		xPosition,
        sword 		yPosition,
        word 		inputState);</PRE>
<P>
For description of this and other button messages, see below.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_START_MOVE_COPY">
 </A>
MSG_META_START_MOVE_COPY</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, void 	MSG_META_START_MOVE_COPY(
        MouseReturnParams 		*retVal,
        sword 		xPosition,
        sword 		yPosition,
        word 		inputState);</PRE>
<P>
For description of this and other button messages, see below.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_END_MOVE_COPY">
 </A>
MSG_META_END_MOVE_COPY</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, void 	MSG_META_END_MOVE_COPY(
        MouseReturnParams 		*retVal,
        sword 		xPosition,
        sword 		yPosition,
        word 		inputState);</PRE>
<P>
For description of this and other button messages, see below.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_START_FEATURES">
 </A>
MSG_META_START_FEATURES</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, void 	MSG_META_START_FEATURES(
        MouseReturnParams 		*retVal,
        sword 		xPosition,
        sword 		yPosition,
        word 		inputState);</PRE>
<P>
For description of this and other button messages, see below.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_END_FEATURES">
 </A>
MSG_META_END_FEATURES</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, void 	MSG_META_END_FEATURES(
        MouseReturnParams 		*retVal,
        sword 		xPosition,
        sword 		yPosition,
        word 		inputState);</PRE>
<P>
For description of this and other button messages, see below.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_START_OTHER">
 </A>
MSG_META_START_OTHER</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, void 	MSG_META_START_OTHER(
        MouseReturnParams 		*retVal,
        sword 		xPosition,
        sword 		yPosition,
        word 		inputState);</PRE>
<P>
For description of this and other button messages, see below.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_END_OTHER">
 </A>
MSG_META_END_OTHER</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, void 	MSG_META_END_OTHER(
        MouseReturnParams 		*retVal,
        sword 		xPosition,
        sword 		yPosition,
        word 		inputState);</PRE>
<P>
For description of this and other button messages, see below.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_DRAG_SELECT">
 </A>
MSG_META_DRAG_SELECT</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, void 	MSG_META_DRAG_SELECT(
        MouseReturnParams 		*retVal,
        sword 		xPosition,
        sword 		yPosition,
        word 		inputState);</PRE>
<P>
For description of this and other button messages, see below.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_DRAG_MOVE_COPY">
 </A>
MSG_META_DRAG_MOVE_COPY</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, void 	MSG_META_DRAG_MOVE_COPY(
        MouseReturnParams 		*retVal,
        sword 		xPosition,
        sword 		yPosition,
        word 		inputState);</PRE>
<P>
For description of this and other button messages, see below.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_DRAG_FEATURES">
 </A>
MSG_META_DRAG_FEATURES</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, void 	MSG_META_DRAG_FEATURES(
        MouseReturnParams 		*retVal,
        sword 		xPosition,
        sword 		yPosition,
        word 		inputState);</PRE>
<P>
For description of this and other button messages, see below.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_DRAG_OTHER">
 </A>
MSG_META_DRAG_OTHER</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, void 	MSG_META_DRAG_OTHER(
        MouseReturnParams 		*retVal,
        sword 		xPosition,
        sword 		yPosition,
        word 		inputState);</PRE>
<P>
For description of this and other button messages, see below.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_PRE_PASSIVE_BUTTON">
 </A>
MSG_META_PRE_PASSIVE_BUTTON</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, void 	MSG_META_PRE_PASSIVE_BUTTON(
        MouseReturnParams 		*retVal,
        sword 		xPosition,
        sword 		yPosition,
        word 		inputState);</PRE>
<P>
For description of this and other button messages, see below.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_POST_PASSIVE_BUTTON">
 </A>
MSG_META_POST_PASSIVE_BUTTON</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, void 	MSG_META_POST_PASSIVE_BUTTON(
        MouseReturnParams 		*retVal,
        sword 		xPosition,
        sword 		yPosition,
        word 		inputState);</PRE>
<P>
For description of this and other button messages, see below.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_PRE_PASSIVE_START_SELECT">
 </A>
MSG_META_PRE_PASSIVE_START_SELECT</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, void 	MSG_META_PRE_PASSIVE_START_SELECT(
        MouseReturnParams 		*retVal,
        sword 		xPosition,
        sword 		yPosition,
        word 		inputState);</PRE>
<P>
For description of this and other button messages, see below.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_POST_PASSIVE_START_SELECT">
 </A>
MSG_META_POST_PASSIVE_START_SELECT</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, void 	MSG_META_POST_PASSIVE_START_SELECT(
        MouseReturnParams 		*retVal,
        sword 		xPosition,
        sword 		yPosition,
        word 		inputState);</PRE>
<P>
For description of this and other button messages, see below.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_PRE_PASSIVE_END_SELECT">
 </A>
MSG_META_PRE_PASSIVE_END_SELECT</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, void 	MSG_META_PRE_PASSIVE_END_SELECT(
        MouseReturnParams 		*retVal,
        sword 		xPosition,
        sword 		yPosition,
        word 		inputState);</PRE>
<P>
For description of this and other button messages, see below.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_POST_PASSIVE_END_SELECT">
 </A>
MSG_META_POST_PASSIVE_END_SELECT</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, void 	MSG_META_POST_PASSIVE_END_SELECT(
        MouseReturnParams 		*retVal,
        sword 		xPosition,
        sword 		yPosition,
        word 		inputState);</PRE>
<P>
For description of this and other button messages, see below.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_PRE_PASSIVE_START_MOVE_COPY">
 </A>
MSG_META_PRE_PASSIVE_START_MOVE_COPY</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, void 	MSG_META_PRE_PASSIVE_START_MOVE_COPY(
        MouseReturnParams 		*retVal,
        sword 		xPosition,
        sword 		yPosition,
        word 		inputState);</PRE>
<P>
For description of this and other button messages, see below.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_POST_PASSIVE_START_MOVE_COPY">
 </A>
MSG_META_POST_PASSIVE_START_MOVE_COPY</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, void 	MSG_META_POST_PASSIVE_START_MOVE_COPY(
        MouseReturnParams 		*retVal,
        sword 		xPosition,
        sword 		yPosition,
        word 		inputState);</PRE>
<P>
For description of this and other button messages, see below.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_PRE_PASSIVE_END_MOVE_COPY">
 </A>
MSG_META_PRE_PASSIVE_END_MOVE_COPY</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, void 	MSG_META_PRE_PASSIVE_END_MOVE_COPY(
        MouseReturnParams 		*retVal,
        sword 		xPosition,
        sword 		yPosition,
        word 		inputState);</PRE>
<P>
For description of this and other button messages, see below.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_POST_PASSIVE_END_MOVE_COPY">
 </A>
MSG_META_POST_PASSIVE_END_MOVE_COPY</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, void 	MSG_META_POST_PASSIVE_END_MOVE_COPY(
        MouseReturnParams 		*retVal,
        sword 		xPosition,
        sword 		yPosition,
        word 		inputState);</PRE>
<P>
For description of this and other button messages, see below.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_PRE_PASSIVE_START_FEATURES">
 </A>
MSG_META_PRE_PASSIVE_START_FEATURES</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, void 	MSG_META_PRE_PASSIVE_START_FEATURES(
        MouseReturnParams 		*retVal,
        sword 		xPosition,
        sword 		yPosition,
        word 		inputState);</PRE>
<P>
For description of this and other button messages, see below.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_POST_PASSIVE_START_FEATURES">
 </A>
MSG_META_POST_PASSIVE_START_FEATURES</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, void 	MSG_META_POST_PASSIVE_START_FEATURES(
        MouseReturnParams 		*retVal,
        sword 		xPosition,
        sword 		yPosition,
        word 		inputState);</PRE>
<P>
For description of this and other button messages, see below.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_PRE_PASSIVE_END_FEATURES">
 </A>
MSG_META_PRE_PASSIVE_END_FEATURES</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, void 	MSG_META_PRE_PASSIVE_END_FEATURES(
        MouseReturnParams 		*retVal,
        sword 		xPosition,
        sword 		yPosition,
        word 		inputState);</PRE>
<P>
For description of this and other button messages, see below.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_POST_PASSIVE_END_FEATURES">
 </A>
MSG_META_POST_PASSIVE_END_FEATURES</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, void 	MSG_META_POST_PASSIVE_END_FEATURES(
        MouseReturnParams 		*retVal,
        sword 		xPosition,
        sword 		yPosition,
        word 		inputState);</PRE>
<P>
For description of this and other button messages, see below.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_PRE_PASSIVE_START_OTHER">
 </A>
MSG_META_PRE_PASSIVE_START_OTHER</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, void 	MSG_META_PRE_PASSIVE_START_OTHER(
        MouseReturnParams 		*retVal,
        sword 		xPosition,
        sword 		yPosition,
        word 		inputState);</PRE>
<P>
For description of this and other button messages, see below.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_POST_PASSIVE_START_OTHER">
 </A>
MSG_META_POST_PASSIVE_START_OTHER</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, void 	MSG_META_POST_PASSIVE_START_OTHER(
        MouseReturnParams 		*retVal,
        sword 		xPosition,
        sword 		yPosition,
        word 		inputState);</PRE>
<P>
For description of this and other button messages, see below.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_PRE_PASSIVE_END_OTHER">
 </A>
MSG_META_PRE_PASSIVE_END_OTHER</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, void 	MSG_META_PRE_PASSIVE_END_OTHER(
        MouseReturnParams 		*retVal,
        sword 		xPosition,
        sword 		yPosition,
        word 		inputState);</PRE>
<P>
For description of this and other button messages, see below.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_POST_PASSIVE_END_OTHER">
 </A>
MSG_META_POST_PASSIVE_END_OTHER</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, void 	MSG_META_POST_PASSIVE_END_OTHER(
        MouseReturnParams 		*retVal,
        sword 		xPosition,
        sword 		yPosition,
        word 		inputState);</PRE>
<P>
The above messages are the standard button functions generated by the UI upon receiving <CODE>
MSG_META_BUTTON</CODE>
 events from the Input Manager. These messages are sent out to whatever object has the implied grab (whichever window the mouse is over), until the mouse is &quot;grabbed&quot; by an object, after which the messages go there until the mouse is released (ungrabbed).</P>
<P CLASS="refField">
Parameters:	<EM>retVal</EM>	Structure to hold return values.</P>
<DL>
<DT>
<EM>xPosition</EM> </DT><DD><EM>
x</EM>
-coordinate of press.</DD>
<DT>
<EM>yPosition</EM> </DT><DD><EM>
y</EM>
-coordinate of press.</DD>
<DT>
<EM>inputState</EM></DT><DD>High byte is <CODE>
UIFunctionsActive</CODE>
 structure; low byte is <CODE>
ButtonInfo</CODE>
 structure.</DD>
</DL>
<P CLASS="refField">
Structures:	</P>
<PRE><A NAME="MetaClass_10.htm_IX_MouseReturnParams"> </A>typedef struct {
	word 			unused;
	MouseReturnFlags 			flags;
	optr 			ptrImage;
} MouseReturnParams;</PRE>
<PRE><A NAME="MetaClass_10.htm_IX_MRF_&ldots;"> </A><A NAME="IX_MouseReturnFlags"> </A>typedef WordFlags MouseReturnFlags;
/* These flags may be combined using | and &amp;:
	MRF_PROCESSED,
	MRF_REPLAY,
	MRF_PREVENT_PASS_THROUGH,
	MRF_SET_POINTER_IMAGE,
	MRF_CLEAR_POINTER_IMAGE */</PRE>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_LARGE_PTR">
 </A>
MSG_META_LARGE_PTR</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, void 	MSG_META_LARGE_PTR(
        MouseReturnParams 		*retVal,
        LargeMouseData 		*largeMouseDataStruct);</PRE>
<P>
<A NAME="MetaClass_10.htm_IX_Large document model">
 </A>
See below for information about this and other large mouse messages.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_LARGE_START_SELECT">
 </A>
MSG_META_LARGE_START_SELECT</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, void 	MSG_META_LARGE_START_SELECT(
        MouseReturnParams 		*retVal,
        LargeMouseData 		*largeMouseDataStruct);</PRE>
<P>
See below for information about this and other large mouse messages.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_LARGE_END_SELECT">
 </A>
MSG_META_LARGE_END_SELECT</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, void 	MSG_META_LARGE_END_SELECT(
        MouseReturnParams 		*retVal,
        LargeMouseData 		*largeMouseDataStruct);</PRE>
<P>
See below for information about this and other large mouse messages.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_LARGE_START_MOVE_COPY">
 </A>
MSG_META_LARGE_START_MOVE_COPY</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, void 	MSG_META_LARGE_START_MOVE_COPY(
        MouseReturnParams 		*retVal,
        LargeMouseData 		*largeMouseDataStruct);</PRE>
<P>
See below for information about this and other large mouse messages.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_LARGE_END_MOVE_COPY">
 </A>
MSG_META_LARGE_END_MOVE_COPY</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, void 	MSG_META_LARGE_END_MOVE_COPY(
        MouseReturnParams 		*retVal,
        LargeMouseData 		*largeMouseDataStruct);</PRE>
<P>
See below for information about this and other large mouse messages.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_LARGE_START_FEATURES">
 </A>
MSG_META_LARGE_START_FEATURES</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, void 	MSG_META_LARGE_START_FEATURES(
        MouseReturnParams 		*retVal,
        LargeMouseData 		*largeMouseDataStruct);</PRE>
<P>
See below for information about this and other large mouse messages.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_LARGE_END_FEATURES">
 </A>
MSG_META_LARGE_END_FEATURES</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, void 	MSG_META_LARGE_END_FEATURES(
        MouseReturnParams 		*retVal,
        LargeMouseData 		*largeMouseDataStruct);</PRE>
<P>
See below for information about this and other large mouse messages.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_LARGE_START_OTHER">
 </A>
MSG_META_LARGE_START_OTHER</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, void 	MSG_META_LARGE_START_OTHER(
        MouseReturnParams 		*retVal,
        LargeMouseData 		*largeMouseDataStruct);</PRE>
<P>
See below for information about this and other large mouse messages.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_LARGE_END_OTHER">
 </A>
MSG_META_LARGE_END_OTHER</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, void 	MSG_META_LARGE_END_OTHER(
        MouseReturnParams 		*retVal,
        LargeMouseData 		*largeMouseDataStruct);</PRE>
<P>
See below for information about this and other large mouse messages.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_LARGE_DRAG_SELECT">
 </A>
MSG_META_LARGE_DRAG_SELECT</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, void 	MSG_META_LARGE_DRAG_SELECT(
        MouseReturnParams 		*retVal,
        LargeMouseData 		*largeMouseDataStruct);</PRE>
<P>
See below for information about this and other large mouse messages.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_LARGE_DRAG_MOVE_COPY">
 </A>
MSG_META_LARGE_DRAG_MOVE_COPY</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, void 	MSG_META_LARGE_DRAG_MOVE_COPY(
        MouseReturnParams 		*retVal,
        LargeMouseData 		*largeMouseDataStruct);</PRE>
<P>
See below for information about this and other large mouse messages.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_LARGE_DRAG_FEATURES">
 </A>
MSG_META_LARGE_DRAG_FEATURES</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, void 	MSG_META_LARGE_DRAG_FEATURES(
        MouseReturnParams 		*retVal,
        LargeMouseData 		*largeMouseDataStruct);</PRE>
<P>
See below for information about this and other large mouse messages.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_LARGE_DRAG_OTHER">
 </A>
MSG_META_LARGE_DRAG_OTHER</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, void 	MSG_META_LARGE_DRAG_OTHER(
        MouseReturnParams 		*retVal,
        LargeMouseData 		*largeMouseDataStruct);</PRE>
<P>
Objects which have been set up with 32-bit coordinate spaces must be prepared to handle large mouse events along with regular mouse events.</P>
<P>
These messages are available by request for use within 32-bit visible document models. Mouse position data is in full 32-bit integer, 16-bit fraction format, as generated by GenView.</P>
<P CLASS="refField">
Parameters:	<EM>retVal</EM>	Structure to hold return values.</P>
<DL>
<DT>
<EM>largeMouseDataStruct</DT><DD>
</EM>Structure to hold pass values.</DD>
</DL>
<P CLASS="refField">
Return:	Nothing returned explicitly.</P>
<DL>
<DT>
<EM>retVal</EM></DT><DD>Filled with return values.</DD>
</DL>
<P CLASS="refField">
Structures:	</P>
<PRE><A NAME="MetaClass_10.htm_IX_LMD_&ldots;"> </A><A NAME="IX_LargeMouseData"> </A>typedef struct {
	PointDWFixed 				LMD_location;
	byte 				LMD_buttonInfo;
	UIFunctionsActive 				LMD_uiFunctionsActive;
} LargeMouseData;</PRE>
<PRE>typedef struct {
	word 			unused;
	MouseReturnFlags 			flags;
	optr 			ptrImage;
	/* Pointer image to use, if MRF_SET_PTR_IMAGE
	 * returned */
} MouseReturnParams;</PRE>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_ENSURE_MOUSE_NOT_ACTIVELY_TRESPASSING">
 </A>
MSG_META_ENSURE_MOUSE_NOT_ACTIVELY_TRESPASSING</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, MouseReturnFlags 	MSG_META_ENSURE_MOUSE_NOT_ACTIVELY_TRESPASSING();</PRE>
<P>
Sent to the passive, active, or implied mouse grab chain whenever modality status changes within the system--any object receiving this message which has a window grabbed should make sure that it has a legitimate right to have the window grab active--if not, it should be released (along with the mouse). In particular, menus in stay-up mode should come down, any interaction between the mouse and primary, display, menu, or view windows should be terminated. <CODE>
MSG_GEN_APPLICATION_TEST_WIN_INTERACTABILITY</CODE>
 is useful; this message will test any passed OD against the list of window(s) which the mouse is allowed to interact with (Generally, top most system modal window, else top most application modal window, else all windows), and return a flag indicating the result.</P>
<P CLASS="refField">
Parameters:	None.</P>
<P CLASS="refField">
Return:	Flags field which system normally ignores.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_ENSURE_NO_MENUS_IN_STAY_UP_MODE">
 </A>
MSG_META_ENSURE_NO_MENUS_IN_STAY_UP_MODE</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, MouseReturnFlags 	MSG_META_ENSURE_NO_MENUS_IN_STAY_UP_MODE();</PRE>
<P>
Sent to the passive, active/implied mouse grab chain whenever we want to make sure all of an application's menus are closed. Sent directly to the Flow object from the global shortcut code. Any menus receiving this message which are in stay-up mode should dismiss themselves.</P>
<P CLASS="refField">
Parameters:	None.</P>
<P CLASS="refField">
Return:	Flags field, normally ignored by system.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_ENSURE_ACTIVE_FT">
 </A>
MSG_META_ENSURE_ACTIVE_FT</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, void 	MSG_META_ENSURE_ACTIVE_FT();</PRE>
<P>
Makes sure that some object with the Focus/Target node to which this message may be sent has the Focus and Target exclusives. Called from within the UI, usually when windowed objects below the node have closed, or moved to the back, to give the Focus and/or Target to the most suitable window.</P>
<P>
Behavior as implemented in <CODE>
GenApplicationClass</CODE>
:<BR>
Checks to make sure that something within the application has the Focus and Target exclusives. Called from within the UI, usually on the closure of a window, to give the Focus and/or Target to the next best location.</P>
<P>
Typical click-to-type model is implemented using the following rules:<BR>
For Target, the priority order is:</P>
<OL>
<LI>
Anything already having the exclusive.</LI>
<LI FIXME_NumListOther>
Top targetable PRIO_STD priority level window.</LI>
<LI FIXME_NumListOther>
Top targetable PRIO_COMMAND priority level window.</LI>
</OL>
<P>
For Focus, priority goes to:</P>
<OL>
<LI>
Anything already having the exclusive.</LI>
<LI FIXME_NumListOther>
Top system modal window.</LI>
<LI FIXME_NumListOther>
Top application modal window.</LI>
<LI FIXME_NumListOther>
Last non-modal window to have or request the exclusive.</LI>
<LI FIXME_NumListOther>
Window having Target exclusive.</LI>
<LI FIXME_NumListOther>
Top focusable PRIO_COMMAND priority level window.</LI>
</OL>
<P CLASS="refField">
Source:	Most always internally from the UI, though is unrestricted.</P>
<P CLASS="refField">
Destination:	Focus/Target node, specifically: GenSystem, GenField, or GenApplication object.</P>
<P CLASS="refField">
Interception:	No reason to intercept. Default behavior is provided by above objects. Could possibly be replaced, but as default behavior varies by specific UI, results could be unpredictable.</P>
<P CLASS="refField">
Parameters:	None.</P>
<P CLASS="refField">
Return:	Nothing.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_NOTIFY_NO_FOCUS_WITHIN_NODE">
 </A>
MSG_META_NOTIFY_NO_FOCUS_WITHIN_NODE</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, void 	MSG_META_NOTIFY_NO_FOCUS_WITHIN_NODE();</PRE>
<P>
Notification from Focus node <CODE>
MSG_META_ENSURE_ACTIVE_FT</CODE>
 handler that it was unable to keep/find an object below it suitable for being the focus. The most likely cause is that the last focusable geode/object running below this point has been shut down/closed.</P>
<P CLASS="refField">
Source:	Focus node, <CODE>
MSG_META_ENSURE_ACTIVE_FT</CODE>
 handler</P>
<P CLASS="refField">
Destination:	Self</P>
<P CLASS="refField">
Interception:	Intercepted to find something safe to do for the user, such as push this field/application to the back, or mark this object as no longer &quot;focusable&quot; and call <CODE>
MSG_META_ENSURE_ACTIVE_FT</CODE>
 on the node above this one, in an attempt to find something for the user to access. If there's nothing left at all in the system, the last focusable application has exited, so it's time to shut down.</P>
<P CLASS="refField">
Parameters:	None.</P>
<P CLASS="refField">
Return:	Nothing.</P>



<H4 CLASS="HeadingC">
Miscellaneous Meta Messages</H4>

<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_UI_FORCE_CONTROLLER_UPDATE">
 </A>
MSG_META_UI_FORCE_CONTROLLER_UPDATE</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, void MSG_META_UI_FORCE_CONTROLLER_UPDATE(
        ManufacturerID		manufID,
        word		changeID);</PRE>
<P>
This message forces an object to update one or all of the GCN notification lists that it communicates with.</P>
<P CLASS="refField">
Source:	Usually sent by a controller to its output.</P>
<P CLASS="refField">
Destination:	Any object.</P>
<P CLASS="refField">
Parameters:	<EM>
manufID</EM>
	<CODE>
ManufacturerID</CODE>
 of GCN lists.</P>
<DL>
<DT>
<EM>
changeID</EM>
	Notification list ID. </DT><DD>
This value may be 0xffffh if all notification lists should be updated or 0xfffeh to generate the standard notifications.</DD>
</DL>
<P CLASS="refField">
Interception:	Objects that send notification for controllers should respond to this message.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_GEN_PATH_RESTORE_DISK_PROMPT">
 </A>
MSG_META_GEN_PATH_RESTORE_DISK_PROMPT</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, Boolean MSG_META_GEN_PATH_RESTORE_DISK_PROMPT(
        DiskRestoreError				*error,
        GenPathDiskRestoreArgs				*args);</PRE>
<P>
This message prompts the user to insert a particular disk into a particular drive when restoring a disk handle for the object's path.</P>
<P CLASS="refField">
Source:	Sent by the callback passed to <CODE>
DiskRestore()</CODE>
 when a disk handle saved in an object's path is being restored after a shutdown.</P>
<P CLASS="refField">
Destination:	Any object possessing a path.</P>
<P CLASS="refField">
Parameters:	<EM>
error</EM>
	Pointer to store an error code. This error code will be returned to<CODE>
 DiskRestore()</CODE>
.</P>
<DL>
<DT>
<EM>
args</EM>
</DT><DD><CODE>
GenPathDiskRestoreArgs</CODE>
.</DD>
</DL>
<P CLASS="refField">
Structures:	</P>
<PRE>typedef struct {
	word			GPDRA_pathType;
	word			GPDRA_savedDiskType;
	char			*GPDRA_driveName;
	char			*GPDRA_diskName;
	DiskRestoreError			GPDRA_errorCode;
} GenPathDiskRestoreArgs;</PRE>
<P>
GPDRA_<CODE>
pathType</CODE>
 stores the vardata tag holding the path.</P>
<P>
GPDRA_<CODE>
savedDiskType</CODE>
 stores the vardata tag holding the saved disk handle.</P>
<P>
GPDRA_<CODE>
driveName</CODE>
 and GPDRA_<CODE>
diskName</CODE>
 store pointers to the null-terminated drive and disk names.</P>
<P>
GPDRA_<CODE>
errorCode</CODE>
 stores the error code that is returned to<CODE>
 DiskRestore()</CODE>
.</P>
<P CLASS="refField">
Interception:	May be intercepted if the object has more information to provide to the user, or if the object doesn't wish to prompt the user. If this message is intercepted, it should not call its superclass.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_PAGED_OBJECT_GOTO_PAGE">
 </A>
MSG_META_PAGED_OBJECT_GOTO_PAGE</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, void MSG_META_PAGED_OBJECT_GOTO_PAGE(
        word	page);</PRE>
<P>
This message instructs a GenDocument to go to the passed page.</P>
<P>
This message is sent out by the GenPageControl object and is handled by a GenApplication's subclassed GenDocument object.</P>
<P CLASS="refField">
Source:	GenPageControl object.</P>
<P CLASS="refField">
Destination:	GenDocument object.</P>
<P CLASS="refField">
Parameters:	<EM>
page</EM>
	Page to set the GenDocument to display.</P>
<P CLASS="refField">
Interception:	You may intercept to provide custom paging behavior.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_PAGED_OBJECT_NEXT_PAGE">
 </A>
MSG_META_PAGED_OBJECT_NEXT_PAGE</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, void MSG_META_PAGED_OBJECT_NEXT_PAGE();</PRE>
<P>
This message instructs a GenDocument to go to the next page.</P>
<P>
This message is sent out by the GenPageControl object and is handled by a GenApplication's subclassed GenDocument object.</P>
<P CLASS="refField">
Source:	GenPageControl object.</P>
<P CLASS="refField">
Destination:	GenDocument object.</P>
<P CLASS="refField">
Interception:	You may intercept to provide custom paging behavior.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_PAGED_OBJECT_PREVIOUS_PAGE">
 </A>
MSG_META_PAGED_OBJECT_PREVIOUS_PAGE</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, void MSG_META_PAGED_OBJECT_PREVIOUS_PAGE();</PRE>
<P>
This message instructs a GenDocument to go to the previous page.</P>
<P>
This message is sent out by the GenPageControl object and is handled by a GenApplication's subclassed GenDocument object.</P>
<P CLASS="refField">
Source:	GenPageControl object.</P>
<P CLASS="refField">
Destination:	GenDocument object.</P>
<P CLASS="refField">
Interception:	You may intercept to provide custom paging behavior.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_DELETE_RANGE_OF_CHARS">
 </A>
MSG_META_DELETE_RANGE_OF_CHARS</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, void MSG_META_DELETE_RANGE_OF_CHARS(@stack
        VisTextRange		rangeToDelete);</PRE>
<P>
This message instructs an object to delete a range of characters passed in a <CODE>
VisTextRange</CODE>
. Generally, this message is sent out when the user crosses out characters within a HWR grid.</P>
<P CLASS="refField">
Source:	GenPenInputControl.</P>
<P CLASS="refField">
Destination:	Any focused object.</P>
<P CLASS="refField">
Parameters:	<EM>
rangeToDelete</EM>
	<CODE>
VisTextRange</CODE>
 of characters to delete. Objects that are not text objects will need to know how to interpret this value.</P>
<P CLASS="refField">
Interception:	May intercept to provide custom deletion behavior.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_NOTIFY_TASK_SELECTED">
 </A>
MSG_META_NOTIFY_TASK_SELECTED</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, void MSG_META_NOTIFY_TASK_SELECTED();</PRE>
<P>
This message is sent when a task list item of an application in the Express Menu is selected. The default behavior brings the application to the front and gives it the focus.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_FIELD_NOTIFY_DETACH">
 </A>
MSG_META_FIELD_NOTIFY_DETACH</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, void MSG_META_FIELD_NOTIFY_DETACH(
        optr		field,
        word		shutdownFlag);</PRE>
<P>
This message is sent by the GenField object when it is detaching.</P>
<P CLASS="refField">
Source:	GenField.</P>
<P CLASS="refField">
Destination:	The notification destination of the GenField object.</P>
<P CLASS="refField">
Parameters:	<EM>
field</EM>
	Optr of the GenField sending notification.</P>
<DL>
<DT>
<EM>
shutdownFlag</EM>
</DT><DD><EM>
true</EM>
 if the GenField is detaching because of a shutdown.</DD>
</DL>
<P CLASS="refField">
Interception:	The object receiving notification may handle as desired. As this is a notification only, you should not call the superclass.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_FIELD_NOTIFY_NO_FOCUS">
 </A>
MSG_META_FIELD_NOTIFY_NO_FOCUS</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, void MSG_META_FIELD_NOTIFY_NO_FOCUS(
        optr		field,
        word		shutdownFlag);</PRE>
<P>
This message is sent by the GenField when it no longer has any applications in the focus hierarchy.</P>
<P CLASS="refField">
Source:	GenField.</P>
<P CLASS="refField">
Destination:	The notification destination of the GenField object.</P>
<P CLASS="refField">
Parameters:	<EM>
field</EM>
	Optr of the GenField sending notification.</P>
<DL>
<DT>
<EM>
shutdownFlag</EM>
</DT><DD><EM>
true</EM>
 if the GenField lost its focus applications because of a shutdown.</DD>
</DL>
<P CLASS="refField">
Interception:	The object receiving notification may handle as desired. As this is a notification only, you should not call the superclass.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_FIELD_NOTIFY_START_LAUNCHER_ERROR">
 </A>
MSG_META_FIELD_NOTIFY_START_LAUNCHER_ERROR</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, void MSG_META_FIELD_NOTIFY_START_LAUNCHER_ERROR(
        optr		field);</PRE>
<P>
This message is sent by the GenField when an error occurs while attempting to run the launcher for the field object.</P>
<P CLASS="refField">
Source:	GenField.</P>
<P CLASS="refField">
Destination:	The notification destination of the GenField object.</P>
<P CLASS="refField">
Parameters:	<EM>
field</EM>
	Optr of the GenField sending notification.</P>
<P CLASS="refField">
Interception:	The object receiving notification may handle as desired. As this is a notification only, you should not call the superclass.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_TEST_WIN_INTERACTIBILITY">
 </A>
MSG_META_TEST_WIN_INTERACTIBILITY</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, Boolean MSG_META_TEST_WIN_INTERACTIBILITY(
        optr		inputOD,
        WindowHandle		window);</PRE>
<P>
This message checks whether a pointing device (usually a mouse) can interact with the passed window.</P>
<P CLASS="refField">
Source:	</P>
<P CLASS="refField">
Destination:	A windowed object.</P>
<P CLASS="refField">
Parameters:	<EM>
inputOD</EM>
	Input optr of the windowed object to check.</P>
<DL>
<DT>
<EM>
window</EM>
</DT><DD>Window to check.</DD>
</DL>
<P CLASS="refField">
Return:	<EM>
true</EM>
 if window is interactable.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_10.htm_IX_MSG_META_CHECK_IF_INTERACTIBLE_OBJECT">
 </A>
MSG_META_CHECK_IF_INTERACTIBLE_OBJECT</H6>
<PRE CLASS="syntax">@importMessage MetaUIMessages, Boolean MSG_META_CHECK_IF_INTERACTIBLE_OBJECT(
        optr	obj);</PRE>
<P>
This message is sent o objects on the GAGCNLT_ALWAYS_INTERACTABLE_WINDOWS GCN list. </P>
<P CLASS="refField">
Source:	GenApplication object.</P>
<P CLASS="refField">
Destination:	Objects on the GAGCNLT_ALWAYS_INTERACTABLE_WINDOWS GCN list.</P>
<P CLASS="refField">
Parameters:	<EM>
obj</EM>
	Object whose interactable state is being checked.</P>
<P CLASS="refField">
Return:	<EM>
true</EM>
 if object is interactable.</P>
<P CLASS="refField">
Interception:	May intercept.</P>


<HR>
<A NAME="MetaClass_11.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">MetaClass</A>: 3.4 <A HREF="#MetaClass_d.htm">Exported Message Ranges</A>: 
Standard GCN Messages</H3>
<P>
<A NAME="MetaClass_11.htm_IX_General change notification:standard messages">
 </A>
There are several standard messages which objects adding themselves to the appropriate GCN lists may receive and handle.</P>

<H6 CLASS="RefETitle">
<A NAME="MetaClass_11.htm_IX_MSG_NOTIFY_FILE_CHANGE">
 </A>
MSG_NOTIFY_FILE_CHANGE</H6>
<PRE CLASS="syntax">@importMessage MetaGCNMessages, void 	MSG_NOTIFY_FILE_CHANGE(
        MemHandle 		data);</PRE>
<P>
This notification is sent out whenever the file system changes in any way.</P>
<P CLASS="refField">
Source:	GCN mechanism.</P>
<P CLASS="refField">
Destination:	Object on the GCNSLT_FILE_SYSTEM GCN list.</P>
<P CLASS="refField">
Parameters:	<EM>data</EM> 	Handle of a <CODE>
FileChangeNotificationData</CODE>
 block.</P>
<P CLASS="refField">
Return:	Nothing.</P>
<P CLASS="refField">
Structures:	</P>
<PRE><A NAME="MetaClass_11.htm_IX_FCND_&ldots;"> </A><A NAME="IX_FileChangeNotificationData"> </A>typedef struct {
	PathName			FCND_pathname;
	DiskHandle			FCND_diskHandle;
	FileChangeType			FCND_changeType;
} FileChangeNotificationData;</PRE>
<PRE><A NAME="MetaClass_11.htm_IX_FCT_&ldots;"> </A><A NAME="IX_FileChangeType"> </A>typedef ByteEnum FileChangeType;
/* These flags may be combined using | and &amp;:
	FCT_CREATE
	FCT_DELETE
	FCT_RENAME
	FCT_CONTENTS
	FCT_DISK_FORMAT */</PRE>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_11.htm_IX_MSG_NOTIFY_DRIVE_CHANGE">
 </A>
MSG_NOTIFY_DRIVE_CHANGE</H6>
<PRE CLASS="syntax">@importMessage MetaGCNMessages, void 	MSG_NOTIFY_DRIVE_CHANGE(
        GCNDriveChangeNotificationType 						type,
        word 						driveNum);</PRE>
<P>
This is sent to notify various system utilities that a drive has been created or destroyed or has changed ownership from one installable file system driver to another.</P>
<P>
Note that during system initialization, the ownership of a drive may change several times as more-specialized drivers are loaded. This means the recipient should not be surprised if it's told a drive has been created that it thought already existed.</P>
<P CLASS="refField">
Source:	The kernel issues this notification whenever a filesystem driver creates or destroys a drive it manages. This includes when a specialized filesystem driver takes control of an existing drive.</P>
<P CLASS="refField">
Destination:	Any object that has added itself to the GCNSLT_FILE_SYSTEM GCN list. It is intended for system objects, such as the GenFileSelector.</P>
<P CLASS="refField">
Parameters:	<EM>type</EM> 	<CODE>
GCNDriveChangeNotificationType</CODE>
.</P>
<DL>
<DT>
<EM>driveNum</EM></DT><DD>Number of the affected drive.</DD>
</DL>
<P CLASS="refField">
Return:	Nothing.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_11.htm_IX_MSG_NOTIFY_APP_STARTED">
 </A>
MSG_NOTIFY_APP_STARTED</H6>
<PRE CLASS="syntax">@importMessage MetaGCNMessages, void 	MSG_NOTIFY_APP_STARTED();</PRE>
<P>
This message is sent out when an application attaches to the UI.</P>
<P CLASS="refField">
Source:	GCN Mechanism.</P>
<P CLASS="refField">
Destination:	Any object on the GCNSLT_APPLICATION system GCN list.</P>
<P CLASS="refField">
Parameters:	None.</P>
<P CLASS="refField">
Return:	Nothing.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_11.htm_IX_MSG_NOTIFY_APP_EXITED">
 </A>
MSG_NOTIFY_APP_EXITED</H6>
<PRE CLASS="syntax">@importMessage MetaGCNMessages, void 	MSG_NOTIFY_APP_EXITED();</PRE>
<P>
This message is sent out when an application thread exits.</P>
<P CLASS="refField">
Source:	GCN Mechanism.</P>
<P CLASS="refField">
Destination:	Any object on the GCNSLT_APPLICATION system GCN list.</P>
<P CLASS="refField">
Parameters:	None.</P>
<P CLASS="refField">
Return:	Nothing.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_11.htm_IX_MSG_NOTIFY_DATE_TIME_CHANGE">
 </A>
MSG_NOTIFY_DATE_TIME_CHANGE</H6>
<PRE CLASS="syntax">@importMessage MetaGCNMessages, void 	MSG_NOTIFY_DATE_TIME_CHANGE();</PRE>
<P>
This message is sent out when the date or time changes--whenever the system comes back or the system time is altered (e.g. by the User in Preferences). </P>
<P CLASS="refField">
Source:	GCN Mechanism.</P>
<P CLASS="refField">
Destination:	Any object on the GCNSLT_DATE_TIME system GCN list.</P>
<P CLASS="refField">
Parameters:	None.</P>
<P CLASS="refField">
Return:	Nothing.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_11.htm_IX_MSG_NOTIFY_USER_DICT_CHANGE">
 </A>
MSG_NOTIFY_USER_DICT_CHANGE</H6>
<PRE CLASS="syntax">@importMessage MetaGCNMessages, void 	MSG_NOTIFY_USER_DICT_CHANGE(
        MemHandle 		sendingSpellBox,
        MemHandle 		userDictChanged);</PRE>
<P>
This message is sent out when an application attaches to the UI.</P>
<P CLASS="refField">
Source:	GCN Mechanism.</P>
<P CLASS="refField">
Destination:	Any object on the GCNSLT_DICTIONARY system GCN list.</P>
<P CLASS="refField">
Parameters:	<EM>sendingSpellBox</EM> 	Handle of SpellBox that sent out the notification.</P>
<DL>
<DT>
<EM>userDictChanged</EM> </DT><DD>Handle of user dictionary that changed.</DD>
</DL>
<P CLASS="refField">
Return:	Nothing.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_11.htm_IX_MSG_NOTIFY_KEYBOARD_LAYOUT_CHANGE">
 </A>
MSG_NOTIFY_KEYBOARD_LAYOUT_CHANGE</H6>
<PRE CLASS="syntax">@importMessage MetaGCNMessages, void 	MSG_NOTIFY_KEYBOARD_LAYOUT_CHANGE();</PRE>
<P>
This message is sent out when the keyboard layout is changing. Usually this involves a change in status of the floating keyboard. When passing this event to <CODE>
GCNListSend()</CODE>
, you must be sure to pass the GCNLSF_FORCE_QUEUE flag. (Otherwise, if you have a <CODE>
GenPenInputControl</CODE>
 running on the same thread, it may try to remove itself from the list while you are sending this message.)</P>
<P CLASS="refField">
Source:	GCN Mechanism.</P>
<P CLASS="refField">
Destination:	Any object on the GCNSLT_KEYBOARD_OBJECT system GCN list.</P>
<P CLASS="refField">
Parameters:	None.</P>
<P CLASS="refField">
Return:	Nothing.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_11.htm_IX_MSG_NOTIFY_EXPRESS_MENU_CHANGE">
 </A>
MSG_NOTIFY_EXPRESS_MENU_CHANGE</H6>
<PRE CLASS="syntax">@importMessage MetaGCNMessages, void 	MSG_NOTIFY_EXPRESS_MENU_CHANGE(
        GCNExpressMenuNotificationTypes 	type,
        optr 		affectedField);</PRE>
<P>
This message is sent to notify various system utilities that an express menu has been created or destroyed. The recipient receives the optr of the field to which the affected express menu belongs, as all access to the express menu is via messages sent to the field.</P>
<P CLASS="refField">
Source:	The UI issues this notification whenever a GenField object creates or destroys its express menu.</P>
<P CLASS="refField">
Destination:	Any object that has added itself to the GCNSLT_EXPRESS_MENU. GCN list. It is intended for system utilities, such as the print spooler or a task-switching driver, that need to add objects to each express menu in the system.</P>
<P CLASS="refField">
Parameters:	<EM>type</EM>	What happened to the field.</P>
<DL>
<DT><EM>affectedField</EM></DT>
<DD>Which field of the menu was affected. (This will not be the optr of the
express menu itself.)</DD>
</DL>
<P CLASS="refField">
Return:	Nothing.</P>
<P CLASS="refField">
Structures:	</P>
<PRE><A NAME="MetaClass_11.htm_IX_GCNEMNT_&ldots;"> </A><A NAME="IX_GCNExpressMenuNotificationTypes"> </A>typedef enum {
	GCNEMNT_CREATED,
	GCNEMNT_DESTROYED
} GCNExpressMenuNotificationTypes;</PRE>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_11.htm_IX_MSG_PRINTER_INSTALLED_REMOVED">
 </A>
MSG_PRINTER_INSTALLED_REMOVED</H6>
<PRE CLASS="syntax">@importMessage MetaGCNMessages, void 	MSG_PRINTER_INSTALLED_REMOVED();</PRE>
<P>
This message is sent whenever a printer is installed or removed. The recipient of this message might call <CODE>
SpoolGetNumPrinters()</CODE>
 to determine if any printers or fax machines are currently installed.</P>
<P CLASS="refField">
Source:	GCN Mechanism.</P>
<P CLASS="refField">
Destination:	Any object on the GCNSLT_INSTALLED_PRINTERS system GCN list.</P>
<P CLASS="refField">
Parameters:	None.</P>
<P CLASS="refField">
Return:	Nothing.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_11.htm_IX_MSG_META_CONFIRM_SHUTDOWN">
 </A>
MSG_META_CONFIRM_SHUTDOWN</H6>
<PRE CLASS="syntax">@importMessage MetaGCNMessages, void 	MSG_META_CONFIRM_SHUTDOWN(
        GCNShutdownControlType 	type);</PRE>
<P>
This message is sent out when the system is about to shut down.</P>
<P>
All applications which need to keep the system from shutting down must add themselves to GCNSLT_SHUTDOWN_CONTROL and handle this message.</P>
<P CLASS="refField">
Source:	The task switch mechanism, through GCN.</P>
<P CLASS="refField">
Destination:	Any object on the GCNSLT_SHUTDOWN_CONTROL system GCN list.</P>
<P CLASS="refField">
Parameters:	<EM>type</EM>	The type of shutdown occurring. See
description under Interception for more information.
</P>
<P CLASS="refField">
Return:	Nothing.</P>
<P CLASS="refField">
Interception:   If the system is about to be suspended or shut down (if
the passed <CODE>GCNShutDownControlType</CODE> is GCNSCT_SUSPEND or
GCNSCT_SHUTDOWN), then any object receiving this message <EM>must</EM>
call <CODE>SysShutdown()</CODE>, passing SST_CONFIRM_START before it puts
up any dialog box it uses to ensure the user isn't doing something foolish.
If <CODE>SysShutdown()</CODE> returns <EM>true</EM> (indicating something
has already denied the shutdown request), the caller should <EM>not</EM>
put up its confirmation box, nor need it call <CODE>SysShutdown()</CODE>
again.<BR>
Once the object has received a response from the user, either affirmative
or negative, it must call <CODE>SysShutdown()</CODE>, passing SST_CONFIRM_END
with either TRUE or FALSE as appropriate. This will allow any other
confirmations to happen, as well as sending the final result to the original
caller of <CODE>SysShutdown()</CODE>.<BR>
If the passed control type is GCNSCT_UNSUSPEND, no response is required.
</P>
<P CLASS="refField">
See Also: <A HREF="#/CRef/Routines/R_94.htm_IX_SysShutdown()">SysShutdown()</A>
</P>

<HR>
<A NAME="MetaClass_12.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">MetaClass</A>: 3.5 <A HREF="#MetaClass_d.htm">Exported Message Ranges</A>: 
IACP Meta Messages</H3>
<P>
IACP is fully discussed in <A HREF="../../Kernel/Geodes/combo.htm">the Applications and Geodes chapter</A>.</P>
<H6 CLASS="RefETitle">
<A NAME="MetaClass_12.htm_IX_MSG_META_IACP_PROCESS_MESSAGE">
 </A>
MSG_META_IACP_PROCESS_MESSAGE</H6>
<PRE CLASS="syntax">@importMessage MetaIACPMessages, void MSG_META_IACP_PROCESS_MESSAGE(
        EventHandle		msgToSend,
        TravelOption		topt,
        EventHandle		completionMsg);</PRE>
<P>
This message dispatches an IACP message to its proper destination, sending a completion message back when that has finished.</P>
<P CLASS="refField">
Source:	<CODE>
IACPSendMessage()</CODE>
.</P>
<P CLASS="refField">
Destination:	Any object registered as an IACP server, or the GenApplication object of a geode that is a client of such a server.</P>
<P CLASS="refField">
Parameters:	<EM>
msgToSend</EM>
	EventHandle of recorded message that the other side of the connection is actually sending.</P>
<DL>
<DT>
<EM>
topt</EM>
</DT><DD><CODE>
TravelOption</CODE>
 (or -1 if <EM>
msgToSend</EM>
 should be dispatched via <CODE>
MessageDispatch() o</CODE>
r delivered via MSG_META_SEND_TO_CLASSED_EVENT.</DD>
<DT>
<EM>
completionMsg</EM>
</DT><DD><CODE>
EventHandle</CODE>
 of recorded message to send when the message in <EM>
msgToSend</EM>
 has been handled. If null, then no completion message will be sent.</DD>
</DL>
<P CLASS="refField">
Interception:	if you have an object other than the GenApplication object that is an IACP server, you will need to intercept this message. You do not want to pass it on to the superclass in this case; usually, you will just want to call<CODE>
 IACPProcessMessage()</CODE>
.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_12.htm_IX_MSG_META_IACP_NEW_CONNECTION">
 </A>
MSG_META_IACP_NEW_CONNECTION</H6>
<PRE CLASS="syntax">@importMessage MetaIACPMessages, void MSG_META_IACP_NEW_CONNECTION(
        MemHandle		appLaunchBlock,
        Boolean		justLaunched,
        IACPConnection		connection);</PRE>
<P>
This message informs servers that a new client has connected to the server.</P>
<P CLASS="refField">
Source:	<CODE>
IACPConnect()</CODE>
.</P>
<P CLASS="refField">
Destination:	Any object registered as an IACP server.</P>
<P CLASS="refField">
Parameters:	<EM>
appLaunchBlock</EM>
	Handle of <CODE>
AppLaunchBlock</CODE>
 passed to <CODE>
IACPConnect()</CODE>
. Do not free this block.</P>
<DL>
<DT>
<EM>
justLaunched</EM>
</DT><DD><EM>
true</EM>
 if the recipient was just launched (i.e. it received the <CODE>
AppLaunchBlock</CODE>
 in its MSG_META_ATTACH call).</DD>
<DT>
<EM>
connection</EM>
</DT><DD><CODE>
IACPConnection</CODE>
 that is now open.</DD>
</DL>
<P CLASS="refField">
Interception:	Must intercept if you want to do anything about receiving the new client; there is not default handler for this message. If you do not intercept this message, no harm is done.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_12.htm_IX_MSG_META_IACP_LOST_CONNECTION">
 </A>
MSG_META_IACP_LOST_CONNECTION</H6>
<PRE CLASS="syntax">@importMessage MetaIACPMessages, void MSG_META_IACP_LOST_CONNECTION(
        IACPConnection		connection,
        word		serverNum);</PRE>
<P>
This message informs a server (or client) that one of its clients (or servers) has shut down.</P>
<P CLASS="refField">
Source:	<CODE>
IACPShutdown()</CODE>
.</P>
<P CLASS="refField">
Destination:	Any object registered as an IACP server, or the GenApplication object of a geode who is a client of such.</P>
<P CLASS="refField">
Parameters:	<EM>
connection</EM>
	<CODE>
IACPConnection</CODE>
 being closed.</P>
<DL>
<DT>
<EM>
serverNum</EM>
</DT><DD>Server number that shut down, or 0 if this was a client that shut down (and thus it is a server being notified through this message).</DD>
</DL>
<P CLASS="refField">
Interception:	Must be intercepted to provide custom behavior upon losing a connection, as there is no default handler for this message. <CODE>
IACPLostConnection()</CODE>
 is a good routine for servers to call to ensure that connections don't linger after a client has shut down its end.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_12.htm_IX_MSG_META_IACP_SHUTDOWN_CONNECTION">
 </A>
MSG_META_IACP_SHUTDOWN_CONNECTION</H6>
<PRE CLASS="syntax">@importMessage MetaIACPMessages, void MSG_META_IACP_SHUTDOWN_CONNECTION(
        IACPConnection		connection);</PRE>
<P>
This message shuts down the appropriate side of the indicated connection.</P>
<P CLASS="refField">
Source:	<CODE>
IACPLostConnection()</CODE>
, though after a delay.</P>
<P CLASS="refField">
Destination:	Any IACP server object.</P>
<P CLASS="refField">
Parameters:	<EM>
connection</EM>
	<CODE>
IACPConnection</CODE>
 to shutdown.</P>
<P CLASS="refField">
Interception:	Must be intercepted to finish the work of a call to <CODE>
IACPLostConnection()</CODE>
. Call<CODE>
 IACPShutdownConnection()</CODE>
 to get default handling of this message.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_12.htm_IX_MSG_META_IACP_DOC_OPEN_ACK">
 </A>
MSG_META_IACP_DOC_OPEN_ACK</H6>
<PRE CLASS="syntax"><CODE>@importMessage MetaIACPMessages, void</CODE> MSG_META_IACP_DOC_OPEN_ACK(
        IACPDocOpenAckParams			*params);</PRE>
<P>
This message is sent when a document has been opened; the document must have previously been passed in the <CODE>
AppLaunchBlock</CODE>
 when the IACP connection was made. The optr of the GenDocument object managing the document is passed so that messages can be sent to it explicitly, though these messages must always be sent via IACP (with a <CODE>
TravelOption</CODE>
 of -1) to allow the application to exit at any time.</P>
<P CLASS="refField">
Source:	GenDocumentGroup.</P>
<P CLASS="refField">
Destination:	IACP client (usually the GenApplication object of the client application).</P>
<P CLASS="refField">
Parameters:	<EM>
params</EM>
	Pointer to an <CODE>
IACPDocOpenAckParams</CODE>
 structure.</P>
<P CLASS="refField">
Structures:	</P>
<PRE>typedef struct {
	optr			IDOAP_docObj;
	IACPConnection			IDOAP_connection;
	word			IDOAP_serverNum;
} IACPDocOpenAckParams;</PRE>
<P>
IDOAP_<CODE>
docObj</CODE>
 stores the optr of the document object managing the document.</P>
<P>
IDOAP_<CODE>
connection</CODE>
 stores the <CODE>
IACPConnection</CODE>
 over which the open request was received.</P>
<P>
IDOAP_<CODE>
serverNum</CODE>
 stores the server number of the GenApplication object acting as the document object's server, or zero if the connection is through some other object.</P>
<P CLASS="refField">
Interception:	No default handler is defined. You must intercept this message to provide custom behavior.</P>


<H6 CLASS="RefETitle">
<A NAME="MetaClass_12.htm_IX_MSG_META_IACP_DOC_CLOSE_ACK">
 </A>
MSG_META_IACP_DOC_CLOSE_ACK</H6>
<PRE CLASS="syntax">@importMessage MetaIACPMessages, void MSG_META_IACP_DOC_CLOSE_ACK(
        IACPDocCloseAckParams				*params);</PRE>
<P>
This message acts as the acknowledgment sent by a GenDocument object after it successfully processes MSG_GEN_DOCUMENT_CLOSE. Documents opened via IACP always operate in transparent mode; i.e. if you close a dirty file, it will be saved. If you don't want this behavior, you will have to send a message to revert the document.</P>
<P CLASS="refField">
Source:	GenDocument object.</P>
<P CLASS="refField">
Destination:	IACP client.</P>
<P CLASS="refField">
Parameters:	<EM>
params</EM>
	Pointer to a <CODE>
IACPDocCloseAckParams</CODE>
 structure.</P>
<P CLASS="refField">
Structures:	</P>
<PRE>typedef struct {
	optr			IDCAP_docObj;
	IACPConnection			IDCAP_connection;
	word			IDCAP_serverNum;
	word			IDCAP_status;
} IACPDocCloseAckParams;</PRE>
<P>
IDCAP_<CODE>
docObj</CODE>
 stores the optr of the document object that was managing the document.</P>
<P>
IDCAP_<CODE>
connection</CODE>
 stores the <CODE>
IACPConnection</CODE>
 over which the close request was received.</P>
<P>
IDCAP_<CODE>
serverNum</CODE>
 stores the server number of the GenApplication object acting as the document object's server, or zero if the connection is through some other object.</P>
<P>
IDCAP_<CODE>
status</CODE>
 stores the <CODE>
DocQuitStatus</CODE>
 of the close operation.</P>
<P CLASS="refField">
Interception:	No default handler is defined. You must intercept this message to provide custom behavior.</P>

<HR>
This document is a single-page version of a <A HREF="index.htm">a multi-page document</A>, suitable for easy printing.
</BODY>
</HTML>
