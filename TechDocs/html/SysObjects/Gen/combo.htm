<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD>
<!-- This page was automatically generated from a bunch of smaller pages. -->
<META NAME="copyright" CONTENT="Copyright GEOWORKS">
<LINK REL="STYLESHEET" HREF="../../docHelpers/style.css">
<LINK REV="MADE" HREF="mailto:doc-feedback@geoworks.com">
<TITLE>GenClass</TITLE>
</HEAD>
<BODY BGCOLOR="#ffffdf">
This document is a single-page version of a <A HREF="index.htm">a multi-page document</A>, suitable for easy printing.
<A NAME="index.htm"></A>



<H1 CLASS="chapterTitle">

<A NAME="index.htm_97933">
 </A>
GenClass

</H1>
<P>
<CODE>
GenClass </CODE>
<A NAME="index.htm_IX_GenClass">
 </A>
provides the basic functionality, via message handlers and instance data, for all objects in the generic object library. <EM>
All</EM>
 generic objects are subclassed off this master class. Therefore, all generic objects will contain common behavior in the instance fields and message handlers of <CODE>
GenClass</CODE>
. <CODE>
GenClass</CODE>
 allows you to create generic trees, manage state data, and attach data such as visual monikers, keyboard accelerators, and even variable-length data to a specific object.</P>
<P>
The Gen world, along with the Vis<CODE>
 </CODE>
world, contains a large variety of pre-defined objects ready to install into your applications. <CODE>
GenClass</CODE>
 itself is not a normally usable object, however. It should not be directly subclassed and used by your application. The functionality within this chapter will normally be accessed within one of <CODE>
GenClass</CODE>
' subclasses.</P>
<P>
All of these pre-defined objects will contain behavior explained in this chapter. The instance data and message handlers described in this chapter may be implemented differently under different specific UIs, but the basic functionality will remain the same. Therefore, it is important to fully understand the concepts explained in this chapter before using any generic object.</P>
<P>
<P CLASS="sectionlinks">
<STRONG>
&nbsp;&nbsp;<A HREF="#GenClass_1.htm">1 GenClass Features</A><BR>
&nbsp;&nbsp;<A HREF="#GenClass_2.htm">2 GenClass Instance Data</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#GenClass_3.htm">2.1 Instance Fields</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#GenClass_4.htm">2.2 Vardata</A><BR>
&nbsp;&nbsp;<A HREF="#GenClass_5.htm">3 GenClass Basics</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#GenClass_6.htm">3.1 Visual Monikers</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#GenClass_7.htm">3.2 Composite Links</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#GenClass_8.htm">3.3 Keyboard Accelerators</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#GenClass_9.htm">3.4 Attributes</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#GenClass_a.htm">3.5 States</A><BR>
&nbsp;&nbsp;<A HREF="#GenClass_b.htm">4 Modifying GenClass Instance Data</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#GenClass_c.htm">4.1 Visual Monikers</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#GenClass_d.htm">4.2 Managing Visual Monikers</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#GenClass_e.htm">4.3 Managing Keyboard Accelerators</A><BR>
&nbsp;&nbsp;<A HREF="#GenClass_f.htm">5 Generic Trees</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#GenClass_10.htm">5.1 Child/Parent Searches</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#GenClass_11.htm">5.2 Manipulating Children Directly</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#GenClass_12.htm">5.3 Branch Construction/Destruction</A><BR>
&nbsp;&nbsp;<A HREF="#GenClass_13.htm">6 Vardata</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#GenClass_14.htm">6.1 Optional Attributes (ATTRs)</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#GenClass_15.htm">6.2 Hints to the Specific UI</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#GenClass_16.htm">6.3 Dynamically Managing VarData</A><BR>
&nbsp;&nbsp;<A HREF="#GenClass_17.htm">7 Special Message Passing</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#GenClass_18.htm">7.1 Parent and Child Message Passing</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#GenClass_19.htm">7.2 Generic Upward Queries</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#GenClass_1a.htm">7.3 Object-Specific Queries</A><BR>
&nbsp;&nbsp;<A HREF="#GenClass_1b.htm">8 Visual Refreshing</A><BR>
&nbsp;&nbsp;<A HREF="#GenClass_1c.htm">9 Setting Sizes</A><BR>
&nbsp;&nbsp;<A HREF="#GenClass_1d.htm">10 Activation Messages</A><BR>
&nbsp;&nbsp;<A HREF="#GenClass_1e.htm">11 Focus Modifications</A><BR>
&nbsp;&nbsp;<A HREF="#GenClass_1f.htm">12 Navigation Methods</A><BR>
&nbsp;&nbsp;<A HREF="#GenClass_20.htm">13 Window Positions and Sizes</A><BR>
</STRONG>
</P> <!-- end of sectionlinks blob -->

<HR>
<A NAME="GenClass_1.htm"></A>


<H2 CLASS="sectionTitle">
<A HREF="#index.htm">GenClass</A>: 1 
GenClass Features</H2>
<P>
<CODE>
GenClass</CODE>
 provides the instance fields and message handlers common to all generic objects. You will need to understand and manipulate <CODE>
GenClass</CODE>
 operations in almost every generic object you create. <CODE>
GenClass</CODE>
 is very powerful and diverse, providing a number of wide-ranging functions within your user interface.<CODE>
 GenClass</CODE>
 in specific provides the following:</P>
<UL>
<LI>
an abstract UI providing code common within any specific user interface. </LI>
<LI>
an object-oriented generic tree structure, including dynamic creation and destruction of generic UI objects &quot;on the fly.&quot;</LI>
<LI>
an object-oriented messaging system, including generic upward queries, allowing the UI objects to pass messages without defining a specific destination.</LI>
<LI>
pre-instantiation and persistence (state-saving) across sessions.</LI>
<LI>
window sizing and positioning with an abstract geometry manager without involved coordinate space computations.</LI>
<LI>
a generic visual update mechanism for your application, allowing you to ensure an accurate and visually up-to-date UI.</LI>
<LI>
the ability to create custom UI gadgets of your own.</LI>
</UL>
<P>
Most importantly, <CODE>
GenClass</CODE>
 provides the common functionality that will be accessed by all generic objects from the simplest GenTrigger to the most complex GenView.</P>
<HR>
<A NAME="GenClass_2.htm"></A>


<H2 CLASS="sectionTitle">
<A HREF="#index.htm">GenClass</A>: 2 
<A NAME="GenClass_2.htm_14327">
 </A>
GenClass Instance Data</H2>
<P>
Generic objects, along with visual objects, are the main means through which a user can communicate with an application. All generic objects follow an object-oriented class hierarchy with <CODE>
GenClass</CODE>
 acting as their superclass. Therefore, all<CODE>
 </CODE>
generic objects will share the attributes and behavior of<CODE>
 GenClass</CODE>
, although many may not make use of the entire utility provided.</P>
<P CLASS="subsectionLink">
<A HREF="#GenClass_3.htm">Instance Fields</A></P>
<P CLASS="subsectionLink">
<A HREF="#GenClass_4.htm">Vardata</A></P>
<HR>
<A NAME="GenClass_3.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">GenClass</A>: 2.1 <A HREF="#GenClass_2.htm">GenClass Instance Data</A>: 
<A NAME="GenClass_3.htm_40387">
 </A>
Instance Fields</H3>
<P>
<CODE>
GenClass</CODE>
 provides a set of instance fields common to all subclasses. These instance fields are listed in <A HREF="#GenClass_3.htm_32234"> GenClass Instance Data Fields</A>
.</P>
<P CLASS="figTitle">
Code Display 2-1 <A NAME="GenClass_3.htm_IX_GI_&ldots;">
 </A>
<A NAME="GenClass_3.htm_32234">
 </A>
GenClass Instance Data Fields</P>
<PRE>    @instance @link				GI_link;
    @instance @visMoniker				GI_visMoniker;
    @instance @composite				GI_comp;
    @instance @kbdAccelerator				GI_kbdAccelerator;
    @instance GenAttrs				GI_attrs = 0;
    @instance GenStates GI_states = GS_USABLE | GS_ENABLED;</PRE>
<PRE>/* GenAttrs store attributes of a generic object. */</PRE>
<PRE>typedef ByteFlags GenAttrs;
#define GA_SIGNAL_INTERACTION_COMPLETE					0x80
#define GA_INITIATES_BUSY_STATE					0x40
#define GA_INITIATES_INPUT_HOLD_UP					0x20
#define GA_INITIATES_INPUT_IGNORE					0x10
#define GA_READ_ONLY					0x08
#define GA_KBD_SEARCH_PATH					0x04
#define GA_TARGETABLE					0x02
#define GA_NOTIFY_VISIBILITY					0x01</PRE>
<PRE>/* GenStates store the usability states of a generic object. */</PRE>
<PRE>typedef ByteFlags GenStates;
#define GS_USABLE			0x80
#define GS_ENABLED			0x40*</PRE>
<P>
<CODE>
GI_visMoniker</CODE>
 chooses the title for the generic object, usually added in an appropriate location within the object by the specific UI. The moniker can be text, in the form of a null-terminated text string, or as a graphics string, usually set up separately. For more information on visual monikers, see <A HREF="#GenClass_6.htm_10323"> Visual Monikers</A>
.</P>
<P>
<CODE>
GI_comp</CODE>
 assigns child objects to the current object (the parent). <CODE>
GI_comp</CODE>
 takes a list of generic objects separated by commas as arguments in its instance field. It then sets each of those arguments as children of the current object. In the Goc preprocessor, the <CODE>
GI_comp</CODE>
 arguments will be used to create a generic tree structure, reassigning present links using both the <CODE>
GI_comp</CODE>
 instance field and an internal instance field, <CODE>
GI_link</CODE>
. The <CODE>
GI_link</CODE>
 instance field is therefore an elemental instance field for every generic object but is rarely, if ever, accessed directly. For more information, see <A HREF="#GenClass_7.htm_38463"> Composite Links</A>
.</P>
<P>
<CODE>
GI_kbdAccelerator</CODE>
 sets a given keystroke as a keyboard accelerator for the object. Usually, an object is activated in a manner relating to its specific UI implementation. Pressing the accelerator keystroke will activate the object in the same manner as if its default activation action had occurred. The instance field takes a modifier (<EM>
alt</EM>
, <EM>
shift</EM>
, <EM>
ctrl</EM>
, or combinations of these) and a character (a valid keyboard character) as its arguments. You can further specify the specific keyboard set to use. For more information, see <A HREF="#GenClass_8.htm_77927"> Keyboard Accelerators</A>
.</P>
<P>
<CODE>
GI_attrs</CODE>
 defines how actions performed by the generic object will affect user interface input and output. You may set any, all, or none of these attributes within your object declaration. For more information, see <A HREF="#GenClass_9.htm_90005"> Attributes</A>
.</P>
<P>
<CODE>
GI_states</CODE>
 defines in what state a generic object will be represented. Default states are GS_USABLE and GS_ENABLED. You may set any, all, or none of these states within your object declaration. For more information, see <A HREF="#GenClass_a.htm_44040"> States</A>
.</P>
<HR>
<A NAME="GenClass_4.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">GenClass</A>: 2.2 <A HREF="#GenClass_2.htm">GenClass Instance Data</A>: 
Vardata</H3>
<P>
<CODE>
GenClass</CODE>
 provides a multitude of pre-defined vardata instance fields. You may add these vardata entries to a generic object directly within its object declaration. Vardata instance fields perform several key roles for a generic object. Specifically, they provide two distinct uses:</P>
<UL>
<LI>
hints to the specific UI on its implementation of an object. Hints always appear in the form HINT_<EM>hintname</EM>. </LI>
<LI>
an attribute data storage area considered part of an object's state data (which may therefore be saved to state). Vardata storage areas act as attributes attached to an object if they are explicitly declared within the object declaration. These data appear in the form ATTR_<EM>attributename</EM>. These data act in much the same way as fixed instance fields.</LI>
</UL>
<P>
Any of these data may be accessed and altered using object system routines. For more information, see <A HREF="../../Programming/GOCLanguage/combo.htm">the GEOS Programming chapter</A>.</P>
<H4 CLASS="HeadingC">
Vardata Attributes</H4>
<P>
Vardata attributes may contain the same functionality as other instance fields. Variable attributes, however, will only be allocated space within an object declaration if they are actually declared; instance data fields always take up space within an object, whether used or not. Therefore, vardata attributes are ideal for data that should only take up space if actually used. Vardata attributes are prefaced with <CODE>
ATTR_</CODE>
. Several ATTRs are included in <CODE>
GenClass</CODE>
. See <A HREF="#GenClass_4.htm_35342"> ATTR vardata fields</A>
 for a complete list of these vardata attributes.</P>
<P CLASS="figTitle">
Code Display 2-2 <A NAME="GenClass_4.htm_35342">
 </A>
ATTR vardata fields</P>
<PRE>@vardata void 			ATTR_GEN_PROPERTY;
@vardata void 			ATTR_GEN_NOT_PROPERTY;</PRE>
<PRE>@vardata DestinationClassArgs				ATTR_GEN_DESTINATION_CLASS;
    @reloc ATTR_GEN_DESTINATION_CLASS, 0, optr;</PRE>
<PRE>@vardata char[]			ATTR_GEN_INIT_FILE_KEY;
@vardata char[]			ATTR_GEN_INIT_FILE_CATEGORY;
@vardata void			ATTR_GEN_INIT_FILE_PROPAGATE_TO_CHILDREN;
@vardata void			ATTR_GEN_USES_HIERARCHICAL_INIT_FILE_CATEGORY;</PRE>
<PRE>@vardata Point			ATTR_GEN_POSITION;
@vardata sword			ATTR_GEN_POSITION_X;
@vardata sword			ATTR_GEN_POSITION_Y;</PRE>
<PRE>@vardata void			ATTR_GEN_SEND_APPLY_MSG_ON_APPLY_EVEN_IF_NOT_MODIFIED;
@vardata void			ATTR_GEN_SEND_APPLY_MSG_ON_APPLY_EVEN_IF_NOT_ENABLED;</PRE>
<PRE>@vardata dword			ATTR_GEN_VISIBILITY_DATA;
@vardata word			ATTR_GEN_VISIBILITY_MESSAGE;
@vardata optr			ATTR_GEN_VISIBILITY_DESTINATION;
    @reloc ATTR_GEN_VISIBILITY_DESTINATION, 0, optr;</PRE>
<PRE>@vardata GenFilePath			ATTR_GEN_PATH_DATA;</PRE>
<PRE>@vardata ChunkHandle			ATTR_GEN_FEATURE_LINK;</PRE>
<PRE>@vardata GenDefaultMonikerType ATTR_GEN_DEFAULT_MONIKER;</PRE>
<PRE>@vardata optr 			ATTR_GEN_OUTPUT_TRAVEL_START;
    @reloc ATTR_GEN_OUTPUT_TRAVEL_START, 0, optr;</PRE>
<PRE>/* Generic Help attributes */</PRE>
<PRE>@vardata char[]			ATTR_GEN_HELP_FILE;
@vardata byte			ATTR_GEN_HELP_TYPE;
@vardata void			ATTR_GEN_HELP_FILE_FROM_INIT_FILE;
@vardata optr			ATTR_GEN_FOCUS_HELP;
@vardata optr			ATTR_GEN_FOCUS_HELP_LIB;
    @reloc ATTR_GEN_FOCUS_HELP_LIB, 0, optr;
@vardata char[]			ATTR_GEN_HELP_CONTEXT;</PRE>
<PRE>/* Generic Window attributes */</PRE>
<PRE>@vardata MemHandle			ATTR_GEN_WINDOW_CUSTOM_LAYER_ID;
    @reloc ATTR_GEN_WINDOW_CUSTOM_LAYER_ID, 0, optr;
@vardata WinPriority			ATTR_GEN_WINDOW_CUSTOM_WINDOW_PRIORITY;
@vardata LayerPriority			ATTR_GEN_WINDOW_CUSTOM_LAYER_PRIORITY;
@vardata MemHandle			ATTR_GEN_WINDOW_CUSTOM_PARENT;
@vardata void			ATTR_GEN_CUSTOM_WINDOW;
@vardata void			ATTR_GEN_WINDOW_ACCEPT_INK_EVEN_IF_NOT_FOCUSED;
@vardata KeyboardOverride ATTR_GEN_WINDOW_KBD_OVERRIDE;
@vardata Point			ATTR_GEN_WINDOW_KDB_POSITION;</PRE>
<P>
ATTR_GEN_PROPERTY<A NAME="GenClass_4.htm_IX_ATTR_GEN_NOT_PROPERTY">
 </A>
<A NAME="GenClass_4.htm_IX_ATTR_GEN_PROPERTY">
 </A>
<CODE>
 and </CODE>
ATTR_GEN_NOT_PROPERTY<CODE>
 affect a generic object's ability to behave as a properties group. These attributes override the property group's default behavior. For more information, see <A HREF="#GenClass_14.htm_42380"> Generic Properties</A>
.</CODE>
</P>
<P>
<CODE>
ATTR_GEN_DESTINATION_CLASS</CODE>
<A NAME="GenClass_4.htm_IX_Destination class">
 </A>
 specifies an object class that should handle all messages sent out along a destination path. The type <CODE>
DestinationClassArgs</CODE>
 contains a pointer to a <CODE>
ClassStruct</CODE>
. Typically, this attribute is used with a <CODE>
TravelOption</CODE>
 destination to form a search path. The message for that generic object travels down a path specified in the <CODE>
TravelOption</CODE>
 until it encounters an object class of type <CODE>
ATTR_GEN_DESTINATION_CLASS</CODE>
; at that point, the message will be handled. For more information, see <A HREF="#GenClass_14.htm_95328"> Destination Classes</A>
.</P>
<P>
<CODE>
ATTR_GEN_INIT_FILE_KEY</CODE>
<A NAME="GenClass_4.htm_IX_ATTR_GEN_USES_HIERARCHICAL_INIT_FILE_CATEGORY">
 </A>
<A NAME="GenClass_4.htm_IX_ATTR_GEN_INIT_FILE_PROPAGATE_TO_CHILDREN">
 </A>
<A NAME="GenClass_4.htm_IX_ATTR_GEN_INIT_FILE_CATEGORY">
 </A>
<A NAME="GenClass_4.htm_IX_ATTR_GEN_INIT_FILE_KEY">
 </A>
, <CODE>
ATTR_GEN_INIT_FILE_CATEGORY</CODE>
, <CODE>
ATTR_GEN_INIT_FILE_PROPAGATE_TO_CHILDREN</CODE>
, and ATTR_GEN_USES_HIERARCHICAL_INIT_FILE_CATEGORY allow a generic object to load options from the .INI file upon startup (after receiving a <CODE>
MSG_META_ATTACH</CODE>
). Generic objects with these attributes will receive a <CODE>
MSG_GEN_LOAD_OPTIONS</CODE>
 (with the category and key of the proper entry in the .INI file) and may intercept that message to provide additional behavior. For more information, see <A HREF="#GenClass_14.htm_11206"> Initialization File Management</A>
.</P>
<P>
<CODE>
ATTR_GEN_POSITION</CODE>
<A NAME="GenClass_4.htm_IX_ATTR_GEN_POSITION_Y">
 </A>
<A NAME="GenClass_4.htm_IX_ATTR_GEN_POSITION_X">
 </A>
<A NAME="GenClass_4.htm_IX_ATTR_GEN_POSITION">
 </A>
, <CODE>
ATTR_GEN_POSITION_X</CODE>
, and <CODE>
ATTR_GEN_POSITION_Y</CODE>
 override default geometry management of an object and set a precise position for the object to appear within the UI, offset from the parent object. ATTR_GEN_POSITION specifies both a horizontal and a vertical position to place the object. ATTR_GEN_POSITION_X and ATTR_GEN_POSITION_Y specify either a horizontal or vertical position to align the object along. You should avoid using these attributes because they override default behavior and may result in different (and potentially unsightly) appearances under different specific UIs. For more information, see <A HREF="#GenClass_14.htm_95545"> Altering Default Geometry Management</A>
.</P>
<P>
<CODE>
ATTR_GEN_SEND_APPLY_MSG_ON_APPLY_EVEN_IF_NOT_MODIFIED</CODE>
<A NAME="GenClass_4.htm_IX_ATTR_GEN_SEND_APPLY_MSG_ON_APPLY_EVEN_IF_NOT_ENABLED">
 </A>
<A NAME="GenClass_4.htm_IX_ATTR_GEN_SEND_APPLY_MSG_ON_APPLY_EVEN_IF_NOT_MODIFIED">
 </A>
 and <CODE>
ATTR_GEN_SEND_APPLY_MSG_ON_APPLY_EVEN_IF_NOT_ENABLED</CODE>
 affect generic objects that contain an apply message--a message that an object sends out when it wishes to apply changes made within that object. By default, an apply message will not be sent out if the object's state has not changed since the last apply or if the object is not enabled; these attributes tell the object to send out its apply message regardless of these conditions. For more information, see <A HREF="#GenClass_14.htm_52019"> Altering Delayed Mode Activity</A>
.</P>
<P>
<CODE>
ATTR_GEN_VISIBILITY_DATA</CODE>
<A NAME="GenClass_4.htm_IX_ATTR_GEN_VISIBILITY_DESTINATION">
 </A>
<A NAME="GenClass_4.htm_IX_ATTR_GEN_VISIBILITY_MESSAGE">
 </A>
<A NAME="GenClass_4.htm_IX_ATTR_GEN_VISIBILITY_DATA">
 </A>
, <CODE>
ATTR_GEN_VISIBILITY_MESSAGE</CODE>
, and <CODE>
ATTR_GEN_VISIBILITY_DESTINATION</CODE>
 set the data, message or destination to use with the visibility notification mechanism in <CODE>
GenClass</CODE>
. The visibility mechanism allows an application to know when an object becomes visible and not visible. An object provides this notification if its GA_NOTIFY_VISIBILITY bit is set. For more information, see <A HREF="#GenClass_14.htm_18848"> Notification of Visibility</A>
.</P>
<P>
<CODE>
ATTR_GEN_PATH_DATA</CODE>
<A NAME="GenClass_4.htm_IX_ATTR_GEN_PATH_DATA">
 </A>
 stores an object's generic path information in the form of a <CODE>
GenFilePath</CODE>
 structure. This structure contains disk and path information including path name and file name; generic objects can use this attribute to store current or default paths and files. For more information, see <A HREF="#GenClass_14.htm_64105"> Generic Paths</A>
.</P>
<P>
<CODE>
ATTR_GEN_FEATURE_LINK</CODE>
<A NAME="GenClass_4.htm_IX_ATTR_GEN_FEATURE_LINK">
 </A>
 contains a link to the next feature used by the GenControl mechanism when a controller's features map to multiple objects. It is unlikely you will use this attribute. For more information, see <A HREF="#GenClass_14.htm_65875"> Feature Links</A>
.</P>
<P>
ATTR_GEN_DEFAULT_MONIKER<A NAME="GenClass_4.htm_IX_ATTR_GEN_DEFAULT_MONIKER">
 </A>
 specifies a default moniker for a generic object. This is generally used for graphic monikers that occur several places within the system. For more information, see <A HREF="#GenClass_14.htm_20719"> Default Monikers</A>
.</P>
<P>
ATTR_GEN_OUTPUT_TRAVEL_START<A NAME="GenClass_4.htm_IX_MSG_GEN_OUTPUT_ACTION">
 </A>
<A NAME="GenClass_4.htm_IX_ATTR_GEN_OUTPUT_TRAVEL_START">
 </A>
 allows you to set a specific object to begin the <CODE>
TravelOption</CODE>
. Normally, objects that contain a <CODE>
TravelOption</CODE>
 in their destination field use their own object as the point of reference for sending messages along travel paths. (I.e sending a message TO_FOCUS would send a message along the focus path, starting at the sending object.) This can be used for optimization purposes, enabling you to skip several layers of hierarchies.</P>
<P>
ATTR_GEN_HELP_FILE<A NAME="GenClass_4.htm_IX_ATTR_GEN_HELP_CONTEXT">
 </A>
<A NAME="GenClass_4.htm_IX_ATTR_GEN_FOCUS_HELP_LIB">
 </A>
<A NAME="GenClass_4.htm_IX_ATTR_GEN_FOCUS_HELP">
 </A>
<A NAME="GenClass_4.htm_IX_ATTR_GEN_HELP_FILE_FROM_INIT_FILE">
 </A>
<A NAME="GenClass_4.htm_IX_ATTR_GEN_HELP_TYPE">
 </A>
<A NAME="GenClass_4.htm_IX_ATTR_GEN_HELP_FILE">
 </A>
, ATTR_GEN_HELP_TYPE, ATTR_GEN_HELP_FILE_FROM_INIT_FILE, ATTR_GEN_FOCUS_HELP, ATTR_GEN_FOCUS_HELP_LIB, and ATTR_GEN_HELP_CONTEXT specify the configuration of the help files for a generic object. Focus help starts help notification when the generic object gains the focus. For more information on Help files, see <A HREF="#GenClass_14.htm_81506"> Help Management</A>
.</P>
<P>
ATTR_GEN_WINDOW_CUSTOM_LAYER_ID<A NAME="GenClass_4.htm_IX_ATTR_GEN_WINDOW_KBD_POSITION">
 </A>
<A NAME="GenClass_4.htm_IX_ATTR_GEN_WINDOW_KBD_OVERRIDE">
 </A>
<A NAME="GenClass_4.htm_IX_ATTR_GEN_WINDOW_ACCEPT_INK_EVEN_IF_NOT_FOCUSED">
 </A>
<A NAME="GenClass_4.htm_IX_ATTR_GEN_CUSTOM_WINDOW">
 </A>
<A NAME="GenClass_4.htm_IX_ATTR_GEN_WINDOW_CUSTOM_PARENT">
 </A>
<A NAME="GenClass_4.htm_IX_ATTR_GEN_WINDOW_CUSTOM_LAYER_PRIORITY">
 </A>
<A NAME="GenClass_4.htm_IX_ATTR_GEN_WINDOW_CUSTOM_WINDOW_PRIORITY">
 </A>
<A NAME="GenClass_4.htm_IX_ATTR_GEN_WINDOW_CUSTOM_LAYER_ID">
 </A>
, ATTR_GEN_WINDOW_CUSTOM_WINDOW_PRIORITY, ATTR_GEN_WINDOW_CUSTOM_LAYER_PRIORITY, ATTR_GEN_WINDOW_CUSTOM_PARENT, and ATTR_GEN_CUSTOM_WINDOW specify a window's interaction and place within the window system. ATTR_GEN_WINDOW_ACCEPT_INK_EVEN_IF_NOT_FOCUSED, ATTR_GEN_WINDOW_KBD_OVERRIDE, and ATTR_GEN_WINDOW_KBD_POSITION affect how input flows within a generic window. For more information, see <A HREF="#GenClass_14.htm_59456"> Window Management</A>
.</P>


<H4 CLASS="HeadingC">
Hints</H4>
<P>
Hints to the specific UI suggest added functionality to your application, and are prefaced with <CODE>
HINT_</CODE>
 (such as <CODE>
HINT_SEEK_REPLY_BAR</CODE>
). Hints may also have data structures attached to them. There are a large number of pre-defined hints with <CODE>
GenClass</CODE>
. See <A HREF="#GenClass_15.htm_68134"> Hints to the Specific UI</A>
 for details on the operation of hints.</P>
<P>
Many of the hints provided in <CODE>
GenClass</CODE>
 manage the geometry of generic objects. For complete information on these hints, see <A HREF="../../UI/Geometry/combo.htm">the Managing UI Geometry chapter</A>.</P><P CLASS="figTitle">
Code Display 2-3 Geometry Hints</P>
<PRE><A NAME="GenClass_4.htm_IX_Geometry:list of generic hints"> </A>/* These hints are explained within the Geometry Management chapter. */</PRE>
<PRE>@vardata void			<A NAME="GenClass_4.htm_IX_HINT_DONT_ALLOW_CHILDREN_TO_WRAP"> </A>HINT_DONT_ALLOW_CHILDREN_TO_WRAP;
@vardata void			<A NAME="GenClass_4.htm_IX_HINT_ALLOW_CHILDREN_TO_WRAP"> </A>HINT_ALLOW_CHILDREN_TO_WRAP;
@vardata word			<A NAME="GenClass_4.htm_IX_HINT_WRAP_AFTER_CHILD_COUNT"> </A>HINT_WRAP_AFTER_CHILD_COUNT;
@vardata word			<A NAME="GenClass_4.htm_IX_HINT_WRAP_AFTER_CHILD_COUNT_IF_VERTICAL_SCREEN"> </A>HINT_WRAP_AFTER_CHILD_COUNT_IF_VERTICAL_SCREEN;</PRE>
<PRE>@vardata void			<A NAME="GenClass_4.htm_IX_HINT_BOTTOM_JUSTIFY_CHILDREN"> </A>HINT_BOTTOM_JUSTIFY_CHILDREN;
@vardata void			<A NAME="GenClass_4.htm_IX_HINT_LEFT_JUSTIFY_CHILDREN"> </A>HINT_LEFT_JUSTIFY_CHILDREN;
@vardata void			<A NAME="GenClass_4.htm_IX_HINT_RIGHT_JUSTIFY_CHILDREN"> </A>HINT_RIGHT_JUSTIFY_CHILDREN;
@vardata void			<A NAME="GenClass_4.htm_IX_HINT_TOP_JUSTIFY_CHILDREN"> </A>HINT_TOP_JUSTIFY_CHILDREN;</PRE>
<PRE>@vardata void			<A NAME="GenClass_4.htm_IX_HINT_FULL_JUSTIFY_CHILDREN_HORIZONTALLY"> </A>HINT_FULL_JUSTIFY_CHILDREN_HORIZONTALLY;
@vardata void			<A NAME="GenClass_4.htm_IX_HINT_FULL_JUSTIFY_CHILDREN_VERTICALLY"> </A>HINT_FULL_JUSTIFY_CHILDREN_VERTICALLY;
@vardata void			<A NAME="GenClass_4.htm_IX_HINT_DONT_FULL_JUSTIFY_CHILDREN"> </A>HINT_DONT_FULL_JUSTIFY_CHILDREN;</PRE>
<PRE>@vardata SpecSizeSpec			<A NAME="GenClass_4.htm_IX_HINT_CUSTOM_CHILD_SPACING"> </A>HINT_CUSTOM_CHILD_SPACING;
@vardata SpecSizeSpec			<A NAME="GenClass_4.htm_IX_HINT_CUSTOM_CHILD_SPACING_IF_LIMITED_SPACE"> </A>HINT_CUSTOM_CHILD_SPACING_IF_LIMITED_SPACE;
@vardata void			<A NAME="GenClass_4.htm_IX_HINT_DONT_INCLUDE_ENDS_IN_CHILD_SPACING"> </A>HINT_DONT_INCLUDE_ENDS_IN_CHILD_SPACING;
@vardata void			<A NAME="GenClass_4.htm_IX_HINT_INCLUDE_ENDS_IN_CHILD_SPACING"> </A>HINT_INCLUDE_ENDS_IN_CHILD_SPACING;
@vardata void 			<A NAME="GenClass_4.htm_IX_HINT_MINIMIZE_CHILD_SPACING"> </A>HINT_MINIMIZE_CHILD_SPACING;</PRE>
<PRE>@vardata void			<A NAME="GenClass_4.htm_IX_HINT_LEFT_JUSTIFY_MONIKERS"> </A>HINT_LEFT_JUSTIFY_MONIKERS;
@vardata void			<A NAME="GenClass_4.htm_IX_HINT_CENTER_MONIKER"> </A>HINT_CENTER_MONIKER;
@vardata void			<A NAME="GenClass_4.htm_IX_HINT_DO_NOT_USE_MONIKER"> </A>HINT_DO_NOT_USE_MONIKER;
@vardata void			<A NAME="GenClass_4.htm_IX_HINT_ALIGN_LEFT_MONIKER_EDGE_WITH_CHILD"> </A>HINT_ALIGN_LEFT_MONIKER_EDGE_WITH_CHILD;</PRE>
<PRE>@vardata void			<A NAME="GenClass_4.htm_IX_HINT_CENTER_CHILDREN_HORIZONTALLY"> </A>HINT_CENTER_CHILDREN_HORIZONTALLY;
@vardata void			<A NAME="GenClass_4.htm_IX_HINT_CENTER_CHILDREN_ON_MONIKERS"> </A>HINT_CENTER_CHILDREN_ON_MONIKERS;
@vardata void			<A NAME="GenClass_4.htm_IX_HINT_CENTER_CHILDREN_VERTICALLY"> </A>HINT_CENTER_CHILDREN_VERTICALLY;</PRE>
<PRE>@vardata optr			<A NAME="GenClass_4.htm_IX_HINT_ALIGN_LEFT_EDGE_WITH_OBJECT"> </A>HINT_ALIGN_LEFT_EDGE_WITH_OBJECT;
    @reloc HINT_ALIGN_LEFT_EDGE_WITH_OBJECT, 0, optr;
@vardata optr			<A NAME="GenClass_4.htm_IX_HINT_ALIGN_TOP_EDGE_WITH_OBJECT"> </A>HINT_ALIGN_TOP_EDGE_WITH_OBJECT;
    @reloc HINT_ALIGN_TOP_EDGE_WITH_OBJECT, 0, optr;
@vardata optr			<A NAME="GenClass_4.htm_IX_HINT_ALIGN_RIGHT_EDGE_WITH_OBJECT"> </A>HINT_ALIGN_RIGHT_EDGE_WITH_OBJECT;
    @reloc HINT_ALIGN_RIGHT_EDGE_WITH_OBJECT, 0, optr;
@vardata optr			<A NAME="GenClass_4.htm_IX_HINT_ALIGN_BOTTOM_EDGE_WITH_OBJECT"> </A>HINT_ALIGN_BOTTOM_EDGE_WITH_OBJECT;
    @reloc HINT_ALIGN_BOTTOM_EDGE_WITH_OBJECT, 0, optr;</PRE>
<PRE>@vardata CompSizeHintArgs			<A NAME="GenClass_4.htm_IX_HINT_FIXED_SIZE"> </A>HINT_FIXED_SIZE;
@vardata CompSizeHintArgs	<A NAME="GenClass_4.htm_IX_HINT_INITIAL_SIZE"> </A>		HINT_INITIAL_SIZE;
@vardata CompSizeHintArgs	<A NAME="GenClass_4.htm_IX_HINT_MAXIMUM_SIZE"> </A>		HINT_MAXIMUM_SIZE;
@vardata CompSizeHintArgs	<A NAME="GenClass_4.htm_IX_HINT_MINIMUM_SIZE"> </A>		HINT_MINIMUM_SIZE;
@vardata void			<A NAME="GenClass_4.htm_IX_HINT_SIZE_WINDOW_AS_DESIRED"> </A>HINT_SIZE_WINDOW_AS_DESIRED;</PRE>
<PRE>@vardata void			<A NAME="GenClass_4.htm_IX_HINT_DRAW_IN_BOX"> </A>HINT_DRAW_IN_BOX;</PRE>
<PRE>@vardata void			<A NAME="GenClass_4.htm_IX_HINT_EXPAND_HEIGHT_TO_FIT_PARENT"> </A>HINT_EXPAND_HEIGHT_TO_FIT_PARENT;
@vardata void			<A NAME="GenClass_4.htm_IX_HINT_EXPAND_WIDTH_TO_FIT_PARENT"> </A>HINT_EXPAND_WIDTH_TO_FIT_PARENT;</PRE>
<PRE>@vardata void			<A NAME="GenClass_4.htm_IX_HINT_MAKE_REPLY_BAR"> </A>HINT_MAKE_REPLY_BAR;</PRE>
<PRE>@vardata void			<A NAME="GenClass_4.htm_IX_HINT_NO_TALLER_THAN_CHILDREN_REQUIRE"> </A>HINT_NO_TALLER_THAN_CHILDREN_REQUIRE;
@vardata void			<A NAME="GenClass_4.htm_IX_HINT_NO_WIDER_THAN_CHILDREN_REQUIRE"> </A>HINT_NO_WIDER_THAN_CHILDREN_REQUIRE;</PRE>
<PRE>@vardata void			HINT_ORIENT_CHILDREN_HORIZONTALLY;
@vardata void			<A NAME="GenClass_4.htm_IX_HINT_ORIENT_CHILDREN_VERTICALLY"> </A>HINT_ORIENT_CHILDREN_VERTICALLY;
@vardata void			<A NAME="GenClass_4.htm_IX_HINT_ORIENT_CHILDREN_ALONG_LARGER_DIMENSION"> </A>HINT_ORIENT_CHILDREN_ALONG_LARGER_DIMENSION;
@vardata void			<A NAME="GenClass_4.htm_IX_HINT_SAME_ORIENTATION_AS_PARENT"> </A>HINT_SAME_ORIENTATION_AS_PARENT;</PRE>
<PRE>@vardata void			<A NAME="GenClass_4.htm_IX_HINT_PLACE_MONIKER_ABOVE"> </A>HINT_PLACE_MONIKER_ABOVE;
@vardata void			<A NAME="GenClass_4.htm_IX_HINT_PLACE_MONIKER_BELOW"> </A>HINT_PLACE_MONIKER_BELOW;
@vardata void			<A NAME="GenClass_4.htm_IX_HINT_PLACE_MONIKER_TO_LEFT"> </A>HINT_PLACE_MONIKER_TO_LEFT;
@vardata void			<A NAME="GenClass_4.htm_IX_HINT_PLACE_MONIKER_TO_RIGHT"> </A>HINT_PLACE_MONIKER_TO_RIGHT;
@vardata void			<A NAME="GenClass_4.htm_IX_HINT_PLACE_MONIKER_ALONG_LARGER_DIMENSION"> </A>HINT_PLACE_MONIKER_ALONG_LARGER_DIMENSION;
@vardata void			HINT_NO_BORDER_ON_MONIKERS</PRE>
<PRE>@vardata void			<A NAME="GenClass_4.htm_IX_HINT_SEEK_MENU_BAR"> </A>HINT_SEEK_MENU_BAR;
@vardata void			<A NAME="GenClass_4.htm_IX_HINT_AVOID_MENU_BAR"> </A>HINT_AVOID_MENU_BAR;</PRE>
<PRE>@vardata void			<A NAME="GenClass_4.htm_IX_HINT_SEEK_REPLY_BAR"> </A>HINT_SEEK_REPLY_BAR;</PRE>
<PRE>@vardata void			<A NAME="GenClass_4.htm_IX_HINT_SEEK_X_SCROLLER_AREA"> </A>HINT_SEEK_X_SCROLLER_AREA;
@vardata void			<A NAME="GenClass_4.htm_IX_HINT_SEEK_Y_SCROLLER_AREA"> </A>HINT_SEEK_Y_SCROLLER_AREA;</PRE>
<PRE>@vardata void			<A NAME="GenClass_4.htm_IX_HINT_SEEK_LEFT_OF_VIEW"> </A>HINT_SEEK_LEFT_OF_VIEW;
@vardata void			<A NAME="GenClass_4.htm_IX_HINT_SEEK_TOP_OF_VIEW"> </A>HINT_SEEK_TOP_OF_VIEW;
@vardata void			<A NAME="GenClass_4.htm_IX_HINT_SEEK_RIGHT_OF_VIEW"> </A>HINT_SEEK_RIGHT_OF_VIEW;
@vardata void			<A NAME="GenClass_4.htm_IX_HINT_SEEK_BOTTOM_OF_VIEW"> </A>HINT_SEEK_BOTTOM_OF_VIEW;</PRE>
<PRE>@vardata void			<A NAME="GenClass_4.htm_IX_HINT_SEEK_TITLE_BAR_LEFT"> </A>HINT_SEEK_TITLE_BAR_LEFT;
@vardata void			<A NAME="GenClass_4.htm_IX_HINT_SEEK_TITLE_BAR_RIGHT"> </A>HINT_SEEK_TITLE_BAR_RIGHT;</PRE>
<PRE>@vardata void			<A NAME="GenClass_4.htm_IX_HINT_USE_INITIAL_BOUNDS_WHEN_RESTORED"> </A>HINT_USE_INITIAL_BOUNDS_WHEN_RESTORED;</PRE>
<PRE>@vardata void			<A NAME="GenClass_4.htm_IX_HINT_DIVIDE_WIDTH_EQUALLY"> </A>HINT_DIVIDE_WIDTH_EQUALLY;
@vardata void			<A NAME="GenClass_4.htm_IX_HINT_DIVIDE_HEIGHT_EQUALLY"> </A>HINT_DIVIDE_HEIGHT_EQUALLY;</PRE>
<PRE>@vardata void			<A NAME="GenClass_4.htm_IX_HINT_KEEP_INITIALLY_ONSCREEN"> </A>HINT_KEEP_INITIALLY_ONSCREEN;
@vardata void			<A NAME="GenClass_4.htm_IX_HINT_DONT_KEEP_INITIALLY_ONSCREEN"> </A>HINT_DONT_KEEP_INITIALLY_ONSCREEN;
@vardata void			<A NAME="GenClass_4.htm_IX_HINT_KEEP_PARTIALLY_ONSCREEN"> </A>HINT_KEEP_PARTIALLY_ONSCREEN;
@vardata void			<A NAME="GenClass_4.htm_IX_HINT_DONT_KEEP_PARTIALLY_ONSCREEN"> </A>HINT_DONT_KEEP_PARTIALLY_ONSCREEN;
@vardata void			<A NAME="GenClass_4.htm_IX_HINT_KEEP_ENTIRELY_ONSCREEN"> </A>HINT_KEEP_ENTIRELY_ONSCREEN;
@vardata void			<A NAME="GenClass_4.htm_IX_HINT_KEEP_ENTIRELY_ONSCREEN_WITH_MARGIN"> </A>HINT_KEEP_ENTIRELY_ONSCREEN_WITH_MARGIN;</PRE>
<PRE>@vardata void			<A NAME="GenClass_4.htm_IX_HINT_POPS_UP_TO_RIGHT"> </A>HINT_POPS_UP_TO_RIGHT;
@vardata void			<A NAME="GenClass_4.htm_IX_HINT_POPS_UP_BELOW"> </A>HINT_POPS_UP_BELOW;</PRE>
<PRE>@vardata void			<A NAME="GenClass_4.htm_IX_HINT_NOT_MOVABLE"> </A>HINT_NOT_MOVABLE;</PRE>
<PRE>@vardata SpecWinSizePair			<A NAME="GenClass_4.htm_IX_HINT_POSITION_WINDOW_AT_RATIO_OF_PARENT"> </A>HINT_POSITION_WINDOW_AT_RATIO_OF_PARENT;
@vardata void			<A NAME="GenClass_4.htm_IX_HINT_POSITION_WINDOW_AT_MOUSE"> </A>HINT_POSITION_WINDOW_AT_MOUSE;</PRE>
<PRE>@vardata void			<A NAME="GenClass_4.htm_IX_HINT_WINDOW_NO_TITLE_BAR"> </A>HINT_WINDOW_NO_TITLE_BAR;
@vardata void			<A NAME="GenClass_4.htm_IX_HINT_WINDOW_NO_SYS_MENU"> </A>HINT_WINDOW_NO_SYS_MENU;
@vardata void			HINT_WINDOW_MINIMIZE_TITLE_BAR;
@vardata void			HINT_WINDOW_ALWAYS_DRAW_WITH_FOCUS;</PRE>
<PRE>@vardata void			<A NAME="GenClass_4.htm_IX_HINT_STAGGER_WINDOW"> </A>HINT_STAGGER_WINDOW;
@vardata void			<A NAME="GenClass_4.htm_IX_HINT_CENTER_WINDOW"> </A>HINT_CENTER_WINDOW;
@vardata void			<A NAME="GenClass_4.htm_IX_HINT_TILE_WINDOW"> </A>HINT_TILE_WINDOW;</PRE>
<PRE>@vardata void			<A NAME="GenClass_4.htm_IX_HINT_EXTEND_WINDOW_TO_BOTTOM_RIGHT"> </A>HINT_EXTEND_WINDOW_TO_BOTTOM_RIGHT;
@vardata void			<A NAME="GenClass_4.htm_IX_HINT_EXTEND_WINDOW_NEAR_BOTTOM_RIGHT"> </A>HINT_EXTEND_WINDOW_NEAR_BOTTOM_RIGHT;</PRE>
<PRE>@vardata SpecWinSizePair			<A NAME="GenClass_4.htm_IX_HINT_SIZE_WINDOW_AS_RATIO_OF_PARENT"> </A>HINT_SIZE_WINDOW_AS_RATIO_OF_PARENT;
@vardata SpecWinSizePair			<A NAME="GenClass_4.htm_IX_HINT_SIZE_WINDOW_AS_RATIO_OF_FIELD"> </A>HINT_SIZE_WINDOW_AS_RATIO_OF_FIELD;
@vardata void			<A NAME="GenClass_4.htm_IX_HINT_WINDOW_NO_CONSTRAINTS"> </A>HINT_WINDOW_NO_CONSTRAINTS;</PRE>
<PRE>@vardata SpecWinSizePair			<A NAME="GenClass_4.htm_IX_HINT_POSITION_ICON_AS_RATIO_OF_FIELD"> </A>HINT_POSITION_ICON_AS_RATIO_OF_FIELD;</PRE>
<P>
Other hints in <CODE>
GenClass</CODE>
 do not affect geometry. These hints are listed below and are explained within this chapter. Within <CODE>
GenClass</CODE>
, some hints are internal and are not listed in this code display.</P>
<P CLASS="figTitle">
Code Display 2-4 Hints Explained Within This Chapter</P>
<PRE>/* These hints are explained within this chapter (or they are self-explanatory). */</PRE>
<PRE>@vardata void			<A NAME="GenClass_4.htm_IX_HINT_FREQUENTLY_USED"> </A>HINT_FREQUENTLY_USED;
@vardata void			<A NAME="GenClass_4.htm_IX_HINT_INFREQUENTLY_USED"> </A>HINT_INFREQUENTLY_USED;
@vardata void			<A NAME="GenClass_4.htm_IX_HINT_AN_ADVANCED_FEATURE"> </A>HINT_AN_ADVANCED_FEATURE;</PRE>
<PRE>@vardata void			HINT_DEFAULT_DEFAULT_ACTION;
@vardata void			<A NAME="GenClass_4.htm_IX_HINT_ENSURE_TEMPORARY_DEFAULT"> </A>HINT_ENSURE_TEMPORARY_DEFAULT;
@vardata void			<A NAME="GenClass_4.htm_IX_HINT_PREVENT_DEFAULT_OVERRIDES"> </A>HINT_PREVENT_DEFAULT_OVERRIDES;</PRE>
<PRE>@vardata void			<A NAME="GenClass_4.htm_IX_HINT_SAME_CATEGORY_AS_PARENT"> </A>HINT_SAME_CATEGORY_AS_PARENT;</PRE>
<PRE>@vardata void			<A NAME="GenClass_4.htm_IX_HINT_USE_TEXT_MONIKER"> </A>HINT_USE_TEXT_MONIKER;
@vardata void			<A NAME="GenClass_4.htm_IX_HINT_USE_ICONIC_MONIKER"> </A>HINT_USE_ICONIC_MONIKER;</PRE>
<PRE>@vardata void			<A NAME="GenClass_4.htm_IX_HINT_DEFAULT_FOCUS"> </A>HINT_DEFAULT_FOCUS;
@vardata void			<A NAME="GenClass_4.htm_IX_HINT_DEFAULT_TARGET"> </A>HINT_DEFAULT_TARGET;
@vardata void			<A NAME="GenClass_4.htm_IX_HINT_DEFAULT_MODEL"> </A>HINT_DEFAULT_MODEL;</PRE>
<PRE>@vardata void			<A NAME="GenClass_4.htm_IX_HINT_PRESERVE_FOCUS"> </A>HINT_PRESERVE_FOCUS;
@vardata void			<A NAME="GenClass_4.htm_IX_HINT_DO_NOT_PRESERVE_FOCUS"> </A>HINT_DO_NOT_PRESERVE_FOCUS;</PRE>
<PRE>@vardata void			<A NAME="GenClass_4.htm_IX_HINT_GENERAL_CONSUMER_MODE"> </A>HINT_GENERAL_CONSUMER_MODE;</PRE>
<PRE>@vardata void			<A NAME="GenClass_4.htm_IX_HINT_NEVER_ADOPT_MENUS"> </A>HINT_NEVER_ADOPT_MENUS;
@vardata void			<A NAME="GenClass_4.htm_IX_HINT_ALWAYS_ADOPT_MENUS"> </A>HINT_ALWAYS_ADOPT_MENUS;</PRE>
<PRE>@vardata void			<A NAME="GenClass_4.htm_IX_HINT_NAVIGATION_ID"> </A>HINT_NAVIGATION_ID;
@vardata void			<A NAME="GenClass_4.htm_IX_HINT_NAVIGATION_NEXT_ID"> </A>HINT_NAVIGATION_NEXT_ID</PRE>
<PRE>@vardata void			<A NAME="GenClass_4.htm_IX_HINT_DISMISS_WHEN_DISABLED"> </A>HINT_DISMISS_WHEN_DISABLED;</PRE>
<PRE>@vardata void			HINT_TOOLBOX;</PRE>
<PRE>@vardata void			<A NAME="GenClass_4.htm_IX_HINT_SHOW_SHORTCUT"> </A>HINT_SHOW_SHORTCUT;
@vardata void			<A NAME="GenClass_4.htm_IX_HINT_DONT_SHOW_SHORTCUT"> </A>HINT_DONT_SHOW_SHORTCUT;
@vardata void			HINT_DRAW_SHORTCUT_BELOW;</PRE>
<PRE>@vardata void			<A NAME="GenClass_4.htm_IX_HINT_CAN_CLIP_MONIKER_WIDTH"> </A>HINT_CAN_CLIP_MONIKER_WIDTH;
@vardata void			<A NAME="GenClass_4.htm_IX_HINT_CAN_CLIP_MONIKER_HEIGHT"> </A>HINT_CAN_CLIP_MONIKER_HEIGHT;
@vardata void			<A NAME="GenClass_4.htm_IX_HINT_SHOW_ENTIRE_MONIKER"> </A>HINT_SHOW_ENTIRE_MONIKER;</PRE>
<PRE>@vardata BackgroundColors				<A NAME="GenClass_4.htm_IX_HINT_GADGET_BACKGROUND_COLORS"> </A>HINT_GADGET_BACKGROUND_COLORS;
@vardata word			<A NAME="GenClass_4.htm_IX_HINT_GADGET_TEXT_COLOR"> </A>HINT_GADGET_TEXT_COLOR;</PRE>
<PRE>@vardata SystemAttrs			<A NAME="GenClass_4.htm_IX_HINT_IF_SYSTEM_ATTRS"> </A>HINT_IF_SYSTEM_ATTRS;
@vardata void			<A NAME="GenClass_4.htm_IX_HINT_ENDIF"> </A>HINT_ENDIF;
@vardata void			<A NAME="GenClass_4.htm_IX_HINT_ELSE"> </A>HINT_ELSE;</PRE>
<P>
HINT_FREQUENTLY_USED, HINT_INFREQUENTLY_USED, and HINT_AN_ADVANCED_FEATURE are descriptive hints that describe the generic object's role within the UI. It is, of course, left up to the specific UI to implement any special behavior based on these hints.<A NAME="GenClass_4.htm_IX_HINT_AN_ADVANCED_FEATURE">
 </A>
<A NAME="GenClass_4.htm_IX_HINT_INFREQUENTLY_USED">
 </A>
<A NAME="GenClass_4.htm_IX_HINT_FREQUENTLY_USED">
 </A>
</P>
<P>
HINT_DEFAULT_DEFAULT_ACTION<A NAME="GenClass_4.htm_IX_HINT_PREVENT_DEFAULT_OVERRIDES">
 </A>
<A NAME="GenClass_4.htm_IX_HINT_ENSURE_TEMPORARY_DEFAULT">
 </A>
<A NAME="GenClass_4.htm_IX_HINT_DEFAULT_DEFAULT_ACTION">
 </A>
, HINT_ENSURE_TEMPORARY_DEFAULT, and HINT_PREVENT_DEFAULT_OVERRIDES affect the default activation of objects within the UI. Objects with default activation can be activated indirectly (e.g., pressing the ENTER key within a dialog box activates a default trigger). For more information, see <A HREF="#GenClass_15.htm_16416"> Default Actions</A>
.</P>
<P>
HINT_SAME_CATEGORY_AS_PARENT<A NAME="GenClass_4.htm_IX_HINT_SAME_CATEGORY_AS_PARENT">
 </A>
 indicates to the specific UI that this object should be treated in the same manner as its parent. Currently, this hint only affects GenInteractions. By default, GIV_SUB_GROUP GenInteractions within a GIV_POPUP menu have separator lines drawn around them to set them apart from other children. This hint removes those lines.</P>
<P>
HINT_USE_TEXT_MONIKER<A NAME="GenClass_4.htm_IX_HINT_USE_ICONIC_MONIKER">
 </A>
<A NAME="GenClass_4.htm_IX_HINT_USE_TEXT_MONIKER">
 </A>
 and HINT_USE_ICONIC_MONIKER indicates that the generic object should choose either a text moniker or an iconic moniker if there exists a choice within the object's moniker list. Currently, these hints are not implemented.</P>
<P>
HINT_DEFAULT_FOCUS<A NAME="GenClass_4.htm_IX_HINT_DEFAULT_MODEL">
 </A>
<A NAME="GenClass_4.htm_IX_HINT_DEFAULT_TARGET">
 </A>
<A NAME="GenClass_4.htm_IX_HINT_DEFAULT_FOCUS">
 </A>
, HINT_DEFAULT_TARGET, and HINT_DEFAULT_MODEL specify that the generic object is the default focus, target, or model node at this level in the application. HINT_PRESERVE_FOCUS<A NAME="GenClass_4.htm_IX_HINT_DO_NOT_PRESERVE_FOCUS">
 </A>
<A NAME="GenClass_4.htm_IX_HINT_PRESERVE_FOCUS">
 </A>
 and HINT_DO_NOT_PRESERVE_FOCUS affect how the focus node changes after an object's activation. For a complete discussion of the focus and target hierarchies, see <A HREF="../../SysObjects/Input/combo.htm">the Input chapter</A>.</P><P>
HINT_GENERAL_CONSUMER_MODE<A NAME="GenClass_4.htm_IX_HINT_GENERAL_CONSUMER_MODE">
 </A>
 instructs the specific UI to show the object in GCM mode. This hint takes an argument of type <CODE>
GeneralConsumerModeFlags</CODE>
; this record contains two three-bit flags: GCMF_LEFT_ICON and GCMF_RIGHT_ICON, which specify which icon to use on both the left and right sides of the title bar. Each icon must be of type <CODE>
GCMIcon</CODE>
; current types are GCMI_NONE, GCMI_EXIT, and GCMI_HELP.</P>
<P>
HINT_NEVER_ADOPT_MENUS<A NAME="GenClass_4.htm_IX_HINT_ALWAYS_ADOPT_MENUS">
 </A>
<A NAME="GenClass_4.htm_IX_HINT_NEVER_ADOPT_MENUS">
 </A>
 and HINT_ALWAYS_ADOPT_MENUS affect the behavior of menus placed within a GenDisplay. Menus can either sit within the GenDisplay or appear in the associated GenPrimary when that GenDisplay is the target. Menus within GenDisplays are discouraged, however, as they are a fairly advanced UI metaphor.</P>
<P>
HINT_NAVIGATION_ID<A NAME="GenClass_4.htm_IX_HINT_NAVIGATION_NEXT_ID">
 </A>
<A NAME="GenClass_4.htm_IX_HINT_NAVIGATION_ID">
 </A>
 and HINT_NAVIGATION_NEXT_ID allow the field navigation path within a windowed object. HINT_NAVIGATION_NEXT_ID sets the object to navigate to from the current object. An object with a matching HINT_NAVIGATION_ID must exist. For more information, see <A HREF="#GenClass_15.htm_42812"> Keyboard Navigation Hints</A>
.</P>
<P>
HINT_DISMISS_WHEN_DISABLED<A NAME="GenClass_4.htm_IX_HINT_DISMISS_WHEN_DISABLED">
 </A>
 instructs the specific UI to dismiss the object when it is no longer fully enabled. This is typically useful for independently-displayable windows that should be dismissed in such cases.</P>
<P>
HINT_TOOLBOX<A NAME="GenClass_4.htm_IX_HINT_TOOLBOX">
 </A>
 indicates that the generic object and all objects below it in the visual hierarchy are part of a &quot;toolbox&quot; and should draw themselves appropriately. Objects in toolboxes are typically much smaller than other components. For more information on toolboxes, see <A HREF="../../UI/GenInteraction/combo.htm">the Menus and Dialogs chapter</A>.</P><P>
HINT_SHOW_SHORTCUT<A NAME="GenClass_4.htm_IX_HINT_DRAW_SHORTCUT_BELOW">
 </A>
<A NAME="GenClass_4.htm_IX_HINT_DONT_SHOW_SHORTCUT">
 </A>
<A NAME="GenClass_4.htm_IX_HINT_SHOW_SHORTCUT">
 </A>
, HINT_DONT_SHOW_SHORTCUT, and HINT_DRAW_SHORTCUT_BELOW affect the display of keyboard accelerators for generic objects. For more information, see <A HREF="#GenClass_8.htm_77927"> Keyboard Accelerators</A>
.</P>
<P>
HINT_CAN_CLIP_MONIKER_WIDTH<A NAME="GenClass_4.htm_IX_HINT_CAN_CLIP_MONIKER_HEIGHT">
 </A>
<A NAME="GenClass_4.htm_IX_HINT_CAN_CLIP_MONIKER_WIDTH">
 </A>
 and HINT_CAN_CLIP_MONIKER_HEIGHT instruct the specific UI to clip the object's moniker height or width if not enough space is provided for them. Objects with HINT_SHOW_ENTIRE_MONIKER will force the object to leave enough space to show its entire moniker, if possible.</P>
<P>
HINT_GADGET_BACKGROUND_COLORS<A NAME="GenClass_4.htm_IX_HINT_GADGET_BACKGROUND_COLORS">
 </A>
 causes grouping objects in toolboxes to draw custom background colors. The hint takes an argument of type <CODE>
BackgroundColors</CODE>
. Two colors can each be chosen for both the unselected state and the selected state; they will be blended together depending on the state of the object. If both colors are set to the same value, a solid color results. HINT_GADGET_TEXT_COLOR<A NAME="GenClass_4.htm_IX_HINT_GADGET_TEXT_COLOR">
 </A>
 selects the text color of a visual moniker, typically within a toolbox. This hint takes an argument of type <CODE>
TextColors</CODE>
.</P>
<P>
HINT_IF_SYSTEM_ATTRS<A NAME="GenClass_4.htm_IX_HINT_ELSE">
 </A>
<A NAME="GenClass_4.htm_IX_HINT_ENDIF">
 </A>
<A NAME="GenClass_4.htm_IX_HINT_IF_SYSTEM_ATTRS">
 </A>
, HINT_ENDIF, and HINT_ELSE may be used together to conditionally add hints to an object based on certain system criteria. If the <CODE>
SystemAttrs</CODE>
 set in the HINT_IF_SYSTEM_ATTRS field are true for the current system, then the hints that follow (until a HINT_ENDIF is encountered) are included. If no HINT_ENDIF is encountered, then only the next hint is included. If the <CODE>
SystemAttrs</CODE>
 do not match the current system, the following group of hints is deleted. For more information, see <A HREF="#GenClass_15.htm_11736"> System Attributes</A>
.</P>
<P>
Remember that these vardata entries are hints; they can be ignored by the specific UI and their implementation varies from object to object. Some hints, for example, are only relevant for certain object classes. Your mileage may vary.</P>

<HR>
<A NAME="GenClass_5.htm"></A>


<H2 CLASS="sectionTitle">
<A HREF="#index.htm">GenClass</A>: 3 
<A NAME="GenClass_5.htm_24436">
 </A>
GenClass Basics</H2>
<P>
In most cases, you will set much of your generic object's instance data upon instantiation according to the values you include in your <CODE>
.goc</CODE>
 file. You may also update and manipulate this instance data during execution with a variety of messages. The following section deals only with directly setting instance fields in your <CODE>
.goc</CODE>
 file. For information on dynamically altering this instance data, see <A HREF="#GenClass_b.htm_26151"> Modifying GenClass Instance Data</A>
.</P>
<P CLASS="subsectionLink">
<A HREF="#GenClass_6.htm">Visual Monikers</A></P>
<P CLASS="subsectionLink">
<A HREF="#GenClass_7.htm">Composite Links</A></P>
<P CLASS="subsectionLink">
<A HREF="#GenClass_8.htm">Keyboard Accelerators</A></P>
<P CLASS="subsectionLink">
<A HREF="#GenClass_9.htm">Attributes</A></P>
<P CLASS="subsectionLink">
<A HREF="#GenClass_a.htm">States</A></P>
<HR>
<A NAME="GenClass_6.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">GenClass</A>: 3.1 <A HREF="#GenClass_5.htm">GenClass Basics</A>: 
<A NAME="GenClass_6.htm_10323">
 </A>
Visual Monikers</H3>
<P>
<A NAME="GenClass_6.htm_IX_GI_visMoniker">
 </A>
<A NAME="GenClass_6.htm_IX_Monikers">
 </A>
A visual moniker is a text or graphics string attached to a generic object. This visual moniker displays the given string in a manner relevant to the specific implementation of an object. For example, a GenTrigger might create a button with text inserted as the object's main visual implementation. The visual moniker in this case might cover the object's total area. A GenPrimary, on the other hand, might only add such text in a title bar of the window. In all cases, the specific user interface has final control over how a visual moniker is displayed to the user.
<IMG SRC="GenClass_6_monikers.gif">

</P>

<H4 CLASS="HeadingC">
Simple Visual Monikers</H4>
<P>
<A NAME="GenClass_6.htm_IX_@visMoniker">
 </A>
You may set the visual moniker of an object using the <CODE>
GI_visMoniker</CODE>
 instance field. This instance field expects an argument of type <CODE>
@visMoniker</CODE>
. The visual moniker of an object is not actually stored within this instance field, however. The visual moniker of an object is stored within its own chunk, outside of the object itself. The <CODE>
GI_visMoniker</CODE>
 instance field contains a chunk handle to this visual moniker chunk. Because a visual moniker can only be referenced by a chunk handle, visual monikers for an object must reside in the same block as the object that points to them. The UI will set up this chunk and chunk handle automatically.</P>
<P>
Within the object's definition, set the <CODE>
GI_visMoniker </CODE>
field to the desired visual moniker (either a text or graphics string). This can be done either by directly setting the <CODE>
GI_visMoniker</CODE>
 field to the string or by indirectly setting the field to a visual moniker chunk defined elsewhere within your user interface with the Goc keyword <CODE>
@visMoniker</CODE>
. (See <A HREF="#GenClass_6.htm_88023"> Setting Visual Monikers</A>
.)</P>
<P CLASS="figTitle">
Code Display 2-5 <A NAME="GenClass_6.htm_88023">
 </A>
Setting Visual Monikers</P>
<PRE>/* A visual moniker can be set directly within the object's definition. */</PRE>
<PRE>@object GenTriggerClass MyTrigger = {
    GI_visMoniker = &quot;Push Me&quot;;
}</PRE>
<PRE>/* A visual moniker may also be defined indirectly within a .goc file. */</PRE>
<PRE>/* The data for MyMoniker is set using the Goc keyword @visMoniker. This moniker
 * must reside in the same resource block as the object using it. This moniker
 * should be declared before being used in an object declaration. */</PRE>
<PRE>@visMoniker MyMoniker = &quot;Push Me&quot;;</PRE>
<PRE>@object GenTriggerClass MyTrigger = {
    GI_visMoniker = @MyMoniker;
}</PRE>
<P>
Remember that the <CODE>
GI_visMoniker</CODE>
 instance field only stores a chunk handle to the actual string. The visual moniker for the object is not contained in the object chunk itself.</P>
<P>
<A NAME="GenClass_6.htm_IX_Keyboard shortcuts:mnemonics">
 </A>
Text monikers may also specify a character to act as a mnemonic. Mnemonics are keyboard shortcuts used to activate an object without use of the mouse. Menus, menu items, and buttons frequently have mnemonic characters attached. This allows a user to navigate quickly to other UI objects or to activate them. If the specified character is within the text moniker, that letter will be highlighted in whatever fashion the specific UI decides is relevant. For instance, in OSF/Motif, mnemonic characters are underlined.</P>
<P>
Usually the first letter of the text moniker is used for the mnemonic, though any character may be used. The specific UI will underline the first such occurrence of the character within the text moniker. If the character is not within the text itself, the specific UI may place the character within parentheses at the end of the text moniker. Mnemonics are activated according to specifications in the specific UI. In OSF/Motif, pressing the ALT key puts the user interface into its keyboard navigation mode. In this mode, all mnemonics for objects in the focus are activated by pressing the character of the mnemonic without need of an additional keystroke.
<IMG SRC="GenClass_6_mnemonics.gif">

</P>
<P>
Mnemonics are set by enclosing the desired character in single quotes before the text string in your instance data. Mnemonics are case specific when defined. For example, if a visual moniker is the text &quot;File,&quot; only an uppercase mnemonic of F would highlight the first character in the text. Mnemonics are <EM>
not</EM>
 case specific in their activation methods, however. For example, either <EM>
alt</EM>
-f or <EM>
alt</EM>
-F will activate a keyboard mnemonic of F. </P>
<P>
Mnemonics are only valid for an object if that object is visually displayed and currently has the focus (see <A HREF="../../SysObjects/Input/combo.htm">the Input chapter</A>). Therefore, you may duplicate mnemonics for objects that will not exist at the same focus level. (An example of objects at the same focus level would be objects within the same menu.) Be careful not to duplicate the same mnemonic within the same focus level, as the UI will only associate the mnemonic with the first object that matches it.</P><P>
The mnemonic may also store one of the following constants:</P>
<DL>
<DT>
VMO_CANCEL corresponds to the specific UI defined cancel mnemonic. Use this rather than a special cancel mnemonic of your own choosing to keep the UI consistent.</DT>
<DT>
VMO_MNEMONIC_NOT_IN_MKR_TEXT indicates that the mnemonic occurs after the null-terminator for the moniker text. This moniker is itself not null-terminated.</DT>
<DT>
VMO_NO_MNEMONIC indicates that this moniker contains no mnemonic.</DT>
</DL>
<P>
If you need other functionality that requires keyboard control of some form and mnemonics are not satisfactory, see <A HREF="#GenClass_8.htm_77927"> Keyboard Accelerators</A>
.</P>
<P CLASS="figTitle">
Code Display 2-6 Setting Mnemonic Characters</P>
<PRE>/* Mnemonics are case specific. If the following example enclosed f instead of
 * F within single quotes, then the character f in parentheses would follow the
 * text &quot;File.&quot; Note that this case specificity does not apply to the user's
 * activation of the object. That is, alt f will activate a mnemonic of F. */</PRE>
<PRE>@object MyTrigger GenTriggerClass {
    GI_visMoniker = `F', &quot;File&quot;;
}</PRE>
<PRE>/* You can also specify the character to highlight with an actual numerical
 * position, counting from a zero-based (1st character is 0, 2nd character is 1,
 * etc.) character position in the text string. The &quot;5&quot; in the following example
 * will underline the F character (the sixth character in the text string.) */</PRE>
<PRE>    GI_visMoniker = 5, &quot;Open File&quot;;</PRE>


<H4 CLASS="HeadingC">
Graphics String Visual Monikers</H4>
<P>
The GI_<CODE>
visMoniker</CODE>
 instance field recognizes several keywords. These keywords are listed below and are usually only used in the construction of gstring visual monikers. </P>
<UL>
<LI>
style = { <EM>
text</EM>
, <EM>
abbrevText</EM>
, <EM>
graphicText</EM>
, <EM>
icon</EM>
, <EM>
tool</EM>
 }<BR>
This keyword specifies the <CODE>
VMStyle</CODE>
 in use by this visual moniker.<BR>
<BR>
<EM>
text</EM>
                             Normal text moniker<BR>
<EM>
abbrevText</EM>
          Abbreviated text moniker (i.e., a short textual <BR>
                                     description rather than the full title). This is used <BR>
                                     for the name under an icon of an iconified <BR>
                                     GenPrimary.<BR>
<EM>
graphicText</EM>
         Textual gstring<BR>
<EM>
icon</EM>
                           Normal gstring moniker<BR>
<EM>
tool</EM>
                            Moniker for a tool, usually smaller than a standard <BR>
                                     visual moniker</LI>
<LI>
size = { <EM>
tiny</EM>
, <EM>
standard</EM>
, <EM>
large</EM>
, <EM>
huge</EM>
 }<BR>
This keyword specifies the <CODE>
DisplaySize</CODE>
 that this moniker is intended for. It has nothing to do with the actual size of the moniker, which can be set with the keyword `cachedSize.' Each size corresponds to a display type's resolution level. <BR>
<BR>
<EM>
tiny</EM>
                                Tiny screens: CGA, 256x320.<BR>
<EM>
standard</EM>
                     Standard screens: EGA, VGA, HGC, MCGA<BR>
<EM>
large</EM>
                              Large screens: 800x680 SVGA<BR>
<EM>
huge</EM>
                              Huge screens<BR>
<BR>
You should not, in general, use monikers whose sizes are larger than their intended display type. (I.e. using `huge' sized monikers on VGA screens.) You may use smaller monikers on larger screens, however.</LI>
<LI>
color = { <EM>
gray1</EM>
, <EM>
gray2</EM>
, <EM>
gray4</EM>
, <EM>
gray8</EM>
, <EM>
color2</EM>
, <EM>
color4</EM>
, <EM>
colorRGB</EM>
 }<BR>
This keyword specifies the color capability of the display that this setting is intended for. Each setting corresponds to a <CODE>
DisplayClass</CODE>
.<BR>
<BR>
<EM>
gray1</EM>
                            1 bit/pixel gray scale<BR>
<EM>
gray2</EM>
                            2 bit/pixel gray scale<BR>
<EM>
gray4</EM>
                            4 bit/pixel gray scale<BR>
<EM>
gray8</EM>
                            8 bit/pixel gray scale<BR>
<EM>
color2</EM>
                           2 bit/pixel color index<BR>
<EM>
color4</EM>
                           4 bit/pixel color index<BR>
<EM>
color</EM>
RGB                    color with RGB values</LI>
<LI>
aspectRatio = { <EM>
normal</EM>
, <EM>
squished</EM>
, <EM>
verySquished</EM>
 }<BR>
This keyword specifies the aspect ratio of the display that this moniker is intended for.<BR>
<BR>
<EM>
normal</EM>
                        VGA, MCGA<BR>
<EM>
squished</EM>
                     EGA, HGC (though normal is usually used)<BR>
<EM>
verySquished</EM>
             CGA</LI>
<LI>
cachedSize = { <EM>
X</EM>
, <EM>
Y</EM>
 }<BR>
This keyword sets the cached size (pixel by pixel) of the moniker.</LI>
<LI>
gstring { &lt;<EM>
GString OpCodes</EM>
&gt; }<BR>
This keyword stores the gstring operations used in creating the visual moniker. These operations may also specify the creation of a bitmap by using the <CODE>
Bitmap</CODE>
 operator.</LI>
</UL>
<P CLASS="figTitle">
Code Display 2-7 Examples of GString Visual Monikers</P>
<PRE>/* A Graphics string consisting of GString opcodes. */
    GI_visMoniker = {
<EM>	</EM>size = tiny;
	color = color4;
	aspectRatio = normal;
	cachedSize = 15,15;
	gstring{
	    GSSaveTransform(),
	    GSApplyRotation(45),
	    GSFillEllipse(0,0,10,15),
	    GSRestoreTransform(),
	    GSDrawEllipse(0,0,10,15),
	    GSEndString()
	}
    }</PRE>
<PRE>/* A Graphics string containing a bitmap. */
@visMoniker MyBitmap = {
	style = icon;
	size = standard;
	color = color4;
	aspectRatio = normal;
	cachedSize = 64, 40;
	gstring {
	    GSDrawBitmapAtCP(166),
	    Bitmap (64,40,BMC_PACKBITS, (BMT_MASK|BMF_4BIT)),
	    251, 0,
	    233, 221,
	    ...,
	    GSEndString()
	}
    }</PRE>


<H4 CLASS="HeadingC">
Visual Moniker Lists</H4>
<P>
In some cases, an application may wish to use different visual monikers under specific circumstances. For example, a GenApplication's icon may need separate graphics strings for different display types (VGA, SVGA, etc.) In such cases, the argument for the moniker instance field should be given as a list of separate and distinct visual monikers. (See <A HREF="#GenClass_6.htm_97070"> Simple Lists</A>
.)</P>
<P>
You may then place each of these monikers within its own separate resource. Because only one moniker will be selected from the list, only one resource will be loaded into the object block, thereby conserving memory. When the application selects its appropriate moniker, the list will be replaced with the specific moniker, copied into the object block. The system performs this function automatically.</P>
<P CLASS="figTitle">
Code Display 2-8 <A NAME="GenClass_6.htm_97070">
 </A>
Simple Lists</P>
<PRE>/* A list of monikers. */
    GI_visMoniker = list {
			@moniker1, 
			@moniker2, 
			@moniker3
		}</PRE>
<PRE>/* If several monikers are specified in a list, they must be explicitly defined
 * somewhere else. If these monikers are complicated (as in the case of graphics
 * strings) they should each reside within their own resource because they will be
 * loaded in only once per application run. (Those that will be used together can
 * be within the same resource.) For example, in GEOS, several monikers
 * pertaining to different display types would be placed within separate resources.
 * When the appropriate moniker is selected, the list will be replaced with the
 * specific moniker. */</PRE>
<PRE>@start AppMonikerOneResource, notDetachable;</PRE>
<PRE>@visMoniker moniker1 = {
    size = large;
    color = color4;
    aspectRatio = normal;
    cachedSize = 64, 40;
    gstring {<EM>gstring data</EM>}
}</PRE>
<PRE>@end AppMonikerOneResource;</PRE>
<PRE>/* That moniker could then be declared within the object's instance data. */
@object GenPrimaryClass MyObject = {
    GI_visMoniker = list { @moniker1 }
}</PRE>
<PRE>/*
 * The GenApplication object usually contains a moniker list that allows the 
 * specific UI to select a moniker based on the display.
 */
@object GenApplicationClass MyApplication = {
    GI_visMoniker = list {
	@TrigTextMoniker,			/* a simple text string */
	@TrigLCMoniker,			/* Large Color */
	@TrigLMMoniker,			/* Large Mono */
	@TrigSCMoniker,			/* Small Color */
	@TrigSMMoniker,			/* Small Mono */
	@TrigLCGAMoniker,			/* Large CGA */
	@TrigSCGAMoniker			/* Small CGA */
    }
}</PRE>
<PRE>@visMoniker TrigTextMoniker = &quot;Push Me&quot;;</PRE>
<PRE>/* Graphics monikers might then appear within their own resource block. This
 * enables efficient memory management. */</PRE>
<PRE>@start AppMonikerResource, notDetachable;</PRE>
<PRE>@visMoniker TrigLCMoniker = {
    style = icon;
    size = large;
    color = color4;
    aspectRatio = normal;
    cachedSize = 64, 40;
    gstring {
	GSDrawBitmapAtCP(166),
	Bitmap (64,40,BMC_PACKBITS, (BMT_MASK|BMF_4BIT)),
	/*** insert Bitmap here ***/
	GSEndString()
    }
}</PRE>
<PRE>@end AppMonikerResource</PRE>


<H4 CLASS="HeadingC">
The Inner Workings of Visual Monikers</H4>
<P>
The following section explains the inner workings of visual monikers within GEOS. It is not necessary to understand many of these concepts but it is illustrative of the system, and may aid in debugging and custom moniker use.</P>
<P>
<CODE>
GI_visMoniker</CODE>
 can take several types and combinations of arguments, all involving either text or graphics strings. Specifically, <CODE>
GI_visMoniker</CODE>
 may indicate the following:</P>
<DL>
<DT>
	1) a simple text string</DT><DD>
2) a text string with a mnemonic character<BR>
3) a graphics string consisting of GString opcodes<BR>
4) a graphics string containing a bitmap<BR>
5) a list of monikers of any type above.</DD>
</DL>
<P>
Each of these arguments can be set up with the <CODE>
@visMoniker</CODE>
 Goc keyword, but each will store their data in different manners. GEOS automatically sets up the visual moniker in the correct format.</P>
<P>
All visual monikers make use of the <CODE>
VisMoniker</CODE>
 structure. This basic structure indicates whether the moniker is text, a gstring, or a list of several types.</P>
<P CLASS="figTitle">
Code Display 2-9 The Basic VisMoniker Structure</P>
<PRE>/* The Basic VisMoniker structure contains a header which describes the type of 
 * VisMoniker (VisMonikerType) and stores the cached width (width in pixels) of the 
 * VisMoniker. The actual visual moniker data (either text or a gstring) follows
 * this header. 
 *
 * If the visual moniker is text, this VisMoniker structure is contained within a
 * VisMonikerWithText structure. If the visual moniker is a gstring, this 
 * VisMoniker structure is contained within a VisMonikerWithGString structure.*/</PRE>
<PRE>typedef struct {
    byte		VM_type;		/* VisMonikerType */
    word		VM_width;		/* Cached width of moniker */
} VisMoniker;</PRE>
<PRE>/* VisMonikerType specifies the type of moniker contained in the VisMoniker 
 * structure. 
 *
 * The flag VMT_MONIKER_LIST is actually a dummy flag. (This flag is never set
 * within a VisMoniker structure.) VisMonikerListEntryType has a matching flag 
 * in the same location (VMLET_MONIKER_LIST). If that flag is set, it tells the 
 * system that this isn't actually a VisMoniker structure but is instead a
 * VisMonikerListEntry. This is used in moniker lists (see below). 
 *
 * The flag VMT_GSTRING is set if the visual moniker is in the form of a gstring 
 * instead of a simple text string. If this flag is set, VMT_GS_ASPECT_RATIO and
 * VMT_GS_COLOR specify the DisplayAspectRatio and DisplayClass used by this
 * gstring. 
 */</PRE>
<PRE>typedef ByteFlags VisMonikerType;
#define VMT_MONIKER_LIST				0x80
#define VMT_GSTRING				0x40
#define VMT_GS_ASPECT_RATIO				0x30	/* DisplayAspectRatio */
#define VMT_GS_COLOR				0x0f	/* Color */</PRE>
<PRE>#define VMT_GS_ASPECT_RATIO_OFFSET 4
#define VMT_GS_COLOR_OFFSET 0</PRE>
<P>
If the visual moniker is a simple text string, the ChunkHandle within GI_<CODE>
visMoniker</CODE>
 will point to a chunk containing a <CODE>
VisMonikerWithText</CODE>
 structure. This chunk will contain the basic <CODE>
VisMoniker</CODE>
 header, along with the moniker's mnemonic character and a null-terminated text-string.
<IMG SRC="GenClass_6_monikerStruct.gif">

</P>
<P CLASS="figTitle">
Code Display 2-10 VisMonikers With Text</P>
<PRE>/* If the VisMoniker contains simple text, the ChunkHandle within GI_visMoniker 
 * points to a VisMonikerWithText structure. This structure contains the 
 * basic VisMoniker header and the character of the mnemonic. (A value of -1 is 
 * stored in VMWT_mnemonicOffset if there is no mnemonic for this visual moniker.) 
 */</PRE>
<PRE>typedef struct {
    VisMoniker		VMWT_common;
    char		VMWT_mnemonicOffset;
} VisMonikerWithText;</PRE>
<PRE>/* The text, in the form of a null-terminated text string, follows this structure. 
 * This text may be accessed with the VMWT_text offset. */</PRE>
<PRE>#define VMWT_text		(sizeof(VisMonikerWithText)) /* Start of text. */</PRE>
<P>
If the visual moniker is a gstring, the ChunkHandle within GI_<CODE>
visMoniker</CODE>
 will point to a <CODE>
VisMonikerWithGString</CODE>
 structure instead. This structure will contain the basic <CODE>
VisMoniker</CODE>
 header, along with the moniker's cached height and the actual gstring. (The cached width is stored within the <CODE>
VisMoniker</CODE>
 header.)
<IMG SRC="GenClass_6_gstringMonikerStruct.gif">

</P>
<P CLASS="figTitle">
Code Display 2-11 VisMonikers With GStrings</P>
<PRE>/* If the VisMoniker contains a gstring, the ChunkHandle within GI_visMoniker 
 * points to a VisMonikerWithGString structure. This structure contains the 
 * basic VisMoniker header and the cached height of the gstring. (The cached width 
 * is stored within the VisMoniker structure.
 */</PRE>
<PRE>typedef struct {
    VisMoniker		VMWGS_common;
    word		VMWGS_height;
} VisMonikerWithGSTring;</PRE>
<PRE>/* The gstring follows this structure.This gstring may be accessed (though it is 
 * not recommended) with the VMWGS_gString offset. */</PRE>
<PRE>#define VMWGS_gString		(sizeof(VisMonikerWithGString)) /* Start of gstring. */</PRE>
<P>
If instead of a single visual moniker, be it a text string or a gstring, GI_<CODE>
visMoniker</CODE>
 specifies a list of monikers, the case is more complex.</P>
<P>
If GI_<CODE>
visMoniker</CODE>
 contains a list of monikers, that ChunkHandle will point to a group of <CODE>
VisMonikerListEntry</CODE>
 structures (one for each moniker in the list). Each of these list entries will contain the type of moniker it references and the optr of the moniker it refers to. The actual moniker itself is not stored in that chunk. Also, because the moniker may be referred to by an optr, the actual visual monikers may reside in separate resources.
<IMG SRC="GenClass_6_monikerListStruct.gif">

</P>
<P>
When the object containing the moniker list is first built, the system will select one of the monikers in the list (based on matching criteria in the VMLE_<CODE>
type</CODE>
 field) and replace the moniker list with the single selected visual moniker.</P>
<P CLASS="figTitle">
Code Display 2-12 VisMoniker Lists</P>
<PRE>/* If GI_visMoniker contains a list of monikers instead of a single moniker, the 
 * ChunkHandle of that instance field actually points to a collection of 
 * VisMonikerListEntry structures. (The total number can be calculated by dividing 
 * the size of the chunk by sizeof(VisMonikerListEntry) if needed.)
 *
 * Each VisMonikerListEntry structure contains a header which describes the type of 
 * VisMoniker stored in that list entry (VisMonikerListEntryType) and the optr of 
 * the stored moniker. The actual moniker may reside in a different resource. */</PRE>
<PRE>typedef struct {
    word		VMLE_type;
    optr		VMLE_moniker;
} VisMonikerListEntry;</PRE>
<PRE>/* VisMonikerListEntryType specifies the type of moniker specified in the 
 * VisMonikerListEntry structure. 
 *
 * The flag VMLET_MONIKER_LIST must be set within this structure. This flag tells
 * the system that this isn't actually a VisMoniker structure but is instead a
 * VisMonikerListEntry.
 *
 * The system uses the other flags in this structure to determine the type of 
 * moniker contained as the list entry. The system will use this information to
 * select the most appropriate moniker that will satisfy the system's needs. This
 * method is used most often in the selection of a GenPrimary's main application 
 * moniker based on the DisplaySize of the system.
 * 
 * VMLET_GS_SIZE stores the DisplaySize that this moniker is most appropriate for. 
 * This DisplaySize is set using the &quot;size&quot; entry within the visual moniker 
 * declaration.
 *
 * VMLET_STYLE stores the VMStyle that this moniker most closely matches. This 
 * VMStyle is set using the &quot;style&quot; entry within the visual moniker declaration.
 *
 * VMLET_GSTRING specifies that this moniker list entry is in the form of a gstring
 * If this flag is set, VMLET_GS_ASPECT_RATIO and VMLET_GS_COLOR specify the 
 * DisplayAspectRatio and DisplayClass used by this gstring.
 */</PRE>
<PRE>typedef ByteFlags VisMonikerListEntryType;
#define VMLET_GS_SIZE				0x0300 	/* DisplaySize. */
#define VMLET_STYLE				0x0f00	/* VMStyle */
#define VMLET_MONIKER_LIST				0x0080
#define VMLET_GSTRING				0x0040
#define VMLET_GS_ASPECT_RATIO				0x0030	/* DisplayAspectRatio */
#define VMLET_GS_COLOR				0x000f	/* DisplayClass */</PRE>
<PRE>#define VMLET_GS_SIZE_OFFSET	12
#define VMLET_STYLE_OFFSET 8
#define VMLET_GS_ASPECT_RATIO_OFFSET 4
#define VMLET_GS_COLOR_OFFSET 0</PRE>
<PRE>/* VMStyle specifies the style of the visual moniker. The system may select a 
 * moniker based on the style it wishes to display. */</PRE>
<PRE>typedef ByteEnum VMStyle;
#define VMS_TEXT 0				/* Simple text */
#define VMS_ABBREV_TEXT 1				/* Abbreviated text */
#define VMS_GRAPHIC_TEXT 2				/* Textual graphics string */
#define VMS_ICON 3				/* Normal gstring */
#define VMS_TOOL 4				/* Tool-sized gstring */</PRE>
<P>
For information on manipulating visual monikers dynamically using <CODE>
GenClass</CODE>
 messages, see <A HREF="#GenClass_d.htm_97676"> Managing Visual Monikers</A>
.</P>

<HR>
<A NAME="GenClass_7.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">GenClass</A>: 3.2 <A HREF="#GenClass_5.htm">GenClass Basics</A>: 
<A NAME="GenClass_7.htm_38463">
 </A>
Composite Links</H3>
<P>
<A NAME="GenClass_7.htm_IX_GI_comp">
 </A>
Composite links form the connections between parent objects and child objects within a generic tree (see <A HREF="../../UI/UIOverview/combo.htm">the UI Overview</A>). These links are set up using the <CODE>GI_comp</CODE>
 and <CODE>
GI_link</CODE>
 instance fields. The <CODE>
GI_comp</CODE>
 field points to an object's first child. The <CODE>
GI_link</CODE>
 field points to an object's next sibling or to its parent if no next sibling exists. In Goc, however, this usage is greatly simplified. The developer only needs to set the <CODE>
GI_comp</CODE>
 field equal to its complete list of children for the parent object. The Goc preprocessor will then create and reassign all necessary links.</P>
<P CLASS="figTitle">
Code Display 2-13 Using GI_comp to Add Children</P>
<PRE>/* The GenInteraction (MyInteraction) acts as the parent object for the three
 * child GenTriggers. All three GenTrigger children will be placed within the
 * GenInteraction object. */</PRE>
<PRE>@object GenInteractionClass MyInteraction = {
    GI_visMoniker = &quot;Menu&quot;;						 /* Text Moniker */
    GII_visibility = GIV_POPUP;						 /* Creates a Menu */
    GI_comp = @MyFirstChild, @MySecondChild, @MyThirdChild;
						/* list of children */
}</PRE>
<PRE>@object GenTriggerClass MyFirstChild= {
    GI_visMoniker = &quot;Child 1&quot;;					/* Text Moniker */
}</PRE>
<PRE>@object GenTriggerClass MySecondChild = {
    GI_visMoniker = &quot;Child 2&quot;;					/* Text Moniker */
}</PRE>
<PRE>@object GenTriggerClass MyThirdChild = {
    GI_visMoniker = &quot;Child 3&quot;;					/* Text Moniker */
}</PRE>
<P>
This simple functionality is all you need to know to add children to your generic objects (and thus to create generic trees). However, it is somewhat helpful in certain cases (as in debugging) to understand what takes place underneath the surface. When an object in GEOS is assigned children, the preprocessor actually only assigns one composite link (<CODE>
GI_comp</CODE>
) to the first child. Each additional child acquires a link from its previous sibling using the internal instance field <CODE>
GI_link</CODE>
. Therefore, the parent will have a <CODE>
GI_comp</CODE>
 to its first child, the first child will have a <CODE>
GI_link</CODE>
 to the next sibling (the parent's second child) and so forth. The last sibling (the parent's last child) will have a <CODE>
GI_link</CODE>
 back to the parent. This <CODE>
GI_link</CODE>
 will have the LF_IS_PARENT bit set to indicate that the child points to a parent and not to a sibling. This forms what amounts to a circular linked list rather than a branching tree structure. (See the figure below.)</P>
<P>
This structure provides a simple and convenient usage. Any object will always have at most two links to other children or parent objects. Therefore the two instance fields <CODE>
GI_comp</CODE>
 and <CODE>
GI_link</CODE>
 provide the entire means of constructing a generic tree.
<IMG SRC="GenClass_7_genTreeDump.gif">

</P>
<P>
You can travel anywhere in the generic tree through these two links. For example, for MyInteraction to communicate with MyThirdChild, it follows the path of the <CODE>
GI_comp</CODE>
 to the first child, MyFirstChild, and then continues through the two <CODE>
GI_link</CODE>
s to the third child. Conversely, a child can reach a parent by travelling along the <CODE>
GI_link</CODE>
s of siblings until it reaches the last sibling, whose <CODE>
GI_link</CODE>
 points to its parent object.
<IMG SRC="GenClass_7_genTree.gif">

</P>
<P>
<CODE>
GenClass </CODE>
message handlers provide several means of pointing to the proper parent/child object without needing to explicitly state the proper <CODE>
GI_comp</CODE>
 and <CODE>
GI_link </CODE>
paths. In practice, you will never need to, and in fact should not, manipulate the <CODE>
GI_link</CODE>
 field at all. This information is provided merely for your use in debugging your applications. In fact, you can usually assume that a conventional branching tree structure exists rather than the linked-list tree structure shown here.</P>
<P>
For information on manipulating these links dynamically using <CODE>
GenClass</CODE>
 messages, see <A HREF="#GenClass_f.htm_15521"> Generic Trees</A>
.</P>
<HR>
<A NAME="GenClass_8.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">GenClass</A>: 3.3 <A HREF="#GenClass_5.htm">GenClass Basics</A>: 
<A NAME="GenClass_8.htm_77927">
 </A>
Keyboard Accelerators</H3>
<P>
<A NAME="GenClass_8.htm_IX_Keyboard accelerators">
 </A>
Keyboard accelerators permit the user to activate objects without the use of default activations in the specific UI. (Much of the default activations in most graphical user interfaces use the mouse, for example.) In most cases, these keyboard accelerators require the use of a modifier (the <EM>
alt</EM>
, <EM>
shift</EM>
 or <EM>
ctrl</EM>
 key) and another key. The keyboard accelerator may also be a function key (F10, etc.). In general, you should avoid using the <EM>
alt</EM>
 key because of its special role as a keyboard mnemonic within a visual moniker (see <A HREF="#GenClass_6.htm_10323"> Visual Monikers</A>
).
<IMG SRC="GenClass_8_kbdAccelDump.gif">

</P>
<P>
Keyboard accelerators may be activated at any time; they are valid at any point within the application whether the generic object involved is being displayed currently or not. (The only exception to this is during the display of a modal dialog box, which will block input to any other part of the application.) The system will search through the generic tree for the object containing the proper key sequence. In this manner, accelerators differ from mnemonics, which are only valid for an active level. Therefore, only use keyboard accelerators for heavily utilized commands; this prevents a glut of modified keystrokes, which may confuse the user. In general, it is good practice to use the &quot;control&quot; key exclusively for keyboard accelerators to prevent overlapping with GEOS keyboard acclelators and mnemonics.
<IMG SRC="GenClass_8_kbdAccelValid.gif">

</P>
<P>
You can set up keyboard accelerators using the <CODE>
GI_kbdAccelerator</CODE>
 attribute. A keyboard accelerator must contain a valid modifier such as <EM>
alt</EM>
, <EM>
shift</EM>
, <EM>
control</EM>
, or <EM>
ctrl</EM>
. You may use any alpha-numeric character as the action key for the modifier to act on. In addition to alpha-numeric characters, the action keys shown above are also available.</P>
<P>
The specific UI has final control over how and whether a keyboard accelerator will be implemented. Currently, keyboard accelerators will only work for<CODE>
 </CODE>
GenTriggers and GenItems. In most cases, a keyboard accelerator will be displayed alongside the text for the visual moniker of an object. In OSF/Motif, keyboard accelerators are shown to the right of menu items and to the left of other items). You may add <CODE>
HINT_DRAW_SHORTCUT_BELOW</CODE>
<A NAME="GenClass_8.htm_IX_HINT_DRAW_SHORTCUT_BELOW">
 </A>
 on non-menu items to draw the keyboard accelerator below the object's visual moniker.</P>
<P CLASS="figTitle">
Code Display 2-14 <A NAME="GenClass_8.htm_91964">
 </A>
Using a Keyboard Accelerator</P>
<PRE>@object GenTriggerClass MyTrigger = {
	/* Case is ignored for keyboard accelerators. */
    GI_kbdAccelerator = ctrl `R';					/* `ctrl' and `control' are both valid. */
}</PRE>
<PRE>/ * Other examples:
    GI_kbdAccelerator = control `A';</PRE>
<PRE>   Case is ignored for keyboard accelerators (unlike mnemonics). If you need
   an uppercase `A', use `shift' as a modifier.</PRE>
<PRE>    GI_kbdAccelerator = control shift `A';
    GI_kbdAccelerator = alt `z';
    GI_kbdAccelerator = alt shift `Z';
    GI_kbdAccelerator = ctrl shift `G';</PRE>
<PRE>   If you know what specific keyboard set will be implemented, you can add such
   special characters with the @specificUI keyword, though this is discouraged.</PRE>
<PRE>    GI_kbdAccelerator = @specificUI alt shift DELETE;
    GI_kbdAccelerator = @specificUI F6;						*/</PRE>
<P>
For information on manipulating keyboard accelerators dynamically, see <A HREF="#GenClass_e.htm_56092"> Managing Keyboard Accelerators</A>
.</P>
<HR>
<A NAME="GenClass_9.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">GenClass</A>: 3.4 <A HREF="#GenClass_5.htm">GenClass Basics</A>: 
<A NAME="GenClass_9.htm_90005">
 </A>
Attributes</H3>
<PRE>GI_attrs, MSG_GEN_GET_ATTRIBUTES, MSG_GEN_SET_ATTRS</PRE>
<P>
<A NAME="GenClass_9.htm_IX_GA_&ldots;  (GenAttrs)">
 </A>
<A NAME="GenClass_9.htm_IX_GI_attrs">
 </A>
The <CODE>
GI_attrs</CODE>
 attribute is a record specifying how an object will behave under various circumstances. In some cases, the <CODE>
GI_attrs</CODE>
 instance field indicates that an object may initiate a busy state within the application. Several attributes only affect how an object will behave during activation. Prior to an object's activation, some of these attributes will not affect the object's behavior.</P>
<DL>
<DT>
GA_SIGNAL_INTERACTION_COMPLETE</DT><DD>
<A NAME="GenClass_9.htm_IX_GenInteractionClass:GA_SIGNAL_INTERACTION_COMPLETE">
 </A>
This flag instructs the UI that an Interaction has been completed. The specific UI may then decide whether to dismiss the Interaction or not. Most often, this attribute is attached to a GenTrigger within an independently displayable GenInteraction (dialog box). This attribute is useful for dismissing temporary dialogs that request information from the user. This attribute will cause the generic object to send a <CODE>
MSG_GEN_GUP_INTERACTION_COMMAND </CODE>
to its generic parent with the <CODE>
InteractionCommand</CODE>
 IC_INTERACTION_COMPLETE. This message is then passed up the generic tree until it reaches an appropriate Interaction. See <A HREF="../../UI/GenInteraction/combo.htm">the Menus and Dialog Boxes chapter</A> for more information.</DT><P CLASS="WorList">
GA_INITIATES_BUSY_STATE<BR>
<A NAME="GenClass_9.htm_IX_Busy state:mouse pointer">
 </A>
This flag instructs the UI to mark the application as busy whenever the generic object is activated. You should only set this attribute for objects that may initiate long operations. This attribute requests that the UI visually change the cursor to show that the application is busy. (In OSF/Motif this is represented by an hourglass.) When the application finishes its operation, the cursor will revert to its former state. This attribute causes the object to send <CODE>
MSG_GEN_APPLICATION_MARK_BUSY</CODE>
 to the object's application object along with <CODE>
MSG_GEN_APPLICATION_MARK_NOT_BUSY</CODE>
 sent via the process' event queue. This allows the system to process the first message (showing the busy cursor) and only process the second message (removing the busy cursor) after the application finishes its current operation. (If the action is processed quickly, the cursor will often not appear.) The busy state cursor is only reflected in the current application; if the cursor roams outside the application bounds, the default behavior will occur.</P>
<DT>
GA_INITIATES_INPUT_HOLD_UP<BR>
<A NAME="GenClass_9.htm_IX_Input:holding up">
 </A>
This flag instructs the UI to mark the application as busy and to delay processing input messages until the UI and Application queues have been flushed. The application will then complete its current operation before beginning to process its input events. You should set this attribute when an object's activation may modify the UI, thereby preventing the user from clicking on objects that may become invalid after the operation. This attribute immediately sends a <CODE>
MSG_GEN_APPLICATION_HOLD_UP_INPUT</CODE>
 to the application object along with a <CODE>
MSG_GEN_APPLICATION_RESUME_INPUT</CODE>
 delayed via the process' event queue. This functionality is only reflected in the current application; if the cursor roams outside the application bounds, the default behavior will occur.</DD>
<DT>
GA_INITIATES_INPUT_IGNORE</DT><DD>
<A NAME="GenClass_9.htm_IX_Input:ignoring">
 </A>
This flag instructs the UI to mark the application as busy and to completely ignore all subsequent input events to the application. The application will enter a <EM>
modal</EM>
 state, meaning that all other application events will be ignored until the UI and Application queues are flushed. Usually, this state is conveyed to the user by broadcasting an audible beep whenever an input event is attempted. The generic object will immediately send a <CODE>
MSG_GEN_APPLICATION_IGNORE_INPUT</CODE>
 to the application object along with a <CODE>
MSG_GEN_APPLICATION_ACCEPT_INPUT</CODE>
 delayed via the application queue. This functionality is only reflected in the current application; if the cursor roams outside the application bounds, the default behavior will occur.</DD>
<DT>
GA_READ_ONLY</DT><DD>
This flag indicates that this object's only function is to display information to the user; the user will not be able to interact with this object. This attribute is set most often in lists or text objects.</DD>
<DT>
GA_KBD_SEARCH_PATH</DT><DD>
This flag indicates that this generic branch contains objects with keyboard accelerators and should therefore be searched when evaluating such events. This attribute bit is set internally by the system. There should be no need for your application to deal with this attribute directly.</DD>
<DT>
GA_TARGETABLE</DT><DD>
<A NAME="GenClass_9.htm_IX_Target:GA_TARGETABLE">
 </A>
This flag indicates that this object is targetable and is eligible to receive the target exclusive within its target level. Most specific UIs will automatically grab the target for this object whenever the user interacts with it. This attribute is set by default within the following classes:</DD>
<DT>
	GenField</DT><DD>
GenApplication<BR>
GenPrimary<BR>
GenDisplayControl<BR>
GenDisplay<BR>
GenView </DD>
<DT>
GA_NOTIFY_VISIBILITY</DT><DD>
This flag indicates that this object should send notification when it becomes visible and not visible. Objects thus will send <CODE>
MSG_GEN_APPLICATION_VISIBILITY_NOTIFICATION</CODE>
</DL>
 to the GenApplication object whenever the state of their visibility changes (see <A HREF="../../SysObjects/GenApp/combo.htm">the GenApplication chapter</A>). You may alter this behavior by including one of the visibility vardata attributes. </DT><P CLASS="CodeTitle C">
Code Display 2-15 Using GI_attrs in a Dialog Box</P>
<PRE>@object GenInteractionClass MyDialogBox = {
    GI_comp = @MyButton, @MyOtherButton;
    GII_visibility = GIV_DIALOG;				/* build this Interaction as a dialog box.*/
}</PRE>
<PRE>@object GenTriggerClass MyButton = {
    GTI_actionMsg = MSG_MY_SPECIAL_MESSAGE;
    GTI_destination = process;
	/* MyButton, when activated, will send the message above to the
	 * process object. Only when that happens will it activate the
	 * behavior within the GI_attrs instance data below. */
    GI_attrs = @default |<EM> 
	</EM>/* This flag will close the MyDialogBox object */
	GA_SIGNAL_INTERACTION<EM>_</EM>COMPLETE |
	/* This flag will set the application to ignore all input events while the
	 * message above is processed. */
<EM>	</EM>GA_INITIATES_INPUT_IGNORE;
}</PRE>

<H6 CLASS="RefETitle">
<A NAME="GenClass_9.htm_IX_MSG_GEN_GET_ATTRIBUTES">
 </A>
MSG_GEN_GET_ATTRIBUTES</H6>
<PRE CLASS="syntax">byte	MSG_GEN_GET_ATTRIBUTES();</PRE>
<P>
This message retrieves the <CODE>
GI_attrs</CODE>
 instance data for the object the message is sent to. This message returns a byte length bitfield.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any generic object.</P>
<P CLASS="refField">
Return:	Byte length GI_<CODE>
attrs</CODE>
 bitfield.</P>
<P CLASS="refField">
Interception:	Generally not intercepted.</P>


<H6 CLASS="RefETitle">
<A NAME="GenClass_9.htm_IX_MSG_GEN_SET_ATTRS">
 </A>
MSG_GEN_SET_ATTRS</H6>
<PRE CLASS="syntax">void	MSG_GEN_SET_ATTRS(
        byte attrsToSet,
        byte attrsToClear);</PRE>
<P>
This message sets the recipient's <CODE>
GI_attrs</CODE>
 field. This message takes two arguments: the attributes to set and the attributes to clear. There is no need to repeat attributes that have been previously set. Note that these attributes will not take effect until the object is activated in the normal manner. (Sending this message does not in itself initiate the activity described).</P>
<P>
You should only send this message while an object is not GS_USABLE, because these attributes are only checked when an object is specifically built. Setting the attributes of a GS_USABLE object may cause an error.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any non-usable generic object.</P>
<P CLASS="refField">
Parameters:	<EM>
attrsToSet</EM>
	<CODE>
GenAttributes</CODE>
 to set in GI_<CODE>
attrs</CODE>
.</P>
<DL>
<DT>
<EM>
attrsToClear</EM>
	<CODE>
GenAttributes</CODE>
 to clear in GI_<CODE>
attrs</CODE>
.</DD>
</DL>
<P CLASS="refField">
Interception:	Generally not intercepted.</P>
<P CLASS="figTitle">
Code Display 2-16 Conditionally Altering the GI_attrs Field</P>
<PRE>@method MyProcessClass, MSG_DO_CUSTOM_ATTRS {
    byte MyAttrs;</PRE>
<PRE>	/* retrieve the GI_attrs field */
    MyAttrs = @call @MyObject::MSG_GEN_GET_ATTRIBUTES();</PRE>
<PRE>	/* If the GA_COMPLETES_INTERACTION bit is set, then set it 
	 * GA_INITIATES_BUSY_STATE also. Otherwise set it
	 * GA_INITIATES_INPUT_IGNORE. */</PRE>
<PRE>    if (MyAttrs &amp; GA_COMPLETES_INTERACTION){
	@call @MyObject::MSG_GEN_SET_NOT_USABLE();
	@call @MyObject::MSG_GEN_SET_ATTRS(GA_INITIATES_BUSY_STATE, 0);</PRE>
<PRE>	/* Note that setting an object's GA_INITIATES_BUSY_STATE attribute will
	 * not in itself initiate a busy state. That object will only issue a busy
	 * state when it is activated in the normal fashion. */</PRE>
<PRE>    @call @MyObject::MSG_GEN_SET_USABLE();
    } else {
	@call @MyObject::MSG_GEN_SET_NOT_USABLE();
	@call @MyObject::MSG_GEN_SET_ATTRS(GA_INITITATES_INPUT_IGNORE, 0);
	@call @MyObject::MSG_GEN_SET_USABLE();
    }
}</PRE>

<HR>
<A NAME="GenClass_a.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">GenClass</A>: 3.5 <A HREF="#GenClass_5.htm">GenClass Basics</A>: 
<A NAME="GenClass_a.htm_44040">
 </A>
States</H3>
<PRE>GI_states</PRE>
<P>
<A NAME="GenClass_a.htm_IX_GS_&ldots;  (GenStates)">
 </A>
<A NAME="GenClass_a.htm_IX_GI_states">
 </A>
The <CODE>
GI_states</CODE>
 attribute is a record that holds the state of the generic object. These states affect the object's visual representation and its functionality. By default, all objects have both GS_USABLE and GS_ENABLED set when first built. There are two <CODE>
GI_states</CODE>
:</P>
<DL>
<DT>
GS_USABLE</DT><DD>This state controls the usability of an object. Setting an object GS_USABLE will indicate that both the object and the entire generic branch below this object should be considered as an active part of the user interface and therefore should be visually represented. An object that is not set GS_USABLE cannot appear as part of the user interface. Before an object can be visually built and considered part of the user interface, however, it must satisfy two conditions: The object itself must be GS_USABLE, and all ancestors (parents) of the object must also be GS_USABLE.</DD>
<DT>
</DT><DD>This means that a continuous path of GS_USABLE objects must exist from the top node of your application to the object for it to be usable. In this case, an object is considered to be <EM>
fully</EM>
 usable. Conversely, if an object is not GS_USABLE, then no object in the branch below it can be visually displayed either (even if it is GS_USABLE). Therefore, an object may be set GS_USABLE without being fully usable. This allows you to set an entire branch fully usable by setting just one node object usable, provided that all other objects below that node had previously been set GS_USABLE. This attribute is set by default. 

</DD>
<DT>
GS_ENABLED</DT><DD>
This state sets the object enabled. This state controls whether the object is available to the user for activity. An object must be enabled for the user to interact with it. If an object is set GS_USABLE but not GS_ENABLED, it will be visually displayed but will not accept input from the user. The object will also be unable to perform its normal activities. This is usually represented by &quot;graying out&quot; the object's visual moniker. Before an object can be &quot;enabled&quot; for user input and activation, however, it must satisfy two conditions: The object must be GS_ENABLED; all ancestors (parents) of the object must also be GS_ENABLED. Therefore, a continuous path of GS_ENABLED objects must exist from the top node of your application to the object in question for it to be enabled. In this case, an object is considered to be <EM>
fully</EM>
 enabled.</DD>
<DT>
</DT><DD>Conversely, if an object is not GS_ENABLED, then no object in the branch below it can be interacted with either (even if it is GS_ENABLED). Therefore, an object may be GS_ENABLED without being fully enabled. This allows you to set an entire branch fully enabled by setting just one node object enabled, provided that all other objects below that node had previously been set GS_ENABLED. </DD>
</DL>
<P>
These states not only affect the state of the current object but all of its descendants as well. When your user interface is first built (or rebuilt) it conducts a top-down search, building any objects that are declared GS_USABLE. If an object is not GS_USABLE, it will not be visually built. Furthermore, none of its descendants will be searched (or built). Therefore, if any single node is not GS_USABLE, no other object below that node will be fully usable. </P>
<P>
In cases where you wish to alter any fundamental behavior of an object, you may have to set the object not usable, change its behavior, and then set the object GS_USABLE again. This ensures that the object is built out correctly (including visually) according to the new criteria.

</P>
<P CLASS="figTitle">
Code Display 2-17 Setting GI_states</P>
<PRE>@object GenTriggerClass MyTrigger = {
		/* The default GI_states are GS_USABLE and GS_ENABLED.
		 * This object will only be GS_USABLE */
    GI_states = @default &amp; ~GS_ENABLED;
}</PRE>

<H4 CLASS="HeadingC">
The Usable State</H4>
<PRE>MSG_GEN_GET_USABLE, MSG_GEN_SET_USABLE, MSG_GEN_SET_NOT_USABLE, MSG_GEN_CHECK_IF_FULLY_USABLE </PRE>
<P>
Setting an object GS_USABLE will incorporate the object into the generic tree and regard the object as part of the user interface. (It will not by itself enable an object for user input; this requires an object to be set GS_ENABLED also.) If an object is not GS_USABLE, it cannot be used in any manner including any visual implementation by the user interface. The following messages manipulate an object's usable state.</P>

<H6 CLASS="RefETitle">
<A NAME="GenClass_a.htm_IX_MSG_GEN_GET_USABLE">
 </A>
MSG_GEN_GET_USABLE</H6>
<PRE CLASS="syntax">Boolean	MSG_GEN_GET_USABLE();</PRE>
<P>
This message checks the GS_USABLE bit of the <CODE>
GI_states</CODE>
 field.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any generic object.</P>
<P CLASS="refField">
Parameters:	None.</P>
<P CLASS="refField">
Return:	Will return <CODE>
true</CODE>
 if the object is GS_USABLE, <CODE>
false</CODE>
 if it is not usable.</P>
<P CLASS="refField">
Interception:	Generally not intercepted.</P>


<H6 CLASS="RefETitle">
<A NAME="GenClass_a.htm_IX_MSG_GEN_SET_USABLE">
 </A>
MSG_GEN_SET_USABLE</H6>
<PRE CLASS="syntax">void	MSG_GEN_SET_USABLE(
        VisUpdateMode updateMode);</PRE>
<P>
This message sets an object GS_USABLE. (This message has no effect on an object already GS_USABLE.) Objects may be set GS_USABLE only after they have been attached to a generic tree. Setting an object usable forces that object to be specifically built. If the object's associated window is realized, the object will be visually built and updated. Setting an object GS_USABLE that is not attached to the generic tree<CODE>
 </CODE>
will cause an error.</P>
<P>
Setting an object usable allows that object to become part of the user interface. Before the object can be used, though, it must be <EM>
fully</EM>
 <EM>
usable</EM>
. An object becomes fully usable only if all of its ancestors are GS_USABLE. If any ancestor is not GS_USABLE, then the entire branch below it will not be fully usable. You can check if an object is fully usable with the message <CODE>
MSG_GEN_CHECK_IF_FULLY_USABLE</CODE>
.</P>
<P>
Conversely, setting a node GS_USABLE, in which every branch object below it is already GS_USABLE will make that entire branch fully usable. This is useful for bringing up an entire section of a generic tree by setting a single object usable.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any generic object.</P>
<P CLASS="refField">
Parameters:	<EM>
updateMode</EM>
	<CODE>
VisUpdateMode</CODE>
 to use when updating changes to the screen.</P>
<P CLASS="refField">
Return:	Nothing.</P>
<P CLASS="refField">
Interception:	Generally not intercepted.</P>


<H6 CLASS="RefETitle">
<A NAME="GenClass_a.htm_IX_MSG_GEN_SET_NOT_USABLE">
 </A>
MSG_GEN_SET_NOT_USABLE</H6>
<PRE CLASS="syntax">void	MSG_GEN_SET_NOT_USABLE(
        VisUpdateMode updateMode);</PRE>
<P>
This message sets an object not usable (clears the GS_USABLE bit). Because an object may be visually unbuilt by this message, the <CODE>
VisUpdateMode</CODE>
 VUM_MANUAL is not allowed.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any generic object.</P>
<P CLASS="refField">
Parameters:	<EM>
updateMode</EM>
	<CODE>
VisUpdateMode</CODE>
 to use when updating changes to the screen. May not be VUM_MANUAL.</P>
<P CLASS="refField">
Return:	Nothing.</P>
<P CLASS="refField">
Interception:	Generally not intercepted.</P>


<H6 CLASS="RefETitle">
<A NAME="GenClass_a.htm_IX_MSG_GEN_CHECK_IF_FULLY_USABLE">
 </A>
MSG_GEN_CHECK_IF_FULLY_USABLE</H6>
<PRE CLASS="syntax">Boolean	MSG_GEN_CHECK_IF_FULLY_USABLE();</PRE>
<P>
This message checks whether an object is fully usable. The object and all of its parents must be GS_USABLE for the object to be fully usable. </P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any generic object.</P>
<P CLASS="refField">
Return:	Will return <CODE>
true</CODE>
 if the object is fully usable, <CODE>
false</CODE>
 if it is not.</P>
<P CLASS="refField">
Interception:	Generally not intercepted.</P>



<H4 CLASS="HeadingC">
The Enabled State</H4>
<PRE>MSG_GEN_GET_ENABLED, MSG_GEN_SET_ENABLED, MSG_GEN_SET_NOT_ENABLED, MSG_GEN_CHECK_IF_FULLY_ENABLED</PRE>
<P>
An object that is GS_ENABLED is ready for user interaction. As in the case with GS_USABLE, all parents of the object in question must be GS_ENABLED to <EM>
fully</EM>
 <EM>
enable</EM>
 the object. An object may be fully enabled without being fully usable, but the object will not be visually represented. You can check if an object is fully enabled with <CODE>
MSG_GEN_CHECK_IF_FULLY_ENABLED</CODE>
. </P>
<P>
An object that is not enabled but is set usable will be represented in the user interface; it will not, however, allow the user to interact with it. In many cases, the specific UI implements this by &quot;graying out&quot; the object. Setting a disabled object will visually update it.</P>

<H6 CLASS="RefETitle">
<A NAME="GenClass_a.htm_IX_MSG_GEN_GET_ENABLED">
 </A>
MSG_GEN_GET_ENABLED</H6>
<PRE CLASS="syntax">Boolean	MSG_GEN_GET_ENABLED();</PRE>
<P>
This message returns the enabled state of the object the message is sent to.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any generic object.</P>
<P CLASS="refField">
Return:	Will return <CODE>
true</CODE>
 if the object is enabled,<CODE>
 false</CODE>
 if it is not.</P>
<P CLASS="refField">
Interception:	Generally not intercepted.</P>


<H6 CLASS="RefETitle">
<A NAME="GenClass_a.htm_IX_MSG_GEN_SET_ENABLED">
 </A>
MSG_GEN_SET_ENABLED</H6>
<PRE CLASS="syntax">void	MSG_GEN_SET_ENABLED(
        VisUpdateMode updateMode);</PRE>
<P>
This message sets an object GS_ENABLED. (This message has no effect on an object already GS_ENABLED.) You must pass this message a <CODE>
VisUpdateMode</CODE>
. Sending this message allows the object to receive user input. Only send this message if your application will be ready to interact with the object after the period specified in the <CODE>
VisUpdateMode</CODE>
 has passed.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any generic object.</P>
<P CLASS="refField">
Parameters:	<EM>
updateMode</EM>
	<CODE>
VisUpdateMode</CODE>
 to use when updating changes to the screen.</P>
<P CLASS="refField">
Interception:	Generally not intercepted.</P>


<H6 CLASS="RefETitle">
<A NAME="GenClass_a.htm_IX_MSG_GEN_SET_NOT_ENABLED">
 </A>
MSG_GEN_SET_NOT_ENABLED</H6>
<PRE CLASS="syntax">void	MSG_GEN_SET_NOT_ENABLED(
        VisUpdateMode updateMode);</PRE>
<P>
This message sets the object not enabled (clears the object's GS_ENABLED bit.) You must pass the message a <CODE>
VisUpdateMode</CODE>
. In most specific UIs a disabled state is implemented by &quot;graying out&quot; the object. The user will be unable to interact with the object according to the <CODE>
VisUpdateMode</CODE>
 passed. </P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any generic object.</P>
<P CLASS="refField">
Parameters:	<EM>
updateMode</EM>
	<CODE>
VisUpdateMode</CODE>
 to use when updating changes to the screen. May not be VUM_MANUAL.</P>
<P CLASS="refField">
Interception:	Generally not intercepted.</P>


<H6 CLASS="RefETitle">
<A NAME="GenClass_a.htm_IX_MSG_GEN_CHECK_IF_FULLY_ENABLED">
 </A>
MSG_GEN_CHECK_IF_FULLY_ENABLED</H6>
<PRE CLASS="syntax">Boolean	MSG_GEN_CHECK_IF_FULLY_ENABLED();</PRE>
<P>
This message checks whether an object is fully enabled. An object is only fully enabled (ready for user interaction) when both it and all of its ancestors are enabled.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any generic object.</P>
<P CLASS="refField">
Return:	Will return <CODE>
true</CODE>
 if fully enabled, <CODE>
false</CODE>
 if not.</P>
<P CLASS="refField">
Interception:	Generally not intercepted.</P>


<HR>
<A NAME="GenClass_b.htm"></A>


<H2 CLASS="sectionTitle">
<A HREF="#index.htm">GenClass</A>: 4 
<A NAME="GenClass_b.htm_26151">
 </A>
Modifying GenClass Instance Data</H2>
<P>
Instance data need not be set solely within your <STRONG CLASS="fileName">
.goc</STRONG>
 file. You may also retrieve or alter this data dynamically with messages in <CODE>
GenClass</CODE>
. The following section details messages to modify the <CODE>
GI_visMoniker</CODE>
, <CODE>
GI_kbdAccelerator</CODE>
, <CODE>
GI_attrs</CODE>
 and <CODE>
GI_states</CODE>
 instance fields. This section also details ways of using the variable data object routines and messages to modify a generic object's vardata.</P>
<P>
Remember that when accessing and modifying instance data, you may need to dereference the pointer to the object's instance data if the location of that instance data may have changed. This pointer (<CODE>
pself</CODE>
) is automatically set up correctly inside a method upon receipt of the corresponding message. If you perform actions within that method that may move the object, you can use <CODE>
ObjDerefGen</CODE>
() to dereference <CODE>
pself</CODE>
 again.</P>
<P>
If the instance fields you wish to modify are related to generic tree mechanisms (<CODE>
GI_comp</CODE>
 and <CODE>
GI_link</CODE>
), see <A HREF="#GenClass_17.htm_27607"> Special Message Passing</A>
.</P>
<P CLASS="subsectionLink">
<A HREF="#GenClass_c.htm">Visual Monikers</A></P>
<P CLASS="subsectionLink">
<A HREF="#GenClass_d.htm">Managing Visual Monikers</A></P>
<P CLASS="subsectionLink">
<A HREF="#GenClass_e.htm">Managing Keyboard Accelerators</A></P>
<HR>
<A NAME="GenClass_c.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">GenClass</A>: 4.1 <A HREF="#GenClass_b.htm">Modifying GenClass Instance Data</A>: 
Visual Monikers</H3>
<P>
<A NAME="GenClass_c.htm_IX_Monikers:changing">
 </A>
A visual moniker must reside in a local memory (LMem) chunk. That chunk should be located within the object block of the particular generic object it is associated with. Once monikers are defined, there are several messages in <CODE>
GenClass</CODE>
 that you can use to change the visual moniker for an object.</P>
<P>
The <CODE>
GI_visMoniker</CODE>
 field contains a ChunkHandle of the <CODE>
VisMoniker</CODE>
 structure. The <CODE>
VisMoniker</CODE>
 structure contains three pieces of data: the type of moniker, the width of the moniker chunk, and the moniker data.</P>
<HR>
<A NAME="GenClass_d.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">GenClass</A>: 4.2 <A HREF="#GenClass_b.htm">Modifying GenClass Instance Data</A>: 
<A NAME="GenClass_d.htm_97676">
 </A>
Managing Visual Monikers</H3>
<PRE>MSG_GEN_GET_VIS_MONIKER, MSG_GEN_USE_VIS_MONIKER, MSG_GEN_CREATE_VIS_MONIKER, MSG_GEN_REPLACE_VIS_MONIKER, MSG_GEN_REPLACE_VIS_MONIKER_OPTR, MSG_GEN_REPLACE_VIS_MONIKER_TEXT, MSG_GEN_FIND_MONIKER, MSG_GEN_DRAW_MONIKER, MSG_GEN_GET_MONIKER_POS, MSG_GEN_GET_MONIKER_SIZE, MSG_GEN_RELOC_MONIKER_LIST, MSG_GEN_FIND_OBJECT_WITH_TEXT_MONIKER</PRE>
<P>
Sending<CODE>
 MSG_GEN_GET_VIS_MONIKER</CODE>
 to an object returns the chunk handle of the visual moniker (<CODE>
GI_visMoniker</CODE>
) for that object. You can then inspect that visual moniker or use it within other objects (though this is not recommended). You must be careful when sharing monikers with other objects, as freeing one object (and therefore its associated moniker) will interfere with any other objects referencing that moniker.</P>
<P>
Sending<CODE>
 MSG_GEN_USE_VIS_MONIKER</CODE>
 to an object sets a visual moniker for that object to use. The message must pass the chunk handle of the moniker desired for the object along with a <CODE>
VisUpdateMode</CODE>
. Valid <CODE>
VisUpdateMode</CODE>
s are described in <A HREF="../../UI/VisClass/combo.htm">the VisClass chapter</A>. The moniker to use must reside in the same block as the object being set. If you need to set an object to use a new moniker from a location outside of its object block, use <CODE>
MSG_GEN_REPLACE_VIS_MONIKER</CODE>
 to copy the moniker to the new location.</P>
<P>
<CODE>
MSG_GEN_REPLACE_VIS_MONIKER</CODE>
 copies a visual moniker from a source location into a destination. This message must pass parameters specifying the type of copy operation. The source for the moniker can be referenced using an optr or a simple text string. Use this message when you wish to copy a moniker from outside of the object's current object block.</P>
<P>
<CODE>
MSG_GEN_REPLACE_VIS_MONIKER_OPTR</CODE>
 and <CODE>
MSG_GEN_REPLACE_VIS_MONIKER_TEXT </CODE>
are simplified versions of the above message, allowing you to set a visual moniker from an optr or from a pointer to a null-terminated text string without having to pass many other arguments. </P>
<P>
<CODE>
MSG_GEN_CREATE_VIS_MONIKER</CODE>
 creates a visual moniker (within the resource block of the object this message is sent to), copying it from a source; it does not, however, attach this moniker to any object. </P>
<P>
<CODE>
MSG_GEN_FIND_MONIKER </CODE>
searches for a specific type of moniker within a moniker list. You may then use the moniker directly. You can also replace the original moniker list with the specified moniker.</P>
<P>
<CODE>
MSG_GEN_DRAW_MONIKER, MSG_GEN_GET_MONIKER_POS</CODE>
, and <CODE>
MSG_GEN_GET_MONIKER_SIZE</CODE>
 all manipulate a currently existing moniker. These messages are most useful for custom gadgets. <CODE>
MSG_GEN_DRAW_MONIKER</CODE>
 draws the moniker according to the criteria passed with the message. <CODE>
MSG_GEN_GET_MONIKER_POS</CODE>
 and <CODE>
MSG_GEN_GET_MONIKER_SIZE</CODE>
 return <CODE>
GEOS</CODE>
 coordinates specifying the location and size of the moniker, respectively. You may then inspect and alter these coordinates before sending the moniker a <CODE>
MSG_GEN_DRAW_MONIKER</CODE>
 to redraw the moniker according to the changed criteria.</P>
<P>
The utility message <CODE>
MSG_GEN_RELOC_MONIKER_LIST</CODE>
 relocates an object's moniker list. </P>
<P>
To find an object with a particular visual moniker, send MSG_GEN_FIND_OBJECT_WITH_MONIKER_FLAGS to the object at which to start the top-down search, passing the text to perform the match.</P>

<H6 CLASS="RefETitle">
<A NAME="GenClass_d.htm_IX_MSG_GEN_GET_VIS_MONIKER">
 </A>
MSG_GEN_GET_VIS_MONIKER</H6>
<PRE CLASS="syntax">ChunkHandle	 MSG_GEN_GET_VIS_MONIKER();</PRE>
<P>
This message retrieves the instance data in the object's current <CODE>
GI_visMoniker</CODE>
 instance field. This message returns the ChunkHandle of the moniker data structure. You can then use that chunk handle to manipulate the visual moniker directly or to copy the moniker for use by other objects.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any generic object.</P>
<P CLASS="refField">
Return:	The chunk handle of the visual moniker in use by this object.</P>
<P CLASS="refField">
Interception:	Generally not intercepted.</P>


<H6 CLASS="RefETitle">
<A NAME="GenClass_d.htm_IX_MSG_GEN_USE_VIS_MONIKER">
 </A>
MSG_GEN_USE_VIS_MONIKER</H6>
<PRE CLASS="syntax">void	MSG_GEN_USE_VIS_MONIKER(
        ChunkHandle moniker,
        VisUpdateMode updateMode);</PRE>
<P>
This message allows an object to reference a visual moniker; this message does not destroy the chunk of the object's current visual moniker. The moniker must reside in the same block as the object. Use <CODE>
MSG_GEN_REPLACE_VIS_MONIKER</CODE>
 if you wish to set a moniker from a source outside the object block or if you wish to use a new moniker, overwriting the old one.</P>
<P>
You cannot pass a moniker list's chunk handle using this message. See <CODE>
MSG_GEN_FIND_MONIKER</CODE>
 for information on selecting monikers from within a list.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any generic object.</P>
<P CLASS="refField">
Parameters:	<EM>
moniker</EM>
	The chunk handle of the visual moniker to use</P>
<DL>
<DT>
<EM>
updateMode</EM>
</DT><DD><CODE>
VisUpdateMode</CODE>
 to determine when the moniker will be redrawn.</DD>
</DL>
<P CLASS="refField">
Return:	Nothing.</P>
<P CLASS="refField">
Interception:	Generally not intercepted.</P>
<P CLASS="figTitle">
Code Display 2-18 Getting and Using Visual Monikers</P>
<PRE>/* This method effectively copies a visual moniker from ObjectOne into ObjectTwo.
 * Both objects must reside in the same object block. Note that in effect, both
 * ObjectOne and ObjectTwo will &quot;share&quot; the same moniker. This can be dangerous if
 * one object is freed, thereby causing the other object to become dereferenced.
 * For more complex copy operations, use MSG_GEN_REPLACE_VIS_MONIKER instead. */</PRE>
<PRE>@method MyProcessClass, MSG_MY_MONIKER_MESSAGE {
	/* Set up variable to store the chunk handle of the visual moniker. */
    ChunkHandle MyVisMonikerCH;</PRE>
<PRE>	/* Retrieve the visMoniker of ObjectOne and store it in the variable. */</PRE>
<PRE>    MyVisMonikerCH = @call @ObjectOne::MSG_GEN_GET_VIS_MONIKER();</PRE>
<PRE>	/* Set the visMoniker of Object Two to MyVisMonikerCH and update
	 * immediately. Use @send if you don't expect a return value. */</PRE>
<PRE>    @send @ObjectTwo::MSG_GEN_USE_VIS_MONIKER(MyVisMonikerCH, VUM_NOW);
}</PRE>
<PRE>/* You can also declare visual monikers in your .goc file and set them later */</PRE>
<PRE>    @visMoniker OnMoniker = &quot;On&quot;;
    @visMoniker OffMoniker = &quot;Off&quot;;</PRE>
<PRE>	/* Within a method, the following routine will set the moniker to &quot;On&quot;. The
	 * OptrToChunk operator casts the object from an optr to a ChunkHandle. */</PRE>
<PRE>    @call @MyObject::MSG_GEN_SET_MONIKER(OptrToChunk(@OnMoniker), VUM_NOW);</PRE>
<PRE>	/* Within a method, the following routine will set the moniker to &quot;Off&quot; */</PRE>
<PRE>    @call @MyObject::MSG_GEN_SET_MONIKER(OptrToChunk(@OffMoniker), VUM_NOW);</PRE>


<H6 CLASS="RefETitle">
<A NAME="GenClass_d.htm_IX_MSG_GEN_REPLACE_VIS_MONIKER">
 </A>
MSG_GEN_REPLACE_VIS_MONIKER</H6>
<PRE CLASS="syntax">ChunkHandle	 MSG_GEN_REPLACE_VIS_MONIKER(@stack
        VisUpdateMode			updateMode,
        word			height,
        word			width,
        word			length,
        VisMonikerDataType			dataType,
        VisMonikerSourceType			sourceType,
        dword			source);</PRE>
<P>
This message copies a visual moniker from a source to the object sent the message. The message returns the chunk handle of the newly copied moniker. The object's current visual moniker is overwritten by this message; therefore, if more than one object shares the overwritten block, the other object should be updated with <CODE>
MSG_GEN_USE_VIS_MONIKER</CODE>
. This message can copy a visual moniker from a variety of sources.</P>
<P>
This message is a general, all-purpose, moniker replacement device. If your visual moniker source is a <CODE>
visMoniker</CODE>
 structure or a null-terminated text string, you may be able to use the simpler messages <CODE>
MSG_GEN_REPLACE_VIS_MONIKER_OPTR</CODE>
 and <CODE>
MSG_GEN_REPLACE_VIS_MONIKER_TEXT</CODE>
.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any generic object.</P>
<P CLASS="refField">
Parameters:	<EM>
updateMode</EM>
	Specifies the<CODE>
 </CODE>
<CODE>
VisUpdateMode</CODE>
 to use when visually updating the changes to the screen. See <A HREF="../../UI/VisClass/combo.htm">the VisClass Chapter</A> for more information on <CODE>
VisUpdateMode</CODE>
 types.</P>
<DL>
<DT>
<EM>
height</EM>
</DT><DD>If moniker is a GString, this specifies the height of the moniker in points. Otherwise, set this to zero.</DD>
<DT>
<EM>
width</EM>
</DT><DD>If the moniker is a GString, this specifies the width of the moniker in points. Otherwise, set this to zero.</DD>
<DT>
<EM>
length</EM>
</DT><DD>If the moniker is a GString, this specifies the size of the moniker in bytes. If the moniker is text and this argument is zero, the string is assumed to be null-terminated.</DD>
<DT>
<EM>
dataType</EM>
</DT><DD>Specifies the type of data referenced by the <EM>
source</EM>
. Valid <CODE>
VisMonikerDataType</CODE>
 types include VMDT_VIS_MONIKER, VMDT_TEXT, VMDT_GSTRING, or VMDT_TOKEN.</DD>
<DT>
<EM>
sourceType</EM>
</DT><DD>Specifies the type of pointer referencing the <EM>
source</EM>
. Valid <CODE>
VisMonikerSourceType</CODE>
 types are VMST_FPTR, VMST_OPTR, and VMST_HPTR.</DD>
<DT>
<EM>
source</EM>
</DT><DD>Specifies the source of the moniker to be used during the copy process. This source may be a pointer to a text string, an optr pointing to a visual moniker outside the current block, or a variety of other sources. The source type should be specified in <EM>
sourceType</EM>
. </DD>
</DL>
<P CLASS="refField">
Return:	The chunk handle of the new visual moniker for the object.</P>
<P CLASS="refField">
Interception:	Generally not intercepted.</P>


<H6 CLASS="RefETitle">
<A NAME="GenClass_d.htm_IX_MSG_GEN_REPLACE_VIS_MONIKER_OPTR">
 </A>
MSG_GEN_REPLACE_VIS_MONIKER_OPTR</H6>
<PRE CLASS="syntax">ChunkHandle	 MSG_GEN_REPLACE_VIS_MONIKER_OPTR(
        optr		source,
        VisUpdateMode		updateMode);</PRE>
<P>
This message is a simplified version of MSG_GEN_REPLACE_VIS_MONIKER. If your visual moniker source is an existing <CODE>
visMoniker</CODE>
 structure, you can use this message to replace an object's moniker. </P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any generic object.</P>
<P CLASS="refField">
Parameters:	<EM>
source</EM>
	The optr of the visMoniker structure to use in the replacement operation.</P>
<DL>
<DT>
<EM>
updateMode</EM>
</DT><DD>Specifies the<CODE>
 </CODE>
<CODE>
VisUpdateMode</CODE>
 to use when visually updating the changes to the screen.</DD>
</DL>
<P CLASS="refField">
Return:	The chunk handle of the new visual moniker for the object.</P>
<P CLASS="refField">
Interception:	Generally not intercepted.</P>


<H6 CLASS="RefETitle">
<A NAME="GenClass_d.htm_IX_MSG_GEN_REPLACE_VIS_MONIKER_TEXT">
 </A>
MSG_GEN_REPLACE_VIS_MONIKER_TEXT</H6>
<PRE CLASS="syntax">ChunkHandle	 MSG_GEN_REPLACE_VIS_MONIKER_TEXT(
        const char		*source,
        VisUpdateMode		updateMode);</PRE>
<P>
This message is a simplified version of MSG_GEN_REPLACE_VIS_MONIKER. If your visual moniker source is a pointer to a null-terminated text string, you can use this message to replace an object's moniker without having to pass the arguments of <CODE>
MSG_GEN_REPLACE_VIS_MONIKER</CODE>
.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any generic object.</P>
<P CLASS="refField">
Parameters:	<EM>
source</EM>
	A pointer to a null-terminated character string to use in the replacement operation.</P>
<DL>
<DT>
<EM>
updateMode</EM>
</DT><DD>Specifies the<CODE>
 </CODE>
<CODE>
VisUpdateMode</CODE>
 to use when visually updating the changes to the screen.</DD>
</DL>
<P CLASS="refField">
Return:	The chunk handle of the new visual moniker for the object.</P>
<P CLASS="refField">
Interception:	Generally not intercepted.</P>


<H6 CLASS="RefETitle">
<A NAME="GenClass_d.htm_IX_MSG_GEN_CREATE_VIS_MONIKER">
 </A>
MSG_GEN_CREATE_VIS_MONIKER</H6>
<PRE CLASS="syntax">ChunkHandle MSG_GEN_CREATE_VIS_MONIKER(@stack
        CreateVisMonikerFlags			flags,
        word			height,
        word			width,
        word			length,
        VisMonikerDataType			dataType,
        VisMonikerSourceType			sourceType,
        dword			source);</PRE>
<P>
This message creates a visual moniker chunk within the resource block of the object sent this message. The moniker is copied from the source specified but is not attached to any object in the new object block.</P>
<P CLASS="refField">
Source:	Unrestricted</P>
<P CLASS="refField">
Destination:	Any <CODE>
GenClass</CODE>
 object</P>
<P CLASS="refField">
Parameters:	<EM>
flags	</EM>
Flags to use in the creation of the new visual moniker. CVMF_DIRTY<EM>
 </EM>
marks the new moniker chunk<EM>
 </EM>
OCF_DIRTY<EM>
.</EM>
</P>
<DL>
<DT>
<EM>
height</EM>
</DT><DD>If moniker is a GString, this specifies the height of the moniker in points. Otherwise, set this to zero.</DD>
<DT>
<EM>
width</EM>
</DT><DD>If the moniker is a GString, this specifies the width of the moniker in points. Otherwise, set this to zero.</DD>
<DT>
<EM>
length</EM>
</DT><DD>If the moniker is a GString, this specifies the length of the moniker in points. Otherwise, set this to zero.</DD>
<DT>
<EM>
dataType</EM>
</DT><DD>Specifies the type of data referenced by the <EM>
source</EM>
. Valid <CODE>
VisMonikerDataType</CODE>
 types include VMDT_VIS_MONIKER, VMDT_TEXT, VMDT_GSTRING, or VMDT_TOKEN.</DD>
<DT>
<EM>
sourceType</EM>
</DT><DD>Specifies the type of pointer referencing the <EM>
source</EM>
. Valid <CODE>
VisMonikerSourceType</CODE>
 types are VMST_FPTR, VMST_OPTR, and VMST_HPTR.</DD>
<DT>
<EM>
source</EM>
</DT><DD>Specifies the source of the moniker to be used during the copy process. This source may be a pointer to a text string, an optr pointing to a visual moniker outside the current block, or a variety of other sources. The source type should be specified in <EM>
sourceType</EM>
. </DD>
</DL>
<P CLASS="refField">
Return:	The chunk handle of the new visual moniker for the object.</P>
<P CLASS="refField">
Interception:	Generally not intercepted.</P>


<H6 CLASS="RefETitle">
<A NAME="GenClass_d.htm_IX_MSG_GEN_FIND_MONIKER">
 </A>
MSG_GEN_FIND_MONIKER</H6>
<PRE CLASS="syntax">optr	MSG_GEN_FIND_MONIKER(
        Boolean		useAppMonikerList,
        word		searchFlags,					/* VisMonikerSearchFlags */
        MemHandle		destBlock);</PRE>
<P>
This message scans a list of monikers and selects a specific moniker (or the most appropriate moniker). The moniker selected is determined according to the passed <CODE>
VisMonikerSearchFlags</CODE>
. This message is usually used by the specific UI to select an application moniker from a list.</P>
<P>
If the first argument (<CODE>
useAppMonikerList</CODE>
) is not zero, the message will use the GenApplication's moniker list instead of the recipient's. This is useful for finding the icon used for an iconified application.</P>
<P>
Note that this message returns an optr, not a chunk handle, as this message is most often used to find a moniker outside of the current object block. This message returns zero if no moniker is found.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any generic object.</P>
<P CLASS="refField">
Parameters:	<EM>
useAppMonikerList<BR>
</EM>
Non-zero to use the moniker list of the application associated with this object.</P>
<DL>
<DT>
<EM>
searchFlags</EM>
</DT><DD><CODE>
VisMonikerSearchFlags</CODE>
 to use for the search criteria. If VMSF_COPY_CHUNK is specified in the <EM>
searchFlags</EM>
, a block handle must be supplied in <CODE>
destBlock</CODE>
. The selected moniker will be copied into that block.</DD>
<DT>
<EM>
destBlock</EM>
</DT><DD>Block to copy a moniker into, if VMSF_COPY_CHUNK is specified in the <EM>
searchFlags</EM>
.</DD>
</DL>
<P CLASS="refField">
Return:	The optr of the moniker found according to the search criteria. (This may be outside the current object block.)</P>
<P CLASS="refField">
Interception:	Generally not intercepted.</P>


<H6 CLASS="RefETitle">
<A NAME="GenClass_d.htm_IX_MSG_GEN_DRAW_MONIKER">
 </A>
MSG_GEN_DRAW_MONIKER</H6>
<PRE CLASS="syntax">void	MSG_GEN_DRAW_MONIKER(@stack
        DrawMonikerFlags		monikerFlags,
        word		textHeight,
        GStateHandle		gState,
        word		yMaximum,
        word		xMaximum,
        word		yInset,
        word		xInset);</PRE>
<P>
<A NAME="GenClass_d.htm_IX_Monikers:drawing">
 </A>
This message draws a moniker for an object according to the parameters passed. The moniker must currently exist. You can use this message to change the way you wish a visual moniker to appear within a generic object without actually changing the visual moniker itself.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any GS_USABLE generic object.</P>
<P CLASS="refField">
Parameters:	<CODE>
monikerFlags</CODE>
 	Specifies the <CODE>
DrawMonikerFlags</CODE>
 to use when drawing the moniker. The <CODE>
DrawMonikerFlags</CODE>
 record specifies the conditions to draw the moniker under.</P>
<DL>
<DT>
<CODE>
textHeight</CODE>
</DT><DD>Specifies the height of the system text. Passing this value speeds the processing of this message. If you do not know the height of the system text, pass zero. </DD>
<DT>
<CODE>
gState</CODE>
 </DT><DD>Specifies the GState, if any, to use when drawing the moniker.</DD>
<DT>
<CODE>
yMaximum, xMaximum</DT><DD>
</CODE>
These specify the maximum height and width of the moniker. Typically, these are used with DMF_CLIP_TO_MAX_WIDTH (in <CODE>
DrawMonikerFlags</CODE>
) to perform a clipping operation on the moniker. Pass zero if no maximum width is desired.</DD>
<DT>
<CODE>
yInset</DT><DD></CODE>
Specifies the point to begin drawing the moniker if the moniker is right or left justified.</DD>
<DT>
<CODE>
xInset</CODE>
 </DT><DD>Specifies the point to begin drawing the moniker if the moniker is top or bottom justified.</DD>
</DL>
<P CLASS="refField">
Return:	Nothing</P>
<P CLASS="refField">
Interception:	Generally not intercepted. Custom gadgets may handle this if they are supplementing or replacing default functionality.</P>
<P CLASS="refField">
Structures:	The <CODE>
DrawMonikerFlags</CODE>
 record defines the parameters to use when drawing a currently existing visual moniker. This record is used by <CODE>
MSG_GEN_DRAW_MONIKER</CODE>
, <CODE>
MSG_GEN_GET_MONIKER_POS</CODE>
 and <CODE>
MSG_GEN_GET_MONIKER_SIZE</CODE>
. Its flags are shown below:</P>
<PRE>DMF_UNDERLINE_ACCELERATOR
DMF_CLIP_TO_MAX_WIDTH
DMF_NONE
DMF_Y_JUST_MASK    /* of type Justifications */
DMF_X_JUST_MASK    /* of type Justifications */</PRE>
<P>
Use DMF_UNDERLINE_ACCELERATOR to underline the keyboard accelerator of a text moniker. Use DMF_CLIP_TO_MAX_WIDTH to clip the visual bounds of the moniker to the width specified in <CODE>
maxWidth</CODE>
<CODE>
. </CODE>
Use DMF_NONE to draw the moniker at the current pen position.</P>
<P>
The two justification masks are of type <CODE>
Justification</CODE>
, and they specify the vertical and horizontal justifications to use when drawing the moniker. The values you can use in the justification fields are</P>
<PRE>J_LEFT
J_RIGHT
J_CENTER
J_FULL</PRE>


<H6 CLASS="RefETitle">
<A NAME="GenClass_d.htm_IX_MSG_GEN_GET_MONIKER_POS">
 </A>
MSG_GEN_GET_MONIKER_POS</H6>
<PRE CLASS="syntax">XYValueASDWord MSG_GEN_GET_MONIKER_POS(@stack
        DrawMonikerFlags		monikerFlags,
        word		textHeight,
        GStateHandle		gState,
        word		yMaximum,
        word		xMaximum,
        word		yInset,
        word		xInset);</PRE>
<P>
This message returns the x and y coordinates of the moniker for the object as if the moniker were drawn according to the passed parameters (the same as for <CODE>
MSG_GEN_DRAW_MONIKER</CODE>
). Use the macros DWORD_X and DWORD_Y to extract the appropriate coordinates from the returned value.</P>
<P>
This message, along with <CODE>
MSG_GEN_DRAW_MONIKER </CODE>
and <CODE>
MSG_GEN_GET_MONIKER_SIZE </CODE>
is most useful in the construction and modification of custom gadgets.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any generic object.</P>
<P CLASS="refField">
Parameters:	See <CODE>
MSG_GEN_DRAW_MONIKER</CODE>
.</P>
<P CLASS="refField">
Return:	<CODE>
XYValueAsDWord</CODE>
 which can be split up into x and y coordinates of the moniker position with the macros DWORD_X and DWORD_Y.</P>
<P CLASS="refField">
Interception:	Generally not intercepted.</P>


<H6 CLASS="RefETitle">
<A NAME="GenClass_d.htm_IX_MSG_GEN_GET_MONIKER_SIZE">
 </A>
MSG_GEN_GET_MONIKER_SIZE</H6>
<PRE CLASS="syntax">SizeAsDWord MSG_GEN_GET_MONIKER_SIZE(
        word		textHeight,
        GStateHandle		gState);</PRE>
<P>
This message returns the width and height (in points) of the moniker for the object. Use the macros DWORD_WIDTH and DWORD_HEIGHT to extract the appropriate coordinates from the returned value. This message, along with <CODE>
MSG_GEN_DRAW_MONIKER </CODE>
and <CODE>
MSG_GEN_GET_MONIKER_POS</CODE>
, is most useful in the construction and modification of custom gadgets.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any generic object.</P>
<P CLASS="refField">
Parameters:	<CODE>
textHeight</CODE>
	The system text height, if known; otherwise, pass zero.</P>
<DL>
<DT>
<CODE>
gstate</CODE>
</DT><DD>The GState handle of the GState to draw to.</DD>
</DL>
<P CLASS="refField">
Return:	<CODE>
SizeAsDWord</CODE>
 which can be split up into with and height with the macros DWORD_WIDTH and DWORD_HEIGHT.</P>
<P CLASS="refField">
Interception:	Generally not intercepted.</P>


<H6 CLASS="RefETitle">
<A NAME="GenClass_d.htm_IX_MSG_GEN_RELOC_MONIKER_LIST">
 </A>
MSG_GEN_RELOC_MONIKER_LIST</H6>
<PRE CLASS="syntax">void 	MSG_GEN_RELOC_MONIKER_LIST(
        optr		monikerList,
        word 		relocFlag); /* 0: relocate; 1: unrelocate */</PRE>
<P>
This method (un)relocates a passed moniker list. </P>
<P CLASS="refField">
Source:	Anyone.</P>
<P CLASS="refField">
Destination:	Any GenClass object.</P>
<P CLASS="refField">
Parameters:	<EM>monikerList</EM> 	optr of moniker list.</P>
<DL>
<DT>
<EM>reloc</EM></DT><DD>Flag specifying whether relocation or unrelocation is desired.</DD>
</DL>
<P CLASS="refField">
Return:	Nothing.</P>
<P CLASS="refField">
Interception:	Generally not intercepted.</P>


<H6 CLASS="RefETitle">
<A NAME="GenClass_d.htm_IX_MSG_GEN_FIND_OBJECT_WITH_TEXT_MONIKER">
 </A>
MSG_GEN_FIND_OBJECT_WITH_TEXT_MONIKER</H6>
<PRE CLASS="syntax">optr	MSG_GEN_FIND_OBJECT_WITH_TEXT_MONIKER(
        char	*text,
        word	flags);</PRE>
<P>
This message recursively searches through the generic tree (starting at the object sent the message) for an object whose visual moniker matches the passed text. This match does not need to be complete (unless the flag GFTMF_EXACT_MATCH is passed); the message will return the first object whose initial characters match the given text. The message must pass <CODE>
GenFindObjectWithMonikerFlags</CODE>
.</P>
<PRE>typedef WordFlags GenFindObjectWithMonikerFlags;
#define GFTMF_EXACT_MATCH 0x8000
#define GFTMF_SKIP_THIS_NODE 0x4000</PRE>
<P>
If GFTMF_EXACT_MATCH is passed, the text and the visual moniker text must match exactly (null-terminated). If GFTMF_SKIP_THIS_NODE is passed, the object which sent the message will not be checked; only its children will be checked.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any generic object.</P>
<P CLASS="refField">
Parameters:	<EM>
text</EM>
	Null-terminated text.</P>
<DL>
<DT>
<EM>
flags</EM>
</DT><DD><CODE>
GenFindObjectWithMonikerFlags</CODE>
.</DD>
</DL>
<P CLASS="refField">
Return:	optr of the object with the matching moniker, or null if no moniker was found.</P>
<P CLASS="refField">
Interception:	Generally not intercepted.</P>

<HR>
<A NAME="GenClass_e.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">GenClass</A>: 4.3 <A HREF="#GenClass_b.htm">Modifying GenClass Instance Data</A>: 
<A NAME="GenClass_e.htm_56092">
 </A>
Managing Keyboard Accelerators</H3>
<PRE>MSG_GEN_GET_KBD_ACCELERATOR, MSG_GEN_SET_KBD_ACCELERATOR, MSG_GEN_CHANGE_ACCELERATOR </PRE>
<P>
<A NAME="GenClass_e.htm_IX_Keyboard accelerators:managing">
 </A>
Keyboard Accelerators provide keyboard shortcuts for heavily used application functions. For complete information on valid <CODE>
GI_kbdAccelerator</CODE>
 instance data and the functionality those data provide, see <A HREF="#GenClass_8.htm_77927"> Keyboard Accelerators</A>
.</P>
<P>
<CODE>
MSG_GEN_GET_KBD_ACCELERATOR </CODE>
returns a word of data specifying the current keyboard accelerator, if any, for the object the message is sent to.</P>
<P>
<CODE>
MSG_GEN_SET_KBD_ACCELERATOR</CODE>
 sets the keyboard accelerator of the object the message is sent to. The message must pass the keyboard accelerator to use along with a <CODE>
VisUpdateMode</CODE>
. If you wish to remove a keyboard accelerator from an object, pass this message with a keyboard acclerator of zero.</P>
<P>
<CODE>
MSG_GEN_CHANGE_ACCELERATOR</CODE>
 changes the keyboard accelerator using a low-level replace operation.</P>

<H6 CLASS="RefETitle">
<A NAME="GenClass_e.htm_IX_MSG_GEN_GET_KBD_ACCLERATOR">
 </A>
MSG_GEN_GET_KBD_ACCLERATOR</H6>
<PRE CLASS="syntax">word	MSG_GEN_GET_KBD_ACCELERATOR();</PRE>
<P>
This message returns the object's current <CODE>
GI_kbdAccelerator.</CODE>
 The message returns a word-length data structure (<CODE>
KeyboardShortcut</CODE>
). You can then manipulate or use this word of data to set other object's keyboard accelerators. Make sure that you do not have two objects sharing the same keyboard accelerator. </P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any generic object.</P>
<P CLASS="refField">
Return:	<CODE>
KeyboardShortcut</CODE>
 of the generic object (in GI_<CODE>
kbdAccelerator</CODE>
).</P>
<P CLASS="refField">
Interception:	Generally not intercepted.</P>


<H6 CLASS="RefETitle">
<A NAME="GenClass_e.htm_IX_MSG_GEN_SET_KBD_ACCELERATOR">
 </A>
MSG_GEN_SET_KBD_ACCELERATOR</H6>
<PRE CLASS="syntax">void	MSG_GEN_SET_KBD_ACCELERATOR(
        word		accelerator,
        VisUpdateMode		updateMode);</PRE>
<P>
This message sets the <CODE>
GI_kbdAccelerator</CODE>
 of the object the message is sent to.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any generic object.</P>
<P CLASS="refField">
Parameters:	<EM>
accelerator</EM>
	<CODE>
KeyboardShortcut</CODE>
 to set GI_<CODE>
kbdAccelerator</CODE>
 of the generic object to.</P>
<DL>
<DT>
<EM>
updateMode</EM>
</DT><DD><CODE>
VisUpdateMode</CODE>
 to determine when redrawing occurs.</DD>
</DL>
<P CLASS="refField">
Interception:	Generally not intercepted.</P>
<P CLASS="figTitle">
Code Display 2-19 Using a Keyboard Accelerator</P>
<PRE>@kbdAccelerator ShortcutOne = ctrl shift `k';</PRE>
<PRE>	/* @specificUI keyword needed to use DELETE key */
@kbdAccelerator ShortcutTwo = @specificUI ctrl DELETE;</PRE>
<PRE>@object GenTriggerClass MyTrigger = {
    GI_kbdAccelerator = ShortcutOne;				/* sets accel to &quot;ctrl shift `k'&quot; */
}</PRE>
<PRE>@object GenTriggerClass MyOtherTrigger = {
	GI_kbdAccelerator = ShortcutCopy;				/* Copies &quot;ctrl shift `k'&quot; to
					 * MyOtherTrigger */
}</PRE>


<H6 CLASS="RefETitle">
<A NAME="GenClass_e.htm_IX_MSG_GEN_CHANGE_ACCELERATOR">
 </A>
MSG_GEN_CHANGE_ACCELERATOR</H6>
<PRE CLASS="syntax">void	MSG_GEN_CHANGE_ACCELERATOR(
        word	bitsToClear,
        word	bitsToSet);</PRE>
<P>
This message changes the keyboard accelerator using constants defined in the input library. In most cases, use <CODE>
MSG_GEN_SET_KBD_ACCELERATOR</CODE>
 instead. <CODE>
MSG_GEN_CHANGE_ACCELERATOR</CODE>
 is useful in some cases where you wish to tinker slightly with the keyboard shortcut's usage (as in a case where an accelerator of ctrl z should change to alt z in the duplication of a template object).</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any generic object.</P>
<P CLASS="refField">
Parameters:	<EM>
bitsToClear</EM>
	<CODE>
KeyboardShortcut</CODE>
 and/or <CODE>
VChar</CODE>
 to clear.</P>
<DL>
<DT>
<EM>
bitsToSet</EM>
</DT><DD><CODE>
KeyboardShortcut</CODE>
 and/or <CODE>
VChar</CODE>
 to set.</DD>
</DL>
<P CLASS="refField">
Interception:	Generally not intercepted.</P>

<HR>
<A NAME="GenClass_f.htm"></A>


<H2 CLASS="sectionTitle">
<A HREF="#index.htm">GenClass</A>: 5 
<A NAME="GenClass_f.htm_15521">
 </A>
Generic Trees</H2>
<P>
Generic trees are constructed in several ways. The most common is to add, remove, and move individual children. These children may be the top of a generic branch and will therefore add, remove, or move the entire branch below them. <CODE>
GenClass</CODE>
 also provides other means of manipulating entire branches of generic trees. Each manner of generic tree construction and destruction has certain advantages and disadvantages. The various methods are detailed below:</P>
<UL>
<LI>
The object may be declared in the <CODE>
.goc</CODE>
 file, attached to the generic tree. In this case, there is no need to add the child as this is taken care of by the compiler. You can remove the object and any of its children with <CODE>
MSG_GEN_REMOVE</CODE>
 (or <CODE>
MSG_GEN_REMOVE_CHILD</CODE>
). After removal, any single object may be destroyed with <CODE>
MSG_META_OBJ_FREE</CODE>
. You may also destroy a tree of generic objects with <CODE>
MSG_GEN_DESTROY</CODE>
. You may add the removed object (and its children) to a different location in the generic tree with <CODE>
MSG_GEN_ADD_CHILD</CODE>
.</LI>
<LI>
The object may exist in your <CODE>
.goc</CODE>
 file but remain unattached to the generic tree. You may attach the object with <CODE>
MSG_GEN_ADD_CHILD</CODE>
. You can remove the object, and any children of this object, with <CODE>
MSG_GEN_REMOVE</CODE>
 (or <CODE>
MSG_GEN_REMOVE_CHILD</CODE>
). After removal, destroy any single object with <CODE>
MSG_META_OBJ_FREE</CODE>
. You can destroy a tree of generic objects with <CODE>
MSG_GEN_DESTROY</CODE>
.</LI>
<LI>
<CODE>
ObjInstantiate(), ObjInstantiateForThread()<BR>
</CODE>
These routines create a new instance of a single object. You can then add the object to your generic tree with <CODE>
MSG_GEN_ADD_CHILD</CODE>
. After a child is removed using <CODE>
MSG_GEN_REMOVE</CODE>
 (or <CODE>
MSG_GEN_REMOVE_CHILD</CODE>
), it can be destroyed using <CODE>
MSG_META_OBJ_FREE</CODE>
. The object destroyed in such a manner must not have any children attached to it at the time of destruction.</LI>
<LI>
<CODE>
ObjDuplicateResource()<BR>
</CODE>
This routine duplicates an instance of a previously defined object resource. That object block may contain one or more objects. In your <STRONG CLASS="fileName">
.gp</STRONG>
 file, make sure the resource is marked <EM>
discard-only</EM>
. Only use this routine if you want to duplicate an instance of a predefined resource block. After a block duplicated in this manner is removed using <CODE>
MSG_GEN_REMOVE</CODE>
 (or <CODE>
MSG_GEN_REMOVE_CHILD</CODE>
), it can be destroyed using <CODE>
ObjFreeDuplicate()</CODE>
.</LI>
<LI>
<CODE>
MSG_GEN_COPY_TREE</CODE>
 <BR>
This message copies an entire generic branch headed by the recipient. The branch will be set usable and added automatically without need for a <CODE>
MSG_GEN_ADD_CHILD</CODE>
. A generic branch created in this manner can be removed with <CODE>
MSG_GEN_DESTROY</CODE>
. These messages are useful because they can duplicate and destroy generic trees across object blocks. (The copied branch will reside in one block, however.) </LI>
</UL>
<P>
Objects created in these ways must be added using <CODE>
MSG_GEN_ADD_CHILD</CODE>
 (except for those created with <CODE>
MSG_GEN_COPY_TREE</CODE>
).</P>
<UL>
<LI>
<CODE>
MSG_GEN_ADD_CHILD</CODE>
 <BR>
This message adds a generic object that was previously created but not attached to the generic tree. The object may have been created in your <CODE>
.goc</CODE>
 file but not attached as a child of any other object. The object may also have been created through <CODE>
ObjInstantiate()</CODE>
 or <CODE>
ObjInstantiateForThread()</CODE>
 or with <CODE>
ObjDuplicateResource()</CODE>
 (see above). Use <CODE>
MSG_GEN_REMOVE</CODE>
 (or <CODE>
MSG_GEN_REMOVE_CHILD</CODE>
) to remove a child added in this manner.</LI>
</UL>
<P CLASS="subsectionLink">
<A HREF="#GenClass_10.htm">Child/Parent Searches</A></P>
<P CLASS="subsectionLink">
<A HREF="#GenClass_11.htm">Manipulating Children Directly</A></P>
<P CLASS="subsectionLink">
<A HREF="#GenClass_12.htm">Branch Construction/Destruction</A></P>
<HR>
<A NAME="GenClass_10.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">GenClass</A>: 5.1 <A HREF="#GenClass_f.htm">Generic Trees</A>: 
<A NAME="GenClass_10.htm_40962">
 </A>
Child/Parent Searches</H3>
<PRE>MSG_GEN_FIND_CHILD, MSG_GEN_FIND_CHILD_AT_POSITION, MSG_GEN_FIND_PARENT, MSG_GEN_COUNT_CHILDREN</PRE>
<P>
The following messages provide means of searching the generic tree. It is necessary (in most cases) to check whether a child exists for an object before attempting to delete or access the child. Note that it is bad practice to retrieve optrs using these messages and then some time later send messages manipulating these optrs directly because the tree might change. Instead, use the generic dispatch messages <CODE>
MSG_GEN_CALL_PARENT</CODE>
, <CODE>
MSG_GEN_SEND_TO_CHILDREN</CODE>
, etc.</P>

<H6 CLASS="RefETitle">
<A NAME="GenClass_10.htm_IX_MSG_GEN_FIND_CHILD">
 </A>
MSG_GEN_FIND_CHILD</H6>
<PRE CLASS="syntax">word	MSG_GEN_FIND_CHILD(
        optr child);</PRE>
<P>
This message checks whether the object is a child of the recipient. If so, it returns the child's position. If you wish to find out if a specific child currently exists at a certain position, use <CODE>
MSG_GEN_FIND_CHILD_AT_POSITION</CODE>
. </P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any generic object.</P>
<P CLASS="refField">
Parameters:	<EM>
child</EM>
	The optr of child to search for.</P>
<P CLASS="refField">
Return:	The numbered position (zero-based) of the child, or -1 if the specific child is not found.</P>
<P CLASS="refField">
Interception:	Generally not intercepted.</P>


<H6 CLASS="RefETitle">
<A NAME="GenClass_10.htm_IX_MSG_GEN_FIND_CHILD_AT_POSITION">
 </A>
MSG_GEN_FIND_CHILD_AT_POSITION</H6>
<PRE CLASS="syntax">optr	MSG_GEN_FIND_CHILD_AT_POSITION(
        word position);</PRE>
<P>
This message returns the optr of the child at <CODE>
position</CODE>
, if any. Pass the message the zero-based (zero indicates the first child) position to check. If no child is found, the message returns zero.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any generic object.</P>
<P CLASS="refField">
Parameters:	<EM>
position</EM>
	The position (zero-based) of the child to search for.</P>
<P CLASS="refField">
Return:	The optr of child at position passed, if found. Otherwise returns zero.</P>
<P CLASS="refField">
Interception:	Generally not intercepted.</P>


<H6 CLASS="RefETitle">
<A NAME="GenClass_10.htm_IX_MSG_GEN_FIND_PARENT">
 </A>
MSG_GEN_FIND_PARENT</H6>
<PRE CLASS="syntax">optr	MSG_GEN_FIND_PARENT();</PRE>
<P>
This message returns the parent of the recipient object, if any.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any generic object.</P>
<P CLASS="refField">
Return:	The optr of the parent object. If no parent is found, this message returns zero.</P>
<P CLASS="refField">
Interception:	Generally not intercepted.</P>


<H6 CLASS="RefETitle">
<A NAME="GenClass_10.htm_IX_MSG_GEN_COUNT_CHILDREN">
 </A>
MSG_GEN_COUNT_CHILDREN</H6>
<PRE CLASS="syntax">word	MSG_GEN_COUNT_CHILDREN();</PRE>
<P>
This message returns the number of children of the recipient.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any generic object.</P>
<P CLASS="refField">
Return:	The number of children the object has.</P>
<P CLASS="refField">
Interception:	Generally not intercepted.</P>

<HR>
<A NAME="GenClass_11.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">GenClass</A>: 5.2 <A HREF="#GenClass_f.htm">Generic Trees</A>: 
Manipulating Children Directly</H3>
<PRE>MSG_GEN_ADD_CHILD, MSG_GEN_REMOVE, MSG_GEN_REMOVE_CHILD, MSG_GEN_MOVE_CHILD, MSG_GEN_ADD_CHILD_UPWARD_LINK_ONLY</PRE>
<P>
The following messages create, move, and remove objects set up directly in your <CODE>
.goc</CODE>
 file or created with <CODE>
ObjInstantiate()</CODE>
, <CODE>
ObjInstantiateForThread() </CODE>
or <CODE>
ObjDuplicateResource()</CODE>
. These objects may have children, in which case those children will travel with their parent (and be moved and destroyed with the parent).</P>
<P>
When adding or removing children, you typically have to use a <CODE>
CompChildFlags</CODE>
 record. This record has two fields, one of which is a dirty flag; the other is a position number indicating a child's position. The record has the following structure:</P>
<PRE>typedef WordFlags CompChildFlags;
#define CCF_MARK_DIRTY				0x8000 /* high bit */
#define CCF_REFERENCE				0x7FFF /* low 15 bits */</PRE>
<PRE>#define CCF_REFERENCE_OFFSET					0</PRE>
<PRE><A NAME="GenClass_11.htm_IX_CCO_&ldots;"> </A>/* The CCF_REFERENCE field may have any integral
 * number or may be set to one of the following
 * constants:
 *	CCO_FIRST			first child's position
 *	CCO_LAST			last child's position */</PRE>
<P>
<A NAME="GenClass_11.htm_IX_CCF_&ldots;">
 </A>
<A NAME="GenClass_11.htm_IX_CompChildFlags">
 </A>
The <CODE>
CompChildFlags</CODE>
 fields are</P>
<DL>
<DT>
CCF_MARK_DIRTY</DT><DD>
If set, this flag indicates that the operation in progress should mark the affected objects dirty. Any objects marked dirty will be saved to the state file upon shutdown.</DD>
<DT>
CCF_REFERENCE</DT><DD>
This field consists of the lower 15 bits of the word and is a zero-based integer representing the position of the child in its parent's child list. This number cannot be greater than 32767 (0x7fff hex). If the number given is greater than the number of current children, the child will be assumed to be last. For example, a CCF_REFERENCE of four would specify the fifth child of the parent object, or the last child if there are fewer than five children currently. When specifying a position for CCF_REFERENCE, use the CCF_REFERENCE_OFFSET (using the shift operator).</DD>
</DL>
<P>
CCO_FIRST and CCO_LAST specify either the first or last child of the parent, respectively. There is no need to use the CCF_REFERENCE_OFFSET in these cases.</P>

<H6 CLASS="RefETitle">
<A NAME="GenClass_11.htm_IX_MSG_GEN_ADD_CHILD">
 </A>
MSG_GEN_ADD_CHILD</H6>
<PRE CLASS="syntax">void	MSG_GEN_ADD_CHILD(
        optr		child,
        CompChildFlags		flags);</PRE>
<P>
This message adds the passed object as a child of the recipient. The child object must not be GS_USABLE before being added to the generic tree. Make sure not to add a child that is already a child of some other parent. It is also illegal to add an object that is already a child of the parent. If necessary, check first if the specific child currently exists using <CODE>
MSG_GEN_FIND_CHILD</CODE>
.</P>
<P>
In most cases a routine that adds a new child will follow three phases: checking whether the child exists, adding the child, and setting the child GS_USABLE.</P>
<P>
The child object, if already specifically initialized, must be unbuilt before being added to the parent. This ensures that the object will be built out correctly. The internal keyboard search path attribute, GA_KBD_SEARCH_PATH, is also cleared and reset for the child.</P>
<P>
Pass this message the optr of the child object to add, along with the <CODE>
CompChildFlags</CODE>
 to use. If CCF_MARK_DIRTY is specified, the new linkage will be saved to state when the application is detached. You must pass a CCF_REFERENCE in <CODE>
CompChildFlags</CODE>
 to specify the position to add the child. The special constants CCO_FIRST and CCO_LAST, which are special cases of CCF_REFERENCE, will add the object as the first or last child of the parent, respectively.</P>
<P>
Note that the object must currently exist. <CODE>
MSG_GEN_ADD_CHILD</CODE>
 merely sets up the correct linkage and reconfigures your UI. Note also that successive additions of children using the flag CCO_FIRST will result in a &quot;reverse order&quot; of children (the last added will be the first child, the first added will be the last).</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any generic object.</P>
<P CLASS="refField">
Parameters:	<EM>
child</EM>
	The optr of the object to add to the current object's children. This child must not be usable.</P>
<DL>
<DT>
<EM>
flags</EM>
</DT><DD><CODE>
CompChildFlags</CODE>
 to use when adding the child.</DD>
</DL>
<P CLASS="refField">
Interception:	Generally not intercepted. Custom gadgets may intercept to supplement or supersede default functionality.</P>
<P CLASS="figTitle">
Code Display 2-20 ObjDuplicateResource() with MSG_GEN_ADD_CHILD</P>
<PRE>/* This method duplicates a pre-instantiated version of MyMenu.
 * A duplicated object block may also be added using MSG_GEN_ADD_CHILD.*/</PRE>
<PRE>@method MyProcessClass, MSG_DUPLICATE_MY_MENU {
    MemHandle newBlock;				/* The handle of the Duplicate block. */
    optr newMenu;				/* The optr of the new menu. */
    GeodeHandle procHan;				/* The geode handle of the process. */</PRE>
<PRE>    procHan = GeodeGetProcessHandle();
    newBlock = ObjDuplicateResource(OptrToHandle(@MyMenu), procHan, -1);
			/* Pass the handle of MyMenu's resource as well as the
			 * GeodeHandle of the process. Leave the burden thread 
			 * the same.*/</PRE>
<PRE>	/* The new optr is created from the newly created block. */
    newMenu = ConstructOptr(newBlock, OptrToChunk(MyMenu));</PRE>
<PRE>	/* Add the duplicated object tree (MyMenu) as the
	 * first child of MyPrimary. */
    @call @MyPrimary::MSG_GEN_ADD_CHILD(newMenu, (CCF_MARK_DIRTY | CCO_FIRST));</PRE>
<PRE>	/* Then set it usable. Remember, you cannot add a child
	 * that is already GS_USABLE. */
    @call @newMenu::MSG_GEN_SET_USABLE(VUM_NOW);
}</PRE>


<H6 CLASS="RefETitle">
<A NAME="GenClass_11.htm_IX_MSG_GEN_ADD_CHILD_UPWARD_LINK_ONLY">
 </A>
MSG_GEN_ADD_CHILD_UPWARD_LINK_ONLY</H6>
<PRE CLASS="syntax">void	MSG_GEN_ADD_CHILD_UPWARD_LINK_ONLY(
        optr		child);</PRE>
<P>
This message sets a parent link to a passed child object without adding a composite link from the parent to the child. This is a &quot;one way&quot; link in that the parent does not have knowledge of its new child. Therefore, it must be used with caution. </P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any generic object.</P>
<P CLASS="refField">
Parameters:	<EM>
child</EM>
	optr of the child to add with an upward link.</P>
<P CLASS="refField">
Interception:	Generally not intercepted. </P>


<H6 CLASS="RefETitle">
<A NAME="GenClass_11.htm_IX_MSG_GEN_REMOVE">
 </A>
MSG_GEN_REMOVE</H6>
<PRE CLASS="syntax">void 	MSG_GEN_REMOVE(
        VisUpdateMode 		updateMode,
        CompChildFlags 		flags) </PRE>
<P>
This message removes the receiving object from the generic tree. The object to be removed need not be set not usable. Note that all objects below this object will also be removed.</P>
<P CLASS="refField">
Source:	Anyone.</P>
<P CLASS="refField">
Destination:	Any generic object.</P>
<P CLASS="refField">
Parameters:	<EM>updateMode</EM> 	Visual update mode. VUM_MANUAL is not allowed.</P>
<DL>
<DT>
<EM>flags</EM> </DT><DD>Set CCF_MARK_DIRTY to mark links dirty.</DD>
</DL>
<P CLASS="refField">
Return:	Nothing.</P>
<P CLASS="refField">
Interception:	Generally not intercepted. </P>


<H6 CLASS="RefETitle">
<A NAME="GenClass_11.htm_IX_MSG_GEN_REMOVE_CHILD">
 </A>
MSG_GEN_REMOVE_CHILD</H6>
<PRE CLASS="syntax">void	MSG_GEN_REMOVE_CHILD(
        optr		child,
        CompChildFlags		flags);</PRE>
<P>
This message removes the passed object from the recipient. A child must be marked not GS_USABLE in order to be removed. The child must currently exist, so your routine should check this using <CODE>
MSG_GEN_FIND_CHILD</CODE>
. </P>
<P>
Pass this message the optr of the child object to be removed along with a word of <CODE>
CompChildFlags</CODE>
. If CCF_MARK_DIRTY is specified, the updated linkage will be saved to state when the application is detached.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any generic object.</P>
<P CLASS="refField">
Parameters:	<EM>
child</EM>
	The optr of child to remove. This child must be non-usable in order to be removed. The child must also exist as a child of the recipient.</P>
<DL>
<DT>
<EM>
flags</EM>
</DT><DD><CODE>
CompChildFlags</CODE>
 to use when removing the child.</DD>
</DL>
<P CLASS="refField">
Interception:	Generally not intercepted. Custom gadgets may intercept to supplement or supersede default functionality.</P>
<P CLASS="figTitle">
Code Display 2-21 MSG_GEN_REMOVE_CHILD</P>
<PRE>/* This sample method removes the MyChild object from its parent, MyParent. */
@method MyProcessClass, MSG_REMOVE_MY_CHILD {
	/* If the child currently exists, mark it not usable and remove it. */
    if (@call @MyParent::MSG_GEN_FIND_CHILD(@MyChild) != -1) {
	@call @MyChild::MSG_GEN_SET_NOT_USABLE(VUM_NOW);
	@call @MyParent::MSG_GEN_REMOVE_CHILD(@MyChild, CCF_MARK_DIRTY);
    }
}</PRE>


<H6 CLASS="RefETitle">
<A NAME="GenClass_11.htm_IX_MSG_GEN_MOVE_CHILD">
 </A>
MSG_GEN_MOVE_CHILD</H6>
<PRE CLASS="syntax">void	MSG_GEN_MOVE_CHILD(
        optr		child,
        CompChildFlags		flags);</PRE>
<P>
This message moves the given object from the location it currently occupies among its siblings to another location among its siblings. The object will still remain a child of the same parent. </P>
<P>
Pass this message the optr of the child to move along with a word of <CODE>
CompChildFlags</CODE>
. If you pass the flag CCF_MARK_DIRTY, the new linkage will be saved to state when the application is detached. You must also pass a CCF_REFERENCE so the object will be moved to the position specified. CCO_FIRST and CCO_LAST will move the object to the first or last position, respectively.</P>
<P>
If no flags are specified, the object will be moved to the parent object's first position without marking the linkages dirty. Note that for successive moves of children this will result in a &quot;reverse order&quot; of the children.</P>
<P>
Note that this message only moves a child among its siblings. To move an object from one parent of the generic tree to another (different) parent, you must use <CODE>
MSG_GEN_REMOVE </CODE>
(or<CODE>
 MSG_GEN_REMOVE_CHILD</CODE>
) and <CODE>
MSG_GEN_ADD_CHILD</CODE>
.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any generic object.</P>
<P CLASS="refField">
Parameters:	<EM>
child</EM>
	The optr of the child to move.</P>
<DL>
<DT>
<EM>
flags</EM>
</DT><DD><CODE>
CompChildFlags</CODE>
 to use when moving the child.</DD>
</DL>
<P CLASS="refField">
Interception:	Generally not intercepted.</P>

<HR>
<A NAME="GenClass_12.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">GenClass</A>: 5.3 <A HREF="#GenClass_f.htm">Generic Trees</A>: 
Branch Construction/Destruction</H3>
<PRE>MSG_GEN_COPY_TREE, MSG_GEN_DESTROY, MSG_GEN_DESTROY_AND_FREE_BLOCK, MSG_GEN_BRANCH_REPLACE_PARAMS, MSG_GEN_BRANCH_REPLACE_OUTPUT_OPTR_CONSTANT </PRE>
<P>
In addition to instantiating and manipulating generic objects one at a time, you can create, move, and destroy entire branches. One way of doing this is copying a resource using <CODE>
ObjDuplicateResource()</CODE>
 and sending <CODE>
MSG_GEN_ADD_CHILD</CODE>
 to the parent object, passing it the optr of the top object in the tree. This method has the advantage of retaining the same chunk offsets to objects within the duplicated block as in the source block.</P>
<P CLASS="figTitle">
Code Display 2-22 Using ObjDuplicateResource()</P>
<PRE>@start ResourceToCopy;</PRE>
<PRE>/* For simplicity, the GenItems in this listing contain no monikers or 
 * identifiers. */</PRE>
<PRE>@object GenItemGroupClass MyList = {
    GI_comp = @AirplaneEntry, @TrainEntry, @CarEntry, @BicycleEntry;
}
@object GenItemClass AirplaneEntry = {}
@object GenItemClass TrainEntry = {}
@object GenItemClass CarEntry = {}
@object GenItemClass BicycleEntry = {}</PRE>
<PRE>@end ResourceToCopy;</PRE>
<PRE>@method MyProcessClass, MSG_COPY_MY_RESOURCE {
    MemHandle newBlock;</PRE>
<PRE>    newBlock = ObjDuplicateResource(OptrToHandle(@MyList),
		/* Block will be owned by the same geode. */
					-1,
		/* Block will be run by the same thread. */
					-1);</PRE>
<PRE>    @call MyPrimary::MSG_GEN_ADD_CHILD(ConstructOptr(newBlock,
					OptrToChunk(@MyList));
}</PRE>
<P>
Another way to duplicate groups of objects is with <CODE>
MSG_GEN_COPY_TREE</CODE>
. This message greatly simplifies generic tree construction. Those branches of the tree which are roughly similar can be duplicated with one message instead of several.</P>
<P>
In many cases, it might be useful to create a UI resource template. This template should contain objects but should not contain object-specific information such as visual monikers, optrs, etc., as this information may be different for different instances of the branch. You can then duplicate these templates with <CODE>
MSG_GEN_COPY_TREE</CODE>
. The trees can then be updated to reflect their unique data either object by object or by using <CODE>
MSG_GEN_BRANCH_REPLACE_PARAMS</CODE>
, which will replace instance data within an entire branch.</P>
<P>
To set up a template, create the generic tree you wish to function as a template, making sure that the top-level object of that tree is not usable (~GS_USABLE). Then use <CODE>
MSG_GEN_COPY_TREE</CODE>
 to copy the tree to the proper location. You can then set the other instance data within the method. Finally, to make that tree appear on screen, set the top-level object GS_USABLE. You can remove any tree created with <CODE>
MSG_GEN_COPY_TREE</CODE>
 with <CODE>
MSG_GEN_DESTROY</CODE>
. If you use <CODE>
ObjDuplicateResource()</CODE>
 to copy a resource block, you can use<CODE>
 ObjFreeDuplicate()</CODE>
 to remove it. If the generic branch to be destroyed resides completely within a single block, you may send MSG_GEN_DESTROY_AND_FREE_BLOCK to the top object in that generic branch.</P>

<H6 CLASS="RefETitle">
<A NAME="GenClass_12.htm_IX_MSG_GEN_COPY_TREE">
 </A>
MSG_GEN_COPY_TREE</H6>
<PRE CLASS="syntax">optr	MSG_GEN_COPY_TREE(
        MemHandle destBlock,
        ChunkHandle parentChunk,
        word flags);</PRE>
<P>
<A NAME="GenClass_12.htm_IX_Duplicating objects">
 </A>
This message copies an entire branch of a generic object tree, starting at the object first called. Pass this message the handle of the destination object block. The object sent the message must not be GS_USABLE. </P>
<P>
You may pass <CODE>
parentChunk</CODE>
 null if you wish the block to remain unattached to the generic tree. Note that if a generic tree is copied using <CODE>
MSG_GEN_COPY_TREE</CODE>
, the objects contained therein not only will have a new resource handle but will also have new chunk handles. Note that this is different from using <CODE>
ObjDuplicateResource()</CODE>
, which will keep the same chunk offsets into the object block.</P>
<P>
Unlike <CODE>
ObjDuplicateResource()</CODE>
, this message will copy the entire branch desired, even if those objects reside in separate resources. This message is therefore more flexible than <CODE>
ObjDuplicateResource()</CODE>
, which only copies a given object block.</P>
<P>
<CODE>
GenClass</CODE>
 provides the default behavior of broadcasting this message down a generic tree, where each object will make a copy of itself in the destination block. It creates an object chunk the same size as the object chunk being copied, copies over the entire contents of any instance fields and creates an outside chunk for a visual moniker, if any.</P>
<P>
If you have a subclass of a generic object which references (and therefore might need to create) a chunk outside the object, you must be sure to intercept this message and allocate, copy over, and update any references to this chunk. </P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any generic object.</P>
<P CLASS="refField">
Parameters:	<EM>
destBlock</EM>
	The block to copy the tree into. This block cannot be the same as the source object block.</P>
<DL>
<DT>
<EM>
parentChunk</EM>
</DT><DD>The chunk handle of a generic object in the destination block. The recipient of this message will be copied into <CODE>
parentChunk</CODE>
. If zero, copy tree into block without linking it to a particular chunk.</DD>
<DT>
<EM>
flags</EM>
</DT><DD><CODE>
CompChildFlags</CODE>
 to use when adding the tree.</DD>
</DL>
<P CLASS="refField">
Interception:	This message is handled by all generic objects. If you wish to intercept this message, you should first call the superclass to copy over the <CODE>
GenClass</CODE>
 instance data and then copy over any lmem chunks that are referenced by instance data of the intercepting class.</P>
<P CLASS="figTitle">
Code Display 2-23 MSG_GEN_COPY_TREE</P>
<PRE>/* Create a template resource block. For demonstration purposes, this block will
 * only contain one object, a GenItem. All declared resources must also be
 * declared in an application's corresponding .gp file. */</PRE>
<PRE>@start MyTemplate;
@object GenItemClass TemplateItem = {
    GI_states = @default &amp; ~GS_USABLE;					/* Make sure it is NOT usable. */
}
@end MyTemplate;</PRE>
<PRE>/* Start the Interface resource block */</PRE>
<PRE>@start Interface;
@object GenItemGroupClass MyList = { }
				/* Object the template above will be added to. */
@end Interface;</PRE>
<PRE>@method MyProcessClass, MSG_COPY_A_LIST_ITEM {
    optr		newListEntry;</PRE>
<PRE>	/* This call copies TemplateItem to the location at MyList. The macros
	 * OptrToHandle and OptrToChunk are used to cast the optr of MyList into
	 * the proper type for MSG_GEN_COPY_TREE. This new linkage will be marked
	 * dirty, and the child will become the first child of MyList. */
    newListEntry = @call TemplateItem::MSG_GEN_COPY_TREE(
				OptrToHandle(@MyList),
				OptrToChunk(@MyList),
				(CCF_MARK_DIRTY | CCO_FIRST));</PRE>
<PRE>	/* The newListEntry is set usable to bring it up on screen. */
    @call newListEntry::MSG_GEN_SET_USABLE(VUM_NOW);
}</PRE>


<H6 CLASS="RefETitle">
<A NAME="GenClass_12.htm_IX_MSG_GEN_DESTROY">
 </A>
MSG_GEN_DESTROY</H6>
<PRE CLASS="syntax">void	MSG_GEN_DESTROY(
        VisUpdateMode		updateMode,
        word		flags);</PRE>
<P>
This message destroys a generic branch starting at the object called. The message sets all required generic objects not usable, removes them from the generic tree, and destroys them, including any chunks associated with the specific object destroyed. This message is the safest way to destroy a generic branch. </P>
<P>
The message will leave the block that the objects previously resided in intact (except for objects removed, of course), but any chunks coming from those resources will be marked dirty and will be resized to zero.</P>
<P>
It is usually a good idea to destroy generic branches that are not needed to be saved to state when an application detaches or exits. This ensures that when an application is reattached, it will not contain the previous links. This keeps the state file more compact and avoids the possibility of a child not being saved to state while retaining the parent's child pointer.</P>
<P>
The only valid flag in <CODE>
CompChildFlags</CODE>
 is CCF_MARK_DIRTY, which will mark the links as dirty and save them to state.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any generic object.</P>
<P CLASS="refField">
Parameters:	<EM>
updateMode</EM>
	<CODE>
VisUpdateMode</CODE>
 to determine when the generic tree is to be visually updated. May not be VUM_MANUAL.</P>
<DL>
<DT>
<EM>
flags</EM>
</DT><DD><CODE>
CompChildFlags</CODE>
 to use when destroying the branch (either CCF_MARK_DIRTY or zero).</DD>
</DL>
<P CLASS="refField">
Interception:	This message is handled by all generic objects. If you wish to intercept this message, you should first destroy any chunks that are referenced by instance data of the intercepting class and then call the superclass to destroy the object's <CODE>
GenClass</CODE>
 instance data.</P>


<H6 CLASS="RefETitle">
<A NAME="GenClass_12.htm_IX_MSG_GEN_DESTROY_AND_FREE_BLOCK">
 </A>
MSG_GEN_DESTROY_AND_FREE_BLOCK</H6>
<PRE CLASS="syntax">Boolean	MSG_GEN_DESTROY_AND_FREE_BLOCK();</PRE>
<P>
This is a utility message used to destroy a generic branch which resides completely within one block. The block will be freed. The object called with this message must be the only top object in the block. This message is called by <CODE>
UserDestroyDialog()</CODE>
.</P>
<P>
<A NAME="GenClass_12.htm_IX_Active list:MSG_GEN_DESTROY_AND_FREE_BLOCK">
 </A>
If any object within the block resides on the application active list, or if the object is not a window, a slow, non-optimized approach is taken: the branch is set not usable, removed from the generic tree, and sent <CODE>
MSG_META_BLOCK_FREE</CODE>
. If no object of the block can be found on this list, an optimized approach is taken: the window is taken off the screen; FTVMC, mouse, etc. exclusives released; the linkage changed to be one-way upward; and the block sent <CODE>
MSG_META_BLOCK_FREE</CODE>
. In other words, the whole unbuild process is carefully avoided. </P>
<P CLASS="refField">
Source:	Unrestricted</P>
<P CLASS="refField">
Destination:	Top object within a block to be freed.</P>
<P CLASS="refField">
Return:	<EM>
true</EM>
 if the message was handled, <EM>
false</EM>
 otherwise.</P>
<P CLASS="refField">
Interception:	Generally not intercepted.</P>


<H6 CLASS="RefETitle">
<A NAME="GenClass_12.htm_IX_MSG_GEN_BRANCH_REPLACE_PARAMS">
 </A>
MSG_GEN_BRANCH_REPLACE_PARAMS</H6>
<PRE CLASS="syntax">void	MSG_GEN_BRANCH_REPLACE_PARAMS(@stack
        BranchReplaceParamType				type,
        dword				replaceParam,
        dword				searchParam);</PRE>
<P>
This message travels down a generic branch to all of an object's children; the message replaces all instance data specified in <CODE>
type</CODE>
 with replacement instance data. A typical way to implement this is to set up a template UI branch with <CODE>
MSG_GEN_COPY_TREE</CODE>
. Most often, you will use this message to search and replace optrs set within your template. This is easily done by setting these optrs to certain constant values and then searching for those values in <CODE>
type</CODE>
.<CODE>
 </CODE>
If you only wish to replace your destination optrs, use <CODE>
MSG_GEN_BRANCH_REPLACE_OUTPUT_OPTR_CONSTANT</CODE>
, which is just a specialized case of this message.</P>
<P>
When replacing optrs, the constant BRPT_DUMMY_OPTR_START should be used as the <EM>
searchParam</EM>
 value. If multiple optrs are to be replaced, enumerated values based on that value should be used for other optrs. These values will be constants, and since the <CODE>
TravelOption</CODE>
 types are also constants, care must be taken to replace these dummy values before anything else is done on the generic branch; otherwise, their output may be interpreted as a <CODE>
TravelOption</CODE>
.</P>
<P>
This message may not be supported by several subclasses of <CODE>
GenClass</CODE>
.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any generic object.</P>
<P CLASS="refField">
Parameters:	<CODE>
searchParam	</CODE>
Specifies the search parameter. Typically this search parameter is a pre-set constant used to identify the instance data to replace. The search parameter must be a dword.</P>
<DL>
<DT>
<CODE>
replaceParam</CODE>
</DT><DD>Specifies the replacement parameter. Any instance data in the generic branch that matches <CODE>
searchParam</CODE>
 will be replaced with the data specified in <CODE>
replaceParam</CODE>
. The data must be a dword.</DD>
<DT>
<CODE>
type</CODE>
</DT><DD>A value of <CODE>
BranchReplaceParamType</CODE>
. The only value supported is BRPT_OUTPUT_OPTR, which specifies that all optrs with values matching <CODE>
searchParam</CODE>
 should be replaced by the value in <CODE>
replaceParam</CODE>
.</DD>
</DL>
<P CLASS="refField">
Interception:	This message is handled by most generic objects (although not all). If you wish to intercept this message, you should first call the superclass to search and replace any <CODE>
GenClass</CODE>
 instance data, if applicable, and then search and replace any instance data in the intercepting class.</P>


<H6 CLASS="RefETitle">
<A NAME="GenClass_12.htm_IX_MSG_GEN_BRANCH_REPLACE_OUTPUT_OPTR_CONSTANT">
 </A>
MSG_GEN_BRANCH_REPLACE_OUTPUT_OPTR_CONSTANT</H6>
<PRE CLASS="syntax">void	MSG_GEN_BRANCH_OUTPUT_OPTR_CONSTANT(
        optr	replacementOptr,
        word	searchConstant);</PRE>
<P>
This message is a special case of <CODE>
MSG_GEN_BRANCH_REPLACE_PARAMS</CODE>
 where the <CODE>
BranchReplaceParamType</CODE>
 is BRPT_OUTPUT_OPTR with a search parameter of a constant value set up beforehand. You must pass this message the optr to replace the search constant found.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any generic object.</P>
<P CLASS="refField">
Parameters:	<EM>
replacementOptr</EM>
	The optr to replace all instance fields with destinations matching the <EM>
searchConstant</EM>
.</P>
<DL>
<DT>
<EM>
searchConstant</EM>
</DT><DD>The constant to search for and replace with the <EM>
replacementOptr</EM>
.</DD>
</DL>
<P CLASS="refField">
Interception:	Generally not intercepted. This message invokes <CODE>
MSG_GEN_BRANCH_REPLACE_PARAMS</CODE>
 so intercept that instead.</P>

<HR>
<A NAME="GenClass_13.htm"></A>


<H2 CLASS="sectionTitle">
<A HREF="#index.htm">GenClass</A>: 6 
<A NAME="GenClass_13.htm_83751">
 </A>
Vardata</H2>
<P>
Within <CODE>
GenClass</CODE>
, much of your instance data will appear within the basic instance fields allocated with <CODE>
@instance</CODE>
. These instance data fields are fixed; each generic object you create will contain each one of these instance fields. You may also make use of special instance data (variable data, also called &quot;vardata&quot;) using the object variable data storage mechanism. See <A HREF="../../Programming/GOCLanguage/combo.htm">the GEOS Programming chapter</A> for complete information on variable data. </P>
<P>
Vardata performs many of the same functions that fixed instance data does.<CODE>
 </CODE>
However,<CODE>
 </CODE>
vardata differs significantly from fixed instance data in that it will only occupy memory if it is in fact declared. You may also only access vardata entries through special kernel routines and messages. For generic objects, most vardata is either in the form of attributes (beginning with ATTR_) or hints (beginning with HINT_).</P>
<P CLASS="subsectionLink">
<A HREF="#GenClass_14.htm">Optional Attributes (ATTRs)</A></P>
<P CLASS="subsectionLink">
<A HREF="#GenClass_15.htm">Hints to the Specific UI</A></P>
<P CLASS="subsectionLink">
<A HREF="#GenClass_16.htm">Dynamically Managing VarData</A></P>
<HR>
<A NAME="GenClass_14.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">GenClass</A>: 6.1 <A HREF="#GenClass_13.htm">Vardata</A>: 
<A NAME="GenClass_14.htm_73802">
 </A>
Optional Attributes (ATTRs)</H3>
<P>
Vardata attribute entries begin with the form ATTR_<EM>attributename </EM>(as in ATTR_GEN_DESTINATION_CLASS). You can initialize this data within your Goc<CODE>
 </CODE>
object declaration. <CODE>
ATTR</CODE>
s within <CODE>
GenClass</CODE>
 are available for use by any generic object. Several subclasses of <CODE>
GenClass </CODE>
also contain their own ATTR vardata entries. In <CODE>
GenClass</CODE>
 no vardata attributes or hints are set by default.</P>
<P>
ATTRs often behave as additional instance data that just happens to be vardata (and therefore optionally added). For generic objects, these should always be considered part of the generic state of an object and therefore may be saved out to the state file. You may, of course, decide not to save any such fields to the state file.</P>
<P>
Temporary vardata to be used by an object class can be specified using the format <CODE>
TEMP</CODE>
_<EM>tempname</EM>. Any data set up with<CODE>
 TEMP</CODE>
 in a generic object should not be saved to state and should not be considered part of the API but rather an internal field. In almost all cases, you will not need to access such vardata entries. </P>
<P>
For information on manipulating the variable length instance fields dynamically, along with a list of valid hints for <CODE>
GenClass</CODE>
, see <A HREF="#GenClass_16.htm_89895"> Dynamically Managing VarData</A>
.</P>

<H4 CLASS="HeadingC">
<A NAME="GenClass_14.htm_95328">
 </A>
Destination Classes</H4>
<PRE><A NAME="GenClass_14.htm_IX_ATTR_GEN_DESTINATION_CLASS"> </A>ATTR_GEN_DESTINATION_CLASS</PRE>
<P>
<CODE>
ATTR_GEN_DESTINATION_CLASS</CODE>
 specifies the object class that should handle messages sent out by this object. Typically, an object marked with this ATTR will not have a specific destination optr, but instead a destination path defined by a <CODE>
TravelOption</CODE>
. The message for a generic object with a destination class travels down the generic tree along the path specified in the <CODE>
TravelOption</CODE>
 until it encounters an object class of type <CODE>
ATTR_GEN_DESTINATION_CLASS</CODE>
; at that point, the message will be handled.</P>
<P>
ATTR_GEN_DESTINATION_CLASS takes an argument of type <CODE>
DestinationClassArgs</CODE>
. This type contains a pointer to a <CODE>
ClassStruct</CODE>
. You may have to cast the class name into a <CODE>
ClassStruct</CODE>
 type when setting ATTR_GEN_DESTINATION_CLASS.</P>
<PRE><A NAME="GenClass_14.htm_IX_DestinationClassArgs"> </A>typedef struct {
	ClassStruct		* <A NAME="GenClass_14.htm_IX_DCA_class"> </A>DCA_class;
} DestinationClassArgs;</PRE>
<P CLASS="figTitle">
Code Display 2-24 Using ATTR_GEN_DESTINATION_CLASS</P>
<PRE>/* This object will send MSG_META_CUT to the application object and follow the
 * target path until it encounters a VisTextClass object. At that point, the
 * message will be handled. */</PRE>
<PRE>@object GenTriggerClass MyTrigger = {
    GI_visMoniker = &quot;This trigger cuts text from the target object.&quot;
    GTI_actionMsg = MSG_META_CUT;
    GTI_destination = (TO_APP_TARGET);
/* The class pointer points to a ClassStruct structure. */
    ATTR_GEN_DESTINATION_CLASS = { (ClassStruct *)&amp;VisTextClass };
} </PRE>
<PRE>/* To set up a destination class as any generic object, set
 * ATTR_GEN_DESTINATION_CLASS to GenClass. This interaction sends
 * MSG_GEN_SET_NOT_USABLE to the first focus object below the GenInteraction. */</PRE>
<PRE>@object GenTriggerClass MyTrigger = {
    GI_visMoniker = &quot;Remove the Focus object&quot;;
    GTI_actionMsg = MSG_GEN_SET_NOT_USABLE;
    GTI_destination = (TO_FOCUS);
    ATTR_GEN_DESTINATION_CLASS = { (ClassStruct *)&amp;GenClass };
}</PRE>
<PRE><A NAME="GenClass_14.htm_IX_TO_&ldots;"> </A><A NAME="IX_GenTravelOption"> </A><A NAME="IX_TravelOption"> </A>typedef enum {
		/* These values may be used as normal
		 * TravelOptions, and have been set up
		 * so that they will have no value in
		 * common with normal TravelOptions. */
	TO_GEN_PARENT=_FIRST_GenClass,
	TO_FOCUS,
	TO_TARGET,
	TO_MODEL,
	TO_APP_FOCUS,
	TO_APP_TARGET,
	TO_APP_MODEL,
	TO_SYS_FOCUS,
	TO_SYS_TARGET,
	TO_SYS_MODEL,
} GenTravelOption;</PRE>
<P>
The <CODE>
TravelOption</CODE>
 types provided with <CODE>
GenClass</CODE>
 are additional enumerations of the types supplied with <CODE>
MetaClass</CODE>
. <CODE>
MetaClass</CODE>
 provides the types TO_NULL, TO_SELF, TO_OBJ_BLOCK_OUTPUT and TO_PROCESS. Therefore, any generic object can use these types or the further enumerations included here.</P>
<P>
These <CODE>
TravelOption</CODE>
 types typically replace a generic object's destination with a path for a message to be delivered along. Most often, these <CODE>
TravelOption</CODE>
s are used in conjunction with the vardata attribute ATTR_GEN_DESTINATION_CLASS. Together, they allow a message to follow a path specified in <CODE>
TravelOption</CODE>
 until it encounters an object of a class specified in <CODE>
ATTR_GEN_DESTINATION_CLASS</CODE>
. This allows an object to generically send a message down an output path without knowing a specific destination.</P>


<H4 CLASS="HeadingC">
<A NAME="GenClass_14.htm_11206">
 </A>
Initialization File Management</H4>
<PRE>MSG_GEN_LOAD_OPTIONS, MSG_GEN_SAVE_OPTIONS, ATTR_GEN_INIT_FILE_KEY, ATTR_GEN_INIT_FILE_CATEGORY, ATTR_GEN_INIT_FILE_PROPAGATE_TO_CHILDREN, ATTR_GEN_USES_HIERARCHICAL_INIT_FILE_CATEGORY</PRE>
<P>
<A NAME="GenClass_14.htm_IX_Initialization file">
 </A>
Your object may request information from the GEOS.INI file upon startup. Each object on the appropriate GenApplication GCN list may receive a <CODE>
MSG_GEN_LOAD_OPTIONS</CODE>
 upon receiving <CODE>
MSG_META_ATTACH</CODE>
 (and a <CODE>
MSG_GEN_SAVE_OPTIONS</CODE>
 upon <CODE>
MSG_META_SAVE_OPTIONS</CODE>
). Various generic objects intercept this message and perform actions according to the information provided.</P>
<P>
Your object may also access information in the GEOS.INI file as it is being attached by including <A NAME="GenClass_14.htm_IX_ATTR_GEN_INIT_FILE_CATEGORY">
 </A>
ATTR_GEN_INIT_FILE_CATEGORY of the GEOS.INI category you are interested in and the <A NAME="GenClass_14.htm_IX_ATTR_GEN_INIT_FILE_KEY">
 </A>
ATTR_GEN_INIT_FILE_KEY of the specific keyword you want the data for. If a file key, but no file category, exists within an object declaration, then the system will query the application object for its ATTR_GEN_INIT_FILE_CATEGORY. </P>
<P>
Normally only the GenApplication object and any objects in its GCN list will receive <CODE>
MSG_GEN_LOAD_OPTIONS</CODE>
 and <CODE>
MSG_GEN_SAVE_OPTIONS</CODE>
. If you wish other children below these objects to also receive these messages (and therefore request or save information from the GEOS.INI file) you can add the attribute <A NAME="GenClass_14.htm_IX_ATTR_GEN_INIT_FILE_PROPAGATE_TO_CHILDREN">
 </A>
ATTR_GEN_INIT_FILE_PROPAGATE_TO_CHILDREN. Any objects with this attribute will send these messages on down the generic tree to their children. Any children may then also contain this attribute and pass the messages on down to their children, etc.</P>
<P>
Normally, the object itself and then the GenApplication object is queried for an ATTR_GEN_INIT_FILE_CATEGORY. If instead, the object wants a generic upward query of the object's parents, you can attach ATTR_GEN_USES_HIERARCHICAL_INIT_FILE_CATEGORY to the object. In this case, the object will be queried for its file category, and then query up the generic tree for the first object encountered with an ATTR_GEN_INIT_FILE_CATEGORY. In this manner, one parent may contain a file category and several children may contain different file keys within that category. </P>
<P>
Because this method is recursive, it is slow and therefore should be avoided. Most applications should only need one init file category.</P>

<H6 CLASS="RefETitle">
<A NAME="GenClass_14.htm_IX_MSG_GEN_LOAD_OPTIONS">
 </A>
MSG_GEN_LOAD_OPTIONS</H6>
<PRE CLASS="syntax">void	MSG_GEN_LOAD_OPTIONS(
        GenOptionsParams		*params);</PRE>
<P>
This message instructs the generic object to load a value from the GEOS.INI file. It is called automatically by the handler in <CODE>
GenClass</CODE>
 for <CODE>
MSG_META_LOAD_OPTIONS</CODE>
. The message scans the object's vardata for an ATTR_GEN_INIT_FILE_KEY and an ATTR_GEN_INIT_FILE_CATEGORY to scan the .INI file. If no file category is found in the object's vardata, the handler will search up the generic tree for a parent with an ATTR_GEN_INIT_FILE_CATEGORY.</P>
<P>
You may send this message, passing it the proper <CODE>
GenOptionsParams</CODE>
. The return value must be cast into the proper type of whatever the entry within the file key is. This is a null-terminated text string.</P>
<P CLASS="refField">
Source:	Sent by <CODE>
GenClass</CODE>
 on <CODE>
MSG_META_ATTACH</CODE>
. <CODE>
GenClass</CODE>
 generates the <CODE>
GenOptionsParams</CODE>
 structure by looking in the object's vardata (and by querying up the generic tree, if necessary). </P>
<P CLASS="refField">
Destination:	Any generic object.</P>
<P CLASS="refField">
Parameters:	<EM>
params</EM>
	<CODE>
GenOptionsParams</CODE>
 structure (automatically generated by <CODE>
GenClass</CODE>
). See <CODE>
MSG_GEN_SAVE_OPTIONS</CODE>
.</P>
<P CLASS="refField">
Return:	Return values must be cast into the proper type of whatever the entry of category and file key is. </P>
<P CLASS="refField">
Interception:	Various generic classes intercept this and provide default behavior</P>


<H6 CLASS="RefETitle">
<A NAME="GenClass_14.htm_IX_MSG_GEN_SAVE_OPTIONS">
 </A>
MSG_GEN_SAVE_OPTIONS</H6>
<PRE CLASS="syntax">void	MSG_GEN_SAVE_OPTIONS(
        GenOptionsParams		*params);</PRE>
<P>
This message instructs the generic object to save its options to the initialization file.</P>
<P CLASS="refField">
Source:	Sent by <CODE>
GenClass</CODE>
 on <CODE>
MSG_META_SAVE_OPTIONS</CODE>
. <CODE>
GenClass</CODE>
 generates the proper <CODE>
GenOptionsParams</CODE>
 structure by looking in the object's vardata (and querying up the generic tree, if necessary). </P>
<P CLASS="refField">
Destination:	Any generic object.</P>
<P CLASS="refField">
Parameters:	<EM>
params</EM>
	<CODE>
GenOptionsParams</CODE>
 structure (automatically generated by <CODE>
GenClass</CODE>
).</P>
<P CLASS="refField">
Return:	Return values must be cast into the proper type of whatever the entry of category and file key is.</P>
<P CLASS="refField">
Interception:	Various generic classes intercept this and provide default behavior</P>
<P CLASS="refField">
Structures:	The <CODE>
GenOptionsParams</CODE>
 structure is defined as follows:</P>
<PRE><A NAME="GenClass_14.htm_IX_GOP_&ldots;"> </A><A NAME="IX_GenOptionsParams"> </A>typedef struct {
	char	GOP_category[INIT_CATEGORY_BUFFER_SIZE];
	char	GOP_key[INIT_CATEGORY_BUFFER_SIZE];
} GenOptionsParams;</PRE>



<H4 CLASS="HeadingC">
<A NAME="GenClass_14.htm_95545">
 </A>
Altering Default Geometry Management</H4>
<PRE>ATTR_GEN_POSITION, ATTR_GEN_POSITION_X, ATTR_GEN_POSITION_Y</PRE>
<P>
You may wish, in rare cases, to hard-wire a generic object's position relative to its parent. You can do this by including one of these attributes with a position offset from the parent. These attributes supersede the geometry manager; because of this, you should exercise extreme caution whenever using these attributes. You should only use these attributes in the rare cases when the geometry manager (and hints) cannot accommodate your geometry concerns.</P>
<P>
ATTR_GEN_POSITION<A NAME="GenClass_14.htm_IX_ATTR_GEN_POSITION">
 </A>
 takes a <CODE>
Point</CODE>
 argument, specifying the x and y offset (in points) from the parent's top left corner. This point will become the object's top left corner.</P>
<P>
ATTR_GEN_POSITION_X<A NAME="GenClass_14.htm_IX_ATTR_GEN_POSITION_X">
 </A>
 specifies the horizontal (x) offset (in points) from the left edge of the parent. The vertical (y) offset will be left to the specific UI (or ATTR_GEN_POSITION_Y) to determine.</P>
<P>
ATTR_GEN_POSITION_Y<A NAME="GenClass_14.htm_IX_ATTR_GEN_POSITION_Y">
 </A>
 specifies the vertical (y) offset (in points) from the top edge of the parent. The horizontal (x) offset will be left to the specific UI (or ATTR_GEN_POSITION_X) to determine.</P>
<P>
Several hints also accomplish similar geometry overrides. <CODE>
HINT_ALIGN_TOP_EDGE_WITH_OBJECT</CODE>
<A NAME="GenClass_14.htm_IX_HINT_ALIGN_TOP_EDGE_WITH_OBJECT">
 </A>
 aligns an object's top edge with the top edge of the object (optr) this hint is set to. Similarly, <CODE>
HINT_ALIGN_LEFT_EDGE_WITH_OBJECT</CODE>
<A NAME="GenClass_14.htm_IX_HINT_ALIGN_LEFT_EDGE_WITH_OBJECT">
 </A>
, <CODE>
HINT_ALIGN_RIGHT_EDGE_WITH_OBJECT</CODE>
<A NAME="GenClass_14.htm_IX_HINT_ALIGN_RIGHT_EDGE_WITH_OBJECT">
 </A>
, and <CODE>
HINT_ALIGN_BOTTOM_EDGE_WITH_OBJECT</CODE>
<A NAME="GenClass_14.htm_IX_HINT_ALIGN_BOTTOM_EDGE_WITH_OBJECT">
 </A>
 all line up an object's edge with the same edge of the object these hints are set to. One of these hints can be used in each direction. The same concerns over superceding the default geometry manager in the above attributes are valid here as well. Therefore, avoid using these hints if possible.</P>


<H4 CLASS="HeadingC">
<A NAME="GenClass_14.htm_52019">
 </A>
Altering Delayed Mode Activity</H4>
<PRE>ATTR_GEN_SEND_APPLY_MSG_ON_APPLY_EVEN_IF_NOT_MODIFIED, ATTR_GEN_SEND_APPLY_MSG_ON_APPLY_EVEN_IF_NOT_ENABLED</PRE>
<P>
Most generic objects act on changes made by the user. Some generic objects may not immediately react to these changes; instead these objects allow the user to select a variety of settings and then later &quot;apply&quot; these changes. These generic objects operate in <EM>
delayed</EM>
 <EM>
mode</EM>
 and each has an &quot;apply message&quot; associated with it. For these objects, the user may alter the state of the object or its children, but the application only sends out the action to perform those changes when the &quot;apply&quot; message is sent out.</P>
<P>
For example, a dialog box may contain a list of settings that represent the state of a paragraph in a word processor. If the user ever actually changes those settings, the dialog box is marked as modified, but the changes are not actually made until the object receives notification to apply its changes (send out its apply message).</P>
<P>
By default, these generic objects check whether their state has been modified since the last apply message has been sent out. If their state has not been modified and they receive a request to apply changes made, they instead will ignore the request. Likewise, objects set not enabled will ignore the request. ATTR_GEN_SEND_APPLY_MSG_ON_APPLY_EVEN_IF_NOT_MODIFIED<A NAME="GenClass_14.htm_IX_ATTR_GEN_SEND_APPLY_MSG_ON_APPLY_EVEN_IF_NOT_MODIFIED">
 </A>
 and <CODE>
ATTR_GEN_SEND_APPLY_MSG_ON_APPLY_EVEN_IF_NOT_ENABLED</CODE>
<A NAME="GenClass_14.htm_IX_ATTR_GEN_SEND_APPLY_MSG_ON_APPLY_EVEN_IF_NOT_ENABLED">
 </A>
 override this behavior, telling the generic object to send out its apply message regardless of the modified or enabled state of a generic object.</P>
<P>
In the above example, this would mean that whenever the dialog box receives notification to apply its changes it would not check whether its settings have been altered since the last time it applied its changes. Instead it would apply these changes anyway.</P>


<H4 CLASS="HeadingC">
<A NAME="GenClass_14.htm_18848">
 </A>
Notification of Visibility</H4>
<PRE>ATTR_GEN_VISIBILITY_DATA, ATTR_GEN_VISIBILITY_MESSAGE, ATTR_GEN_VISIBILITY_DESTINATION</PRE>
<P>
If a generic object has its GA_NOTIFY_VISIBILITY bit set, it will notify the GenApplication object when it becomes visible or not visible. The object does this by sending <CODE>
MSG_GEN_APPLICATION_VISIBILITY_NOTIFICATION</CODE>
 to the GenApplication object, passing the sending object's optr as data.</P>
<P>
You can alter this default behavior by including one or more attributes. ATTR_GEN_VISIBILITY_MESSAGE<A NAME="GenClass_14.htm_IX_ATTR_GEN_VISIBILITY_MESSAGE">
 </A>
 specifies a different message than <CODE>
MSG_GEN_APPLICATION_VISIBILITY_NOTIFICATION</CODE>
; ATTR_GEN_VISIBILITY_DESTINATION<A NAME="GenClass_14.htm_IX_ATTR_GEN_VISIBILITY_DESTINATION">
 </A>
 specifies a different destination to send visibility notification to than the GenApplication object; ATTR_GEN_VISIBILITY_DATA<A NAME="GenClass_14.htm_IX_ATTR_GEN_VISIBILITY_DATA">
 </A>
 specifies a different word of data to send out than the default data (the optr of the sending object). These attributes will have no effect on objects not marked GA_NOTIFY_VISIBILITY.</P>


<H4 CLASS="HeadingC">
<A NAME="GenClass_14.htm_42380">
 </A>
Generic Properties</H4>
<PRE>ATTR_GEN_PROPERTY, ATTR_GEN_NOT_PROPERTY</PRE>
<P>
<A NAME="GenClass_14.htm_IX_Delayed Mode">
 </A>
Objects that exhibit properties (List Objects, GenValues, GenTexts, etc.) sometimes do not exhibit immediate effects when the user interacts with the object. These objects act in what is known as <EM>
delayed</EM>
 <EM>
mode</EM>
; they only apply their properties when their object receives a MSG_GEN_APPLY. </P>
<P>
Properties objects such as these are usually placed within a GIT_PROPERTIES GenInteraction object. The GIT_PROPERTIES dialog box provides an &quot;Apply&quot; trigger to get the objects to apply their properties. You can, however, change this default behavior, though it is uncommon to need to do so.</P>
<P>
ATTR_GEN_PROPERTY, when added to an object that exhibits properties, allows an object to act like it is within a properties dialog box even if it normally operates in immediate mode. That is, it will not apply its changes until explicitly told to do so (using MSG_GEN_APPLY).</P>
<P>
ATTR_GEN_NOT_PROPERTY allows an object within a GIT_PROPERTIES dialog box to act like it is not within such a dialog box. That is, any user interaction with the object will result in an immediate application of those changes.</P>


<H4 CLASS="HeadingC">
<A NAME="GenClass_14.htm_59456">
 </A>
Window Management</H4>
<P>
<CODE>
GenClass</CODE>
 supplies several optional attributes that affect the display of windows within the user interface. Windowed objects include GenPrimarys, GenDisplays, and GenInteractions (as dialog boxes). </P>
<P>
The optional attributes that follow are divided into two groups. Window layering affects how windowed objects are arranged on the screen; i.e., where they appear and whether they appear above or below other windowed objects. In general, this layering behavior is only determined for windowed objects having the same parent, i.e., windows having the same parent can be custom layered, and their parents will be layered among its siblings.</P>
<P>
There also exist optional attributes to alter the manner in which input travels within a window. These optional attributes allow the application to provide floating keyboards for pen input.</P>

<H5 CLASS="HeadingD">
Window Layering</H5>
<PRE>ATTR_GEN_WINDOW_CUSTOM_LAYER_ID, ATTR_GEN_WINDOW_CUSTOM_WINDOW_PRIORITY, ATTR_GEN_WINDOW_CUSTOM_LAYER_PRIORITY, ATTR_GEN_WINDOW_CUSTOM_PARENT, ATTR_GEN_WINDOW_CUSTOM_WINDOW</PRE>
<P>
ATTR_GEN_WINDOW_CUSTOM_LAYER_ID sets a unique layer identifier for the windowed object. All objects with a common identifier are considered part of the same window layer. These layers can then be manipulated as a unit. By convention, these IDs are usually set to the handles owned by the application; this avoids collisions with other application window layer IDs.</P>
<P>
If a null layer ID is specified, the handle of the block the object lies in will be selected as the layer ID at run-time. This is the common method of assigning layer IDs.</P>
<P>
ATTR_GEN_WINDOW_CUSTOM_LAYER_PRIORITY allows a windowed object to set its layer priority to a custom value. The optional attribute expects an argument of type <CODE>
LayerPriority</CODE>
. Note that all windowed objects with the same Layer ID <EM>
must</EM>
 have the same layer priority; therefore, this attribute must be used with care. It should only be used if a layer ID declared with ATTR_GEN_WINDOW_CUSTOM_LAYER_ID is also used.</P>
<P>
ATTR_GEN_WINDOW_CUSTOM_WINDOW_PRIORITY sets a custom window priority for this specific window among all other windows of the same layer ID. This optional attribute expects an argument of type <CODE>
WindowPriority</CODE>
. </P>
<P>
ATTR_GEN_WINDOW_CUSTOM_PARENT allows windowed objects to set a custom parent window. Because window layering applies only to the ordering of windows having the same parent, a window with a custom parent will have its layer ID, layer priority, and window priority compared to other windows having the same parent as ATTR_GEN_WINDOW_CUSTOM_PARENT.</P>
<P>
If ATTR_GEN_WINDOW_CUSTOM_PARENT is set null, this indicates that the system screen window should be the parent. Because this window is the parent window for all base windows in the system, an object setting the screen window as its custom parent will be able to appear on top of (or below) all other windows in the system (that do not have a matching layer ID). This is very low-level behavior and should be used with caution, however.</P>


<H5 CLASS="HeadingD">
Window Input Management</H5>
<PRE>ATTR_GEN_WINDOW_ACCEPT_INK_EVEN_IF_NOT_FOCUSED, ATTR_GEN_WINDOW_KBD_OVERRIDE, ATTR_GEN_WINDOW_KBD_POSITION, MSG_GEN_SET_KBD_OVERRIDE, MSG_GEN_SET_KBD_POSITION</PRE>
<P>
ATTR_GEN_WINDOW_ACCEPT_INK_EVEN_IF_NOT_FOCUSED indicates that the object should accept ink even if it doesn't have the focus. In general, presses on non-focused windows will never turn into ink. If this attribute is present, then presses on the window can turn into ink. The normal mechanism for determining if a press should be ink is then followed.</P>
<P>
ATTR_GEN_WINDOW_KBD_OVERRIDE indicates the manner in which a floating keyboard is provided for a given window. This optional attribute expects an argument of type of <CODE>
KeyboardOverride</CODE>
. This attribute specifies whether a floating keyboard is provided for text input via a pen device.</P>
<P>
The following <CODE>
KeyboardOverride</CODE>
 values are valid:</P>
<DL>
<DT>
KO_NO_KEYBOARD</DT><DD>
This type indicates that the window should act as if none of its children accepts text input; no floating keyboard will be made available.</DD>
<DT>
KO_KEYBOARD_REQUIRED</DT><DD>
This type indicates that the window should act as if one of its children requires text input; a floating keyboard will be brought on-screen whenever the window gains the focus.</DD>
<DT>
KO_KEYBOARD_EMBEDDED</DT><DD>
This type indicates that the application is directly providing the keyboard; no system-created floating keyboard will be provided.</DD>
</DL>
<P>
You can change the <CODE>
KeyboardOverride</CODE>
 exhibited by a windowed object by sending the object MSG_GEN_SET_KBD_OVERRIDE.</P>
<P>
The following rules will ensure that a keyboard will be present whenever the user interacts with a display requiring a keyboard: Set the KO_KEYBOARD_REQUIRED bit for any GenDisplay which should be accompanied by a floating keyboard. If all GenDisplays in your geode require a floating keyboard, then set this bit for each of them. GenDisplays that contain embedded keyboards should have the KO_KEYBOARD_EMBEDDED bit set instead of the KO_KEYBOARD_REQUIRED bit.</P>
<P>
If you want a keyboard to appear visible even when no GenDisplays are open, mark the GenPrimary KO_KEYBOARD_REQUIRED and mark each GenDisplay KO_NO_KEYBOARD.</P>
<P>
ATTR_GEN_WINDOW_KBD_POSITION specifies the default position for the floating keyboard to appear when the window gains the focus. If the user moves the floating keyboard, this attribute is updated to reflect the new position and the keyboard will appear at that position when brought up in the future.</P>
<P>
You can change this keyboard position by sending the object MSG_GEN_SET_KBD_POSITION, passing it the <CODE>
Point</CODE>
 to position the keyboard at.</P>

<H6 CLASS="RefETitle">
<A NAME="GenClass_14.htm_IX_MSG_GEN_SET_KBD_OVERRIDE">
 </A>
MSG_GEN_SET_KBD_OVERRIDE</H6>
<PRE CLASS="syntax"><STRONG>void</STRONG>	MSG_GEN_SET_KBD_OVERRIDE(
        KeyboardOverride 		override);</PRE>
<P>
This message sets an object's ATTR_GEN_WINDOW_KBD_OVERRIDE to the passed <CODE>
KeyboardOverride</CODE>
 value.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any windowed generic object.</P>
<P CLASS="refField">
Parameters:	<EM>
override</EM>
	<CODE>
KeyboardOverride</CODE>
.</P>
<P CLASS="refField">
Interception:	Generally not intercepted.</P>


<H6 CLASS="RefETitle">
<A NAME="GenClass_14.htm_IX_MSG_GEN_SET_KBD_POSITION">
 </A>
MSG_GEN_SET_KBD_POSITION</H6>
<PRE CLASS="syntax">void	MSG_GEN_SET_KBD_POSITION(
        sword		xCoord,
        sword		yCoord);</PRE>
<P>
This message sets an object's ATTR_GEN_WINDOW_KBD_POSITION to the passed <CODE>
Point</CODE>
 values. </P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any windowed generic object.</P>
<P CLASS="refField">
Parameters:	<EM>
xCoord</EM>
	<EM>
X</EM>
 coordinate to position the keyboard (relative to the window).</P>
<DL>
<DT>
<EM>
yCoord</EM>
</DT><DD><EM>
Y</EM>
 coordinate to position the keyboard (relative to the window).</DD>
</DL>
<P CLASS="refField">
Interception:	Generally not intercepted.</P>




<H4 CLASS="HeadingC">
<A NAME="GenClass_14.htm_81506">
 </A>
Help Management</H4>
<P>
The Help system is discussed in full in <A HREF="../../UI/Help/combo.htm">the Help chapter</A>. You should read that chapter if you wish to include help within your application. The information provided here is mostly an overview of that information.</P>
<H5 CLASS="HeadingD">
Help Files</H5>
<PRE>ATTR_GEN_HELP_FILE, ATTR_GEN_HELP_TYPE, ATTR_GEN_HELP_FILE_FROM_INIT_FILE, ATTR_GEN_HELP_CONTEXT</PRE>
<P>
ATTR_GEN_HELP_FILE stores the help file associated with this object. Help files are generated by the help editor (a modified GeoWrite) from GeoWrite documents and are located in USERDATA\HELP.If the help system queries this object for a help file and this optional attribute does not exist, it will query up the generic tree for the first object with an ATTR_GEN_HELP_FILE.</P>
<P>
An object can use <CODE>
ATTR_GEN_HELP_FILE_FROM_INIT_FILE</CODE>
 to specify that its help file should be taken from the GEOS.INI file. If this attribute is used, the help controller will look in the GEOS.INI file for a category of the same name as the application and a key named &quot;helpfile.&quot; Thus, to set the help file to &quot;My Own Help File&quot; for the HelpSamp application, you could add the following to your GEOS.INI file:</P>
<PRE>[HelpSamp]
helpfile = My Own Help File</PRE>
<P>
If, however, no object has <CODE>
ATTR_GEN_HELP_FILE_FROM_INIT_FILE</CODE>
, this init file entry will not be noticed by the help controller.</P>
<P>
ATTR_GEN_HELP_TYPE stores the <CODE>
HelpType</CODE>
 associated with this object. If the help system queries this object for a help type and this optional attribute does not exist, it will query up the generic tree for the first object with an ATTR_GEN_HELP_TYPE.</P>
<P>
Each help file must have several contexts named within the file. These contexts are set up when the help file is written. When an object brings up help, it should reference the specific context for which the user needs help. This context is stored within the object's ATTR_GEN_HELP_CONTEXT field. Usually this optional attribute is placed on a windowed GenInteraction (dialog box).</P>
<P>
If an object needs to set a different help context for itself at run-time, it can use MSG_META_DELETE_VAR_DATA and MSG_META_ADD_VAR_DATA to alter the contents of the object's ATTR_GEN_HELP_CONTEXT.</P>


<H5 CLASS="HeadingD">
Focus Help</H5>
<PRE>ATTR_GEN_FOCUS_HELP, ATTR_GEN_FOCUS_HELP_LIB</PRE>
<P>
ATTR_GEN_FOCUS_HELP is currently unsupported. This help mechanism is a simple, scaled down version of the previously mentioned help system. A fixed area at the bottom of the screen on certain displays acts as a help text area. An object with ATTR_GEN_FOCUS_HELP indicates that this text area should display the its help text when this object gains the focus within the application. This field expects an optr pointing to the required text.</P>
<P>
ATTR_GEN_FOCUS_HELP_LIB is similar to ATTR_GEN_FOCUS_HELP but only applies to objects exported from a library(e.g., controllers).</P>



<H4 CLASS="HeadingC">
<A NAME="GenClass_14.htm_20719">
 </A>
Default Monikers</H4>
<PRE>ATTR_GEN_DEFAULT_MONIKER, GenDefaultMonikerType</PRE>
<P>
ATTR_GEN_DEFAULT_MONIKER specifies a default moniker for this object. Default monikers are generally used for gstring monikers that occur several places within the system (i.e., they are stored outside of the application). ATTR_GEN_DEFAULT_MONIKER expects an argument of type <CODE>
GenDefaultMonikerType</CODE>
.</P>
<PRE>typedef enum {
	GDMT_LEVEL_0,
	GDMT_LEVEL_1,
	GDMT_LEVEL_2,
	GDMT_LEVEL_3,
	GDMT_HELP,
	GDMT_HELP_PRIMARY
} GenDefaultMonikerType;</PRE>
<P>
The GDMT_LEVEL monikers correspond to the gstring monikers used to indicate the current user level. GDMT_HELP corresponds to the default help trigger moniker. GDMT_HELP_PRIMARY corresponds to the special help trigger for a GenPrimary object.</P>


<H4 CLASS="HeadingC">
<A NAME="GenClass_14.htm_65875">
 </A>
Feature Links</H4>
<PRE>ATTR_GEN_FEATURE_LINK</PRE>
<P>
This optional attribute indicates that a feature within a GenControl object maps to multiple generic trees within the child block. If a feature in a GenControl so marked is turned off, for example, the controller will remove the feature from the first generic tree associated with this feature and then will remove the feature from the link to the next generic tree. Controllers and features are discussed more fully in <A HREF="../../SysObjects/Controllers/combo.htm">the Controllers chapter</A>.</P>

<H4 CLASS="HeadingC">
<A NAME="GenClass_14.htm_64105">
 </A>
Generic Paths</H4>
<PRE>ATTR_GEN_PATH_DATA, MSG_GEN_PATH_SET, MSG_GEN_PATH_GET, GenFilePath</PRE>
<P>
<CODE>
GenClass</CODE>
<A NAME="GenClass_14.htm_IX_ATTR_GEN_PATH_DATA">
 </A>
 is able to keep track of file path information. <CODE>
GenClass</CODE>
 does not use this information itself, but maintains it so that various subclasses (e.g., the file selector and document control) will be able to use the same instance fields and messages.</P>
<P>
Because handlers for all these messages are implemented in <CODE>
GenClass</CODE>
, it is possible to store a path with any generic object, whether the particular object normally does anything with the file system or not.</P>
<P>
The path itself is stored in the object's vardata in the ATTR_GEN_PATH_DATA field. In the absence of such a field, <CODE>
GenClass</CODE>
 will use SP_TOP as the standard path. Subclasses can change this default by intercepting <CODE>
MSG_META_INITIALIZE_VAR_DATA</CODE>
, filling in the <CODE>
GenFilePath</CODE>
 structure after it has called the superclass (which will actually allocate the attribute).</P>
<P>
The ATTR_GEN_PATH_DATA field contains the following structure;</P>
<PRE><A NAME="GenClass_14.htm_IX_GenFilePath"> </A>typedef struct {
	DiskHandle 		GFP_disk;
	PathName 		GFP_path;
} GenFilePath;</PRE>
<P>
GFP_<CODE>
disk</CODE>
 stores the handle of the disk on which the path resides. This value may be initialized to a <CODE>
StandardPath</CODE>
 constant. GFP_<CODE>
path</CODE>
 stores the absolute path to the directory; this path may be a relative path if GFP_<CODE>
disk</CODE>
 is a <CODE>
StandardPath</CODE>
 directory.</P>
<P>
You can retrieve an object's current path with MSG_GEN_PATH_GET. You can alter an object's path with MSG_GEN_PATH_SET.</P>

<H6 CLASS="RefETitle">
<A NAME="GenClass_14.htm_IX_MSG_GEN_PATH_SET">
 </A>
MSG_GEN_PATH_SET</H6>
<PRE CLASS="syntax">Boolean 	MSG_GEN_PATH_SET(
        char 		*path,
        DiskHandle 		disk);</PRE>
<P>
This message sets the path associated with the object. Normally, a complete path name must be passed. Note that this path string should not include a drive specifier, as this is implied by the passed disk handle. If the passed <CODE>
DiskHandle</CODE>
 is actually a <CODE>
StandardPath</CODE>
 value, then the path string will be taken to be relative to this standard path.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Generic object which has an associated path.</P>
<P CLASS="refField">
Parameters:	<EM>path</EM> 	Null-terminated pathname; may not be in the same block as the object receiving this message. (If null, default handler will use root directory of disk handle or directory associated with standard path.)</P>
<DL>
<DT>
<EM>disk</EM> </DT><DD>Disk handle of path, or <CODE>
StandardPath</CODE>
 constant.</DD>
</DL>
<P CLASS="refField">
Return:	Returns <EM>
true</EM>
 if error.</P>
<P CLASS="refField">
Interception:	Generally not intercepted. If the object is specifically grown, the message will be forwarded to the specific class after it has been acted on by <CODE>
GenClass</CODE>
.</P>


<H6 CLASS="RefETitle">
<A NAME="GenClass_14.htm_IX_MSG_GEN_PATH_GET">
 </A>
MSG_GEN_PATH_GET</H6>
<PRE CLASS="syntax">Boolean 	MSG_GEN_PATH_GET(
        char 		*buffer,
        word 		bufSize);</PRE>
<P>
This message returns a null-terminated complete path (no drive letter--drive is implied by the disk handle) for the object. Note that if the object is within a standard directory, the disk handle will be a <CODE>
StandardPath</CODE>
 constant and the path will appear relative.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Generic object which has an associated path.</P>
<P CLASS="refField">
Parameters:	<EM>buffer</EM> 	Pointer to character buffer which will be filled with return value.</P>
<DL>
<DT>
<EM>bufSize</EM> </DT><DD>Size of the above buffer.</DD>
</DL>
<P CLASS="refField">
Return:	Returns <EM>
true</EM>
 if error (if the path won't fit in the passed buffer or is invalid).</P>
<DL>
<DT>
<EM>buffer</EM> </DT><DD>Null-terminated pathname.</DD>
</DL>
<P CLASS="refField">
Interception:	Generally not intercepted.</P>


<H6 CLASS="RefETitle">
<A NAME="GenClass_14.htm_IX_MSG_GEN_PATH_GET_BLOCK">
 </A>
MSG_GEN_PATH_GET_BLOCK</H6>
<PRE CLASS="syntax">@alias (MSG_GEN_PATH_GET) MemHandle 	MSG_GEN_PATH_GET_BLOCK(
        char 		*buffer, 	/* This must be NULL */
        word 		bufSize);</PRE>
<P>
This message returns the handle of a block containing the path.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Generic object which has an associated path.</P>
<P CLASS="refField">
Parameters:	<EM>buffer</EM> 	This must be NULL.</P>
<DL>
<DT>
<EM>bufSize</EM> </DT><DD>This argument is not used.</DD>
</DL>
<P CLASS="refField">
Return:	Handle of block containing path.</P>
<P CLASS="refField">
Interception:	Generally not intercepted.</P>


<H6 CLASS="RefETitle">
<A NAME="GenClass_14.htm_IX_MSG_GEN_PATH_GET_DISK_HANDLE">
 </A>
MSG_GEN_PATH_GET_DISK_HANDLE</H6>
<PRE CLASS="syntax">DiskHandle MSG_GEN_PATH_GET_DISK_HANDLE();</PRE>
<P>
This message returns the disk handle for the path bound to the object.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Generic object which has an associated path.</P>
<P CLASS="refField">
Parameters:	None.</P>
<P CLASS="refField">
Return:	Disk handle associated with path, or <CODE>
StandardPath</CODE>
 if object is associated with a standard directory.</P>
<P CLASS="refField">
Interception:	Generally not intercepted.</P>


<HR>
<A NAME="GenClass_15.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">GenClass</A>: 6.2 <A HREF="#GenClass_13.htm">Vardata</A>: 
<A NAME="GenClass_15.htm_68134">
 </A>
Hints to the Specific UI</H3>
<P>
Hints permit the developer to add suggested behavior to the user interface without requiring the specific UI to implement that functionality. Hints therefore provide the specific UI with less stringent guidelines than other attributes. The specific UI has the option of completely ignoring a hint if it cannot understand it or implement it in the requested fashion. </P>
<P>
For example, some hints deal with the spacial arrangement of objects and can be ignored if the specific UI cannot accommodate their requests. Developers should use hints to add suggested user interface behavior throughout their UI. This suggested use, however, should not be crucial to their application. </P>
<P>
For example, the hint <CODE>
HINT_LIST_CHECKBOXES</CODE>
 has no effect under OSF/Motif because the OSF/Motif specification does not include checkboxes. However, in some other specific UI (OpenLook, for example) that feature may be implemented.</P>
<P CLASS="figTitle">
Code Display 2-25 Setting Hints</P>
<PRE>@object GenInteractionClass MyInteraction = {
    GI_comp = @OneTrigger, @TwoTrigger, @ThreeTrigger;</PRE>
<PRE>	/* Hints are added directly in an object's declaration. Note that each
	 * vardata entry will expand the size of the object in memory. */
    <A NAME="GenClass_15.htm_IX_HINT_ORIENT_CHILDREN_HORIZONTALLY"> </A>HINT_ORIENT_CHILDREN_HORIZONTALLY;
	/* This hint instructs the specific UI to arrange the object's children
	 * in one or more horizontal rows, if possible. */
}</PRE>
<PRE>/* Hints are entered separately in C if multiple hints are desired. */</PRE>
<PRE>@object MyObjectClass MyObject = {
    GI_comp = @MyObjectChild;
    HINT_LIST_CHECKBOXES;
    HINT_ORIENT_CHILDREN_HORIZONTALLY;
}</PRE>

<H4 CLASS="HeadingC">
<A NAME="GenClass_15.htm_11736">
 </A>
System Attributes</H4>
<PRE>SystemAttrs, HINT_IF_SYSTEM_ATTRS, HINT_ELSE, HINT_ENDIF</PRE>
<P>
The system attributes are global flags that describe what sort of environment is running the generic object. HINT_IF_SYSTEM_ATTRS is used to conditionally add hints to an object based on these <CODE>
SystemAttrs</CODE>
. If the <CODE>
SystemAttrs</CODE>
 set in the HINT_IF_SYSTEM_ATTRS field are true for the current system, then the hints that follow (until a HINT_ENDIF is encountered) are included. If no HINT_ENDIF is encountered, then only the next hint is included. If the <CODE>
SystemAttrs</CODE>
 do not match the current system, the following group of hints is instead deleted.</P>
<P>
The following <CODE>
SystemAttrs</CODE>
 are defined:</P>
<DL>
<DT>
SA_TINY</DT><DD>If set, the screen must be either horizontally or vertically tiny.</DD>
<DT>
SA_HORIZONTALLY_TINY</DT><DD>
If set, the screen must be horizontally tiny.</DD>
<DT>
SA_VERTICALLY_TINY</DT><DD>
If set, the screen must be vertically tiny.</DD>
<DT>
SA_COLOR</DT><DD>If set, the system must have a color screen.</DD>
<DT>
SA_PEN_BASED</DT><DD>
If set, the system must be pen-based.</DD>
<DT>
SA_KEYBOARD_ONLY</DT><DD>
If set, the system must be set keyboard-only.</DD>
<DT>
SA_NO_KEYBOARD</DT><DD>
If set, the system must be set no-keyboard.</DD>
<DT>
SA_NOT</DT><DD>If this flag is set, any other set bits indicate criteria that must <EM>
not</EM>
 match. This is the equivalent of a logical NOT operation.</DD>
</DL>
<P>
The HINT_ELSE hint can be used between HINT_IF_SYSTEM_ATTRS and HINT_END_IF. This allows the inclusion of a separate set of hints to be included when the system conditions in HINT_IF_SYSTEM_ATTRS are not satisfied.</P>
<P CLASS="figTitle">
Code Display 2-26 System Attributes</P>
<PRE>/* The SA_NOT bit acts as a logical not operation. In this case, the hint 
 * HINT_EXPAND_HEIGHT_TO_FIT_PARENT will only be included in the object 
 * declaration if the system is not pen-based. In addition, if the system is tiny,
 * the other hints will be included. The HINT_ENDIF marks the end of these
 * conditional hints. */</PRE>
<PRE>    HINT_IF_SYSTEM_ATTRS = SA_NOT | SA_PEN_BASED;
	HINT_EXPAND_HEIGHT_TO_FIT_PARENT;
    HINT_IF_SYSTEM_ATTRS = SA_TINY;
	HINT_MINIMIZE_SIZE;
	HINT_DISPLAY_CURRENT_SELECTION;
    HINT_ENDIF;</PRE>
<PRE>/* Example within an object declaration. */</PRE>
<PRE>@object GenInteractionClass GroupingObject = {
    GI_comp = @One, @Two, @Three, @Four, @Five, @Six;
    HINT_IF_SYSTEM_ATTRS = SA_HORIZONTALLY_TINY;
    	HINT_ORIENT_CHILDREN_VERTICALLY;
    	HINT_WRAP_AFTER_CHILD_COUNT = 3;
    HINT_ELSE;
    	HINT_ORIENT_CHILDREN_HORIZONTALLY;
    HINT_ENDIF;
}</PRE>


<H4 CLASS="HeadingC">
<A NAME="GenClass_15.htm_16416">
 </A>
Default Actions</H4>
<PRE>HINT_DEFAULT_DEFAULT_ACTION, HINT_ENSURE_TEMPORARY_DEFAULT, HINT_PREVENT_DEFAULT_OVERRIDES</PRE>
<P>
Normally, objects in the user interface are activated by direct action (e.g., clicking on them). Objects may also be indirectly activated, however. The object activated indirectly is known as the default action object. For example, within a window, pressing ENTER or sending the window <CODE>
MSG_GEN_ACTIVATE_INTERACTION_DEFAULT</CODE>
 will activate the object marked as the default action.</P>
<P>
HINT_DEFAULT_DEFAULT_ACTION marks an object as the default action for the window it appears in. This hint is only relevant for GenTriggers or dialog GenInteractions (that are brought up by an activation trigger). The default activation object is usually activated by pressing the ENTER key within the window.</P>
<P>
Normally, whenever a trigger is activated within a window, it will become the default activation object the next time around. Even if a trigger has HINT_DEFAULT_DEFAULT_ACTION, if some other trigger is activated, that other trigger will become the default action in the future. To prevent these automatic default overrides, add HINT_PREVENT_DEFAULT_OVERRIDES to the object's instance data.</P>
<P>
HINT_ENSURE_TEMPORARY_DEFAULT ensures that an object that can be navigated to (via the TAB key for example) will act as a default activation object even if the specific UI does not normally allow such behavior. (OSF/Motif does this automatically.)</P>


<H4 CLASS="HeadingC">
<A NAME="GenClass_15.htm_42812">
 </A>
Keyboard Navigation Hints</H4>
<PRE>HINT_NAVIGATION_ID, HINT_NAVIGATION_NEXT_ID</PRE>
<P>
Most specific UIs allow keyboard navigation within windows, usually through use of the TAB key. Normally, the navigation path follows the order of the children within the windowed object, and this is sufficient for most needs. </P>
<P>
HINT_NAVIGATION_ID sets a navigation identifier for an object. Objects may &quot;jump&quot; to this object by including HINT_NAVIGATION_NEXT_ID in their instance data with a value equal to the matching navigation ID of the object to travel to.</P>
<P CLASS="figTitle">
Code Display 2-27 Navigation IDs</P>
<PRE>/* Essentially, this code allows keyboard navigation to skip the Two 
 * trigger. Hitting the TAB key on the `One' trigger navigates the focus to the
 * Three trigger. */</PRE>
<PRE>@object GenTriggerClass One = {
    GI_visMoniker = &quot;TAB here to get to Three&quot;;
    HINT_NAVIGATION_NEXT_ID = 3;
}</PRE>
<PRE>@object GenTriggerClass Two = {
    GI_visMoniker = &quot;2&quot;;
}</PRE>
<PRE>@object GenTriggerClass Three = {
    GI_visMoniker = &quot;3&quot;;
    HINT_NAVIGATION_ID = 3;
}</PRE>
<P>
Note that an object with a matching navigation ID must exist, so this method is not recommended. If possible, your UI should be constructed in such a way to allow the default behavior.</P>

<HR>
<A NAME="GenClass_16.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">GenClass</A>: 6.3 <A HREF="#GenClass_13.htm">Vardata</A>: 
<A NAME="GenClass_16.htm_89895">
 </A>
Dynamically Managing VarData</H3>
<PRE>MSG_META_ADD_VAR_DATA, MSG_META_DELETE_VAR_DATA, MSG_GEN_ADD_GEOMETRY_HINT, MSG_GEN_REMOVE_GEOMETRY_HINT</PRE>
<P>
You must use special kernel routines and <CODE>
MetaClass</CODE>
 messages to access, add, or remove entries within an object's instance fields.</P>
<UL>
<LI>
<CODE>
ObjVarScanData()<BR>
</CODE>
<A NAME="GenClass_16.htm_IX_ObjVarScanData">
 </A>
This routine scans an object's vardata and calls routines listed in the variable data handler table. This routine is useful for processing several HINTs and ATTRs at one time.</LI>
<LI>
<CODE>
MSG_META_ADD_VAR_DATA<BR>
</CODE>
You can use this message to add a vardata entry to an object. The object must first be set not usable before adding the entry. Set the object usable again after you have added the vardata entry.</LI>
<LI>
<CODE>
MSG_META_DELETE_VAR_DATA<BR>
</CODE>
Use this message to delete a vardata entry from an object. The object must first be set not usable before removing the entry. Set the object usable again after you have removed the vardata entry.</LI>
<LI>
<CODE>
ObjVarFindData()<BR>
</CODE>
<A NAME="GenClass_16.htm_IX_ObjVarFindData">
 </A>
This routine checks the object for the passed type and returns a pointer to its data. The message returns <CODE>
true</CODE>
 if the entry is present,<CODE>
 false</CODE>
 if it is not. This routine is useful for processing a single vardata entry.</LI>
</UL>
<P>
In addition to these routines and messages, two messages specific to <CODE>
GenClass</CODE>
 allow you to add or remove hints dynamically: <CODE>
MSG_GEN_ADD_GEOMETRY_HINT</CODE>
 and <CODE>
MSG_GEN_REMOVE_GEOMETRY_HINT</CODE>
. These messages allow geometry and window positioning hints to be added or removed while the object is on-screen. Sending a GS_USABLE object one of these messages with a valid geometry hint forces that object to redraw itself according to the new geometry.</P>

<H6 CLASS="RefETitle">
<A NAME="GenClass_16.htm_IX_MSG_GEN_ADD_GEOMETRY_HINT">
 </A>
MSG_GEN_ADD_GEOMETRY_HINT</H6>
<PRE CLASS="syntax">void	MSG_GEN_ADD_GEOMETRY_HINT(
        word		hint,
        word		hintArgument,
        VisUpdateMode		updateMode);</PRE>
<P>
This message adds a geometry hint to a generic object. The object may be GS_USABLE at the time, in which case the object is redrawn according to the new geometry configuration.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any generic object.</P>
<P CLASS="refField">
Parameters:	<EM>
hint</EM>
	The hint to add to the object's instance data</P>
<DL>
<DT>
<EM>
hintArgument</EM>
</DT><DD>A word of data for any hints that require an argument.</DD>
<DT>
<EM>
updateMode</EM>
</DT><DD><CODE>
VisUpdateMode</CODE>
 to determine when the object will be redrawn.</DD>
</DL>
<P CLASS="refField">
Interception:	Generally not intercepted.</P>


<H6 CLASS="RefETitle">
<A NAME="GenClass_16.htm_IX_MSG_GEN_REMOVE_GEOMETRY_HINT">
 </A>
MSG_GEN_REMOVE_GEOMETRY_HINT</H6>
<PRE CLASS="syntax">void	MSG_GEN_REMOVE_GEOMETRY_HINT(
        word		hint,
        VisUpdateMode		updateMode);</PRE>
<P>
This message removes a geometry hint from an object's instance data. The object may be GS_USABLE at the time, in which case it will be redrawn according to the new geometry configuration.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any generic object.</P>
<P CLASS="refField">
Parameters:	<EM>
hint</EM>
	The hint to remove.</P>
<DL>
<DT>
<EM>
updateMode</EM>
</DT><DD><CODE>
VisUpdateMode</CODE>
 to determine when the object will be redrawn.</DD>
</DL>
<P CLASS="refField">
Interception:	Generally not intercepted.</P>

<HR>
<A NAME="GenClass_17.htm"></A>


<H2 CLASS="sectionTitle">
<A HREF="#index.htm">GenClass</A>: 7 
<A NAME="GenClass_17.htm_27607">
 </A>
Special Message Passing</H2>
<P>
<A NAME="GenClass_17.htm_IX_Classed events:with generic objects">
 </A>
It is often useful to pass messages &quot;generically&quot; rather than having to specify the particular optr directly. For example, in many cases, retrieving and storing the optr of an object is cumbersome, and it would be much easier to say &quot;deliver this message to my parent.&quot; <CODE>
GenClass</CODE>
 provides many useful messages which handle cases such as these. These message passers are of three types:</P>
<UL>
<LI>
Parent and Child Generic Message Passers</LI>
<LI>
Generic Upward Queries</LI>
<LI>
Object-Specific Upward Queries</LI>
</UL>
<P>
In all cases, the message must be stored as a <EM>
classed event</EM>
. A classed event is a combination of a class and a message. The message itself may pass data. The classed event enables the object to specify which class it would like the message to be handled by. In Goc, a classed event is created by encapsulating the message and class using the<STRONG> </STRONG><CODE>
@record</CODE>
 keyword.</P>
<P CLASS="subsectionLink">
<A HREF="#GenClass_18.htm">Parent and Child Message Passing</A></P>
<P CLASS="subsectionLink">
<A HREF="#GenClass_19.htm">Generic Upward Queries</A></P>
<P CLASS="subsectionLink">
<A HREF="#GenClass_1a.htm">Object-Specific Queries</A></P>
<HR>
<A NAME="GenClass_18.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">GenClass</A>: 7.1 <A HREF="#GenClass_17.htm">Special Message Passing</A>: 
Parent and Child Message Passing</H3>
<PRE>MSG_GEN_CALL_PARENT, MSG_GEN_SEND_TO_PARENT, MSG_GEN_SEND_TO_CHILDREN</PRE>
<P>
Three messages enable you to pass other messages to a generic object's parents and children without having to know the proper optrs. Using these messages, you can perform operations on any generic object's parents and children. If you need return values from an operation being performed by the parent object, use <CODE>
MSG_GEN_CALL_PARENT</CODE>
. If no return values are needed, you may use <CODE>
MSG_GEN_SEND_TO_PARENT</CODE>
. </P>
<P>
To pass a message to all of your generic children, use <CODE>
MSG_GEN_SEND_TO_CHILDREN</CODE>
. Note that no comparable <CODE>
MSG_GEN_CALL_CHILDREN</CODE>
 exists because it is meaningless to expect return values from multiple objects for a single event.</P>
<P>
You may also use the Goc macros <CODE>
genParent</CODE>
 and <CODE>
genChildren</CODE>
 to send a message to a parent or the generic children of an object.</P>

<H6 CLASS="RefETitle">
<A NAME="GenClass_18.htm_IX_MSG_GEN_CALL_PARENT">
 </A>
MSG_GEN_CALL_PARENT</H6>
<PRE CLASS="syntax">void	MSG_GEN_CALL_PARENT(
        EventHandle		event);</PRE>
<P>
This message delivers an event to the generic parent of the recipient. This message must pass a classed event that the parent object will handle. You should use this message if return values are expected. Always make sure to cast the return (following the call) into the proper type. The most effective way to do this is by enclosing the actual message sent within parentheses. The event will be freed after it is sent.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any generic object.</P>
<P CLASS="refField">
Parameters:	<EM>
event</EM>
	The classed event to deliver to parent of this object.</P>
<P CLASS="refField">
Return:	The return value of the classed event (cast to the proper type).</P>
<P CLASS="refField">
Interception:	Generally not intercepted. Custom gadgets may handle to supplement or supersede default functionality.</P>
<P CLASS="figTitle">
Code Display 2-28 MSG_GEN_CALL_PARENT</P>
<PRE>/* The following method retrieves the visual moniker
 * of an object's parent. */</PRE>
<PRE>@method MyProcessClass, MSG_GET_MY_PARENTS_MONIKER {
    ChunkHandle parentMoniker;
    EventHandle myEvent;</PRE>
<PRE>	/* Encapsulate the message to be handled
	 * by any generic (GenClass) object. */</PRE>
<PRE>    myEvent = @record GenClass::MSG_GEN_GET_MONIKER();</PRE>
<PRE>/* Calls the parent of EntryNumberTwo with the classed event specified above. Note
 * that the return value is cast to type (MSG_GEN_GET_MONIKER) because
 * MSG_GEN_CALL_PARENT itself returns void. */</PRE>
<PRE>    parentMoniker = @call (MSG_GEN_GET_MONIKER) 
			@EntryNumberTwo::MSG_GEN_CALL_PARENT(myEvent);
    return(parentMoniker); /* return the parentMoniker. */
}</PRE>


<H6 CLASS="RefETitle">
<A NAME="GenClass_18.htm_IX_MSG_GEN_SEND_TO_PARENT">
 </A>
MSG_GEN_SEND_TO_PARENT</H6>
<PRE CLASS="syntax">void	MSG_GEN_SEND_TO_PARENT(
        EventHandle event);</PRE>
<P>
This message sends an encapsulated event to the parent but expects no return values. The event will be freed after it is sent.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any generic object.</P>
<P CLASS="refField">
Parameters:	<EM>
event</EM>
	The classed event to deliver to parent of this object.</P>
<P CLASS="refField">
Interception:	Generally not intercepted. Custom gadgets may handle to supplement or supersede default functionality. </P>


<H6 CLASS="RefETitle">
<A NAME="GenClass_18.htm_IX_MSG_GEN_SEND_TO_CHILDREN">
 </A>
MSG_GEN_SEND_TO_CHILDREN</H6>
<PRE CLASS="syntax">void	MSG_GEN_SEND_TO_CHILDREN(
        EventHandle event);</PRE>
<P>
This message sends an encapsulated event to all children of the generic object receiving it. This message cannot return values. The event will be freed after it is sent.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any generic object.</P>
<P CLASS="refField">
Parameters:	<EM>
event</EM>
	The classed event to deliver to all children.</P>
<P CLASS="refField">
Interception:	Generally not intercepted. Custom gadgets may handle to supplement or supersede default functionality.</P>

<HR>
<A NAME="GenClass_19.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">GenClass</A>: 7.2 <A HREF="#GenClass_17.htm">Special Message Passing</A>: 
Generic Upward Queries</H3>
<PRE>MSG_GEN_GUP_CALL_OBJECT_OF_CLASS, MSG_GEN_GUP_SEND_TO_OBJECT_OF_CLASS, MSG_GEN_GUP_TEST_FOR_OBJECT_OF_CLASS, MSG_GEN_GUP_FIND_OBJECT_OF_CLASS, MSG_GEN_GUP_QUERY, MSG_GEN_GUP_INTERACTION_COMMAND, MSG_GEN_GUP_FINISH_QUIT</PRE>
<P>
<CODE>
GenClass</CODE>
<A NAME="GenClass_19.htm_IX_Generic upward queries">
 </A>
 provides the capability to search up the generic tree beyond the parent. Using the following messages, the UI can continue passing classed events up the generic tree until it reaches an object of the proper class. This behavior is known as a Generic UPward query (GUP).</P>
<P>
For example, if you specify <CODE>
GenInteractionClass</CODE>
 in your classed event and later send a GUP message to any object in the generic tree, the stored message will be handled at the first available GenInteraction object it encounters. </P>
<P>
<CODE>
MSG_GEN_GUP_CALL_OBJECT_OF_CLASS</CODE>
 performs a GUP, returning values from the passed message. You must cast the return values into the proper type based on the return values of the passed message. <CODE>
MSG_GEN_GUP_SEND_TO_OBJECT_OF_CLASS</CODE>
 performs a GUP but does not allow return values.</P>
<P>
<CODE>
MSG_GEN_GUP_TEST_FOR_OBJECT_OF_CLASS</CODE>
 performs a GUP whose sole function is to search for the existence of an object of the specified class among the object's parents.</P>
<P>
<CODE>
MSG_GEN_GUP_FIND_OBJECT_OF_CLASS</CODE>
 performs a GUP searching for any object of the passed class, but it also returns the optr of the object found. Note that it is unwise to later use this optr as the generic tree may have changed.</P>

<H6 CLASS="RefETitle">
<A NAME="GenClass_19.htm_IX_MSG_GEN_GUP_CALL_OBJECT_OF_CLASS">
 </A>
MSG_GEN_GUP_CALL_OBJECT_OF_CLASS</H6>
<PRE CLASS="syntax">void	MSG_GEN_GUP_CALL_OBJECT_OF_CLASS(
        EventHandle event);</PRE>
<P>
This message performs a generic upward query, passing the classed event upward until it reaches an object of the passed class. This message allows return values and should be cast into whatever return values are expected of the passed message. This is most easily done by enclosing the message sent within parentheses.</P>
<P>
An object of the expected class should be present or the event will not be delivered to any object. To check for the existence of such a class, use <CODE>
MSG_GEN_GUP_TEST_FOR_OBJECT_OF_CLASS</CODE>
.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any generic object.</P>
<P CLASS="refField">
Parameters:	<EM>
event</EM>
	The classed event to deliver to an object up the generic tree.</P>
<P CLASS="refField">
Return:	The return values of the classed event (cast to the proper type).</P>
<P CLASS="refField">
Interception:	Generally not intercepted. Custom gadgets may handle to supplement or supersede default functionality. </P>


<H6 CLASS="RefETitle">
<A NAME="GenClass_19.htm_IX_MSG_GEN_GUP_SEND_TO_OBJECT_OF_CLASS">
 </A>
MSG_GEN_GUP_SEND_TO_OBJECT_OF_CLASS</H6>
<PRE CLASS="syntax">void	MSG_GEN_GUP_SEND_TO_OBJECT_OF_CLASS(
        EventHandle event);</PRE>
<P>
This message performs a generic upward query, passing the classed event upward until it reaches an object of the described class. Since this message performs a send, it does not allow return values. An object of the expected class should be present; otherwise, the event will not be delivered to any object. To check for the existence of such a class, use <CODE>
MSG_GEN_GUP_TEST_FOR_OBJECT_OF_CLASS</CODE>
.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any generic object.</P>
<P CLASS="refField">
Parameters:	<EM>
event</EM>
	The classed event to deliver to an object up the generic tree.</P>
<P CLASS="refField">
Interception:	Generally not intercepted. Custom gadgets may handle to supplement or supersede default functionality. </P>
<P CLASS="figTitle">
Code Display 2-29 Nesting Classed Events</P>
<PRE>/* The following method can be used by any object in the generic tree below the
 * primary to set all menus and GenInteractions below the primary window enabled
 * all at once. */</PRE>
<PRE>@method MyProcessClass, MSG_ENABLE_ALL_MY_MENUS {
    EventHandle menuEvent, primaryEvent;</PRE>
<PRE>/* The first classed event (menuEvent) encapsulates MSG_GEN_SET_ENABLED for any
 * object of GenInteractionClass (typically menus). The @record keyword
 * encapsulates the message to be handled by GenInteractionClass. The
 * VisUpdateMode delays updates via the Application queue to avoid constant visual
 * updates and &quot;flashing.&quot; */</PRE>
<PRE>    menuEvent = @record GenInteractionClass::MSG_GEN_SET_ENABLED( 
					VUM_DELAYED_VIA_APP_QUEUE);</PRE>
<PRE>/* The second classed event binds MSG_GEN_SEND_TO_CHILDREN to the GenPrimaryClass.
 * Sending this message to the GenPrimary will send the menuEvent to all
 * its children. In this case, sending this event to the Primary will send
 * MSG_GEN_SET_ENABLED to all its GenInteraction children. */</PRE>
<PRE>    primaryEvent = @record GenPrimaryClass::MSG_GEN_SEND_TO_CHILDREN(menuEvent);</PRE>
<PRE>/* Finally, to send this message to the GenPrimary from any object below the
 * GenPrimary, simply send a MSG_GEN_GUP_SEND_TO_OBJECT_OF_CLASS with the
 * PrimaryEvent above. The GUP message will send the message
 * MSG_GEN_SEND_TO_CHILDREN up the generic tree until it encounters the GenPrimary,
 * at which point the Primary will send the MenuEvent MSG_GEN_SEND_TO_CHILDREN to
 * all its GenInteraction children. */</PRE>
<PRE>    @send @MyObject::MSG_GEN_GUP_SEND_TO_OBJECT_OF_CLASS(primaryEvent);
}</PRE>


<H6 CLASS="RefETitle">
<A NAME="GenClass_19.htm_IX_MSG_GEN_GUP_TEST_FOR_OBJECT_OF_CLASS">
 </A>
MSG_GEN_GUP_TEST_FOR_OBJECT_OF_CLASS</H6>
<PRE CLASS="syntax">Boolean	MSG_GEN_GUP_TEST_FOR_OBJECT_OF_CLASS(
        ClassStruct  *class);</PRE>
<P>
This message searches up the generic tree for any object of the specific class. This message is useful for testing the existence of required classes before sending <CODE>
MSG_GEN_GUP_CALL_OBJECT_OF_CLASS</CODE>
 and <CODE>
MSG_GEN_GUP_SEND_TO_OBJECT_OF_CLASS</CODE>
. </P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any generic object.</P>
<P CLASS="refField">
Parameters:	<EM>
class</EM>
	<CODE>
ClassStruct</CODE>
 to search for among the object's parents.</P>
<P CLASS="refField">
Return:	Will return <CODE>
true </CODE>
if the class is found, <CODE>
false</CODE>
 if not.</P>
<P CLASS="refField">
Interception:	Generally not intercepted. Custom gadgets may handle to supplement or supersede default functionality.</P>


<H6 CLASS="RefETitle">
<A NAME="GenClass_19.htm_IX_MSG_GEN_GUP_FIND_OBJECT_OF_CLASS">
 </A>
MSG_GEN_GUP_FIND_OBJECT_OF_CLASS</H6>
<PRE CLASS="syntax">optr	MSG_GEN_GUP_FIND_OBJECT_OF_CLASS(
        ClassStruct  *class);</PRE>
<P>
This message performs a function similar to that of <CODE>
MSG_GEN_GUP_TEST_FOR_OBJECT_OF_CLASS</CODE>
, but it returns the optr of the class found, if any. This optr can then be used as the recipient of other messages. You should not use an optr returned by this message at a later time, as the object may have been removed.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any generic object.</P>
<P CLASS="refField">
Parameters:	<EM>
class</EM>
	<CODE>
ClassStruct</CODE>
 to search for.</P>
<P CLASS="refField">
Return:	The optr of the object of the requested class, or a null optr if no such object was found.</P>
<P CLASS="refField">
Interception:	Generally not intercepted. Custom gadgets may handle to supplement or supersede default functionality.</P>


<H6 CLASS="RefETitle">
<A NAME="GenClass_19.htm_IX_MSG_GEN_GUP_QUERY">
 </A>
MSG_GEN_GUP_QUERY</H6>
<PRE CLASS="syntax">void 	MSG_GEN_GUP_QUERY(
        GenReturnParams 		*retValue,
        word 		queryType);</PRE>
<P>
This message is used to query up the generic composite tree. </P>
<P CLASS="refField">
Source:	Anyone.</P>
<P CLASS="refField">
Destination:	Any usable generic object, though only certain objects will answer certain queries.</P>
<P CLASS="refField">
Parameters:	<EM>retValue</EM> 	Structure to hold return values.</P>
<DL>
<DT>
<EM>queryType</EM> </DT><DD><CODE>
GenUpwardQueryType</CODE>
.</DD>
</DL>
<P>
The <CODE>
GenUpwardQueryType</CODE>
 should be one of the following:</P>
<DL>
<DT>
GUQT_DELAYED_OPERATION</DT><DD>
<A NAME="GenClass_19.htm_IX_GenUpwardQueryType">
 </A>
<A NAME="GenClass_19.htm_IX_GUQT_DELAYED_OPERATION">
 </A>
This query type determines if a gadget should be operating in &quot;delayed mode,&quot; i.e., whether it should wait for a MSG_GEN_APPLY before sending notification to its output, or whether it should send notification whenever it changes state.</DD>
<DT>
GUQT_FIELD</DT><DD>
<A NAME="GenClass_19.htm_IX_GUQT_&ldots;">
 </A>
Returns field object in GRP_<CODE>
cx</CODE>
:GRP_<CODE>
dx</CODE>
 and window (if realized) handle in GRP_<CODE>
bp</CODE>
. This is a reasonably safe thing to do, since the field window will remain open until all applications within the field are shut down. Only field objects or substitutes for them should intercept this message.</DD>
<DT>
GUQT_SCREEN</DT><DD>
Returns screen object in GRP_<CODE>
cx</CODE>
:GRP_<CODE>
dx</CODE>
 and window (if any) handle in GRP_<CODE>
bp</CODE>
. This is a reasonably safe thing to do, since the screen window will remain open until all applications within the field are shut down. Screen object being returned will be default screen for the field.</DD>
</DL>
<P CLASS="refField">
Return:	Nothing returned explicitly. <EM>retValue</EM> struct filled with values which depend on query type.</P>
<P CLASS="refField">
Structures:	</P>
<PRE><A NAME="GenClass_19.htm_IX_GenReturnParams"> </A><A NAME="IX_GRP_&ldots;"> </A>typedef struct {
	word 	GRP_ax;
	word 	GRP_bp;
	word 	GRP_cx;
	word 	GRP_dx;</PRE>
<PRE>} GenReturnParams;</PRE>


<H6 CLASS="RefETitle">
<A NAME="GenClass_19.htm_IX_MSG_GEN_GUP_INTERACTION_COMMAND">
 </A>
MSG_GEN_GUP_INTERACTION_COMMAND</H6>
<PRE CLASS="syntax">Boolean 	MSG_GEN_GUP_INTERACTION_COMMAND(
        InteractionCommand 		command);</PRE>
<P>
This message travels up the generic tree until it reaches a non-GIT_ORGANIZATIONAL GenInteraction. Once there, it performs the indicated <CODE>
InteractionCommand</CODE>
. See <CODE>
InteractionCommand</CODE>
 declaration for the different command types and how specific user interfaces interpret the commands. If the GenInteraction is a dialog brought up with <CODE>
UserDoDialog()</CODE>
, <CODE>
InteractionCommand</CODE>
 will be returned to the caller, after performing the command, via <CODE>
MSG_GEN_INTERACTION_RELEASE_BLOCKED_THREAD_WITH_RESPONSE</CODE>
.</P>
<P CLASS="refField">
Source:	Unrestricted. Normally sent by a <CODE>
MSG_GEN_INTERACTION_ACTIVATE_COMMAND</CODE>
 handler or by a custom trigger's action message handler to perform some default command after perform some application-specific function.</P>
<P CLASS="refField">
Destination:	Any generic object. Will travel up generic tree, stopping at first non organizational interaction.</P>
<P CLASS="refField">
Parameters:	<EM>command</EM> 	Standard InteractionCommand.</P>
<P CLASS="refField">
Return:	Returns <EM>
true</EM>
 if handled.</P>
<P CLASS="refField">
Interception:	Not normally intercepted.</P>


<H6 CLASS="RefETitle">
<A NAME="GenClass_19.htm_IX_MSG_GEN_GUP_FINISH_QUIT">
 </A>
MSG_GEN_GUP_FINISH_QUIT</H6>
<PRE CLASS="syntax">void 	MSG_GEN_GUP_FINISH_QUIT(
        Boolean 		abortFlag, 
        Boolean 		notifyParent); </PRE>
<P>
<A NAME="GenClass_19.htm_IX_Active list:MSG_GEN_GUP_FINISH_QUIT">
 </A>
Message to be used by nodes that implement a GCN active list. This should be used if <CODE>
MSG_META_QUIT</CODE>
 is handled and sent to the active list items by that node. When a node has finished sending a <CODE>
MSG_META_QUIT</CODE>
 to the active list or if the quit is aborted, this allows the notification of the above node in the generic tree.</P>
<P CLASS="refField">
Source:	Sent by active list nodes that implement quit mechanism.</P>
<P CLASS="refField">
Destination:	Any generic object involved in quit mechanism.</P>
<P CLASS="refField">
Parameters:	<EM>abortFlag</EM> 	Pass true to abort. This will be passed on to <CODE>
MSG_META_FINISH_QUIT</CODE>
.</P>
<DL>
<DT>
<EM>notifyParent</EM> </DT><DD>Pass true to notify parent of finished quit sequence.</DD>
</DL>
<P CLASS="refField">
Interception:	Generally not intercepted. Default handler sends <CODE>
MSG_META_FINISH_QUIT</CODE>
 to self, then sends to generic parent if flag indicates such. <CODE>
MSG_META_FINISH_QUIT</CODE>
 is normally the message to intercept to know when a quit is aborted or finished.</P>

<HR>
<A NAME="GenClass_1a.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">GenClass</A>: 7.3 <A HREF="#GenClass_17.htm">Special Message Passing</A>: 
Object-Specific Queries</H3>
<PRE>MSG_GEN_CALL_APPLICATION, MSG_GEN_SEND_TO_PROCESS, MSG_GEN_CALL_SYSTEM,MSG_GEN_OUTPUT_ACTION MSG_GEN_QUERY_NEED_TO_BE_ON_ACTIVE_LIST</PRE>
<P>
Besides the Generic Upward Queries, <CODE>
GenClass</CODE>
 also contains several object-specific queries. These messages behave in the same manner as the GUP messages except that there is no need to set up a classed event. The object-specific upward query automatically sets up the class to send the message to.</P>
<P>
<CODE>
MSG_GEN_CALL_APPLICATION</CODE>
 sends a message up the generic tree to the GenApplication object. This message allows return values and should be cast to whatever return values are expected of the passed message.</P>
<P>
<CODE>
MSG_GEN_SEND_TO_PROCESS</CODE>
 sends a message to the process object associated with this object. Because this message may cross threads, no return values are allowed.</P>
<P>
<CODE>
MSG_GEN_CALL_SYSTEM</CODE>
 sends a message up the generic tree to the GenSystem object. This message allows return values and should be cast into whatever return values are expected of the passed message.</P>
<P>
MSG_GEN_QUERY_NEED_TO_BE_ON_ACTIVE_LIST </P>

<H6 CLASS="RefETitle">
<A NAME="GenClass_1a.htm_IX_MSG_GEN_CALL_APPLICATION">
 </A>
MSG_GEN_CALL_APPLICATION</H6>
<PRE CLASS="syntax">void	MSG_GEN_CALL_APPLICATION(
        EventHandle event);</PRE>
<P>
<A NAME="GenClass_1a.htm_IX_GenApplication:generic upward queries">
 </A>
This message calls the GenApplication object associated with the recipient. This message allows return values and should be cast to whatever return values are expected of the passed message.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any generic object.</P>
<P CLASS="refField">
Parameters:	<EM>
event</EM>
	The classed event to deliver to the object's GenApplication object.</P>
<P CLASS="refField">
Return:	The return values of the classed event (cast to the proper type).</P>
<P CLASS="refField">
Interception:	Generally not intercepted. Custom gadgets may handle to supplement or supersede default functionality.</P>


<H6 CLASS="RefETitle">
<A NAME="GenClass_1a.htm_IX_MSG_GEN_SEND_TO_PROCESS">
 </A>
MSG_GEN_SEND_TO_PROCESS</H6>
<PRE CLASS="syntax">void	MSG_GEN_SEND_TO_PROCESS(
        EventHandle event);</PRE>
<P>
<A NAME="GenClass_1a.htm_IX_ProcessClass:generic upward queries">
 </A>
This message sends the event to the Process object of your application. Because the message may cross threads, return values are not allowed.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any generic object.</P>
<P CLASS="refField">
Parameters:	<EM>
event</EM>
	The classed event to deliver to the object's GenProcess object.</P>
<P CLASS="refField">
Interception:	Generally not intercepted. Custom gadgets may handle to supplement or supersede default functionality.</P>


<H6 CLASS="RefETitle">
<A NAME="GenClass_1a.htm_IX_MSG_GEN_CALL_SYSTEM">
 </A>
MSG_GEN_CALL_SYSTEM</H6>
<PRE CLASS="syntax">void	MSG_GEN_CALL_SYSTEM(
        EventHandle event);</PRE>
<P>
<A NAME="GenClass_1a.htm_IX_GenSystemClass:generic upward queries">
 </A>
This message calls the GenSystem object (the root object) associated with your application and sends the event. If you expect return values, make sure to cast them into the proper variable type.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any generic object.</P>
<P CLASS="refField">
Parameters:	<CODE>
event</CODE>
	The classed event to deliver to the object's GenSystem object.</P>
<P CLASS="refField">
Return:	The return values of the classed event (cast to the proper type).</P>
<P CLASS="refField">
Interception:	Generally not intercepted. Custom gadgets may handle to supplement or supersede default functionality.</P>


<H6 CLASS="RefETitle">
<CODE>
MSG_GEN_OUTPUT_ACTION</CODE>
<A NAME="GenClass_1a.htm_IX_MSG_GEN_OUTPUT_ACTION">
 </A>
</H6>
<PRE CLASS="syntax"><CODE> </CODE>void<CODE>	MSG_GEN_OUTPUT_ACTION(</CODE>
        EventHandle		event,
        optr		dest);</PRE>
<P>
This message sends an event via the destination optr (if any) of the object sent the message. The default handler (which is rarely subclassed) also scans the vardata looking for an <CODE>
ATTR_GEN_DESTINATION_CLASS</CODE>
 and records that class in a classed event.</P>
<P>
This message is usually sent at a low level and dispatches a message via the destination optr of the object. You may intercept <CODE>
MSG_GEN_OUTPUT_ACTION</CODE>
 if you wish knowledge of when an object is being activated (although you may wish to intercept <CODE>
MSG_GEN_ACTIVATE</CODE>
 in those cases). If you do send this message yourself, you must either pass a destination optr or leave it null, depending on the object being activated.</P>
<P CLASS="refField">
Source:	Normally sent by an object to itself.</P>
<P CLASS="refField">
Destination:	Normally sent by an object to itself.</P>
<P CLASS="refField">
Parameters:	<EM>
event</EM>
	A classed event.</P>
<DL>
<DT>
<EM>
optr</EM>
</DT><DD>The destination optr to send event to or a <CODE>
TravelOption</CODE>
.</DD>
</DL>
<P CLASS="refField">
Interception:	Generally not intercepted.</P>


<H6 CLASS="RefETitle">
<A NAME="GenClass_1a.htm_IX_MSG_GEN_QUERY_NEED_TO_BE_ON_ACTIVE_LIST">
 </A>
MSG_GEN_QUERY_NEED_TO_BE_ON_ACTIVE_LIST</H6>
<PRE CLASS="syntax">Boolean	MSG_GEN_QUERY_NEED_TO_BE_ON_ACTIVE_LIST();</PRE>
<P>
<A NAME="GenClass_1a.htm_IX_Active list:MSG_GEN_QUERY_NEED_TO_BE_ON_ACTIVE_LIST">
 </A>
This message queries whether an object still needs to be on an active list. The active list mechanism sends this message if a mechanism no longer needs an object to remain on the active list; it checks whether any other mechanism also needs the object to be on the active list also. Windowed specific UI objects, for example, will return <EM>
true</EM>
 if ATTR_INITIATE_ON_STARTUP is present on the object, because this optional attribute requires the object to be on the active list.</P>
<P CLASS="refField">
Source:	Unrestricted, though it is generally called on itself. Specifically, if an object no longer needs to remain on the active list for a particular reason, this message should be called on the object to see if it should remain on the active list for any other reason. If so, the caller should not remove the object from the active list. The only exception to this would be if the object were being destroyed, in which the object should be removed in any case.</P>
<P CLASS="refField">
Destination:	Any generic object.</P>
<P CLASS="refField">
Return:	<EM>
true</EM>
 if the object needs to remain on the active list for some other reason.</P>
<P CLASS="refField">
Interception:	Object classes which add the object to the active list must intercept this message and return <EM>
true</EM>
 if the class desires the object to remain on the active list. If the message is intercepted and this is not the case, it should be sent to the superclass for handling.</P>

<HR>
<A NAME="GenClass_1b.htm"></A>


<H2 CLASS="sectionTitle">
<A HREF="#index.htm">GenClass</A>: 8 
Visual Refreshing</H2>
<PRE>MSG_GEN_UPDATE_VISUAL</PRE>
<P>
<CODE>
MSG_GEN_UPDATE_VISUAL</CODE>
 performs a visual update of the object sent the message. Use this message to force a visual update on objects previously updated using the <CODE>
VisUpdateMode</CODE>
 VUM_MANUAL.</P>

<H6 CLASS="RefETitle">
<A NAME="GenClass_1b.htm_IX_MSG_GEN_UPDATE_VISUAL">
 </A>
MSG_GEN_UPDATE_VISUAL</H6>
<PRE CLASS="syntax">void	MSG_GEN_UPDATE_VISUAL(
        VisUpdateMode updateMode);</PRE>
<P>
<A NAME="GenClass_1b.htm_IX_Visual updates:MSG_GEN_UPDATE_VISUAL">
 </A>
This message updates the visual tree at the node specified and is used for updating objects modified with VUM_MANUAL.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any generic object.</P>
<P CLASS="refField">
Parameters:	<EM>
updateMode</EM>
	<CODE>
VisUpdateMode</CODE>
 to determine when the object should be redrawn.</P>
<P CLASS="refField">
Interception:	Generally not intercepted.</P>

<HR>
<A NAME="GenClass_1c.htm"></A>


<H2 CLASS="sectionTitle">
<A HREF="#index.htm">GenClass</A>: 9 
Setting Sizes</H2>
<PRE>MSG_GEN_SET_INITIAL_SIZE, MSG_GEN_SET_MINIMUM_SIZE, MSG_GEN_SET_MAXIMUM_SIZE, MSG_GEN_SET_FIXED_SIZE, MSG_GEN_GET_INITIAL_SIZE, MSG_GEN_GET_MINIMUM_SIZE, MSG_GEN_GET_MAXIMUM_SIZE, MSG_GEN_GET_FIZED_SIZE, MSG_GEN_RESET_TO_INITIAL_SIZE, CompSizeHintArgs</PRE>
<P>
<A NAME="GenClass_1c.htm_IX_Geometry:generic geometry messages">
 </A>
These messages all perform resizing operations on generic objects. In some cases, the geometry is not redone by sending these messages; the object will need to be set not usable and then set usable to force the new sizing scheme. In most cases, however, sending these messages will affect the current geometry of an object. These messages manipulate their associated hints, either by creating new hints or by altering old ones. As such, these messages will only affect an object if the associated hint does also.</P>
<P>
These messages alter four size restrictions associated with an object: initial, maximum, minimum, and fixed. These restrictions are set up using the <CODE>
GenClass</CODE>
 hints <CODE>
HINT_INITIAL_SIZE</CODE>
, <CODE>
HINT_MAXIMUM_SIZE</CODE>
, <CODE>
HINT_MINIMUM_SIZE</CODE>
, and <CODE>
HINT_FIXED_SIZE</CODE>
, all of which are described in <A HREF="../../UI/Geometry/combo.htm">the Managing UI Geometry chapter</A>.</P><P>
The size parameter required by each of these hints is a structure of type <CODE>
CompSizeHintArgs</CODE>
. This structure is shown below:</P>
<PRE><A NAME="GenClass_1c.htm_IX_CSHA_&ldots;"> </A><A NAME="IX_CompSizeHintArgs"> </A>typedef struct {
    SpecWidth			CSHA_width;
    SpecHeight			CSHA_height;
    sword			CSHA_count;
} CompSizeHintArgs;</PRE>
<P>
Many of the messages pass a structure of <CODE>
GetSizeArgs</CODE>
 to place size information retrieved from the message. This size information is used by the specific UI to visually construct the object, bypassing default sizes in the process. The structure is shown below:</P>
<PRE>typedef struct {
    word		GSA_width;
    word		GSA_height;
    word		GSA_unused;
    word		GSA_count;
} GetSizeArgs;</PRE>

<H6 CLASS="RefETitle">
<A NAME="GenClass_1c.htm_IX_MSG_GEN_GET_INITIAL_SIZE">
 </A>
MSG_GEN_GET_INITIAL_SIZE</H6>
<PRE CLASS="syntax">void	MSG_GEN_GET_INITIAL_SIZE(
        GetSizeArgs *initSize);</PRE>
<P>
<A NAME="GenClass_1c.htm_IX_HINT_INITIAL_SIZE">
 </A>
This message retrieves the initial size specifications of a generic object stored in the hint <CODE>
HINT_INITIAL_SIZE. </CODE>
The object must be passed a pointer to a structure of type <CODE>
GetSizeArgs</CODE>
 to store the retrieved data. If the hint <CODE>
HINT_INITIAL_SIZE</CODE>
 does not exist for this object<CODE>
, </CODE>
the structure passed to the object of size <CODE>
GetSizeArgs</CODE>
 will remain empty.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any generic object.</P>
<P CLASS="refField">
Parameters:	<EM>
initSize</EM>
	A pointer to an empty <CODE>
GetSizeArgs</CODE>
 structure.</P>
<P CLASS="refField">
Return:	The <CODE>
GetSizeArgs</CODE>
 structure will contain the object's initial size.</P>
<P CLASS="refField">
Interception:	Generally not intercepted.</P>


<H6 CLASS="RefETitle">
<A NAME="GenClass_1c.htm_IX_MSG_GEN_SET_INITIAL_SIZE">
 </A>
MSG_GEN_SET_INITIAL_SIZE</H6>
<PRE CLASS="syntax">void	MSG_GEN_SET_INITIAL_SIZE(@stack
        byte		updateMode,
        word		count,
        word		height,				/* SpecHeight */
        word		width);				/* SpecWidth */</PRE>
<P>
This message sets the initial size of a generic object (its size on being first built). This is only done by creating or modifying the hint <CODE>
HINT_INITIAL_SIZE</CODE>
; there is no guarantee that the specific UI will implement this message in the expected fashion. </P>
<P>
The message must pass a <CODE>
VisUpdateMode</CODE>
. This message will only affect the size of an object when it first opens; it will not modify the geometry of a currently built object. For the defined geometry to take effect on an already built object, the object must be set not usable and then set usable again.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any generic object.</P>
<P CLASS="refField">
Parameters:	<EM>
count</EM>
	The number of children (or zero, if not applicable).</P>
<DL>
<DT>
<EM>
height</EM>
</DT><DD>The height of each child.</DD>
<DT>
<EM>
width</EM>
</DT><DD>The width of the composite.</DD>
</DL>
<P CLASS="refField">
Interception:	Generally not intercepted.</P>


<H6 CLASS="RefETitle">
<A NAME="GenClass_1c.htm_IX_MSG_GEN_RESET_TO_INITIAL_SIZE">
 </A>
MSG_GEN_RESET_TO_INITIAL_SIZE</H6>
<PRE CLASS="syntax">void	MSG_GEN_RESET_TO_INITIAL_SIZE(
        VisUpdateMode		updateMode);</PRE>
<P>
This message forces the recipient and all of its children to be resized according to their initial size specifications. If the objects contain <CODE>
HINT_INITIAL_SIZE</CODE>
, they will be resized according to the hint; otherwise they will be resized according to their default geometry. This message is useful for activating sizes set with <CODE>
MSG_GEN_SET_INITIAL_SIZE</CODE>
.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any GS_USABLE generic object.</P>
<P CLASS="refField">
Parameters:	<EM>
updateMode</EM>
	<CODE>
VisUpdateMode</CODE>
 to determine when the object will be redrawn.</P>
<P CLASS="refField">
Interception:	Generally not intercepted.</P>


<H6 CLASS="RefETitle">
<A NAME="GenClass_1c.htm_IX_MSG_GEN_GET_MINIMUM_SIZE">
 </A>
MSG_GEN_GET_MINIMUM_SIZE</H6>
<PRE CLASS="syntax">void	MSG_GEN_GET_MINIMUM_SIZE(
        GetSizeArgs  *minSize);</PRE>
<P>
<A NAME="GenClass_1c.htm_IX_HINT_MINIMUM_SIZE">
 </A>
This message retrieves the recipient's minimum size specifications stored in the hint <CODE>
HINT_MINIMUM_SIZE</CODE>
. If <CODE>
HINT_MINIMUM_SIZE</CODE>
 is not set<CODE>
, </CODE>
the structure passed to the object will remain empty.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any generic object.</P>
<P CLASS="refField">
Parameters:	<EM>
minSize</EM>
	A pointer to an empty <CODE>
GetSizeArgs</CODE>
 structure.</P>
<P CLASS="refField">
Return:	The <CODE>
GetSizeArgs</CODE>
 structure will contain the object's minimum size.</P>
<P CLASS="refField">
Interception:	Generally not intercepted.</P>


<H6 CLASS="RefETitle">
<A NAME="GenClass_1c.htm_IX_MSG_GEN_SET_MINIMUM_SIZE">
 </A>
MSG_GEN_SET_MINIMUM_SIZE</H6>
<PRE CLASS="syntax">void	MSG_GEN_SET_MINIMUM_SIZE(@stack
        byte	updateMode,
        word	count,
        word	height,				/* SpecHeight */
        word	width);				/* SpecWidth */</PRE>
<P>
This message sets the minimum allowable size of an object. An object with a minimum size is not allowed to shrink smaller than the bounds set in <CODE>
HINT_MINIMUM_SIZE</CODE>
. This message alters the minimum size by creating or modifying the hint <CODE>
HINT_MINIMUM_SIZE</CODE>
. Due to the nature of hints, there is no guarantee that the specific UI will implement this message in the expected fashion. </P>
<P>
This message will modify the geometry of a currently built object, forcing that object to be unbuilt and then built again. Note that the minimum size of an object has nothing to do with the minimized state of an object (for GenDisplays, the iconification of an object) but merely the minimum allowable size of an object in its normal usable state.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any generic object.</P>
<P CLASS="refField">
Parameters:	<EM>
count</EM>
	The number of children (or zero, if not applicable).</P>
<DL>
<DT>
<EM>
height</EM>
</DT><DD>The height of each child.</DD>
<DT>
<EM>
width</EM>
</DT><DD>The width of the composite.</DD>
</DL>
<P CLASS="refField">
Interception:	Generally not intercepted.</P>


<H6 CLASS="RefETitle">
<A NAME="GenClass_1c.htm_IX_MSG_GEN_GET_MAXIMUM_SIZE">
 </A>
MSG_GEN_GET_MAXIMUM_SIZE</H6>
<PRE CLASS="syntax">void	MSG_GEN_GET_MAXIMUM_SIZE(
        GetSizeArgs  *maxSize);</PRE>
<P>
<A NAME="GenClass_1c.htm_IX_HINT_MAXIMUM_SIZE">
 </A>
This message retrieves the recipient's maximum size stored in the hint <CODE>
HINT_MAXIMUM_SIZE</CODE>
. If <CODE>
HINT_MAXIMUM_SIZE</CODE>
 is not set<CODE>
, </CODE>
the structure passed will remain empty.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any generic object.</P>
<P CLASS="refField">
Parameters:	<EM>
maxSize</EM>
	A pointer to an empty <CODE>
GetSizeArgs</CODE>
 structure.</P>
<P CLASS="refField">
Return:	The <CODE>
GetSizeArgs</CODE>
 structure will contain the object's maximum size.</P>
<P CLASS="refField">
Interception:	Generally not intercepted.</P>


<H6 CLASS="RefETitle">
<A NAME="GenClass_1c.htm_IX_MSG_GEN_SET_MAXIMUM_SIZE">
 </A>
MSG_GEN_SET_MAXIMUM_SIZE</H6>
<PRE CLASS="syntax">void	MSG_GEN_SET_MAXIMUM_SIZE(
        word	count,
        word	height,				/* SpecHeight */
        word	width);				/* SpecWidth */</PRE>
<P>
This message sets the maximum allowable size of an object. An object with a maximum size is not allowed to grow larger than the bounds set with <CODE>
HINT_MAXIMUM_SIZE</CODE>
. This message alters the maximum size by creating or modifying the hint <CODE>
HINT_MAXIMUM_SIZE</CODE>
. Due to the nature of hints, there is no guarantee that the specific UI will implement this message in the expected fashion.</P>
<P>
This message will modify the geometry of a currently built object, forcing that object to be unbuilt and then built again. Note that the maximum size of an object has nothing to do with the maximized state of an object but merely the maximum allowable size of an object in its normal usable state.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any generic object.</P>
<P CLASS="refField">
Parameters:	<EM>
count</EM>
	The number of children (or zero, if not applicable).</P>
<DL>
<DT>
<EM>
height</EM>
</DT><DD>The height of each child.</DD>
<DT>
<EM>
width</EM>
</DT><DD>The width of the composite.</DD>
</DL>
<P CLASS="refField">
Interception:	Generally not intercepted.</P>


<H6 CLASS="RefETitle">
<A NAME="GenClass_1c.htm_IX_MSG_GEN_GET_FIXED_SIZE">
 </A>
MSG_GEN_GET_FIXED_SIZE</H6>
<PRE CLASS="syntax">void	MSG_GEN_GET_FIXED_SIZE(
        GetSizeArgs *fixedSize);</PRE>
<P>
<A NAME="GenClass_1c.htm_IX_HINT_FIXED_SIZE">
 </A>
This message retrieves the size stored in <CODE>
HINT_FIXED_SIZE</CODE>
. If <CODE>
HINT_FIXED_SIZE</CODE>
 is not set, the structure passed will remain empty.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any generic object.</P>
<P CLASS="refField">
Parameters:	<EM>
fixedSize</EM>
	A pointer to an empty <CODE>
GetSizeArgs</CODE>
 structure.</P>
<P CLASS="refField">
Return:	The <CODE>
GetSizeArgs</CODE>
 structure will contain the object's fixed size.</P>
<P CLASS="refField">
Interception:	Generally not intercepted.</P>


<H6 CLASS="RefETitle">
<A NAME="GenClass_1c.htm_IX_MSG_GEN_SET_FIXED_SIZE">
 </A>
MSG_GEN_SET_FIXED_SIZE</H6>
<PRE CLASS="syntax">void	MSG_GEN_SET_FIXED_SIZE(
        word	count,
        word	height,				/* SpecHeight */
        word	width);				/* SpecWidth */</PRE>
<P>
This message sets the fixed size of an object. An object with a fixed size is forced to remain at the size set with <CODE>
HINT_FIXED_SIZE</CODE>
. This message alters this fixed size by creating or modifying <CODE>
HINT_FIXED_SIZE</CODE>
. Due to the nature of hints, there is no guarantee that the specific UI will implement this message in the expected fashion. </P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any generic object.</P>
<P CLASS="refField">
Parameters:	<EM>
count</EM>
	The number of children (or zero, if not applicable).</P>
<DL>
<DT>
<EM>
height</EM>
</DT><DD>The height of each child.</DD>
<DT>
<EM>
width</EM>
</DT><DD>The width of the composite.</DD>
</DL>
<P CLASS="refField">
Interception:	Generally not intercepted.</P>

<HR>
<A NAME="GenClass_1d.htm"></A>


<H2 CLASS="sectionTitle">
<A HREF="#index.htm">GenClass</A>: 10 
Activation Messages</H2>
<PRE>MSG_GEN_APPLY, MSG_GEN_PRE_APPLY, MSG_GEN_POST_APPLY, MSG_GEN_RESET, MSG_GEN_MAKE_APPLYABLE, MSG_GEN_MAKE_NOT_APPLYABLE, MSG_GEN_ACTIVATE, MSG_GEN_ACTIVATE_INTERACTION_DEFAULT </PRE>
<P>
<A NAME="GenClass_1d.htm_IX_Properties gadgets:activating">
 </A>
These messages only affect objects which contain properties. These property gadgets (such as GenItemGroups, GenValues, GenTexts, etc.) typically operate in one of two modes: <EM>
immediate</EM>
 or <EM>
delayed</EM>
.</P>
<P>
<A NAME="GenClass_1d.htm_IX_Immediate mode">
 </A>
If an object is operating in immediate mode, any changes in the object's state will cause an immediate change to occur in the application (through the sending of an <EM>
apply</EM>
 message in the object's instance data). For example, if a GenBooleanGroup is operating in immediate mode, every time the user makes a selection within the BooleanGroup, those changes will be applied to the application immediately, as they occur.</P>
<P>
<A NAME="GenClass_1d.htm_IX_Delayed Mode:and activation messages">
 </A>
If instead an object is operating in delayed mode, any changes in the object's state will not be sent out immediately. They will only be sent out at a later time when the object receives instructions to apply its changes. The UI asks a generic object to apply its changes with <CODE>
MSG_GEN_APPLY</CODE>
. </P>
<P>
Typically, each properties gadget operating in delayed mode has a modified state, indicating whether the object has changed since it last applied its changes. Upon receiving <CODE>
MSG_GEN_APPLY</CODE>
, the object checks whether it has been modified; if it has, it will send out its apply message in the object's instance data. Either you or the system may send out <CODE>
MSG_GEN_APPLY</CODE>
 to force a properties gadget to apply its changes. Sending out <CODE>
MSG_GEN_APPLY</CODE>
 clears any modified states associated with a properties gadget (after those properties are applied, of course). </P>
<P>
If <CODE>
MSG_GEN_APPLY</CODE>
 is sent to either a dialog GenInteraction or another GenInteraction within that dialog, it will be propagated to all property gadgets within that Interaction. In this manner, you can apply multiple properties within a dialog box all at once. A GIT_PROPERTIES GenInteraction automatically sends out <CODE>
MSG_GEN_APPLY</CODE>
 upon receiving <CODE>
MSG_GEN_GUP_INTERACTION_COMMAND</CODE>
 with the <CODE>
InteractionCommand</CODE>
 IC_APPLY. (This is typically through an &quot;Apply&quot; trigger in the dialog box.) The dialog will also send <CODE>
MSG_GEN_PRE_APPLY</CODE>
 and <CODE>
MSG_GEN_POST_APPLY</CODE>
 messages before and after the apply, respectively. </P>
<P>
<CODE>
MSG_GEN_RESET</CODE>
 also exhibits this automatic propagation behavior; if this message is sent to a dialog GenInteraction, it will be sent to all property gadgets within that Interaction. However, generic property gadgets provide no default handling for <CODE>
MSG_GEN_RESET</CODE>
. If you wish for an object to reset its properties upon receiving <CODE>
MSG_GEN_RESET</CODE>
, you must subclass the object and handle this message yourself. A GIT_PROPERTIES GenInteraction automatically sends out <CODE>
MSG_GEN_RESET</CODE>
 upon receiving <CODE>
MSG_GEN_GUP_INTERACTION_COMMAND</CODE>
 with the <CODE>
InteractionCommand</CODE>
 IC_RESET. (This is typically through a &quot;Reset&quot; trigger in the dialog box.)</P>
<P>
<CODE>
MSG_GEN_MAKE_APPLYABLE</CODE>
 instructs an object to enable any apply and reset mechanisms that may be disabled. The object must be in delayed mode.</P>
<P>
<CODE>
MSG_GEN_MAKE_NOT_APPLYABLE</CODE>
 instructs an object to disable any apply and reset mechanisms. The object must be in delayed mode.</P>
<P>
<CODE>
MSG_GEN_ACTIVATE</CODE>
 activates a generic object as if it had been activated by the user through the specific UI. For example, sending a GenTrigger <CODE>
MSG_GEN_ACTIVATE</CODE>
 will cause the trigger to send out its action message in the same manner as if the user had clicked on the trigger.</P>
<P>
<CODE>
MSG_GEN_ACTIVATE_INTERACTION_DEFAULT</CODE>
 sends a <CODE>
MSG_GEN_ACTIVATE</CODE>
 to the object marked as the default within a GenInteraction. This message travels up the generic tree to the first independently-displayable object (usually a dialog box) and then activates the default object for that windowed object.</P>

<H6 CLASS="RefETitle">
<A NAME="GenClass_1d.htm_IX_MSG_GEN_APPLY">
 </A>
MSG_GEN_APPLY</H6>
<PRE CLASS="syntax">void	MSG_GEN_APPLY();</PRE>
<P>
This message is sent to property gadgets to cause them to dispatch their &quot;apply&quot; message and at the same time reset any modified states associated with that object. If this message is sent to a GenInteraction within a dialog box, the GenInteraction will propagate this message to all of its children.</P>
<P>
This message may be sent by a GIT_PROPERTIES Interaction upon receipt of <CODE>
MSG_GEN_GUP_INTERACTION_COMMAND</CODE>
 with IC_APPLY. You may send this message yourself if you wish for changes in state within the dialog box to be reflected in your application.</P>
<P CLASS="refField">
Source:	Usually a GIT_PROPERTIES Interaction (with an IC_APPLY trigger). You may send this message yourself to force generic objects to apply their changes.</P>
<P CLASS="refField">
Destination:	Any GenInteraction within a dialog box, or any gadget with properties (GenItemGroup, GenValue, etc.).</P>
<P CLASS="refField">
Parameters:	None.</P>
<P CLASS="refField">
Return:	Nothing.</P>
<P CLASS="refField">
Interception:	Generally not intercepted. </P>


<H6 CLASS="RefETitle">
<A NAME="GenClass_1d.htm_IX_MSG_GEN_PRE_APPLY">
 </A>
MSG_GEN_PRE_APPLY</H6>
<PRE CLASS="syntax">Boolean 	MSG_GEN_PRE_APPLY();</PRE>
<P>
A properties dialog will send this message before <CODE>
MSG_GEN_APPLY</CODE>
. Geodes may use this to do validation of settings or to prepare for applying of changes.</P>
<P CLASS="refField">
Source:	Normally sent by properties dialog before sending <CODE>
MSG_GEN_APPLY</CODE>
.</P>
<P CLASS="refField">
Destination:	Same as <CODE>
MSG_GEN_APPLY</CODE>
.</P>
<P CLASS="refField">
Parameters:	None.</P>
<P CLASS="refField">
Return:	Return <EM>
true</EM>
 if error.</P>
<P CLASS="refField">
Interception:	Must be intercepted to handle properties validation.</P>


<H6 CLASS="RefETitle">
<A NAME="GenClass_1d.htm_IX_MSG_GEN_POST_APPLY">
 </A>
MSG_GEN_POST_APPLY</H6>
<PRE CLASS="syntax">void	MSG_GEN_POST_APPLY();</PRE>
<P>
A properties dialog will send this message after <CODE>
MSG_GEN_APPLY</CODE>
. This can be used to clean up after application of changes.</P>
<P CLASS="refField">
Source:	Normally sent by properties dialog after sending <CODE>
MSG_GEN_APPLY</CODE>
.</P>
<P CLASS="refField">
Destination:	Same as <CODE>
MSG_GEN_APPLY</CODE>
.</P>
<P CLASS="refField">
Parameters:	None.</P>
<P CLASS="refField">
Return:	Nothing.</P>
<P CLASS="refField">
Interception:	Can be intercepted to handle clean up work after <CODE>
MSG_GEN_APPLY</CODE>
.</P>


<H6 CLASS="RefETitle">
<A NAME="GenClass_1d.htm_IX_MSG_GEN_RESET">
 </A>
MSG_GEN_RESET</H6>
<PRE CLASS="syntax">void	MSG_GEN_RESET();</PRE>
<P>
This message, if sent to a GenInteraction within a GIT_PROPERTIES dialog box, will propagate to all children below the receiving Interaction. This message provides a convenient means to reset properties within gadgets. There is no default handling of <CODE>
MSG_GEN_RESET</CODE>
 by generic objects. You must provide the reset behavior yourself by subclassing individual objects.</P>
<P CLASS="refField">
Source:	Usually a GIT_PROPERTIES GenInteraction (with an IC_RESET trigger), or your application.</P>
<P CLASS="refField">
Destination:	Any GenInteraction within a dialog box, or any gadget subclassed to handle <CODE>
MSG_GEN_RESET</CODE>
.</P>
<P CLASS="refField">
Parameters:	None.</P>
<P CLASS="refField">
Return:	Nothing.</P>
<P CLASS="refField">
Interception:	Your subclassed generic object should intercept this message to provide its own custom reset behavior.</P>


<H6 CLASS="RefETitle">
<A NAME="GenClass_1d.htm_IX_MSG_GEN_MAKE_APPLYABLE">
 </A>
MSG_GEN_MAKE_APPLYABLE</H6>
<PRE CLASS="syntax">void	MSG_GEN_MAKE_APPLYABLE();</PRE>
<P>
This message is typically sent to a dialog GenInteraction<CODE>
 </CODE>
to enable its default &quot;apply&quot; and &quot;reset&quot; buttons. This message also sets up the proper user and actual states for the object. This message is useful in the implementation of custom gadgets.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any GS_USABLE <CODE>
GenClass</CODE>
 object. (This message is only meaningful for objects within a GIT_PROPERTIES GenInteraction, however.) </P>
<P CLASS="refField">
Parameters:	None.</P>
<P CLASS="refField">
Return:	Nothing.</P>
<P CLASS="refField">
Interception:	Generally not intercepted.</P>


<H6 CLASS="RefETitle">
<A NAME="GenClass_1d.htm_IX_MSG_GEN_MAKE_NOT_APPLYABLE">
 </A>
MSG_GEN_MAKE_NOT_APPLYABLE</H6>
<PRE CLASS="syntax">void	MSG_GEN_MAKE_NOT_APPLYABLE();</PRE>
<P>
This message is typically sent to a dialog GenInteraction<CODE>
 </CODE>
to disable its default &quot;apply&quot; and &quot;reset&quot; buttons. This message is useful in the implementation of custom gadgets.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any GS_USABLE <CODE>
GenClass</CODE>
 object. (This message is only meaningful for objects within a GIT_PROPERTIES GenInteraction, however.) </P>
<P CLASS="refField">
Parameters:	None.</P>
<P CLASS="refField">
Return:	Nothing.</P>
<P CLASS="refField">
Interception:	Generally not intercepted.</P>


<H6 CLASS="RefETitle">
<A NAME="GenClass_1d.htm_IX_MSG_GEN_ACTIVATE">
 </A>
MSG_GEN_ACTIVATE</H6>
<PRE CLASS="syntax">void	MSG_GEN_ACTIVATE();</PRE>
<P>
This message manually activates an object as if the user had activated it in the manner defined by the specific UI. For example, this message may activate GenTriggers without use of the mouse. This message causes all normal visual cues associated with the activation.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Usually sent by an object to itself.</P>
<P CLASS="refField">
Parameters:	None.</P>
<P CLASS="refField">
Return:	Nothing.</P>
<P CLASS="refField">
Interception:	Generally not intercepted. </P>


<H6 CLASS="RefETitle">
<A NAME="GenClass_1d.htm_IX_MSG_GEN_ACTIVATE_INTERACTION_DEFAULT">
 </A>
MSG_GEN_ACTIVATE_INTERACTION_DEFAULT</H6>
<PRE CLASS="syntax">Boolean	MSG_GEN_ACTIVATE_INTERACTION_DEFAULT();</PRE>
<P>
<A NAME="GenClass_1d.htm_IX_HINT_DEFAULT_DEFAULT_ACTION">
 </A>
This message acts on a default exclusive object within a window, forcing that object to activate as in <CODE>
MSG_GEN_ACTIVATE</CODE>
. This message travels up the visible tree to the first WIN_GROUP (windowed) object and sends a <CODE>
MSG_GEN_ACTIVATE</CODE>
 to the default object selected there. (This default object is typically marked with the hint <CODE>
HINT_DEFAULT_DEFAULT_ACTION</CODE>
.)</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any GS_USABLE <CODE>
GenClass</CODE>
 object (usually within a dialog box).</P>
<P CLASS="refField">
Parameters:	None.</P>
<P CLASS="refField">
Return:	Will return <EM>
true</EM>
 if the object was activated, <EM>
false</EM>
 if it was not.</P>
<P CLASS="refField">
Interception:	Generally not intercepted.</P>

<HR>
<A NAME="GenClass_1e.htm"></A>


<H2 CLASS="sectionTitle">
<A HREF="#index.htm">GenClass</A>: 11 
Focus Modifications</H2>
<PRE>MSG_GEN_BRING_TO_TOP, MSG_GEN_LOWER_TO_BOTTOM </PRE>
<P>
<CODE>
MetaClass</CODE>
 provides the main means of changing the focus and target hierarchies within an application. <CODE>
GenClass</CODE>
 also provides two messages to perform special cases with windowed objects.</P>
<P>
<CODE>
MSG_GEN_BRING_TO_TOP</CODE>
 brings a windowed object to the front of all overlapping windowed objects within its window layer. Depending on the specific UI, this message may alter the focus and target by sending <CODE>
MSG_META_GRAB_FOCUS_EXCL</CODE>
 or <CODE>
MSG_META_GRAB_TARGET_EXCL</CODE>
 to the window brought to the front.</P>
<P>
<CODE>
MSG_GEN_LOWER_TO_BOTTOM</CODE>
 lowers a windowed object to the bottom of all overlapping windowed objects within its window layer. Depending on the specific UI, this message may alter the focus and target hierarchies by sending a <CODE>
MSG_META_RELEASE_FOCUS_EXCL</CODE>
 and <CODE>
MSG_META_RELEASE_TARGET_EXCL</CODE>
 to the window lowered to the bottom.</P>

<H6 CLASS="RefETitle">
<A NAME="GenClass_1e.htm_IX_MSG_GEN_BRING_TO_TOP">
 </A>
MSG_GEN_BRING_TO_TOP</H6>
<PRE CLASS="syntax">void	MSG_GEN_BRING_TO_TOP();</PRE>
<P>
This message brings a windowed object to the front if it is in a maximized or overlapping arrangement with other window objects. This message may also grab the focus and target exclusives for the window involved, if the specific UI allows such behavior.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any GS_USABLE <CODE>
GenClass</CODE>
 object. (Only GenDisplays, independently displayable GenInteractions, and GenPrimarys are affected.)</P>
<P CLASS="refField">
Parameters:	None.</P>
<P CLASS="refField">
Return:	Nothing.</P>
<P CLASS="refField">
Interception:	Generally not intercepted.</P>


<H6 CLASS="RefETitle">
<A NAME="GenClass_1e.htm_IX_MSG_GEN_LOWER_TO_BOTTOM">
 </A>
MSG_GEN_LOWER_TO_BOTTOM</H6>
<PRE CLASS="syntax">void	MSG_GEN_LOWER_TO_BOTTOM();</PRE>
<P>
This message lowers a windowed object to the bottom if it is in an overlapping arrangement with other windowed objects. This message may also release the focus and target exclusives for the window involved, if the specific UI allows such behavior.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any GS_USABLE <CODE>
GenClass </CODE>
object. (Only GenDisplays, independently displayable GenInteractions, and GenPrimarys are affected.)</P>
<P CLASS="refField">
Parameters:	None.</P>
<P CLASS="refField">
Return:	Nothing.</P>
<P CLASS="refField">
Interception:	Generally not intercepted.</P>

<HR>
<A NAME="GenClass_1f.htm"></A>


<H2 CLASS="sectionTitle">
<A HREF="#index.htm">GenClass</A>: 12 
Navigation Methods</H2>
<PRE>MSG_GEN_NAVIGATE_TO_NEXT_FIELD, MSG_GEN_NAVIGATE_TO_PREVIOUS_FIELD, MSG_GEN_NAVIGATION_QUERY</PRE>
<P>
<A NAME="GenClass_1f.htm_IX_Keyboard navigation">
 </A>
These messages move the navigation cursor between fields at the same level. Typically, these messages alter the focus and target exclusives to implement this behavior. These messages are rarely used within applications.</P>

<H6 CLASS="RefETitle">
<A NAME="GenClass_1f.htm_IX_MSG_GEN_NAVIGATE_TO_NEXT_FIELD">
 </A>
MSG_GEN_NAVIGATE_TO_NEXT_FIELD</H6>
<PRE CLASS="syntax">void	MSG_GEN_NAVIGATE_TO_NEXT_FIELD();</PRE>
<P>
This message moves the navigation cursor from its current object to the next valid object. This message is useful if you are trapping keyboard characters using <CODE>
MSG_META_KBD_CHAR</CODE>
 and wish to use special characters to navigate the cursor to various fields within a View.</P>
<P CLASS="refField">
Source:	Normally sent by the specific UI, although your application could also send this.</P>
<P CLASS="refField">
Destination:	Any GS_USABLE <CODE>
GenClass</CODE>
 object.</P>
<P CLASS="refField">
Parameters:	None.</P>
<P CLASS="refField">
Return:	Nothing.</P>
<P CLASS="refField">
Interception:	Generally not intercepted. To alter navigation functionality, intercept <CODE>
MSG_GEN_NAVIGATION_QUERY</CODE>
 instead.</P>


<H6 CLASS="RefETitle">
<A NAME="GenClass_1f.htm_IX_MSG_GEN_NAVIGATE_TO_PREVIOUS_FIELD">
 </A>
MSG_GEN_NAVIGATE_TO_PREVIOUS_FIELD</H6>
<PRE CLASS="syntax">void	MSG_GEN_NAVIGATE_TO_PREVIOUS_FIELD();</PRE>
<P>
This message moves the navigation cursor from its current object to the previous valid object. This message is useful if you are trapping keyboard characters using <CODE>
MSG_META_KBD_CHAR</CODE>
 and wish to use special characters to navigate the cursor to various fields within a View.</P>
<P CLASS="refField">
Source:	Normally sent by the specific UI, although your application could also send this.</P>
<P CLASS="refField">
Destination:	Any GS_USABLE <CODE>
GenClass</CODE>
 object.</P>
<P CLASS="refField">
Parameters:	None.</P>
<P CLASS="refField">
Return:	Nothing.</P>
<P CLASS="refField">
Interception:	Generally not intercepted. To alter navigation functionality, intercept <CODE>
MSG_GEN_NAVIGATION_QUERY</CODE>
 instead.</P>


<H6 CLASS="RefETitle">
<A NAME="GenClass_1f.htm_IX_MSG_GEN_NAVIGATION_QUERY">
 </A>
MSG_GEN_NAVIGATION_QUERY</H6>
<PRE CLASS="syntax">Boolean	MSG_GEN_NAVIGATION_QUERY(
        NavigationQueryParams 		*retValue,
        optr 				queryOrigin,
        NavigationFlags			navFlags);</PRE>
<P>
This message can be used by applications to initiate navigation-oriented queries, as the <CODE>
MSG_GEN_NAVIGATE_TO_</CODE>
[<CODE>
NEXT</CODE>
|<CODE>
PREVIOUS</CODE>
]<CODE>
_FIELD</CODE>
 messages do. </P>
<P>
This structure's return values determine how it fits into the navigation network. If this message returns <EM>
true</EM>
, then the object which should receive the focus was found, and the <CODE>
NQP_nextObject</CODE>
 field will hold the pointer of this object. </P>
<P>
If the message returns <EM>
false</EM>
, then the focusable object has not yet been found. The <CODE>
NQP_nextObject</CODE>
 field contains the field of the next object to try and the <CODE>
NQP_navFlags</CODE>
 contains the updated navigation flags which should be passed in the next query.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any generic object.</P>
<P CLASS="refField">
Parameters:	<EM>navFlags</EM> 	Flags giving state of navigation.</P>
<DL>
<DT>
<CODE>
queryOrigin</CODE>
 </DT><DD>Object which originated this query.</DD>
<DT>
<EM>
retValue</EM>
</DT><DD>Structure to hold return values.</DD>
</DL>
<P CLASS="refField">
Return:	<EM>
true</EM>
 if the queried object should receive the focus; <EM>
false</EM>
 otherwise.</P>
<P CLASS="refField">
Structures:	</P>
<PRE><A NAME="GenClass_1f.htm_IX_NQP_&ldots;"></A><A NAME="IX_NavigationQueryParams"></A>typedef struct {
	word		NQP_navFlags;
 	byte 		NQP_backtrackFlag;
 	byte 		NQP_unused;
	optr		NQP_nextObject;
} NavigationQueryParams;</PRE>

<HR>
<A NAME="GenClass_20.htm"></A>


<H2 CLASS="sectionTitle">
<A HREF="#index.htm">GenClass</A>: 13 
Window Positions and Sizes</H2>
<PRE>MSG_GEN_SET_WIN_POSITION, MSG_GEN_SET_WIN_SIZE, MSG_GEN_SET_WIN_CONSTRAIN</PRE>
<P>
<A NAME="GenClass_20.htm_IX_Windows:position">
 </A>
<A NAME="GenClass_20.htm_IX_Windows:size">
 </A>
These messages allow window objects to override their default window behavior. Sending these messages may cause the objects involved to be specifically rebuilt.</P>
<P>
You may also override the default constraints on a windowed object. To do so, send the windowed object MSG_GEN_SET_WIN_CONSTRAIN, passing it the <CODE>
WinConstrainType</CODE>
 to set for the window. </P>

<H6 CLASS="RefETitle">
<A NAME="GenClass_20.htm_IX_MSG_GEN_SET_WIN_POSITION">
 </A>
MSG_GEN_SET_WIN_POSITION</H6>
<PRE CLASS="syntax">void	MSG_GEN_SET_WIN_POSITION(
        word		modeAndType,
        SpecWinSizeSpec		xPosSpec,
        SpecWinSizeSpec		yPosSpec);</PRE>
<P>
This message sets a window's position. The message must be passed a <CODE>
WinPositionType</CODE>
 along with two x and y coordinates passed in <CODE>
SpecWinSizeSpec</CODE>
 structures. The window's upper left corner will be drawn at the supplied coordinates.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any GS_USABLE GenDisplay, GenPrimary, or independently-displayable GenInteraction.</P>
<P CLASS="refField">
Parameters:	<EM>
modeAndType</EM>
	<CODE>
VisUpdateMode</CODE>
 and<CODE>
 WinPositionType</CODE>
. This message expects a <CODE>
VisUpdateMode</CODE>
 and <CODE>
WinPositionType</CODE>
 passed in the parameter <EM>
modeAndType</EM>
. Use the macro GET_MM_AND_TYPE to combine these two values into one word.</P>
<DL>
<DT>
<EM>
xPosSpec</EM>
</DT><DD>The new x coordinates of the window.</DD>
<DT>
<EM>
yPosSpec</EM>
</DT><DD>The new y coordinates of the window.</DD>
</DL>
<P CLASS="refField">
Return:	Nothing.</P>
<P CLASS="refField">
Interception:	Generally not intercepted.</P>


<H6 CLASS="RefETitle">
<A NAME="GenClass_20.htm_IX_MSG_GEN_SET_WIN_SIZE">
 </A>
MSG_GEN_SET_WIN_SIZE</H6>
<PRE CLASS="syntax">void	MSG_GEN_SET_WIN_SIZE(
        word		modeAndType,
        SpecWinSizeSpec		xSizeSpec,
        SpecWinsizeSpec		ySizeSpec);</PRE>
<P>
This message sets a window's size. The message must be passed a <CODE>
WinPositionType</CODE>
 along with two x and y coordinates passed in <CODE>
SpecWinSizeSpec</CODE>
 structures.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any GS_USABLE GenDisplay, GenPrimary, or independently-displayable GenInteraction.</P>
<P CLASS="refField">
Parameters:	<EM>
modeAndType</EM>
	<CODE>
VisUpdateMode</CODE>
 and <CODE>
WinSizeType</CODE>
. Use the macro GET_MM_AND_TYPE to combine these two values into one word.</P>
<DL>
<DT>
<EM>
xSizeSpec</EM>
</DT><DD>The new x coordinates of the window.</DD>
<DT>
<EM>
ySizeSpec</EM>
</DT><DD>The new y coordinates of the window.</DD>
</DL>
<P CLASS="refField">
Return:	Nothing.</P>
<P CLASS="refField">
Interception:	Generally not intercepted.</P>


<H6 CLASS="RefETitle">
<A NAME="GenClass_20.htm_IX_MSG_GEN_SET_WIN_CONSTRAIN">
 </A>
MSG_GEN_SET_WIN_CONSTRAIN</H6>
<PRE CLASS="syntax">void	MSG_GEN_SET_WIN_CONSTRAIN(
        VisUpdateMode		updateMode,
        byte		constrainType);</PRE>
<P>
This message changes a window's constrain type to the passed <CODE>
WindowConstrainType</CODE>
. </P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any GS_USABLE GenPrimary or GenInteraction object.</P>
<P CLASS="refField">
Parameters:	<EM>
updateMode</EM>
	<CODE>
VisUpdateMode</CODE>
.</P>
<DL>
<DT>
<EM>
constrainType</EM>
</DT><DD><CODE>
WinConstrainType</CODE>
.<BR>
WCT_NONE<BR>
WCT_KEEP_PARTIALLY_VISIBLE<BR>
WCT_KEEP_VISIBLE<BR>
WCT_KEEP_VISIBLE_WITH_MARGIN</DD>
</DL>
<P CLASS="refField">
Interception:	Generally not intercepted.</P>

<HR>
This document is a single-page version of a <A HREF="index.htm">a multi-page document</A>, suitable for easy printing.
</BODY>
</HTML>
