COMMENT @-----------------------------------------------------------------------

	Copyright (c) GeoWorks 1989 -- All Rights Reserved

PROJECT:	PC GEOS
MODULE:		
FILE:		

AUTHOR:		Cheng, 1/91

ROUTINES:
	Name			Description
	----			-----------
	
REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	jimmy	3/92		initial version

DESCRIPTION:

	The sample format strings are reduceed under DBCS since the number
	are now (DBCS only) set up to go scientific if they are too large.
	Since the "SampleStruc" is allocated on the stack, this saves bytes!

	$Id: math.def,v 1.2 98/06/25 00:58:18 martin Exp $

-------------------------------------------------------------------------------@

SetDef __MATH

include ec.def

StartLibrary 	math

;-------------------------------------------------------------------------------
;	CONSTANTS
;-------------------------------------------------------------------------------

FPSIZE = 10			; size of Geos-80 floating point number in bytes

FPSIZE_IEEE64 = 8		; size of IEEE-64 floating point number in bytes

DECIMAL_EXPONENT_UPPER_LIMIT = 4932

DECIMAL_EXPONENT_LOWER_LIMIT = -4932

FACTORIAL_LIMIT		= 1754		; 1754! is our limit, yuge!

DECIMAL_PRECISION	= 15

SIGN_STR_LEN		= 5

PAD_STR_LEN		= 8

FP_DEFAULT_STACK_ELEMENTS = 25
FP_DEFAULT_STACK_SIZE 	= FP_DEFAULT_STACK_ELEMENTS * FPSIZE
FP_MIN_STACK_ELEMENTS	= 5
FP_MIN_STACK_SIZE	= FP_MIN_STACK_ELEMENTS * FPSIZE
FP_NAN			= 0x7fff
		
FLOAT_EPSILON_MAGNITUDE = 64

;-------------------------------------------------------------------------------
;	CONSTANTS FOR FloatFloatToAscii
;-------------------------------------------------------------------------------

;
; First, we will figure out the sizes of numbers so that applications
; can allocate appropriately sized buffers.
;

MAX_DIGITS_FOR_NORMAL_NUMBERS		equ DECIMAL_PRECISION

MAX_CHARS_FOR_COMMAS_IN_NORMAL_NUMBERS	equ DECIMAL_PRECISION / 3 + 1

MAX_DIGITS_FOR_HUGE_NUMBERS		equ 64

MAX_CHARS_FOR_COMMAS_IN_HUGE_NUMBERS	equ MAX_DIGITS_FOR_HUGE_NUMBERS / 3 + 1

MAX_CHARS_FOR_DECIMAL_POINT		equ 1

MAX_CHARS_FOR_EXPONENT			equ 6	; "E+4932"

MAX_CHARS_FOR_PERCENATGE		equ 1	; "%"

MAX_CHARS_FOR_NULL_TERM			equ 1

MAX_CHARS_FOR_FORMAT_STUFF_IN_NORMAL_NUMBERS	equ \
	SIGN_STR_LEN * 2 + \
	PAD_STR_LEN * 2 + \
	MAX_CHARS_FOR_COMMAS_IN_NORMAL_NUMBERS + \
	MAX_CHARS_FOR_DECIMAL_POINT + \
	MAX_CHARS_FOR_EXPONENT + \
	MAX_CHARS_FOR_PERCENATGE

MAX_CHARS_FOR_FORMAT_STUFF_IN_HUGE_NUMBERS	equ \
	SIGN_STR_LEN * 2 + \
	PAD_STR_LEN * 2 + \
	MAX_CHARS_FOR_COMMAS_IN_HUGE_NUMBERS + \
	MAX_CHARS_FOR_DECIMAL_POINT + \
	MAX_CHARS_FOR_EXPONENT + \
	MAX_CHARS_FOR_PERCENATGE

MAX_CHARS_FOR_NORMAL_NUMBER	equ \
	MAX_DIGITS_FOR_NORMAL_NUMBERS + \
	DECIMAL_PRECISION + \
	MAX_CHARS_FOR_FORMAT_STUFF_IN_NORMAL_NUMBERS + \
	MAX_CHARS_FOR_NULL_TERM

MAX_CHARS_FOR_HUGE_NUMBER	equ \
	MAX_DIGITS_FOR_HUGE_NUMBERS + \
	MAX_CHARS_FOR_FORMAT_STUFF_IN_HUGE_NUMBERS + \
	MAX_CHARS_FOR_NULL_TERM

;*******************************************************************************
;
;	NOTE!
;	For your buffers, you will need to use one of:
;	    a) FLOAT_TO_ASCII_NORMAL_BUF_LEN
;	    b) FLOAT_TO_ASCII_HUGE_BUF_LEN
;
;	The reason for having these two is as follows:
;	We normally switch formatting from fixed to scientific if the number
;	cannot fit.  Users can choose to override this automatic switching if
;	they use the FFAF_DONT_USE_SCIENTIFIC flag.  If they do this, numbers
;	will be padded with zeros on the right till the result is gotten.
;	Since the result is potentially huge, we still place a limit and
;	switch to scientific despite the request.
;
;	FLOAT_TO_ASCII_NORMAL_BUF_LEN is the size of the buffer that should be
;	passed to FloatFloatToAscii for "normal" operations.  Operations are
;	"normal" if the FFAF_DONT_USE_SCIENTIFIC flag is clear.  Operations
;	are "huge" otherwise.
;
;*******************************************************************************

;
; force numbers to be even
;
FLOAT_TO_ASCII_NORMAL_BUF_LEN	equ ((MAX_CHARS_FOR_NORMAL_NUMBER+1)/2)*2

FLOAT_TO_ASCII_HUGE_BUF_LEN	equ ((MAX_CHARS_FOR_HUGE_NUMBER+1)/2)*2

;------------------------------------------------------------------------------
;	CONSTANTS FOR THE DATE AND TIME ROUTINES
;-------------------------------------------------------------------------------

YEAR_LENGTH	=	365
YEAR_MAX	=	2099
YEAR_MIN	=	1900
MONTH_MAX	=	12
MONTH_MIN	=	1
DAY_MAX		=	31
DAY_MIN		=	1

HOUR_MAX	=	23
HOUR_MIN	=	0
MINUTE_MAX	=	59
MINUTE_MIN	=	0
SECOND_MAX	=	59
SECOND_MIN	=	0

DATE_NUMBER_MIN	=	1		; Jan 1, 1900
DATE_NUMBER_MAX	=	73049		; Dec 31, 2099
	
;-------------------------------------------------------------------------------
;	STRUCTURES
;-------------------------------------------------------------------------------

FloatStackType	etype byte, 0
FLOAT_STACK_GROW	enum	FloatStackType
FLOAT_STACK_WRAP	enum	FloatStackType
FLOAT_STACK_ERROR	enum	FloatStackType

FLOAT_STACK_DEFAULT_TYPE equ FLOAT_STACK_GROW

FloatExponent	record
	FE_SIGN:1		; set if number is negative
	FE_EXPONENT:15		; the exponent is biased by 3fffh
FloatExponent	end
	
IEEE64		struct
	IEEE64_wd0	word
	IEEE64_wd1	word
	IEEE64_wd2	word
	IEEE64_wd3	word
IEEE64		ends
	
FloatNum	struct
	F_mantissa_wd0	word			; offset 0
	F_mantissa_wd1	word			; offset 2
	F_mantissa_wd2	word			; offset 4
	F_mantissa_wd3	word			; offset 6
	F_exponent	FloatExponent <>	; offset 8
FloatNum	ends

;
; This structure appears at the top of the transfer item block for
; CIF_FLOAT, followed by however many FloatNums.
;
FloatTransferBlockHeader	struct
	FTBH_link	VMChainLink
	FTBH_numFloats	word
FloatTransferBlockHeader	ends

;-------------------------------------------------------------------------------
;	FLAGS
;-------------------------------------------------------------------------------

FloatAsciiToFloatFlags	record
	:6
	FAF_PUSH_RESULT:1,
	FAF_STORE_NUMBER:1
FloatAsciiToFloatFlags	end

;*******************************************************************************
;
; FloatFloatToAsciiFormatFlags
; boolean bits, phrased so that a 0 will give the default
;
;*******************************************************************************

FloatFloatToAsciiFormatFlags	record
	;***********************************************************************
	; these first 2 bits must not move
	FFAF_FLOAT_RESERVED:1,			; must be 0 (a 1 => a date op)
	FFAF_FROM_ADDR:1,			; set if number is from address
						;     given, else number will
						;     taken from the fp stack
	;***********************************************************************

	:4,					; unused bits
	FFAF_DONT_USE_SCIENTIFIC:1,		; This is a preference flag
						; that tells FloatFloatToAscii
						; to format the number as fixed
						; by padding the number with
						; zeros as necessary.  The
						; routine will force scientific
						; anyway if the resulting
						; string exceeds some large
						; limit.
	;
	; boolean bits, phrased so that a 0 will give the default
	;
	FFAF_SCIENTIFIC:1,			; set if scientific, clear
						;     if fixed
	FFAF_PERCENT:1,				; display as percentage
	FFAF_USE_COMMAS:1,			; use comma seperators
	FFAF_NO_TRAIL_ZEROS:1,			; trailing zeros pad number
	FFAF_NO_LEAD_ZERO:1,			; 0 precedes decimal point
						;     if ABS(#) < 1
	FFAF_HEADER_PRESENT:1,			; here to speed formatting &
						;     save on storage
	FFAF_TRAILER_PRESENT:1,			; here to speed fomatting &
						;     save on storage
	FFAF_SIGN_CHAR_TO_FOLLOW_HEADER:1,	; position of negative char
	FFAF_SIGN_CHAR_TO_PRECEDE_TRAILER:1	; position of negative char
FloatFloatToAsciiFormatFlags	end

;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
;
;	THE MULTITUDE OF STRUCTURES THAT FOLLOW....
;	(for FloatFloatToAscii)
;
;	FloatFloatToAscii can convert floating point numbers into ASCII
;	or dates and times.
;
;	Since the parameters for the two operations are very different,
;	uninons are used to pass paramters to FloatFloatToAscii.
;
;	Naming conventions:
;	    ...Flags		- flags :)
;	    ...Params		- parameters for FloatFloatToAscii.  These are
;				  fields that the user needs to initialize
;	    ...Data		- structure that contains the Params and other
;				  fields for internal use
;	    ...Params_Union	- a union of the "...Params" structures
;	    FFA_stackFrame	- the stack frame that FloatFloatToAscii takes.
;				  This is a union of the "...Data" structures
;
;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

;*******************************************************************************
;
;	FloatToAsciiParams
;	The FloatToAsciiParams portion of FloatFloatToAsciiData needs to be
;	initialized before the call to FloatFloatToAscii.
;	It may be cumbersome so some of the more common formats have
;	routines that you can call to have them deal with the stack frame
;	(eg. FloatFloatToAscii_StdFormat).
;
;	The FloatToAsciiParams is part of the FloatFloatToAsciiData structure
;	which in turn is a member of the FFA_stackFrame union.
;
;*******************************************************************************

FloatFloatToAsciiParams	struct

	;***********************************************************************
	;
	; FIELDS FOR CALLER TO SET UP
	; ALL FIELDS MUST BE INITIALIZED
	;
	;***********************************************************************

	;
	; format:
	; A record of boolean bits saying how the caller wants string to look.
	;
	formatFlags	FloatFloatToAsciiFormatFlags

	;
	; decimalOffset:
	; Number of decimal places that the caller want the decimal point to be
	; offset. Eg. Caller may want offset of -6 to display numbers in
	; terms of "millions". (Character count)
	; -DECIMAL_PRECISION <= decimalOffset <= DECIMAL_PRECISION
	;
	decimalOffset	byte

	;
	; totalDigits:
	; Max number of digits (integer + decimal portions).
	; The ASCII string is truncated if length(string) > number.
	; Generally,
	;     totalDigits <= DECIMAL_PRECISION if FFAF_DONT_USE_SCIENTIFIC
	;	  is not used
	;     totalDigits <= MAX_DIGITS_FOR_HUGE_NUMBERS if
	;	  FFAF_DONT_USE_SCIENTIFIC is used.
	;
	; By the way, a significant digit is a decimal digit derived from the
	; floating point number's mantissa and it may preceed or follow a
	; decimal point.  The IEEE format is only capable of DECIMAL_PRECISION
	; number of significant digits.  If the totalDigits is greater then
	; DECIMAL_PRECISION, the excess digits will be 0.
	;
	totalDigits	byte

	;
	; decimalLimit:
	; Max number of decimal digits.
	; The number will be rounded to meet this limit.
	; Eg. 345.678 with decimalLimit=2 will give
	;	in fixed format		345.68
	;	in scientific format	3.46E+2
	; 0 <= decimalLimit <=  DECIMAL_PRECISION
	;
	decimalLimit	byte

	;
	; preNegative:
	; The characters used to preceed a negative number.
	; The string is expected to be null terminated.
	; Eg. for parenthesized negatives, set preNegative = '('
	;     for arithmetic negatives, set preNegative = '-'
	; Set to 0 if no character.
	; (the +1 in "SIGN_STR_LEN+1" is for the null terminator)
	;
SBCS<	preNegative	char SIGN_STR_LEN+1 dup (?)	>
DBCS<	preNegative	wchar SIGN_STR_LEN+1 dup (?)	>

	;
	; postNegative:
	; The characters used to terminate a negative number.
	; The string is expected to be null terminated.
	; Eg. for parenthesized negatives, postNegative = ')'
	; Set to 0 if no character.
	; (the +1 in "SIGN_STR_LEN+1" is for the null terminator)
	;
SBCS<	postNegative	char SIGN_STR_LEN+1 dup (?)	>
DBCS<	postNegative	wchar SIGN_STR_LEN+1 dup (?)	>

	;
	; prePositive:
	; The characters used to preceed a positive number.
	; The string is expected to be null terminated.
	; Eg. for arithmetic positives, set prePositive = '+'
	; Set to 0 if no character.
	; (the +1 in "SIGN_STR_LEN+1" is for the null terminator)
	;
SBCS<	prePositive	char SIGN_STR_LEN+1 dup (?)	>
DBCS<	prePositive	wchar SIGN_STR_LEN+1 dup (?)	>

	;
	; postPositive:
	; The characters used to terminate a positive number.
	; The string is expected to be null terminated.
	; Set to 0 if no character.
	; (the +1 in "SIGN_STR_LEN+1" is for the null terminator)
	;
SBCS<	postPositive	char SIGN_STR_LEN+1 dup (?)	>
DBCS<	postPositive	wchar SIGN_STR_LEN+1 dup (?)	>

	;
	; HEADER AND TRAILER FOLLOW
	; If these aren't present then only the chars above need be stored
	; per format
	;

	;
	; header:
	; The characters that should preceed the number.
	; The string is expected to be null terminated.
	; Whether or not this string follows or precedes the sign is
	; determined by FFAF_SIGN_CHAR_TO_FOLLOW_HEADER.
	; (the +1 in "PAD_STR_LEN+1" is for the null terminator)
	;
SBCS<	header		char	PAD_STR_LEN+1 dup (?)	>
DBCS<	header		wchar	PAD_STR_LEN+1 dup (?)	>


	;
	; trailer:
	; The characters that should follow the number.
	; The string is expected to be null terminated.
	; Whether or not this string follows or precedes the sign is
	; determined by FFAF_SIGN_CHAR_TO_PRECEDE_TRAILER.
	; (the +1 in "PAD_STR_LEN+1" is for the null terminator)
	;
SBCS<	trailer		char	PAD_STR_LEN+1 dup (?)	>
DBCS<	trailer		wchar	PAD_STR_LEN+1 dup (?)	>

	align		word
FloatFloatToAsciiParams	ends

;*******************************************************************************
;
;	FloatFloatToAsciiData
;	Contains the FloatFloatToAsciiParams and some fields for internal use.
;	This structure exists as a member of the FFA_stackFrame union.
;
;*******************************************************************************

FloatFloatToAsciiData	struct

	;***********************************************************************
	;
	; FIELDS FOR CALLER TO SET UP
	; ALL FIELDS MUST BE INITIALIZED
	;
	;***********************************************************************

	FFA_params		FloatFloatToAsciiParams

	;***********************************************************************
	;
	; POSSIBLY USEFUL INFORMATION RETURNED BY FloatFloatToAscii
	;
	;***********************************************************************

	;
	; FFA_startNumber:
	; offset to start of numeric chars
	; (set by FloatFloatToAscii::FloatDoPreNumeric)
	;
	FFA_startNumber		word

	;
	; FFA_decimalPoint:
	; offset to decimal point, 0 if no decimal point
	; (set by FloatFloatToAscii::StuffDecimalPoint)
	;
	FFA_decimalPoint	word

	;
	; FFA_endNumber:
	; offset to end of numeric chars
	; (set by FloatFloatToAscii::FloatDoPostNumeric)
	;
	FFA_endNumber		word

	;
	; FFA_numChars:
	; total number of chars in ASCII string excl null
	; = 0 if error
	; (set by FloatFloatToAscii in 2 locations)
	;
	FFA_numChars		word

	;
	; FFA_startExponent:
	; offset to the "E" character, 0 if no exponent
	; (Applications can check this to see if the exponent format was used).
	;
	FFA_startExponent	word

	;***********************************************************************
	;
	; FIELDS FOR INTERNAL USE ONLY
	; TOUCH THEM NOT
	;
	;***********************************************************************

	FFA_bufSize		word	; size of ASCII buffer
	FFA_saveDI		word	; original di
	FFA_numSign		word	; {-ve,0,+ve}
					; -ve if number is negative
					; 0 if number is 0
					; +ve if number is positive

	FFA_startSigCount	byte	; boolean - start counting sig digits
	FFA_sigCount		byte	; count -  siginificant digits

	FFA_noMoreSigInfo	byte	; boolean - no more significant info
	FFA_startDecCount	byte	; boolean - start counting dec digits
	FFA_decCount		byte	; count - decimal digits

	FFA_decExponent		word	; decimal exponent of number
	FFA_curExponent		word	; current decimal exponent of number
	FFA_useCommas		byte	; boolean - deal with commas
	FFA_charsToComma	byte	; number of characters to comma
SBCS<	FFA_commaChar		char	>
DBCS<	FFA_commaChar		wchar	>
SBCS<	FFA_decimalChar		char	>
DBCS<	FFA_decimalChar		wchar	>
FloatFloatToAsciiData	ends

FloatFloatToDateTimeFlags	record
	;***********************************************************************
	; these first 2 bits must not move
	FFDT_DATE_TIME_OP:1,	; must be 1 to tell FloatFloatToAscii that
				; a date operation is desired
	FFDT_FROM_ADDR:1,	; boolean - use number from given address
	;***********************************************************************

	FFDT_FORMAT:14		; DateTimeFormats
FloatFloatToDateTimeFlags	end

;*******************************************************************************
;
;	FloatFloatToDateTimeParams
;	The FloatFloatToDateTimeParams portion of FloatFloatToDateTimeData
;	needs to be initialized before the call to FloatFloatToAscii.
;
;	The FloatFloatToDateTimeParams is part of the FloatFloatToDateTimeData
;	structure which in turn is a member of the FFA_stackFrame union.
;
;*******************************************************************************

FloatFloatToDateTimeParams	struct
	FFA_dateTimeFlags	FloatFloatToDateTimeFlags

	FFA_year		word
	FFA_month		byte
	FFA_day			byte
	FFA_weekday		byte
	FFA_hours		byte
	FFA_minutes		byte
	FFA_seconds		byte
FloatFloatToDateTimeParams	ends

;*******************************************************************************
;
;	FloatFloatToDateTimeData
;	Contains the FloatFloatToDateTimeParams and fields for internal use.
;	This structure exists as a member of the FFA_stackFrame union.
;
;*******************************************************************************

FloatFloatToDateTimeData	struct
	FFA_dateTimeParams	FloatFloatToDateTimeParams
	;
	; no extra fields at this time
	;
FloatFloatToDateTimeData	ends

;*******************************************************************************
;
;	FFA_stackFrame
;
;	The FFA_stackFrame needs to be passed to FloatFloatToAscii.
;	It may be cumbersome so some of the more common formats have
;	routines that you can call to have them deal with the stack frame
;	(eg. FloatFloatToAscii_StdFormat).
;
;*******************************************************************************

FFA_stackFrame	union
	FFA_float	FloatFloatToAsciiData
	FFA_dateTime	FloatFloatToDateTimeData
FFA_stackFrame	end

;*******************************************************************************
;
;	FloatFloatToAsciiParams_Union
;	Structure that will allow us to store pre-defined formats.
;
;*******************************************************************************

FloatFloatToAsciiParams_Union	union
	FFAP_FLOAT		FloatFloatToAsciiParams
	FFAP_DATE_TIME		FloatFloatToDateTimeParams
FloatFloatToAsciiParams_Union	end

;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
;
;	end of the structures that FloatFloatToAscii takes
;




;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

;
; to be loaded in al when calling FloatInitRandom
;
RandomGenInitFlags	record
	RGIF_USE_SEED:1,
	RGIF_GENERATE_SEED:1
	:6
RandomGenInitFlags	end

;------------------------------------------------------------------------------
;	FORMAT RELATED
;------------------------------------------------------------------------------

COMMENT @-----------------------------------------------------------------------

 Tracking of formats:
 --------------------

 Formats are tracked via 2 format arrays - one for the pre-defined formats
 and another for the user-defined formats.  Format tokens are offsets
 into these arrays.

 The pre-defined format array is a lookup table consisting of FormatParams
 as elements.  The user-defined format array will sit in a VM block and will
 consist of FormatEntry structures as elements.  This array will grow as
 necessary.  The size of the user-defined format array will be tracked in
 the spreadsheet's instance data.

 User-defined format token assignment is done as follows:
 --------------------------------------------------------

 Search all existing entries for a free entry.  If no free entry is found,
 expand the format array.

-------------------------------------------------------------------------------@

MAX_FORMATS		= 10		; limit for number of user-def formats
					; set low to test, will be 128 for
					; release

NUM_NUMBER_FORMATS	= 12

NUM_DATE_TIME_FORMATS	= 19

NUM_PRE_DEF_FORMATS	= NUM_NUMBER_FORMATS + NUM_DATE_TIME_FORMATS

FORMAT_NAME_LENGTH	= 40		; null is extra

FORMAT_ID_PREDEF	= 8000h		; we tell pre defined formats
					; from user defined formats 
					; by using this mask

FORMAT_ARRAY_HDR_SIG	= 'y' shl 8 or 'c'

FORMAT_ENTRY_SIG	= 't' shl 8 or 'c'

FORMAT_PARAMS_ID	= 63h

FormatArrayHeader	struc
	FAH_signature		word
	FAH_numFormatEntries	word	; format array entries that have
					; been allocated (possibly free)
	FAH_numUserDefEntries	word
	FAH_formatArrayEnd	word	;offset to end of format array
FormatArrayHeader	ends

FormatParams	struc
	FP_params	FloatFloatToAsciiParams_Union
SBCS<	FP_formatName	char  FORMAT_NAME_LENGTH+1 dup (?)	>
DBCS<	FP_formatName	wchar FORMAT_NAME_LENGTH+1 dup (?)	>
	FP_nameHan	word
	FP_nameOff	word
	FP_listEntryNum	word
	FP_signature	word
FormatParams	ends

FormatEntry	struc
	FE_params		FormatParams
	FE_listEntryNumber	word	; list entry number
					; This will allow us to get the right
					; entry given the list entry
	FE_used			byte	; boolean, 0 if entry is free
	FE_sig			word	; signature for EC purposes
FormatEntry	ends

FormatIdType	etype	word, FORMAT_ID_PREDEF, size FormatParams
FORMAT_ID_GENERAL			enum	FormatIdType
FORMAT_ID_FIXED				enum	FormatIdType
FORMAT_ID_FIXED_WITH_COMMAS		enum	FormatIdType
FORMAT_ID_FIXED_INTEGER			enum	FormatIdType
FORMAT_ID_CURRENCY			enum	FormatIdType
FORMAT_ID_CURRENCY_WITH_COMMAS		enum	FormatIdType
FORMAT_ID_CURRENCY_INTEGER		enum	FormatIdType
FORMAT_ID_PERCENTAGE			enum	FormatIdType
FORMAT_ID_PERCENTAGE_INTEGER		enum	FormatIdType
FORMAT_ID_THOUSANDS			enum	FormatIdType
FORMAT_ID_MILLIONS			enum	FormatIdType
FORMAT_ID_SCIENTIFIC			enum	FormatIdType

FORMAT_ID_DATE_LONG			enum	FormatIdType
FORMAT_ID_DATE_LONG_CONDENSED		enum	FormatIdType
FORMAT_ID_DATE_LONG_NO_WKDAY		enum	FormatIdType
FORMAT_ID_DATE_LONG_NO_WKDAY_CONDENSED	enum	FormatIdType
FORMAT_ID_DATE_SHORT			enum	FormatIdType
FORMAT_ID_DATE_SHORT_ZERO_PADDED	enum	FormatIdType
FORMAT_ID_DATE_LONG_MD			enum	FormatIdType
FORMAT_ID_DATE_LONG_MD_NO_WKDAY		enum	FormatIdType
FORMAT_ID_DATE_SHORT_MD			enum	FormatIdType
FORMAT_ID_DATE_LONG_MY			enum	FormatIdType
FORMAT_ID_DATE_SHORT_MY			enum	FormatIdType
FORMAT_ID_DATE_YEAR			enum	FormatIdType
FORMAT_ID_DATE_MONTH			enum	FormatIdType
FORMAT_ID_DATE_DAY			enum	FormatIdType
FORMAT_ID_DATE_WEEKDAY			enum	FormatIdType
FORMAT_ID_TIME_HMS			enum	FormatIdType
FORMAT_ID_TIME_HM			enum	FormatIdType
FORMAT_ID_TIME_H			enum	FormatIdType
FORMAT_ID_TIME_MS			enum	FormatIdType
FORMAT_ID_TIME_HMS_24HR			enum	FormatIdType
FORMAT_ID_TIME_HM_24HR			enum	FormatIdType

FORMAT_ID_INDETERMINATE		= 0ffffh

FloatModifyFormatFlags	record
	FMFF_COMMA:1			; toggle comma seperator
	FMFF_CURRENCY:1			; set currency mode
	FMFF_PERCENTAGE:1		; set percentage mode
	FMFF_SET_DECIMALS:1		; use FFMFF_DECIMALS
	:8
	FMFF_DECIMALS:4			; number of decimal places
FloatModifyFormatFlags	end

;-------------------------------------------------------------------------------
;	ERRORS
;-------------------------------------------------------------------------------

;
; !!! NOTE !!!
; These errors have corresponding PSEE_ errors in parse.def
; Any change to these errors require corresponding changes there.
;
FLOAT_ERROR_CODES_ENUM_START	= 250

FloatErrorType		etype	byte, FLOAT_ERROR_CODES_ENUM_START, 1
FLOAT_POS_INFINITY	enum	FloatErrorType
FLOAT_NEG_INFINITY	enum	FloatErrorType
FLOAT_GEN_ERR		enum	FloatErrorType

;-------------------------------------------------------------------------------
;	ROUTINES
;-------------------------------------------------------------------------------
	
ifidn	@CurSeg,<math>

FloatMinus1 		equ FLOATMINUS1
FloatMinusPoint5 	equ FLOATMINUSPOINT5
Float0 			equ FLOAT0
FloatPoint5		equ FLOATPOINT5
Float1			equ FLOAT1
Float2			equ FLOAT2
Float5			equ FLOAT5
Float10			equ FLOAT10
Float3600		equ FLOAT3600
Float16384		equ FLOAT16384
Float86400		equ FLOAT86400
FloatAbs		equ FLOATABS
FloatAdd		equ FLOATADD
FloatArcCos		equ FLOATARCCOS
FloatArcCosh		equ FLOATARCCOSH
FloatArcSin		equ FLOATARCSIN
FloatArcSinh		equ FLOATARCSINH
FloatArcTan		equ FLOATARCTAN
FloatArcTan2		equ FLOATARCTAN2
FloatArcTanh		equ FLOATARCTANH
FloatCos		equ FLOATCOS
FloatCosh		equ FLOATCOSH
FloatDepth		equ FLOATDEPTH
FloatDIV		equ FLOATDIV
FloatDivide		equ FLOATDIVIDE
FloatDivide2		equ FLOATDIVIDE2
FloatDivide10		equ FLOATDIVIDE10
FloatDrop		equ FLOATDROP
FloatDup		equ FLOATDUP
FloatEpsilon		equ FLOATEPSILON
FloatExp		equ FLOATEXP
FloatExponential	equ FLOATEXPONENTIAL
FloatFactorial		equ FLOATFACTORIAL
FloatFrac		equ FLOATFRAC
FloatInt		equ FLOATINT
FloatIntFrac		equ FLOATINTFRAC
FloatInverse		equ FLOATINVERSE
FloatLg			equ FLOATLG
FloatLg10		equ FLOATLG10
FloatLn			equ FLOATLN
FloatLn1plusX		equ FLOATLN1PLUSX
FloatLn2		equ FLOATLN2
FloatLn10		equ FLOATLN10
FloatLog		equ FLOATLOG
FloatLt10		equ FLOATLT0
FloatMax		equ FLOATMAX
FloatMin		equ FLOATMIN
FloatMod		equ FLOATMOD
FloatMultiply		equ FLOATMULTIPLY
FloatMultiply2		equ FLOATMULTIPLY2
FloatMultiply10		equ FLOATMULTIPLY10
FloatNegate		equ FLOATNEGATE
FloatOver		equ FLOATOVER
FloatPi			equ FLOATPI
FloatPiDiv2		equ FLOATPIDIV2
FloatRandom		equ FLOATRANDOM
FloatRot		equ FLOATROT
FloatSin		equ FLOATSIN
FloatSinh		equ FLOATSINH
FloatSqr		equ FLOATSQR
FloatSqrt		equ FLOATSQRT
FloatSqrt2		equ FLOATSQRT2
FloatSub		equ FLOATSUB
FloatSwap		equ FLOATSWAP
FloatTan		equ FLOATTAN
FloatTanh		equ FLOATTANH
Float10ToTheX		equ FLOAT10TOTHEX
FloatTrunc		equ FLOATTRUNC
FloatGetStackPointer	equ FLOATGETSTACKPOINTER
FloatFloatToDword	equ FLOATFLOATTODWORD
FloatRandomN		equ FLOATRANDOMN
FloatDateNumberGetYear	equ FLOATDATENUMBERGETYEAR
FloatDateNumberGetWeekday	equ FLOATDATENUMBERGETWEEKDAY
FloatTimeNumberGetSeconds	equ FLOATTIMENUMBERGETSECONDS
FloatTimeNumberGetMinutes	equ FLOATTIMENUMBERGETMINUTES
FloatTimeNumberGetHour		equ FLOATTIMENUMBERGETHOUR
FloatGetNumDigitsInIntergerPart	equ FLOATGETNUMDIGITSININTERGERPART
 
global FloatExit:far
global FloatInit:far

global FloatFormatNumber:far
global FLOATMINUS1:far
global FLOATMINUSPOINT5:far
global FLOAT0:far
global FLOATPOINT5:far
global FLOAT1:far
global FLOAT2:far
global FLOAT5:far
global FLOAT10:far
global FLOAT3600:far
global FLOAT16384:far
global FLOAT86400:far

global FLOATABS:far
global FLOATADD:far
global FLOATARCCOS:far
global FLOATARCCOSH:far
global FLOATARCSIN:far
global FLOATARCSINH:far
global FLOATARCTAN:far
global FLOATARCTAN2:far
global FLOATARCTANH:far
global FloatCompAndDrop:far
global FloatComp:far
global FloatCompESDI:far
global FloatCompPtr:far
global FLOATCOS:far
global FLOATCOSH:far
global FLOATDEPTH:far
global FLOATDIV:far		; used "DIV" instead of "Div" to guard
				; against unintended errors
global FLOATDIVIDE:far
global FLOATDIVIDE2:far
global FLOATDIVIDE10:far
global FLOATDROP:far
global FLOATDUP:far
global FloatDwordToFloat:far
global FloatWordToFloat:far
global FloatEntry:far
global FLOATEPSILON:far
global FloatEq0:far
global FLOATEXP:far
global FLOATEXPONENTIAL:far
global FloatFloatToAscii:far
global FloatFloatToAscii_StdFormat:far
global FLOATFACTORIAL:far
global FLOATFRAC:far
global FloatGenerateFormatStr:far
global FormatDisplayNumber:far
global FloatGeos80ToIEEE64:far
global FloatGeos80ToIEEE32:far
global FLOATGETNUMDIGITSININTEGERPART:far
global FloatGetNumDigitsInIntegerPartInternal:far
global FloatGt0:far
global FloatIEEE64ToGeos80:far
global FloatIEEE32ToGeos80:far
global FLOATINT:far
global FLOATINTFRAC:far
global FLOATINVERSE:far
global FLOATLG:far
global FLOATLG10:far
global FLOATLN:far
global FLOATLN1PLUSX:far
global FLOATLN2:far
global FLOATLN10:far
global FLOATLOG:far
global FloatLt0:far
global FLOATMAX:far
global FLOATMIN:far
global FLOATMOD:far
global FLOATMULTIPLY:far
global FLOATMULTIPLY2:far
global FLOATMULTIPLY10:far
global FLOATNEGATE:far
global FLOATOVER:far
global FLOATPI:far
global FLOATPIDIV2:far
global FloatPick:far
global FloatPopNumber:far
global FloatPushNumber:far
global FLOATRANDOM:far
global FloatRandomInternal:far
global FloatRandomize:far
global FloatRandomizeInternal:far
global FLOATRANDOMN:far
global FloatRandomNInternal:far
global FloatRoll:far
global FloatRollInternal:far
global FloatRollDown:far
global FloatRollDownInternal:far
global FLOATROT:far
global FloatRound:far
global FLOATSIN:far
global FLOATSINH:far
global FLOATSQR:far
global FLOATSQRT:far
global FLOATSQRT2:far
global FloatAsciiToFloat:far
global FLOATSUB:far
global FLOATSWAP:far
global FLOATTAN:far
global FLOATTANH:far
global FLOAT10TOTHEX:far
global FLOATTRUNC:far
global FLOATFLOATTODWORD:far
global FLOATWORDTOFLOAT:far
global FloatCheckStackCount:far
global FLOATGETSTACKPOINTER:far
global FloatSetStackPointer:far

global FLOATFLOATTOASCII_STDFORMAT:far

global FloatGetDateNumber:far
global FLOATDATENUMBERGETYEAR:far
global FloatDateNumberGetMonthAndDay:far
global FLOATDATENUMBERGETWEEKDAY:far
global FloatGetTimeNumber:far
global FloatStringGetDateNumber:far
global FloatStringGetTimeNumber:far
global FLOATTIMENUMBERGETHOUR:far
global FLOATTIMENUMBERGETMINUTES:far
global FLOATTIMENUMBERGETSECONDS:far
global FloatGetDaysInMonth:far

;
; Controller related
;
global FloatFormatInit:far
global FloatFormatGetFormatParamsWithListEntry:far
global FloatFormatInitFormatList:far
global FloatFormatProcessFormatSelected:far
global FloatFormatInvokeUserDefDB:far
global FloatFormatUserDefOK:far
global FloatFormatGetFormatTokenWithName:far
global FloatFormatGetFormatParamsWithToken:far
global FloatFormatDelete:far
global FloatFormatIsFormatTheSame?:far
global FloatFormatAddFormat:far
global FLOATFORMATINIT:far
global FLOATFORMATGETFORMATPARAMSWITHLISTENTRY:far
global FLOATFORMATINITFORMATLIST:far
global FLOATFORMATPROCESSFORMATSELECTED:far
global FLOATFORMATINVOKEUSERDEFDB:far
global FLOATFORMATUSERDEFOK:far
global FLOATFORMATGETFORMATTOKENWITHNAME:far
global FLOATFORMATGETFORMATPARAMSWITHTOKEN:far
global FLOATFORMATDELETE:far
global FLOATFORMATISFORMATTHESAME?:far
global FLOATFORMATADDFORMAT:far

global FloatFSTSW:far
;***********************************************************************
;	these routines are meant for HARDWARE LIBRARIES ONLY
;	if you are need any of the following routines, check the above
;	list for the appropriate one
;***********************************************************************
global GetDateNumber:far
global DateNumberGetYear:far
global DateNumberGetMonthAndDay:far
global DateNumberGetWeekday:far
global GetTimeNumber:far
global StringGetDateNumber:far
global StringGetTimeNumber:far
global TimeNumberGetHour:far
global TimeNumberGetMinutes:far
global TimeNumberGetSeconds:far
global GetDaysInMonth:far

global FloatHardwareEnter:far
global FloatHardwareLeave:far
global FloatGetSoftwareStackHandle:far
global FloatPushNumberInternal:far
global FloatPopNumberInternal:far
global FloatSetStackSizeInternal:far
global FloatFloatToAsciiInternal:far
global FloatAsciiToFloatInternal:far
global FloatFloatToAscii_StdFormatInternal:far
global FloatPickInternal:far
global FloatHardwareInit:far
global FloatHardwareExit:far
global FloatGetStackDepth:far
global FloatSetStackDepth:far
global FloatSetStackSize:far

;
; C routines
;

;
; misc
;
global FloatLocalizeFormats:far
endif

protominor	GetModifiedFormat
global FloatFormatGetModifiedFormat:far
global FLOATFORMATGETMODIFIEDFORMAT:far
protoreset


;*******************************************************************************
;	FLOATING POINT CONTROLLER RELATED
;*******************************************************************************

;
; GenApplication GCN lists to be placed on:
;	GAGCNLT_SELF_LOAD_OPTIONS

FloatFormatClass	class	GenControlClass

if 0
;-------------------------------------------------------------------------------
;	EXTERNAL MESSAGES
;-------------------------------------------------------------------------------

MSG_FLOAT_CONTROLLER_SET_NUM_FORMAT			message

MSG_FLOAT_CONTROLLER_GET_LIST_ENTRY_WITH_TOKEN		message
;	PASS:	cx - format token
;	RETURN:	cx - list entry number
;

MSG_FLOAT_CONTROLLER_ADD_FORMAT				message
;
; Add the given format.
;	PASS:	dx:bp - ptr to a FormatParams structure
;	RETURN:	cx - 0 if successful
;		     -1 otherwise (realloc error / max format limit hit)
;

MSG_FLOAT_CONTROLLER_IS_FORMAT_THE_SAME			message
;
;	Checks to see if the FormatParams for the given token match the
;	FormatParams that are passed.
;
;	PASS:	cx - user def FormatParams
;		dx:bp - FormatParams
;	RETURN:	cx - FLOAT_CONTROLLER_FORMAT_PARAMS_MATCH /
;		     FLOAT_CONTROLLER_FORMAT_PARAMS_DONT_MATCH
;

;*******************************************************************************

MSG_FLOAT_CONTROLLER_GET_FORMAT_COUNT			message
;
; Get the number of names in the spreadsheet name list
;	RETURN:	dx - # of pre-defined names in the name list
;		bp - # of user-defined names in the name list
;

MSG_FLOAT_CONTROLLER_GET_FORMAT_INFO			message
;
; Get the moniker and format token for the given entry
;	PASS:	bp - entry # for which we need to get a moniker
;	RETURN:	dx:bp - address of null-terminated moniker
;		cx - format token
;

MSG_FLOAT_CONTROLLER_GET_FORMAT_TOKEN			message
;
; Get the format token that was assigned to the list entry number.
; 	PASS:	cx - list entry number
;	RETURN:	cx - format token
;

MSG_FLOAT_CONTROLLER_GET_FORMAT_TOKEN_WITH_PARAMS	message
;
; Get the format token given the format params of the format.
;
;     PASS:   dx:bp - address of format params (FloatFloatToAsciiParams)
;     RETURN: cx - format token if match found,
;             FLOAT_FORMAT_FORMAT_NAME_NOT_FOUND otherwise

MSG_FLOAT_CONTROLLER_CHANGE_FORMAT			message
;
; Delete the given format.
;	PASS:	cx - format token of format to change
;

MSG_FLOAT_CONTROLLER_DELETE_FORMAT			message
;
; Delete the given format.
;	PASS:	cx - format token of format to delete
;

endif

;-------------------------------------------------------------------------------
;	INTERNAL MESSAGES
;-------------------------------------------------------------------------------

MSG_FC_REQUEST_MONIKER			message
MSG_FORMAT_OPTION_STYLE_CHANGE		message
MSG_FORMAT_OPTION_BOOLEAN_CHANGE	message
MSG_FORMAT_SELECTED			message
MSG_FORMAT_USER_DEF_INVOKE		message
MSG_FORMAT_UPDATE_USER_DEF_SAMPLES	message
MSG_FORMAT_USER_DEF_OK			message
MSG_FORMAT_DELETE			message
MSG_FORMAT_APPLY			message
MSG_FORMAT_NUM_DECIMALS			message
MSG_FORMAT_DECIMAL_OFFSET		message
MSG_FORMAT_USER_DEF_CANCEL		message

NotifyFloatFormatChange	struc
	NFFC_vmFileHan	word
	NFFC_vmBlkHan	word
	NFFC_format	word
	NFFC_count	word
NotifyFloatFormatChange	ends

;
; variable data
;
TEMP_FLOAT_CTRL_USER_DEFINE_ACTIVE	vardata
;
; internally used to indicate user format definition is in progress
;

;-------------------------------------------------------------------------------
;	INSTANCE DATA
;-------------------------------------------------------------------------------

formatInfoStrucHan	word	(?)

;-------------------------------------------------------------------------------
;	UPDATE_UI DATA BLOCK STRUCTURES
;-------------------------------------------------------------------------------

;
; Definitions of parameter structures which are passed to the spreadsheet
; object in order to get, set, or modify information about names.
;
; Please see the method definition to determine which of these fields you
; actually need to fill in.
;
FormatNameParams	struct
    FNP_listEntry	word		; the entry # in the defined list
    FNP_textLength	word		; length of the format name
SBCS< FNP_text		char  FORMAT_NAME_LENGTH dup (?)	>
DBCS< FNP_text		wchar FORMAT_NAME_LENGTH dup (?)	>
    FNP_token		word		; the token of the format
    align		word
FormatNameParams	ends

FloatCtrlInfoStruc	struc
	;
	; passed values
	;
	FCIS_listEntryNum	word
	FCIS_fmtToken		word
	FCIS_listOD		dword
	FCIS_fmtArrayHan	word
	FCIS_fmtArraySeg	word
	;
	; returned values
	;
	FCIS_fmtParamsHan	word
FloatCtrlInfoStruc	ends

;
; The target document passes the VM block handle of the document's format data
; block with each MSG_GEN_CONTROL_UPDATE_UI.  The float controller manages this
; data block:
;	*  when the user defines a new format, a format entry gets added
;	*  when the user edits an existing format, a format entry gets modified
;	*  when the user deletes an existing format, a format entry is nuked
;
UpdateUIDataBlk	struc
	UUIDB_formatDataVMFileHan	word
	UUIDB_formatDataVMBlkHan	word
	UUIDB_curFormatToken		FormatIdType	; current format token
UpdateUIDataBlk	ends

;-------------------------------------------------------------------------------
;	CONSTANTS AND STRUCTURES
;-------------------------------------------------------------------------------

SamplesStruc	struc
if DBCS_PCGEOS
	SS_sample1Str	wchar	FLOAT_TO_ASCII_NORMAL_BUF_LEN dup (?)
	SS_sample2Str	wchar	FLOAT_TO_ASCII_NORMAL_BUF_LEN dup (?)
	SS_formatPosStr	wchar	FLOAT_TO_ASCII_NORMAL_BUF_LEN dup (?)
	SS_formatNegStr	wchar	FLOAT_TO_ASCII_NORMAL_BUF_LEN dup (?)
else
	SS_sample1Str	char	FLOAT_TO_ASCII_HUGE_BUF_LEN dup (?)
	SS_sample2Str	char	FLOAT_TO_ASCII_HUGE_BUF_LEN dup (?)
	SS_formatPosStr	char	FLOAT_TO_ASCII_HUGE_BUF_LEN dup (?)
	SS_formatNegStr	char	FLOAT_TO_ASCII_HUGE_BUF_LEN dup (?)
endif
SamplesStruc	ends

FloatFormatErrors	etype byte, 0
FLOAT_FORMAT_NO_ERROR	enum	FloatFormatErrors
FLOAT_FORMAT_TOO_MANY_FORMATS		enum	FloatFormatErrors
FLOAT_FORMAT_CANNOT_ALLOC		enum	FloatFormatErrors

;
; picked with FORMAT_ID_PREDEF in mind 
;
FLOAT_FORMAT_FORMAT_NAME_NOT_FOUND	=	7fffh
FLOAT_FORMAT_PARAMS_MATCH		=	TRUE
FLOAT_FORMAT_PARAMS_DONT_MATCH		=	FALSE

; Features flags (used with ATTR_GEN_CONTROL_REQUIRE_UI and
; ATTR_GEN_CONTROL_PROHIBIT_UI )

FFCFeatures	record
	:14
	FCF_FORMAT_LIST:1
	FCF_DEFINE_FORMATS:1
FFCFeatures	end

FLOAT_CTRL_DEFAULT_FEATURES		equ	mask FFCFeatures


FormatOption	record
	:2
	FO_COMMA:1
	FO_PCT:1
	FO_LEAD_ZERO:1
	FO_TRAIL_ZERO:1
	FO_HEADER_SIGN_POS:1
	FO_TRAILER_SIGN_POS:1
FormatOption	end

;
; passed as a block to the format create/edit code
;
FormatInfoStruc	struc
	;
	; in some cases, it may be convenient for the controller to have
	; the target fill in the user def format array information and
	; send this message to the controller
	;
		FIS_signature			word	; for EC purposes

	;
	; user def fmt array for controller to work on
	;
		FIS_userDefFmtArrayFileHan	word	; file handle
		FIS_userDefFmtArrayBlkHan	word	; block handle

	;
	; ODs for objects in the controller that the target can get to
	;
		FIS_childBlk			word
		FIS_chooseFmtListChunk		word

	;
	; for use by the controller
	;
		FIS_features		FFCFeatures
		FIS_editFlag		byte	; -1 if editing, 0 if creating
		FIS_curSelection	word	; selected item in format list
		FIS_curToken		word	; token of selected item
		FIS_curParams		FormatParams ; params for selected item

FormatInfoStruc	ends

FORMAT_INFO_STRUC_ID	equ	('y' shl 8) or 'c'

;-------------------------------------------------------------------------------
;	META METHODS FOR THE FLOAT FORMAT CONTROLLER
;-------------------------------------------------------------------------------

	;
	; MSG_FLOAT_CTRL_REQUEST_MONIKER
	; Sent to the target for it to set the appropriate list moniker.
	;
	; PASSED:	cx - handle of FormatInfoStruc
	;
	; App should:
	;	lock FormatInfoStruc
	;	fill in user def array info
	;	call FloatFormatGetFormatParamsWithListEntry (utility routine
	;	    to fill in format info)
	;	set the moniker
	;	free the FormatInfoStruc
	; For an example, see SSFormatRequestMoniker in the SSheet lib
	;
MSG_FLOAT_CTRL_REQUEST_MONIKER		message	MetaFloatMessages

	;
	; MSG_FLOAT_CTRL_UPDATE_UI
	; Sent to the target for it to initialize the "choose format" list
	;
	; PASSED:	cx - mem handle of FormatInfoStruc
	;
	; App should:
	;	lock FormatInfoStruc
	;	fill in user def array info
	;	call FloatFormatInitFormatList (utility routine)
	;	call FloatFormatProcessFormatSelected
	;	free FormatInfoStruc
	; For an example, see SSFormatUpdateUI in the SSheet lib
	;
MSG_FLOAT_CTRL_UPDATE_UI	message	MetaFloatMessages

	;
	; MSG_FLOAT_CTRL_FORMAT_SELECTED
	; Sent to the target for it to pass info about the user array.
	;
	; PASSED:	cx - mem handle of FormatInfoStruc
	;
	; App should:
	;	lock FormatInfoStruc
	;	fill in user def array info
	;	call FloatFormatProcessFormatSelected
	;	free FormatInfoStruc
	; For an example, see SSFormatSelected in the SSheet lib
	;
MSG_FLOAT_CTRL_FORMAT_SELECTED	message MetaFloatMessages

	;
	; MSG_FLOAT_CTRL_USER_DEF_INVOKE
	; Sent to the target for it to initiate the User Define Format DB.
	; Target should not free the FormatInfoStruc.
	;
	; PASSED:	cx - mem handle of FormatInfoStruc
	;
	; App should:
	;	lock FormatInfoStruc
	;	fill in user def array info
	;	call FloatFormatGetFormatParamsWithListEntry
	;	call FloatFormatInvokeUserDefDB
	;	unlock FormatInfoStruc
	; For an example, see SSFormatUserDefInvoke in the SSheet lib
	;
MSG_FLOAT_CTRL_USER_DEF_INVOKE	message MetaFloatMessages

	;
	; MSG_FLOAT_CTRL_USER_DEF_OK
	; Sent to the target for it to process the User Define Format DB.
	;
	; PASSED:	cx - mem handle of FormatInfoStruc
	;
	; App should:
	;	lock FormatInfoStruc
	;	fill in user def array info
	;	call FloatFormatUserDefOK
	;	free FormatInfoStruc (NOTE: do not free if error)
	; For an example, see SSFormatUserDefInvoke in the SSheet lib
	;
MSG_FLOAT_CTRL_USER_DEF_OK	message MetaFloatMessages

	;
	; MSG_FLOAT_CTRL_FORMAT_DELETE
	; Sent to the target for it to delete the selected item.
	;
	; PASSED:	cx - mem handle of FormatInfoStruc
	;
	; App should:
	;	lock FormatInfoStruc
	;	fill in user def array info
	;	call FloatFormatGetFormatParamsWithListEntry
	;	call FloatFormatDelete
	;	free FormatInfoStruc
	; For an example, see SSFormatDelete in the SSheet lib
	;
MSG_FLOAT_CTRL_FORMAT_DELETE	message MetaFloatMessages

	;
	; MSG_FLOAT_CTRL_REPLACE_NUM_FORMAT
	;
	; Replace all occurences of a format token with another
	; PASS:	cx - format token to replace
	;	dx - format token replacement
	;
MSG_FLOAT_CTRL_REPLACE_NUM_FORMAT	message	MetaFloatMessages

	;
	; MSG_FLOAT_CTRL_FORMAT_APPLY
	;
	; User has selected a format.
	; App should:
	;	lock FormatInfoStruc
	;	fill in user def array info
	;	call FloatFormatGetFormatParamsWithListEntry
	;	use info in the FormatInfoStruc
	;	free FormatInfoStruc
	; For an example, see SSFormatApply in the SSheet lib
MSG_FLOAT_CTRL_FORMAT_APPLY		message	MetaFloatMessages

FloatFormatClass	endc


EndLibrary	math
