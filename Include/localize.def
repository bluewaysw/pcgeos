COMMENT @----------------------------------------------------------------------

	Copyright (c) GeoWorks 1989 -- All Rights Reserved

PROJECT:	PC GEOS
FILE:		localize.def

DECLARER:	Kernel

DESCRIPTION:
	This file defines constants for localization

	$Id: localize.def,v 1.2 98/06/17 21:33:14 gene Exp $

------------------------------------------------------------------------------@
SetDef	__LOCALIZE

include	sllang.def

StartKernel

global LocalSetDateTimeFormat:far
global LocalGetDateTimeFormat:far
global LocalFormatDateTime:far
global LocalFormatFileDateTime:far
global LocalParseDateTime:far
global LocalCustomParseDateTime:far
global LocalUpcaseChar:far
global LocalDowncaseChar:far
global LocalUpcaseString:far
global LocalDowncaseString:far
global LocalCmpStrings:far
global LocalCmpStringsNoCase:far
global LocalCmpChars:far
global LocalCmpCharsNoCase:far
global LocalCmpStringsNoSpace:far
global LocalCmpStringsNoSpaceCase:far
global LocalIsUpper:far
global LocalIsLower:far
global LocalIsAlpha:far
global LocalIsPunctuation:far
global LocalIsSpace:far
global LocalIsControl:far
global LocalIsDigit:far
global LocalIsHexDigit:far
global LocalIsAlphaNumeric:far
global LocalIsPrintable:far
global LocalIsGraphic:far
global LocalIsSymbol:far
global LocalIsDateChar:far
global LocalIsTimeChar:far
global LocalIsNumChar:far
global LocalDosToGeos:far
global LocalGeosToDos:far
global LocalGetQuotes:far
global LocalSetQuotes:far
global LocalIsDosChar:far
global LocalCustomFormatDateTime:far
global LocalGetNumericFormat:far
global LocalSetNumericFormat:far
global LocalGetCurrencyFormat:far
global LocalSetCurrencyFormat:far
global LocalCmpStringsDosToGeos:far		;not in DBCS
global LocalIsCodePageSupported:far
global LocalCodePageToGeos:far			;not in DBCS
global LocalGeosToCodePage:far			;not in DBCS
global LocalCodePageToGeosChar:far		;not in DBCS
global LocalGeosToCodePageChar:far		;not in DBCS
global LocalDosToGeosChar:far
global LocalGeosToDosChar:far
global LocalGetCodePage:far
global LocalSetCodePage:far
global LocalSetMeasurementType:far
global LocalLexicalValue:far
global LocalLexicalValueNoCase:far
global LocalStringSize:far
global LocalStringLength:far
global LocalDistanceToAscii:far
global LocalDistanceFromAscii:far
global LocalFixedToAscii:far
global LocalAsciiToFixed:far
global LocalCalcDaysInMonth:far
if DBCS_PCGEOS
global LocalAddGengoName:far
global LocalRemoveGengoName:far
global LocalIsKana:far
global LocalIsKanji:far
global LocalGetGengoInfo:far
global LocalSetKinsoku:far
global LocalGetKinsoku:far
global LocalGetWordPartType:far
endif

LocalGetMeasurementType	equ	LOCALGETMEASUREMENTTYPE
LocalGetLanguage equ		LOCALGETLANGUAGE
global LocalSetTimezone:far
global LocalGetTimezone:far
global LocalNormalizeDateTime:far
global LocalCompareDateTimes:far
global LocalCalcDayOfWeek:far

;-

global LOCALGETMEASUREMENTTYPE:far
global LOCALGETDATETIMEFORMAT:far
global LOCALFORMATDATETIME:far
global LOCALFORMATFILEDATETIME:far
global LOCALPARSEDATETIME:far
global LOCALCUSTOMPARSEDATETIME:far
global TOUPPER:far
global TOLOWER:far
global LOCALUPCASESTRING:far
global LOCALDOWNCASESTRING:far
global LOCALCMPSTRINGS:far
global LOCALCMPSTRINGSNOCASE:far
global LOCALCMPSTRINGSNOSPACE:far
global LOCALCMPSTRINGSNOSPACECASE:far
global ISUPPER:far
global ISLOWER:far
global ISALPHA:far
global ISPUNCT:far
global ISSPACE:far
global ISCNTRL:far
global ISDIGIT:far
global ISXDIGIT:far
global ISALNUM:far
global ISPRINT:far
global ISGRAPH:far
global LOCALISSYMBOL:far
global LOCALISDATECHAR:far
global LOCALISTIMECHAR:far
global LOCALISNUMCHAR:far
global LOCALISDOSCHAR:far
global LOCALDOSTOGEOSCHAR:far
global LOCALGEOSTODOSCHAR:far
global LOCALGETCODEPAGE:far
global LOCALSETCODEPAGE:far
global LOCALDOSTOGEOS:far
global LOCALGEOSTODOS:far
global LOCALGETQUOTES:far
global LOCALCUSTOMFORMATDATETIME:far
global LOCALGETNUMERICFORMAT:far
global LOCALGETCURRENCYFORMAT:far
global LOCALCMPSTRINGSDOSTOGEOS:far
global LOCALISCODEPAGESUPPORTED:far
global LOCALCODEPAGETOGEOS:far
global LOCALGEOSTOCODEPAGE:far
global LOCALCODEPAGETOGEOSCHAR:far
global LOCALGEOSTOCODEPAGECHAR:far
global LOCALLEXICALVALUE:far
global LOCALLEXICALVALUENOCASE:far
global LOCALSETDATETIMEFORMAT:far
global LOCALSETQUOTES:far
global LOCALSETNUMERICFORMAT:far
global LOCALSETCURRENCYFORMAT:far
global LOCALSETMEASUREMENTTYPE:far
global LOCALSTRINGSIZE:far
global LOCALSTRINGLENGTH:far
global LOCALDISTANCETOASCII:far
global LOCALDISTANCEFROMASCII:far
global LOCALFIXEDTOASCII:far
global LOCALASCIITOFIXED:far
global LOCALGETLANGUAGE:far
global LOCALCALCDAYSINMONTH:far
if DBCS_PCGEOS
global LOCALADDGENGONAME:far
global LOCALREMOVEGENGONAME:far
global LOCALISKANA:far
global LOCALISKANJI:far
global LOCALGETGENGOINFO:far
global LOCALGETWORDPARTTYPE:far
endif
global LOCALSETTIMEZONE:far
global LOCALGETTIMEZONE:far
global LOCALNORMALIZEDATETIME:far
global LOCALCOMPAREDATETIMES:far
global LOCALCALCDAYOFWEEK:far

;===============================================================================
;
;	Localization Macros
;
;===============================================================================

COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

MACRO:		_ParseReg

DESCRIPTION:	Parse a register into low and high portions

PASS:
	reg - register
	op - string for operator identification

RETURN:
	regl - low byte of arg
	regh - high byte of arg

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@
_ParseReg	macro	reg, regl, regh, op
	local	t, q, lc

if (4 AND .TYPE (reg))
    ErrMessage <op : charReg cannot be a constant>
else
    alen sizestr <&reg>
    if (alen eq 2)
	t  substr <reg>, 1, 1
	lc substr <reg>, 2, 1
	
	regh catstr t, <h>
	regl catstr t, <l>

	ifdif lc, <x>			;; must end in "x"
	    ErrMessage <op : reg must be one of ax, bx, cx, or dx>
	endif
	
	q instr <abcd>, t
	if (q eq 0)
	    ErrMessage <op : reg must be one of ax, bx, cx, or dx>
	endif
    else
	ErrMessage <op : reg cannot be used for high/low pair>
    endif
endif

endm


COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		SBCS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Include code only in the SBCS version of PC/GEOS

PASS:		line - line of source code

PSEUDO CODE/STRATEGY:
	Only includes line if DBCS_PCGEOS is false
KNOWN BUGS/SIDE EFFECTS/IDEAS:

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	gene	9/17/92		Initial version

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@
SBCS		macro	line
	if not DBCS_PCGEOS
line
	endif
endm


COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		DBCS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Include code only in the DBCS version of PC/GEOS

PASS:		line - line of source code

PSEUDO CODE/STRATEGY:

KNOWN BUGS/SIDE EFFECTS/IDEAS:
	Only includes line if DBCS_PCGEOS *is* defined
REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	gene	9/17/92		Initial version

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@
DBCS		macro	line
	if	DBCS_PCGEOS
line
	endif
endm


COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		PZ
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Include code one in the PZ(pizza) version of PC/GEOS

PASS:		line - line of source code

PSEUDO CODE/STRATEGY:
	Only include line if PZ_PCGEOS is true
KNOWN BUGS/SIDE EFFECTS/IDEAS:

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@
PZ		macro	line
	if	PZ_PCGEOS
line
	endif
		endm


COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		NPZ
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Include code one in the NOT PZ (pizza) version of PC/GEOS

PASS:		line - line of source code

PSEUDO CODE/STRATEGY:
	Only include line if PZ_PCGEOS is false
KNOWN BUGS/SIDE EFFECTS/IDEAS:

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@
NPZ		macro	line
	if not	PZ_PCGEOS
line
	endif
		endm


COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		LocalCopyString
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Copy a NULL-terminated string

PASS:		ds:si - ptr to source
		es:di - ptr to dest
		<optional> SAVE_REGS to preserve registers
			(Otherwise, SI and DI will point to the byte/word
			immediately following the null term in the source
			and dest strings.)

DESTROYED:	ax (see note above concerning how SI and DI may change)

PSEUDO CODE/STRATEGY:

KNOWN BUGS/SIDE EFFECTS/IDEAS:

EXPANDS TO:
	if SAVE_REGS:
		12 bytes
	else:
		6 bytes

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	gene	9/17/92		Initial version

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@

LocalCopyString	macro	saveFlag
	local	charLoop
ifnb <saveFlag>
    ifidn <saveFlag>, <SAVE_REGS>
	push	ax, si, di
    else
	ErrMessage <LocalCopyString: unrecognized flag>
    endif
endif
charLoop:
					; bytes / cycles
if DBCS_PCGEOS
	lodsw				; 1 / 16
	stosw				; 1 / 15
	tst	ax			; 2 /  3
	jnz	charLoop		; 2 / 16
else
	lodsb				; 1 / 12
	stosb				; 1 / 11
	tst	al			; 2 /  3
	jnz	charLoop		; 2 / 16
endif
					; 6 / 42 per char
ifnb <saveFlag>
    ifidn <saveFlag>, <SAVE_REGS>
	pop	ax, si, di
    endif
endif
endm


COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		LocalCopyNString
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Copy N characters of a string

PASS:		ds:si - ptr to source
		es:di - ptr to dest
		cx - # of characters to copy
		<optional> SAVE_REGS to preserve registers

DESTROYED:	cx, si, di (unless SAVE_REGS passed)

PSEUDO CODE/STRATEGY:

KNOWN BUGS/SIDE EFFECTS/IDEAS:

EXPANDS TO:
	if SAVE_REGS:
		7 bytes
	else:
		1 byte

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	gene	9/17/92		Initial version

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@

LocalCopyNString	macro	saveFlag
ifnb <saveFlag>
    ifidn <saveFlag>, <SAVE_REGS>
	push	cx, si, di
    endif
endif
if DBCS_PCGEOS
	rep	movsw
else
	rep	movsb
endif
ifnb <saveFlag>
    ifidn <saveFlag>, <SAVE_REGS>
	pop	cx, si, di
    endif
endif
endm


COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		LocalCopySBCSToDBCS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Copy an SBCS string to DBCS string

PASS:		ds:si - ptr to source (SBCS)
		es:di - ptr to dest (DBCS)
RETURN:		ds:si - past NULL
		es:di - past NULL
DESTROYED:	ax

PSEUDO CODE/STRATEGY:
KNOWN BUGS/SIDE EFFECTS/IDEAS:
REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	gene	12/ 7/93		Initial version

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@

LocalCopySBCSToDBCS	macro
	local	copyLoop

	clr	ah
copyLoop:
	lodsb					;al <- SBCS char
	stosw					;store DBCS char
	tst	ax				;reached NULL?
	jnz	copyLoop			;loop until NULL
endm


COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		LocalCopyFixedString
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Copies a string of fixed length.

PASS:		ds:si  - ptr to source
		es:di  - ptr to dest
		length - length of string
		<optional> SAVE_REGS to preserve registers

DESTROYED:	cx, si, di (unless SAVE_REGS passed)

PSEUDO CODE/STRATEGY:
KNOWN BUGS/SIDE EFFECTS/IDEAS:

EXPANDS TO:
	if SAVE_REGS:
		15 bytes if length is even
		16 bytes if length is odd
	else:
		5 bytes if length is even
		6 bytes if length is odd
	
REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	martin	11/4/92		Initial version

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@
LocalCopyFixedString		macro	length, saveFlag
ifnb <saveFlag>
    ifidn <saveFlag>, <SAVE_REGS>
	push	cx, si, di			; 3 / 45
    endif
endif
if DBCS_PCGEOS
	mov	cx, (length)			; 3 / 4
	rep	movsw				; 2 / 9+25n
else
	mov	cx, (length) / 2		; 3 / 4
	rep	movsw				; 2 / 9+12.5n
if (((length) and 1) eq 1)
	movsb					; 1 / 18
endif
endif
ifnb <saveFlag>
    ifidn <saveFlag>, <SAVE_REGS>
	pop	cx, si, di			; 3 / 36
    endif
endif
endm


COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		LocalGetChar
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Get a character of a string

PASS:		charReg - word register to put char into
		strPtr - regpair ptr to source string
		<optional> NO_ADVANCE to not advance the pointer

    the following are the optimal values:
		ax - word register to put char into
		dssi - ptr to source string

RETURN:		charReg - character
		strPtr - updated to next character (unless NO_ADVANCE)
		

PSEUDO CODE/STRATEGY:

KNOWN BUGS/SIDE EFFECTS/IDEAS:

EXPANDS TO:
	ax, ds:[si] -- 2 bytes (1 byte in DBCS)
	others -- 4 bytes + addressing mode (3 bytes + am in DBCS)

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	gene	9/17/92		Initial version

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@

_LGCReg	macro	charReg, strPtr, noAdvance
	local	rl, rh, dwl, dwh, regargs

regargs = 0
_ParseReg charReg, rl, rh, LocalGetChar
_ParseDWordArg strPtr, dwl, dwh, regargs, LocalGetChar

if (regargs gt 0)
    if DBCS_PCGEOS
        mov	charReg, {word} dwh:[dwl]
    else
        mov rl, {byte} dwh:[dwl]
    endif
else
    ifnb <noAdvance>
    	if DBCS_PCGEOS
            mov	charReg, strPtr
        else
            mov rl, strPtr
        endif
    else
        ErrMessage <LocalGetChar : cannot use memory-based string w/advance ptr>
    endif
endif

endm

LocalGetChar		macro charReg, strPtr, noAdvance

ifidn <charReg>, <ax>			;if (charReg == ax)
    ifb <noAdvance>			; && (!NO_ADVANCE)
	ifidn <strPtr>, <dssi>		; && (strPtr == dssi) {
	    if DBCS_PCGEOS
		lodsw			;  lodsw (DBCS)
	    else
		lodsb			;  lodsb (SBCS)
	    endif
	else				;} else {
	    _LGCReg charReg, strPtr	;  mov charReg, strPtr
	    LocalNextChar strPtr	;  strPtr++
	endif				;}
    else
	_LGCReg charReg, strPtr, noAdvance
    endif
else
    _LGCReg charReg, strPtr, noAdvance
    ifb <noAdvance>
	LocalNextChar strPtr
    endif
endif

endm


COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		LocalPutChar
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Put a character into a string

PASS:		charReg - word register with character
		strPtr - regpair ptr to dest string
		<optional> NO_ADVANCE to not advance the pointer

    the following are the optimal values:
		ax - word register with character
		esdi - ptr to dest string

RETURN:		strPtr - updated to next character (unless NO_ADVANCE)

PSEUDO CODE/STRATEGY:

KNOWN BUGS/SIDE EFFECTS/IDEAS:

EXPANDS TO:
	ax, esdi -- 1 byte (non-EC)
	others -- 3 bytes + addressing mode

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	gene	9/17/92		Initial version

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@
_LPCReg	macro	charReg, strPtr
	local	rl, rh, dwl, dwh, regargs

regargs = 0
_ParseReg charReg, rl, rh, LocalPutChar
_ParseDWordArg strPtr, dwl, dwh, regargs, LocalPutChar

if (regargs gt 0)
    if DBCS_PCGEOS
        mov	{word} dwh:[dwl], charReg
    else
        mov {byte} dwh:[dwl], rl
    endif
else
    ErrMessage <LocalPutChar : cannot use memory-based pointer>
endif
endm

LocalPutChar		macro strPtr, charReg, noAdvance

ifidn <charReg>, <ax>			;if (charReg == ax)
    ifb <noAdvance>			; && (!NO_ADVANCE)
	ifidn <strPtr>, <esdi>		; && (strPtr == esdi) {
	    if DBCS_PCGEOS
		stosw			;  stosw (DBCS)
	    else
		stosb			;  stosb (SBCS)
	    endif
	else				;} else {
	    _LPCReg charReg, strPtr	;  mov strPtr, charReg
	    LocalNextChar strPtr	;  strPtr++
	endif				;}
    else
	_LPCReg charReg, strPtr
    endif
else
    _LPCReg charReg, strPtr
    ifb <noAdvance>
	LocalNextChar strPtr
    endif
endif

endm


COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		LocalNextChar
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Advance a string pointer to the next character

PASS:		pointer - far pointer to update

RETURN:		pointer - updated

PSEUDO CODE/STRATEGY:

KNOWN BUGS/SIDE EFFECTS/IDEAS:

EXPANDS TO:
	REGISTER PAIR:
	    SBCS: 1 byte
	    DBCS: 2 bytes
	MEMORY:
	    SBCS: 1 byte + addressing mode
	    DBCS: 3 bytes + addressing mode

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	gene	9/17/92		Initial version

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@
LocalNextChar		macro	pointer, arg2
	local	drl, drh, regargs

    if (.TYPE (pointer)) AND 10h        ;see if val is one register
	ErrMessage      "next pointer must be esdi like"
    endif

regargs = 0
_CheckDWordOneArg <pointer>, <LocalNextChar>, <arg2>
_ParseDWordArg <pointer>, drl, drh, regargs, <LocalNextChar>

if DBCS_PCGEOS
	if (regargs gt 0)
		inc	drl
		inc	drl
	else
		add	drl, 2
	endif
else
	inc	drl
endif

endm


COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		LocalPrevChar
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Move a string pointer to the previous character

PASS:		pointer - far pointer to update

RETURN:		pointer - updated

PSEUDO CODE/STRATEGY:

KNOWN BUGS/SIDE EFFECTS/IDEAS:

EXPANDS TO:
	REGISTER PAIR:
	    SBCS: 1 byte
	    DBCS: 2 bytes
	MEMORY:
	    SBCS: 1 byte + addressing mode
	    DBCS: 3 bytes + addressing mode

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	gene	9/17/92		Initial version

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@
LocalPrevChar		macro	pointer, arg2
	local	drl, drh, regargs

    if (.TYPE (pointer)) AND 10h        ;see if val is one register
	ErrMessage      "prev pointer must be esdi like"
    endif

regargs = 0
_CheckDWordOneArg <pointer>, <LocalPrevChar>, <arg2>
_ParseDWordArg <pointer>, drl, drh, regargs, <LocalPrevChar>

if DBCS_PCGEOS
	if (regargs gt 0)
		dec	drl
		dec	drl
	else
		sub	drl, 2
	endif
else
	dec	drl
endif

endm


COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		LocalIsNull
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Test a character to see if it is NULL

PASS:		charReg - word register with character
			Can also be a memory reference that will be typecast.

RETURN:		z flag - set (jz) if character is NULL

PSEUDO CODE/STRATEGY:

KNOWN BUGS/SIDE EFFECTS/IDEAS:

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	gene	9/18/92		Initial version
	witt	10/21/93	Accept memory reference as well.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@
LocalIsNull		macro	charReg
	local	rl, rh, regargs

if (.TYPE (charReg)) AND 10h        ;; see if charReg is a register

  _ParseReg charReg, rl, rh, LocalCharIsNull

  if DBCS_PCGEOS
	tst	charReg
  else
	tst	rl
  endif
else
	;; Nope, a memory reference..
  if DBCS_PCGEOS
	tst	<{wchar} charReg>
  else
	tst	<{char} charReg>
  endif
endif

endm


COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		LocalClrChar
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Clears a character, ie, sets it to C_NULL  Handles register
		and memory locations.  Uses 'clr' macro to do all the work.

PASS:		clrReg = place to store C_NULL, either register or memory.

PSEUDO CODE/STRATEGY:
		Use 'clr' macro to do all the work.
		If a memory reference, it is typecasted appropriately.

DESTROYED:	Flags are destroyed by 'clr' macro.

KNOWN BUGS/SIDE EFFECTS/IDEAS:

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	witt	1/ 7/94   	Initial version

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@
LocalClrChar		macro	clrReg
	local	rl, rh, regargs

if (.TYPE (clrReg)) AND 10h		;; see if clrReg is a register

  _ParseReg clrReg, rl, rh, LocalClrChar

  if DBCS_PCGEOS
	clr	clrReg
  else
	clr	rl
  endif
else
	;; Nope, a memory reference..
  if DBCS_PCGEOS
	clr1	<{wchar} clrReg>
  else
	clr1	<{char} clrReg>
  endif
endif

	endm


COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		LocalFindChar
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Find a character in a string

PASS:		ax - character
		esdi - ptr to string
		cx - # of characters to check
		NOTE: cx = 0 is invalid

DESTROYED:	cx

RETURN:		esdi - updated to next character beyond match
		z flag - set (je) if character found

PSEUDO CODE/STRATEGY:

KNOWN BUGS/SIDE EFFECTS/IDEAS:

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	gene	11/29/92	Initial version

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@
LocalFindChar		macro

if DBCS_PCGEOS
	repne	scasw
else
	repne	scasb
endif

endm


COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		LocalFindCharBackward
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Find a character in a string searching backward

PASS:		ax - character
		esdi - ptr to string
		cx - # of characters to check
		NOTE: cx = 0 is invalid

DESTROYED:	cx

RETURN:		esdi - updated to next character beyond match
		z flag - set (je) if character found

PSEUDO CODE/STRATEGY:

KNOWN BUGS/SIDE EFFECTS/IDEAS:

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	dlitwin	8/17/94		Initial version

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@
LocalFindCharBackward		macro
	std			; search backward
if DBCS_PCGEOS
	repne	scasw
else
	repne	scasb
endif
	cld			; restore direction flag to forward
endm


COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		LocalStrSize
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Find the size of a NULL-terminated string

PASS:		esdi - ptr to string
		includeNull - if non-blank, include size of NULL

RETURN:		esdi - ptr beyond NULL
		if includeNull:
		    cx - size of string (w/ NULL)
		else:
		    cx - size of string (w/o NULL)

DESTROYED:	ax

PSEUDO CODE/STRATEGY:

KNOWN BUGS/SIDE EFFECTS/IDEAS:
	NOTE: because this expands to more than the 5 bytes for a far
	call, you should normally call LocalStringSize() instead.

EXPANDS TO:
	SBCS:
	DBCS:

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	gene	4/14/93		Initial version

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@
LocalStrSize		macro includeNull

	LocalStrLength	<includeNull>

DBCS <	shl	cx, 1				; cx <- # of bytes>

endm


COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		LocalStrLength
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Find the length of a NULL-terminated string

PASS:		esdi - ptr to string
		includeNull - if non-blank, include NULL in length

RETURN:		esdi - ptr beyond NULL
		if includeNull:
		    cx - length of string (w/ NULL)
		else:
		    cx - length of string (w/o NULL)

DESTROYED:	ax

PSEUDO CODE/STRATEGY:

KNOWN BUGS/SIDE EFFECTS/IDEAS:
	NOTE: because this expands to more than the 5 bytes for a far
	call, you should normally call LocalStringLength() instead.

EXPANDS TO:
	SBCS:
	DBCS:

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	gene	4/14/93		Initial version

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@
LocalStrLength		macro includeNull

if DBCS_PCGEOS
	clr	ax				; ax <- word to scan for
else
	clr	al				; al <- byte to scan for
endif
	mov	cx, -1				; Scan this many bytes/words

if DBCS_PCGEOS
	repne	scasw				; di <- offset past null
else
	repne	scasb				; di <- offset past null
endif

	not	cx				; cx <- # of chars w/ null
ifb <includeNull>
	dec	cx				; cx <- # of chars w/o null
endif

endm



COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		LocalCmpChar
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Compare a memory or register location to a character constant

PASS:		source - memory location or register
		val - character constant

RETURN:		flag - set for compare

PSEUDO CODE/STRATEGY:

KNOWN BUGS/SIDE EFFECTS/IDEAS:

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	gene	6/22/93		Initial version

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@
LocalCmpChar		macro	source, val
	local	rl, rh, regargs

    alen sizestr <&source>
    if (alen eq 2)
	if DBCS_PCGEOS
		cmp	source, val
	else
		_ParseReg source, rl, rh, LocalCmpChar
		cmp	rl, val
	endif
    else

	if DBCS_PCGEOS
		cmp	{wchar} source, val
	else
		cmp	{char} source, val
	endif
    endif

endm



COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		LocalLoadChar
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Load a register with a character constant

PASS:		dest - register
		val - character constant

RETURN:		flag - set for compare

PSEUDO CODE/STRATEGY:

KNOWN BUGS/SIDE EFFECTS/IDEAS:

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	gene	6/22/93		Initial version

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@
LocalLoadChar		macro	source, val
	local	rl, rh, regargs

    _ParseReg source, rl, rh, LocalLoadChar
    if DBCS_PCGEOS
	mov	source, val
    else
	mov	rl, val
    endif

endm


COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		LocalDefString
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Define a localizeable string

PASS:		name - name of chunk
		str - string constant

PSEUDO CODE/STRATEGY:

KNOWN BUGS/SIDE EFFECTS/IDEAS:

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	gene	7/ 7/93		Initial version

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@
LocalDefString		macro	name, str

ifb <str>
    .warn -unref
    if DBCS_PCGEOS
	chunk.wchar	name
    else
	chunk.char	name
    endif
    .warn @unref
else
    if DBCS_PCGEOS
	name	chunk.wchar	str
    else
	name	chunk.char	str
    endif
endif

endm


COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		LocalDefNLString
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Define a non-localizeable string

PASS:		name - name of chunk
		str - string constant

PSEUDO CODE/STRATEGY:

KNOWN BUGS/SIDE EFFECTS/IDEAS:
	NOTE: use this with caution -- most strings need to be localizeable,
	and therefore should be defined in lmem resources in .ui files or
	using LocalDefString in .asm files.

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	gene	7/ 7/93		Initial version

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@
LocalDefNLString		macro	name, str

ifb <str>
    .warn -unref
    if DBCS_PCGEOS
	wchar	name
    else
	char	name
    endif
    .warn @unref
else
    if DBCS_PCGEOS
	name	wchar	str
    else
	name	char	str
    endif
endif

endm

;==============================================================================
;
;	String macros useful for strings which remain single-byte in a
;	DBCS system
;
;==============================================================================


COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		SBStringLength
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Get the length of a single-byte string (regardless of
		SBCS or DBCS system)

PASS:		es:di	- ptr to string
RETURN:		if includeNull:
			cx - length of string (w/ NULL)
		else
			cx - length of string (w/out NULL)

PSEUDO CODE/STRATEGY:

KNOWN BUGS/SIDE EFFECTS/IDEAS:

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	grisco	2/27/97   	Initial version

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@
SBStringLength		macro	includeNull

	push	ax, di

	clr	al				; al <- byte to scan for
	mov	cx, -1				; Scan this many bytes
	repne	scasb				; di <- offset past null
	not	cx				; cx <- # of chars w/ null
ifb <includeNull>
	dec	cx				; cx <- # of chars w/o null
endif
	pop	ax, di
endm


COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		SBCompareStrings
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Compare two SBCS strings (regardless of SBCS or DBCS
		system).

PASS:		ds:si - ptr to string1
		es:di - ptr to string2
		cx - maximum # of chars to compare (0 for NULL terminated)

RETURN:		flags - should be used for testing equality only (this
		is not a "lexical" comparison

DESTROYED:	none

PSEUDO CODE/STRATEGY:

KNOWN BUGS/SIDE EFFECTS/IDEAS:

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	grisco	2/27/97   	Initial version

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@
SBCompareStrings		macro

	;
	; If not null-terminated then just repe
	;
		;pusha
		push	ax, cx, dx, bx, bp, si, di
		jcxz	cmpNull
		repe	cmpsb
		jmp	doneComp
cmpNull:
	;
	; loop, comparing bytes & checking for null
	;
		mov	ax, 0xffff		; initialize...
nullLoop:
		or	al, ah			; check for null
		jz	doneComp

		lodsb				; al = source byte
		mov	ah, {byte} es:[di]	; ah = dest byte
		inc	di

		cmp	al, ah
		loope	nullLoop
doneComp:
		pop	ax, cx, dx, bx, bp, si, di
		;popa
endm


;===============================================================================
;
;	Country codes
;
;===============================================================================

CountryType 		etype word, 1, 1
CT_UNITED_STATES 	enum CountryType
CT_CANADA		enum CountryType
CT_UNITED_KINGDOM	enum CountryType
CT_GERMANY		enum CountryType
CT_FRANCE		enum CountryType
CT_SPAIN		enum CountryType
CT_ITALY		enum CountryType
CT_DENMARK		enum CountryType
CT_NETHERLANDS		enum CountryType


;===============================================================================
;	Miscellaneous Info
;===============================================================================

if not DBCS_PCGEOS
;
;	Paramters to LocalCmpStringsDosToGeos
;
LocalCmpStringsDosToGeosFlags	record
    :6
    LCSDTG_NO_CONVERT_STRING_2:1
    LCSDTGF_NO_CONVERT_STRING_1:1
LocalCmpStringsDosToGeosFlags	end

;
; Minimum mappable character (for use with DosCodePage)
;
MIN_MAP_CHAR = 0x80

endif

CURRENCY_SYMBOL_LENGTH 	=	9	;(8 plus null)
			
; number formats
;
; NFF_LEADING_ZERO	TRUE -> .5 = 0.5
;
NumberFormatFlags record	
	:7,
	NFF_LEADING_ZERO:1
NumberFormatFlags end
	
;
; currency formats
; CFF_SYMBOL_BEFORE_NUMBER:	TRUE : $3.45
;				FALSE : 3.45$
; CFF_SPACE_AROUND_SYMBOL:	TRUE:  $ 3.45    or 3.45 $
;				FALSE: $3.45     or 3.45$
; CFF_USE_NEGATIVE_SIGN:	FALSE : (3.45)
;				TRUE : -3.45
; CFF_NEGATIVE_SIGN_BEFORE_NUMBER:	TRUE : -2.45
;					FALSE : 2.45-
; CFF_NEGATIVE_SIGN_BEFORE_SYMBOL:	TRUE :  -$2.45    or  2.45-$
;					FALSE:	$-2.45    or  2.45$-
; CFF_LEADING_ZERO:	TRUE :  0.45
;			FALSE : .45
;
; As with anything I seem to write on this project, change the order and you die
;
CurrencyFormatFlags 	record 
	:2
	CFF_LEADING_ZERO:1,
	CFF_SPACE_AROUND_SYMBOL:1,
	
	CFF_USE_NEGATIVE_SIGN:1,		;these four set together in
	CFF_SYMBOL_BEFORE_NUMBER:1, 		;  one preference mgr gadget
	CFF_NEGATIVE_SIGN_BEFORE_NUMBER:1,
	CFF_NEGATIVE_SIGN_BEFORE_SYMBOL:1,
CurrencyFormatFlags	end

;--------------------------------------------------------------------------
;
; measurement system
;
MeasurementType 	etype byte
MEASURE_US 		enum MeasurementType
MEASURE_METRIC 		enum MeasurementType
			
DistanceUnit		etype	byte
DU_POINTS	enum	DistanceUnit
	;U.S. points (72 per inch)
	;Display format is "###.### pt"
	;Entry format is "###.### pt"
DU_INCHES	enum	DistanceUnit
	;Display format is "##.### in"
	;Entry format is "##.### in" or "##.###"" (double quote means inches)
DU_CENTIMETERS	enum	DistanceUnit
	;Display format is "###.### cm"
	;Entry format is "###.### cm"
DU_MILLIMETERS	enum	DistanceUnit
	;Display format is "###.### mm"
	;Entry format is "###.### mm"
DU_PICAS	enum	DistanceUnit		;U.S. picas (12 points)
	;Display format is "###.### pi" (should fraction be in points ???)
	;Entry format is "###.### pi"
DU_EUR_POINTS	enum	DistanceUnit		;European points
	;Display format is "###.### ep"
	;Entry format is "###.### ep"
DU_CICEROS	enum	DistanceUnit
	;Display format is "###.### ci" (should fraction be in e points ???)
	;Entry format is "###.### ci"
DU_POINTS_OR_MILLIMETERS	enum	DistanceUnit
	;Depends on units for for app
DU_INCHES_OR_CENTIMETERS	enum	DistanceUnit
	;Depends on units for for app

LOCAL_DISTANCE_BUFFER_SIZE	=	32

LocalDistanceFlags	record
    LDF_FULL_NAMES:1
    LDF_PRINT_PLURAL_IF_NEEDED:1
    LDF_OMIT_UNITS_STRING:1		;New for GlobalPC - omit units string
    :9
    LDF_PASSING_DECIMAL_PLACES:1	;Internal, V2.1 and up: decimal places
    LDF_DECIMAL_PLACES:3		;Number of decimal places, if 
					;  LDF_PASSING_DECIMAL_PLACES passed.
LocalDistanceFlags	end

;--------------------------------------------------------------------------
;
; keyboard map types
;
KeyMapType 			etype word, 1, 1
KEYMAP_US_EXTD			enum KeyMapType
KEYMAP_US			enum KeyMapType
KEYMAP_UK_EXTD			enum KeyMapType
KEYMAP_UK			enum KeyMapType
KEYMAP_GERMANY_EXTD		enum KeyMapType
KEYMAP_GERMANY			enum KeyMapType
KEYMAP_SPAIN_EXTD		enum KeyMapType
KEYMAP_SPAIN			enum KeyMapType
KEYMAP_DENMARK_EXTD		enum KeyMapType
KEYMAP_DENMARK			enum KeyMapType
KEYMAP_BELGIUM_EXTD		enum KeyMapType
KEYMAP_BELGIUM			enum KeyMapType
KEYMAP_CANADA_EXTD		enum KeyMapType
KEYMAP_CANADA			enum KeyMapType
KEYMAP_ITALY_EXTD		enum KeyMapType
KEYMAP_ITALY			enum KeyMapType
KEYMAP_LATIN_AMERICA_EXTD	enum KeyMapType
KEYMAP_LATIN_AMERICA		enum KeyMapType
KEYMAP_NETHERLANDS		enum KeyMapType
KEYMAP_NETHERLANDS_EXTD		enum KeyMapType
KEYMAP_NORWAY_EXTD		enum KeyMapType
KEYMAP_NORWAY			enum KeyMapType
KEYMAP_PORTUGAL_EXTD		enum KeyMapType
KEYMAP_PORTUGAL			enum KeyMapType
KEYMAP_SWEDEN_EXTD		enum KeyMapType
KEYMAP_SWEDEN			enum KeyMapType
KEYMAP_SWISS_FRENCH_EXTD	enum KeyMapType
KEYMAP_SWISS_FRENCH		enum KeyMapType
KEYMAP_SWISS_GERMAN_EXTD	enum KeyMapType
KEYMAP_SWISS_GERMAN		enum KeyMapType
KEYMAP_FRANCE_EXTD		enum KeyMapType
KEYMAP_FRANCE			enum KeyMapType
KEYMAP_EUROPE			enum KeyMapType
KEYMAP_BRAZILIAN_EXTD		enum KeyMapType
KEYMAP_BRAZILIAN		enum KeyMapType

KeyboardType 		etype byte, 1, 1
KT_NOT_EXTD		enum KeyboardType	;84-key PC/AT
KT_EXTD			enum KeyboardType	;102-key PC/AT, PS/2
KT_BOTH			enum KeyboardType	;does both (U.S. only)

;--------------------------------------------------------------------------
;			Miscellaneous constants
;--------------------------------------------------------------------------

;-----------------------------------------------------------------------------
;	DOS code pages
;-----------------------------------------------------------------------------
DosCodePage	etype word
CODE_PAGE_CURRENT		enum DosCodePage, 0
CODE_PAGE_US			enum DosCodePage, 437
CODE_PAGE_LATIN_1		enum DosCodePage, 819
CODE_PAGE_MULTILINGUAL		enum DosCodePage, 850
CODE_PAGE_MULTILINGUAL_EURO	enum DosCodePage, 858
CODE_PAGE_PORTUGUESE		enum DosCodePage, 860
CODE_PAGE_CANADIAN_FRENCH	enum DosCodePage, 863
CODE_PAGE_NORDIC		enum DosCodePage, 865
CODE_PAGE_JIS_X_0208_SJIS	enum DosCodePage, 932
					; Japanese Industrial Standard X 0208
					;  -1990 base, Shift-JIS encoding, MS
					;  extensions
CODE_PAGE_GB_2312_EUC		enum DosCodePage, 936
					; Guojia Biaojun 2312-1980 base,
					;  Extended Unix Code encoding
CODE_PAGE_KS_C_5601_UHC		enum DosCodePage, 949
					; Korean Standard C 5601-1992 base,
					;  Unified Hangul Code encoding, MS
					;  extensions
CODE_PAGE_BIG_FIVE_BIG_FIVE	enum DosCodePage, 950
					; Big Five base, Big Five encoding, MS
					;  extensions
CODE_PAGE_JOHAB_JOHAB		enum DosCodePage, 1361
					; Johab base, Johab encoding
CODE_PAGE_RUSSIAN		enum DosCodePage, 1251
CODE_PAGE_RUSSIAN_866		enum DosCodePage, 866
CODE_PAGE_RUSSIAN_KOI8		enum DosCodePage, 65529

; NOTE: the code page values below do not represent real DOS code pages,
; but instead represent standards related algorithmically to SJIS.
;
CODE_PAGE_JIS_X_0208_EUC_DB	enum DosCodePage, 65530
CODE_PAGE_JIS_X_0208_EUC	enum DosCodePage, 65531
					; Japanese Industrial Standard X 0208
					;  -1990 base, Extended Unix Code
					;  encoding
CODE_PAGE_JIS_X_0208_DB		enum DosCodePage, 65534
CODE_PAGE_JIS_X_0208		enum DosCodePage, 65535
					; Japanese Industrial Standard X 0208
					;  -1990 base, no encoding

; Some commonly used names:
CODE_PAGE_SJIS			equ	CODE_PAGE_JIS_X_0208_SJIS
CODE_PAGE_EUC_DB		equ	CODE_PAGE_JIS_X_0208_EUC_DB
CODE_PAGE_EUC			equ	CODE_PAGE_JIS_X_0208_EUC
CODE_PAGE_JIS_DB		equ	CODE_PAGE_JIS_X_0208_DB
CODE_PAGE_JIS			equ	CODE_PAGE_JIS_X_0208


if DBCS_PCGEOS
DosToGeosStringStatus		etype	byte, 1, 1

DTGSS_SUBSTITUTIONS		enum DosToGeosStringStatus
; One or more substitions were required for characters not supported
; in the target character set.

DTGSS_CODE_PAGE_NOT_SUPPORTED	enum DosToGeosStringStatus
; The DosCodePage specified is not supported by the current FS.

DTGSS_CHARACTER_INCOMPLETE	enum DosToGeosStringStatus
; The character value passed is not complete.  This can happen with mixed-size
; character sets such as SJIS and JIS.  Get another byte and try again.
; Be sure to include the appropriate number of bytes the second time.

DTGSS_INVALID_CHARACTER		enum DosToGeosStringStatus
; The character value passed is not a valid character in the DosCodePage
; that was specified.  This can happen in character sets such as SJIS, where
; not all 65,536 values are legal characters.

endif


;===============================================================================
;	Date / Time formatting info
;===============================================================================
;
; Formatting constants to pass to DateFormat() and TimeFormat().
; If you use these constants, then you will be language independent.
; This is a very important thing.
;
; It is possible to format dates and times directly, but these specially
; formatted dates/times may not be handled by the parser and will not
; be language independent.
;
; The text on the right (after the ';') are just examples. It is an
; sample of what might be produced in the US version of the software.
; THE ACTUAL FORMAT SHOULD NOT BE ASSUMED! The localized version may be
; drastically different.
;
;NOTES:
; This list of formats cannot be changed without changing the corresponding
; table in the localization driver resource where the format strings are
; actually stored. (The resource is called 'FormatStrings').
;
; There is code in the localization driver which assumes that the first
; format is the 'Long' date format. If you change which format comes first
; you will need to change that code. See the code in DateTimeFormat() for
; more information.
;
DateTimeFormat	etype	word

DTF_LONG			enum DateTimeFormat  ; Sunday, March 5th, 1990
DTF_LONG_CONDENSED		enum DateTimeFormat  ; Sun, Mar 5, 1990
DTF_LONG_NO_WEEKDAY		enum DateTimeFormat  ; March 5th, 1990
DTF_LONG_NO_WEEKDAY_CONDENSED	enum DateTimeFormat  ; Mar 5, 1990
DTF_SHORT			enum DateTimeFormat  ; 3/5/90
DTF_ZERO_PADDED_SHORT		enum DateTimeFormat  ; 03/05/90
DTF_MD_LONG			enum DateTimeFormat  ; Sunday, March 5th
DTF_MD_LONG_NO_WEEKDAY		enum DateTimeFormat  ; March 5th
DTF_MD_SHORT			enum DateTimeFormat  ; 3/5
DTF_MY_LONG			enum DateTimeFormat  ; March 1990
DTF_MY_SHORT			enum DateTimeFormat  ; 3/90
DTF_YEAR			enum DateTimeFormat  ; 1990
DTF_MONTH			enum DateTimeFormat  ; March
DTF_DAY				enum DateTimeFormat  ; 5th
DTF_WEEKDAY			enum DateTimeFormat  ; Wednesday
	;
DTF_END_DATE_FORMATS	=	DateTimeFormat

DTF_START_TIME_FORMATS	=	DateTimeFormat

DTF_HMS				enum DateTimeFormat  ; 1:05:31 PM
DTF_HM				enum DateTimeFormat  ; 1:05 PM
DTF_H				enum DateTimeFormat  ; 1 PM
DTF_MS				enum DateTimeFormat  ; 5:31
DTF_HMS_24HOUR			enum DateTimeFormat  ; 13:05:31
DTF_HM_24HOUR			enum DateTimeFormat  ; 13:05

DTF_END_TIME_FORMATS	= DateTimeFormat

;
; This is the delimiter for tokens, see below.
;
TOKEN_DELIMITER		=	'|'

;
; The low level formatting code uses a format string. Do not use the low
; level formatting code unless it is absolutely necessary. Using the low
; level code will make your application language dependent and that will
; cause you headaches later when you want to have your application run in
; a different country.
;
; DateFormatStrings:
;	The date format strings contain any characters that are supposed
; to be part of the formatted string, as well as place holders for the
; different fields of the date.
;
; An example might serve well here.
;	"|LW|, |LM| |LD|, |LY|"
; Would produce:
;	Wednesday, February 8th, 1990
;
; The '|' character can be placed into the text by using another place holding
; token.
;
; Here is the list of tokens. Do not add or delete tokens without making
; changes to the tables in dateTimeVariable.asm. There is a table of
; routines which convert from a token to a string, and a table of routines
; which attempt to parse a string by comparing it to a given token.
;
TOKEN_TOKEN_DELIMITER	= 'DD'
TOKEN_TOKEN_CHAR_1	= 'D'
TOKEN_TOKEN_CHAR_2	= 'D'

if DBCS_PCGEOS
				; Weekday tokens(Japan).
TOKEN_LONG_WEEKDAY_JP	= 'LB'
TOKEN_SHORT_WEEKDAY_JP	= 'SB'
				; Emperors Year(Gengo) tokens(Japan).
TOKEN_LONG_EMPEROR_YEAR_JP	= 'LG'
TOKEN_SHORT_EMPEROR_YEAR_JP	= 'SG'
endif

				; Weekday tokens.
TOKEN_LONG_WEEKDAY	= 'LW'
TOKEN_SHORT_WEEKDAY	= 'SW'
				; Month tokens.
TOKEN_LONG_MONTH	= 'LM'
TOKEN_SHORT_MONTH	= 'SM'
TOKEN_NUMERIC_MONTH	= 'NM'
TOKEN_ZERO_PADDED_MONTH	= 'ZM'
TOKEN_SPACE_PADDED_MONTH= 'PM'
				; Date tokens.
TOKEN_LONG_DATE		= 'LD'
TOKEN_SHORT_DATE	= 'SD'
TOKEN_ZERO_PADDED_DATE	= 'ZD'
TOKEN_SPACE_PADDED_DATE	= 'PD'
				; Year tokens.
TOKEN_LONG_YEAR		= 'LY'
TOKEN_SHORT_YEAR	= 'SY'
				; 12-Hour tokens.
TOKEN_12HOUR		  = 'HH'
TOKEN_ZERO_PADDED_12HOUR  = 'ZH'
TOKEN_SPACE_PADDED_12HOUR = 'PH'
				; 24-Hour tokens.
TOKEN_24HOUR		  = 'hh'
TOKEN_ZERO_PADDED_24HOUR  = 'Zh'
TOKEN_SPACE_PADDED_24HOUR = 'Ph'
				; Minute tokens.
TOKEN_MINUTE		  = 'mm'
TOKEN_ZERO_PADDED_MINUTE  = 'Zm'
TOKEN_SPACE_PADDED_MINUTE = 'Pm'
				; Second tokens.
TOKEN_SECOND		  = 'ss'
TOKEN_ZERO_PADDED_SECOND  = 'Zs'
TOKEN_SPACE_PADDED_SECOND = 'Ps'
				; AM/PM tokens.
TOKEN_AM_PM		= 'ap'
TOKEN_AM_PM_CAP		= 'Ap'
TOKEN_AM_PM_ALL_CAPS	= 'AP'

;
; There are certain maximum sizes that you can safely assume for the
; formatted results. When you pass a formatting string to DateFieldFormat()
; you should use these constants to figure out the size of the buffer you
; may need to hold the result.
;
MAX_MONTH_LENGTH	=	32	; Months won't be larger than this.
MAX_DAY_LENGTH		=	12	; Days won't be larger than this.
MAX_YEAR_LENGTH		=	12	; Years won't be larger than this.
MAX_WEEKDAY_LENGTH	=	32	; Weekdays won't be larger than this.
MAX_SEPARATOR_LENGTH	=	8	; Separating strings shouldn't be larger
TOKEN_LENGTH		=	4	; Token length
;
; Minimum size for buffer for formatted date/time strings
;
if DBCS_PCGEOS
DATE_TIME_BUFFER_SIZE	=((MAX_MONTH_LENGTH \
			+ MAX_DAY_LENGTH \
			+ MAX_YEAR_LENGTH \
			+ MAX_WEEKDAY_LENGTH \
			+ MAX_SEPARATOR_LENGTH*5 \
			+ 1 + 1) / 2 * 2)*(size wchar)

DATE_TIME_FORMAT_SIZE	=((TOKEN_LENGTH \
			+ TOKEN_LENGTH \
			+ TOKEN_LENGTH \
			+ TOKEN_LENGTH \
			+ (MAX_SEPARATOR_LENGTH*TOKEN_LENGTH*5) \
			+ 1 + 1) / 2 * 2)*(size wchar)
else
DATE_TIME_BUFFER_SIZE	=(MAX_MONTH_LENGTH \
			+ MAX_DAY_LENGTH \
			+ MAX_YEAR_LENGTH \
			+ MAX_WEEKDAY_LENGTH \
			+ MAX_SEPARATOR_LENGTH*5 \
			+ 1 + 1) / 2 * 2

DATE_TIME_FORMAT_SIZE	=(TOKEN_LENGTH \
			+ TOKEN_LENGTH \
			+ TOKEN_LENGTH \
			+ TOKEN_LENGTH \
			+ (MAX_SEPARATOR_LENGTH*TOKEN_LENGTH*5) \
			+ 1 + 1) / 2 * 2
endif
					;(separators could all be '|'s.)

if DBCS_PCGEOS

;
; Constants for Gengo date format (emperor year)
;
GENGO_LONG_NAME_LENGTH equ 8		; choosen according to MAX_YEAR_LENGTH
GENGO_SHORT_NAME_LENGTH equ 4

;
; return structure for LocalGetGengoInfo
;
GengoNameData	struct
	GND_year	word
	GND_month	byte
	GND_date	byte
	GND_longName	wchar GENGO_LONG_NAME_LENGTH+1 dup (?)
	GND_shortName	wchar GENGO_SHORT_NAME_LENGTH+1 dup (?)
GengoNameData	ends

MAX_KINSOKU_CHARS			equ	60

KinsokuCharType	etype	byte
KCT_START_CHARS		enum KinsokuCharType
KCT_END_CHARS		enum KinsokuCharType

KinsokuState	record
	KS_DISABLED:1			; 0 - enabled, 1 - disabled
	:5
	KS_CHARS KinsokuCharType:2	; Start/End
KinsokuState	end
endif

;------------------------------------------------------------------------------
;	character types for word selection
;------------------------------------------------------------------------------

if DBCS_PCGEOS
WordPartType		etype	byte

WPT_SPACE			enum	WordPartType
;
; space characters
;
WPT_ALPHA_NUMERIC		enum	WordPartType
;
; alpha numeric
;
WPT_PUNCTUATION			enum	WordPartType
;
; punctuation
;
WPT_OTHER			enum	WordPartType
;
; other characters
;
WPT_HIRAGANA			enum	WordPartType
;
; hiragana
;
WPT_KATAKANA			enum	WordPartType
;
; katakana
;
WPT_KANJI			enum	WordPartType
;
; kanji
;
WPT_HALFWIDTH_KATAKANA		enum	WordPartType
;
; halfwidth katakana
;
WPT_FULLWIDTH_ALPHA_NUMERIC	enum	WordPartType
;
; fullwidth alpha numeric variants
;

endif

EndKernel
