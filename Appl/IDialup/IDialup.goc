/***********************************************************************
 *
 *	Copyright (c) GlobalPC 1998 -- All Rights Reserved
 *
 * PROJECT:	Internet Dial-up & Configure  Applications
 * MODULE:
 * FILE:
 *
 * AUTHOR:	mzhu: Nov 23, 1998
 *
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      mzhu    11/23/98        Initial version
 *
 * DESCRIPTION:
 *
 *	$Id: $
 *
 ***********************************************************************/
#include <product.h>
@include <stdapp.goh>
@include <system.h>
@include <gcnlist.goh>
#include <geoworks.h>
@include <geoMisc.h>
@include <socket.goh>
#include <sockmisc.h>
@include "IDialup.goh"
@include "IDialUI.goh"
#include "IDialppp.h"
#include <Ansi/string.h>
#include <Ansi/stdlib.h>
#include <Ansi/stdio.h>
#include <Internal/ppp.h>
#include <Internal/socketDr.h>
#include <sockmisc.h>
@include <accpnt.goh>
#include <initfile.h>
#include <sem.h>
#include <Internal/geodeStr.h>

#define HIDDEN_INTERNET_ACCPNT 1
#define NAME_LEN 30

@classdecl	IDialupProcessClass, neverSaved;
@classdecl	IDialupIPTextClass;
@extern method IDialupProcessClass, MSG_IDP_TIMER_HANDLE;

TimerHandle timerHandle ;
word timerId ;
dword startTime;
PPPStatus pppStatus;

//unsigned int tHours, tMinutes, tSeconds;
word idleTime, idleTimeout, delayTimeout;

MemHandle connectionHandle;
ChunkHandle connectionChunk;
ChunkHandle iAppChunk;

word  connectionNum = 0;
word  currentAccpnt=0;
word  defaultAccpnt=0;
int   G_lastActiveNetType = 0;
int   G_activeAccpnt = 0;

// word tempAccpnt = 0;
// #define TEMPORARY_KEY "temp"

static SemaphoreHandle wait;
static Boolean creatingConnection = FALSE;

Boolean iAppRunning = FALSE;

// This is used to indicate that the connect message was sent to us
// and that we are currently attempting to connect.  Because the
// notification from the PPP driver can take some time, we don't want
// a field change to happen between the time the user presses CONNECT
// and the time the ppp driver responds.
Boolean connectSent = FALSE;
Boolean disconnectRequested = FALSE;

Boolean bStealthLIAFlag = FALSE;

/*#ifndef PRODUCT_NDO2000 */
Boolean editDialOptionsChanged;
/*#endif */

Boolean G_registered = FALSE ;

extern Boolean sendFieldChangeConfirm;

extern Boolean _pascal IDialupConnect (void);
extern Boolean _pascal IDialupDisconnect (void);
extern word GetBaudRate(void);
extern void RegisterToPPP(void);
extern void UnregisterToPPP(void);
extern Boolean IAppRunning(void);
extern void SendPing(void);
void IDialupEnsureDefaultConnection(void);

/*
 ***************************************************************************
 *		Code for IDialupProcessClass
 ***************************************************************************
 */
/***********************************************************************
 *	MSG_GEN_PROCESS_OPEN_APPLICATION for IDialupProcessClass
 ***********************************************************************
 * SYNOPSIS:     Initialize the application.
 *
 * PARAMETERS:  (AppAttachFlags attachFlags = cx,
 *		 MemHandle launchBlock = dx,
 *		 MemHandle extraState = bp)
 *
 * SIDE EFFECTS:
 *
 * STRATEGY:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	mzhu	11/23/98	Initial Revision
 *
 ***********************************************************************/
@method IDialupProcessClass, MSG_GEN_PROCESS_OPEN_APPLICATION
{
    AppLaunchBlock *ab;
    MemHandle mh;
    word size, i;
    TCHAR *ptr, *names;
    char *p;
    Boolean bShowDetails = FALSE; /* this must match the object default */

    pppStatus = PPP_STATUS_CLOSED;

    GCNListAdd(@IDialupApp, MANUFACTURER_ID_GEOWORKS, GCNSLT_PPP_STATUS_NOTIFICATIONS);
    GCNListAdd(ConstructOptr(GeodeGetProcessHandle(), NullChunk),
	       MANUFACTURER_ID_GEOWORKS,
	       GCNSLT_APPLICATION);
    GCNListAdd(@IDialupApp, MANUFACTURER_ID_GEOWORKS,
	       GCNSLT_INSTANT_SUSPEND_RESUME_NOTIFICATIONS);
    GCNListAdd(@IDialupApp, MANUFACTURER_ID_GEOWORKS, GCNSLT_FIELD_CHANGE_NOTIFICATIONS);

  /* Register for a connection */
  if (!G_registered)  {
      LoadPPPDriver();

      RegisterToPPP();
	  G_registered = TRUE ;
  }

    // read the currently active Accpnt from the INI into currentAccpnt
    // and G_activeAccpnt also init internal Accpnt List.
    @call self::MSG_IDP_READ_ACCPNT_AND_ACCPNT_LIST();

    // Hack to delete the temporary access point created by signup, just in case
    // signup crashes and fails to clean up after itself. (dhunter 1/13/2000)
    //
    // Disabled for FreeGEOS edition of PC/GEOS (meyerk 01/2025)
    //if (tempAccpnt)
    //{
    //    AccessPointDestroyEntryDirect(tempAccpnt);
    //    tempAccpnt = 0;
    //    AccessPointCommit();
    //
    //    // Reload the accpnt list.
    //    @call self::MSG_IDP_READ_ACCPNT_AND_ACCPNT_LIST();
    //}

    // Ensure that there is only one default access point.  We do this because
    // Welcome can add a new default without un-defaulting the old one.  The
    // last one discovered (the one set by MSG_IDP_READ_ACCPNT_AND_ACCPNT_LIST) is the
    // desired default.
    IDialupEnsureDefaultConnection();

    // Make sure to store the netType that's active when we start up
    // so we can check out if a reboot is needed when switching
    // Accpnts. This is only ever set once, right here, because:
    // if we switch to an accpnt that's of a different netType, we'll
    // reboot and end up here again. And if we switch to another accpnt of the same
    // netType - no netType change occurs...
    if (AccessPointGetIntegerPropertyDirect(currentAccpnt, "netType", (int*) &G_lastActiveNetType)) {
      G_lastActiveNetType = NET_TYPE_PPP;
    }

    // update UI
    @call self::MSG_IDP_UPDATE_UI_FOR_SELECTED_ACCPNT();

    @callsuper();

    if(launchBlock)
      {
	ab = MemLock(launchBlock);
	wait = ab->ALB_extraData;
	if(wait)
	  {
	    // we should connect from here
	    // if there is only one Connection setting, use it to connect
	    // otherwise, we need to ask user to choose one (or use the default one
	    // if there is one marked default
	    @call self::MSG_IDP_SELECT_ACCPNT();
	  }
	MemUnlock(launchBlock);
      }

    if(!wait)
      @call IDialupPrimary::MSG_GEN_DISPLAY_SET_NOT_MINIMIZED();

    // read the Timeout
    if(InitFileReadInteger(IDIAL_CATEGORY, IDLE_TIMEOUT_KEY, &idleTimeout))
       {
	 idleTimeout = DEFAULT_IDLE_TIME;
       }

    if(InitFileReadInteger(IDIAL_CATEGORY, DELAY_TIMEOUT_KEY, &delayTimeout))
       {
	 delayTimeout = DEFAULT_DELAY_TIME;
       }

    if(delayTimeout > idleTimeout)
      {
	delayTimeout = idleTimeout;
      }

    // read the list of applications that will use socket/ppp
    if(!InitFileReadStringBlock(IDIAL_CATEGORY, INET_APPLS_KEY, &mh, 0, &size))
      {
	if(size)
	  {
	    if(!connectionHandle)
	      {
		connectionHandle = MemAllocLMem(LMEM_TYPE_GENERAL, sizeof(LMemBlockHeader));
	      }

	    MemLock(connectionHandle);
	    iAppChunk = ChunkArrayCreate(connectionHandle, 0, sizeof(ChunkArrayHeader), 0);

	    names = MemLock(mh);
	    ptr = 0;
	    for(i=0; i<size; i++, names++)
	      {
		if(!isalnum(*names) && *names != '.')
		  {
		    *names = 0;
		    if(ptr)
		      {
			p = ChunkArrayAppendHandles(connectionHandle, iAppChunk, names-ptr+1);
@ifdef DO_DBCS
			while(*ptr) *p++ = *ptr++; *p = C_NULL;
@else
			strcpy(p, ptr);
@endif
			ptr = 0;
		      }
		  }
		else
		  {
		    if(!ptr) ptr = names;
		  }
	      }

	    // Make sure we get the last one in there as well. --JimG
	    if ( names > ptr )
	      {
		p = ChunkArrayAppendHandles(connectionHandle, iAppChunk,
					    names-ptr+1);
@ifdef DO_DBCS
		while(*ptr) *p++ = *ptr++; *p = C_NULL;
@else
		strcpy( p, ptr );
@endif
	      }

	    MemUnlock(connectionHandle);
	  }
	MemFree(mh);
      }

    // See if any of our iApp applications are running.
    //  (NB: Must have the chunk array set up first.. duh.)
    iAppRunning = IAppRunning();

    /* Retrieve and apply the setting for Show Details. */
    InitFileReadBoolean(IDIAL_CATEGORY, SHOW_DETAILS_KEY, &bShowDetails);
    if (bShowDetails)		/* the default is to hide details */
    {
	/* Check the boolean. */
	@send IDShowDetailsGroup::MSG_GEN_BOOLEAN_GROUP_SET_GROUP_STATE(1, 0);
	/* Elicit a MSG_IDA_SHOW_DETAILS. */
	@send IDShowDetailsGroup::MSG_GEN_BOOLEAN_GROUP_SET_GROUP_MODIFIED_STATE(1, 0);
	@send IDShowDetailsGroup::MSG_GEN_APPLY();
    }

    return;
} /* End of MSG_GEN_PROCESS_OPEN_APPLICATION */


/***********************************************************************
 *	MSG_IDP_SELECT_ACCPNT for IDialupProcessClass
 ***********************************************************************
 * SYNOPSIS:
 *
 * PARAMETERS:
 *
 * SIDE EFFECTS:
 *
 * STRATEGY:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	mzhu	11/23/98	Initial Revision
 *
 ***********************************************************************/
@method IDialupProcessClass, MSG_IDP_SELECT_ACCPNT
{
    /*
        This method is apparently only called by MSG_GEN_PROCESS_OPEN_APPLICATION
        when the dialer is started by other applications. It's original purpose
        was to either dial an access point immediately or allow the user to
        select one. However, the latter function was outcommented in later
        builds (see last ELSE branch), instead the first access point in the list
        was used. Also, while this method calls MSG_IDA_VIEW_INFO (the active
        connection view) it doesn't start a connection itself.
        Calling AccessPointSetActivePoint shouldn't be done here, as currentAccpnt
        is read via MSG_IDP_READ_ACCPNT_AND_ACCPNT_LIST in MSG_GEN_PROCESS_OPEN_APPLICATION
        and doesn't have a chance to change in between.
        In favor of not breaking anything, we leave everything as is for now, but
        improvement is needed.
        (meyerk 01/2025).
    */

//  TCHAR *str;

  if(connectionNum == 1)
    {
      // just one Connection, so connect it
      AccessPointSetActivePoint(currentAccpnt, APT_INTERNET);
      AccessPointCommit();
      ThreadVSem(wait);
      @call IDialupApp::MSG_IDA_VIEW_INFO();
    }
  else if(defaultAccpnt)
    {
      // there is one default Connection, use it
      currentAccpnt = defaultAccpnt;
      AccessPointSetActivePoint(currentAccpnt, APT_INTERNET);
      AccessPointCommit();
      ThreadVSem(wait);
      @call IDialupApp::MSG_IDA_VIEW_INFO();
    }
  else if(connectionNum == 0)
    {
      ThreadVSem(wait);

      /*
       * This is now all done by the PPP_STATUS_CLOSED handler in
       * META_NOTIFY
       *
      MemLock(OptrToHandle(@noConnectionStr));
      str = LMemDeref(@noConnectionStr);

      @call IDialupApp::MSG_GEN_APPLICATION_DO_STANDARD_DIALOG(
			0,
			0,
    	    	    	0,
    	    	    	0,
			0,
			0,
	        	str,
			(CDT_NOTIFICATION << CDBF_DIALOG_TYPE_OFFSET) |
			(GIT_NOTIFICATION << CDBF_INTERACTION_TYPE_OFFSET));

      MemUnlock(OptrToHandle(@noConnectionStr));

      @call IDialupPrimary::MSG_GEN_DISPLAY_SET_NOT_MINIMIZED();
      @call IDialupApp::MSG_GEN_APPLICATION_BRING_WINDOW_TO_TOP(@IDialupPrimary);
      */
    }
  else
    {
      word *id, datalen;

      MemLock(connectionHandle);

      id = ChunkArrayElementToPtrHandles(connectionHandle, connectionChunk, 0, &datalen);
      AccessPointSetActivePoint(*id, APT_INTERNET);
      currentAccpnt = *id;
      AccessPointCommit();
      MemUnlock(connectionHandle);

      ThreadVSem(wait);

      // otherwise, we need to ask the user to choose one
      /*
      @call IDConnectionMenu::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_UI_QUEUE);
      @call IDConnectButton::MSG_GEN_SET_NOT_USABLE(VUM_DELAYED_VIA_UI_QUEUE);
      @call IDContinueButton::MSG_GEN_SET_USABLE(VUM_NOW);
      @call IDialupPrimary::MSG_GEN_DISPLAY_SET_NOT_MINIMIZED();
      @call IDialupApp::MSG_GEN_APPLICATION_BRING_WINDOW_TO_TOP(@IDialupPrimary);
      */

      @call IDialupApp::MSG_IDA_VIEW_INFO();
    }
}

/***********************************************************************
 *	MSG_IDP_SELECT_CONTINUE for IDialupProcessClass
 ***********************************************************************
 * SYNOPSIS:
 *
 * PARAMETERS:
 *
 * SIDE EFFECTS:
 *
 * STRATEGY:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	mzhu	11/23/98	Initial Revision
 *
 ***********************************************************************/
/*
@method IDialupProcessClass, MSG_IDP_SELECT_CONTINUE
{
  AccessPointSetActivePoint(currentAccpnt, APT_INTERNET);
  AccessPointCommit();

  @call IDialupPrimary::MSG_GEN_DISPLAY_SET_MINIMIZED();

  @send IDConnectionMenu::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_UI_QUEUE);
  @send IDContinueButton::MSG_GEN_SET_NOT_USABLE(VUM_DELAYED_VIA_UI_QUEUE);
  @send IDConnectButton::MSG_GEN_SET_USABLE(VUM_NOW);

  ThreadVSem(wait);
}
*/


/***********************************************************************
 *		MSG_GEN_PROCESS_CLOSE_APPLICATION for IDialupProcessClass
 ***********************************************************************
 * SYNOPSIS:	    Tell the ppp we quit.
 * PARAMETERS:
 * SIDE EFFECTS:
 *
 * STRATEGY:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	MZ	12/4/98   	Initial Revision
 *
 ***********************************************************************/
@method IDialupProcessClass, MSG_GEN_PROCESS_CLOSE_APPLICATION
{
  Boolean bShowDetails;

    /* disconnect */
    if (pppStatus != PPP_STATUS_CLOSED) {
	@call process::MSG_IDP_DISCONNECT();
    }

  if(connectionHandle) MemFree(connectionHandle);
  connectionHandle = 0;
  connectionChunk = (ChunkHandle) 0;

  GCNListRemove(@IDialupApp, MANUFACTURER_ID_GEOWORKS, GCNSLT_PPP_STATUS_NOTIFICATIONS);
  GCNListRemove(ConstructOptr(GeodeGetProcessHandle(), NullChunk),
	       MANUFACTURER_ID_GEOWORKS,
	       GCNSLT_APPLICATION);
  GCNListRemove(@IDialupApp, MANUFACTURER_ID_GEOWORKS,
	       GCNSLT_INSTANT_SUSPEND_RESUME_NOTIFICATIONS);
  GCNListRemove(@IDialupApp, MANUFACTURER_ID_GEOWORKS, GCNSLT_FIELD_CHANGE_NOTIFICATIONS);

  if (G_registered)  {
	  UnregisterToPPP();

	  UnloadPPPDriver();
	  G_registered = FALSE ;
  }
  /* Save the setting for Show Details. */
  bShowDetails = @call IDShowDetailsGroup::MSG_GEN_BOOLEAN_GROUP_GET_SELECTED_BOOLEANS()
      & 0x0001;
  InitFileWriteBoolean(IDIAL_CATEGORY, SHOW_DETAILS_KEY, bShowDetails);
  InitFileCommit();

  @callsuper();

  return 0;
}


/***********************************************************************
 *		MSG_GEN_PROCESS_CREATE_NEW_STATE_FILE for IDialupProcessClass
 ***********************************************************************
 * SYNOPSIS:	    No state file.
 * PARAMETERS:
 * SIDE EFFECTS:
 *
 * STRATEGY:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	brianc	4/7/99   	Initial Revision
 *
 ***********************************************************************/
@method IDialupProcessClass, MSG_GEN_PROCESS_CREATE_NEW_STATE_FILE
{
  return 0;
}

/***********************************************************************
 *	MSG_IDP_NEW_NUMBERS for IDialupProcessClass
 ***********************************************************************
 * SYNOPSIS:     Get new local numbers.
 *
 * PARAMETERS:
 *
 * SIDE EFFECTS:
 *
 * STRATEGY:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	brianc	12/5/00         Initial Revision
 *
 ***********************************************************************/
/*@method IDialupProcessClass, MSG_IDP_NEW_NUMBERS
{
    MemHandle launchBlk;
    IACPConnection iacpConnectionToken;
    word serverCount;
    GeodeToken welcomeToken = {'G', 'P', 'C', 's', 0};

    InitFileWriteBoolean("welcome", "changePop", TRUE);
    launchBlk = IACPCreateDefaultLaunchBlock(MSG_GEN_PROCESS_OPEN_APPLICATION);
    iacpConnectionToken = IACPConnect(&welcomeToken,
				      IACPCF_FIRST_ONLY |
				      IACPSM_USER_INTERACTIBLE,
				      launchBlk, NullOptr, &serverCount);
    if (iacpConnectionToken != IACP_NO_CONNECTION) {
	IACPShutdown(iacpConnectionToken, NullOptr);
    }
    @call process::MSG_IDP_DISCONNECT();
    @send, forceQueue IDialupApp::MSG_META_QUIT();
}

/***********************************************************************
 *	MSG_IDP_EDIT_CONNECTION for IDialupProcessClass
 ***********************************************************************
 * SYNOPSIS:     Edit the current Connectino setting.
 *
 * PARAMETERS:
 *
 * SIDE EFFECTS:
 *
 * STRATEGY:	  Get the current settings from the .ini and fill in
 *               the appropriate fields
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	mzhu	11/23/98	Initial Revision
 *
 ***********************************************************************/
@method IDialupProcessClass, MSG_IDP_EDIT_CONNECTION
{
  word datalen;
  TCHAR name[MAX_TEXT_LEN], *str;
  word dialOptionsProp;
  word dialOptions = DEFAULT_DIAL_OPTIONS;
  word type ;

  datalen = MAX_TEXT_LEN*sizeof(TCHAR);
  memset(name, 0, sizeof(TCHAR)*MAX_TEXT_LEN);
  if(!AccessPointGetStringPropertyBufferDirect(currentAccpnt,
					 (char*)APSP_PHONE, name, (int*) &datalen))
	 {
      @call IDEditPhoneNumber::MSG_VIS_TEXT_REPLACE_ALL_PTR(name, datalen);
    }

  if(!AccessPointGetIntegerPropertyDirect(currentAccpnt,
					  (char*)APSP_LOCAL_DIALING_OPTIONS,
					  (int*) &dialOptionsProp))
  {
		if (dialOptionsProp & APLDO_OMIT_ONE_FOR_LONG_DISTANCE)
	  dialOptions &= ~IDEDO_ONE_FOR_LD;
		if (dialOptionsProp & APLDO_ALWAYS_ADD_AREA_CODE)
	  dialOptions |= IDEDO_AREA_CODE;
  }
  @call IDEditDialingOptionsGroup::
		MSG_GEN_BOOLEAN_GROUP_SET_GROUP_STATE(dialOptions, 0);

  datalen = MAX_TEXT_LEN*sizeof(TCHAR);
  memset(name, 0, sizeof(TCHAR)*MAX_TEXT_LEN);
  if(!AccessPointGetStringPropertyBufferDirect(currentAccpnt,
					 (char*)APSP_USER, name, (int*) &datalen))
    {
      @call IDEditUserName::MSG_VIS_TEXT_REPLACE_ALL_PTR(name, datalen);
    }

  datalen = MAX_TEXT_LEN*sizeof(TCHAR);
  memset(name, 0, sizeof(TCHAR)*MAX_TEXT_LEN);
  if(!AccessPointGetStringPropertyBufferDirect(currentAccpnt,
					 (char*)APSP_SECRET, name, (int*) &datalen))
  {
      @call IDEditPassword::MSG_VIS_TEXT_REPLACE_ALL_PTR(name, datalen);
  }
  else
  {
      @call IDEditPassword::MSG_VIS_TEXT_DELETE_ALL();
  }

  datalen = MAX_TEXT_LEN*sizeof(TCHAR);
  memset(name, 0, sizeof(TCHAR)*MAX_TEXT_LEN);
  if(!AccessPointGetStringPropertyBufferDirect(currentAccpnt,
					 (char*)APSP_NAME, name, (int*) &datalen))
    {
      @call IDEditConnectionName::MSG_VIS_TEXT_REPLACE_ALL_PTR(name, datalen);
    }

/*#if _NDO2000 */
  datalen = MAX_TEXT_LEN*sizeof(TCHAR);
  memset(name, 0, sizeof(TCHAR)*MAX_TEXT_LEN);
  if(!AccessPointGetStringPropertyBufferDirect(currentAccpnt,
					 (char*)APSP_ADDRESS, name, (int*) &datalen))
    {
      @call IDEditIP::MSG_VIS_TEXT_REPLACE_ALL_PTR(name, datalen);
    } else {
      @call IDEditIP::MSG_VIS_TEXT_DELETE_ALL();
    }
  datalen = MAX_TEXT_LEN*sizeof(TCHAR);
  memset(name, 0, sizeof(TCHAR)*MAX_TEXT_LEN);
  if(!AccessPointGetStringPropertyBufferDirect(currentAccpnt,
					 (char*)APSP_GATEWAY, name, (int*) &datalen))
    {
      @call IDEditGateway::MSG_VIS_TEXT_REPLACE_ALL_PTR(name, datalen);
    } else {
      @call IDEditGateway::MSG_VIS_TEXT_DELETE_ALL();
    }
  datalen = MAX_TEXT_LEN*sizeof(TCHAR);
  memset(name, 0, sizeof(TCHAR)*MAX_TEXT_LEN);
  if(!AccessPointGetStringPropertyBufferDirect(currentAccpnt,
					 (char*)APSP_MASK, name, (int*) &datalen))
    {
      @call IDEditMask::MSG_VIS_TEXT_REPLACE_ALL_PTR(name, datalen);
    } else {
      @call IDEditMask::MSG_VIS_TEXT_DELETE_ALL();
    }
/*#endif */

  datalen = MAX_TEXT_LEN*sizeof(TCHAR);
  memset(name, 0, sizeof(TCHAR)*MAX_TEXT_LEN);
  if(!AccessPointGetStringPropertyBufferDirect(currentAccpnt,
					 (char*)APSP_DNS1, name, (int*) &datalen))
    {
      @call IDEditDNS1::MSG_VIS_TEXT_REPLACE_ALL_PTR(name, datalen);
    } else {
      @call IDEditDNS1::MSG_VIS_TEXT_DELETE_ALL();
    }
  datalen = MAX_TEXT_LEN*sizeof(TCHAR);
  memset(name, 0, sizeof(TCHAR)*MAX_TEXT_LEN);
  if(!AccessPointGetStringPropertyBufferDirect(currentAccpnt,
					 (char*)APSP_DNS2, name, (int*) &datalen))
    {
      @call IDEditDNS2::MSG_VIS_TEXT_REPLACE_ALL_PTR(name, datalen);
    } else {
      @call IDEditDNS2::MSG_VIS_TEXT_DELETE_ALL();
    }

  MemLock(OptrToHandle(@modifyConnectionStr));
  str = LMemDeref(@modifyConnectionStr);
  @call IDEditGroup::MSG_GEN_REPLACE_VIS_MONIKER_TEXT(str, VUM_DELAYED_VIA_UI_QUEUE);

  str = LMemDeref(@changeStr);
  @call IDEditOkButton::MSG_GEN_REPLACE_VIS_MONIKER_TEXT(str, VUM_DELAYED_VIA_UI_QUEUE);

  str = LMemDeref(@noChangeStr);
  @call IDEditCancelButton::MSG_GEN_REPLACE_VIS_MONIKER_TEXT(str, VUM_NOW);

  MemUnlock(OptrToHandle(@modifyConnectionStr));

  @call IDEditConnectionName::MSG_GEN_TEXT_SET_MODIFIED_STATE(FALSE);
  @call IDEditPhoneNumber::MSG_GEN_TEXT_SET_MODIFIED_STATE(FALSE);
/*#ifndef PRODUCT_NDO2000 */
  editDialOptionsChanged = FALSE;
/*#endif  */
  @call IDEditUserName::MSG_GEN_TEXT_SET_MODIFIED_STATE(FALSE);
/*@if defined(PRODUCT_NDO2000) */
  @call IDEditIP::MSG_GEN_TEXT_SET_MODIFIED_STATE(FALSE);
  @call IDEditGateway::MSG_GEN_TEXT_SET_MODIFIED_STATE(FALSE);
  @call IDEditMask::MSG_GEN_TEXT_SET_MODIFIED_STATE(FALSE);
/*@endif */
  @call IDEditDNS1::MSG_GEN_TEXT_SET_MODIFIED_STATE(FALSE);
  @call IDEditDNS2::MSG_GEN_TEXT_SET_MODIFIED_STATE(FALSE);

  creatingConnection = FALSE;

  // set to PPP if netType not set...
  if (AccessPointGetIntegerPropertyDirect(currentAccpnt, "netType", (int*) &type)) {
      type = NET_TYPE_PPP ;
  }
  @call IDEditConnectionType::MSG_GEN_ITEM_GROUP_SET_SINGLE_SELECTION(type, FALSE) ;
  @call oself::MSG_IDP_EDIT_TYPE_UPDATE() ;

  if (currentAccpnt == G_activeAccpnt)
  {
    @call IDEditConnectionType::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
  }

  // This message is force-queued to allow the process thread to flush out
  // all of the MSG_META_TEXT_EMPTY_STATUS_CHANGED messages that might have
  // been queued by all of the above MSG_VIS_TEXT_REPLACE/DELETE calls.
  // -Dave 1/14/2000
  @send, forceQueue self::MSG_IDP_EDIT_CONNECTION_FINISH();
}

/***********************************************************************
 *	MSG_IDP_EDIT_CONNECTION_FINISH for IDialupProcessClass
 ***********************************************************************
 * SYNOPSIS:     Finish setting up the edit dialog for Connection modify.
 *
 * PARAMETERS:
 *
 * SIDE EFFECTS:
 *
 * STRATEGY:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	dhunter 1/14/2000   Initial Revision
 *
 ***********************************************************************/
@method IDialupProcessClass, MSG_IDP_EDIT_CONNECTION_FINISH
{
  @call IDEditOkButton::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_UI_QUEUE);
  @send IDEditGroup::MSG_GEN_INTERACTION_INITIATE();
}

Boolean CheckValidIPAddress(MemHandle mh)
{
    word    pCount, nCount, wasPCount, i;
    TCHAR    *buffer, nBuffer[UHTA_NULL_TERM_BUFFER_SIZE];
    Boolean isBadIP, wasP;
    dword   URLNum;

    if ( mh )
    {
        buffer = MemLock( mh );

        /* Let empty IP be valid since fields can be empty */
        if ( *buffer == '\0' )
            isBadIP = FALSE;
        else
        {
            pCount = 0;
            nCount = 0;
            nBuffer[0] = 0;
            wasPCount = 0;
            isBadIP = FALSE;
            wasP = TRUE;
            for (i = 0; i < strlen(buffer); i++)
            {
                if ((buffer[i] >= '0') && (buffer[i] <= '9'))
                {
                    if (nCount > 2)
                    {
                        isBadIP = TRUE;
                	    break;
                    }
                    nBuffer[nCount] = buffer[i];
                    nCount++;
                    if (wasP) wasPCount++;
                    wasP = FALSE;
                }
                else if ((buffer[i] == '.') && (!wasP))
                {
                    pCount++;
                    if (pCount > 3)
                    {
                        isBadIP = TRUE;
                        break;
                    }
                    /* ok lets check the number... */
                    nBuffer[nCount] = 0;
                    UtilAsciiToHex32(nBuffer, (long*) &URLNum);
                    if (URLNum > 255)
                    {
                        isBadIP = TRUE;
                        break;
                    }
                    nCount = 0;
                    nBuffer[0] = 0;
                    wasP = TRUE;
                }
                else
                {
                    isBadIP = TRUE;
                    break;
                }
            } /* end of step thru buffer for loop */
            /* and check the last number... */
            nBuffer[nCount] = 0;
            UtilAsciiToHex32(nBuffer, (long*) &URLNum);
            if (URLNum > 255)
                isBadIP = TRUE;

            isBadIP = isBadIP || (wasPCount != 4);
        }

        MemUnlock( mh );
    }
    return !isBadIP;
}


/***********************************************************************
 *		GetLocalDialingOptions
 ***********************************************************************
 *
 * SYNOPSIS:	Get the current state of the dialing options booleans
 *		and return the equivalent AccessPointLocalDialingOptions.
 *
 * CALLED BY:	MSG_IDP_EDIT_OK
 *
 * RETURN:	AccessPointLocalDialingOptions
 *
 * SIDE EFFECTS:none
 *
 * STRATEGY:    Get the state of IDEditDialingOptionsGroup
 *		Convert the state to the return value type
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	dhunter	5/17/00   	Initial Revision
 *
 ***********************************************************************/
AccessPointLocalDialingOptions GetLocalDialingOptions (void)
{
    word dialOptions;
    word dialOptionsProp = 0;

    dialOptions = @call IDEditDialingOptionsGroup::
	MSG_GEN_BOOLEAN_GROUP_GET_SELECTED_BOOLEANS();
    if (!(dialOptions & IDEDO_ONE_FOR_LD))
	dialOptionsProp |= APLDO_OMIT_ONE_FOR_LONG_DISTANCE;
    if (dialOptions & IDEDO_AREA_CODE)
	dialOptionsProp |= APLDO_ALWAYS_ADD_AREA_CODE;
    return dialOptionsProp;
}	/* End of GetLocalDialingOptions.	*/

/***********************************************************************
 *	MSG_IDP_EDIT_OK for IDialupProcessClass
 ***********************************************************************
 * SYNOPSIS:     Edit the current Connection setting.
 *
 * PARAMETERS:
 *
 * SIDE EFFECTS:
 *
 * STRATEGY:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	mzhu	11/23/98	Initial Revision
 *
 ***********************************************************************/
@method IDialupProcessClass, MSG_IDP_EDIT_OK
{
    MemHandle mh;
    MemHandle hanDNS1, hanDNS2;
    word sel;
    optr item;
    TCHAR *str;
    Boolean dns1Valid, dns2Valid;
    word newAccpnt = 0;
    word type = @call IDEditConnectionType::MSG_GEN_ITEM_GROUP_GET_SELECTION() ;

    // Before we can commit the changes to or addition of this Connection, we
    // need to validate the IP addresses entered in the DNS fields.
    //
    hanDNS1 = @call IDEditDNS1::MSG_VIS_TEXT_GET_ALL_BLOCK(0);
    hanDNS2 = @call IDEditDNS2::MSG_VIS_TEXT_GET_ALL_BLOCK(0);

    dns1Valid = CheckValidIPAddress( hanDNS1 );
    dns2Valid = CheckValidIPAddress( hanDNS2 );

    if ( !dns1Valid || !dns2Valid )
    {
        MemLock( OptrToHandle( @invalidDNS1Str ) );
        str = LMemDeref( (dns1Valid) ? @invalidDNS2Str : @invalidDNS1Str );

        // Small hack: this will send a grab focus message to
        // the field that had the error.  It has to be done after
        // the dialog box goes down or else the focus is changed
        // by the invalidation of the edit dialog.  The message
        // normally sent by doStandardDialog passes one argument (in cx)
        // which we don't care about and grab focus takes no args so
        // this is OK.

        @call IDialupApp::MSG_GEN_APPLICATION_DO_STANDARD_DIALOG(
            MSG_META_GRAB_FOCUS_EXCL,
            (dns1Valid ? @IDEditDNS2 : @IDEditDNS1), 0,
            (char *)0, (char *)0, (char *)0,
            str,
            (CDT_ERROR << CDBF_DIALOG_TYPE_OFFSET) |
            (GIT_NOTIFICATION << CDBF_INTERACTION_TYPE_OFFSET) |
            CDBF_SYSTEM_MODAL
        );

        MemUnlock( OptrToHandle( @invalidDNS1Str ));

        MemFree( hanDNS1 );
        MemFree( hanDNS2 );
        return;
    }

    if (type == NET_TYPE_PPP)
    {
        /* If the user has modified the phone number or the local dialing
        * options, put up a dialog showing the full number as it will be
        * dialed by the modem, and ask them to verify it before proceeding.
        */
        if (@call IDEditPhoneNumber::MSG_GEN_TEXT_IS_MODIFIED() || editDialOptionsChanged)
        {
            MemHandle phoneHan, phoneWithOptionsHan;

            /* Get the current phone number. */
            phoneHan = @call IDEditPhoneNumber::MSG_VIS_TEXT_GET_ALL_BLOCK(0);
            if (phoneHan != NullHandle)
            {
                /* Generate the full phone number with dialing options applied. */
                phoneWithOptionsHan = GetPhoneStringWithOptions(phoneHan, GetLocalDialingOptions());
                if (phoneWithOptionsHan != NullHandle)
                {
                    TCHAR *phoneStr = MemLock(phoneWithOptionsHan);
                    if (phoneStr[0] != '\0')
                    phoneStr ++;	/* always skip the T/P character */
                    @call IDVPNumberGlyph::
                    MSG_GEN_REPLACE_VIS_MONIKER_TEXT(phoneStr, VUM_NOW);
                    MemFree(phoneWithOptionsHan);
                }
                if (UserDoDialog(@IDVerifyPhoneGroup) == IC_NO)
                {
                    /* The user wishes to change the number.  Have the phone
                    * field grab the focus and allow the user to continue
                    * editing.
                    */
                    @send IDEditPhoneNumber::MSG_META_GRAB_FOCUS_EXCL();
                    return;
                }
            }
        }

        /* If the password field is blank, ask the user to verify that they
        * indeed have no password. */
        if (@call IDEditPassword::MSG_VIS_TEXT_GET_TEXT_SIZE() == 0)
        {
            /*  if (*/UserStandardDialogOptr(NULL, NULL, NullOptr,
            NullOptr,
            @verifyBlankPwdStr,
                    ((CDT_NOTIFICATION << CDBF_DIALOG_TYPE_OFFSET) |
                    (GIT_NOTIFICATION << CDBF_INTERACTION_TYPE_OFFSET)));
        /*     {
            @send IDEditPassword::MSG_META_GRAB_FOCUS_EXCL();
            return;
            }  */
        }
    }

    // create a new accesspoint
    if(creatingConnection)
    {
        /* jfh - there is no method for this msg !?!? */
        /* - can't find one either !?!?!? (meyerk 12/2024)*/
        @call IDialupApp::MSG_IDA_SAVE_CURRENT_PASSWORD();

        currentAccpnt = AccessPointCreateEntry(1, APT_INTERNET);
        if (type == NET_TYPE_PPP)
        {
            // Indicate that this access point should use the dialing
            // options.
            AccessPointSetIntegerPropertyDirect(
                currentAccpnt,
                (char*)APSP_USE_DIALING_OPTIONS,
                1
            );
        }
        else
        {
            // Packet or ODI driver

            /* no global dialing options */
            AccessPointSetIntegerPropertyDirect(
                currentAccpnt,
                (char*)APSP_USE_DIALING_OPTIONS,
                0
            );

            /* no local dialing options */
            AccessPointSetIntegerPropertyDirect(
                currentAccpnt,
                (char*)APSP_LOCAL_DIALING_OPTIONS,
                0
            );

            /* never prompt for a password */
            AccessPointSetIntegerPropertyDirect(currentAccpnt, (char*)APSP_PROMPT_SECRET, 0);

            /* dummy phone number */
            AccessPointSetStringPropertyDirect(currentAccpnt, (char*)APSP_PHONE, _TEXT("+"));
        }
    }

    if (type == NET_TYPE_PPP)
    {
        mh = @call IDEditUserName::MSG_VIS_TEXT_GET_ALL_BLOCK(0);
        if (mh)
        {
            str = MemLock(mh);
            if (strlen(str)) {
                AccessPointSetStringPropertyDirect(currentAccpnt, (char*)APSP_USER, str);
            }
            MemFree(mh);
        }

        mh = @call IDEditPassword::MSG_VIS_TEXT_GET_ALL_BLOCK(0);
        if (mh)
        {
            str = MemLock(mh);
            if (strlen(str))
            {
                AccessPointSetStringPropertyDirect(currentAccpnt, (char*)APSP_SECRET, str);
                AccessPointDestroyPropertyDirect(currentAccpnt, (char*)APSP_PROMPT_SECRET);
            }
            else
            {
                AccessPointDestroyPropertyDirect(currentAccpnt, (char*)APSP_SECRET);
                /* this makes the accpt lib ask for a pword at logon */
                AccessPointSetIntegerPropertyDirect(currentAccpnt, (char*)APSP_PROMPT_SECRET, 1);
            }
            MemFree(mh);
        }

        mh = @call IDEditPhoneNumber::MSG_VIS_TEXT_GET_ALL_BLOCK(0);
        if (mh)
        {
            str = MemLock(mh);
            if (strlen(str)) {
                AccessPointSetStringPropertyDirect(currentAccpnt, (char*)APSP_PHONE, str);
            }
            MemFree(mh);
        }

        AccessPointSetIntegerPropertyDirect(
            currentAccpnt,
            (char*)APSP_LOCAL_DIALING_OPTIONS,
            GetLocalDialingOptions()
        );
    }

    mh = @call IDEditIP::MSG_VIS_TEXT_GET_ALL_BLOCK(0);
    if(mh)
    {
        str = MemLock(mh);
        if (strlen(str)) {
            AccessPointSetStringPropertyDirect(currentAccpnt, (char*)APSP_ADDRESS, str);
        }
        MemFree(mh);
    }

    mh = @call IDEditGateway::MSG_VIS_TEXT_GET_ALL_BLOCK(0);
    if(mh)
    {
        str = MemLock(mh);
        if (strlen(str)) {
            AccessPointSetStringPropertyDirect(currentAccpnt, (char*)APSP_GATEWAY, str);
        }
        MemFree(mh);
    }

    mh = @call IDEditMask::MSG_VIS_TEXT_GET_ALL_BLOCK(0);
    if(mh)
    {
        str = MemLock(mh);
        if (strlen(str)) {
            AccessPointSetStringPropertyDirect(currentAccpnt, (char*)APSP_MASK, str);
        }
        MemFree(mh);
    }

    mh = hanDNS1;
    if(mh)
    {
        str = MemLock(mh);
        if (strlen(str)) {
            AccessPointSetStringPropertyDirect(currentAccpnt, (char*)APSP_DNS1, str);
        }
        else {
            AccessPointDestroyPropertyDirect(currentAccpnt, (char*)APSP_DNS1);
        }
        MemFree(mh);
        hanDNS1 = NULL;
    }

    mh = hanDNS2;
    if(mh)
    {
        str = MemLock(mh);
        if (strlen(str)) {
            AccessPointSetStringPropertyDirect(currentAccpnt, (char*)APSP_DNS2, str);
        }
        else {
            AccessPointDestroyPropertyDirect(currentAccpnt, (char*)APSP_DNS2);
        }
        MemFree(mh);
        hanDNS2 = NULL;
    }

    mh = @call IDEditConnectionName::MSG_VIS_TEXT_GET_ALL_BLOCK(0);
    if(mh)
    {
        str = MemLock(mh);
        if (strlen(str))
        {
            AccessPointSetStringPropertyDirect(currentAccpnt, (char*)APSP_NAME, str);
            // change the name in the connection list
            sel = @call IDConnectionList::MSG_GEN_ITEM_GROUP_GET_SELECTION();
            item = @call IDConnectionList::MSG_GEN_ITEM_GROUP_GET_ITEM_OPTR(sel);
            @call item::MSG_GEN_REPLACE_VIS_MONIKER_TEXT(str, VUM_NOW);
        }
        MemFree(mh);
    }

    AccessPointSetIntegerPropertyDirect(currentAccpnt, "netType", type);

    AccessPointCommit();

    if(creatingConnection)
    {
        creatingConnection = FALSE;

        // we must re-read the accpnt list, but
        // MSG_IDP_READ_ACCPNT_AND_ACCPNT_LIST will reset currentAccpnt
        // to the currently active Accpnt, so we need to backup our new
        // accpnt first and restore it afterwards...
        newAccpnt = currentAccpnt;
        @call self::MSG_IDP_READ_ACCPNT_AND_ACCPNT_LIST();
        currentAccpnt = newAccpnt;
        // assuming that the new accpnt is last in list and equals connectionNum-1...
        @send IDConnectionList::MSG_GEN_ITEM_GROUP_SET_SINGLE_SELECTION((connectionNum - 1), 0);
        @send IDConnectionList::MSG_GEN_ITEM_GROUP_MAKE_ITEM_VISIBLE((connectionNum - 1));
        @call self::MSG_IDP_UPDATE_UI_FOR_SELECTED_ACCPNT();
    }
    else
    {
        @call self::MSG_IDP_READ_ACCPNT_AND_ACCPNT_LIST();
        @call self::MSG_IDP_UPDATE_UI_FOR_SELECTED_ACCPNT();
    }

    // We no longer automatically do this via GI_attrs since we may not
    // want to bring down the dialog if the DNS entry is invalid.
    @send IDEditGroup::MSG_GEN_INTERACTION_ACTIVATE_COMMAND(IC_INTERACTION_COMPLETE);
}

/***********************************************************************
 *	MSG_IDP_CREATE_CONNECTION for IDialupProcessClass
 ***********************************************************************
 * SYNOPSIS:     Create a new current connection setting.
 *
 * PARAMETERS:
 *
 * SIDE EFFECTS:
 *
 * STRATEGY:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	mzhu	11/23/98	Initial Revision
 *
 ***********************************************************************/
@method IDialupProcessClass, MSG_IDP_CREATE_CONNECTION
{
  TCHAR *str;

  @call IDEditConnectionType::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);

  @call IDEditPhoneNumber::MSG_VIS_TEXT_DELETE_ALL();

  @call IDEditDialingOptionsGroup::
      MSG_GEN_BOOLEAN_GROUP_SET_GROUP_STATE(DEFAULT_DIAL_OPTIONS, 0);

  @call IDEditUserName::MSG_VIS_TEXT_DELETE_ALL();

  @call IDEditPassword::MSG_VIS_TEXT_DELETE_ALL();

  @call IDEditConnectionName::MSG_VIS_TEXT_DELETE_ALL();

  @call IDEditIP::MSG_VIS_TEXT_DELETE_ALL();

  @call IDEditMask::MSG_VIS_TEXT_DELETE_ALL();

  @call IDEditGateway::MSG_VIS_TEXT_DELETE_ALL();

  @call IDEditDNS1::MSG_VIS_TEXT_DELETE_ALL();

  @call IDEditDNS2::MSG_VIS_TEXT_DELETE_ALL();

  MemLock(OptrToHandle(@addConnectionStr));

  str = LMemDeref(@addConnectionStr);
  @call IDEditGroup::MSG_GEN_REPLACE_VIS_MONIKER_TEXT(str, VUM_DELAYED_VIA_APP_QUEUE);

  str = LMemDeref(@addStr);
  @call IDEditOkButton::MSG_GEN_REPLACE_VIS_MONIKER_TEXT(str, VUM_DELAYED_VIA_APP_QUEUE);
  @call IDEditOkButton::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);

  str = LMemDeref(@cancelStr);
  @call IDEditCancelButton::MSG_GEN_REPLACE_VIS_MONIKER_TEXT(str, VUM_DELAYED_VIA_APP_QUEUE);

  MemUnlock(OptrToHandle(@addConnectionStr));

  @send IDEditGroup::MSG_GEN_INTERACTION_INITIATE();

  @send IDEditConnectionName::MSG_META_GRAB_FOCUS_EXCL();
  @send IDEditConnectionName::MSG_META_GRAB_TARGET_EXCL();

  creatingConnection = TRUE;
}

/***********************************************************************
 *	MSG_IDP_DELETE_CONNECTION for IDialupProcessClass
 ***********************************************************************
 * SYNOPSIS:     Delete the current connection setting.
 *
 * PARAMETERS:
 *
 * SIDE EFFECTS:
 *
 * STRATEGY:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	mzhu	11/23/98	Initial Revision
 *
 ***********************************************************************/
#define min(x, y) (x)>(y)?(y):(x)
@method IDialupProcessClass, MSG_IDP_DELETE_CONNECTION
{
  TCHAR tstr[100], name[NAME_LEN];
  TCHAR *tptr;
  word datalen = NAME_LEN;

  if (currentAccpnt == G_activeAccpnt)
  {
    UserStandardDialogOptr(
        0, 0, 0, 0,
        @noEdit,
        (CDT_WARNING<<CDBF_DIALOG_TYPE_OFFSET)|(GIT_NOTIFICATION<<CDBF_INTERACTION_TYPE_OFFSET)) ;
    return;
  }

  if(AccessPointGetStringPropertyBufferDirect(currentAccpnt, (char*)APSP_NAME, name, (int*) &datalen))
    AccessPointGetStringPropertyBufferDirect(currentAccpnt, (char*)APSP_PHONE, name, (int*) &datalen);

  MemLock(OptrToHandle(@deleteStr1));
  tptr = LMemDeref(@deleteStr1);
  strcpy(tstr, tptr);
  strncat(tstr, name, min((80 - strlen(tstr)), datalen));
  tptr = LMemDeref(@deleteStr2);
  strcat(tstr, tptr);

  MemUnlock(OptrToHandle(@deleteStr1));

  @call IDialupApp::MSG_GEN_APPLICATION_DO_STANDARD_DIALOG(
			MSG_IDP_DELETE_CONFIRM,
			oself,
    	    	    	0,
    	    	    	0,
			0,
			0,
	        	tstr,
			(CDT_WARNING << CDBF_DIALOG_TYPE_OFFSET) |
			(GIT_AFFIRMATION << CDBF_INTERACTION_TYPE_OFFSET));
}


/***********************************************************************
 *	MSG_IDP_DELETE_CONNECTION for IDialupProcessClass
 ***********************************************************************
 * SYNOPSIS:     Delete the current connection setting.
 *
 * PARAMETERS:
 *               InteractionCommand response = cx
 * SIDE EFFECTS:
 *
 * STRATEGY:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	mzhu	11/23/98	Initial Revision
 *
 ***********************************************************************/
@method IDialupProcessClass, MSG_IDP_DELETE_CONFIRM
{
    if(response == IC_YES)
    {
      AccessPointDestroyEntryDirect(currentAccpnt);
      AccessPointCommit();

      // reset the current accesspoint
      currentAccpnt = 0;

      // read active AccPnt from the ini
      // - the active AccPnt can't have been deleted
      @call self::MSG_IDP_READ_ACCPNT_AND_ACCPNT_LIST();
      @call self::MSG_IDP_UPDATE_UI_FOR_SELECTED_ACCPNT();
    }
}

/***********************************************************************
 *		MSG_IDP_READ_ACCPNT_AND_ACCPNT_LIST
 ***********************************************************************
 *
 * SYNOPSIS:	Initialize UI and Connection settings.
 * CALLED BY:
 * RETURN:
 *
 * STRATEGY:
 *
 * REVISION HISTORY:
 *	Name		Date		Description
 *	----		----		-----------
 *	mzhu    	12/03/98   	Initial Revision
 *
 ***********************************************************************/
@method IDialupProcessClass, MSG_IDP_READ_ACCPNT_AND_ACCPNT_LIST
{
    word *id, datalen, i, defaultItem=0;
    word tmpAccpnt=0, tmpItem=0;
    word *hidden;
    word  currentListItem=0;

    if(connectionHandle)
    {
        if(connectionChunk)
        {
            MemLock(connectionHandle);
            ChunkArrayZeroHandles(connectionHandle, connectionChunk);
            MemUnlock(connectionHandle);
        }
    }
    else
    {
        connectionHandle = MemAllocLMem(LMEM_TYPE_GENERAL, sizeof(LMemBlockHeader));
    }

    MemLock(connectionHandle);
    connectionChunk = AccessPointGetEntries(connectionHandle, 0, APT_INTERNET);

    if (!connectionChunk)
    {
        MemUnlock(connectionHandle);
        EC(EC_ERROR(-1);)
        return;
    }

    connectionNum = ChunkArrayGetCountHandles(connectionHandle, connectionChunk);
    if(!connectionNum)
    {
        // the ini file wrong
        MemUnlock(connectionHandle);
        EC(EC_ERROR(-1);)
        return;
    }

    currentAccpnt = AccessPointGetActivePoint(APT_INTERNET);
    defaultAccpnt = 0;

    for(i=0; i<connectionNum; i++)
    {
        id = ChunkArrayElementToPtrHandles(connectionHandle, connectionChunk, i, &datalen);

        // the accesspoint0001 is protected from being used, prepare for removal from the list
        if(*id == HIDDEN_INTERNET_ACCPNT)
        {
            hidden = id;
            continue;
        }

        // if we don't have a valid accpnt just yet, we will use the first one we stumple upon
        if(!currentAccpnt)
        {
            tmpAccpnt = *id;
            tmpItem = i;
        }
        else if(currentAccpnt == *id)
        {   // if we have a valid accpnt, store its "i" to be used as the active list item
            tmpItem = i;
        }

        // test if this is the default access point
        if(!AccessPointGetIntegerPropertyDirect(
            *id,
            DEFAULT_KEY,
            (int*) &datalen) && datalen != 0)
        {
            defaultAccpnt = *id;
            defaultItem = i;
        }

        // Hack to flag for deletion the temporary access point created by signup,
        // just in case signup crashes and fails to clean up after itself.
        // The actual removal occurs in MSG_GEN_PROCESS_OPEN_APPLICATION.
        // (dhunter 1/13/2000)
        // There is no "Welcome" or "Signup" application in the FreeGEOS Version of
        // PC/GEOS, so let's disable this hack.
        // (meyerk 01/2025)
        // if (!AccessPointGetIntegerPropertyDirect(
        //     *id,
        //     TEMPORARY_KEY,
        //     (int*) &datalen) && datalen == 1)
        // {
        //     tempAccpnt = *id; // don't confuse with tmpAccpnt!
        // }
    }

    if(hidden)
    {   // delete the hidden access point from the list
        ChunkArrayDeleteHandle(connectionChunk, hidden);
    }
    else
    {
        // if we have no hidden accpnt as of now, the ini file is broken
        EC(EC_ERROR(-1);)
    }

    // rescan needed, as we have removed the hidden access point from the list, so the count is off
    connectionNum = ChunkArrayGetCountHandles(connectionHandle, connectionChunk);

    MemUnlock(connectionHandle);

    if(!currentAccpnt)
    {
        if(defaultAccpnt)
        {
            currentAccpnt = defaultAccpnt;
            currentListItem = defaultItem;
        }
        else if(tmpAccpnt)
        {
            currentAccpnt = tmpAccpnt;
            currentListItem = tmpItem;
        }
    }
    else
    {
        currentListItem = tmpItem;
    }

    /* store currentAccpnt also in G_activeAccpnt */
    G_activeAccpnt = currentAccpnt;

    /* if there is only 1 access point and no default accpnt
       then let's make it the default access point automagically...
       (jfh 2/19/02) */
    if ((connectionNum == 1) && !defaultAccpnt)
    {
        IDialupMakeCurrentAccpntActiveAndDefault();
    }

    // init / update the list UI, the rest of the UI must be updated separately by
    // manually calling MSG_IDP_UPDATE_UI_FOR_SELECTED_ACCPNT
    @call IDConnectionList::MSG_GEN_DYNAMIC_LIST_INITIALIZE(connectionNum);
    @send IDConnectionList::MSG_GEN_ITEM_GROUP_SET_SINGLE_SELECTION(currentListItem, 0);
}

/***********************************************************************
 *	MSG_IDP_UPDATE_UI_FOR_SELECTED_ACCPNT for IDialupProcessClass
 ***********************************************************************
 * SYNOPSIS:     Edit the current CONNECTION setting.
 *
 * PARAMETERS:   void (optr list, word item)
 *
 * SIDE EFFECTS:
 *
 * STRATEGY:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	mzhu	11/23/98	Initial Revision
 *
 ***********************************************************************/
@method IDialupProcessClass, MSG_IDP_UPDATE_UI_FOR_SELECTED_ACCPNT
{
    word datalen;
    TCHAR name[MAX_TEXT_LEN];
    MemHandle mh;
    int type = 0;

    if (AccessPointGetIntegerPropertyDirect(currentAccpnt, "netType", (int*) &type)) {
        type = NET_TYPE_PPP ;
    }

    switch (type)
    {
        case NET_TYPE_PKT:
            @call IDConnectionNetType::MSG_GEN_REPLACE_VIS_MONIKER_OPTR(@netTypePktStr, VUM_DELAYED_VIA_APP_QUEUE);
        break;

        case NET_TYPE_HOST:
            @call IDConnectionNetType::MSG_GEN_REPLACE_VIS_MONIKER_OPTR(@netTypeHostStr, VUM_DELAYED_VIA_APP_QUEUE);
        break;

        case NET_TYPE_ODI:
            @call IDConnectionNetType::MSG_GEN_REPLACE_VIS_MONIKER_OPTR(@netTypeOdiStr, VUM_DELAYED_VIA_APP_QUEUE);
        break;

        default: //NET_TYPE_PPP:
            @call IDConnectionNetType::MSG_GEN_REPLACE_VIS_MONIKER_OPTR(@netTypePppStr, VUM_DELAYED_VIA_APP_QUEUE);
        break;
    }

    if (
        // only if we have list items...
        (connectionNum) &&
        // never if we have a HOST connection...
        (type != NET_TYPE_HOST)
    )
    {
        @call IDModifyConnectionButton::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
        @call IDDeleteConnectionButton::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
    }
    else
    {
        @call IDModifyConnectionButton::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
        @call IDDeleteConnectionButton::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
    }

/*
    if(!AccessPointGetIntegerPropertyDirect(currentAccpnt, DEFAULT_KEY, (int*) &datalen) &&
        datalen != 0)
    {
        @call IDConnectionDefaultBoxGroup::MSG_GEN_BOOLEAN_GROUP_SET_BOOLEAN_STATE(1, TRUE);
    }
    else
    {
        @call IDConnectionDefaultBoxGroup::MSG_GEN_BOOLEAN_GROUP_SET_BOOLEAN_STATE(1, FALSE);
    }
*/

    datalen = MAX_TEXT_LEN*sizeof(TCHAR);
    memset(name, 0, sizeof(TCHAR)*MAX_TEXT_LEN);
    @send IDConnectionUserName::MSG_GEN_SET_NOT_USABLE(VUM_DELAYED_VIA_APP_QUEUE);
    if (!AccessPointGetStringPropertyBufferDirect(
        currentAccpnt,
        (char*)APSP_USER,
        name,
        (int*) &datalen))
    {
        @call IDConnectionUserName::MSG_VIS_TEXT_REPLACE_ALL_PTR(name, datalen);
    }
    else
    {
        @call IDConnectionUserName::MSG_VIS_TEXT_DELETE_ALL();
    }
    @send IDConnectionUserName::MSG_VIS_MARK_INVALID(VOF_GEOMETRY_INVALID, VUM_DELAYED_VIA_APP_QUEUE);
    @send IDConnectionUserName::MSG_GEN_SET_USABLE(VUM_DELAYED_VIA_APP_QUEUE);

    if(connectionNum)
    {
        @call IDConnectButton::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
        //@call IDConnectionDefaultBoxGroup::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
    }
    else
    {
        @call IDConnectButton::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
        //@call IDConnectionDefaultBoxGroup::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
    }

    /*
    if(AccessPointGetIntegerPropertyDirect(currentAccpnt, "hours", &tHours))
        tHours = 0;
    if(AccessPointGetIntegerPropertyDirect(currentAccpnt, "minutes", &tMinutes))
        tMinutes = 0;
    if(AccessPointGetIntegerPropertyDirect(currentAccpnt, "seconds", &tSeconds))
        tSeconds = 0;
    */

    datalen = MAX_TEXT_LEN;
    memset(name, 0, sizeof(TCHAR)*MAX_TEXT_LEN);
    mh = NULL;
    @send IDConnectionPhoneNumber::MSG_GEN_SET_NOT_USABLE(VUM_DELAYED_VIA_APP_QUEUE);
    if ( AccessPointGetPhoneStringWithOptions(currentAccpnt, &mh, (int*) &datalen))
    {
        TCHAR *str;
        str = MemLock( mh );
        if ( str )
        {
            if ( *str == 'T' || *str == 'P' )
                ++str;
        }
        @call IDConnectionPhoneNumber::MSG_VIS_TEXT_REPLACE_ALL_PTR(str, 0 /*NULL term*/);
        MemUnlock( mh );
        MemFree( mh );
    }
    else if (!AccessPointGetStringPropertyBufferDirect(
        currentAccpnt,
        (char*)APSP_PHONE,
        name,
        (int*) &datalen))
    {
        @call IDConnectionPhoneNumber::MSG_VIS_TEXT_REPLACE_ALL_PTR(name, datalen);
    }
    else
    {
        @call IDConnectionPhoneNumber::MSG_VIS_TEXT_DELETE_ALL();
    }
    @send IDConnectionPhoneNumber::MSG_VIS_MARK_INVALID(VOF_GEOMETRY_INVALID, VUM_DELAYED_VIA_APP_QUEUE);
    @send IDConnectionPhoneNumber::MSG_GEN_SET_USABLE(VUM_DELAYED_VIA_APP_QUEUE);

    @send IDConnectionPhoneAndLogin::MSG_GEN_SET_NOT_USABLE(VUM_DELAYED_VIA_APP_QUEUE);

    if (currentAccpnt != G_activeAccpnt)
    {
        @send IDConnectionActivateBox::MSG_GEN_SET_USABLE(VUM_DELAYED_VIA_APP_QUEUE);
    }
    else
    {
        @send IDConnectionActivateBox::MSG_GEN_SET_NOT_USABLE(VUM_DELAYED_VIA_APP_QUEUE);
        if (type == NET_TYPE_PPP)
        {
            @send IDConnectionPhoneAndLogin::MSG_GEN_SET_USABLE(VUM_DELAYED_VIA_APP_QUEUE);
        }
    }

    @send IDialupPrimary::MSG_GEN_RESET_TO_INITIAL_SIZE(VUM_DELAYED_VIA_APP_QUEUE);
}

/***********************************************************************
 *	IDialupEnsureDefaultConnection
 ***********************************************************************
 * SYNOPSIS:     Ensure that only defaultAccpnt is flagged as the
 *               default.
 *
 * PARAMETERS:
 *
 * SIDE EFFECTS: Resets the default flag for all other access points.
 *
 * STRATEGY:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	dhunter	2/25/2000	Extracted from MSG_IDP_SET_DEFAULT_CONNECTION
 *
 ***********************************************************************/
void IDialupEnsureDefaultConnection(void)
{
  word i, datalen, *id;

  MemLock(connectionHandle);

  for(i=0; i<connectionNum; i++)
  {
    id = ChunkArrayElementToPtrHandles(connectionHandle, connectionChunk, i, &datalen);
    if(*id != defaultAccpnt)
    {
	AccessPointSetIntegerPropertyDirect(*id, DEFAULT_KEY, 0);
    }
  }
  MemUnlock(connectionHandle);
}

/***********************************************************************
 *	MSG_IDP_SET_DEFAULT_CONNECTION for IDialupProcessClass
 ***********************************************************************
 * SYNOPSIS:     Create a new current connection setting.
 *
 * PARAMETERS:
 *
 * SIDE EFFECTS:
 *
 * STRATEGY:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	mzhu	11/23/98	Initial Revision
 *
 ***********************************************************************/
/*
@method IDialupProcessClass, MSG_IDP_SET_DEFAULT_CONNECTION
{
  if(@call IDConnectionDefaultBoxGroup::MSG_GEN_BOOLEAN_GROUP_GET_SELECTED_BOOLEANS())
    {
      AccessPointSetIntegerPropertyDirect(currentAccpnt, DEFAULT_KEY, 1);
      defaultAccpnt = currentAccpnt;

      IDialupEnsureDefaultConnection();
    }
  else
    {
      AccessPointSetIntegerPropertyDirect(currentAccpnt, DEFAULT_KEY, 0);
      defaultAccpnt = 0;
    }

  AccessPointSetActivePoint(defaultAccpnt, APT_INTERNET);
  AccessPointCommit();
}
*/

/***********************************************************************
 *	IDialupUpdateEditOKButton
 ***********************************************************************
 * SYNOPSIS:    Set the enabled status of the IDEditOkButton to reflect
 *              the validity of the contents of the edit dialog controls.
 *
 * PARAMETERS:  none
 *
 * SIDE EFFECTS:
 *
 * STRATEGY:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *  dhunter 1/14/2000   Moved to common routine called by MSG_META_TEXT...
 *	mzhu	11/23/98	Initial Revision
 *
 ***********************************************************************/
void IDialupUpdateEditOKButton(void)
{
    Boolean name, phone, user;

	word type = @call IDEditConnectionType::MSG_GEN_ITEM_GROUP_GET_SELECTION() ;

    /* Enable the OK button only if we have an Connection name, number and a
     * user name.
     */
	name = ((@call IDEditConnectionName::MSG_VIS_TEXT_GET_TEXT_SIZE()) > 0) ?
	    TRUE : FALSE;
	if (type == NET_TYPE_PPP)  {
		phone = ((@call IDEditPhoneNumber::MSG_VIS_TEXT_GET_TEXT_SIZE()) > 0) ?
			TRUE : FALSE;
		user = ((@call IDEditUserName::MSG_VIS_TEXT_GET_TEXT_SIZE()) > 0) ?
			TRUE : FALSE;
	} else {
		phone = TRUE ;
		user = TRUE ;
	}

	if ( name && phone && user )
	    @send IDEditOkButton::MSG_GEN_SET_ENABLED(
		VUM_DELAYED_VIA_UI_QUEUE);
	else
	    @send IDEditOkButton::MSG_GEN_SET_NOT_ENABLED(
		VUM_DELAYED_VIA_UI_QUEUE);
}

/***********************************************************************
 *	MSG_META_TEXT_EMPTY_STATUS_CHANGED for IDialupProcessClass
 ***********************************************************************
 * SYNOPSIS:
 *
 * PARAMETERS:  optr object = cx:dx,
		Boolean hasTextFlag = bp
 *
 * SIDE EFFECTS:
 *
 * STRATEGY:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	mzhu	11/23/98	Initial Revision
 *
 ***********************************************************************/
@method IDialupProcessClass, MSG_META_TEXT_EMPTY_STATUS_CHANGED
{
    if ( object == @IDEditConnectionName || object == @IDEditPhoneNumber ||
	      object == @IDEditUserName || object == @IDEditPassword)
        IDialupUpdateEditOKButton();
}

/***********************************************************************
 *	MSG_META_TEXT_USER_MODIFIED for IDialupProcessClass
 ***********************************************************************
 * SYNOPSIS:
 *
 * PARAMETERS:  optr obj = cx:dx
 *
 * SIDE EFFECTS:
 *
 * STRATEGY:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	dhunter 1/14/2000   Initial Revision
 *
 ***********************************************************************/
@method IDialupProcessClass, MSG_META_TEXT_USER_MODIFIED
{
    if (!creatingConnection && (obj == @IDEditConnectionName
      || obj == @IDEditPhoneNumber || obj == @IDEditUserName
      || obj == @IDEditPassword
/*@if defined(PRODUCT_NDO2000) */
      || obj == @IDEditIP || obj == @IDEditGateway
      || obj == @IDEditMask
/*@endif*/
      || obj == @IDEditDNS1 || obj == @IDEditDNS2))
        IDialupUpdateEditOKButton();
}


/***********************************************************************
 *		MSG_IDP_EDIT_DIALING_OPTIONS_CHANGED for IDialupProcessClass
 ***********************************************************************
 *
 * SYNOPSIS:	    Sent as the apply message of IDEditDialingOptions
 *                  to update the enabled state of IDEditOkButton.
 *
 * PARAMETERS:	    none of interest
 *
 * STRATEGY:        Set the changed flag for later
 *                  Call our common validation routine
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	dhunter	5/17/00   	Initial Revision
 *
 ***********************************************************************/
@method IDialupProcessClass, MSG_IDP_EDIT_DIALING_OPTIONS_CHANGED
{
/*#ifndef PRODUCT_NDO2000 */
	 editDialOptionsChanged = TRUE;
/*#endif  */
    IDialupUpdateEditOKButton();
}	/* End of MSG_IDP_EDIT_OPTIONS_CHANGED.	*/


/***********************************************************************
 *	MSG_IDP_DIALING_OPTIONS for IDialupProcessClass
 ***********************************************************************
 * SYNOPSIS:     Open the dialing options dialog.
 *
 * PARAMETERS:
 *
 * SIDE EFFECTS:
 *
 * STRATEGY:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	JimG	9/7/99		Initial Revision
 *
 ***********************************************************************/
@method IDialupProcessClass, MSG_IDP_DIALING_OPTIONS
{
    AccessPointDialingOptions options;
/*@if defined(PRODUCT_NDO2000)
    Boolean lqm;

    if (InitFileReadBoolean("ppp", "lqm", &lqm)) lqm = TRUE;
    @call IDDOMiscOptionsGroup::MSG_GEN_BOOLEAN_GROUP_SET_GROUP_STATE(
	(lqm ? 1 : 0), 0);
/*@endif  */

    AccessPointGetDialingOptions( &options );

    /* Must do call's here since fptr is on stack. */
    @call IDDOAreaCode::MSG_VIS_TEXT_REPLACE_ALL_PTR(
	options.APDO_areaCode, 0 /* Null terminated */ );

    @call IDDOOutsideLine::MSG_VIS_TEXT_REPLACE_ALL_PTR(
	options.APDO_outsideLine, 0 /* Null terminated */ );

    @call IDDOCallWaiting::MSG_VIS_TEXT_REPLACE_ALL_PTR(
	options.APDO_callWaiting, 0 /* Null terminated */ );

    @call IDDODialTypeGroup::MSG_GEN_ITEM_GROUP_SET_SINGLE_SELECTION(
	options.APDO_dialMethod, 0 /* DETERMINATE! */ );

    @call IDDODialtoneGroup::MSG_GEN_BOOLEAN_GROUP_SET_GROUP_STATE(
	(options.APDO_waitForDialtone ? 1 : 0), 0 /* DETERMINATE! */ );

    @send IDDialingOptionsDialog::MSG_GEN_INTERACTION_INITIATE();
}


/***********************************************************************
 *	MSG_IDP_DIALING_OPTIONS_CHANGE for IDialupProcessClass
 ***********************************************************************
 * SYNOPSIS:     Set the dialing options in accpnt and close the dlg.
 *
 * PARAMETERS:
 *
 * SIDE EFFECTS:
 *
 * STRATEGY:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	JimG	9/7/99		Initial Revision
 *
 ***********************************************************************/
@method IDialupProcessClass, MSG_IDP_DIALING_OPTIONS_CHANGE
{
    AccessPointDialingOptions options;
    MemHandle mh;
    word nAreaCodeLen;
/*@if defined(PRODUCT_NDO2000)
    Boolean lqm;
/*@endif */

    if ((nAreaCodeLen = @call IDDOAreaCode::MSG_VIS_TEXT_GET_TEXT_SIZE()) > 0
      && nAreaCodeLen != 3)
    {
	/* Put up an error message and return focus to area code entry */
	MemLock( OptrToHandle( @invalidAreaCodeStr ) );
	@call IDialupApp::MSG_GEN_APPLICATION_DO_STANDARD_DIALOG(
	    MSG_META_GRAB_FOCUS_EXCL, @IDDOAreaCode,
	    0, 0, 0, 0,
	    LMemDeref( @invalidAreaCodeStr ),
	    (CDT_ERROR << CDBF_DIALOG_TYPE_OFFSET) |
	    (GIT_NOTIFICATION << CDBF_INTERACTION_TYPE_OFFSET) |
	    CDBF_SYSTEM_MODAL );
	MemUnlock( OptrToHandle( @invalidAreaCodeStr ) );
    }
    else
    {
	/*
	 * All of these strings in the option structure have length of
	 * APDO_..._LEN + 1 for the null terminator.  Since strncpy() will
	 * not place a null terminator at the end of a string that is
	 * exactly n chars long, be sure to provide a terminator, just in case.
	 */
	mh = @call IDDOAreaCode::MSG_VIS_TEXT_GET_ALL_BLOCK(0);
	strncpy( options.APDO_areaCode, MemLock( mh ), APDO_AREA_CODE_LEN );
	MemUnlock( mh );
	options.APDO_areaCode[APDO_AREA_CODE_LEN] = '\0';

	mh = @call IDDOCallWaiting::MSG_VIS_TEXT_GET_ALL_BLOCK(0);
	strncpy( options.APDO_callWaiting, MemLock( mh ),
		 APDO_CALL_WAITING_LEN );
	MemUnlock( mh );
	options.APDO_callWaiting[APDO_CALL_WAITING_LEN] = '\0';

	mh = @call IDDOOutsideLine::MSG_VIS_TEXT_GET_ALL_BLOCK(0);
	strncpy( options.APDO_outsideLine, MemLock( mh ),
		 APDO_OUTSIDE_LINE_LEN );
	MemUnlock( mh );
	options.APDO_outsideLine[APDO_OUTSIDE_LINE_LEN] = '\0';

	options.APDO_dialMethod = @call IDDODialTypeGroup::
	    MSG_GEN_ITEM_GROUP_GET_SELECTION();

	options.APDO_tenDigit = FALSE;	/* set locally on each accpnt */

	options.APDO_waitForDialtone = (@call IDDODialtoneGroup::
	    MSG_GEN_BOOLEAN_GROUP_GET_SELECTED_BOOLEANS() == 1) ? TRUE : FALSE;

	AccessPointSetDialingOptions( &options );

/*@if defined(PRODUCT_NDO2000)
	lqm = (@call IDDOMiscOptionsGroup::
	    MSG_GEN_BOOLEAN_GROUP_GET_SELECTED_BOOLEANS() == 1) ? TRUE : FALSE;
        InitFileWriteBoolean("ppp", "lqm", lqm);
/*@endif */

	@send IDDialingOptionsDialog::MSG_GEN_INTERACTION_ACTIVATE_COMMAND(
	    IC_INTERACTION_COMPLETE);

	/* Update the UI since the number is shown with dialer options. */
	@call self::MSG_IDP_UPDATE_UI_FOR_SELECTED_ACCPNT();
    }
}

/***********************************************************************
 *	IDialupMakeCurrentAccpntActiveAndDefault
 ***********************************************************************
 * SYNOPSIS: Make sure that the "netType"
 *           hasn't changed before calling this function...
 *
 * PARAMETERS:
 *
 * SIDE EFFECTS:
 *
 * STRATEGY:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	meyerk	2025/01	    Initial Revision
 *
 ***********************************************************************/
void IDialupMakeCurrentAccpntActiveAndDefault()
{
    // set G_activeAccpnt
    G_activeAccpnt = currentAccpnt;

    // set default Accpnt
    AccessPointSetIntegerPropertyDirect(currentAccpnt, DEFAULT_KEY, 1);
    defaultAccpnt = currentAccpnt;
    IDialupEnsureDefaultConnection();

    // make point active
    AccessPointSetActivePoint(currentAccpnt, APT_INTERNET);
    AccessPointCommit();
}


/***********************************************************************
 *	MSG_IDP_ACTIVATE for IDialupProcessClass
 ***********************************************************************
 * SYNOPSIS:     activate the selected access point,
 *               reboot if netType changed (Host, PPP, ODI, PKT...)
 *
 * PARAMETERS:
 *
 * SIDE EFFECTS:
 *
 * STRATEGY:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	meyerk	2025/03/01	Initial Revision
 *
 ***********************************************************************/
@method IDialupProcessClass, MSG_IDP_ACTIVATE
{
    word netType = 0 ;
    word size ;
    Boolean toPPP = FALSE ;

    /* make sure to unregister, just in case... */
    if (G_registered)  {
        UnregisterToPPP();

        UnloadPPPDriver();
        G_registered = FALSE ;
    }

    // Set active access point to the current one
    IDialupMakeCurrentAccpntActiveAndDefault();

    if (AccessPointGetIntegerPropertyDirect(currentAccpnt, "netType", (int*) &netType)) {
        netType = NET_TYPE_PPP ;
    }

    if (netType != G_lastActiveNetType)
    {
        // note: G_lastActiveNetType doesn't need to be updated, as we will reboot now

        if( netType == NET_TYPE_HOST )
        {
            NEC(char *driver = "Host TCP/IP Driver" ; )
            EC(char *driver = "EC Host TCP/IP Driver" ; )
            InitFileWriteString("tcpip", "driver", driver) ;

            InitFileDeleteEntry("tcpip", "link") ;
            InitFileWriteString("tcpip", "linkDomain", "Host") ;
            InitFileDeleteEntry("tcpip", "linkPermname") ;
        }
        else
        {
            NEC(char *driver = "TCP/IP Driver" ; )
            EC(char *driver = "EC TCP/IP Driver" ; )
            InitFileWriteString("tcpip", "driver", driver) ;

            if (netType == NET_TYPE_ODI)
            {
                NEC(char *link = "ODI Ethernet Driver" ; )
                EC(char *link = "EC ODI Ethernet Driver" ; )
                InitFileWriteString("tcpip", "link", link) ;
                InitFileWriteString("tcpip", "linkDomain", "EtherODI") ;
                InitFileDeleteEntry("tcpip", "linkPermname") ;
            }
            else if (netType == NET_TYPE_PKT)
            {
                NEC(char *link = "Packet Ethernet Driver" ; )
                EC(char *link = "EC Packet Ethernet Driver" ; )
                InitFileWriteString("tcpip", "link", link) ;
                InitFileWriteString("tcpip", "linkDomain", "EtherPKT") ;
                InitFileDeleteEntry("tcpip", "linkPermname") ;
            }
            else
            {
                NEC(char *ppplink = "PPP Driver" ; )
                EC(char *ppplink = "EC PPP Driver" ; )
                InitFileWriteString("tcpip", "link", ppplink) ;
                InitFileWriteString("tcpip", "linkDomain", "PPP") ;
                InitFileWriteString("tcpip", "linkPermname", "ppp") ;
                toPPP = TRUE ;
            }
        }

        if (toPPP)
        {
            UserStandardDialogOptr(
                0, 0, 0, 0,
                @mustRestartPPP,
                (CDT_WARNING<<CDBF_DIALOG_TYPE_OFFSET)|(GIT_NOTIFICATION<<CDBF_INTERACTION_TYPE_OFFSET)
            );
        }
        else
        {
            UserStandardDialogOptr(
                0, 0, 0, 0,
                @mustRestart,
                (CDT_WARNING<<CDBF_DIALOG_TYPE_OFFSET)|(GIT_NOTIFICATION<<CDBF_INTERACTION_TYPE_OFFSET)
            );
        }

        SysShutdown(SST_RESTART) ;
    }
    else
    {
        @send process::MSG_IDP_READ_ACCPNT_AND_ACCPNT_LIST();
        @send process::MSG_IDP_UPDATE_UI_FOR_SELECTED_ACCPNT();
    }
}



/***********************************************************************
 *	MSG_IDP_CONNECT for IDialupProcessClass
 ***********************************************************************
 * SYNOPSIS:     open the ppp connection.
 *
 * PARAMETERS:
 *
 * SIDE EFFECTS:
 *
 * STRATEGY:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	mzhu	11/23/98	Initial Revision
 *
 ***********************************************************************/
@method IDialupProcessClass, MSG_IDP_CONNECT
{
    connectSent = TRUE;
    disconnectRequested = FALSE;

    /* Unregister if we are not connected */
    if (G_registered)  {
        UnregisterToPPP();

        UnloadPPPDriver();
        G_registered = FALSE ;
    }

    @call IDConnectButton::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_UI_QUEUE);
    @call IDDisconnectButton::MSG_GEN_SET_NOT_ENABLED(VUM_NOW);
    @call IDInfoGroup::MSG_IDI_RESET();		/* Make sure stats are 0'd */
    @call IDialupApp::MSG_IDA_VIEW_INFO();

    /* Register for a connection */
    if (!G_registered)  {
        LoadPPPDriver();

        RegisterToPPP();
        G_registered = TRUE ;
    }

    if(!IDialupConnect())
    {
        /* something wrong, should notify the user */
        if ( !disconnectRequested )
        EC(EC_WARNING(-1);)

        /*
        * If connectSent wasn't cleared, we never got to PPP_STATUS_OPENING,
        * so take care of that and restore the connection view.  Otherwise,
        * PPP_STATUS_CLOSED will eventually do all this for us.
        */
        if (connectSent)
        {
            connectSent = FALSE;
            disconnectRequested = FALSE;

            @call IDialupApp::MSG_IDA_VIEW_CONNECTION();
        }
    }
}


/***********************************************************************
 *	MSG_IDP_DISCONNECT for IDialupProcessClass
 ***********************************************************************
 * SYNOPSIS:     stop the ppp connection.
 *		 This is not sent directly from the UI anymore, but
 *		 may be routed here by the App object.
 *
 * PARAMETERS:
 *
 * SIDE EFFECTS:
 *
 * STRATEGY:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	mzhu	11/23/98	Initial Revision
 *
 ***********************************************************************/
@method IDialupProcessClass, MSG_IDP_DISCONNECT
{
    /*
     * This message is sent to us from the App object's
     * MSG_IDA_DISCONNECT handler.  All UI and timer stuff may have been
     * done by the app object; but we cannot be sure so do it again, just
     * to be safe.
     */
    connectSent = FALSE;

    // Note: Do NOT set disconnectRequested to TRUE here because that
    // should ONLY be set when the USER requested a disconnect via the
    // UI.  Since the UI sends a msg to the app object, let it set this
    // value.  Otherwise, we may lose messages to the user.
    //
    // disconnectRequested = TRUE;
    @call IDDisconnectButton::MSG_GEN_SET_NOT_ENABLED(VUM_NOW);

    if(timerHandle)
    {
	TimerStop(timerHandle, timerId) ;
	timerHandle = 0 ;
        timerId = 0;
    }

    // If we are opening or dialing, this will force the modem to stop
    if(!IDialupDisconnect())
    {
	EC_WARNING(-1);
    }
}


/***********************************************************************
 *	MSG_IDP_STAY_CONNECTED for IDialupProcessClass
 ***********************************************************************
 * SYNOPSIS:     keep connection after timeout; if CUI, lower app to
 *		 bottom
 *
 * PARAMETERS:
 *
 * SIDE EFFECTS:
 *
 * STRATEGY:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	mzhu	04/19/99	Initial Revision
 *
 ***********************************************************************/
@method IDialupProcessClass, MSG_IDP_STAY_CONNECTED
{
    SendPing();
    @send IDIdleNotifyDialog::MSG_GEN_SET_NOT_USABLE(VUM_NOW);
    @send IDialupPrimary::MSG_GEN_DISPLAY_SET_MINIMIZED();
}


/***********************************************************************
 *	MSG_IDP_IDLE_DISCONNECTED for IDialupProcessClass
 ***********************************************************************
 * SYNOPSIS:     disconnect after timeout
 *
 * PARAMETERS:
 *
 * SIDE EFFECTS:
 *
 * STRATEGY:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	mzhu	04/19/99	Initial Revision
 *
 ***********************************************************************/
@method IDialupProcessClass, MSG_IDP_IDLE_DISCONNECT
{
    disconnectRequested = TRUE;	/* causes notify handler to send quit */
    @send process::MSG_IDP_DISCONNECT();
}


/********************************************************************
 *              MSG_NOTIFY_APP_STARTED
 ********************************************************************
 * SYNOPSIS:     Get notified when the any application starts
 * PARAMETERS:   MemHandle appStarted (process handle to new app)
 * RETURNS:
 * SIDE EFFECTS: none
 * STRATEGY:
 * REVISION HISTORY:
 *      Name   Date             Description
 *      ----   ----             -----------
 *      JimG  9/13/99          Initial Version
 *******************************************************************/
@method IDialupProcessClass, MSG_NOTIFY_APP_STARTED
{
    Boolean iAppWasRunning = iAppRunning;

    // We used to use the passed core block to see if that particular
    // app was an iApp, but then realized that this message can get
    // QUEUED if the process thread is, say, making the connection.
    // When this message was finally handled, the application could have
    // been closed, the block handle could be free, and MemLock would
    // crash. -Dave 1/14/2000

    // Simply check to see if an iApp is running and flag that state.
    iAppRunning = IAppRunning();

    // If no iApps were running and now at least one is, dismiss the
    // "last internet app" dialog, since it's no longer valid.

    if (!iAppWasRunning && iAppRunning)
    {
        if((@call IDLIANotifyDialog::MSG_VIS_GET_ATTRS()) & VA_REALIZED )
    	    @send IDLIANotifyDialog::MSG_GEN_INTERACTION_ACTIVATE_COMMAND(IC_DISMISS);
    }
}

/********************************************************************
 *              MSG_NOTIFY_APP_EXITED
 ********************************************************************
 * SYNOPSIS:     Get notified when the caller application quits
 * PARAMETERS:   MemHandle appExited (FREE'd process handle to dead app)
 * RETURNS:
 * SIDE EFFECTS: none
 * STRATEGY:
 * REVISION HISTORY:
 *      Name   Date             Description
 *      ----   ----             -----------
 *      mzhu  1/28/99          Initial Version
 *******************************************************************/
@method IDialupProcessClass, MSG_NOTIFY_APP_EXITED
{
  TCHAR name[NAME_LEN];
  word datalen = NAME_LEN;
  Boolean iAppWasRunning = iAppRunning;

  if(AccessPointGetStringPropertyBufferDirect(currentAccpnt, (char*)APSP_NAME, name, (int*) &datalen))
    AccessPointGetStringPropertyBufferDirect(currentAccpnt, (char*)APSP_PHONE, name, (int*) &datalen);

  iAppRunning = IAppRunning();

  // If an iApp was running and there are now no longer any iApp's running,
  // then put up the dialing asking the user if s/he wants to bail.
  //   (oh, yeah, if the connection is OPEN, that is.)
  if(pppStatus == PPP_STATUS_OPEN && iAppWasRunning && !iAppRunning)
    {
      // Reset the idle time to now to disconnect after the delay timeout.
  	  idleTime = (TimerGetCount() - startTime) / 60;

      if (UserGetDefaultUILevel() != UIIL_INTRODUCTORY)
      {
	  /* In the AUI, raise the dialog. */

	  // Dismiss the idle notify dialog before raising the last internet app
	  // dialog. -dhunter 1/14/2000
	  if((@call IDIdleNotifyDialog::MSG_VIS_GET_ATTRS()) & VA_REALIZED )
          {
	      @send IDIdleNotifyDialog::MSG_GEN_INTERACTION_ACTIVATE_COMMAND(IC_DISMISS);
              @send IDIdleNotifyDialog::MSG_GEN_SET_NOT_USABLE(VUM_NOW);
          }

	  MemLock(OptrToHandle(@lastIAppStr));

	  @call IDLIANotifyText::MSG_VIS_TEXT_REPLACE_ALL_PTR(LMemDeref(@lastIAppStr), 0);
	  @call IDLIANotifyText::MSG_VIS_TEXT_APPEND_PTR(_TEXT("\""), 0);
	  @call IDLIANotifyText::MSG_VIS_TEXT_APPEND_PTR(name, datalen);
	  @call IDLIANotifyText::MSG_VIS_TEXT_APPEND_PTR(_TEXT("\""), 0);
	  @call IDLIANotifyText::MSG_VIS_TEXT_APPEND_PTR(_TEXT("?"), 0);

	  MemUnlock(OptrToHandle(@lastIAppStr));

	  @call IDLIANotifyDialog::MSG_GEN_INTERACTION_INITIATE();
	  @call IDLIANotifyDialog::MSG_GEN_BRING_TO_TOP();
	  @call IDialupApp::MSG_GEN_BRING_TO_TOP();
      }
      else
      {
	  /* In the CUI, don't raise the dialog.  Instead, set a flag so we can
	     stealthily disconnect after the delay timeout. */
	  bStealthLIAFlag = TRUE;
      }
    }
}


/********************************************************************
 *              MSG_META_KBD_CHAR
 ********************************************************************
 * SYNOPSIS:     For the IPTextClass, only allow a valid IP address
 *		 to be entered.  Can be incomplete, but any characters
 *		 entered must consitute a valid IP address.
 * PARAMETERS:
 * RETURNS:
 * SIDE EFFECTS: none
 * STRATEGY:
 * REVISION HISTORY:
 *      Name   Date             Description
 *      ----   ----             -----------
 *      JimG  8/24/99          Initial Version
 *******************************************************************/
@method IDialupIPTextClass, MSG_META_KBD_CHAR
{
    byte cset = ((character & 0xff00) >> 8);
    byte chval = character & 0xff;
    Boolean passUp = FALSE;

    if ( cset == CS_BSW )
    {
@ifdef DO_DBCS  /* checking cset=CS_BSW still works for DBCS */
	if (chval == '.' || (chval >= C_DIGIT_ZERO && chval <= C_DIGIT_NINE))
@else
	if (chval == '.' || (chval >= C_ZERO && chval <= C_NINE))
@endif
	        passUp = TRUE;
    }

    else
	passUp = TRUE;

    if ( passUp )
	@callsuper();

    /* If we can't pass up to super, then sound an error for keydown. */
    else if ( flags & CF_FIRST_PRESS )
	UserStandardSound( SST_NO_INPUT );
}

/***********************************************************************
 *	MSG_IDP_FIELD_CHANGE_CONFIRM for IDialupProcessClass
 ***********************************************************************
 * SYNOPSIS:     Handle result of standard dialog to confirm field change.
 *
 * PARAMETERS:
 *
 * SIDE EFFECTS:
 *
 * STRATEGY:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	JimG	08/26/99	Initial Revision
 *
 ***********************************************************************/
@method IDialupProcessClass, MSG_IDP_FIELD_CHANGE_CONFIRM
{
    // User wants to close down the connection and allow the field change.
    // So set the flag so that the field change complete will be sent
    // once the connection is closed and force the disconnect.
    //
    if ( response == IC_YES )
    {
	sendFieldChangeConfirm = TRUE;
	@send IDialupPrimary::MSG_GEN_DISPLAY_SET_NOT_MINIMIZED();
	@call process::MSG_IDP_DISCONNECT();
    }

    // Otherwise, blow off the field change.
    //
    else
	UserConfirmFieldChange( CFCT_CONFIRM_COMPLETE, (word)FALSE );
}

@method IDialupProcessClass, MSG_IDP_EDIT_TYPE_MODIFIED
{
	@call oself::MSG_IDP_EDIT_TYPE_UPDATE() ;
}

@method IDialupProcessClass, MSG_IDP_EDIT_TYPE_UPDATE
{
	/* TBD */
	word type = @call IDEditConnectionType::MSG_GEN_ITEM_GROUP_GET_SELECTION() ;
	if (type == NET_TYPE_PPP)
        {
		@call IDEditUserName::MSG_GEN_SET_USABLE(VUM_DELAYED_VIA_APP_QUEUE) ;
		@call IDEditPassword::MSG_GEN_SET_USABLE(VUM_DELAYED_VIA_APP_QUEUE) ;
		@call IDEditPhoneNumber::MSG_GEN_SET_USABLE(VUM_DELAYED_VIA_APP_QUEUE) ;
		@call IDEditDialingOptionsGroup::MSG_GEN_SET_USABLE(VUM_DELAYED_VIA_APP_QUEUE) ;
		@call IDEditUserName::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_APP_QUEUE) ;
		@call IDEditPassword::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_APP_QUEUE) ;
		@call IDEditPhoneNumber::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_APP_QUEUE) ;
		@call IDEditDialingOptionsGroup::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_APP_QUEUE) ;
	}
        else
        {
		@call IDEditUserName::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE) ;
		@call IDEditPassword::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE) ;
		@call IDEditPhoneNumber::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE) ;
		@call IDEditDialingOptionsGroup::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE) ;
		@call IDEditUserName::MSG_GEN_SET_NOT_USABLE(VUM_DELAYED_VIA_APP_QUEUE) ;
		@call IDEditPassword::MSG_GEN_SET_NOT_USABLE(VUM_DELAYED_VIA_APP_QUEUE) ;
		@call IDEditPhoneNumber::MSG_GEN_SET_NOT_USABLE(VUM_DELAYED_VIA_APP_QUEUE) ;
		@call IDEditDialingOptionsGroup::MSG_GEN_SET_NOT_USABLE(VUM_DELAYED_VIA_APP_QUEUE) ;
	}
    IDialupUpdateEditOKButton();
}


/***********************************************************************
 *	MSG_IDP_CONNECTION_LIST_MONIKER_QUERY for IDialupAppClass
 ***********************************************************************
 * SYNOPSIS:     Edit the current Network Connection setting.
 *
 * PARAMETERS:   void (optr list, word item)
 *
 * SIDE EFFECTS:
 *
 * STRATEGY:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	mzhu	11/23/98	Initial Revision
 *
 ***********************************************************************/
@method IDialupProcessClass, MSG_IDP_CONNECTION_LIST_MONIKER_QUERY
{
  word *id, datalen;
  TCHAR name[MAX_TEXT_LEN];
  TCHAR *aas;

  if (connectionHandle) {

      MemLock(connectionHandle);

      id = ChunkArrayElementToPtrHandles(connectionHandle, connectionChunk, item, &datalen);

      datalen = MAX_TEXT_LEN;
      memset(name, 0, sizeof(TCHAR)*MAX_TEXT_LEN);

      if(AccessPointGetStringPropertyBufferDirect(*id, (char*)APSP_NAME, name, (int*) &datalen))
      {
        AccessPointGetStringPropertyBufferDirect(*id, (char*)APSP_PHONE, name, (int*) &datalen);
      }

      if (*id == (word) G_activeAccpnt)
      {
        MemLock(OptrToHandle(@activeAppendStr));
        aas = LMemDeref(@activeAppendStr);
        strcat(name, aas);
        MemUnlock(OptrToHandle(@activeAppendStr));
      }

      if(name && datalen)
      {
        @call list::MSG_GEN_DYNAMIC_LIST_REPLACE_ITEM_TEXT(item, name);
      }

      MemUnlock(connectionHandle);
  }

}


/***********************************************************************
 *	MSG_IDP_CONNECTION_LIST_APPLY for IDialupAppClass
 ***********************************************************************
 * SYNOPSIS:     Edit the current Network Connection setting.
 *
 * PARAMETERS:
 *    	    word selection = cx,
 *	    word numSelections = bp,
 *	    GenItemGroupStateFlags stateFlags = dl
 *
 * SIDE EFFECTS:
 *
 * STRATEGY:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	mzhu	11/23/98	Initial Revision
 *
 ***********************************************************************/
@method IDialupProcessClass, MSG_IDP_CONNECTION_LIST_APPLY
{
  word *id, datalen;

  // now display the new selection
  MemLock(connectionHandle);

  id = ChunkArrayElementToPtrHandles(connectionHandle, connectionChunk, selection, &datalen);

  currentAccpnt = *id;

  MemUnlock(connectionHandle);

  @send process::MSG_IDP_UPDATE_UI_FOR_SELECTED_ACCPNT();
}


