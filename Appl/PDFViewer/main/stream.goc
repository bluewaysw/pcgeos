//========================================================================
//
// Stream.cc
//
// Copyright 1996 Derek B. Noonburg
//
//========================================================================

#ifdef __GNUC__
#pragma implementation
#endif

@include "pdfvu.goh"

// #include <string.h>
//#include "config.h"
@include "obj.goh"
@include "stream.goh"
@include "ccitt.h"


//------------------------------------------------------------------------

#define headerSearchSize 1024	// read this many bytes at beginning of
				//   file to look for '%PDF'


/*
 * forward decls
*/

Stream *StreamMakeFilter(Stream *str1, char *name, Obj *params, XRef *xref);

void FlateStreamReadSome(Stream *str);
GBool FlateStreamStartBlock(Stream *str);
void FlateStreamLoadFixedCodes(Stream *str);
GBool FlateStreamReadDynamicCodes(Stream *str);
void FlateStreamCompHuffmanCodes(Stream *str, FlateHuffmanTab *tab, long n);
long FlateStreamGetHuffmanCodeWord(Stream *str, FlateHuffmanTab *tab);
long FlateStreamGetCodeWord(Stream *str, long bits);


void ASCIIHexStreamInit(Stream *str, Stream *str1);
void ASCIIHexStreamFree(Stream *str);
void ASCIIHexStreamReset(Stream *str);
long ASCIIHexStreamLookChar(Stream *str);
long ASCIIHexStreamGetChar(Stream *str);

void ASCII85StreamInit(Stream *str, Stream *str1);
void ASCII85StreamFree(Stream *str);
void ASCII85StreamReset(Stream *str);
long ASCII85StreamLookChar(Stream *str);
long ASCII85StreamGetChar(Stream *str);

void RunLengthStreamInit(Stream *str, Stream *str1);
void RunLengthStreamFree(Stream *str);
void RunLengthStreamReset(Stream *str);
GBool RunLengthStreamFillBuf(Stream *str);
long RunLengthStreamGetChar(Stream *str);
long RunLengthStreamLookChar(Stream *str);

void CCITTFaxStreamInit(Stream *str, Stream *str1, long encoding1, GBool byteAlign1,
			       long columns1, long rows1, GBool black1);
void CCITTFaxStreamFree(Stream *str);
void CCITTFaxStreamReset(Stream *str);
long CCITTFaxStreamLookChar(Stream *str);
long CCITTFaxStreamGetChar(Stream *str);
void CCITTFaxStreamEatBits(Stream *str, short bits);
short CCITTFaxStreamGetTwoDimCode(Stream *str);
short CCITTFaxStreamGetWhiteCode(Stream *str);
short CCITTFaxStreamGetBlackCode(Stream *str);
short CCITTFaxStreamLook13Bits(Stream *str);

void DCTStreamInit(Stream *str, Stream *str1);
void DCTStreamFree(Stream *str);
void DCTStreamReset(Stream *str);
long DCTStreamLookChar(Stream *str);
long DCTStreamGetChar(Stream *str);
void DCTStreamRestart(Stream *str);
GBool DCTStreamReadMCURow(Stream *str);
GBool DCTStreamReadDataUnit(Stream *str, DCTHuffTable *dcHuffTable,
			      DCTHuffTable *acHuffTable,
			      Guchar *quantTable, long *prevDC,
			      Guchar *data);
long DCTStreamReadHuffSym(Stream *str, DCTHuffTable *table);
long DCTStreamReadAmp(Stream *str, long size);
long DCTStreamReadBit(Stream *str);
GBool DCTStreamReadHeader(Stream *str);
GBool DCTStreamReadFrameInfo(Stream *str);
GBool DCTStreamReadScanInfo(Stream *str);
GBool DCTStreamReadQuantTables(Stream *str);
GBool DCTStreamReadHuffmanTables(Stream *str);
GBool DCTStreamReadRestartInterval(Stream *str);
GBool DCTStreamReadAdobeMarker(Stream *str);
GBool DCTStreamReadTrailer(Stream *str);
long DCTStreamReadMarker(Stream *str);
long DCTStreamRead16(Stream *str);

Dict *SubStreamGetDict(Stream *str);


//------------------------------------------------------------------------
// Stream (base class)
//------------------------------------------------------------------------

void StreamInit(Stream *stream) {

  stream->kind = strWeird;
  stream->str = NULL;

  stream->ref = 1;
  stream->predictor = 1;
  stream->rawLine = NULL;
  stream->pixLine = NULL;
}


void StreamFree(Stream *str) {

    gfree(str->rawLine);
    gfree(str->pixLine);

    switch (str->kind) {
/*
 * File Streams don't wrap other streams, so we return here and skip freeing
 * the stream pointed to by str->str.
 */
    case strFile:
	FStreamFree(str);
	return;
/*
 * SubStreams are tacked onto streams (for example, to read an inline image)
 * then freed without freeing the base stream.  So again, we return instead
 * of going on to free the base stream at str->str.
*/
    case strSubStream:
	SubStreamFree(str);
	return;
/*
 * Other streams wrap other streams that must also be freed; use "break"
 * instead of "return".
 */
    case strLZW:
	LZWStreamFree(str);
	break;

    case strFlate:
	FlateStreamFree(str);
	break;

    case strDCT:
	DCTStreamFree(str);
	break;

    case strASCIIHex:
	ASCIIHexStreamFree(str);
	break;

    case strASCII85:
	ASCII85StreamFree(str);
	break;

    case strRunLength:
	RunLengthStreamFree(str);
	break;

    case strCCITTFax:
	CCITTFaxStreamFree(str);
	break;

    case strEOF:
	EOFStreamFree(str);
	break;
    }

    StreamFree(str->str);
    gfree(str->str);
}

  long StreamIncRef(Stream *stream) { return ++stream->ref; }
  long StreamDecRef(Stream *stream) { return --stream->ref; }

FileHandle StreamGetFile(Stream *str) {

    if (str->kind == strFile)
	return FStreamGetFile(str);

    return StreamGetFile(str->str);
}

long StreamGetChar(Stream *str) {

    switch (str->kind) {

    case strFile:
	return FStreamGetChar(str);

    case strSubStream:
	return StreamGetChar(str->str);  /* no special processing for substream wrapper */

    case strLZW:
	return LZWStreamGetChar(str);

    case strFlate:
	return FlateStreamGetChar(str);

    case strDCT:
	return DCTStreamGetChar(str);

    case strASCIIHex:
	return ASCIIHexStreamGetChar(str);

    case strASCII85:
	return ASCII85StreamGetChar(str);

    case strRunLength:
	return RunLengthStreamGetChar(str);

    case strCCITTFax:
	return CCITTFaxStreamGetChar(str);

    case strEOF:
	return EOFStreamGetChar(str);
    }

    return EOF;
}

long StreamLookChar(Stream *str) {

    switch (str->kind) {

    case strFile:
	return FStreamLookChar(str);

    case strSubStream:
	return StreamLookChar(str->str);  /* no special processing for substream */

    case strLZW:
	return LZWStreamLookChar(str);

    case strFlate:
	return FlateStreamLookChar(str);

    case strDCT:
	return DCTStreamLookChar(str);

    case strASCIIHex:
	return ASCIIHexStreamLookChar(str);

    case strASCII85:
	return ASCII85StreamLookChar(str);

    case strRunLength:
	return RunLengthStreamLookChar(str);

    case strCCITTFax:
	return CCITTFaxStreamLookChar(str);

    case strEOF:
	return EOFStreamLookChar(str);
    }

    return EOF;
}

long FlateStreamGetChar(Stream *str) {
  FlateData *pflate = str->u.flate;
  long c;
  Guchar *buf = MemLock(pflate->bufhan);

  while (pflate->remain == 0) {
    if (pflate->endOfBlock && pflate->eof)
    {
      MemUnlock(pflate->bufhan);
      return EOF;
    }
    FlateStreamReadSome(str);
  }
  c = buf[pflate->index];
  pflate->index = (pflate->index + 1) & flateMask;
  --pflate->remain;
  MemUnlock(pflate->bufhan);
  return c;
}

Dict *StreamGetDict(Stream *str) {

    switch (str->kind) {
    case strFile:
	return FStreamGetDict(str);

    case strSubStream:
	return SubStreamGetDict(str);
    }

    return StreamGetDict(str->str);
}


void StreamReset(Stream *str) {

    switch (str->kind) {

    case strFile:
	FStreamReset(str);
	break;

    case strSubStream:
	SubStreamReset(str);
	break;

    case strLZW:
	LZWStreamReset(str);
	break;

    case strFlate:
	FlateStreamReset(str);
	break;

    case strDCT:
	DCTStreamReset(str);
	break;

    case strASCIIHex:
	ASCIIHexStreamReset(str);
	break;

    case strASCII85:
	ASCII85StreamReset(str);
	break;

    case strRunLength:
	RunLengthStreamReset(str);
	break;

    case strCCITTFax:
	CCITTFaxStreamReset(str);
	break;

    case strEOF:
	EOFStreamReset(str);
	break;

    default:
	EC_WARNING(-1);
	StreamReset(str->str);
    }
}

/* 
 * Gets the length of the base file stream
*/
long StreamGetLength(Stream *str) {

    if (str->kind == strFile) 
	return FStreamGetLength(str);

    return StreamGetLength(str->str);
}

long StreamGetPos(Stream *str) { 

    if (str->kind == strFile) 
	return FStreamGetPos(str);

    return StreamGetPos(str->str);
}

void StreamSetPos(Stream *str, long pos1) {

    if (str->kind == strFile)
	FStreamSetPos(str, pos1);
    else
	StreamSetPos(str->str, pos1);
}

GBool StreamIsBinary(Stream *str, GBool last) {
/* XXX: fill this in, if it matters */

    return gTrue;
}

void StreamGetLine(Stream *str, char *buf, long size) {
  long i;
  long c;

  if (StreamLookChar(str) == EOF) {
      buf[0] = '\0';
      return;
  }
  for (i = 0; i < size - 1; ++i) {
    c = StreamGetChar(str);
    if (c == EOF || c == '\n')
      break;
    if (c == '\r') {
      if ((c = StreamLookChar(str)) == '\n')
	StreamGetChar(str);
      break;
    }
    buf[i] = c;
  }
  buf[i] = '\0';
}

void StreamResetImage(Stream *stream, short width1, short nComps1, short nBits1) {

  StreamReset(stream);

  if (stream->predictor > 1 &&
      (width1 != stream->width || nComps1 != stream->nComps || nBits1 != stream->nBits))
      EC_WARNING(-1);
//    error(-1, "Mismatched image parameters in predictor");
  stream->width = width1;
  stream->nComps = nComps1;
  stream->nBits = nBits1;
  stream->nVals = (long)(stream->width) * stream->nComps;
  stream->pixBytes = ((long)(stream->nComps) * stream->nBits + 7) >> 3;
  stream->rowBytes = (stream->nVals * stream->nBits + 7) >> 3;
  stream->rawLine = (Guchar *)grealloc(stream->rawLine, stream->rowBytes + stream->pixBytes);
  memset(stream->rawLine, 0, stream->rowBytes);
  stream->pixLine = (Guchar *)grealloc(stream->pixLine, 
				       ((stream->nVals + 7) & ~7) * sizeof(Guchar));
  stream->pixIdx = stream->nVals;
}

GBool StreamGetImagePixel(Stream *this, Guchar *pix) {
  long curPred;
  long left, up, upLeft, p, pa, pb, pc;
  Guchar upLeftBuf[4];
  Gulong buf, bitMask;
  long c;
  long bits;
  short i, j;

  // read an image line
  if (this->pixIdx >= this->nVals) {

    // get PNG optimum predictor number
    if (this->predictor == 15) {
      if ((curPred = StreamGetChar(this)) == EOF)
	return EOF;
      curPred += 10;
    } else {
      curPred = this->predictor;
    }

    // read the raw line, apply byte predictor
    upLeftBuf[0] = upLeftBuf[1] = upLeftBuf[2] = upLeftBuf[3] = 0;
    for (i = 0; i < this->rowBytes; ++i) {
      upLeftBuf[3] = upLeftBuf[2];
      upLeftBuf[2] = upLeftBuf[1];
      upLeftBuf[1] = upLeftBuf[0];
      upLeftBuf[0] = this->rawLine[this->pixBytes+i];
      if ((c = StreamGetChar(this)) == EOF)
	return EOF;
      switch (curPred) {
      case 11:			// PNG sub
	this->rawLine[this->pixBytes+i] = this->rawLine[i] + (Guchar)c;
	break;
      case 12:			// PNG up
	this->rawLine[this->pixBytes+i] = this->rawLine[this->pixBytes+i] + (Guchar)c;
	break;
      case 13:			// PNG average
	this->rawLine[this->pixBytes+i] = 
	    ((this->rawLine[i] + this->rawLine[this->pixBytes+i]) >> 1) +
	    (Guchar)c;
	break;
      case 14:			// PNG Paeth
	left = this->rawLine[i];
	up = this->rawLine[this->pixBytes+i];
	upLeft = upLeftBuf[this->pixBytes];
	p = left + up - upLeft;
	if ((pa = p - left) < 0)
	  pa = -pa;
	if ((pb = p - up) < 0)
	  pb = -pb;
	if ((pc = p - upLeft) < 0)
	  pc = -pc;
	if (pa <= pb && pa <= pc)
	  this->rawLine[this->pixBytes+i] = pa + (Guchar)c;
	else if (pb <= pc)
	  this->rawLine[this->pixBytes+i] = pb + (Guchar)c;
	else
	  this->rawLine[this->pixBytes+i] = pc + (Guchar)c;
	break;
      case 10:			// PNG none
      default:			// no predictor or TIFF predictor
	this->rawLine[this->pixBytes+i] = (Guchar)c;
	break;
      }
    }

    // convert into pixels, apply component predictor
    if (this->predictor == 2) {
      if (this->nBits == 1) {
	for (i = 0, j = this->pixBytes; i < this->nVals; i += 8, ++j) {
	  c = this->rawLine[j];
	  this->pixLine[i+0] = (Guchar)((this->pixLine[i+0] + (c >> 7)) & 1);
	  this->pixLine[i+1] = (Guchar)((this->pixLine[i+1] + (c >> 6)) & 1);
	  this->pixLine[i+2] = (Guchar)((this->pixLine[i+2] + (c >> 5)) & 1);
	  this->pixLine[i+3] = (Guchar)((this->pixLine[i+3] + (c >> 4)) & 1);
	  this->pixLine[i+4] = (Guchar)((this->pixLine[i+4] + (c >> 3)) & 1);
	  this->pixLine[i+5] = (Guchar)((this->pixLine[i+5] + (c >> 2)) & 1);
	  this->pixLine[i+6] = (Guchar)((this->pixLine[i+6] + (c >> 1)) & 1);
	  this->pixLine[i+7] = (Guchar)((this->pixLine[i+7] + c) & 1);
	}
      } else if (this->nBits == 8) {
	for (i = 0, j = this->pixBytes; i < this->nVals; ++i, ++j)
	  this->pixLine[i] = this->pixLine[i] + this->rawLine[j];
      } else {
	bitMask = (1 << this->nBits) - 1;
	buf = 0;
	bits = 0;
	j = this->pixBytes;
	for (i = 0; i < this->nVals; ++i) {
	  if (bits < this->nBits) {
	    buf = (buf << 8) | (this->rawLine[j++] & 0xff);
	    bits += 8;
	  }
	  this->pixLine[i] = (Guchar)((this->pixLine[i] +
				 (buf >> (bits - this->nBits))) & bitMask);
	  bits -= this->nBits;
	}
      }
    } else {
      if (this->nBits == 1) {
	for (i = 0, j = this->pixBytes; i < this->nVals; i += 8, ++j) {
	  c = this->rawLine[j];
	  this->pixLine[i+0] = (Guchar)((c >> 7) & 1);
	  this->pixLine[i+1] = (Guchar)((c >> 6) & 1);
	  this->pixLine[i+2] = (Guchar)((c >> 5) & 1);
	  this->pixLine[i+3] = (Guchar)((c >> 4) & 1);
	  this->pixLine[i+4] = (Guchar)((c >> 3) & 1);
	  this->pixLine[i+5] = (Guchar)((c >> 2) & 1);
	  this->pixLine[i+6] = (Guchar)((c >> 1) & 1);
	  this->pixLine[i+7] = (Guchar)(c & 1);
	}
      } else if (this->nBits == 8) {
	for (i = 0, j = this->pixBytes; i < this->nVals; ++i, ++j)
	  this->pixLine[i] = this->rawLine[j];
      } else {
	bitMask = (1 << this->nBits) - 1;
	buf = 0;
	bits = 0;
	j = this->pixBytes;
	for (i = 0; i < this->nVals; ++i) {
	  if (bits < this->nBits) {
	    buf = (buf << 8) | (this->rawLine[j++] & 0xff);
	    bits += 8;
	  }
	  this->pixLine[i] = (Guchar)((buf >> (bits - this->nBits)) & bitMask);
	  bits -= this->nBits;
	}
      }
    }

    // read from start of line
    this->pixIdx = 0;
  }

  for (i = 0; i < this->nComps; ++i)
    pix[i] = this->pixLine[this->pixIdx++];
  return gTrue;
}

#if 0

void Stream::skipImageLine() {
  int n, i;

  n = (nVals * nBits + 7) / 8;
  for (i = 0; i < n; ++i)
    getChar();
  pixIdx = nVals;
}

void Stream::setPos(int pos) {
  error(-1, "Internal: called setPos() on non-FileStream");
}

GString *Stream::getPSFilter(char *indent) {
  return new GString();
}

#endif /* 0 */

Stream *StreamAddFilters(Stream *str1, Obj *dict, XRef *xref) {
  Obj obj, obj2;
  Obj params, params2;
  Stream *str;
  short i;

  str = str1;
  ObjDictLookup(dict, "Filter", &obj, xref);
  if (isNull(&obj)) {
    ObjFree(&obj);
    ObjDictLookup(dict, "F", &obj, xref);
  }
  ObjDictLookup(dict, "DecodeParms", &params, xref);
  if (isNull(&params)) {
    ObjFree(&params);
    ObjDictLookup(dict, "DP", &params, xref);
  }
  if (isName(&obj)) {
    str = StreamMakeFilter(str, getName(&obj), &params, xref);
  } else if (isArray(&obj)) {

    for (i = 0; i < ObjArrayGetLength(&obj); ++i) {
      ObjArrayGet(&obj, i, &obj2, xref);
      if (isArray(&params))
	ObjArrayGet(&params, i, &params2, xref);
      else
	initNull(&params2);
      if (isName(&obj2)) {
	str = StreamMakeFilter(str, getName(&obj2), &params2, xref);
      } else {
	  EC_WARNING(-1);
//	error(getPos(), "Bad filter name");
	str = gmalloc( sizeof(Stream) );
	EOFStreamInit(str, str1);
      }
      ObjFree(&obj2);
      ObjFree(&params2);
    }
  } else if (!isNull(&obj)) {
      EC_WARNING(-1);
//    error(getPos(), "Bad 'Filter' attribute in stream");
  }
  ObjFree(&obj);
  ObjFree(&params);

  return str;
}

Stream *StreamMakeFilter(Stream *str1, char *name, Obj *params, XRef *xref) {
  long pred;			// parameters
  long colors;
  long bits;
  long early;
  long encoding;
  GBool byteAlign;
  GBool black;
  long columns, rows;
  Obj obj;

  Stream *str;

  str = gmalloc( sizeof(Stream) );

  if (!strcmp(name, "ASCIIHexDecode") || !strcmp(name, "AHx")) {
    ASCIIHexStreamInit(str, str1);
  } else if (!strcmp(name, "ASCII85Decode") || !strcmp(name, "A85")) {
    ASCII85StreamInit(str, str1);
  } else if (!strcmp(name, "LZWDecode") || !strcmp(name, "LZW")) {
    pred = 1;
    columns = 1;
    colors = 1;
    bits = 8;
    early = 1;
    if (isDict(params)) {
      ObjDictLookup(params, "Predictor", &obj, xref);
      if (isInt(&obj))
	pred = getInt(&obj);
      ObjFree(&obj);
      ObjDictLookup(params, "Columns", &obj, xref);
      if (isInt(&obj))
	columns = getInt(&obj);
      ObjFree(&obj);
      ObjDictLookup(params, "Colors", &obj, xref);
      if (isInt(&obj))
	colors = getInt(&obj);
      ObjFree(&obj);
      ObjDictLookup(params, "BitsPerComponent", &obj, xref);
      if (isInt(&obj))
	bits = getInt(&obj);
      ObjFree(&obj);
      ObjDictLookup(params, "EarlyChange", &obj, xref);
      if (isInt(&obj))
	early = getInt(&obj);
      ObjFree(&obj);
    }
    LZWStreamInit(str, str1, pred, columns, colors, bits, early);
  } else if (!strcmp(name, "RunLengthDecode") || !strcmp(name, "RL")) {
    RunLengthStreamInit(str, str1);
  } else if (!strcmp(name, "CCITTFaxDecode") || !strcmp(name, "CCF")) {
    encoding = 0;
    byteAlign = gFalse;
    columns = 1728;
    rows = 0;
    black = gFalse;
    if (isDict(params)) {
      ObjDictLookup(params, "K", &obj, xref);
      if (isInt(&obj))
	encoding = getInt(&obj);
      ObjFree(&obj);
      ObjDictLookup(params, "EncodedByteAlign", &obj, xref);
      if (isBool(&obj))
	byteAlign = getBool(&obj);
      ObjFree(&obj);
      ObjDictLookup(params, "Columns", &obj, xref);
      if (isInt(&obj))
	columns = getInt(&obj);
      ObjFree(&obj);
      ObjDictLookup(params, "Rows", &obj, xref);
      if (isInt(&obj))
	rows = getInt(&obj);
      ObjFree(&obj);
      ObjDictLookup(params, "BlackIs1", &obj, xref);
      if (isBool(&obj))
	black = getBool(&obj);
      ObjFree(&obj);
    }
    CCITTFaxStreamInit(str, str1, encoding, byteAlign, columns, rows, black);
  } else if (!strcmp(name, "DCTDecode") || !strcmp(name, "DCT")) {
    DCTStreamInit(str, str1);
  } else if (!strcmp(name, "FlateDecode") || !strcmp(name, "Fl")) {
    pred = 1;
    columns = 1;
    colors = 1;
    bits = 8;
    if (isDict(params)) {
      ObjDictLookup(params, "Predictor", &obj, xref);
      if (isInt(&obj))
	pred = getInt(&obj);
      ObjFree(&obj);
      ObjDictLookup(params, "Columns", &obj, xref);
      if (isInt(&obj))
	columns = getInt(&obj);
      ObjFree(&obj);
      ObjDictLookup(params, "Colors", &obj, xref);
      if (isInt(&obj))
	colors = getInt(&obj);
      ObjFree(&obj);
      ObjDictLookup(params, "BitsPerComponent", &obj, xref);
      if (isInt(&obj))
	bits = getInt(&obj);
      ObjFree(&obj);
    }
    FlateStreamInit(str, str1, pred, columns, colors, bits);
  } else {
      EC_WARNING(-1);
//    error(getPos(), "Unknown filter '%s'", name);
    EOFStreamInit(str, str1);
  }

  return str;
}

//------------------------------------------------------------------------
// FileStream
//------------------------------------------------------------------------

void FStreamInit(Stream *this, FileHandle f1, long start1, long length1, Obj *dict1) {

    FStream *myfs;

    StreamInit(this);
    this->kind = strFile;

    myfs = this->u.fs = gmalloc( sizeof (FStream) );

    myfs->f = FileDuplicateHandle(f1);

    myfs->start = myfs->bufPos = start1;
    myfs->length = length1;
    myfs->bufPtr = myfs->bufEnd = myfs->buf;
    myfs->savePos = -1;
    ObjCopy(&myfs->dict, dict1);

    FilePos(myfs->f, myfs->bufPos, FILE_POS_START);
}


void FStreamFree(Stream *this) {
    FStream *fs = this->u.fs;

/*
 * Note: FStream shouldn't wrap another stream, so no need to free this->str.
 */

//  if (this->savePos >= 0)
//    FilePos(this->f, this->savePos, FILE_POS_START);

    
    ObjFree(&fs->dict);
    FileClose(fs->f, FALSE);
    gfree(fs);

}

void FStreamReset(Stream *str) {
    FStream *this = str->u.fs;

  this->savePos = FilePos(this->f, 0, FILE_POS_RELATIVE);
  FilePos(this->f, this->start, FILE_POS_START);
  this->bufPtr = this->bufEnd = this->buf;
  this->bufPos = this->start;
}

GBool FStreamFillBuf(Stream *str) {
    FStream *this = str->u.fs;
    word n;

  this->bufPos += this->bufEnd - this->buf;
/*
 * I originally implemented streams using 'FileDuplicateHandle' because I thought each
 * handle would maintain its own independent file position as reads were made.
 * I was wrong.  So, we have to make sure the file is in the correct position:
 */
  FStreamSetPos(str, this->bufPos);

/*  FStreamSetPos takes care of this: */
//  this->bufPtr = this->bufEnd = this->buf;

  if (this->length >= 0 && this->bufPos >= this->start + this->length)
    return gFalse;
  if (this->length >= 0 && this->bufPos + sizeof(this->buf) > this->start + this->length)
    n = this->start + this->length - this->bufPos;
  else
    n = sizeof (this->buf);
  n = FileRead(this->f, this->buf, n, FALSE);
  this->bufEnd = this->buf + n;
  if (this->bufPtr >= this->bufEnd)
    return gFalse;
  return gTrue;
}

void FStreamSetPos(Stream *str, long pos1) {
    FStream *this = str->u.fs;
    long size;

  if (pos1 >= 0) {
    FilePos(this->f, pos1, FILE_POS_START);
    this->bufPos = pos1;
  } else {
    size = FilePos(this->f, 0, FILE_POS_END);
    if (pos1 < -size)
      pos1 = (-size);
    this->bufPos = FilePos(this->f, pos1, FILE_POS_END);
  }
  this->bufPtr = this->bufEnd = this->buf;
}

GBool FStreamCheckHeader(Stream *str) {
    FStream *this = str->u.fs;
    char hdrBuf[headerSearchSize+1];
    char *p;
    gdouble version;
    long i;

  for (i = 0; i < headerSearchSize; ++i)
    hdrBuf[i] = FStreamGetChar(str);
  hdrBuf[headerSearchSize] = '\0';
  for (i = 0; i < headerSearchSize - 5; ++i) {
    if (!strncmp(&hdrBuf[i], "%PDF-", 5))
      break;
  }
  if (i >= headerSearchSize - 5) {
    EC_WARNING(-1);
//    error(-1, "May not be a PDF file (continuing anyway)");
    return gFalse;
  }
  this->start += i;
/*  p = strtok(&hdrBuf[i+5], " \t\n\r");
*/
/*
 * XXX: should check version number, but FloatAsciiToFloat is such a pain...
 */
//  p = &hdrBuf[i+5];
//  version = atof(p);
//  if (!(hdrBuf[i+5] >= '0' && hdrBuf[i+5] <= '9') || version > pdfVersionNum) {
//    error(getPos(), "PDF version %s -- xpdf supports version %s"
//	  " (continuing anyway)", p, pdfVersion);
//    EC_WARNING(-1);
//    return gFalse;
//  }
  return gTrue;
}


long FStreamGetChar(Stream *str) {
    FStream *this = str->u.fs;

    return (this->bufPtr >= this->bufEnd && 
	    !FStreamFillBuf(str)) ? EOF : (*this->bufPtr++ & 0xff); 
}

long FStreamLookChar(Stream *str) {
    FStream *this = str->u.fs;

    return (this->bufPtr >= this->bufEnd && 
	    !FStreamFillBuf(str)) ? EOF : (*this->bufPtr & 0xff); 
}

long FStreamGetLength(Stream *str) {
    return str->u.fs->length;
}

long FStreamGetPos(Stream *str) { 
    FStream *this = str->u.fs;

    return this->bufPos + (this->bufPtr - this->buf); 
}

//  GBool isBinary(GBool last = gTrue) { return last; }
  GBool FStreamIsBinary(Stream *str) { return gTrue; }
//  Stream *getBaseStream() { return this; }
  FileHandle FStreamGetFile(Stream *str) { return str->u.fs->f; }
  Dict *FStreamGetDict(Stream *str) { return getDict(&str->u.fs->dict); }

  // Get position of first byte of stream within the file.
long FStreamGetStart(Stream *str) { return str->u.fs->start; }


//------------------------------------------------------------------------
// SubStream
//------------------------------------------------------------------------

void SubStreamInit(Stream *str, Stream *str1, Obj *dict1) {
  StreamInit(str);
  str->str = str1;

  str->kind = strSubStream;

  ObjCopy(&str->dict, dict1);
  str->eof = gFalse;
}

void SubStreamFree(Stream *str) {
  ObjFree(&str->dict);
}

/*
 * For inline images, we can't reset the stream at str->str; that would
 * force it back to beginning-of-page, I think.  I think it will be safe
 * to not propagate this call to str->str; if I'm wrong, you'll have to 
 * store the underlying stream pos when the substream is init'd, then use
 * that pos to reset/position the stream here.
 */
void SubStreamReset(Stream *str) {
  str->eof = gFalse;
}

Dict *SubStreamGetDict(Stream *str) {
    return getDict(&str->dict);
}

//------------------------------------------------------------------------
// EOFStream
//------------------------------------------------------------------------

void EOFStreamInit(Stream *str, Stream *str2) {
    StreamInit(str);
    str->str = str2;
    str->kind = strEOF;
}

void EOFStreamFree(Stream *str) {
}

void EOFStreamReset(Stream *str) {
}

long EOFStreamGetChar(Stream *str) {
    return EOF;
}

long EOFStreamLookChar(Stream *str) {
    return EOF;
}


//------------------------------------------------------------------------
// ASCIIHexStream
//------------------------------------------------------------------------

#ifdef __BORLANDC__
#pragma codeseg ASCIIHexStream
#endif
#ifdef __WATCOMC__
#pragma code_seg("ASCIIHexStream")
#endif

void ASCIIHexStreamInit(Stream *str, Stream *str1) {
  StreamInit(str);
  str->str = str1;

  str->kind = strASCIIHex;

  str->buf = EOF;
  str->eof = gFalse;
}

void ASCIIHexStreamFree(Stream *str) {
}

void ASCIIHexStreamReset(Stream *str) {

  StreamReset(str->str);
  str->buf = EOF;
  str->eof = gFalse;
}

long ASCIIHexStreamLookChar(Stream *str) {
  long c1, c2, x;

  if (str->buf != EOF)
    return str->buf;
  if (str->eof) {
    str->buf = EOF;
    return EOF;
  }
  do {
    c1 = StreamGetChar(str->str);
  } while (isspace(c1));
  if (c1 == '>') {
    str->eof = gTrue;
    str->buf = EOF;
    return str->buf;
  }
  do {
    c2 = StreamGetChar(str->str);
  } while (isspace(c2));
  if (c2 == '>') {
    str->eof = gTrue;
    c2 = '0';
  }
  if (c1 >= '0' && c1 <= '9') {
    x = (c1 - '0') << 4;
  } else if (c1 >= 'A' && c1 <= 'F') {
    x = (c1 - 'A' + 10) << 4;
  } else if (c1 >= 'a' && c1 <= 'f') {
    x = (c1 - 'a' + 10) << 4;
  } else if (c1 == EOF) {
    str->eof = gTrue;
    x = 0;
  } else {
      EC_WARNING(-1);
//    error(getPos(), "Illegal character <%02x> in ASCIIHex stream", c1);
    x = 0;
  }
  if (c2 >= '0' && c2 <= '9') {
    x += c2 - '0';
  } else if (c2 >= 'A' && c2 <= 'F') {
    x += c2 - 'A' + 10;
  } else if (c2 >= 'a' && c2 <= 'f') {
    x += c2 - 'a' + 10;
  } else if (c2 == EOF) {
    str->eof = gTrue;
    x = 0;
  } else {
      EC_WARNING(-1);
//    error(getPos(), "Illegal character <%02x> in ASCIIHex stream", c2);
  }
  str->buf = x & 0xff;
  return str->buf;
}

long ASCIIHexStreamGetChar(Stream *str) {
    long c = ASCIIHexStreamLookChar(str);
    str->buf = EOF; 
    return c;
}

/*
GString *ASCIIHexStream::getPSFilter(char *indent) {
  GString *s;

  s = str->getPSFilter(indent);
  s->append(indent)->append("/ASCIIHexDecode filter\n");
  return s;
}

GBool ASCIIHexStream::isBinary(GBool last) {
  return str->isBinary(gFalse);
}
*/

//------------------------------------------------------------------------
// ASCII85Stream
//------------------------------------------------------------------------

void ASCII85StreamInit(Stream *str, Stream *str1) {
  StreamInit(str);
  str->str = str1;

  str->kind = strASCII85;
  str->u.a85 = gmalloc( sizeof(ASCII85Data) );

  str->u.a85->index = str->u.a85->n = 0;
  str->eof = gFalse;
}

void ASCII85StreamFree(Stream *str) {
    gfree(str->u.a85);
}

void ASCII85StreamReset(Stream *str) {
  StreamReset(str->str);
  str->u.a85->index = str->u.a85->n = 0;
  str->eof = gFalse;
}

long ASCII85StreamLookChar(Stream *str) {
  short k;
  Gulong t;
  ASCII85Data *p85 = str->u.a85;

  if (p85->index >= p85->n) {
    if (str->eof)
      return EOF;
    p85->index = 0;
    do {
      p85->c[0] = StreamGetChar(str->str);
    } while (p85->c[0] == '\n' || p85->c[0] == '\r');
    if (p85->c[0] == '~' || p85->c[0] == EOF) {
      str->eof = gTrue;
      p85->n = 0;
      return EOF;
    } else if (p85->c[0] == 'z') {
      p85->b[0] = p85->b[1] = p85->b[2] = p85->b[3] = 0;
      p85->n = 4;
    } else {
      for (k = 1; k < 5; ++k) {
	do {
	  p85->c[k] = StreamGetChar(str->str);
	} while (p85->c[k] == '\n' || p85->c[k] == '\r');
	if (p85->c[k] == '~' || p85->c[k] == EOF)
	  break;
      }
      p85->n = k - 1;
      if (k < 5 && (p85->c[k] == '~' || p85->c[k] == EOF)) {
	for (++k; k < 5; ++k)
	  p85->c[k] = 0x21 + 84;
	str->eof = gTrue;
      }
      t = 0;
      for (k = 0; k < 5; ++k)
	t = t * 85 + (p85->c[k] - 0x21);
      for (k = 3; k >= 0; --k) {
	p85->b[k] = (long)(t & 0xff);
	t >>= 8;
      }
    }
  }
  return p85->b[p85->index];
}

long ASCII85StreamGetChar(Stream *str) {
    long ch = ASCII85StreamLookChar(str);
    ++str->u.a85->index; 
    return ch;
}

/*
GString *ASCII85Stream::getPSFilter(char *indent) {
  GString *s;

  s = str->getPSFilter(indent);
  s->append(indent)->append("/ASCII85Decode filter\n");
  return s;
}

GBool ASCII85Stream::isBinary(GBool last) {
  return str->isBinary(gFalse);
}
*/

//------------------------------------------------------------------------
// LZWStream
//------------------------------------------------------------------------

#ifdef __BORLANDC__
#pragma codeseg LZWStream
#endif
#ifdef __WATCOMC__
#pragma code_seg("LZWStream")
#endif

/* code copied from Acorn port of xpdf */

/*
 * forward decls
 */

long LZWStreamGetCode(Stream *str);

/*
 * Code
 */

void LZWStreamInit(Stream *str, Stream *str2, long predictor1, long columns1, long colors1,
		     long bits1, long early1) {
//  str = str1;

  StreamInit(str);
  str->str = str2;

  str->kind = strLZW;
  str->u.lzw = gmalloc( sizeof (LZWData) );

  str->u.lzw->predictor = predictor1;
  str->u.lzw->columns = columns1;
  str->u.lzw->colors = colors1;
  str->u.lzw->bits = bits1;
  str->u.lzw->early = early1;
  str->u.lzw->bufPtr = str->u.lzw->bufEnd = str->u.lzw->buf;
}

void LZWStreamFree(Stream *str) {
//  delete str;
    gfree(str->u.lzw);
}

void LZWStreamReset(Stream *str) {
  long code;
  LZWData *plzw = str->u.lzw;

  StreamReset(str->str);

  plzw->inCodeBits = 9;
  plzw->inputBuf = 0;
  plzw->inputBits = 0;

  for (code = 0; code < 256; code++) {
    plzw->codetab[code] = 0;
    plzw->htab[code] = code;
  }
  plzw->free_ent = 258;

  while ((code = LZWStreamGetCode(str)) == 256);

  if (code == EOF || code == 257) {
    // EOF code
    plzw->bufPtr = plzw->bufEnd = plzw->buf;
    return;
  }

  plzw->buf[0] = plzw->oldcode = plzw->finchar = code;
  plzw->bufPtr = plzw->buf;
  plzw->bufEnd = &plzw->buf[1];
}

long LZWStreamGetCode(Stream *str) {
  long c;
  long code;
  LZWData *plzw = str->u.lzw;

  while (plzw->inputBits < plzw->inCodeBits) {
    if ((c = StreamGetChar(str->str)) == EOF) {
      return EOF;
    }
    //inputBuf = (inputBuf << 8) | (c & 0xff);
    plzw->inputBuf = (plzw->inputBuf << 8) | c; // LJBS 971109 c is al geand met 0xff door getChar
    plzw->inputBits += 8;
  }
  code = (plzw->inputBuf >> (plzw->inputBits - plzw->inCodeBits)) & ((1 << plzw->inCodeBits) - 1);
//  code = (inputBuf >> (inputBits - inCodeBits)); // LJBS 971109 high bits zijn al 0, schuiven is genoeg
  plzw->inputBits -= plzw->inCodeBits;
  return code;
}

GBool LZWStreamFillBuf(Stream *str)
{
  long code, incode, count;
  LZWData *plzw = str->u.lzw;

  code = LZWStreamGetCode(str);
  if (code == 256) {
    // Clear code
#if 1==0
    for (code = 0; code < 256; code++) {
      codetab[code] = 0;
    }
#else
    memset(&plzw->codetab[0], 0, 256 * sizeof(short) ); // LJBS 971109, in een klap clearen
#endif
    plzw->free_ent = 257;
    plzw->inCodeBits = 9;
    while ((code = LZWStreamGetCode(str)) == 256);
  }

  if (code == EOF || code == 257) {
    // EOF code
    plzw->bufPtr = plzw->bufEnd = plzw->buf;
    return gFalse;
  }
  incode = code;

  count = sizeof(plzw->buf);

  // Special case for KwKwK string.
  if (code >= plzw->free_ent) {
    plzw->buf[--count] = plzw->finchar;
    code = plzw->oldcode;
  }

  //
  // Generate output characters
  // traverse tables in reverse order.
  //
  while (code >= 256) {
    plzw->buf[--count] = plzw->htab[code];
    code = plzw->codetab[code];
    if (count == 0) {
	EC_WARNING(-1);
//      error(getPos(), "LZW buffer overflow");
      plzw->bufPtr = plzw->buf;
      plzw->bufEnd = &plzw->buf[sizeof(plzw->buf) - 1];
      return gTrue;
    }
  }
  plzw->buf[--count] = plzw->finchar = plzw->htab[code];

  // Generate the new entry.
  if ((code = plzw->free_ent) < 4096) {
    plzw->codetab[code] = (short) plzw->oldcode;
    plzw->htab[code] = plzw->finchar;
    plzw->free_ent = code + 1;
      // check input code size
      if (plzw->free_ent + plzw->early == 0x200) {
	plzw->inCodeBits = 10;
      } else if (plzw->free_ent + plzw->early == 0x400) {
	plzw->inCodeBits = 11;
      } else if (plzw->free_ent + plzw->early == 0x800) {
	plzw->inCodeBits = 12;
      }
  }


  // Remember previous code.
  plzw->oldcode = incode;

  plzw->bufPtr = &plzw->buf[count];
  plzw->bufEnd = &plzw->buf[sizeof(plzw->buf)];
  return gTrue;
}

long LZWStreamGetChar(Stream *str) { 
    LZWData *plzw = str->u.lzw;

    return (plzw->bufPtr >= plzw->bufEnd && !LZWStreamFillBuf(str)) ? 
	EOF : (*plzw->bufPtr++ & 0xff); 
}

long LZWStreamLookChar(Stream *str) {
    LZWData *plzw = str->u.lzw;

    return (plzw->bufPtr >= plzw->bufEnd && !LZWStreamFillBuf(str)) ? 
	EOF : (*plzw->bufPtr & 0xff); 
}

//GooString *LZWStreamGetPSFilter(Stream *str, char *indent) {
//  GString *s;
//
//  s = str->getPSFilter(indent);
//  s->append(indent)->append("/LZWDecode filter\n");
//  return s;
//}

GBool LZWStreamIsBinary(Stream *str, GBool last) {
  return StreamIsBinary(str->str, gTrue);
}


//------------------------------------------------------------------------
// RunLengthStream
//------------------------------------------------------------------------

#ifdef __BORLANDC__
#pragma codeseg RunLengthStream
#endif
#ifdef __WATCOMC__
#pragma code_seg("RunLengthStream")
#endif

void RunLengthStreamInit(Stream *str, Stream *str1) {
  StreamInit(str);
  str->str = str1;

  str->kind = strRunLength;
  str->u.runLength = gmalloc( sizeof (RunLengthData) );

  str->u.runLength->bufPtr = str->u.runLength->bufEnd = str->u.runLength->buf;
  str->eof = gFalse;
}

void RunLengthStreamFree(Stream *str) {
    gfree(str->u.runLength);
}

void RunLengthStreamReset(Stream *str) {
  StreamReset(str->str);

  str->u.runLength->bufPtr = str->u.runLength->bufEnd = str->u.runLength->buf;
  str->eof = gFalse;
}

/*
GString *RunLengthStream::getPSFilter(char *indent) {
  GString *s;

  s = str->getPSFilter(indent);
  s->append(indent)->append("/RunLengthDecode filter\n");
  return s;
}

GBool RunLengthStream::isBinary(GBool last) {
  return str->isBinary(gTrue);
}
*/

GBool RunLengthStreamFillBuf(Stream *str) {
  RunLengthData *pRun = str->u.runLength;
  long c;
  short n, i;

  if (str->eof)
    return gFalse;
  c = StreamGetChar(str->str);
  if (c == 0x80 || c == EOF) {
    str->eof = gTrue;
    return gFalse;
  }
  if (c < 0x80) {
    n = c + 1;
    for (i = 0; i < n; ++i)
      pRun->buf[i] = (char) StreamGetChar(str->str);
  } else {
    n = 0x101 - c;
    c = StreamGetChar(str->str);
    for (i = 0; i < n; ++i)
      pRun->buf[i] = (char)c;
  }
  pRun->bufPtr = pRun->buf;
  pRun->bufEnd = pRun->buf + n;
  return gTrue;
}

long RunLengthStreamGetChar(Stream *str) { 
    RunLengthData *pRun = str->u.runLength;

    return (pRun->bufPtr >= pRun->bufEnd && !RunLengthStreamFillBuf(str)) ? 
	EOF : (*pRun->bufPtr++ & 0xff); 
}

long RunLengthStreamLookChar(Stream *str) {
    RunLengthData *pRun = str->u.runLength;

    return (pRun->bufPtr >= pRun->bufEnd && !RunLengthStreamFillBuf(str)) ? 
	EOF : (*pRun->bufPtr & 0xff); 
}

//------------------------------------------------------------------------
// CCITTFaxStream
//------------------------------------------------------------------------

#ifdef __BORLANDC__
#pragma codeseg CCITTFaxStream
#endif
#ifdef __WATCOMC__
#pragma code_seg("CCITTFaxStream")
#endif

void CCITTFaxStreamInit(Stream *str, Stream *str1, long encoding1, GBool byteAlign1,
			       long columns1, long rows1, GBool black1) {

    CCITTFaxData *pfax;

  StreamInit(str);
  str->str = str1;

  str->kind = strCCITTFax;
  pfax = str->u.fax = gmalloc( sizeof (CCITTFaxData) );

  pfax->encoding = encoding1;
  pfax->byteAlign = byteAlign1;
  pfax->columns = columns1;
  pfax->rows = rows1;
  pfax->black = black1;
  pfax->refLine = (short *)gmalloc((pfax->columns + 2) * sizeof(short));
  pfax->codingLine = (short *)gmalloc((pfax->columns + 2) * sizeof(short));

  str->eof = gFalse;
  pfax->nextLine2D = pfax->encoding < 0;
  pfax->inputBits = 0;
  pfax->codingLine[0] = 0;
  pfax->codingLine[1] = pfax->refLine[2] = columns1;
  pfax->a0 = 1;

  pfax->buf = EOF;
}

void CCITTFaxStreamFree(Stream *str) {
    gfree(str->u.fax->refLine);
    gfree(str->u.fax->codingLine);
    gfree(str->u.fax);
}

void CCITTFaxStreamReset(Stream *str) {
    CCITTFaxData *pfax = str->u.fax;

    StreamReset(str->str);
    str->eof = gFalse;

  pfax->nextLine2D = pfax->encoding < 0;
  pfax->inputBits = 0;
  if ((CCITTFaxStreamLook13Bits(str) >> 1) == 0x001)
    CCITTFaxStreamEatBits(str, 12);
  pfax->codingLine[0] = 0;
  pfax->codingLine[1] = pfax->refLine[2] = pfax->columns;
  pfax->a0 = 1;
  pfax->buf = EOF;
}

long CCITTFaxStreamLookChar(Stream *str) {
    CCITTFaxData *pfax = str->u.fax;
  long a0New;
  long ret;
  long bits, i;
  short code1, code2, code3;

  // if at eof just return EOF
  if (str->eof && pfax->codingLine[pfax->a0] >= pfax->columns)
    return EOF;

  // read the next row
  if (pfax->codingLine[pfax->a0] >= pfax->columns) {

    // check for end of file
    i = CCITTFaxStreamLook13Bits(str);
    if (i == EOF || (i >> 1) == 0x001) {
      str->eof = gTrue;
      pfax->codingLine[pfax->a0 = 0] = pfax->columns;
      return EOF;
    }

    // 2-D encoding
    if (pfax->nextLine2D) {
      for (i = 0; pfax->codingLine[i] < pfax->columns; ++i)
	pfax->refLine[i] = pfax->codingLine[i];
      pfax->refLine[i] = pfax->refLine[i + 1] = pfax->columns;
      pfax->b1 = 1;
      a0New = pfax->codingLine[pfax->a0 = 0] = 0;
      do {
	code1 = CCITTFaxStreamGetTwoDimCode(str);
	switch (code1) {
	case twoDimPass:
	  if (pfax->refLine[pfax->b1] < pfax->columns) {
	    a0New = pfax->refLine[pfax->b1 + 1];
	    pfax->b1 += 2;
	  }
	  break;
	case twoDimHoriz:
	  if ((pfax->a0 & 1) == 0) {
	    code1 = code2 = 0;
	    do {
	      code1 += code3 = CCITTFaxStreamGetWhiteCode(str);
	    } while (code3 >= 64);
	    do {
	      code2 += code3 = CCITTFaxStreamGetBlackCode(str);
	    } while (code3 >= 64);
	  } else {
	    code1 = code2 = 0;
	    do {
	      code1 += code3 = CCITTFaxStreamGetBlackCode(str);
	    } while (code3 >= 64);
	    do {
	      code2 += code3 = CCITTFaxStreamGetWhiteCode(str);
	    } while (code3 >= 64);
	  }
	  pfax->codingLine[pfax->a0 + 1] = a0New + code1;
	  ++pfax->a0;
	  a0New = pfax->codingLine[pfax->a0 + 1] = pfax->codingLine[pfax->a0] + code2;
	  ++pfax->a0;
	  while (pfax->refLine[pfax->b1] <= pfax->codingLine[pfax->a0] && 
		 pfax->refLine[pfax->b1] < pfax->columns)
	    pfax->b1 += 2;
	  break;
	case twoDimVert0:
	  a0New = pfax->codingLine[++pfax->a0] = pfax->refLine[pfax->b1];
	  if (pfax->refLine[pfax->b1] < pfax->columns) {
	    ++pfax->b1;
	    while (pfax->refLine[pfax->b1] <= pfax->codingLine[pfax->a0] && 
		   pfax->refLine[pfax->b1] < pfax->columns)
	      pfax->b1 += 2;
	  }
	  break;
	case twoDimVertR1:
	  a0New = pfax->codingLine[++pfax->a0] = pfax->refLine[pfax->b1] + 1;
	  if (pfax->refLine[pfax->b1] < pfax->columns) {
	    ++pfax->b1;
	    while (pfax->refLine[pfax->b1] <= pfax->codingLine[pfax->a0] && 
		   pfax->refLine[pfax->b1] < pfax->columns)
	      pfax->b1 += 2;
	  }
	  break;
	case twoDimVertL1:
	  a0New = pfax->codingLine[++pfax->a0] = pfax->refLine[pfax->b1] - 1;
	  --pfax->b1;
	  while (pfax->refLine[pfax->b1] <= pfax->codingLine[pfax->a0] && 
		 pfax->refLine[pfax->b1] < pfax->columns)
	    pfax->b1 += 2;
	  break;
	case twoDimVertR2:
	  a0New = pfax->codingLine[++pfax->a0] = pfax->refLine[pfax->b1] + 2;
	  if (pfax->refLine[pfax->b1] < pfax->columns) {
	    ++pfax->b1;
	    while (pfax->refLine[pfax->b1] <= pfax->codingLine[pfax->a0] && 
		   pfax->refLine[pfax->b1] < pfax->columns)
	      pfax->b1 += 2;
	  }
	  break;
	case twoDimVertL2:
	  a0New = pfax->codingLine[++pfax->a0] = pfax->refLine[pfax->b1] - 2;
	  --pfax->b1;
	  while (pfax->refLine[pfax->b1] <= pfax->codingLine[pfax->a0] && 
		 pfax->refLine[pfax->b1] < pfax->columns)
	    pfax->b1 += 2;
	  break;
	case twoDimVertR3:
	  a0New = pfax->codingLine[++pfax->a0] = pfax->refLine[pfax->b1] + 3;
	  if (pfax->refLine[pfax->b1] < pfax->columns) {
	    ++pfax->b1;
	    while (pfax->refLine[pfax->b1] <= pfax->codingLine[pfax->a0] && 
		   pfax->refLine[pfax->b1] < pfax->columns)
	      pfax->b1 += 2;
	  }
	  break;
	case twoDimVertL3:
	  a0New = pfax->codingLine[++pfax->a0] = pfax->refLine[pfax->b1] - 3;
	  --pfax->b1;
	  while (pfax->refLine[pfax->b1] <= pfax->codingLine[pfax->a0] && 
		 pfax->refLine[pfax->b1] < pfax->columns)
	    pfax->b1 += 2;
	  break;
	case EOF:
	  str->eof = gTrue;
	  pfax->codingLine[pfax->a0 = 0] = pfax->columns;
	  return EOF;
	default:
	    EC_WARNING(-1);
//	  error(getPos(), "Bad 2D code %04x in CCITTFax stream", code1);
	  return EOF;
	}
      } while (pfax->codingLine[pfax->a0] < pfax->columns);

    // 1-D encoding
    } else {
      pfax->codingLine[pfax->a0 = 0] = 0;
      while (1) {
	code1 = 0;
	do {
	  code1 += code3 = CCITTFaxStreamGetWhiteCode(str);
	} while (code3 >= 64);
	pfax->codingLine[pfax->a0+1] = pfax->codingLine[pfax->a0] + code1;
	++pfax->a0;
	if (pfax->codingLine[pfax->a0] >= pfax->columns)
	  break;
	code2 = 0;
	do {
	  code2 += code3 = CCITTFaxStreamGetBlackCode(str);
	} while (code3 >= 64);
	pfax->codingLine[pfax->a0+1] = pfax->codingLine[pfax->a0] + code2;
	++pfax->a0;
	if (pfax->codingLine[pfax->a0] >= pfax->columns)
	  break;
      }
    }

    if (pfax->codingLine[pfax->a0] != pfax->columns)
	EC_WARNING(-1);
//      error(getPos(), "CCITTFax row is wrong length (%d)", codingLine[a0]);

    // check for end-of-line marker
    code1 = CCITTFaxStreamLook13Bits(str);
    if ((code1 >> 1) == 0x001) {
      CCITTFaxStreamEatBits(str, 12);
      if (pfax->encoding > 0) {
	CCITTFaxStreamEatBits(str, 1);
	pfax->nextLine2D = !(code1 & 1);
      }
    }

    pfax->a0 = 0;
    pfax->outputBits = pfax->codingLine[1] - pfax->codingLine[0];
  }

  // get a byte
  if (pfax->outputBits >= 8) {
    ret = ((pfax->a0 & 1) == 0) ? 0xff : 0x00;
    if ((pfax->outputBits -= 8) == 0) {
      ++pfax->a0;
      if (pfax->codingLine[pfax->a0] < pfax->columns)
	pfax->outputBits = pfax->codingLine[pfax->a0 + 1] - pfax->codingLine[pfax->a0];
    }
  } else {
    bits = 8;
    ret = 0;
    do {
      if (pfax->outputBits > bits) {
	i = bits;
	bits = 0;
	if ((pfax->a0 & 1) == 0)
	  ret |= 0xff >> (8 - i);
	pfax->outputBits -= i;
      } else {
	i = pfax->outputBits;
	bits -= pfax->outputBits;
	if ((pfax->a0 & 1) == 0)
	  ret |= (0xff >> (8 - i)) << bits;
	pfax->outputBits = 0;
	++pfax->a0;
	if (pfax->codingLine[pfax->a0] < pfax->columns)
	  pfax->outputBits = pfax->codingLine[pfax->a0 + 1] - pfax->codingLine[pfax->a0];
      }
    } while (bits > 0 && pfax->codingLine[pfax->a0] < pfax->columns);
  }
  pfax->buf = pfax->black ? (ret ^ 0xff) : ret;
  return pfax->buf;
}

long CCITTFaxStreamGetChar(Stream *str) {
    long c = CCITTFaxStreamLookChar(str);
    str->u.fax->buf = EOF;
    return c;
}

void CCITTFaxStreamEatBits(Stream *str, short bits) {
    str->u.fax->inputBits -= bits;
}

/*
 * XXX: the memlock / lmemderef calls below should, for efficiency,
 * be collected in the Init call above, with the pointers assigned to fields
 * added to the CCITTFaxData struct.  The mem block would then be unlocked in
 * CCITTFaxStreamFree.
 */


short CCITTFaxStreamGetTwoDimCode(Stream *str) {
  short code, code0;
  CCITTCode *twoDimTab1;
  CCITTCode *p;
  short retval;

  code0 = CCITTFaxStreamLook13Bits(str);
  code = code0 >> 6;
  if (code == 0x0002) {
    CCITTFaxStreamEatBits(str, 7);
    return twoDimVertL3;
  }
  if (code == 0x0003) {
    CCITTFaxStreamEatBits(str, 7);
    return twoDimVertR3;
  }
  code >>= 1;
  if (code == 0x0002) {
    CCITTFaxStreamEatBits(str, 6);
    return twoDimVertL2;
  }
  if (code == 0x0003) {
    CCITTFaxStreamEatBits(str, 6);
    return twoDimVertR2;
  }

  MemLock(OptrToHandle(@twoDimTab1xx));
  twoDimTab1 = LMemDeref(@twoDimTab1xx);

  code >>= 2;
  p = &twoDimTab1[code];
  if (p->bits > 0) {
    CCITTFaxStreamEatBits(str, p->bits);
    retval = p->n;
    MemUnlock(OptrToHandle(@twoDimTab1xx));
    return retval;
  }
  MemUnlock(OptrToHandle(@twoDimTab1xx));

  EC_WARNING(-1);
//  error(getPos(), "Bad two dim code (%04x) in CCITTFax stream", code0);
  return EOF;
}

short CCITTFaxStreamGetWhiteCode(Stream *str) {
  short code, retval;
  CCITTCode *p;
  CCITTCode *whiteTab1, *whiteTab2;

  MemLock(OptrToHandle(@whiteTab1xx));

  code = CCITTFaxStreamLook13Bits(str);
  if ((code >> 6) == 0) {
      whiteTab1 = LMemDeref(@whiteTab1xx);
      p = &whiteTab1[code >> 1];
  } else {
      whiteTab2 = LMemDeref(@whiteTab2xx);
      p = &whiteTab2[code >> 4];
  }
  if (p->bits > 0) {
    CCITTFaxStreamEatBits(str, p->bits);
    retval = p->n;
    MemUnlock(OptrToHandle(@whiteTab1xx));
    return retval;
  }

  MemUnlock(OptrToHandle(@whiteTab1xx));
  EC_WARNING(-1);
//  error(getPos(), "Bad white code (%04x) in CCITTFax stream", code);
  return EOF;
}

short CCITTFaxStreamGetBlackCode(Stream *str) {
  short code, retval;
  CCITTCode *p;
  CCITTCode *blackTab1, *blackTab2, *blackTab3;

  MemLock(OptrToHandle(@blackTab1xx));

  code = CCITTFaxStreamLook13Bits(str);
  if ((code >> 7) == 0){
      blackTab1 = LMemDeref(@blackTab1xx);
      p = &blackTab1[code];
  } else if ((code >> 9) == 0) {
      blackTab2 = LMemDeref(@blackTab2xx);
      p = &blackTab2[(code >> 1) - 64];
  } else {
      blackTab3 = LMemDeref(@blackTab3xx);
      p = &blackTab3[code >> 7];
  }
  if (p->bits > 0) {
    CCITTFaxStreamEatBits(str, p->bits);
    retval = p->n;
    MemUnlock(OptrToHandle(@blackTab1xx));
    return retval;
  }

  MemUnlock(OptrToHandle(@blackTab1xx));
  EC_WARNING(-1);
//  error(getPos(), "Bad black code (%04x) in CCITTFax stream", code);
  return EOF;
}

short CCITTFaxStreamLook13Bits(Stream *str) {
  long c;
  CCITTFaxData *pfax = str->u.fax;

  while (pfax->inputBits < 13) {
    if ((c = StreamGetChar(str->str)) == EOF) {
      if (pfax->inputBits == 0)
	return EOF;
      c = 0;
    }
    pfax->inputBuf = (pfax->inputBuf << 8) + c;
    pfax->inputBits += 8;
  }
  return (pfax->inputBuf >> (pfax->inputBits - 13)) & 0x1fff;
}

/*
GString *CCITTFaxStream::getPSFilter(char *indent) {
  GString *s;
  char s1[50];

  s = str->getPSFilter(indent);
  s->append(indent)->append("<< ");
  if (encoding != 0) {
    sprintf(s1, "/K %d ", encoding);
    s->append(s1);
  }
  if (byteAlign)
    s->append("/EncodedByteAlign true ");
  sprintf(s1, "/Columns %d ", columns);
  s->append(s1);
  if (rows != 0) {
    sprintf(s1, "/Rows %d ", rows);
    s->append(s1);
  }
  if (black)
    s->append("/BlackIs1 true ");
  s->append(">> /CCITTFaxDecode filter\n");
  return s;
}

GBool CCITTFaxStream::isBinary(GBool last) {
  return str->isBinary(gTrue);
}
*/

//------------------------------------------------------------------------
// DCTStream
//------------------------------------------------------------------------

#ifdef __BORLANDC__
#pragma codeseg DCTStream
#endif
#ifdef __WATCOMC__
#pragma code_seg("DCTStream")
#endif

// IDCT constants (20.12 fixed point format)
#ifndef FP_IDCT
#define dctCos1    4017		// cos(pi/16)
#define dctSin1     799		// sin(pi/16)
#define dctCos3    3406		// cos(3*pi/16)
#define dctSin3    2276		// sin(3*pi/16)
#define dctCos6    1567		// cos(6*pi/16)
#define dctSin6    3784		// sin(6*pi/16)
#define dctSqrt2   5793		// sqrt(2)
#define dctSqrt1d2 2896		// sqrt(2) / 2
#endif

// IDCT constants
#ifdef FP_IDCT
#define dctCos1    0.98078528	// cos(pi/16)
#define dctSin1    0.19509032	// sin(pi/16)
#define dctCos3    0.83146961	// cos(3*pi/16)
#define dctSin3    0.55557023	// sin(3*pi/16)
#define dctCos6    0.38268343	// cos(6*pi/16)
#define dctSin6    0.92387953	// sin(6*pi/16)
#define dctSqrt2   1.41421356	// sqrt(2)
#define dctSqrt1d2 0.70710678	// sqrt(2) / 2
#endif

// color conversion parameters (16.16 fixed point format)
#define dctCrToR   91881	//  1.4020
#define dctCbToG  -22553	// -0.3441363
#define dctCrToG  -46802	// -0.71413636
#define dctCbToB  116130	//  1.772

// clip [-256,511] --> [0,255]
#define dctClipOffset 256
//static Guchar dctClip[768];
static Handle dctClipHandle = 0;

// zig zag decode map
static int dctZigZag[64] = {
   0,
   1,  8,
  16,  9,  2,
   3, 10, 17, 24,
  32, 25, 18, 11, 4,
   5, 12, 19, 26, 33, 40,
  48, 41, 34, 27, 20, 13,  6,
   7, 14, 21, 28, 35, 42, 49, 56,
  57, 50, 43, 36, 29, 22, 15,
  23, 30, 37, 44, 51, 58,
  59, 52, 45, 38, 31,
  39, 46, 53, 60,
  61, 54, 47,
  55, 62,
  63
};

void DCTStreamInit(Stream *str, Stream *str1) {
    DCTData *pdct;
    Guchar *dctClip;
  short i, j;

  StreamInit(str);
  str->str = str1;

  str->kind = strDCT;
  pdct = str->u.dct = gmalloc( sizeof (DCTData) );

  pdct->width = pdct->height = 0;
  pdct->mcuWidth = pdct->mcuHeight = 0;
  pdct->numComps = 0;
  pdct->comp = 0;
  pdct->x = pdct->y = pdct->dy = 0;
  for (i = 0; i < 4; ++i)
    for (j = 0; j < 32; ++j)
      pdct->rowBuf[i][j] = NULL;

  if (!dctClipHandle) {
/*
 * Allocate & initialize memory.
 * Stays allocated until geode is exited.
 */
      dctClipHandle = MemAlloc(768, HF_SWAPABLE, HAF_NO_ERR);
      dctClip = MemLock(dctClipHandle);

    for (i = -256; i < 0; ++i)
      dctClip[dctClipOffset + i] = 0;
    for (i = 0; i < 256; ++i)
      dctClip[dctClipOffset + i] = i;
    for (i = 256; i < 512; ++i)
      dctClip[dctClipOffset + i] = 255;

      MemUnlock(dctClipHandle);
  }
}

void DCTStreamFree(Stream *str) {
    DCTData *pdct = str->u.dct;
  short i, j;

  for (i = 0; i < pdct->numComps; ++i)
    for (j = 0; j < pdct->mcuHeight; ++j)
      gfree(pdct->rowBuf[i][j]);

  gfree(pdct);
}

void DCTStreamReset(Stream *str) {
  StreamReset(str->str);
  if (!DCTStreamReadHeader(str)) {
    str->u.dct->y = str->u.dct->height;
    return;
  }
  str->u.dct->restartMarker = 0xd0;
  DCTStreamRestart(str);
}

long DCTStreamLookChar(Stream *str) {
    DCTData *pdct = str->u.dct;

  if (pdct->y >= pdct->height)
    return EOF;
  if (pdct->dy >= pdct->mcuHeight) {
    if (!DCTStreamReadMCURow(str)) {
      pdct->y = pdct->height;
      return EOF;
    }
    pdct->comp = 0;
    pdct->x = 0;
    pdct->dy = 0;
  }
  return pdct->rowBuf[pdct->comp][pdct->dy][pdct->x];
}

long DCTStreamGetChar(Stream *str) {
    DCTData *pdct = str->u.dct;
  long c;

  c = DCTStreamLookChar(str);
  if (c == EOF)
    return EOF;
  if (++pdct->comp == pdct->numComps) {
    pdct->comp = 0;
    if (++pdct->x == pdct->width) {
      pdct->x = 0;
      ++pdct->y;
      ++pdct->dy;
    }
  }
  if (pdct->y == pdct->height)
    DCTStreamReadTrailer(str);
  return c;
}

void DCTStreamRestart(Stream *str) {
    DCTData *pdct = str->u.dct;
  short i;

  pdct->inputBits = 0;
  pdct->restartCtr = pdct->restartInterval;
  for (i = 0; i < pdct->numComps; ++i)
    pdct->compInfo[i].prevDC = 0;
}

GBool DCTStreamReadMCURow(Stream *str) {
    DCTData *pdct = str->u.dct;
    Guchar *dctClip;
  Guchar data[64];
  Guchar *p1, *p2;
  long pY, pCb, pCr, pR, pG, pB;
  long h, v, horiz, vert, hSub, vSub;
  long x1, x2, y2, x3, y3, x4, y4, x5, y5, cc, i;
  long c;

  dctClip = MemLock(dctClipHandle);

  for (x1 = 0; x1 < pdct->width; x1 += pdct->mcuWidth) {

    // deal with restart marker
    if (pdct->restartInterval > 0 && pdct->restartCtr == 0) {
      c = DCTStreamReadMarker(str);
      if (c != pdct->restartMarker) {
	  EC_WARNING(-1);
//	error(getPos(), "Bad DCT data: incorrect restart marker");

	  MemUnlock(dctClipHandle);
	  return gFalse;
      }
      if (++pdct->restartMarker == 0xd8)
	pdct->restartMarker = 0xd0;
      DCTStreamRestart(str);
    }

    // read one MCU
    for (cc = 0; cc < pdct->numComps; ++cc) {
      h = pdct->compInfo[cc].hSample;
      v = pdct->compInfo[cc].vSample;
      horiz = pdct->mcuWidth / h;
      vert = pdct->mcuHeight / v;
      hSub = horiz / 8;
      vSub = vert / 8;
      for (y2 = 0; y2 < pdct->mcuHeight; y2 += vert) {
	for (x2 = 0; x2 < pdct->mcuWidth; x2 += horiz) {
	  if (!DCTStreamReadDataUnit(str,
	      		    &pdct->dcHuffTables[pdct->compInfo[cc].dcHuffTable],
			    &pdct->acHuffTables[pdct->compInfo[cc].acHuffTable],
			    &pdct->quantTables[pdct->compInfo[cc].quantTable],
			    &pdct->compInfo[cc].prevDC,
			    &data)) {
	      MemUnlock(dctClipHandle);
	      return gFalse;
	  }
	  if (hSub == 1 && vSub == 1) {
	    for (y3 = 0, i = 0; y3 < 8; ++y3, i += 8) {
	      p1 = &pdct->rowBuf[cc][y2+y3][x1+x2];
	      p1[0] = data[i];
	      p1[1] = data[i+1];
	      p1[2] = data[i+2];
	      p1[3] = data[i+3];
	      p1[4] = data[i+4];
	      p1[5] = data[i+5];
	      p1[6] = data[i+6];
	      p1[7] = data[i+7];
	    }
	  } else if (hSub == 2 && vSub == 2) {
	    for (y3 = 0, i = 0; y3 < 16; y3 += 2, i += 8) {
	      p1 = &pdct->rowBuf[cc][y2+y3][x1+x2];
	      p2 = &pdct->rowBuf[cc][y2+y3+1][x1+x2];
	      p1[0] = p1[1] = p2[0] = p2[1] = data[i];
	      p1[2] = p1[3] = p2[2] = p2[3] = data[i+1];
	      p1[4] = p1[5] = p2[4] = p2[5] = data[i+2];
	      p1[6] = p1[7] = p2[6] = p2[7] = data[i+3];
	      p1[8] = p1[9] = p2[8] = p2[9] = data[i+4];
	      p1[10] = p1[11] = p2[10] = p2[11] = data[i+5];
	      p1[12] = p1[13] = p2[12] = p2[13] = data[i+6];
	      p1[14] = p1[15] = p2[14] = p2[15] = data[i+7];
	    }
	  } else {
	    i = 0;
	    for (y3 = 0, y4 = 0; y3 < 8; ++y3, y4 += vSub) {
	      for (x3 = 0, x4 = 0; x3 < 8; ++x3, x4 += hSub) {
		for (y5 = 0; y5 < vSub; ++y5)
		  for (x5 = 0; x5 < hSub; ++x5)
		    pdct->rowBuf[cc][y2+y4+y5][x1+x2+x4+x5] = data[i];
		++i;
	      }
	    }
	  }
	}
      }
    }
    --pdct->restartCtr;

    // color space conversion
    if (pdct->colorXform) {
      // convert YCbCr to RGB
      if (pdct->numComps == 3) {
	for (y2 = 0; y2 < pdct->mcuHeight; ++y2) {
	  for (x2 = 0; x2 < pdct->mcuWidth; ++x2) {
	    pY = pdct->rowBuf[0][y2][x1+x2];
	    pCb = pdct->rowBuf[1][y2][x1+x2] - 128;
	    pCr = pdct->rowBuf[2][y2][x1+x2] - 128;
	    pR = ((pY << 16) + dctCrToR * pCr + 32768) >> 16;
	    pdct->rowBuf[0][y2][x1+x2] = dctClip[dctClipOffset + pR];
	    pG = ((pY << 16) + dctCbToG * pCb + dctCrToG * pCr + 32678) >> 16;
	    pdct->rowBuf[1][y2][x1+x2] = dctClip[dctClipOffset + pG];
	    pB = ((pY << 16) + dctCbToB * pCb + 32768) >> 16;
	    pdct->rowBuf[2][y2][x1+x2] = dctClip[dctClipOffset + pB];
	  }
	}
      // convert YCbCrK to CMYK (K is passed through unchanged)
      } else if (pdct->numComps == 4) {
	for (y2 = 0; y2 < pdct->mcuHeight; ++y2) {
	  for (x2 = 0; x2 < pdct->mcuWidth; ++x2) {
	    pY = pdct->rowBuf[0][y2][x1+x2];
	    pCb = pdct->rowBuf[1][y2][x1+x2] - 128;
	    pCr = pdct->rowBuf[2][y2][x1+x2] - 128;
	    pR = ((pY << 16) + dctCrToR * pCr + 32768) >> 16;
	    pdct->rowBuf[0][y2][x1+x2] = 255 - dctClip[dctClipOffset + pR];
	    pG = ((pY << 16) + dctCbToG * pCb + dctCrToG * pCr + 32678) >> 16;
	    pdct->rowBuf[1][y2][x1+x2] = 255 - dctClip[dctClipOffset + pG];
	    pB = ((pY << 16) + dctCbToB * pCb + 32768) >> 16;
	    pdct->rowBuf[2][y2][x1+x2] = 255 - dctClip[dctClipOffset + pB];
	  }
	}
      }
    }
  }
  MemUnlock(dctClipHandle);
  return gTrue;
}

// This IDCT algorithm is taken from:
//   Christoph Loeffler, Adriaan Ligtenberg, George S. Moschytz,
//   "Practical Fast 1-D DCT Algorithms with 11 Multiplications",
//   IEEE Intl. Conf. on Acoustics, Speech & Signal Processing, 1989,
//   988-991.
// The stage numbers mentioned in the comments refer to Figure 1 in this
// paper.
#ifndef FP_IDCT
GBool DCTStreamReadDataUnit(Stream *str, DCTHuffTable *dcHuffTable,
			      DCTHuffTable *acHuffTable,
			      Guchar *quantTable, long *prevDC,
			      Guchar *data) {
    Guchar *dctClip;
  long tmp1[64];
  long v0, v1, v2, v3, v4, v5, v6, v7, t;
  long run, size, amp;
  long c;
  short i, j;

  // Huffman decode and dequantize
  size = DCTStreamReadHuffSym(str, dcHuffTable);
  if (size == 9999)
    return gFalse;
  if (size > 0) {
    amp = DCTStreamReadAmp(str, size);
    if (amp == 9999)
      return gFalse;
  } else {
    amp = 0;
  }
  tmp1[0] = (*prevDC += amp) * quantTable[0];
  for (i = 1; i < 64; ++i)
    tmp1[i] = 0;
  i = 1;
  while (i < 64) {
    run = 0;
    while ((c = DCTStreamReadHuffSym(str, acHuffTable)) == 0xf0 && run < 0x30)
      run += 0x10;
    if (c == 9999)
      return gFalse;
    if (c == 0x00) {
      break;
    } else {
      run += (c >> 4) & 0x0f;
      size = c & 0x0f;
      amp = DCTStreamReadAmp(str, size);
      if (amp == 9999)
	return gFalse;
      i += run;
      j = dctZigZag[i++];
      tmp1[j] = amp * quantTable[j];
    }
  }

  // inverse DCT on rows
  for (i = 0; i < 64; i += 8) {

    // stage 4
    v0 = (dctSqrt2 * tmp1[i+0] + 128) >> 8;
    v1 = (dctSqrt2 * tmp1[i+4] + 128) >> 8;
    v2 = tmp1[i+2];
    v3 = tmp1[i+6];
    v4 = (dctSqrt1d2 * (tmp1[i+1] - tmp1[i+7]) + 128) >> 8;
    v7 = (dctSqrt1d2 * (tmp1[i+1] + tmp1[i+7]) + 128) >> 8;
    v5 = tmp1[i+3] << 4;
    v6 = tmp1[i+5] << 4;

    // stage 3
    t = (v0 - v1+ 1) >> 1;
    v0 = (v0 + v1 + 1) >> 1;
    v1 = t;
    t = (v2 * dctSin6 + v3 * dctCos6 + 128) >> 8;
    v2 = (v2 * dctCos6 - v3 * dctSin6 + 128) >> 8;
    v3 = t;
    t = (v4 - v6 + 1) >> 1;
    v4 = (v4 + v6 + 1) >> 1;
    v6 = t;
    t = (v7 + v5 + 1) >> 1;
    v5 = (v7 - v5 + 1) >> 1;
    v7 = t;

    // stage 2
    t = (v0 - v3 + 1) >> 1;
    v0 = (v0 + v3 + 1) >> 1;
    v3 = t;
    t = (v1 - v2 + 1) >> 1;
    v1 = (v1 + v2 + 1) >> 1;
    v2 = t;
    t = (v4 * dctSin3 + v7 * dctCos3 + 2048) >> 12;
    v4 = (v4 * dctCos3 - v7 * dctSin3 + 2048) >> 12;
    v7 = t;
    t = (v5 * dctSin1 + v6 * dctCos1 + 2048) >> 12;
    v5 = (v5 * dctCos1 - v6 * dctSin1 + 2048) >> 12;
    v6 = t;

    // stage 1
    tmp1[i+0] = v0 + v7;
    tmp1[i+7] = v0 - v7;
    tmp1[i+1] = v1 + v6;
    tmp1[i+6] = v1 - v6;
    tmp1[i+2] = v2 + v5;
    tmp1[i+5] = v2 - v5;
    tmp1[i+3] = v3 + v4;
    tmp1[i+4] = v3 - v4;
  }

  // inverse DCT on columns
  for (i = 0; i < 8; ++i) {

    // stage 4
    v0 = (dctSqrt2 * tmp1[0*8+i] + 2048) >> 12;
    v1 = (dctSqrt2 * tmp1[4*8+i] + 2048) >> 12;
    v2 = tmp1[2*8+i];
    v3 = tmp1[6*8+i];
    v4 = (dctSqrt1d2 * (tmp1[1*8+i] - tmp1[7*8+i]) + 2048) >> 12;
    v7 = (dctSqrt1d2 * (tmp1[1*8+i] + tmp1[7*8+i]) + 2048) >> 12;
    v5 = tmp1[3*8+i];
    v6 = tmp1[5*8+i];

    // stage 3
    t = (v0 - v1 + 1) >> 1;
    v0 = (v0 + v1 + 1) >> 1;
    v1 = t;
    t = (v2 * dctSin6 + v3 * dctCos6 + 2048) >> 12;
    v2 = (v2 * dctCos6 - v3 * dctSin6 + 2048) >> 12;
    v3 = t;
    t = (v4 - v6 + 1) >> 1;
    v4 = (v4 + v6 + 1) >> 1;
    v6 = t;
    t = (v7 + v5 + 1) >> 1;
    v5 = (v7 - v5 + 1) >> 1;
    v7 = t;

    // stage 2
    t = (v0 - v3 + 1) >> 1;
    v0 = (v0 + v3 + 1) >> 1;
    v3 = t;
    t = (v1 - v2 + 1) >> 1;
    v1 = (v1 + v2 + 1) >> 1;
    v2 = t;
    t = (v4 * dctSin3 + v7 * dctCos3 + 2048) >> 12;
    v4 = (v4 * dctCos3 - v7 * dctSin3 + 2048) >> 12;
    v7 = t;
    t = (v5 * dctSin1 + v6 * dctCos1 + 2048) >> 12;
    v5 = (v5 * dctCos1 - v6 * dctSin1 + 2048) >> 12;
    v6 = t;

    // stage 1
    tmp1[0*8+i] = v0 + v7;
    tmp1[7*8+i] = v0 - v7;
    tmp1[1*8+i] = v1 + v6;
    tmp1[6*8+i] = v1 - v6;
    tmp1[2*8+i] = v2 + v5;
    tmp1[5*8+i] = v2 - v5;
    tmp1[3*8+i] = v3 + v4;
    tmp1[4*8+i] = v3 - v4;
  }

  // convert to 8-bit integers
  dctClip = MemLock(dctClipHandle);

  for (i = 0; i < 64; ++i)
    data[i] = dctClip[dctClipOffset + 128 + ((tmp1[i] + 8) >> 4)];

  MemUnlock(dctClipHandle);

  return gTrue;
}
#endif

#ifdef FP_IDCT
GBool DCTStream::readDataUnit(DCTHuffTable *dcHuffTable,
			      DCTHuffTable *acHuffTable,
			      Guchar quantTable[64], int *prevDC,
			      Guchar data[64]) {
  double tmp1[64];
  double v0, v1, v2, v3, v4, v5, v6, v7, t;
  int run, size, amp;
  int c;
  int i, j;

  // Huffman decode and dequantize
  size = readHuffSym(dcHuffTable);
  if (size == 9999)
    return gFalse;
  if (size > 0) {
    amp = readAmp(size);
    if (amp == 9999)
      return gFalse;
  } else {
    amp = 0;
  }
  tmp1[0] = (*prevDC += amp) * quantTable[0];
  for (i = 1; i < 64; ++i)
    tmp1[i] = 0;
  i = 1;
  while (i < 64) {
    run = 0;
    while ((c = readHuffSym(acHuffTable)) == 0xf0 && run < 0x30)
      run += 0x10;
    if (c == 9999)
      return gFalse;
    if (c == 0x00) {
      break;
    } else {
      run += (c >> 4) & 0x0f;
      size = c & 0x0f;
      amp = readAmp(size);
      if (amp == 9999)
	return gFalse;
      i += run;
      j = dctZigZag[i++];
      tmp1[j] = amp * quantTable[j];
    }
  }

  // inverse DCT on rows
  for (i = 0; i < 64; i += 8) {

    // stage 4
    v0 = dctSqrt2 * tmp1[i+0];
    v1 = dctSqrt2 * tmp1[i+4];
    v2 = tmp1[i+2];
    v3 = tmp1[i+6];
    v4 = dctSqrt1d2 * (tmp1[i+1] - tmp1[i+7]);
    v7 = dctSqrt1d2 * (tmp1[i+1] + tmp1[i+7]);
    v5 = tmp1[i+3];
    v6 = tmp1[i+5];

    // stage 3
    t = 0.5 * (v0 - v1);
    v0 = 0.5 * (v0 + v1);
    v1 = t;
    t = v2 * dctSin6 + v3 * dctCos6;
    v2 = v2 * dctCos6 - v3 * dctSin6;
    v3 = t;
    t = 0.5 * (v4 - v6);
    v4 = 0.5 * (v4 + v6);
    v6 = t;
    t = 0.5 * (v7 + v5);
    v5 = 0.5 * (v7 - v5);
    v7 = t;

    // stage 2
    t = 0.5 * (v0 - v3);
    v0 = 0.5 * (v0 + v3);
    v3 = t;
    t = 0.5 * (v1 - v2);
    v1 = 0.5 * (v1 + v2);
    v2 = t;
    t = v4 * dctSin3 + v7 * dctCos3;
    v4 = v4 * dctCos3 - v7 * dctSin3;
    v7 = t;
    t = v5 * dctSin1 + v6 * dctCos1;
    v5 = v5 * dctCos1 - v6 * dctSin1;
    v6 = t;

    // stage 1
    tmp1[i+0] = v0 + v7;
    tmp1[i+7] = v0 - v7;
    tmp1[i+1] = v1 + v6;
    tmp1[i+6] = v1 - v6;
    tmp1[i+2] = v2 + v5;
    tmp1[i+5] = v2 - v5;
    tmp1[i+3] = v3 + v4;
    tmp1[i+4] = v3 - v4;
  }

  // inverse DCT on columns
  for (i = 0; i < 8; ++i) {

    // stage 4
    v0 = dctSqrt2 * tmp1[0*8+i];
    v1 = dctSqrt2 * tmp1[4*8+i];
    v2 = tmp1[2*8+i];
    v3 = tmp1[6*8+i];
    v4 = dctSqrt1d2 * (tmp1[1*8+i] - tmp1[7*8+i]);
    v7 = dctSqrt1d2 * (tmp1[1*8+i] + tmp1[7*8+i]);
    v5 = tmp1[3*8+i];
    v6 = tmp1[5*8+i];

    // stage 3
    t = 0.5 * (v0 - v1);
    v0 = 0.5 * (v0 + v1);
    v1 = t;
    t = v2 * dctSin6 + v3 * dctCos6;
    v2 = v2 * dctCos6 - v3 * dctSin6;
    v3 = t;
    t = 0.5 * (v4 - v6);
    v4 = 0.5 * (v4 + v6);
    v6 = t;
    t = 0.5 * (v7 + v5);
    v5 = 0.5 * (v7 - v5);
    v7 = t;

    // stage 2
    t = 0.5 * (v0 - v3);
    v0 = 0.5 * (v0 + v3);
    v3 = t;
    t = 0.5 * (v1 - v2);
    v1 = 0.5 * (v1 + v2);
    v2 = t;
    t = v4 * dctSin3 + v7 * dctCos3;
    v4 = v4 * dctCos3 - v7 * dctSin3;
    v7 = t;
    t = v5 * dctSin1 + v6 * dctCos1;
    v5 = v5 * dctCos1 - v6 * dctSin1;
    v6 = t;

    // stage 1
    tmp1[0*8+i] = v0 + v7;
    tmp1[7*8+i] = v0 - v7;
    tmp1[1*8+i] = v1 + v6;
    tmp1[6*8+i] = v1 - v6;
    tmp1[2*8+i] = v2 + v5;
    tmp1[5*8+i] = v2 - v5;
    tmp1[3*8+i] = v3 + v4;
    tmp1[4*8+i] = v3 - v4;
  }

  // convert to 8-bit integers
  for (i = 0; i < 64; ++i)
    data[i] = dctClip[dctClipOffset + (int)(tmp1[i] + 128.5)];

  return gTrue;
}
#endif

long DCTStreamReadHuffSym(Stream *str, DCTHuffTable *table) {
  Gushort code;
  long bit;
  long codeBits;

  code = 0;
  codeBits = 0;
  do {
    // add a bit to the code
    if ((bit = DCTStreamReadBit(str)) == EOF)
      return 9999;
    code = (code << 1) + bit;
    ++codeBits;

    // look up code
    if (code - table->firstCode[codeBits] < table->numCodes[codeBits]) {
      code -= table->firstCode[codeBits];
      return table->sym[table->firstSym[codeBits] + code];
    }
  } while (codeBits < 16);

  EC_WARNING(-1);
//  error(getPos(), "Bad Huffman code in DCT stream");
  return 9999;
}

long DCTStreamReadAmp(Stream *str, long size) {
  long amp, bit;
  long bits;

  amp = 0;
  for (bits = 0; bits < size; ++bits) {
    if ((bit = DCTStreamReadBit(str)) == EOF)
      return 9999;
    amp = (amp << 1) + bit;
  }
  if (amp < (1 << (size - 1)))
    amp -= (1 << size) - 1;
  return amp;
}

long DCTStreamReadBit(Stream *str) {
    DCTData *pdct = str->u.dct;
  long bit;
  long c, c2;

  if (pdct->inputBits == 0) {
    if ((c = StreamGetChar(str->str)) == EOF)
      return EOF;
    if (c == 0xff) {
      do {
	c2 = StreamGetChar(str->str);
      } while (c2 == 0xff);
      if (c2 != 0x00) {
	  EC_WARNING(-1);
//	error(getPos(), "Bad DCT data: missing 00 after ff");
	return EOF;
      }
    }
    pdct->inputBuf = c;
    pdct->inputBits = 8;
  }
  bit = (pdct->inputBuf >> (pdct->inputBits - 1)) & 1;
  --pdct->inputBits;
  return bit;
}

GBool DCTStreamReadHeader(Stream *str) {
    DCTData *pdct = str->u.dct;
  long minHSample, minVSample;
  long bufWidth;
  long n;
  long c = 0;
  short i, j;
  GBool doScan;

  pdct->width = pdct->height = 0;
  pdct->numComps = 0;
  pdct->numQuantTables = 0;
  pdct->numDCHuffTables = 0;
  pdct->numACHuffTables = 0;
  pdct->colorXform = 0;
  pdct->restartInterval = 0;

  // read headers
  doScan = gFalse;
  while (!doScan) {
    c = DCTStreamReadMarker(str);
    switch (c) {
    case 0xc0:			// SOF0
      if (!DCTStreamReadFrameInfo(str))
	return gFalse;
      break;
    case 0xc4:			// DHT
      if (!DCTStreamReadHuffmanTables(str))
	return gFalse;
      break;
    case 0xd8:			// SOI
      break;
    case 0xda:			// SOS
      if (!DCTStreamReadScanInfo(str))
	return gFalse;
      doScan = gTrue;
      break;
    case 0xdb:			// DQT
      if (!DCTStreamReadQuantTables(str))
	return gFalse;
      break;
    case 0xdd:			// DRI
      if (!DCTStreamReadRestartInterval(str))
	return gFalse;
      break;
    case 0xee:			// APP14
      if (!DCTStreamReadAdobeMarker(str))
	return gFalse;
      break;
    case EOF:
	EC_WARNING(-1);
//      error(getPos(), "Bad DCT header");
      return gFalse;
    default:
      // skip APPn / COM / etc.
      if (c >= 0xe0) {
	n = DCTStreamRead16(str) - 2;
	for (i = 0; i < n; ++i)
	  StreamGetChar(str->str);
      } else {
	  EC_WARNING(-1);
//	error(getPos(), "Unknown DCT marker <%02x>", c);
	return gFalse;
      }
      break;
    }
  }

  // compute MCU size
  pdct->mcuWidth = minHSample = pdct->compInfo[0].hSample;
  pdct->mcuHeight = minVSample = pdct->compInfo[0].vSample;
  for (i = 1; i < pdct->numComps; ++i) {
    if (pdct->compInfo[i].hSample < minHSample)
      minHSample = pdct->compInfo[i].hSample;
    if (pdct->compInfo[i].vSample < minVSample)
      minVSample = pdct->compInfo[i].vSample;
    if (pdct->compInfo[i].hSample > pdct->mcuWidth)
      pdct->mcuWidth = pdct->compInfo[i].hSample;
    if (pdct->compInfo[i].vSample > pdct->mcuHeight)
      pdct->mcuHeight = pdct->compInfo[i].vSample;
  }
  for (i = 0; i < pdct->numComps; ++i) {
    pdct->compInfo[i].hSample /= minHSample;
    pdct->compInfo[i].vSample /= minVSample;
  }
  pdct->mcuWidth = (pdct->mcuWidth / minHSample) * 8;
  pdct->mcuHeight = (pdct->mcuHeight / minVSample) * 8;

  // allocate buffers
  bufWidth = ((pdct->width + pdct->mcuWidth - 1) / pdct->mcuWidth) * pdct->mcuWidth;
  for (i = 0; i < pdct->numComps; ++i)
    for (j = 0; j < pdct->mcuHeight; ++j)
      pdct->rowBuf[i][j] = (Guchar *)gmalloc(bufWidth * sizeof(Guchar));

  // initialize counters
  pdct->comp = 0;
  pdct->x = 0;
  pdct->y = 0;
  pdct->dy = pdct->mcuHeight;

  return gTrue;
}

GBool DCTStreamReadFrameInfo(Stream *str) {
    DCTData *pdct = str->u.dct;
  long length;
  long prec;
  long c;
  short i;

  length = DCTStreamRead16(str) - 2;
  prec = StreamGetChar(str->str);
  pdct->height = DCTStreamRead16(str);
  pdct->width = DCTStreamRead16(str);
  pdct->numComps = StreamGetChar(str->str);
  length -= 6;
  if (prec != 8) {
      EC_WARNING(-1);
//    error(getPos(), "Bad DCT precision %d", prec);
    return gFalse;
  }
  for (i = 0; i < pdct->numComps; ++i) {
    pdct->compInfo[i].id = StreamGetChar(str->str);
    pdct->compInfo[i].inScan = gFalse;
    c = StreamGetChar(str->str);
    pdct->compInfo[i].hSample = (c >> 4) & 0x0f;
    pdct->compInfo[i].vSample = c & 0x0f;
    pdct->compInfo[i].quantTable = StreamGetChar(str->str);
    pdct->compInfo[i].dcHuffTable = 0;
    pdct->compInfo[i].acHuffTable = 0;
  }
  return gTrue;
}

GBool DCTStreamReadScanInfo(Stream *str) {
    DCTData *pdct = str->u.dct;
  long length;
  long scanComps, id, c;
  short i, j;

  length = DCTStreamRead16(str) - 2;
  scanComps = StreamGetChar(str->str);
  --length;
  if (length != 2 * scanComps + 3) {
      EC_WARNING(-1);
//    error(getPos(), "Bad DCT scan info block");
    return gFalse;
  }
  for (i = 0; i < scanComps; ++i) {
    id = StreamGetChar(str->str);
    for (j = 0; j < pdct->numComps; ++j) {
      if (id == pdct->compInfo[j].id)
	break;
    }
    if (j == pdct->numComps) {
	EC_WARNING(-1);
//      error(getPos(), "Bad DCT component ID in scan info block");
      return gFalse;
    }
    pdct->compInfo[j].inScan = gTrue;
    c = StreamGetChar(str->str);
    pdct->compInfo[j].dcHuffTable = (c >> 4) & 0x0f;
    pdct->compInfo[j].acHuffTable = c & 0x0f;
  }
  StreamGetChar(str->str);
  StreamGetChar(str->str);
  StreamGetChar(str->str);
  return gTrue;
}

GBool DCTStreamReadQuantTables(Stream *str) {
    DCTData *pdct = str->u.dct;
  long length;
  long index;
  short i;

  length = DCTStreamRead16(str) - 2;
  while (length > 0) {
    index = StreamGetChar(str->str);
    if ((index & 0xf0) || index >= 4) {
	EC_WARNING(-1);
//      error(getPos(), "Bad DCT quantization table");
      return gFalse;
    }
    if (index == pdct->numQuantTables)
      pdct->numQuantTables = index + 1;
    for (i = 0; i < 64; ++i)
      pdct->quantTables[index][dctZigZag[i]] = StreamGetChar(str->str);
    length -= 65;
  }
  return gTrue;
}

GBool DCTStreamReadHuffmanTables(Stream *str) {
    DCTData *pdct = str->u.dct;
  DCTHuffTable *tbl;
  long length;
  long index;
  long c;
  short i;
  Gushort code;
  Guchar sym;

  length = DCTStreamRead16(str) - 2;
  while (length > 0) {
    index = StreamGetChar(str->str);
    --length;
    if ((index & 0x0f) >= 4) {
	EC_WARNING(-1);
//      error(getPos(), "Bad DCT Huffman table");
      return gFalse;
    }
    if (index & 0x10) {
      index &= 0x0f;
      if (index >= pdct->numACHuffTables)
	pdct->numACHuffTables = index+1;
      tbl = &pdct->acHuffTables[index];
    } else {
      if (index >= pdct->numDCHuffTables)
	pdct->numDCHuffTables = index+1;
      tbl = &pdct->dcHuffTables[index];
    }
    sym = 0;
    code = 0;
    for (i = 1; i <= 16; ++i) {
      c = StreamGetChar(str->str);
      tbl->firstSym[i] = sym;
      tbl->firstCode[i] = code;
      tbl->numCodes[i] = c;
      sym += c;
      code = (code + c) << 1;
    }
    length -= 16;
    for (i = 0; i < sym; ++i)
      tbl->sym[i] = StreamGetChar(str->str);
    length -= sym;
  }
  return gTrue;
}

GBool DCTStreamReadRestartInterval(Stream *str) {
    DCTData *pdct = str->u.dct;
  long length;

  length = DCTStreamRead16(str);
  if (length != 4) {
      EC_WARNING(-1);
//    error(getPos(), "Bad DCT restart interval");
    return gFalse;
  }
  pdct->restartInterval = DCTStreamRead16(str);
  return gTrue;
}

GBool DCTStreamReadAdobeMarker(Stream *str) {
    DCTData *pdct = str->u.dct;
  long length, i;
  char buf[12];
  long c;

  length = DCTStreamRead16(str);
  if (length != 14)
    goto err;
  for (i = 0; i < 12; ++i) {
    if ((c = StreamGetChar(str->str)) == EOF)
      goto err;
    buf[i] = c;
  }
  if (strncmp(buf, "Adobe", 5))
    goto err;
  pdct->colorXform = buf[11];
  return gTrue;

 err:
  EC_WARNING(-1);
//  error(getPos(), "Bad DCT Adobe APP14 marker");
  return gFalse;
}

GBool DCTStreamReadTrailer(Stream *str) {
  long c;

  c = DCTStreamReadMarker(str);
  if (c != 0xd9) {		// EOI
      EC_WARNING(-1);
//    error(getPos(), "Bad DCT trailer");
    return gFalse;
  }
  return gTrue;
}

long DCTStreamReadMarker(Stream *str) {
  long c;

  do {
    do {
      c = StreamGetChar(str->str);
    } while (c != 0xff);
    do {
      c = StreamGetChar(str->str);
    } while (c == 0xff);
  } while (c == 0x00);
  return c;
}

long DCTStreamRead16(Stream *str) {
  long c1, c2;

  if ((c1 = StreamGetChar(str->str)) == EOF)
    return EOF;
  if ((c2 = StreamGetChar(str->str)) == EOF)
    return EOF;
  return (c1 << 8) + c2;
}

/*
GString *DCTStream::getPSFilter(char *indent) {
  GString *s;

  s = str->getPSFilter(indent);
  s->append(indent)->append("<< >> /DCTDecode filter\n");
  return s;
}

GBool DCTStream::isBinary(GBool last) {
  return str->isBinary(gTrue);
}
*/

//------------------------------------------------------------------------
// FlateStream
//------------------------------------------------------------------------

#ifdef __BORLANDC__
#pragma codeseg FlateStream
#endif
#ifdef __WATCOMC__
#pragma code_seg("FlateStream")
#endif

@start FLATEDATA, data;

@chunk short codeLenCodeMap_[flateMaxCodeLenCodes] = {
  16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15
};

@chunk FlateDecode lengthDecode_[flateMaxLitCodes-257] = {
  {0,   3},
  {0,   4},
  {0,   5},
  {0,   6},
  {0,   7},
  {0,   8},
  {0,   9},
  {0,  10},
  {1,  11},
  {1,  13},
  {1,  15},
  {1,  17},
  {2,  19},
  {2,  23},
  {2,  27},
  {2,  31},
  {3,  35},
  {3,  43},
  {3,  51},
  {3,  59},
  {4,  67},
  {4,  83},
  {4,  99},
  {4, 115},
  {5, 131},
  {5, 163},
  {5, 195},
  {5, 227},
  {0, 258}
};

@chunk FlateDecode distDecode_[flateMaxDistCodes] = {
  { 0,     1},
  { 0,     2},
  { 0,     3},
  { 0,     4},
  { 1,     5},
  { 1,     7},
  { 2,     9},
  { 2,    13},
  { 3,    17},
  { 3,    25},
  { 4,    33},
  { 4,    49},
  { 5,    65},
  { 5,    97},
  { 6,   129},
  { 6,   193},
  { 7,   257},
  { 7,   385},
  { 8,   513},
  { 8,   769},
  { 9,  1025},
  { 9,  1537},
  {10,  2049},
  {10,  3073},
  {11,  4097},
  {11,  6145},
  {12,  8193},
  {12, 12289},
  {13, 16385},
  {13, 24577}
};

@end FLATEDATA;

void FlateStreamInit(Stream *str, Stream *str1, long predictor1, long columns1,
			 long colors1, long bits1) {

  StreamInit(str);
  str->str = str1;

  str->kind = strFlate;
  str->u.flate = gmalloc( sizeof (FlateData) );
  str->u.flate->bufhan = MemAlloc( flateWindow, HF_DYNAMIC, HAF_STANDARD_NO_ERR );

  str->predictor = predictor1;
  if (predictor1 > 1) {
    str->width = columns1;
    str->nComps = colors1;
    str->nBits = bits1;
  }
}

void FlateStreamFree(Stream *str) {
    MemFree(str->u.flate->bufhan);
    gfree(str->u.flate);
}

void FlateStreamReset(Stream *str) {
  long cmf, flg;
  FlateData *pflate = str->u.flate;

  StreamReset(str->str);

  // read header
  //~ need to look at window size?
  pflate->endOfBlock = pflate->eof = gTrue;
  cmf = StreamGetChar(str->str);
  flg = StreamGetChar(str->str);
  if (cmf == EOF || flg == EOF)
    return;
  if ((cmf & 0x0f) != 0x08) {
      EC_WARNING(-1);
//    error(getPos(), "Unknown compression method in flate stream");
    return;
  }
  if ((((cmf << 8) + flg) % 31) != 0) {
      EC_WARNING(-1);
//    error(getPos(), "Bad FCHECK in flate stream");
    return;
  }
  if (flg & 0x20) {
      EC_WARNING(-1);
//    error(getPos(), "FDICT bit set in flate stream");
    return;
  }

  // initialize
  pflate->index = 0;
  pflate->remain = 0;
  pflate->codeBuf = 0;
  pflate->codeSize = 0;
  pflate->compressedBlock = gFalse;
  pflate->endOfBlock = gTrue;
  pflate->eof = gFalse;
}

/* FlateStreamGetChar moved above into StreamGetChar's code segment. */

long FlateStreamLookChar(Stream *str) {
  FlateData *pflate = str->u.flate;
  long c;
  Guchar *buf = MemLock(pflate->bufhan);

  while (pflate->remain == 0) {
    if (pflate->endOfBlock && pflate->eof)
    {
      MemUnlock(pflate->bufhan);
      return EOF;
    }
    FlateStreamReadSome(str);
  }
  c = buf[pflate->index];
  MemUnlock(pflate->bufhan);
  return c;
}

/*
GString *FlateStream::getPSFilter(char *indent) {
  return NULL;
}
*/
GBool FlateStreamIsBinary(Stream *str, GBool last) {
  return StreamIsBinary(str->str, gTrue);
}

void FlateStreamReadSome(Stream *str) {
  FlateData *pflate = str->u.flate;
  FlateDecode *lengthDecode;
  FlateDecode *distDecode;
  Guchar *buf = MemDeref(pflate->bufhan);	/* locked by caller */

  long code1, code2;
  long len, dist;
  long i, j, k;
  long c;

  if (pflate->endOfBlock) {
    if (!FlateStreamStartBlock(str))
      return;
  }

  MemLock(OptrToHandle(@lengthDecode_));
  lengthDecode = LMemDeref(@lengthDecode_);
  distDecode = LMemDeref(@distDecode_);

  if (pflate->compressedBlock) {
    if ((code1 = FlateStreamGetHuffmanCodeWord(str, &pflate->litCodeTab)) == EOF)
      goto err;
    if (code1 < 256) {
      buf[pflate->index] = code1;
      pflate->remain = 1;
    } else if (code1 == 256) {
      pflate->endOfBlock = gTrue;
      pflate->remain = 0;
    } else {
      code1 -= 257;
      code2 = lengthDecode[code1].bits;
      if (code2 > 0 && (code2 = FlateStreamGetCodeWord(str, code2)) == EOF)
	goto err;
      len = lengthDecode[code1].first + code2;
      if ((code1 = FlateStreamGetHuffmanCodeWord(str, &pflate->distCodeTab)) == EOF)
	goto err;
      code2 = distDecode[code1].bits;
      if (code2 > 0 && (code2 = FlateStreamGetCodeWord(str, code2)) == EOF)
	goto err;
      dist = distDecode[code1].first + code2;
      i = pflate->index;
      j = (pflate->index - dist) & flateMask;
      for (k = 0; k < len; ++k) {
	buf[i] = buf[j];
	i = (i + 1) & flateMask;
	j = (j + 1) & flateMask;
      }
      pflate->remain = len;
    }

  } else {
    len = (pflate->blockLen < flateWindow) ? pflate->blockLen : flateWindow;
    for (i = 0, j = pflate->index; i < len; ++i, j = (j + 1) & flateMask) {
      if ((c = StreamGetChar(str->str)) == EOF) {
	pflate->endOfBlock = pflate->eof = gTrue;
	break;
      }
      buf[j] = c & 0xff;
    }
    pflate->remain = i;
    pflate->blockLen -= len;
    if (pflate->blockLen == 0)
      pflate->endOfBlock = gTrue;
  }

  MemUnlock(OptrToHandle(@lengthDecode_));
  return;

err:
  EC_WARNING(-1);
//  error(getPos(), "Unexpected end of file in flate stream");
  pflate->endOfBlock = pflate->eof = gTrue;
  pflate->remain = 0;

  MemUnlock(OptrToHandle(@lengthDecode_));
}

GBool FlateStreamStartBlock(Stream *str) {
  FlateData *pflate = str->u.flate;
  long blockHdr;
  long c;
  long check;

  // read block header
  blockHdr = FlateStreamGetCodeWord(str, 3);
  if (blockHdr & 1)
    pflate->eof = gTrue;
  blockHdr >>= 1;

  // uncompressed block
  if (blockHdr == 0) {
    pflate->compressedBlock = gFalse;
    if ((c = StreamGetChar(str->str)) == EOF)
      goto err;
    pflate->blockLen = c & 0xff;
    if ((c = StreamGetChar(str->str)) == EOF)
      goto err;
    pflate->blockLen |= (c & 0xff) << 8;
    if ((c = StreamGetChar(str->str)) == EOF)
      goto err;
    check = c & 0xff;
    if ((c = StreamGetChar(str->str)) == EOF)
      goto err;
    check |= (c & 0xff) << 8;
    if (check != (~pflate->blockLen & 0xffff))
	EC_WARNING(-1);
//      error(getPos(), "Bad uncompressed block length in flate stream");
    pflate->codeBuf = 0;
    pflate->codeSize = 0;

  // compressed block with fixed codes
  } else if (blockHdr == 1) {
    pflate->compressedBlock = gTrue;
    FlateStreamLoadFixedCodes(str);

  // compressed block with dynamic codes
  } else if (blockHdr == 2) {
    pflate->compressedBlock = gTrue;
    if (!FlateStreamReadDynamicCodes(str))
      goto err;

  // unknown block type
  } else {
    goto err;
  }

  pflate->endOfBlock = gFalse;
  return gTrue;

err:
  EC_WARNING(-1);
//  error(getPos(), "Bad block header in flate stream");
  pflate->endOfBlock = pflate->eof = gTrue;
  return gFalse;
}

void FlateStreamLoadFixedCodes(Stream *str) {
  FlateData *pflate = str->u.flate;
  long i;

  // set up code arrays
  pflate->litCodeTab.codes = pflate->allCodes;
  pflate->distCodeTab.codes = pflate->allCodes + flateMaxLitCodes;

  // initialize literal code table
  for (i = 0; i <= 143; ++i)
    pflate->litCodeTab.codes[i].len = 8;
  for (i = 144; i <= 255; ++i)
    pflate->litCodeTab.codes[i].len = 9;
  for (i = 256; i <= 279; ++i)
    pflate->litCodeTab.codes[i].len = 7;
  for (i = 280; i <= 287; ++i)
    pflate->litCodeTab.codes[i].len = 8;
  FlateStreamCompHuffmanCodes(str, &pflate->litCodeTab, flateMaxLitCodes);

  // initialize distance code table
  for (i = 0; i < 5; ++i)
    pflate->distCodeTab.start[i] = 0;
  pflate->distCodeTab.start[5] = 0;
  for (i = 6; i <= flateMaxHuffman+1; ++i)
    pflate->distCodeTab.start[6] = flateMaxDistCodes;
  for (i = 0; i < flateMaxDistCodes; ++i) {
    pflate->distCodeTab.codes[i].len = 5;
    pflate->distCodeTab.codes[i].code = i;
    pflate->distCodeTab.codes[i].val = i;
  }
}

GBool FlateStreamReadDynamicCodes(Stream *str) {
  FlateData *pflate = str->u.flate;
  short *codeLenCodeMap;

  long numCodeLenCodes;
  long numLitCodes;
  long numDistCodes;
  FlateCode codeLenCodes[flateMaxCodeLenCodes];
  FlateHuffmanTab codeLenCodeTab;
  long len, repeat, code;
  long i;

  MemLock(OptrToHandle(@lengthDecode_));
  codeLenCodeMap = LMemDeref(@codeLenCodeMap_);

  // read lengths
  if ((numLitCodes = FlateStreamGetCodeWord(str, 5)) == EOF)
    goto err;
  numLitCodes += 257;
  if ((numDistCodes = FlateStreamGetCodeWord(str, 5)) == EOF)
    goto err;
  numDistCodes += 1;
  if ((numCodeLenCodes = FlateStreamGetCodeWord(str, 4)) == EOF)
    goto err;
  numCodeLenCodes += 4;
  if (numLitCodes > flateMaxLitCodes ||
      numDistCodes > flateMaxDistCodes ||
      numCodeLenCodes > flateMaxCodeLenCodes)
    goto err;

  // read code length code table
  codeLenCodeTab.codes = codeLenCodes;
  for (i = 0; i < flateMaxCodeLenCodes; ++i)
    codeLenCodes[i].len = 0;
  for (i = 0; i < numCodeLenCodes; ++i) {
    if ((codeLenCodes[codeLenCodeMap[i]].len = FlateStreamGetCodeWord(str, 3)) == -1)
      goto err;
  }
  FlateStreamCompHuffmanCodes(str, &codeLenCodeTab, flateMaxCodeLenCodes);

  // set up code arrays
  pflate->litCodeTab.codes = pflate->allCodes;
  pflate->distCodeTab.codes = pflate->allCodes + numLitCodes;

  // read literal and distance code tables
  len = 0;
  repeat = 0;
  i = 0;
  while (i < numLitCodes + numDistCodes) {
    if ((code = FlateStreamGetHuffmanCodeWord(str, &codeLenCodeTab)) == EOF)
      goto err;
    if (code == 16) {
      if ((repeat = FlateStreamGetCodeWord(str, 2)) == EOF)
	goto err;
      for (repeat += 3; repeat > 0; --repeat)
	pflate->allCodes[i++].len = len;
    } else if (code == 17) {
      if ((repeat = FlateStreamGetCodeWord(str, 3)) == EOF)
	goto err;
      len = 0;
      for (repeat += 3; repeat > 0; --repeat)
	pflate->allCodes[i++].len = 0;
    } else if (code == 18) {
      if ((repeat = FlateStreamGetCodeWord(str, 7)) == EOF)
	goto err;
      len = 0;
      for (repeat += 11; repeat > 0; --repeat)
	pflate->allCodes[i++].len = 0;
    } else {
      pflate->allCodes[i++].len = len = code;
    }
  }
  FlateStreamCompHuffmanCodes(str, &pflate->litCodeTab, numLitCodes);
  FlateStreamCompHuffmanCodes(str, &pflate->distCodeTab, numDistCodes);

  MemUnlock(OptrToHandle(@lengthDecode_));
  return gTrue;

err:
  EC_WARNING(-1);
//  error(getPos(), "Bad dynamic code table in flate stream");
  MemUnlock(OptrToHandle(@lengthDecode_));
  return gFalse;
}

// On entry, the <tab->codes> array contains the lengths of each code,
// stored in code value order.  This function computes the code words.
// The result is sorted in order of (1) code length and (2) code word.
// The length values are no longer valid.  The <tab->start> array is
// filled with the indexes of the first code of each length.
void FlateStreamCompHuffmanCodes(Stream *str, FlateHuffmanTab *tab, long n) {
  long numLengths[flateMaxHuffman+1];
  long nextCode[flateMaxHuffman+1];
  long nextIndex[flateMaxHuffman+2];
  long code;
  long i, j;

  // count number of codes for each code length
  for (i = 0; i <= flateMaxHuffman; ++i)
    numLengths[i] = 0;
  for (i = 0; i < n; ++i)
    ++numLengths[tab->codes[i].len];

  // compute first index for each length
  tab->start[0] = nextIndex[0] = 0;
  for (i = 1; i <= flateMaxHuffman + 1; ++i)
    tab->start[i] = nextIndex[i] = tab->start[i-1] + numLengths[i-1];

  // compute first code for each length
  code = 0;
  numLengths[0] = 0;
  for (i = 1; i <= flateMaxHuffman; ++i) {
    code = (code + numLengths[i-1]) << 1;
    nextCode[i] = code;
  }

  // compute the codes -- this permutes the codes array from value
  // order to length/code order
  for (i = 0; i < n; ++i) {
    j = nextIndex[tab->codes[i].len]++;
    if (tab->codes[i].len == 0)
      tab->codes[j].code = 0;
    else
      tab->codes[j].code = nextCode[tab->codes[i].len]++;
    tab->codes[j].val = i;
  }
}

long FlateStreamGetHuffmanCodeWord(Stream *str, FlateHuffmanTab *tab) {
  FlateData *pflate = str->u.flate;
  long len;
  long code;
  long c;
  long i, j;

  code = 0;
  for (len = 1; len <= flateMaxHuffman; ++len) {

    // add a bit to the code
    if (pflate->codeSize == 0) {
      if ((c = StreamGetChar(str->str)) == EOF)
	return EOF;
      pflate->codeBuf = c & 0xff;
      pflate->codeSize = 8;
    }
    code = (code << 1) | (pflate->codeBuf & 1);
    pflate->codeBuf >>= 1;
    --pflate->codeSize;

    // look for code
    i = tab->start[len];
    j = tab->start[len + 1];
    if (i < j && code >= tab->codes[i].code && code <= tab->codes[j-1].code) {
      i += code - tab->codes[i].code;
      return tab->codes[i].val;
    }
  }

  // not found
  EC_WARNING(-1);
//  error(getPos(), "Bad code (%04x) in flate stream", code);
  return EOF;
}

long FlateStreamGetCodeWord(Stream *str, long bits) {
  FlateData *pflate = str->u.flate;
  long c;

  while (pflate->codeSize < bits) {
    if ((c = StreamGetChar(str->str)) == EOF)
      return EOF;
    pflate->codeBuf |= (c & 0xff) << pflate->codeSize;
    pflate->codeSize += 8;
  }
  c = pflate->codeBuf & ((1 << bits) - 1);
  pflate->codeBuf >>= bits;
  pflate->codeSize -= bits;
  return c;
}

