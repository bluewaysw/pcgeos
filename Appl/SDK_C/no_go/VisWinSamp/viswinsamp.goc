/***********************************************************************
 *
 *	Copyright (c) GeoWorks 1991 -- All Rights Reserved
 *
 * PROJECT:	PC GEOS
 * MODULE:	VisWinSamp (Sample PC GEOS application)
 * FILE:	visSamp.goc
 * AUTHOR:	Chris Hawley 8/20/91
 *
 * DESCRIPTION:
 *	This file source code for the VisWinSamp application. This code will
 *	be compiled by ???, and then linked by the GLUE linker to produce
 *	a runnable .geo application file.
 *
 * RCS STAMP:
 *	$Id: viswinsamp.goc,v 1.1 97/04/04 16:38:13 newdeal Exp $
 *
 ***********************************************************************/

/*
 ***************************************************************************
 *		Include files
 ***************************************************************************
 */

@include <stdapp.goh>

/*
 ***************************************************************************
 *		Class & Message Definitions
 ***************************************************************************
 */

/*
 * Here we define "VisWinSampProcessClass" as a subclass of the system provided
 * "GenProcessClass". As this application is launched, an instance of this class
 * will be created, and will handle all application-related events (messages).
 * The application thread will be responsible for running this object,
 * meaning that whenever this object handles a method, we will be executing
 * in the application thread.
 */

@class	VisWinSampProcessClass, GenProcessClass ;

/* define methods for this class here. */

@message void MSG_MAKE_ROTARY_PHONE();
@message void MSG_MAKE_BUTTON_PHONE();

@endc   /* end of class definition */

/*
 * This class definition must be stored in memory at runtime, so that
 * the PC/GEOS messaging system can examine it.
 *
 * The neverSaved flag is necessary because ProcessClass objects are
 * hybrid objects.
 */

@classdecl	VisWinSampProcessClass, neverSaved ;

/*
 ***************************************************************************
 *		VisWinSampNumberClass 
 ***************************************************************************
 */

@class	VisWinSampNumberClass, VisClass ;

@message void MSG_VIS_SAMP_NUMBER_SET_STATE(byte stateToSet, byte stateToClear);
@message byte MSG_VIS_SAMP_NUMBER_GET_STATE();
@message void MSG_VIS_SAMP_NUMBER_OPEN_WIN_HERE();
@message void MSG_VIS_SAMP_NUMBER_CLOSE_WIN_HERE();

/* state flags */
#define VSNS_LONG_TEXT	0x80
#define VSNS_MOUSE_DOWN 0x40
#define VSNS_SELECTED   0x20

#define NUMBER_TEXT_HEIGHT 36.0

	@instance @visMoniker VSNI_shortMoniker;
	@instance @visMoniker VSNI_longMoniker;
	@instance word VSNI_xOffset = 0;
	@instance word VSNI_yOffset = 0;
	@instance byte VSNI_state = 0;
@endc
@classdecl	VisWinSampNumberClass ;

/*
 ***************************************************************************
 *		VisWinSampCompClass 
 ***************************************************************************
 */

@class VisWinSampCompClass, VisCompClass ;

@message void MSG_VIS_SAMP_COMP_SET_STATE(byte stateToSet = cl, byte stateToClear = ch); 
@message byte MSG_VIS_SAMP_COMP_GET_STATE();

@message void MSG_VIS_SAMP_COMP_INC_DRAW_COLOR();
@message byte MSG_VIS_SAMP_COMP_GET_DRAW_COLOR();

/* state flags */
#define VSCS_ROTARY_STYLE	0x80


	@instance byte VSCI_state = 0;
        @instance TempGeoDataParams VSCI_tempGeoData = {0, 0, 0, 0};
        @instance byte VSCI_drawColor = C_LIGHT_CYAN;

@endc
@classdecl	VisWinSampCompClass ;

/*
 ***************************************************************************
 *		VisWinSampWinClass 
 *
 * This is our floating window, which we'll try to open under an object 
 * that is clicked on.  It is a window which gets its own MSG_EXPOSE
 * events.   We have to subclass this object to handle MSG_VIS_OPEN_WIN
 * and MSG_VIS_CLOSE_WIN.
 *
 ***************************************************************************
 */
@class VisWinSampWinClass, VisCompClass ;

  @default VI_typeFlags = VTF_IS_COMPOSITE | VTF_IS_WINDOW;

  /* We don't our parent to manage this object like it does the other objects.
   * We'll set its bounds manually.
   */
  @default VI_geoAttrs = VA_DRAWABLE | VA_DETECTABLE | VA_FULLY_ENABLED;

@endc
@classdecl	VisWinSampWinClass ;



/*
 ***************************************************************************
 *		VisWinSampContentClass 
 ***************************************************************************
 */

/*
 * We have to subclass the content here because the geometry manager requires
 * that if you do certain justifications (here, we're centering vertically
 * in a horizontal object) we have to subclass MSG_VIS_COM_SAVE_RESTORE_
 * TEMP_GEO_DATA and MSG_VIS_COMP_RESTORE_TEMP_GEO_DATA to keep some temporary
 * variables for the geometry manager.
 */
@class VisWinSampContentClass, VisContentClass ;

        @instance TempGeoDataParams VSCNI_tempGeoData = 0;
@endc
@classdecl	VisWinSampContentClass ;

/*
 *		Application Object
 *
 * The very top-level generic object of an application MUST be a GenApplication
 * object. The visSamp.gp file contains "appobj" statement which indicates
 * that this "VisWinSampApp" object is in fact the top-level UI object.
 * This object should be in its own resource so that GeoManager can load it
 * quickly to grab the icon for this application. GeoManager will store this
 * icon in its "Token Database", so that the icon image can be reused quickly.
 */

@start	AppResource ;

@object GenApplicationClass VisWinSampApp = {
    /*
     * The geoManager uses this token information to store this application's
     * icon in a database.
     *
     * Four letters used as index to refer to this application in the token
     * database.
     */


    GI_visMoniker = list { VisWinSampTextMoniker }

    /*
     * Manufacturer ID number. Also used for accessing database, to ensure
     * uniqueness.
     */


    /*
     * The GenApplication object only has one child: the main application
     * window.
     */

    GI_comp = VisWinSampPrimary;

    /*
     * The main window should appear on-screen when the application is
     * launched.
     */

    gcnList(MANUFACTURER_ID_GEOWORKS,GAGCNLT_WINDOWS) = VisWinSampPrimary;
}

@visMoniker VisWinSampTextMoniker = "C VisWinSamp";

@end	AppResource

/*
 *		Primary window
 *
 * Every application has at least one GenPrimary object. This object serves
 * as the main window of the application. Inside this window, various UI
 * components, such as menus or lists, can be placed.
 */

@start	Interface		/* this resource is for misc UI objects */ ;

@object GenPrimaryClass VisWinSampPrimary  = {

    GI_comp = VisWinSampView, RotaryTrigger, ButtonTrigger, ColorTrigger;		
					

    ATTR_GEN_DISPLAY_NOT_MINIMIZABLE;
    HINT_SIZE_WINDOW_AS_RATIO_OF_PARENT = {
		   SWSS_RATIO | PCT_80, 
		   SWSS_RATIO | PCT_60
    };   
}

@object GenTriggerClass RotaryTrigger = {
    GI_visMoniker = "Rotary";
    GTI_destination = process;
    GTI_actionMsg = MSG_MAKE_ROTARY_PHONE;
}

@object GenTriggerClass ButtonTrigger = {
    GI_visMoniker = "Normal";
    GTI_destination = process;
    GTI_actionMsg = MSG_MAKE_BUTTON_PHONE;
}

@object GenTriggerClass ColorTrigger = {
    GI_visMoniker = "Color";
    GTI_destination = MySampComp;
    GTI_actionMsg = MSG_VIS_SAMP_COMP_INC_DRAW_COLOR;
}


/*
 *		GenView object
 *
 * This GenView object creates a window where the application can display
 * portions of the document as necessary. As we want this window to be
 * scrollable, the specific UI (Motif) will create scroll bars which the
 * user can interact with. Whenever a portion of the window needs to be
 * redrawn, the GenView object will invalidate a portion of the window,
 * causing a MSG_META_EXPOSED to be sent to the application. The application
 * will draw the document into the window as requested. The window keeps
 * track of a mask, which is used to clip the application's drawing operations,
 * so that only the invalid portion of the window is drawn to.
 */

@object GenViewClass VisWinSampView = {
    /*
     * We'll have the view run a VisContent object, in the UI thread, same as
     * the view.  
     */
    GVI_content = VisWinSampContent;

    /* Choose a pretty color. The other arguments are used for RGB colors.
     * we'll just choose on of the 16 standard EGA colors.
     */
    GVI_color = { C_CYAN, 0, 0, 0 };
}

@object VisWinSampContentClass VisWinSampContent = { 

    /* We'll let the content to size itself according to the view.  We'll
     * let the view be any size it wants.
     */
    VCNI_attrs = @default | VCNA_SAME_WIDTH_AS_VIEW | 
                            VCNA_SAME_HEIGHT_AS_VIEW; 


    /* Define children for the content */
    VCI_comp = MySampComp;  

    /* Center the child comp horizontally and vertically.
     * The expand flags allow the content to get larger than the space the
     * children need.  VisComp's by default don't get any larger than the
     * children require.
     */
    VCI_geoDimensionAttrs = @default | WJ_CENTER_CHILDREN_HORIZONTALLY
                                     | HJ_CENTER_CHILDREN_VERTICALLY
				     | GDA_EXPAND_HEIGHT_TO_FIT_PARENT
				     | GDA_EXPAND_WIDTH_TO_FIT_PARENT;
}

/* Set up a composite to hold all our buttons. */

@object VisWinSampCompClass MySampComp = {
	/* Set up some children, with some default numbers */
	VCI_comp = MySampNum1,  MySampNum2, MySampNum3,
		   MySampNum4,  MySampNum5, MySampNum6, 
		   MySampNum7,  MySampNum8, MySampNum9, 
		   MySampNumAst,MySampNum0, MySampNumHash; 

	/* Set up some default geometry stuff, in case we manage children 
	 * Also, we'll plan on wrapping after 3 items no matter what.
	 * Also, we'll make sure we keep a minimum width regardless of the
	 * total size of the children or the passed width (this gets set
	 * in MSG_VIS_SET_MINIMUM_SIZE.)
	 */
	VCI_geoAttrs = @default | VCGA_ALLOW_CHILDREN_TO_WRAP | 
	                          VCGA_WRAP_AFTER_CHILD_COUNT |
	                          VCGA_HAS_MINIMUM_SIZE;
	
}

/* Set up our buttons.  We'll use a macro to make the definitions easier. */

@define defSampNumber(NAME,SHORT,LONG,XOFF,YOFF) \
	@object VisWinSampNumberClass NAME = { \
	    VSNI_shortMoniker = SHORT; \
	    VSNI_longMoniker = LONG; \
	    VSNI_xOffset = XOFF; \
	    VSNI_yOffset = YOFF; \
	}

@defSampNumber(MySampNum0, "0", "Zero", 10, 10)
@defSampNumber(MySampNum1, "1", "One", 10, 1)
@defSampNumber(MySampNum2, "2", "Two", 7, 0)
@defSampNumber(MySampNum3, "3", "Three", 4, 0)
@defSampNumber(MySampNum4, "4", "Four", 1, 1)
@defSampNumber(MySampNum5, "5", "Five", 0, 4)
@defSampNumber(MySampNum6, "6", "Six", 0, 7)
@defSampNumber(MySampNum7, "7", "Seven", 1, 10)
@defSampNumber(MySampNum8, "8", "Eight", 4, 11)
@defSampNumber(MySampNum9, "9", "Nine", 7, 11)
@defSampNumber(MySampNumAst, "*", "Asterisk", 0, 0)
@defSampNumber(MySampNumHash, "#","Hash mark", 0, 0) 


@object VisWinSampWinClass MyFloatingWin = {
  VCI_comp = MySampWinNum;
  VI_geoAttrs = VA_DRAWABLE | VA_DETECTABLE | VA_FULLY_ENABLED;
}

@defSampNumber(MySampWinNum, "BANG!", "BANG BANG BANG!", 0, 0)

@end Interface

/***********************************************************************
 *
 * Handlers for VisWinSampProcessClass
 *
 ***********************************************************************/
/***********************************************************************
 *
 * MESSAGE:	MSG_MAKE_ROTARY_PHONE for VisWinSampProcessClass
 *
 * DESCRIPTION:	Makes rotary phone out of this thing.
 *
 * PARAMETERS:  void ()
 *
 * STRATEGY:
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	chris	8/28/91		Initial Revision
 *
 ***********************************************************************/
@method VisWinSampProcessClass, MSG_MAKE_ROTARY_PHONE 
{
  @send MySampComp::MSG_VIS_SAMP_COMP_SET_STATE(VSCS_ROTARY_STYLE, 0); 
}
/***********************************************************************
 *
 * MESSAGE:	MSG_MAKE_BUTTON_PHONE for VisWinSampProcessClass
 *
 * DESCRIPTION:	Makes button phone out of this thing.
 *
 * PARAMETERS:  void ()
 *
 * STRATEGY:
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	chris	8/28/91		Initial Revision
 *
 ***********************************************************************/
@method VisWinSampProcessClass, MSG_MAKE_BUTTON_PHONE 
{
  @send MySampComp::MSG_VIS_SAMP_COMP_SET_STATE(0, VSCS_ROTARY_STYLE); 
}

/***********************************************************************
 *
 * Handlers for VisWinSampContentClass
 *
 ***********************************************************************/
/***********************************************************************
 *
 * MESSAGE:	MSG_VIS_COMP_SAVE_TEMP_GEO_DATA for VisWinSampContentClass
 *
 * DESCRIPTION:	Since our composite wraps, it has to handle save and 
 *              restore messages for temporary geometry data.  We'll
 *              just store it in our instance data.
 *
 * PARAMETERS:  void (word wrapData, word leftCenterData, word rightCenterData)
 *
 * STRATEGY:
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	chris	8/28/91		Initial Revision
 *
 ***********************************************************************/
@method VisWinSampContentClass, MSG_VIS_COMP_SAVE_TEMP_GEO_DATA
{
  pself->VSCNI_tempGeoData.TGDP_wrapData = wrapData;
  pself->VSCNI_tempGeoData.TGDP_leftCenterData = leftCenterData;
  pself->VSCNI_tempGeoData.TGDP_rightCenterData = rightCenterData;
}

@method VisWinSampContentClass, MSG_VIS_COMP_RESTORE_TEMP_GEO_DATA
{
  retValue->TGDP_wrapData = pself->VSCNI_tempGeoData.TGDP_wrapData;
  retValue->TGDP_leftCenterData = pself->VSCNI_tempGeoData.TGDP_leftCenterData;
  retValue->TGDP_rightCenterData= pself->VSCNI_tempGeoData.TGDP_rightCenterData;
}



/***********************************************************************
 *
 * Handlers for VisWinSampCompClass
 *
 ***********************************************************************/

/***********************************************************************
 *
 * MESSAGE:	MSG_VIS_SAMP_COMP_SET_STATE for VisWinSampCompClass
 *
 * DESCRIPTION:	Sets our composite's state.  Does any updates required
 *              by the new state.
 *
 * PARAMETERS:  void (byte)
 *
 * STRATEGY:
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	chris	8/28/91		Initial Revision
 *
 ***********************************************************************/
@method VisWinSampCompClass, MSG_VIS_SAMP_COMP_SET_STATE 
{
    /* Only do something if the flag passed changes the rotary flag */
    if ((pself->VSCI_state ^ stateToSet) & VSCS_ROTARY_STYLE ||
        (pself->VSCI_state ^ ~stateToSet) & VSCS_ROTARY_STYLE) {

	pself->VSCI_state |= stateToSet;
	pself->VSCI_state &= ~stateToClear;

	/* If we're doing to a rotary phone, we'll set one object not
	 * drawable and remove the other one from the vis tree altogether.
	 */

	if (stateToSet & VSCS_ROTARY_STYLE) {
		/* Set the asterisk not drawable. */
		@call MySampNumAst::MSG_VIS_SET_ATTRS
			(0, VA_DRAWABLE, VUM_DELAYED_VIA_APP_QUEUE);

		/* Close the hash button, then remove from vis tree */
		@call MySampNumHash::MSG_VIS_CLOSE();

		@call self::MSG_VIS_REMOVE_CHILD
			((optr) &MySampNumHash, 0);
		
	} else {
		/* Set the asterisk drawable */
		@call MySampNumAst::MSG_VIS_SET_ATTRS
			(VA_DRAWABLE, 0, VUM_DELAYED_VIA_APP_QUEUE);

		/* Add the hash mark to the tree, then mark it invalid */
		@call self::MSG_VIS_ADD_CHILD
			((optr) &MySampNumHash, CCO_LAST);

		@call MySampNumHash::MSG_VIS_MARK_INVALID
			(VOF_WINDOW_INVALID, VUM_DELAYED_VIA_APP_QUEUE);
	}

	/* Mark our geometry invalid, so it gets redone.  Also mark the
	 * image invalid, too, as the size may not change but we definitely
	 * want to redraw.
	 */
	@call self::MSG_VIS_MARK_INVALID(
			 VOF_GEOMETRY_INVALID | VOF_IMAGE_INVALID,
			 VUM_NOW);
      }
}

/***********************************************************************
 *
 * MESSAGE:	MSG_VIS_SAMP_COMP_GET_STATE for VisWinSampCompClass
 *
 * DESCRIPTION:	Returns the current state.
 *
 * PARAMETERS:  byte ()
 *
 * STRATEGY:
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	chris	8/28/91		Initial Revision
 *
 ***********************************************************************/
@method VisWinSampCompClass, MSG_VIS_SAMP_COMP_GET_STATE 
{
	return(pself->VSCI_state);
}

/***********************************************************************
 *
 * MESSAGE:	MSG_VIS_COMP_SAVE_TEMP_GEO_DATA for VisWinSampCompClass
 *
 * DESCRIPTION:	Since our composite wraps, it has to handle save and 
 *              restore messages for temporary geometry data.  We'll
 *              just store it in our instance data.
 *
 * PARAMETERS:  void (word wrapData, word leftCenterData, word rightCenterData)
 *
 * STRATEGY:
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	chris	8/28/91		Initial Revision
 *
 ***********************************************************************/
@method VisWinSampCompClass, MSG_VIS_COMP_SAVE_TEMP_GEO_DATA
{
  pself->VSCI_tempGeoData.TGDP_wrapData = wrapData;
  pself->VSCI_tempGeoData.TGDP_leftCenterData = leftCenterData;
  pself->VSCI_tempGeoData.TGDP_rightCenterData = rightCenterData;
}

@method VisWinSampCompClass, MSG_VIS_COMP_RESTORE_TEMP_GEO_DATA
{
  retValue->TGDP_wrapData = pself->VSCI_tempGeoData.TGDP_wrapData;
  retValue->TGDP_leftCenterData = pself->VSCI_tempGeoData.TGDP_leftCenterData;
  retValue->TGDP_rightCenterData = pself->VSCI_tempGeoData.TGDP_rightCenterData;
}

/***********************************************************************
 *
 * MESSAGE:	MSG_VIS_COMP_GET_WRAP_COUNT for VisWinSampCompClass
 *
 * DESCRIPTION:	Returns the number of children to go through before forcing
 *              a wrap.
 *
 * PARAMETERS:  word ()
 *
 * STRATEGY:
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	chris	8/28/91		Initial Revision
 *
 ***********************************************************************/
@method VisWinSampCompClass, MSG_VIS_COMP_GET_WRAP_COUNT 
{
  return (3);
}


/***********************************************************************
 *
 * MESSAGE:	MSG_VIS_COMP_GET_SPACING for VisWinSampCompClass
 *
 * DESCRIPTION:	Returns the amount of spacing between children.
 *
 * PARAMETERS:  SpacingAsDWord ()
 *
 * STRATEGY:
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	chris	8/28/91		Initial Revision
 *
 ***********************************************************************/
#define CHILD_SPACING 15
#define WRAP_SPACING  15

@method VisWinSampCompClass, MSG_VIS_COMP_GET_CHILD_SPACING
{
  return(MAKE_SPACING_DWORD(CHILD_SPACING, WRAP_SPACING));
}

/***********************************************************************
 *
 * MESSAGE:	MSG_VIS_COMP_GET_MARGINS for VisWinSampCompClass
 *
 * DESCRIPTION:	Returns margins for the composite.
 *
 * PARAMETERS:  void (rectangle *far retValue)
 *
 * STRATEGY:
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	chris	8/28/91		Initial Revision
 *
 ***********************************************************************/
#define SAMP_COMP_MARGIN 10

@method VisWinSampCompClass, MSG_VIS_COMP_GET_MARGINS 
{
  retValue->R_left = SAMP_COMP_MARGIN;
  retValue->R_right = SAMP_COMP_MARGIN;
  retValue->R_top = SAMP_COMP_MARGIN;
  retValue->R_bottom = SAMP_COMP_MARGIN;
}


/***********************************************************************
 *
 * MESSAGE:	MSG_VIS_COMP_GET_MINIMUM_SIZE for VisWinSampCompClass
 *
 * DESCRIPTION:	Returns a minimum size for the composite, regardless
 *              of what the passed size is or how big the children
 *              are.
 *
 * PARAMETERS:  SizeAsDWord ()
 *
 * STRATEGY:    We use this here to keep the composite from getting too
 *              small to wrap three children.  It would be a pretty silly
 *              looking phone if we let it have a one button wide column
 *              of buttons.  We could also accomplish this by using a
 *              HINT_MINIMUM_SIZE for the GenView, but this is more direct
 *              and this object knows the most about how the children
 *              are laid out.  (It also leaves room for the rotary version).
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	chris	8/28/91		Initial Revision
 *
 ***********************************************************************/
#define MINIMUM_BUTTON_WIDTH 210
#define MINIMUM_ROTARY_WIDTH 280

@method VisWinSampCompClass, MSG_VIS_COMP_GET_MINIMUM_SIZE 
{
  word retWidth;

  /* Guess at a big enough width, don't care about height */

  if (pself->VSCI_state & VSCS_ROTARY_STYLE) {
    return (MAKE_SIZE_DWORD(MINIMUM_ROTARY_WIDTH, 0));
  } else {
    return (MAKE_SIZE_DWORD(MINIMUM_BUTTON_WIDTH, 0));
  }
}


/***********************************************************************
 *
 * MESSAGE:	MSG_VIS_SAMP_COMP_INC_DRAW_COLOR for VisWinSampCompClass
 *
 * DESCRIPTION:	Increments the draw color.
 *
 * PARAMETERS:  void ()
 *
 * STRATEGY:
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	chris	9/ 2/91		Initial Revision
 *
 ***********************************************************************/
@method VisWinSampCompClass, MSG_VIS_SAMP_COMP_INC_DRAW_COLOR 
{
  pself->VSCI_drawColor = (pself->VSCI_drawColor + 1) & 15;
/*  @send genChildren::MSG_VIS_INVALIDATE;  */
}


/***********************************************************************
 *
 * MESSAGE:	MSG_VIS_SAMP_COMP_GET_DRAW_COLOR for VisWinSampCompClass
 *
 * DESCRIPTION:	Returns current draw color.
 *
 * PARAMETERS:  void ()
 *
 * STRATEGY:
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	chris	9/ 2/91		Initial Revision
 *
 ***********************************************************************/
@method VisWinSampCompClass, MSG_VIS_SAMP_COMP_GET_DRAW_COLOR 
{
  return(pself->VSCI_drawColor);
}

/***********************************************************************
 *
 * Handlers for VisWinSampNumberClass
 *
 ***********************************************************************/


/***********************************************************************
 *
 * MESSAGE:	MSG_VIS_DRAW for VisWinSampNumberClass
 *
 * DESCRIPTION:	Handles drawing.
 *
 * PARAMETERS:  void (word drawFlags, GStateHandle gstate)
 *
 * STRATEGY:
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *      This doesn't deal with black-and-white systems at all.
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	chris	8/28/91		Initial Revision
 *
 ***********************************************************************/
@method VisWinSampNumberClass, MSG_VIS_DRAW 
{
	MonikerMessageParams mkrParams;
	byte parentState;
	byte leftTopColor, rightBottomColor, fillColor;

	parentState = @call MySampComp::MSG_VIS_SAMP_COMP_GET_STATE();

        GrSetFont(gstate, FID_DTC_URW_ROMAN, MakeWWFixed(NUMBER_TEXT_HEIGHT));
	GrSetTextColor (gstate, CF_INDEX, C_BLACK, 0, 0);

	/* Use different colors if the object is selected. */

	if (pself->VSNI_state & VSNS_SELECTED) {
	  leftTopColor = C_BLACK;
	  rightBottomColor = C_WHITE;
	  fillColor = C_DARK_GREY;
	} else {
	  leftTopColor = C_WHITE;
	  rightBottomColor = C_BLACK;
/*	  fillColor = @call genParent::MSG_VIS_SAMP_COMP_GET_DRAW_COLOR(); */
	  fillColor = @call MySampComp::MSG_VIS_SAMP_COMP_GET_DRAW_COLOR(); 
	}


	if (parentState & VSCS_ROTARY_STYLE) {
	        GrSetAreaColor (gstate, CF_INDEX, fillColor, 0, 0);
		GrFillEllipse (gstate, pself->VI_bounds.R_left,
				   pself->VI_bounds.R_top,
				   pself->VI_bounds.R_right,
				   pself->VI_bounds.R_bottom);

	        GrSetLineColor (gstate, CF_INDEX, leftTopColor, 0, 0);
		GrDrawArc (gstate, pself->VI_bounds.R_left,
				   pself->VI_bounds.R_top,
				   pself->VI_bounds.R_right,
				   pself->VI_bounds.R_bottom,
			           45, 225);

	        GrSetLineColor (gstate, CF_INDEX, rightBottomColor, 0, 0);
		GrDrawArc (gstate, pself->VI_bounds.R_left,
				   pself->VI_bounds.R_top,
				   pself->VI_bounds.R_right,
				   pself->VI_bounds.R_bottom,
			           225, 45);
	} else {
	        GrSetAreaColor (gstate, CF_INDEX, fillColor, 0, 0);
		GrFillRect (gstate, pself->VI_bounds.R_left,
				   pself->VI_bounds.R_top,
				   pself->VI_bounds.R_right-1,
				   pself->VI_bounds.R_bottom-1);

	        /* Draw a rectangle, with a cute border around it. */

	        GrSetLineColor (gstate, CF_INDEX, leftTopColor, 0, 0);
		GrDrawVLine (gstate, pself->VI_bounds.R_left,
			             pself->VI_bounds.R_top,
			             pself->VI_bounds.R_bottom-1);

		GrDrawHLine (gstate, pself->VI_bounds.R_left,
			             pself->VI_bounds.R_top,
			             pself->VI_bounds.R_right-1);

	        GrSetLineColor (gstate, CF_INDEX, rightBottomColor, 0, 0);
		GrDrawVLine (gstate, pself->VI_bounds.R_right,
			             pself->VI_bounds.R_top,
			             pself->VI_bounds.R_bottom-1);

		GrDrawHLine (gstate, pself->VI_bounds.R_left+1,
			             pself->VI_bounds.R_bottom,
			             pself->VI_bounds.R_right-1);

		GrDrawVLine (gstate, pself->VI_bounds.R_right,
			             pself->VI_bounds.R_top+1,
			             pself->VI_bounds.R_bottom);

		GrDrawHLine (gstate, pself->VI_bounds.R_left+1,
			             pself->VI_bounds.R_bottom,
			             pself->VI_bounds.R_right);
	}

	/* Attempt to draw a moniker for this thing. */

	if (pself->VSNI_state & VSNS_LONG_TEXT) {
		mkrParams.MMP_visMoniker = pself->VSNI_longMoniker;
	} else {
		mkrParams.MMP_visMoniker = pself->VSNI_shortMoniker;
	}
	mkrParams.MMP_textHeight = 0;
	mkrParams.MMP_monikerFlags = J_CENTER << 2 | J_CENTER;
	mkrParams.MMP_gState = gstate;
	@call self::MSG_VIS_DRAW_MONIKER(&mkrParams);
}

/***********************************************************************
 *
 * MESSAGE:	MSG_VIS_POSITION_BRANCH for VisWinSampNumberClass
 *
 * DESCRIPTION:	Positions an object and all its children at the offset
 *              given.  
 *
 * PARAMETERS:  void (word xOffset, word yOffset)
 *
 * STRATEGY:    We actually cheat in rotary mode and position the children
 *              in a different place than what is passed, we we can do our
 *              own positioning.
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	chris	8/28/91		Initial Revision
 *
 ***********************************************************************/
@method VisWinSampNumberClass, MSG_VIS_POSITION_BRANCH 
{
        byte parentState;
	word newXOrigin, newYOrigin;
	word phoneIncrement;
	SizeAsDWord parentSize, ourSize, availSize;
	Rectangle parentBounds;

	/* Based on the current parent state, we'll either act like a good boy,
	 * and position ourselves as our parent asked, or we'll force our
	 * position based on the position hints in the instance data.
	 */

	parentState = @call MySampComp::MSG_VIS_SAMP_COMP_GET_STATE();
	if (parentState & VSCS_ROTARY_STYLE) {
	        /* First, let's calculate how large a phone to create.  It must
	         * be a multiple of 13, and is based on the parent comp's size.
	         */
#if 0
		parentSize = @call MySampComp::MSG_VIS_GET_SIZE();
		ourSize = @call self::MSG_VIS_GET_SIZE();
		availSize = MAKE_SIZE_DWORD(
			  DWORD_WIDTH(parentSize) < DWORD_WIDTH(ourSize)
			  ? DWORD_WIDTH(parentSize)-DWORD_WIDTH(ourSize) : 0,

			  DWORD_HEIGHT(parentSize) < DWORD_HEIGHT(ourSize)
			  ? DWORD_HEIGHT(parentSize)-DWORD_HEIGHT(ourSize) : 0);
#else
		availSize = @call MySampComp::MSG_VIS_GET_SIZE();
#endif

		phoneIncrement = 
		  ((DWORD_WIDTH(availSize) > DWORD_HEIGHT(availSize)) ?
		     DWORD_HEIGHT(availSize) : DWORD_WIDTH(availSize));

		phoneIncrement /= 13;

		@call MySampComp::MSG_VIS_GET_BOUNDS(&parentBounds);

		newXOrigin = phoneIncrement * pself->VSNI_xOffset
		             + parentBounds.R_left;
		newYOrigin = phoneIncrement * pself->VSNI_yOffset
		             + parentBounds.R_top;
		@call self::MSG_VIS_SET_POSITION(newXOrigin, newYOrigin);
	} else {
#if 0
	        @callsuper self::VisWinSampNumberClass::MSG_VIS_POSITION_BRANCH
		     (xOrigin, yOrigin);   
#else
	        @call self::MSG_VIS_SET_POSITION(xOrigin, yOrigin);
#endif
	}
}


/***********************************************************************
 *
 * MESSAGE:	MSG_VIS_SAMP_NUMBER_SET_STATE for VisWinSampNumberClass
 *
 * DESCRIPTION:	Sets the state.
 *
 * PARAMETERS:  void (byte stateToSet, byte stateToClear)
 *
 * STRATEGY:
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	chris	8/28/91		Initial Revision
 *
 ***********************************************************************/
@method VisWinSampNumberClass, MSG_VIS_SAMP_NUMBER_SET_STATE 
{
	pself->VSNI_state |= stateToSet;
	pself->VSNI_state &= ~stateToClear;
}

/***********************************************************************
 *
 * MESSAGE:	MSG_VIS_SAMP_NUMBER_GET_STATE for VisWinSampNumberClass
 *
 * DESCRIPTION:	Returns the current state.
 *
 * PARAMETERS:  byte ()
 *
 * STRATEGY:
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	chris	8/28/91		Initial Revision
 *
 ***********************************************************************/
@method VisWinSampNumberClass, MSG_VIS_SAMP_NUMBER_GET_STATE 
{
	return(pself->VSNI_state);
}


/***********************************************************************
 *
 * MESSAGE:	MSG_VIS_RECALC_SIZE for VisWinSampNumberClass
 *
 * DESCRIPTION:	Chooses a size for the object.
 *
 * PARAMETERS:  SizeAsDWord (word width, word height)
 *
 * STRATEGY:    We ignore what is passed and choose our own size, based on
 *              the size of our parent.
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	chris	8/28/91		Initial Revision
 *
 ***********************************************************************/
#define	NUMBER_Y_INSET	6
#define NUMBER_X_INSET  6

@method VisWinSampNumberClass, MSG_VIS_RECALC_SIZE 
{
	word retWidth;
	word retHeight;
	SizeAsDWord monikerSize;
	MonikerMessageParams mkrParams;
	GStateHandle gstate;

	/* Get the size of the moniker, including our margins */
	gstate = @call self::MSG_VIS_VUP_CREATE_GSTATE();
        GrSetFont(gstate, FID_DTC_URW_ROMAN, MakeWWFixed(NUMBER_TEXT_HEIGHT));

	if (pself->VSNI_state & VSNS_LONG_TEXT) {
		mkrParams.MMP_visMoniker = pself->VSNI_longMoniker;
	} else {
		mkrParams.MMP_visMoniker = pself->VSNI_shortMoniker;
	}
	mkrParams.MMP_textHeight = 0;
	mkrParams.MMP_monikerFlags = J_CENTER << 2 | J_CENTER;
	mkrParams.MMP_gState = gstate;    /* don't have a gstate */
	monikerSize = @call self::MSG_VIS_GET_MONIKER_SIZE(&mkrParams);
	retWidth = DWORD_WIDTH(monikerSize) + NUMBER_X_INSET*2;
	retHeight = DWORD_HEIGHT(monikerSize) + NUMBER_Y_INSET*2;

	/* Take the larger of the width and height, and return it for both
	 * the width and the height, to make it square.  (Only if we're
	 * using a small moniker.)
	 */
	if (!(pself->VSNI_state & VSNS_LONG_TEXT)) {
	  if (retWidth < retHeight) {
	    retWidth = retHeight;
	  } else {
	    retHeight = retWidth;
	  }
	}

	GrDestroyState(gstate);

	return(MAKE_SIZE_DWORD(retWidth, retHeight));
}


byte EnsureSelectedState(byte newState, byte *oldState) {
  if (newState) {
    if (!(*oldState & VSNS_SELECTED)) {
      *oldState = *oldState | VSNS_SELECTED;
      return (-1);
    } else {
      return (0);
    }
  } else {
    if (*oldState & VSNS_SELECTED) {
      *oldState = *oldState & ~VSNS_SELECTED;
      return (-1);
    } else {
      return (0);
    }
  }
}

/***********************************************************************
 *
 * MESSAGE:	MSG_META_START_SELECT for VisWinSampNumberClass
 *
 * DESCRIPTION:	Handles a start select from the application.
 *
 * PARAMETERS:
 *	void (word xPosition, word yPosition, word inputState,
 *						MouseReturnParams *retVal)
 *
 * STRATEGY:
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	chris	8/28/91		Initial Revision
 *
 ***********************************************************************/
@method VisWinSampNumberClass, MSG_META_START_SELECT 
{
  pself->VSNI_state = pself->VSNI_state | VSNS_MOUSE_DOWN;

  /* Grab the mouse, and make sure we get pointer events. */
  @call self::MSG_VIS_GRAB_MOUSE();
  @call self::MSG_VIS_SEND_ALL_PTR_EVENTS();

  if (EnsureSelectedState(VSNS_SELECTED, &(pself->VSNI_state))) {
    @call self::MSG_VIS_REDRAW_ENTIRE_OBJECT();
  }

  @call self::MSG_VIS_SAMP_NUMBER_OPEN_WIN_HERE();

  /* Say we handled this method, and we want to return to the default cursor
   * in case someone else set a special cursor previously.
   */
  retVal->flags = MRF_PROCESSED | MRF_CLEAR_POINTER_IMAGE;
}





/***********************************************************************
 *
 * MESSAGE:	MSG_META_END_SELECT for VisWinSampNumberClass
 *
 * DESCRIPTION:	Handles a end select from the application.
 *
 * PARAMETERS:
 *	void (word xPosition, word yPosition, word inputState,
 *						MouseReturnParams *retVal)
 *
 * STRATEGY:
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	chris	8/28/91		Initial Revision
 *
 ***********************************************************************/
@method VisWinSampNumberClass, MSG_META_END_SELECT 
{
  if (pself->VSNI_state & VSNS_MOUSE_DOWN) {

      pself->VSNI_state = pself->VSNI_state & ~VSNS_MOUSE_DOWN;

      /* Release the mouse grab */
      @call self::MSG_VIS_RELEASE_MOUSE();

      if (EnsureSelectedState(0, &(pself->VSNI_state))) {
	 /*
          * Yes, the object was selected.  Let's redraw it and do whatever
	  * our desired action should be.
	  */
         @call self::MSG_VIS_REDRAW_ENTIRE_OBJECT();

	 @call self::MSG_VIS_SAMP_NUMBER_CLOSE_WIN_HERE();
      }
    }

  /* Say user has surrendered the mouse, and let some other object use the
   * message if they want it.
   */
  retVal->flags = MRF_REPLAY;
}






/***********************************************************************
 *
 * MESSAGE:	MSG_META_PTR for VisWinSampNumberClass
 *
 * DESCRIPTION:	Handles pointer events, once button has the grab.
 *
 * PARAMETERS:
 *	void (word xPosition, word yPosition, word inputState,
 *						MouseReturnParams *retVal)
 *
 * STRATEGY:
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	chris	8/28/91		Initial Revision
 *
 ***********************************************************************/
@method VisWinSampNumberClass, MSG_META_PTR 
{
  /* If the user moves off the button, and it's currently selected, we'll 
   * deselect it.  If the user moves over the button, and it's currently
   * not selected, we'll select it.
   */
  if (!(pself->VSNI_state & VSNS_MOUSE_DOWN)) {
    retVal->flags = MRF_REPLAY;
  } else {
    if ((xPosition < pself->VI_bounds.R_left) ||
      (xPosition > pself->VI_bounds.R_right) ||
      (yPosition < pself->VI_bounds.R_top) ||
      (yPosition > pself->VI_bounds.R_bottom)) {

      /* Moved off of the button, make sure deselected */
      if (EnsureSelectedState(0, &(pself->VSNI_state))) {
        @call self::MSG_VIS_REDRAW_ENTIRE_OBJECT();
      }
    
    } else {

      /* Moved over button, make sure selected */
      if (EnsureSelectedState(VSNS_SELECTED, &(pself->VSNI_state))) {
        @call self::MSG_VIS_REDRAW_ENTIRE_OBJECT();
      }
    }
   /* Say we handled this method, and we want to return to the default cursor
    * in case someone else set a special cursor previously.
    */
    retVal->flags = MRF_PROCESSED | MRF_CLEAR_POINTER_IMAGE;
  }
}


/***********************************************************************
 *
 * MESSAGE:	MSG_VIS_SAMP_NUMBER_OPEN_WINDOW_HERE for VisWinSampNumberClass
 *
 * DESCRIPTION:	Attaches the window object to our parent, and opens it, in
 *              order to have it drop below our object.
 *
 * PARAMETERS:  void()
 *
 * STRATEGY:
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	chris	9/ 4/91		Initial Revision
 *
 ***********************************************************************/
@method VisWinSampNumberClass, MSG_VIS_SAMP_NUMBER_OPEN_WIN_HERE {
        SizeAsDWord winSize;

        /* Open the floating win, after positioning it under us. */

        @call MyFloatingWin::MSG_VIS_SET_POSITION
	        (pself->VI_bounds.R_left, pself->VI_bounds.R_bottom+1);

	winSize = @call MyFloatingWin::MSG_VIS_RECALC_SIZE(
				RSA_CHOOSE_OWN_SIZE, RSA_CHOOSE_OWN_SIZE);

	@call MyFloatingWin::MSG_VIS_SET_SIZE(
		    DWORD_WIDTH(winSize), DWORD_HEIGHT(winSize));
	        
	@call MySampComp::MSG_VIS_ADD_CHILD
		((optr) &MyFloatingWin, CCO_LAST);

	@call MyFloatingWin::MSG_VIS_MARK_INVALID
		(VOF_WINDOW_INVALID, VUM_NOW);
}


/***********************************************************************
 *
 * MESSAGE:	MSG_VIS_SAMP_NUMBER_CLOSE_WIN_HERE for VisSampNumberClass
 *
 * DESCRIPTION:	Closes the floating window.
 *
 * PARAMETERS:  void()
 *
 * STRATEGY:
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	chris	9/ 4/91		Initial Revision
 *
 ***********************************************************************/
#if  0
@method VisSampNumberClass, MSG_VIS_SAMP_NUMBER_CLOSE_WIN_HERE {
   
        /* Close the floating window and remove it. */
	@call MyFloatingWin::MSG_VIS_CLOSE();

	@call MySampComp::MSG_VIS_REMOVE_CHILD
		((optr) &MyFloatingWin, 0);
		

}
#endif

/***********************************************************************
 *
 * Handlers for VisWinSampWinClass
 *
 ***********************************************************************/

/***********************************************************************
 *
 * MESSAGE:	MSG_VIS_OPEN_WIN for VisWinSampWinClass
 *
 * DESCRIPTION:	Opens a window for this object.
 *
 * PARAMETERS:  void(WindowHandle parentWindow)
 *
 * STRATEGY:
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	chris	9/ 4/91		Initial Revision
 *
 ***********************************************************************/
@method VisWinSampWinClass, MSG_VIS_OPEN_WIN {
  WindowHandle viewWin;

  viewWin = @call VisWinSampView::MSG_VIS_VUP_QUERY_GWIN();

  /* Open the window.  A moment of prayer before trying this. */

  if (!pself->VCI_window) {
    pself->VCI_window = 
      WinOpen(viewWin,                               /* parent window */
	  oself,                                     /* input recipient */
	  oself,                                     /* exposure recipient */
	  0, C_RED, 0, 0,                           /* color */
	  WIN_PRIO_ON_TOP,                           /* layer ID */
	  0,                                         /* flags */
	  MemOwner(OptrToHandle(oself)),             /* owner */
	  0,                                         /* region (null if rect) */
	  pself->VI_bounds.R_left,                   /* left bound */
	  pself->VI_bounds.R_top,                    /* top bound */
	  pself->VI_bounds.R_right,                  /* right bound */
	  pself->VI_bounds.R_bottom);                /* bottom bound */
  }
}


/***********************************************************************
 *
 * MESSAGE:	MSG_VIS_CLOSE_WIN for VisWinSampWinClass
 *
 * DESCRIPTION:	Handles closing the window.
 *
 * PARAMETERS:  void()
 *
 * STRATEGY:
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	chris	9/ 4/91		Initial Revision
 *
 ***********************************************************************/
@method VisWinSampWinClass, MSG_VIS_CLOSE_WIN {

  /* Close the window, if there is one. */
  if (pself->VCI_window) {
    WinClose(pself->VCI_window);
  }
}
