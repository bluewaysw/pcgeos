/****************************************************************************
*
*   Copyright (C) 1995-98 Breadbox Computer Company -=- All Right Reserved
*
*   PROJECT:    Graphics Viewer
*   MODULE:
*   FILE:       Main\Process.goc
*   AUTHOR:     20th January 1995
*
*   REVISION HISTROY:
*		 Written 1995-98 by Falk Rehwagen
*
*
****************************************************************************/

/*@define NEWDEAL_MEDIA_VIEWER  */
/*@define OLD_THUMBNAIL_DB  */
@define JPEG_SUPPORT

/**************************************************************************/

@include <stdapp.goh>
@include <Objects/gViewCC.goh>
@include <Objects/colorC.goh>
#include <IMPBMP/imp_bmp.h>
@include <statbar/statbar.goh>
#include <Ansi/string.h>
#include <gstring.h>
@include "MAIN/strings.goh"
#include "GRAPH/quant.h"
#include <initfile.h>
#include <graphics.h>
@include "bvdirmon.goh"

@ifndef OLD_THUMBNAIL_DB
@include <thumbdb.h>
@endif


/**************************************************************************/

#undef GSSetClipRect
#define GSSetClipRect(path,rl_sw,rt_sw,rr_sw,rb_sw)      \
		GR_SET_CLIP_RECT, GOC_WORD(path) , GOC_SW(rl_sw),                             \
	GOC_SW(rt_sw),GOC_SW(rr_sw),GOC_SW(rb_sw)

/**************************************************************************/

extern VMChain  /*XXX*/
	_pascal MyVMCopyVMChain(VMFileHandle sourceFile,
		  VMChain sourceChain,
		  VMFileHandle destFile);
extern VMChain  /*XXX*/
	_pascal MyVMFreeVMChain(VMFileHandle sourceFile,
				  VMChain sourceChain);

/**************************************************************************/

typedef struct
{
  FileDateAndTime BVFA_date;
  dword           BVFA_size;
  FileAttrs       BVFA_type;
  FileLongName    BVFA_name;
} BVFileAttr;

/**************************************************************************/

@ifdef OLD_THUMBNAIL_DB

void
ThumbCreateItem(FileLongName name, dword size, FileDateAndTime date,
				VMFileHandle file, VMBlockHandle block);

typedef struct
{
  DBGroupAndItem BVTDBM_firstItem;
  DBGroupAndItem BVTDBM_lastItem;
  word           BVTDBM_version;
} BVThumbDBMap;

typedef struct
{
  FileLongName BVTDBI_name;
  FileDateAndTime BVTDBI_date;
  dword BVTDBI_size;
  VMBlockHandle BVTDBI_thumbnail;
  DBGroupAndItem BVTDBI_next;
} BVThumbDBItem;

@endif

/**************************************************************************/

typedef struct
{
	char    BVSD_path[256];
	word    BVSD_attrs;
	Boolean BVSD_focus;
} BVStateData;

/**************************************************************************/

/*
static void SendSelectNotify(VMBlockHandle bmpblock);
*/

#define BITMAP_FORMAT FormatIDFromManufacturerAndType(MANUFACTURER_ID_GEOWORKS, \
							 CIF_BITMAP)

#define BV_BETTER_PALETTE 0x01

#define BV_SHOW_TOOLS       0x01
#define BV_IMP_INFO         0x02
#define BV_AUTOCLOSE_OBOX   0x04
#define BV_AUTOCREAT_THUMB  0x08
#define BV_USE_THUMBNAILS   0x10

#define BVA_BITMAP_OPEN     0x01
#define BVA_WIN_OPEN        0x02
#define BVA_SYS_TARGET      0x04

#define BVA_REALIZE_PALETTE 0x08

#define BV_SHOW_ALL         0
#define BV_SHOW_ALL_MEDIA   1
#define BV_SHOW_BMP         2
#define BV_SHOW_PCX         3
#define BV_SHOW_GIF         4
#define BV_SHOW_JPEG        5
#define BV_SHOW_PNG         6

/**************************************************************************/

word          BVAttrs2 = BVA_REALIZE_PALETTE;
DisplayClass  BVDisplayClass = 0;
Boolean       BVBrowserFocus = FALSE;

/* initial setting for file selection dialog */
DiskHandle BVCurrentDisk = SP_DOCUMENT;
PathName BVCurrentPath = "";

MemHandle BVFileList = NULL;
word BVFileNumber = 0;

@ifdef OLD_THUMBNAIL_DB
FileHandle BVThumbnailDB = 0;
@endif

/**************************************************************************/

@class BVProcessClass, GenProcessClass;
@message void MSG_BV_NO_FILE_SELECTED();
@message void MSG_BV_FILE_SELECTED();
@message void MSG_BV_UPDATE_OPEN_TRIGGER();
@message void MSG_BV_READ_THUMBNAILS();
@message void MSG_BV_DELETE_THUMBNAILS();
@message void MSG_BV_IMPORT_BITMAP();
@message void MSG_BV_MASK_APPLY();
@message void MSG_BV_READ_FILES();
@message void MSG_BV_SET_FILELIST_MONIKER(word item, optr list);
@message (GEN_DYNAMIC_LIST_QUERY_MSG) MSG_BV_SET_DRIVE_MONIKER;
@message (GEN_DYNAMIC_LIST_QUERY_MSG) MSG_BV_SET_PATH_MONIKER;
@message (GEN_ITEM_GROUP_APPLY_MSG) MSG_BV_VIEW_CHANGED;
@message (GEN_ITEM_GROUP_APPLY_MSG) MSG_BV_FILELIST_SELECTION;
@message (GEN_ITEM_GROUP_APPLY_MSG) MSG_BV_FILELIST_OPEN;
@message (GEN_ITEM_GROUP_APPLY_MSG) MSG_BV_SELECT_DRIVE;
@message (GEN_ITEM_GROUP_APPLY_MSG) MSG_BV_SELECT_PATH;
@message void MSG_BV_CLOSE_DIRECTORY();
@message void MSG_BV_GO_TO_DOCUMENT();
@message void MSG_BV_CREATE_THUMBNAIL(char *name,
									  dword size,
									  FileDateAndTime date,
									  VMFileHandle file,
									  VMBlockHandle block);

@message (GEN_ITEM_GROUP_APPLY_MSG) MSG_BV_FILE_FORMAT_CHANGED;
@message (GEN_FILE_SELECTOR_NOTIFICATION_MSG) MSG_BV_FILE_SELECTION;

@message (GEN_BOOLEAN_GROUP_APPLY_MSG) MSG_BV_OPTION_STATE_CHANGED;
@message (GEN_BOOLEAN_GROUP_APPLY_MSG) MSG_BV_PALETTE_OPT_CHANGED;

@message void MSG_BV_QUERY_RESET_OPTIONS();
@message void MSG_BV_DESELECT_ALL_FILES();
@message void MSG_BV_SELECT_ALL_FILES();

@message void MSG_BV_SAVE_PATH();
@message void MSG_BV_RESET_PATH();
@endc;
@classdecl BVProcessClass, neverSaved;

@class BVDocumentClass, GenDocumentClass;
@instance VMBlockHandle BVBmpBlock = 0;
@instance FileHandle    BVBmpFile = 0;
@instance WindowHandle  BVWindow = 0;
@instance word          BVBmpWidth = 0;
@instance word          BVBmpHeight = 0;
@instance FileLongName  BVName;
@instance FileLongName  BVTempName;
@instance MemHandle     BVPalette = 0;
@instance word          BVAttrs = 0;
@instance byte          BVType = 0;
@instance char          BVImpForm[31] = "";
@message void MSG_BV_OPEN_BITMAP(FileHandle file,
								 VMBlockHandle block,
								 char *name,
								 char *srcform);
@message void MSG_BV_CLOSE_BITMAP();
@message void MSG_BV_SET_PALETTE();
@message void MSG_BV_RESET_PALETTE();
@message void MSG_BV_SHOW_PIC_INFO();
@message void MSG_BV_CLEAR_PIC_INFO();
@message void MSG_BVDOC_PAL_STATE_CHANGED();
@endc;
@classdecl BVDocumentClass;

/**************************************************************************/

@class BVDocCtrlClass, GenDocumentControlClass;
@endc;
@classdecl BVDocCtrlClass;

/**************************************************************************/

@class BVAppClass, GenApplicationClass;
@endc;
@classdecl BVAppClass;

/**************************************************************************/

@class BVDynListClass, GenItemGroupClass;
@message void MSG_BV_DELETE_FILELIST();
@message optr MSG_BV_ADD_FILELIST_ITEM(MemHandle *objblock);
@endc
@classdecl BVDynListClass;

/**************************************************************************/

@class BVBrowserInterClass, GenInteractionClass;
@endc;
@classdecl BVBrowserInterClass;

/**************************************************************************/

@ifndef OLD_THUMBNAIL_DB

@class ThumbnailItemClass, GenItemClass;

@message void MSG_THUMBNAIL_ITEM_SET_DATA(char *name,
										  dword size,
										  FileDateAndTime date,
										  int folderflag);

@instance FileLongName          TII_name;
@instance dword                 TII_size;
@instance FileDateAndTime       TII_date;
@instance int                   TII_folderflag;

@endc;
@classdecl ThumbnailItemClass;

/**************************************************************************/

@method ThumbnailItemClass, MSG_THUMBNAIL_ITEM_SET_DATA
{
	strcpy(&(pself->TII_name[0]), name);
	pself->TII_size = size;
	pself->TII_date = date;
	pself->TII_folderflag = folderflag;

	@send oself::MSG_VIS_MARK_INVALID(VOF_GEOMETRY_INVALID|
				 VOF_IMAGE_INVALID, VUM_DELAYED_VIA_UI_QUEUE);
}

/**************************************************************************/

@method ThumbnailItemClass, MSG_VIS_RECALC_SIZE
{
	ExtraSizeParams extraSize;

	@call oself::MSG_SPEC_GET_EXTRA_SIZE(&extraSize, 0);

	return(MAKE_SIZE_DWORD(96 + extraSize.ESP_extraWidth,
						   96 + extraSize.ESP_extraHeight));
}

/**************************************************************************/

@method ThumbnailItemClass, MSG_VIS_DRAW
{
	word width, count;
	VisInstance *visptr;
	GStateHandle gstring;

	@callsuper();

	visptr = ObjDerefVis(oself);

	GrSetFont(gstate, FID_BERKELEY, MakeWWFixed(9));
	width = GrTextWidth(gstate, pself->TII_name, 0);

	if(width > 90)
	{
	  width = GrTextWidth(gstate, "...", 0);
	  count = 0;
	  while ((width < 96) && (pself->TII_name[count] != 0))
	  {
		width += (GrCharWidth(gstate, pself->TII_name[count])>>16);
		count++;
	  };
	  count--;
	  width -= (GrCharWidth(gstate, pself->TII_name[count])>>16);
	  GrDrawText(gstate, visptr->VI_bounds.R_left + 48-(width/2),
						visptr->VI_bounds.R_top + 85, pself->TII_name, count);
	  GrDrawTextAtCP(gstate, "...",0);

	}
	else
	  GrDrawText(gstate, visptr->VI_bounds.R_left + 48-(width/2),
						 visptr->VI_bounds.R_top + 85, pself->TII_name, 0);

	if(pself->TII_folderflag)
	{
	  gstring = GrLoadGString(OptrToHandle(@BVDirMoniker), GST_CHUNK, (word) OptrToChunk(@BVDirMoniker));
	  GrDrawGString(gstate, gstring, visptr->VI_bounds.R_left+18,
				visptr->VI_bounds.R_top+17,0,0);
	  GrDestroyGString(gstring, 0, GSKT_LEAVE_DATA);
	}
	else
		if(ThumbDrawItem(gstate, visptr->VI_bounds.R_left + 48,
							  visptr->VI_bounds.R_top + 43, THJ_CENTER, TVJ_CENTER,
							 pself->TII_name,
							 pself->TII_size,
							 pself->TII_date) != TE_NO_ERROR)
		{
			  gstring = GrLoadGString(OptrToHandle(@BVUnknownMoniker), GST_CHUNK,
						  (word) OptrToChunk(@BVUnknownMoniker));
			  GrDrawGString(gstate, gstring, visptr->VI_bounds.R_left+21,
						visptr->VI_bounds.R_top+14,0,0);
			  GrDestroyGString(gstring, 0, GSKT_LEAVE_DATA);
		}
}

@endif

/**************************************************************************/

@start AppResource;

/**************************************************************************/

@object BVAppClass BVApp = {
	GI_visMoniker = list {
		@BVTextMoniker,
		@BVVGAMoniker,
		@BVHGAMoniker,
		@BVCGAMoniker,
		@BVTCMoniker
	};
	GI_comp = @BVPrimary;

	gcnList(MANUFACTURER_ID_GEOWORKS,MGCNLT_APP_STARTUP) = @BVDocumentControl;

	gcnList(MANUFACTURER_ID_GEOWORKS, GAGCNLT_WINDOWS) = @BVPrimary;

	gcnList(MANUFACTURER_ID_GEOWORKS, GAGCNLT_SELF_LOAD_OPTIONS) =
		@BVViewControl,
		@BVEditControl,
		@BVDocumentControl,
		@BVDisplayControl,
		@BlendColorControl;

	gcnList(MANUFACTURER_ID_GEOWORKS, GAGCNLT_STARTUP_LOAD_OPTIONS) =
		@BVOptionGroup,
		@BVViewOptGroup,
		@BVImpFileShowTools,
		@BlendColorControl;

	gcnList(MANUFACTURER_ID_GEOWORKS, MGCNLT_ACTIVE_LIST) =
		@BVViewControl,
		@BVDocumentControl,
		@BVDisplayControl,
		@BlendColorControl;


@ifdef NEWDEAL_MEDIA_VIEWER
		  ATTR_GEN_INIT_FILE_CATEGORY = "MediaViewer";
@else
		  ATTR_GEN_INIT_FILE_CATEGORY = "GraphicsViewer";
@endif
	//	  ATTR_GEN_APPLICATION_SAVE_OPTIONS_TRIGGER = @BVOptionSaveTrigger;
}

/**************************************************************************/

@ifdef NEWDEAL_MEDIA_VIEWER
@visMoniker BVTextMoniker = "Media Viewer";
@else
@visMoniker BVTextMoniker = "Graphics Viewer";
@endif

/**************************************************************************/

@end AppResource;

/**************************************************************************/

@start ObjBlTemplateResource, notDetachable;
@chunk word objBlockObjectCount = 0;
@end ObjBlTemplateResource;

/**************************************************************************/

@start MonikerRes, data;

@include "token.goh"

@end MonikerRes;

/**************************************************************************/

@start Interface;

/**************************************************************************/

@object GenPrimaryClass BVPrimary = {
		  GI_comp = @BVWorkArea,
						@BVFileMenu,
						@BVEditMenu,
												@BVViewMenu,
						@BVOptionMenu,
												@BVWindowMenu,
												@BVImportingDlg,
												@BVThumbDlg,
												@BVFileImpBmp;
	GI_attrs = @default | GA_TARGETABLE
						  | GA_KBD_SEARCH_PATH;
	HINT_ORIENT_CHILDREN_HORIZONTALLY;
	HINT_PRIMARY_FULL_SCREEN;
   ATTR_GEN_HELP_CONTEXT = "TOC";
}

/**************************************************************************/

@object GenInteractionClass BVWorkArea = {
				  GI_comp = @BVToolArea,
							@BVDisplayGroup;
		HINT_ORIENT_CHILDREN_VERTICALLY;
	HINT_EXPAND_WIDTH_TO_FIT_PARENT;
	HINT_EXPAND_HEIGHT_TO_FIT_PARENT;
}

/**************************************************************************/

@ifdef NEWDEAL_MEDIA_VIEWER

@object GenInteractionClass BVToolArea = {
		GII_visibility = GIV_POPOUT;
		GI_comp = @BVDocumentTool,
				  @BVEditTool,
				  @BVViewTool,
				  @BVDisplayTool;
		  HINT_ORIENT_CHILDREN_HORIZONTALLY;
		  HINT_EXPAND_WIDTH_TO_FIT_PARENT;
		  HINT_TOOLBOX;
		  HINT_ALLOW_CHILDREN_TO_WRAP;
		  HINT_FULL_JUSTIFY_CHILDREN_HORIZONTALLY;
				  HINT_CENTER_CHILDREN_VERTICALLY;
		GI_attrs = @default | GA_NOTIFY_VISIBILITY;
		HINT_INTERACTION_NO_DISTURB;

}

@else

/**************************************************************************/

@object GenInteractionClass BVToolArea = {
		GII_visibility = GIV_POPOUT;
		GI_comp = @BVRealToolArea;
		HINT_ORIENT_CHILDREN_HORIZONTALLY;
		HINT_EXPAND_WIDTH_TO_FIT_PARENT;
		HINT_CENTER_CHILDREN_VERTICALLY;

}

/**************************************************************************/

@object GenInteractionClass BVRealToolArea = {
		GI_comp = @BVDocumentTool,
				  @BVEditTool,
				  @BVViewTool,
				  @BVDisplayTool;
		  HINT_ORIENT_CHILDREN_HORIZONTALLY;
		  HINT_EXPAND_WIDTH_TO_FIT_PARENT;
		  HINT_TOOLBOX;
		  HINT_ALLOW_CHILDREN_TO_WRAP;
		  HINT_FULL_JUSTIFY_CHILDREN_HORIZONTALLY;
				  HINT_CENTER_CHILDREN_VERTICALLY;
		GI_attrs = @default | GA_NOTIFY_VISIBILITY;
		HINT_INTERACTION_NO_DISTURB;

}

@endif

/**************************************************************************/

@object GenToolGroupClass BVEditTool = {
	GTGI_controller = @BVEditControl;
		  HINT_MINIMIZE_CHILD_SPACING;
		  HINT_SAME_ORIENTATION_AS_PARENT;
}

/**************************************************************************/

@object GenToolGroupClass BVViewTool = {
		  GTGI_controller = @BVViewControl;
		  HINT_MINIMIZE_CHILD_SPACING;
		  HINT_SAME_ORIENTATION_AS_PARENT;
}

/**************************************************************************/

@object GenToolGroupClass BVDisplayTool = {
				  GTGI_controller = @BVDisplayControl;
		  HINT_MINIMIZE_CHILD_SPACING;
		  HINT_SAME_ORIENTATION_AS_PARENT;
}

/**************************************************************************/

@object GenToolGroupClass BVDocumentTool = {
				  GTGI_controller = @BVDocumentControl;
		  HINT_MINIMIZE_CHILD_SPACING;
		  HINT_SAME_ORIENTATION_AS_PARENT;
}

/**************************************************************************/

@object GenInteractionClass BVWindowMenu ={
		GI_comp = @BVDisplayControl;
		  GII_visibility = GIV_POPUP;
		ATTR_GEN_INTERACTION_GROUP_TYPE = (GIGT_WINDOW_MENU);
}

/**************************************************************************/

@object GenInteractionClass BVFileMenu = {
@ifdef NEWDEAL_MEDIA_VIEWER
				  GI_comp = @BVFileGroup;
@else
				  GI_comp = @BVFileGroup;
@endif
		  GII_visibility = GIV_POPUP;
		  ATTR_GEN_INTERACTION_GROUP_TYPE = (GIGT_FILE_MENU);
}

/**************************************************************************/

@object GenInteractionClass BVFileGroup = {
		GI_comp = @BVFileOpenTrigger,
				  @BVDocumentControl;
		  GII_visibility = GIV_SUB_GROUP;
}

/**************************************************************************/

@object GenTriggerClass BVFileOpenTrigger = {
		GI_visMoniker = 'O', "Open";
		HINT_TRIGGER_BRINGS_UP_WINDOW;
		GTI_destination = BVDocumentControl;
		GTI_actionMsg = MSG_GEN_DOCUMENT_CONTROL_INITIATE_OPEN_DOC;
}

/**************************************************************************/

/* ==============================================================
 *  Import file selector start
 */

@object BVDocCtrlClass BVDocumentControl = {
		GDCI_attrs = (@default &
				(~(GDCA_VM_FILE|GDCA_CURRENT_TASK|GDCA_MODE)))
					 | (GDCA_NATIVE
					 | GDCA_MULTIPLE_OPEN_FILES
					 | (GDCM_VIEWER << GDCA_MODE_OFFSET)
					 | (GDCT_NONE << GDCA_CURRENT_TASK_OFFSET));
		GDCI_features = @default & ~(
					GDCF_SUPPORTS_TEMPLATES |
					GDCF_SUPPORTS_USER_SETTABLE_EMPTY_DOCUMENT |
					GDCF_SUPPORTS_USER_MAKING_SHARED_DOCUMENTS |
					GDCF_NAME_ON_PRIMARY);
	GDCI_noNameText = "No Document";
	GDCI_documentGroup = BVDocumentGroup;
}


/**************************************************************************/

@object GenInteractionClass BVViewMenu = {
		  GII_visibility = GIV_POPUP;
		  GI_comp = @BVViewControl,
						@BVViewOptGroup;
		  ATTR_GEN_INTERACTION_GROUP_TYPE = (GIGT_VIEW_MENU);
}

/**************************************************************************/

@object GenBooleanGroupClass BVViewOptGroup = {
		  GI_comp = @BVViewPalette;
		  GBGI_selectedBooleans = BV_BETTER_PALETTE;
		  GBGI_destination = process;
		  GBGI_applyMsg = MSG_BV_PALETTE_OPT_CHANGED;
		  ATTR_GEN_INIT_FILE_KEY = "viewMenu";
}

/**************************************************************************/

@object GenBooleanClass BVViewPalette = {
		  GI_visMoniker = 'P', "Optimize Palette";
		  GBI_identifier = BV_BETTER_PALETTE;
}

/**************************************************************************/

@object GenViewControlClass BVViewControl = {
		GVCI_maxZoom = 400;
		ATTR_GEN_CONTROL_PROHIBIT_UI = { (
										 GVCF_SHOW_HORIZONTAL
					 |GVCF_SHOW_VERTICAL) };
		ATTR_GEN_INIT_FILE_KEY = "viewControl";

}

/**************************************************************************/

@object GenInteractionClass BVEditMenu = {
		  GII_visibility = GIV_POPUP;
		  GI_comp = @BVEditControl;
		  ATTR_GEN_INTERACTION_GROUP_TYPE = (GIGT_EDIT_MENU);
	GI_attrs = @default | GA_TARGETABLE
						  | GA_KBD_SEARCH_PATH;
}

/**************************************************************************/

@object GenEditControlClass BVEditControl = {
		  ATTR_GEN_CONTROL_PROHIBIT_UI =
 { (GECF_UNDO|GECF_SELECT_ALL|GECF_CUT|GECF_PASTE|GECF_DELETE) };
				  ATTR_GEN_CONTROL_PROHIBIT_TOOLBOX_UI =
 { (GECTF_UNDO|GECTF_SELECT_ALL|GECTF_CUT|GECTF_PASTE|GECTF_DELETE) };
				  GCI_output = (TO_APP_TARGET);
}

/**************************************************************************/

@object GenInteractionClass BVOptionMenu = {
		GII_visibility = GIV_POPUP;
		GI_comp = 	@BVOptionGroup,
		  		@BlendColorControl,
				@BVDialogsGroup,
				@BVOptionSaveGroup;
		ATTR_GEN_INTERACTION_GROUP_TYPE = (GIGT_OPTIONS_MENU);
};

/**************************************************************************/
@object ColorSelectorClass BlendColorControl = {
	GI_visMoniker = "Set PNG Blend Color";
	GI_states = @default | GS_USABLE | GS_ENABLED;
	CSI_color = {C_WHITE, CF_INDEX, 0, 0};

	GCI_output = process;
	GII_visibility = GIV_DIALOG;
	GII_type = GIT_PROPERTIES;

	ATTR_GEN_CONTROL_REQUIRE_UI = (CSF_RGB | CSF_INDEX | CSF_OTHER);
	ATTR_GEN_CONTROL_PROHIBIT_UI = (CSF_PATTERN | CSF_DRAW_MASK);
	HINT_DRAW_IN_BOX;
    	HINT_PLACE_MONIKER_ABOVE;
};

/**************************************************************************/

@object GenInteractionClass BVDialogsGroup = {
		GII_visibility = GIV_SUB_GROUP;
		GI_comp = @BVDlgPicInfo;
};

/**************************************************************************/

@object GenInteractionClass BVDlgPicInfo = {
		GII_visibility = GIV_DIALOG;
@ifdef NEWDEAL_MEDIA_VIEWER
		GI_visMoniker = 'M', "Media Info";
@else
		GI_visMoniker = 'G', "Graphic Info";
@endif
		HINT_INTERACTION_NO_DISTURB;
		GI_comp = @BVPicInfoName,
				  @BVPicInfoX,
				  @BVPicInfoY,
				  @BVPicInfoCol,
				  @BVPicInfoForm;
		HINT_ORIENT_CHILDREN_VERTICALLY;
		HINT_CENTER_CHILDREN_ON_MONIKERS;
}

/**************************************************************************/

@object GenTextClass BVPicInfoName = {
		GI_visMoniker = "Name:";
@ifdef NEWDEAL_MEDIA_VIEWER
		GTXI_text = "<no media opened>";
@else
		GTXI_text = "<no graphic opened>";
@endif
		GI_attrs = @default | GA_READ_ONLY;
		GTXI_attrs = @default | GTA_SINGLE_LINE_TEXT;
		HINT_FIXED_SIZE = {
		  SST_WIDE_CHAR_WIDTHS|12,
		  0,
		  0
		};
}

/**************************************************************************/

@object GenTextClass BVPicInfoX = {
		GI_visMoniker = "Width:";
		GI_attrs = @default | GA_READ_ONLY;
		HINT_FIXED_SIZE = {
		  SST_WIDE_CHAR_WIDTHS|12,
		  0,
		  0
		};
		GTXI_attrs = @default | GTA_SINGLE_LINE_TEXT;
}

/**************************************************************************/

@object GenTextClass BVPicInfoY = {
		GI_visMoniker = "Height:";
		GI_attrs = @default | GA_READ_ONLY;
		HINT_FIXED_SIZE = {
		  SST_WIDE_CHAR_WIDTHS|12,
		  0,
		  0
		};
		GTXI_attrs = @default | GTA_SINGLE_LINE_TEXT;
}

/**************************************************************************/

@object GenTextClass BVPicInfoCol = {
		GI_visMoniker = "Color Count:";
		GI_attrs = @default | GA_READ_ONLY;
		HINT_FIXED_SIZE = {
		  SST_WIDE_CHAR_WIDTHS|12,
		  0,
		  0
		};
		GTXI_attrs = @default | GTA_SINGLE_LINE_TEXT;
}

/**************************************************************************/

@object GenTextClass BVPicInfoForm = {
		GI_visMoniker = "Format:";
		HINT_FIXED_SIZE = {
		  SST_WIDE_CHAR_WIDTHS|12,
		  0,
		  0
		};
		GI_attrs = @default | GA_READ_ONLY;
  /*      GTXI_attrs = @default | GTA_SINGLE_LINE_TEXT;    */
}

/**************************************************************************/

@object GenInteractionClass BVOptionSaveGroup = {
		  GII_visibility = GIV_SUB_GROUP;
		  GI_comp = @BVOptionSaveTrigger,
				  @BVOptionLoadTrigger;
}

/**************************************************************************/

@object GenTriggerClass BVOptionSaveTrigger = {
		  GI_visMoniker = 'S', "Save Configuration";
		  GTI_destination = BVApp;
		  GTI_actionMsg = MSG_META_SAVE_OPTIONS;
}

/**************************************************************************/

@object GenTriggerClass BVOptionLoadTrigger = {
		  GI_visMoniker = 'R', "Reset Configuration";
		  GTI_actionMsg = MSG_BV_QUERY_RESET_OPTIONS;
		  GTI_destination = process;
}

/**************************************************************************/

@object GenBooleanGroupClass BVOptionGroup = {
		GI_comp = @BVOptionTool,
				  @BVOptionImp,
				  @BVOptionCloseOBox,
				  @BVOptionCreatThumb,
				  @BVOptionUseThumb;
		GBGI_selectedBooleans = BV_SHOW_TOOLS|BV_AUTOCLOSE_OBOX|
								BV_AUTOCREAT_THUMB|BV_USE_THUMBNAILS;
		GBGI_destination = process;
		GBGI_applyMsg = MSG_BV_OPTION_STATE_CHANGED;
		ATTR_GEN_INIT_FILE_KEY = "optMenu";
}

/**************************************************************************/

@object GenBooleanClass BVOptionImp = {
				  GI_visMoniker = 'F', "Show Import Format";
				  GBI_identifier = BV_IMP_INFO;
}

/**************************************************************************/

@object GenBooleanClass BVOptionTool = {
		  GI_visMoniker = 'T', "Show Toolbar";
		  GBI_identifier = BV_SHOW_TOOLS;
}

/**************************************************************************/

@object GenBooleanClass BVOptionCloseOBox = {
	  GI_visMoniker = 'A', "Auto-Close Selector";
	  GBI_identifier = BV_AUTOCLOSE_OBOX;
}

/**************************************************************************/

@object GenBooleanClass BVOptionUseThumb = {
	  GI_visMoniker = 'U', "Use Thumbnails";
	  GBI_identifier = BV_USE_THUMBNAILS;
}

/**************************************************************************/

@object GenBooleanClass BVOptionCreatThumb = {
	  GI_visMoniker = 'u', "Auto-Create Thumbnails";
	  GBI_identifier = BV_AUTOCREAT_THUMB;
}

/**************************************************************************/

@object GenInteractionClass BVImportingDlg = {
		  GII_attrs = @default | GIA_NOT_USER_INITIATABLE
									  | GIA_MODAL;
				  GI_comp = @BVImportingTex,
						@BVImpStatus,
						@BVImportingWait,
						@BVStopProgressTrigger;
		  GII_visibility = GIV_DIALOG;
		  GII_type = GIT_PROGRESS;
		  HINT_CENTER_CHILDREN_HORIZONTALLY;
		  HINT_FULL_JUSTIFY_CHILDREN_VERTICALLY;
}

/**************************************************************************/

@object GenGlyphClass BVImportingTex = {
		  GI_visMoniker = "Importing Bitmap TEST.GIF...";
}

/**************************************************************************/

@object GenInteractionClass BVImpStatus = {
		  HINT_MINIMUM_SIZE = {
			 0,
			 SST_LINES_OF_TEXT|2,
			 0
		  };
		  GI_comp = @BVImportStatus;
		  HINT_CENTER_CHILDREN_HORIZONTALLY;
		  HINT_CENTER_CHILDREN_VERTICALLY;
}

/**************************************************************************/

@object ExtUIStatusBarClass BVImportStatus = {
}

/**************************************************************************/

@object GenGlyphClass BVImportingWait = {
		  GI_visMoniker = "Please Wait!";
}

/**************************************************************************/

@object GenTriggerClass BVStopProgressTrigger = {
		  GI_visMoniker = 'S', "Stop";
		  GI_attrs = @default | GA_SIGNAL_INTERACTION_COMPLETE;
		  GTI_destination = BVImportStatus;
		  GTI_actionMsg = MSG_SB_STOP_PROGRESS;
		  ATTR_GEN_TRIGGER_INTERACTION_COMMAND = { IC_STOP };
		  HINT_SEEK_REPLY_BAR;
}

/**************************************************************************/

@object GenInteractionClass BVThumbDlg = {
		  GII_attrs = @default | GIA_NOT_USER_INITIATABLE
									  | GIA_MODAL;
				  GI_comp = @BVThumbTex,
						@BVThumbStatus,
						@BVThumbWait,
						@BVThumbStopTrigger;
		  GII_visibility = GIV_DIALOG;
		  GII_type = GIT_PROGRESS;
		  HINT_CENTER_CHILDREN_HORIZONTALLY;
		  HINT_FULL_JUSTIFY_CHILDREN_VERTICALLY;
}

/**************************************************************************/

@object GenGlyphClass BVThumbTex = {
		  GI_visMoniker = "Creating Thumbnail for TEST.GIF...";
}

/**************************************************************************/

@object GenInteractionClass BVThumbStatus = {
		  HINT_MINIMUM_SIZE = {
			 0,
			 SST_LINES_OF_TEXT|2,
			 0
		  };
		  GI_comp = @BVThumbnailStatus;
		  HINT_CENTER_CHILDREN_HORIZONTALLY;
		  HINT_CENTER_CHILDREN_VERTICALLY;
}

/**************************************************************************/

@object ExtUIStatusBarClass BVThumbnailStatus = {
}

/**************************************************************************/

@object GenGlyphClass BVThumbWait = {
		  GI_visMoniker = "Please Wait!";
}

/**************************************************************************/

@object GenTriggerClass BVThumbStopTrigger = {
		  GI_visMoniker = 'S', "Stop";
		  GI_attrs = @default | GA_SIGNAL_INTERACTION_COMPLETE;
		  GTI_destination = BVThumbnailStatus;
		  GTI_actionMsg = MSG_SB_STOP_PROGRESS;
		  ATTR_GEN_TRIGGER_INTERACTION_COMMAND = { IC_STOP };
		  HINT_SEEK_REPLY_BAR;
}

/**************************************************************************/

@object GenDisplayControlClass BVDisplayControl = {
}

/**************************************************************************/

@object GenDisplayGroupClass BVDisplayGroup = {
	HINT_INITIAL_SIZE = {
	SST_PCT_OF_FIELD_WIDTH | PCT_70,
	SST_PCT_OF_FIELD_HEIGHT | PCT_55,
	0
	};
	HINT_DEFAULT_FOCUS;
	HINT_DEFAULT_TARGET;
}

/**************************************************************************/

@end Interface;

/**************************************************************************/

@start DocumentUI ;

/**************************************************************************/

@object GenDocumentGroupClass BVDocumentGroup = {
		GDGI_attrs = (@default | GDGA_NATIVE)
							 & ~(GDGA_VM_FILE |
								 GDGA_SUPPORTS_AUTO_SAVE |
								 GDGA_AUTOMATIC_CHANGE_NOTIFICATION|
								 GDGA_AUTOMATIC_DIRTY_NOTIFICATION);
		GDGI_untitledName = "UNNAMED";
		GDGI_documentClass = &BVDocumentClass;
		GDGI_documentControl = BVDocumentControl;
		GDGI_genDisplayGroup = BVDisplayGroup;
		GDGI_genDisplay = BVDisplay;
		GDGI_genView = BVView;
}

/**************************************************************************/

@end DocumentUI;

/**************************************************************************/

@start DisplayUI ;

/**************************************************************************/

@object GenDisplayClass BVDisplay = {
	GI_states = @default & ~GS_USABLE;
	GI_comp = @BVView;
	ATTR_GEN_DISPLAY_NOT_MINIMIZABLE;
}

/**************************************************************************/

@object GenViewClass BVView = {
		  GVI_attrs = @default | GVA_CONTROLLED;
		  GVI_vertAttrs = @default | GVDA_SCROLLABLE;
		  GVI_horizAttrs = @default | GVDA_SCROLLABLE;
		  HINT_VIEW_REMOVE_SCROLLERS_WHEN_NOT_SCROLLABLE;
		  HINT_EXPAND_WIDTH_TO_FIT_PARENT;
		  HINT_EXPAND_HEIGHT_TO_FIT_PARENT;
		  HINT_MINIMUM_SIZE = {
						 20,
						 20,
			 0
		  };
	GVI_docBounds = {0, 0, 20, 20};

	 ATTR_GEN_VIEW_DOES_NOT_ACCEPT_TEXT_INPUT;
	HINT_DEFAULT_FOCUS;
	HINT_DEFAULT_TARGET;
}

/**************************************************************************/

@end DisplayUI

/**************************************************************************/

@start FileSelUI;

/**************************************************************************/

@object BVBrowserInterClass BVFileImpBmp = {
		GII_attrs = @default | GIA_NOT_USER_INITIATABLE;
		GI_visMoniker = "Open";
		GI_comp = @BVImpFileTools,
				  @BVImpFileView,
				  @BVImpTrigger;

		GII_visibility = GIV_DIALOG;
		GII_type = GIT_COMMAND;
		HINT_ORIENT_CHILDREN_VERTICALLY;
		HINT_CENTER_CHILDREN_HORIZONTALLY;
		HINT_FULL_JUSTIFY_CHILDREN_VERTICALLY;

		/* set window handling  */
		HINT_INTERACTION_MAXIMIZABLE;
		HINT_INTERACTION_MAKE_RESIZABLE;

		/* window initial position and size */
		HINT_CENTER_WINDOW;
		HINT_SIZE_WINDOW_AS_RATIO_OF_FIELD = {
		  SWSS_RATIO|PCT_85,
		  SWSS_RATIO|PCT_85
		};

		ATTR_GEN_HELP_CONTEXT = "bvOpen";
}

/**************************************************************************/

@object GenInteractionClass BVImpFileTools = {
		GI_comp = @BVImpFileDirTools,
				  @BVImpFileItemTools;
		HINT_ORIENT_CHILDREN_HORIZONTALLY;
		HINT_FULL_JUSTIFY_CHILDREN_HORIZONTALLY;
		HINT_EXPAND_WIDTH_TO_FIT_PARENT;
		HINT_ALLOW_CHILDREN_TO_WRAP;
}

/**************************************************************************/

@object GenInteractionClass BVImpFileDirTools = {
		GI_comp = @BVImpFileDirBelow,
				  @BVImpFileDirPath,
				  @BVImpFileDirDoc,
				  @BVImpFileDirDrive;
		HINT_ORIENT_CHILDREN_HORIZONTALLY;
		HINT_DONT_ALLOW_CHILDREN_TO_WRAP;
		HINT_CENTER_CHILDREN_VERTICALLY;
}

/**************************************************************************/

@object GenTriggerClass BVImpFileDirBelow = {
		GI_visMoniker = list { @BVDirUpMoniker } ;
		GTI_destination = process;
		GTI_actionMsg = MSG_BV_CLOSE_DIRECTORY;
}

/**************************************************************************/

@object GenDynamicListClass BVImpFileDirPath = {
		GI_visMoniker = 'P', "Path";
		GIGI_destination = process;
		GIGI_applyMsg = MSG_BV_SELECT_PATH;
		GDLI_queryMsg = MSG_BV_SET_PATH_MONIKER;
		HINT_ITEM_GROUP_MINIMIZE_SIZE;
		ATTR_GEN_ITEM_GROUP_SET_MODIFIED_ON_REDUNDANT_SELECTION;
}

/**************************************************************************/

@object GenTriggerClass BVImpFileDirDoc = {
		GI_visMoniker = 'u', "Go to Document";
		GTI_destination = process;
		GTI_actionMsg = MSG_BV_GO_TO_DOCUMENT;
}

/**************************************************************************/

@object GenDynamicListClass BVImpFileDirDrive = {
		GI_visMoniker = 'v', "Drive";
		GIGI_destination = process;
		GDLI_queryMsg = MSG_BV_SET_DRIVE_MONIKER;
		GIGI_applyMsg = MSG_BV_SELECT_DRIVE;
		HINT_ITEM_GROUP_MINIMIZE_SIZE;
		ATTR_GEN_ITEM_GROUP_SET_MODIFIED_ON_REDUNDANT_SELECTION;
}

/**************************************************************************/

@object GenInteractionClass BVImpFileItemTools = {
		GI_comp = @BVImpFileShowTools,
				  @BVImpFileEditTools;
		HINT_ORIENT_CHILDREN_HORIZONTALLY;
		HINT_DONT_ALLOW_CHILDREN_TO_WRAP;
		HINT_CENTER_CHILDREN_VERTICALLY;
}

/**************************************************************************/

@object GenItemGroupClass BVImpFileShowTools = {
		GIGI_numSelections = 1;
		GIGI_selection = BV_SHOW_ALL_MEDIA;
		GIGI_destination = process;
		GIGI_applyMsg = MSG_BV_VIEW_CHANGED;
		GI_visMoniker = 'f', "Preferences";
		GI_comp = @BVImpFileShowAll,
				  @BVImpFileShowAllMedia,
				  @BVImpFileShowBMP,
				  @BVImpFileShowPCX,
				  @BVImpFileShowPNG,
@ifdef JPEG_SUPPORT
				  @BVImpFileShowGIF,
				  @BVImpFileShowJPEG;
@else
				  @BVImpFileShowGIF;
@endif
		HINT_ITEM_GROUP_MINIMIZE_SIZE;
		ATTR_GEN_INIT_FILE_KEY = "viewOpt";
}

/**************************************************************************/

@object GenItemClass BVImpFileShowAll = {
		GI_visMoniker = 'A', "Show All Files";
		GII_identifier = BV_SHOW_ALL;
}

/**************************************************************************/

@object GenItemClass BVImpFileShowAllMedia = {
@ifdef NEWDEAL_MEDIA_VIEWER
		GI_visMoniker = 'M', "Show All Media Files";
@else
		GI_visMoniker = 'G', "Show All Graphic Files";
@endif
		GII_identifier = BV_SHOW_ALL_MEDIA;
}

/**************************************************************************/

@object GenItemClass BVImpFileShowBMP = {
		GI_visMoniker = 'B', "Show .BMP Files";
		GII_identifier = BV_SHOW_BMP;
}

/**************************************************************************/

@object GenItemClass BVImpFileShowPCX = {
		GI_visMoniker = 'P', "Show .PCX Files";
		GII_identifier = BV_SHOW_PCX;
}

/**************************************************************************/

@object GenItemClass BVImpFileShowPNG = {
		GI_visMoniker = 'P', "Show .PNG Files";
		GII_identifier = BV_SHOW_PNG;
}

/**************************************************************************/

@object GenItemClass BVImpFileShowGIF = {
		GI_visMoniker = 'G', "Show .GIF Files";
		GII_identifier = BV_SHOW_GIF;
}

/**************************************************************************/

@ifdef JPEG_SUPPORT
@object GenItemClass BVImpFileShowJPEG = {
		GI_visMoniker = 'G', "Show .JPG Files";
		GII_identifier = BV_SHOW_JPEG;
}
@endif

/**************************************************************************/

@object GenInteractionClass BVImpFileEditTools = {
		GI_visMoniker = 'D', "Display";
		GII_visibility = GIV_POPUP;
		HINT_AVOID_MENU_BAR;
		GI_comp = @BVImpEditSelect,
				  @BVImpEditThumb,
				  @BVImpEditPath;
}

/**************************************************************************/

@object GenInteractionClass BVImpEditSelect = {
		GI_comp = @BVImpEditSelAllTrig,
				  @BVImpEditDeSelAllTrig;
		GII_visibility = GIV_SUB_GROUP;
}

/**************************************************************************/

@object GenTriggerClass BVImpEditSelAllTrig = {
		GI_visMoniker = 'A', "Select All";
		GTI_destination = process;
		GTI_actionMsg = MSG_BV_SELECT_ALL_FILES;
}

/**************************************************************************/

@object GenTriggerClass BVImpEditDeSelAllTrig = {
		GI_visMoniker = 'U', "Unselect All";
		GTI_destination = process;
		GTI_actionMsg = MSG_BV_DESELECT_ALL_FILES;
}

/**************************************************************************/

@object GenInteractionClass BVImpEditThumb = {
		GI_comp = @BVImpEditReadThumbTrig,
				  @BVImpEditDelThumbTrig;
		GII_visibility = GIV_SUB_GROUP;
}

/**************************************************************************/

@object GenTriggerClass BVImpEditReadThumbTrig = {
		GI_visMoniker = 'C', "Create Thumbnail(s)";
		GTI_destination = process;
		GTI_actionMsg = MSG_BV_READ_THUMBNAILS;
}

/**************************************************************************/

@object GenTriggerClass BVImpEditDelThumbTrig = {
		GI_visMoniker = 'R', "Remove Thumbnail(s)";
		GTI_destination = process;
		GTI_actionMsg = MSG_BV_DELETE_THUMBNAILS;
}

/**************************************************************************/

@object GenInteractionClass BVImpEditPath = {
		GI_comp = @BVImpEditSavePath,
				  @BVImpEditResetPath;
		GII_visibility = GIV_SUB_GROUP;
}

/**************************************************************************/

@object GenTriggerClass BVImpEditSavePath = {
		GI_visMoniker = 'S', "Save Path";
		GTI_destination = process;
		GTI_actionMsg = MSG_BV_SAVE_PATH;
}

/**************************************************************************/

@object GenTriggerClass BVImpEditResetPath = {
		GI_visMoniker = 'P', "Reset Path";
		GTI_destination = process;
		GTI_actionMsg = MSG_BV_RESET_PATH;
}


/**************************************************************************/

@object GenViewClass BVImpFileView = {
		GVI_attrs = @default | GVA_GENERIC_CONTENTS
							 | GVA_SAME_COLOR_AS_PARENT_WIN
							 | GVA_SEND_ALL_KBD_CHARS;

		HINT_EXPAND_WIDTH_TO_FIT_PARENT;
		HINT_EXPAND_HEIGHT_TO_FIT_PARENT;
		GVI_content = @BVFileListCont;
		GVI_vertAttrs = @default | GVDA_SCROLLABLE
								 | GVDA_SIZE_A_MULTIPLE_OF_INCREMENT;
		GVI_horizAttrs = @default | GVDA_SIZE_A_MULTIPLE_OF_INCREMENT;
		HINT_VIEW_REMOVE_SCROLLERS_WHEN_NOT_SCROLLABLE;
		GVI_increment = {100, 100};
		HINT_DEFAULT_TARGET;
}

/**************************************************************************/

@object GenContentClass BVFileListCont = {
		GI_comp = @BVDynFileList;
		GCI_genView = @BVImpFileView;
		GCI_attrs = @default | VCNA_SAME_WIDTH_AS_VIEW;
}

/**************************************************************************/

@object BVDynListClass BVDynFileList = {
		GIGI_selection = 0;
		GIGI_numSelections = 1;
		GIGI_applyMsg = MSG_BV_FILELIST_SELECTION;
		GIGI_destination = process;
		GIGI_behaviorType = GIGBT_EXTENDED_SELECTION;
		HINT_ALLOW_CHILDREN_TO_WRAP;
		HINT_ITEM_GROUP_TOOLBOX_STYLE;
		ATTR_GEN_ITEM_GROUP_CUSTOM_DOUBLE_PRESS
		  = MSG_BV_FILELIST_OPEN;
}

/**************************************************************************/

@object GenTriggerClass BVImpTrigger = {
				  GI_visMoniker = "Open";
		  GI_attrs = @default | GA_SIGNAL_INTERACTION_COMPLETE;
		  GI_states = @default & ~GS_ENABLED;
				  GTI_destination = process;
		  GTI_actionMsg = MSG_BV_IMPORT_BITMAP;
		  ATTR_GEN_TRIGGER_INTERACTION_COMMAND = { IC_OK };
		  HINT_SEEK_REPLY_BAR;
}

/*
 * Import file selector end
 *===============================================================
 */

/**************************************************************************/

@include "bvdirup.goh"

/**************************************************************************/

@end FileSelUI;

/**************************************************************************/

@method BVProcessClass, MSG_BV_OPTION_STATE_CHANGED
{
  if((modifiedBooleans & BV_SHOW_TOOLS) != 0)
  {
	 if((selectedBooleans & BV_SHOW_TOOLS) == 0)
	 {
			@send BVToolArea::MSG_GEN_SET_NOT_USABLE(VUM_DELAYED_VIA_APP_QUEUE);
	 }
	 else
	 {
				@send BVToolArea::MSG_GEN_SET_USABLE(VUM_DELAYED_VIA_APP_QUEUE);
				@send BVToolArea::MSG_GEN_INTERACTION_INITIATE();

	 };
  };
  if((modifiedBooleans & BV_USE_THUMBNAILS) != 0)
  {
	@call oself::MSG_BV_READ_FILES();
  };
}

/**************************************************************************/

@method BVProcessClass, MSG_BV_PALETTE_OPT_CHANGED
{
  EventHandle event;
  optr target;
  Boolean stat;

  if((modifiedBooleans & BV_BETTER_PALETTE) != 0)
  {
	 if((selectedBooleans & BV_BETTER_PALETTE) == 0)
	 {
				BVAttrs2 &= ~BVA_REALIZE_PALETTE;
		@call oself::MSG_BV_RESET_PALETTE();
	 }
	 else
	 {
				BVAttrs2 |= BVA_REALIZE_PALETTE;
	  @call oself::MSG_BV_SET_PALETTE();
	 };
  }

  stat = @call BVDisplayGroup::MSG_META_GET_TARGET_EXCL(&target);

  if(stat != 0)
  {
	/* neuzeichnen aller Dokumente */
	@call target::MSG_META_RELEASE_TARGET_EXCL();

	event = @record null::MSG_BVDOC_PAL_STATE_CHANGED();
	@call BVDocumentGroup::MSG_GEN_SEND_TO_CHILDREN(event);

	@send target::MSG_META_GRAB_TARGET_EXCL();
  };
}

/**************************************************************************/

@if 0
@method BVProcessClass, MSG_BV_FILE_FORMAT_CHANGED
{
  char mask[6];

  switch(selection)
  {
	 case IBF_AUTO:
		strcpy(mask, "*.*");
		break;

	 case IBF_BMP:
		strcpy(mask, "*.BMP");
		break;

	 case IBF_PCX:
		strcpy(mask, "*.PCX");
		break;

	 case IBF_PNG:
		strcpy(mask, "*.PNG");
		break;

	 case IBF_GIF:
		strcpy(mask, "*.GIF");
		break;
@ifdef JPEG_SUPPORT
	 case IBF_JPEG:
		strcpy(mask, "*.JPG");
		break;
@endif
	 case IBF_TIFF:
		strcpy(mask, "*.TIF");
		break;
  };
  @call BVImpFileMask::MSG_VIS_TEXT_REPLACE_ALL_PTR(mask, 0);
  @call BVImpFileSel::MSG_GEN_FILE_SELECTOR_SET_MASK(mask);
}

/**************************************************************************/

@method BVProcessClass, MSG_BV_MASK_APPLY
{
  char mask[21];

  @call BVImpFileMask::MSG_VIS_TEXT_GET_ALL_PTR(mask);
  @call BVImpFileSel::MSG_GEN_FILE_SELECTOR_SET_MASK(mask);
  @send BVImpFileMask::MSG_VIS_TEXT_SELECT_ALL();
}

@endif

/**************************************************************************/

static Boolean
CheckPasteable(ClipboardItemFlags transferFlags)
{
  ClipboardQueryArgs    query;
  Boolean   pasteable = FALSE;

  ClipboardQueryItem(transferFlags, &query);
  pasteable = (query.CQA_numFormats &&
		 ClipboardTestItemFormat(query.CQA_header, BITMAP_FORMAT));

  ClipboardDoneWithItem(query.CQA_header);

  return (pasteable);
}

/**************************************************************************/

static void
SendSelectNotify(VMBlockHandle bmpblock)
{
  MemHandle data;
  NotifySelectStateChange *nsscPtr;
  EventHandle notifyEvent;

	 data = MemAlloc(sizeof(NotifySelectStateChange), HF_DYNAMIC|HF_SHARABLE,
			 HAF_STANDARD_NO_ERR);
	 nsscPtr = (NotifySelectStateChange *)MemLock(data);

	 nsscPtr->NSSC_selectionType = SDT_GRAPHICS;
	 nsscPtr->NSSC_clipboardableSelection =
		 nsscPtr->NSSC_deleteableSelection = (bmpblock != 0);
	 nsscPtr->NSSC_selectAllAvailable = FALSE;
	 nsscPtr->NSSC_pasteable = CheckPasteable(TIF_NORMAL);

	 MemUnlock(data);
	 MemInitRefCount(data, 1);

	 notifyEvent =
	@record null::MSG_META_NOTIFY_WITH_DATA_BLOCK(MANUFACTURER_ID_GEOWORKS,
								GWNT_SELECT_STATE_CHANGE,
								data);
	 @call application::MSG_META_GCN_LIST_SEND
	(GCNLSF_SET_STATUS,
	 notifyEvent,
	 data,
	 GAGCNLT_APP_TARGET_NOTIFY_SELECT_STATE_CHANGE,
	 MANUFACTURER_ID_GEOWORKS);
}

/**************************************************************************/

static TransferBlockID
BuildBitmapTransferItem(FileHandle bmpfile, VMBlockHandle bmpblock,
			   FileLongName bmpname, word bmpwidth, word bmpheight)
{
  MemHandle mem;
  VMFileHandle    transferFile;
  VMBlockHandle   transferItem;
  ClipboardItemHeader *ptr;
  VMBlockHandle chain;
  GStateHandle gstate;

  transferFile = ClipboardGetClipboardFile();

  chain = MyVMCopyVMChain(bmpfile,
						VMCHAIN_MAKE_FROM_VM_BLOCK(bmpblock)
						, transferFile);
  transferItem = VMAlloc(transferFile,
								 sizeof(ClipboardItemHeader),
								 0);

  ptr = (ClipboardItemHeader *)
			 VMLock(transferFile, transferItem, &mem);

  ptr->CIH_owner = (optr) (((dword)GeodeGetProcessHandle()<<16) | 0);
  ptr->CIH_flags = 0;
  (void) strcpy(ptr->CIH_name, bmpname);
  ptr->CIH_formatCount = 2;
  ptr->CIH_sourceID = 0;

  ptr->CIH_formats[1].CIFI_format =
		 FormatIDFromManufacturerAndType(MANUFACTURER_ID_GEOWORKS, CIF_BITMAP);
  ptr->CIH_formats[1].CIFI_vmChain = VMCHAIN_MAKE_FROM_VM_BLOCK(chain);
  ptr->CIH_formats[1].CIFI_extra1 = 0;
  ptr->CIH_formats[1].CIFI_extra2 = 0;

  gstate = GrCreateGString(transferFile, GST_VMEM, &chain);
  GrSetGStringBounds(gstate, 0, 0, bmpwidth, bmpheight);
  GrSaveState(gstate);
  GrSaveTransform(gstate);
  GrSetClipRect(gstate,0,0,0,bmpwidth,bmpheight);
  GrDrawHugeBitmap(gstate, 0, 0, bmpfile, bmpblock);

  GrRestoreTransform(gstate);
  GrRestoreState(gstate);
  /* ### returns error code */
  GrEndGString(gstate);

  GrDestroyGString(gstate, 0, GSKT_LEAVE_DATA);


  ptr->CIH_formats[0].CIFI_format =
		 FormatIDFromManufacturerAndType(MANUFACTURER_ID_GEOWORKS, CIF_GRAPHICS_STRING);
  ptr->CIH_formats[0].CIFI_vmChain = VMCHAIN_MAKE_FROM_VM_BLOCK(chain);
  ptr->CIH_formats[0].CIFI_extra1 = bmpwidth;
  ptr->CIH_formats[0].CIFI_extra2 = bmpheight;

  VMDirty(mem);
  VMUnlock(mem);
  return (BlockIDFromFileAndBlock(transferFile, transferItem));
};

/**************************************************************************/

static Boolean
CopyCommon(ClipboardItemFlags transferFlags, FileHandle bmpfile,
					   VMBlockHandle bmpblock, char *bmpname,
						word bmpwidth, word bmpheight)
{
  if (bmpblock != 0)
  {
		 TransferBlockID transferItem = BuildBitmapTransferItem(bmpfile,
									bmpblock, bmpname, bmpwidth, bmpheight);
	 return ClipboardRegisterItem(transferItem, transferFlags);
  }
  else
  {
	 return(FALSE);
  }
}

static void
getPngBlendColor(RGBValue* blendColor)
{
	ColorAndFlagReturn cafr = {0};

	@call BlendColorControl::MSG_COLOR_SELECTOR_GET_COLOR(&cafr);

	// convert INDEX to RGB
	if(cafr.CAFR_color.CQ_info == CF_INDEX)
	{
		RGBColorAsDWord c = GrMapColorIndex(0, cafr.CAFR_color.CQ_redOrIndex);
		blendColor->RGB_red = RGB_RED(c);
		blendColor->RGB_green = RGB_GREEN(c);
		blendColor->RGB_blue = RGB_BLUE(c);
	}
	else if (cafr.CAFR_color.CQ_info == CF_RGB)
	{
		blendColor->RGB_red = cafr.CAFR_color.CQ_redOrIndex;
		blendColor->RGB_green = cafr.CAFR_color.CQ_green;
		blendColor->RGB_blue = cafr.CAFR_color.CQ_blue;
	}
	else if (cafr.CAFR_color.CQ_info == CF_GRAY)
	{
		blendColor->RGB_red = cafr.CAFR_color.CQ_redOrIndex;
		blendColor->RGB_green = cafr.CAFR_color.CQ_redOrIndex;
		blendColor->RGB_blue = cafr.CAFR_color.CQ_redOrIndex;
	}

}


/**************************************************************************/

/*
static ClipboardQuickNotifyFlags
PasteCommon(ClipboardItemFlags transferFlags, optr oself, word bvattrs)
{
  ClipboardItemHeader       *item;
  ClipboardQueryArgs           query;
  ClipboardRequestArgs      request;
  ClipboardQuickNotifyFlags retVal;
  VMBlockHandle bitmap;
  MemHandle mem;
  FileLongName name;

  ClipboardQueryItem(transferFlags, &query);
  if (query.CQA_numFormats)
  {
	 if (ClipboardTestItemFormat(query.CQA_header, BITMAP_FORMAT))
	 {
		item = VMLock(FileFromTransferBlockID(query.CQA_header),
				 BlockFromTransferBlockID(query.CQA_header),
				 &mem);

		if(item->CIH_name[0] != 0)
		{
		  strcpy(name, item->CIH_name);
		}
		else
		{
				  MemLock(OptrToHandle(@BVClipUnnamed));
				  strcpy(name, LMemDeref(@BVClipUnnamed));
				  MemUnlock(OptrToHandle(@BVClipUnnamed));
				};
		VMUnlock(mem);
		ClipboardRequestItemFormat(BITMAP_FORMAT, query.CQA_header, &request);

				bitmap = MyVMCopyVMChain(request.CRA_file, request.CRA_data,
											  ClipboardGetClipboardFile());
		if(bitmap != 0)
		{
				  if((bvattrs & BVA_BITMAP_OPEN)!=0)
						 @call oself::MSG_BV_CLOSE_BITMAP();
				  @call oself::MSG_BV_OPEN_BITMAP(ClipboardGetClipboardFile(),
												  bitmap, name, 0);
				  retVal = CQNF_COPY; */
				  /*SendSelectNotify(bitmap);*/
		/*        }
		else
		{
		  retVal = CQNF_ERROR;
		}
	 }
	 else
	 {
		retVal = CQNF_NO_OPERATION;
	 }
  }
  else
  {
	 retVal = CQNF_NO_OPERATION;
  }
  ClipboardDoneWithItem(query.CQA_header);

  return(retVal);
}
*/

/**************************************************************************/

/*
@method BVDocumentClass, MSG_META_CLIPBOARD_CUT
{
  @call oself::MSG_META_CLIPBOARD_COPY();
  @call oself::MSG_META_DELETE();
}
*/

/**************************************************************************/

@method BVDocumentClass, MSG_META_CLIPBOARD_COPY
{
  (void) CopyCommon(TIF_NORMAL, pself->BVBmpFile, pself->BVBmpBlock,
							pself->GDI_fileName,
						   pself->BVBmpWidth, pself->BVBmpHeight);
}

/**************************************************************************/

/*
@method BVDocumentClass, MSG_META_CLIPBOARD_PASTE
{
  (void) PasteCommon(TIF_NORMAL, oself, pself->BVAttrs);
}
*/

/**************************************************************************/

@method BVDocumentClass, MSG_META_CLIPBOARD_NOTIFY_NORMAL_TRANSFER_ITEM_CHANGED
{
  SendSelectNotify(0);
}

/**************************************************************************/

@method BVProcessClass, MSG_GEN_PROCESS_OPEN_APPLICATION
{
//  word version;
  DiskHandle disk;
  DisplayScheme display;
/*TimerDateAndTime date; */
/*FontID font; */
/*  byte temp; */
  word docOpt, size;
  Boolean docOptStat, stat;
//  VMBlockHandle mapblock;
//  MemHandle mem;
@ifdef OLD_THUMBNAIL_DB
  BVThumbDBMap *mapptr;
@endif
  word drives, count, drvstat, drive, count1;
  BVStateData *sdptr;
  char *path;
  char path2[256];
  char path3[256];
  ColorQuad pngBlendColor = {0};

  if((extraState != 0) &&
	((attachFlags & AAF_RESTORING_FROM_STATE)!=0))
  {
	sdptr = MemLock(extraState);
	path = &(path2[0]);

	disk = FileConstructFullPath(&path,255,0,&(sdptr->BVSD_path[0]), FALSE);

	path = &(path2[0]);
	BVCurrentDisk = FileParseStandardPath(disk, (const char**) &path);
	strcpy(BVCurrentPath, path);
	if(BVCurrentDisk == SP_NOT_STANDARD_PATH)
	  BVCurrentDisk = disk;

	if(BVCurrentPath[0] == 0)
	  strcpy(BVCurrentPath, "\\");

	BVBrowserFocus = sdptr->BVSD_focus;
	BVAttrs2 = sdptr->BVSD_attrs;

	MemUnlock(extraState);
  }
  else
  {
@ifdef NEWDEAL_MEDIA_VIEWER
	stat = InitFileReadStringBuffer("MediaViewer","dlgPath",path3,255,&size);
@else
	stat = InitFileReadStringBuffer("GraphicsViewer","dlgPath",path3,255,&size);
@endif
	if(stat == FALSE)
	{
	  path = &(path2[0]);

	  disk = FileConstructFullPath(&path,255,0,&(path3[0]), FALSE);
	  path = &(path2[0]);
	  BVCurrentDisk = FileParseStandardPath(disk, (const char**) &path);
	  strcpy(BVCurrentPath, path);
	  if(BVCurrentDisk == SP_NOT_STANDARD_PATH)
		BVCurrentDisk = disk;

	  if(BVCurrentPath[0] == 0)
		strcpy(BVCurrentPath, "\\");
	};
  };

  BVFileList = 0;
  BVFileNumber = 0;
@ifdef OLD_THUMBNAIL_DB
  BVThumbnailDB = 0;
@endif

  /* show open trigger in file menu */
  docOptStat = InitFileReadInteger("uiFeatures","docControlOptions",&docOpt);
  if((docOptStat != FALSE) || ((docOpt & 8192) == 0))
	@send BVFileOpenTrigger::MSG_GEN_SET_USABLE(VUM_NOW);
  else
	@send BVFileOpenTrigger::MSG_GEN_SET_NOT_USABLE(VUM_NOW);

/* temp = 9; */

@ifdef OLD_THUMBNAIL_DB

  /* opening or creating thumbnail database */
  FilePushDir();
  FileSetCurrentPath(SP_PRIVATE_DATA, ".");

  BVThumbnailDB = VMOpen("Thumbnail Database",0,VMO_CREATE,0);
  FilePopDir();

  mapblock = VMGetMapBlock(BVThumbnailDB);
  if(mapblock == 0)
  {
	/* create map block */
	mapblock = VMAlloc(BVThumbnailDB, sizeof(BVThumbDBMap), 0);
	mapptr = VMLock(BVThumbnailDB, mapblock, &mem);

	mapptr->BVTDBM_firstItem = 0;
	mapptr->BVTDBM_lastItem = 0;
	mapptr->BVTDBM_version = 1;

	VMDirty(mem);
	VMUnlock(mem);
	VMSetMapBlock(BVThumbnailDB, mapblock);
  }
  else
  {
	/* create map block */
	mapptr = VMLock(BVThumbnailDB, mapblock, &mem);

	version = mapptr->BVTDBM_version;

	VMUnlock(mem);

	if(version != 1)
	{
		VMClose(BVThumbnailDB, FILE_NO_ERRORS);
		BVThumbnailDB = 0;
	}
  }
@endif

  /* reading available drives */
  drive = DiskGetDrive(BVCurrentDisk);
  drives = 0;
  count = 256;
  do
  {
	count--;
	drvstat = DriveGetStatus(count);
	if((drvstat&DS_PRESENT) != 0)
	  drives++;
	if(count == drive)
	  count1 = drives;
  }
  while(count != 0);

  @call BVImpFileDirDrive::MSG_GEN_DYNAMIC_LIST_INITIALIZE(drives);

  @call process::MSG_BV_READ_FILES();

  @send BVApp::MSG_GEN_APPLICATION_INSTALL_TOKEN();
  @call BVApp::MSG_GEN_APPLICATION_GET_DISPLAY_SCHEME(&display);
  BVDisplayClass = display.DS_displayType & DT_DISP_CLASS;
  if(BVDisplayClass != DC_COLOR_8)
	 @send BVViewPalette::MSG_GEN_SET_NOT_ENABLED(VUM_NOW);

  ClipboardAddToNotificationList(HandleToOptr(GeodeGetProcessHandle()));

  @send BVImpFileDirDrive::MSG_GEN_ITEM_GROUP_SET_SINGLE_SELECTION(drives - count1, FALSE);

@ifdef NEWDEAL_MEDIA_VIEWER
	stat = InitFileReadDataBuffer("MediaViewer", "pngBlendColor", &pngBlendColor, sizeof(ColorQuad), 0);
@else
	stat = InitFileReadDataBuffer("GraphicsViewer", "pngBlendColor", &pngBlendColor, sizeof(ColorQuad), 0);
@endif

	if (!stat)
	{
		@send BlendColorControl::MSG_COLOR_SELECTOR_SET_COLOR(pngBlendColor, FALSE);
	}

  @callsuper();
}

/**************************************************************************/

@method BVProcessClass, MSG_GEN_PROCESS_CLOSE_APPLICATION
{
  MemHandle extramem;
  BVStateData *sdptr;
  char *path;

  ClipboardRemoveFromNotificationList(HandleToOptr(GeodeGetProcessHandle()));

  if(BVFileList != 0)
  {
	MemFree(BVFileList);
	BVFileList = 0;
  }

  @call BVDynFileList::MSG_BV_DELETE_FILELIST();

@ifdef OLD_THUMBNAIL_DB
  if(BVThumbnailDB != 0)
  {
	VMClose(BVThumbnailDB, FILE_NO_ERRORS);
	BVThumbnailDB = 0;
  }
@endif

  @callsuper();

  extramem = MemAlloc(sizeof(BVStateData),HF_SWAPABLE ,0);
  sdptr = MemLock(extramem);
  path = &(sdptr->BVSD_path[0]);
  FileConstructFullPath(&path,255,BVCurrentDisk,BVCurrentPath, TRUE);
  sdptr->BVSD_focus = BVBrowserFocus;
  sdptr->BVSD_attrs = BVAttrs2;
  MemUnlock(extramem);
  return(extramem);
}

/**************************************************************************/
@method BVProcessClass, MSG_META_COLORED_OBJECT_SET_COLOR
{

@ifdef NEWDEAL_MEDIA_VIEWER
	InitFileWriteData("MediaViewer", "pngBlendColor", &colorQuad, sizeof(ColorQuad));
@else
	InitFileWriteData("GraphicsViewer", "pngBlendColor", &colorQuad, sizeof(ColorQuad));
@endif

  	InitFileCommit();

	@send BlendColorControl::MSG_GEN_GUP_INTERACTION_COMMAND(IC_DISMISS);
}

/**************************************************************************/

@method BVDocumentClass, MSG_BV_OPEN_BITMAP
{
  word pallen;
  word offset;
  byte *ptr, *temppal, *destpal;
  byte type;
  MemHandle mem, palmem, palmem2;
  word width, height;
  GStateHandle gstate;
/*  char string[55];
  char string2[LOCAL_DISTANCE_BUFFER_SIZE];
*/  VisUpdateModeAsWord update;

  /* read picture parameters */
  ptr = VMLock(file, block, &mem);

  width = ptr[0x1a]+256*(ptr[0x1b]);
  height = ptr[0x1c]+256*(ptr[0x1d]);

  type = ptr[0x1f];

  offset = ptr[0x28]+256*(ptr[0x29]);
  offset += 0x1c;

  pallen = ptr[offset-2]+256*(ptr[offset-1]);

  VMUnlock(mem);

  update.VUMAW_mode = VUM_DELAYED_VIA_APP_QUEUE;

  @send pself->GCI_genView::MSG_GEN_VIEW_SET_ATTRS(0, GVA_SCALE_TO_FIT, update);
  @send pself->GCI_genView::MSG_GEN_VIEW_SET_SCALE_FACTOR(0, 0, SVT_AROUND_POINT,
							MakeWWFixed(1.0), MakeWWFixed(1.0));
  @send pself->GCI_genView::MSG_GEN_VIEW_SET_DOC_BOUNDS(1000, 1000,0 ,0);

  pself->BVBmpWidth = width;
  pself->BVBmpHeight = height;
  pself->BVBmpFile = file;
  pself->BVBmpBlock = block;
  pself->BVType = type;
  strcpy(pself->BVImpForm, srcform);
  strcpy(pself->BVName ,name);

  if((pallen != 0)&&((type&BMT_PALETTE) != 0))
  {
	 palmem = MemAlloc(240*3, 0, 0);
		 pself->BVPalette = palmem;

	 palmem2 = MemAlloc(256*3, 0, 0);
	 temppal = MemLock(palmem2);
	 ptr = VMLock(file, block, &mem);
	 memcpy(temppal, &(ptr[offset]), pallen*3);
	 VMUnlock(mem);

	 destpal = MemLock(palmem);
	 if(pallen == 256)
	 {
		QuantPalette((RGBValue *)temppal, pallen, (RGBValue *) destpal, 240);
		memcpy(temppal, destpal, 240*3);
		pallen = 240;
	 };
	 MemUnlock(palmem);
	 MemUnlock(palmem2);
	 MemFree(palmem2);

	 /* Palette an System ausrichten */
  };

  pself->BVAttrs |= BVA_BITMAP_OPEN;

  gstate = GrCreateState(pself->BVWindow);
  GrInvalRect(gstate, 0, 0, width, height);
  GrDestroyState(gstate);
  if(pself->BVWindow != 0)
		 @call process::MSG_META_EXPOSED(pself->BVWindow);

}

/**************************************************************************/

@method BVDocumentClass, MSG_BV_CLOSE_BITMAP
{
  GStateHandle gstate;
  MemHandle pal;

  pself = ObjDerefGen(oself);

  @send oself::MSG_BV_RESET_PALETTE();

  pself->BVAttrs &= ~BVA_BITMAP_OPEN;

  gstate = GrCreateState(pself->BVWindow);
  GrInvalRect(gstate, 0, 0, pself->BVBmpWidth, pself->BVBmpHeight);
  GrDestroyState(gstate);

  if(pself->BVWindow != 0)
		 @call oself::MSG_META_EXPOSED(pself->BVWindow);

  MyVMFreeVMChain(pself->BVBmpFile,
	  VMCHAIN_MAKE_FROM_VM_BLOCK(pself->BVBmpBlock));

  if(pself->BVWindow != 0)
		 @call process::MSG_META_EXPOSED(pself->BVWindow);

/*  @send pself->GCI_genView::MSG_GEN_VIEW_SET_ORIGIN(0, 0);
  @send pself->GCI_genView::MSG_GEN_VIEW_SET_DOC_BOUNDS(0, 0 ,0 ,0);
*/
  pself->BVBmpFile = 0;
  pself->BVBmpBlock = 0;
  pself->BVBmpWidth = 0;
  pself->BVBmpHeight = 0;
  pself->BVType = 0;
  pself->BVImpForm[0] = 0;
  pself->BVName[0] = 0;

  /* free optional palette */
  pal = pself->BVPalette;
  pself->BVPalette = 0;
  if(pal != 0)
	MemFree(pal);
}

/**************************************************************************/

@method BVDocumentClass, MSG_META_EXPOSED
{
  GStateHandle gstate;
  byte *pal;

  gstate=GrCreateState(pself->BVWindow);
  GrBeginUpdate(gstate);

  /* is this a 256 color device */
  if((pself->BVAttrs&BVA_BITMAP_OPEN)==BVA_BITMAP_OPEN)
  {
		 if(((pself->BVPalette != 0)&&((BVAttrs2&BVA_REALIZE_PALETTE)!=0))
			 && (BVDisplayClass == DC_COLOR_8))
	 {
		GrCreatePalette(gstate);
				pal = MemLock(pself->BVPalette);
		GrSetPalette(gstate, (RGBValue *)pal, 16, 240);
				MemUnlock(pself->BVPalette);
				GrDrawHugeBitmap(gstate, 0, 0, pself->BVBmpFile, pself->BVBmpBlock);
		GrDestroyPalette(gstate);
	 }
	 else
	 {
		GrDrawHugeBitmap(gstate, 0, 0, pself->BVBmpFile, pself->BVBmpBlock);
	 };
  };
  GrEndUpdate(gstate);
  GrDestroyState(gstate);
}

/**************************************************************************/

@method BVDocumentClass, MSG_META_GAINED_TARGET_EXCL
{
  @callsuper();
  SendSelectNotify(pself->BVBmpBlock);
  @send oself::MSG_BV_SHOW_PIC_INFO();
}

/**************************************************************************/

@method BVDocumentClass, MSG_META_LOST_TARGET_EXCL
{
  SendSelectNotify(0);
  @send oself::MSG_BV_CLEAR_PIC_INFO();
}

/**************************************************************************/

@method BVDocumentClass, MSG_META_GAINED_SYS_TARGET_EXCL
{
  @callsuper();
  pself->BVAttrs |= BVA_SYS_TARGET;
  @call oself::MSG_BV_SET_PALETTE();
}

/**************************************************************************/

@method BVDocumentClass, MSG_META_LOST_SYS_TARGET_EXCL
{
  @call oself::MSG_BV_RESET_PALETTE();
  pself->BVAttrs &= ~BVA_SYS_TARGET;
  @callsuper();
}

/**************************************************************************/

@method BVDocumentClass, MSG_META_CONTENT_VIEW_OPENING
{
  @callsuper();
  pself->BVAttrs |= BVA_WIN_OPEN;
  @call oself::MSG_BV_SET_PALETTE();
}

/**************************************************************************/

@method BVDocumentClass, MSG_META_CONTENT_VIEW_CLOSING
{
  @call oself::MSG_BV_RESET_PALETTE();
  pself->BVAttrs &= ~BVA_WIN_OPEN;
  @callsuper();
}

/**************************************************************************/

@method BVDocumentClass, MSG_BV_SET_PALETTE
{
  byte *pal;
  GStateHandle gstate;

  if(BVBrowserFocus == TRUE)
	return;

  /* is this a 256 color device */
  if(((pself->BVAttrs&(BVA_BITMAP_OPEN|BVA_SYS_TARGET|BVA_WIN_OPEN))
	 ==(BVA_SYS_TARGET|BVA_WIN_OPEN|BVA_BITMAP_OPEN))
	  && (BVDisplayClass == DC_COLOR_8))
  {
		 if(((pself->BVPalette != 0)&&((BVAttrs2&BVA_REALIZE_PALETTE)!=0))
							 && (BVDisplayClass == DC_COLOR_8))
	 {
				gstate = GrCreateState(pself->BVWindow);
		GrCreatePalette(gstate);
				pal = MemLock(pself->BVPalette);
		GrSetPalette(gstate, (RGBValue *)pal, 16, 240);
				MemUnlock(pself->BVPalette);
				WinRealizePalette(pself->BVWindow);
		GrDestroyPalette(gstate);
		GrDestroyState(gstate);
	 };
  };
}

/**************************************************************************/

@method BVDocumentClass, MSG_BV_RESET_PALETTE
{
  GStateHandle gstate;


  if(((pself->BVAttrs&(BVA_BITMAP_OPEN|BVA_SYS_TARGET|BVA_WIN_OPEN))
	==(BVA_BITMAP_OPEN|BVA_SYS_TARGET|BVA_WIN_OPEN))
	  && (BVDisplayClass == DC_COLOR_8))
  {
		 gstate = GrCreateState(pself->BVWindow);
	 GrCreatePalette(gstate);
		 WinRealizePalette(pself->BVWindow);
	 GrDestroyPalette(gstate);
	 GrDestroyState(gstate);
  }
}

/**************************************************************************/

@method BVDocumentClass, MSG_META_CONTENT_VIEW_WIN_OPENED
{
  @callsuper();
  pself->BVWindow = viewWindow;
}

/**************************************************************************/

@method BVDocumentClass, MSG_META_CONTENT_VIEW_WIN_CLOSED
{
  pself->BVWindow = NULL;
  @callsuper();
}

/**************************************************************************/

/*
@method BVDocumentClass, MSG_META_DELETE
{
  if((pself->BVAttrs & BVA_BITMAP_OPEN)!=0)
						 @call oself::MSG_BV_CLOSE_BITMAP();
  SendSelectNotify(0);
}
*/

/**************************************************************************/

@method BVDocumentClass, MSG_META_START_MOVE_COPY
{
  if (ClipboardStartQuickTransfer(CQTF_COPY_ONLY | CQTF_NOTIFICATION,
		CQTF_COPY,0, 0, 0, oself))
  {
		 if (CopyCommon(CIF_QUICK, pself->BVBmpFile, pself->BVBmpBlock,
		  pself->GDI_fileName, pself->BVBmpWidth, pself->BVBmpHeight))
	 {
				@send pself->GCI_genView::MSG_GEN_VIEW_ALLOW_GLOBAL_TRANSFER();
	 }
	 else
	 {
		ClipboardAbortQuickTransfer();
	 }
  }
  retVal->flags = MRF_PROCESSED;
}

/**************************************************************************/

/*
@method BVDocumentClass, MSG_META_PTR
{
  if ((GET_UI_FUNCTIONS_ACTIVE(inputState) & UIFA_MOVE_COPY) &&
			ClipboardGetQuickTransferStatus())
  {
	 ClipboardSetQuickTransferFeedback((CheckPasteable(CIF_QUICK) ?
					 CQTF_COPY :
					 CQTF_CLEAR),
					inputState);
  }
  retVal->flags = MRF_PROCESSED;
}
*/

/**************************************************************************/

/*
@method BVDocumentClass, MSG_META_END_MOVE_COPY
{
  ClipboardEndQuickTransfer(PasteCommon(CIF_QUICK, oself, pself->BVAttrs));
  retVal->flags = MRF_PROCESSED;
}
*/

/**************************************************************************/

/*
@method BVProcessClass, MSG_BV_FILE_SELECTION
{
  if(GFS_GET_ENTRY_TYPE(entryFlags) == GFSET_FILE)
  {
	 @send process::MSG_BV_FILE_SELECTED();
	 if(GFS_GET_ENTRY_FLAGS(entryFlags) & GFSEF_OPEN)
		  @send BVImpTrigger::MSG_GEN_TRIGGER_SEND_ACTION(FALSE);
  }
  else
  {
	 @send process::MSG_BV_NO_FILE_SELECTED();
  };
};
*/

/**************************************************************************/

@method BVProcessClass, MSG_BV_QUERY_RESET_OPTIONS
{
	 MemLock(OptrToHandle(@BVResetConfig));

	 if (UserStandardDialog((char *) 0,
				(char *) 0,
				(char *) 0, (char *) 0,
				LMemDeref(@BVResetConfig),
				(GIT_AFFIRMATION << CDBF_INTERACTION_TYPE_OFFSET) |
				(CDT_QUESTION << CDBF_DIALOG_TYPE_OFFSET))
								 == IC_YES)
	{
	  @send BVApp::MSG_META_RESET_OPTIONS();
	};
	MemUnlock(OptrToHandle(@BVResetConfig));
};

/**************************************************************************/

@method BVDocumentClass, MSG_GEN_DOCUMENT_ATTACH_UI_TO_DOCUMENT
{
	dword date, size;
	Boolean stat;
	ImpBmpStatus status;
	ImpBmpParams para;
	char string[255];
	VMBlockHandle bmpblock;
	word count;
	RGBValue blendColor = {0};

	MemLock(OptrToHandle(@BVImportingText));
	strcpy(string, LMemDeref(@BVImportingText));
	MemUnlock(OptrToHandle(@BVImportingText));

	strcat(string, pself->GDI_fileName);
	strcat(string, "...");

	@callsuper();

	@send BVImportingTex::MSG_GEN_REPLACE_VIS_MONIKER_TEXT(string ,VUM_NOW);
	@send BVImportingDlg::MSG_GEN_INTERACTION_INITIATE();

	count = 0;
	while(count != sizeof(pself->BVTempName))
	{
		pself->BVTempName[count] = 0;
		count++;
	};

	FilePushDir();
	FileSetCurrentPath(SP_WASTE_BASKET, ".");
	para.IBP_source = pself->GDI_fileHandle ;
	para.IBP_dest = VMOpen(pself->BVTempName, VMAF_FORCE_READ_WRITE, VMO_TEMP_FILE, 0);
	FilePopDir();
	para.IBP_status = @BVImportStatus;

	getPngBlendColor(&blendColor);
	para.IBP_pngBlendColor = blendColor;

	// start importing
	status = Imp_BmpProcessFile(&para, IBF_AUTO);

	@send BVImportingDlg::MSG_GEN_GUP_INTERACTION_COMMAND(IC_DISMISS);

	if(status == IBS_NO_ERROR)
	{
		bmpblock = GrCompactBitmap(para.IBP_dest, para.IBP_bitmap, para.IBP_dest);
		MyVMFreeVMChain(para.IBP_dest, VMCHAIN_MAKE_FROM_VM_BLOCK(para.IBP_bitmap));
		para.IBP_bitmap = bmpblock;

		date = FileGetDateAndTime(pself->GDI_fileHandle) ;
		/* this doesn't work in all fs drivers (only ms4) so we'll go with...
		FileGetHandleExtAttributes(pself->GDI_fileHandle,FEA_SIZE,&size, sizeof(size));
		/* this more generic routine. jfh 6/7/04 */
		size = FileSize(pself->GDI_fileHandle);

		stat = @call BVOptionGroup::MSG_GEN_BOOLEAN_GROUP_IS_BOOLEAN_SELECTED(BV_AUTOCREAT_THUMB);
        	if(stat != FALSE)
			@call process::MSG_BV_CREATE_THUMBNAIL(pself->GDI_fileName, size, date,
				para.IBP_dest, para.IBP_bitmap);

		pself = ObjDerefGen(oself);
		if((pself->BVAttrs & BVA_BITMAP_OPEN)!=0)
			@call oself::MSG_BV_CLOSE_BITMAP();

		@call oself::MSG_BV_OPEN_BITMAP(para.IBP_dest, para.IBP_bitmap,
			pself->GDI_fileName, para.IBP_impForm);

		stat = @call BVOptionGroup::
			MSG_GEN_BOOLEAN_GROUP_IS_BOOLEAN_SELECTED(BV_IMP_INFO);

		if(stat != FALSE)
		{
			MemLock(OptrToHandle(@BVImportFormat));

			UserStandardDialog((char *) 0,
				(char *) 0,
				(char *) 0, para.IBP_impForm,
				LMemDeref(@BVImportFormat),
				(GIT_NOTIFICATION << CDBF_INTERACTION_TYPE_OFFSET) |
				(CDT_NOTIFICATION << CDBF_DIALOG_TYPE_OFFSET));

			MemUnlock(OptrToHandle(@BVImportFormat));
		};
		stat = FALSE;
	}
	else
	{
		stat = TRUE;

		if(status == IBS_IMPORT_STOPPED)
		{
			MemLock(OptrToHandle(@BVImportStopped));

			UserStandardDialog((char *) 0,
				(char *) 0,
				(char *) 0, (char *) 0,
				LMemDeref(@BVImportStopped),
				(GIT_NOTIFICATION << CDBF_INTERACTION_TYPE_OFFSET) |
				(CDT_NOTIFICATION << CDBF_DIALOG_TYPE_OFFSET));

			MemUnlock(OptrToHandle(@BVImportStopped));
		}
		else
			if(status == IBS_UNSUPPORTED_COMPRESSION)
			{
				MemLock(OptrToHandle(@BVImportError));

				LocalFixedToAscii(string, MakeWWFixed(status), 0);
				UserStandardDialog((char *) 0,
					(char *) 0,
					(char *) 0, string,
					LMemDeref(@BVUnsupportedCompressionError),
					(GIT_NOTIFICATION << CDBF_INTERACTION_TYPE_OFFSET) |
					(CDT_ERROR << CDBF_DIALOG_TYPE_OFFSET));

				MemUnlock(OptrToHandle(@BVImportError));
			}
			else
			{
				MemLock(OptrToHandle(@BVImportError));

				LocalFixedToAscii(string, MakeWWFixed(status), 0);
				UserStandardDialog((char *) 0,
					(char *) 0,
					(char *) 0, string,
					LMemDeref(@BVImportError),
					(GIT_NOTIFICATION << CDBF_INTERACTION_TYPE_OFFSET) |
					(CDT_ERROR << CDBF_DIALOG_TYPE_OFFSET));

				MemUnlock(OptrToHandle(@BVImportError));
			};

		@send oself::MSG_GEN_DOCUMENT_CLOSE(0);
	};
}

/**************************************************************************/

@method BVDocumentClass, /* MSG_GEN_DOCUMENT_PHYSICAL_CLOSE */
						 MSG_GEN_DOCUMENT_DETACH_UI_FROM_DOCUMENT
{
  FileHandle file;

  file = pself->BVBmpFile;

  if(file != 0)
  {
	if((pself->BVAttrs & BVA_BITMAP_OPEN)!=0)
						 @call oself::MSG_BV_CLOSE_BITMAP();

	VMClose(file, FILE_NO_ERRORS);

	FilePushDir();
	FileSetCurrentPath(SP_WASTE_BASKET,".");
	FileDelete(pself->BVTempName);
	FilePopDir();
  }
}

/**************************************************************************/

@method BVDocumentClass, MSG_VIS_RECALC_SIZE
{
  return(MAKE_SIZE_DWORD(pself->BVBmpWidth, pself->BVBmpHeight));
}

/**************************************************************************/

@method BVDocCtrlClass, MSG_GEN_DOCUMENT_CONTROL_INITIATE_OPEN_DOC
{
  @send BVFileImpBmp::MSG_GEN_INTERACTION_INITIATE();
};

/**************************************************************************/

@method BVProcessClass, MSG_BV_IMPORT_BITMAP
{
  DocumentCommonParams docParams;
  BVFileAttr *filelist;
  word filecount, filenum, /*fileident,*/ filenum2;
  MemHandle fileidlist;
  word *idlistptr;
  Boolean stat;

  stat = @call BVOptionGroup::MSG_GEN_BOOLEAN_GROUP_IS_BOOLEAN_SELECTED(BV_AUTOCLOSE_OBOX);

  if(stat != FALSE)
	@send BVFileImpBmp::MSG_GEN_GUP_INTERACTION_COMMAND(IC_DISMISS);

  if(BVFileList != 0)
  {

	filenum = @call BVDynFileList::MSG_GEN_ITEM_GROUP_GET_NUM_SELECTIONS();

	fileidlist = MemAlloc(filenum*2, 0, 0);

	idlistptr = MemLock(fileidlist);

	filenum = @call BVDynFileList::MSG_GEN_ITEM_GROUP_GET_MULTIPLE_SELECTIONS(
	  idlistptr, filenum*2);

	MemUnlock(fileidlist);

	filecount = 0;
	do
	{
	  idlistptr = MemLock(fileidlist);
	  filenum2 = idlistptr[filecount];
	  MemUnlock(fileidlist);

	  filelist = MemLock(BVFileList);
	  if((filelist[filenum2].BVFA_type&FA_SUBDIR) == 0)
	  {
		strcpy(docParams.DCP_name, filelist[filenum2].BVFA_name);
		MemUnlock(BVFileList);

		strcpy(docParams.DCP_path, BVCurrentPath);
		docParams.DCP_diskHandle = BVCurrentDisk;

		docParams.DCP_docAttrs = GDA_READ_ONLY;
		docParams.DCP_flags = 0;
		docParams.DCP_connection = 0;
		@call BVDocumentGroup::MSG_GEN_DOCUMENT_GROUP_OPEN_DOC(&docParams);

		@send BVDynFileList::MSG_GEN_ITEM_GROUP_SET_ITEM_STATE(filenum2, 0);
	  }
	  else
	  {
		MemUnlock(BVFileList);
	  };
	  filecount++;
	}
	while(filecount != filenum);

	MemFree(fileidlist);

	@send oself::MSG_BV_UPDATE_OPEN_TRIGGER();
  };
}

/**************************************************************************/

@method BVAppClass, MSG_GEN_APPLICATION_VISIBILITY_NOTIFICATION
{
  @send BVOptionGroup::MSG_GEN_BOOLEAN_GROUP_SET_BOOLEAN_STATE
								(BV_SHOW_TOOLS,opening);
  @send BVOptionGroup::MSG_GEN_BOOLEAN_GROUP_SET_BOOLEAN_MODIFIED_STATE
								(BV_SHOW_TOOLS,TRUE);
};

/**************************************************************************/

@method BVDocumentClass, MSG_BV_SHOW_PIC_INFO
{
  char string[20];

  @call BVPicInfoName::MSG_VIS_TEXT_REPLACE_ALL_PTR(pself->BVName,0);

  LocalFixedToAscii(string, MakeWWFixed(pself->BVBmpWidth), 0);
  @call BVPicInfoX::MSG_VIS_TEXT_REPLACE_ALL_PTR(string,0);

  LocalFixedToAscii(string, MakeWWFixed(pself->BVBmpHeight), 0);
  @call BVPicInfoY::MSG_VIS_TEXT_REPLACE_ALL_PTR(string,0);

  switch((pself->BVType)&BMT_FORMAT)
  {
	 case BMF_MONO:
				strcpy(string, "2");
		break;

	 case BMF_4BIT:
				strcpy(string, "16");
		break;

	 case BMF_8BIT:
				strcpy(string, "256");
		break;

	 case BMF_24BIT:
				strcpy(string, "16.7M");
		break;

	 default:
				strcpy(string, "???");
		break;
  }
  @call BVPicInfoCol::MSG_VIS_TEXT_REPLACE_ALL_PTR(string,0);
	/*
		 switch(pself->BVImpForm)
		 {
			 case IBF_BMP:
				strcpy(string, ".BMP");
				break;

			 case IBF_PCX:
				strcpy(string, ".PCX");
				break;

			 case IBF_GIF:
				strcpy(string, ".GIF");
				break;
@ifdef JPEG_SUPPORT
			 case IBF_JPEG:
				strcpy(string, ".JPG");
				break;
@endif
			 case IBF_TIFF:
				strcpy(string, ".TIF");
				break;
	}; */
	@call BVPicInfoForm::MSG_VIS_TEXT_REPLACE_ALL_PTR(pself->BVImpForm,0);

}

/**************************************************************************/

@method BVDocumentClass, MSG_BV_CLEAR_PIC_INFO
{
  @call BVPicInfoName::MSG_VIS_TEXT_REPLACE_ALL_OPTR(
	@BVNoGraphicOpenText, 0);
  @call BVPicInfoX::MSG_VIS_TEXT_REPLACE_ALL_PTR("",0);
  @call BVPicInfoY::MSG_VIS_TEXT_REPLACE_ALL_PTR("",0);
  @call BVPicInfoCol::MSG_VIS_TEXT_REPLACE_ALL_PTR("",0);
  @call BVPicInfoForm::MSG_VIS_TEXT_REPLACE_ALL_PTR("",0);
};

/**************************************************************************/

Boolean StrEnd(char *text, char *endstr)
{
	word pos;

	pos = strlen(text) - strlen(endstr);

	return((LocalCmpStringsNoCase(&(text[pos]), endstr, 0)) == 0);
}

/**************************************************************************/

@method BVProcessClass, MSG_BV_READ_FILES
{
#define MOD_S    sizeof(FileDateAndTime)
#define SIZE_S   sizeof(dword)
#define ATTR_S   sizeof(FileAttrs)
#define NAME_S   sizeof(FileLongName)

  FileExtAttrDesc attrs[] = {
						{FEA_MODIFICATION, (void *) 0, sizeof(FileDateAndTime), 0},
						{FEA_SIZE, (void *) MOD_S, sizeof(dword), 0},
						{FEA_FILE_ATTR, (void *) (MOD_S + SIZE_S), sizeof(FileAttrs), 0},
						{FEA_NAME, (void *) (MOD_S + SIZE_S + ATTR_S), sizeof(FileLongName), 0},
						{FEA_END_OF_LIST, 0, 0, 0}
					  };
  FileEnumParams params;
  word itemsleft;
/*  word number; */
  MemHandle mem, objblock;
  FileAttrs attrs1, attrs2;
  BVFileAttr fileattr, *filelist;
  word count1, count2;
  char path[256];
  char *pathptr;
  optr child;
  word childcount;
/*  word blocksize; */
  word drive;
  word sel;

  @send BVApp::MSG_GEN_APPLICATION_MARK_BUSY();
  FilePushDir();
  FileSetCurrentPath(BVCurrentDisk, BVCurrentPath);


  params.FEP_searchFlags = FESF_NON_GEOS|FESF_DIRS;
  params.FEP_returnAttrs = &attrs;
  params.FEP_returnSize = MOD_S + SIZE_S + ATTR_S + NAME_S;
  params.FEP_matchAttrs = 0;
  params.FEP_bufSize = 300 /*FE_BUFSIZE_UNLIMITED*/;
  params.FEP_skipCount = 0;
  params.FEP_callback = 0;
  params.FEP_callbackAttrs = 0;
  params.FEP_cbData1 = 0;
  params.FEP_cbData2 = 0;
  params.FEP_headerSize = 0;

  BVFileNumber = FileEnum(&params, &mem, &itemsleft);

  if(BVFileList != 0)
	MemFree(BVFileList);

  if(BVFileNumber != 0)
	BVFileList = mem;
  else
	BVFileList = 0;

  if(BVFileNumber != 0)
  {
	filelist = MemLock(mem);

	/* sorting */
	count1 = BVFileNumber;
	while(count1 != 0)
	{
	  count2 = count1;
	  while(count2 != 0)
	  {
		attrs1 = filelist[count1 - 1].BVFA_type & FA_SUBDIR;
		attrs2 = filelist[count2 - 1].BVFA_type & FA_SUBDIR;

		if( ( (strcmp(filelist[count1-1].BVFA_name,
			   filelist[count2-1].BVFA_name) < 0) &&  ((attrs1 == attrs2) || (attrs1 != 0))) ||
		   ((attrs1 != attrs2) && (attrs1 != 0)))
		{

		 /* swap if (count2) greater (count1) */
			fileattr = filelist[count1-1];
			filelist[count1-1] = filelist[count2-1];
			filelist[count2-1] = fileattr;
		};
		count2--;
	  };
	  count1--;
	};

	/* get view options */
	sel = @call BVImpFileShowTools::MSG_GEN_ITEM_GROUP_GET_SELECTION();

	/* filtering the file list */
	if(sel != BV_SHOW_ALL)
	{
		count1 = 0; /* writing */
		count2 = 0; /* reading */
		do
		{
			attrs1 = filelist[count2].BVFA_type & FA_SUBDIR;

			if(attrs1 == 0)
			{
				if(StrEnd(&filelist[count2].BVFA_name, ".BMP") && ((sel == BV_SHOW_BMP)
					|| (sel == BV_SHOW_ALL_MEDIA)))
				{
					filelist[count1] = filelist[count2];
					count1++;
				}
				else
					if(StrEnd(&filelist[count2].BVFA_name, ".PCX") && ((sel == BV_SHOW_PCX)
						|| (sel == BV_SHOW_ALL_MEDIA)))
					{
						filelist[count1] = filelist[count2];
						count1++;
					}
					else
						if(StrEnd(&filelist[count2].BVFA_name, ".GIF") && ((sel == BV_SHOW_GIF)
							|| (sel == BV_SHOW_ALL_MEDIA)))
						{
							filelist[count1] = filelist[count2];
							count1++;
						}
						else
							if(StrEnd(&filelist[count2].BVFA_name, ".PNG") && ((sel == BV_SHOW_PNG)
								|| (sel == BV_SHOW_ALL_MEDIA)))
							{
								filelist[count1] = filelist[count2];
								count1++;
							}

@ifdef JPEG_SUPPORT
							else
								if(StrEnd(&filelist[count2].BVFA_name, ".JPG") && ((sel == BV_SHOW_JPEG)
									|| (sel == BV_SHOW_ALL_MEDIA)))
								{
									filelist[count1] = filelist[count2];
									count1++;
								}
@endif
			}
			else
			{
				filelist[count1] = filelist[count2];
				count1++;
			}

			count2++;
		}
		while((count2 != BVFileNumber) && (count1 < 250));

		BVFileNumber = count1;
	}

	MemUnlock(mem);

	BVFileList = MemReAlloc(mem, BVFileNumber * sizeof(BVFileAttr), 0);
  };

  @call BVDynFileList::MSG_BV_DELETE_FILELIST();

  /* add new items for each file */
  childcount = 0;
  objblock = 0;
  while(childcount != BVFileNumber)
  {
	child = @call BVDynFileList::MSG_BV_ADD_FILELIST_ITEM(&objblock);

	@call BVDynFileList::MSG_GEN_ADD_CHILD(child, CCF_MARK_DIRTY|CCO_LAST);
	@call oself::MSG_BV_SET_FILELIST_MONIKER(childcount,child);
	@call child::MSG_GEN_ITEM_SET_IDENTIFIER(childcount);
	@call child::MSG_GEN_SET_USABLE(VUM_DELAYED_VIA_APP_QUEUE);
	childcount++;
  };
  @send BVDynFileList::MSG_GEN_ITEM_GROUP_SET_NONE_SELECTED(FALSE);



/*  @send BVDynFileList::MSG_GEN_DYNAMIC_LIST_INITIALIZE(BVFileNumber);*/

  FilePopDir();

  /* setting path list */
  pathptr = &(path[0]);
  FileConstructFullPath(&pathptr, 255, BVCurrentDisk, BVCurrentPath, FALSE);

  count1 = 1;
  count2 = 2;
  if(path[count1] == 0) count2 = 1;
  while(path[count1] != 0)
  {
	if(path[count1] == '\\')
	  count2++;
	count1++;
  }


  if((BVCurrentDisk == SP_DOCUMENT)&&(strcmp(BVCurrentPath, "") == 0))

	@send BVImpFileDirDoc::MSG_GEN_SET_NOT_ENABLED(VUM_NOW);
  else
	@send BVImpFileDirDoc::MSG_GEN_SET_ENABLED(VUM_NOW);

  if(strcmp(path, "\\")==0)
  {
	@send BVImpFileDirBelow::MSG_GEN_SET_NOT_ENABLED(VUM_NOW);
	@send BVImpFileDirPath::MSG_GEN_SET_NOT_ENABLED(VUM_NOW);
  }
  else
  {
	@send BVImpFileDirBelow::MSG_GEN_SET_ENABLED(VUM_NOW);
	@send BVImpFileDirPath::MSG_GEN_SET_ENABLED(VUM_NOW);
  }

  @send process::MSG_BV_NO_FILE_SELECTED();
  @send BVImpFileDirPath::MSG_GEN_DYNAMIC_LIST_INITIALIZE(count2);
  @send BVImpFileDirPath::MSG_GEN_ITEM_GROUP_SET_SINGLE_SELECTION(count2-1,FALSE);

  drive = DiskGetDrive(BVCurrentDisk);
  @send BVImpFileDirDrive::MSG_GEN_ITEM_GROUP_SET_SINGLE_SELECTION(drive,FALSE);


  @send BVApp::MSG_GEN_APPLICATION_MARK_NOT_BUSY();
}

/**************************************************************************/

@ifdef OLD_THUMBNAIL_DB
VMBlockHandle ThumbFindItem(FileLongName name, dword size,
							FileDateAndTime date)
{
  VMBlockHandle thumbnail = 0, mapblock;
  BVThumbDBMap *mapptr;
  DBGroupAndItem item;
  MemHandle mem;
  BVThumbDBItem *itemptr;

  if(BVThumbnailDB == 0)
	return(0);

  mapblock = VMGetMapBlock(BVThumbnailDB);

  if(mapblock != 0)
  {
	mapptr = VMLock(BVThumbnailDB, mapblock, &mem);
	item = mapptr->BVTDBM_firstItem;
	VMUnlock(mem);
	while((item != 0) && (thumbnail == 0))
	{
	  itemptr = DBLockUngrouped(BVThumbnailDB, item);
	  if((strcmp(name, itemptr->BVTDBI_name) == 0) &&
		 (date == itemptr->BVTDBI_date) &&
		 (size == itemptr->BVTDBI_size))
		thumbnail = itemptr->BVTDBI_thumbnail;
	  item = itemptr->BVTDBI_next;
	  DBUnlock(itemptr);
	}
  };
  return(thumbnail);
};

/**************************************************************************/

void
ThumbDeleteItem(FileLongName name, dword size,
							FileDateAndTime date)
{
  VMBlockHandle thumbnail = 0, mapblock;
  BVThumbDBMap *mapptr;
  DBGroupAndItem item;
  MemHandle mem;
  BVThumbDBItem *itemptr;
  DBGroupAndItem last, newitem;

  if(BVThumbnailDB == 0)
	return;

  last = 0;

  mapblock = VMGetMapBlock(BVThumbnailDB);

  if(mapblock != 0)
  {
	mapptr = VMLock(BVThumbnailDB, mapblock, &mem);
	item = mapptr->BVTDBM_firstItem;
	VMUnlock(mem);
	while((item != 0) && (thumbnail == 0))
	{
	  itemptr = DBLockUngrouped(BVThumbnailDB, item);
	  if((strcmp(name, itemptr->BVTDBI_name) == 0) &&
		 (date == itemptr->BVTDBI_date) &&
		 (size == itemptr->BVTDBI_size))
	  {
		newitem = itemptr->BVTDBI_next;

		thumbnail = itemptr->BVTDBI_thumbnail;

		 /* Thumbnail l�schen */
		 MyVMFreeVMChain(BVThumbnailDB, VMCHAIN_MAKE_FROM_VM_BLOCK(thumbnail));

		 /* item l�schen */
		DBUnlock(itemptr);
		DBFreeUngrouped(BVThumbnailDB, item);

		if(last == 0)
		{
			mapptr = VMLock(BVThumbnailDB, mapblock, &mem);
			mapptr->BVTDBM_firstItem = newitem;
			VMDirty(mem);
			VMUnlock(mem);
		}
		else
		{
			/* letztes item lock */
			itemptr = DBLockUngrouped(BVThumbnailDB, last);

			/* n�chstes eintragen */
			itemptr->BVTDBI_next = newitem;

			DBDirty(itemptr);
			DBUnlock(itemptr);
		}

		mapptr = VMLock(BVThumbnailDB, mapblock, &mem);
		if(item == mapptr->BVTDBM_lastItem)
			mapptr->BVTDBM_lastItem = last;
		VMDirty(mem);
		VMUnlock(mem);
	  }
	  else
	  {
		last = item;
		item = itemptr->BVTDBI_next;
		DBUnlock(itemptr);
	  }
	}
  };
  return;
};

/**************************************************************************/

void
ThumbCreateItem(FileLongName name, dword size, FileDateAndTime date,
				VMFileHandle file, VMBlockHandle block)
{
  VMBlockHandle thumbnail, compact;
  DBGroupAndItem item, item2;
  BVThumbDBItem *itemptr;
  BVThumbDBMap *mapptr;
  MemHandle mem/*, mem2*/;
  GStateHandle gstate;
  WWFixedAsDWord sx, sy;
  word x, y;
  byte *ptr/*, *ptr2*/;
  BMType type;
/*  word offset, offset2; */
  word size_x, size_y;

  if(BVThumbnailDB == 0)
	return;

  if((ThumbFindItem(name, size, date) == 0)&&
	 (BVThumbnailDB != 0))
  {
	ptr = VMLock(file, block, &mem);

	x = ptr[0x1a]+256*(ptr[0x1b]);
	y = ptr[0x1c]+256*(ptr[0x1d]);
	type = ptr[0x1f] & 7;
	VMUnlock(mem);

	/* creating thumbnail */
	sx=GrSDivWWFixed(MakeWWFixed(88), MakeWWFixed(x));
	sy=GrSDivWWFixed(MakeWWFixed(80), MakeWWFixed(y));

	if(sx > sy)
	  sx = sy;

	size_x = IntegerOf(GrMulWWFixed(MakeWWFixed(x),sx));
	if(size_x == 0) size_x = 1;
	size_y = IntegerOf(GrMulWWFixed(MakeWWFixed(y),sx));
	if(size_y == 0) size_y = 1;

	thumbnail = GrCreateBitmap(type, size_x, size_y
							   , BVThumbnailDB,
								   0, &gstate);
/*    GrDestroyBitmap(gstate, BMD_LEAVE_DATA);


	if(((type&(BMT_FORMAT|BMT_PALETTE))==(BMF_4BIT|BMT_PALETTE))||
	   ((type&(BMT_FORMAT|BMT_PALETTE))==(BMF_8BIT|BMT_PALETTE)))
	{
	  ptr = VMLock(file, block, &mem);
	  ptr2 = VMLock(BVThumbnailDB, thumbnail, &mem2);
	  offset = ptr[0x28]+256*(ptr[0x29]);
	  offset += 0x1c;
	  offset2 = ptr2[0x28]+256*(ptr2[0x29]);
	  offset2 += 0x1c;

	  if((type&BMT_FORMAT) == BMF_4BIT)
		memcpy(&(ptr2[offset2]),&(ptr[offset]), 16*3);
	  else
		memcpy(&(ptr2[offset2]),&(ptr[offset]), 256*3);

	  VMDirty(mem2);
	  VMUnlock(mem2);
	  VMUnlock(mem);
	};

	gstate = GrEditBitmap(BVThumbnailDB, thumbnail, 0);
	type &= BMT_PALETTE;
*/
	if(sx == 0)
	  FatalError(300);
	GrApplyScale(gstate, sx, sx);
	GrDrawHugeBitmap(gstate, 0, 0, file, block);
	GrDestroyBitmap(gstate, BMD_LEAVE_DATA);

	compact =  GrCompactBitmap(BVThumbnailDB, thumbnail,BVThumbnailDB);

	MyVMFreeVMChain(BVThumbnailDB,
	  VMCHAIN_MAKE_FROM_VM_BLOCK( thumbnail));


	item = DBAllocUngrouped(BVThumbnailDB, sizeof(BVThumbDBItem));
	itemptr = DBLockUngrouped(BVThumbnailDB, item);
	strcpy(itemptr->BVTDBI_name, name);
	itemptr->BVTDBI_date = date;
	itemptr->BVTDBI_size = size;
	itemptr->BVTDBI_next = 0;
	itemptr->BVTDBI_thumbnail = compact;
	DBDirty(itemptr);
	DBUnlock(itemptr);

	thumbnail = VMGetMapBlock(BVThumbnailDB);
	mapptr = VMLock(BVThumbnailDB, thumbnail, &mem);
	item2 = mapptr->BVTDBM_lastItem;
	mapptr->BVTDBM_lastItem = item;
	if(item2 == 0)
	  mapptr->BVTDBM_firstItem = item;
	VMDirty(mem);
	VMUnlock(mem);

	if(item2 != 0)
	{
	  itemptr = DBLockUngrouped(BVThumbnailDB, item2);
	  itemptr->BVTDBI_next = item;
	  DBDirty(itemptr);
	  DBUnlock(itemptr);
	};
  };
};
@endif

/**************************************************************************/

void
BVCalcDriveName(char *text, word item)
{
  DiskHandle disk;
  word count, drvstat;
  VolumeName name;

  count = 0;
  item++;
  while(item != 0)
  {
	while(((drvstat = DriveGetStatus(count))&DS_PRESENT) == 0) count++;
	count++;
	item--;
  };

  text[0] = count + 64;
  text[1] = ':';
  text[2] = 0;
  if((drvstat & (DS_TYPE|DS_MEDIA_REMOVABLE)) == DRIVE_FIXED)
  {
	disk = DiskRegisterDiskSilently(count-1);
	if(disk != 0)
	{
	  strcat(text, "[");
	  DiskGetVolumeName(disk, name);
	  strcat(text, name);
	  strcat(text,"]");
	};
  };
};

/**************************************************************************/

@method BVProcessClass, MSG_BV_SET_DRIVE_MONIKER
{
  char text[VOLUME_BUFFER_SIZE + 2];

  BVCalcDriveName(text, item);
  @call list::MSG_GEN_DYNAMIC_LIST_REPLACE_ITEM_TEXT(
										   item, text);
};

/**************************************************************************/

@ifndef OLD_THUMBNAIL_DB

@method BVProcessClass, MSG_BV_SET_FILELIST_MONIKER
{
	BVFileAttr *filelist;

	if(BVFileList)
	{
		filelist = MemLock(BVFileList);

		if(filelist)
			@call list::MSG_THUMBNAIL_ITEM_SET_DATA(
							 filelist[item].BVFA_name,
							 filelist[item].BVFA_size,
							 filelist[item].BVFA_date,
							 filelist[item].BVFA_type & FA_SUBDIR);

		MemUnlock(BVFileList);
	}
}

@else

/**************************************************************************/

@method BVProcessClass, MSG_BV_SET_FILELIST_MONIKER
{
  Boolean stat;
  GStateHandle gstate;
  MemHandle mem, mem2;
  ChunkHandle chunk;
  byte *ptr/*, *ptr2*/;
/*  word offset2; */
  BVFileAttr *filelist;
  word width;
  GStateHandle gstring;
/*  GStringElement gstrelem;*/
  VMBlockHandle thumbnail;
  word x, y;
/*  byte type; */
  byte count;

  mem = MemAllocLMem(LMEM_TYPE_GENERAL,0);

  if(mem == 0)
	return;

  gstate = GrCreateGString(mem, GST_CHUNK, &chunk);
  if(BVFileList == 0)
	GrDrawRect(gstate, 0, 0, 80, 80);
  else
  {
	filelist = MemLock(BVFileList);
	GrSetGStringBounds(gstate, 0, 0, 96,96);
	GrSetFont(gstate, FID_BERKELEY, MakeWWFixed(9));
	width = GrTextWidth(gstate, filelist[item].BVFA_name, 0);
	if(width > 90)
	{
	  width = GrTextWidth(gstate, "...", 0);
	  count = 0;
	  while ((width < 96) && (filelist[item].BVFA_name[count] != 0))
	  {
		width += (GrCharWidth(gstate, filelist[item].BVFA_name[count])>>16);
		count++;
	  };
	  count--;
	  width -= (GrCharWidth(gstate, filelist[item].BVFA_name[count])>>16);
	  GrDrawText(gstate, 48-(width/2),85, filelist[item].BVFA_name, count);
	  GrDrawTextAtCP(gstate, "...",0);

	}
	else
	  GrDrawText(gstate, 48-(width/2),85, filelist[item].BVFA_name, 0);

	if(filelist[item].BVFA_type & FA_SUBDIR)
	{
	  gstring = GrLoadGString(OptrToHandle(@BVDirMoniker), GST_CHUNK,
				  OptrToChunk(@BVDirMoniker));
	  GrDrawGString(gstate, gstring, 18,14,0,0);
	  GrDestroyGString(gstring, 0, GSKT_LEAVE_DATA);
	}
	else
	{
	  stat = @call BVOptionGroup::MSG_GEN_BOOLEAN_GROUP_IS_BOOLEAN_SELECTED(BV_USE_THUMBNAILS);

	  if(stat != FALSE)
	  {
@ifdef OLD_THUMBNAIL_DB
		thumbnail = ThumbFindItem(filelist[item].BVFA_name,
								filelist[item].BVFA_size,
								filelist[item].BVFA_date);

		if(thumbnail != 0)
		{
			ptr = VMLock(BVThumbnailDB, thumbnail, &mem2);

			x = ptr[0x1a]+256*(ptr[0x1b]);
			y = ptr[0x1c]+256*(ptr[0x1d]);
			VMUnlock(mem2);
			GrDrawHugeBitmap(gstate, 48-(x/2) , 43-(y/2), BVThumbnailDB, thumbnail);
		}
		else
		{
			gstring = GrLoadGString(OptrToHandle(@BVUnknownMoniker), GST_CHUNK,
					  OptrToChunk(@BVUnknownMoniker));
			GrDrawGString(gstate, gstring, 18,14,0,0);
			GrDestroyGString(gstring, 0, GSKT_LEAVE_DATA);
		}
@else
		if(ThumbDrawItem(gstate, 48, 43, THJ_CENTER, TVJ_CENTER,
						 filelist[item].BVFA_name,
						 filelist[item].BVFA_size,
						 filelist[item].BVFA_date) != TE_NO_ERROR)
		{
			gstring = GrLoadGString(OptrToHandle(@BVUnknownMoniker), GST_CHUNK,
				  OptrToChunk(@BVUnknownMoniker));
			GrDrawGString(gstate, gstring, 18,14,0,0);
			GrDestroyGString(gstring, 0, GSKT_LEAVE_DATA);
		}
@endif
	  }
	  else
	  {
		gstring = GrLoadGString(OptrToHandle(@BVUnknownMoniker), GST_CHUNK,
				  OptrToChunk(@BVUnknownMoniker));
		GrDrawGString(gstate, gstring, 18,14,0,0);
		GrDestroyGString(gstring, 0, GSKT_LEAVE_DATA);
	  };
	};
	MemUnlock(BVFileList);
  };

  GrEndGString(gstate);
  @call list::MSG_GEN_REPLACE_VIS_MONIKER(
	  VUM_NOW,96,96,
	  0, VMDT_GSTRING, VMST_OPTR, ConstructOptr(mem, chunk));
  GrDestroyGString(gstate, 0, GSKT_KILL_DATA);

  MemFree(mem);
}

@endif

/**************************************************************************/

@method BVProcessClass, MSG_BV_FILELIST_SELECTION
{
  BVFileAttr *filelist;
  word count;

  count = @call BVDynFileList::MSG_GEN_ITEM_GROUP_GET_NUM_SELECTIONS();

  if((BVFileList != 0) && (count != 0))
  {
	filelist = MemLock(BVFileList);
	if(((filelist[selection].BVFA_type & FA_SUBDIR) == 0) || (count > 1))
	{
	  @send process::MSG_BV_FILE_SELECTED();
	}
	else
	{
	  @send process::MSG_BV_NO_FILE_SELECTED();
	};
	MemUnlock(BVFileList);
  }
  else
	@send process::MSG_BV_NO_FILE_SELECTED();
}

/**************************************************************************/

@method BVProcessClass, MSG_BV_FILELIST_OPEN
{
  BVFileAttr *filelist;
  char *pathptr;
  DiskHandle disk;
  word len;
  word count;

  count = @call BVDynFileList::MSG_GEN_ITEM_GROUP_GET_NUM_SELECTIONS();

  if((BVFileList != 0)&&(count != 0))
  {
	filelist = MemLock(BVFileList);
	if(((filelist[selection].BVFA_type & FA_SUBDIR) == 0) || (count > 1))
	{
	  @send process::MSG_BV_FILE_SELECTED();
	  MemUnlock(BVFileList);
	  @send BVImpTrigger::MSG_GEN_TRIGGER_SEND_ACTION(FALSE);
	}
	else
	{
	  /* open subdir */
	  @send process::MSG_BV_NO_FILE_SELECTED();
	  len = strlen(BVCurrentPath);
	  if((BVCurrentPath[len-1] != '\\') || (len == 0))
	  strcat(BVCurrentPath, "\\");
	  strcat(BVCurrentPath, filelist[selection].BVFA_name);

	  pathptr = &(BVCurrentPath[0]);
	  disk = FileParseStandardPath(BVCurrentDisk, (const char**) &pathptr);
	  if(disk != 0)
		BVCurrentDisk = disk;
	  strcpy(BVCurrentPath, pathptr);

	  MemUnlock(BVFileList);
	  @send process::MSG_BV_READ_FILES();
	};
  }
}

/**************************************************************************/

@method BVProcessClass, MSG_BV_CLOSE_DIRECTORY
{
  word pos;
  byte endFlag;
  char path[256];
  char *pathptr;
  DiskHandle disk;

  pathptr = &(path[0]);
  disk = FileConstructFullPath(&pathptr, 256, BVCurrentDisk, BVCurrentPath, FALSE);

  pos = strlen(path);
  endFlag = 255;

  while((pos != 0) && (endFlag == 255))
  {
	pos--;
	if((path[pos] == '\\')||(pos == 0))
	{
	  endFlag = 0;
	  path[pos] = 0;
	};
  }
  pathptr = &(path[0]);
  BVCurrentDisk = FileParseStandardPath(disk, (const char**) &pathptr);

  if(BVCurrentDisk == SP_NOT_STANDARD_PATH)
	BVCurrentDisk = disk;
  strcpy(BVCurrentPath, pathptr);
  if(BVCurrentPath[0] == 0)
	strcpy(BVCurrentPath, "\\");

  @send process::MSG_BV_READ_FILES();
}

/**************************************************************************/

@method BVProcessClass, MSG_BV_SET_PATH_MONIKER
{
  DiskHandle disk;
  FileLongName name;
  word count1, count2;
  char path[256];
  char *pathptr;
  word start, end;

  pathptr = &(path[0]);

  disk = FileConstructFullPath(&pathptr, 256, BVCurrentDisk, BVCurrentPath, FALSE);

  if(item == 0)
  {
	count1 = DiskGetDrive(disk);
	DiskGetVolumeName(disk, path);
	name[0] = 65 + count1;
	name[1] = ':';
	name[2] = '[';
	name[3] = 0;
	strcat(name, path);
	strcat(name, "]\\");
  }
  else
  {

	end = 0;
	count1 = item + 1;
	count2 = 0;
	do
	{
	  start = end;
	  while((path[count2] != '\\') &&
		  (path[count2] != 0 )) count2++;
	  count1--;
	  count2++;
	  end = count2;
	}
	while(count1 != 0);

	strncpy(name, &(path[start]), count2 - start - 1);
	name[count2 - start -1] = 0;

  };
  @call list::MSG_GEN_DYNAMIC_LIST_REPLACE_ITEM_TEXT(
										   item, name);

}

/**************************************************************************/

@method BVProcessClass, MSG_BV_SELECT_DRIVE
{
  word itemcount, count;
  DiskHandle disk;
  char text[VOLUME_BUFFER_SIZE + 2];
  VolumeName name;

  count = 0;
  itemcount = selection + 1;
  while(itemcount != 0)
  {
	while((DriveGetStatus(count)&DS_PRESENT)== 0) count++;
	count++;
	itemcount--;
  };

  text[0] = count + 64;
  text[1] = ':';
  text[2] = 0;

  disk = DiskRegisterDiskSilently(count-1);
  if(disk != 0)
  {
	strcat(text, "[");
	DiskGetVolumeName(disk, name);
	strcat(text, name);
	strcat(text,"]");
  };
  @call BVImpFileDirDrive::MSG_GEN_DYNAMIC_LIST_REPLACE_ITEM_TEXT(
										   selection, text);
  @call BVImpFileDirDrive::MSG_GEN_REPLACE_VIS_MONIKER_TEXT(
										   text, 0);
  BVCurrentDisk = disk;
  strcpy(BVCurrentPath, "\\");

  @send process::MSG_BV_READ_FILES();
};

/**************************************************************************/

@method BVProcessClass, MSG_BV_SELECT_PATH
{
  DiskHandle disk;
  char path[256];
  char *pathptr;
  word count, count2;

  pathptr = &(path[0]);
  disk = FileConstructFullPath(&pathptr, 256, BVCurrentDisk, BVCurrentPath, FALSE);
  if(selection == 0)
	strcpy(path, "\\");
  else
  {
	count = selection;
	count2 = 0;
	while(path[count2] == '\\') count2++;
	while(count != 0)
	{
	  if(path[count2] == '\\')
		count--;
	  if(path[count2] == 0)
		count = 0;
	  count2++;
	}
	path[count2 -1] = 0;
  };

  pathptr = &(path[0]);
  BVCurrentDisk = FileParseStandardPath(disk, (const char**) &pathptr);

  if(BVCurrentDisk == SP_NOT_STANDARD_PATH)
	BVCurrentDisk = disk;
  strcpy(BVCurrentPath, pathptr);
  if(BVCurrentPath[0] == 0)
	strcpy(BVCurrentPath, "\\");

  @send process::MSG_BV_READ_FILES();
};

/**************************************************************************/

@method BVProcessClass, MSG_BV_GO_TO_DOCUMENT
{
  BVCurrentDisk = SP_DOCUMENT;
  BVCurrentPath[0] = 0;

  @send process::MSG_BV_READ_FILES();
};

/**************************************************************************/

@method BVProcessClass, MSG_BV_CREATE_THUMBNAIL
{
  BVFileAttr *filelist;
  word count;
  optr childoptr;

  if(ThumbFindItem(name, size, date) != 0)
	return;

@ifdef OLD_THUMBNAIL_DB
  ThumbCreateItem(name, size, date, file, block);
@else
  ThumbCreateItem(name, size, date, file, block, TST_HUGE_BITMAP);
@endif
  if(BVFileList != 0)
  {
	filelist = MemLock(BVFileList);
	count = 0;
	while(count != BVFileNumber)
	{
	  if((size == filelist[count].BVFA_size) &&
		 (date == filelist[count].BVFA_date) &&
		 (strcmp(name, filelist[count].BVFA_name) == 0))
	  {
		childoptr = @call BVDynFileList::MSG_GEN_FIND_CHILD_AT_POSITION(count);
		@call process::MSG_BV_SET_FILELIST_MONIKER(count, childoptr);
	  };
	  count++;
	};
	MemUnlock(BVFileList);
  };
};

/**************************************************************************/

@method BVDynListClass, MSG_BV_DELETE_FILELIST
{
  word childcount;
  optr child;
  word count,*pCount;

  /* removing all old entrys from item list */
  childcount = @call oself::MSG_GEN_COUNT_CHILDREN();

  while(childcount != 0)
  {
	childcount--;
	child = @call oself::MSG_GEN_FIND_CHILD_AT_POSITION(childcount);
	@send child::MSG_GEN_SET_NOT_USABLE(VUM_DELAYED_VIA_UI_QUEUE);
	@call child::MSG_GEN_REMOVE(VUM_DELAYED_VIA_UI_QUEUE, CCF_MARK_DIRTY);

	ObjLockObjBlock( OptrToHandle( child ) );
	pCount = (word *)LMemDerefHandles(
				OptrToHandle( child ),
				OptrToChunk( @objBlockObjectCount ) );
	count = --(*pCount);
	MemUnlock( OptrToHandle( child ) );

	if( count==0 )
		ObjFreeObjBlock(HandleOf(child));
  };
};

/**************************************************************************/

@method BVDynListClass, MSG_BV_ADD_FILELIST_ITEM
{
		optr child;
		word blocksize;

		/* create new object and a new object block if
		   needed */
		if((*objblock) != 0)
			blocksize = MemGetInfo((*objblock), MGIT_SIZE);

		if(((*objblock) == 0) || (blocksize > (8192-200)))
		{
				*objblock =
				  ObjDuplicateResource(
					OptrToHandle(@objBlockObjectCount), 0, -1);
		};
@ifdef OLD_THUMBNAIL_DB
		child = ObjInstantiate((*objblock), &GenItemClass);
@else
		child = ObjInstantiate((*objblock), &ThumbnailItemClass);
@endif

		ObjLockObjBlock(*objblock);
		(*(word *)LMemDerefHandles( (*objblock),
		  OptrToChunk(@objBlockObjectCount) ))++;
		MemUnlock(*objblock);

		return(child);
};

/**************************************************************************/

@method BVDocumentClass, MSG_BVDOC_PAL_STATE_CHANGED
{
  GStateHandle gstate;

  if((pself->BVAttrs&BVA_BITMAP_OPEN)!=0)
  {
   gstate = GrCreateState(pself->BVWindow);
   GrInvalRect(gstate, 0, 0, pself->BVBmpWidth, pself->BVBmpHeight);
	 GrDestroyState(gstate);
   if(pself->BVWindow != 0)
	@call oself::MSG_META_EXPOSED(pself->BVWindow);
  };

}

/**************************************************************************/

@method BVProcessClass, MSG_BV_SELECT_ALL_FILES
{
  word count;
  MemHandle mem;
  word *selptr;
  BVFileAttr *filelist;
  word selection;

  if(BVFileList != 0)
  {
	mem = MemAlloc(BVFileNumber*2, 0, 0);
	selptr = MemLock(mem);
	selection = selptr[0];

	count = 0;
	while(count != BVFileNumber)
	{
	  selptr[count] = count;
	  count++;
	};

	@call BVDynFileList::MSG_GEN_ITEM_GROUP_SET_MULTIPLE_SELECTIONS(selptr, BVFileNumber);
	MemUnlock(mem);
	MemFree(mem);
	@send process::MSG_BV_NO_FILE_SELECTED();

	if(BVFileNumber > 1)
	  @send process::MSG_BV_FILE_SELECTED();
	else
	  if(BVFileNumber == 1)
	  {
		filelist = MemLock(BVFileList);
		if((filelist[selection].BVFA_type & FA_SUBDIR) == 0)
		  @send process::MSG_BV_FILE_SELECTED();
		MemUnlock(BVFileList);
	  };
  };
}

/**************************************************************************/

@method BVProcessClass, MSG_BV_DESELECT_ALL_FILES
{
  @call BVDynFileList::MSG_GEN_ITEM_GROUP_SET_NONE_SELECTED(FALSE);
  @send process::MSG_BV_NO_FILE_SELECTED();
}

/**************************************************************************/

@method BVProcessClass, MSG_BV_SAVE_PATH
{
  char pfad[256];
  char *pfadptr = &pfad;

  FileConstructFullPath(&pfadptr, 255, BVCurrentDisk, BVCurrentPath, TRUE);

@ifdef NEWDEAL_MEDIA_VIEWER
  InitFileWriteString("MediaViewer","dlgPath",&pfad);
@else
  InitFileWriteString("GraphicsViewer","dlgPath",&pfad);
@endif
  InitFileCommit();
}

/**************************************************************************/

@method BVProcessClass, MSG_BV_RESET_PATH
{
@ifdef NEWDEAL_MEDIA_VIEWER
  InitFileDeleteEntry("MediaViewer", "dlgPath");
@else
  InitFileDeleteEntry("GraphicsViewer", "dlgPath");
@endif
}

/**************************************************************************/

@method BVBrowserInterClass, MSG_META_GAINED_SYS_FOCUS_EXCL
{
/*	Boolean stat; */
/*	optr target, doc;*/
	EventHandle event;

	BVBrowserFocus = TRUE;

	event = @record BVDocumentClass::MSG_BV_RESET_PALETTE();

	@send BVDisplayGroup::MSG_META_SEND_CLASSED_EVENT(event, TO_TARGET);

	@callsuper();
}

/**************************************************************************/

@method BVBrowserInterClass, MSG_META_LOST_SYS_FOCUS_EXCL
{
/*	Boolean stat;*/
/*	optr target, doc;*/
	EventHandle event;

	BVBrowserFocus = FALSE;

	event = @record BVDocumentClass::MSG_BV_SET_PALETTE();

	@send BVDisplayGroup::MSG_META_SEND_CLASSED_EVENT(event, TO_TARGET);

	@callsuper();
}

/**************************************************************************/

@method BVProcessClass, MSG_BV_READ_THUMBNAILS
{
  BVFileAttr *filelist;
  word filecount, filenum, /*fileident, */filenum2;
  MemHandle fileidlist;
  word *idlistptr;
/*  Boolean stat; */
  FileLongName srcname;
  FileLongName tempname;
  FileDateAndTime date;
  dword size;
  word count;
  ImpBmpStatus status;
  ImpBmpParams para;
  char string[255];
  RGBValue blendColor = {0};

  if(BVFileList != 0)
  {

	filenum = @call BVDynFileList::MSG_GEN_ITEM_GROUP_GET_NUM_SELECTIONS();

	fileidlist = MemAlloc(filenum*2, 0, 0);

	idlistptr = MemLock(fileidlist);

	filenum = @call BVDynFileList::MSG_GEN_ITEM_GROUP_GET_MULTIPLE_SELECTIONS(
	  idlistptr, filenum*2);

	MemUnlock(fileidlist);

	filecount = 0;
	do
	{
	  idlistptr = MemLock(fileidlist);
	  filenum2 = idlistptr[filecount];
	  MemUnlock(fileidlist);

	  filelist = MemLock(BVFileList);
	  if((filelist[filenum2].BVFA_type&FA_SUBDIR) == 0)
	  {
		strcpy(srcname, filelist[filenum2].BVFA_name);
		MemUnlock(BVFileList);

		MemLock(OptrToHandle(@BVThumbnailText));
		strcpy(string, LMemDeref(@BVThumbnailText));
		MemUnlock(OptrToHandle(@BVThumbnailText));

		strcat(string, srcname);
		strcat(string, "...");

		@send BVThumbTex::MSG_GEN_REPLACE_VIS_MONIKER_TEXT(string ,VUM_NOW);

		count = 0;
		while(count != sizeof(tempname))
		{
			tempname[count] = 0;
			count++;
		};

		/* import bitmap */
		FilePushDir();

		FileSetCurrentPath(BVCurrentDisk, BVCurrentPath);
		para.IBP_source = FileOpen(srcname, FILE_DENY_W|FILE_ACCESS_R);

		date = FileGetDateAndTime(para.IBP_source) ;
		FileGetHandleExtAttributes(para.IBP_source,FEA_SIZE,&size, sizeof(size));

		if(ThumbFindItem(srcname, size, date) != 0)
		{
			FileClose(para.IBP_source, FILE_NO_ERRORS);
			FilePopDir();

			@send BVDynFileList::MSG_GEN_ITEM_GROUP_SET_ITEM_STATE(filenum2, 0);
		}
		else
		{
			@send BVThumbDlg::MSG_GEN_INTERACTION_INITIATE();

			FileSetCurrentPath(SP_WASTE_BASKET, ".");
			para.IBP_dest = VMOpen(tempname, VMAF_FORCE_READ_WRITE, VMO_TEMP_FILE, 0);

			getPngBlendColor(&blendColor);
			para.IBP_pngBlendColor = blendColor;

			FilePopDir();

			para.IBP_status = @BVThumbnailStatus;
			status = Imp_BmpProcessFile(&para, IBF_AUTO);

			@send BVThumbDlg::MSG_GEN_GUP_INTERACTION_COMMAND(IC_DISMISS);

			/* create thumbnail */
			if(status == IBS_NO_ERROR)
			{
				@call process::MSG_BV_CREATE_THUMBNAIL(srcname, size, date,
					para.IBP_dest, para.IBP_bitmap);

				@send BVDynFileList::MSG_GEN_ITEM_GROUP_SET_ITEM_STATE(filenum2, 0);
			}

			if(status == IBS_IMPORT_STOPPED)
				filecount = filenum - 1;

			FileClose(para.IBP_source, FILE_NO_ERRORS);
			VMClose(para.IBP_dest, FILE_NO_ERRORS);

			/* delete temp file */
			FilePushDir();
			FileSetCurrentPath(SP_WASTE_BASKET, ".");
			FileDelete(tempname);
			FilePopDir();
		}
	  }
	  else
	  {
		MemUnlock(BVFileList);
	  };
	  filecount++;
	}
	while(filecount != filenum);

	MemFree(fileidlist);

	@send oself::MSG_BV_UPDATE_OPEN_TRIGGER();
  };
}

/**************************************************************************/

@method BVProcessClass, MSG_BV_DELETE_THUMBNAILS
{
  optr childoptr;
  FileHandle filehdl;
  BVFileAttr *filelist;
  word filecount, filenum, /*fileident, */filenum2;
  MemHandle fileidlist;
  word *idlistptr;
/*  Boolean stat; */
  FileLongName srcname;
  FileDateAndTime date;
  dword size;
/*  word count; */

  if(BVFileList != 0)
  {

	filenum = @call BVDynFileList::MSG_GEN_ITEM_GROUP_GET_NUM_SELECTIONS();

	fileidlist = MemAlloc(filenum*2, 0, 0);

	idlistptr = MemLock(fileidlist);

	filenum = @call BVDynFileList::MSG_GEN_ITEM_GROUP_GET_MULTIPLE_SELECTIONS(
	  idlistptr, filenum*2);

	MemUnlock(fileidlist);

	filecount = 0;
	do
	{
	  idlistptr = MemLock(fileidlist);
	  filenum2 = idlistptr[filecount];
	  MemUnlock(fileidlist);

	  filelist = MemLock(BVFileList);
	  if((filelist[filenum2].BVFA_type&FA_SUBDIR) == 0)
	  {
		strcpy(srcname, filelist[filenum2].BVFA_name);
		MemUnlock(BVFileList);

		/* import bitmap */
		FilePushDir();

		FileSetCurrentPath(BVCurrentDisk, BVCurrentPath);
		filehdl = FileOpen(srcname, FILE_DENY_W|FILE_ACCESS_R);

		date = FileGetDateAndTime(filehdl) ;
		FileGetHandleExtAttributes(filehdl,FEA_SIZE,&size, sizeof(size));

		FileClose(filehdl, FILE_NO_ERRORS);
		FilePopDir();

@ifdef OLD_THUMBNAIL_DB
		ThumbDeleteItem(srcname, size, date);
@else
		ThumbRemoveItem(srcname, size, date);
@endif

		@send BVDynFileList::MSG_GEN_ITEM_GROUP_SET_ITEM_STATE(filenum2, 0);

		childoptr = @call BVDynFileList::MSG_GEN_FIND_CHILD_AT_POSITION(filenum2);
		@call process::MSG_BV_SET_FILELIST_MONIKER(filenum2, childoptr);
	  }
	  else
	  {
		MemUnlock(BVFileList);
	  };
	  filecount++;
	}
	while(filecount != filenum);

	MemFree(fileidlist);

	@send oself::MSG_BV_UPDATE_OPEN_TRIGGER();
  };
}

/**************************************************************************/

@method BVProcessClass, MSG_BV_UPDATE_OPEN_TRIGGER
{
	word count, selection;
	BVFileAttr *filelist;

	count = @call BVDynFileList::MSG_GEN_ITEM_GROUP_GET_NUM_SELECTIONS();
	selection = @call BVDynFileList::MSG_GEN_ITEM_GROUP_GET_SELECTION();

	if((BVFileList != 0) && (count != 0))
	{
	  filelist = MemLock(BVFileList);
	  if(((filelist[selection].BVFA_type & FA_SUBDIR) == 0) || (count > 1))
	  {
		@send process::MSG_BV_FILE_SELECTED();
	  }
	  else
	  {
		@send process::MSG_BV_NO_FILE_SELECTED();
	  };

	  MemUnlock(BVFileList);
	}
	else
	  @send process::MSG_BV_NO_FILE_SELECTED();
}

/**************************************************************************/

@method BVProcessClass, MSG_BV_VIEW_CHANGED
{
	@send process::MSG_BV_READ_FILES();
}

/**************************************************************************/

@method BVProcessClass, MSG_BV_NO_FILE_SELECTED
{
	@send BVImpTrigger::MSG_GEN_SET_NOT_ENABLED(VUM_NOW);
	@send BVImpEditThumb::MSG_GEN_SET_NOT_ENABLED(VUM_NOW);
}

/**************************************************************************/

@method BVProcessClass, MSG_BV_FILE_SELECTED
{
	@send BVImpTrigger::MSG_GEN_SET_ENABLED(VUM_NOW);
	@send BVImpEditThumb::MSG_GEN_SET_ENABLED(VUM_NOW);
}

/**************************************************************************/
