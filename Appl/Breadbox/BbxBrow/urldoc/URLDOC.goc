/*
 *                          ==CONFIDENTIAL INFORMATION==
 *
 * COPYRIGHT 1994-99 BREADBOX COMPUTER COMPANY -- ALL RIGHTS RESERVED  --
 * THE FOLLOWING CONFIDENTIAL INFORMATION IS BEING DISCLOSED TO YOU UNDER
 * A NON-DISCLOSURE AGREEMENT AND MAY NOT BE DISCLOSED OR FORWARDED BY THE
 * RECIPIENT TO ANY OTHER PERSON OR ENTITY NOT COVERED BY THE SAME
 * NON-DISCLOSURE AGREEMENT COVERING THE RECIPIENT. USE OF THE FOLLOWING
 * CONFIDENTIAL INFORMATION IS RESTRICTED TO THE TERMS OF THE NON-DISCLOSURE
 * AGREEMENT.
 *
*/
/***********************************************************************
 *
 * PROJECT:       HTMLView
 * FILE:          URLDoc.goc
 *
 * AUTHOR:        Marcus Gr√∂ber
 *
 ***********************************************************************/

/**************************************************************************
 *      Include files
 **************************************************************************/

@include <stdapp.goh>
#include <geoMisc.h>                    /* various unix-like goodies */
#include <initfile.h>

#include <Ansi/string.h>
#include <Ansi/stdio.h>
#include <Ansi/stdlib.h>

@include <fixes.goh>
@include "htmlview.goh"


@extern object HTMLVApp;
@extern object HTMLVPrimary;
@extern object CurrentURLText;
@extern object HTMLDisplayGroup;
@extern object DocumentControl;
@ifdef COMPILE_OPTION_PAGE_SIZE_CONTROL
@extern object PageSizeControl;
@endif
@extern object SettingsBoolGroup;

@ifdef COMPILE_OPTION_BOOKMARKS
@include "bookmark.goh"
@extern object BookmarkTriggerList ;
@extern object BookmarksDynamicList ;
@endif

@ifdef COMPILE_OPTION_FAVORITES
@include "favorite.goh"
@extern object FavoriteTriggerList ;
@extern object FavoritesDynamicList ;
@endif

@extern visMoniker Untitled;            /* "untitled" text */

@ifdef COMPILE_OPTION_PARENTAL_CONTROL
@include <parentc.goh>
@extern object PCSiteAlreadyAddedDlg;
@extern object PCSiteNotInListDlg;
extern Boolean G_pcBypassed;
@endif

@ifdef GLOBAL_INTERNET_BUILD
@extern object HelpWindow;
@extern object HelpFrame;
@endif

@ifdef JAVASCRIPT_SUPPORT
@extern object WindowOpenWindow;
@extern object WindowOpenFrame;
@endif


@start    DocGroupResource;
  @object URLDocumentGroupClass HTMLDocumentGroup = {
     GDGI_attrs = GDGA_NATIVE
                | GDGA_APPLICATION_THREAD;
     GDGI_documentControl = @DocumentControl;
     GDGI_genDocument = @HTMLDocument;
     GDGI_genDisplay = @HTMLDisplay;
     GDGI_genDisplayGroup = @HTMLDisplayGroup;
@ifdef GLOBAL_INTERNET_BUILD
@ifdef DO_DBCS
     GDGI_untitledName = "browser page";
@else
     GDGI_untitledName = "WebMagick 3.0";
@endif
@else
     GDGI_untitledName = "untitled";
@endif
     ATTR_GEN_DOCUMENT_GROUP_DOCUMENT_HANDLES = {
         0
     };
  }
@end      DocGroupResource;


@start  UIResource, notDetachable;

  @object GenDisplayClass HTMLDisplay = {
    GI_states = @default & ~GS_USABLE;
@ifdef GLOBAL_INTERNET_BUILD
    GI_visMoniker = "WebMagick 3.0";
@else
    GI_visMoniker = "untitled";
@endif
    GI_comp = @UITop;
    ATTR_GEN_DISPLAY_NOT_MINIMIZABLE;
    HINT_DEFAULT_TARGET;
    HINT_DEFAULT_FOCUS;
  }

  @object GenInteractionClass UITop = {
    GI_attrs = @default | GA_TARGETABLE;
    HINT_EXPAND_WIDTH_TO_FIT_PARENT;
    HINT_EXPAND_HEIGHT_TO_FIT_PARENT;
    HINT_ORIENT_CHILDREN_VERTICALLY;
    HINT_MINIMIZE_CHILD_SPACING;
  }

@end    UIResource;

@start ViewGroupTemplateResource, notDetachable;

@object GenInteractionClass ViewGroupTemplate = {
    GI_attrs = @default | GA_TARGETABLE;
    GI_states = @default & ~GS_USABLE;
    HINT_EXPAND_WIDTH_TO_FIT_PARENT;
    HINT_EXPAND_HEIGHT_TO_FIT_PARENT;
    HINT_ORIENT_CHILDREN_HORIZONTALLY;
    HINT_MINIMIZE_CHILD_SPACING;
}

@end ViewGroupTemplateResource;

@start ViewTemplateResource, notDetachable;

@object GenViewClass ViewTemplate = {
    GI_attrs = @default | GA_TARGETABLE;
    GI_states = @default & ~GS_USABLE;
    GVI_vertAttrs = @default | GVDA_SCROLLABLE;  /* default is AUTO */
    GVI_horizAttrs = @default | GVDA_SCROLLABLE;  /* default is AUTO */
    GVI_attrs = @default | GVA_CONTROLLED | GVA_DRAG_SCROLLING \
                         | GVA_WINDOW_COORDINATE_MOUSE_EVENTS \
                         | GVA_DONT_SEND_KBD_RELEASES | GVA_FOCUSABLE;
    ATTR_GEN_VIEW_DOES_NOT_ACCEPT_TEXT_INPUT;
    HINT_EXPAND_WIDTH_TO_FIT_PARENT;
    HINT_EXPAND_HEIGHT_TO_FIT_PARENT;
    HINT_MINIMIZE_CHILD_SPACING;
    HINT_VIEW_REMOVE_SCROLLERS_WHEN_NOT_SCROLLABLE;  /* default is AUTO */
@ifdef GLOBAL_INTERNET_BUILD
    ATTR_GEN_VIEW_NOTIFY_EVEN_IF_NOT_TARGETED;
@endif
}

@end ViewTemplateResource;


@start  FrameResource, notDetachable;

  @object URLDocumentClass HTMLDocument = {
    GI_states = @default & ~GS_USABLE;
    UDCI_topFrame = @FrameTop;
  }

  @object URLFrameClass FrameTop = {
    UFI_document = @HTMLDocument;
  }

@end    FrameResource;

@start FrameTemplateResource, notDetachable;

@object URLFrameClass FrameTemplate = {
    UFI_document = @HTMLDocument;
}

@end FrameTemplateResource;


@start  TextResource, notDetachable;

  @object VisContentClass URLContent = {
    VCNI_attrs = @default | VCNA_LARGE_DOCUMENT_MODEL
                          | VCNA_WINDOW_COORDINATE_MOUSE_EVENTS
                          | VCNA_SAME_WIDTH_AS_VIEW;
    VCI_comp = @URLText;
  }

  @object URLTextClass URLText = {
      ATTR_VIS_TEXT_WRAP_AFTER_OVERFLOW_WITH_MAXIMUM = 780 ;
      ATTR_VIS_TEXT_DONT_DRAW_BREAKS;
      ATTR_VIS_TEXT_ALLOW_CROSS_SECTION_COPY ;
  }

@end    TextResource;


/***************************************************************************
 *              URL browser display
 ***************************************************************************/

@classdecl URLDocumentClass;

@ifdef COMPILE_OPTION_LOCAL_PAGES

/* Declared in LOCALPAG.GOC */
@extern method URLDocumentClass, MSG_URL_DOCUMENT_SAVE_LOCAL;
@extern method URLDocumentClass, MSG_URL_DOCUMENT_OPEN_LOCAL;
@extern method URLDocumentClass, MSG_URL_DOCUMENT_STORE_TO_FILENAME;
@extern method URLDocumentClass, MSG_URL_DOCUMENT_STORE_TO_VM;
@extern method URLDocumentClass, MSG_URL_DOCUMENT_RESTORE_FROM_VM;
@extern method URLDocumentClass, MSG_URL_DOCUMENT_SET_LOCAL_PAGE;
@extern method URLDocumentClass, MSG_URL_DOCUMENT_GET_LOCAL_PAGE;
@extern method URLDocumentClass, MSG_URL_DOCUMENT_UPDATE_LOCAL;
@extern method URLDocumentClass, MSG_URL_DOCUMENT_REQUEST_LOCAL_PAGE_NOTIFY;

@endif


@method URLDocumentClass, MSG_GEN_DOCUMENT_PHYSICAL_OPEN,
                          MSG_GEN_DOCUMENT_PHYSICAL_CREATE
{
    PathName name;
    TCHAR *p;
    PathName fullname;
    NameToken url;
    ChunkHandle historyChunk, forwardChunk;
    MemHandle docBlock = OptrToHandle(oself);

    HWChecksumCheck() ;
    historyChunk = LMemAlloc( docBlock, sizeof(historyBufferData) * HTML_HISTORY);
    forwardChunk = LMemAlloc( docBlock, sizeof(historyBufferData) * HTML_HISTORY);

    // Allocate arrays for forward/back
    pself = ObjDerefGen(oself);
    pself->UDCI_historyBuffer = historyChunk;
    pself->UDCI_forwardBuffer = forwardChunk;

    pself->UDCI_topFrame = ConstructOptr(docBlock, OptrToChunk(@FrameTop));

    // This Add.. matches the followup Remove.. in PHYSICAL_CLOSE.
    AddCacheFileReference();

    strcpy(name, params->DCP_path);     // join file and path name
    if(*name && name[strlen(name)-1]!='\\') strcat(name, _TEXT("\\"));
    strcat(name, params->DCP_name);

    p = fullname;                       // make double indirection clean
    FileConstructFullPath(&p, PATH_BUFFER_SIZE, params->DCP_diskHandle, name, TRUE);

    HWChecksumCheck() ;
    if(message==MSG_GEN_DOCUMENT_PHYSICAL_OPEN)
    {
      char *fullnameP = fullname;
      MemHandle urlHan = NullHandle;
      // handle .URL files
      if (LocalCmpStringsNoCase((fullname+strlen(fullname)-4), _TEXT(".URL"), 4) == 0)
      {
          FileHandle urlFile;
          TCHAR *fp;
          int fsize;
          urlFile = FileOpen(fullname, FILE_DENY_W|FILE_ACCESS_R);
          if (urlFile)
          {
              fsize = FileSize(urlFile);
              if (fsize > HTML_MAX_BUF) fsize = HTML_MAX_BUF;
              urlHan = MemAlloc(fsize+1, HF_DYNAMIC, HAF_STANDARD);
              if (urlHan)
              {
                  fp = MemLock(urlHan);
                  fp[fsize] = 0;
                  if (FileRead(urlFile, fp, fsize, FALSE) == fsize)
                  {
                      if (fp[0] == '[')
                      {
                          // Outlook(?) format: [DEFAULT]
                          //                      BASEURL=<url>
                          // ...

                          fp = strchr(fp, '=');
                          if (fp) {
                              fullnameP = fp+1;
                              fp = fullnameP;
                              while (*fp > 32) fp++;
                              *fp = 0;  /* null-terminate */
                          }
                      }
                      else
                      {
                          // Netscape mailer(?) format: <cr>
                          //                            <sp><url>

                          while (*fp <= 32) fp++;
                          fullnameP = fp;
                          while (*fp > 32) fp++;
                          *fp = 0;  /* null-terminate */
                      }
                  }
              }
              FileClose(urlFile, TRUE);
          }
      }
      url = NamePoolTokenize(namePool, fullnameP, TRUE);
      if (urlHan) MemFree(urlHan);
      HWChecksumCheck() ;
      @send,forceQueue self::MSG_URL_DOCUMENT_LOAD_URL(url, DIR_ABSOLUTE);
    }
    else
    {
      MemHandle homeH = 0;
      TCHAR *homeP;
      extern MemHandle lazarusURL;

      HWChecksumCheck() ;
      if(lazarusURL)
      {
          homeH = lazarusURL;
          lazarusURL = 0;
      }

      if(homeH || (NavigateGetHome(&homeH) && !(@call HTMLVApp::MSG_HMLVA_GET_LAUNCH_URL())))
      {
        homeP = MemLock(homeH);
        url = NamePoolTokenize(namePool, homeP, TRUE);
        MemFree(homeH);
        HWChecksumCheck() ;
        @send,forceQueue self::MSG_URL_DOCUMENT_LOAD_URL(url, DIR_ABSOLUTE);
                                               // load home URL if defined
      }
    }

#ifdef GLOBAL_INTERNET_BUILD
    *fileOrError = textObjFile;
#else
    *fileOrError = cacheFile;
#endif
    HWChecksumCheck() ;
    return FALSE;
}

@method URLDocumentClass, MSG_GEN_DOCUMENT_ATTACH_UI_TO_DOCUMENT
{
    optr dispObj;
    MemHandle UIBlock, docBlock = OptrToHandle(oself);

    @callsuper();

    dispObj = @call self::MSG_GEN_DOCUMENT_GET_DISPLAY();
    UIBlock = OptrToHandle(dispObj);

    @send ConstructOptr(docBlock, OptrToChunk(@FrameTop))::MSG_URL_FRAME_SET_INTERACTION_OBJ(
        ConstructOptr(UIBlock, OptrToChunk(@UITop)));
}

@method URLDocumentClass, MSG_GEN_DOCUMENT_DETACH_UI_FROM_DOCUMENT
{
    @call (pself->UDCI_topFrame)::MSG_URL_FRAME_DETACH_VIEW_CONTENT_TREE();
@ifdef GLOBAL_INTERNET_BUILD
    // Tell help window to clean up.
    @call HelpFrame::MSG_URL_FRAME_DETACH_VIEW_CONTENT_TREE();
@endif
@ifdef JAVASCRIPT_SUPPORT
    // Tell window.open window to clean up.
    @call WindowOpenFrame::MSG_URL_FRAME_DETACH_VIEW_CONTENT_TREE();
@endif

    HWChecksumCheck() ;
    @callsuper();
    HWChecksumCheck() ;
}

@method URLDocumentClass, MSG_GEN_DOCUMENT_PHYSICAL_CLOSE
{
    @call self::MSG_URL_DOCUMENT_INT_DROP_FORWARD();
    @call self::MSG_URL_DOCUMENT_INT_DROP_BACK();

    pself = ObjDerefGen(oself);
    LMemFreeHandles(OptrToHandle(oself), pself->UDCI_historyBuffer);
    LMemFreeHandles(OptrToHandle(oself), pself->UDCI_forwardBuffer);
// release memory for history arrays

    @call (pself->UDCI_topFrame)::MSG_URL_FRAME_DELETE_ALL(TRUE);
@ifdef GLOBAL_INTERNET_BUILD
    @call HelpFrame::MSG_URL_FRAME_DELETE_ALL(TRUE);
@endif
@ifdef JAVASCRIPT_SUPPORT
    @call WindowOpenFrame::MSG_URL_FRAME_DELETE_ALL(TRUE);
@endif

    @call (pself->UDCI_topFrame)::MSG_URL_FRAME_DESTRUCT_TEXT_TREE();
@ifdef GLOBAL_INTERNET_BUILD
    @call HelpFrame::MSG_URL_FRAME_DESTRUCT_TEXT_TREE();
@endif
@ifdef JAVASCRIPT_SUPPORT
    @call WindowOpenFrame::MSG_URL_FRAME_DESTRUCT_TEXT_TREE();
@endif

    /* There is a poor assumption made in the app shutdown sequence that
       is broken when a system detach is performed.  The normal sequence
       is that this message is called long before the final
       RemoveCacheFileReference call made (indirectly) by
       MSG_GEN_PROCESS_CLOSE_APPLICATION.  The system detach causes the
       CLOSE_APPLICATION to happen BEFORE this message is handled, so
       the final URLText object which calls Remove.. ends up closing its
       own VM file on itself, causing nasty death.  To prevent nasty death,
       RemoveCacheFileReference is called here, after the text objects have
       self-destructed. - DH 9/7/99 */

    RemoveCacheFileReference();
}

@method URLDocumentClass, MSG_GEN_DOCUMENT_PHYSICAL_DELETE
{
}

@method URLDocumentClass, MSG_URL_DOCUMENT_GET_STATE
{
    Boolean unresolved;
    MemHandle homeH;
    TCHAR *homeP;
    WordFlags flags;
    NameToken url;

    flags = 0;

    url = @call self::MSG_URL_DOCUMENT_GET_URL();

    // get current home page
    if(url != NAME_POOL_NONE && NavigateGetHome(&homeH))
    {
      homeP = MemLock(homeH);
      if(FALSE == NamePoolTestEqual(namePool, url, homeP))
        flags |= HTML_HIST_HOME;        // home enabled if not already there
      MemFree(homeH);
    }

    unresolved = @call self::MSG_URL_DOCUMENT_TEST_UNRESOLVED_IMAGES();

    pself = ObjDerefGen(oself);
    flags |= ( (pself->UDCI_historyHead != pself->UDCI_historyTail) ?
               HTML_HIST_BACK: 0)
           | ( (pself->UDCI_historyForward) ?
               HTML_HIST_FORWARD: 0)
           | ( (url != NAME_POOL_NONE) ?
               HTML_HIST_CURRENT: 0)
           | ( unresolved ?
               HTML_HIST_LOAD_GR: 0);

    if(url != NAME_POOL_NONE) NamePoolReleaseToken(namePool, url);

    return flags;
}

@method URLDocumentClass, MSG_URL_DOCUMENT_NOTIFY_FRAME_CHANGE_POST
{
    optr frameSet;
    optr frame = pself->UDCI_topFrame;
    WordFlags flags;

    if(dir!=DIR_RELOAD && dir!=DIR_SOURCE && dir!=DIR_SAVE)
    { // changed anything important?
      HWChecksumCheck() ;

      // create a second frame set for the LRU history stack
      // TBD: it would probably be better to use a refrence-count based
      // scheme for frame sets.
      MemLock(frameCacheBlock);

      frameSet = ConstructOptr(frameCacheBlock, ChunkArrayCreate(frameCacheBlock, sizeof(HTMLframeRec), 0, 0));

      @call frame::MSG_URL_FRAME_COLLECT_FRAMES(frameSet, 0);

      @call self::MSG_URL_DOCUMENT_INT_UPDATE_LRU(frameSet);
      // update list of recently used URLs
      MemUnlock(frameCacheBlock);

      flags = @call self::MSG_URL_DOCUMENT_GET_STATE();
      @send process::MSG_HMLVP_NOTIFY_NAVIGATION_CHANGE(flags);

      HWChecksumCheck() ;
    }
}

@method URLDocumentClass, MSG_URL_DOCUMENT_NOTIFY_TOP_CHANGE
{
    NameToken tok;
    optr win;
    TCHAR buf[80];

@ifdef COMPILE_OPTION_MULTIPLE_WINDOWS
    win = @call self::MSG_GEN_DOCUMENT_GET_DISPLAY();
@else
    win = @HTMLVPrimary;
@endif
    if(win)
    {
      tok = title;                      // window name based on title or URL
      if(tok == NAME_POOL_NONE)
        tok = url;

      if(tok)                           // got title or URL
      {
        NamePoolCopy(namePool, buf, sizeof(buf), tok, NULL);
        @call win::MSG_GEN_REPLACE_VIS_MONIKER_TEXT(buf, VUM_DELAYED_VIA_APP_QUEUE);
      }
      else                              // nothing that could serve as title
      {
        @call win::MSG_GEN_REPLACE_VIS_MONIKER_OPTR(@Untitled, VUM_DELAYED_VIA_APP_QUEUE);
      }
    }

    // notify application about the change
    if(url != NAME_POOL_NONE) NamePoolUseToken(namePool, url);
    if(title != NAME_POOL_NONE) NamePoolUseToken(namePool, title);

    @send process::MSG_HMLVP_NOTIFY_TOP_CHANGE(url, title);
}

@method URLDocumentClass, MSG_META_GAINED_MODEL_EXCL
{
    NameToken url, title;
    WordFlags flags;

    HWChecksumCheck() ;

    url = @call self::MSG_URL_DOCUMENT_GET_URL();
    title = @call self::MSG_URL_DOCUMENT_GET_TITLE();
    @send process::MSG_HMLVP_NOTIFY_TOP_CHANGE(url, title);

    flags = @call self::MSG_URL_DOCUMENT_GET_STATE();
    @send process::MSG_HMLVP_NOTIFY_NAVIGATION_CHANGE(flags);

@ifdef COMPILE_OPTION_LOCAL_PAGES
    @call self::MSG_URL_DOCUMENT_REQUEST_LOCAL_PAGE_NOTIFY();
@endif

    HWChecksumCheck() ;
}

@method URLDocumentClass, MSG_URL_DOCUMENT_INT_ADD_BACK_URL
{
    word prevTail;
    historyBufferData *historyBuffer;

    HWChecksumCheck() ;

    // don't store if shouldn't
    if (!pself->UDCI_allowHistory) return;

    prevTail = pself->UDCI_historyTail;

    // store pointer to free entry
    if(++pself->UDCI_historyTail == HTML_HISTORY)
      pself->UDCI_historyTail = 0;      // advance tail, wrap if req'd

    if(pself->UDCI_historyTail == pself->UDCI_historyHead)
    { // list full, must discard entry?
      historyBuffer = LMemDerefHandles(OptrToHandle(oself),
                                       pself->UDCI_historyBuffer);

      // release frame description
      FreeArrayNameTokens(historyBuffer[pself->UDCI_historyTail].frameSet,
        namePool, TOKEN_FIELDS_FRAME_REC);
      LMemFree(historyBuffer[pself->UDCI_historyTail].frameSet);

      pself = ObjDerefGen(oself);
      if(++pself->UDCI_historyHead==HTML_HISTORY)
        pself->UDCI_historyHead = 0;    // advance head, wrap if req'd
    }

    historyBuffer = LMemDerefHandles(OptrToHandle(oself), pself->UDCI_historyBuffer);
    historyBuffer[prevTail].frameSet = frameSet;
}

@method URLDocumentClass, MSG_URL_DOCUMENT_INT_ADD_FORWARD_URL
{
    historyBufferData *forwardBuffer;

    HWChecksumCheck() ;

    // don't store if shouldn't
    if (!pself->UDCI_allowHistory) return;

    if(pself->UDCI_historyForward < HTML_HISTORY)
    { // have URL and room in fwd buffer?
      forwardBuffer = LMemDerefHandles(OptrToHandle(oself), pself->UDCI_forwardBuffer);
      forwardBuffer[pself->UDCI_historyForward++].frameSet = frameSet;
    }
}

@method URLDocumentClass, MSG_URL_DOCUMENT_INT_DROP_FORWARD
{
    word n;
    historyBufferData *forwardBuffer;
    ChunkHandle forwardChunk;

    forwardChunk = pself->UDCI_forwardBuffer;
    n = pself->UDCI_historyForward;
    pself->UDCI_historyForward = 0;      // no more entries in fwd buffer

    while(n>0)
    {
      HWChecksumCheck() ;
      forwardBuffer = LMemDerefHandles(OptrToHandle(oself), forwardChunk);

      // release frame description
      FreeArrayNameTokens(forwardBuffer[--n].frameSet, namePool, TOKEN_FIELDS_FRAME_REC);
      LMemFree(forwardBuffer[n].frameSet);
    }
}

@method URLDocumentClass, MSG_URL_DOCUMENT_INT_DROP_BACK
{
    word n1, n2;
    historyBufferData *historyBuffer;
    ChunkHandle historyChunk;

    historyChunk = pself->UDCI_historyBuffer;
    n1 = pself->UDCI_historyHead;
    n2 = pself->UDCI_historyTail;
    pself->UDCI_historyHead = pself->UDCI_historyTail = 0;

    // no more entries in history buffer
    while(n1 != n2)
    {
      HWChecksumCheck() ;
      historyBuffer = LMemDerefHandles(OptrToHandle(oself), historyChunk);

      // release frame description
      FreeArrayNameTokens(historyBuffer[n1].frameSet, namePool, TOKEN_FIELDS_FRAME_REC);
      LMemFree(historyBuffer[n1].frameSet);

      if(++n1 == HTML_HISTORY)          // advance head, wrap if req'd
        n1 = 0;
    }
}

@method URLDocumentClass, MSG_URL_DOCUMENT_INT_UPDATE_LRU
{
    NameToken tok;

    // don't store if shouldn't
    if (!pself->UDCI_allowHistory)
        return;

    tok = @call self::MSG_URL_DOCUMENT_GET_TITLE();
    if(tok == NAME_POOL_NONE)
      tok = @call self::MSG_URL_DOCUMENT_GET_URL();

    if(tok != NAME_POOL_NONE)
    {
      HistoryUpdateLRU(frameSet, tok);
      NamePoolReleaseToken(namePool, tok);
    }
}

/*
 *  Go forward, undoing the last "back" step.
 */
@method URLDocumentClass, MSG_URL_DOCUMENT_FORWARD
{
    optr frameSet;
    historyBufferData *forwardBuffer;

    if(!pself->UDCI_historyForward)     // can't go forward - do nothing
    {
@ifdef DO_ERROR_CHECKING
      @StartOperation();                // perform dummy operation for Auto
      @EndOperation();
@endif
      return 0;
    }

    forwardBuffer = LMemDerefHandles(OptrToHandle(oself), pself->UDCI_forwardBuffer);
    frameSet = LMemDup(forwardBuffer[--pself->UDCI_historyForward].frameSet);
    // get state from buffer

    HWChecksumCheck() ;
    // clear mod state so we'll update URL with current page
    @call CurrentURLText::MSG_VIS_TEXT_SET_NOT_USER_MODIFIED();
    @call self::MSG_URL_DOCUMENT_LOAD_FRAME_SET(frameSet, DIR_FORWARD);
    return 0;
}

/*
 *  Go back to previous URL in history list and drop it from the list.
 */
@method URLDocumentClass, MSG_URL_DOCUMENT_BACK
{
    optr frameSet;
    historyBufferData *historyBuffer;

    if(pself->UDCI_historyHead == pself->UDCI_historyTail)
    {
@ifdef DO_ERROR_CHECKING
      @StartOperation();                // perform dummy operation for Auto
      @EndOperation();
@endif
      return 0;                         // can't go back - do nothing
    }

    if(--(pself->UDCI_historyTail)==0xFFFF) pself->UDCI_historyTail = HTML_HISTORY-1;
    // move back tail, wrap if req'd
    historyBuffer = LMemDerefHandles(OptrToHandle(oself), pself->UDCI_historyBuffer);
    frameSet = LMemDup(historyBuffer[pself->UDCI_historyTail].frameSet);
    // get state from buffer

    HWChecksumCheck() ;
    // clear mod state so we'll update URL with current page
    @call CurrentURLText::MSG_VIS_TEXT_SET_NOT_USER_MODIFIED();
    @call self::MSG_URL_DOCUMENT_LOAD_FRAME_SET(frameSet, DIR_BACK);
    return 0;
}

@method URLDocumentClass, MSG_URL_DOCUMENT_NOTIFY_FRAME_CHANGE_PRE
{
    NameToken oldURL;
    optr frame = pself->UDCI_topFrame;
    optr frameSet;
    WordFlags flags;

    if(dir==DIR_RELOAD || dir==DIR_SOURCE || dir==DIR_SAVE || dir==DIR_FRAME
       || dir == DIR_FRAME_FORCE_RELOAD)
      return; // didn't really change anything...

    oldURL = @call self::MSG_URL_DOCUMENT_GET_URL();

    HWChecksumCheck() ;
    if(oldURL != NAME_POOL_NONE)
    {
      NamePoolReleaseToken(namePool, oldURL);

      // create frame set for back/forward stacks
      frameSet = ConstructOptr(OptrToHandle(oself),
        ChunkArrayCreate(OptrToHandle(oself), sizeof(HTMLframeRec), 0, 0));

      @call frame::MSG_URL_FRAME_COLLECT_FRAMES(frameSet, 0);

      if(dir==DIR_BACK)                 // going back?
        @call self::MSG_URL_DOCUMENT_INT_ADD_FORWARD_URL(frameSet);
                                        // add current URL to "forward" list
      else                              // going forward:
      {
        if(dir==DIR_ABSOLUTE || dir==DIR_GO || dir==DIR_ABSOLUTE_GO)
                                        // moving freely: forward useless
          @call self::MSG_URL_DOCUMENT_INT_DROP_FORWARD();
        @call self::MSG_URL_DOCUMENT_INT_ADD_BACK_URL(frameSet);
      }

      // create a second frame set for the LRU history stack
      // TBD: it would probably be better to use a refrence-count based
      // scheme for frame sets.
      MemLock(frameCacheBlock);
      frameSet = ConstructOptr(frameCacheBlock,
        ChunkArrayCreate(frameCacheBlock, sizeof(HTMLframeRec), 0, 0));

      @call frame::MSG_URL_FRAME_COLLECT_FRAMES(frameSet, 0);

      @call self::MSG_URL_DOCUMENT_INT_UPDATE_LRU(frameSet);
      // update list of recently used URLs
      MemUnlock(frameCacheBlock);

      flags = @call self::MSG_URL_DOCUMENT_GET_STATE();
      @send process::MSG_HMLVP_NOTIFY_NAVIGATION_CHANGE(flags);
    }
}

/*
   Note: the passed URL name token is freed by the message handler. This
   allows it to be *sent* rather than just called.
 */
@method URLDocumentClass, MSG_URL_DOCUMENT_LOAD_URL
{
    MemHandle urlB;
    TCHAR *urlP;
    optr frame = pself->UDCI_topFrame;
    int urlLen;
@ifdef COMPILE_OPTION_DOWNLOAD_PROGRESS_DIALOG
    extern Boolean G_allowFileDownloadStatus;
@endif

    if (!((@call application::MSG_GEN_APPLICATION_GET_STATE())&AS_QUITTING))
    {
        HWChecksumCheck() ;
        @AbortOperation(FALSE, TRUE, 0);  // stop current page load, first
        @call oself::MSG_URL_DOCUMENT_STOP(0) ;
@ifdef COMPILE_OPTION_DOWNLOAD_PROGRESS_DIALOG
        // allow file download progress dialog (from URL entry field, history,
        // favorites, external request, etc.)
        G_allowFileDownloadStatus = TRUE;
@endif
        // show new URL in URL input field while loading
        urlLen = NamePoolStrLength(namePool, url)+1;
        urlB = MemAlloc(urlLen*sizeof(TCHAR), HF_DYNAMIC, HAF_STANDARD);
        if (urlB)
        {
            urlP = MemLock(urlB);
            NamePoolCopy(namePool, urlP, urlLen*sizeof(TCHAR), url, 0);
            @call CurrentURLText::MSG_VIS_TEXT_REPLACE_ALL_PTR(urlP, 0);
            MemFree(urlB);
        }
        @call frame::MSG_URL_FRAME_FETCH_URL(url, dir, NullHandle, NAME_POOL_NONE);

        HWChecksumCheck() ;
        NamePoolReleaseToken(namePool, url);
        HWChecksumCheck() ;
    }
}

@method URLDocumentClass, MSG_URL_DOCUMENT_LOAD_FRAME_SET
{
    optr frame = pself->UDCI_topFrame;

    HWChecksumCheck() ;
    @AbortOperation(FALSE, TRUE, 0);  // stop current page load, first
    @call oself::MSG_URL_DOCUMENT_STOP(0) ;
    // load frame set into topmost frame
    ObjLockObjBlock(OptrToHandle(frameArray));
    @call frame::MSG_URL_FRAME_FETCH_FRAMES(frameArray, dir);
    LMemFree(frameArray);
    MemUnlock(OptrToHandle(frameArray));
    HWChecksumCheck() ;
}

/*
 *  Update visual representation of current frame tree
 *
 *  jfh 3/13/03 - pulled the ifndef DRAG_COPY stuff since it was
 *	               keeping pages from printing, and it didn't hurt
 *                the drag & drop capability
 */
@method URLDocumentClass, MSG_URL_DOCUMENT_UPDATE_FRAME_UI
{
    optr focusOptr = NullOptr;
    @call (pself->UDCI_topFrame)::MSG_URL_FRAME_UPDATE_FRAME_UI(&focusOptr);
//@ifndef COMPILE_OPTION_DRAG_COPY_WEB_PAGES
    if (focusOptr) {
        @send focusOptr::MSG_META_GRAB_FOCUS_EXCL();
        @send focusOptr::MSG_META_GRAB_TARGET_EXCL();
    }
//@endif
@ifdef JAVASCRIPT_SUPPORT
    // update window.open frames, we do this even if not open since we
    // could have just closed it and replaced the frames with about:blank,
    // though the focus grabbing is only if the window is open
    @call WindowOpenFrame::MSG_URL_FRAME_UPDATE_FRAME_UI(&focusOptr);
//@ifndef COMPILE_OPTION_DRAG_COPY_WEB_PAGES
    if (@call WindowOpenWindow::MSG_VIS_GET_ATTRS() & VA_VISIBLE) {
        if (focusOptr) {
                @send focusOptr::MSG_META_GRAB_FOCUS_EXCL();
                @send focusOptr::MSG_META_GRAB_TARGET_EXCL();
        }
    }
//@endif
@endif
@ifdef GLOBAL_INTERNET_BUILD
    if (@call HelpWindow::MSG_VIS_GET_ATTRS() & VA_VISIBLE)
    {
        @call HelpFrame::MSG_URL_FRAME_UPDATE_FRAME_UI(&focusOptr);
//@ifndef COMPILE_OPTION_DRAG_COPY_WEB_PAGES
        if (focusOptr) {
            @send focusOptr::MSG_META_GRAB_FOCUS_EXCL();
            @send focusOptr::MSG_META_GRAB_TARGET_EXCL();
        }
//@endif
    }
@endif
}

/*
 *  Attempt to reload current document
 */
@method URLDocumentClass, MSG_URL_DOCUMENT_RELOAD
{
    HWChecksumCheck() ;
    @AbortOperation(FALSE, TRUE, 0);  // stop current page load, first
    @call oself::MSG_URL_DOCUMENT_STOP(0) ;
    // clear mod state so we'll update URL with current page
    @call CurrentURLText::MSG_VIS_TEXT_SET_NOT_USER_MODIFIED();
    @call (pself->UDCI_topFrame)::MSG_URL_FRAME_RELOAD();
@ifdef GLOBAL_INTERNET_BUILD
    if (@call HelpWindow::MSG_VIS_GET_ATTRS() & VA_VISIBLE)
    {
        @call HelpFrame::MSG_URL_FRAME_RELOAD();
    }
@endif
@ifdef JAVASCRIPT_SUPPORT
    if (@call WindowOpenWindow::MSG_VIS_GET_ATTRS() & VA_VISIBLE)
    {
        @call WindowOpenFrame::MSG_URL_FRAME_RELOAD();
    }
@endif
    HWChecksumCheck() ;
}

/*
 *  Attempt to reload current document and view as Source
 */
@method URLDocumentClass, MSG_URL_DOCUMENT_SOURCE
{
    HWChecksumCheck() ;
    @call (pself->UDCI_topFrame)::MSG_URL_FRAME_SOURCE();
    HWChecksumCheck() ;
}

/*
 *  Attempt to reload current document and save to file
 */
@method URLDocumentClass, MSG_URL_DOCUMENT_SAVE
{
    HWChecksumCheck() ;
    @call (pself->UDCI_topFrame)::MSG_URL_FRAME_SAVE();
    HWChecksumCheck() ;
}

/*
 *  Load missing images
 */
@method URLDocumentClass, MSG_URL_DOCUMENT_LOAD_GRAPHICS
{
    HWChecksumCheck() ;
    @call (pself->UDCI_topFrame)::MSG_URL_FRAME_LOAD_GRAPHICS();
    HWChecksumCheck() ;
}

@method URLDocumentClass, MSG_URL_DOCUMENT_GET_TOP_FRAME
{
    HWChecksumCheck() ;
    return pself->UDCI_topFrame;
}

@method URLDocumentClass, MSG_URL_DOCUMENT_ALLOW_HISTORY
{
    pself->UDCI_allowHistory = TRUE;
}

@method URLDocumentClass, MSG_URL_DOCUMENT_DISALLOW_HISTORY
{
    pself->UDCI_allowHistory = FALSE;
}

@method URLDocumentClass, MSG_URL_DOCUMENT_MAKE_NEW_HOME
{
    NameToken url;
    TCHAR buf[HTML_STATIC_BUF],*p;
    WordFlags flags;

    HWChecksumCheck() ;

    url = @call self::MSG_URL_DOCUMENT_GET_URL();
    if(url != NAME_POOL_NONE)      // currently showing URL?
    {
        NamePoolCopy(namePool, buf, sizeof(buf), url, &p);
                                        // save as new home page
        NavigateSetHome(p);               // set home URL
        NamePoolDestroyIfDynamic(p);      // release dynamic buffer, if any
        NamePoolReleaseToken(namePool, url);

        HWChecksumCheck() ;

        flags = @call self::MSG_URL_DOCUMENT_GET_STATE();
        @send process::MSG_HMLVP_NOTIFY_NAVIGATION_CHANGE(flags);

        HWChecksumCheck() ;
    }
}

@ifdef COMPILE_OPTION_BOOKMARKS

@method URLDocumentClass, MSG_URL_DOCUMENT_ADD_BOOKMARK
{
    NameToken url,title;
    TCHAR urlString[HTML_STATIC_BUF], *uP ;
    TCHAR titleString[HTML_STATIC_BUF], *tP ;

    HWChecksumCheck() ;
    url = @call self::MSG_URL_DOCUMENT_GET_URL();
    title = @call self::MSG_URL_DOCUMENT_GET_TITLE();

    if (url != NAME_POOL_NONE)
    {
        // Get the URL and title for the bookmark
        NamePoolCopy(namePool, urlString, sizeof(urlString), url, &uP);
        NamePoolCopy(namePool, titleString, sizeof(titleString), title?title:url, &tP);

        // Add a new bookmark
        BookmarkAppend(tP, uP);

        NamePoolDestroyIfDynamic(tP);
        NamePoolDestroyIfDynamic(uP);

        // Rebuild the menu
        BookmarksBuildUIList(@BookmarkTriggerList) ;

        // Note that another item has been added to the list
        @call BookmarksDynamicList::MSG_GEN_DYNAMIC_LIST_ADD_ITEMS(GDLP_LAST, 1) ;

        NamePoolReleaseToken(namePool, url) ;
    }

    if (title != NAME_POOL_NONE) NamePoolReleaseToken(namePool, title) ;

    HWChecksumCheck() ;
}

@method URLDocumentClass, MSG_URL_DOCUMENT_GO_TO_BOOKMARK
{
    TCHAR *p_title ;
    TCHAR *p_location ;
    NameToken url ;

    // Get the bookmark we are going to go to
    p_title = BookmarkLock(bookmarkNum, &p_location) ;
    if (p_title)  {
        url = NamePoolTokenize(namePool, p_location, TRUE);
        BookmarkUnlock(p_title) ;

        HWChecksumCheck() ;
        // Put in a request to go to that url location
        @send ,forceQueue oself::MSG_URL_DOCUMENT_LOAD_URL(url, DIR_GO) ;
    }
}

@endif

@ifdef COMPILE_OPTION_FAVORITES

@method URLDocumentClass, MSG_URL_DOCUMENT_GO_TO_FAVORITE
{
    NameToken url ;
    T_lockedFavorite *p_favorite = NULL ;
    word i ;
    dword pos ;
    dword count ;

    // Get the favorite we are going to go to
    if (!useAll && FavoriteCountTopTen())  {
        p_favorite = FavoriteLockTopEntry(favoriteNum) ;
    } else  {
        // Find the nth non-folder
        count = FavoritesGetCount() ;
        for (i=0, pos=0; pos<count; pos++)
            if (!FavoriteIsFolder(pos))
                if (i++ >= favoriteNum)
                    break ;

        // Lock what we found
        if (pos < count)
            p_favorite = FavoriteLock(pos) ;
    }
    if (p_favorite)  {
        url = NamePoolTokenize(namePool, p_favorite->p_location, TRUE);
        FavoriteUnlock(p_favorite) ;

        HWChecksumCheck() ;
        // Put in a request to go to that url location
        @send ,forceQueue oself::MSG_URL_DOCUMENT_LOAD_URL(url, DIR_GO) ;
    }
}

@endif

@method URLDocumentClass, MSG_URL_DOCUMENT_RECALCULATE
{
    // have the top frame recalculate itself and all its
    // children
    HWChecksumCheck() ;
    @call (pself->UDCI_topFrame)::MSG_URL_FRAME_RECALCULATE() ;
    HWChecksumCheck() ;
}

@method URLDocumentClass, MSG_URL_DOCUMENT_STOP
{
    if (frame) {
        @call frame::MSG_URL_FRAME_STOP() ;
    } else {
        @call (pself->UDCI_topFrame)::MSG_URL_FRAME_STOP() ;
    }
}

@method URLDocumentClass, MSG_URL_DOCUMENT_TEST_UNRESOLVED_IMAGES
{
    Boolean ret;

    // have the top frame check for unresolved images in itself and all its
    // children
    HWChecksumCheck() ;
    ret = @call (pself->UDCI_topFrame)::MSG_URL_FRAME_TEST_UNRESOLVED_IMAGES() ;
    HWChecksumCheck() ;

    return ret;
}

@method URLDocumentClass, MSG_URL_DOCUMENT_GET_URL
{
    NameToken ret;

    // get "document URL", defined as the URL loaded in the top frame
    HWChecksumCheck() ;
    ret = @call (pself->UDCI_topFrame)::MSG_URL_FRAME_GET_URL() ;
    HWChecksumCheck() ;

    return ret;
}

@method URLDocumentClass, MSG_URL_DOCUMENT_GET_TITLE
{
    NameToken ret;

    // get "document title", defined as that of the page in the top frame
    HWChecksumCheck() ;
    ret = @call (pself->UDCI_topFrame)::MSG_URL_FRAME_GET_TITLE() ;
    HWChecksumCheck() ;

    return ret;
}

@method URLDocumentClass, MSG_URL_DOCUMENT_INC_PENDING
{
    if (pself->UDCI_numPendingFrames++ == 0)
        @StartOperation() ;
    EC_ERROR_IF(pself->UDCI_numPendingFrames >= MAX_NUM_REQUESTS, -1) ;
}

@method URLDocumentClass, MSG_URL_DOCUMENT_DEC_PENDING
{
    pself->UDCI_numPendingFrames-- ;
    EC_ERROR_IF(pself->UDCI_numPendingFrames >= MAX_NUM_REQUESTS, -1) ;

    if (pself->UDCI_numPendingFrames == 0)
    {
        // Inform the frame that we are done.
        @send self::MSG_URL_DOCUMENT_NOTIFY_DOCUMENT_COMPLETE();

        @EndOperation() ;
    }
}

@method URLDocumentClass, MSG_URL_DOCUMENT_NOTIFY_DOCUMENT_COMPLETE
{
    WordFlags flags;
@ifdef COMPILE_OPTION_LOCAL_PAGES
    FileLongName saveFile;
@endif

    HWChecksumCheck() ;

@ifdef JAVASCRIPT_SUPPORT
     // ensure script context for all frames, if anyone has JS
     if (pself->UDCI_haveJS) {
        @call (pself->UDCI_topFrame)::MSG_URL_FRAME_ENSURE_SCRIPT_CONTEXT();
     }
     pself->UDCI_haveJS = FALSE;  // clear for next time
@endif

    flags = @call self::MSG_URL_DOCUMENT_GET_STATE();
    @send process::MSG_HMLVP_NOTIFY_NAVIGATION_CHANGE(flags);

@ifdef COMPILE_OPTION_SECURE_STATUS
     // update secure status at end of operation
     @send (pself->UDCI_topFrame)::MSG_URL_FRAME_UPDATE_SECURE_ICON(NAME_POOL_NONE);
@endif

@ifdef COMPILE_OPTION_LOCAL_PAGES
    HWChecksumCheck() ;

    // Pending update of local page? Save it now as everything has come in.
    pself = ObjDerefGen(oself);
    if(pself->UDCI_localPage && pself->UDCI_updatingLocal)
    {
      // Done updating - save to file.
      pself->UDCI_updatingLocal = FALSE;

      NamePoolCopy(namePool, saveFile, sizeof(saveFile), pself->UDCI_localPage, NULL);
      @call self::MSG_URL_DOCUMENT_STORE_TO_FILENAME(saveFile);
    }
@endif

    // flush any URL driver data
    FlushURLData();

    HWChecksumCheck() ;

    // Commit source cache
    SrcCacheCommit();

    HWChecksumCheck() ;
}

@ifdef COMPILE_OPTION_PARENTAL_CONTROL

@method URLDocumentClass, MSG_URL_DOCUMENT_PC_ADD_SITE
{
    ParentalControlFlags pcFlags = 0;
    AccessFlags access;

    access = ParentalControlGetAccessInfo();
    // if full access, no password; if not bypassed, require password
    if (((access & AF_WWWBROWSING) || (access & AF_WWWLIMITED)) && !G_pcBypassed)
    {
        pcFlags |= PCF_REQUIRE_PASSWORD;
    }

    // forward to top frame
    ParentalControlEnsureOpenData();
    @call (pself->UDCI_topFrame)::MSG_URL_FRAME_PC_ADD_SITE(&pcFlags);
    ParentalControlCloseData();
    if (!(pcFlags & PCF_ADDED_SITE) && !(pcFlags & PCF_ABORT_PASSWORD))
    {
        // didn't add anything, report it
        @send PCSiteAlreadyAddedDlg::MSG_GEN_INTERACTION_INITIATE();
    }
}

@method URLDocumentClass, MSG_URL_DOCUMENT_PC_REMOVE_SITE
{
    ParentalControlFlags pcFlags = 0;
    AccessFlags access;

    access = ParentalControlGetAccessInfo();
    // if full access, no password; if not bypassed, require password
    if (((access & AF_WWWBROWSING) || (access & AF_WWWLIMITED)) && !G_pcBypassed) {
        pcFlags |= PCF_REQUIRE_PASSWORD;
    }

    // forward to top frame
    ParentalControlEnsureOpenData();
    @call (pself->UDCI_topFrame)::MSG_URL_FRAME_PC_REMOVE_SITE(&pcFlags);
    ParentalControlCloseData();
    if (!(pcFlags & PCF_REMOVED_SITE) && !(pcFlags & PCF_ABORT_PASSWORD))
    {
        // didn't remove anything, report it
        @send PCSiteNotInListDlg::MSG_GEN_INTERACTION_INITIATE();
    }
}

@endif

@method URLDocumentClass, MSG_PRINT_GET_DOC_NAME
{
    EventHandle evt;
    NameToken url;
    optr display;

    url = @call self::MSG_URL_DOCUMENT_GET_URL();

    if(url != NAME_POOL_NONE)           // Do we have a page loaded?
    {
        NamePoolReleaseToken(namePool, url);

        // forward this message to the targeted frame
        display = @call self::MSG_GEN_DOCUMENT_GET_DISPLAY();
        evt = @record VisTextClass::MSG_PRINT_GET_DOC_NAME(printCtrlOD);
        @send display::MSG_META_SEND_CLASSED_EVENT(evt, TO_TARGET);
    }
}

@method URLDocumentClass, MSG_PRINT_START_PRINTING
{
    EventHandle evt;
    NameToken url;
    optr display;

    url = @call self::MSG_URL_DOCUMENT_GET_URL();

    if(url != NAME_POOL_NONE)           // Do we have a page loaded?
    {
        NamePoolReleaseToken(namePool, url);

        /* forward this message to the targeted frame */
        display = @call self::MSG_GEN_DOCUMENT_GET_DISPLAY();
        evt = @record VisTextClass::MSG_PRINT_START_PRINTING(printCtrlOD, gstate);
        @send display::MSG_META_SEND_CLASSED_EVENT(evt, TO_TARGET);
    }
}

@method URLDocumentClass, MSG_PRINT_NOTIFY_PRINT_DB
{
    EventHandle evt;
    NameToken url;
    optr display;

    if(pcs==PCS_PRINT_BOX_VISIBLE)      // Updating print box when it comes up?
    {
        url = @call self::MSG_URL_DOCUMENT_GET_URL();

        if(url != NAME_POOL_NONE)         // Do we have a page loaded?
        {
            NamePoolReleaseToken(namePool, url);

            // forward this message to the targeted frame
            display = @call self::MSG_GEN_DOCUMENT_GET_DISPLAY();
            evt = @record VisTextClass::MSG_PRINT_NOTIFY_PRINT_DB(printCtrlOD, pcs);
            @send display::MSG_META_SEND_CLASSED_EVENT(evt, TO_TARGET);
        }
    }
}

@ifdef JAVASCRIPT_SUPPORT
@method URLDocumentClass, MSG_URL_DOCUMENT_SET_JS_ERROR
{
    pself->UDCI_jsError = state;
}

@method URLDocumentClass, MSG_URL_DOCUMENT_GET_JS_ERROR
{
    return(pself->UDCI_jsError);
}

/*
 *  Clear document's frames from object cache.
 */
@method URLDocumentClass, MSG_URL_DOCUMENT_CLEAR_OBJ_CACHE
{
    HWChecksumCheck() ;
    @call (pself->UDCI_topFrame)::MSG_URL_FRAME_CLEAR_OBJ_CACHE();
    HWChecksumCheck() ;
}

/*
 *  Set JS flag.
 */
@method URLDocumentClass, MSG_URL_DOCUMENT_SET_JS
{
    pself->UDCI_haveJS = TRUE;
}

/*
 *  Ensure all frames have script context initialized.
 */
@method URLDocumentClass, MSG_URL_DOCUMENT_ENSURE_SCRIPT_CONTEXT
{
    @call (pself->UDCI_topFrame)::MSG_URL_FRAME_ENSURE_SCRIPT_CONTEXT();
@ifdef GLOBAL_INTERNET_BUILD
    if (@call HelpWindow::MSG_VIS_GET_ATTRS() & VA_VISIBLE) {
        @call HelpFrame::MSG_URL_FRAME_ENSURE_SCRIPT_CONTEXT();
    }
@endif
@ifdef JAVASCRIPT_SUPPORT
    if (@call WindowOpenWindow::MSG_VIS_GET_ATTRS() & VA_VISIBLE) {
        @call WindowOpenFrame::MSG_URL_FRAME_ENSURE_SCRIPT_CONTEXT();
    }
@endif
}

@endif
