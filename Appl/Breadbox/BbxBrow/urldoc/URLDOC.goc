/*
 *                          ==CONFIDENTIAL INFORMATION==
 *
 * COPYRIGHT 1994-99 BREADBOX COMPUTER COMPANY -- ALL RIGHTS RESERVED  --
 * THE FOLLOWING CONFIDENTIAL INFORMATION IS BEING DISCLOSED TO YOU UNDER
 * A NON-DISCLOSURE AGREEMENT AND MAY NOT BE DISCLOSED OR FORWARDED BY THE
 * RECIPIENT TO ANY OTHER PERSON OR ENTITY NOT COVERED BY THE SAME
 * NON-DISCLOSURE AGREEMENT COVERING THE RECIPIENT. USE OF THE FOLLOWING
 * CONFIDENTIAL INFORMATION IS RESTRICTED TO THE TERMS OF THE NON-DISCLOSURE
 * AGREEMENT.
 *
*/
/***********************************************************************
 *
 * PROJECT:       HTMLView
 * FILE:          URLDoc.goc
 *
 * AUTHOR:        Marcus Gr√∂ber
 *
 ***********************************************************************/

/**************************************************************************
 *      Include files
 **************************************************************************/

@include <stdapp.goh>
#include <geoMisc.h>                    /* various unix-like goodies */
#include <initfile.h>

#include <Ansi/string.h>
#include <Ansi/stdio.h>
#include <Ansi/stdlib.h>

@include "htmlview.goh"


@extern object HTMLVApp;
@extern object HTMLVPrimary;
@extern object CurrentURLText;
@extern object HTMLDisplayGroup;
@extern object DocumentControl;
@ifdef COMPILE_OPTION_PAGE_SIZE_CONTROL
@extern object PageSizeControl;
@endif
@extern object SettingsBoolGroup;

@ifdef COMPILE_OPTION_BOOKMARKS
@include "bookmark.goh"
@extern object BookmarkTriggerList ;
@extern object BookmarksDynamicList ;
@endif

@ifdef COMPILE_OPTION_FAVORITES
@include "favorite.goh"
@extern object FavoriteTriggerList ;
@extern object FavoritesDynamicList ;
@endif

@extern visMoniker Untitled;            /* "untitled" text */

@ifdef COMPILE_OPTION_PARENTAL_CONTROL
@include <parentc.goh>
@extern object PCSiteAlreadyAddedDlg;
@extern object PCSiteNotInListDlg;
extern Boolean G_pcBypassed;
@endif

@ifdef GLOBAL_INTERNET_BUILD
@extern object HelpWindow;
@extern object HelpFrame;
@endif

@ifdef JAVASCRIPT_SUPPORT
@extern object WindowOpenWindow;
@extern object WindowOpenFrame;
@endif


@start    DocGroupResource;
    @object URLDocumentGroupClass HTMLDocumentGroup = {
        GDGI_attrs = GDGA_NATIVE
                        | GDGA_APPLICATION_THREAD;
        GDGI_documentControl = @DocumentControl;
        GDGI_genDocument = @HTMLDocument;
        GDGI_genDisplay = @HTMLDisplay;
        GDGI_genDisplayGroup = @HTMLDisplayGroup;
@ifdef GLOBAL_INTERNET_BUILD
@ifdef DO_DBCS
     GDGI_untitledName = "browser page";
@else
     GDGI_untitledName = "WebMagick";
@endif
@else
     GDGI_untitledName = "untitled";
@endif
        ATTR_GEN_DOCUMENT_GROUP_DOCUMENT_HANDLES = {
            0
        };
    }
@end      DocGroupResource;


@start  UIResource, notDetachable;

    @object GenDisplayClass HTMLDisplay = {
        GI_states = @default & ~GS_USABLE;
@ifdef GLOBAL_INTERNET_BUILD
        GI_visMoniker = "WebMagick";
@else
        GI_visMoniker = "untitled";
@endif
        GI_comp = @UITop;
        ATTR_GEN_DISPLAY_NOT_MINIMIZABLE;
        HINT_DEFAULT_TARGET;
        HINT_DEFAULT_FOCUS;
    }

  @object GenInteractionClass UITop = {
        GI_attrs = @default | GA_TARGETABLE;
        HINT_EXPAND_WIDTH_TO_FIT_PARENT;
        HINT_EXPAND_HEIGHT_TO_FIT_PARENT;
        HINT_ORIENT_CHILDREN_VERTICALLY;
        HINT_MINIMIZE_CHILD_SPACING;
  }

@end    UIResource;

@start ViewGroupTemplateResource, notDetachable;

@object GenInteractionClass ViewGroupTemplate = {
    GI_attrs = @default | GA_TARGETABLE;
    GI_states = @default & ~GS_USABLE;
    HINT_EXPAND_WIDTH_TO_FIT_PARENT;
    HINT_EXPAND_HEIGHT_TO_FIT_PARENT;
    HINT_ORIENT_CHILDREN_HORIZONTALLY;
    HINT_MINIMIZE_CHILD_SPACING;
}

@end ViewGroupTemplateResource;

@start ViewTemplateResource, notDetachable;

@object GenViewClass ViewTemplate = {
    GI_attrs = @default | GA_TARGETABLE;
    GI_states = @default & ~GS_USABLE;
    GVI_vertAttrs = @default | GVDA_SCROLLABLE;  /* default is AUTO */
    GVI_horizAttrs = @default | GVDA_SCROLLABLE;  /* default is AUTO */
    GVI_attrs = @default | GVA_CONTROLLED | GVA_DRAG_SCROLLING \
                         | GVA_WINDOW_COORDINATE_MOUSE_EVENTS \
                         | GVA_DONT_SEND_KBD_RELEASES | GVA_FOCUSABLE;
    ATTR_GEN_VIEW_DOES_NOT_ACCEPT_TEXT_INPUT;
    HINT_EXPAND_WIDTH_TO_FIT_PARENT;
    HINT_EXPAND_HEIGHT_TO_FIT_PARENT;
    HINT_MINIMIZE_CHILD_SPACING;
    HINT_VIEW_REMOVE_SCROLLERS_WHEN_NOT_SCROLLABLE;  /* default is AUTO */
@ifdef GLOBAL_INTERNET_BUILD
    ATTR_GEN_VIEW_NOTIFY_EVEN_IF_NOT_TARGETED;
@endif
}

@end ViewTemplateResource;


@start  FrameResource, notDetachable;

    @object URLDocumentClass HTMLDocument = {
        GI_states = @default & ~GS_USABLE;
        UDCI_topFrame = @FrameTop;
    }

    @object URLFrameClass FrameTop = {
        UFI_document = @HTMLDocument;
    }

@end    FrameResource;

@start FrameTemplateResource, notDetachable;

    @object URLFrameClass FrameTemplate = {
        UFI_document = @HTMLDocument;
    }

@end FrameTemplateResource;


@start  TextResource, notDetachable;

    @object VisContentClass URLContent = {
        VCNI_attrs = @default | VCNA_LARGE_DOCUMENT_MODEL
                    | VCNA_WINDOW_COORDINATE_MOUSE_EVENTS
                    | VCNA_SAME_WIDTH_AS_VIEW;
        VCI_comp = @URLText;
    }

    @object URLTextClass URLText = {
        ATTR_VIS_TEXT_WRAP_AFTER_OVERFLOW_WITH_MAXIMUM = 780 ;
        ATTR_VIS_TEXT_DONT_DRAW_BREAKS;
        ATTR_VIS_TEXT_ALLOW_CROSS_SECTION_COPY ;
    }

@end    TextResource;


/***************************************************************************
 *              URL browser display
 ***************************************************************************/

@classdecl URLDocumentClass;

@ifdef COMPILE_OPTION_LOCAL_PAGES

/* Declared in LOCALPAG.GOC */
@extern method URLDocumentClass, MSG_URL_DOCUMENT_SAVE_LOCAL;
@extern method URLDocumentClass, MSG_URL_DOCUMENT_OPEN_LOCAL;
@extern method URLDocumentClass, MSG_URL_DOCUMENT_STORE_TO_FILENAME;
@extern method URLDocumentClass, MSG_URL_DOCUMENT_STORE_TO_VM;
@extern method URLDocumentClass, MSG_URL_DOCUMENT_RESTORE_FROM_VM;
@extern method URLDocumentClass, MSG_URL_DOCUMENT_SET_LOCAL_PAGE;
@extern method URLDocumentClass, MSG_URL_DOCUMENT_GET_LOCAL_PAGE;
@extern method URLDocumentClass, MSG_URL_DOCUMENT_UPDATE_LOCAL;
@extern method URLDocumentClass, MSG_URL_DOCUMENT_REQUEST_LOCAL_PAGE_NOTIFY;

@endif


@method URLDocumentClass, MSG_GEN_DOCUMENT_PHYSICAL_OPEN,
                          MSG_GEN_DOCUMENT_PHYSICAL_CREATE
{
    PathName name;
    TCHAR *p;
    PathName fullname;
    NameToken url;
    ChunkHandle historyChunk, forwardChunk;
    MemHandle docBlock = OptrToHandle(oself);

    HWChecksumCheck() ;
    historyChunk = LMemAlloc( docBlock,
        sizeof(historyBufferData) * HTML_HISTORY);
    forwardChunk = LMemAlloc( docBlock,
        sizeof(historyBufferData) * HTML_HISTORY);
                                        /* Allocate arrays for forward/back */
    pself = ObjDerefGen(oself);
    pself->UDCI_historyBuffer = historyChunk;
    pself->UDCI_forwardBuffer = forwardChunk;

    pself->UDCI_topFrame = ConstructOptr(docBlock, OptrToChunk(@FrameTop));

    /* This Add.. matches the followup Remove.. in PHYSICAL_CLOSE. */
    AddCacheFileReference();

    strcpy(name, params->DCP_path);     /* join file and path name */
    if(*name && name[strlen(name)-1]!='\\')
        strcat(name, _TEXT("\\"));
    strcat(name, params->DCP_name);

    p = fullname;                       /* make double indirection clean */
    FileConstructFullPath(&p, PATH_BUFFER_SIZE,
        params->DCP_diskHandle, name,TRUE);

    HWChecksumCheck() ;
    if(message==MSG_GEN_DOCUMENT_PHYSICAL_OPEN)
    {
        char *fullnameP = fullname;
        MemHandle urlHan = NullHandle;
        /* handle .URL files */
        if (LocalCmpStringsNoCase((fullname+strlen(fullname)-4), _TEXT(".URL"), 4) == 0) {
            FileHandle urlFile;
            TCHAR *fp;
            int fsize;
            urlFile = FileOpen(fullname, FILE_DENY_W|FILE_ACCESS_R);
            if (urlFile) {
                fsize = FileSize(urlFile);
                if (fsize > HTML_MAX_BUF) fsize = HTML_MAX_BUF;
                urlHan = MemAlloc(fsize+1, HF_DYNAMIC, HAF_STANDARD);
                if (urlHan) {
                    fp = MemLock(urlHan);
                    fp[fsize] = 0;
                    if (FileRead(urlFile, fp, fsize, FALSE) == fsize) {
                        if (fp[0] == '[') {
                            /* Outlook(?) format: [DEFAULT]
                                                  BASEURL=<url>
                                                   ...
                            */
                            fp = strchr(fp, '=');
                            if (fp) {
                                fullnameP = fp+1;
                                fp = fullnameP;
                                while (*fp > 32) fp++;
                                *fp = 0;  /* null-terminate */
                            }
                        } else {
                            /* Netscape mailer(?) format: <cr>
                                                        <sp><url>
                            */
                            while (*fp <= 32) fp++;
                            fullnameP = fp;
                            while (*fp > 32) fp++;
                            *fp = 0;  /* null-terminate */
                        }
                    }
                }
                FileClose(urlFile, TRUE);
            }
        }
        url = NamePoolTokenize(namePool, fullnameP, TRUE);
        if (urlHan) MemFree(urlHan);
        HWChecksumCheck() ;
        @send,forceQueue self::MSG_URL_DOCUMENT_LOAD_URL(url, DIR_ABSOLUTE);
    }
    else
    {
        MemHandle homeH = 0;
        TCHAR *homeP;
        extern MemHandle lazarusURL;

        HWChecksumCheck() ;
        if(lazarusURL) {
            homeH = lazarusURL;
            lazarusURL = 0;
        }
        if(homeH || (NavigateGetHome(&homeH) && !(@call HTMLVApp::MSG_HMLVA_GET_LAUNCH_URL())))
        {
            homeP = MemLock(homeH);
            url = NamePoolTokenize(namePool, homeP, TRUE);
            MemFree(homeH);
            HWChecksumCheck() ;
            @send,forceQueue self::MSG_URL_DOCUMENT_LOAD_URL(url, DIR_ABSOLUTE);
            /* load home URL if defined */
        }
    }

#ifdef GLOBAL_INTERNET_BUILD
    *fileOrError = textObjFile;
#else
    *fileOrError = cacheFile;
#endif
    HWChecksumCheck() ;
    return FALSE;
}

@method URLDocumentClass, MSG_GEN_DOCUMENT_ATTACH_UI_TO_DOCUMENT
{
    optr dispObj;
    MemHandle UIBlock, docBlock = OptrToHandle(oself);

    @callsuper();

    dispObj = @call self::MSG_GEN_DOCUMENT_GET_DISPLAY();
    UIBlock = OptrToHandle(dispObj);

    @send ConstructOptr(docBlock, OptrToChunk(@FrameTop))::
        MSG_URL_FRAME_SET_INTERACTION_OBJ(
            ConstructOptr(UIBlock, OptrToChunk(@UITop)));
}

@method URLDocumentClass, MSG_GEN_DOCUMENT_DETACH_UI_FROM_DOCUMENT
{
    @call (pself->UDCI_topFrame)::MSG_URL_FRAME_DETACH_VIEW_CONTENT_TREE();
@ifdef GLOBAL_INTERNET_BUILD
    /* Tell help window to clean up. */
    @call HelpFrame::MSG_URL_FRAME_DETACH_VIEW_CONTENT_TREE();
@endif
@ifdef JAVASCRIPT_SUPPORT
    /* Tell window.open window to clean up. */
    @call WindowOpenFrame::MSG_URL_FRAME_DETACH_VIEW_CONTENT_TREE();
@endif

    HWChecksumCheck() ;
    @callsuper();
    HWChecksumCheck() ;
}

@method URLDocumentClass, MSG_GEN_DOCUMENT_PHYSICAL_CLOSE
{
    @call self::MSG_URL_DOCUMENT_INT_DROP_FORWARD();
    @call self::MSG_URL_DOCUMENT_INT_DROP_BACK();

    pself = ObjDerefGen(oself);
    LMemFreeHandles(OptrToHandle(oself), pself->UDCI_historyBuffer);
    LMemFreeHandles(OptrToHandle(oself), pself->UDCI_forwardBuffer);
    /* release memory for history arrays */

    @call (pself->UDCI_topFrame)::MSG_URL_FRAME_DELETE_ALL(TRUE);
@ifdef GLOBAL_INTERNET_BUILD
    @call HelpFrame::MSG_URL_FRAME_DELETE_ALL(TRUE);
@endif
@ifdef JAVASCRIPT_SUPPORT
    @call WindowOpenFrame::MSG_URL_FRAME_DELETE_ALL(TRUE);
@endif

    @call (pself->UDCI_topFrame)::MSG_URL_FRAME_DESTRUCT_TEXT_TREE();
@ifdef GLOBAL_INTERNET_BUILD
    @call HelpFrame::MSG_URL_FRAME_DESTRUCT_TEXT_TREE();
@endif
@ifdef JAVASCRIPT_SUPPORT
    @call WindowOpenFrame::MSG_URL_FRAME_DESTRUCT_TEXT_TREE();
@endif

    /* There is a poor assumption made in the app shutdown sequence that
       is broken when a system detach is performed.  The normal sequence
       is that this message is called long before the final
       RemoveCacheFileReference call made (indirectly) by
       MSG_GEN_PROCESS_CLOSE_APPLICATION.  The system detach causes the
       CLOSE_APPLICATION to happen BEFORE this message is handled, so
       the final URLText object which calls Remove.. ends up closing its
       own VM file on itself, causing nasty death.  To prevent nasty death,
       RemoveCacheFileReference is called here, after the text objects have
       self-destructed. - DH 9/7/99 */

    RemoveCacheFileReference();
}

@method URLDocumentClass, MSG_GEN_DOCUMENT_PHYSICAL_DELETE
{
}

@method URLDocumentClass, MSG_URL_DOCUMENT_GET_STATE
{
    Boolean unresolved;
    MemHandle homeH;
    TCHAR *homeP;
    WordFlags flags;
    NameToken url;

    flags = 0;

    url = @call self::MSG_URL_DOCUMENT_GET_URL();

    /* get current home page */
    if(url != NAME_POOL_NONE && NavigateGetHome(&homeH))
    {
        homeP = MemLock(homeH);
        if(FALSE == NamePoolTestEqual(namePool, url, homeP))
            flags |= HTML_HIST_HOME;        /* home enabled if not already there */
        MemFree(homeH);
    }

    unresolved = @call self::MSG_URL_DOCUMENT_TEST_UNRESOLVED_IMAGES();

    pself = ObjDerefGen(oself);
    flags |= ( (pself->UDCI_historyHead != pself->UDCI_historyTail) ?
               HTML_HIST_BACK: 0)
           | ( (pself->UDCI_historyForward) ?
               HTML_HIST_FORWARD: 0)
           | ( (url != NAME_POOL_NONE) ?
               HTML_HIST_CURRENT: 0)
           | ( unresolved ?
               HTML_HIST_LOAD_GR: 0);

    if(url != NAME_POOL_NONE)
        NamePoolReleaseToken(namePool, url);

    return flags;
}

@method URLDocumentClass, MSG_URL_DOCUMENT_NOTIFY_FRAME_CHANGE_POST
{
    optr frameSet;
    optr frame = pself->UDCI_topFrame;
    WordFlags flags;

    if(dir!=DIR_RELOAD && dir!=DIR_SOURCE && dir!=DIR_SAVE)
    {                                   /* changed anything important? */
        HWChecksumCheck() ;

        /* create a second frame set for the LRU history stack */
        // TBD: it would probably be better to use a refrence-count based
        // scheme for frame sets.
        MemLock(frameCacheBlock);

        frameSet = ConstructOptr(frameCacheBlock,
            ChunkArrayCreate(frameCacheBlock, sizeof(HTMLframeRec), 0, 0));

        @call frame::MSG_URL_FRAME_COLLECT_FRAMES(frameSet, 0);

        @call self::MSG_URL_DOCUMENT_INT_UPDATE_LRU(frameSet);
        /* update list of recently used URLs */
        MemUnlock(frameCacheBlock);

        flags = @call self::MSG_URL_DOCUMENT_GET_STATE();
        @send process::MSG_HMLVP_NOTIFY_NAVIGATION_CHANGE(flags);

        HWChecksumCheck() ;
    }
}

@method URLDocumentClass, MSG_URL_DOCUMENT_NOTIFY_TOP_CHANGE
{
    NameToken tok;
    optr win;
    TCHAR buf[80];

@ifdef COMPILE_OPTION_MULTIPLE_WINDOWS
    win = @call self::MSG_GEN_DOCUMENT_GET_DISPLAY();
@else
    win = @HTMLVPrimary;
@endif
    if(win)
    {
        tok = title;                      /* window name based on title or URL */
        if(tok == NAME_POOL_NONE)
            tok = url;

        if(tok)                           /* got title or URL */
        {
            NamePoolCopy(namePool, buf, sizeof(buf), tok, NULL);
            @call win::MSG_GEN_REPLACE_VIS_MONIKER_TEXT(buf,
                VUM_DELAYED_VIA_APP_QUEUE);
        }
        else                              /* nothing that could serve as title */
        {
            @call win::MSG_GEN_REPLACE_VIS_MONIKER_OPTR(@Untitled,
                VUM_DELAYED_VIA_APP_QUEUE);
        }
    }

    /* notify application about the change */
    if(url != NAME_POOL_NONE)
        NamePoolUseToken(namePool, url);
    if(title != NAME_POOL_NONE)
        NamePoolUseToken(namePool, title);

    @send process::MSG_HMLVP_NOTIFY_TOP_CHANGE(url, title);
}

@method URLDocumentClass, MSG_META_GAINED_MODEL_EXCL
{
    NameToken url, title;
    WordFlags flags;

    HWChecksumCheck() ;

    /*  it took me two weeks to find out why the multi-document 
        mode was acting up when enabled. 
        the reason was this missing @callsuper.*/
    @callsuper();

    url = @call self::MSG_URL_DOCUMENT_GET_URL();
    title = @call self::MSG_URL_DOCUMENT_GET_TITLE();
    @send self::MSG_URL_DOCUMENT_NOTIFY_TOP_CHANGE(url, title); // calls MSG_HMLVP_NOTIFY_TOP_CHANGE

    flags = @call self::MSG_URL_DOCUMENT_GET_STATE();
    @send process::MSG_HMLVP_NOTIFY_NAVIGATION_CHANGE(flags);

@ifdef COMPILE_OPTION_LOCAL_PAGES
    @call self::MSG_URL_DOCUMENT_REQUEST_LOCAL_PAGE_NOTIFY();
@endif

    HWChecksumCheck() ;
}

@method URLDocumentClass, MSG_URL_DOCUMENT_INT_ADD_BACK_URL
{
    word prevTail;
    historyBufferData *historyBuffer;

    HWChecksumCheck() ;

    /* don't store if shouldn't */
    if (!pself->UDCI_allowHistory)
    return;

    prevTail = pself->UDCI_historyTail;
                                        /* store pointer to free entry */
    if(++pself->UDCI_historyTail == HTML_HISTORY)
        pself->UDCI_historyTail = 0;      /* advance tail, wrap if req'd */

    if(pself->UDCI_historyTail == pself->UDCI_historyHead)
    {                                   /* list full, must discard entry? */
        historyBuffer = LMemDerefHandles(OptrToHandle(oself),
                                         pself->UDCI_historyBuffer);

        /* release frame description */
        FreeArrayNameTokens(historyBuffer[pself->UDCI_historyTail].frameSet,
            namePool, TOKEN_FIELDS_FRAME_REC);
        LMemFree(historyBuffer[pself->UDCI_historyTail].frameSet);

        pself = ObjDerefGen(oself);
        if(++pself->UDCI_historyHead==HTML_HISTORY)
            pself->UDCI_historyHead = 0;    /* advance head, wrap if req'd */
    }

    historyBuffer = LMemDerefHandles(OptrToHandle(oself),
                                     pself->UDCI_historyBuffer);
    historyBuffer[prevTail].frameSet = frameSet;
}

@method URLDocumentClass, MSG_URL_DOCUMENT_INT_ADD_FORWARD_URL
{
    historyBufferData *forwardBuffer;

    HWChecksumCheck() ;

    /* don't store if shouldn't */
    if (!pself->UDCI_allowHistory)
    return;

    if(pself->UDCI_historyForward < HTML_HISTORY)
    {                                   /* have URL and room in fwd buffer? */
        forwardBuffer = LMemDerefHandles(OptrToHandle(oself),
                                         pself->UDCI_forwardBuffer);
        forwardBuffer[pself->UDCI_historyForward++].frameSet = frameSet;
    }
}

@method URLDocumentClass, MSG_URL_DOCUMENT_INT_DROP_FORWARD
{
    word n;
    historyBufferData *forwardBuffer;
    ChunkHandle forwardChunk;

    forwardChunk = pself->UDCI_forwardBuffer;
    n = pself->UDCI_historyForward;
    pself->UDCI_historyForward = 0;      /* no more entries in fwd buffer */

    while(n>0)
    {
        HWChecksumCheck() ;
        forwardBuffer = LMemDerefHandles(OptrToHandle(oself), forwardChunk);

        /* release frame description */
        FreeArrayNameTokens(forwardBuffer[--n].frameSet, namePool,
            TOKEN_FIELDS_FRAME_REC);
        LMemFree(forwardBuffer[n].frameSet);
    }
}

@method URLDocumentClass, MSG_URL_DOCUMENT_INT_DROP_BACK
{
    word n1, n2;
    historyBufferData *historyBuffer;
    ChunkHandle historyChunk;

    historyChunk = pself->UDCI_historyBuffer;
    n1 = pself->UDCI_historyHead;
    n2 = pself->UDCI_historyTail;
    pself->UDCI_historyHead = pself->UDCI_historyTail = 0;
                                        /* no more entries in history buffer */
    while(n1 != n2)
    {
        HWChecksumCheck() ;
        historyBuffer = LMemDerefHandles(OptrToHandle(oself), historyChunk);

        /* release frame description */
        FreeArrayNameTokens(historyBuffer[n1].frameSet, namePool,
            TOKEN_FIELDS_FRAME_REC);
        LMemFree(historyBuffer[n1].frameSet);

        if(++n1 == HTML_HISTORY)          /* advance head, wrap if req'd */
            n1 = 0;
    }
}

@method URLDocumentClass, MSG_URL_DOCUMENT_INT_UPDATE_LRU
{
    NameToken tok;

    /* don't store if shouldn't */
    if (!pself->UDCI_allowHistory)
        return;

    tok = @call self::MSG_URL_DOCUMENT_GET_TITLE();
    if(tok == NAME_POOL_NONE)
        tok = @call self::MSG_URL_DOCUMENT_GET_URL();

    if(tok != NAME_POOL_NONE)
    {
        HistoryUpdateLRU(frameSet, tok);
        NamePoolReleaseToken(namePool, tok);
    }
}

/*
 *  Go forward, undoing the last "back" step.
 */
@method URLDocumentClass, MSG_URL_DOCUMENT_FORWARD
{
    optr frameSet;
    historyBufferData *forwardBuffer;

    if(!pself->UDCI_historyForward)     /* can't go forward - do nothing */
    {
@ifdef DO_ERROR_CHECKING
        @StartOperation();                /* perform dummy operation for Auto */
        @EndOperation();
@endif
        return 0;
    }

    forwardBuffer = LMemDerefHandles(OptrToHandle(oself), 
                                     pself->UDCI_forwardBuffer);
    frameSet = LMemDup(forwardBuffer[--pself->UDCI_historyForward].frameSet);
    /* get state from buffer */

    HWChecksumCheck() ;
    /* clear mod state so we'll update URL with current page */
    @call CurrentURLText::MSG_VIS_TEXT_SET_NOT_USER_MODIFIED();
    @call self::MSG_URL_DOCUMENT_LOAD_FRAME_SET(frameSet, DIR_FORWARD);
    return 0;
}

/*
 *  Go back to previous URL in history list and drop it from the list.
 */
@method URLDocumentClass, MSG_URL_DOCUMENT_BACK
{
    optr frameSet;
    historyBufferData *historyBuffer;

    if(pself->UDCI_historyHead == pself->UDCI_historyTail)
    {
@ifdef DO_ERROR_CHECKING
        @StartOperation();                /* perform dummy operation for Auto */
        @EndOperation();
@endif
      return 0;                         /* can't go back - do nothing */
    }

    if(--(pself->UDCI_historyTail)==0xFFFF)
        pself->UDCI_historyTail = HTML_HISTORY-1;
    /* move back tail, wrap if req'd */
    historyBuffer = LMemDerefHandles(OptrToHandle(oself),
                                     pself->UDCI_historyBuffer);
    frameSet = LMemDup(historyBuffer[pself->UDCI_historyTail].frameSet);
    /* get state from buffer */

    HWChecksumCheck() ;
    /* clear mod state so we'll update URL with current page */
    @call CurrentURLText::MSG_VIS_TEXT_SET_NOT_USER_MODIFIED();
    @call self::MSG_URL_DOCUMENT_LOAD_FRAME_SET(frameSet, DIR_BACK);
    return 0;
}

@method URLDocumentClass, MSG_URL_DOCUMENT_NOTIFY_FRAME_CHANGE_PRE
{
    NameToken oldURL;
    optr frame = pself->UDCI_topFrame;
    optr frameSet;
    WordFlags flags;

    if(dir==DIR_RELOAD || dir==DIR_SOURCE || dir==DIR_SAVE || dir==DIR_FRAME
        || dir == DIR_FRAME_FORCE_RELOAD)
    return;                           /* didn't really change anything... */

    oldURL = @call self::MSG_URL_DOCUMENT_GET_URL();

    HWChecksumCheck() ;
    if(oldURL != NAME_POOL_NONE)
    {
        NamePoolReleaseToken(namePool, oldURL);

        /* create frame set for back/forward stacks */
        frameSet = ConstructOptr(OptrToHandle(oself),
            ChunkArrayCreate(OptrToHandle(oself), sizeof(HTMLframeRec), 0, 0));

        @call frame::MSG_URL_FRAME_COLLECT_FRAMES(frameSet, 0);

        if(dir==DIR_BACK)                 /* going back? */
            @call self::MSG_URL_DOCUMENT_INT_ADD_FORWARD_URL(frameSet);
                                          /* add current URL to "forward" list */
        else                              /* going forward: */
        {
            if(dir==DIR_ABSOLUTE || dir==DIR_GO || dir==DIR_ABSOLUTE_GO)
                                            /* moving freely: forward useless */
            @call self::MSG_URL_DOCUMENT_INT_DROP_FORWARD();
            @call self::MSG_URL_DOCUMENT_INT_ADD_BACK_URL(frameSet);
        }

        /* create a second frame set for the LRU history stack */
        // TBD: it would probably be better to use a refrence-count based
        // scheme for frame sets.
        MemLock(frameCacheBlock);
        frameSet = ConstructOptr(frameCacheBlock,
            ChunkArrayCreate(frameCacheBlock, sizeof(HTMLframeRec), 0, 0));

        @call frame::MSG_URL_FRAME_COLLECT_FRAMES(frameSet, 0);

        @call self::MSG_URL_DOCUMENT_INT_UPDATE_LRU(frameSet);
                                        /* update list of recently used URLs */
        MemUnlock(frameCacheBlock);

        flags = @call self::MSG_URL_DOCUMENT_GET_STATE();
        @send process::MSG_HMLVP_NOTIFY_NAVIGATION_CHANGE(flags);
    }
}

/*
   Note: the passed URL name token is freed by the message handler. This
   allows it to be *sent* rather than just called.
 */
@method URLDocumentClass, MSG_URL_DOCUMENT_LOAD_URL
{
    MemHandle urlB;
    TCHAR *urlP;
    optr frame = pself->UDCI_topFrame;
    int urlLen;
@ifdef COMPILE_OPTION_DOWNLOAD_PROGRESS_DIALOG
    extern Boolean G_allowFileDownloadStatus;
@endif

    if (!((@call application::MSG_GEN_APPLICATION_GET_STATE())&AS_QUITTING)) {
        HWChecksumCheck() ;
        @AbortOperation(FALSE, TRUE, 0);  /* stop current page load, first */
        @call oself::MSG_URL_DOCUMENT_STOP(0) ;
@ifdef COMPILE_OPTION_DOWNLOAD_PROGRESS_DIALOG
        /* allow file download progress dialog (from URL entry field, history,
           favorites, external request, etc.) */
        G_allowFileDownloadStatus = TRUE;
@endif
        /* show new URL in URL input field while loading */
        urlLen = NamePoolStrLength(namePool, url)+1;
        urlB = MemAlloc(urlLen*sizeof(TCHAR), HF_DYNAMIC, HAF_STANDARD);
        if (urlB) {
            urlP = MemLock(urlB);
            NamePoolCopy(namePool, urlP, urlLen*sizeof(TCHAR), url, 0);
            @call CurrentURLText::MSG_VIS_TEXT_REPLACE_ALL_PTR(urlP, 0);
            MemFree(urlB);
        }
        @call frame::MSG_URL_FRAME_FETCH_URL(url, dir, NullHandle, NAME_POOL_NONE);

        HWChecksumCheck() ;
        NamePoolReleaseToken(namePool, url);
        HWChecksumCheck() ;
    }
}

@method URLDocumentClass, MSG_URL_DOCUMENT_LOAD_FRAME_SET
{
    optr frame = pself->UDCI_topFrame;

    HWChecksumCheck() ;
    @AbortOperation(FALSE, TRUE, 0);  /* stop current page load, first */
    @call oself::MSG_URL_DOCUMENT_STOP(0) ;
    /* load frame set into topmost frame */
    ObjLockObjBlock(OptrToHandle(frameArray));
    @call frame::MSG_URL_FRAME_FETCH_FRAMES(frameArray, dir);
    LMemFree(frameArray);
    MemUnlock(OptrToHandle(frameArray));
    HWChecksumCheck() ;
}

/*
 *  Update visual representation of current frame tree
 *
 *  jfh 3/13/03 - pulled the ifndef DRAG_COPY stuff since it was
 *	               keeping pages from printing, and it didn't hurt
 *                the drag & drop capability
 */
@method URLDocumentClass, MSG_URL_DOCUMENT_UPDATE_FRAME_UI
{
    optr focusOptr = NullOptr;
    @call (pself->UDCI_topFrame)::MSG_URL_FRAME_UPDATE_FRAME_UI(&focusOptr);
/*@ifndef COMPILE_OPTION_DRAG_COPY_WEB_PAGES  */
    if (focusOptr) {
        @send focusOptr::MSG_META_GRAB_FOCUS_EXCL();
        @send focusOptr::MSG_META_GRAB_TARGET_EXCL();
    }
/*@endif */
@ifdef JAVASCRIPT_SUPPORT
    /* update window.open frames, we do this even if not open since we
       could have just closed it and replaced the frames with about:blank,
       though the focus grabbing is only if the window is open */
    @call WindowOpenFrame::MSG_URL_FRAME_UPDATE_FRAME_UI(&focusOptr);
/*@ifndef COMPILE_OPTION_DRAG_COPY_WEB_PAGES  */
    if (@call WindowOpenWindow::MSG_VIS_GET_ATTRS() & VA_VISIBLE) {
        if (focusOptr) {
            @send focusOptr::MSG_META_GRAB_FOCUS_EXCL();
            @send focusOptr::MSG_META_GRAB_TARGET_EXCL();
        }
    }
/*@endif */
@endif
@ifdef GLOBAL_INTERNET_BUILD
    if (@call HelpWindow::MSG_VIS_GET_ATTRS() & VA_VISIBLE) {
        @call HelpFrame::MSG_URL_FRAME_UPDATE_FRAME_UI(&focusOptr);
/*@ifndef COMPILE_OPTION_DRAG_COPY_WEB_PAGES */
        if (focusOptr) {
            @send focusOptr::MSG_META_GRAB_FOCUS_EXCL();
            @send focusOptr::MSG_META_GRAB_TARGET_EXCL();
        }
/*@endif */
    }
@endif
}

/*
 *  Attempt to reload current document
 */
@method URLDocumentClass, MSG_URL_DOCUMENT_RELOAD
{
    HWChecksumCheck() ;
    @AbortOperation(FALSE, TRUE, 0);  /* stop current page load, first */
    @call oself::MSG_URL_DOCUMENT_STOP(0) ;
    /* clear mod state so we'll update URL with current page */
    @call CurrentURLText::MSG_VIS_TEXT_SET_NOT_USER_MODIFIED();
    @call (pself->UDCI_topFrame)::MSG_URL_FRAME_RELOAD();
@ifdef GLOBAL_INTERNET_BUILD
    if (@call HelpWindow::MSG_VIS_GET_ATTRS() & VA_VISIBLE) {
        @call HelpFrame::MSG_URL_FRAME_RELOAD();
    }
@endif
@ifdef JAVASCRIPT_SUPPORT
    if (@call WindowOpenWindow::MSG_VIS_GET_ATTRS() & VA_VISIBLE) {
        @call WindowOpenFrame::MSG_URL_FRAME_RELOAD();
    }
@endif
    HWChecksumCheck() ;
}

/*
 *  Attempt to reload current document and view as Source
 */
@method URLDocumentClass, MSG_URL_DOCUMENT_SOURCE
{
    HWChecksumCheck() ;
    @call (pself->UDCI_topFrame)::MSG_URL_FRAME_SOURCE();
    HWChecksumCheck() ;
}

/*
 *  Attempt to reload current document and save to file
 */
@method URLDocumentClass, MSG_URL_DOCUMENT_SAVE
{
    HWChecksumCheck() ;
    @call (pself->UDCI_topFrame)::MSG_URL_FRAME_SAVE();
    HWChecksumCheck() ;
}

/*
 *  Load missing images
 */
@method URLDocumentClass, MSG_URL_DOCUMENT_LOAD_GRAPHICS
{
    HWChecksumCheck() ;
    @call (pself->UDCI_topFrame)::MSG_URL_FRAME_LOAD_GRAPHICS();
    HWChecksumCheck() ;
}

@method URLDocumentClass, MSG_URL_DOCUMENT_GET_TOP_FRAME
{
    HWChecksumCheck() ;
    return pself->UDCI_topFrame;
}

@method URLDocumentClass, MSG_URL_DOCUMENT_ALLOW_HISTORY
{
    pself->UDCI_allowHistory = TRUE;
}

@method URLDocumentClass, MSG_URL_DOCUMENT_DISALLOW_HISTORY
{
    pself->UDCI_allowHistory = FALSE;
}

@method URLDocumentClass, MSG_URL_DOCUMENT_MAKE_NEW_HOME
{
    NameToken url;
    TCHAR buf[HTML_STATIC_BUF],*p;
    WordFlags flags;

    HWChecksumCheck() ;

    url = @call self::MSG_URL_DOCUMENT_GET_URL();
    if(url != NAME_POOL_NONE)      /* currently showing URL? */
    {
        NamePoolCopy(namePool, buf, sizeof(buf), url, &p);
                                        /* save as new home page */
        NavigateSetHome(p);               /* set home URL */
        NamePoolDestroyIfDynamic(p);      /* release dynamic buffer, if any */
        NamePoolReleaseToken(namePool, url);

        HWChecksumCheck() ;

        flags = @call self::MSG_URL_DOCUMENT_GET_STATE();
        @send process::MSG_HMLVP_NOTIFY_NAVIGATION_CHANGE(flags);

        HWChecksumCheck() ;
    }
}

@ifdef COMPILE_OPTION_BOOKMARKS

@method URLDocumentClass, MSG_URL_DOCUMENT_ADD_BOOKMARK
{
    NameToken url,title;
    TCHAR urlString[HTML_STATIC_BUF], *uP ;
    TCHAR titleString[HTML_STATIC_BUF], *tP ;

    HWChecksumCheck() ;
    url = @call self::MSG_URL_DOCUMENT_GET_URL();
    title = @call self::MSG_URL_DOCUMENT_GET_TITLE();

    if (url != NAME_POOL_NONE)
    {
        /* Get the URL and title for the bookmark */
        NamePoolCopy(namePool, urlString, sizeof(urlString), url, &uP);
        NamePoolCopy(namePool, titleString, sizeof(titleString),
            title?title:url, &tP);

        /* Add a new bookmark */
        BookmarkAppend(tP, uP) ;

        NamePoolDestroyIfDynamic(tP);
        NamePoolDestroyIfDynamic(uP);

        /* Rebuild the menu */
        BookmarksBuildUIList(@BookmarkTriggerList) ;

        /* Note that another item has been added to the list */
        @call BookmarksDynamicList::MSG_GEN_DYNAMIC_LIST_ADD_ITEMS(GDLP_LAST, 1) ;

        NamePoolReleaseToken(namePool, url) ;
    }

    if (title != NAME_POOL_NONE)
        NamePoolReleaseToken(namePool, title) ;

    HWChecksumCheck() ;
}

@method URLDocumentClass, MSG_URL_DOCUMENT_GO_TO_BOOKMARK
{
    TCHAR *p_title ;
    TCHAR *p_location ;
    NameToken url ;

    /* Get the bookmark we are going to go to */
    p_title = BookmarkLock(bookmarkNum, &p_location) ;
    if (p_title)  {
        url = NamePoolTokenize(namePool, p_location, TRUE);
        BookmarkUnlock(p_title) ;

        HWChecksumCheck() ;
        /* Put in a request to go to that url location */
        @send ,forceQueue oself::MSG_URL_DOCUMENT_LOAD_URL(url, DIR_GO) ;
    }
}

@endif

@ifdef COMPILE_OPTION_FAVORITES

@method URLDocumentClass, MSG_URL_DOCUMENT_GO_TO_FAVORITE
{
    NameToken url ;
    T_lockedFavorite *p_favorite = NULL ;
    word i ;
    dword pos ;
    dword count ;

    /* Get the favorite we are going to go to */
    if (!useAll && FavoriteCountTopTen())  {
        p_favorite = FavoriteLockTopEntry(favoriteNum) ;
    } else  {
        /* Find the nth non-folder */
        count = FavoritesGetCount() ;
        for (i=0, pos=0; pos<count; pos++)
            if (!FavoriteIsFolder(pos))
                if (i++ >= favoriteNum)
                    break ;

        /* Lock what we found */
        if (pos < count)
            p_favorite = FavoriteLock(pos) ;
    }
    if (p_favorite)  {
        url = NamePoolTokenize(namePool, p_favorite->p_location, TRUE);
        FavoriteUnlock(p_favorite) ;

        HWChecksumCheck() ;
        /* Put in a request to go to that url location */
        @send ,forceQueue oself::MSG_URL_DOCUMENT_LOAD_URL(url, DIR_GO) ;
    }
}

@endif

@method URLDocumentClass, MSG_URL_DOCUMENT_RECALCULATE
{
    /* have the top frame recalculate itself and all its */
    /* children */
    HWChecksumCheck() ;
    @call (pself->UDCI_topFrame)::MSG_URL_FRAME_RECALCULATE() ;
    HWChecksumCheck() ;
}

@method URLDocumentClass, MSG_URL_DOCUMENT_STOP
{
    if (frame) {
        @call frame::MSG_URL_FRAME_STOP() ;
    } else {
        @call (pself->UDCI_topFrame)::MSG_URL_FRAME_STOP() ;
    }
}

@method URLDocumentClass, MSG_URL_DOCUMENT_TEST_UNRESOLVED_IMAGES
{
    Boolean ret;

    /* have the top frame check for unresolved images in itself and all its */
    /* children */
    HWChecksumCheck() ;
    ret = @call (pself->UDCI_topFrame)::MSG_URL_FRAME_TEST_UNRESOLVED_IMAGES() ;
    HWChecksumCheck() ;

    return ret;
}

@method URLDocumentClass, MSG_URL_DOCUMENT_GET_URL
{
    NameToken ret;

    /* get "document URL", defined as the URL loaded in the top frame */
    HWChecksumCheck() ;
    ret = @call (pself->UDCI_topFrame)::MSG_URL_FRAME_GET_URL() ;
    HWChecksumCheck() ;

    return ret;
}

@method URLDocumentClass, MSG_URL_DOCUMENT_GET_TITLE
{
    NameToken ret;

    /* get "document title", defined as that of the page in the top frame */
    HWChecksumCheck() ;
    ret = @call (pself->UDCI_topFrame)::MSG_URL_FRAME_GET_TITLE() ;
    HWChecksumCheck() ;

    return ret;
}

@method URLDocumentClass, MSG_URL_DOCUMENT_INC_PENDING
{
    if (pself->UDCI_numPendingFrames++ == 0)
        @StartOperation() ;
    EC_ERROR_IF(pself->UDCI_numPendingFrames >= MAX_NUM_REQUESTS, -1) ;
}

@method URLDocumentClass, MSG_URL_DOCUMENT_DEC_PENDING
{
    pself->UDCI_numPendingFrames-- ;
    EC_ERROR_IF(pself->UDCI_numPendingFrames >= MAX_NUM_REQUESTS, -1) ;

    if (pself->UDCI_numPendingFrames == 0)
    {
        /* Inform the frame that we are done. */
        @send self::MSG_URL_DOCUMENT_NOTIFY_DOCUMENT_COMPLETE();

        @EndOperation() ;
    }
}

@method URLDocumentClass, MSG_URL_DOCUMENT_NOTIFY_DOCUMENT_COMPLETE
{
    WordFlags flags;
@ifdef COMPILE_OPTION_LOCAL_PAGES
    FileLongName saveFile;
@endif

    HWChecksumCheck() ;

@ifdef JAVASCRIPT_SUPPORT
     /* ensure script context for all frames, if anyone has JS */
     if (pself->UDCI_haveJS) {
        @call (pself->UDCI_topFrame)::MSG_URL_FRAME_ENSURE_SCRIPT_CONTEXT();
     }
     pself->UDCI_haveJS = FALSE;  /* clear for next time */
@endif

    flags = @call self::MSG_URL_DOCUMENT_GET_STATE();
    @send process::MSG_HMLVP_NOTIFY_NAVIGATION_CHANGE(flags);

@ifdef COMPILE_OPTION_SECURE_STATUS
     /* update secure status at end of operation */
     @send (pself->UDCI_topFrame)::MSG_URL_FRAME_UPDATE_SECURE_ICON(
        NAME_POOL_NONE);
@endif

@ifdef COMPILE_OPTION_LOCAL_PAGES
    HWChecksumCheck() ;

    /* Pending update of local page? Save it now as everything has come in. */
    pself = ObjDerefGen(oself);
    if(pself->UDCI_localPage && pself->UDCI_updatingLocal)
    {
      /* Done updating - save to file. */
      pself->UDCI_updatingLocal = FALSE;

      NamePoolCopy(namePool, saveFile, sizeof(saveFile), pself->UDCI_localPage,
        NULL);
      @call self::MSG_URL_DOCUMENT_STORE_TO_FILENAME(saveFile);
    }
@endif

    /* flush any URL driver data */
    FlushURLData();

    HWChecksumCheck() ;

    /* Commit source cache */
    SrcCacheCommit();

    HWChecksumCheck() ;
}

@ifdef COMPILE_OPTION_PARENTAL_CONTROL

@method URLDocumentClass, MSG_URL_DOCUMENT_PC_ADD_SITE
{
    ParentalControlFlags pcFlags = 0;
    AccessFlags access;

    access = ParentalControlGetAccessInfo();
    /* if full access, no password; if not bypassed, require password */
    if (((access & AF_WWWBROWSING) || (access & AF_WWWLIMITED)) &&
    !G_pcBypassed) {
        pcFlags |= PCF_REQUIRE_PASSWORD;
    }
    /* forward to top frame */
    ParentalControlEnsureOpenData();
    @call (pself->UDCI_topFrame)::MSG_URL_FRAME_PC_ADD_SITE(&pcFlags);
    ParentalControlCloseData();
    if (!(pcFlags & PCF_ADDED_SITE) && !(pcFlags & PCF_ABORT_PASSWORD)) {
        /* didn't add anything, report it */
        @send PCSiteAlreadyAddedDlg::MSG_GEN_INTERACTION_INITIATE();
    }
}

@method URLDocumentClass, MSG_URL_DOCUMENT_PC_REMOVE_SITE
{
    ParentalControlFlags pcFlags = 0;
    AccessFlags access;

    access = ParentalControlGetAccessInfo();
    /* if full access, no password; if not bypassed, require password */
    if (((access & AF_WWWBROWSING) || (access & AF_WWWLIMITED)) &&
    !G_pcBypassed) {
        pcFlags |= PCF_REQUIRE_PASSWORD;
    }
    /* forward to top frame */
    ParentalControlEnsureOpenData();
    @call (pself->UDCI_topFrame)::MSG_URL_FRAME_PC_REMOVE_SITE(&pcFlags);
    ParentalControlCloseData();
    if (!(pcFlags & PCF_REMOVED_SITE) && !(pcFlags & PCF_ABORT_PASSWORD)) {
        /* didn't remove anything, report it */
        @send PCSiteNotInListDlg::MSG_GEN_INTERACTION_INITIATE();
    }
}

@endif

@method URLDocumentClass, MSG_PRINT_GET_DOC_NAME
{
    EventHandle evt;
    NameToken url;
    optr display;

    url = @call self::MSG_URL_DOCUMENT_GET_URL();

    if(url != NAME_POOL_NONE)           // Do we have a page loaded?
    {
        NamePoolReleaseToken(namePool, url);

        /* forward this message to the targeted frame */
        display = @call self::MSG_GEN_DOCUMENT_GET_DISPLAY();
        evt = @record VisTextClass::MSG_PRINT_GET_DOC_NAME(printCtrlOD);
        @send display::MSG_META_SEND_CLASSED_EVENT(evt, TO_TARGET);
    }
}

@method URLDocumentClass, MSG_PRINT_START_PRINTING
{
    EventHandle evt;
    NameToken url;
    optr display;

    url = @call self::MSG_URL_DOCUMENT_GET_URL();

    if(url != NAME_POOL_NONE)           // Do we have a page loaded?
    {
        NamePoolReleaseToken(namePool, url);

        /* forward this message to the targeted frame */
        display = @call self::MSG_GEN_DOCUMENT_GET_DISPLAY();
        evt = @record VisTextClass::MSG_PRINT_START_PRINTING(printCtrlOD, gstate);
        @send display::MSG_META_SEND_CLASSED_EVENT(evt, TO_TARGET);
    }
}

@method URLDocumentClass, MSG_PRINT_NOTIFY_PRINT_DB
{
    EventHandle evt;
    NameToken url;
    optr display;

    if(pcs==PCS_PRINT_BOX_VISIBLE)      // Updating print box when it comes up?
    {
        url = @call self::MSG_URL_DOCUMENT_GET_URL();

        if(url != NAME_POOL_NONE)         // Do we have a page loaded?
        {
            NamePoolReleaseToken(namePool, url);

            /* forward this message to the targeted frame */
            display = @call self::MSG_GEN_DOCUMENT_GET_DISPLAY();
            evt = @record VisTextClass::MSG_PRINT_NOTIFY_PRINT_DB(printCtrlOD, pcs);
            @send display::MSG_META_SEND_CLASSED_EVENT(evt, TO_TARGET);
        }
    }
}

@ifdef JAVASCRIPT_SUPPORT
@method URLDocumentClass, MSG_URL_DOCUMENT_SET_JS_ERROR
{
    pself->UDCI_jsError = state;
}

@method URLDocumentClass, MSG_URL_DOCUMENT_GET_JS_ERROR
{
    return(pself->UDCI_jsError);
}

/*
 *  Clear document's frames from object cache.
 */
@method URLDocumentClass, MSG_URL_DOCUMENT_CLEAR_OBJ_CACHE
{
    HWChecksumCheck() ;
    @call (pself->UDCI_topFrame)::MSG_URL_FRAME_CLEAR_OBJ_CACHE();
    HWChecksumCheck() ;
}

/*
 *  Set JS flag.
 */
@method URLDocumentClass, MSG_URL_DOCUMENT_SET_JS
{
    pself->UDCI_haveJS = TRUE;
}

/*
 *  Ensure all frames have script context initialized.
 */
@method URLDocumentClass, MSG_URL_DOCUMENT_ENSURE_SCRIPT_CONTEXT
{
    @call (pself->UDCI_topFrame)::MSG_URL_FRAME_ENSURE_SCRIPT_CONTEXT();
@ifdef GLOBAL_INTERNET_BUILD
    if (@call HelpWindow::MSG_VIS_GET_ATTRS() & VA_VISIBLE) {
        @call HelpFrame::MSG_URL_FRAME_ENSURE_SCRIPT_CONTEXT();
    }
@endif
@ifdef JAVASCRIPT_SUPPORT
    if (@call WindowOpenWindow::MSG_VIS_GET_ATTRS() & VA_VISIBLE) {
        @call WindowOpenFrame::MSG_URL_FRAME_ENSURE_SCRIPT_CONTEXT();
    }
@endif
}

@endif
