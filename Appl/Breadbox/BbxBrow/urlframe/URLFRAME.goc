/*
 *                          ==CONFIDENTIAL INFORMATION==
 *
 * COPYRIGHT 1994-99 BREADBOX COMPUTER COMPANY -- ALL RIGHTS RESERVED  --
 * THE FOLLOWING CONFIDENTIAL INFORMATION IS BEING DISCLOSED TO YOU UNDER
 * A NON-DISCLOSURE AGREEMENT AND MAY NOT BE DISCLOSED OR FORWARDED BY THE
 * RECIPIENT TO ANY OTHER PERSON OR ENTITY NOT COVERED BY THE SAME
 * NON-DISCLOSURE AGREEMENT COVERING THE RECIPIENT. USE OF THE FOLLOWING
 * CONFIDENTIAL INFORMATION IS RESTRICTED TO THE TERMS OF THE NON-DISCLOSURE
 * AGREEMENT.
 *
 */
/***********************************************************************
 *
 * PROJECT:       HTMLView
 * FILE:          URLFrame.goc
 *
 * AUTHOR:        Marcus Grï¿½ber
 *
 ***********************************************************************/

/**************************************************************************
 *        Include files
 **************************************************************************/

@include <stdapp.goh>
#include <geoMisc.h>                    /* various unix-like goodies */
#include <initfile.h>

#include <Ansi/string.h>
#include <Ansi/stdio.h>
#include <Ansi/stdlib.h>

@include <fixes.goh>

@include "htmlview.goh"
#include "javascr.h"

/* When replacing an existing frame with a frame/frameset loaded into it,
   these flags are determined by the newly loaded frameset, while all other
   attributes remain those that have been defined in the <frame> tag. */
#define FRF_FLAGS_FROM_CHILD (HTML_FRF_FRAMESET | HTML_FRF_COLS)


@ifdef COMPILE_OPTION_PARENTAL_CONTROL
@include <parentc.goh>
@endif


@extern object HTMLVApp;        // for @AbortOperation()
@extern object HTMLDocumentGroup;

@ifdef GLOBAL_INTERNET_BUILD
@extern object HelpWindow;
@extern object HelpFrame;
@extern chunk HelpWindowMoniker;
@endif

@ifdef JAVASCRIPT_SUPPORT
@extern object WindowOpenWindow;
@extern object WindowOpenFrame;
@extern object WindowOpenTop;
@endif

@ifdef COMPILE_OPTION_PARENTAL_CONTROL
@extern object PCRoot;
@endif

@ifdef COMPILE_OPTION_SECURE_STATUS
@extern object SecureStatus;
@extern object SecureStatusOnMoniker;
@extern object SecureStatusOffMoniker;
@extern object SecureStatusOnHelp;
@extern object SecureStatusOffHelp;
@endif

@extern object URLText;
@extern object URLContent;
@extern object ViewGroupTemplate;
@extern object ViewTemplate;
@extern object FrameTemplate;

@extern object NavigateLoadGraphics;

@extern object CurrentURLText;

@extern object HTMLSettingsBoolGroup;


/* abort handling */
extern Boolean UserAbortCheck(void);
extern void UserAbortEnd(void);

@ifdef POST_DATA_CACHE
extern MemHandle PostDataCacheFind(NameToken url);
@endif

@ifdef CHECK_ISP
extern Boolean CheckConnected(void);
@endif

@ifdef JAVASCRIPT_SUPPORT
extern jseVariable globalObject;
@endif

/***************************************************************************
 *              URL Frame Class
 ***************************************************************************/

@classdecl URLFrameClass;

/* Implemeted in FRFETCH.GOC */
@extern method URLFrameClass, MSG_URL_FRAME_REQUEST_URL;
@extern method URLFrameClass, MSG_URL_FRAME_URL_FETCHED;
#if EMBED_SUPPORT
@extern method URLFrameClass, MSG_URL_FRAME_EMBED_FETCHED;
#endif
@extern method URLFrameClass, MSG_URL_FRAME_GOT_URL;
@extern method URLFrameClass, MSG_URL_FRAME_LOADING_FINISHED;
@extern method URLFrameClass, MSG_URL_FRAME_GOT_PAGE_NOFRAME;
@extern method URLFrameClass, MSG_URL_FRAME_GET_COMPUTED_DIMENSION_PIXELS;
@extern method URLFrameClass, MSG_URL_FRAME_UPDATE_FRAME_UI;
@ifdef JAVASCRIPT_SUPPORT
@extern method URLFrameClass, MSG_URL_FRAME_INTERPRET_SCRIPT_HA_DURING_PARSING;
@extern method URLFrameClass, MSG_URL_FRAME_ADD_SCRIPT_SRC;
@extern method URLFrameClass, MSG_URL_FRAME_FLUSH_SCRIPT_SRC;
@endif
@extern method URLFrameClass, MSG_URL_FRAME_REQUIRE_EXT_FILE;
@extern method URLFrameClass, MSG_URL_FRAME_RELEASE_EXT_FILES;
@extern method URLFrameClass, MSG_URL_FRAME_EXT_FILE_FETCHED;


@method URLFrameClass, MSG_URL_FRAME_CREATE_CHILD
{
    MemHandle textBlock, frameBlock, viewBlock;
    optr textObj, frameObj, viewObj;
    optr interactionObj, contObj, docObj;
    MemHandle uiThread;

    // create text
    textBlock = ObjDuplicateResource(OptrToHandle(@URLText), 0, 0);
    textObj = ConstructOptr(textBlock, OptrToChunk(@URLText));
    // create frame
    frameBlock = ObjDuplicateResource(OptrToHandle(@FrameTemplate), 0, 0);
    frameObj = ConstructOptr(frameBlock, OptrToChunk(@FrameTemplate));
    // point frame to document object
    @call HTMLDocumentGroup::MSG_META_GET_MODEL_EXCL(&docObj);
    @send frameObj::MSG_URL_FRAME_SET_DOCUMENT_OBJ(docObj);
    // hook text object to frame and vice versa
    @send frameObj::MSG_URL_FRAME_SET_TEXT_OBJ(textObj);
    @send textObj::MSG_URL_TEXT_SET_FRAME_OBJ(frameObj);
    // Tell HTML Text object about the file to store its data in.
@ifdef GLOBAL_INTERNET_BUILD
    @send textObj::MSG_HTML_TEXT_INIT_STORAGE(textObjFile);
@else
    @send textObj::MSG_HTML_TEXT_INIT_STORAGE(cacheFile);
@endif
    @send textObj::MSG_VIS_NOTIFY_GEOMETRY_VALID();
@ifdef COMPILE_OPTION_PAGE_SIZE_CONTROL
    @send textObj::MSG_HTML_TEXT_SET_PAGE_SIZE_CONTROLLER(@PageSizeControl) ;
@endif
    // attach new frame as child
    ObjCompAddChild(oself, frameObj,
		    CCO_LAST,
		    0,
		    word_offsetof(URLFrameInstance, UFI_comp),
		    word_offsetof(URLFrameInstance, UFI_link));
    // create associated view
    uiThread = MemGetInfo(OptrToHandle(@HTMLVApp), MGIT_EXEC_THREAD);
    viewBlock = ObjDuplicateResource(OptrToHandle(@ViewTemplate), 0, uiThread);
    viewObj = ConstructOptr(viewBlock, OptrToChunk(@ViewTemplate));
    // attach to our associated interaction obj
    interactionObj = @call oself::MSG_URL_FRAME_GET_INTERACTION_OBJ();
    @call interactionObj::MSG_GEN_ADD_CHILD(viewObj, CCO_LAST);
    // hook view, content, and frame together
    contObj = ConstructOptr(OptrToHandle(textObj), OptrToChunk(@URLContent));
    @call viewObj::MSG_GEN_VIEW_SET_CONTENT(contObj);
    @call frameObj::MSG_URL_FRAME_SET_INTERACTION_OBJ(viewObj);
    @call textObj::MSG_HTML_TEXT_SET_VIEW_OBJ(viewObj);
}

@method URLFrameClass, MSG_URL_FRAME_CREATE_VIEW_GROUP
{
    optr viewObj, textObj, parentObj;
    word parentPos;
    MemHandle groupBlock;
    optr groupObj;
    MemHandle uiThread;

    textObj = @call self::MSG_URL_FRAME_GET_TEXT_OBJ();
    // all done if already a group
    if (textObj) {
	viewObj = @call self::MSG_URL_FRAME_GET_INTERACTION_OBJ();
	// unhook content object from view
	@call viewObj::MSG_GEN_VIEW_SET_CONTENT(NullOptr);
        // detach text object from the page it is showing
        @call self::MSG_URL_FRAME_FLIP_PAGE(OCT_NULL, FALSE);
	// unhook text object from frame
	@call self::MSG_URL_FRAME_SET_TEXT_OBJ(NullOptr);
	// free text object block
	@send, forceQueue textObj::MSG_URL_TEXT_SELF_DESTRUCT();
	// destroy current view
	parentObj = @call viewObj::MSG_GEN_FIND_PARENT();
	parentPos = @call parentObj::MSG_GEN_FIND_CHILD(viewObj);
	@send, forceQueue viewObj::MSG_GEN_DESTROY_AND_FREE_BLOCK();
	// create new one
	uiThread = MemGetInfo(OptrToHandle(@HTMLVApp), MGIT_EXEC_THREAD);
	groupBlock = ObjDuplicateResource(OptrToHandle(@ViewGroupTemplate), 0,
					  uiThread);
	groupObj = ConstructOptr(groupBlock, OptrToChunk(@ViewGroupTemplate));
	// set as interaction object
	@call parentObj::MSG_GEN_ADD_CHILD(groupObj, parentPos);
	@call groupObj::MSG_GEN_SET_USABLE(VUM_NOW);
	@call oself::MSG_URL_FRAME_SET_INTERACTION_OBJ(groupObj);
    }
}

@method URLFrameClass, MSG_URL_FRAME_DETACH_VIEW_CONTENT_TREE
{
    optr interactionObj;

    interactionObj = @call self::MSG_URL_FRAME_GET_INTERACTION_OBJ();
    if (interactionObj) {
	if (@call self::MSG_URL_FRAME_GET_TEXT_OBJ()) {
	    /* has text, interaction object is view */
	    @call interactionObj::MSG_GEN_VIEW_SET_CONTENT(NullOptr);
	} else {
	    /* has no text, interaction object is interaction */
	    @send @frameChildren::MSG_URL_FRAME_DETACH_VIEW_CONTENT_TREE();
	}
    }
}

@method URLFrameClass, MSG_URL_FRAME_DESTRUCT_TEXT_TREE
{
    optr textObj;

@ifdef JAVASCRIPT_SUPPORT
    /* get rid of these things */
    @call self::MSG_URL_FRAME_KILL_ALL_TIMEOUTS();
@endif

    textObj = @call self::MSG_URL_FRAME_GET_TEXT_OBJ();
    if (textObj) {

        @call self::MSG_URL_FRAME_FLIP_PAGE(OCT_NULL, FALSE);
	@call textObj::MSG_URL_TEXT_SELF_DESTRUCT();
    }
    @send @frameChildren::MSG_URL_FRAME_DESTRUCT_TEXT_TREE();
}

@method URLFrameClass, MSG_URL_FRAME_SET_TEXT_OBJ
{
    pself->UFI_text = textObject;
    HWChecksumCheck() ;
}

@method URLFrameClass, MSG_URL_FRAME_GET_TEXT_OBJ
{
    return pself->UFI_text;
}

@method URLFrameClass, MSG_URL_FRAME_SET_DOCUMENT_OBJ
{
    pself->UFI_document = documentObject;
}

@method URLFrameClass, MSG_URL_FRAME_GET_DOCUMENT_OBJ
{
    return pself->UFI_document;
}

@method URLFrameClass, MSG_URL_FRAME_SET_INTERACTION_OBJ
{
    pself->UFI_interaction = interactionObject;
    HWChecksumCheck() ;
}

@method URLFrameClass, MSG_URL_FRAME_GET_INTERACTION_OBJ
{
    return pself->UFI_interaction;
}

@method URLFrameClass, MSG_URL_FRAME_HANDLE_LINK
{
    optr parent, top, try, realSelf;
    optr doc = pself->UFI_document;
    TCHAR name[HTML_STATIC_BUF], *p;
    NameToken absURL;
    NameToken referer;
    word dirMode = DIR_ABSOLUTE;
    NameToken baseTarget = pself->UFI_baseTarget;
@ifdef COMPILE_OPTION_PROGRESS_INDICATOR
    extern Boolean G_progressStatus;
@ifdef COMPILE_OPTION_DOWNLOAD_PROGRESS_DIALOG
    extern Boolean G_allowFileDownloadStatus;
@endif
@endif

    HWChecksumCheck() ;

    /* This case should only occur for non-execute, i.e. preview requests: */
    if(link == NAME_POOL_NONE)          /* cursor off link? */
    {
      @CallStatusUpdate(_TEXT(""),
        HTML_STATUS_TYPE_URL_HIGHLIGHT);
      return;
    }

    /* back up through dummy levels */
    realSelf = @call self::MSG_URL_FRAME_FIND_REAL_FRAME();

    parent = @call realSelf::MSG_URL_FRAME_FIND_PARENT();
    top = @call doc::MSG_URL_DOCUMENT_GET_TOP_FRAME();

    EC_ERROR_IF(top==0, -1);            /* always the "last resort" target */

    if (target == NAME_POOL_NONE && baseTarget)
	target = baseTarget;

    if(target == NAME_POOL_NONE)        /* links to current frame */
    {
      try = realSelf;
    }
    else if(NamePoolTestEqualI(namePool, target, _TEXT("_self")))
    {
	try = realSelf;
    }
    else if(NamePoolTestEqualI(namePool, target, _TEXT("_parent")))
    {                                   /* link to parent */
      if(parent)
        try = parent;
      else
        try = top;
    }
    else if(NamePoolTestEqualI(namePool, target, _TEXT("_top")))
    {                                   /* link to top */
      try = top;                        /* only try top frame */
    }
@ifdef GLOBAL_INTERNET_BUILD
    else if(NamePoolTestEqualI(namePool, target, _TEXT("_help")))
    {
      try = @HelpFrame;
      /* attach help frame to our document for now */
      @call try::MSG_URL_FRAME_SET_DOCUMENT_OBJ(doc);
    }
@endif
    else
    {                                   /* any other links: check from top */
      try = @call top::MSG_URL_FRAME_FIND_TARGET_BY_TITLE(target);
@ifdef JAVASCRIPT_SUPPORT
      if (!try && @call WindowOpenWindow::MSG_VIS_GET_ATTRS() & VA_VISIBLE) {
	 try = @call WindowOpenFrame::MSG_URL_FRAME_FIND_TARGET_BY_TITLE(target);
      }
@endif

      // TBD: this should start a search for other windows with this name...
      if(!try) {                         /* top object must accept the reset */
        try = top;
      } else {
	dirMode = DIR_ABSOLUTE_GO;
      }
    }
    /* force reloading if loading a different frame */
    if (try != oself && try != realSelf) {
	dirMode = DIR_CROSS_FRAME_LOAD;
    }

    NamePoolCopy(namePool, name, sizeof(name), link, &p);

    /* We have to complete the URL here, because if it is relative it refers
       to the context of the source frame, not of the target. */
#if JAVASCRIPT_SUPPORT
    if(LocalCmpStringsNoCase(p, JS_SCHEME, sizeof(JS_SCHEME)/sizeof(TCHAR)-1)) {
	@call self::MSG_URL_FRAME_COMPLETE_URL(&p);
    } else {
	/* javascript: URL, try must be set to oself, to allow scope to
	   be current window */
	try = @call oself::MSG_URL_FRAME_FIND_REAL_FRAME();
    }
#else
    @call self::MSG_URL_FRAME_COMPLETE_URL(&p);
#endif

    if(execute)                         /* preview or execute the link? */
    {
      /* heuristic to allow cache detection when we've got
         a request generated by a form: check for agruments,
	 but no anchor */
      if ((dirMode == DIR_ABSOLUTE) && strchr(p, '?') &&
	  (strchr(p, '#') == 0)) {
	  dirMode = DIR_ABSOLUTE_GO;
      }
      /* Stop any previously processing items */
      /* NOTE:  If a user has multiple windows opened, at this time */
      /*        it stops all downloading actions. This will probably be */
      /*        changed in the future. !!! (LES: 01/19/98) !!! */
      /* partial support: pass frame to stop */
      @AbortOperation(TRUE, FALSE, try) ;

      /* Clear out the current highlighted selection to show we are */
      /* doing something else */
      @CallStatusUpdate(_TEXT(""),
        HTML_STATUS_TYPE_URL_HIGHLIGHT);

      absURL = NamePoolTokenize(namePool, p, TRUE);
      /* build referer data, can re-use 'name' buffer now (marked in-use) */
      referer = @call realSelf::MSG_URL_FRAME_GET_URL();
@ifdef COMPILE_OPTION_PROGRESS_INDICATOR
      G_progressStatus = TRUE;
@ifdef COMPILE_OPTION_DOWNLOAD_PROGRESS_DIALOG
      G_allowFileDownloadStatus = TRUE;
@endif
@endif
@ifdef COMPILE_OPTION_IGNORE_INPUT_DURING_LOADING
      @call application::MSG_HMLVA_IGNORE_INPUT();
@endif
      /* clear mod state so we'll update URL with current page */
      @call CurrentURLText::MSG_VIS_TEXT_SET_NOT_USER_MODIFIED();
      @call try::MSG_URL_FRAME_FETCH_URL(absURL, dirMode, postData, referer);
@ifdef GLOBAL_INTERNET_BUILD
      if (try == @HelpFrame) @call HelpWindow::MSG_GEN_INTERACTION_INITIATE();
@endif
      NamePoolReleaseToken(namePool, referer);
      NamePoolReleaseToken(namePool, absURL);
    }
    else                                /* just preview it... */
    {
      @CallStatusUpdate(p,
        HTML_STATUS_TYPE_URL_HIGHLIGHT);
    }

    NamePoolDestroyIfDynamic(p);
}

@method URLFrameClass, MSG_URL_FRAME_FIND_TARGET_BY_TITLE
{
    word i, children;
    optr child, ret = NullOptr;

    HWChecksumCheck() ;

    if(pself->UFI_frameState & FS_ACTIVE)
    {                                   /* go down only in active branch */
      // TBD: may be better to compare target/name case-insensitive...
      if(target==pself->UFI_windowName)
        ret = oself;
      else
      {
        children = @call self::MSG_URL_FRAME_COUNT_CHILDREN();
        HWChecksumCheck() ;

        for(i=0; i<children && !ret; i++)
        {                               /* relay to child objects until found */
          HWChecksumCheck() ;
          child = @call self::MSG_URL_FRAME_FIND_CHILD(i);
          ret = @call child::MSG_URL_FRAME_FIND_TARGET_BY_TITLE(target);
        }
      }
      HWChecksumCheck() ;
    }
    HWChecksumCheck() ;

    return ret;
}

@ifdef JAVASCRIPT_SUPPORT
@method URLFrameClass, MSG_URL_FRAME_FETCH_URL_AND_RELEASE
{
    @call oself::MSG_URL_FRAME_FETCH_URL(url, dir, postData, referer);
    NamePoolReleaseToken(namePool, url);
    NamePoolReleaseToken(namePool, referer);
}
@endif

@method URLFrameClass, MSG_URL_FRAME_FETCH_URL
{
    NameToken anchor, absURL;
    TCHAR *p, *newP, buf[HTML_STATIC_BUF];
    Boolean doLoad;
    optr parent;
    NameToken currentURL = pself->UFI_currentURL;

    HWChecksumCheck() ;

    /* default: no anchor, no URL */
    absURL = anchor = NAME_POOL_NONE;

    HWChecksumCheck() ;
    NamePoolCopy(namePool, buf, sizeof(buf), url, &newP);

#if JAVASCRIPT_SUPPORT
    /* "Fast lane" handling for passing JavaScript through untouched */
    if(LocalCmpStringsNoCase(newP, JS_SCHEME, sizeof(JS_SCHEME)/sizeof(TCHAR)-1)==0)
    {
      absURL = url;
      NamePoolUseToken(namePool, url);
    }
    else
    {
#endif
    /* Separate anchor name */
    p = strrchr(newP,'\x23');
    if(p)
    {
      if(p[1])                          /* real anchor name follows? */
        anchor = NamePoolTokenize(namePool, p+1, TRUE);
      *p = 0;                           /* truncate after anchor */
    }
    HWChecksumCheck() ;

    /* Make URL absolute */
    if(*newP)
    {
      parent = @call self::MSG_URL_FRAME_FIND_PARENT();

      /* Complete possible relative URLs based on specified direction.
         Determine if the new URL demands actual reloading or not. */

      /* max possible length is this */
      if (NamePoolResizeDynamic(&newP, ((strlen(newP)*2)+URL_MAX_TYPE)*sizeof(TCHAR)))  /* encompasses switch */
      switch(dir)
      {
        case DIR_GO:                    /* completely ignore URL context */
          ToolsMakeURLAbsolute(_TEXT(""), newP, newP);
          doLoad = TRUE;
          break;

        case DIR_FRAME:
        case DIR_FRAME_FORCE_RELOAD:
          if(parent)
            @call parent::MSG_URL_FRAME_COMPLETE_URL(&newP);
          else
            ToolsMakeURLAbsolute(_TEXT(""), newP, newP);

          if (currentURL && dir != DIR_FRAME_FORCE_RELOAD)
              doLoad = !(NamePoolTestEqual(namePool, currentURL, newP));
          else
              doLoad = TRUE ;
          break;

        default:
          doLoad = @call self::MSG_URL_FRAME_COMPLETE_URL(&newP);
	  if (dir == DIR_ABSOLUTE_GO || dir == DIR_RELOAD || dir == DIR_CROSS_FRAME_LOAD)
	      doLoad = TRUE;
          break;
      }
@ifdef JAVASCRIPT_SUPPORT
      if (pself->UFI_noURL)
	  doLoad = TRUE;
@endif

      /* If there is good reason for a URL request, set up URL to be fetched. */

      if(*newP && (doLoad || postData)) /* load new document? */
        absURL = NamePoolTokenize(namePool, newP, TRUE);
    }
#if JAVASCRIPT_SUPPORT
    }
#endif
    HWChecksumCheck() ;

    /* We're sending this message through the queue because it could already
       cause a flipping of the page, possibly changing the entire contents
       of our text object, so we'd better unwind the call stack before
       this happens. */
    NamePoolUseToken(namePool, referer);
    @send,forceQueue self::MSG_URL_FRAME_REQUEST_URL(
      0, absURL, anchor, dir, postData, referer);

    NamePoolDestroyIfDynamic(newP);     /* free dynamic buffer if any */

    HWChecksumCheck() ;
}

/*
 * Restore a frame set used for storing back/forth, history state.
 * This basically acts the same as if a document containing the appropriate
 * frame definitions had just been received by MSG_URL_FRAME_GOT_URL.
 * One difference is that the top frame's URL, title and base URI are
 * taken from the saved frame state rather than the (nonexistent)
 * hypertext transfer item.
 */
@method URLFrameClass, MSG_URL_FRAME_FETCH_FRAMES
{
    HTMLframeRec *frec;
    word size;
@ifdef COMPILE_OPTION_LOCAL_PAGES
    optr document = pself->UFI_document;
@endif

    HWChecksumCheck() ;

    /*
     * Update history etc. before dropping old URL
     */
    @send self::MSG_URL_FRAME_NOTIFY_FRAME_CHANGE_PRE(dir);

    frec = ChunkArrayElementToPtr(frameSet, 0, &size);

    if(frec->HF_flags & HTML_FRF_FRAMESET)
      @call self::MSG_URL_FRAME_SET_URL_TITLE_BASE_TARGET(
        frec->HF_url, frec->HF_title, frec->HF_base, frec->HF_target,
        frec->HF_referrer);
      @call self::MSG_URL_FRAME_SET_REFRESH(frec->HF_refreshURL, frec->HF_refreshTime) ;

@ifdef COMPILE_OPTION_LOCAL_PAGES
    /* Notify document that it's no longer corresponding to a local page.
       We simply assume that any change in a frame set invalidates the
       correspondence to the local page without checking if we happened
       to get in line with a new one. */

    if(dir != DIR_RELOAD && dir != DIR_SAVE && dir != DIR_FRAME &&
	dir != DIR_FRAME_FORCE_RELOAD)
      @call document::MSG_URL_DOCUMENT_SET_LOCAL_PAGE(NAME_POOL_NONE);
@endif

    @call self::MSG_URL_FRAME_ESTABLISH_FRAMES(frameSet, 0, dir);

    /*
     * Update controllers etc.
     */
    @call self::MSG_URL_FRAME_NOTIFY_FRAME_CHANGE_POST(dir);

    HWChecksumCheck() ;
}

@method URLFrameClass, MSG_URL_FRAME_ESTABLISH_FRAMES
{
    HTMLframeRec *frec;
    word curLevel, level, size, children, i, count;
    optr child;
@ifdef POST_DATA_CACHE
     MemHandle cachedPostData;
@endif
     /* use our URL as the referer for subframes */
    NameToken referer = pself->UFI_currentURL;

    HWChecksumCheck() ;
    @call self::MSG_URL_FRAME_ACTIVATE(FALSE);

    frec = ChunkArrayElementToPtr(frameArray, framePtr, &size);

    curLevel = frec->HF_level;

    /*
     * Adopt frame attributes. The top node in the frame tree inherits most
     * attributes from the frame it is loaded it rather than using those
     * specified for it.
     */
    if(framePtr)
      @call self::MSG_URL_FRAME_SET_FLAGS_SIZE_NAME(
        frec->HF_flags, frec->HF_size, frec->HF_name);
    else
    {
      pself = ObjDeref(oself, 0);
      pself->UFI_frameFlags &= ~(FRF_FLAGS_FROM_CHILD);
      pself->UFI_frameFlags |= (frec->HF_flags & FRF_FLAGS_FROM_CHILD);
    }

    /* store frame level (within this HTML file) */
@ifdef JAVASCRIPT_SUPPORT
    pself->UFI_frameLevel = frec->HF_level;
@endif

    /* Copy over any margin widths (mainly to hold the data so it is passed elsewhere */
    /* because we'll no longer have access to frec later). */
    pself->UFI_marginWidth = frec->HF_marginWidth ;
    pself->UFI_marginHeight = frec->HF_marginHeight ;

    if(frec->HF_flags & HTML_FRF_FRAMESET)
    {
      i = 0;                            /* assign first child */
      children = @call self::MSG_URL_FRAME_COUNT_CHILDREN();
      if (!children) {
	  @call self::MSG_URL_FRAME_CREATE_VIEW_GROUP();
      }

      framePtr++;                       /* skip frame set header */
      level = 999;
      count = ChunkArrayGetCount(frameArray);

      while(level >= curLevel+1 && framePtr < count)
      {
        HWChecksumCheck() ;
        frec = ChunkArrayElementToPtr(frameArray, framePtr, &size);
        level = frec->HF_level;
        if(level == curLevel+1)         /* data for frame at current level? */
        {
          child = @call self::MSG_URL_FRAME_FIND_CHILD(i++);
	  if (!child) {
	      @call self::MSG_URL_FRAME_CREATE_CHILD();
	      child = @call self::MSG_URL_FRAME_FIND_CHILD(i-1);
	      children++;
	  }
          if(child)
          {
	    /* set correct referer for child frame, as we'll need it for
	       fetch */
	    if(frec->HF_referrer)
		NamePoolReleaseToken(namePool, frec->HF_referrer);
	    frec->HF_referrer = referer;
	    if(frec->HF_referrer)
		NamePoolUseToken(namePool, frec->HF_referrer);
            if(frec->HF_flags & HTML_FRF_FRAMESET)
              @call child::MSG_URL_FRAME_SET_URL_TITLE_BASE_TARGET(
                frec->HF_url, frec->HF_title, frec->HF_base, frec->HF_target,
                frec->HF_referrer);

            @call child::MSG_URL_FRAME_SET_REFRESH(frec->HF_refreshURL, frec->HF_refreshTime) ;
            @call child::MSG_URL_FRAME_ESTABLISH_FRAMES(frameArray, framePtr, dir);
          }
        }
        framePtr++;                     /* check next entry */
      }

      /* set expected number of frames */
      pself->UFI_frameLoadCount = i;

      while(i<children)                 /* deactivate all other children */
      {
        HWChecksumCheck() ;
        child = @call self::MSG_URL_FRAME_FIND_CHILD(i++);
        @call child::MSG_URL_FRAME_DELETE_ALL(TRUE);
      }
    }
    else                                /* level specifying a URL frame */
    {
@ifdef POST_DATA_CACHE
     cachedPostData = PostDataCacheFind(frec->HF_url);
	if (dir == DIR_RELOAD || dir == DIR_FRAME_FORCE_RELOAD || dir == DIR_CROSS_FRAME_LOAD)
	    @call self::MSG_URL_FRAME_FETCH_URL(frec->HF_url, DIR_FRAME_FORCE_RELOAD, cachedPostData, frec->HF_referrer);
	else
	    @call self::MSG_URL_FRAME_FETCH_URL(frec->HF_url, DIR_FRAME, cachedPostData, frec->HF_referrer);
                                        /* start loading URL into frame */
@else
	if (dir == DIR_RELOAD || dir == DIR_FRAME_FORCE_RELOAD || dir == DIR_CROSS_FRAME_LOAD)
	    @call self::MSG_URL_FRAME_FETCH_URL(frec->HF_url, DIR_FRAME_FORCE_RELOAD, 0, frec->HF_referrer);
	else
	    @call self::MSG_URL_FRAME_FETCH_URL(frec->HF_url, DIR_FRAME, 0, frec->HF_referrer);
                                        /* start loading URL into frame */
@endif
    }
}

@ifdef COMPILE_OPTION_LOCAL_PAGES
@method URLFrameClass, MSG_URL_FRAME_FETCH_FRAMES_WITH_ITEMS
{
    HTMLframeRecWithItem *frec;
    word size;
    optr document = pself->UFI_document;

    HWChecksumCheck() ;

@ifdef COMPILE_OPTION_PROGRESS_INDICATOR
     @SendUpdateProgress(PI_NUM_FRAMES, ChunkArrayGetCount(frameSet));
@endif

    /*
     * Update history etc. before dropping old URL
     */
    @send self::MSG_URL_FRAME_NOTIFY_FRAME_CHANGE_PRE(dir);

    frec = ChunkArrayElementToPtr(frameSet, 0, &size);

    if(frec->HFRWI_rec.HF_flags & HTML_FRF_FRAMESET)
      @call self::MSG_URL_FRAME_SET_URL_TITLE_BASE_TARGET(
        frec->HFRWI_rec.HF_url, frec->HFRWI_rec.HF_title,
        frec->HFRWI_rec.HF_base, frec->HFRWI_rec.HF_target,
        frec->HFRWI_rec.HF_referrer);

    @call document::MSG_URL_DOCUMENT_SET_LOCAL_PAGE(localPage);

    @call self::MSG_URL_FRAME_ESTABLISH_FRAMES_WITH_ITEMS(frameSet, (word) 0, vmf);

    /*
     * Update controllers etc.
     */
    @call self::MSG_URL_FRAME_NOTIFY_FRAME_CHANGE_POST(dir);

    HWChecksumCheck() ;
}

@method URLFrameClass, MSG_URL_FRAME_ESTABLISH_FRAMES_WITH_ITEMS
{
    HTMLframeRecWithItem *frec;
    word curLevel, level, size, children, i, count;
    optr child;

    HWChecksumCheck() ;
    @call self::MSG_URL_FRAME_ACTIVATE(FALSE);

    frec = ChunkArrayElementToPtr(frameArray, framePtr, &size);

    curLevel = frec->HFRWI_rec.HF_level;

    /*
     * Adopt frame attributes. The top node in the frame tree inherits most
     * attributes from the frame it is loaded it rather than using those
     * specified for it.
     */
    if(framePtr != 0)
      @call self::MSG_URL_FRAME_SET_FLAGS_SIZE_NAME(
        frec->HFRWI_rec.HF_flags, frec->HFRWI_rec.HF_size, frec->HFRWI_rec.HF_name);
    else
    {
      pself = ObjDeref(oself, 0);
      pself->UFI_frameFlags &= ~(FRF_FLAGS_FROM_CHILD);
      pself->UFI_frameFlags |= (frec->HFRWI_rec.HF_flags & FRF_FLAGS_FROM_CHILD);
    }

    /* Restore URL, Title and Base URL to the current frame */
    @call self::MSG_URL_FRAME_SET_URL_TITLE_BASE_TARGET(
      frec->HFRWI_rec.HF_url, frec->HFRWI_rec.HF_title,
      frec->HFRWI_rec.HF_base, frec->HFRWI_rec.HF_target,
      frec->HFRWI_rec.HF_referrer);

    if(frec->HFRWI_rec.HF_flags & HTML_FRF_FRAMESET)
    {
      i = 0;                            /* assign first child */
      children = @call self::MSG_URL_FRAME_COUNT_CHILDREN();

      framePtr++;                       /* skip frame set header */
      level = 999;
      count = ChunkArrayGetCount(frameArray);

      while(level >= curLevel+1 && framePtr < count)
      {
        HWChecksumCheck() ;
        frec = ChunkArrayElementToPtr(frameArray, framePtr, &size);
        level = frec->HFRWI_rec.HF_level;
        if(level == curLevel+1)         /* data for frame at current level? */
        {
          child = @call self::MSG_URL_FRAME_FIND_CHILD(i++);
	  if (!child) {
	      @call self::MSG_URL_FRAME_CREATE_CHILD();
	      child = @call self::MSG_URL_FRAME_FIND_CHILD(i-1);
	      children++;
	  }
          if(child)
            @call child::MSG_URL_FRAME_ESTABLISH_FRAMES_WITH_ITEMS(
              frameArray, framePtr, vmf);
        }
        framePtr++;                     /* check next entry */
      }

      while(i<children)                 /* deactivate all other children */
      {
        HWChecksumCheck() ;
        child = @call self::MSG_URL_FRAME_FIND_CHILD(i++);
        @call child::MSG_URL_FRAME_DELETE_ALL(TRUE);
      }
    }
    else                                // level specifying a URL frame
    /*
      @call self::MSG_URL_FRAME_GOT_PAGE_NOFRAME(
        vmf,
        VMCHAIN_GET_VM_BLOCK(frec->HFRWI_item),
        NAME_POOL_NONE,
        GUF_CACHABLE,
        FALSE,
        0);
        */

      @call self::MSG_URL_FRAME_GOT_PAGE_NOFRAME(
        VMCHAIN_GET_VM_BLOCK(frec->HFRWI_item),
        NAME_POOL_NONE,
        GUF_RELOAD, // GUF_CACHABLE = not defined?
        FALSE);

}
@endif

@method URLFrameClass, MSG_URL_FRAME_COLLECT_FRAMES
{
    HTMLframeRec *frec;
    word children, i;
    optr child, text;
    TCHAR buf[POSITION_ANCHOR_SIZE];

    if((pself->UFI_frameState & (FS_ACTIVE | FS_DUMMY)) == FS_ACTIVE)
    {
      frec = ChunkArrayAppend(frameArray, sizeof(HTMLframeRec));

      pself = ObjDeref(oself,0);
      frec->HF_flags = pself->UFI_frameFlags;
      frec->HF_size = pself->UFI_size;
      frec->HF_level = level;

      frec->HF_base = pself->UFI_baseURI;
      if(frec->HF_base != NAME_POOL_NONE)
        NamePoolUseToken(namePool, frec->HF_base);

      frec->HF_target = pself->UFI_baseTarget;
      if(frec->HF_target != NAME_POOL_NONE)
        NamePoolUseToken(namePool, frec->HF_target);

      frec->HF_name = pself->UFI_windowName;
      if(frec->HF_name != NAME_POOL_NONE)
        NamePoolUseToken(namePool, frec->HF_name);

      frec->HF_url = pself->UFI_currentURL;
      if(frec->HF_url != NAME_POOL_NONE)
        NamePoolUseToken(namePool, frec->HF_url);

      /* we could have set HF_referrer in ESTABLISH_FRAMES */
      if(frec->HF_referrer)
	NamePoolReleaseToken(namePool, frec->HF_referrer);
      frec->HF_referrer = pself->UFI_referrer;
      if(frec->HF_referrer != NAME_POOL_NONE)
        NamePoolUseToken(namePool, frec->HF_referrer);

      /* If there is a text object, also keep track of its scroll position */
      if(pself->UFI_currentURL && !(pself->UFI_frameFlags & HTML_FRF_FRAMESET))
      {
        text = @call self::MSG_URL_FRAME_FIND_TEXT_OBJECT();

        /* Do this by creating an artifical anchor representing the text
           position in the upper-left corner */
        @call text::MSG_HTML_TEXT_CREATE_POSITION_ANCHOR(buf);
        frec->HF_url = NamePoolConcatStr(namePool, frec->HF_url, buf);
      }

      frec->HF_title = pself->UFI_documentTitle;
      if(frec->HF_title != NAME_POOL_NONE)
        NamePoolUseToken(namePool, frec->HF_title);

      /* Copy over the refresh data */
      frec->HF_refreshTime = pself->UFI_refreshTime ;
      frec->HF_refreshURL = pself->UFI_refreshURL ;
      if (frec->HF_refreshURL)
          NamePoolUseToken(namePool, frec->HF_refreshURL) ;

      children = @call self::MSG_URL_FRAME_COUNT_CHILDREN();
      for(i=0; i<children; i++)         /* collect child frames */
      {
        child = @call self::MSG_URL_FRAME_FIND_CHILD(i);
        @call child::MSG_URL_FRAME_COLLECT_FRAMES(frameArray, level+1);
      }
    }
}

@ifdef COMPILE_OPTION_LOCAL_PAGES
@method URLFrameClass, MSG_URL_FRAME_COLLECT_FRAMES_WITH_ITEMS
{
    HTMLframeRecWithItem *frec;
    word children, i;
    optr child, text;

    if((pself->UFI_frameState & (FS_ACTIVE | FS_DUMMY)) == FS_ACTIVE)
    {
      frec = ChunkArrayAppend(frameArray, sizeof(HTMLframeRecWithItem));

      pself = ObjDeref(oself,0);
      frec->HFRWI_rec.HF_flags = pself->UFI_frameFlags;
      frec->HFRWI_rec.HF_size = pself->UFI_size;
      frec->HFRWI_rec.HF_level = level;

      /* Copy fields which are stored as name tokens. */
      frec->HFRWI_rec.HF_base = NamePoolTokenizeFromPool(pool, namePool,
        pself->UFI_baseURI, FALSE);
      frec->HFRWI_rec.HF_target = NamePoolTokenizeFromPool(pool, namePool,
        pself->UFI_baseTarget, FALSE);
      frec->HFRWI_rec.HF_name = NamePoolTokenizeFromPool(pool, namePool,
        pself->UFI_windowName, FALSE);
      frec->HFRWI_rec.HF_url = NamePoolTokenizeFromPool(pool, namePool,
        pself->UFI_currentURL, FALSE);
      frec->HFRWI_rec.HF_referrer = NamePoolTokenizeFromPool(pool, namePool,
        pself->UFI_referrer, FALSE);
      frec->HFRWI_rec.HF_title = NamePoolTokenizeFromPool(pool, namePool,
        pself->UFI_documentTitle, FALSE);

      text = @call self::MSG_URL_FRAME_FIND_TEXT_OBJECT();
                                        /* go down through dummy levels */

      if(text)                          /* serialize text object, if any */
        frec->HFRWI_item = @call text::MSG_HTML_TEXT_STORE_CONTENTS(vmf, pool);
      else
        frec->HFRWI_item = 0;

      children = @call self::MSG_URL_FRAME_COUNT_CHILDREN();
      for(i=0; i<children; i++)         /* collect child frames */
      {
        child = @call self::MSG_URL_FRAME_FIND_CHILD(i);
        @call child::MSG_URL_FRAME_COLLECT_FRAMES_WITH_ITEMS(frameArray,
          level+1, vmf, pool);
      }
    }
}
@endif

@method URLFrameClass, MSG_URL_FRAME_GET_SIZE
{
    return pself->UFI_size;
}

@method URLFrameClass, MSG_URL_FRAME_GET_FRAME_FLAGS
{
    return pself->UFI_frameFlags;
}

@method URLFrameClass, MSG_URL_FRAME_SET_FLAGS_SIZE_NAME
{
    pself->UFI_frameFlags = flags;
    pself->UFI_size = size;
    @call self::MSG_URL_FRAME_SET_NAME(name);
}

@method URLFrameClass, MSG_URL_FRAME_SET_NAME
{
    if(pself->UFI_windowName != NAME_POOL_NONE)
    {
      NamePoolReleaseToken(namePool, pself->UFI_windowName);
      pself = ObjDeref(oself,0);
    }
    pself->UFI_windowName = name;
    if(name != NAME_POOL_NONE)
      NamePoolUseToken(namePool, name);
}

@method URLFrameClass, MSG_URL_FRAME_GET_STATE
{
    return pself->UFI_frameState;
}

@method URLFrameClass, MSG_URL_FRAME_SET_STATE
{
    pself->UFI_frameState &= ~clear;
    pself->UFI_frameState |= set;
}

@method URLFrameClass, MSG_URL_FRAME_ACTIVATE
{
    pself->UFI_frameState |= FS_ACTIVE;

    /* possibly mark frame as dummy level */
    if(dummy)
      pself->UFI_frameState |= FS_DUMMY;
    else
      pself->UFI_frameState &= ~FS_DUMMY;
}

/*
 *  Remove content from all the text objects belonging
 *  to this frame and its children, possibly deactivating it
 *  along the way. If the frame is a frameset, all its children
 *  will be deactivated (in preparation for a frameset change).
 */
@method URLFrameClass, MSG_URL_FRAME_DELETE_ALL
{
    if(pself->UFI_frameState & FS_ACTIVE)
    {                                   /* Frame currently active? */
      if(deactivate)
        pself->UFI_frameState &= ~(FS_ACTIVE | FS_DUMMY);
                                        /* yes: deactivate */

      @call self::MSG_URL_FRAME_FLIP_PAGE(OCT_NULL, FALSE);
                                        /* release text object storage */

      @call self::MSG_URL_FRAME_SET_URL_TITLE_BASE_TARGET(NAME_POOL_NONE,
        NAME_POOL_NONE, NAME_POOL_NONE, NAME_POOL_NONE, NAME_POOL_NONE);
      @call self::MSG_URL_FRAME_SET_REFRESH(NAME_POOL_NONE, 0);

      /* clean and deactivate children */
      @send @frameChildren::MSG_URL_FRAME_DELETE_ALL(TRUE);
    }
}

/*
 *  Attempt to reload/save/show as source the current URL
 */
@method URLFrameClass, MSG_URL_FRAME_RELOAD,
                       MSG_URL_FRAME_SOURCE,
                       MSG_URL_FRAME_SAVE
{
    NameToken url, referer;

    HWChecksumCheck() ;
    if(pself->UFI_frameState & FS_ACTIVE)
    {                                   /* only process active branches */
      url = @call self::MSG_URL_FRAME_GET_URL();
      if(url != NAME_POOL_NONE)         /* currently showing URL? */
      {
        referer = @call self::MSG_URL_FRAME_GET_REFERRER();
        @call self::MSG_URL_FRAME_REQUEST_URL(
          0, url, NAME_POOL_NONE,
          (message==MSG_URL_FRAME_RELOAD)? DIR_RELOAD:
          (message==MSG_URL_FRAME_SOURCE)? DIR_SOURCE:
                                           DIR_SAVE,
          NullHandle, referer);
      }
    }
}

/*
 *  Load missing images
 */
@method URLFrameClass, MSG_URL_FRAME_LOAD_GRAPHICS
{
    optr text = pself->UFI_text;

    HWChecksumCheck() ;
    /* clear previous abort, if any */
    if (UserAbortCheck()) UserAbortEnd();
    if(pself->UFI_frameState & FS_ACTIVE)
    {                                   /* only process active branches */
      if(text)
      {
        @send,forceQueue text::MSG_HTML_TEXT_MARK_ALL_BROKEN_AND_RESOLVING_IMAGES_UNRESOLVED() ;
        @send,forceQueue text::MSG_URL_TEXT_PROCESS_GRAPHICS(FALSE);
      }

      @send @frameChildren::MSG_URL_FRAME_LOAD_GRAPHICS();
    }
}

@method URLFrameClass, MSG_URL_FRAME_SET_URL_TITLE_BASE_TARGET
{
@ifdef GLOBAL_INTERNET_BUILD
    TCHAR buf[80];
@endif
    optr document = pself->UFI_document;

    HWChecksumCheck() ;
    if(pself->UFI_currentURL != NAME_POOL_NONE)
    {
      NamePoolReleaseToken(namePool, pself->UFI_currentURL);
      pself = ObjDeref(oself,0);
    }
    pself->UFI_currentURL = url;
    if(url != NAME_POOL_NONE)
      NamePoolUseToken(namePool, url);

    if(pself->UFI_referrer != NAME_POOL_NONE)
    {
      NamePoolReleaseToken(namePool, pself->UFI_referrer);
      pself = ObjDeref(oself,0);
    }
    pself->UFI_referrer = referer;
    if(referer != NAME_POOL_NONE)
      NamePoolUseToken(namePool, referer);

    if(pself->UFI_documentTitle != NAME_POOL_NONE)
    {
      NamePoolReleaseToken(namePool, pself->UFI_documentTitle);
      pself = ObjDeref(oself,0);
    }
    pself->UFI_documentTitle = title;
    if(title != NAME_POOL_NONE)
      NamePoolUseToken(namePool, title);

    if(pself->UFI_baseURI != NAME_POOL_NONE)
    {
      NamePoolReleaseToken(namePool, pself->UFI_baseURI);
      pself = ObjDeref(oself,0);
    }
    pself->UFI_baseURI = base;
    if(base != NAME_POOL_NONE)
      NamePoolUseToken(namePool, base);

    if(pself->UFI_baseTarget != NAME_POOL_NONE)
    {
      NamePoolReleaseToken(namePool, pself->UFI_baseTarget);
      pself = ObjDeref(oself,0);
    }
    pself->UFI_baseTarget = target;
    if(target != NAME_POOL_NONE)
      NamePoolUseToken(namePool, target);

    HWChecksumCheck() ;

    /* Find out if top level frame has changed, or some other... */
    /* (HelpWindow and WindowOpen title is set only by below code) */
    if (oself == @call document::MSG_URL_DOCUMENT_GET_TOP_FRAME()) {
      @call document::MSG_URL_DOCUMENT_NOTIFY_TOP_CHANGE(url, title);
                                        /* inform document about top change */
    }
@ifdef GLOBAL_INTERNET_BUILD
     if (oself == @HelpFrame) {
	 if (title) {
	     NamePoolCopy(namePool, buf, sizeof(buf), title, NULL);
	     @call HelpWindow::MSG_GEN_REPLACE_VIS_MONIKER_TEXT(buf, VUM_DELAYED_VIA_APP_QUEUE);
	 } else {
	     @call HelpWindow::MSG_GEN_REPLACE_VIS_MONIKER_OPTR(@HelpWindowMoniker, VUM_DELAYED_VIA_APP_QUEUE);
	 }
     }
@endif
@ifdef JAVASCRIPT_SUPPORT
     if (oself == @WindowOpenFrame) {
	 if (title) {
	     NamePoolCopy(namePool, buf, sizeof(buf), title, NULL);
	     @call WindowOpenWindow::MSG_GEN_REPLACE_VIS_MONIKER_TEXT(buf, VUM_DELAYED_VIA_APP_QUEUE);
	 }
     }
@endif

    HWChecksumCheck() ;
}

#if EMBED_SUPPORT
@method URLFrameClass, MSG_URL_FRAME_SET_EMBED
{
    if (pself->UFI_embed != NAME_POOL_NONE) {
	NamePoolReleaseToken(namePool, pself->UFI_embed);
	pself = ObjDeref(oself, 0);
    }
    pself->UFI_embed = embed;
    if (embed != NAME_POOL_NONE) {
	NamePoolUseToken(namePool, embed);
    }
}
#endif

@method URLFrameClass, MSG_URL_FRAME_GET_URL,
                       MSG_URL_FRAME_GET_TITLE,
                       MSG_URL_FRAME_GET_REFERRER,
                       MSG_URL_FRAME_GET_NAME
{
    NameToken tok =
      (message==MSG_URL_FRAME_GET_URL)?      pself->UFI_currentURL:
      (message==MSG_URL_FRAME_GET_TITLE)?    pself->UFI_documentTitle:
      (message==MSG_URL_FRAME_GET_REFERRER)? pself->UFI_referrer:
                                             pself->UFI_windowName;
    ;

    if(tok != NAME_POOL_NONE)
      NamePoolUseToken(namePool, tok);
    return tok;
}

Boolean CompleteURLBuffer(NameToken base, TCHAR **buf)
{
    TCHAR urlbuf[HTML_MIN_BUF], *curURL, *p;
    Boolean ret;
    int numSpaces = 0;

EC_ERROR_IF(!NamePoolIsDynamic(*buf), -1);

    NamePoolCopy(namePool, urlbuf, sizeof(urlbuf), base, &curURL);
    /* max possible length is this (spaces expand to %20) */
    p = curURL; while (*p) if (*p++ == ' ') numSpaces++;  /* count spaces */
    p = *buf; while (*p) if (*p++ == ' ') numSpaces++;  /* count spaces */
    if (NamePoolResizeDynamic(buf, (strlen(curURL)+strlen(*buf)+URL_MAX_TYPE+numSpaces*2)*sizeof(TCHAR)))
                                      /* get current URL as text string */
    ret = ToolsMakeURLAbsolute(curURL, *buf, *buf);
    NamePoolDestroyIfDynamic(curURL); /* release buffer for URL */
    ToolsNormalizeURL(*buf);          /* bring URL into canonical format */

    return ret;
}

/* must pass pointer to dynamic NamePool buffer */
@method URLFrameClass, MSG_URL_FRAME_COMPLETE_URL
{
    Boolean ret = FALSE;
    optr parent;
    NameToken base;

    HWChecksumCheck() ;
    if(pself->UFI_baseURI)              /* Use explicit base URI if specified */
      base = pself->UFI_baseURI;
    else
      base = pself->UFI_currentURL;

    if(base != NAME_POOL_NONE)          /* can only complete if URL available */
    {
      ret = CompleteURLBuffer(base, buf);
    }
    else                                /* attempt to propagate request up */
    {
      parent = @call self::MSG_URL_FRAME_FIND_PARENT();
      if(parent)
        ret = @call parent::MSG_URL_FRAME_COMPLETE_URL(buf);
      else
      {
        ret = ToolsMakeURLAbsolute(_TEXT(""), *buf, *buf);
        HWChecksumCheck() ;
        ToolsNormalizeURL(*buf);        /* bring URL into canonical format */
      }
    }

    HWChecksumCheck() ;
    return ret;
}

@method URLFrameClass, MSG_URL_FRAME_FIND_PARENT
{
    return ObjLinkFindParent(oself,
      0,
      word_offsetof(URLFrameInstance, UFI_link));
}

@method URLFrameClass, MSG_URL_FRAME_FIND_CHILD
{
    return ObjCompFindChildByNumber(oself, child,
      0,
      word_offsetof(URLFrameInstance, UFI_comp),
      word_offsetof(URLFrameInstance, UFI_link));
}

@method URLFrameClass, MSG_URL_FRAME_COUNT_CHILDREN
{
    word children;

    children = 0;
    while(@call self::MSG_URL_FRAME_FIND_CHILD(children))
      children++;

    return children;
}

/*
   Back up through dummy levels until the frame holding the URL information
   is found. Should eventually become obsolete through elimination of
   dummy levels.
 */

@method URLFrameClass, MSG_URL_FRAME_FIND_REAL_FRAME
{
    optr parent, ret;

    if(!(pself->UFI_frameState & FS_DUMMY))
      ret = oself;
    else
    {
      parent = @call self::MSG_URL_FRAME_FIND_PARENT();
      if(parent)
        ret = @call parent::MSG_URL_FRAME_FIND_REAL_FRAME();
      else
        ret = NullOptr;
    }
    return ret;
}

/*
   Go down the dummy level tree to find our text object. Also an artifact
   of dummy levels...
 */
@method URLFrameClass, MSG_URL_FRAME_FIND_TEXT_OBJECT
{
    word children,i;
    optr child, obj;
    WordFlags state;

    if(pself->UFI_text)                 /* has text object? return it */
      return pself->UFI_text;

    obj = NullOptr;
    children = @call self::MSG_URL_FRAME_COUNT_CHILDREN();
    for(i=0; i<children && !obj; i++)   /* scan child frames */
    {
      /* Only query active dummy levels if they know a text object... */
      child = @call self::MSG_URL_FRAME_FIND_CHILD(i);
      state = @call child::MSG_URL_FRAME_GET_STATE();
      if( (state & (FS_ACTIVE | FS_DUMMY)) == (FS_ACTIVE | FS_DUMMY) ||
	  !(state & FS_DUMMY) )
        obj = @call child::MSG_URL_FRAME_FIND_TEXT_OBJECT();
    }
    return obj;
}

@method URLFrameClass, MSG_URL_FRAME_RECALCULATE
{
    if(pself->UFI_frameState & FS_ACTIVE)
    {                                   /* only process active branches */
      if(pself->UFI_text)  {
          @send ,forceQueue (pself->UFI_text)::MSG_URL_TEXT_RECALCULATE() ;
      }

      @send @frameChildren::MSG_URL_FRAME_RECALCULATE();
    }
}

@method URLFrameClass, MSG_URL_FRAME_CLEAR_REFRESH
{
    optr child ;
    word num ;

    @call self::MSG_URL_FRAME_SET_REFRESH(NAME_POOL_NONE, 0);

    /* Call all the children too */
    num = 0 ;
    do {
        child = ObjCompFindChildByNumber(
            oself,
            num,
            0,
	    word_offsetof(URLFrameInstance, UFI_comp),
	    word_offsetof(URLFrameInstance, UFI_link));
        if (!child)
            break ;
        @call child::MSG_URL_FRAME_CLEAR_REFRESH() ;
    } while (++num) ;
}

@method URLFrameClass, MSG_URL_FRAME_STOP
{
    optr child ;
    word num ;

    if (pself->UFI_text)  {
        @call (pself->UFI_text)::MSG_URL_TEXT_STOP() ;
    }

    /* Call all the children too */
    num = 0 ;
    do {
        child = ObjCompFindChildByNumber(
            oself,
            num,
            0,
	    word_offsetof(URLFrameInstance, UFI_comp),
	    word_offsetof(URLFrameInstance, UFI_link));
        if (!child)
            break ;
        @call child::MSG_URL_FRAME_STOP() ;
    } while (++num) ;
}

@method URLFrameClass, MSG_URL_FRAME_SET_REFRESH
{
    HWChecksumCheck() ;

    /* limit refresh to about 18 minutes, could improve by using
       cascading timers */
    if (secs > (65535/60)) {
	secs = 65535/60;
    }

    /* destroy old timer, if any */
    if(pself->UFI_refreshTimer)
    {
      TimerStop(pself->UFI_refreshTimer, pself->UFI_refreshID);
      pself->UFI_refreshTimer = NullHandle;
    }

    /* set new destination URL, release old one, if any */
    if(pself->UFI_refreshURL != NAME_POOL_NONE)
    {
      NamePoolReleaseToken(namePool, pself->UFI_refreshURL);
      pself = ObjDeref(oself,0);
    }
    pself->UFI_refreshURL = url;
    pself->UFI_refreshTime = secs ;
    if(url != NAME_POOL_NONE)
      NamePoolUseToken(namePool, url);

    /* launch timer if requested */
    if(secs)
    {
      pself->UFI_refreshTimer = TimerStart(TIMER_EVENT_ONE_SHOT,
        oself, secs * 60, MSG_URL_FRAME_REFRESH_TIMER_EXPIRED, 0,
        &(pself->UFI_refreshID));
    }
    else                                /* transfer immediately */
      if(url != NAME_POOL_NONE)
        @call self::MSG_URL_FRAME_REFRESH_TIMER_EXPIRED();

    HWChecksumCheck() ;
}

@method URLFrameClass, MSG_URL_FRAME_REFRESH_TIMER_EXPIRED
{
    HWChecksumCheck() ;

    /* timer has expired */
    pself->UFI_refreshTimer = NullHandle;

@ifdef CHECK_ISP
    /* only if connected do we refresh (encompasses entire following 'if') */
    if (CheckConnected())
@endif
    /* load specified URL resp. refresh current one */
    if(pself->UFI_refreshURL)
    {
	/* use DIR_ABSOLUTE_GO as must still refresh if same URL */
      @call self::MSG_URL_FRAME_FETCH_URL(pself->UFI_refreshURL,
        DIR_ABSOLUTE_GO, 0, NAME_POOL_NONE);
    }
    else
      @call self::MSG_URL_FRAME_RELOAD();

    /* release previous refresh request */
    @call self::MSG_URL_FRAME_SET_REFRESH(NAME_POOL_NONE, 0);
}

@method URLFrameClass, MSG_URL_FRAME_TEST_UNRESOLVED_IMAGES
{
    word i, children;
    optr textObj = pself->UFI_text, child;
    Boolean ret = FALSE;

    HWChecksumCheck() ;

    if(pself->UFI_frameState & FS_ACTIVE)
    {                                   /* go down only in active branch */
      if(textObj)  {                     /* check if we have our own page */
        ret = @call textObj::MSG_HTML_TEXT_TEST_UNRESOLVED_IMAGES();
        if (!ret)
            ret = @call textObj::MSG_HTML_TEXT_TEST_BROKEN_AND_RESOLVING_IMAGES() ;
      }

      if(!ret)                          /* not found anything yet: go down */
      {
        children = @call self::MSG_URL_FRAME_COUNT_CHILDREN();

        for(i=0; i<children && !ret; i++)
        {                               /* relay to child objects until found */
          HWChecksumCheck() ;
          child = @call self::MSG_URL_FRAME_FIND_CHILD(i);
          ret = @call child::MSG_URL_FRAME_TEST_UNRESOLVED_IMAGES();
        }
        HWChecksumCheck() ;
      }
    }
    HWChecksumCheck() ;

    return ret;
}

@method URLFrameClass, MSG_URL_FRAME_NOTIFY_FRAME_CHANGE_PRE,
                       MSG_URL_FRAME_NOTIFY_FRAME_CHANGE_POST
{
    Message sendMsg;
    optr document = pself->UFI_document;

    if(message == MSG_URL_FRAME_NOTIFY_FRAME_CHANGE_PRE)
      sendMsg = MSG_URL_DOCUMENT_NOTIFY_FRAME_CHANGE_PRE;
    else
    {
      sendMsg = MSG_URL_DOCUMENT_NOTIFY_FRAME_CHANGE_POST;

      /* update frame UI */
      @send document::MSG_URL_DOCUMENT_UPDATE_FRAME_UI();
    }

    /* Notify document about the change... */
    @send document::{MSG_URL_DOCUMENT_NOTIFY_FRAME_CHANGE_PRE}(sendMsg)(dir);
}

@extern chunk MsgAborted ;

@method URLFrameClass, MSG_URL_FRAME_NOTIFY_FRAME_COMPLETE
{
    optr text = pself->UFI_text;
    Boolean isEmpty ;
    URLFetchResult *p_urlResult ;
    MemHandle mem ;
    extern Boolean G_stopped ;
    optr requestState ;
    HTMLV_URLRequestState *p_requestState ;
    optr document = pself->UFI_document ;

    /* If someone aborted, then we need to check if we */
    /* have a blank page and put up an abort message if we do. */
    if (G_stopped)  {
        G_stopped = FALSE ;
        isEmpty = @call text::MSG_HTML_TEXT_IS_EMPTY() ;
        if (isEmpty)  {
            mem = MemAlloc(
                      sizeof(URLFetchResult),
                      HF_DYNAMIC | HF_SHARABLE,
                      HAF_ZERO_INIT) ;
            if (mem)  {
                p_urlResult = MemLock(mem) ;
                p_urlResult->url = @call oself::MSG_URL_FRAME_GET_URL();
                strcpy(p_urlResult->mimeType, _TEXT("text/html")) ;
                p_urlResult->retType = URLRequestMakeRet(URL_RET_MESSAGE) ;
                p_urlResult->htmlMsg = @MsgAborted ;
	        p_urlResult->anchor = NAME_POOL_NONE;
                requestState = URLFetchExtraMemoryAlloc(
                                   sizeof(HTMLV_URLRequestState)) ;
                URLFetchExtraMemoryLock(requestState) ;
                p_requestState = URLFetchExtraMemoryDeref(requestState) ;
                p_requestState->requestToken = NAME_POOL_NONE ;
                p_requestState->anchor = NAME_POOL_NONE ;
                p_requestState->referer = NAME_POOL_NONE ;
                p_requestState->objCache = FALSE ;
                p_requestState->dir = DIR_SOURCE ;
                URLFetchExtraMemoryUnlock(requestState) ;
                p_urlResult->extraData = requestState ;
                MemUnlock(mem) ;

		@send document::MSG_URL_DOCUMENT_INC_PENDING();
                /* Send out a request to show this page */
                @send ,forceQueue oself::MSG_URL_FRAME_URL_FETCHED(mem) ;
            }
        }
    }
}

@method URLFrameClass, MSG_URL_FRAME_FLIP_PAGE
{
    VMFileHandle vmf;
    VMChain item;
    optr text = pself->UFI_text;
    ObjCacheToken oldToken;

    if(text)
    {
      oldToken = pself->UFI_cacheToken; // Release entry afterwards

@ifdef JAVASCRIPT_SUPPORT
      /* destroy old script context for this window */
@ifdef HANDLE_SCRIPTS_DURING_PARSING
      /* only if clearing page */
      if(oct == OCT_NULL)
@endif
      @call self::MSG_URL_FRAME_DESTROY_SCRIPT_CONTEXT(TRUE);
@endif

      /* remember URL of item in cache */
      pself->UFI_cacheToken = oct;

      /* load new content into page */
      if(oct != OCT_NULL)
      {
        /* Add reference to entry in cache */
        ObjCacheLockItem(oct, &vmf, &item, NULL, 0);

        /* Load entry into text object */
        @call text::MSG_HTML_TEXT_ATTACH_TO_ITEM(vmf, item);

        /* Change color of visited (i.e. cached) links */
        @call text::MSG_URL_TEXT_MARK_VISITED_LINKS();

        /* start loading images if enabled */
        if(@call NavigateLoadGraphics::MSG_GEN_BOOLEAN_GROUP_GET_SELECTED_BOOLEANS())
        {
          @call text::MSG_URL_TEXT_PROCESS_GRAPHICS(reload);
          @call text::MSG_HTML_TEXT_SHOW_ITEM();
        }
        else
        {
          @call text::MSG_HTML_TEXT_SHOW_ITEM();
        }
      }
      else
      {
        @call text::MSG_HTML_TEXT_ATTACH_TO_ITEM(NullHandle, 0);
        @call text::MSG_HTML_TEXT_SHOW_ITEM();
      }

      /* Release old item, if any */
      if(oldToken != OCT_NULL)
        ObjCacheUnlockItem(oldToken);
    }
}

@method URLFrameClass, MSG_URL_FRAME_INC_PENDING
{
    @send (pself->UFI_document)::MSG_URL_DOCUMENT_INC_PENDING();
}

@method URLFrameClass, MSG_URL_FRAME_DEC_PENDING
{
    @send (pself->UFI_document)::MSG_URL_DOCUMENT_DEC_PENDING();
}

@ifdef COMPILE_OPTION_PARENTAL_CONTROL

void PCAddRemoveHostFromURL(TCHAR *url, ParentalControlFlags *pcFlags,
			    Boolean add)
{
    TCHAR hostBuf[URL_MAX_SERVER+1], *hostEnd;
    TCHAR *host = hostBuf;
    dword position;
    Boolean there;

    /* get host */
    ToolsParseURL(url, NULL, host, NULL);
    hostEnd = host+strlen(host);
    if (*host) {
	TCHAR *h1 = 0, *h2 = 0;
	h1 = strrchr(host, '.');
	if (h1 && h1!=host) {
	    *h1 = C_NULL;
	    h2 = strrchr(host, '.');
	    *h1 = '.';
	}
	if (h1 && h2) host = h2;  /* .myturn.com instead of www.myturn.com */
	/* add if not there */
	there = ParentalControlFindURL(host, hostEnd, &position);
	if ((add && !there) || (!add && there)) {
	    /* determine if we need to ask for password */
	    if ((*pcFlags & PCF_REQUIRE_PASSWORD) &&
		!(*pcFlags & PCF_GOT_PASSWORD)) {
		if (@call PCRoot::MSG_PC_CHECK_PASSWORD_DB(PC_WWW) == IC_OK) {
		    *pcFlags |= PCF_GOT_PASSWORD;
		} else {
		    *pcFlags |= PCF_ABORT_PASSWORD;
		}
	    }
	    if (!(*pcFlags & PCF_ABORT_PASSWORD) &&
		(!(*pcFlags & PCF_REQUIRE_PASSWORD) ||
		 (*pcFlags & PCF_GOT_PASSWORD))) {
		if (add) {
		    /* add it */
		    (void)ParentalControlStoreURL(host, hostEnd);
		} else {
		    /* remove it */
		    /* XXX: there is a small synchornization hole here, if
		       someone adds or removes a site between our find and
		       delete */
		    if (ParentalControlFindURL(host, hostEnd, &position)) {
			(void)ParentalControlDeleteURL(position);
		    }
		}
		/* share code below */
		*pcFlags |= (add ? PCF_ADDED_SITE : PCF_REMOVED_SITE);
	    }
	}
    } else {
	/* no site, mark added/removed so user doesn't get warning message */
	*pcFlags |= (add ? PCF_ADDED_SITE : PCF_REMOVED_SITE);
    }
}

/*
 * add top level site and all embedded sites (via text object)
 */
@method URLFrameClass, MSG_URL_FRAME_PC_ADD_SITE
{
    TCHAR urlbuf[HTML_STATIC_BUF], *url;

    if (pself->UFI_frameState & FS_ACTIVE) {
	/* get current URL */
	if (NamePoolInitializeDynamic(urlbuf, sizeof(urlbuf), 0, &url)) {
	@call self::MSG_URL_FRAME_COMPLETE_URL(&url);
	PCAddRemoveHostFromURL(url, pcFlags, TRUE);
	NamePoolDestroyIfDynamic(url);
	/* call text object to add all embedded sites */
	if (pself->UFI_text && !(*pcFlags & PCF_ABORT_PASSWORD)) {
	    @call (pself->UFI_text)::MSG_URL_TEXT_PC_ADD_EMBEDDED_SITES(
		pcFlags);
	}
	/* propogate to children */
	if (!(*pcFlags & PCF_ABORT_PASSWORD)) {
	    @send @frameChildren::MSG_URL_FRAME_PC_ADD_SITE(pcFlags);
	}
        }
    }
}

/*
 * remove only HTML sites, not embedded ones
 */
@method URLFrameClass, MSG_URL_FRAME_PC_REMOVE_SITE
{
    TCHAR urlbuf[HTML_STATIC_BUF], *url;

    if (pself->UFI_frameState & FS_ACTIVE) {
	/* get current URL */
	if (NamePoolInitializeDynamic(urlbuf, sizeof(urlbuf), 0, &url)) {
	@call self::MSG_URL_FRAME_COMPLETE_URL(&url);
	PCAddRemoveHostFromURL(url, pcFlags, FALSE);
	NamePoolDestroyIfDynamic(url);
	/* call text object to add all embedded sites */
	if (pself->UFI_text && !(*pcFlags & PCF_ABORT_PASSWORD)) {
	    @call (pself->UFI_text)::MSG_URL_TEXT_PC_REMOVE_EMBEDDED_SITES(
		pcFlags);
	}
	/* propogate to children */
	if (!(*pcFlags & PCF_ABORT_PASSWORD)) {
	    @send @frameChildren::MSG_URL_FRAME_PC_REMOVE_SITE(pcFlags);
	}
	}
    }
}

@endif

@ifdef COMPILE_OPTION_SECURE_STATUS

/*
 * update secure icon
 */
@method URLFrameClass, MSG_URL_FRAME_UPDATE_SECURE_ICON
{
    TCHAR urlBuf[HTML_STATIC_BUF], *url;
    TCHAR type[URL_MAX_TYPE];
    optr offHelp = @SecureStatusOffHelp;
    optr onHelp = @SecureStatusOnHelp;

    if (pself->UFI_frameState & FS_ACTIVE) {
	/* get current URL, if not passed */
	if (urlT == NAME_POOL_NONE) {
	    if (!NamePoolInitializeDynamic(urlBuf, sizeof(urlBuf), 0, &url))
		return;
	    @call self::MSG_URL_FRAME_COMPLETE_URL(&url);
	    ToolsParseURL(url, type, NULL, NULL);
	} else {
	    NamePoolCopy(namePool, urlBuf, sizeof(urlBuf), urlT, &url);
	    ToolsParseURL(url, type, NULL, NULL);
	}
	NamePoolDestroyIfDynamic(url);
	if (strcmp(type, _TEXT("HTTPS")) == 0) {
	    @call SecureStatus::MSG_GEN_USE_VIS_MONIKER(
		@SecureStatusOnMoniker, VUM_NOW);
	    @call SecureStatus::MSG_META_ADD_VAR_DATA(
		ATTR_GEN_FOCUS_HELP, sizeof(optr), &onHelp);
	} else {
	    @call SecureStatus::MSG_GEN_USE_VIS_MONIKER(
		@SecureStatusOffMoniker, VUM_NOW);
	    @call SecureStatus::MSG_META_ADD_VAR_DATA(
		ATTR_GEN_FOCUS_HELP, sizeof(optr), &offHelp);
	}
    }
}

@endif

@ifdef JAVASCRIPT_SUPPORT
/***************************************************************************
 *              JS-related methods of URL Frame Class
 ***************************************************************************/

#pragma codeseg FRAME_JS_TEXT
/* String constants would still go into the original codeseg... */
#pragma option -dc-

@method URLFrameClass, MSG_URL_FRAME_CAN_WINDOW_OPEN
{
    return (pself->UFI_canWindowOpen);
}

@extern chunk MsgScriptStatusError;
@ifndef JS_ERROR_DIALOG
extern MemHandle jsErrorString;
@endif

void SetJSError(optr frame, Boolean state)
{
    optr doc = @call frame::MSG_URL_FRAME_GET_DOCUMENT_OBJ();

    /* always update status bar (even if using dialog error) */
    MemLock(OptrToHandle(@MsgScriptStatusError));
    @CallStatusUpdate(state ? LMemDeref(@MsgScriptStatusError) : _TEXT(""),
		      HTML_STATUS_TYPE_JAVASCRIPT_ERROR);
    MemUnlock(OptrToHandle(@MsgScriptStatusError));
@ifndef JS_ERROR_DIALOG
    /* clear error string */
    if (!state && jsErrorString) {
	MemFree(jsErrorString);
	jsErrorString = 0;
    }
@endif

    if (doc) {
	@call doc::MSG_URL_DOCUMENT_SET_JS_ERROR(state);
    }
}

@method URLFrameClass, MSG_URL_FRAME_SET_JS_ERROR
{
    SetJSError(oself, TRUE);
}

Boolean GetJSError(optr frame)
{
    Boolean ret = FALSE;

    optr doc = @call frame::MSG_URL_FRAME_GET_DOCUMENT_OBJ();

    if (doc) {
	ret = @call doc::MSG_URL_DOCUMENT_GET_JS_ERROR();
    }
    return ret;
}

@method URLFrameClass, MSG_URL_FRAME_CREATE_SCRIPT_CONTEXT
{
    /* Back up over dummy levels, if any */
    if(pself->UFI_frameState & FS_DUMMY)
    {
      optr parent = @call self::MSG_URL_FRAME_FIND_PARENT();
      @call parent::MSG_URL_FRAME_CREATE_SCRIPT_CONTEXT();
      return;
    }

    /* notify document, the keeper for the haveJS flag */
    @call (pself->UFI_document)::MSG_URL_DOCUMENT_SET_JS();

    /* Don't initialize global script context twice */
    if(!jsecontext)
      InitBrowserJS();

    /* Don't initialize window-specific context twice */
    if(!pself->UFI_hasScriptContext)
    {
      pself->UFI_hasScriptContext = TRUE;
      SetJSError(oself, FALSE);  /* clear error */
      jseEnter();
      browserInitWindow(jsecontext, (struct BrowserWindow *)oself);
#ifdef EXTRA_GC
      /* collect garbage from initialization */
      jseGarbageCollect(jsecontext, JSE_GARBAGE_COLLECT);
#endif
      jseLeave();
    }
}

void GetEventName(char *evtname, NameToken code, optr frame)
{
@ifdef DO_DBCS
    sprintfsbcs(evtname, "_event_%04x_%d", OptrToHandle(frame), code);
@else
    sprintf(evtname, "_event_%04x_%d", OptrToHandle(frame), code);
@endif
}

@method URLFrameClass, MSG_URL_FRAME_DESTROY_SCRIPT_CONTEXT
{
    optr document = NullOptr;
    ChunkHandle evtArray = pself->UFI_eventsList;
    MemHandle mem = OptrToHandle(oself);
    ChunkHandle *evtP;
    word i, count, size;
    char evtname[50];

    /* Back up over dummy levels, if any */
    if(pself->UFI_frameState & FS_DUMMY)
    {
      optr parent = @call self::MSG_URL_FRAME_FIND_PARENT();
      @call parent::MSG_URL_FRAME_DESTROY_SCRIPT_CONTEXT(fullDestroy);
      return;
    }

    @call oself::MSG_URL_FRAME_KILL_ALL_TIMEOUTS() ;

    /* Don't destroy uninitialized script context */
    if(pself->UFI_hasScriptContext)
    {
      pself->UFI_hasScriptContext = FALSE;
      if (jsecontext) {
      jseEnter();

      /* remove events from global object for this frame */
      if (evtArray) {
	  count = ChunkArrayGetCountHandles(mem, evtArray);
	  for (i = 0; i < count; i++) {
	      evtP = ChunkArrayElementToPtrHandles(mem, evtArray, i, &size);
	      GetEventName(evtname, *evtP, oself);
	      jseDeleteMember(jsecontext, globalObject, evtname);
	  }
	  LMemFreeHandles(mem, evtArray);
	  pself->UFI_eventsList = NullHandle;
      }

      browserTermWindow(jsecontext, (struct BrowserWindow *)oself);
#ifdef EXTRA_GC
      jseGarbageCollect(jsecontext, JSE_GARBAGE_COLLECT);
#endif
      jseLeave();
      }
    }
    /* additionally, if we are top frame, exit a bit more aggressively to
       clear up memory as much as possible between pages */
    if (fullDestroy && jsecontext) {
	document = @call oself::MSG_URL_FRAME_GET_DOCUMENT_OBJ();
	if (document && (oself == @call document::MSG_URL_DOCUMENT_GET_TOP_FRAME())) {
	    /* clear flag all the way down the tree */
	    @call oself::MSG_URL_FRAME_CLEAR_SCRIPT_CONTEXT_STATE();
	    ExitBrowserJS();
	    jsecontext = NULL;
	}
    }
    SetJSError(oself, FALSE);  /* clear error */
}

@method URLFrameClass, MSG_URL_FRAME_INTERPRET_SCRIPT_SOURCE
{
    jseVariable ret;
    optr text;
    char ref[9];

    /* bail if error */
    if (GetJSError(oself)) return FALSE;

    /* Back up over dummy levels, if any */
    if(pself->UFI_frameState & FS_DUMMY)
    {
      optr parent = @call self::MSG_URL_FRAME_FIND_PARENT();
      return @call parent::MSG_URL_FRAME_INTERPRET_SCRIPT_SOURCE(bss);
    }

    /* Make sure that the scripting context for this window is initialized */
    @call self::MSG_URL_FRAME_CREATE_SCRIPT_CONTEXT();
    /* Make sure initialized for all frames (for cross frame scripting) */
    @call (pself->UFI_document)::MSG_URL_DOCUMENT_ENSURE_SCRIPT_CONTEXT();

    /* Wrap reference into something that looks like a filename... */
@ifdef DO_DBCS
    sprintfsbcs(ref,"%08lx",(dword)bss);
@else
    sprintf(ref,"%08lx",(dword)bss);
@endif

    jseEnter();
    ret = browserInterpret(jsecontext, (struct BrowserWindow *)oself, ref);
    if(ret)
      jseDestroyVariable(jsecontext, ret);

    /* after running, clean up memory as much as possible */
#ifdef EXTRA_GC
    if (pself->UFI_hasScriptContext)
	jseGarbageCollect(jsecontext, JSE_GARBAGE_COLLECT);
#endif
    jseLeave();

    /* if any layout changes (because of image changes), update */
    text = @call self::MSG_URL_FRAME_FIND_TEXT_OBJECT();
    if (text) {
	/* this is very fast if there are no layout changes */
	@send, forceQueue text::MSG_HTML_TEXT_CALCULATE_LAYOUT();
    }

    return TRUE;
}

@method URLFrameClass, MSG_URL_FRAME_INTERPRET_SCRIPT_TOKEN
{
    BrowserScriptSource bss;

    bss.BSS_isToken = TRUE;             // code is in NameToken
    bss.BSS_data.token.code = tok;      // reference to huge array
    bss.BSS_offset = offset;            // position to start at

    /* Pass script through interpreter */
    return @call self::MSG_URL_FRAME_INTERPRET_SCRIPT_SOURCE(&bss);
}

@method URLFrameClass, MSG_URL_FRAME_INTERPRET_SCRIPT_HA
{
    BrowserScriptSource bss;

    bss.BSS_isToken = FALSE;            // code is in huge array
    bss.BSS_data.array.vmf = vmf;       // reference to huge array
    bss.BSS_data.array.vmb = vmb;
    bss.BSS_offset = offset;            // position to start at

    /* Pass script through interpreter */
    return @call self::MSG_URL_FRAME_INTERPRET_SCRIPT_SOURCE(&bss);
}

@method URLFrameClass, MSG_URL_FRAME_HANDLE_EVENT
{
    TCHAR buf[256], *p;
    char evtname[50];
    jseVariable thisvar = NULL, func;
    jseVariable retVar = NULL;
    Boolean ret = TRUE;
    jseStack stack;
    optr text = @call self::MSG_URL_FRAME_FIND_TEXT_OBJECT();
    optr textPool = @call text::MSG_HTML_TEXT_GET_NAME_POOL();
    NameToken textPoolCode;

    /* bail if error */
    if (GetJSError(oself)) return FALSE;

    /* let's get all the way down here before we abort */
    if (!(@call HTMLSettingsBoolGroup::
	MSG_GEN_BOOLEAN_GROUP_GET_SELECTED_BOOLEANS() & HTML_JAVASCRIPT))
	return TRUE;  /* execute event (i.e. submit) */

    /* Back up over dummy levels, if any */
    if(pself->UFI_frameState & FS_DUMMY)
    {
      optr parent = @call self::MSG_URL_FRAME_FIND_PARENT();
      return @call parent::MSG_URL_FRAME_HANDLE_EVENT(evt, type, obj, code);
    }

    /* allow window.open for events where users click */
    if (evt == HTML_EVENT_CHANGE || evt == HTML_EVENT_SUBMIT ||
	evt == HTML_EVENT_SELECT || evt == HTML_EVENT_CLICK)
	pself->UFI_canWindowOpen = TRUE;
    /* Make sure that the scripting context for this window is initialized */
    @call self::MSG_URL_FRAME_CREATE_SCRIPT_CONTEXT();
    /* Make sure initialized for all frames (for cross frame scripting) */
    @call (pself->UFI_document)::MSG_URL_DOCUMENT_ENSURE_SCRIPT_CONTEXT();

    /* clear previous abort, if any */
    if (UserAbortCheck()) UserAbortEnd();

    /* clear JS error message (since we allow events to run again after
       event-generated error), note that this occurs after the initial
       error check above, so it only clears the error message, not the
       error state itself */
    SetJSError(oself, FALSE);

    jseEnter();
    switch(type)
    {
      case HTML_EVENT_OBJECT_BODY:
      case HTML_EVENT_OBJECT_FRAMESET:
        thisvar = JSWindowObject(jsecontext, oself);
        break;

      case HTML_EVENT_OBJECT_IMAGE:
        thisvar = JSImageObject(jsecontext, oself, obj);
        break;

      case HTML_EVENT_OBJECT_FORM:
        thisvar = JSFormObject(jsecontext, text, obj);
        break;

      case HTML_EVENT_OBJECT_ELEMENT:
        thisvar = JSElementObject(jsecontext, text, obj);
        break;

      case HTML_EVENT_OBJECT_LINK:
      case HTML_EVENT_OBJECT_AREA:
        thisvar = JSLinkObject(jsecontext, oself, obj);
        break;
    }

    /* code is in local name pool, want text object pool's version */
    textPoolCode = NamePoolTokenizeFromPool(textPool, namePool, code, FALSE);
    GetEventName(evtname, textPoolCode, oself);
    NamePoolReleaseToken(textPool, textPoolCode);
    func = jseGetMemberEx(jsecontext, globalObject, evtname, jseCreateVar);

    /* interpret event if it wasn't already - will be reused in the future */
    if( func==NULL )
    {
      ChunkHandle array;
      MemHandle mem = OptrToHandle(oself);
@ifdef DO_DBCS
      DosCodePage cp = G_codePage;
      word len, status, backup;
@endif

      NamePoolCopy(namePool, buf, sizeof(buf), code, &p);
@ifdef DO_DBCS
      /* DBCS TBD: convert JS code to SBCS */
      len = strlen(p)+1;  /* include null */
      LocalGeosToDos(p, p, &len, DEFCHAR, &cp, 0, &status, &backup);
@endif
      func = browserEventHandler(jsecontext, (struct BrowserWindow *)oself,
        evtname, p, globalObject);
      NamePoolDestroyIfDynamic(p);
      /* add to our list of event handlers */
      pself = ObjDeref(oself, 0);
      array = pself->UFI_eventsList;
      if (!array) {
	  array = ChunkArrayCreate(mem, sizeof(ChunkHandle), 0, 0);
	  pself = ObjDeref(oself, 0);
	  pself->UFI_eventsList = array;
      }
      /* textPoolCode value still valid here */
      *((ChunkHandle *)(ChunkArrayAppendHandles(mem, array, sizeof(ChunkHandle)))) = textPoolCode;
    }

    if( func!=NULL )
    {
      stack = jseCreateStack(jsecontext);
      browserCallFunction(jsecontext,func,stack,&retVar,thisvar,(struct BrowserWindow *)oself);
      if (retVar)
      {
          /* The convention used for interpreting script return values is that
             every non-boolean return value (including "0" and "undefined") is
             treated as being "true". Only "false" is "false". It's true. */
          if( jseGetType(jsecontext, retVar) == jseTypeBoolean )
	    ret = jseGetBoolean(jsecontext, retVar);
          else
            ret = TRUE;
      }
      jseDestroyStack(jsecontext,stack);
    }

    if(func)
      jseDestroyVariable(jsecontext, func);
    if(thisvar)
      jseDestroyVariable(jsecontext, thisvar);

#ifdef EXTRA_GC
    /* after running, clean up memory as much as possible */
    jseGarbageCollect(jsecontext, JSE_GARBAGE_COLLECT);
#endif

    jseLeave();

    /* if any layout changes (because of image changes), update */
    text = @call self::MSG_URL_FRAME_FIND_TEXT_OBJECT();
    if (text) {
	/* this is very fast if there are no layout changes */
	@send, forceQueue text::MSG_HTML_TEXT_CALCULATE_LAYOUT();
    }

    /* if there are new pending document.writes from event, flush them */
    @call self::MSG_URL_FRAME_FLUSH_SCRIPT_SRC();

    /* if user-click event, clear any error to allow user to try again,
       since event-generated error may not affect other events */
    if (evt == HTML_EVENT_CHANGE || evt == HTML_EVENT_SUBMIT ||
	evt == HTML_EVENT_SELECT || evt == HTML_EVENT_CLICK) {
	/* only clear error flag, leave most recent error message active */
	optr doc = @call oself::MSG_URL_FRAME_GET_DOCUMENT_OBJ();
	if (doc) {
	    @call doc::MSG_URL_DOCUMENT_SET_JS_ERROR(FALSE);
	}
    }

    return ret;
}

/*-------------------------------------------------------------------------
 | FrameTimer Code:
 *------------------------------------------------------------------------*/
typedef struct {
	word ST_uniqueID ;

    NameToken ST_codeToRun ;
	dword ST_interval ;			/* millisecs */
	Boolean ST_isIntervalTimer ;

    TimerHandle ST_timer ;
    word ST_timerID ;
} ScriptTimer ;

typedef struct {
	ChunkArrayHeader STH_meta ;
	word STH_lastUnique ;
} ScriptTimersHeader ;

/*-------------------------------------------------------------------------
 | Method:  URLFrameClass::MSG_URL_FRAME_START_TIMER
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Create a timeout timer and tell when to have it occur
 |
 | Inputs:
 |    dword millisecs             -- When to fire off
 |    NameToken codeToRun         -- Javascript to execute when fired
 |    Boolean isIntervalTimer     -- FALSE for one shot, TRUE for multiple
 |
 | Outputs:
 |    FrameTimerID                -- Unique identifier to the timer
 |                                   returns FRAME_TIMER_ID_BAD if failed.
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  09/15/00  Created
 |    LES  10/20/00  Renamed and restructured for interval timers
 |
 *-----------------------------------------------------------------------*/
@method URLFrameClass, MSG_URL_FRAME_START_TIMER
{
    ChunkHandle timeout = FRAME_TIMER_ID_BAD ;
    ScriptTimer *p_timer ;
	ScriptTimersHeader *p_header ;
    MemHandle mem = OptrToHandle(oself) ;
	ChunkHandle array ;

    if (codeToRun != NAME_POOL_NONE)  {
		/* If we don't have a list yet, we'll need to create it */
		if (!pself->UFI_timeoutList)  {
			array = ChunkArrayCreate(mem, sizeof(ScriptTimer), sizeof(ScriptTimersHeader), 0) ;
			pself = ObjDeref(oself, 0) ;
			pself->UFI_timeoutList = array ;
			p_header = LMemDerefHandles(mem, array) ;
			p_header->STH_lastUnique = 1 ;
		}

		/* Create another timer spot */
		p_timer = ChunkArrayAppendHandles(mem, pself->UFI_timeoutList, 1) ;
        if (p_timer)  {
			/* Allocation my invalidate pself */
            pself = ObjDeref(oself, 0);

			/* Look at the header for the next timer id */
			p_header = LMemDerefHandles(mem, pself->UFI_timeoutList) ;

			/* Use the id and move to the next one */
			timeout = p_timer->ST_uniqueID = p_header->STH_lastUnique++ ;
			if (!p_header->STH_lastUnique)
				p_header->STH_lastUnique++ ;

			/* Timer triggers what code? when? repeat? */
            p_timer->ST_codeToRun = codeToRun ;
			p_timer->ST_interval = millisecs ;
			p_timer->ST_isIntervalTimer = isIntervalTimer ;

			/* Start the timer */
            p_timer->ST_timer =
                TimerStart(
                    TIMER_EVENT_ONE_SHOT,
                    oself,
                    (millisecs*6L)/100L,  /* Convert from 1000 ticks per second to 60 ticks per second */
                    MSG_URL_FRAME_TIMER_EXPIRED,
                    0,
                    &p_timer->ST_timerID) ;
        }
    }

    return timeout ;
}

/*-------------------------------------------------------------------------
 | Method:  URLFrameClass::MSG_URL_FRAME_STOP_TIMER
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Destroy a previously created timeout using the handle returned
 |    from MSG_URL_FRAME_START_TIMER (a chunk handle to the individual
 |    TimeoutCode struct).
 |
 | Inputs:
 |    FrameTimerID uniqueTimerID  -- Handle to ScriptTimer struct
 |                                   in with this frame's ObjBlock
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  09/15/00  Created
 |    LES  10/20/00  Renamed and restructured for interval timers
 |
 *-----------------------------------------------------------------------*/
@method URLFrameClass, MSG_URL_FRAME_STOP_TIMER
{
	optr array ;
	word i, n ;
    ScriptTimer *p_timer ;
	word size ;

	/* Find the timer's structure */
	if (pself->UFI_timeoutList)  {
		array = ConstructOptr(OptrToHandle(oself), pself->UFI_timeoutList) ;
		n = ChunkArrayGetCount(array) ;
		for (i=0; i<n; i++)  {
			p_timer = ChunkArrayElementToPtr(array, i, &size) ;
			if (p_timer->ST_uniqueID == uniqueTimerID)  {
				/* stop the timer (if not already gone) */
				if (p_timer->ST_timer)  {
					TimerStop(
						p_timer->ST_timer,
						p_timer->ST_timerID) ;
					p_timer->ST_timer = NullHandle ;
				}

				/* Release associated code */
				if (p_timer->ST_codeToRun)  {
					NamePoolReleaseToken(namePool, p_timer->ST_codeToRun) ;
					p_timer->ST_codeToRun = NULL ;
				}

				/* Destroy this timer */
				ChunkArrayDelete(array, p_timer) ;
				break ;
			}
		}
	}
}

/*-------------------------------------------------------------------------
 | Method:  URLFrameClass::MSG_URL_FRAME_TIMER_EXPIRED
 *-------------------------------------------------------------------------
 |
 | Description:
 |    This method is called when one of the timers on this frame has
 |    expired.  This routine looks through the current list of timers,
 |    fires off the associated javascript code, and then destroys
 |    the timeout or fires out another interval.
 |
 | Inputs:
 |    word timerID                -- Unique ID for this timer
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  09/15/00  Created
 |
 *-----------------------------------------------------------------------*/
@method URLFrameClass, MSG_URL_FRAME_TIMER_EXPIRED
{
	optr array ;
	word i, n ;
    ScriptTimer *p_timer ;
	word size ;

	/* Find the timer's structure */
	if (pself->UFI_timeoutList)  {
		array = ConstructOptr(OptrToHandle(oself), pself->UFI_timeoutList) ;
		n = ChunkArrayGetCount(array) ;
		for (i=0; i<n; i++)  {
			p_timer = ChunkArrayElementToPtr(array, i, &size) ;
			if (p_timer->ST_timerID == timerID)  {
				/* Mark the timer as dead */
				p_timer->ST_timer = NullHandle ;

				/* Execute the script */
				@call oself::MSG_URL_FRAME_INTERPRET_SCRIPT_TOKEN(p_timer->ST_codeToRun, 0);

				/* Deref again in case something changed in the frame */
				p_timer = ChunkArrayElementToPtr(array, i, &size) ;
				if (p_timer->ST_isIntervalTimer)  {
					/* Start the timer (again) */
					p_timer->ST_timer =
						TimerStart(
							TIMER_EVENT_ONE_SHOT,
							oself,
							(p_timer->ST_interval*6L)/100L,  /* Convert from 1000 ticks per second to 60 ticks per second */
							MSG_URL_FRAME_TIMER_EXPIRED,
							0,
							&p_timer->ST_timerID) ;
				} else {
					/* Kill this timer for good */
					/* Release associated code */
					if (p_timer->ST_codeToRun)  {
						NamePoolReleaseToken(namePool, p_timer->ST_codeToRun) ;
						p_timer->ST_codeToRun = NULL ;
					}

					/* Destroy this timer */
					ChunkArrayDelete(array, p_timer) ;
				}
				break ;
			}
		}
	}
}

/*-------------------------------------------------------------------------
 | Method:  URLFrameClass::MSG_URL_FRAME_KILL_ALL_TIMEOUTS
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Go through all the timeouts in the link list at UFI_timeoutList
 |    and destroy them.
 |    Call this method to ensure all memory is also freed by the timers.
 |
 |    NOTE:  This method does not recursively call the heirarchy of the
 |    Frame tree
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  09/16/00  Created
 |
 *-----------------------------------------------------------------------*/
@method URLFrameClass, MSG_URL_FRAME_KILL_ALL_TIMEOUTS
{
	optr array ;
    ScriptTimer *p_timer ;
	word size ;
	word i, n ;

    /* Keep pulling them off the front until they are all gone */
	if (pself->UFI_timeoutList)  {
		array = ConstructOptr(
					OptrToHandle(oself),
					pself->UFI_timeoutList) ;
		n = ChunkArrayGetCount(array) ;
		for (i=0; i<n; i++)  {
			p_timer = ChunkArrayElementToPtr(array, 0, &size) ;

			/* stop the timer (if not already gone) */
			if (p_timer->ST_timer)  {
				TimerStop(
					p_timer->ST_timer,
					p_timer->ST_timerID) ;
				p_timer->ST_timer = NullHandle ;
			}

			/* Release associated code */
			if (p_timer->ST_codeToRun)  {
				NamePoolReleaseToken(namePool, p_timer->ST_codeToRun) ;
				p_timer->ST_codeToRun = NULL ;
			}

			/* Destroy this timer */
			ChunkArrayDelete(array, p_timer) ;
		}

		/* Destroy the list totally.  This ensures we don't */
		/* have any leaky blocks if others always call here before */
		/* freeing the URLFrame object. */
		LMemFree(array) ;
		pself->UFI_timeoutList = NullHandle ;
	}
}

/*
 *  Clear frame from object cache.
 */
@method URLFrameClass, MSG_URL_FRAME_CLEAR_OBJ_CACHE
{
    if(pself->UFI_frameState & FS_ACTIVE)
    {                                   /* only process active branches */
      if (pself->UFI_currentURL != NAME_POOL_NONE)
	  (void)ObjCacheForceNocache(OCT_TEXTOBJ, pself->UFI_currentURL);
      @send @frameChildren::MSG_URL_FRAME_CLEAR_OBJ_CACHE();
    }
}

@method URLFrameClass, MSG_URL_FRAME_SET_NO_URL
{
    pself->UFI_noURL = TRUE;
}

/*
 *  Clear frame hasScriptContext flag.
 */
@method URLFrameClass, MSG_URL_FRAME_CLEAR_SCRIPT_CONTEXT_STATE
{
    if(pself->UFI_frameState & FS_ACTIVE)
    {                                   /* only process active branches */
      pself->UFI_hasScriptContext = FALSE;
      @send @frameChildren::MSG_URL_FRAME_CLEAR_SCRIPT_CONTEXT_STATE();
    }
}

@method URLFrameClass, MSG_URL_FRAME_ENSURE_SCRIPT_CONTEXT
{
    if(pself->UFI_frameState & FS_ACTIVE)
    {                                   /* only process active branches */
      if (pself->UFI_hasScriptContext == FALSE) {
	  @call oself::MSG_URL_FRAME_CREATE_SCRIPT_CONTEXT();
      }
      @send @frameChildren::MSG_URL_FRAME_ENSURE_SCRIPT_CONTEXT();
    }
}

@method URLFrameClass, MSG_URL_FRAME_GET_FRAME_LEVEL
{
    return (pself->UFI_frameLevel);
}

@method URLFrameClass, MSG_URL_FRAME_GET_OPENER
{
    return (pself->UFI_opener);
}

@method URLFrameClass, MSG_URL_FRAME_SET_OPENER
{
    pself->UFI_opener = opener;
}

@endif
