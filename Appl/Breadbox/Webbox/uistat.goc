/***********************************
 * Copyright (C) 1995 Clemens Kochinke d/b/a/ FuzzyLogicTM
 * File Handling Portions:
 * Copyright (C) Blue Marsh Softworks 1995 -- All Rights Reserved
 * Portions Copyright (c) Geoworks 1992 -- All Rights Reserved
 * PROJECT:  Web Editor Jupiter 2Web version 1
 * MODULE:   Objects Module
 * FILE:     appUI.goc
 * AUTHORS:  Lawrence Hosken: Sep 21, 1992
 *           Nathan Fiedler:  Apr 1, 1995
 *           Clemens Kochinke:  December 29, 1995
 *
 * Other important contributors
 * 	John Howard, Ray Kopczynski, Lee Grant
 *	Dave Challener, Dirk Haase, Mark Tenney
 *
 * REVISION HISTORY:
 *      Name   Date      Description
 *      ----   ----      -----------
 *      LH     09/21/92  Initial version
 *      EB     12/16/93  Fixed up scrolling, default focus, and
 *                       targeting Text object for EditControl.
 *      NF     04/01/95  Started work on Zoomer Text File Editor
 *      NF     06/04/95  End of beta phase
 *      CK     12/29/95  Completed version 1 of web editor
 *      CK     5/26/96   Revision with large text object
 *      CK     2/22/97   Revision for Breadbox, added 3.2 HTML, UI db's,
 *                       user advisories.
 *	RB     3/25/24	 Updated for Free PC/GEOS Ensemble	
 *
 * DESCRIPTION:
 *      This is a simple web page editor based primarily on Nathan Fiedler's
 *      text file editor made for the Zoomer and other GEOS-based PDAs.
 *      This module contains some static objects (top of UI tree).
 **********************************************/
/*****************Headers**********************/
    @include <stdapp.goh> /* Includes classes and constants. */
    @include <Objects/vLTextC.goh>
    @include <Objects/Text/tCtrlC.goh> /* SearchReplaceControlClass */
    @include <spell.goh>               /* Spell library */
    @include <spool.goh>               /* Spool library */
    #include <print.h>                 /* Printer definitions */
/*    @include <objects/GViewcc.goh>     View control*/
    #include <gstring.h>
    @include "app.goh" /* Includes classes and constants. */
/*    @include <netjet1.goh>              Icon */
    @include <icons/bbxwebed.goh>
/*****************Global Definitions************/
       /* Current point size of text. */
    WWFixed pointSize_g;
       /* Current font ID of text. */
    FontID fontID_g;
/******************Class Declarations************/
    @classdecl HTMProcessClass, neverSaved;
    @classdecl HTMPrimaryClass;
    @classdecl HTMDocumentClass;
    @class HTMTextClass, VisLargeTextClass;
      /* TRUE if text changes mean document changes. */
      @instance Boolean HTMTI_allowChanges;
    @endc;
    @classdecl HTMTextClass;
@classdecl FixedGenValueClass;
@classdecl SampleColorClass;
/******************Method Declarations***********/
    @extern method HTMProcessClass, MSG_GEN_PROCESS_OPEN_APPLICATION;
    @extern method HTMProcessClass, MSG_GEN_PROCESS_CLOSE_APPLICATION;
    @extern method HTMProcessClass, MSG_META_SAVE_OPTIONS;
    @extern method HTMProcessClass, MSG_GEN_PROCESS_TOGGLE_TOOL_BAR;
    @extern method HTMProcessClass, MSG_GEN_PROCESS_TOGGLE_BUTTON_BAR;
    @extern method HTMProcessClass, MSG_GEN_PROCESS_TOGGLE_SPEEDTAG_BAR;
    @extern method HTMProcessClass, MSG_GEN_PROCESS_OPEN_CWEB;
    @extern method HTMProcessClass, MSG_FL_FILE_SIZE;
    @extern method HTMProcessClass, MSG_FL_FS_GO;
    @extern method HTMProcessClass, /*(GEN_ITEM_GROUP_STATUS_MSG)*/ MSG_COLOR_CHANGED;

    @extern method HTMPrimaryClass, MSG_GEN_DISPLAY_CLOSE;
    @extern method HTMDocumentClass, MSG_GEN_PROCESS_REDRAW_GENVIEW;
    @extern method HTMDocumentClass,
                       MSG_GEN_DOCUMENT_INITIALIZE_DOCUMENT_FILE;
    @extern method HTMDocumentClass,
                       MSG_GEN_DOCUMENT_ATTACH_UI_TO_DOCUMENT;
    @extern method HTMDocumentClass,
                       MSG_GEN_DOCUMENT_DETACH_UI_FROM_DOCUMENT;
    @extern method HTMDocumentClass, MSG_GEN_DOCUMENT_ATTACH_FAILED;
    @extern method HTMDocumentClass, MSG_GEN_DOCUMENT_OPEN;
    @extern method HTMDocumentClass, MSG_GEN_DOCUMENT_PHYSICAL_REVERT;
    @extern method HTMDocumentClass, MSG_GEN_DOCUMENT_PHYSICAL_SAVE,
                                     MSG_GEN_DOCUMENT_PHYSICAL_UPDATE;
    @extern method HTMDocumentClass,
                       MSG_GEN_DOCUMENT_PHYSICAL_SAVE_AS_FILE_HANDLE;

    @extern method HTMDocumentClass, MSG_TAG_ONE;
    @extern method HTMDocumentClass, MSG_TAG_TWO;
    @extern method HTMDocumentClass, MSG_TAG_THREE;
    @extern method HTMDocumentClass, MSG_TAG_FOUR;
    @extern method HTMDocumentClass, MSG_BUTTON_CASE;
    @extern method HTMDocumentClass, MSG_FL_JAVA;
    @extern method HTMDocumentClass, MSG_FL_OBLET;
    @extern method HTMDocumentClass, MSG_SPEED_TAG;

    @extern method HTMTextClass, MSG_META_TEXT_USER_MODIFIED;
    @extern method HTMTextClass, MSG_PRINT_START_PRINTING;
    @extern method HTMTextClass, MSG_VIS_TEXT_SET_POINT_SIZE;
    @extern method HTMTextClass, MSG_VIS_TEXT_FREE_ALL_STORAGE;
    @extern method HTMTextClass, MSG_VIS_TEXT_REPLACE_WITH_HWR;

    @extern method SampleColorClass, MSG_VIS_RECALC_SIZE;
    @extern method SampleColorClass, MSG_VIS_DRAW;
    @extern method HTMProcessClass, MSG_COLOR_CHANGED;
    @extern method FixedGenValueClass, MSG_GEN_VALUE_SET_VALUE_FROM_RATIO;

@extern object @FileBox;

    /*************************************************/

@start AppResource;

@object GenApplicationClass HTMApp = {
        GI_visMoniker = list { @HTMTextMoniker,
              @BBXWebEd, @BBXWebEd1, @BBXWebEd2, @BBXWebEd3 };

        GI_comp = @HTMPrimary
         /*now dyn. added:  , @EntryBox, @HeaderBox, JavaBox */;

  gcnList( MANUFACTURER_ID_GEOWORKS, GAGCNLT_WINDOWS ) = @HTMPrimary;
  gcnList( MANUFACTURER_ID_GEOWORKS, MGCNLT_ACTIVE_LIST ) =
           @HTMDocumentControl, @HTMPrintControl, @HTMDisplayControl ;
/*gcnList( MANUFACTURER_ID_GEOWORKS, \
        GAGCNLT_APP_TARGET_NOTIFY_SEARCH_SPELL_CHANGE) =
                @HTMSpellControl; removed in jw96 */
  gcnList( MANUFACTURER_ID_GEOWORKS, MGCNLT_APP_STARTUP ) =
                @HTMDocumentControl;
  gcnList( MANUFACTURER_ID_GEOWORKS, GAGCNLT_STARTUP_LOAD_OPTIONS ) =
                @HTMToolControl;
  gcnList( MANUFACTURER_ID_GEOWORKS, GAGCNLT_SELF_LOAD_OPTIONS ) =
                @HTMDocumentControl, @HTMEditControl, @HTMFontControl,
                @HTMSearchReplaceControl, @HTMToolControl, @HTMPrintControl,
                @HTMPtSizeControl, @HTMSpellControl, @HTMThesControl,
                @HTMCharFGColorControl, @HTMCharBGColorControl,
                @HTMDisplayControl;
  HINT_APP_IS_PRODUCTIVITY_ORIENTED;
  ATTR_GEN_INIT_FILE_CATEGORY = INI_CATEGORY;
  ATTR_GEN_APPLICATION_PRINT_CONTROL = @HTMPrintControl;
    ATTR_GEN_HELP_FILE = "WebBoxHelp";
}

@visMoniker HTMTextMoniker = "WebBox";

@end AppResource;
/**************************************
 *       Main UI Tree
 **************************************/
@start Interface;
@object HTMPrimaryClass HTMPrimary = {
  GI_attrs = @default | GA_KBD_SEARCH_PATH;
  GI_comp = @HTMFileGroup, @HTMGEOSGroup, @HTMToolbar, @HTMDisplayGroup;
  ATTR_GEN_HELP_CONTEXT = "TOC";
  HINT_PRIMARY_FULL_SCREEN;
/*  HINT_SIZE_WINDOW_AS_RATIO_OF_FIELD={SWSS_RATIO|PCT_90,SWSS_RATIO|PCT_70};*/
}
/* new 2/9/97 but not useful under GenPrimary:
        HINT_FULL_JUSTIFY_CHILDREN_HORIZONTALLY; */

     /**** File menu ****/

@object GenInteractionClass HTMFileGroup = {
  GI_attrs = @default | GA_KBD_SEARCH_PATH;
  GI_comp =  @HTMDocumentControl, @HTMSaveTrigger,
             HTMFileSubGroup;
/*GI_states = @default & ~GS_ENABLED; for demo version*/
  GII_visibility = GIV_POPUP;
  ATTR_GEN_INTERACTION_GROUP_TYPE = (GIGT_FILE_MENU);
  HINT_SEEK_MENU_BAR;
}

@object GenInteractionClass HTMFileSubGroup = {
  GI_comp = @HTMPrintControl, @FileBoxToggle;
}

   /**** Document control UI ****/

@object GenDocumentControlClass HTMDocumentControl = {
/*  GDCI_targetDocName = "*.HTM"; Not this! */
@ifdef E
  GDCI_noNameText = "New Page";
@endif
@ifdef D
  GDCI_noNameText = "Neue Seite";
@endif
  GDCI_documentGroup = @HTMDocumentGroup;
  GDCI_attrs =  ( @default | GDCA_MULTIPLE_OPEN_FILES |
                GDCA_NATIVE ) & ~GDCA_VM_FILE; /* for viewer: GDCM_VIEWER */
  GDCI_features = @default &
                  ~( GDCF_SUPPORTS_TEMPLATES |
                     GDCF_SUPPORTS_USER_SETTABLE_EMPTY_DOCUMENT |
                     GDCF_SUPPORTS_USER_MAKING_SHARED_DOCUMENTS  |
                     GDCF_NAME_ON_PRIMARY  );
@ifdef E
  GDCI_dialogNewText =  "\rCreate:\rCreate a Web Page.";
@endif
@ifdef D
  GDCI_dialogNewText =  "\rNeu:\rNeue Webseite anlegen.";
@endif
@ifdef E
  GDCI_dialogOpenText = "\rOpen:\rOpen a Web Page.";
@endif
@ifdef D
  GDCI_dialogOpenText = "\r�ffnen:\rWebseite �ffnen."; /*  Alt 133/154 */
@endif
  GDCI_enableDisableList = HTMDocEnableList;
  GDCI_selectorType = GFST_NON_GEOS_FILES;
//  ATTR_GEN_PATH_DATA = {SP_DOCUMENT, "Jupiter 2Web"};
  ATTR_GEN_HELP_CONTEXT = "Overview";
}
@chunk optr HTMDocEnableList[] = {
        @HTMSearchReplaceControl, @HTMPrintControl, @HTMSpellControl };

@object GenTriggerClass HTMSaveTrigger = {
@ifdef E
 GI_visMoniker = "Save File";
@endif
@ifdef D
 GI_visMoniker = 'r', "Speichern";
@endif
/* GI_states = @default & ~GS_ENABLED; new in jw96*/
 GI_states = @default & ~(GS_ENABLED | GS_USABLE); /* RB */
 				    /* Trigger obsolete? will never be enabled R.B. */
 GTI_destination = HTMDocumentControl;
 GTI_actionMsg = MSG_GEN_DOCUMENT_CONTROL_INITIATE_SAVE_DOC;
}

@object PrintControlClass HTMPrintControl = {
 PCI_attrs = @default & ~( PCA_PAGE_CONTROLS | PCA_VERIFY_PRINT ) |
          PCA_MARK_APP_BUSY | PCA_SHOW_PROGRESS | PCA_PROGRESS_PAGE;
 PCI_output = ( TO_APP_TARGET );
 PCI_docNameOutput = @HTMDocumentGroup;
 PCI_docSizeInfo = { ( 7.5 * 72 ), ( 10 * 72 ), PT_PAPER,
         { ( 0.5 * 72 ), ( 0.5 * 72 ), ( 0.5 * 72 ), ( 0.5 * 72 ) } };
 HINT_SAME_CATEGORY_AS_PARENT;
}

@object GenTriggerClass FileBoxToggle = {
@ifdef E
  GI_visMoniker = 'x', "File Box";
@endif
@ifdef D
  GI_visMoniker = 'D', "Dateifenster";
@endif
  GTI_destination = @FileBox;
  GTI_actionMsg = MSG_GEN_INTERACTION_INITIATE;
}

/* --------------================GEOS GROUP===========----------- */
@object GenInteractionClass HTMGEOSGroup = {
 GI_visMoniker='G', "GEOS";
 GI_comp = @HTMEditGroup,    @HTMSpellControlGroup,
        @HTMFontControlGroup,   @HTMPtSizeControl,
        @HTMCharFGColorControlGroup, @HTMWindowGroup,
        @HTMOptionsGroup,       @HTMToolbox;
 GII_visibility = GIV_POPUP;
 GI_attrs = @default | GA_KBD_SEARCH_PATH;
}
   /* Edit menu */
@object GenInteractionClass HTMEditGroup = {
  GI_attrs = @default | GA_KBD_SEARCH_PATH;
  GI_comp = @HTMEditControl,
            @HTMSearchReplaceControl;
  GII_visibility = GIV_POPUP;
  ATTR_GEN_INTERACTION_GROUP_TYPE = (GIGT_EDIT_MENU);
  HINT_SEEK_MENU_BAR;
}
   /* Edit tools */
@object GenEditControlClass HTMEditControl = {
  GI_attrs = @default | GA_KBD_SEARCH_PATH;
  GII_visibility = GIV_SUB_GROUP;
}
   /* Find and Replace functions. */
@object SearchReplaceControlClass HTMSearchReplaceControl = {
@ifdef E
  GI_visMoniker = 'F', "Find and Replace";
@endif
@ifdef D
  GI_visMoniker = 'S', "Suchen und ersetzen";
@endif
  GI_states = @default & ~GS_ENABLED;
  GII_visibility = GIV_DIALOG;
  ATTR_SEARCH_CONTROL_INTERACT_ONLY_WITH_TARGETED_TEXT_OBJECTS;
  ATTR_GEN_DESTINATION_CLASS = { (ClassStruct*)&HTMTextClass };
}
/* ============================= */
@object GenInteractionClass HTMSpellControlGroup = {
@ifdef E
  GI_visMoniker = 'C', "Word Check";
@endif
@ifdef D
  GI_visMoniker = 'k', "Wortkontrolle";
@endif
  GI_comp = @HTMSpellControl, @HTMThesControl;
  GII_visibility = GIV_POPUP;
  GI_attrs = @default | GA_KBD_SEARCH_PATH;
}
@object SpellControlClass HTMSpellControl = {
@ifdef E
  GI_visMoniker = 'S', "Spell Check";
@endif
@ifdef D
  GI_visMoniker = 'R', "Rechtschreibung";
@endif
  GI_states = @default & ~GS_ENABLED;
  GII_visibility = GIV_DIALOG;
  ATTR_GEN_DESTINATION_CLASS = { (ClassStruct*) &VisTextClass };
}

/* =============================*/
@visMoniker ThesIcon = {
        size = tiny;
        style = tool;
        color = color4;
        aspectRatio = normal;
        cachedSize = 19, 15;
        gstring {
                GSDrawBitmapAtCP (215),
                Bitmap (19,15,BMC_PACKBITS,(BMT_MASK|BMF_4BIT)),
                0x0c, 0xff, 0xff, 0xe0, 0x77, 0x77, 0xc4, 0x44,
                0x77,
                0x7c, 0x44, 0x47, 0x77, 0x7f,
                0x0c, 0xff, 0xff, 0xe0, 0x7c, 0xcc, 0xee, 0xee,
                0x47,
                0x4e, 0xee, 0xe4, 0x44, 0x7f,
                0x0c, 0xff, 0xff, 0xe0, 0xce, 0xee, 0x44, 0x4e,
                0xe0,
                0xee, 0x81, 0xee, 0xee, 0x4f,
                0x0c, 0xff, 0xff, 0xe0, 0xce, 0xe4, 0x4e, 0x44,
                0xe7,
                0xee, 0x81, 0x1e, 0xe7, 0x4f,
                0x0c, 0xff, 0xff, 0xe0, 0xce, 0xee, 0xee, 0x44,
                0xe0,
                0xee, 0x81, 0x1e, 0xee, 0x4f,
                0x0c, 0xff, 0xff, 0xe0, 0xce, 0xee, 0x44, 0x4e,
                0xe7,
                0xee, 0x81, 0x1e, 0xe7, 0x4f,
                0x0c, 0xff, 0xff, 0xe0, 0xce, 0xe4, 0x4e, 0xee,
                0xe0,
                0xee, 0x81, 0x0e, 0xee, 0x4f,
                0x0c, 0xff, 0xff, 0xe0, 0xce, 0xe4, 0x4e, 0x44,
                0xe7,
                0xee, 0x81, 0x0e, 0xe7, 0x4f,
                0x0c, 0xff, 0xff, 0xe0, 0xce, 0xee, 0x44, 0x4e,
                0xe0,
                0xee, 0x81, 0x0e, 0xee, 0x4f,
                0x03, 0xff, 0xff, 0xe0, 0xce, 0xfe, 0xee, 0x00,
                0xe7,
                0xfe, 0xee, 0x01, 0xe7, 0x4f,
                0x0c, 0xff, 0xff, 0xe0, 0xce, 0xee, 0x44, 0x4e,
                0xe0,
                0xee, 0x81, 0x0e, 0xee, 0x4f,
                0x0c, 0xff, 0xff, 0xe0, 0xce, 0xee, 0x44, 0x4e,
                0xe7,
                0xee, 0x81, 0x0e, 0xe7, 0x4f,
                0x03, 0xff, 0xff, 0xe0, 0xce, 0xfe, 0xee, 0x00,
                0xe8,
                0xfd, 0xee, 0x00, 0x4f,
                0x0c, 0xff, 0xff, 0xe0, 0xce, 0xee, 0xff, 0x5f,
                0xe7,
                0xef, 0x57, 0xfe, 0xe7, 0x4f,
                0x0c, 0xff, 0xfe, 0xe0, 0xce, 0xf7, 0x55, 0x85,
                0xf0,
                0xf5, 0x85, 0x5f, 0x7f, 0x4f,
                GSEndString()
        }
}
@object ThesControlClass HTMThesControl = {
  GI_visMoniker = list{ @WordThesMon /*, @ThesIcon*/ };
  GII_visibility = GIV_DIALOG;
/* added new 2/9/97 Below and ThesIcon above, but merely disables
   control, without displaying icon properly: */
/*GI_states = @default & ~GS_ENABLED;
  ATTR_GEN_DESTINATION_CLASS = { (ClassStruct*) &VisTextClass };*/
}
@ifdef E
@visMoniker WordThesMon = 'T', "Thesaurus";
@endif
@ifdef D
@visMoniker WordThesMon = 'L', "Lexikon";
@endif


/* ============================= */

@object GenInteractionClass HTMFontControlGroup = {
 GI_comp = @HTMFontControl;
@ifdef E
 GI_visMoniker = 'F', "Font";
@endif
@ifdef D
 GI_visMoniker = 'f', "Schrift";
@endif
 GII_visibility = GIV_POPUP;
 GI_attrs = @default | GA_KBD_SEARCH_PATH;
}

@object FontControlClass HTMFontControl = {
 GII_visibility = GIV_SUB_GROUP;
 ATTR_GEN_CONTROL_REQUIRE_UI = FCF_SHORT_LIST;
}
/* ============================= */
@object PointSizeControlClass HTMPtSizeControl = {
@ifdef E
  GI_visMoniker = 'S', "Sizes";
@endif
@ifdef D
  GI_visMoniker = 'r', "Gr\x9a\xa7e";
@endif
/* rem'd in jw96:*/ GII_visibility = GIV_POPUP;
  GI_attrs = @default | GA_KBD_SEARCH_PATH;
  ATTR_GEN_CONTROL_REQUIRE_TOOLBOX_UI = { PSCTF_18|PSCTF_SMALLER|PSCTF_LARGER };
}
/* ============================= */
@object GenInteractionClass HTMCharFGColorControlGroup = {
  GI_comp = @HTMCharFGColorControl, @HTMCharBGColorControl;
@ifdef E
  GI_visMoniker = 'C', "Text Color";
@endif
@ifdef D
  GI_visMoniker = 'x', "Textfarbe";
@endif
  GII_visibility = GIV_POPUP;
}
@object CharFGColorControlClass HTMCharFGColorControl = {
@ifdef E
  GI_visMoniker = 'F', "Foreground";
@endif
@ifdef D
  GI_visMoniker = 'V', "Vordergrund";
@endif
  GII_visibility = GIV_DIALOG;
  GII_type = GIT_PROPERTIES;
  CSI_toolboxPrefs=@default|(COO_TEXT_ORIENTED<<CTP_INDEX_ORIENTATION_OFFSET)
    /* | (COO_LINE_ORIENTED << CTP_DRAW_MASK_ORIENTATION_OFFSET)
       | (COO_LINE_ORIENTED << CTP_PATTERN_ORIENTATION_OFFSET)*/;
  ATTR_GEN_CONTROL_PROHIBIT_UI = CSF_PATTERN;
  ATTR_GEN_CONTROL_REQUIRE_TOOLBOX_UI = { CSTF_INDEX };
  ATTR_GEN_CONTROL_PROHIBIT_TOOLBOX_UI = {CSTF_PATTERN | CSTF_DRAW_MASK};
}
@object CharBGColorControlClass HTMCharBGColorControl = {
@ifdef E
  GI_visMoniker = 'B', "Background";
@endif
@ifdef D
  GI_visMoniker = 'H', "Hintergrund";
@endif
  GII_visibility = GIV_DIALOG;
  GII_type = GIT_PROPERTIES;
}
/* ============================= */
@object GenInteractionClass HTMWindowGroup = {
  GI_comp = @HTMDisplayControl, @HTMRedrawGenView;
  GII_visibility = GIV_POPUP;
  GI_attrs = @default | GA_KBD_SEARCH_PATH;
  ATTR_GEN_INTERACTION_GROUP_TYPE = (GIGT_WINDOW_MENU);
}
/* HTMDisplayControl */
@object GenDisplayControlClass  HTMDisplayControl = {
}
@object GenTriggerClass HTMRedrawGenView = {
@ifdef E
 GI_visMoniker = 'R', "Redraw";
@endif
@ifdef D
 GI_visMoniker = 'N', "Neu zeichnen";
@endif
 GTI_actionMsg = MSG_GEN_PROCESS_REDRAW_GENVIEW;
 GTI_destination = (TO_APP_TARGET);
 ATTR_GEN_DESTINATION_CLASS = { (ClassStruct*)&HTMDocumentClass };
}
/* ============================= */
@object GenInteractionClass HTMOptionsGroup = {
  GI_comp = @HTMToolOptions,      @HTMSaveOptsTrigger,
        @HTMToggleToolBarTrigger, @HTMToggleSpeed , @HTMToggleBarTrigger;
  GII_visibility = GIV_SUB_GROUP;
  ATTR_GEN_INTERACTION_GROUP_TYPE = (GIGT_OPTIONS_MENU);
  GI_attrs = @default | GA_KBD_SEARCH_PATH;
}
@object GenTriggerClass HTMToggleSpeed = {
@ifdef E
  GI_visMoniker = 'g', "Toggle Speed Tag Bar";
@endif
@ifdef D
  GI_visMoniker = 'T', "Speed Tag-Leiste umstellen";
@endif
  GTI_destination = process;
  GTI_actionMsg = MSG_GEN_PROCESS_TOGGLE_SPEEDTAG_BAR;
}
@object GenTriggerClass HTMToggleBarTrigger = {
@ifdef E
  GI_visMoniker = 'B', "Toggle Button Bar";
@endif
@ifdef D
  GI_visMoniker = 'B', "Speed Buttons umstellen";
@endif
  GTI_destination = process;
  GTI_actionMsg = MSG_GEN_PROCESS_TOGGLE_BUTTON_BAR;
}
@object GenTriggerClass HTMToggleToolBarTrigger = {
@ifdef E
  GI_visMoniker = 'T', "Toggle Tool Bar";
@endif
@ifdef D
  GI_visMoniker = 'I', "Ikon-Leiste umstellen"; /* plazieren ? */
@endif
  GTI_destination = process;
  GTI_actionMsg = MSG_GEN_PROCESS_TOGGLE_TOOL_BAR;
}
@object GenTriggerClass HTMSaveOptsTrigger = {
@ifdef E
  GI_visMoniker = 'S', "Save Setup";
@endif
@ifdef D
  GI_visMoniker = 'g', "Einstellung speichern";
@endif
  GTI_destination = process;
  GTI_actionMsg = MSG_META_SAVE_OPTIONS;
}
@object GenInteractionClass HTMToolOptions = {
@ifdef E
  GI_visMoniker = 'C', "Customize Tools";
@endif
@ifdef D
  GI_visMoniker = 'E', "Einstellungen \x08andern"; /* alt 138 */
@endif
  GI_comp = @HTMToolControl;
  GII_visibility = GIV_DIALOG;
}
@object GenToolControlClass HTMToolControl = {
  GTCI_toolboxList = @HTMToolboxList;
  GTCI_toolGroupList = @HTMToolGroupList;
  HINT_SAME_CATEGORY_AS_PARENT;
}
@chunk  ToolboxInfo HTMToolboxList[] = {
  { @HTMToolbar, @HTMToolbarName},  { @HTMToolbox, @HTMToolboxName}
};
@chunk ToolGroupInfo HTMToolGroupList[] = {
 {@HTMDocumentToolToolGroup}, {@HTMEditToolToolGroup},
 {@HTMFontToolGroup},         {@HTMSizeToolGroup},
 {@HTMCharFGColorControlToolGroup}, /*{@BackgroundColorTrigger},*/
/* {@HTMCharBGColorControlToolGroup},*/ {@HTMFindToolToolGroup},
 {@HTMThesToolGroup},         {@HTMSpellToolGroup},
 {@HTMPrintToolGroup}
/*,Not useful: */
/* new 2/9/97:  { HTMDisplayToolGroup}, {@BBXIconSmall} */
};

/************ Toolbar *********/
@object GenInteractionClass HTMToolbar = {
  GI_comp =     @HTMDocumentToolToolGroup,      @HTMPrintToolGroup,
                @HTMEditToolToolGroup,          @HTMFontToolGroup,
                @HTMSizeToolGroup;
  GII_visibility = GIV_POPOUT;
  HINT_TOOLBOX;
  HINT_ALLOW_CHILDREN_TO_WRAP;     /* 2/22/1997 */
  HINT_ORIENT_CHILDREN_HORIZONTALLY;
  HINT_EXPAND_WIDTH_TO_FIT_PARENT; /* 2/9/97 */
  HINT_FULL_JUSTIFY_CHILDREN_HORIZONTALLY;
}
@ifdef E
@chunk char HTMToolbarName[] = "Toolbar";
@endif
@ifdef D
@chunk char HTMToolbarName[] = "Icon-Leiste";
@endif

@object GenInteractionClass HTMToolbox = {
@ifdef E
 GI_visMoniker = 'F', "Floating Tools";
@endif
@ifdef D
 GI_visMoniker = 'z', "Werkzeugleiste";
@endif
 GI_comp = @HTMFindToolToolGroup,
              @HTMSpellToolGroup,
              @HTMThesToolGroup,
              @HTMDisplayToolGroup,
              @HTMCharFGColorControlToolGroup /*,
              @BackgroundColorTrigger  */
             /*@HTMCharBGColorControlToolGroup,*/;
 GII_visibility = GIV_DIALOG;
 GII_type = GIT_ORGANIZATIONAL;
 HINT_TOOLBOX;
 HINT_ORIENT_CHILDREN_HORIZONTALLY;
 HINT_CENTER_WINDOW;
 HINT_INTERACTION_MAKE_RESIZABLE;
 HINT_ALLOW_CHILDREN_TO_WRAP;
}
@ifdef E
@chunk char HTMToolboxName[] = "Floating Tools";
@endif
@ifdef D
@chunk char HTMToolboxName[] = "Werkzeugleiste";
@endif

@object GenToolGroupClass HTMDocumentToolToolGroup = {
 GTGI_controller = @HTMDocumentControl;
 HINT_MINIMIZE_CHILD_SPACING;
 HINT_SAME_ORIENTATION_AS_PARENT;
}
@object GenToolGroupClass HTMEditToolToolGroup = {
 GTGI_controller = @HTMEditControl;
 HINT_MINIMIZE_CHILD_SPACING;
 HINT_SAME_ORIENTATION_AS_PARENT;
}
@object GenToolGroupClass HTMPrintToolGroup = {
 GTGI_controller = @HTMPrintControl;
 HINT_SAME_ORIENTATION_AS_PARENT;
 HINT_MINIMIZE_CHILD_SPACING;
}
@object GenToolGroupClass HTMFontToolGroup = {
 GTGI_controller = @HTMFontControl;
 HINT_SAME_ORIENTATION_AS_PARENT;
 HINT_MINIMIZE_CHILD_SPACING;
}
@object GenToolGroupClass HTMSizeToolGroup = {
 GTGI_controller = @HTMPtSizeControl;
 HINT_SAME_ORIENTATION_AS_PARENT;
 HINT_MINIMIZE_CHILD_SPACING;
}
@object GenToolGroupClass HTMCharFGColorControlToolGroup = {
 GTGI_controller = @HTMCharFGColorControl;
 HINT_SAME_ORIENTATION_AS_PARENT;
}
/* Acts/looks like a graphics tool, not text background tool:
@object GenToolGroupClass HTMCharBGColorControlToolGroup = {
 GTGI_controller = @HTMCharBGColorControl;
 HINT_SAME_ORIENTATION_AS_PARENT;
}*/
/* NEW:  Looks poorly, not moveable between toolboxes,
         not worth having around in such encumbered state:
@object GenTriggerClass BackgroundColorTrigger = {
 GI_visMoniker = "BG";
 GTI_destination =  @HTMCharBGColorControl;
 GTI_actionMsg = MSG_GEN_INTERACTION_INITIATE;
 HINT_TOOLBOX;
 HINT_SAME_ORIENTATION_AS_PARENT;
}
*/
@object GenToolGroupClass HTMFindToolToolGroup = {
  GTGI_controller = @HTMSearchReplaceControl;
  HINT_MINIMIZE_CHILD_SPACING;
  HINT_SAME_ORIENTATION_AS_PARENT;
}

/* =============================*/
   /* Keeps track of multiple displays */
@object GenDisplayGroupClass HTMDisplayGroup = {
  ATTR_GEN_DESTINATION_CLASS = { (ClassStruct*)&HTMDocumentClass };
  HINT_DEFAULT_FOCUS;
  HINT_DEFAULT_TARGET;
}
@object  GenInteractionClass HTMDisplayToolGroup = {
/* To make it manageable 2/9/97 / but made not enabled:
@object  GenToolGroupClass HTMDisplayToolGroup = { */
  GI_comp = @HTMDisplayTile, @HTMDisplayFull ;
  HINT_ORIENT_CHILDREN_HORIZONTALLY;
}
@object GenTriggerClass HTMDisplayTile = {
  GI_visMoniker = list { @TileDisplayMoniker };
  GTI_destination = HTMDisplayGroup ;
  GTI_actionMsg = MSG_GEN_DISPLAY_GROUP_TILE_DISPLAYS;
  HINT_TOOLBOX;
  HINT_SAME_ORIENTATION_AS_PARENT;
}
@object GenTriggerClass HTMDisplayFull = {
  GI_visMoniker = list { @FullDisplayMoniker };
  GTI_destination = HTMDisplayGroup ;
  GTI_actionMsg = MSG_GEN_DISPLAY_GROUP_SET_FULL_SIZED;
  HINT_TOOLBOX;
  HINT_SAME_ORIENTATION_AS_PARENT;
}

@object GenToolGroupClass HTMThesToolGroup = {
 GI_visMoniker = list {@ThesIcon};
 GTGI_controller = @HTMThesControl;
/*  HINT_SAME_ORIENTATION_AS_PARENT;   2/11 */
  HINT_MINIMIZE_CHILD_SPACING;
  HINT_NO_WIDER_THAN_CHILDREN_REQUIRE;
/* This makes blank "trigger" and icon switch places:*/
  HINT_PLACE_MONIKER_TO_RIGHT;
/* This makes a partial overlap which is progress but looks
   worse:
  HINT_CENTER_MONIKER; */
}
@object GenToolGroupClass HTMSpellToolGroup = {
 GTGI_controller = @HTMSpellControl;
 HINT_SAME_ORIENTATION_AS_PARENT;
}
@end Interface;

/********************************************************************
 *       DocGroupResource
 *******************************************************************/
@start DocGroupResource;

   /* This manages the documents and sends messages. */
@object GenDocumentGroupClass HTMDocumentGroup = {
@ifdef E
  GDGI_untitledName = "WPage";
@endif
@ifdef D
  GDGI_untitledName = "WebS";
@endif
  GDGI_documentClass = (ClassStruct*)&HTMDocumentClass;
  GDGI_documentControl = @HTMDocumentControl;
  GDGI_genDisplayGroup = @HTMDisplayGroup;
  GDGI_genView =         @HTMView;
  GDGI_genDisplay =      @HTMDisplay;
  GDGI_attrs = ( @default | GDGA_NATIVE ) & ~( GDGA_VM_FILE |
       GDGA_SUPPORTS_AUTO_SAVE | GDGA_AUTOMATIC_CHANGE_NOTIFICATION |
       GDGA_AUTOMATIC_DIRTY_NOTIFICATION );
}
@end DocGroupResource;
/********************************************************************
 *       DisplayResource
 * This res is duplicated by the GenDocumentGroup each time it creates
 * a new GenDocument object. Each GenDoc is linked to the GenView that
 * is the display's child and is displayed within that GenView.
 *******************************************************************/
@start DisplayResource;
@object GenDisplayClass HTMDisplay = {
  GI_states = @default & ~GS_USABLE;
  GI_comp =   @HTMView;
  ATTR_GEN_DISPLAY_NOT_MINIMIZABLE;
}
@object GenViewClass HTMView = {
  GVI_attrs = @default | GVA_WINDOW_COORDINATE_MOUSE_EVENTS
                       | GVA_FOCUSABLE | GVA_DRAG_SCROLLING;
  GVI_horizAttrs = @default | GVDA_SCROLLABLE;
  GVI_vertAttrs =  @default | GVDA_SCROLLABLE;
  HINT_EXPAND_WIDTH_TO_FIT_PARENT;
  HINT_DEFAULT_TARGET;
  HINT_DEFAULT_FOCUS;
}
@end DisplayResource;
/********************************************************************
 *       DocumentResource
 * This resource is duplicated by the GenDocument when a new GenDocument
 * object is created, and contains the text object.
 *******************************************************************/
@start DocumentResource;
@object HTMTextClass HTMText = {
  VTI_state = ( @default | VTS_EDITABLE | VTS_SELECTABLE | VTS_TARGETABLE );
  VTI_features = @default | VTF_ALLOW_UNDO;
  VTI_output = process;
  VLTI_displayMode = VLTDM_DRAFT_WITH_STYLES;
  VLTI_attrs = VLTA_EXACT_HEIGHT;
  VLTI_regionArray = @HTMTextRegionArray;
/*  VTI_washColor = {C_LIGHT_CYAN, CF_INDEX, 0, 0};
 * ****************************/
/*  May not be needed with large data structure ======>
   VTI_charAttrRuns = DEF_CHAR_ATTR_FONT_SIZE(VTDF_URW_SANS, VTDS_14);*/
/*    THAT'S BEEN REPLACED BY STORAGE STUFF as per mg/jfh */
  HTMTI_allowChanges = TRUE;
}
@chunk ChunkArrayHeader HTMTextRegionArray = {  0,
  sizeof( VisLargeTextRegionArrayElement ),  0,
  sizeof( ChunkArrayHeader )
}; /* HTMTextRegionArray */
@end DocumentResource;

/* Tile Display Icon */
@start TileDisplayIcon, data;
@visMoniker TileDisplayMoniker = {
        size = standard;
        style = tool;
        color = color4;
        aspectRatio = normal;
        cachedSize = 13, 14;
        gstring {
                GSDrawBitmapAtCP (143),
                Bitmap (13,14,BMC_PACKBITS,(BMT_MASK|BMF_4BIT)),
                0x01, 0xff, 0xf8, 0xfb, 0x11, 0x00, 0x1f,
                0x01, 0xff, 0xf8, 0xfe, 0xee, 0x03, 0x1b, 0xbb,
                0xba,
                0xaf,
                0x08, 0xff, 0xf8, 0xee, 0x8e, 0xee, 0x1b, 0xbb,
                0xbb,
                0xaf,
                0x08, 0xff, 0xf8, 0xe8, 0x88, 0xee, 0x1b, 0xbb,
                0xcb,
                0xaf,
                0x08, 0xff, 0xf8, 0xe8, 0x88, 0xee, 0x1b, 0xbc,
                0xbb,
                0xaf,
                0x08, 0xff, 0xf8, 0xe8, 0x8e, 0xee, 0x1b, 0xcb,
                0xbb,
                0xaf,
                0x08, 0xff, 0xf8, 0x88, 0x88, 0xee, 0x1c, 0xbb,
                0xbb,
                0xaf,
                0x08, 0xff, 0xf8, 0x89, 0x88, 0xe9, 0x9b, 0xbb,
                0xbb,
                0xaf,
                0x04, 0xff, 0xf8, 0x88, 0x99, 0x91, 0xfe, 0x11,
                0x00,
                0x1f,
                0x08, 0xff, 0xf8, 0x88, 0x88, 0x77, 0x78, 0x77,
                0x87,
                0x7f,
                0x08, 0xff, 0xf8, 0x88, 0x88, 0x77, 0x78, 0x77,
                0x87,
                0x7f,
                0x08, 0xff, 0xf8, 0x78, 0x87, 0x77, 0x78, 0x77,
                0x87,
                0x7f,
                0x08, 0xff, 0xf8, 0x78, 0x87, 0x77, 0x78, 0x77,
                0x87,
                0x7f,
                0x08, 0xff, 0xf8, 0x78, 0x87, 0x77, 0x78, 0x77,
                0x87,
                0x7f,
                GSEndString()
        }
}
@end TileDisplayIcon;
@start FullDisplayIcon, data;
@visMoniker FullDisplayMoniker = {
        size = standard;
        style = tool;
        color = color4;
        aspectRatio = normal;
        cachedSize = 13, 14;
        gstring {
                GSDrawBitmapAtCP (146),
                Bitmap (13,14,BMC_PACKBITS,(BMT_MASK|BMF_4BIT)),
                0x04, 0xff, 0xf8, 0x77, 0x77, 0x71, 0xfe, 0x11,
                0x00,
                0x1f,
                0x08, 0xff, 0xf8, 0x77, 0x77, 0x71, 0xbb, 0xbb,
                0xba,
                0xaf,
                0x04, 0xff, 0xf8, 0x77, 0x87, 0x71, 0xfe, 0xbb,
                0x00,
                0xaf,
                0x08, 0xff, 0xf8, 0x78, 0x88, 0x71, 0xbb, 0xbb,
                0xcb,
                0xaf,
                0x08, 0xff, 0xf8, 0x78, 0x88, 0x71, 0xbb, 0xbc,
                0xbb,
                0xaf,
                0x08, 0xff, 0xf8, 0x78, 0x87, 0x71, 0xbb, 0xcb,
                0xbb,
                0xaf,
                0x08, 0xff, 0xf8, 0x88, 0x88, 0x71, 0xbc, 0xbb,
                0xbb,
                0xaf,
                0x08, 0xff, 0xf8, 0x89, 0x88, 0x79, 0x9b, 0xbb,
                0xbb,
                0xaf,
                0x04, 0xff, 0xf8, 0x88, 0x99, 0x99, 0xfe, 0x11,
                0x00,
                0x1f,
                0x08, 0xff, 0xf8, 0x88, 0x88, 0x77, 0x78, 0x77,
                0x87,
                0x7f,
                0x08, 0xff, 0xf8, 0x88, 0x88, 0x77, 0x78, 0x77,
                0x87,
                0x7f,
                0x08, 0xff, 0xf8, 0x78, 0x87, 0x77, 0x78, 0x77,
                0x87,
                0x7f,
                0x08, 0xff, 0xf8, 0x78, 0x87, 0x77, 0x78, 0x77,
                0x87,
                0x7f,
                0x08, 0xff, 0xf8, 0x78, 0x87, 0x77, 0x78, 0x77,
                0x87,
                0x7f,
                GSEndString()
        }
}
@end FullDisplayIcon;
/**********************
 * Credits and copyright messages * Now in UIabout.goc for dynamic linking
 **********************/
/**********************
 * Photon Buttons * Moved to separate file
 **********************/
/**********************
 * HTMLMenu * Moved to separate file
 **********************/
@extern method HTMTextClass, MSG_VIS_TEXT_FREE_ALL_STORAGE {
  ChunkArrayHeader *cahp;   /* Pointer to chunk array header. */
  VisTextInstance  *vself;  /* Pointer to our instance data. */
  optr             ourText; /* Pointer to text object. */
  @callsuper();
     /* Free the extra space that VisLargeText used.  */
  ourText = ConstructOptr( OptrToHandle( oself ),
                           OptrToChunk( @HTMTextRegionArray ) );
  MemLock( OptrToHandle( oself ) );
  LMemReAlloc( ourText, sizeof( ChunkArrayHeader ) );
  MemUnlock( OptrToHandle( oself ) );
     /* Reset the chunk header to default values. */
  cahp = LMemDeref( ourText );
  cahp->CAH_count       = 0;
  cahp->CAH_elementSize = sizeof( VisLargeTextRegionArrayElement );
  cahp->CAH_curOffset   = 0;
  cahp->CAH_offset      = sizeof( ChunkArrayHeader );
     /* Set text object to small model and invalidate it visually. */
  vself = ObjDerefVis( oself );
  vself->VTI_storageFlags &= ~VTSF_LARGE;
  vself->VI_optFlags      |= VOF_GEOMETRY_INVALID;
} /* MSG_VIS_TEXT_FREE_ALL_STORAGE */

@extern method HTMTextClass, MSG_META_TEXT_USER_MODIFIED {
  @callsuper();
     /* Check if we can set doc dirty. Set dirty if we are allowed to. */
  pself = ObjDerefVis( oself );
  if ( pself->HTMTI_allowChanges ) {
    @send @visParent::MSG_GEN_DOCUMENT_MARK_DIRTY();
  }
} /* MSG_META_TEXT_USER_MODIFIED */

@extern method HTMTextClass, MSG_PRINT_START_PRINTING {
  dword          curPage;      /* Current page being printed. */
  int            numPages;     /* Number of pages. */
  PageSizeReport psr;          /* Size of page from PrintControl. */
  word           pageWidth;    /* Width of paper. */
  dword          pageHeight;   /* Height of print area in points. */
  Boolean        continu;      /* Indicates when to stop printing. */
  XYValueAsDWord textSize;     /* Image size of text. */
  Boolean        textModified; /* TRUE if text modified. */
  optr           printConOD;   /* Pointer to HTMPrintControl. */
  WWFixed        newPtSize;    /* Used to set point size. */
  WWFixed        savedSize;    /* Current point size, saved. */
  FontID         savedFont;    /* Current font, saved. */
     /* Returned by MSG_VIS_LARGE_TEXT_GET_REGION_POS. */
  VisLargeTextGetRegionPosReturnStruct regPos;
     /* Get the paper size as set by the user and find the
      * page width and height without margins. Then set the
      * document size to reflect current paper size. */
  printConOD = /*GeodeGetOptrNS(*/ @HTMPrintControl /*)*/;
  @call printConOD::MSG_PRINT_CONTROL_GET_PAPER_SIZE_INFO( &psr );
  pageWidth  = psr.PSR_width -
               psr.PSR_margins.PCMP_left -
               psr.PSR_margins.PCMP_right;
  pageHeight = psr.PSR_height -
               psr.PSR_margins.PCMP_top -
               psr.PSR_margins.PCMP_bottom;
  @call printConOD::MSG_PRINT_CONTROL_SET_DOC_SIZE(
                             psr.PSR_width, psr.PSR_height );
/* Have Undo ignore next changes to text object. False to
   have it not flush queue. Set flag so text won't mark document
   dirty. Save text modified state. Save text image size (width). */
  @call process::MSG_GEN_PROCESS_UNDO_IGNORE_ACTIONS( FALSE );
  pself = ObjDerefVis( oself );
  pself->HTMTI_allowChanges = FALSE;
  textModified = @call self::MSG_VIS_TEXT_GET_USER_MODIFIED_STATE();
  textSize = @call self::MSG_VIS_LARGE_TEXT_GET_DRAFT_REGION_SIZE( 0 );
     /* Freeze text. Set text width to printer page width.  */
  @send self::MSG_META_SUSPEND();
  savedFont = fontID_g;
  @send self::MSG_VIS_TEXT_SET_FONT_ID( HTM_PRINT_FONT,
                                        TEXT_ADDRESS_PAST_END, 1 );
  newPtSize.WWF_int  = HTM_PRINT_PS;
  newPtSize.WWF_frac = 0;
  savedSize = pointSize_g;
  @send self::MSG_VIS_TEXT_SET_POINT_SIZE( newPtSize,
                                           TEXT_ADDRESS_PAST_END, 1 );
  @send self::MSG_VIS_LARGE_TEXT_SET_DRAFT_REGION_SIZE(
                  pageWidth, pageHeight );
  @call self::MSG_META_UNSUSPEND();
     /* Set number of pages to print. */
  numPages = @call self::MSG_VIS_LARGE_TEXT_GET_REGION_COUNT();
  @call printConOD::MSG_PRINT_CONTROL_SET_TOTAL_PAGE_RANGE(
                        1, numPages );
     /* This loop is from Concepts Vol2 Code Display 23-1 on p809.
      * It is the main printing loop. It translates the text up
      * one page at a time while printing it.  */
  for( curPage = 0; curPage < numPages; curPage++ ) {
    continu = @call printConOD::MSG_PRINT_CONTROL_REPORT_PROGRESS(
                                    PCPT_PAGE, curPage+1 );
    if ( continu == FALSE ) {
      break;    }
       /* Shift text up number of pages and draw text. This is done
        * by using the regions of the VisLargeText, which are each
        * a page of the text. Form feed to next page.  */
    GrSaveState( gstate );
    @call self::MSG_VIS_LARGE_TEXT_GET_REGION_POS( &regPos, curPage );
    GrSetClipRect( gstate, PCT_REPLACE,
                   psr.PSR_margins.PCMP_left,
                   psr.PSR_margins.PCMP_top,
                   pageWidth +
                       psr.PSR_margins.PCMP_right,
                   regPos.VLTGRPRS_height +
                       psr.PSR_margins.PCMP_bottom );
    GrApplyTranslationDWord( gstate, psr.PSR_margins.PCMP_left,
                             -( regPos.VLTGRPRS_yPosition -
                                psr.PSR_margins.PCMP_top ) );
    GrInitDefaultTransform( gstate );
    @call self::MSG_VIS_DRAW( DF_PRINT, gstate );
    GrRestoreState( gstate );
    GrNewPage( gstate, PEC_FORM_FEED );
  }
     /* Restore previous text settings. */
  @send self::MSG_META_SUSPEND();
  @send self::MSG_VIS_TEXT_SET_FONT_ID( savedFont,
                                        TEXT_ADDRESS_PAST_END, 1 );
  @send self::MSG_VIS_TEXT_SET_POINT_SIZE( savedSize,
                                           TEXT_ADDRESS_PAST_END, 1 );
  @send self::MSG_VIS_LARGE_TEXT_SET_DRAFT_REGION_SIZE(
                  DWORD_X( textSize ), DWORD_Y( textSize ) );
  @send self::MSG_META_UNSUSPEND();
     /* Restore text modified state and re-enable undo. */
  pself->HTMTI_allowChanges = TRUE;
  if ( textModified == FALSE ) {
    @send self::MSG_VIS_TEXT_SET_NOT_USER_MODIFIED();
  }
  @send process::MSG_GEN_PROCESS_UNDO_ACCEPT_ACTIONS();
     /* Wrap up the printing (tell PC if done or cancelled). */
  if ( continu ) {@send printConOD::MSG_PRINT_CONTROL_PRINTING_COMPLETED();}
  else {    @send printConOD::MSG_PRINT_CONTROL_PRINTING_CANCELLED();  }
} /* MSG_PRINT_START_PRINTING */

@extern method HTMTextClass, MSG_VIS_TEXT_SET_POINT_SIZE {
  Boolean textModified; /* TRUE if text modified. */
     /* Update our copy of the current point size. */
  pointSize_g = pointSize;
     /* Have Undo ignore next changes to text object.
      * False to have it not flush queue. */
  @call process::MSG_GEN_PROCESS_UNDO_IGNORE_ACTIONS( FALSE );
  pself = ObjDerefVis( oself );
  pself->HTMTI_allowChanges = FALSE;
  textModified = @call self::MSG_VIS_TEXT_GET_USER_MODIFIED_STATE();
  @callsuper();
     /* Check if text was modified previously and set appropriately.
      * Re-enable undo actions.  */
  if ( textModified == FALSE ) {
    @send self::MSG_VIS_TEXT_SET_NOT_USER_MODIFIED();
  }
  pself->HTMTI_allowChanges = TRUE;
  @send process::MSG_GEN_PROCESS_UNDO_ACCEPT_ACTIONS();
} /* MSG_VIS_TEXT_SET_POINT_SIZE */

@extern method HTMTextClass, MSG_VIS_TEXT_SET_FONT_ID {
  Boolean textModified; /* TRUE if text modified. */
     /* Update our copy of the current font ID. */
  fontID_g = fid;
     /* Have Undo ignore next changes to text object.
      * False to have it not flush queue.  */
  @call process::MSG_GEN_PROCESS_UNDO_IGNORE_ACTIONS( FALSE );
  pself = ObjDerefVis( oself );
  pself->HTMTI_allowChanges = FALSE;
  textModified = @call self::MSG_VIS_TEXT_GET_USER_MODIFIED_STATE();
  @callsuper();
     /* Check if text was modified previously and set appropriately.
      * Re-enable undo actions.  */
  if ( textModified == FALSE ) {
    @send self::MSG_VIS_TEXT_SET_NOT_USER_MODIFIED();  }
  pself->HTMTI_allowChanges = TRUE;
  @send process::MSG_GEN_PROCESS_UNDO_ACCEPT_ACTIONS();
} /* MSG_VIS_TEXT_SET_FONT_ID */

@extern method HTMTextClass, MSG_VIS_TEXT_REPLACE_WITH_HWR {
@ifdef OMNIGO
  MemHandle textBlock;  char * textPtr;
  if ( pself->VTI_state & VTS_EDITABLE ) {
    textBlock = DoHWR( ink, flags, oself );
    if ( textBlock ) {
      textPtr = MemLock( textBlock );
      if( textPtr[0] == 0 ) {UserStandardSound( SST_NOTIFY );}
      else {@call self::MSG_VIS_TEXT_REPLACE_SELECTION_PTR( textPtr, 0 );}
         /* Free the recognized text. */
      MemFree( textBlock );
    }
    else {UserStandardSound( SST_NOTIFY );}
  }
  MemDecRefCount( ink );
@endif
} /* MSG_VIS_TEXT_REPLACE_WITH_HWR */

void ResetUndo  (  void  );
Boolean badChar  (  unsigned char ch  /* Character to test (in). */  );
void ErrorMessage
    (    unsigned char * errorString  /* Message to be displayed (in) */    );
void ProcessString
  (  word numCharsRead_p,  optr ourText_p, unsigned char * dataBlockPtr_p );
Boolean ReadDataFromFile
  (  FileHandle file_p,  optr ourText_p, word * error_p );
void RemoveBadChars
  ( unsigned char * dataBlockPtr, word curCharIndex, word * numCharsLeft);
Boolean WriteDataToFile
  (  FileHandle file_p,  optr ourText_p, word * error);

Boolean badChar
  (  unsigned char ch  /* Character to test (in). */  )
{    /* Check if passed character is legal
      * and return appropriate value.      */
  if ( ch == 0 ) {return( TRUE );}
  else {if ( ( ch >= SPACE  ) && ( ch != DELETE ) ) {return( FALSE );}
    else {if ((ch <= CR) && (ch >= TAB) && (ch != LINE_FEED)){return(FALSE);}
      else { return( TRUE ); }
    }
  }
} /* badChar */

#ifdef DEBUG
  void ErrorMessage
    (    unsigned char * errorString  /* Message to be displayed (in) */    )
  {
    UserStandardDialog( "fault", (char*)0, (char*)0, (char*)0,
        errorString,( ( CDT_ERROR << CDBF_DIALOG_TYPE_OFFSET ) |
        ( GIT_NOTIFICATION << CDBF_INTERACTION_TYPE_OFFSET ) ) );
    @send HTMApp::MSG_META_QUIT();
  } /* ErrorMessage */
#endif
void ProcessString
  (
  word            numCharsRead_p, /* Number of characters (in) */
  optr            ourText_p,    /* Text object to append to (in) */
  unsigned char * dataBlockPtr_p  /* String of characters (i/o) */
  )
{
  word curCharIndex; /* Index to current char being processed. */
  word numCharsLeft; /* Number of characters left to process. */
     /* Initialize variables for loop.  */
  curCharIndex = 0;
  numCharsLeft = numCharsRead_p;
     /* Loop that checks each character and removes the bad ones. */
  while( curCharIndex < numCharsLeft ) {
    if ( badChar( dataBlockPtr_p[ curCharIndex ] ) ) {
      RemoveBadChars( dataBlockPtr_p, curCharIndex, &numCharsLeft );
    }
    curCharIndex++;
  }
     /* Convert the DOS characters to GEOS characters.
      * Now append the text that's left to text object. */
  LocalDosToGeos( dataBlockPtr_p, numCharsLeft, '.' );
  if ( numCharsLeft > 0 ) {
    @call ourText_p::MSG_VIS_TEXT_APPEND_PTR( dataBlockPtr_p,
                                              numCharsLeft );
  }
} /* ProcessString */

Boolean ReadDataFromFile
  (
  FileHandle file_p,    /* Handle of file to read from (in). */
  optr       ourText_p, /* Pointer to text object to write to (in). */
  word *     error_p    /* Pointer to error status word (out). */
  )
{
  word            numCharsRead;    /* Size returned by FileRead. */
  MemHandle       dataBlockHandle; /* Handle to memory block. */
  unsigned char * dataBlockPtr;    /* Holds string being processed. */
/*  word            numCharsLeft;     Characters left to process. */
/*  word            curCharIndex;     Index into character array. */
     /* Set position to start of file. */
  #ifdef DEBUG
    if ( file_p == NullHandle ) {
@ifdef E
      ErrorMessage( "Error in reading document (null file handle)." );
@endif
@ifdef D
      ErrorMessage( "Fehler beim Lesen der Datei (null file handle)." );
@endif
    }
    else {FilePos( file_p, 0L, FILE_POS_START );}
  #else
    FilePos( file_p, 0L, FILE_POS_START );
  #endif
     /* Freeze text object and delete all its text. */
  @send ourText_p::MSG_META_SUSPEND();
  @send ourText_p::MSG_VIS_TEXT_DELETE_ALL();
     /* Allocate memory for dataBlock so we can read in file.
      * Have memory locked right away, and get pointer to block. */
  dataBlockHandle = MemAlloc( DOC_BLOCK_SIZE, HF_SWAPABLE, 0 );
  dataBlockPtr    = (char*)MemLock( dataBlockHandle );
     /* Main read loop. Reads in a block from file and removes any
      * linefeeds, then appends the text to the text object. */
  do {
    numCharsRead = FileRead( file_p, dataBlockPtr,
                             DOC_BLOCK_SIZE, FALSE );
    if ( numCharsRead <= DOC_BLOCK_SIZE ) {
      ProcessString( numCharsRead, ourText_p, dataBlockPtr );
    }
  } while( numCharsRead == DOC_BLOCK_SIZE );
     /* Free memory block. Don't need to unlock first.
      * Put cursor at beginning of text and unfreeze it. */
  MemFree( dataBlockHandle );
  @send ourText_p::MSG_VIS_TEXT_SELECT_START();
  @call ourText_p::MSG_META_UNSUSPEND();
     /* Check for file read errors. If no error,
      * reset undo and set text not user modified.  */
  if ( numCharsRead > DOC_BLOCK_SIZE ) {
    *error_p = ThreadGetError();
    return( TRUE );
  }
  else {
    ResetUndo();
    @send ourText_p::MSG_VIS_TEXT_SET_NOT_USER_MODIFIED();
    return( FALSE );
  }
} /* ReadDataFromFile */

void RemoveBadChars
  (
  unsigned char * dataBlockPtr, /* String to examine (i/o) */
  word            curCharIndex,  /* Position to start check (i/o) */
  word *          numCharsLeft /* Number of characters in array (i/o) */
  )
{
  word numCharsBad;  /* Number of consecutive bad characters. */
  word curShiftChar; /* Current character being shifted. */
  #ifdef DEBUG
    if ( curCharIndex > DOC_BLOCK_SIZE ) {ErrorMessage( "bad index value." );}
    if ( *numCharsLeft > DOC_BLOCK_SIZE ){ErrorMessage( "bad 'left' value." );}
    if ( dataBlockPtr == NULL ) {ErrorMessage( "bad string pointer." );}
  #endif
     /* Found a bad one. Look for more consecutive bad characters. */
  numCharsBad = 1;
  while( ( badChar( dataBlockPtr[curCharIndex+numCharsBad] ) ) &&
         ( ( curCharIndex + numCharsBad ) < *numCharsLeft  ) ) {
    numCharsBad += 1;
  }
  #ifdef DEBUG
    if ( numCharsBad > DOC_BLOCK_SIZE ) {
      ErrorMessage( "RemoveBadChars found too many bad characters." );}
  #endif
     /* Remove all the consecutive bad characters found. */
  if ( ( curCharIndex + numCharsBad ) < *numCharsLeft ) {
    for ( curShiftChar = curCharIndex + numCharsBad;
          curShiftChar < *numCharsLeft;
          curShiftChar++ ) {
      dataBlockPtr[curShiftChar-numCharsBad] = dataBlockPtr[curShiftChar]; }
  }
     /* Decrement bytes left by bytes removed. (Don't move this into
        the if conditional. It needs to be done every time.) */
  *numCharsLeft -= numCharsBad;
} /* RemoveBadChars */

void ResetUndo  (  void  )
{
  NotifyUndoStateChange *undoState;  /* Record for setting undo. */
  MemHandle             memHan;      /* Handle to undo record. */
  EventHandle           notifyEvent; /* Message sent to edit control. */
     /* Allocate memory for undo state record. */
  memHan = MemAlloc( sizeof( NotifyUndoStateChange ),
                     ( HF_DYNAMIC | HF_SHARABLE ), 0 );
     /* Set up the undo record. Make sure block stays after
      * it's unlocked. */
  undoState = MemLock( memHan );
  undoState->NUSC_undoTitle = NullOptr;
  undoState->NUSC_undoType  = UD_UNDO;
  MemUnlock( memHan );
  MemInitRefCount( memHan, 1 );
     /* Tell objects on edit control that there's nothing to undo. */
  notifyEvent = @record null::MSG_META_NOTIFY_WITH_DATA_BLOCK(
                                  MANUFACTURER_ID_GEOWORKS,
                                  GWNT_UNDO_STATE_CHANGE, memHan );
  @call application::MSG_META_GCN_LIST_SEND(
              GCNLSF_SET_STATUS, notifyEvent, memHan,
              GAGCNLT_EDIT_CONTROL_NOTIFY_UNDO_STATE_CHANGE,
              MANUFACTURER_ID_GEOWORKS );
} /* ResetUndo */

Boolean WriteDataToFile
  (  FileHandle file_p,    /* File to write to. (in) */
  optr       ourText_p, /* Pointer to text object. (in) */
  word *     error      /* Return error. (out) */  )
{
  MemHandle    dataBlockHandle; /* Handle to memory block. */
  char         *dataBlockPtr;   /* Used to read in file. */
  word         curShiftChar,    /* Used in for loop. */
               numChars,        /* Number of bytes in buffer. */
               curCharIndex;    /* Used in finding CR. */
  dword        selectStart,     /* Start of text selection. */
               selectEnd,       /* End of text selection. */
               textSize,        /* Number of characters. */
               totalSize;       /* Text size plus LF's added. */
  Boolean      endOfText;       /* Signals end of text. */
  VisTextRange vtr;             /* Saved cursor position. */
     /* Set position to start of file. Set error flag to no error
      * so we can check it later if there's no text to write.   */
  #ifdef DEBUG
    if ( file_p == NullHandle ) {
      ErrorMessage( "Error writing text to file (null file handle)" ); }
    else {FilePos( file_p, 0L, FILE_POS_START );}
  #else
    FilePos( file_p, 0L, FILE_POS_START );
  #endif
  *error = NO_ERROR;
     /* Set start of text selection and get text length.
      * Make sure selectEnd not past end of text.
      * Set flag indicating that we didn't reach end of text yet.  */
  selectStart = 0;
  selectEnd   = DOC_BLOCK_SIZE / 2;
  textSize  = @call ourText_p::MSG_VIS_TEXT_GET_TEXT_SIZE();
  totalSize = textSize;
  if ( selectEnd > textSize ) {  selectEnd = textSize;  }
  endOfText = FALSE;
     /* Save text cursor position and freeze text. */
  @send ourText_p::MSG_VIS_TEXT_GET_SELECTION_RANGE( &vtr );
  @send ourText_p::MSG_META_SUSPEND();
     /* Allocate memory for dataBlock so we can write out file.
      * Lock memory right away and get pointer to block.   */
  dataBlockHandle = MemAlloc( DOC_BLOCK_SIZE, HF_SWAPABLE, 0 );
  dataBlockPtr    = (char*)MemLock( dataBlockHandle );
     /* This loop copies the text from the object and writes
      * it to the file. */
  do {
       /* Copy block from text object and set numChars.
        * Convert the GEOS characters to DOS characters. */
    @send ourText_p::MSG_VIS_TEXT_SELECT_RANGE( selectEnd, selectStart );
    @call ourText_p::MSG_VIS_TEXT_GET_SELECTION_PTR( dataBlockPtr );
    numChars = selectEnd - selectStart;
    LocalGeosToDos( dataBlockPtr, numChars, '.' );
       /* Search for CR and add LF after each one found.  */
    curCharIndex = 0;
    while( curCharIndex < numChars ) {
      if ( dataBlockPtr[curCharIndex] == CR ) {
        for ( curShiftChar = numChars;
              curShiftChar > curCharIndex+1;
              curShiftChar-- ) {
          dataBlockPtr[curShiftChar] = dataBlockPtr[curShiftChar-1];
        }
        dataBlockPtr[curCharIndex+1] = LINE_FEED;
        curCharIndex += 1; /* Skip over new LF. */
        numChars     += 1; /* Increment number of characters. */
        totalSize    += 1; /* Increase total size of file. */
      }
      curCharIndex += 1; /* Advance to next character. */
    } /* while */
       /* Write text to the DOS file and check for error.
        * If error, mark end of text TRUE.  */
    if ( numChars > 0 ) {
      FileWrite( file_p, dataBlockPtr, numChars, FALSE );
      *error = ThreadGetError();
      if ( *error != NO_ERROR ) {
        #ifdef DEBUG
          ErrorMessage( "Error in WriteDataToFile calling FileWrite" );
        #else
          endOfText = TRUE;
        #endif
      }
    }
       /* Advance text selection to next block making sure not
        * past end of text. Set endOfText appropriately.  */
    selectStart += DOC_BLOCK_SIZE / 2;
    selectEnd   += DOC_BLOCK_SIZE / 2;
    if ( selectEnd > textSize ) {selectEnd = textSize;}
    if ( selectStart >= textSize ) {endOfText = TRUE;}
  } while( endOfText == FALSE );
     /* Free memory block. Don't need to unlock first. */
  MemFree( dataBlockHandle );
     /* Reinstate previous text selection and unfreeze it. */
  @send ourText_p::MSG_VIS_TEXT_SELECT_RANGE( vtr.VTR_end,vtr.VTR_start );
  @send ourText_p::MSG_META_UNSUSPEND();
     /* Check for file write errors. Truncate file and set text
      * not user modified if no file error. Reset undo.  */
  if ( *error != NO_ERROR ) { return( TRUE );  }
  else {
    #ifdef DEBUG
      FileTruncate( file_p, totalSize, TRUE );
    #else
      FileTruncate( file_p, totalSize, FALSE );
    #endif
    ResetUndo();
    @send ourText_p::MSG_VIS_TEXT_SET_NOT_USER_MODIFIED();
    return( FALSE );
  }
} /* WriteDataToFile */

@extern method HTMDocumentClass, MSG_GEN_DOCUMENT_INITIALIZE_DOCUMENT_FILE {
  @callsuper();
     /* Set text handle to null so we can check it later. */
  pself = ObjDerefGen( oself );
  pself->HTMDI_textHandle = NullHandle;
  return( FALSE );
} /* MSG_GEN_DOCUMENT_INITIALIZE_DOCUMENT_FILE */

@extern method HTMDocumentClass, MSG_GEN_DOCUMENT_ATTACH_UI_TO_DOCUMENT {
  word                 error;      /* Error value from ReadDataFromFile. */
  VMFileHandle         fileHan;    /* Used to set VM file for text. */
  optr                 ourText;    /* Pointer to text object. */
  optr                 textOD;     /* Pointer to HTMText. */
  VisContentInstance * vself;      /* Pointer to self */
     /* Duplicate the text resource. */
  pself = ObjDerefGen( oself );
  vself = ObjDerefVis( oself );
  textOD = /*GeodeGetOptrNS(*/ @HTMText /*)*/;
  pself->HTMDI_textHandle = ObjDuplicateResource(
                                OptrToHandle( textOD ), 0, 0);
     /* Set the attributes of the content to be large.  */
  pself->GCI_attrs  = VCNA_LARGE_DOCUMENT_MODEL |
                      VCNA_WINDOW_COORDINATE_MOUSE_EVENTS |
                      VCNA_SAME_WIDTH_AS_VIEW;
  vself->VCNI_attrs = VCNA_LARGE_DOCUMENT_MODEL |
                      VCNA_WINDOW_COORDINATE_MOUSE_EVENTS |
                      VCNA_SAME_WIDTH_AS_VIEW;
     /* Set up geometry of content so manager is not used. */
  vself->VI_attrs    &= ~VA_MANAGED;
  vself->VI_optFlags &= ~( VOF_GEOMETRY_INVALID |
                           VOF_GEO_UPDATE_PATH );
  vself->VI_geoAttrs |= VCGA_CUSTOM_MANAGE_CHILDREN;
     /* Set up VisText object for the large document model. */
  ourText = ConstructOptr( pself->HTMDI_textHandle, OptrToChunk( textOD ) );
  fileHan = ClipboardGetClipboardFile();
  @send ourText::MSG_VIS_TEXT_SET_VM_FILE( fileHan );
  @send ourText::MSG_VIS_LARGE_TEXT_CREATE_DATA_STRUCTURES();

/* NEW */
@call ourText::MSG_VIS_TEXT_CREATE_STORAGE(
        VTSF_MULTIPLE_CHAR_ATTRS |
        VTSF_MULTIPLE_PARA_ATTRS ,
        FALSE);
/* THIS IS IN LIEU OF VTI_ATTRS @text ui */

  @send ourText::MSG_VIS_NOTIFY_GEOMETRY_VALID();
  @callsuper();

     /* Set the text object as our first visible child.  */
  @call self::MSG_VIS_ADD_CHILD( ourText, CCO_FIRST );
     /* Tell text to grab the target and focus. Set point size of text
        to current size. Set font to current font. */
  @send ourText::MSG_META_GRAB_TARGET_EXCL();
  @send ourText::MSG_META_GRAB_FOCUS_EXCL();

/* WAS 1 INSTEAD OF 0 HERE: */
  @send ourText::MSG_VIS_TEXT_SET_POINT_SIZE( pointSize_g,
                                              TEXT_ADDRESS_PAST_END, 0 );
  if ( fontID_g != 0 ) {
    @send ourText::MSG_VIS_TEXT_SET_FONT_ID( fontID_g,
                                             TEXT_ADDRESS_PAST_END, 0 );
  }
     /* Read in text file by calling read data function.  */
  ReadDataFromFile( pself->GDI_fileHandle, ourText, &error );
} /* MSG_GEN_DOCUMENT_ATTACH_UI_TO_DOCUMENT */

@extern method HTMDocumentClass, MSG_GEN_DOCUMENT_DETACH_UI_FROM_DOCUMENT {
  optr textOD;  /* Pointer to HTMText. */
     /* Remove the text object.  */
  pself = ObjDerefGen( oself );
  if ( pself->HTMDI_textHandle != NullHandle ) {
    textOD = ConstructOptr( pself->HTMDI_textHandle,
                            OptrToChunk( /*GeodeGetOptrNS(*/ @HTMText/* )*/));
    @send textOD::MSG_VIS_REMOVE( VUM_DELAYED_VIA_APP_QUEUE );
    @callsuper();
       /* Free all storage, release VM file, and destroy block.
        * Set text handle null so save and revert work okay. */
    @send textOD::MSG_VIS_TEXT_FREE_ALL_STORAGE( TRUE );
    @send textOD::MSG_VIS_TEXT_SET_VM_FILE( NullHandle );
    @send textOD::MSG_VIS_DESTROY( VUM_DELAYED_VIA_APP_QUEUE );
    pself->HTMDI_textHandle = NullHandle;
  }
  else {
    @callsuper();
  }
} /* MSG_GEN_DOCUMENT_DETACH_UI_FROM_DOCUMENT */

@extern method HTMDocumentClass, MSG_GEN_DOCUMENT_ATTACH_FAILED {
  optr ourText; /* Pointer to text object. */
  optr textOD;  /* Pointer to ZTEText. */
  @callsuper();
  pself = ObjDerefGen( oself );
  if ( pself->HTMDI_textHandle != NullHandle ) {
    textOD = /*GeodeGetOptrNS(*/ @HTMText/* )*/;
    ourText = ConstructOptr( pself->HTMDI_textHandle,
                             OptrToChunk( textOD ) );
    @send ourText::MSG_VIS_TEXT_FREE_ALL_STORAGE( TRUE );
    @send ourText::MSG_VIS_TEXT_SET_VM_FILE( NullHandle );
    @send ourText::MSG_VIS_DESTROY( VUM_DELAYED_VIA_APP_QUEUE );
    pself->HTMDI_textHandle = NullHandle;
  }
} /* MSG_GEN_DOCUMENT_ATTACH_FAILED */

@extern method HTMDocumentClass, MSG_GEN_DOCUMENT_OPEN {
     /* Check if error occurred during open.
      * If so, cancel the open. Return error status.
      * (Don't try to do MSG_GEN_DESTROY, that gives an error.) */
  if ( @callsuper() ) {
    @send self::MSG_GEN_REMOVE( VUM_NOW, 0 );
    return( TRUE );
  }
  else {
    return( FALSE );
  }
} /* MSG_GEN_DOCUMENT_OPEN */

@extern method HTMDocumentClass, MSG_GEN_DOCUMENT_PHYSICAL_REVERT {
  optr ourText; /* Handle of current text object. */
  @callsuper(); /* There probably isn't one, but do it anyway. */
     /* Make sure there's a text object. If there is, read the text
      * from the file into the text object. */
  pself = ObjDerefGen( oself );
  if ( pself->HTMDI_textHandle == NullHandle ) {
    return( FALSE );
  }
  else {
    ourText = ConstructOptr( pself->HTMDI_textHandle,
                             OptrToChunk( @HTMText ) );
    return( ReadDataFromFile( pself->GDI_fileHandle, ourText, error ) );
  }
} /* MSG_GEN_DOCUMENT_PHYSICAL_REVERT */

@extern method HTMDocumentClass, MSG_GEN_DOCUMENT_PHYSICAL_SAVE,
                          MSG_GEN_DOCUMENT_PHYSICAL_UPDATE {
  optr ourText; /* Pointer to text object. */
  optr textOD;  /* Pointer to HTMText. */
  @callsuper(); /* Returns a bad error value. */
     /* Make sure there's a text object. If so, write it to file. */
  pself = ObjDerefGen( oself );
  if ( pself->HTMDI_textHandle == NullHandle ) {
    return( FALSE );
  }
  else {
    textOD = /*GeodeGetOptrNS(*/ @HTMText /*)*/;
    ourText = ConstructOptr( pself->HTMDI_textHandle,
                             OptrToChunk( textOD ) );
    return( WriteDataToFile( pself->GDI_fileHandle, ourText, error ) );
  }
} /* MSG_GEN_DOCUMENT_PHYSICAL_SAVE,
   * MSG_GEN_DOCUMENT_PHYSICAL_UPDATE */

@extern method HTMDocumentClass,
          MSG_GEN_DOCUMENT_PHYSICAL_SAVE_AS_FILE_HANDLE {
  optr textOD;  /* Pointer to HTMText. */
  @callsuper(); /* Returns a bad error value. */
     /* Check that there's a text object. Get a pointer to it.
      * Save text using passed file handle. */
  pself = ObjDerefGen( oself );
  if ( pself->HTMDI_textHandle == NullHandle ) {
    return( FALSE );
  }
  else {
    textOD = ConstructOptr( pself->HTMDI_textHandle,
                            OptrToChunk( /*GeodeGetOptrNS(*/ @HTMText/* )*/));
    return( WriteDataToFile( file, textOD, error ) );
  }
} /* MSG_GEN_DOCUMENT_PHYSICAL_SAVE_AS_FILE_HANDLE */

@extern method HTMDocumentClass, MSG_GEN_PROCESS_REDRAW_GENVIEW
{
optr ourText;
optr textOD;
@callsuper();
pself = ObjDerefGen(oself);
if (pself->HTMDI_textHandle==NullHandle){}
    else {ourText=/*GeodeGetOptrNS(*/@HTMText/*)*/;
          textOD=ConstructOptr(pself->HTMDI_textHandle,OptrToChunk(ourText));
          @call textOD::MSG_VIS_TEXT_RECALC_AND_DRAW();
          }
} /* CK */

