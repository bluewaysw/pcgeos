/***************************************************************************
 *                                                                         *
 *  GeoNoid                                                                *
 *                                                                         *
 ***************************************************************************/


/***************************************************************************
 *		Include files
 ***************************************************************************/
@include <stdapp.goh>
@include <Objects/colorC.goh>
#include <graphics.h>
#include <initfile.h>
@include <game.goh>
#include <stdlib.h>
#include <gstring.h>
#include <file.h>
#include <sound.h>
#include <localize.h>
#include <sem.h>
@include "Art/icon.goh"


#define ABS(x)    (((x)>=0) ? (x) : (-(x)))  /* Standard-Abs-Makro */
#define MIN(x,y)  (((x)<=(y)) ? (x) : (y))   /* Standard-Min-Makro */
#define MAX(x,y)  (((x)>=(y)) ? (x) : (y))   /* Standard-Max-Makro */

#define maxX					420
#define maxY					270
#define leftPos					15
#define rightPos				50
#define startSize				50

#define AnimLength				5

#define NOID_GAME_SPEED_FAST	1
#define NOID_GAME_SPEED_MEDIUM	2
#define NOID_GAME_SPEED_SLOW	3

#define SHOW_ON_STARTUP			1

#define SOUND_ON				1
#define SOUND_OFF				2
#define SOUND_SYSTEM			3

typedef struct{
	int ballX;
	int ballY;
	int dirX;
	int dirY;
	byte ballSpeed;
	Boolean activated;
}NoidBall;


MemHandle	hit,
			goal,
			lasershot,
			blockhit,
			gegnerhit,
			winSound;/*,
			loseSound;  */

GStateHandle	myGstate;
WindowHandle	winHan;

byte		anzahlSteine			= 0;
byte 		level[12*11];
byte 		maxLevel				= 1;
NoidBall	balls[3];

char 		noid_state_file[25] 	= "GeoNoid State" ;
char 		noid_path[20]       	= "Game" ;
char 		noid_relativePath[] 	= "." ;
word 		noid_drive 				= SP_PUBLIC_DATA ;

int			gameSpeed				= NOID_GAME_SPEED_MEDIUM;
int 		batSpeed				= 10;
int 		batAccel				= 5;
ColorQuad	color					= {C_BLACK,CF_INDEX,0,0};
word		sound 					= SOUND_SYSTEM;

Boolean		paused					= FALSE;
Boolean		g_optsStopped					= FALSE;
Boolean		gameEnd					= FALSE;
Boolean		ball_not_locked			= FALSE;
Boolean		gAktiv					= TRUE;
Boolean		shot;

int			punkte					= 0;
int			leben					= 3;
int			levelnr					= 1;

int			batX					= leftPos;
int			batY					= 10;
int			laenge					= startSize;
int			schuesse				= 0;

int			gDir					= 1;
int 		gPosX					= 140;
int 		gPosY					= maxY/2;
byte		gegnerAnim				= 0;

TimerHandle	HTimer;
word		timerid;
TimerHandle	HBTimer;
word		bTimerid;
TimerHandle	HGTimer;
word		gTimerid;

const word winSoundBuf[] = {     /* from blackjack win sound */
	SSE_CHANGE,             0, IP_ACOUSTIC_GRAND_PIANO, IT_STANDARD_TABLE,
	SSDTT_TICKS,            0,
	SSE_VOICE_ON,           0, MIDDLE_C, DYNAMIC_F,
	SSDTT_TICKS,            10,
	SSE_VOICE_OFF,          0,
	SSDTT_TICKS,            0,
	SSE_VOICE_ON,           0, MIDDLE_E, DYNAMIC_F,
	SSDTT_TICKS,            10,
	SSE_VOICE_OFF,          0,
	SSDTT_TICKS,            0,
	SSE_VOICE_ON,           0, MIDDLE_G, DYNAMIC_F,
	SSDTT_TICKS,            10,
	SSE_VOICE_OFF,          0,
	SSDTT_TICKS,            0,
	SSE_VOICE_ON,           0, HIGH_C, DYNAMIC_F,
	SSDTT_TICKS,            15,
	SSE_VOICE_OFF,          0,
	SSDTT_TICKS,            0,
	SSE_VOICE_ON,           0, MIDDLE_G, DYNAMIC_F,
	SSDTT_TICKS,            8,
	SSE_VOICE_OFF,          0,
	SSDTT_TICKS,            0,
	SSE_VOICE_ON,           0, HIGH_C, DYNAMIC_F,
	SSDTT_TICKS,            25,
	SSE_VOICE_OFF,          0,
	SSDTT_TICKS,            0,
	SSE_GENERAL,            GE_END_OF_SONG};

/*const word loseSoundBuf[] = {     /* from blackjack lose sound */
/*	SSE_CHANGE,             0, IP_ACOUSTIC_GRAND_PIANO, IT_STANDARD_TABLE,
	SSDTT_TICKS,            0,
	SSE_VOICE_ON,           0, LOW_D, DYNAMIC_F,
	SSDTT_TICKS,            20,
	SSE_VOICE_OFF,          0,
	SSDTT_TICKS,            1,
	SSE_VOICE_ON,           0, LOW_D, DYNAMIC_F,
	SSDTT_TICKS,            20,
	SSE_VOICE_OFF,          0,
	SSDTT_TICKS,            1,
	SSE_VOICE_ON,           0, LOW_D, DYNAMIC_F,
	SSDTT_TICKS,            7,
	SSE_VOICE_OFF,          0,
	SSDTT_TICKS,            1,
	SSE_VOICE_ON,           0, LOW_D, DYNAMIC_F,
	SSDTT_TICKS,            20,
	SSE_VOICE_OFF,          0,
	SSDTT_TICKS,            0,
	SSE_VOICE_ON,           0, LOW_F, DYNAMIC_F,
	SSDTT_TICKS,            20,
	SSE_VOICE_OFF,          0,
	SSDTT_TICKS,            0,
	SSE_VOICE_ON,           0, LOW_E, DYNAMIC_F,
	SSDTT_TICKS,            7,
	SSE_VOICE_OFF,          0,
	SSDTT_TICKS,            1,
	SSE_VOICE_ON,           0, LOW_E, DYNAMIC_F,
	SSDTT_TICKS,            20,
	SSE_VOICE_OFF,          0,
	SSDTT_TICKS,            0,
	SSE_VOICE_ON,           0, LOW_D, DYNAMIC_F,
	SSDTT_TICKS,            7,
	SSE_VOICE_OFF,          0,
	SSDTT_TICKS,            1,
	SSE_VOICE_ON,           0, LOW_D, DYNAMIC_F,
	SSDTT_TICKS,            20,
	SSE_VOICE_OFF,          0,
	SSDTT_TICKS,            0,
	SSE_VOICE_ON,           0, LOW_D_b, DYNAMIC_F,
	SSDTT_TICKS,            7,
	SSE_VOICE_OFF,          0,
	SSDTT_TICKS,            0,
	SSE_VOICE_ON,           0, LOW_D, DYNAMIC_F,
	SSDTT_TICKS,            20,
	SSE_VOICE_OFF,          0,
	SSDTT_TICKS,            0,
	SSE_GENERAL,            GE_END_OF_SONG};


/***************************************************************************
 *		Class & Message Definitions
 ***************************************************************************/

    /*---------------------------------------------------------------------*/
    @class NoidProcessClass, GenProcessClass;
    	@message void MSG_NOID_NEW_GAME();
    	@message void MSG_NOID_CONTINUE();
		@message void MSG_NOID_PAUSE();

		@message void MSG_NOID_PADDLE_OPTIONS();
		@message void MSG_NOID_NEW_PADDLE_OPTIONS();
		@message void MSG_NOID_CANCEL_PADDLE_OPTIONS();

		@message (GEN_ITEM_GROUP_APPLY_MSG) MSG_NOID_SOUND_CHOICE_CHANGED;
		@message (GEN_ITEM_GROUP_APPLY_MSG) MSG_NOID_SPEED_CHOICE_CHANGED;
		@message (GEN_ITEM_GROUP_APPLY_MSG) MSG_NOID_COLOR_CHOICE_CHANGED;

        @message void MSG_START_TIMER();
  		@message void MSG_STOP_TIMER();
  		@message void MSG_START_BALLTIMER();
		@message void MSG_STOP_BALLTIMER();
		@message void MSG_START_GEGNERTIMER();
  		@message void MSG_STOP_GEGNERTIMER();

  		@message void MSG_TIMER_RANG();

        @message void MSG_NOID_GAME_END();
		@message void MSG_REDRAW_GAMEBOARD();
    @endc   /* end of class definition */

@classdecl      NoidProcessClass, neverSaved;

/***************************************************************************
 *		UI Objects
 ***************************************************************************/

/*=========================================================================*/

@start	AppResource ;
    /*---------------------------------------------------------------------*/
    @object GenApplicationClass NoidApp = {
        GI_visMoniker = list {@NoidTextMoniker,
                              @Moniker0,
                              @Moniker1,
                              @Moniker5 }
	    GI_comp       = @NoidPrimary;
        gcnList(MANUFACTURER_ID_GEOWORKS,GAGCNLT_WINDOWS) =
                        @NoidPrimary;
        gcnList(MANUFACTURER_ID_GEOWORKS,MGCNLT_ACTIVE_LIST) =
				        @NoidColorControl,
					    @NoidHighScore;
        gcnList(MANUFACTURER_ID_GEOWORKS,GAGCNLT_SELF_LOAD_OPTIONS) =
				        @NoidColorControl;
        gcnList(MANUFACTURER_ID_GEOWORKS,GAGCNLT_STARTUP_LOAD_OPTIONS) =
                        @NoidColorControl ;
    }
    /*---------------------------------------------------------------------*/
    @visMoniker NoidTextMoniker = "GeoNoid" ;
    /*---------------------------------------------------------------------*/
@end	AppResource

/*=========================================================================*/

@start	Interface		/* this resource is for misc UI objects */;

	@object GenPrimaryClass NoidPrimary  = {
		GI_attrs = @default | GA_KBD_SEARCH_PATH;
	    GI_comp = 	@NoidWholeGroup,
	                @NoidGameMenu,
	    			@NoidOptionsMenu,
	    			@QTipsDialogBox;
	    /*ATTR_GEN_HELP_CONTEXT = "TOC";*/
	    HINT_PRIMARY_NO_HELP_BUTTON;
	    HINT_PRIMARY_NO_FILE_MENU ;
		HINT_SIZE_WINDOW_AS_DESIRED ;
	    HINT_CENTER_WINDOW;
	    HINT_CENTER_CHILDREN_HORIZONTALLY ;
		HINT_CENTER_CHILDREN_VERTICALLY ;
	}
	/*---------------------------------------------------------------------*/
    @object GenInteractionClass NoidWholeGroup = {
		GI_comp = @NoidTopGroup,
                  @NoidViewOwner ;
		HINT_CENTER_CHILDREN_VERTICALLY ;
		HINT_CENTER_CHILDREN_HORIZONTALLY ;
		HINT_INCLUDE_ENDS_IN_CHILD_SPACING;
        HINT_DEFAULT_FOCUS ;
        HINT_DEFAULT_TARGET;
        HINT_DEFAULT_MODEL;
	}
	/*---------------------------------------------------------------------*/
	@object GenInteractionClass NoidTopGroup = {
		GI_comp = @NoidNewTrigger,
		          @NoidScoreValue,
		          @NoidLiveValue,
		          @NoidLevelValue;
		HINT_ORIENT_CHILDREN_HORIZONTALLY ;
		HINT_CENTER_CHILDREN_HORIZONTALLY ;
		HINT_CENTER_CHILDREN_VERTICALLY ;
		HINT_EXPAND_WIDTH_TO_FIT_PARENT ;
		HINT_FULL_JUSTIFY_CHILDREN_HORIZONTALLY;
	}
	/*---------------------------------------------------------------------*/
	@object GenTriggerClass NoidNewTrigger = {
		GI_visMoniker = 'N', "New";
		GTI_destination = process;
		GTI_actionMsg = MSG_NOID_NEW_GAME;
	}
	/*---------------------------------------------------------------------*/
	@object GenValueClass NoidScoreValue = {
	    GI_visMoniker = "Score:";
	    GVLI_displayFormat = GVDF_INTEGER;
	    GVLI_value = MakeWWFixed(0.0);
	    GVLI_minimum = MakeWWFixed(0.0);
	    HINT_VALUE_NOT_INCREMENTABLE;
	    HINT_VALUE_DIGITAL_DISPLAY;
    	HINT_VALUE_NOT_DIGITALLY_EDITABLE;
	}
	/*---------------------------------------------------------------------*/
	@object GenValueClass NoidLiveValue = {
	    GI_visMoniker = "Lives:";
	    GVLI_displayFormat = GVDF_INTEGER;
	    GVLI_value = MakeWWFixed(0.0);
	    HINT_VALUE_NOT_INCREMENTABLE;
	    HINT_VALUE_DIGITAL_DISPLAY;
    	HINT_VALUE_NOT_DIGITALLY_EDITABLE;
	}
	/*---------------------------------------------------------------------*/
	@object GenValueClass NoidLevelValue = {
	    GI_visMoniker = "Level:";
	    GVLI_displayFormat = GVDF_INTEGER;
	    GVLI_value = MakeWWFixed(1.0);
	    HINT_VALUE_NOT_INCREMENTABLE;
	    HINT_VALUE_DIGITAL_DISPLAY;
    	HINT_VALUE_NOT_DIGITALLY_EDITABLE;
	}
	/*---------------------------------------------------------------------*/
	@object GenViewClass NoidViewOwner = {
    	GVI_horizAttrs = @default | GVDA_NO_LARGER_THAN_CONTENT | GVDA_NO_SMALLER_THAN_CONTENT;
	    GVI_vertAttrs  = @default | GVDA_NO_LARGER_THAN_CONTENT | GVDA_NO_SMALLER_THAN_CONTENT;
	    GVI_content = process;
	    GVI_docBounds = {0, 0, maxX, maxY};
        HINT_DEFAULT_TARGET;
	    HINT_DEFAULT_FOCUS;
        HINT_DEFAULT_MODEL;
	}
	/*---------------------------------------------------------------------*/
	@object GenInteractionClass NoidGameMenu = {
		GI_attrs = @default | GA_KBD_SEARCH_PATH;
		GI_comp = @NoidNewGameTrigger,
				  @NoidQTipsTrigger,
			      @NoidPauseTrigger,
			      @NoidContTrigger,
				  @NoidHighScore;
		GI_visMoniker = 'G', "Game" ;
	    GII_visibility = GIV_POPUP ;
	    ATTR_GEN_INTERACTION_GROUP_TYPE = (GIGT_FILE_MENU);
	}
	/*---------------------------------------------------------------------*/
	@object GenTriggerClass NoidNewGameTrigger = {
		GI_visMoniker   = 'N', "New" ;
		GTI_destination = process ;
		GTI_actionMsg   = MSG_NOID_NEW_GAME;
	}
	/*---------------------------------------------------------------------*/
	@object GenTriggerClass NoidQTipsTrigger = {
		GI_visMoniker   = 'Q', "Quick Tips" ;
		GTI_destination = @QTipsDialogBox ;
		GTI_actionMsg   = MSG_GEN_INTERACTION_INITIATE ;
		HINT_TRIGGER_BRINGS_UP_WINDOW;
	}
	/*---------------------------------------------------------------------*/
	@object GenTriggerClass NoidPauseTrigger = {
		GI_attrs = @default | GA_KBD_SEARCH_PATH;
		GI_visMoniker   = 'a', "Pause";
		GI_states = @default & (~GS_ENABLED);
		GI_kbdAccelerator = control 'p';
		GTI_destination = process;
		GTI_actionMsg   = MSG_NOID_PAUSE;
	}
	/*---------------------------------------------------------------------*/
	@object GenTriggerClass NoidContTrigger = {
		GI_attrs = @default | GA_KBD_SEARCH_PATH;
		GI_visMoniker   = 'o', "Continue" ;
		GI_states = @default & (~GS_ENABLED);
		GI_kbdAccelerator = control 'c';
		GTI_destination = process;
		GTI_actionMsg   = MSG_NOID_CONTINUE;
	}
	/*---------------------------------------------------------------------*/
	@object HighScoreClass NoidHighScore = {
		HSI_fileName = "GeoNoid High Scores";
		HSI_creator = {"Noid", 16431};
		HSI_highScoreTitle = "GeoNoid High Scores";
	}
	/*---------------------------------------------------------------------*/
	@object GenInteractionClass NoidOptionsMenu = {
	    GI_attrs = @default | GA_KBD_SEARCH_PATH ;
	    GI_comp        = @NoidOptionsSpeedGroup,
						 @NoidOptionsPaddle,
						 @NoidOptionsColor,
						 @NoidOptionsSoundGroup;
	    GII_visibility = GIV_POPUP ;
	    ATTR_GEN_INTERACTION_GROUP_TYPE = (GIGT_OPTIONS_MENU) ;
	}
	/*---------------------------------------------------------------------*/
	@object GenInteractionClass NoidOptionsSpeedGroup = {
		GI_visMoniker = 'G', "Game Speed";
		GI_comp = @NoidOptionsSpeedList;
		GII_visibility = GIV_POPUP;
	}
	/*---------------------------------------------------------------------*/
	@object GenItemGroupClass NoidOptionsSpeedList = {
		GI_comp = @NoidOptionsSpeedSlow,
	  	          @NoidOptionsSpeedMedium,
	  	          @NoidOptionsSpeedFast;
	  	GIGI_selection = NOID_GAME_SPEED_MEDIUM;
	  	GIGI_destination = process;
	  	GIGI_applyMsg = MSG_NOID_SPEED_CHOICE_CHANGED;
	}
	/*---------------------------------------------------------------------*/
	@object GenItemClass NoidOptionsSpeedFast = {
		GI_visMoniker = 'F', "Fast";
		GII_identifier = NOID_GAME_SPEED_FAST;
	}
	/*---------------------------------------------------------------------*/
	@object GenItemClass NoidOptionsSpeedMedium = {
		GI_visMoniker = 'M', "Medium";
		GII_identifier = NOID_GAME_SPEED_MEDIUM;
	}
	/*---------------------------------------------------------------------*/
	@object GenItemClass NoidOptionsSpeedSlow = {
		GI_visMoniker = 'S', "Slow";
		GII_identifier = NOID_GAME_SPEED_SLOW;
	}
	/*---------------------------------------------------------------------*/
	@object GenTriggerClass NoidOptionsPaddle = {
	    GI_visMoniker   = 'P', "Paddle" ;
	    GTI_destination = process;
	    GTI_actionMsg =   MSG_NOID_PADDLE_OPTIONS;
        HINT_TRIGGER_BRINGS_UP_WINDOW;
	}
	/*---------------------------------------------------------------------*/
	@object GenInteractionClass NoidOptionsColor = {
	    GI_visMoniker   = 'C', "Color Change" ;
	    GII_visibility  = GIV_DIALOG ;
	    GI_comp         = @NoidColorAll ;
	}
	/*---------------------------------------------------------------------*/
	@object GenInteractionClass NoidOptionsSoundGroup = {
		GI_visMoniker = 'S', "Sound";
		GI_comp = @NoidOptionsSoundList;
		GII_visibility = GIV_POPUP;
	}
	/*---------------------------------------------------------------------*/
    @object GenItemGroupClass NoidOptionsSoundList = {
		GI_comp          = @NoidSoundOn,
						   @NoidSoundOff,
						   @NoidSystemPref ;
		GIGI_selection   = SOUND_SYSTEM ;
	    GIGI_destination = process ;
		GIGI_applyMsg = MSG_NOID_SOUND_CHOICE_CHANGED;
	}
	/*---------------------------------------------------------------------*/
	@object GenItemClass NoidSoundOn = {
		GI_visMoniker = 'S', "Sound On" ;
		GII_identifier = SOUND_ON ;
	}
	/*---------------------------------------------------------------------*/
	@object GenItemClass NoidSoundOff = {
		GI_visMoniker = 'O', "Sound Off" ;
		GII_identifier = SOUND_OFF ;
	}
	/*---------------------------------------------------------------------*/
	@object GenItemClass NoidSystemPref = {
		GI_visMoniker = 'P', "Use System Preference" ;
		GII_identifier = SOUND_SYSTEM ;
	}
	/*---------------------------------------------------------------------*/
	@object GenInteractionClass NoidGameSolveBox = {
			  GI_visMoniker   = "We have a winner!" ;
			  GI_link 		= @NoidPrimary;
			  GII_visibility  = GIV_DIALOG ;
			  GII_type        = GIT_NOTIFICATION ;
			  GII_attrs       = @default                         |
								GIA_INITIATED_VIA_USER_DO_DIALOG |
								GIA_MODAL                        |
								GIA_NOT_USER_INITIATABLE;
			  GI_comp         = @SolveGlyph1, @SolveGlyph2;
			  HINT_CENTER_CHILDREN_HORIZONTALLY ;
	}
	/*---------------------------------------------------------------------*/
	@object GenGlyphClass SolveGlyph1 = {
		GI_visMoniker = "CONGRATULATIONS!" ;
	}
	/*---------------------------------------------------------------------*/
	@object GenGlyphClass SolveGlyph2 = {
		GI_visMoniker = "You have completed all the levels." ;
	}
	/*---------------------------------------------------------------------*/
/*	@object GenInteractionClass NoidGameWinBox = {
			  GI_visMoniker   = "We have a winner!" ;
			  GI_link 		= @NoidPrimary;
			  GII_visibility  = GIV_DIALOG ;
			  GII_type        = GIT_NOTIFICATION ;
			  GII_attrs       = @default                         |
								GIA_INITIATED_VIA_USER_DO_DIALOG |
								GIA_MODAL                        |
								GIA_NOT_USER_INITIATABLE;
			  GI_comp         = @WinGlyph1, @WinGlyph2;
			  HINT_CENTER_CHILDREN_HORIZONTALLY ;
	}
	/*---------------------------------------------------------------------*/
/*	@object GenGlyphClass WinGlyph1 = {
		GI_visMoniker = "CONGRATULATIONS!" ;
	}
	/*---------------------------------------------------------------------*/
/*	@object GenGlyphClass WinGlyph2 = {
		GI_visMoniker = "You have made many scores." ;
	}
	/*---------------------------------------------------------------------*/
/*	@object GenInteractionClass NoidGameLoseBox = {
			  GI_visMoniker   = "We have a loser!" ;
			  GI_link 		= @NoidPrimary;
			  GII_visibility  = GIV_DIALOG ;
			  GII_type        = GIT_NOTIFICATION ;
			  GII_attrs       = @default                         |
								GIA_INITIATED_VIA_USER_DO_DIALOG |
								GIA_MODAL                        |
								GIA_NOT_USER_INITIATABLE;
			  GI_comp         = @LoseGlyph1, @LoseGlyph2;
			  HINT_CENTER_CHILDREN_HORIZONTALLY ;
	}
	/*---------------------------------------------------------------------*/
/*	@object GenGlyphClass LoseGlyph1 = {
		GI_visMoniker = "Not enough scores for the high scores!" ;
	}
	/*---------------------------------------------------------------------*/
/*	@object GenGlyphClass LoseGlyph2 = {
		GI_visMoniker = "Try it again!" ;
	}
	/*---------------------------------------------------------------------*/

@end Interface;

@start OptionsInterface;

    /*---------------------------------------------------------------------*/
	@object GenInteractionClass NoidColorAll = {
	    GI_comp = @NoidColorText,
				  @NoidColorControl;
		HINT_CENTER_CHILDREN_HORIZONTALLY ;
	}
	/*---------------------------------------------------------------------*/
	@object GenGlyphClass NoidColorText = {
	    GI_visMoniker = "Select Background  Color";
	}
    /*---------------------------------------------------------------------*/
    @object ColorSelectorClass NoidColorControl = {
        GCI_output = process;
        ATTR_GEN_CONTROL_PROHIBIT_UI = (
							CSF_RGB |
							CSF_OTHER |
							CSF_PATTERN |
							CSF_DRAW_MASK);
    }
    /*---------------------------------------------------------------------*/
	@object GenInteractionClass NoidPaddleOptions = {
	    GI_visMoniker = "Paddle Settings";
		GI_link = @NoidPrimary;
	    GI_comp = @NoidPaddleOptionsSpeedValue,
	    		  @NoidPaddleOptionsAccelValue,
	              @NoidPaddleOptionsTriggerOk,
	              @NoidPaddleOptionsTriggerCancel;
	    GII_visibility = GIV_DIALOG ;
		GII_attrs = @default | GIA_MODAL | GIA_NOT_USER_INITIATABLE;
		HINT_RIGHT_JUSTIFY_CHILDREN;
	}
	/*---------------------------------------------------------------------*/
	@object GenValueClass NoidPaddleOptionsSpeedValue = {
    	GI_visMoniker = 's',"Paddle speed:";
    	GVLI_displayFormat = GVDF_INTEGER;
    	GVLI_value = MakeWWFixed(10.0);
    	GVLI_minimum = MakeWWFixed(2.0);
    	GVLI_maximum = MakeWWFixed(30.0);
    	HINT_VALUE_DIGITAL_DISPLAY;
	}
	/*---------------------------------------------------------------------*/
	@object GenValueClass NoidPaddleOptionsAccelValue = {
	    GI_visMoniker = 'P',"Paddle acceleration:";
	    GVLI_displayFormat = GVDF_INTEGER;
	    GVLI_value = MakeWWFixed(5.0);
	    GVLI_minimum = MakeWWFixed(0.0);
	    GVLI_maximum = MakeWWFixed(15.0);
	    HINT_VALUE_DIGITAL_DISPLAY;
	}
	/*---------------------------------------------------------------------*/
	@object GenTriggerClass NoidPaddleOptionsTriggerOk = {
	    GTI_destination = process;
	    GTI_actionMsg   = MSG_NOID_NEW_PADDLE_OPTIONS;
	    GI_attrs = @default | GA_SIGNAL_INTERACTION_COMPLETE;
	    ATTR_GEN_TRIGGER_INTERACTION_COMMAND = { IC_APPLY };
	    HINT_SEEK_REPLY_BAR;
	}
	/*---------------------------------------------------------------------*/
	@object GenTriggerClass NoidPaddleOptionsTriggerCancel = {
	    GTI_destination = process;
		 GTI_actionMsg   = MSG_NOID_CANCEL_PADDLE_OPTIONS;
	    GI_attrs = @default | GA_SIGNAL_INTERACTION_COMPLETE;
		 ATTR_GEN_TRIGGER_INTERACTION_COMMAND = { IC_DISMISS };
	    HINT_SEEK_REPLY_BAR;
    }


@end OptionsInterface;

/*=========================================================================*/

@start BallResource;

@include "Art/ball.goh"

@end BallResource;

/*=========================================================================*/

@start StringResource, data;

@chunk char NoidFileError[] = "File Error!";
@chunk char NoidNewGameMsg[] = "Changing this option will end the current game and begin a new one.  Are you sure you want to do this?";
@chunk char NoidGameOver[] = "Game Over";
@chunk char NoidPaused[] = "Paused";

@end StringResource;

/*=========================================================================*/

@start OpponentResource;

@include "Art/oppon1.goh"
@include "Art/oppon2.goh"
@include "Art/oppon3.goh"
@include "Art/oppon4.goh"
@include "Art/oppon5.goh"

@end OpponentResource;

/*=========================================================================*/

@start FeatureBrickResource;

@include "Art/brick1.goh"
@include "Art/brick2.goh"
@include "Art/brick3.goh"
@include "Art/brick4.goh"
@include "Art/brick5.goh"
@include "Art/brick6.goh"
@include "Art/brick7.goh"

@end FeatureBrickResource;

/*=========================================================================*/

@start ScoreBrickResource;

@include "Art/brick8.goh"
@include "Art/brick9.goh"
@include "Art/brick10.goh"
@include "Art/brick11.goh"
@include "Art/brick12.goh"
@include "Art/brick13.goh"
@include "Art/brick14.goh"
@include "Art/brick15.goh"

@end ScoreBrickResource;


/*=========================================================================*/

@start QTipsResource;

@include "Art/QTip1.goh"
@include "Art/QTip2.goh"

	 @object GenInteractionClass QTipsDialogBox = {
		  GI_visMoniker = "GeoNoid Quick Tips";
		  GI_comp = @GoalText,
					@QuickTipsGroup,
					@ShowOnStartupGroup,
					@OKTipsButton;
		  GII_visibility = GIV_DIALOG ;
		  GII_attrs = @default | GIA_MODAL | GIA_NOT_USER_INITIATABLE;
		  HINT_CENTER_CHILDREN_HORIZONTALLY ;
		  /*ATTR_GEN_HELP_CONTEXT = "TOC";*/
	 }
	 /*---------------------------------------------------------------------*/
	 @object GenTextClass GoalText = {
		  GI_attrs = @default | GA_READ_ONLY;
		  GTXI_text = "The goal of the game is to destroy all the blocks in the playing field. Move your paddle to keep the ball in play and destroy the blocks. Destroying blocks adds points to your score. You have three lives to destroy all the blocks.";
		  ATTR_GEN_TEXT_NEVER_MAKE_SCROLLABLE;
	 }
	 /*---------------------------------------------------------------------*/
	 @object GenBooleanGroupClass ShowOnStartupGroup = {
		  GI_comp = @ShowOnStartupBoolean;
	 }
	 /*---------------------------------------------------------------------*/
	 @object GenBooleanClass ShowOnStartupBoolean = {
		  GI_visMoniker = 'S', "Show this Dialog box when GeoNoid starts";
		  GBI_identifier = SHOW_ON_STARTUP;
	 }
	 /*---------------------------------------------------------------------*/
	 @object GenTriggerClass OKTipsButton = {
		  GI_visMoniker   = 'O', "OK";
        GI_attrs = @default | GA_SIGNAL_INTERACTION_COMPLETE ;
		  HINT_SEEK_REPLY_BAR;
		  HINT_DEFAULT_DEFAULT_ACTION;
	 }
	 /*---------------------------------------------------------------------*/
	 @object GenInteractionClass QuickTipsGroup = {
		  GI_comp = @QTip1,
					@QTip2;
	 }
	 /*---------------------------------------------------------------------*/
	 @object GenInteractionClass QTip1 = {
		  GI_comp = @QTip1GlyphHolder, @QTip1Text ;
		  HINT_ORIENT_CHILDREN_HORIZONTALLY;
		  HINT_CENTER_CHILDREN_VERTICALLY;
	 }
	 /*---------------------------------------------------------------------*/
	 @object GenInteractionClass QTip1GlyphHolder = {
		  GI_comp = @QTip1Glyph;
		  HINT_CENTER_CHILDREN_HORIZONTALLY;
		  HINT_CENTER_CHILDREN_VERTICALLY;
		  HINT_FIXED_SIZE = {SST_PIXELS | 80, 0,0};
		  /* ^^^ is based on the width of the widest icon */
	 }
	 /*---------------------------------------------------------------------*/
	 @object GenGlyphClass QTip1Glyph = {
		  GI_visMoniker = list { @QTip1Moniker };
	 }
	 /*---------------------------------------------------------------------*/
	 @object GenTextClass QTip1Text = {
		  GI_attrs = @default | GA_READ_ONLY;
		  GTXI_text = "Use the arrow keys on your keyboard to move the paddle.";
		  ATTR_GEN_TEXT_NEVER_MAKE_SCROLLABLE;
		  HINT_MINIMUM_SIZE = {SST_PIXELS | 325, 0, 0};
	 }
	 /*---------------------------------------------------------------------*/
	 @object GenInteractionClass QTip2 = {
		  GI_comp = @QTip2GlyphHolder, @QTip2Text ;
		  HINT_ORIENT_CHILDREN_HORIZONTALLY;
		  HINT_CENTER_CHILDREN_VERTICALLY;
	 }
	 /*---------------------------------------------------------------------*/
	 @object GenInteractionClass QTip2GlyphHolder = {
		  GI_comp = @QTip2Glyph;
		  HINT_CENTER_CHILDREN_HORIZONTALLY;
		  HINT_CENTER_CHILDREN_VERTICALLY;
		  HINT_FIXED_SIZE = {SST_PIXELS | 80, 0,0};
	 }
	 /*---------------------------------------------------------------------*/
	 @object GenGlyphClass QTip2Glyph = {
		  GI_visMoniker = list { @QTip2Moniker };
	 }
	 /*---------------------------------------------------------------------*/
	 @object GenTextClass QTip2Text = {
		  GI_attrs = @default | GA_READ_ONLY;
		  GTXI_text = "The moving GeoNoid can be either a friend or foe; it all depends on how well you play the game. If the ball hits the GeoNoid, two things can happen: either the ball will bounce back toward your paddle, or the ball will change course and hit a different area of blocks.";
		  ATTR_GEN_TEXT_NEVER_MAKE_SCROLLABLE;
		  HINT_MINIMUM_SIZE = {SST_PIXELS | 325, 0, 0};
	 }

@end QTipsResource;

/*-------------------------------------------------------------------------*/
void animGegner(GStateHandle myGstate)
{
	static Boolean	gDeaktiv = FALSE;
	word			oldPosY = gPosY;

	if(myGstate)
	{
		MemLock(OptrToHandle(@NoidOpponent1Moniker));

    	if (gAktiv) gDeaktiv=FALSE;
    	if (!gDeaktiv) gegnerAnim++;
    	if (gegnerAnim>AnimLength*2) gegnerAnim=0;
    	if (gAktiv) {
    		gPosY+=gDir;
    		if ((gPosY+40 >= maxY) || (gPosY <= 0)) gDir=-gDir;
			GrBitBlt(myGstate, gPosX, oldPosY, gPosX, gPosY, 39, 39, BLTM_MOVE);
    		/* Draw the "gegner" */
    		if(gegnerAnim<AnimLength) {
				if(gDir>0) GrDrawBitmap(myGstate, gPosX, gPosY, LMemDeref(@NoidOpponent4Moniker), NULL);
				else       GrDrawBitmap(myGstate, gPosX, gPosY, LMemDeref(@NoidOpponent2Moniker), NULL);
			} else {
				if(gDir>0) GrDrawBitmap(myGstate, gPosX, gPosY, LMemDeref(@NoidOpponent5Moniker), NULL);
				else       GrDrawBitmap(myGstate, gPosX, gPosY, LMemDeref(@NoidOpponent3Moniker), NULL);
			}
        } else {
      		if(gegnerAnim<AnimLength) {
      			GrDrawBitmap(myGstate, gPosX, gPosY, LMemDeref(@NoidOpponent1Moniker), NULL);
      		} else {
         		if(!gDeaktiv) {
            		GrInvalRect(myGstate, gPosX, gPosY, gPosX+40, gPosY+40);
           			gDeaktiv=TRUE;
           		}
           	}
		}
		MemUnlock(OptrToHandle(@NoidOpponent1Moniker));
	}
}
/*-------------------------------------------------------------------------*/
void batUp(byte duration)
{ int oldPos=batY;

  if (paused) return;
  if (batY>0) batY-=batSpeed+duration;
  if (batY<=1) batY=1;
  if (myGstate) GrBitBlt(myGstate, batX, oldPos, batX, batY, 6, laenge+1, BLTM_MOVE);
}
/*-------------------------------------------------------------------------*/
void batDown(byte duration)
{ int oldPos=batY;

  if (paused) return;
  if (batY+laenge<maxY-1) batY+=batSpeed+duration;
  if (batY+laenge>maxY-2) batY=maxY-2-laenge;
  if (myGstate) GrBitBlt(myGstate, batX, oldPos, batX, batY, 6, laenge+1, BLTM_MOVE);
}
/*-------------------------------------------------------------------------*/
void batLeft(void)
{ int oldPos=batX;
  byte i;

  if (paused) return;
  if (batX!=leftPos)
  { batX=leftPos;
    if (myGstate) GrBitBlt(myGstate,oldPos,batY,batX,batY,6,laenge+1,BLTM_MOVE);
    for (i=0; i<3; i++)
      if ((balls[i].ballX<=rightPos+7) && (balls[i].ballX>=leftPos))
	if ((balls[i].ballY>batY) && (balls[i].ballY<batY+laenge))
        { balls[i].ballX=leftPos-7;
          if (myGstate)
	    GrInvalRect(myGstate,leftPos,batY,rightPos+15,batY+laenge+7);
	  /* ^ noetig, da Ball evtl. im Schlger war ^*/
        }
  }
}
/*-------------------------------------------------------------------------*/
void batRight(void)
{
	int		oldPos = batX;
	byte	i;

	if (paused) return;
	if (batX!=rightPos) {
		batX=rightPos;
		if (myGstate) GrBitBlt(myGstate, oldPos, batY, batX, batY, 6, laenge+1, BLTM_MOVE);
		for (i=0; i<3; i++)
			if ((balls[i].ballX<=rightPos+7) && (balls[i].ballX>=leftPos))
				if ((balls[i].ballY>batY) && (balls[i].ballY<batY+laenge)) {
					balls[i].ballX = rightPos+7;
					if (myGstate)
						GrInvalRect(myGstate, leftPos, batY, rightPos+15, batY+laenge+7);
				}
	}
}
/*-------------------------------------------------------------------------*/
void NoidDraw(GStateHandle mgstate)          /* GState to draw to */
{
	byte			x, y;
	optr			steine[] =	{	@NoidBrick1Moniker, /* 1 point block */
									@NoidBrick2Moniker, /* 2 point block */
									@NoidBrick3Moniker, /* 3 point block */
									@NoidBrick4Moniker, /* 4 point block */
									@NoidBrick5Moniker, /* 5 point block */
								 	@NoidBrick6Moniker, /* 6 point block */
								 	@NoidBrick7Moniker, /* indestructible */
								 	@NoidBrick8Moniker, /* next level    */
								 	@NoidBrick9Moniker, /* extra live    */
								 	@NoidBrick15Moniker, /* start multiball */
								 	@NoidBrick10Moniker, /* double block */
								 	@NoidBrick11Moniker, /* laser canon */
								 	@NoidBrick12Moniker, /* ball slows down */
								 	@NoidBrick13Moniker, /* decrease paddle size */
								 	@NoidBrick14Moniker  /* increase paddle size */
								 	};

	 @call NoidViewOwner::MSG_GEN_VIEW_SET_COLOR(color.CQ_redOrIndex,
 	                           color.CQ_info, (color.CQ_blue<<8) | color.CQ_green);

	/* Draw the bat */
	GrSetLineColor(mgstate, CF_INDEX, C_WHITE, 0, 0);
	GrDrawLine(mgstate,batX+0,batY,batX+0,batY+laenge);
	GrDrawLine(mgstate,batX+1,batY,batX+1,batY+laenge);
	GrSetLineColor(mgstate, CF_INDEX, C_YELLOW, 0, 0);
	GrDrawLine(mgstate,batX+2,batY,batX+2,batY+laenge);
	GrDrawLine(mgstate,batX+3,batY,batX+3,batY+laenge);
	GrDrawLine(mgstate,batX+4,batY,batX+4,batY+laenge);
	GrSetLineColor(mgstate, CF_INDEX, C_BROWN, 0, 0);
	GrDrawLine(mgstate,batX+5,batY,batX+5,batY+laenge);
	if (schuesse) {
		GrSetLineColor(mgstate, CF_INDEX, C_GREEN, 0, 0);
		GrDrawLine(mgstate,batX,batY+(laenge/2)-1,batX+5,batY+(laenge/2)-1);
		GrDrawLine(mgstate,batX,batY+(laenge/2),batX+5,batY+(laenge/2));
		GrDrawLine(mgstate,batX,batY+(laenge/2)+1,batX+5,batY+(laenge/2)+1);
	}

	/* Draw the blocks */
	anzahlSteine = 0;
	for (x=0;x<=11;x++) {
		for (y=0;y<=10;y++) {
			if(level[x+y*12]) {
				MemLock(OptrToHandle(steine[(level[x+y*12])-1]));
				GrDrawBitmap(mgstate, 250+x*13, 15+y*22, LMemDeref(steine[(level[x+y*12])-1]), NULL);
				MemUnlock(OptrToHandle(steine[(level[x+y*12])-1]));
				if (level[x+y*12] != 7) anzahlSteine++;
			}
		}
	}

	/* Draw the "gegner" */
	if(gAktiv) {
		MemLock(OptrToHandle(@NoidOpponent1Moniker));
		if(gegnerAnim<AnimLength) {
			if(gDir>0) GrDrawBitmap(mgstate, gPosX, gPosY, LMemDeref(@NoidOpponent4Moniker), NULL);
			else       GrDrawBitmap(mgstate, gPosX, gPosY, LMemDeref(@NoidOpponent2Moniker), NULL);
		} else {
			if(gDir>0) GrDrawBitmap(mgstate, gPosX, gPosY, LMemDeref(@NoidOpponent5Moniker), NULL);
			else       GrDrawBitmap(mgstate, gPosX, gPosY, LMemDeref(@NoidOpponent3Moniker), NULL);
		}
		MemUnlock(OptrToHandle(@NoidOpponent1Moniker));
	}

	MemLock(OptrToHandle(@NoidBallMoniker));
	for (x=0; x<3; x++) {
		if(balls[x].activated)
			GrDrawBitmap(mgstate, balls[x].ballX, balls[x].ballY, LMemDeref(@NoidBallMoniker), NULL);
	}
	MemUnlock(OptrToHandle(@NoidBallMoniker));

	if(gameEnd) {
		GrSetTextColor(mgstate, CF_INDEX, C_BLACK, 0, 0);
		GrSetFont(mgstate, FID_DTC_URW_ROMAN, MakeWWFixed(36));
		MemLock(OptrToHandle(@NoidGameOver));
		GrDrawText(mgstate, 115, 115, LMemDeref(@NoidGameOver), 0);
		GrSetTextColor(mgstate, CF_INDEX, C_WHITE, 0, 0);
		GrDrawText(mgstate, 112, 112, LMemDeref(@NoidGameOver), 0);
		MemUnlock(OptrToHandle(@NoidGameOver));
	} else if(paused) {
		GrSetTextColor(mgstate, CF_INDEX, C_BLACK, 0, 0);
		GrSetFont(mgstate, FID_DTC_URW_ROMAN, MakeWWFixed(36));
		MemLock(OptrToHandle(@NoidPaused));
		GrDrawText(mgstate, 115, 115, LMemDeref(@NoidPaused), 0);
		GrSetTextColor(mgstate, CF_INDEX, C_WHITE, 0, 0);
		GrDrawText(mgstate, 112, 112, LMemDeref(@NoidPaused), 0);
		MemUnlock(OptrToHandle(@NoidPaused));
	}
}
/*-------------------------------------------------------------------------*/
void NoidPlaySound(MemHandle soundHandle)
{
  word 		tempo = 8;

     SoundStopMusicNote(hit);
     SoundStopMusicNote(goal);
     SoundStopMusicNote(lasershot);
     SoundStopMusicNote(gegnerhit);
     SoundStopMusicNote(blockhit);
     SoundStopMusic(winSound);
//     SoundStopMusic(loseSound);

  if (sound == SOUND_SYSTEM) {
    UserStandardSound(SST_CUSTOM_SOUND, soundHandle, 1);
  } else {
    if (sound == SOUND_OFF) {
      return;
    } else {
      SoundPlayMusic(soundHandle, SP_GAME, tempo, EOSF_UNLOCK);
	}
  }
}
/*-------------------------------------------------------------------------*/
@method NoidProcessClass, MSG_META_EXPOSED
{
    GrBeginUpdate(myGstate);
    NoidDraw(myGstate);
    GrEndUpdate(myGstate);
}
/*-------------------------------------------------------------------------*/
@method NoidProcessClass, MSG_META_KBD_CHAR
{ byte myscancode=state>>8;
  static byte beschleunigung;

  if (flags & CF_FIRST_PRESS)
  { beschleunigung=0;
     if ((myscancode==0x1d) || (myscancode==0x77)) shot=TRUE;
  }

  if (flags & CF_REPEAT_PRESS)
    if (beschleunigung<=150) beschleunigung+=batAccel;

  if (myscancode==0x48) batUp(beschleunigung);
  if (myscancode==0x50) batDown(beschleunigung);
  if (myscancode==0x4b) batLeft();
  if (myscancode==0x4d) batRight();
}
/*-------------------------------------------------------------------------*/
@method NoidProcessClass, MSG_META_CONTENT_VIEW_WIN_OPENED
{
   winHan = viewWindow;
   myGstate = GrCreateState(winHan);
}
/*-------------------------------------------------------------------------*/
@method NoidProcessClass, MSG_REDRAW_GAMEBOARD
{
    if (myGstate) GrInvalRect(myGstate, 0, 0, maxX, maxY);
}
/*-------------------------------------------------------------------------*/
@method NoidProcessClass, MSG_NOID_PAUSE
{
    if (!(paused)) {
    	@call NoidPauseTrigger::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
   		@call NoidContTrigger::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
		@call NoidOptionsSpeedList::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);

		@call self::MSG_STOP_TIMER();

		paused = TRUE;
	}

	@call self::MSG_REDRAW_GAMEBOARD();
}
/*-------------------------------------------------------------------------*/
@method NoidProcessClass, MSG_NOID_NEW_GAME
{
	FileHandle		fHandle;
	word			x, y;

	@call process::MSG_STOP_TIMER();
	leben = 3;
	punkte = 0;
	levelnr = 1;
	schuesse=0;
	batY=10; batX=leftPos;
	balls[0].activated=TRUE;
	balls[0].ballX=100; balls[0].ballY=150;
	balls[0].ballSpeed=1;
	balls[0].dirX=2; balls[0].dirY=2;
	balls[1].activated=FALSE;
	balls[1].ballSpeed=1;
	balls[2].activated=FALSE;
	balls[2].ballSpeed=1;
	laenge=startSize;
	gDir=1; gPosX=140; gPosY=maxY/2;

	/* load level file */
	FilePushDir();
	FileSetCurrentPath(SP_USER_DATA,"GeoNoid");
	fHandle = FileOpen("GeoNoidLevel.dat", (FILE_ACCESS_RW | FILE_DENY_RW));
	if (fHandle)
	{ FilePos(fHandle,0,FILE_POS_START);
	  maxLevel=(byte)(FilePos(fHandle,0,FILE_POS_END)/132);/*je 132 Steine*/
	  FilePos(fHandle,0,FILE_POS_START);
	  for (x=0; x<=11; x++)
	    for (y=0; y<=10; y++)
	       FileRead(fHandle,&level[x+y*12],1,FALSE);
	    FileClose(fHandle,FALSE);
	}else{
	  maxLevel=1;
	  fHandle = FileCreate("GeoNoidLevel.dat", ((FILE_ACCESS_RW | FILE_DENY_RW) | FILE_CREATE_ONLY),0);
	  for (x=0; x<=11; x++)
	    for (y=0; y<=10; y++)
	    { level[x+y*12] = x;
	      FileWrite(fHandle, &level[x+y*12], 1, FALSE);
	    }
	  FileClose(fHandle, FALSE);
	}
    FilePopDir();

    @call NoidPauseTrigger::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
    @call NoidContTrigger::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
	@call NoidOptionsSpeedList::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);

    @call NoidScoreValue::MSG_GEN_VALUE_SET_INTEGER_VALUE(punkte, FALSE);
    @call NoidLiveValue::MSG_GEN_VALUE_SET_INTEGER_VALUE(leben, FALSE);
    @call NoidLevelValue::MSG_GEN_VALUE_SET_INTEGER_VALUE(levelnr, FALSE);

	@call process::MSG_REDRAW_GAMEBOARD();
	@call process::MSG_START_TIMER();
    @call process::MSG_START_BALLTIMER();

    gAktiv=TRUE;
	paused = FALSE;
	gameEnd = FALSE;
}
/*-------------------------------------------------------------------------*/
@method NoidProcessClass, MSG_NOID_CONTINUE
{
	if (paused) {
    	gAktiv=TRUE;
		paused = FALSE;

		@call NoidPauseTrigger::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
    	@call NoidContTrigger::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
		@call process::MSG_START_TIMER();
	}

	@call process::MSG_REDRAW_GAMEBOARD();
}
/*-------------------------------------------------------------------------*/
@method NoidProcessClass, MSG_META_COLORED_OBJECT_SET_COLOR
{
    color = colorQuad;
    @call NoidViewOwner::MSG_GEN_VIEW_SET_COLOR(color.CQ_redOrIndex,
 	                           color.CQ_info, (color.CQ_green<<8) | color.CQ_blue);
    if (myGstate) GrInvalRect(myGstate, 0, 0, maxX, maxY);
}
/*-------------------------------------------------------------------------*/
@method NoidProcessClass, MSG_GEN_PROCESS_OPEN_APPLICATION
{
    FileHandle	fHandle;
    Boolean		initError, tips;
    word		x, y;

	@callsuper() ;

	@call NoidApp::MSG_GEN_APPLICATION_INSTALL_TOKEN();

	/* check for quick tips */
	initError = InitFileReadBoolean("GeoNoid", "showTips", &tips);
	if (initError) tips = TRUE;
	if (tips) {
		 @send ShowOnStartupGroup::MSG_GEN_BOOLEAN_GROUP_SET_BOOLEAN_STATE(
														 SHOW_ON_STARTUP, TRUE);
		 @send QTipsDialogBox::MSG_GEN_INTERACTION_INITIATE();
	 } else
		 @send ShowOnStartupGroup::MSG_GEN_BOOLEAN_GROUP_SET_BOOLEAN_STATE(
														 SHOW_ON_STARTUP, FALSE);

	FilePushDir() ;
    FileSetCurrentPath(noid_drive, noid_relativePath) ;
    FileCreateDir(noid_path) ;
    FileSetCurrentPath(noid_drive, noid_path) ;
    fHandle = FileOpen(noid_state_file, FILE_ACCESS_R|FILE_DENY_W) ;

    if (fHandle!=NullHandle) {
      FileRead(fHandle,&batSpeed, sizeof(batSpeed),FALSE);
	  FileRead(fHandle,&batAccel, sizeof(batAccel),FALSE);
	  FileRead(fHandle,&gameSpeed, sizeof(gameSpeed),FALSE);
	  FileRead(fHandle,&sound, sizeof(sound), FALSE);
	  FileRead(fHandle,&color, sizeof(color), FALSE);
 	  FileClose(fHandle,FALSE);
    }
    FilePopDir() ;

	@call NoidPaddleOptionsSpeedValue::MSG_GEN_VALUE_SET_INTEGER_VALUE(batSpeed,FALSE);
	@call NoidPaddleOptionsAccelValue::MSG_GEN_VALUE_SET_INTEGER_VALUE(batAccel,FALSE);
	@call NoidOptionsSpeedList::MSG_GEN_ITEM_GROUP_SET_SINGLE_SELECTION(gameSpeed, FALSE);
	@call NoidOptionsSoundList::MSG_GEN_ITEM_GROUP_SET_SINGLE_SELECTION(sound, FALSE);
	@send NoidColorControl::MSG_COLOR_SELECTOR_SET_COLOR(color, FALSE);

	@send NoidColorControl::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_UI_QUEUE);

	/* load level file */
	FilePushDir();
	FileSetCurrentPath(SP_USER_DATA,"GeoNoid");
	fHandle = FileOpen("GeoNoidLevel.dat", (FILE_ACCESS_RW | FILE_DENY_RW));
	if (fHandle)
	{ FilePos(fHandle,0,FILE_POS_START);
	  maxLevel=(byte)(FilePos(fHandle,0,FILE_POS_END)/132);/*je 132 Steine*/
	  FilePos(fHandle,0,FILE_POS_START);
	  for (x=0; x<=11; x++)
	    for (y=0; y<=10; y++)
	       FileRead(fHandle,&level[x+y*12],1,FALSE);
	    FileClose(fHandle,FALSE);
	}else{
	  maxLevel=1;
	  fHandle = FileCreate("GeoNoidLevel.dat", ((FILE_ACCESS_RW | FILE_DENY_RW) | FILE_CREATE_ONLY),0);
	  for (x=0; x<=11; x++)
	    for (y=0; y<=10; y++)
	    { level[x+y*12] = x;
	      FileWrite(fHandle, &level[x+y*12], 1, FALSE);
	    }
	  FileClose(fHandle, FALSE);
	  /* maxLevel = 132; */
    }
    FilePopDir();

	SoundAllocMusicNote (IP_ACOUSTIC_GRAND_PIANO, 0, HIGH_A,
		    DYNAMIC_FFFF, SSDTT_TEMPO, WHOLE, &hit);
	SoundAllocMusicNote (IP_ACOUSTIC_GRAND_PIANO, 0, LOW_C,
		    DYNAMIC_FFFF, SSDTT_TEMPO, WHOLE, &goal);
	SoundAllocMusicNote (IP_FX_SCI_FI, 0, HIGH_C,
		    DYNAMIC_FFFF, SSDTT_TEMPO, SIXTEENTH, &lasershot);
	SoundAllocMusicNote (IP_CRASH_CYMBAL_1,0, FR_CRASH_CYMBAL_1,
		    DYNAMIC_FFFF, SSDTT_TEMPO, SIXTEENTH, &blockhit);
	SoundAllocMusicNote (IP_GUNSHOT,0, MIDDLE_C,
		    DYNAMIC_FFFF, SSDTT_TEMPO, QUARTER, &gegnerhit);

	 SoundAllocMusic(winSoundBuf, 1, &winSound);
//	 SoundAllocMusic(loseSoundBuf, 1, &loseSound);

	@send process::MSG_REDRAW_GAMEBOARD();
}
/*-------------------------------------------------------------------------*/
@method NoidProcessClass, MSG_GEN_PROCESS_CLOSE_APPLICATION
{
	FileHandle	fHandle ;
	Boolean	  	tips;

    @call self::MSG_NOID_PAUSE();

    FilePushDir() ;
    FileSetCurrentPath(noid_drive, noid_relativePath) ;
    FileCreateDir(noid_path) ;
    FileSetCurrentPath(noid_drive, noid_path) ;
    FileDelete(noid_state_file) ;

    fHandle = FileCreate(noid_state_file,
              FILE_CREATE_TRUNCATE |
              FILE_ACCESS_RW |
              FILE_DENY_NONE,
              FILE_ATTR_NORMAL) ;

    if (fHandle!=NullHandle)  {
	  FileWrite(fHandle,&batSpeed, sizeof(batSpeed),FALSE);
	  FileWrite(fHandle,&batAccel, sizeof(batAccel),FALSE);
	  FileWrite(fHandle,&gameSpeed, sizeof(gameSpeed),FALSE);
 	  FileWrite(fHandle,&sound, sizeof(sound), FALSE);
 	  FileWrite(fHandle,&color, sizeof(color), FALSE);
 	  FileClose(fHandle,FALSE);
    }
    FilePopDir();

    /* set the quick tips if not default */
	tips = @call ShowOnStartupGroup::MSG_GEN_BOOLEAN_GROUP_IS_BOOLEAN_SELECTED(SHOW_ON_STARTUP);
	InitFileWriteBoolean("GeoNoid", "showTips", tips);

    if (myGstate) GrDestroyState(myGstate);

   if(HTimer) {
      TimerStop (HTimer, timerid);
      HTimer = NullHandle;
   }
   if(HBTimer) {
      TimerStop (HBTimer, bTimerid);
      HBTimer = NullHandle;
   }
   if(HGTimer) {
      TimerStop (HGTimer, gTimerid);
      HGTimer = NullHandle;
   }

   /* Sound handles may be zero if no sound driver has been loaded */
   if (hit) {
	SoundStopMusicNote(hit);
	SoundFreeMusicNote(hit);
	}
   if (goal) {
	SoundStopMusicNote(goal);
	SoundFreeMusicNote(goal);
	}
   if (lasershot) {
	SoundStopMusicNote(lasershot);
	SoundFreeMusicNote(lasershot);
	}
   if (gegnerhit) {
	SoundStopMusicNote(gegnerhit);
	SoundFreeMusicNote(gegnerhit);
	}
   if (blockhit) {
	SoundStopMusicNote(blockhit);
	SoundFreeMusicNote(blockhit);
	}
   if (winSound) {
	SoundStopMusic(winSound);
	SoundFreeMusic(winSound);
	}
//   SoundStopMusic(loseSound);
//   SoundFreeMusic(loseSound);

   return(@callsuper());
}
/*-------------------------------------------------------------------------*/
@method NoidProcessClass, MSG_NOID_PADDLE_OPTIONS
{

	/* instead of pausing (which causes a restart on continue even if
	 * there was no game going) just stop the action */
	if (HTimer) {
		g_optsStopped = TRUE;
		@call self::MSG_STOP_TIMER();
		}
//	@call process::MSG_NOID_PAUSE();
	@call NoidPaddleOptions::MSG_GEN_INTERACTION_INITIATE();
}
/*-------------------------------------------------------------------------*/
@method NoidProcessClass, MSG_NOID_NEW_PADDLE_OPTIONS
{
    word	answer;

    answer = UserStandardDialogOptr(
                NullOptr,
                NullOptr,
                NullOptr,
                NullOptr,
		        @NoidNewGameMsg,
		        (CDT_QUESTION << CDBF_DIALOG_TYPE_OFFSET) |
		        (GIT_AFFIRMATION << CDBF_INTERACTION_TYPE_OFFSET));

    if(answer == IC_YES)
    {
        batSpeed = @call NoidPaddleOptionsSpeedValue::MSG_GEN_VALUE_GET_INTEGER_VALUE();
        batAccel = @call NoidPaddleOptionsAccelValue::MSG_GEN_VALUE_GET_INTEGER_VALUE();
		  g_optsStopped = FALSE;
		  @call self::MSG_NOID_NEW_GAME();
    }else{
 /*       @call NoidPaddleOptionsSpeedValue::MSG_GEN_VALUE_SET_INTEGER_VALUE(batSpeed, FALSE);
        @call NoidPaddleOptionsAccelValue::MSG_GEN_VALUE_SET_INTEGER_VALUE(batAccel, FALSE);
		  @call self::MSG_NOID_CONTINUE();
 */
		  @call self::MSG_NOID_CANCEL_PADDLE_OPTIONS();
	 }
}
/*-------------------------------------------------------------------------*/
@method NoidProcessClass, MSG_NOID_CANCEL_PADDLE_OPTIONS
{
	@call NoidPaddleOptionsSpeedValue::MSG_GEN_VALUE_SET_INTEGER_VALUE(batSpeed, FALSE);
    @call NoidPaddleOptionsAccelValue::MSG_GEN_VALUE_SET_INTEGER_VALUE(batAccel, FALSE);
//	@call self::MSG_NOID_CONTINUE();
	 if (g_optsStopped) {
		g_optsStopped = FALSE;
		@call process::MSG_START_TIMER();
      }
}
/*-------------------------------------------------------------------------*/
@method NoidProcessClass, MSG_NOID_GAME_END
{
	/* this required the player to advance to level 2 before even being
	 * considered for the hi score list.  Changed to more conventional
	 * ending - jfh
	if((levelnr == maxLevel) && (anzahlSteine == 0)){
		NoidPlaySound(winSound);
		UserDoDialog(@NoidGameSolveBox);
		@send NoidHighScore::MSG_HIGH_SCORE_ADD_SCORE((dword) punkte, 0);
	}else if(levelnr > 1) {
		NoidPlaySound(winSound);
		UserDoDialog(@NoidGameWinBox);
		@send NoidHighScore::MSG_HIGH_SCORE_ADD_SCORE((dword) punkte, 0);
	}else{
		NoidPlaySound(loseSound);
		UserDoDialog(@NoidGameLoseBox);
	}
	*/

	/* show special dialog after completing all levels */
	if((levelnr == maxLevel) && (anzahlSteine == 0)){
		NoidPlaySound(winSound);
		UserDoDialog(@NoidGameSolveBox);
		}
   /* and check for hi score eligibility */
	@send NoidHighScore::MSG_HIGH_SCORE_ADD_SCORE((dword) punkte, 0);

	leben = 3;
	punkte = 0;
	levelnr = 1;
	schuesse=0;
	paused = TRUE;
	batY=10; batX=leftPos;
	balls[0].activated=TRUE;
	balls[0].ballX=100; balls[0].ballY=150;
	balls[0].ballSpeed=1;
	balls[0].dirX=2; balls[0].dirY=2;
	balls[1].activated=FALSE;
	balls[1].ballSpeed=1;
	balls[2].activated=FALSE;
	balls[2].ballSpeed=1;
	laenge=startSize;
	gDir=1; gPosX=140; gPosY=maxY/2;

	gameEnd = TRUE;
}
/*-------------------------------------------------------------------------*/
@method NoidProcessClass, MSG_NOID_SOUND_CHOICE_CHANGED
{
	sound = selection;
}
/*-------------------------------------------------------------------------*/
@method NoidProcessClass, MSG_NOID_COLOR_CHOICE_CHANGED
{
    @send NoidColorControl::MSG_COLOR_SELECTOR_SET_COLOR(color, FALSE) ;
}
/*-------------------------------------------------------------------------*/
@method NoidProcessClass, MSG_NOID_SPEED_CHOICE_CHANGED
{
	gameSpeed = selection;
}
/*-------------------------------------------------------------------------*/
@method NoidProcessClass, MSG_START_TIMER
{
   if (!HTimer) {
	  HTimer=TimerStart(TIMER_EVENT_CONTINUAL, oself, 10,
		       MSG_TIMER_RANG, gameSpeed, &timerid);
   }
}
/*-------------------------------------------------------------------------*/
@method NoidProcessClass, MSG_STOP_TIMER
{
   if(HTimer)
   {
      TimerStop (HTimer, timerid);
      HTimer = NullHandle;
   }
}
/*-------------------------------------------------------------------------*/
@method NoidProcessClass, MSG_START_BALLTIMER
{
   if (!HBTimer)
   { HBTimer=TimerStart(TIMER_EVENT_ONE_SHOT, oself, 100,
     MSG_STOP_BALLTIMER, 1, &bTimerid);
     ball_not_locked=FALSE;
   }
}
/*-------------------------------------------------------------------------*/
@method NoidProcessClass, MSG_STOP_BALLTIMER
{  ball_not_locked=TRUE;
   if(HBTimer)
   {
      TimerStop (HBTimer, bTimerid);
      HBTimer = NullHandle;
   }
}
/*-------------------------------------------------------------------------*/
@method NoidProcessClass, MSG_START_GEGNERTIMER
{
   if (!HGTimer)
     HGTimer=TimerStart(TIMER_EVENT_ONE_SHOT, oself, 300,
	     MSG_STOP_GEGNERTIMER, 1, &gTimerid);
}
/*-------------------------------------------------------------------------*/
@method NoidProcessClass, MSG_STOP_GEGNERTIMER
{  gAktiv=TRUE;
   if(HGTimer)
   {
      TimerStop (HGTimer, gTimerid);
      HGTimer = NullHandle;
   }
}
/*-------------------------------------------------------------------------*/
@method NoidProcessClass, MSG_TIMER_RANG
{
  byte x,y;                  /*Zaehler fuer Level=>Stein*/
  word blockX,blockY;        /*Pos. eines Steines in dem der Ball ist*/
  FileHandle levelf;         /*Zum Levelnachladen*/
  static Boolean ballFix[3]={FALSE,FALSE,FALSE};    /*Falls Multiball ausging*/
  static byte redrawFix[3]={0,0,0};     /*Falls Ball in unkaputtbarem Block*/
  static byte unkaputtFix[3]={0,0,0};   /*Falls Ball zw. unkaputtbaren Bloecken haengt*/
  Boolean toOldPosFix=FALSE;
  int ballX,ballY,dirX,dirY,ballSpeed; /*Fuer Baelle*/
  int oldX, oldY; /*" "*/
  byte i,i2;      /*" "*/
  static int startX;
  static int zielX;
  static int zielY;
  byte geraeusch=0;
  static Boolean lastShot=FALSE;

	/*Gegner*/
	if (!paused) animGegner(myGstate);

	for (i=0; i<3; i++)
		if (balls[i].activated) {
			/* move ball (part1) */
			ballX=balls[i].ballX;
			ballY=balls[i].ballY;
			dirX=balls[i].dirX;
			dirY=balls[i].dirY;
			ballSpeed=balls[i].ballSpeed;
			oldX=ballX;
			oldY=ballY;
			if (!paused) {
				if (ball_not_locked) {
					ballX += (dirX*ballSpeed);
					ballY += (dirY*ballSpeed);
				} else {
					ballX = batX + 6; ballY = batY;
				}
 			}

			/* check for goals */
			if (((ballX<=6) && (dirX<0)) && (ball_not_locked)) {
				balls[i].activated = FALSE;
				ballFix[i]=TRUE;
				if (((!balls[0].activated) && (!balls[1].activated)) && (!balls[2].activated)) {
					balls[0].activated=TRUE;
					@call NoidLiveValue::MSG_GEN_VALUE_SET_INTEGER_VALUE(--leben,FALSE);
					balls[0].ballX=batX+6;
					balls[0].ballSpeed = 1;
					balls[0].dirX = GameRandom(2) + 1;
					balls[0].dirY=2;/*reflect y*/
					laenge=startSize;
					@call self::MSG_REDRAW_GAMEBOARD();
					/* ^ Noetig, da Ball evtl. im Schlaeger war ^ */
					NoidPlaySound(goal);
					@call self::MSG_START_BALLTIMER();
					unkaputtFix[0]=0;
					unkaputtFix[1]=0;
					unkaputtFix[2]=0;
					continue; /*Abbruch der Fuer-Alle-Baelle-Schleife*/
				}/*if alle deaktiviert*/
			}

			/* check for bats */
			if (((ballX<=batX+11) && (ballX>=batX)) && (ball_not_locked))
				if ((ballY+6>batY) && (ballY<batY+laenge)) {
					dirX = GameRandom(2) + 1;
					if (dirY>0) dirY = GameRandom(2) + 1;
					else        dirY = -(GameRandom(2) + 1);
					if (ballX<=batX+7) ballX=batX+7;
					unkaputtFix[i]=0;
					if (myGstate) GrInvalRect(myGstate, leftPos, batY, rightPos+15, batY+laenge);
					/* ^ noetig, da Ball evtl. im Schlaeger war ^*/
				} /*<-Bat links*/

			/*check for right reflection */
			if (((ballX>=maxX-11) && (dirX>0)) && (ball_not_locked)) {
				dirX=-(GameRandom(2) + 1);
				if (dirY>0) dirY = GameRandom(2) + 1;
				else        dirY = -(GameRandom(2) + 1);
				ballX=maxX-11;
			}

			/* check for y-reflections */
			if ((ballY<=1) && (ball_not_locked)) {
				ballY=2;
				dirY=-dirY;
			} /*oben*/
			if ((ballY>=maxY-11) && (ball_not_locked)) {
				ballY=maxY-12;
				dirY=-dirY;/*reflect y*/
			} /*unten*/

			/* check for gegner */
			if ((ballX+10>=gPosX) && (ballX<=gPosX+40))
				if (((ballY+10>=gPosY) && (ballY<=gPosY+40)) && (gAktiv)) {
					dirX = -(GameRandom(2) + 1) + GameRandom(2) + 1;
					if (dirX==0) dirX=2;
					if (dirX>0) ballX=gPosX+41;
					else        ballX=gPosX-11;
				}/*if in Gegner*/

			/* check for blocks */
			if (((ballX+/*6*/ 10>=250) && (ballX<=404)) && (ball_not_locked))
				if ((ballY+/*6*/10>=15) && (ballY<=256)) {
					for (x=0;x<=11;x++)
						for (y=0;y<=10;y++) {
							blockX=250+x*13;
							blockY=15+y*22;
							if ((((ballX+/*5*/ 10>=blockX) && (ballX<=blockX+10)) &&
							     ((ballY+/*5*/ 10>=blockY) && (ballY<=blockY+20))) && (level[x+y*12]>0)) {
								punkte+=(word)level[x+y*12];
								if (level[x+y*12]==11) {
									level[x+y*12]=1;
									redrawFix[i]=2;
									unkaputtFix[i]=0;
								} else if (level[x+y*12]==7) { /*unkaputtbar*/
									redrawFix[i]=2;
									unkaputtFix[i]++;
									toOldPosFix=TRUE;
									/*nur Winkelaenderung - HIER keine Reflektion!*/
								} else { /*Steine, die verschwinden*/
									unkaputtFix[i]=0;
									switch (level[x+y*12]) {
										case 15:
											if (laenge<=maxY/2) laenge+=20;
											if (batY+laenge>maxY-2) batY=maxY-2-laenge;
											if (myGstate) GrInvalRect(myGstate,MAX(batX-1,0),
																MAX(batY-1,0),
																MIN(batX+6,maxX),
																MIN(batY+laenge+1,maxY));
			     						break;/*Vergroessern*/

										case 14:
											if (laenge>=startSize) laenge-=20;
											if (myGstate) GrInvalRect(myGstate,MAX(batX-1,0),
																MAX(batY-1,0),
																MIN(batX+6,maxX),
																MIN(batY+laenge+21,maxY));
										break;/*Verkleinern*/

										case 13:
											ballSpeed=1;
										break;/*Abbremsen*/

										case 12:
											schuesse+=5;
			              					if (myGstate) GrInvalRect(myGstate,MAX(batX-1,0),
																MAX(batY-1,0),
																MIN(batX+6,maxX),
																MIN(batY+laenge+21,maxY));
										break;/*Laser*/

										case 10:
											for (i2=0; i2<3;i2++)
											if (!balls[i2].activated) {
												balls[i2].activated=TRUE;
												balls[i2].ballX=ballX+1+i2;
												balls[i2].ballY=ballY-1-i2;
												balls[i2].dirX=i2+1;
												balls[i2].dirY=-i2-1;
												balls[i2].ballSpeed=1;
											}
										break;/*Multiball*/

										case 9:
											if (leben<9)
												@call NoidLiveValue::MSG_GEN_VALUE_SET_INTEGER_VALUE(++leben,FALSE);
										break;/*Neues Leben*/

										case 8:
											anzahlSteine=1; /*Da noch abgezogen wird*/
										break;/*Neuer Level*/
									}/*switch*/

									level[x+y*12]=0;
									anzahlSteine--;
								}
							if (ballSpeed<2) ballSpeed++;
							@call NoidScoreValue::MSG_GEN_VALUE_SET_INTEGER_VALUE(punkte, FALSE);
							if ((oldX+/*5*/ 10>=blockX) && (oldX<=blockX+10)) dirY=-dirY;
							else if ((oldY+/*5*/ 10>=blockY) && (oldY<=blockY+20)) dirX=-dirX;
		  				else {
							if (ABS(dirX)>ABS(dirY)) dirY=-dirY;
							else if (ABS(dirX)<ABS(dirY)) dirX=-dirX;
					else {
						if (dirX>0) dirX=-(GameRandom(2) + 1);
						else dirX = GameRandom(2) + 1;
						if (dirY>0) dirY=-(GameRandom(2) + 1);
						else dirY= GameRandom(2) + 1;
					}
				}
				if (toOldPosFix) {ballX=oldX;ballY=oldY;}
				if ((anzahlSteine) && (myGstate)) GrInvalRect(myGstate,blockX,blockY,MIN(blockX+10,maxX),MIN(blockY+20,maxY));
				NoidPlaySound(hit);
			}/*if Ball in Block*/
		}/*fuer alle Bloecke*/
	}/*If Ball in Blockgegend*/

  /* move ball (part2:finally visualize it) */
  if (unkaputtFix[i]>5)
  { ballX++; ballY++;
    if (dirX>0) dirX++;
    else dirX--;
    if (dirY>0) dirY++;
    else dirY--;
    ballSpeed++;
    unkaputtFix[i]=0;
  }
  GrBitBlt(myGstate, oldX, oldY, ballX, ballY, 10, 10, BLTM_MOVE);
  if (redrawFix[i])
     if (myGstate) GrInvalRect(myGstate,MAX(oldX-10,0),MAX(oldY-10,0),
				MIN(oldX+10,maxX),MIN(oldY+10,maxY));
  if (redrawFix[i]>0) redrawFix[i]--;
  if (ballFix[i])
  { ballFix[i]=FALSE;
    if (myGstate) GrInvalRect(myGstate,0,0,batX+10,maxY);
  };

  balls[i].ballX=ballX;
  balls[i].ballY=ballY;
  balls[i].dirX=dirX;
  balls[i].dirY=dirY;
  balls[i].ballSpeed=ballSpeed;
 }/*fuer alle Baelle*/


	/*Schuá*/
	if ((shot) && (schuesse<=0)) shot = FALSE;
	if (lastShot) {
		GrInvalRect(myGstate,startX,zielY,zielX,zielY);
		GrSetLineColor(myGstate, CF_INDEX, C_LIGHT_CYAN, 0, 0);
		GrDrawLine(myGstate,startX,zielY,zielX,zielY);
		lastShot = FALSE;
	}

	if ((!(paused)) && ((schuesse) && (shot))) {
		schuesse--;
		geraeusch = 1;
		zielY=batY+(laenge/2);
		if (myGstate) {
			if (schuesse==0) GrInvalRect(myGstate,batX,batY,batX+6,batY+laenge+1);
			if ((gAktiv) && ((zielY>=gPosY) && (zielY<=gPosY+40))) {
				gAktiv=FALSE;
				gegnerAnim=0;
				geraeusch=2;
				punkte+=25;
				@call NoidScoreValue::MSG_GEN_VALUE_SET_INTEGER_VALUE(punkte,FALSE);
				@call self::MSG_START_GEGNERTIMER();
			}

			if ((zielY>=15) && (zielY<=255)) {
				for (y=0; y<=10; y++)
					if ((zielY>=15+y*22) && (zielY<=35+y*22)) break;
					if (y<11)
						for (x=0; x<=11; x++)
							if (level[x+y*12]!=0) {
								level[x+y*12]=0;
								zielX=250+x*13;
								GrInvalRect(myGstate,250+x*13,15+y*22,260+x*13,35+y*22);
								break;
							}
			}

			GrSetLineColor(myGstate, CF_INDEX, C_WHITE, 0, 0);
			startX=batX+9;
			GrDrawLine(myGstate,startX,zielY,zielX,zielY);
			lastShot=TRUE;
		}

    	if (geraeusch == 1) NoidPlaySound(lasershot);
		if (geraeusch == 2) NoidPlaySound(gegnerhit);

	}
    shot=FALSE;
 /* }TEST Schuá-Ende*/

  /*end game*/
	if ((leben==0) || (anzahlSteine==0)) {
		@call self::MSG_STOP_TIMER();
		if (!gAktiv) @call self::MSG_STOP_GEGNERTIMER();
		if (leben==0) {
			@call NoidPauseTrigger::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
			@call NoidContTrigger::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
			@call NoidOptionsSpeedList::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);

			@call self::MSG_REDRAW_GAMEBOARD();
			@call process::MSG_NOID_GAME_END();

		} else {
			@call NoidLevelValue::MSG_GEN_VALUE_SET_INTEGER_VALUE(++levelnr,FALSE);
			if (levelnr>maxLevel) {
				@call NoidPauseTrigger::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
				@call NoidContTrigger::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
				@call NoidOptionsSpeedList::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);

				@call self::MSG_REDRAW_GAMEBOARD();
				@call self::MSG_NOID_GAME_END();
			} else {
				balls[0].ballSpeed=1;
				balls[0].ballX=100; balls[0].ballY=150;
				balls[0].dirX=2; balls[0].dirY=2;
				balls[0].activated=TRUE;
				balls[1].activated=FALSE;
				balls[2].activated=FALSE;
				gAktiv=TRUE;
				schuesse=0;
				for (x=0; x<=11; x++)
					for (y=0; y<=10; y++)
						level[x+y*12]=x;

				FilePushDir();
				FileSetCurrentPath(SP_USER_DATA,"GeoNoid");
				levelf=FileOpen("GeoNoidLevel.dat", (FILE_ACCESS_RW | FILE_DENY_RW));
				if (levelf) {
					FilePos(levelf, (levelnr-1)*132, FILE_POS_START);
					for (x=0; x<=11; x++)
						for (y=0; y<=10; y++)
							FileRead(levelf,&level[x+y*12],1,FALSE);
							FileClose(levelf,FALSE);
				} else {
					UserStandardDialogOptr(NULL, NULL, NULL, NULL,
			                   @NoidFileError,
			                   ((GIT_AFFIRMATION << CDBF_INTERACTION_TYPE_OFFSET) |
			                    (CDT_ERROR << CDBF_DIALOG_TYPE_OFFSET)));

				}
				FilePopDir();

				@call self::MSG_REDRAW_GAMEBOARD();
				@call self::MSG_START_TIMER();
				@call self::MSG_START_BALLTIMER();
			}/*next level*/
		}
	}/*Gewonnen oder verloren*/
}
