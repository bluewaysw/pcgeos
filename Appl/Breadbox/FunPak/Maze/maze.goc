/***************************************************************************
 *                                                                         *
 *  MAZE                                                                   *
 *                                                                         *
 *  REVISION HISTORY:                                                      *										
 * 	Name    Date            Description                                *
 * 	----    ----            -----------                                *
 * 			        Initial version.                           *
 * 	RainerB 01/20/2024	Updated for Free PC/GEOS 6                 *
 *                                                                         *
 ***************************************************************************/


/***************************************************************************
 *		Include files
 ***************************************************************************/

@include <stdapp.goh>
@include <Objects/gViewCC.goh>
#include <gstring.h>
@include <spool.goh>
@include <Objects/clipbrd.goh>
#include <Ansi/string.h>
#include <Ansi/stdio.h>
@include <Objects/colorC.goh>
@include "icons.goh"
#include <initfile.h>
@include <game.goh>
#include <sound.h>
#include <stdlib.h>

#define MAZE_BIT_ONCE      0x01
#define MAZE_BIT_TWICE     0x02
#define MAZE_BIT_TRAVELED  0x04
#define MAZE_BIT_SOL_ONCE  0x08
#define MAZE_BIT_SOL_TWICE 0x10

#define MAZE_COLOR_BACKGROUND       0
#define MAZE_COLOR_WALLS            1
#define MAZE_COLOR_TRAIL            2
#define MAZE_COLOR_SOLUTION         3
#define MAZE_COLOR_PLAYER_PIECE     4

/* The size of the maze. Be careful, a fixed block of MAZE_BUFFER_SIZE will be allocated */
/* In a further version, it should be moved into a movable block. */
#define INITIAL_SIZE 18
#define MINIMUM_SIZE 5

#define MAX_SIZE_X		70
#define MAX_SIZE_Y		50
#define MAZE_BUFFER_SIZE	( 4*(MAX_SIZE_X)*(MAX_SIZE_Y) )		/* about 14 kB */

#define STATE_FILE_MAGIC	(dword)( ((dword)'M' << 0) | ((dword)'S' << 8) | ((dword)'F' << 16) | ((dword)(01) << 24) )

#define DOC_WIDTH             ((INITIAL_SIZE)*12)
#define DOC_HEIGHT            DOC_WIDTH

#define SHOW_ON_STARTUP   1

#define quick_maze(posx, posy)  ((posx)+((posy)*(size_x)))

#define SOUND_ON 1
#define SOUND_OFF 2
#define SOUND_SYSTEM 3

const word winSoundBuf[] = {     /* from blackjack win sound */
	SSE_CHANGE,             0, IP_ACOUSTIC_GRAND_PIANO, IT_STANDARD_TABLE,
	SSDTT_TICKS,            0,
	SSE_VOICE_ON,           0, MIDDLE_C, DYNAMIC_F,
	SSDTT_TICKS,            10,
	SSE_VOICE_OFF,          0,
	SSDTT_TICKS,            0,
	SSE_VOICE_ON,           0, MIDDLE_E, DYNAMIC_F,
	SSDTT_TICKS,            10,
	SSE_VOICE_OFF,          0,
	SSDTT_TICKS,            0,
	SSE_VOICE_ON,           0, MIDDLE_G, DYNAMIC_F,
	SSDTT_TICKS,            10,
	SSE_VOICE_OFF,          0,
	SSDTT_TICKS,            0,
	SSE_VOICE_ON,           0, HIGH_C, DYNAMIC_F,
	SSDTT_TICKS,            15,
	SSE_VOICE_OFF,          0,
	SSDTT_TICKS,            0,
	SSE_VOICE_ON,           0, MIDDLE_G, DYNAMIC_F,
	SSDTT_TICKS,            8,
	SSE_VOICE_OFF,          0,
	SSDTT_TICKS,            0,
	SSE_VOICE_ON,           0, HIGH_C, DYNAMIC_F,
	SSDTT_TICKS,            25,
	SSE_VOICE_OFF,          0,
	SSDTT_TICKS,            0,
	SSE_GENERAL,            GE_END_OF_SONG};

const word loseSoundBuf[] = {     /* from blackjack lose sound */
	SSE_CHANGE,             0, IP_ACOUSTIC_GRAND_PIANO, IT_STANDARD_TABLE,
	SSDTT_TICKS,            0,
	SSE_VOICE_ON,           0, LOW_D, DYNAMIC_F,
	SSDTT_TICKS,            20,
	SSE_VOICE_OFF,          0,
	SSDTT_TICKS,            1,
	SSE_VOICE_ON,           0, LOW_D, DYNAMIC_F,
	SSDTT_TICKS,            20,
	SSE_VOICE_OFF,          0,
	SSDTT_TICKS,            1,
	SSE_VOICE_ON,           0, LOW_D, DYNAMIC_F,
	SSDTT_TICKS,            7,
	SSE_VOICE_OFF,          0,
	SSDTT_TICKS,            1,
	SSE_VOICE_ON,           0, LOW_D, DYNAMIC_F,
	SSDTT_TICKS,            20,
	SSE_VOICE_OFF,          0,
	SSDTT_TICKS,            0,
	SSE_VOICE_ON,           0, LOW_F, DYNAMIC_F,
	SSDTT_TICKS,            20,
	SSE_VOICE_OFF,          0,
	SSDTT_TICKS,            0,
	SSE_VOICE_ON,           0, LOW_E, DYNAMIC_F,
	SSDTT_TICKS,            7,
	SSE_VOICE_OFF,          0,
	SSDTT_TICKS,            1,
	SSE_VOICE_ON,           0, LOW_E, DYNAMIC_F,
	SSDTT_TICKS,            20,
	SSE_VOICE_OFF,          0,
	SSDTT_TICKS,            0,
	SSE_VOICE_ON,           0, LOW_D, DYNAMIC_F,
	SSDTT_TICKS,            7,
	SSE_VOICE_OFF,          0,
	SSDTT_TICKS,            1,
	SSE_VOICE_ON,           0, LOW_D, DYNAMIC_F,
	SSDTT_TICKS,            20,
	SSE_VOICE_OFF,          0,
	SSDTT_TICKS,            0,
	SSE_VOICE_ON,           0, LOW_D_b, DYNAMIC_F,
	SSDTT_TICKS,            7,
	SSE_VOICE_OFF,          0,
	SSDTT_TICKS,            0,
	SSE_VOICE_ON,           0, LOW_D, DYNAMIC_F,
	SSDTT_TICKS,            20,
	SSE_VOICE_OFF,          0,
	SSDTT_TICKS,            0,
	SSE_GENERAL,            GE_END_OF_SONG};

MemHandle	winSound, loseSound;
word	g_sound;

byte *maze;	/* a fixed buffer of MAZE_BUFFER_SIZE bytes */
word size_x = (INITIAL_SIZE*2)-1 ;
word size_y = (INITIAL_SIZE*2)-1 ;
word pos_start = 0 ;
word draw_mode = 0 ;
sword pos_x = 1000 ;
sword pos_y = 1000 ;
byte game_mode = 0 ;
byte time_sec = 0 ;
byte time_min = 0 ;
byte time_hour = 0 ;
word timer_id = 0;
word timer_handle = NullHandle;
Boolean timer_going = FALSE ;
Boolean solved = FALSE ;
Boolean gray_screen = FALSE ;
word player_score         = 1 ;

char maze_state_file[25] = "Maze Runner State" ;

char maze_path[20] = "Game" ;
char maze_relativePath[] = "." ;
word maze_drive = SP_PUBLIC_DATA ;

int color_choice = MAZE_COLOR_BACKGROUND ;

ColorQuad colors[5] = { {C_WHITE,CF_INDEX,0,0},
								{C_BLACK,CF_INDEX,0,0},
								{C_RED,CF_INDEX,0,0},
								{C_BLACK,CF_INDEX,0,0},
								{C_RED,CF_INDEX,0,0} } ;

word ClearPlayerTrail(void) ;
void SolveMaze(void) ;
void MazeDraw1(GStateHandle gstate,
              RectDWord *rect) ;
void MazeDraw2(GStateHandle gstate,
              RectDWord *rect) ;

/***************************************************************************
 *		Class & Message Definitions
 ***************************************************************************/

    /*---------------------------------------------------------------------*/
    @class MazeProcessClass, GenProcessClass ;
        @message void MSG_VIEW_INVALIDATE() ;
        @message void MSG_VIEW_MAZE_NEW() ;
        @message void MSG_VIEW_MAZE_NEW_AND_PLAY(Boolean playOnly) ;
        @message void MSG_MAZE_VIEW_MODE_1() ;
        @message void MSG_MAZE_VIEW_MODE_2() ;
        @message void MSG_MAZE_SIZE_CHANGED() ;
        @message void MSG_MAZE_MOVE_UP() ;
        @message void MSG_MAZE_MOVE_DOWN() ;
        @message void MSG_MAZE_MOVE_LEFT() ;
        @message void MSG_MAZE_MOVE_RIGHT() ;
        @message void MSG_MAZE_PLAY_GAME() ;
        @message void MSG_MAZE_MOVE_REDRAW_AROUND() ;
        @message void MSG_MAZE_COMPLETED() ;
        @message void MSG_MAZE_COMPLETED2() ;
        @message void MSG_MAZE_CHECK_POSITION() ;
        @message void MSG_MAZE_SOLVE() ;
		  @message void MSG_MAZE_UPDATE_SCORE() ;
		  @message (GEN_ITEM_GROUP_APPLY_MSG) MSG_PROCESS_COLOR_CHOICE_CHANGED;
		  @message (GEN_ITEM_GROUP_APPLY_MSG) MSG_MAZE_SOUND_CHANGED;
		  @message void MSG_MAZE_PAUSE();
		  @message void MSG_MAZE_CONT();
    @endc

    @classdecl MazeProcessClass, neverSaved ;
    /*---------------------------------------------------------------------*/

	 /*---------------------------------------------------------------------*/
    @class MazeTimerClass, GenGlyphClass ;
        @message void MSG_MAZE_CHANGE_TIME() ;
        @message void MSG_MAZE_RESET_TIMER() ;
        @message void MSG_MAZE_TIMER_CHANGE() ;
    @endc

    @classdecl MazeTimerClass;
    /*---------------------------------------------------------------------*/

	 /*---------------------------------------------------------------------*/
    @class MazeViewClass, GenViewClass ;
    @endc

    @classdecl MazeViewClass;
    /*---------------------------------------------------------------------*/

	 /*---------------------------------------------------------------------*/
    @class MazeContentClass, VisContentClass ;
    @endc

    @classdecl MazeContentClass ;
    /*---------------------------------------------------------------------*/

	 /*---------------------------------------------------------------------*/
    @class MazeAppClass, GenApplicationClass ;
    @endc

    @classdecl MazeAppClass ;
    /*---------------------------------------------------------------------*/

	 /*---------------------------------------------------------------------*/
    @class MazePauseInterClass, GenInteractionClass ;
    @endc

    @classdecl MazePauseInterClass ;
    /*---------------------------------------------------------------------*/


/***************************************************************************
 *		UI Objects
 ***************************************************************************/

/*=========================================================================*/

@start Mouse_Picture, data ;
@include "Mouse.goh"
@end Mouse_Picture

@start	AppResource ;
    /*---------------------------------------------------------------------*/
    @object MazeAppClass MazeApp = {
        GI_visMoniker = list { @MazeTextMoniker,
                               @Moniker0,
						 @Moniker1,
						 @Moniker4 }
	   GI_comp       = @MazePrimary;
        gcnList(MANUFACTURER_ID_GEOWORKS,GAGCNLT_WINDOWS)
                      = @MazePrimary;
        gcnList(MANUFACTURER_ID_GEOWORKS,MGCNLT_ACTIVE_LIST)
				  = /*@MazeViewControl,  */
								@MazeColorControl,
								@HighScoreControl ;
        gcnList(MANUFACTURER_ID_GEOWORKS,GAGCNLT_SELF_LOAD_OPTIONS)
				  = /*@MazeViewControl,  */
                        @MazeColorControl ;
        gcnList(MANUFACTURER_ID_GEOWORKS,GAGCNLT_STARTUP_LOAD_OPTIONS)
				  = /*@MazeViewControl, */
                        @MazeColorControl ;
    }
    /*---------------------------------------------------------------------*/
    @visMoniker MazeTextMoniker =
        "Maze Runner" ;
    /*---------------------------------------------------------------------*/
@end	AppResource



/*=========================================================================*/



@start	Interface		/* this resource is for misc UI objects */ ; ;
    /*---------------------------------------------------------------------*/
	 @object GenPrimaryClass MazePrimary  = {
        GI_attrs = @default | GA_KBD_SEARCH_PATH ;
		  GI_comp             = @MazeWholeGroup,
                              @MazeGameMenu,
										@MazeEditMenu,
										@MazeOptionsMenu,
							/*			@MazeViewMenu, */
										@MazeDialogs,
										@QTipsDialogBox ;
	/*ATTR_GEN_HELP_CONTEXT = "TOC";*/
	HINT_PRIMARY_NO_HELP_BUTTON;
       HINT_PRIMARY_NO_FILE_MENU ;
		  HINT_SIZE_WINDOW_AS_DESIRED ;
  //      HINT_CENTER_WINDOW;
        HINT_CENTER_CHILDREN_HORIZONTALLY ;
		  HINT_CENTER_CHILDREN_VERTICALLY ;
	 }
    /*---------------------------------------------------------------------*/
    @object GenInteractionClass MazeWholeGroup = {
		  GI_comp = @MazeTopGroup,
                  @MazeViewOwner ;
		  HINT_CENTER_CHILDREN_VERTICALLY ;
		  HINT_CENTER_CHILDREN_HORIZONTALLY ;
        HINT_DEFAULT_FOCUS ;
        HINT_DEFAULT_TARGET ;
		  HINT_MINIMUM_SIZE = {SST_PIXELS | DOC_WIDTH + 60,
									  SST_PIXELS | DOC_WIDTH + 60, 0};
	 //	  HINT_EXPAND_WIDTH_TO_FIT_PARENT ;
	 	  HINT_EXPAND_HEIGHT_TO_FIT_PARENT ;
	//	  HINT_DRAW_IN_BOX;
	 }
	 /*---------------------------------------------------------------------*/
	 @object GenInteractionClass MazeTopGroup = {
		  GI_comp = @MazeNewTrigger, @MazeRunTrigger, @MazeSpacer, @MazeRightGroup ;
		  HINT_ORIENT_CHILDREN_HORIZONTALLY ;
		  HINT_CENTER_CHILDREN_VERTICALLY ;
		  HINT_EXPAND_WIDTH_TO_FIT_PARENT ;
		  HINT_FULL_JUSTIFY_CHILDREN_HORIZONTALLY;
	 }
	 /*---------------------------------------------------------------------*/
	 @object GenTriggerClass MazeNewTrigger = {
		  GI_visMoniker   = 'N', "New Maze" ;
		  GTI_destination = process ;
		  GTI_actionMsg   = MSG_VIEW_MAZE_NEW ;
	 }
	 @object GenTriggerClass MazeRunTrigger = {
		  GI_visMoniker   = 'R', "Run" ;
		  GTI_destination = process ;
		  GTI_actionMsg   = MSG_VIEW_MAZE_NEW_AND_PLAY ;
		  ATTR_GEN_TRIGGER_ACTION_DATA = TRUE;		/* only run */
	 }
	 /*---------------------------------------------------------------------*/
	 @object GenInteractionClass MazeSpacer = {
		  HINT_FIXED_SIZE = {SST_PIXELS | 30, 0,0};
	 }
	 /*---------------------------------------------------------------------*/
	 @object GenInteractionClass MazeRightGroup = {
		  GI_comp = @MazeTimerGroup, @MazeScoreGroup ;
 //		  HINT_EXPAND_WIDTH_TO_FIT_PARENT ;
	 }
	 /*---------------------------------------------------------------------*/
	 @object GenInteractionClass MazeTimerGroup = {
		  GI_comp = @MazeTimerTitle, @MazeTimer ;
		  HINT_ORIENT_CHILDREN_HORIZONTALLY ;
		  HINT_EXPAND_WIDTH_TO_FIT_PARENT ;
		  HINT_FULL_JUSTIFY_CHILDREN_HORIZONTALLY;
	 }
	 /*---------------------------------------------------------------------*/
	 @object MazeTimerClass MazeTimerTitle = {
		  GI_visMoniker    = "Time: " ;
	 }
	 /*---------------------------------------------------------------------*/
	 @object MazeTimerClass MazeTimer = {
	 }
	 /*---------------------------------------------------------------------*/
	 @object GenInteractionClass MazeScoreGroup = {
		  GI_comp = @MazeScoreTitle, @MazeScore ;
		  HINT_ORIENT_CHILDREN_HORIZONTALLY ;
		  HINT_EXPAND_WIDTH_TO_FIT_PARENT ;
		  HINT_FULL_JUSTIFY_CHILDREN_HORIZONTALLY;
	 }
	 /*---------------------------------------------------------------------*/
	 @object MazeTimerClass MazeScoreTitle = {
		  GI_visMoniker    = "Score: " ;
	 }
	 /*---------------------------------------------------------------------*/
    @object GenGlyphClass MazeScore = {
	 }
	 /*---------------------------------------------------------------------*/
    @object GenInteractionClass MazeViewOwner = {
        GI_comp = @MazeView, @MazeLostFocusGlyph ;
        HINT_EXPAND_WIDTH_TO_FIT_PARENT ;
        HINT_EXPAND_HEIGHT_TO_FIT_PARENT ;
        HINT_CENTER_CHILDREN_HORIZONTALLY ;
        HINT_CENTER_CHILDREN_VERTICALLY ;
	/*	  HINT_MAXIMUM_SIZE = { SST_PIXELS | 600,
										SST_PIXELS | 400,
                              0 } ;
	/*	  HINT_MINIMUM_SIZE = { SST_PIXELS | DOC_WIDTH+10,
										SST_PIXELS | DOC_WIDTH+10,
                              0 } ;
	/*	  HINT_INITIAL_SIZE = { SST_PIXELS | DOC_WIDTH+10,
										SST_PIXELS | DOC_WIDTH+10,
                              0 } ;
	*/	  HINT_DEFAULT_FOCUS ;
        HINT_DEFAULT_TARGET ;
  //		  HINT_DRAW_IN_BOX;
	 }
    /*---------------------------------------------------------------------*/
    @object MazeViewClass MazeView = {
        GVI_attrs      = @default |
								 GVA_CONTROLLED |
								 GVA_SCALE_TO_FIT;
        GVI_horizAttrs   = @default |
									GVDA_SCROLLABLE/* |
						 //			GVDA_NO_SMALLER_THAN_CONTENT |
									GVDA_NO_LARGER_THAN_CONTENT */;
		  GVI_vertAttrs    = @default |
									GVDA_SCROLLABLE/* |
				 		 //			GVDA_NO_SMALLER_THAN_CONTENT |
									GVDA_NO_LARGER_THAN_CONTENT*/ ;
        GVI_content      = @MazeContent;
        GVI_docBounds    = {0, 0, DOC_WIDTH, DOC_HEIGHT};
        HINT_EXPAND_WIDTH_TO_FIT_PARENT ;
        HINT_EXPAND_HEIGHT_TO_FIT_PARENT ;
        HINT_DEFAULT_TARGET;
        HINT_DEFAULT_FOCUS;
        HINT_DEFAULT_MODEL ;
		  HINT_VIEW_REMOVE_SCROLLERS_WHEN_NOT_SCROLLABLE ;
    }
	 /*---------------------------------------------------------------------*/
	 @object MazeContentClass MazeContent = {
		  VCNI_view         = MazeView ;
		  VCNI_attrs        = @default |
									 VCNA_SAME_WIDTH_AS_VIEW |
									 VCNA_SAME_HEIGHT_AS_VIEW |
									 VCNA_LARGE_DOCUMENT_MODEL |
									 VCNA_ACTIVE_MOUSE_GRAB_REQUIRES_LARGE_EVENTS ;
	 }
    /*---------------------------------------------------------------------*/
    @object GenInteractionClass MazeLostFocusGlyph = {
        GI_comp = @MazeLostFocusGroup ;
	   GI_states = @default & (~GS_USABLE) ;
   	HINT_EXPAND_WIDTH_TO_FIT_PARENT ;
        HINT_EXPAND_HEIGHT_TO_FIT_PARENT ;
        HINT_CENTER_CHILDREN_HORIZONTALLY ;
        HINT_CENTER_CHILDREN_VERTICALLY ;
    }
    /*---------------------------------------------------------------------*/
    @object MazePauseInterClass MazeLostFocusGroup = {
        GI_comp = @MazeLostFocusGlyph1,
                  @MazeLostFocusGlyph2 ;
        HINT_CENTER_CHILDREN_HORIZONTALLY ;
        HINT_CENTER_CHILDREN_VERTICALLY ;
    }
    /*---------------------------------------------------------------------*/
    @object GenGlyphClass MazeLostFocusGlyph1 = {
        GI_visMoniker = " Game " ;
    }
    /*---------------------------------------------------------------------*/
    @object GenGlyphClass MazeLostFocusGlyph2 = {
        GI_visMoniker = " Paused " ;
    }

	 /*---------------------------------------------------------------------*/
	 @object GenInteractionClass MazeGameMenu = {
		GI_comp = @MazePlayGameTrigger,
 //			@MazeNewOption,
				@MazeQTipsTrigger,
			   @MazePauseTrigger,
			   @MazeContTrigger,
			   @MazeSolveTrigger,
						@HighScoreControl;
		GI_visMoniker = 'G', "Game" ;
		  GI_attrs = @default | GA_KBD_SEARCH_PATH ;
        GII_visibility = GIV_POPUP ;
        ATTR_GEN_INTERACTION_GROUP_TYPE
                       = (GIGT_FILE_MENU) ;
    }
	 /*---------------------------------------------------------------------*/
	 @object GenTriggerClass MazePlayGameTrigger = {
		  GI_visMoniker   = 'M', "Start New Maze" ;
		  GTI_destination = process ;
		  GTI_actionMsg   = MSG_VIEW_MAZE_NEW_AND_PLAY ;
		  ATTR_GEN_TRIGGER_ACTION_DATA = FALSE;		/* new maze and then run */
	 }
	 /*---------------------------------------------------------------------*/
/*	 @object GenTriggerClass MazeNewOption = {
		  GI_visMoniker   = 'N', "New Maze" ;
		  GTI_destination = process ;
		  GTI_actionMsg   = MSG_VIEW_MAZE_NEW ;
	 }
	 /*---------------------------------------------------------------------*/
	 @object GenTriggerClass MazeQTipsTrigger = {
		  GI_visMoniker   = 'Q', "Quick Tips" ;
		  GTI_destination = @QTipsDialogBox ;
		  GTI_actionMsg   = MSG_GEN_INTERACTION_INITIATE ;
		  HINT_TRIGGER_BRINGS_UP_WINDOW;
    }
	 /*---------------------------------------------------------------------*/
	 @object GenTriggerClass MazePauseTrigger = {
		GI_visMoniker   = 'P', "Pause" ;
		GI_attrs = @default | GA_KBD_SEARCH_PATH;
		GI_kbdAccelerator = control 'p';
		GTI_destination = process ;
		GTI_actionMsg   = MSG_MAZE_PAUSE ;
	 }

	 /*---------------------------------------------------------------------*/
	 @object GenTriggerClass MazeContTrigger = {
		GI_visMoniker   = 'C', "Continue" ;
		GI_attrs = @default | GA_KBD_SEARCH_PATH;
		GI_kbdAccelerator = control 'c';
		GTI_destination = process ;
		GTI_actionMsg   = MSG_MAZE_CONT ;
	 }
	 /*---------------------------------------------------------------------*/
	 @object GenTriggerClass MazeSolveTrigger = {
		  GI_visMoniker   = 'v', "Solve" ;
		  GTI_destination = process ;
		  GTI_actionMsg   = MSG_MAZE_SOLVE ;
	 }
	 /*---------------------------------------------------------------------*/
	 @object HighScoreClass HighScoreControl = {
		  HSI_fileName = "Maze High Scores";
		  HSI_creator = {"MRun", 16431};
		  HSI_highScoreTitle = "Maze Runner High Scores";
	 }

	 /*---------------------------------------------------------------------*/
	 @object GenInteractionClass MazeEditMenu = {
		  GI_attrs = @default | GA_KBD_SEARCH_PATH ;
		  GI_comp        = @MazeCopyToClipboard ;
		  GII_visibility = GIV_POPUP ;
		  ATTR_GEN_INTERACTION_GROUP_TYPE
							  = (GIGT_EDIT_MENU) ;
	 }
	 /*---------------------------------------------------------------------*/
	 @object GenTriggerClass MazeCopyToClipboard = {
		  GI_visMoniker   = 'C', "Copy Maze" ;
		  GTI_destination = process ;
		  GTI_actionMsg   = MSG_META_CLIPBOARD_COPY ;
	 }

	 /*---------------------------------------------------------------------*/
	 @object GenInteractionClass MazeOptionsMenu = {
		  GI_attrs = @default | GA_KBD_SEARCH_PATH ;
		  GI_comp        = @MazeSoundOpt,
								 @MazeViewMode1,
								 @MazeViewMode2,
								 @MazeMoveBox,
								 @MazeSizeOption,
								 @MazeColorChange;
		  GII_visibility = GIV_POPUP ;
		  ATTR_GEN_INTERACTION_GROUP_TYPE
							  = (GIGT_OPTIONS_MENU) ;
	 }
	 /*---------------------------------------------------------------------*/
	 @object GenInteractionClass MazeSoundOpt = {
		  GI_visMoniker = 'S', "Sound" ;
		  GI_comp = @SoundGroup;
		  GII_visibility = GIV_POPUP;
	 }
	 /*---------------------------------------------------------------------*/
	 @object GenItemGroupClass SoundGroup = {
		  GI_comp          = @SoundOn,
									@SoundOff,
									@SystemPref ;
		  GIGI_selection   = SOUND_SYSTEM ;
        GIGI_destination = process ;
		  GIGI_applyMsg = MSG_MAZE_SOUND_CHANGED ;
    }
    /*---------------------------------------------------------------------*/
	 @object GenItemClass SoundOn = {
		  GI_visMoniker = 'S', "Sound On" ;
		  GII_identifier = SOUND_ON ;
    }
	 /*---------------------------------------------------------------------*/
	 @object GenItemClass SoundOff = {
		  GI_visMoniker = 'O', "Sound Off" ;
		  GII_identifier = SOUND_OFF ;
	 }
	 /*---------------------------------------------------------------------*/
	 @object GenItemClass SystemPref = {
		  GI_visMoniker = 'P', "Use System Preference" ;
		  GII_identifier = SOUND_SYSTEM ;
	 }

	 /*---------------------------------------------------------------------*/
	 @object GenTriggerClass MazeViewMode1 = {
		  GI_visMoniker   = 'B', "Blocks" ;
		  GTI_destination = process ;
		  GTI_actionMsg   = MSG_MAZE_VIEW_MODE_1 ;
	 }
	 /*---------------------------------------------------------------------*/
	 @object GenTriggerClass MazeViewMode2 = {
		  GI_visMoniker   = 'L', "Lines" ;
		  GTI_destination = process ;
		  GTI_actionMsg   = MSG_MAZE_VIEW_MODE_2 ;
	 }
	 /*---------------------------------------------------------------------*/
	 @object GenInteractionClass MazeMoveBox = {
		  GI_attrs = @default | GA_KBD_SEARCH_PATH ;
		  GI_visMoniker   = 'M', "Move Controls" ;
		  GII_visibility  = GIV_DIALOG ;
		  GI_comp         = @MazeMoveUpTrigger,
								  @MazeMoveLeftAndRightGroup,
								  @MazeMoveDownTrigger ;
		  HINT_CENTER_CHILDREN_HORIZONTALLY ;
		  HINT_POSITION_WINDOW_AT_RATIO_OF_PARENT = {
					SWSS_RATIO | PCT_80,  SWSS_RATIO | PCT_5 };
	 }
	 /*---------------------------------------------------------------------*/
    @object GenInteractionClass MazeSizeOption = {
        GI_visMoniker   = 'S', "Size Change" ;
        GII_visibility  = GIV_DIALOG ;
		  GI_comp         = @MazeSizeApplyTrigger,
								  @MazeSizeXGenValue,
                          @MazeSizeYGenValue ;
    }
    /*---------------------------------------------------------------------*/
    @object GenInteractionClass MazeColorChange = {
        GI_visMoniker   = 'o', "Color Change" ;
        GII_visibility  = GIV_DIALOG ;
        GI_comp         = @MazeColorAll ;
    }
    /*---------------------------------------------------------------------*/
    @object GenTriggerClass MazeSizeApplyTrigger = {
        GI_visMoniker   = 'D', "Do it!" ;
		  GTI_destination = process ;
        GTI_actionMsg   = MSG_MAZE_SIZE_CHANGED ;
        ATTR_GEN_TRIGGER_INTERACTION_COMMAND = {IC_APPLY} ;
        HINT_SEEK_REPLY_BAR ;
        HINT_DEFAULT_DEFAULT_ACTION ;
    }
    /*---------------------------------------------------------------------*/
    @object GenValueClass MazeSizeXGenValue = {
        GI_visMoniker   = 'X', "X Size" ;
        GVLI_value      = MakeWWFixed(INITIAL_SIZE) ;
        GVLI_minimum    = MakeWWFixed(MINIMUM_SIZE) ;
	GVLI_maximum    = MakeWWFixed(MAX_SIZE_X) ;
    }
    /*---------------------------------------------------------------------*/
    @object GenValueClass MazeSizeYGenValue = {
        GI_visMoniker   = 'Y', "Y Size" ;
        GVLI_value      = MakeWWFixed(INITIAL_SIZE) ;
        GVLI_minimum    = MakeWWFixed(MINIMUM_SIZE) ;
	GVLI_maximum    = MakeWWFixed(MAX_SIZE_Y) ;
    }

	 /*---------------------------------------------------------------------*/
/*	 @object GenInteractionClass MazeViewMenu = {
		  GI_comp        = @MazeViewControl ;
		  GII_visibility = GIV_POPUP ;
		  ATTR_GEN_INTERACTION_GROUP_TYPE
							  = (GIGT_VIEW_MENU) ;
	 }
	 /*---------------------------------------------------------------------*/
/*    @object GenViewControlClass MazeViewControl = {
        GVCI_maxZoom = 400 ;
        HINT_GEN_CONTROL_MODIFY_INITIAL_UI
                   = { GCUF_USER_UI,
							  0 /*GVCF_REDRAW*//*,
                       GVCF_ADJUST_ASPECT_RATIO |
                       GVCF_MAIN_SCALE_TO_FIT |
                       GVCF_SCALE_TO_FIT |
                       GVCF_APPLY_TO_ALL |
                       GVCF_SHOW_HORIZONTAL|
                       GVCF_SHOW_VERTICAL,
                       0,
                       0} ;
    }

	 /*---------------------------------------------------------------------*/
	 @object GenInteractionClass MazeDialogs = {
		  GI_comp = @MazeCompletedBox, @MazeTimeRanOutBox;
		  GII_type = GIT_ORGANIZATIONAL ;
		  GII_visibility = GIV_DIALOG ;
		  GII_attrs = @default | GIA_NOT_USER_INITIATABLE ;
	 }
	 /*---------------------------------------------------------------------*/
	 @object GenInteractionClass MazeCompletedBox = {
		  GI_visMoniker   = "We have a winner!" ;
		  GII_visibility  = GIV_DIALOG ;
		  GII_type        = GIT_NOTIFICATION ;
		  GII_attrs       = @default                         |
								  GIA_INITIATED_VIA_USER_DO_DIALOG |
								  GIA_MODAL                        |
								  GIA_NOT_USER_INITIATABLE         ;
		  GI_comp         = @WinnerGlyph,
								  @MouseGlyph ;
		  HINT_ORIENT_CHILDREN_HORIZONTALLY ;
		  HINT_CENTER_CHILDREN_VERTICALLY ;
	 }
	 /*---------------------------------------------------------------------*/
    @object GenGlyphClass MouseGlyph = {
        GI_visMoniker = list { @MouseMoniker } ;
    }
    /*---------------------------------------------------------------------*/
    @object GenInteractionClass WinnerGlyph = {
        GI_comp = @WinnerGlyph1,
                  @WinnerGlyph2,
                  @WinnerGlyph3 ;
        HINT_CENTER_CHILDREN_HORIZONTALLY ;
    }
    /*---------------------------------------------------------------------*/
    @object GenGlyphClass WinnerGlyph1 = {
        GI_visMoniker = "CONGRATULATIONS!" ;
    }
    /*---------------------------------------------------------------------*/
    @object GenGlyphClass WinnerGlyph2 = {
        GI_visMoniker = "You completed the maze!" ;
    }
    /*---------------------------------------------------------------------*/
	 @object GenGlyphClass WinnerGlyph3 = {
		  GI_visMoniker = "Have some cheese ..." ;
	 }

    	 /*---------------------------------------------------------------------*/
	 @object GenInteractionClass MazeTimeRanOutBox = {
		  GI_visMoniker   = "Time ran out!" ;
		  GII_visibility  = GIV_DIALOG ;
		  GII_type        = GIT_NOTIFICATION ;
		  GII_attrs       = @default                         |
								  GIA_INITIATED_VIA_USER_DO_DIALOG |
								  GIA_MODAL                        |
								  GIA_NOT_USER_INITIATABLE         ;
		  GI_comp         = @TimeGlyph1, @TimeGlyph2, @TimeGlyph3;
		  HINT_CENTER_CHILDREN_HORIZONTALLY ;
	 }
	 /*---------------------------------------------------------------------*/
	 @object GenGlyphClass TimeGlyph1 = {
		  GI_visMoniker = "Too Late!" ;
    }
    /*---------------------------------------------------------------------*/
	 @object GenGlyphClass TimeGlyph2 = {
		  GI_visMoniker = "You ran out of time." ;
    }
    /*---------------------------------------------------------------------*/
	 @object GenGlyphClass TimeGlyph3 = {
		  GI_visMoniker = "No cheese for you." ;
	 }

	 /*---------------------------------------------------------------------*/
	 @chunk char MazeNewGameMsg[] = "Changing this option will end the current game and begin a new one.  Are you sure you want to do this?" ;

@end Interface



/*=========================================================================*/




@start InterfaceMoveBox ;
@include "moves.goh"

	 /*---------------------------------------------------------------------*/
	 @object GenInteractionClass MazeMoveLeftAndRightGroup = {
		  GI_attrs = @default | GA_KBD_SEARCH_PATH ;
		  GI_comp         = @MazeMoveLeftTrigger,
								  @MazeMoveRightTrigger;
		  HINT_ORIENT_CHILDREN_HORIZONTALLY ;
	 }
	 /*---------------------------------------------------------------------*/
	 @object GenTriggerClass MazeMoveUpTrigger = {
        GI_attrs = @default | GA_KBD_SEARCH_PATH ;
		  GI_kbdAccelerator = ctrl 'i' ;
		  GI_visMoniker = list { @UpMoniker0,
										 @UpMoniker1,
										 @UpMoniker2 }
		  GTI_destination = process ;
        GTI_actionMsg   = MSG_MAZE_MOVE_UP ;
	 }
	 /*---------------------------------------------------------------------*/
	 @object GenTriggerClass MazeMoveLeftTrigger = {
		  GI_attrs = @default | GA_KBD_SEARCH_PATH ;
		  GI_kbdAccelerator = ctrl 'j' ;
		  GI_visMoniker = list { @LeftMoniker0,
										 @LeftMoniker1,
										 @LeftMoniker2 }
		  GTI_destination = process ;
        GTI_actionMsg   = MSG_MAZE_MOVE_LEFT ;
    }
    /*---------------------------------------------------------------------*/
    @object GenTriggerClass MazeMoveRightTrigger = {
        GI_attrs = @default | GA_KBD_SEARCH_PATH ;
        GI_kbdAccelerator = ctrl 'k' ;
        GI_visMoniker = list { @RightMoniker0,
                               @RightMoniker1,
                               @RightMoniker2 }
        GTI_destination = process ;
        GTI_actionMsg   = MSG_MAZE_MOVE_RIGHT ;
    }
    /*---------------------------------------------------------------------*/
    @object GenTriggerClass MazeMoveDownTrigger = {
        GI_attrs = @default | GA_KBD_SEARCH_PATH ;
        GI_kbdAccelerator = ctrl 'm' ;
        GI_visMoniker = list { @DownMoniker0,
                               @DownMoniker1,
                               @DownMoniker2 }
        GTI_destination = process ;
        GTI_actionMsg   = MSG_MAZE_MOVE_DOWN ;
    }
    /*---------------------------------------------------------------------*/

@end InterfaceMoveBox



/*=========================================================================*/



@start InterfaceColor ;
    /*---------------------------------------------------------------------*/
	 @object GenInteractionClass MazeColorAll = {
		  GI_comp = @MazeColorGroup,
						@MazeColorControl ;
		  HINT_CENTER_CHILDREN_HORIZONTALLY ;
	 }
	 /*---------------------------------------------------------------------*/
    @object GenItemGroupClass MazeColorGroup = {
        GI_comp          = @MazeColorBackground,
                           @MazeColorWalls,
                           @MazeColorTrail,
                           @MazeColorSolution,
                           @MazeColorPlayerPiece ;
        GIGI_selection   = MAZE_COLOR_BACKGROUND ;
        GIGI_destination = process ;
        GIGI_applyMsg = MSG_PROCESS_COLOR_CHOICE_CHANGED;
        HINT_PLACE_MONIKER_ABOVE ;
    }
    /*---------------------------------------------------------------------*/
    @object GenItemClass MazeColorBackground = {
        GI_visMoniker = 'B', "Background" ;
        GII_identifier = MAZE_COLOR_BACKGROUND ;
    }
    /*---------------------------------------------------------------------*/
    @object GenItemClass MazeColorWalls = {
        GI_visMoniker = 'W', "Walls" ;
        GII_identifier = MAZE_COLOR_WALLS ;
    }
    /*---------------------------------------------------------------------*/
    @object GenItemClass MazeColorTrail = {
        GI_visMoniker = 'T', "Trail" ;
        GII_identifier = MAZE_COLOR_TRAIL ;
    }
    /*---------------------------------------------------------------------*/
    @object GenItemClass MazeColorSolution = {
        GI_visMoniker = 'S', "Solution" ;
        GII_identifier = MAZE_COLOR_SOLUTION ;
    }
    /*---------------------------------------------------------------------*/
    @object GenItemClass MazeColorPlayerPiece = {
        GI_visMoniker = 'P', "Player Piece" ;
        GII_identifier = MAZE_COLOR_PLAYER_PIECE;
    }
    /*---------------------------------------------------------------------*/
    @object ColorSelectorClass MazeColorControl = {
        GCI_output = process;
		  ATTR_GEN_CONTROL_PROHIBIT_UI = (CSF_RGB |
													 CSF_OTHER |
													 CSF_PATTERN |
													 CSF_OTHER |
													 CSF_DRAW_MASK);
    }
    /*---------------------------------------------------------------------*/
@end InterfaceColor

@start QTipsResource;
@include "Art/QTip1.goh"
@include "Art/QTip2a.goh"
@include "Art/QTip2b.goh"

	 @object GenInteractionClass QTipsDialogBox = {
		  GI_visMoniker = "Maze Runner Quick Tips";
		  GI_comp = @GoalText,
						@QuickTipsGroup,
						@ShowOnStartupGroup,
						@OKTipsButton;
		  GII_visibility = GIV_DIALOG ;
		  GII_attrs = @default | GIA_MODAL | GIA_NOT_USER_INITIATABLE;
		  HINT_CENTER_CHILDREN_HORIZONTALLY ;
		  /*ATTR_GEN_HELP_CONTEXT = "TOC";*/
	 }


	 @object GenTextClass GoalText = {
		  GI_attrs = @default | GA_READ_ONLY;
		  GTXI_text = "The goal of the game is to find your way out!";
		  ATTR_GEN_TEXT_NEVER_MAKE_SCROLLABLE;
	 }

	 @object GenBooleanGroupClass ShowOnStartupGroup = {
		  GI_comp = @ShowOnStartupBoolean;
	 }

	 @object GenBooleanClass ShowOnStartupBoolean = {
		  GI_visMoniker = 'S', "Show this Dialog box when Maze Runner starts";
		  GBI_identifier = SHOW_ON_STARTUP;
	 }

	 @object GenTriggerClass OKTipsButton = {
		  GI_visMoniker   = 'O', "OK";
        GI_attrs = @default | GA_SIGNAL_INTERACTION_COMPLETE ;
		  HINT_SEEK_REPLY_BAR;
		  HINT_DEFAULT_DEFAULT_ACTION;
	 }


	 @object GenInteractionClass QuickTipsGroup = {
		  GI_comp = @QTip1, @QTip2;
	 }

	 @object GenInteractionClass QTip1 = {
		  GI_comp = @QTip1GlyphHolder, @QTip1Text ;
		  HINT_ORIENT_CHILDREN_HORIZONTALLY;
		  HINT_CENTER_CHILDREN_VERTICALLY;
	 }

	 @object GenInteractionClass QTip1GlyphHolder = {
		  GI_comp = @QTip1Glyph;
		  HINT_CENTER_CHILDREN_HORIZONTALLY;
		  HINT_CENTER_CHILDREN_VERTICALLY;
		  HINT_FIXED_SIZE = {SST_PIXELS | 100, 0,0};
		  /* ^^^ is based on the width of the widest icon */
	 }

	 @object GenGlyphClass QTip1Glyph = {
		  GI_visMoniker = list { @QTip1Moniker };
	 }

	 @object GenTextClass QTip1Text = {
		  GI_attrs = @default | GA_READ_ONLY;
		  GTXI_text = "No cheating now: you can go through open doors, but you can't jump any walls. And remember: the faster you solve the maze, the higher your score.";
		  ATTR_GEN_TEXT_NEVER_MAKE_SCROLLABLE;
		  HINT_MINIMUM_SIZE = {SST_PIXELS | 325, 0, 0};
	 }

	 @object GenInteractionClass QTip2 = {
		  GI_comp = @QTip2GlyphHolder, @QTip2Text ;
		  HINT_ORIENT_CHILDREN_HORIZONTALLY;
		  HINT_CENTER_CHILDREN_VERTICALLY;
	 }

	 @object GenInteractionClass QTip2GlyphHolder = {
		  GI_comp = @QTip2aGlyph, @QTip2bGlyph;
		  HINT_CENTER_CHILDREN_HORIZONTALLY;
		  HINT_CENTER_CHILDREN_VERTICALLY;
		  HINT_FIXED_SIZE = {SST_PIXELS | 100, 0,0};
	 }

	 @object GenGlyphClass QTip2aGlyph = {
		  GI_visMoniker = list { @QTip2aMoniker };
	 }

	 @object GenGlyphClass QTip2bGlyph = {
		  GI_visMoniker = list { @QTip2bMoniker };
	 }

	 @object GenTextClass QTip2Text = {
		  GI_attrs = @default | GA_READ_ONLY;
		  GTXI_text = "You can use the arrow keys on the keyboard or the mouse to move the cursor through the maze. To use the mouse, hold down the left mouse button and drag the cursor.";
		  ATTR_GEN_TEXT_NEVER_MAKE_SCROLLABLE;
		  HINT_MINIMUM_SIZE = {SST_PIXELS | 325, 0, 0};
	 }


@end QTipsResource


/*=========================================================================*/



word MyRandom(void) ;
//void show(byte* maze, word size_x, word size_y) ;

word MyRandom()
{
    static word rand1 = 0xf32d ;
    static word rand2 = 0x0103 ;
    static word rand3 = 0x4326 ;
    static word rand4 = 0x4878 ;
    TimerDateAndTime dateAndTime ;
    word old ;

    TimerGetDateAndTime(&dateAndTime) ;
    old = rand1 ;
    rand1 = rand2 ;
    rand2 = rand3 ;
    rand3 = rand4 ;
/*
    rand4 += dateAndTime.TDAT_minutes + dateAndTime.TDAT_minutes +
             dateAndTime.TDAT_hours + dateAndTime.TDAT_day ;
*/
    rand4 ^= old^rand1^rand2^rand3 ;
    rand3 += rand1+rand2+rand4 ;
    rand4 += TimerGetCount() ;
    return old ;
}


/* size_x and size_y must be odd values */

void MazeMake(byte* maze, word size_x, word size_y)
{
    word pos = size_x * size_y;
    word pos_x ;
    word pos_y ;
    int dirs[4] = { 1, -1, 0, 0} ;
    int dir_try ;
    int dir_step ;
    int double_step ;
    int count ;

    @send MazeApp::MSG_GEN_APPLICATION_MARK_BUSY() ;
    dirs[3] = -(dirs[2] = size_x) ;

    for (pos--; pos!=(word)(-1); pos--)
        maze[pos] = 0 ;

    for (pos_x=0; pos_x<size_x; pos_x++)
        maze[quick_maze(pos_x, size_y-1)] =
            maze[quick_maze(pos_x, 0)] = MAZE_BIT_TWICE ;

    for (pos_y=0; pos_y<size_y; pos_y++)  {
        maze[quick_maze(0, pos_y)] =
            maze[quick_maze(size_x-1, pos_y)] = MAZE_BIT_TWICE ;
    }

    pos_x = 1 + ((MyRandom() % (size_x-2)) & 0xFFFE) ;
    pos_y = 1 + ((MyRandom() % (size_y-2)) & 0xFFFE) ;

    pos = quick_maze(pos_x, pos_y) ;

    maze[pos] = MAZE_BIT_ONCE ;

    do {
        if ((maze[pos+1] == MAZE_BIT_TWICE) &&
            (maze[pos-1] == MAZE_BIT_TWICE) &&
            (maze[pos+size_x] == MAZE_BIT_TWICE) &&
            (maze[pos-size_x] == MAZE_BIT_TWICE))
           break ;

        do {
            dir_try = (MyRandom() >> 2) % 5;
        } while (dir_try>3) ;
        double_step = (dir_step = dirs[dir_try])<<1 ;

        count = 0 ;

        while ((maze[pos+dir_step]&(MAZE_BIT_TWICE|MAZE_BIT_ONCE)) ||
                (maze[pos+double_step]&(MAZE_BIT_TWICE|MAZE_BIT_ONCE)))  {
           dir_try = (dir_try+1)&3 ;
           double_step = (dir_step = dirs[dir_try])<<1 ;
           if ((++count)==4)
              break ;
        }

        if (count==4)  {
            dir_try = MyRandom() & 3 ;
            dir_step = dirs[dir_try] ;

            count = 0 ;

            while (maze[pos+dir_step] != MAZE_BIT_ONCE)  {
                dir_try = (dir_try+1)&3 ;
                dir_step = dirs[dir_try] ;
                if ((++count)==4)
                    break ;
            }
            if (count!=4)  {
                maze[pos] |= MAZE_BIT_TWICE ;
                pos += dir_step ;
                maze[pos] |= MAZE_BIT_TWICE ;
                pos += dir_step ;
            }
        } else {
            pos += dir_step ;
            maze[pos] |= MAZE_BIT_ONCE ;
            pos += dir_step ;
            maze[pos] |= MAZE_BIT_ONCE ;
        }
    } while (count != 4) ;
    maze[pos] = MAZE_BIT_ONCE|MAZE_BIT_TWICE ;

    pos_start = pos_y = 1 + ((MyRandom() % (size_y-2)) & 0xFFFE) ;
    pos = quick_maze(0, pos_y) ;
    maze[pos] = MAZE_BIT_ONCE|MAZE_BIT_TWICE ;

    pos_y = 1 + ((MyRandom() % (size_y-2)) & 0xFFFE) ;
    pos = quick_maze(size_x-1, pos_y) ;
    maze[pos] = MAZE_BIT_ONCE|MAZE_BIT_TWICE ;

    for (pos=0; pos<MAZE_BUFFER_SIZE; pos++)
        maze[pos] &= (~MAZE_BIT_TWICE) ;
    @send MazeApp::MSG_GEN_APPLICATION_MARK_NOT_BUSY() ;
}


void SolveMaze()
{
    word pos = size_x * size_y;
    word pos_x ;
    word pos_y ;
    int dirs[4] = { 1, 0, 0, -1} ;
    int dir_try ;
    int dir_step ;
    int count ;

    for (pos=0; pos<MAZE_BUFFER_SIZE; pos++)
        maze[pos] &= (~(MAZE_BIT_SOL_TWICE|MAZE_BIT_SOL_ONCE)) ;

    dirs[2] = -(dirs[1] = size_x) ;

    pos_x = 0 ;
    pos_y = pos_start ;

    pos = quick_maze(pos_x, pos_y) ;

    maze[pos] |= MAZE_BIT_SOL_ONCE ;

    do {
        if ((pos % size_x) == (size_x-1))
            break ;

        count = dir_try = 0 ;

        dir_step = dirs[dir_try] ;
        while (!(maze[pos+dir_step]&MAZE_BIT_ONCE) ||
               (maze[pos+dir_step]&MAZE_BIT_SOL_ONCE)) {
            dir_try++ ;
            dir_step = dirs[dir_try] ;
            if ((++count)==4)
                break ;
        }

        if (count==4)  {
            count = dir_try = 0 ;
            dir_step = dirs[dir_try] ;

            while (!(maze[pos+dir_step]&MAZE_BIT_SOL_ONCE) ||
                   (maze[pos+dir_step]&MAZE_BIT_SOL_TWICE))  {
                dir_try++ ;
                dir_step = dirs[dir_try] ;
                if ((++count)==4)
                    break ;
            }
            if (count!=4)  {
                maze[pos] |= MAZE_BIT_SOL_TWICE ;
                pos += dir_step ;
            } else {
                break ;
            }
        } else {
            pos += dir_step ;
            maze[pos] |= MAZE_BIT_SOL_ONCE ;
        }
    } while (count != 4) ;

    maze[pos] |= MAZE_BIT_SOL_ONCE ;

    for (pos=0; pos<MAZE_BUFFER_SIZE; pos++)
        if (maze[pos]&MAZE_BIT_SOL_TWICE)
            maze[pos] &= (~(MAZE_BIT_SOL_TWICE|MAZE_BIT_SOL_ONCE)) ;
}


/*-------------------------------------------------------------------------*/
word ClearPlayerTrail()
{
    word i ;
    word r = 0;

    for (i=0; i<MAZE_BUFFER_SIZE; i++)
        if (maze[i] & MAZE_BIT_TRAVELED)  {
            r |= 1 ;
            maze[i] &= (~MAZE_BIT_TRAVELED) ;
        }

    return r ;
}
/*-------------------------------------------------------------------------*/
void MazeDraw(GStateHandle gstate,
              RectDWord *rect)
{
    if (gray_screen == FALSE)  {
        switch(draw_mode)  {
            case 0:  MazeDraw1(gstate, rect) ;
                     break ;
            case 1:  MazeDraw2(gstate, rect) ;
                     break ;
        }
    }
}

/*-------------------------------------------------------------------------*/
void MazeDraw1(GStateHandle gstate,
              RectDWord *rect)
{
    word start_x, start_y, end_x, end_y ;
    word x, y ;
    word pos ;
    word x_at, y_at ;

    start_x = ((word)(rect->RD_left)) / 6 ;
    start_y = ((word)(rect->RD_top)) / 6 ;
    end_x = (((word)(rect->RD_right)) / 6) ;
    end_y = (((word)(rect->RD_bottom)) / 6) ;

    if (start_x != 0)
       start_x-- ;
    if (start_y != 0)
       start_y-- ;
    if (end_x >= size_x)
       end_x = size_x-1 ;
    if (end_y >= size_y)
       end_y = size_y-1 ;

    GrSetAreaColor(gstate,
        colors[MAZE_COLOR_BACKGROUND].CQ_info,
        colors[MAZE_COLOR_BACKGROUND].CQ_redOrIndex,
        colors[MAZE_COLOR_BACKGROUND].CQ_green,
        colors[MAZE_COLOR_BACKGROUND].CQ_blue) ;

    GrApplyTranslation(gstate, MakeWWFixed(3.0), MakeWWFixed(3.0)) ;

    GrFillRect(gstate, 6*start_x,
                       6*start_y,
                       6*(1+end_x),
                       6*(1+end_y)) ;


    GrSetAreaColor(gstate,
        colors[MAZE_COLOR_WALLS].CQ_info,
        colors[MAZE_COLOR_WALLS].CQ_redOrIndex,
        colors[MAZE_COLOR_WALLS].CQ_green,
        colors[MAZE_COLOR_WALLS].CQ_blue) ;
    y_at = 6 * start_y ;
    for (y=start_y; y<=end_y; y++, y_at += 6)  {
        x_at = 6 * start_x ;
        pos = quick_maze(start_x, y) ;
        for (x=start_x;x<=end_x; x++, pos++, x_at += 6)
            if (!(maze[pos]&MAZE_BIT_ONCE))
               GrFillRect(gstate, x_at, y_at, x_at+6, y_at+6) ;
    }

    GrSetAreaColor(gstate,
        colors[MAZE_COLOR_TRAIL].CQ_info,
        colors[MAZE_COLOR_TRAIL].CQ_redOrIndex,
        colors[MAZE_COLOR_TRAIL].CQ_green,
        colors[MAZE_COLOR_TRAIL].CQ_blue) ;
    y_at = 6*start_y ;
    for (y=start_y; y<=end_y; y++, y_at += 6)  {
        x_at = 6*start_x ;
        pos = quick_maze(start_x, y) ;
        for (x=start_x;x<=end_x; x++, pos++, x_at+=6)  {
            if (maze[pos]&MAZE_BIT_TRAVELED)
			 GrFillRect(gstate, x_at+2, y_at+2, x_at+4, y_at+4) ;
	   }
    }

    GrSetAreaColor(gstate,
        colors[MAZE_COLOR_SOLUTION].CQ_info,
        colors[MAZE_COLOR_SOLUTION].CQ_redOrIndex,
        colors[MAZE_COLOR_SOLUTION].CQ_green,
        colors[MAZE_COLOR_SOLUTION].CQ_blue) ;
    y_at = 6*start_y ;
    for (y=start_y; y<=end_y; y++, y_at += 6)  {
        x_at = 6*start_x ;
        pos = quick_maze(start_x, y) ;
        for (x=start_x;x<=end_x; x++, pos++, x_at+=6)  {
            if (maze[pos]&MAZE_BIT_SOL_ONCE)
        //        GrFillRect(gstate, x_at+3, y_at+3, x_at+4, y_at+4) ;
			 GrFillRect(gstate, x_at+2, y_at+2, x_at+4, y_at+4) ;
	   }
    }

    if (game_mode)  {
        GrSetLineColor(gstate,
            colors[MAZE_COLOR_PLAYER_PIECE].CQ_info,
            colors[MAZE_COLOR_PLAYER_PIECE].CQ_redOrIndex,
            colors[MAZE_COLOR_PLAYER_PIECE].CQ_green,
            colors[MAZE_COLOR_PLAYER_PIECE].CQ_blue) ;
        GrSetLineWidth(gstate, MakeWWFixed(2.0)) ;
        x_at = 6*pos_x ;
        y_at = 6*pos_y ;
        GrDrawRect(gstate, x_at+1, y_at+1, x_at+5, y_at+5) ;
    }
}
/*-------------------------------------------------------------------------*/
void MazeDraw2(GStateHandle gstate,
              RectDWord *rect)
{
    sword start_x, start_y, end_x, end_y ;
    sword x, y ;
    word pos ;
    word x_at, y_at ;
    Boolean on_off_flag = FALSE;
    word start = 0 ;

    start_x = (((sword)(rect->RD_left)) / 6) ;
    start_y = (((sword)(rect->RD_top)) / 6) ;
    end_x = 1+(((word)(rect->RD_right)) / 6) ;
    end_y = 1+(((word)(rect->RD_bottom)) / 6) ;

    GrApplyTranslation(gstate, MakeWWFixed(6.0), MakeWWFixed(6.0)) ;

    if (!(end_x & 1))
        end_x++ ;
    if (!(end_y & 1))
        end_y++ ;
    if (start_x & 1)
        start_x-- ;
    if (start_y & 1)
        start_y-- ;
    if (start_x > 0)
       start_x-- ;
    if (start_y > 0)
       start_y-- ;
    if (start_x > 0)
       start_x-- ;
    if (start_y > 0)
       start_y-- ;
    if (end_x >= size_x)
       end_x = size_x-1 ;
    if (end_y >= size_y)
       end_y = size_y-1 ;

    GrSetAreaColor(gstate,
        colors[MAZE_COLOR_BACKGROUND].CQ_info,
        colors[MAZE_COLOR_BACKGROUND].CQ_redOrIndex,
        colors[MAZE_COLOR_BACKGROUND].CQ_green,
        colors[MAZE_COLOR_BACKGROUND].CQ_blue) ;
    GrFillRect(gstate, 6*start_x,
                       6*start_y,
                       6*end_x,
                       6*end_y) ;

    GrSetLineColor(gstate,
        colors[MAZE_COLOR_WALLS].CQ_info,
        colors[MAZE_COLOR_WALLS].CQ_redOrIndex,
        colors[MAZE_COLOR_WALLS].CQ_green,
        colors[MAZE_COLOR_WALLS].CQ_blue) ;

    GrSetLineWidth(gstate, MakeWWFixed(0.0)) ;

    y_at = 6 * start_y ;
    for (y=start_y; y<=end_y; y++, y_at += 6)  {
        x_at = 6 * start_x ;
        pos = quick_maze(start_x, y) ;
        on_off_flag = FALSE ;

        if ((y&1)==0)  {
        for (x=start_x;x<=end_x; x++, pos++, x_at += 6)
            if (on_off_flag)  {
                if (maze[pos]&MAZE_BIT_ONCE)  {
                    if (start+6 != x_at)
                        GrDrawHLine(gstate, start, y_at, x_at-6) ;
                    on_off_flag = FALSE ;
                }
            } else {
                if (!(maze[pos]&MAZE_BIT_ONCE))  {
                    on_off_flag = TRUE ;
                    start = x_at ;
                }
            }
        if (on_off_flag)
            if (start+6 != x_at)
/*                if (end_x != (size_x-1))
                    GrDrawHLine(gstate, start, y_at, x_at) ;
                else */
                    GrDrawHLine(gstate, start, y_at, x_at-6) ;
        }
    }

    x_at = 6 * start_x ;
    for (x=start_x; x<=end_x; x++, x_at += 6)  {
        y_at = 6 * start_y ;
        on_off_flag = FALSE ;
        if ((x&1)==0)  {
        for (y=start_y;y<=end_y; y++, y_at += 6)  {
            pos = quick_maze(x, y) ;
            if (on_off_flag)  {
                if (maze[pos]&MAZE_BIT_ONCE)  {
                    if (y_at-6 != start)
                        GrDrawVLine(gstate, x_at, start, y_at-6) ;
                    on_off_flag = FALSE ;
                }
            } else {
                if (!(maze[pos]&MAZE_BIT_ONCE))  {
                    on_off_flag = TRUE ;
                    start = y_at ;
                }
            }
        }
        if (on_off_flag)
            if (start+6 != y_at)
/*                if (end_y != (size_y-1))
                    GrDrawVLine(gstate, x_at, start, y_at) ;
                else */
                    GrDrawVLine(gstate, x_at, start, y_at-6) ;
        }
    }

    GrSetAreaColor(gstate,
        colors[MAZE_COLOR_TRAIL].CQ_info,
        colors[MAZE_COLOR_TRAIL].CQ_redOrIndex,
        colors[MAZE_COLOR_TRAIL].CQ_green,
        colors[MAZE_COLOR_TRAIL].CQ_blue) ;
    y_at = 6*start_y ;
    for (y=start_y; y<=end_y; y++, y_at += 6)  {
        x_at = 6*start_x ;
        pos = quick_maze(start_x, y) ;
        for (x=start_x;x<=end_x; x++, pos++, x_at+=6)  {
            if (maze[pos]&MAZE_BIT_TRAVELED)
                GrFillRect(gstate, x_at-2, y_at-2, x_at+2, y_at+2) ;
        }
    }

    GrSetAreaColor(gstate,
        colors[MAZE_COLOR_SOLUTION].CQ_info,
        colors[MAZE_COLOR_SOLUTION].CQ_redOrIndex,
        colors[MAZE_COLOR_SOLUTION].CQ_green,
        colors[MAZE_COLOR_SOLUTION].CQ_blue) ;
    y_at = 6*start_y ;
    for (y=start_y; y<=end_y; y++, y_at += 6)  {
        x_at = 6*start_x ;
        pos = quick_maze(start_x, y) ;
        for (x=start_x;x<=end_x; x++, pos++, x_at+=6)  {
            if (maze[pos]&MAZE_BIT_SOL_ONCE)
	   //        GrFillRect(gstate, x_at-1, y_at-1, x_at+1, y_at+1) ;
                GrFillRect(gstate, x_at-2, y_at-2, x_at+2, y_at+2) ;
	   }
    }

    if (game_mode)  {
        GrSetLineColor(gstate,
            colors[MAZE_COLOR_PLAYER_PIECE].CQ_info,
            colors[MAZE_COLOR_PLAYER_PIECE].CQ_redOrIndex,
            colors[MAZE_COLOR_PLAYER_PIECE].CQ_green,
            colors[MAZE_COLOR_PLAYER_PIECE].CQ_blue) ;
        GrSetLineWidth(gstate, MakeWWFixed(2.0)) ;
        x_at = 6*pos_x ;
        y_at = 6*pos_y ;
        GrDrawRect(gstate, x_at-3, y_at-3, x_at+3, y_at+3) ;
    }
}
/*-------------------------------------------------------------------------*/
void MazePlaySound(MemHandle soundHandle)
{
 word 		tempo = 8;


	 if (g_sound == SOUND_SYSTEM)
		 /* this routine abides by syst sound setting */
		 UserStandardSound(SST_CUSTOM_SOUND, soundHandle, 1);
	 else if (g_sound == SOUND_OFF)  return;
	 else {
		 /* this routine doesn't check syst sound setting -
		  * but we need to supply the tempo */
		 SoundPlayMusic(soundHandle, SP_GAME, tempo, EOSF_UNLOCK);
		 }
}

/*-------------------------------------------------------------------------*/
@method MazeProcessClass, MSG_GEN_PROCESS_OPEN_APPLICATION
{
 FileHandle fhandle ;
 Boolean		initError, tips;
 word		i;
 dword 		magic;
 
    maze=malloc(MAZE_BUFFER_SIZE);	/* alloc the game board */
    memset(maze, 0, MAZE_BUFFER_SIZE);

    @callsuper() ;

    @call MazeApp::MSG_GEN_APPLICATION_INSTALL_TOKEN();

	 SoundAllocMusic(winSoundBuf, 1, &winSound);
	 SoundAllocMusic(loseSoundBuf, 1, &loseSound);

	 /* check for quick tips */
	 initError = InitFileReadBoolean("Maze", "showTips", &tips);
	 if (initError) tips = TRUE;
	 if (tips) {
		 @send ShowOnStartupGroup::MSG_GEN_BOOLEAN_GROUP_SET_BOOLEAN_STATE(
														 SHOW_ON_STARTUP,
														 TRUE);
		 @send QTipsDialogBox::MSG_GEN_INTERACTION_INITIATE();
		 }
	 else
		 @send ShowOnStartupGroup::MSG_GEN_BOOLEAN_GROUP_SET_BOOLEAN_STATE(
														 SHOW_ON_STARTUP,
														 FALSE);
	 /* check for sound */
	 initError = InitFileReadInteger("Maze", "sound", &g_sound);
	 if (initError) g_sound = SOUND_SYSTEM;
	 @call SoundGroup::MSG_GEN_ITEM_GROUP_SET_SINGLE_SELECTION(g_sound, FALSE) ;


	 FilePushDir() ;
    FileSetCurrentPath(maze_drive, maze_relativePath) ;
    FileCreateDir(maze_path) ;
    FileSetCurrentPath(maze_drive, maze_path) ;
    fhandle = FileOpen(maze_state_file, FILE_ACCESS_R|FILE_DENY_W) ;


    if (fhandle!=NullHandle)  {
        /* Make sure file at beginning */
        FilePos(fhandle, 0, FILE_POS_START) ;
	FileRead(fhandle, &magic, sizeof(dword), FALSE) ;
        if (STATE_FILE_MAGIC == magic) {
            FileRead(fhandle, &size_x, sizeof(word), FALSE) ;
            FileRead(fhandle, &size_y, sizeof(word), FALSE) ;
            FileRead(fhandle, maze, sizeof(byte)*size_x*size_y, FALSE) ;
            FileRead(fhandle, &pos_start, sizeof(word), FALSE) ;
            FileRead(fhandle, &draw_mode, sizeof(word), FALSE) ;
            FileRead(fhandle, &pos_x, sizeof(sword), FALSE) ;
            FileRead(fhandle, &pos_y, sizeof(sword), FALSE) ;
            FileRead(fhandle, &game_mode, sizeof(byte), FALSE) ;
            FileRead(fhandle, &time_sec, sizeof(byte), FALSE) ;
            FileRead(fhandle, &time_min, sizeof(byte), FALSE) ;
            FileRead(fhandle, &time_hour, sizeof(byte), FALSE) ;

            FileRead(fhandle, &player_score, sizeof(word), FALSE) ;
            FileRead(fhandle, &solved, sizeof(Boolean), FALSE) ;
            FileRead(fhandle, colors, sizeof(ColorQuad)*5, FALSE) ;
            }
            
	FileClose(fhandle, FALSE) ;
	}

	 @send MazeSizeXGenValue::MSG_GEN_VALUE_SET_INTEGER_VALUE((1+size_x)>>1, FALSE) ;
	 @send MazeSizeYGenValue::MSG_GEN_VALUE_SET_INTEGER_VALUE((1+size_y)>>1, FALSE) ;

	 @send MazeView::MSG_GEN_VIEW_SET_DOC_BOUNDS(
									 6+(size_y*6),
									 6+(size_x*6),
									 0,
									 0) ;
	 @send MazePrimary::MSG_GEN_SET_WIN_SIZE(
								GET_MM_AND_TYPE(VUM_DELAYED_VIA_APP_QUEUE,WST_AS_DESIRED),
								SST_PIXELS | (20+(size_x*6)),
								SST_PIXELS | (50+(size_y*6)));
	 for (i = 0; i < 5; i++)
		  @send MazeColorControl::MSG_COLOR_SELECTOR_SET_COLOR(colors[i], FALSE) ;
	 @send process::MSG_VIEW_MAZE_NEW() ;

	 FilePopDir() ;
	 @send MazeColorControl::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_UI_QUEUE) ;
	 @send MazePauseTrigger::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_UI_QUEUE) ;
	 @send MazeContTrigger::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_UI_QUEUE) ;
}
/*-------------------------------------------------------------------------*/
@method MazeProcessClass, MSG_GEN_PROCESS_CLOSE_APPLICATION
{
	 FileHandle fhandle ;
	 Boolean		tips;
	 dword 			magic;


    if (timer_going)
		  TimerStop(timer_handle, timer_id) ;
	 timer_going = FALSE ;

	 SoundStopMusic(winSound);
	 SoundFreeMusic(winSound);
	 SoundStopMusic(loseSound);
	 SoundFreeMusic(loseSound);

	 FilePushDir() ;
    FileSetCurrentPath(maze_drive, maze_relativePath) ;
    FileCreateDir(maze_path) ;
    FileSetCurrentPath(maze_drive, maze_path) ;
    FileDelete(maze_state_file) ;

    fhandle = FileCreate(maze_state_file,
              FILE_CREATE_TRUNCATE |
              FILE_ACCESS_RW |
              FILE_DENY_NONE,
              FILE_ATTR_NORMAL) ;

    if (fhandle!=NullHandle)  {
        /* Make sure file at beginning */
        FilePos(fhandle, 0, FILE_POS_START) ;
        magic = STATE_FILE_MAGIC;
        FileWrite(fhandle, &magic, sizeof(dword), FALSE) ;
        FileWrite(fhandle, &size_x, sizeof(word), FALSE) ;
        FileWrite(fhandle, &size_y, sizeof(word), FALSE) ;
        FileWrite(fhandle, maze, sizeof(byte)*size_x*size_y, FALSE) ;
        FileWrite(fhandle, &pos_start, sizeof(word), FALSE) ;
        FileWrite(fhandle, &draw_mode, sizeof(word), FALSE) ;
        FileWrite(fhandle, &pos_x, sizeof(sword), FALSE) ;
        FileWrite(fhandle, &pos_y, sizeof(sword), FALSE) ;
        FileWrite(fhandle, &game_mode, sizeof(byte), FALSE) ;
        FileWrite(fhandle, &time_sec, sizeof(byte), FALSE) ;
        FileWrite(fhandle, &time_min, sizeof(byte), FALSE) ;
        FileWrite(fhandle, &time_hour, sizeof(byte), FALSE) ;

        FileWrite(fhandle, &player_score, sizeof(word), FALSE) ;
        FileWrite(fhandle, &solved, sizeof(Boolean), FALSE) ;
        FileWrite(fhandle, colors, sizeof(ColorQuad)*5, FALSE) ;

        FileClose(fhandle, FALSE) ;
    }
    FilePopDir() ;

	 /* set the quick tips if not default */
	 tips = @call ShowOnStartupGroup::MSG_GEN_BOOLEAN_GROUP_IS_BOOLEAN_SELECTED(
																	 SHOW_ON_STARTUP);
	 InitFileWriteBoolean("Maze", "showTips", tips);
	 InitFileWriteInteger("Maze", "sound", g_sound);

    free (maze); 		/* free the game board */

	 return (@callsuper()) ;
}
/*-------------------------------------------------------------------------*/
@method MazeProcessClass, MSG_MAZE_SOUND_CHANGED
{
	 g_sound = selection ;
}

/*-------------------------------------------------------------------------*/
@method MazeContentClass, MSG_META_EXPOSED
{
    GStateHandle gstate;
    RectDWord    rect ;

/*
    @callsuper() ;
*/

//    @call MazeView::MSG_GEN_VIEW_GET_VISIBLE_RECT(&rect) ;
	 @call MazeView::MSG_GEN_VIEW_GET_DOC_BOUNDS(&rect);
	 gstate = GrCreateState(win);
    GrBeginUpdate(gstate);

    GrSetAreaColor(gstate,
        colors[MAZE_COLOR_BACKGROUND].CQ_info,
        colors[MAZE_COLOR_BACKGROUND].CQ_redOrIndex,
        colors[MAZE_COLOR_BACKGROUND].CQ_green,
        colors[MAZE_COLOR_BACKGROUND].CQ_blue) ;
    GrFillRect(gstate, 0, 0, 2000, 2000) ;

    MazeDraw(gstate,&rect);

    GrEndUpdate(gstate);
	 GrDestroyState(gstate);


}
/*-------------------------------------------------------------------------*/
@method MazeProcessClass, MSG_VIEW_INVALIDATE
{
    WindowHandle win ;
    GStateHandle gstate ;

    win = @call MazeView::MSG_GEN_VIEW_GET_WINDOW() ;
    gstate = GrCreateState(win) ;
    GrInvalRect(gstate, 0, 0, 2000,2000) ;
    GrDestroyState(gstate) ;
    @call MazeContent::MSG_VIS_INVALIDATE();
}
/*-------------------------------------------------------------------------*/
@method MazeProcessClass, MSG_VIEW_MAZE_NEW
{
    MazeMake(maze, size_x, size_y) ;
    @call process::MSG_VIEW_INVALIDATE() ;
    @call MazeView::MSG_GEN_UPDATE_VISUAL(VUM_NOW) ;
    solved = FALSE ;
    @call MazeSolveTrigger::MSG_GEN_SET_ENABLED(VUM_NOW) ;
    pos_x = pos_y = 1000 ;
    game_mode = 0 ;
    if (timer_going)
        TimerStop(timer_handle, timer_id) ;
    @call MazeTimer::MSG_MAZE_RESET_TIMER() ;
}
/*-------------------------------------------------------------------------*/
@method MazeProcessClass, MSG_VIEW_MAZE_NEW_AND_PLAY
{

    if (gray_screen)  /* unpause the game first if it was paused */
		@call oself::MSG_MAZE_CONT();
    if (FALSE==playOnly)
    		@call oself::MSG_VIEW_MAZE_NEW() ;
    @call oself::MSG_MAZE_PLAY_GAME() ;
    @send MazePauseTrigger::MSG_GEN_SET_ENABLED(VUM_NOW) ;
    @send MazeContTrigger::MSG_GEN_SET_NOT_ENABLED(VUM_NOW) ;
}
/*-------------------------------------------------------------------------*/
@method MazeProcessClass, MSG_MAZE_VIEW_MODE_1
{
    draw_mode = 0 ;
    @call process::MSG_VIEW_INVALIDATE() ;
    @call MazeView::MSG_GEN_UPDATE_VISUAL(VUM_NOW) ;
}
/*-------------------------------------------------------------------------*/
@method MazeProcessClass, MSG_MAZE_VIEW_MODE_2
{
    draw_mode = 1 ;
    @call process::MSG_VIEW_INVALIDATE() ;
    @call MazeView::MSG_GEN_UPDATE_VISUAL(VUM_NOW) ;
}
/*-------------------------------------------------------------------------*/
@method MazeProcessClass, MSG_MAZE_SIZE_CHANGED
{
    word x, y ;
    word answer = IC_YES ;

    x = @call MazeSizeXGenValue::MSG_GEN_VALUE_GET_INTEGER_VALUE() ;
    y = @call MazeSizeYGenValue::MSG_GEN_VALUE_GET_INTEGER_VALUE() ;
    x <<= 1 ;
    y <<= 1 ;
    x-- ;
    y-- ;

    if ((x != size_x) || (y != size_y))  {
        if (game_mode == 1)  {
            answer = UserStandardDialogOptr(
                NullOptr,
                NullOptr,
                NullOptr,
                NullOptr,
		        @MazeNewGameMsg,
		        (CDT_QUESTION << CDBF_DIALOG_TYPE_OFFSET) |
		        (GIT_AFFIRMATION << CDBF_INTERACTION_TYPE_OFFSET));
        }
        if (answer == IC_YES)  {
            size_x = x ;
            size_y = y ;

            @send process::MSG_VIEW_MAZE_NEW() ;
				@send MazeView::MSG_GEN_VIEW_SET_DOC_BOUNDS(
                                6+(size_y*6),
										  6+(size_x*6),
										  0,
                                0) ;
  //				@send MazeView::MSG_GEN_VIEW_REDRAW_CONTENT();
  				@send MazeWholeGroup::MSG_GEN_SET_NOT_USABLE(VUM_NOW);
				@send MazeWholeGroup::MSG_GEN_SET_USABLE(VUM_NOW);
	 /* try this */
/*	 @send MazePrimary::MSG_GEN_SET_WIN_POSITION(
								GET_MM_AND_TYPE(VUM_DELAYED_VIA_APP_QUEUE,WPT_CENTER),
								0,
								0);  */
	 @send MazePrimary::MSG_GEN_SET_WIN_SIZE(
								GET_MM_AND_TYPE(VUM_DELAYED_VIA_APP_QUEUE,WST_AS_DESIRED),
								SST_PIXELS | (20+(size_x*6)),
								SST_PIXELS | (50+(size_y*6)));
		  } else {
            @call MazeSizeXGenValue::MSG_GEN_VALUE_SET_INTEGER_VALUE((1+size_x)>>1, FALSE) ;
            @call MazeSizeYGenValue::MSG_GEN_VALUE_SET_INTEGER_VALUE((1+size_y)>>1, FALSE) ;
        }
    }
}
/*-------------------------------------------------------------------------*/
@method MazeViewClass, MSG_GEN_VIEW_CALC_WIN_SIZE {
     sword newWidth, newHeight;
     
/* 	  if (width == RSA_CHOOSE_OWN_SIZE && height == RSA_CHOOSE_OWN_SIZE)
     {
          newWidth = width;             /* we want some real values! */
/*			 newHeight = height;           /* try again when you're ready */
/*	  }
     else
     {
*/			 newWidth = 6+(size_x*6);
			 newHeight = 6+(size_y*6);
/*	  }
*/     return MAKE_SIZE_DWORD(newWidth, newHeight);
}

/*-------------------------------------------------------------------------*/
@method MazeProcessClass, MSG_MAZE_MOVE_RIGHT
{
    int i ;
    word pos ;
    int count = 2;

   if (game_mode) {
    if ((pos_x != 1000)&&(pos_x<size_x))  {
        if ((pos_x&1)==0)
            count-- ;
        for (i=0; i<count; i++)  {
            pos = quick_maze(pos_x+1, pos_y) ;
            if ((maze[pos]&MAZE_BIT_ONCE)&&(pos_y<size_y))  {
                if (i==0)
                    @call process::MSG_MAZE_MOVE_REDRAW_AROUND() ;
                pos = quick_maze(pos_x, pos_y) ;
                maze[pos] |= MAZE_BIT_TRAVELED ;
                pos_x++ ;
                @call process::MSG_MAZE_MOVE_REDRAW_AROUND() ;
            }
        }
    }
   } /* end game_mode if */
}
/*-------------------------------------------------------------------------*/
@method MazeProcessClass, MSG_MAZE_MOVE_LEFT
{
    int i ;
    word pos ;
    int count = 2;

   if (game_mode) {
    if ((pos_x != 1000)&&(pos_x>0))  {
        if ((pos_x&1)==0)
            count-- ;
        for (i=0; i<count; i++)  {
            pos = quick_maze(pos_x-1, pos_y) ;
            if ((maze[pos]&MAZE_BIT_ONCE)&&(pos_x>0))  {
                if (i==0)
                    @call process::MSG_MAZE_MOVE_REDRAW_AROUND() ;
                pos = quick_maze(pos_x, pos_y) ;
                maze[pos] |= MAZE_BIT_TRAVELED ;
                pos_x-- ;
                @call process::MSG_MAZE_MOVE_REDRAW_AROUND() ;
            }
        }
    }
   } /* end game_mode if */
}
/*-------------------------------------------------------------------------*/
@method MazeProcessClass, MSG_MAZE_MOVE_UP
{
    int i ;
    word pos ;
    int count = 2;

   if (game_mode) {
    if ((pos_y != 1000)&&(pos_y>0))  {
        if ((pos_y&1)==0)
            count-- ;
        for (i=0; i<count; i++)  {
            pos = quick_maze(pos_x, pos_y-1) ;
            if ((maze[pos]&MAZE_BIT_ONCE)&&(pos_y>0))  {
                if (i==0)
                    @call process::MSG_MAZE_MOVE_REDRAW_AROUND() ;
                pos = quick_maze(pos_x, pos_y) ;
                maze[pos] |= MAZE_BIT_TRAVELED ;
                pos_y-- ;
                @call process::MSG_MAZE_MOVE_REDRAW_AROUND() ;
            }
        }
    }
   } /* end game_mode if */
}
/*-------------------------------------------------------------------------*/
@method MazeProcessClass, MSG_MAZE_MOVE_DOWN
{
    int i ;
    word pos ;
    int count = 2;

   if (game_mode) {
    if ((pos_x != 1000)&&(pos_y<size_y))  {
        if ((pos_y&1)==0)
            count-- ;
        for (i=0; i<count; i++)  {
            pos = quick_maze(pos_x, pos_y+1) ;
            if ((maze[pos]&MAZE_BIT_ONCE)&&(pos_y<size_y))  {
                if (i==0)
                    @call process::MSG_MAZE_MOVE_REDRAW_AROUND() ;
                pos = quick_maze(pos_x, pos_y) ;
                maze[pos] |= MAZE_BIT_TRAVELED ;
                pos_y++ ;
                @call process::MSG_MAZE_MOVE_REDRAW_AROUND() ;
            }
        }
    }
   } /* end game_mode if */
}
/*-------------------------------------------------------------------------*/
@method MazeProcessClass, MSG_MAZE_MOVE_REDRAW_AROUND
{
    WindowHandle win ;
    GStateHandle gstate ;
    RectDWord    rect = {0,0,2000,2000} ;

    if (draw_mode == 0)  {
        rect.RD_left = 6*(sword)pos_x-1 ;
        rect.RD_top = 6*(sword)pos_y-1 ;
        rect.RD_right = 6*(sword)pos_x+7 ;
        rect.RD_bottom = 6*(sword)pos_y+7 ;
    } else {
        rect.RD_left = 6*(sword)pos_x-5 ;
        rect.RD_top = 6*(sword)pos_y-5 ;
        rect.RD_right = 6*(sword)pos_x+7 ;
        rect.RD_bottom = 6*(sword)pos_y+7 ;
    }

    if (rect.RD_left<0)
        rect.RD_left = 0 ;
    if (rect.RD_top<0)
        rect.RD_top = 0 ;

    win = @call MazeView::MSG_GEN_VIEW_GET_WINDOW() ;
    gstate = GrCreateState(win) ;

/*
    GrApplyTranslation(gstate, MakeWWFixed(3.0), MakeWWFixed(3.0)) ;
    GrInvalRectDWord(gstate, &rect) ;
*/
    MazeDraw(gstate, &rect) ;
    GrDestroyState(gstate) ;

    /* Check if we reached the right side */
    if (pos_x == (size_x-1))
        @call process::MSG_MAZE_COMPLETED() ;
    @send process::MSG_MAZE_CHECK_POSITION() ;
}
/*-------------------------------------------------------------------------*/
@method MazeViewClass, MSG_META_KBD_CHAR
{
    if (!(flags&CF_RELEASE))  {
        if (((character&0xFF00)==0)||((character&0xFF00)==0xFF00))  {
            switch(character&255)  {
                case ';':
                case '4':
                case 'a':
                case 'j':
                case 'A':
                case 'J':
                case 0x93:
                    @call process::MSG_MAZE_MOVE_LEFT() ;
                    break ;
                case '[':
                case '8':
                case 'w':
                case 'i':
                case 'W':
                case 'I':
                case 0x90:
                    @call process::MSG_MAZE_MOVE_UP() ;
                    break ;
                case '\/':
                case '2':
                case 'z':
                case 'm':
                case 'Z':
                case 'M':
                case 0x91:
                    @call process::MSG_MAZE_MOVE_DOWN() ;
                    break ;
                case '\'':
                case '6':
                case 's':
                case 'k':
                case 'S':
                case 'K':
                case 0x92:
                    @call process::MSG_MAZE_MOVE_RIGHT() ;
                    break ;
                default:
                    @callsuper() ;
                    break ;
            }
        }
    } ;
}
/*-------------------------------------------------------------------------*/
@method MazeContentClass, MSG_META_PTR
{
    sword deltax, deltay ;
    sword signx=1, signy=1 ;
    word inside ;

    if ((inputState&BI_B0_DOWN)&&(game_mode))  {
        switch (draw_mode)  {
            case 0:  inside = 3 ;
                     break ;
            case 1:  inside = 6 ;
                     break ;
        }
        if (((int)xPosition+(int)inside-6)<0)
            xPosition = 6 ;
        if (((int)yPosition+(int)inside-6)<0)
            yPosition = 6 ;
        deltax = ((((xPosition+inside-6)/12))<<1)-pos_x+1 ;
        deltay = ((((yPosition+inside-6)/12))<<1)-pos_y+1 ;
        if ((deltax!=0)||(deltay!=0))  {
            if (deltax<0)  {
                deltax = -deltax ;
                signx = -1 ;
            }
            if (deltay<0)  {
                deltay = -deltay ;
                signy = -1 ;
            }

            if (deltax>deltay)  {
                if (signx==1) {
                    @send process::MSG_MAZE_MOVE_RIGHT() ;
                } else {
                    @send process::MSG_MAZE_MOVE_LEFT() ;
                }
            } else {
                if (signy==1) {
                    @send process::MSG_MAZE_MOVE_DOWN() ;
                } else {
                    @send process::MSG_MAZE_MOVE_UP() ;
                }
            }
        }
    } else {
        @callsuper() ;
    }
    retVal->flags = MRF_PROCESSED ;
}
/*-------------------------------------------------------------------------*/
@method MazeProcessClass, MSG_MAZE_PLAY_GAME
{
    if (solved)
        @call process::MSG_VIEW_MAZE_NEW() ;
    if (!game_mode)  {
        if (ClearPlayerTrail())
            @call process::MSG_VIEW_INVALIDATE() ;
        pos_x = 0 ;
        pos_y = pos_start ;
        game_mode = 1 ;
        @call process::MSG_MAZE_MOVE_REDRAW_AROUND() ;
        @call MazeTimer::MSG_MAZE_RESET_TIMER() ;
        timer_handle = TimerStart(TIMER_EVENT_CONTINUAL,
                                  @MazeTimer,
                                  80,
                                  MSG_MAZE_TIMER_CHANGE,
                                  60,
                                  &timer_id) ;
        timer_going = TRUE ;
    }

    @call process::MSG_MAZE_UPDATE_SCORE() ;
}
/*-------------------------------------------------------------------------*/
@method MazeProcessClass, MSG_META_CLIPBOARD_COPY
{
    ClipboardItemHeader *headerMem ;
    MemHandle           headerMemHandle ;
    VMFileHandle        transferVMFile ;
    VMBlockHandle       dataVMBlock ;
    VMBlockHandle       headerVMBlock ;
    GStateHandle        gstate;
    RectDWord           rect = {0,0,2000,2000} ;

    @send MazeApp::MSG_GEN_APPLICATION_MARK_BUSY() ;
    transferVMFile = ClipboardGetClipboardFile() ;

    gstate = GrCreateGString(transferVMFile, GST_VMEM, &dataVMBlock);
    MazeDraw(gstate,&rect);
    GrEndGString(gstate);

    headerVMBlock = VMAlloc(transferVMFile, sizeof(ClipboardItemHeader), 1111) ;
    headerMem = (ClipboardItemHeader *)VMLock(
                 transferVMFile, headerVMBlock, &headerMemHandle) ;
    headerMem->CIH_owner = ConstructOptr(GeodeGetProcessHandle(), 0) ;
    headerMem->CIH_flags = 0 ;
    headerMem->CIH_name[0] = 'M' ;
    headerMem->CIH_name[1] = 'a' ;
    headerMem->CIH_name[2] = 'z' ;
    headerMem->CIH_name[3] = 'e' ;
    headerMem->CIH_name[4] = '\0' ;
    headerMem->CIH_formatCount = 1;
    headerMem->CIH_sourceID = 0 ;
    headerMem->CIH_formats[0].CIFI_format =
        FormatIDFromManufacturerAndType(
             MANUFACTURER_ID_GEOWORKS,
             CIF_GRAPHICS_STRING) ;
    headerMem->CIH_formats[0].CIFI_vmChain =
        (VMChain)(((dword)(dataVMBlock))<<16L) ;
    headerMem->CIH_formats[0].CIFI_extra1 = 0 ;
    headerMem->CIH_formats[0].CIFI_extra2 = 0 ;
    VMUnlock(headerMemHandle) ;
    ClipboardRegisterItem(BlockIDFromFileAndBlock(transferVMFile,
        headerVMBlock),
        0) ;
    @send MazeApp::MSG_GEN_APPLICATION_MARK_NOT_BUSY() ;
}
/*-------------------------------------------------------------------------*/
@method MazeProcessClass, MSG_MAZE_COMPLETED
{
    word id ;

    if (timer_going)
        TimerStop(timer_handle, timer_id) ;
    solved = TRUE ;
    game_mode = 0 ;
    TimerStart(
        TIMER_EVENT_ONE_SHOT,
        oself,
        5,
        MSG_MAZE_COMPLETED2,
        0,
        &id) ;
}
/*-------------------------------------------------------------------------*/
@method MazeProcessClass, MSG_MAZE_COMPLETED2
{

	 MazePlaySound(winSound);
	 UserDoDialog(@MazeCompletedBox) ;
    pos_x = pos_y = 1000 ;
    @call process::MSG_VIEW_INVALIDATE() ;
	 @send HighScoreControl::MSG_HIGH_SCORE_ADD_SCORE(
												  (dword) player_score, 0);

}
/*-------------------------------------------------------------------------*/
@method MazeProcessClass, MSG_MAZE_CHECK_POSITION
{
    RectDWord    rect ;
    word         x_at=0, y_at=0 ;
    sdword       origin_x, origin_y ;
    sdword       width_x, width_y ;

    if ((x_at != 1000) && (y_at != 1000))  {
        x_at = pos_x*6 ;
        y_at = pos_y*6 ;

        @call MazeView::MSG_GEN_VIEW_GET_VISIBLE_RECT(&rect) ;

    /* Check if we are off in the X direction.  If so, align position
       so that player piece is in middle of x view */
        if (((rect.RD_left+30)>x_at)||((rect.RD_right-30)<x_at))  {
            width_x = rect.RD_right - rect.RD_left ;
            origin_x = x_at - (width_x>>1) ;
            if (origin_x < 0)
                origin_x = 0 ;
            @send MazeView::MSG_GEN_VIEW_SCROLL_SET_X_ORIGIN(origin_x) ;
        }

    /* Check if we are off in the Y direction.  If so, align position
       so that player piece is in middle of y view */
        if (((rect.RD_top+30)>y_at)||((rect.RD_bottom-30)<y_at))  {
            width_y = rect.RD_bottom - rect.RD_top ;
            origin_y = y_at - (width_y>>1) ;
            if (origin_y < 0)
                origin_y = 0 ;
            @send MazeView::MSG_GEN_VIEW_SCROLL_SET_Y_ORIGIN(origin_y) ;
        }
    }
}
/*-------------------------------------------------------------------------*/
@method MazeTimerClass, MSG_MAZE_CHANGE_TIME
{
	 char new_time[10] ;

	 new_time[0] = '0'+time_hour/10;
	 new_time[1] = '0'+time_hour%10;
	 new_time[2] = ':';

	 new_time[3] = '0'+time_min/10;
	 new_time[4] = '0'+time_min%10;
	 new_time[5] = ':';

	 new_time[6] = '0'+time_sec/10;
	 new_time[7] = '0'+time_sec%10;
	 new_time[8] = 0;


    @call MazeTimer::MSG_GEN_REPLACE_VIS_MONIKER_TEXT(new_time, VUM_NOW) ;
}
/*-------------------------------------------------------------------------*/
@method MazeTimerClass, MSG_MAZE_TIMER_CHANGE
{
    time_sec++ ;
    if (time_sec==60)  {
        time_sec = 0 ;
        time_min++ ;
        if (time_min==60)  {
            time_min = 0 ;
            time_hour++ ;
            if (time_hour == 100)  {
                time_hour = 0 ;
            }
        }
    }
    @send MazeTimer::MSG_MAZE_CHANGE_TIME() ;
    @send process::MSG_MAZE_UPDATE_SCORE() ;
}
/*-------------------------------------------------------------------------*/
@method MazeTimerClass, MSG_MAZE_RESET_TIMER
{
    time_sec = time_min = time_hour = 0 ;
    @send MazeTimer::MSG_MAZE_CHANGE_TIME() ;
    @call process::MSG_MAZE_UPDATE_SCORE() ;
}
/*-------------------------------------------------------------------------*/
@method MazeProcessClass, MSG_MAZE_SOLVE
{
	 if (timer_going)
		  TimerStop(timer_handle, timer_id) ;
	 solved = TRUE ;
    @call MazeSolveTrigger::MSG_GEN_SET_NOT_ENABLED(VUM_NOW) ;
    game_mode = 0 ;
    SolveMaze() ;
    @send process::MSG_VIEW_INVALIDATE() ;
}
/*-------------------------------------------------------------------------*/
/*@method MazeAppClass, MSG_META_LOST_TARGET_EXCL
{

    if (timer_going)
        TimerStop(timer_handle, timer_id) ;
    timer_going = FALSE ;
    if (game_mode == 1)  {
        gray_screen = TRUE ;
        @call MazeView::MSG_GEN_SET_NOT_USABLE(VUM_NOW) ;
        @call MazeLostFocusGlyph::MSG_GEN_SET_USABLE(VUM_DELAYED_VIA_UI_QUEUE) ;
    }
    @callsuper() ;
}
/*-------------------------------------------------------------------------*/
/*@method MazeAppClass, MSG_META_GAINED_TARGET_EXCL
{
    gray_screen = FALSE ;
    if (game_mode==1)  {
        if (timer_going == FALSE)  {
            timer_handle = TimerStart(TIMER_EVENT_CONTINUAL,
                                  @MazeTimer,
                                  120,
                                  MSG_MAZE_TIMER_CHANGE,
                                  60,
                                  &timer_id) ;
            timer_going = TRUE ;
        }
    }
    @call MazeLostFocusGlyph::MSG_GEN_SET_NOT_USABLE(VUM_NOW) ;
    @call MazeView::MSG_GEN_SET_USABLE(VUM_DELAYED_VIA_UI_QUEUE) ;
    @callsuper() ;
}
/*-------------------------------------------------------------------------*/
@method MazeProcessClass, MSG_MAZE_UPDATE_SCORE
{
    char buffer[30] ;
    sword score_time ;
    word max_score ;

    max_score = ((size_x>>1)*(size_y>>1)) ;
    score_time = ((sword)time_hour)*3600 + ((sword)time_min)*60 + ((sword)time_sec) ;
	 score_time = max_score - score_time;

	 player_score = score_time ;
	 sprintf(buffer, "%d", player_score);
	 @call MazeScore::MSG_GEN_REPLACE_VIS_MONIKER_TEXT(buffer, VUM_NOW) ;

	 if (score_time == 0)  {
		  /* ran out of time */
		  if (timer_going) {
				TimerStop(timer_handle, timer_id) ;
				timer_going = FALSE;
				}
		  game_mode = 0;
	     MazePlaySound(loseSound);
		  UserDoDialog(@MazeTimeRanOutBox);
	 }

}
/*-------------------------------------------------------------------------*/
@method MazeProcessClass, MSG_PROCESS_COLOR_CHOICE_CHANGED
{
    color_choice = selection ;
    @send MazeColorControl::MSG_COLOR_SELECTOR_SET_COLOR(colors[color_choice], FALSE) ;
}
/*-------------------------------------------------------------------------*/
@method MazeProcessClass, MSG_META_COLORED_OBJECT_SET_COLOR
{
    colors[color_choice] = colorQuad ;
/*
    if (color_choice == MAZE_COLOR_BACKGROUND)  {
        @call MazeView::MSG_GEN_VIEW_SET_COLOR(
                  colors[MAZE_COLOR_BACKGROUND].CQ_redOrIndex,
                  colors[MAZE_COLOR_BACKGROUND].CQ_info,
                  ((word)(((word)colors[MAZE_COLOR_BACKGROUND].CQ_blue)<<8)|
                      ((word)colors[MAZE_COLOR_BACKGROUND].CQ_green))) ;
    }
*/
    @send process::MSG_VIEW_INVALIDATE() ;
}
/*-------------------------------------------------------------------------*/
@method MazePauseInterClass, MSG_VIS_DRAW
{
    Rectangle rect;

    @call oself::MSG_VIS_GET_BOUNDS(&rect) ;
    GrSaveState(gstate) ;
    GrSetLineWidth(gstate, MakeWWFixed(1.0)) ;
    GrSetLineColor(gstate, CF_INDEX, C_BLACK, 0, 0) ;
    GrSetAreaColor(gstate, CF_INDEX, C_WHITE, 0, 0) ;
    GrDrawRect(gstate,
        rect.R_left-1,
        rect.R_top-1,
        rect.R_right+2,
        rect.R_bottom+2) ;
    GrFillRect(gstate,
        rect.R_left-2,
        rect.R_top-2,
        rect.R_right+1,
        rect.R_bottom+1) ;
    GrDrawRect(gstate,
        rect.R_left-2,
        rect.R_top-2,
        rect.R_right+1,
        rect.R_bottom+1) ;
    GrRestoreState(gstate) ;

    @callsuper() ;
}
/*-------------------------------------------------------------------------*/
@method MazeProcessClass, MSG_MAZE_PAUSE
{

	  if (timer_going)
		TimerStop(timer_handle, timer_id) ;
	  timer_going = FALSE ;
	  if (game_mode == 1)  {
		gray_screen = TRUE ;
		@call MazeView::MSG_GEN_SET_NOT_USABLE(VUM_NOW) ;
		@call MazeLostFocusGlyph::MSG_GEN_SET_USABLE(VUM_DELAYED_VIA_UI_QUEUE) ;
		@call MazeContTrigger::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_UI_QUEUE) ;
		@call MazePauseTrigger::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_UI_QUEUE) ;
		}
}

/*-------------------------------------------------------------------------*/
@method MazeProcessClass, MSG_MAZE_CONT
{
	  gray_screen = FALSE ;
	  if (game_mode==1)  {
		if (timer_going == FALSE)  {
		   timer_handle = TimerStart(TIMER_EVENT_CONTINUAL,
						    @MazeTimer,
						    120,
						    MSG_MAZE_TIMER_CHANGE,
						    60,
						    &timer_id) ;
		   timer_going = TRUE ;
		   }
		}
	  @call MazeLostFocusGlyph::MSG_GEN_SET_NOT_USABLE(VUM_NOW) ;
	  @call MazeView::MSG_GEN_SET_USABLE(VUM_DELAYED_VIA_UI_QUEUE) ;
	  @call MazePauseTrigger::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_UI_QUEUE) ;
	  @call MazeContTrigger::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_UI_QUEUE) ;
}



/*-------------------------------------------------------------------------*/

