/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	Copyright (c) Derrick Renaud 1994 -- All Rights Reserved

PROJECT:        Battle Raft     
MODULE:         Battle Raft application
FILE:           battle.goc

AUTHOR:         Derrick Renaud, January 31, 1994

REVISION HISTORY:
	Name    Date            Description
	----    ----            -----------
	DR      1/31/94         Initial version. 1.0
	DR      2/7/94          Rev 1.1 added monochrome fix
				 and fast log drawing.
				Added skill levels. (Beginner and
				 Intermediate)
	DR      3/14/94         Rev 1.2 added board size and 
				 scale to fit viewing.

DESCRIPTION:    This application is a game similar to Battle Ship.

***********************************************************************/


/***********************************************************************
 *              Include files
 ***********************************************************************/

#include <Ansi/string.h>
/* #include <initfile.h> */
@include <stdapp.goh>   /* standard application inclusion file */
@include <math.goh>     /* need for random numbers */
#include <gstring.h>    /* needed for the icons */
#include <sound.h>      /* needed for custom notes */
@include "battle.goh"   /* the icons for the application */

/***********************************************************************
 *              Definitions
 ***********************************************************************/


#define FIRST_HORIZ     1       /* First screen location of grid 0,0 */
#define FIRST_VERT      1
#define BATTLE_BLOCK    20      /* Pts till next grid line */
#define NO_OF_LOGS      5       /* Logs to cover grid location */
#define LOG_SIZE        4       /* Width of logs */
#define LOG_LENGTH      16
#define LOG_CURVE       2       /* Radius of log end */
#define NO_OF_BLOCKS    20      /* MAX # of x-y grid locations */

#define BATTLE_GRID_MINIMUM     10
#define BATTLE_GRID_MAXIMUM     20
#define BATTLE_GRID_START       12
#define BATTLE_GRID_INC         2

/* Start Total length of grid */
#define BOARD_LENGTH		BATTLE_GRID_START * BATTLE_BLOCK +1

#define NO_OF_RAFTS      5

#define BR_EMPTY        0
#define BR_ROCK         0x80
#define BR_RAFT_MASK    7       /* Bit locations of raft */

#define BR_2MAN         1       /* Raft Types */
#define BR_3MAN1        2
#define BR_3MAN2        3
#define BR_4MAN         4  
#define BR_5MAN         5  

#define COMP_DIRECTION_N        1   /* Search directions */
#define COMP_DIRECTION_E        2
#define COMP_DIRECTION_S        3
#define COMP_DIRECTION_W        4

#define PBP_HORIZONTAL  1       /* Direction for raft */
#define PBP_VERTICAL    0

				/* Game Status Flags */
#define BR_GAME_NEW     0       /* Rafts can be moved */
#define BR_GAME_STARTED 1       /* You can take shots */
#define BR_GAME_OVER    2       /* Wait for new game trigger */

#define TURN_PLAYER     0       /* Flag to keep track of who's turn */
#define TURN_COMPUTER   1       /* it is. Gotta take turns you know */

//#define BATTLE_MONOCHROME_DISPLAY       0x0001
#define BATTLE_DRAW_LOGS                0x0002

/* Skill Levels */
#define BATTLE_LEVEL_BEGINNER           1
#define BATTLE_LEVEL_INTERMEDIATE       2

  int gridSize = BATTLE_GRID_START;
  int battleStarted = BR_GAME_OVER;
  int battleTurn = TURN_PLAYER;
  word battleRaftSetup = BATTLE_DRAW_LOGS;
  int skillLevel = BATTLE_LEVEL_INTERMEDIATE;
  int shotsOnCheckerBoard = BATTLE_GRID_START * BATTLE_GRID_START / 2;

/***********************************************************************
 *              Class and Message Definitions
 ***********************************************************************/

/* 
 * Declare the application's process object, so that we can add new
 * messages to it later if we like.
 */

@class  BattleProcessClass, GenProcessClass ;
  
  /* define messages for this class here. */

  @message void MSG_NEW_GAME();
    /* 
     * This message is sent by the `New Game` trigger in the Game menu
     * when the user wants to reset the game.  It is sent transfered to
     * the game board objects and causes the board object first to
     * send the "new game" message to each of its children and then
     * to redraw the game board.
     */

  @message int MSG_GET_RANDOM_INT(int randomMax);
    /* Return a random integer from 0 to randomMax */

  @message (GEN_BOOLEAN_GROUP_APPLY_MSG) MSG_BATTLE_CHANGE_SETUP;

  @message (GEN_ITEM_GROUP_APPLY_MSG) MSG_BATTLE_CHANGE_LEVEL;

  @message void MSG_BATTLE_PLAY_END_SOUND(int winner);

  @message (GEN_VALUE_APPLY_MSG) MSG_BATTLE_CHANGE_GRID_SIZE;


@endc

/*  Declare the class in memory so the method table will be built.      */

@classdecl      BattleProcessClass, neverSaved;


/************************************************************************
 *                      BattleBoardClass
 *  This class is a subclass of VisContentClass [Obj 26] and provides
 *  common fields for the 2 game boards.
 ***********************************************************************/

@class  BattleBoardClass, VisContentClass;

  /* Define the instance data fields of this class: */

  /* # of rafts sunk */
  @instance int BP_sunk;

  /* Size of raft @ [type] */
  @instance int BP_size[NO_OF_RAFTS + 1]; /* +1 so I don't gotta -1 later */

  /* # of hits on raft @ [type] */
  @instance int BP_hitCount[NO_OF_RAFTS + 1];
    /* [0] keeps track of misses */

  @instance   unsigned char BR_board[NO_OF_BLOCKS][NO_OF_BLOCKS];
    /*
     * BR_board[y][x] contains empty/rock/raft information.  
     *
     *   7 6 5 4 3 2 1 0
     *   1                      empty                      
     *                          rock
     *             x x x        raft type
     *     x x x x              plenty of room for expansion
     */

  /* Message definitions for this class */

  @message int MSG_BOARD_PLACE_PIECE_CHECK(int x, int y,
		   int size, int direction, int type);
    /*
     * This message is sent by a raft piece that is being moved by the
     * user and is about to be set down. x and y are the proposed grid 
     * locations. The raft's size, direction and type will have to fit 
     * in the grid. The raft cannot be placed on any other raft other
     * then itself. If the raft can be placed, then this message returns
     * TRUE. Any conflicts and FALSE will be returned.
     */

  @message void MSG_BOARD_PLACE_PIECE(int x, int y,
		   int size, int direction, int type);
    /*
     * This message is sent by a raft piece that is being moved by the
     * user and is able to be set down. x and y are the grid 
     * locations. The raft's size, direction and type are used to fill 
     * the grid.
     */

  @message int MSG_BOARD_CHECK_GRID(int x, int y);
    /*
     * This message is returns the value in the grid.
     */

  @message void MSG_BOARD_NEW_GAME();
    /* 
     * This message will notify the board to reset itself.
     */

@endc

@classdecl      BattleBoardClass;


/************************************************************************
 *                      PlayerBattleBoardClass
 *  This class is a subclass of BattleBoardClass and will control the
 *  action on the left side of the screen.
 ***********************************************************************/

@class  PlayerBattleBoardClass, BattleBoardClass;

  @instance int compLastX;            /* Last search location */

  @instance int compLastY;

  @instance int compStartDirection;   /* Direction search started at */

  @instance int compDirection;        /* Current search direction */

  @instance int compDirectionSpin;    /* Direction to rotate search */

  @instance int compWorkingOnHit;     /* Last shot was a hit flag */

  @instance int compProgress;         /* Progress was made in last search */

  @message void MSG_COMPUTER_MAKE_SHOT();
    /* Place a computer piece on the gameboard */

@endc

@classdecl      PlayerBattleBoardClass;


/************************************************************************
 *                      ComputerBattleBoardClass
 *  This class is a subclass of BattleBoardClass and will control the
 *  action on the right side of the screen.
 ***********************************************************************/

@class  ComputerBattleBoardClass, BattleBoardClass;

@endc

@classdecl      ComputerBattleBoardClass;


/************************************************************************
 *                      PlayerBattlePieceClass
 *  This class is a subclass of VisClass [Obj 24] and provides all the
 *  functions necessary for a game piece in the game.
 ***********************************************************************/

@class  PlayerBattlePieceClass, VisClass;

  @instance   char PBP_type;
    /*
     * PBP_type defines what type of piece it is.  
     */

  @instance   char PBP_size;
    /*
     * PBP_size defines how long the raft is.  
     */

  @instance   Boolean PBP_direction;
    /*
     * PBP_direction defines wheither the raft is horizontal  
     * or vertical.
     */
 
  @instance   int  PBP_vertPos;
    /*
     * PBP_vertPos indicates the current y position of
     * the piece.  This does not indicate the piece's actual
     * bounds but rather where its moving outline appears. 
     */

  @instance   int PBP_horizPos;
    /*  
     * PBP_horizPos indicates the current x position of
     * the piece.  This does not indicate the piece's actual
     * bounds but rather where its moving outline appears. 
     */

  @instance   Boolean PBP_dragging;
    /* Set if user is dragging this piece somewhere around the board */
     
  /* Message definitions unique to this class.  */

  @message void MSG_PLAYER_PIECE_SETUP(int x, int y,
		   int size, int direction, int type);
    /*
     * This message notifies the piece object that it should set itself
     * to the new parameters. Normally sent only when starting a game.
     */

@endc

@classdecl      PlayerBattlePieceClass;



/***********************************************************************
 *              The Application Object
 ***********************************************************************/

@start  AppResource ;

@object GenApplicationClass BattleApp = {
    GI_visMoniker = list { @BattleTextMoniker, 
			   @Moniker0,           /* VGA      */
			   @Moniker2}            /* tiny */

    GI_comp = @BattlePrimary;

    gcnList(MANUFACTURER_ID_GEOWORKS,GAGCNLT_WINDOWS) = @BattlePrimary;
}

@visMoniker BattleTextMoniker = "Battle Raft";

@end    AppResource



/***********************************************************************
 *              The Primary Window Object
 ***********************************************************************/

@start  Interface ;
  /*  
   * The Interface resource block contains all the menu and
   *  generic UI objects of this application including the
   *  Primary window (BattlePrimary).                     
   */

  /*  
   * This is the Primary window of the application.  It should
   * not be opened maximized (GI_states).
   */

@object GenPrimaryClass BattlePrimary  = {
  GI_comp = @BattleFileMenu,
	    @BattleOptionsMenu, 
	    @PlayerBattleView, 
	    @ComputerBattleView,
	    @BRGameOver;
  HINT_ORIENT_CHILDREN_HORIZONTALLY;
  HINT_CENTER_CHILDREN_HORIZONTALLY;
  HINT_CENTER_CHILDREN_VERTICALLY;
  HINT_DIVIDE_WIDTH_EQUALLY;
  ATTR_GEN_HELP_CONTEXT = "Title Page";   
    /* Bring up help at Battle Raft Title Page */
    /* See the end of the file for help on making Help Files */
}


/***********************************************************************
 *              The View Window Objects
 ***********************************************************************/

  /*  
   * These objects provide the window through which the user interacts
   *  with the visible object tree.  This object communicates with the
   *  game board object (a subclass of VisContentClass) to coordinate
   *  drawing, clipping, sizing, and even input handling.
   */

@object GenViewClass PlayerBattleView = {

  GVI_content = PlayerBattleBoard;  
    /* 
     * The content object of this view is the PlayerBattleBoard object,
     * the root object of the visible tree.
     */

  GVI_docBounds = {0, 0, BOARD_LENGTH, BOARD_LENGTH};

  GVI_color = { C_LIGHT_CYAN, 0, 0, 0 };    
    /* The background color of  this view should be light cyan. */

  GVI_horizAttrs = @default   | GVDA_NO_LARGER_THAN_CONTENT
			      | GVDA_SCROLLABLE;
    /* 
     * The horizontal attributes of this view set it to the same
     * size as the game board, and the view is not scrollable.
     */

  GVI_vertAttrs = @default    | GVDA_NO_LARGER_THAN_CONTENT
			      | GVDA_SCROLLABLE;
    /* 
     * The vertical attributes of this view set it to the same
     * size as the game board, and the view is not scrollable.
     */
  HINT_VIEW_REMOVE_SCROLLERS_WHEN_NOT_SCROLLABLE;
}

@object GenViewClass ComputerBattleView = {
  
  GVI_content = ComputerBattleBoard;

  GVI_docBounds = {0, 0, BOARD_LENGTH, BOARD_LENGTH};

  GVI_color = { C_LIGHT_CYAN, 0, 0, 0 };    

  GVI_horizAttrs = @default   | GVDA_NO_LARGER_THAN_CONTENT
			      | GVDA_SCROLLABLE;

  GVI_vertAttrs = @default    | GVDA_NO_LARGER_THAN_CONTENT
			      | GVDA_SCROLLABLE;
  HINT_VIEW_REMOVE_SCROLLERS_WHEN_NOT_SCROLLABLE;
}


/***********************************************************************
 *              The Game Menu and New Game Trigger Objects
 ***********************************************************************/

@object GenInteractionClass BattleFileMenu = {
  GI_visMoniker = 'G', "Game";
  /* We are going to use the standard file menu and just add to it */
  GI_comp = @BattleNewTriggerGroup;
    /* Each GI_comp will be added */
  GII_visibility = GIV_POPUP;         
  ATTR_GEN_INTERACTION_GROUP_TYPE = (GIGT_FILE_MENU);
}

@object GenInteractionClass BattleNewTriggerGroup = {
  GI_comp = @BattleNewTrigger;
}
@object GenTriggerClass BattleNewTrigger = {
  GI_visMoniker = 'N', "New Game";
  GTI_destination = process;      
  GTI_actionMsg = MSG_NEW_GAME;
}

@object GenInteractionClass BattleOptionsMenu = {
  /* Put a menu item 'Options' on menu bar */
  GI_visMoniker = 'O', "Options"; 
  /* We will group setup and levels seperately, but on the same menu */
  GI_comp = @BattleOptionsSetupGroup,
	    @BattleSizeMenu,
	    @BattleOptionsLevelGroup;
  GII_visibility = GIV_POPUP;         
}

@object GenInteractionClass BattleOptionsSetupGroup = {
  GI_comp = @BattleOptionsSetup;
}

@object GenBooleanGroupClass BattleOptionsSetup = {
  GI_comp = /*@BattleOptionsMono, */
	    @BattleOptionsDrawLogs;
  GBGI_selectedBooleans = BATTLE_DRAW_LOGS;
  GBGI_destination = process;
  GBGI_applyMsg = MSG_BATTLE_CHANGE_SETUP;
}

/*@object GenBooleanClass BattleOptionsMono = {
  GI_visMoniker = 'M', "Monochrome";
  GBI_identifier = BATTLE_MONOCHROME_DISPLAY;
}
*/
@object GenBooleanClass BattleOptionsDrawLogs = {
  GI_visMoniker = 'L', "Draw Logs";
  GBI_identifier = BATTLE_DRAW_LOGS;
}

@object GenInteractionClass BattleOptionsLevelGroup = {
  GI_comp = @BattleOptionsLevel;
}

@object GenItemGroupClass BattleOptionsLevel = {          
  GI_comp = @BattleOptionsLevelHeading,
	    @BattleOptionsLevelBeginner,
	    @BattleOptionsLevelIntermediate;
  GIGI_applyMsg = MSG_BATTLE_CHANGE_LEVEL;
  GIGI_destination = process;
  GIGI_selection = BATTLE_LEVEL_INTERMEDIATE;
}

@object GenGlyphClass BattleOptionsLevelHeading = {
  /* This will put a Skill Level Heading in the options subgroup */
  GI_visMoniker = "   - Skill Level -";
  HINT_CENTER_MONIKER;
}

@object GenItemClass BattleOptionsLevelBeginner = { 
  GI_visMoniker = 'B', "Beginner";
  GII_identifier = BATTLE_LEVEL_BEGINNER;
}

@object GenItemClass BattleOptionsLevelIntermediate = { 
  GI_visMoniker = 'A', "Advanced";
  GII_identifier = BATTLE_LEVEL_INTERMEDIATE;
}

@object GenInteractionClass BattleSizeMenu = {
  GI_visMoniker = 'S', "Grid Size";
  GI_comp = @BattleSize;
  GII_visibility = GIV_DIALOG;
  GII_type = GIT_PROPERTIES;
}

@object GenValueClass BattleSize = {
  GVLI_minimum = MakeWWFixed(BATTLE_GRID_MINIMUM);
  GVLI_maximum = MakeWWFixed(BATTLE_GRID_MAXIMUM);
  GVLI_value = MakeWWFixed(BATTLE_GRID_START);
  GVLI_increment = MakeWWFixed(BATTLE_GRID_INC);
  GVLI_destination = process;
  GVLI_applyMsg = MSG_BATTLE_CHANGE_GRID_SIZE;
}


@object GenInteractionClass BRGameOver = {
  /* Game Over Dialog Box */
  GI_visMoniker = "Game Over";
  GI_comp = @BRGameOverText,
	    @BRGameOverTextQuestion,
	    @BRGameOverYes;
  GII_type = GIT_AFFIRMATION;   /* Yes/No response */
  GII_visibility = GIV_DIALOG;
  GII_attrs = @default | GIA_MODAL | GIA_NOT_USER_INITIATABLE;
    /* this causes the dialog to force a reply.
     * Also this dialog will not appear in the menu. */
  HINT_ORIENT_CHILDREN_VERTICALLY;
}

@visMoniker ComputerWonText = "You Have Been Defeated!";
@visMoniker PlayerWonText = "You Are Victorious!";

@object GenGlyphClass BRGameOverText = {
  /* Moniker will be set before calling dialog */
  HINT_CENTER_MONIKER;
}

@object GenGlyphClass BRGameOverTextQuestion = {
  GI_visMoniker = "Do you want to play again?";
  HINT_CENTER_MONIKER;
}

@object GenTriggerClass BRGameOverYes = {
  GI_attrs = @default | GA_SIGNAL_INTERACTION_COMPLETE;
  GTI_destination = process;
  GTI_actionMsg = MSG_NEW_GAME;
  ATTR_GEN_TRIGGER_INTERACTION_COMMAND = {IC_YES};
  HINT_SEEK_REPLY_BAR;
}

@end    Interface       /* End of the Interface resource block. */


/***********************************************************************
 *              The Visible Tree
 ***********************************************************************/

@start BoardBlock;      /*  This resource block contains all the        * 
			 *  visible objects in the visible tree.        */


/***********************************************************************
 *              The Game Board Objects
 ***********************************************************************/
/* 
 * These objects act as three things:  The content object of a
 * BattleView, the game board of the game, and the organizational
 * object for all the game pieces.  The bounds of this object are the
 * exact size of the game board, and each player raft is a child in the
 * visible tree.
 */ 

@object PlayerBattleBoardClass PlayerBattleBoard = { 
    
  VI_bounds = {0, 0, BOARD_LENGTH, BOARD_LENGTH};
    /*
     * The bounds are in GEOS coordinates, or points.
     * The upper-left corner of the content appears at
     * (0,0), and the lower right extends to whatever is
     * set as the height and width of the board.
     * The bounds are important here because the View is
     * set up to automatically match the size of the
     * BattleBoard object.
     */

  VCI_geoAttrs = VCGA_CUSTOM_MANAGE_CHILDREN;
    /*
     * This attribute indicates that the geometry manager
     * should not be invoked on this object's children.
     * Rather this object will manage its own geometery.
     * Or, as in this case, the children will manage
     * themselves.
     */
}

@object ComputerBattleBoardClass ComputerBattleBoard = { 
    
  VI_bounds = {0, 0, BOARD_LENGTH, BOARD_LENGTH};

  VCI_geoAttrs = VCGA_CUSTOM_MANAGE_CHILDREN;
}

@end BoardBlock         /*  End of the BoardBlock resource block. */



/****************************************************************
 *              CODE FOR BattleProcessClass                 *
 ***************************************************************/


/*****************************************************************************
 *                 MSG_GEN_PROCESS_OPEN_APPLICATION for BattleProcessClass
 *****************************************************************************
 * SYNOPSIS:       Handle anything needed when opening app.
 *
 * On Entry:
 *
 * On Exit Return:
 * 
 * Revision History:
 *   Name               Date           Description
 *   Derrick Renaud     01/01/97       Initial .1 beta
 *****************************************************************************/
@extern method BattleProcessClass, MSG_GEN_PROCESS_OPEN_APPLICATION {


	@call BattleApp::MSG_GEN_APPLICATION_INSTALL_TOKEN();

	@callsuper();


}


/***********************************************************************
 *              MSG_NEW_GAME for BattleProcessClass
 ***********************************************************************
 * SYNOPSIS:    This method notifies each of the views that
 *              a new game is beginning; they should notify their contents,
 *              and then the board object will redraw itself.
 *  
 * PARAMETERS:  None    
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      DR      1/31/94         Initial Revision
 *
 ***********************************************************************/

@method BattleProcessClass, MSG_NEW_GAME {
    
  FloatRandomize(RGIF_GENERATE_SEED, 8);
  battleStarted = BR_GAME_NEW;
    /* Game has reset. Rafts are now movable */
  battleTurn = TURN_PLAYER;
    /* Player gets to go first */

  shotsOnCheckerBoard = gridSize * gridSize / 2;
  
  /* Call the boards and tell them to get ready */
  @call PlayerBattleBoard::MSG_BOARD_NEW_GAME();
  @call ComputerBattleBoard::MSG_BOARD_NEW_GAME();
}


/***********************************************************************
 *              MSG_GET_RANDOM_INT for BattleProcessClass
 ***********************************************************************
 * SYNOPSIS:    This method returns a random value between 0 and
 *              randomMax.
 *  
 * PARAMETERS:
 *      int (int randomMax)
 * STRATEGY:    This should be updated with a better random number
 *              generator.
 *
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      DR      1/31/94         Initial Revision
 *
 ***********************************************************************/

@method BattleProcessClass, MSG_GET_RANDOM_INT {

  FloatWordToFloat(randomMax);
  FloatRandomN();
  randomMax = 	FloatFloatToDword();
  return (randomMax);
}


/***********************************************************************
 *              MSG_BATTLE_CHANGE_SETUP for BattleProcessClass
 ***********************************************************************
 * SYNOPSIS:    This method saves the new setup info.
 *  
 * PARAMETERS:  void (word selectedBooleans, word indeterminateBooleans,    
 *                    word modifiedBooleans)  
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      DR      2/7/94          Rev 1.1
 *
 ***********************************************************************/

@method BattleProcessClass, MSG_BATTLE_CHANGE_SETUP {
  WindowHandle win;
  GStateHandle gstate;
  int boardLength;

  battleRaftSetup = selectedBooleans;

  boardLength = gridSize * BATTLE_BLOCK + 1;

/* Invalidate the Player window */
  win = @call PlayerBattleView::MSG_GEN_VIEW_GET_WINDOW();
  gstate = GrCreateState(win);
  GrInvalRect(gstate, 0, 0, boardLength, boardLength);
  
  /* Invalidate the Computer window */
  win = @call ComputerBattleView::MSG_GEN_VIEW_GET_WINDOW();
  gstate = GrCreateState(win);
  GrInvalRect(gstate, 0, 0, boardLength, boardLength);
  
  GrDestroyState(gstate);
}


/***********************************************************************
 *              MSG_BATTLE_CHANGE_LEVEL for BattleProcessClass
 ***********************************************************************
 * SYNOPSIS:    This method saves the new setup info.
 *  
 * PARAMETERS:  void (word selection, word numSelections, byte stateFlags)
 *
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      DR      2/7/94          Rev 1.1
 *
 ***********************************************************************/

@method BattleProcessClass, MSG_BATTLE_CHANGE_LEVEL {
  /* Save the selected Skill Level */
  skillLevel = selection;
}

/***********************************************************************
 *              MSG_BATTLE_PLAY_END_SOUND for BattleProcessClass
 ***********************************************************************
 * SYNOPSIS:    This method plays some ending music.
 *              1 = Computer Won
 *              2 = Player Won
 *  
 * PARAMETERS:  void (int winner)
 *
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      DR      2/7/94          Rev 1.1
 *
 ***********************************************************************/

@method BattleProcessClass, MSG_BATTLE_PLAY_END_SOUND {
/*  MemHandle musicHandle;
  Boolean err;

  static const word endSongBuf1[] = {
    SSE_CHANGE, 0, IP_FLUTE,
    SSE_GENERAL, GE_SET_PRIORITY, SP_GAME,
    SSE_VOICE_ON, 0, LOW_C, DYNAMIC_MP,
    SSDTT_TEMPO, QUARTER,
    SSE_VOICE_OFF, 0,
    SSDTT_TEMPO, SIXTEENTH,
    SSE_VOICE_ON, 0, LOW_C, DYNAMIC_MP,
    SSDTT_TEMPO, QUARTER,
    SSE_VOICE_OFF, 0,
    SSDTT_TEMPO, SIXTEENTH,
    SSE_VOICE_ON, 0, LOW_C, DYNAMIC_MP,
    SSDTT_TEMPO, QUARTER,
    SSE_VOICE_OFF, 0,
    SSDTT_TEMPO, SIXTEENTH,
    SSE_VOICE_ON, 0, LOW_A, DYNAMIC_MP,
    SSDTT_TEMPO, QUARTER,
    SSE_VOICE_OFF, 0,
    SSDTT_TICKS, 6,
    SSE_GENERAL, GE_END_OF_SONG };
  
  static const word endSongBuf2[] = {
    SSE_CHANGE, 0, IP_FLUTE,
    SSE_GENERAL, GE_SET_PRIORITY, SP_GAME,
    SSE_VOICE_ON, 0, MIDDLE_C, DYNAMIC_MP,
    SSDTT_TEMPO, QUARTER,
    SSE_VOICE_OFF, 0,
    SSDTT_TEMPO, SIXTEENTH,
    SSE_VOICE_ON, 0, MIDDLE_C, DYNAMIC_MP,
    SSDTT_TEMPO, QUARTER,
    SSE_VOICE_OFF, 0,
    SSDTT_TEMPO, SIXTEENTH,
    SSE_VOICE_ON, 0, MIDDLE_C, DYNAMIC_MP,
    SSDTT_TEMPO, QUARTER,
    SSE_VOICE_OFF, 0,
    SSDTT_TEMPO, SIXTEENTH,
    SSE_VOICE_ON, 0, MIDDLE_D, DYNAMIC_MP,
    SSDTT_TEMPO, QUARTER,
    SSE_VOICE_OFF, 0,
    SSDTT_TICKS, 6,
    SSE_GENERAL, GE_END_OF_SONG };
  
  if (winner == 1) {        
    err = SoundAllocMusic(&endSongBuf1, 1, &musicHandle);
    err = SoundPlayMusic(musicHandle, SP_GAME, 125, DESTROY_ON_EOS);
  } else {
    err = SoundAllocMusic(&endSongBuf2, 1, &musicHandle);
    err = SoundPlayMusic(musicHandle, SP_GAME, 125, DESTROY_ON_EOS);
  }
*/
}

/***********************************************************************
 *              MSG_BATTLE_CHANGE_GRID_SIZE for BattleProcessClass
 ***********************************************************************
 * SYNOPSIS:    This method changes the grid size and ends current game.
 *  
 * PARAMETERS:  void (WWFixedAsDWord value, word stateFlags)
 *
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      DR      3/14/94         Rev 1.2
 *
 ***********************************************************************/

@method BattleProcessClass, MSG_BATTLE_CHANGE_GRID_SIZE {
  int boardSize;

  gridSize = value >> 16;

  boardSize = gridSize * BATTLE_BLOCK + 1;
  
  battleStarted = BR_GAME_OVER;
  
/* Calling the views is not needed because changing the content size
 * automatically updates the view size.  It is done only to help speed up
 * the screen drawing.  If it was not followed by the content resize, then
 * the view would fit itself back to the content size. */

  @call PlayerBattleView::MSG_GEN_VIEW_SET_DOC_BOUNDS(
		boardSize, boardSize, 0, 0);
  
  @call ComputerBattleView::MSG_GEN_VIEW_SET_DOC_BOUNDS(
		boardSize, boardSize, 0, 0);

  @call PlayerBattleBoard::MSG_VIS_SET_SIZE(
		boardSize, boardSize);
  @call ComputerBattleBoard::MSG_VIS_SET_SIZE(
		boardSize, boardSize);
  
  @send process::MSG_NEW_GAME();
}


/****************************************************************
 *              CODE FOR BattleBoardClass                       *
 ***************************************************************/


/***********************************************************************
 *              MSG_BOARD_PLACE_PIECE_CHECK for BattleBoardClass
 ***********************************************************************
 * SYNOPSIS:    This method checks to see if the new location for
 *              the raft will fit in the grid. Also the raft can not
 *              be placed on top of a different raft. But it is ok
 *              for the raft to overlap it's old positon.
 * PARAMETERS:  
 *      int (int x, int y, int size, int direction, int type)    
 * STRATEGY:    If the raft meets the above conditions, return TRUE.
 *              If there are any conflicts, return FALSE.
 *
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      DR      1/31/94         Initial Revision
 *
 ***********************************************************************/

@method BattleBoardClass, MSG_BOARD_PLACE_PIECE_CHECK {

  int xEnd, yEnd;
  int check = TRUE;

  if ((x >= 0) && (x < gridSize) &&   /* check start of raft */
      (y >= 0) && (y < gridSize)) {

    xEnd = x;
    yEnd = y;
      
    if (direction == PBP_HORIZONTAL) xEnd += size - 1;
    else yEnd += size - 1;

    if ((xEnd >= 0) && (xEnd < gridSize) &&   /* check end of raft */
	(yEnd >= 0) && (yEnd < gridSize)) {

      /* Check to see if raft overlaps a different raft */
      do {
	if ((pself->BR_board[y][x] != BR_EMPTY) &&
	    (pself->BR_board[y][x] != type))
	  check = FALSE;
	    /*
	     * can't place over a different object
	     */
	/* Increment to next raft location */
	if (direction == PBP_HORIZONTAL) x ++;
	else y ++;
	size --;
      } while (size > 0);
      
    }
    else check = FALSE;       /* end not in grid */
  }
  else check = FALSE;         /* start not in grid */
  
  return (check);
}


/***********************************************************************
 *              MSG_BOARD_PLACE_PIECE for BattleBoardClass
 ***********************************************************************
 * SYNOPSIS:    This method will place an object in the grid.
 *              No checking is done, so it better fit.
 * PARAMETERS:  
 *      void (int x, int y, int size, int direction, int type)    
 * SIDE EFFECTS:Total chaos if x,y out of range.    
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      DR      1/31/94         Initial Revision
 *
 ***********************************************************************/

@method BattleBoardClass, MSG_BOARD_PLACE_PIECE {
  
  do {
    pself->BR_board[y][x]=type;
    if (direction == PBP_HORIZONTAL) x ++;
    else y ++;
    size --;
  } while (size > 0);
}


/***********************************************************************
 *              MSG_BOARD_CHECK_GRID for BattleBoardClass
 ***********************************************************************
 * SYNOPSIS:    This method returns a value from the grid.
 * PARAMETERS:  
 *      unsigned char (int x, int y)    
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      DR      1/31/94         Initial Revision
 *
 ***********************************************************************/

@method BattleBoardClass, MSG_BOARD_CHECK_GRID {
  int i;
  i = pself->BR_board[y][x];
  return(i);
}



/****************************************************************
 *              CODE FOR PlayerBattleBoardClass                 *
 ***************************************************************/


/***********************************************************************
 *              MSG_BOARD_NEW_GAME for PlayerBattleBoardClass
 ***********************************************************************
 * SYNOPSIS:    This method notifies each of the visible children that
 *              a new game is beginning; they should take their places,
 *              and then the board object will redraw itself.
 *  
 * PARAMETERS:  None    
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      DR      1/31/94         Initial Revision
 *
 ***********************************************************************/

@method PlayerBattleBoardClass, MSG_BOARD_NEW_GAME {
  
  WindowHandle win;
  GStateHandle gstate;
  optr childOptr;
  MemHandle ourBlock;
  int x = 0;
  int y = 0;
  int boardLength;

  boardLength = gridSize * BATTLE_BLOCK +1;
  
  /*
   * Anything using pself should be done first, because routines and
   * Messages can trash it without warning. Then you could end up
   * accessing random memory locations. write = crash
   */
  
  /* reset grid values */
  for (y = 0; y < gridSize; y ++) {
    for (x = 0; x < gridSize; x ++) {
      pself->BR_board[y][x] = 0;
    }
  }
  
  /* setup counter sizes before pself gets trased */
  pself->BP_hitCount[0] = 0;      /* contains # of misses */
  pself->BP_size[BR_2MAN] = 2;
  pself->BP_hitCount[BR_2MAN] = 0;
  pself->BP_size[BR_3MAN1] = 3;
  pself->BP_hitCount[BR_3MAN1] = 0;
  pself->BP_size[BR_3MAN2] = 3;
  pself->BP_hitCount[BR_3MAN2] = 0;
  pself->BP_size[BR_4MAN] = 4;
  pself->BP_hitCount[BR_4MAN] = 0;
  pself->BP_size[BR_5MAN] = 5;
  pself->BP_hitCount[BR_5MAN] = 0;
  pself->BP_sunk = 0;
  
  /* Reset computer search data */
  pself->compWorkingOnHit = 0;
  pself->compProgress = 0;
  
  /* 
   * Rafts could have been declared objects at the start, but this will
   * allow future menu selection of rafts. So they will be killed at the
   * start of the game and then rebuilt.
   */
  
  /*  Kill any current rafts */  
  while ((childOptr = @call self::MSG_VIS_FIND_CHILD_AT_POSITION(0)) != 0) {
    @call childOptr::MSG_VIS_DESTROY(VUM_DELAYED_VIA_APP_QUEUE);
  }
  
  ourBlock = OptrToHandle(oself);
  
  /* Make 2MAN raft */

  childOptr = ConstructOptr(ourBlock,                     /* new child */
		ObjInstantiate(OptrToHandle(oself), 
			       &PlayerBattlePieceClass));
  @call childOptr::MSG_PLAYER_PIECE_SETUP                 /* setup raft */
		      (0, 0, 2, PBP_HORIZONTAL, BR_2MAN);
  @call self::MSG_VIS_ADD_CHILD(childOptr, CCO_LAST);   /* add it to tree */
  
  /* Make 3MAN1 raft */

  childOptr = ConstructOptr(ourBlock,                     /* new child */
		ObjInstantiate(OptrToHandle(oself), 
			       &PlayerBattlePieceClass));
  @call childOptr::MSG_PLAYER_PIECE_SETUP                 /* setup raft */
		      (0, 1, 3, PBP_HORIZONTAL, BR_3MAN1);
  @call self::MSG_VIS_ADD_CHILD(childOptr, CCO_LAST);   /* add it to tree */

  /* Make 3MAN2 raft */

  childOptr = ConstructOptr(ourBlock,                     /* new child */
		ObjInstantiate(OptrToHandle(oself), 
			       &PlayerBattlePieceClass));
  @call childOptr::MSG_PLAYER_PIECE_SETUP                 /* setup raft */
		      (0, 2, 3, PBP_HORIZONTAL, BR_3MAN2);
  @call self::MSG_VIS_ADD_CHILD(childOptr, CCO_LAST);   /* add it to tree */
  
  /* Make 4MAN raft */

  childOptr = ConstructOptr(ourBlock,                     /* new child */
		ObjInstantiate(OptrToHandle(oself), 
			       &PlayerBattlePieceClass));
  @call childOptr::MSG_PLAYER_PIECE_SETUP                 /* setup raft */
		      (0, 3, 4, PBP_HORIZONTAL, BR_4MAN);
  @call self::MSG_VIS_ADD_CHILD(childOptr, CCO_LAST);   /* add it to tree */
  
  /* Make 5MAN raft */

  childOptr = ConstructOptr(ourBlock,                     /* new child */
		ObjInstantiate(OptrToHandle(oself), 
			       &PlayerBattlePieceClass));
  @call childOptr::MSG_PLAYER_PIECE_SETUP                 /* setup raft */
		      (0, 4, 5, PBP_HORIZONTAL, BR_5MAN);
  @call self::MSG_VIS_ADD_CHILD(childOptr, CCO_LAST);   /* add it to tree */
  
  /*
   * Mark as invalid so UI can setup and use object. 
   * Board will check for children and then use them. If this wasn't done
   * then the rafts would not respond to the mouse.
   */
  @call self::MSG_VIS_MARK_INVALID(VOF_IMAGE_INVALID,
		       VUM_DELAYED_VIA_APP_QUEUE);

  /* 
   * Now initiate a new gstate for the view window. Get the
   * window handle from the view, and then create a new gstate
   * for it.
   */

  win = @call PlayerBattleView::MSG_GEN_VIEW_GET_WINDOW();
  gstate = GrCreateState(win);

  /* 
   * Invalidate the game board rectangle in the document. This
   * will cause the view object to generate a MSG_META_EXPOSED
   * for the rectangle, causing MSG_VIS_DRAW to be sent to this
   * object.
   */

  GrInvalRect(gstate, 0, 0, boardLength, boardLength);
  GrDestroyState(gstate);
}


/***********************************************************************
 *              MSG_VIS_DRAW for PlayerBattleBoardClass
 ***********************************************************************
 * SYNOPSIS:    This method draws the board's outline and the
 *              lines of the playing field.  It is sent each time
 *              a portion of the view window becomes invalid (such
 *              as when the primary is moved).   
 * PARAMETERS:  
 *      void (word drawFlags, GStateHandle gstate)
 *              The gstate is the handle of the graphics state
 *              associated with the exposed portion of the view
 *              window. 
 *
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      DR      1/31/94         Initial Revision
 *      DR      2/7/94          Rev 1.1 added monochrome fix.
 *
 ***********************************************************************/

@method PlayerBattleBoardClass, MSG_VIS_DRAW {

  int i = 0;
  int x, y;
  sword x1, y1, x2, y2;
  int boardLength;

  boardLength = gridSize * BATTLE_BLOCK + 1;

  /*
   * Set up the graphic state properly.  The board lines are 1pt thick.
   * If Monochrome is set then lines are white. Otherwise there Black.
   */

  GrSetLineWidth(gstate, 1);
/*  if (battleRaftSetup & BATTLE_MONOCHROME_DISPLAY) {
    GrSetLineColor(gstate, CF_INDEX, C_WHITE, 0, 0);
  } else {  */
    GrSetLineColor(gstate, CF_INDEX, C_BLACK, 0, 0);
/*  }   */

  /*
   * Now draw the border of the game board.  It is a rectangle
   * that outlines the entire board.
   */

  GrDrawRect(gstate, FIRST_HORIZ -1, FIRST_VERT -1, 
    FIRST_HORIZ -1 + boardLength, FIRST_VERT -1 + boardLength);

  /* 
   * Set and draw the playing field grid lines.
   */
  
  do {  
  
    GrDrawHLine(gstate, FIRST_HORIZ, FIRST_VERT - 1 + BATTLE_BLOCK * i,  
      FIRST_HORIZ + boardLength - 2);
    GrDrawVLine(gstate, FIRST_HORIZ - 1 + BATTLE_BLOCK * i, FIRST_VERT,  
      FIRST_VERT + boardLength - 2);
    i++;
  
  } while (i <= gridSize);

  /* 
   * Draw any waves where rocks missed the raft.
   * Lines are white if monochrome else they are blue.
   */
  
/*  if (battleRaftSetup & BATTLE_MONOCHROME_DISPLAY) {
    GrSetLineColor(gstate, CF_INDEX, C_WHITE, 0, 0);
  } else { */
    GrSetLineColor(gstate, CF_INDEX, C_BLUE, 0, 0);
/*  }   */

  for (y = 0; y < gridSize; y ++) {
    for (x = 0; x < gridSize; x ++) {
      if (pself->BR_board[y][x] == BR_ROCK) {
	/* Waves only if rock and no raft at location */
	x1 = x * BATTLE_BLOCK + FIRST_HORIZ - 1 + BATTLE_BLOCK / 4;
	y1 = y * BATTLE_BLOCK + FIRST_VERT - 1 + BATTLE_BLOCK / 4;
	x2 = x1 + BATTLE_BLOCK / 2;
	y2 = y1 + BATTLE_BLOCK / 2;
	GrDrawEllipse(gstate, x1, y1, x2, y2);
	  /* Hi-tech waves! Just a circle for now. */
      }
    } /* next x */
  } /* next y */

  /* 
   * When the MSG_VIS_DRAW is received by the game board, it
   * must pass it on to its visible children.  It must also pass
   * on the parameters of the message as passed to ensure all
   * drawing is done properly.
   */
  
  @send @visChildren::MSG_VIS_DRAW(drawFlags, gstate);

  /* 
   * Call the superclass to invoke any default behavior
   * for this message.
   */

  @callsuper();
}


/***********************************************************************
 *              MSG_COMPUTER_MAKE_SHOT for PlayerBattleBoardClass
 ***********************************************************************
 * SYNOPSIS:    This method is the computer's brain.
 *              This is where it decides where it is going to through
 *              it's rock.
 *              Forgive the goto's, but I'm to used to programming
 *              in assembly language. I find unstructured easier when
 *              I need a lot of if statements.
 *  
 * PARAMETERS:  None    
 *
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      DR      1/31/94         Initial Revision
 *      DR      2/7/94          Rev 1.1
 *                              Added Skill Levels and fixed progress
 *                               bug that would make computer do a
 *                               rotate search at both ends.
 *
 ***********************************************************************/

@method PlayerBattleBoardClass, MSG_COMPUTER_MAKE_SHOT {
  
  GStateHandle gstate;
  WindowHandle win;
  int raft;
  int newX, newY;
  int search;

  /* Check to make sure game is not over before shooting */
  if (battleStarted != BR_GAME_OVER) {
  
  if (!pself->compWorkingOnHit) goto AddrMakeRandom;

  /* Last shot was a hit. Let's find that raft. */

AddrNewLast:;
  /* We will start the search from the last hit */
  newX = pself->compLastX;
  newY = pself->compLastY;

AddrIncNew:;
  /* Increment to the next location in grid to search at. */
  if (pself->compDirection == COMP_DIRECTION_N) newY --;
  else if (pself->compDirection == COMP_DIRECTION_E) newX ++;
  else if (pself->compDirection == COMP_DIRECTION_S) newY ++;
  else newX --;

  /* Check if new search will fit in grid */
  if ((newX < 0) || (newX >= gridSize) ||
      (newY < 0) || (newY >= gridSize))
      /* New search is not in grid. */
      goto AddrCheckProgress;

  /* Search is in grid, so... */

  /* Check if there is a shot that missed already there. */
  if (pself->BR_board[newY][newX] == BR_ROCK)
    /* A miss blocks further progress */
    goto AddrCheckProgress;

  /* There is no miss blocking progess, so... */

  /* Check if there is a hit that needs to be skipped over */
  if ((pself->BR_board[newY][newX] & BR_ROCK) != BR_EMPTY)
    /* There is a hit there. Skip over it. */
    goto AddrIncNew;

  /* The spot is open. Fire away. */
  goto AddrMakeShot;

AddrCheckProgress:;
  /* Let's find out what direction we should look in now */
  if (pself->compProgress == 0) {
    
    /* We have not found another hit yet so let rotate search direction */
    pself->compDirection += pself->compDirectionSpin;
    if (pself->compDirection < 1) pself->compDirection = 4;
    if (pself->compDirection > 4) pself->compDirection = 1;

    /* Check to see if we've managed to rotate back to start direction */
    if (pself->compDirection == pself->compStartDirection)
      /* Yep, we're back at the start. Take a random shot. */
      goto AddrMakeRandom;

    /* Otherwise... */
    /* Restore new search back to start and check new rotation. */
    goto AddrNewLast;
  }
  else if (pself->compProgress == 1) {
    /* Some progress was made on the last shot,
     * but we're at the end of the line. 
     * Try going in the other direction */
    pself->compDirection = 6 - pself->compDirection;
    if (pself->compDirection == 3) pself->compDirection = 1;
    else if (pself->compDirection == 5) pself->compDirection = 3;

    /* Increment progress so we don't end up going 
     * back in the old direction */
    pself->compProgress ++;

    /* Restore new search back to start and check new direction */
    goto AddrNewLast;
  }
  else {
    /* We've checked both directions and come to both ends. */
    /* So just continue on to make a random shot. */
  }

AddrMakeRandom:;
  /* First clear out all previous progress */
  pself->compProgress = 0;
  pself->compWorkingOnHit = 0;

  /* Beginner Level will shoot any where on the board.
   * Intermediate Level will shoot only on checkerboard spots
   *   eg. 010101
   *       101010
   */
  search = gridSize;
  if (skillLevel == BATTLE_LEVEL_INTERMEDIATE) {
    search /= 2;
  }
  
  /* Loop until we find a random free location */
  do {
    newX = @call process::MSG_GET_RANDOM_INT(search);
    newY = @call process::MSG_GET_RANDOM_INT(gridSize);
    if (skillLevel == BATTLE_LEVEL_INTERMEDIATE) {
      /* Intermediate level so we only search ever other x location */
      newX *= 2;
      /* If checkerboard shots are left then stager X on even rows,
       * else stager X on odd rows. */
      /* We need to do this because if for some reason all rafts have not
       * been found by shooting ever other space then the game will lock up. */
      if ( ((shotsOnCheckerBoard == 0) && (((newY / 2) * 2) != newY)) ||
        ((shotsOnCheckerBoard != 0) && (((newY / 2) * 2) == newY)) ) {
        newX += 1;
      }
    }
  } while (pself->BR_board[newY][newX] & BR_ROCK);
  
AddrMakeShot:;
  /* We have a location to shoot at. Try it out. */

  if( (shotsOnCheckerBoard != 0) && (((newY ^ newX) & 1)) ) shotsOnCheckerBoard --;
  
  /* First Place the rock */
  pself->BR_board[newY][newX] |= BR_ROCK;
  
  /* Find out what raft (if any) is there */
  raft = pself->BR_board[newY][newX] & BR_RAFT_MASK;
  
  /* increment hits on raft */
  pself->BP_hitCount[raft] ++;
      
  /* Update the grid location visually */
  win = @call PlayerBattleView::MSG_GEN_VIEW_GET_WINDOW();
  gstate = GrCreateState(win);
  GrInvalRect(gstate, newX * BATTLE_BLOCK + FIRST_HORIZ,
		 newY * BATTLE_BLOCK + FIRST_VERT,
		 newX * BATTLE_BLOCK + FIRST_HORIZ + BATTLE_BLOCK - 2,
		 newY * BATTLE_BLOCK + FIRST_VERT + BATTLE_BLOCK - 2);
  GrDestroyState(gstate);
  
  if (raft != BR_EMPTY) {
    /* Something was hit. Notify user. */
    UserStandardSound(SST_NOTIFY);
    
    /* Update X-Y for next shot to search from */
    pself->compLastX = newX;
    pself->compLastY = newY;
    
    /* Check if this is a first hit. */
    if (pself->compWorkingOnHit == 0) {
      /* This is a first hit, so... */

      /* Setup random search for next shot */
      pself->compStartDirection = @call process::MSG_GET_RANDOM_INT(4) + 1;
      pself->compDirection = pself->compStartDirection;
      pself->compDirectionSpin = @call process::MSG_GET_RANDOM_INT(2);
      if (pself->compDirectionSpin == 0) pself->compDirectionSpin = (-1);

      /* Update to notify next shot that it's working on a hit */
      pself->compWorkingOnHit = 1;
    } else {
      if (pself->compProgress == 0) {
	/* We are making progress in this direction, so... */
	pself->compProgress = 1;
      }
    }
    
    if (pself->BP_hitCount[raft] == pself->BP_size[raft]) {
      /* raft has been sunk */
      pself->BP_sunk ++;
      if (pself->BP_sunk == NO_OF_RAFTS) {
	/* all player rafts sunk */
	battleStarted = BR_GAME_OVER;
	@call process::MSG_BATTLE_PLAY_END_SOUND(1);
	/* Update Game Over Dialog for Computer win */
	@call BRGameOverText::MSG_GEN_USE_VIS_MONIKER(
	      OptrToChunk(@ComputerWonText), VUM_DELAYED_VIA_UI_QUEUE);
	@send BRGameOver::MSG_GEN_INTERACTION_INITIATE();
      }
    }
  } /* splash could go here */
  /* Player can go now */
  battleTurn = TURN_PLAYER;
}
}



/****************************************************************
 *              CODE FOR ComputerBattleBoardClass               *
 ***************************************************************/


/***********************************************************************
 *              MSG_BOARD_NEW_GAME for ComputerBattleBoardClass
 ***********************************************************************
 * SYNOPSIS:    This method notifies the computer to place it's rafts
 *              where it wants them.
 *  
 * PARAMETERS:  None    
 *
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      DR      1/31/94         Initial Revision
 *
 ***********************************************************************/

@method ComputerBattleBoardClass, MSG_BOARD_NEW_GAME {
  
  WindowHandle win;
  GStateHandle gstate;
  int i;
  int x, y;
  int direction;
  int check = FALSE;
  int boardLength;

  boardLength = gridSize * BATTLE_BLOCK + 1;

  /* Reset grid values */
  for (y = 0; y < gridSize; y ++) {
    for (x = 0; x < gridSize; x ++) {
      pself->BR_board[y][x] = BR_EMPTY;
    } /* next x */
  } /* next y */
  
  /* setup piece sizes and set hits to 0 */
  pself->BP_sunk = 0;
  for (i = 1; i <= NO_OF_RAFTS; i ++) {
    pself->BP_hitCount[i] = 0;
    pself->BP_size[i] = i;
  }
  pself->BP_size[1] = 2;
  pself->BP_size[2] = 3;

  for (i = 1; i <= NO_OF_RAFTS; i ++) {
    check = FALSE;      /* reset check flag */

    /* loop until raft is randomly placed in board */
    while (!check) {
      /* set the direction random */
      direction = PBP_HORIZONTAL;
      if (@call process::MSG_GET_RANDOM_INT(2) == 0) 
				direction = PBP_VERTICAL;
      
      x = @call process::MSG_GET_RANDOM_INT(gridSize - 
					    pself->BP_size[i] + 1);
      y = @call process::MSG_GET_RANDOM_INT(gridSize);
      
      /* see if raft will fit in given direction */
      if (direction == PBP_HORIZONTAL) {
	if (@call self::MSG_BOARD_PLACE_PIECE_CHECK(x, y, 
			pself->BP_size[i], direction, i)) {
	  /* the piece will fit, so place it */
	  check = TRUE;
	  @call self::MSG_BOARD_PLACE_PIECE(x, y,
			pself->BP_size[i], direction, i);
	}
      } else {
	if (@call self::MSG_BOARD_PLACE_PIECE_CHECK(y, x, 
			pself->BP_size[i], direction, i)) {
	  /* the piece will fit, so place it */
	  check = TRUE;
	  @call self::MSG_BOARD_PLACE_PIECE(y, x,
			pself->BP_size[i], direction, i);
	}
      }
    }  /* check if fits loop */
  }  /* next i (next raft) */

  win = @call ComputerBattleView::MSG_GEN_VIEW_GET_WINDOW();
  gstate = GrCreateState(win);

  /* Notify view to redraw itself */
  GrInvalRect(gstate, 0, 0, boardLength, boardLength);
  GrDestroyState(gstate);
}


/***********************************************************************
 *              MSG_VIS_DRAW for ComputerBattleBoardClass
 ***********************************************************************
 * SYNOPSIS:    This method draws the board's outline, grid lines,
 *              waves and rocks.  It is sent each time
 *              a portion of the view window becomes invalid (such
 *              as when the primary is moved).   
 * PARAMETERS:  
 *      void (word drawFlags, GStateHandle gstate)
 *              The gstate is the handle of the graphics state
 *              associated with the exposed portion of the view
 *              window. 
 *
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      DR      1/31/94         Initial Revision
 *      DR      2/7/94          Rev 1.1 added monochrome fix.
 *
 ***********************************************************************/

@method ComputerBattleBoardClass, MSG_VIS_DRAW {

  int i = 0;
  int x, y;
  sword x1, y1, x2, y2;
  int boardLength;

  boardLength = gridSize * BATTLE_BLOCK + 1;

  /* 
   * First call the superclass to invoke any default behavior
   * for this message.
   */

  @callsuper();

  GrSetLineWidth(gstate, 1);
/*  if (battleRaftSetup & BATTLE_MONOCHROME_DISPLAY) {
    GrSetLineColor(gstate, CF_INDEX, C_WHITE, 0, 0);
  } else { */
    GrSetLineColor(gstate, CF_INDEX, C_BLACK, 0, 0);
/*  }  */

  /*
   * Now draw the border of the game board.  It is a rectangle
   * that outlines the entire board.
   */

  GrDrawRect(gstate, FIRST_HORIZ -1, FIRST_VERT -1, 
    FIRST_HORIZ -1 + boardLength, FIRST_VERT -1 + boardLength);

  /* 
   * Set and draw the playing field grid lines.
   */
  
  do {  
  
    GrDrawHLine(gstate, FIRST_HORIZ, FIRST_VERT - 1 + BATTLE_BLOCK * i,  
      FIRST_HORIZ + boardLength - 2);
    GrDrawVLine(gstate, FIRST_HORIZ - 1 + BATTLE_BLOCK * i, FIRST_VERT,  
      FIRST_VERT + boardLength - 2);
    i++;
  
  } while (i <= gridSize);

  /* 
   * Draw any waves and rocks where needed.
   */
  
  GrSetAreaColor(gstate, CF_INDEX, C_LIGHT_GRAY, 0, 0);
  
  for (y = 0; y < gridSize; y ++) {
    for (x = 0; x < gridSize; x ++) {
      x1 = x * BATTLE_BLOCK + FIRST_HORIZ - 1 + BATTLE_BLOCK / 4;
      y1 = y * BATTLE_BLOCK + FIRST_VERT - 1 + BATTLE_BLOCK / 4;
      x2 = x1 + BATTLE_BLOCK / 2;
      y2 = y1 + BATTLE_BLOCK / 2;
      if (pself->BR_board[y][x] == BR_ROCK) {
	/* Setup wave colour. White if monochrome, else blue */
  /*	if (battleRaftSetup & BATTLE_MONOCHROME_DISPLAY) {
	  GrSetLineColor(gstate, CF_INDEX, C_WHITE, 0, 0);
	} else { */
	  GrSetLineColor(gstate, CF_INDEX, C_BLUE, 0, 0);
  /*	}  */
	/* Draw a wave */
	GrDrawEllipse(gstate, x1, y1, x2, y2);
      } else if (pself->BR_board[y][x] & BR_ROCK) {
	/* A hit! Draw a rock */
	GrSetLineColor(gstate, CF_INDEX, C_BLACK, 0, 0);
	GrFillEllipse(gstate, x1, y1, x2, y2);
	GrDrawEllipse(gstate, x1, y1, x2, y2);
      }
    } /* next x */
  } /* next y */
}


/***********************************************************************
 *              MSG_META_START_SELECT for ComputerBattleBoardClass
 ***********************************************************************
 * SYNOPSIS:    This method handles your shots on the computer.
 *
 * PARAMETERS:  
 *      void (MouseReturnParams *retVal,
 *                      word xPosition, word yPosition, word inputState);    
 *
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      DR      1/31/94         Initial Revision
 *
 ***********************************************************************/

@method ComputerBattleBoardClass, MSG_META_START_SELECT {

  GStateHandle gstate;
  WindowHandle win;
  int x, y;
  int raft;  
  word id; /* temp placeholders for TimerStart id */
  optr tempOptr;
  TimerHandle tempTimerHandle;

  /* Check to see if game has been reset and it is the player's turn */
  if ((battleStarted != BR_GAME_OVER) 
	&& (battleTurn == TURN_PLAYER)) { 
  
  if (battleStarted == BR_GAME_NEW) {
    /* First shot on the computer. Start game. */
    battleStarted = BR_GAME_STARTED;
  }
  
  /* Convert mouse co-ordinates to grid location */
  x = (xPosition - FIRST_HORIZ + 1) / BATTLE_BLOCK;
  y = (yPosition - FIRST_VERT + 1) / BATTLE_BLOCK;

  if (((x * BATTLE_BLOCK + FIRST_HORIZ - 1) != xPosition) &&
      ((y * BATTLE_BLOCK + FIRST_VERT - 1) != yPosition)) {
      /* Mouse is not on a grid line*/
    
    if (pself->BR_board[y][x] & BR_ROCK) {
      /* There is already a rock here. Warn user.*/
      UserStandardSound(SST_ERROR);
    } else {
      raft = pself->BR_board[y][x] & BR_RAFT_MASK; /* block all but raft */
      pself->BR_board[y][x] |= BR_ROCK;         /* place rock in grid */
      
      /* Update the grid location visually */
      win = @call ComputerBattleView::MSG_GEN_VIEW_GET_WINDOW();
      gstate = GrCreateState(win);
      GrInvalRect(gstate, x * BATTLE_BLOCK + FIRST_HORIZ,
		 y * BATTLE_BLOCK + FIRST_VERT,
		 x * BATTLE_BLOCK + FIRST_HORIZ + BATTLE_BLOCK - 2,
		 y * BATTLE_BLOCK + FIRST_VERT + BATTLE_BLOCK - 2);
      GrDestroyState(gstate);
      
      if (raft != BR_EMPTY) {
	/* There must be something else here */
	UserStandardSound(SST_NOTIFY);
	pself->BP_hitCount[raft] ++;
	
	/* check to see if raft has been sunk */
	if (pself->BP_hitCount[raft]  == 
	    pself->BP_size[raft]) {
	  /* You sunk a computer raft */
	  pself->BP_sunk ++;
	  if (pself->BP_sunk == NO_OF_RAFTS) {
	    /* all computer rafts sunk */
	    battleStarted = BR_GAME_OVER;
	    @call process::MSG_BATTLE_PLAY_END_SOUND(2);
	    /* Update Game Over dialog for Player win */
	    @call BRGameOverText::MSG_GEN_USE_VIS_MONIKER(
		OptrToChunk(@PlayerWonText), VUM_DELAYED_VIA_UI_QUEUE);
	    @send BRGameOver::MSG_GEN_INTERACTION_INITIATE();
	  }
	}
      } /* splash could go here in an 'else { }' */
    
      /* Let the computer take a turn */
      /* Delay a little so player's shot gets drawn and noticed */
      tempOptr = @call PlayerBattleBoard::MSG_META_GET_OPTR();
      tempTimerHandle = TimerStart(TIMER_EVENT_ONE_SHOT, tempOptr, 12,
		 MSG_COMPUTER_MAKE_SHOT, 0, &id);
    
    }
  } else {
    /* Mouse on grid line. Notify user. */
    UserStandardSound(SST_ERROR);
  }
  } /* New game not picked yet */

  retVal->flags = MRF_PROCESSED;      /* this event processed */
}


/****************************************************************
 *              CODE FOR PlayerBattlePieceClass                 *
 ***************************************************************/

/***********************************************************************
 *              MSG_PLAYER_PIECE_SETUP for PlayerBattlePieceClass
 ***********************************************************************
 * SYNOPSIS:    This message causes the piece to setup itself
 *              to to the given parameters.  It is invoked when the
 *              user presses the New Game trigger; the trigger sends
 *              MSG_BATTLE_NEW_GAME to the PlayerBattleBoard object, and
 *              the board object sends this message to each of
 *              the game piece objects.    
 * PARAMETERS:      
 *      void (int x, int y, int size, int direction, int type) 
 *
 * STRATEGY:
 *
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      DR      1/31/94         Initial Revision
 *
 ***********************************************************************/

@method PlayerBattlePieceClass, MSG_PLAYER_PIECE_SETUP {

int x1, x2, y1, y2;

  pself->PBP_type = type;
  pself->PBP_size = size;
  pself->PBP_direction = direction;
  pself->PBP_horizPos = x;
  pself->PBP_vertPos = y;
  pself->PBP_dragging = FALSE;

  /* set object to receive mouse clicks and visable */
  pself->VI_attrs |= (VA_FULLY_ENABLED | 
		     VA_DRAWABLE | VA_DETECTABLE);

  x1 = x * BATTLE_BLOCK + FIRST_HORIZ;     /* Calculate bounds */
  y1 = y * BATTLE_BLOCK + FIRST_VERT;
  if (direction == PBP_HORIZONTAL) {
    x2 = size * BATTLE_BLOCK + x1 - 2;       /* Bounds fit made to fit */
    y2 = BATTLE_BLOCK + y1 - 2;              /* inside grid lines     */
  } else {
    x2 = BATTLE_BLOCK + x1 - 2;
    y2 = size * BATTLE_BLOCK + y1 - 2;
  }
  pself->VI_bounds.R_left = x1;
  pself->VI_bounds.R_top = y1;
  pself->VI_bounds.R_right = x2;
  pself->VI_bounds.R_bottom = y2;

  /* Mark as invalid so UI can setup and use object */
  @call self::MSG_VIS_MARK_INVALID(VOF_IMAGE_INVALID | VOF_WINDOW_INVALID,
		       VUM_DELAYED_VIA_APP_QUEUE);
  
  /* Place the piece in the grid */
  @call PlayerBattleBoard::MSG_BOARD_PLACE_PIECE
			   (x, y, size, direction, type);
}


/***********************************************************************
 *              MSG_VIS_DRAW for PlayerBattlePieceClass
 ***********************************************************************
 * SYNOPSIS:    Draw the piece at the current location.
 *              This message is received whenever a portion
 *              of the view window becomes invalid; PlayerBattleView
 *              will send a MSG_META_EXPOSED to BattleBoard, which
 *              will send itself (by default) a MSG_VIS_DRAW.  The
 *              MSG_VIS_DRAW will be handled and then will be passed
 *              on to each of the game pieces.  Then each piece (in
 *              this handler) will draw itself at its own bounds.    
 * PARAMETERS:      
 *      void (word drawFlags GStateHandle gstate) 
 * SIDE EFFECTS:    
 *
 * STRATEGY:
 *
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      DR      1/31/94         Initial Revision
 *      DR      2/7/94          Rev 1.1 added monochrome fix
 *                              and fast log drawing.
 *
 ***********************************************************************/

@method PlayerBattlePieceClass, MSG_VIS_DRAW {

  int xPos, yPos;
  int i = 1;
  sword x = 0;
  sword y = 0;

  /* 
   * Set the mode to MM_COPY; this means that the image drawn
   * now will be drawn over whatever is there now.
   */

  GrSetMixMode(gstate, MM_COPY);
  
  GrSetAreaColor(gstate, CF_INDEX, C_BROWN, 0, 0);
  GrSetLineColor(gstate, CF_INDEX, C_BLACK, 0, 0);
  GrSetLineWidth(gstate, 1);

  x = FIRST_HORIZ + 1 + (pself->PBP_horizPos) * BATTLE_BLOCK;
  y = FIRST_HORIZ + 1 + (pself->PBP_vertPos) * BATTLE_BLOCK;

  /* Check to see if we bother to draw logs */
  if (battleRaftSetup & BATTLE_DRAW_LOGS) {
    /* Yep draw logs for the raft */

  /* Draw logs so that there is 1 less then the amount to fill
   * the blocks covered by the raft. */
  
  do {
    
    if (pself->PBP_direction == PBP_HORIZONTAL) {
      GrFillRoundRect(gstate, x, y, x + LOG_SIZE, y + LOG_LENGTH, LOG_CURVE); 
      GrDrawRoundRect(gstate, x, y, x + LOG_SIZE, y + LOG_LENGTH, LOG_CURVE); 
      x += LOG_SIZE;
    } else {
      GrFillRoundRect(gstate, x, y, x + LOG_LENGTH, y + LOG_SIZE, LOG_CURVE); 
      GrDrawRoundRect(gstate, x, y, x + LOG_LENGTH, y + LOG_SIZE, LOG_CURVE); 
      y += LOG_SIZE;
    }

    i++;

  } while (i < (pself->PBP_size * NO_OF_LOGS));
  } else {      
    /* Just draw one big log for speed */
    if (pself->PBP_direction == PBP_HORIZONTAL) {
      GrFillRoundRect(gstate, x, y,
		pself->PBP_size * NO_OF_LOGS * LOG_SIZE + x - LOG_SIZE,
		LOG_LENGTH + y, LOG_CURVE + 2);
      GrDrawRoundRect(gstate, x, y,
		pself->PBP_size * NO_OF_LOGS * LOG_SIZE + x - LOG_SIZE,
		LOG_LENGTH + y, LOG_CURVE + 2);
    } else {
      GrFillRoundRect(gstate, x, y, LOG_LENGTH + x,
		pself->PBP_size * NO_OF_LOGS * LOG_SIZE + y - LOG_SIZE,
		LOG_CURVE + 2);
      GrDrawRoundRect(gstate, x, y,  LOG_LENGTH + x,
		pself->PBP_size * NO_OF_LOGS * LOG_SIZE + y - LOG_SIZE,
		LOG_CURVE + 2);
    }
  }

  /* Draw any needed holes in the raft */

  GrSetAreaColor(gstate, CF_INDEX, C_LIGHT_CYAN, 0, 0);
  
  xPos = pself->PBP_horizPos;
  yPos = pself->PBP_vertPos;
  x = xPos * BATTLE_BLOCK + FIRST_HORIZ - 1 + BATTLE_BLOCK / 4;
  y = yPos * BATTLE_BLOCK + FIRST_VERT - 1 + BATTLE_BLOCK / 4;

  for (i = 0; i < pself->PBP_size; i ++) {
    if (@call PlayerBattleBoard::MSG_BOARD_CHECK_GRID(xPos, yPos) 
						      & BR_ROCK) {  
      /* raft has been hit */
      GrFillEllipse(gstate, x, y, 
	    x + BATTLE_BLOCK / 2, y + BATTLE_BLOCK / 2);
      GrDrawEllipse(gstate, x, y, 
	    x + BATTLE_BLOCK / 2, y + BATTLE_BLOCK / 2);
    }
    /* Increment to next location in raft */
    if (pself->PBP_direction == PBP_HORIZONTAL) {
      x += BATTLE_BLOCK;
      xPos ++; 
    } else {
      y += BATTLE_BLOCK;
      yPos ++; 
    }
  } /* next i */
  
  /* 
   * After handling the message, call the superclass to ensure
   * that no default behavior has been mucked up.
   */

  @callsuper();
}


/***********************************************************************
 *              MSG_META_START_SELECT for PlayerBattlePieceClass
 ***********************************************************************
 * SYNOPSIS:    Grabs the mouse and calls for future pointer events.
 *              When the user clickes in the view, PlayerBattleView will
 *              pass the click event to PlayerBattleBoard. Since
 *              PlayerBattleBoardClass does not intercept the event,
 *              VisContentClass passes it on to its child object currently   
 *              under the pointer.
 * PARAMETERS:  
 *      void (MouseReturnParams *retVal,
 *                      word xPosition, word yPosition, word inputState);    
 * SIDE EFFECTS:    
 *
 * STRATEGY:    When the piece object receives this message, it means
 *              it has been clicked on by the user and the mouse button
 *              is still down.  The piece must grab the mouse so that it
 *              gets all future mouse events, and it must request that
 *              all future mouse events be sent to it.  This ensures
 *              that if the pointer leaves the object's bounds while
 *              the button is still pressed, the piece object will still
 *              receive all the pointer events (otherwise they would be
 *              sent to whatever object was under the new pointer
 *              position).
 *
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      DR      1/31/94         Initial Revision
 *
 ***********************************************************************/

@method PlayerBattlePieceClass, MSG_META_START_SELECT {

  if (battleStarted == BR_GAME_NEW) {
    /* don't move pieces when game over or battle started */
  
  /* 
   * Grab the gadget exclusive, so that we're allowed to grab
   * the mouse.
   */

  @call @visParent::MSG_VIS_TAKE_GADGET_EXCL(oself);

  /* 
   * Grab the mouse.  This requests that all future pointer
   * events be passed directly to this game piece.
   */

  @call self::MSG_VIS_GRAB_MOUSE();           
	
  /* 
   * Finally, return that this particular click event has been
   * processed.  If this flag is not returned, the system will
   * send out the click event again.
   */
}
    retVal->flags = MRF_PROCESSED;      /* this event processed */
}


/***********************************************************************
 *              MSG_META_DRAG_SELECT for PlayerBattlePieceClass
 ***********************************************************************
 * SYNOPSIS:    This message is sent to the piece object when the
 *              select button has been pressed and the mouse has been
 *              moved, resulting in a "drag-select" event.
 *              For event processing from the View, see the header
 *              for MSG_META_START_SELECT.    
 * PARAMETERS:  
 *      void (MouseReturnParams *retVal,
 *                      word xPosition, word yPosition, word inputState);    
 *
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      DR      1/31/94         Initial Revision
 *
 ***********************************************************************/

@method PlayerBattlePieceClass, MSG_META_DRAG_SELECT {

  GStateHandle gstate;
  WindowHandle win;
  sword x = 0;
  sword y = 0;

  if (battleStarted == BR_GAME_NEW) {
    /* don't move pieces when game over or battle started */

  /* Set flag indicating that we're being dragged. */

  pself->PBP_dragging = TRUE;

  /* 
   * Get the view's window handle and create a temporary gstate
   * for drawing into.
   */

  win = @call PlayerBattleView::MSG_GEN_VIEW_GET_WINDOW();
  gstate = GrCreateState(win);

  /* 
   * Set the color to black and the drawing mode to MM_INVERT
   * for outline drawing.
   */

  GrSetLineColor(gstate, CF_INDEX, C_BLACK, 0, 0);
  GrSetMixMode(gstate, MM_INVERT);

  /* 
   * Now set the current motion position so the top left of the raft is
   * centered on the pointer.
   */

  pself->PBP_vertPos = yPosition / BATTLE_BLOCK;
  pself->PBP_horizPos = xPosition / BATTLE_BLOCK;

  /* Draw the new outline at the current position. */

  x = FIRST_HORIZ + 1 + pself->PBP_horizPos * BATTLE_BLOCK;
  y = FIRST_VERT + 1 + pself->PBP_vertPos * BATTLE_BLOCK;
  
  /* Draw outline in proper direction */
  if (pself->PBP_direction == PBP_HORIZONTAL) {

    GrDrawRoundRect(gstate, x, y, 
			    x + pself->PBP_size * BATTLE_BLOCK - LOG_SIZE, 
			    y + LOG_LENGTH, LOG_CURVE);
  } else {

    GrDrawRoundRect(gstate, x, y, 
			    x + LOG_LENGTH, 
			    y + pself->PBP_size * BATTLE_BLOCK - LOG_SIZE, 
			    LOG_CURVE);
  }

  GrDestroyState(gstate);
}
  retVal->flags = MRF_PROCESSED;
}



/***********************************************************************
 *              MSG_META_PTR for PlayerBattlePieceClass
 ***********************************************************************
 * SYNOPSIS:    This message is received whenever the pointer passes
 *              over this game piece object's bounds (and another
 *              game piece is not sitting directly on top of it).
 *              See MSG_META_START_SELECT for a description of how the event
 *              gets passed from PlayerBattleView to this object.    
 * PARAMETERS:      
 *      void (MouseReturnParams *retVal,
 *                      word xPosition, word yPosition, word inputState);
 *
 * STRATEGY:    This message can be either a drag event or a simple
 *              pointer event.  If the latter, we want to do nothing
 *              because no mouse button is pressed.  If the latter,
 *              we want to execute the same function as MSG_DRAG.
 *
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      DR      1/31/94         Initial Revision
 *
 ***********************************************************************/
@method PlayerBattlePieceClass, MSG_META_PTR {

  GStateHandle gstate;
  WindowHandle win;
  sword x = 0;
  sword y = 0;
  int xnew = 0;
  int ynew = 0;

  if (battleStarted == BR_GAME_NEW) {
    /* don't move pieces when game over or battle started */

  /* 
   * First check if piece is being dragged. If not, do nothing
   * and return that this event was not processed. Also check 
   * to see if raft changed grid positions. If this is a
   * true, then draw a new outline and erase the old outline.
   */

  xnew = xPosition / BATTLE_BLOCK;
  ynew = yPosition / BATTLE_BLOCK;

  if ((pself->PBP_dragging) && ((xnew != pself->PBP_horizPos) 
     || (ynew != pself->PBP_vertPos))) {

    win = @call PlayerBattleView::MSG_GEN_VIEW_GET_WINDOW();
    gstate = GrCreateState(win);

    GrSetLineColor(gstate, CF_INDEX, C_BLACK, 0, 0);
    GrSetMixMode(gstate, MM_INVERT);

    /* 
     * Erase the old outline by drawing an inverse outline at the
     * old bounds.
     */

    x = FIRST_HORIZ + 1 + pself->PBP_horizPos * BATTLE_BLOCK;
    y = FIRST_VERT + 1 + pself->PBP_vertPos * BATTLE_BLOCK;
  
    if (pself->PBP_direction == PBP_HORIZONTAL) {
      GrDrawRoundRect(gstate, x, y, 
			    x + pself->PBP_size * BATTLE_BLOCK - LOG_SIZE, 
			    y + LOG_LENGTH, LOG_CURVE);
    } else {
    GrDrawRoundRect(gstate, x, y, 
			    x + LOG_LENGTH, 
			    y + pself->PBP_size * BATTLE_BLOCK - LOG_SIZE, 
			    LOG_CURVE);
    }

    /* 
     * Now set the current motion position so the top left of the raft is
     * centered on the pointer.
     */

    pself->PBP_horizPos = xnew;
    pself->PBP_vertPos = ynew;
    x = FIRST_HORIZ + 1 + pself->PBP_horizPos * BATTLE_BLOCK;
    y = FIRST_VERT + 1 + pself->PBP_vertPos * BATTLE_BLOCK;

    /* Draw the new outline at the current position. */
  
    if (pself->PBP_direction == PBP_HORIZONTAL) {

      GrDrawRoundRect(gstate, x, y, 
			    x + pself->PBP_size * BATTLE_BLOCK - LOG_SIZE, 
			    y + LOG_LENGTH, LOG_CURVE);
    
    } else {
      
      GrDrawRoundRect(gstate, x, y, 
			    x + LOG_LENGTH, 
			    y + pself->PBP_size * BATTLE_BLOCK - LOG_SIZE, 
			    LOG_CURVE);
    }

	GrDestroyState(gstate);
  }
}
    retVal->flags = MRF_PROCESSED;      /* this event processed */
}


/***********************************************************************
 *              MSG_META_END_SELECT for PlayerBattlePieceClass
 ***********************************************************************
 * SYNOPSIS:    This message is received when the selection button has
 *              been released and this game piece had the mouse grab.
 *              All it does is release the gadget exclusive, which will
 *              cause us to end any dragging in process, & release the
 *              mouse.    
 * PARAMETERS:  
 *      void (MouseReturnParams *retVal,
 *                      word xPosition, word yPosition, word inputState);    
 *
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      DR      1/31/94         Initial Revision
 *
 ***********************************************************************/

@method PlayerBattlePieceClass, MSG_META_END_SELECT {

  if (battleStarted == BR_GAME_NEW) {
    /* don't move pieces when game over or battle started */

    @call @visParent::MSG_VIS_RELEASE_GADGET_EXCL(oself);
}
    retVal->flags = MRF_PROCESSED;      /* this event processed */
}


/***********************************************************************
 *              MSG_VIS_LOST_GADGET_EXCL for PlayerBattlePieceClass
 ***********************************************************************
 * SYNOPSIS:    This message is received when the selection button has
 *              been released and this game piece had the mouse grab.
 *              It first checks to see if the new, proposed bounds are
 *              on the game board.  If the bounds are valid, then
 *              it sets the objects VI_bounds field to the new values
 *              and causes the object to erase its original drawing
 *              and draw itself at its new bounds.  If the bounds are
 *              not on the game board, it will retain the original bounds.
 * PARAMETERS:      
 *      void ();
 *
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      DR      1/31/94         Initial Revision
 *
 ***********************************************************************/
@method PlayerBattlePieceClass, MSG_VIS_LOST_GADGET_EXCL {

  WindowHandle win;
  GStateHandle gstate;
  sword x, x1 = 0;
  sword y, y1 = 0;

  if (battleStarted == BR_GAME_NEW) {
    /* don't move pieces when game over or battle started */

  /* 
   * See if piece was being dragged or not.  If so, we have to
   * clear out outine.
   */

  if (pself->PBP_dragging) {

    win = @call PlayerBattleView::MSG_GEN_VIEW_GET_WINDOW();
    gstate = GrCreateState(win);


    GrSetLineColor(gstate, CF_INDEX, C_BLACK, 0, 0);
    GrSetMixMode(gstate, MM_INVERT);

    /* Erase outline on screen. */

    x = FIRST_HORIZ + 1 + pself->PBP_horizPos * BATTLE_BLOCK;
    y = FIRST_VERT + 1 + pself->PBP_vertPos * BATTLE_BLOCK;
  
    if (pself->PBP_direction == PBP_HORIZONTAL) {
      
      x1 = x + pself->PBP_size * BATTLE_BLOCK - LOG_SIZE;
      y1 = y + LOG_LENGTH;
      GrDrawRoundRect(gstate, x, y, x1, y1, LOG_CURVE);
    
    } else {
      
      x1 = x + LOG_LENGTH;
      y1 = y + pself->PBP_size * BATTLE_BLOCK - LOG_SIZE;
      GrDrawRoundRect(gstate, x, y, x1, y1, LOG_CURVE);
    }

    /* 
     * Check to see if the new bounds are on the game board.  If
     * they are, set the object's bounds to the new values.  If
     * the are not, retain the original values and set the values
     * to those last stored.
     */

    if (@call PlayerBattleBoard::MSG_BOARD_PLACE_PIECE_CHECK( 
	      pself->PBP_horizPos, pself->PBP_vertPos,
	      pself->PBP_size, pself->PBP_direction, pself->PBP_type)) {

      /* 
       * Invalidate the original drawing of the game piece.  Send
       * the VI_bounds rectangle as the parameters because they have
       * not been changed since the START_SELECT.  This message is
       * the equivalent of calling GrInvalRect() with the same
       * bounds.
       */

      @call self::MSG_VIS_BOUNDS_CHANGED(
				pself->VI_bounds.R_bottom,
				pself->VI_bounds.R_right,
				pself->VI_bounds.R_top,
				pself->VI_bounds.R_left);

      /* Erase the raft from the battle grid at old position */

      @call PlayerBattleBoard::MSG_BOARD_PLACE_PIECE(
	    pself->VI_bounds.R_left / BATTLE_BLOCK,
	    pself->VI_bounds.R_top / BATTLE_BLOCK,
	    pself->PBP_size, pself->PBP_direction, BR_EMPTY);

      /* Set the game piece object's bounds to the new coordinates. */

      pself->VI_bounds.R_left = x - 1;
      pself->VI_bounds.R_right = x1 + 1;
      pself->VI_bounds.R_top = y - 1;
      pself->VI_bounds.R_bottom = y1 + 1;

      /* Place the raft in the battle grid at new position */

      @call PlayerBattleBoard::MSG_BOARD_PLACE_PIECE(
	    pself->PBP_horizPos, pself->PBP_vertPos,
	    pself->PBP_size, pself->PBP_direction, pself->PBP_type);
    
      /* 
       * Now, the game piece must draw itself at its newly-set
       * bounds.
       */  

       @call self::MSG_VIS_DRAW(0, gstate);
    
    } else {

      /* 
       * If the bounds are not on the game board, then  reset the
       * current positions to be the original bounds. Warn User.
       */

      pself->PBP_horizPos = pself->VI_bounds.R_left / BATTLE_BLOCK;
      pself->PBP_vertPos = pself->VI_bounds.R_top / BATTLE_BLOCK;
      UserStandardSound(SST_ERROR);
    }

    GrDestroyState(gstate);

    /* Clear flag to indicate we are no longer dragging. */

    pself->PBP_dragging = FALSE;
  
  }

  /* 
   * Release the mouse grab now that the move has finished.
   * Other objects in the view (other game pieces, for example)
   * may now receive pointer, select, and drag events.
   */ 

  @call self::MSG_VIS_RELEASE_MOUSE();
}
}


/***********************************************************************
 *              MSG_META_START_MOVE_COPY for PlayerBattlePieceClass
 ***********************************************************************
 * SYNOPSIS:    This message is received when the move/copy button has
 *              been pressed.
 *              It first checks to see if the new, proposed bounds are
 *              on the game board.  If the bounds are valid, then
 *              it sets the objects VI_bounds field to the new values
 *              and causes the object to erase its original drawing
 *              and draw itself at its new bounds.  If the bounds are
 *              not on the game board, it will retain the original bounds
 *              and redraw using them.    
 * PARAMETERS:      
 *      void (MouseReturnParams *retVal,
 *                      word xPosition, word yPosition, word inputState);    
 *
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      DR      1/31/94         Initial Revision
 *
 ***********************************************************************/
@method PlayerBattlePieceClass, MSG_META_START_MOVE_COPY {

  WindowHandle win;
  GStateHandle gstate;
  int direction = PBP_HORIZONTAL;
  sword x, x1, y, y1;

  if (battleStarted == BR_GAME_NEW) {
    /* don't move pieces when game over or battle started */

    /*
	* Calculate proposed bounds of new direction.
	*/
    x = FIRST_HORIZ + 1 + pself->PBP_horizPos * BATTLE_BLOCK;
    y = FIRST_VERT + 1 + pself->PBP_vertPos * BATTLE_BLOCK;

    if (pself->PBP_direction == PBP_HORIZONTAL) {
	 x1 = x + LOG_LENGTH;
	 y1 = y + pself->PBP_size * BATTLE_BLOCK - LOG_SIZE;
	 /* Change direction for test */
	 direction = PBP_VERTICAL;
    } else {
	 x1 = x + pself->PBP_size * BATTLE_BLOCK - LOG_SIZE;
	 y1 = y + LOG_LENGTH;
    }

    /*
	* Check to see if the new bounds are on the game board.  If
	* they are, set the object's bounds to the new values.  If
	* the are not, retain the original values and set the values
	* to those last stored.
	*/

    if (@call PlayerBattleBoard::MSG_BOARD_PLACE_PIECE_CHECK(
	    pself->PBP_horizPos, pself->PBP_vertPos,
	    pself->PBP_size, direction, pself->PBP_type)) {

	 /*
	  * Piece will fit in new direction.
	  */

	 @call self::MSG_VIS_BOUNDS_CHANGED(
				pself->VI_bounds.R_bottom,
				pself->VI_bounds.R_right,
				pself->VI_bounds.R_top,
				pself->VI_bounds.R_left);

	 /* Erase the raft from the battle grid at old position */

	 @call PlayerBattleBoard::MSG_BOARD_PLACE_PIECE(
	    pself->PBP_horizPos, pself->PBP_vertPos,
	    pself->PBP_size, pself->PBP_direction, BR_EMPTY);

	 /* Rotate piece */
	 pself->PBP_direction = direction;
    
	 /* Set the game piece object's bounds to the new coordinates. */

	 pself->VI_bounds.R_left = x - 1;
	 pself->VI_bounds.R_right = x1 + 1;
	 pself->VI_bounds.R_top = y - 1;
	 pself->VI_bounds.R_bottom = y1 + 1;

	 /* Place the raft in the battle grid at new position */

	 @call PlayerBattleBoard::MSG_BOARD_PLACE_PIECE(
	    pself->PBP_horizPos, pself->PBP_vertPos,
	    pself->PBP_size, pself->PBP_direction, pself->PBP_type);

	 /*
	  * Now, the game piece must draw itself at its newly-set
	  * bounds.
	  */
    
	 win = @call PlayerBattleView::MSG_GEN_VIEW_GET_WINDOW();
	 gstate = GrCreateState(win);

	 @call self::MSG_VIS_DRAW(0, gstate);

	 GrDestroyState(gstate);
    } else {
	 /* Piece will not fit. Warn user. */
	 UserStandardSound(SST_ERROR);
    }
  }  /* end of new game if */

  /*
   * Finally, return that this particular click event has been
   * processed.  If this flag is not returned, the system will
   * send out the click event again.
   */
  retVal->flags = MRF_PROCESSED;      /* this event processed */

}

