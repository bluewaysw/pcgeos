/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	Copyright (c) Derrick Renaud 1994 -- All Rights Reserved

PROJECT:        Battle Raft     
MODULE:         Battle Raft application
FILE:           battle.goc

AUTHOR:         Derrick Renaud, January 31, 1994

REVISION HISTORY:
	Name    Date            Description
	----    ----            -----------
	DR      1/31/94         Initial version. 1.0
	DR      2/7/94          Rev 1.1 added monochrome fix
				 and fast log drawing.
				Added skill levels. (Beginner and
				 Intermediate)
	DR      3/14/94         Rev 1.2 added board size and 
				 scale to fit viewing.
	jfh	   10/11/00	    Started conversion to Treasure Hunt

DESCRIPTION:    This application is a game similar to Battle Ship.

***********************************************************************/


/***********************************************************************
 *              Include files
 ***********************************************************************/

#include <Ansi/string.h>
#include <initfile.h> 
@include <stdapp.goh>   /* standard application inclusion file */
@include <math.goh>     /* need for random numbers */
#include <gstring.h>    /* needed for the icons */
@include "art/AppIcon.goh"

@include "art/AUpLeft.goh"
@include "art/AUpMid.goh"
@include "art/AUpRight.goh"
@include "art/ALeft.goh"
@include "art/ARight.goh"
@include "art/ABLeft.goh"
@include "art/ABMid.goh"
@include "art/ABRight.goh"
@include "art/BUpLeft.goh"
@include "art/BUpMid.goh"
@include "art/BUpRight.goh"
@include "art/BLeft.goh"
@include "art/BRight.goh"
@include "art/BBLeft.goh"
@include "art/BBMid.goh"
@include "art/BBRight.goh"

@include "art/treasure.goh"
@include "art/Shovel.goh"
#include <sound.h>


/***********************************************************************
 *              Definitions
 ***********************************************************************/


#define FIRST_HORIZ     1       /* First screen location of grid 0,0 */
#define FIRST_VERT      1
#define BATTLE_BLOCK    20      /* Pts till next grid line */
#define NO_OF_LOGS      5       /* Logs to cover grid location */
#define LOG_SIZE        4       /* Width of logs */
#define LOG_LENGTH      16
#define LOG_CURVE       2       /* Radius of log end */
#define NO_OF_BLOCKS    12      /* MAX # of x-y grid locations */

#define BATTLE_GRID_START       12

/* Start Total length of grid */
#define BOARD_LENGTH		BATTLE_GRID_START * BATTLE_BLOCK +1

#define NO_OF_RAFTS      5

#define BR_EMPTY        0
#define BR_ROCK         0x80
#define BR_RAFT_MASK    7       /* Bit locations of raft */

#define BR_2MAN         1       /* Raft Types */
#define BR_3MAN1        2
#define BR_3MAN2        3
#define BR_4MAN         4  
#define BR_5MAN         5  

#define COMP_DIRECTION_N        1   /* Search directions */
#define COMP_DIRECTION_E        2
#define COMP_DIRECTION_S        3
#define COMP_DIRECTION_W        4

#define PBP_HORIZONTAL  1       /* Direction for raft */
#define PBP_VERTICAL    0

				/* Game Status Flags */
#define BR_GAME_NEW     0       /* Rafts can be moved */
#define BR_GAME_STARTED 1       /* You can take shots */
#define BR_GAME_OVER    2       /* Wait for new game trigger */
#define BR_SHOW_CHESTS  3

#define TURN_PLAYER     0       /* Flag to keep track of who's turn */
#define TURN_COMPUTER   1       /* it is. Gotta take turns you know */

/* Skill Levels */
#define BATTLE_LEVEL_BEGINNER           1
#define BATTLE_LEVEL_INTERMEDIATE       2

#define SHOW_ON_STARTUP   1

#define SOUND_ON 1
#define SOUND_OFF 2
#define SOUND_SYSTEM 3

const word winSoundBuf[] = {     /* from blackjack win sound */
	SSE_CHANGE,             0, IP_ACOUSTIC_GRAND_PIANO, IT_STANDARD_TABLE,
	SSDTT_TICKS,            0,
	SSE_VOICE_ON,           0, MIDDLE_C, DYNAMIC_F,
	SSDTT_TICKS,            10,
	SSE_VOICE_OFF,          0,
	SSDTT_TICKS,            0,
	SSE_VOICE_ON,           0, MIDDLE_E, DYNAMIC_F,
	SSDTT_TICKS,            10,
	SSE_VOICE_OFF,          0,
	SSDTT_TICKS,            0,
	SSE_VOICE_ON,           0, MIDDLE_G, DYNAMIC_F,
	SSDTT_TICKS,            10,
	SSE_VOICE_OFF,          0,
	SSDTT_TICKS,            0,
	SSE_VOICE_ON,           0, HIGH_C, DYNAMIC_F,
	SSDTT_TICKS,            15,
	SSE_VOICE_OFF,          0,
	SSDTT_TICKS,            0,
	SSE_VOICE_ON,           0, MIDDLE_G, DYNAMIC_F,
	SSDTT_TICKS,            8,
	SSE_VOICE_OFF,          0,
	SSDTT_TICKS,            0,
	SSE_VOICE_ON,           0, HIGH_C, DYNAMIC_F,
	SSDTT_TICKS,            25,
	SSE_VOICE_OFF,          0,
	SSDTT_TICKS,            0,
	SSE_GENERAL,            GE_END_OF_SONG};

const word loseSoundBuf[] = {     /* from blackjack lose sound */
	SSE_CHANGE,             0, IP_ACOUSTIC_GRAND_PIANO, IT_STANDARD_TABLE,
	SSDTT_TICKS,            0,
	SSE_VOICE_ON,           0, LOW_D, DYNAMIC_F,
	SSDTT_TICKS,            20,
	SSE_VOICE_OFF,          0,
	SSDTT_TICKS,            1,
	SSE_VOICE_ON,           0, LOW_D, DYNAMIC_F,
	SSDTT_TICKS,            20,
	SSE_VOICE_OFF,          0,
	SSDTT_TICKS,            1,
	SSE_VOICE_ON,           0, LOW_D, DYNAMIC_F,
	SSDTT_TICKS,            7,
	SSE_VOICE_OFF,          0,
	SSDTT_TICKS,            1,
	SSE_VOICE_ON,           0, LOW_D, DYNAMIC_F,
	SSDTT_TICKS,            20,
	SSE_VOICE_OFF,          0,
	SSDTT_TICKS,            0,
	SSE_VOICE_ON,           0, LOW_F, DYNAMIC_F,
	SSDTT_TICKS,            20,
	SSE_VOICE_OFF,          0,
	SSDTT_TICKS,            0,
	SSE_VOICE_ON,           0, LOW_E, DYNAMIC_F,
	SSDTT_TICKS,            7,
	SSE_VOICE_OFF,          0,
	SSDTT_TICKS,            1,
	SSE_VOICE_ON,           0, LOW_E, DYNAMIC_F,
	SSDTT_TICKS,            20,
	SSE_VOICE_OFF,          0,
	SSDTT_TICKS,            0,
	SSE_VOICE_ON,           0, LOW_D, DYNAMIC_F,
	SSDTT_TICKS,            7,
	SSE_VOICE_OFF,          0,
	SSDTT_TICKS,            1,
	SSE_VOICE_ON,           0, LOW_D, DYNAMIC_F,
	SSDTT_TICKS,            20,
	SSE_VOICE_OFF,          0,
	SSDTT_TICKS,            0,
	SSE_VOICE_ON,           0, LOW_D_b, DYNAMIC_F,
	SSDTT_TICKS,            7,
	SSE_VOICE_OFF,          0,
	SSDTT_TICKS,            0,
	SSE_VOICE_ON,           0, LOW_D, DYNAMIC_F,
	SSDTT_TICKS,            20,
	SSE_VOICE_OFF,          0,
	SSDTT_TICKS,            0,
	SSE_GENERAL,            GE_END_OF_SONG};

MemHandle	winSound, loseSound;
word	g_sound;

/* Globals */
int g_gridsize = BATTLE_GRID_START;
int g_battleStarted = BR_GAME_OVER;
int g_battleTurn = TURN_PLAYER;
int g_skillLevel = BATTLE_LEVEL_INTERMEDIATE;
int g_shotsOnCheckerBoard = BATTLE_GRID_START * BATTLE_GRID_START / 2;

/***********************************************************************
 *              Class and Message Definitions
 ***********************************************************************/

/* 
 * Declare the application's process object, so that we can add new
 * messages to it later if we like.
 */

@class  BattleProcessClass, GenProcessClass ;
  /* define messages for this class here. */
  @message void MSG_NEW_GAME();
    /* This message is sent by the `New Game` trigger in the Game menu
     * when the user wants to reset the game.  It is sent transfered to
     * the game board objects and causes the board object first to
     * send the "new game" message to each of its children and then
	* to redraw the game board. */
  @message int MSG_GET_RANDOM_INT(int randomMax);
    /* Return a random integer from 0 to randomMax */
  @message (GEN_ITEM_GROUP_APPLY_MSG) MSG_BATTLE_CHANGE_LEVEL;
  @message (GEN_ITEM_GROUP_APPLY_MSG) MSG_BATTLE_SOUND_CHANGED;
@endc

/*  Declare the class in memory so the method table will be built.      */
@classdecl      BattleProcessClass, neverSaved;

/* to draw the ocean around the islands */
@class  BorderInteractionClass, GenInteractionClass;
@endc
@classdecl      BorderInteractionClass;

/* to draw the island around the views */
@class  BattleInteractionClass, GenInteractionClass;
@endc
@classdecl      BattleInteractionClass;

/************************************************************************
 *                      BattleBoardClass
 *  This class is a subclass of VisContentClass and provides
 *  common fields for the 2 game boards.
 ***********************************************************************/

@class  BattleBoardClass, VisContentClass;
  /* Define the instance data fields of this class: */
  /* # of rafts sunk */
  @instance int BP_sunk;
  /* Size of raft @ [type] */
  @instance int BP_size[NO_OF_RAFTS + 1]; /* +1 so I don't gotta -1 later */
  /* # of hits on raft @ [type] */
  @instance int BP_hitCount[NO_OF_RAFTS + 1];
    /* [0] keeps track of misses */
  @instance   unsigned char BR_board[NO_OF_BLOCKS][NO_OF_BLOCKS];
    /* BR_board[y][x] contains empty/rock/raft information.
     *
     *   7 6 5 4 3 2 1 0
     *   1                      empty                      
     *                          rock
     *             x x x        raft type
     *     x x x x              plenty of room for expansion
     */

  /* Message definitions for this class */
  @message int MSG_BOARD_PLACE_PIECE_CHECK(int x, int y,
		   int size, int direction, int type);
    /* * This message is sent by a raft piece that is being moved by the
     * user and is about to be set down. x and y are the proposed grid 
     * locations. The raft's size, direction and type will have to fit 
     * in the grid. The raft cannot be placed on any other raft other
     * then itself. If the raft can be placed, then this message returns
	* TRUE. Any conflicts and FALSE will be returned. */
  @message void MSG_BOARD_PLACE_PIECE(int x, int y,
		   int size, int direction, int type);
    /* This message is sent by a raft piece that is being moved by the
     * user and is able to be set down. x and y are the grid 
     * locations. The raft's size, direction and type are used to fill 
	* the grid. */
  @message int MSG_BOARD_CHECK_GRID(int x, int y);
    /* This message is returns the value in the grid. */
  @message void MSG_BOARD_NEW_GAME();
    /* This message will notify the board to reset itself. */
@endc

@classdecl      BattleBoardClass;


/************************************************************************
 *                      PlayerBattleBoardClass
 *  This class is a subclass of BattleBoardClass and will control the
 *  action on the left side of the screen.
 ***********************************************************************/

@class  PlayerBattleBoardClass, BattleBoardClass;
  @instance int compLastX;            /* Last search location */
  @instance int compLastY;
  @instance int compStartDirection;   /* Direction search started at */
  @instance int compDirection;        /* Current search direction */
  @instance int compDirectionSpin;    /* Direction to rotate search */
  @instance int compWorkingOnHit;     /* Last shot was a hit flag */
  @instance int compProgress;         /* Progress was made in last search */
  @message void MSG_COMPUTER_MAKE_SHOT();
    /* Place a computer piece on the gameboard */
@endc

@classdecl      PlayerBattleBoardClass;


/************************************************************************
 *                      ComputerBattleBoardClass
 *  This class is a subclass of BattleBoardClass and will control the
 *  action on the right side of the screen.
 ***********************************************************************/

@class  ComputerBattleBoardClass, BattleBoardClass;
@endc

@classdecl      ComputerBattleBoardClass;


/************************************************************************
 *                      PlayerBattlePieceClass
 *  This class is a subclass of VisClass [Obj 24] and provides all the
 *  functions necessary for a game piece in the game.
 ***********************************************************************/

@class  PlayerBattlePieceClass, VisClass;
  @instance   char PBP_type;
    /* PBP_type defines what type of piece it is. */
  @instance   char PBP_size;
    /* PBP_size defines how long the raft is. */
  @instance   Boolean PBP_direction;
    /* PBP_direction defines wheither the raft is horizontal
	* or vertical. */
  @instance   int  PBP_vertPos;
    /* PBP_vertPos indicates the current y position of
     * the piece.  This does not indicate the piece's actual
	* bounds but rather where its moving outline appears. */
  @instance   int PBP_horizPos;
    /* PBP_horizPos indicates the current x position of
     * the piece.  This does not indicate the piece's actual
	* bounds but rather where its moving outline appears. */
  @instance   Boolean PBP_dragging;
    /* Set if user is dragging this piece somewhere around the board */
     
  /* Message definitions unique to this class.  */
  @message void MSG_PLAYER_PIECE_SETUP(int x, int y,
		   int size, int direction, int type);
    /* This message notifies the piece object that it should set itself
	* to the new parameters. Normally sent only when starting a game. */
@endc

@classdecl      PlayerBattlePieceClass;

/***********************************************************************
 *              The Application Object
 ***********************************************************************/

@start  AppResource ;

@object GenApplicationClass BattleApp = {
    GI_visMoniker = list { @BattleTextMoniker, 
			   @AppIconMoniker,           /* VGA      */
			   @TinyIconMoniker}            /* tiny */
    GI_comp = @BattlePrimary;
    gcnList(MANUFACTURER_ID_GEOWORKS,GAGCNLT_WINDOWS) = @BattlePrimary;
    ATTR_GEN_INIT_FILE_CATEGORY = "Treasure" ;
    ATTR_GEN_INIT_FILE_PROPAGATE_TO_CHILDREN;
}

@visMoniker BattleTextMoniker = "Treasure Hunt";

@end    AppResource

/***********************************************************************
 *              The Primary Window Object
 ***********************************************************************/

@start  Interface ;

@object GenPrimaryClass BattlePrimary  = {
  GI_comp = @BattleFileMenu,
	    @BattleOptionsMenu,
	    @BattleMainGroup,
		 @BRGameOver,
		 @QTipsDialogBox ;
  HINT_DISPLAY_NOT_RESIZABLE;
//  HINT_NO_WIDER_THAN_CHILDREN_REQUIRE;
//  HINT_NO_TALLER_THAN_CHILDREN_REQUIRE;
  HINT_SIZE_WINDOW_AS_DESIRED;
  HINT_CENTER_WINDOW;
  HINT_CENTER_CHILDREN_VERTICALLY;
  HINT_CENTER_CHILDREN_HORIZONTALLY;
  ATTR_GEN_HELP_CONTEXT = "TOC";
  ATTR_GEN_INIT_FILE_CATEGORY = "Treasure" ;
  ATTR_GEN_INIT_FILE_PROPAGATE_TO_CHILDREN;
}


/***********************************************************************
 *              The Game Menu and New Game Trigger Objects
 ***********************************************************************/

@object GenInteractionClass BattleFileMenu = {
  GI_visMoniker = 'G', "Game";
//  GI_comp = @BattleNewTrigger, @BattleQTipsTrigger;
  GI_comp = @BattleGameSubGroup;
  GII_visibility = GIV_POPUP;
  ATTR_GEN_INTERACTION_GROUP_TYPE = (GIGT_FILE_MENU);
}

@object GenInteractionClass BattleGameSubGroup = {
  GI_comp = @BattleNewTrigger, @BattleQTipsTrigger;
  GII_visibility = GIV_SUB_GROUP;
}

@object GenTriggerClass BattleNewTrigger = {
  GI_visMoniker = 'N', "New Game";
  GTI_destination = process;      
  GTI_actionMsg = MSG_NEW_GAME;
}

    /*---------------------------------------------------------------------*/
	 @object GenTriggerClass BattleQTipsTrigger = {
		  GI_visMoniker   = 'Q', "Quick Tips" ;
		  GTI_destination = @QTipsDialogBox ;
		  GTI_actionMsg   = MSG_GEN_INTERACTION_INITIATE ;
		  HINT_TRIGGER_BRINGS_UP_WINDOW;
	 }

@object GenInteractionClass BattleOptionsMenu = {
  GI_visMoniker = 'O', "Options";
  GI_comp = @BattleSoundOpt, @BattleOptionsLevel;
  GII_visibility = GIV_POPUP;         
  ATTR_GEN_INIT_FILE_PROPAGATE_TO_CHILDREN;
}

	 /*---------------------------------------------------------------------*/
	 @object GenInteractionClass BattleSoundOpt = {
		  GI_visMoniker = 'S', "Sound" ;
		  GI_comp = @SoundGroup;
		  GII_visibility = GIV_POPUP;
	 }
	 /*---------------------------------------------------------------------*/
	 @object GenItemGroupClass SoundGroup = {
		  GI_comp          = @SoundOn,
									@SoundOff,
									@SystemPref ;
		  GIGI_selection   = SOUND_SYSTEM ;
        GIGI_destination = process ;
		  GIGI_applyMsg = MSG_BATTLE_SOUND_CHANGED ;
    }
    /*---------------------------------------------------------------------*/
	 @object GenItemClass SoundOn = {
		  GI_visMoniker = 'S', "Sound On" ;
		  GII_identifier = SOUND_ON ;
    }
	 /*---------------------------------------------------------------------*/
	 @object GenItemClass SoundOff = {
		  GI_visMoniker = 'O', "Sound Off" ;
		  GII_identifier = SOUND_OFF ;
	 }
	 /*---------------------------------------------------------------------*/
	 @object GenItemClass SystemPref = {
		  GI_visMoniker = 'P', "Use System Preference" ;
		  GII_identifier = SOUND_SYSTEM ;
	 }

@object GenItemGroupClass BattleOptionsLevel = {
  GI_comp = @BattleOptionsLevelHeading,
	    @BattleOptionsLevelBeginner,
	    @BattleOptionsLevelIntermediate;
  GIGI_destination = process;
  GIGI_applyMsg = MSG_BATTLE_CHANGE_LEVEL;
  GIGI_selection = BATTLE_LEVEL_INTERMEDIATE;
  ATTR_GEN_INIT_FILE_KEY = "level" ;
}

@object GenGlyphClass BattleOptionsLevelHeading = {
  GI_visMoniker = "Computer Level";
  HINT_CENTER_MONIKER;
  ATTR_GEN_INIT_FILE_KEY = "level" ;
}

@object GenItemClass BattleOptionsLevelBeginner = { 
  GI_visMoniker = 'E', "Easy";
  GII_identifier = BATTLE_LEVEL_BEGINNER;
}

@object GenItemClass BattleOptionsLevelIntermediate = { 
  GI_visMoniker = 'D', "Difficult        ";
  GII_identifier = BATTLE_LEVEL_INTERMEDIATE;
}

@object GenInteractionClass BRGameOver = {
  GI_visMoniker = "Game Over";
  GI_comp = @BRGameOverText,
	    @BRGameOverTextQuestion,
	    @BRGameOverYes,
	    @BRGameOverNo;
  GII_type = GIT_AFFIRMATION;
  GII_visibility = GIV_DIALOG;
  GII_attrs = @default | GIA_MODAL | GIA_NOT_USER_INITIATABLE;
  HINT_CENTER_CHILDREN_HORIZONTALLY;
}

@visMoniker ComputerWonText = "Too late!  You didn't find all the treasure.";
@visMoniker PlayerWonText = "Congratulations!  You found all the treasure.";

@object GenGlyphClass BRGameOverText = {
  /* Moniker will be set before calling dialog */
  HINT_CENTER_MONIKER;
}

@object GenGlyphClass BRGameOverTextQuestion = {
  GI_visMoniker = "Do you want to play again?";
  HINT_CENTER_MONIKER;
}

@object GenTriggerClass BRGameOverYes = {
  GI_attrs = @default | GA_SIGNAL_INTERACTION_COMPLETE;
  GTI_destination = process;
  GTI_actionMsg = MSG_NEW_GAME;
  ATTR_GEN_TRIGGER_INTERACTION_COMMAND = {IC_YES};
  HINT_SEEK_REPLY_BAR;
}

@object GenTriggerClass BRGameOverNo = {
  GI_attrs = @default | GA_SIGNAL_INTERACTION_COMPLETE;
//  GTI_destination = @BattleApp;
//  GTI_actionMsg = MSG_META_QUIT;
  ATTR_GEN_TRIGGER_INTERACTION_COMMAND = {IC_NO};
  HINT_SEEK_REPLY_BAR;
}
/***********************************************************************
 *              The View Window Objects
 ***********************************************************************/
  /* A lot of fixed size stuff here to keep the graphics pieces fitting
   * together correctly and for those background parts to fit nicely
   * with the two grids. */

/* to draw the ocean */
@object BorderInteractionClass BattleMainGroup = {
  GI_comp = @BattleMainInteraction;
  HINT_EXPAND_WIDTH_TO_FIT_PARENT;
  HINT_EXPAND_HEIGHT_TO_FIT_PARENT;
  HINT_CENTER_CHILDREN_VERTICALLY;
  HINT_CENTER_CHILDREN_HORIZONTALLY;
}

/* to draw the island graphics */
@object BattleInteractionClass BattleMainInteraction = {
  GI_comp = @SpaceLeft, @BattleBoardsGroup, @SpaceRight;
  HINT_ORIENT_CHILDREN_HORIZONTALLY;
  HINT_FIXED_SIZE = {SST_PIXELS | 624, SST_PIXELS | 387, 0};
}

@object GenInteractionClass SpaceLeft = {
  HINT_FIXED_SIZE = {SST_PIXELS | 27, SST_PIXELS | 387, 0};
}

@object GenInteractionClass BattleBoardsGroup = {
  GI_comp = @PlayerBattleView, @ComputerBattleView;
  HINT_ORIENT_CHILDREN_HORIZONTALLY;
  HINT_FULL_JUSTIFY_CHILDREN_HORIZONTALLY;
  HINT_CENTER_CHILDREN_VERTICALLY;
  HINT_FIXED_SIZE = {SST_PIXELS | 559, SST_PIXELS | 387, 0};
}

@object GenInteractionClass SpaceRight = {
  HINT_FIXED_SIZE = {SST_PIXELS | 38, SST_PIXELS | 387, 0};
}

@object GenViewClass PlayerBattleView = {
  GVI_content = PlayerBattleBoard;
  GVI_docBounds = {0, 0, BOARD_LENGTH, BOARD_LENGTH};
//  GVI_color = { 243, CF_RGB, 225, 153 };
  GVI_horizAttrs = @default | GVDA_NO_LARGER_THAN_CONTENT
					   | GVDA_NO_SMALLER_THAN_CONTENT;
  GVI_vertAttrs = @default | GVDA_NO_LARGER_THAN_CONTENT
					  | GVDA_NO_SMALLER_THAN_CONTENT;
}

@object GenViewClass ComputerBattleView = {
  GVI_content = ComputerBattleBoard;
  GVI_docBounds = {0, 0, BOARD_LENGTH, BOARD_LENGTH};
//  GVI_color = { 243, CF_RGB, 225, 153 };
  GVI_horizAttrs = @default | GVDA_NO_LARGER_THAN_CONTENT
					   | GVDA_NO_SMALLER_THAN_CONTENT;
  GVI_vertAttrs = @default | GVDA_NO_LARGER_THAN_CONTENT
					  | GVDA_NO_SMALLER_THAN_CONTENT;
}


@end    Interface       /* End of the Interface resource block. */


/***********************************************************************
 *              The Visible Tree
 ***********************************************************************/

@start BoardBlock;      /*  This resource block contains all the        * 
			 *  visible objects in the visible tree.        */


/***********************************************************************
 *              The Game Board Objects
 ***********************************************************************/
/* 
 * These objects act as three things:  The content object of a
 * BattleView, the game board of the game, and the organizational
 * object for all the game pieces.  The bounds of this object are the
 * exact size of the game board, and each player raft is a child in the
 * visible tree.
 */ 

@object PlayerBattleBoardClass PlayerBattleBoard = { 
  VI_bounds = {0, 0, BOARD_LENGTH, BOARD_LENGTH};
  VCI_geoAttrs = VCGA_CUSTOM_MANAGE_CHILDREN;
}

@object ComputerBattleBoardClass ComputerBattleBoard = {
  VI_bounds = {0, 0, BOARD_LENGTH, BOARD_LENGTH};
  VCI_geoAttrs = VCGA_CUSTOM_MANAGE_CHILDREN;
}

@end BoardBlock         /*  End of the BoardBlock resource block. */


@start QTipsResource;
@include "art/QTip1.goh"
@include "art/QTip2.goh"

	 @object GenInteractionClass QTipsDialogBox = {
		  GI_visMoniker = "Treasure Hunt Quick Tips";
		  GI_comp = @GoalText,
						@QuickTipsGroup,
						@ShowOnStartupGroup,
						@OKTipsButton;
		  GII_visibility = GIV_DIALOG ;
		  GII_attrs = @default | GIA_MODAL | GIA_NOT_USER_INITIATABLE;
		  HINT_CENTER_CHILDREN_HORIZONTALLY ;
		  ATTR_GEN_HELP_CONTEXT = "TOC";
	 }


	 @object GenTextClass GoalText = {
		  GI_attrs = @default | GA_READ_ONLY;
		  GTXI_text = "The goal of the game is to find all the treasures that your opponent (the computer) has hidden before your opponent can find yours.";
		  ATTR_GEN_TEXT_NEVER_MAKE_SCROLLABLE;
	 }

	 @object GenBooleanGroupClass ShowOnStartupGroup = {
		  GI_comp = @ShowOnStartupBoolean;
	 }

	 @object GenBooleanClass ShowOnStartupBoolean = {
		  GI_visMoniker = 'S', "Show this Dialog box when Treasure Hunt starts";
		  GBI_identifier = SHOW_ON_STARTUP;
	 }

	 @object GenTriggerClass OKTipsButton = {
		  GI_visMoniker   = 'O', "OK";
        GI_attrs = @default | GA_SIGNAL_INTERACTION_COMPLETE ;
		  HINT_SEEK_REPLY_BAR;
		  HINT_DEFAULT_DEFAULT_ACTION;
	 }


	 @object GenInteractionClass QuickTipsGroup = {
		  GI_comp = @QTip1,
						@QTip2;
	 }

	 @object GenInteractionClass QTip1 = {
		  GI_comp = @QTip1GlyphHolder, @QTip1Text ;
		  HINT_ORIENT_CHILDREN_HORIZONTALLY;
		  HINT_CENTER_CHILDREN_VERTICALLY;
	 }

	 @object GenInteractionClass QTip1GlyphHolder = {
		  GI_comp = @QTip1Glyph;
		  HINT_CENTER_CHILDREN_HORIZONTALLY;
		  HINT_CENTER_CHILDREN_VERTICALLY;
		  HINT_FIXED_SIZE = {SST_PIXELS | 105, 0,0};
        /* ^^^ is based on the width of the widest icon */
	 }

	 @object GenGlyphClass QTip1Glyph = {
		  GI_visMoniker = list { @QTip1Moniker };
	 }

	 @object GenTextClass QTip1Text = {
		  GI_attrs = @default | GA_READ_ONLY;
		  GTXI_text = "You have 5 groups of treasure chests.  To move a group, click and hold down the mouse button and slide the group to a new spot on your grid.  To rotate a group of treasure chests click once on the group with the right mouse button.";
		  ATTR_GEN_TEXT_NEVER_MAKE_SCROLLABLE;
		  HINT_MINIMUM_SIZE = {SST_PIXELS | 325, 0, 0};
	 }

	 @object GenInteractionClass QTip2 = {
		  GI_comp = @QTip2GlyphHolder, @QTip2Text ;
		  HINT_ORIENT_CHILDREN_HORIZONTALLY;
		  HINT_CENTER_CHILDREN_VERTICALLY;
	 }

	 @object GenInteractionClass QTip2GlyphHolder = {
		  GI_comp = @QTip2Glyph;
		  HINT_CENTER_CHILDREN_HORIZONTALLY;
		  HINT_CENTER_CHILDREN_VERTICALLY;
		  HINT_FIXED_SIZE = {SST_PIXELS | 105, 0,0};
	 }

	 @object GenGlyphClass QTip2Glyph = {
		  GI_visMoniker = list { @QTip2Moniker };
	 }

	 @object GenTextClass QTip2Text = {
		  GI_attrs = @default | GA_READ_ONLY;
		  GTXI_text = "To start the game move your mouse to the computer's beach (the right grid) and click on a square.  Keep clicking on different squares of the grid to find the computer's hidden treasure.";
		  ATTR_GEN_TEXT_NEVER_MAKE_SCROLLABLE;
		  HINT_MINIMUM_SIZE = {SST_PIXELS | 325, 0, 0};
	 }


@end QTipsResource



/****************************************************************
 *              CODE FOR BattleProcessClass                 *
 ***************************************************************/

/*-------------------------------------------------------------------------*/
void BattlePlaySound(MemHandle soundHandle)
{
 word 		tempo = 8;


	 if (g_sound == SOUND_SYSTEM)
		 /* this routine abides by syst sound setting */
		 UserStandardSound(SST_CUSTOM_SOUND, soundHandle, 1);
	 else if (g_sound == SOUND_OFF)  return;
	 else {
		 /* this routine doesn't check syst sound setting -
		  * but we need to supply the tempo */
		 SoundPlayMusic(soundHandle, SP_GAME, tempo, EOSF_UNLOCK);
		 }
}


/*****************************************************************************
 *                 MSG_GEN_PROCESS_OPEN_APPLICATION for BattleProcessClass
 *****************************************************************************
 * SYNOPSIS:       Handle anything needed when opening app.
 *
 * On Entry:
 *
 * On Exit Return:
 * 
 * Revision History:
 *   Name               Date           Description
 *   Derrick Renaud     01/01/97       Initial .1 beta
 *****************************************************************************/
@method BattleProcessClass, MSG_GEN_PROCESS_OPEN_APPLICATION {
 Boolean		initError, tips;


	@call BattleApp::MSG_GEN_APPLICATION_INSTALL_TOKEN();

	@callsuper();

	 SoundAllocMusic(winSoundBuf, 1, &winSound);
	 SoundAllocMusic(loseSoundBuf, 1, &loseSound);

	 /* check for quick tips */
	 initError = InitFileReadBoolean("Treasure", "showTips", &tips);
	 if (initError) tips = TRUE;
	 if (tips) {
		 @send ShowOnStartupGroup::MSG_GEN_BOOLEAN_GROUP_SET_BOOLEAN_STATE(
														 SHOW_ON_STARTUP,
														 TRUE);
		 @send QTipsDialogBox::MSG_GEN_INTERACTION_INITIATE();
		 }
	 else
		 @send ShowOnStartupGroup::MSG_GEN_BOOLEAN_GROUP_SET_BOOLEAN_STATE(
														 SHOW_ON_STARTUP,
														 FALSE);
	 /* check for sound */
	 initError = InitFileReadInteger("Treasure", "sound", &g_sound);
	 if (initError) g_sound = SOUND_SYSTEM;
	 @call SoundGroup::MSG_GEN_ITEM_GROUP_SET_SINGLE_SELECTION(g_sound, FALSE) ;


	  @send self::MSG_NEW_GAME();
}

/*-------------------------------------------------------------------------*/
@method BattleProcessClass, MSG_GEN_PROCESS_CLOSE_APPLICATION
{
	 Boolean		tips;


	 SoundStopMusic(winSound);
	 SoundFreeMusic(winSound);
	 SoundStopMusic(loseSound);
	 SoundFreeMusic(loseSound);

	 /* set the quick tips if not default */
	 tips = @call ShowOnStartupGroup::MSG_GEN_BOOLEAN_GROUP_IS_BOOLEAN_SELECTED(
																	 SHOW_ON_STARTUP);
	 InitFileWriteBoolean("Treasure", "showTips", tips);
	 InitFileWriteInteger("Treasure", "sound", g_sound);

	 return (@callsuper()) ;
}
/*-------------------------------------------------------------------------*/
@method BattleProcessClass, MSG_BATTLE_SOUND_CHANGED
{
	 g_sound = selection ;
}

/***********************************************************************
 *
 * MESSAGE:	MSG_VIS_DRAW() for BorderInteractionClass
 *
 * DESCRIPTION:	draws the ocean
 *
 * PARAMETERS:
 *	void(word drawFlags, GStateHandle gstate)
 *
 ***********************************************************************/
@method BorderInteractionClass, MSG_VIS_DRAW
{
 Rectangle	myBounds;

 
    @call self::MSG_VIS_GET_BOUNDS(&myBounds);
    GrSaveState(gstate);

    /* draw the background */
    GrSetAreaColor(gstate, CF_RGB, 22, 128, 207);
    GrFillRect(gstate, myBounds.R_left, myBounds.R_top,
				   myBounds.R_right, myBounds.R_bottom);

    GrRestoreState(gstate);
    @callsuper();

}

/***********************************************************************
 *
 * MESSAGE:	MSG_VIS_DRAW() for BattleInteractionClass
 *
 * DESCRIPTION:	draws the islands
 *
 * PARAMETERS:
 *	void(word drawFlags, GStateHandle gstate)
 *
 ***********************************************************************/
@method BattleInteractionClass, MSG_VIS_DRAW
{
 Rectangle	myBounds;
 Bitmap		*section;

    @call self::MSG_VIS_GET_BOUNDS(&myBounds);
    GrSaveState(gstate);

    /* draw the left island */
    MemLock(OptrToHandle(@AUpMidBitmap));
    section = (Bitmap *)LMemDeref(@AUpMidBitmap);
    GrDrawBitmap(gstate, myBounds.R_left + 32, myBounds.R_top + 6, section, 0);
    MemUnlock(OptrToHandle(@AUpMidBitmap));

    MemLock(OptrToHandle(@ALeftBitmap));
    section = (Bitmap *)LMemDeref(@ALeftBitmap);
    GrDrawBitmap(gstate, myBounds.R_left + 0, myBounds.R_top + 73, section, 0);
    MemUnlock(OptrToHandle(@ALeftBitmap));

    MemLock(OptrToHandle(@ARightBitmap));
    section = (Bitmap *)LMemDeref(@ARightBitmap);
    GrDrawBitmap(gstate, myBounds.R_left + 276, myBounds.R_top + 73, section, 0);
    MemUnlock(OptrToHandle(@ARightBitmap));

    MemLock(OptrToHandle(@ABMidBitmap));
    section = (Bitmap *)LMemDeref(@ABMidBitmap);
    GrDrawBitmap(gstate, myBounds.R_left + 32, myBounds.R_top + 316, section, 0);
    MemUnlock(OptrToHandle(@ABMidBitmap));

    MemLock(OptrToHandle(@AUpLeftBitmap));
    section = (Bitmap *)LMemDeref(@AUpLeftBitmap);
    GrDrawBitmap(gstate, myBounds.R_left + 14, myBounds.R_top + 49, section, 0);
    section = (Bitmap *)LMemDeref(@AUpRightBitmap);
    GrDrawBitmap(gstate, myBounds.R_left + 276, myBounds.R_top + 37, section, 0);
    section = (Bitmap *)LMemDeref(@ABLeftBitmap);
    GrDrawBitmap(gstate, myBounds.R_left + 7, myBounds.R_top + 316, section, 0);
    section = (Bitmap *)LMemDeref(@ABRightBitmap);
    GrDrawBitmap(gstate, myBounds.R_left + 276, myBounds.R_top + 316, section, 0);
    MemUnlock(OptrToHandle(@AUpLeftBitmap));

    /* draw the right island */
    MemLock(OptrToHandle(@BUpMidBitmap));
    section = (Bitmap *)LMemDeref(@BUpMidBitmap);
    GrDrawBitmap(gstate, myBounds.R_left + 347, myBounds.R_top + 0, section, 0);
    MemUnlock(OptrToHandle(@BUpMidBitmap));

    MemLock(OptrToHandle(@BLeftBitmap));
    section = (Bitmap *)LMemDeref(@BLeftBitmap);
    GrDrawBitmap(gstate, myBounds.R_left + 305, myBounds.R_top + 72, section, 0);
    MemUnlock(OptrToHandle(@BLeftBitmap));

    MemLock(OptrToHandle(@BRightBitmap));
    section = (Bitmap *)LMemDeref(@BRightBitmap);
    GrDrawBitmap(gstate, myBounds.R_left + 591, myBounds.R_top + 72, section, 0);
    MemUnlock(OptrToHandle(@BRightBitmap));

    MemLock(OptrToHandle(@BBMidBitmap));
    section = (Bitmap *)LMemDeref(@BBMidBitmap);
    GrDrawBitmap(gstate, myBounds.R_left + 347, myBounds.R_top + 316, section, 0);
    MemUnlock(OptrToHandle(@BBMidBitmap));

    MemLock(OptrToHandle(@BUpLeftBitmap));
    section = (Bitmap *)LMemDeref(@BUpLeftBitmap);
    GrDrawBitmap(gstate, myBounds.R_left + 311, myBounds.R_top + 39, section, 0);
    section = (Bitmap *)LMemDeref(@BUpRightBitmap);
    GrDrawBitmap(gstate, myBounds.R_left + 591, myBounds.R_top + 31, section, 0);
    section = (Bitmap *)LMemDeref(@BBLeftBitmap);
    GrDrawBitmap(gstate, myBounds.R_left + 317, myBounds.R_top + 316, section, 0);
    section = (Bitmap *)LMemDeref(@BBRightBitmap);
    GrDrawBitmap(gstate, myBounds.R_left + 591, myBounds.R_top + 316, section, 0);
    MemUnlock(OptrToHandle(@BUpLeftBitmap));

    GrRestoreState(gstate);
    @callsuper();

}

/***********************************************************************
 *              MSG_NEW_GAME for BattleProcessClass
 ***********************************************************************
 * SYNOPSIS:    This method notifies each of the views that
 *              a new game is beginning; they should notify their contents,
 *              and then the board object will redraw itself.
 *  
 * PARAMETERS:  None    
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      DR      1/31/94         Initial Revision
 *
 ***********************************************************************/
@method BattleProcessClass, MSG_NEW_GAME {


  FloatRandomize(RGIF_GENERATE_SEED, 8);
  g_battleStarted = BR_GAME_NEW;
    /* Game has reset. Rafts are now movable */
  g_battleTurn = TURN_PLAYER;
    /* Player gets to go first */

  g_shotsOnCheckerBoard = g_gridsize * g_gridsize / 2;
  
  /* Call the boards and tell them to get ready */
  @call PlayerBattleBoard::MSG_BOARD_NEW_GAME();
  @call ComputerBattleBoard::MSG_BOARD_NEW_GAME();
}


/***********************************************************************
 *              MSG_GET_RANDOM_INT for BattleProcessClass
 ***********************************************************************
 * SYNOPSIS:    This method returns a random value between 0 and
 *              randomMax.
 *  
 * PARAMETERS:
 *      int (int randomMax)
 * STRATEGY:    This should be updated with a better random number
 *              generator.
 *
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      DR      1/31/94         Initial Revision
 *
 ***********************************************************************/

@method BattleProcessClass, MSG_GET_RANDOM_INT {

  FloatWordToFloat(randomMax);
  FloatRandomN();
  randomMax = 	FloatFloatToDword();
  return (randomMax);
/*  
  long double randomX;
  
  randomX = randomMax;
  FloatPushNumber(&randomX);
  FloatRandomN();
  FloatPopNumber(&randomX);
  randomMax = randomX;
  return (randomMax);
*/  
}


/***********************************************************************
 *              MSG_BATTLE_CHANGE_LEVEL for BattleProcessClass
 ***********************************************************************
 * SYNOPSIS:    This method saves the new setup info.
 *  
 * PARAMETERS:  void (word selection, word numSelections, byte stateFlags)
 *
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      DR      2/7/94          Rev 1.1
 *
 ***********************************************************************/

@method BattleProcessClass, MSG_BATTLE_CHANGE_LEVEL {

    g_skillLevel = selection;

    @call BattlePrimary::MSG_META_SAVE_OPTIONS();
    InitFileCommit() ;


}


/****************************************************************
 *              CODE FOR BattleBoardClass                       *
 ***************************************************************/


/***********************************************************************
 *              MSG_BOARD_PLACE_PIECE_CHECK for BattleBoardClass
 ***********************************************************************
 * SYNOPSIS:    This method checks to see if the new location for
 *              the raft will fit in the grid. Also the raft can not
 *              be placed on top of a different raft. But it is ok
 *              for the raft to overlap it's old positon.
 * PARAMETERS:  
 *      int (int x, int y, int size, int direction, int type)    
 * STRATEGY:    If the raft meets the above conditions, return TRUE.
 *              If there are any conflicts, return FALSE.
 *
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      DR      1/31/94         Initial Revision
 *
 ***********************************************************************/

@method BattleBoardClass, MSG_BOARD_PLACE_PIECE_CHECK {

  int xEnd, yEnd;
  int check = TRUE;

  if ((x >= 0) && (x < g_gridsize) &&   /* check start of raft */
      (y >= 0) && (y < g_gridsize)) {

    xEnd = x;
    yEnd = y;
      
    if (direction == PBP_HORIZONTAL) xEnd += size - 1;
    else yEnd += size - 1;

    if ((xEnd >= 0) && (xEnd < g_gridsize) &&   /* check end of raft */
	(yEnd >= 0) && (yEnd < g_gridsize)) {

      /* Check to see if raft overlaps a different raft */
      do {
	if ((pself->BR_board[y][x] != BR_EMPTY) &&
	    (pself->BR_board[y][x] != type))
	  check = FALSE;
	    /*
	     * can't place over a different object
	     */
	/* Increment to next raft location */
	if (direction == PBP_HORIZONTAL) x ++;
	else y ++;
	size --;
      } while (size > 0);
      
    }
    else check = FALSE;       /* end not in grid */
  }
  else check = FALSE;         /* start not in grid */
  
  return (check);
}


/***********************************************************************
 *              MSG_BOARD_PLACE_PIECE for BattleBoardClass
 ***********************************************************************
 * SYNOPSIS:    This method will place an object in the grid.
 *              No checking is done, so it better fit.
 * PARAMETERS:  
 *      void (int x, int y, int size, int direction, int type)    
 * SIDE EFFECTS:Total chaos if x,y out of range.    
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      DR      1/31/94         Initial Revision
 *
 ***********************************************************************/

@method BattleBoardClass, MSG_BOARD_PLACE_PIECE {
  
  do {
    pself->BR_board[y][x]=type;
    if (direction == PBP_HORIZONTAL) x ++;
    else y ++;
    size --;
  } while (size > 0);
}


/***********************************************************************
 *              MSG_BOARD_CHECK_GRID for BattleBoardClass
 ***********************************************************************
 * SYNOPSIS:    This method returns a value from the grid.
 * PARAMETERS:  
 *      unsigned char (int x, int y)    
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      DR      1/31/94         Initial Revision
 *
 ***********************************************************************/

@method BattleBoardClass, MSG_BOARD_CHECK_GRID {
  int i;
  i = pself->BR_board[y][x];
  return(i);
}



/****************************************************************
 *              CODE FOR PlayerBattleBoardClass                 *
 ***************************************************************/


/***********************************************************************
 *              MSG_BOARD_NEW_GAME for PlayerBattleBoardClass
 ***********************************************************************
 * SYNOPSIS:    This method notifies each of the visible children that
 *              a new game is beginning; they should take their places,
 *              and then the board object will redraw itself.
 *  
 * PARAMETERS:  None    
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      DR      1/31/94         Initial Revision
 *
 ***********************************************************************/

@method PlayerBattleBoardClass, MSG_BOARD_NEW_GAME {
  
  WindowHandle win;
  GStateHandle gstate;
  optr childOptr;
  MemHandle ourBlock;
  int x = 0;
  int y = 0;
  int boardLength;

  boardLength = g_gridsize * BATTLE_BLOCK +1;
  
  /*
   * Anything using pself should be done first, because routines and
   * Messages can trash it without warning. Then you could end up
   * accessing random memory locations. write = crash
   */
  
  /* reset grid values */
  for (y = 0; y < g_gridsize; y ++) {
    for (x = 0; x < g_gridsize; x ++) {
      pself->BR_board[y][x] = 0;
    }
  }
  
  /* setup counter sizes before pself gets trased */
  pself->BP_hitCount[0] = 0;      /* contains # of misses */
  pself->BP_size[BR_2MAN] = 2;
  pself->BP_hitCount[BR_2MAN] = 0;
  pself->BP_size[BR_3MAN1] = 3;
  pself->BP_hitCount[BR_3MAN1] = 0;
  pself->BP_size[BR_3MAN2] = 3;
  pself->BP_hitCount[BR_3MAN2] = 0;
  pself->BP_size[BR_4MAN] = 4;
  pself->BP_hitCount[BR_4MAN] = 0;
  pself->BP_size[BR_5MAN] = 5;
  pself->BP_hitCount[BR_5MAN] = 0;
  pself->BP_sunk = 0;
  
  /* Reset computer search data */
  pself->compWorkingOnHit = 0;
  pself->compProgress = 0;
  
  /* 
   * Rafts could have been declared objects at the start, but this will
   * allow future menu selection of rafts. So they will be killed at the
   * start of the game and then rebuilt.
   */
  
  /*  Kill any current rafts */  
  while ((childOptr = @call self::MSG_VIS_FIND_CHILD_AT_POSITION(0)) != 0) {
    @call childOptr::MSG_VIS_DESTROY(VUM_DELAYED_VIA_APP_QUEUE);
  }
  
  ourBlock = OptrToHandle(oself);
  
  /* Make 2MAN raft */

  childOptr = ConstructOptr(ourBlock,                     /* new child */
		ObjInstantiate(OptrToHandle(oself), 
			       &PlayerBattlePieceClass));
  @call childOptr::MSG_PLAYER_PIECE_SETUP                 /* setup raft */
		      (0, 0, 2, PBP_HORIZONTAL, BR_2MAN);
  @call self::MSG_VIS_ADD_CHILD(childOptr, CCO_LAST);   /* add it to tree */
  
  /* Make 3MAN1 raft */

  childOptr = ConstructOptr(ourBlock,                     /* new child */
		ObjInstantiate(OptrToHandle(oself), 
			       &PlayerBattlePieceClass));
  @call childOptr::MSG_PLAYER_PIECE_SETUP                 /* setup raft */
		      (0, 1, 3, PBP_HORIZONTAL, BR_3MAN1);
  @call self::MSG_VIS_ADD_CHILD(childOptr, CCO_LAST);   /* add it to tree */

  /* Make 3MAN2 raft */

  childOptr = ConstructOptr(ourBlock,                     /* new child */
		ObjInstantiate(OptrToHandle(oself), 
			       &PlayerBattlePieceClass));
  @call childOptr::MSG_PLAYER_PIECE_SETUP                 /* setup raft */
		      (0, 2, 3, PBP_HORIZONTAL, BR_3MAN2);
  @call self::MSG_VIS_ADD_CHILD(childOptr, CCO_LAST);   /* add it to tree */
  
  /* Make 4MAN raft */

  childOptr = ConstructOptr(ourBlock,                     /* new child */
		ObjInstantiate(OptrToHandle(oself), 
			       &PlayerBattlePieceClass));
  @call childOptr::MSG_PLAYER_PIECE_SETUP                 /* setup raft */
		      (0, 3, 4, PBP_HORIZONTAL, BR_4MAN);
  @call self::MSG_VIS_ADD_CHILD(childOptr, CCO_LAST);   /* add it to tree */
  
  /* Make 5MAN raft */

  childOptr = ConstructOptr(ourBlock,                     /* new child */
		ObjInstantiate(OptrToHandle(oself), 
			       &PlayerBattlePieceClass));
  @call childOptr::MSG_PLAYER_PIECE_SETUP                 /* setup raft */
		      (0, 4, 5, PBP_HORIZONTAL, BR_5MAN);
  @call self::MSG_VIS_ADD_CHILD(childOptr, CCO_LAST);   /* add it to tree */
  
  /*
   * Mark as invalid so UI can setup and use object. 
   * Board will check for children and then use them. If this wasn't done
   * then the rafts would not respond to the mouse.
   */
  @call self::MSG_VIS_MARK_INVALID(VOF_IMAGE_INVALID,
		       VUM_DELAYED_VIA_APP_QUEUE);

  /* 
   * Now initiate a new gstate for the view window. Get the
   * window handle from the view, and then create a new gstate
   * for it.
   */

  win = @call PlayerBattleView::MSG_GEN_VIEW_GET_WINDOW();
  gstate = GrCreateState(win);

  /* 
   * Invalidate the game board rectangle in the document. This
   * will cause the view object to generate a MSG_META_EXPOSED
   * for the rectangle, causing MSG_VIS_DRAW to be sent to this
   * object.
   */

  GrInvalRect(gstate, 0, 0, boardLength, boardLength);
  GrDestroyState(gstate);
}


/***********************************************************************
 *              MSG_VIS_DRAW for PlayerBattleBoardClass
 ***********************************************************************
 * SYNOPSIS:    This method draws the board's outline and the
 *              lines of the playing field.  It is sent each time
 *              a portion of the view window becomes invalid (such
 *              as when the primary is moved).   
 * PARAMETERS:  
 *      void (word drawFlags, GStateHandle gstate)
 *              The gstate is the handle of the graphics state
 *              associated with the exposed portion of the view
 *              window. 
 *
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      DR      1/31/94         Initial Revision
 *      DR      2/7/94          Rev 1.1 added monochrome fix.
 *
 ***********************************************************************/

@method PlayerBattleBoardClass, MSG_VIS_DRAW {

  int i = 0;
  int x, y;
  sword x1, y1;
  int boardLength;
  Bitmap	*hole;


  boardLength = g_gridsize * BATTLE_BLOCK + 1;

  /* Set up the graphic state properly. */
  GrSetLineWidth(gstate, MakeWWFixed(1));
  GrSetLineColor(gstate, CF_INDEX, C_BLACK, 0, 0);

  /* Now draw the border of the game board.  It is a rectangle
   * that outlines the entire board. */
  GrDrawRect(gstate, FIRST_HORIZ -1, FIRST_VERT -1,
    FIRST_HORIZ -1 + boardLength, FIRST_VERT -1 + boardLength);
  /* and fill in the background color */
  GrSetAreaColor(gstate, CF_RGB, 243, 225, 153);
  GrFillRect(gstate, FIRST_HORIZ, FIRST_VERT,
    FIRST_HORIZ -2 + boardLength, FIRST_VERT -2 + boardLength);


  /* Set and draw the playing field grid lines. */
  do {
    GrDrawHLine(gstate, FIRST_HORIZ, FIRST_VERT - 1 + BATTLE_BLOCK * i,  
      FIRST_HORIZ + boardLength - 2);
    GrDrawVLine(gstate, FIRST_HORIZ - 1 + BATTLE_BLOCK * i, FIRST_VERT,  
      FIRST_VERT + boardLength - 2);
    i++;
  } while (i <= g_gridsize);

  /* Draw any holes where digging missed the treasure */
   for (y = 0; y < g_gridsize; y ++) {
    for (x = 0; x < g_gridsize; x ++) {
      if (pself->BR_board[y][x] == BR_ROCK) {
	   /* holes only if rock and no raft at location */
	   x1 = x * BATTLE_BLOCK + FIRST_HORIZ - 1 + BATTLE_BLOCK / 4;
	   y1 = y * BATTLE_BLOCK + FIRST_VERT - 1 + BATTLE_BLOCK / 4;
	   MemLock(OptrToHandle(@HoleBitmap));
	   hole = (Bitmap *)LMemDeref(@HoleBitmap);
	   GrDrawBitmap(gstate, x1-4, y1-4, hole, 0);
	   MemUnlock(OptrToHandle(@HoleBitmap));
	 }
    } /* next x */
  } /* next y */

  /* When the MSG_VIS_DRAW is received by the game board, it
   * must pass it on to its visible children.  It must also pass
   * on the parameters of the message as passed to ensure all
   * drawing is done properly. */
  @send @visChildren::MSG_VIS_DRAW(drawFlags, gstate);

  @callsuper();
}


/***********************************************************************
 *              MSG_COMPUTER_MAKE_SHOT for PlayerBattleBoardClass
 ***********************************************************************
 * SYNOPSIS:    This method is the computer's brain.
 *              This is where it decides where it is going to through
 *              it's rock.
 *              Forgive the goto's, but I'm to used to programming
 *              in assembly language. I find unstructured easier when
 *              I need a lot of if statements.
 *  
 * PARAMETERS:  None    
 *
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      DR      1/31/94         Initial Revision
 *      DR      2/7/94          Rev 1.1
 *                              Added Skill Levels and fixed progress
 *                               bug that would make computer do a
 *                               rotate search at both ends.
 *
 ***********************************************************************/

@method PlayerBattleBoardClass, MSG_COMPUTER_MAKE_SHOT {
  
  GStateHandle gstate;
  WindowHandle win;
  int raft;
  int newX, newY;
  int search;

  /* Check to make sure game is not over before shooting */
  if (g_battleStarted < BR_GAME_OVER) {
  
  if (!pself->compWorkingOnHit) goto AddrMakeRandom;

  /* Last shot was a hit. Let's find that raft. */

AddrNewLast:;
  /* We will start the search from the last hit */
  newX = pself->compLastX;
  newY = pself->compLastY;

AddrIncNew:;
  /* Increment to the next location in grid to search at. */
  if (pself->compDirection == COMP_DIRECTION_N) newY --;
  else if (pself->compDirection == COMP_DIRECTION_E) newX ++;
  else if (pself->compDirection == COMP_DIRECTION_S) newY ++;
  else newX --;

  /* Check if new search will fit in grid */
  if ((newX < 0) || (newX >= g_gridsize) ||
      (newY < 0) || (newY >= g_gridsize))
      /* New search is not in grid. */
      goto AddrCheckProgress;

  /* Search is in grid, so... */

  /* Check if there is a shot that missed already there. */
  if (pself->BR_board[newY][newX] == BR_ROCK)
    /* A miss blocks further progress */
    goto AddrCheckProgress;

  /* There is no miss blocking progess, so... */

  /* Check if there is a hit that needs to be skipped over */
  if ((pself->BR_board[newY][newX] & BR_ROCK) != BR_EMPTY)
    /* There is a hit there. Skip over it. */
    goto AddrIncNew;

  /* The spot is open. Fire away. */
  goto AddrMakeShot;

AddrCheckProgress:;
  /* Let's find out what direction we should look in now */
  if (pself->compProgress == 0) {
    
    /* We have not found another hit yet so let rotate search direction */
    pself->compDirection += pself->compDirectionSpin;
    if (pself->compDirection < 1) pself->compDirection = 4;
    if (pself->compDirection > 4) pself->compDirection = 1;

    /* Check to see if we've managed to rotate back to start direction */
    if (pself->compDirection == pself->compStartDirection)
      /* Yep, we're back at the start. Take a random shot. */
      goto AddrMakeRandom;

    /* Otherwise... */
    /* Restore new search back to start and check new rotation. */
    goto AddrNewLast;
  }
  else if (pself->compProgress == 1) {
    /* Some progress was made on the last shot,
     * but we're at the end of the line. 
     * Try going in the other direction */
    pself->compDirection = 6 - pself->compDirection;
    if (pself->compDirection == 3) pself->compDirection = 1;
    else if (pself->compDirection == 5) pself->compDirection = 3;

    /* Increment progress so we don't end up going 
     * back in the old direction */
    pself->compProgress ++;

    /* Restore new search back to start and check new direction */
    goto AddrNewLast;
  }
  else {
    /* We've checked both directions and come to both ends. */
    /* So just continue on to make a random shot. */
  }

AddrMakeRandom:;
  /* First clear out all previous progress */
  pself->compProgress = 0;
  pself->compWorkingOnHit = 0;

  /* Beginner Level will shoot any where on the board.
   * Intermediate Level will shoot only on checkerboard spots
   *   eg. 010101
   *       101010
   */
  search = g_gridsize;
  if (g_skillLevel == BATTLE_LEVEL_INTERMEDIATE) {
    search /= 2;
  }
  
  /* Loop until we find a random free location */
  do {
    newX = @call process::MSG_GET_RANDOM_INT(search);
    newY = @call process::MSG_GET_RANDOM_INT(g_gridsize);
    if (g_skillLevel == BATTLE_LEVEL_INTERMEDIATE) {
      /* Intermediate level so we only search ever other x location */
      newX *= 2;
      /* If checkerboard shots are left then stager X on even rows,
       * else stager X on odd rows. */
      /* We need to do this because if for some reason all rafts have not
       * been found by shooting ever other space then the game will lock up. */
      if ( ((g_shotsOnCheckerBoard == 0) && (((newY / 2) * 2) != newY)) ||
        ((g_shotsOnCheckerBoard != 0) && (((newY / 2) * 2) == newY)) ) {
        newX += 1;
      }
    }
  } while (pself->BR_board[newY][newX] & BR_ROCK);
  
AddrMakeShot:;
  /* We have a location to shoot at. Try it out. */

  if( (g_shotsOnCheckerBoard != 0) && (((newY ^ newX) & 1)) ) g_shotsOnCheckerBoard --;
  
  /* First Place the rock */
  pself->BR_board[newY][newX] |= BR_ROCK;
  
  /* Find out what raft (if any) is there */
  raft = pself->BR_board[newY][newX] & BR_RAFT_MASK;
  
  /* increment hits on raft */
  pself->BP_hitCount[raft] ++;
      
  /* Update the grid location visually */
  win = @call PlayerBattleView::MSG_GEN_VIEW_GET_WINDOW();
  gstate = GrCreateState(win);
  GrInvalRect(gstate, newX * BATTLE_BLOCK + FIRST_HORIZ,
		 newY * BATTLE_BLOCK + FIRST_VERT,
		 newX * BATTLE_BLOCK + FIRST_HORIZ + BATTLE_BLOCK - 2,
		 newY * BATTLE_BLOCK + FIRST_VERT + BATTLE_BLOCK - 2);
  GrDestroyState(gstate);
  
  if (raft != BR_EMPTY) {
    /* Something was hit. Notify user. */
	 if (g_sound == SOUND_SYSTEM)
		 UserStandardSound(SST_ERROR);
	 else if (g_sound == SOUND_ON)
		 UserStandardSound(SST_ERROR | SST_IGNORE_SOUND_OFF);

    /* Update X-Y for next shot to search from */
    pself->compLastX = newX;
    pself->compLastY = newY;
    
    /* Check if this is a first hit. */
    if (pself->compWorkingOnHit == 0) {
      /* This is a first hit, so... */

      /* Setup random search for next shot */
      pself->compStartDirection = @call process::MSG_GET_RANDOM_INT(4) + 1;
      pself->compDirection = pself->compStartDirection;
      pself->compDirectionSpin = @call process::MSG_GET_RANDOM_INT(2);
      if (pself->compDirectionSpin == 0) pself->compDirectionSpin = (-1);

      /* Update to notify next shot that it's working on a hit */
      pself->compWorkingOnHit = 1;
    } else {
      if (pself->compProgress == 0) {
	/* We are making progress in this direction, so... */
	pself->compProgress = 1;
      }
    }
    
    if (pself->BP_hitCount[raft] == pself->BP_size[raft]) {
      /* raft has been sunk */
      pself->BP_sunk ++;
      if (pself->BP_sunk == NO_OF_RAFTS) {
			/* all player rafts sunk */
			g_battleStarted = BR_SHOW_CHESTS;
			/* show unfound treasure chests as closed */
			@send ComputerBattleBoard::MSG_VIS_MARK_INVALID(VOF_IMAGE_INVALID,
												  VUM_NOW);






			/* Update Game Over Dialog for Computer win */
			BattlePlaySound(loseSound);
			@call BRGameOverText::MSG_GEN_USE_VIS_MONIKER(
				 OptrToChunk(@ComputerWonText), VUM_DELAYED_VIA_UI_QUEUE);
	      @send BRGameOver::MSG_GEN_INTERACTION_INITIATE();
      }
    }
  } /* splash could go here */
  /* Player can go now */
  g_battleTurn = TURN_PLAYER;
}
}



/****************************************************************
 *              CODE FOR ComputerBattleBoardClass               *
 ***************************************************************/

/***********************************************************************
 *              MSG_META_CONTENT_VIEW_WIN_OPENED for ComputerBattleBoardClass
 ***********************************************************************
 * SYNOPSIS:    Intercepts the view opening and changes the cursor to the
 *              shovel
 *  
 * PARAMETERS:
 *
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      jfh     10/17/00        Initial Revision
 *
 ***********************************************************************/
@method ComputerBattleBoardClass, MSG_META_CONTENT_VIEW_WIN_OPENED {
 optr shovelPtr = @Shovel;


   MemLock(OptrToHandle(shovelPtr));
   @call ComputerBattleView::MSG_GEN_VIEW_SET_PTR_IMAGE(shovelPtr,PIL_WINDOW);
   MemUnlock(OptrToHandle(shovelPtr));

   @callsuper();

}


/***********************************************************************
 *              MSG_BOARD_NEW_GAME for ComputerBattleBoardClass
 ***********************************************************************
 * SYNOPSIS:    This method notifies the computer to place it's rafts
 *              where it wants them.
 *  
 * PARAMETERS:  None    
 *
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      DR      1/31/94         Initial Revision
 *
 ***********************************************************************/

@method ComputerBattleBoardClass, MSG_BOARD_NEW_GAME {
  
  WindowHandle win;
  GStateHandle gstate;
  int i;
  int x, y;
  int direction;
  int check = FALSE;
  int boardLength;

  boardLength = g_gridsize * BATTLE_BLOCK + 1;

  /* Reset grid values */
  for (y = 0; y < g_gridsize; y ++) {
    for (x = 0; x < g_gridsize; x ++) {
      pself->BR_board[y][x] = BR_EMPTY;
    } /* next x */
  } /* next y */
  
  /* setup piece sizes and set hits to 0 */
  pself->BP_sunk = 0;
  for (i = 1; i <= NO_OF_RAFTS; i ++) {
    pself->BP_hitCount[i] = 0;
    pself->BP_size[i] = i;
  }
  pself->BP_size[1] = 2;
  pself->BP_size[2] = 3;

  for (i = 1; i <= NO_OF_RAFTS; i ++) {
    check = FALSE;      /* reset check flag */

    /* loop until raft is randomly placed in board */
    while (!check) {
      /* set the direction random */
      direction = PBP_HORIZONTAL;
      if (@call process::MSG_GET_RANDOM_INT(2) == 0) 
				direction = PBP_VERTICAL;
      
      x = @call process::MSG_GET_RANDOM_INT(g_gridsize - 
					    pself->BP_size[i] + 1);
      y = @call process::MSG_GET_RANDOM_INT(g_gridsize);
      
      /* see if raft will fit in given direction */
      if (direction == PBP_HORIZONTAL) {
	if (@call self::MSG_BOARD_PLACE_PIECE_CHECK(x, y, 
			pself->BP_size[i], direction, i)) {
	  /* the piece will fit, so place it */
	  check = TRUE;
	  @call self::MSG_BOARD_PLACE_PIECE(x, y,
			pself->BP_size[i], direction, i);
	}
      } else {
	if (@call self::MSG_BOARD_PLACE_PIECE_CHECK(y, x, 
			pself->BP_size[i], direction, i)) {
	  /* the piece will fit, so place it */
	  check = TRUE;
	  @call self::MSG_BOARD_PLACE_PIECE(y, x,
			pself->BP_size[i], direction, i);
	}
      }
    }  /* check if fits loop */
  }  /* next i (next raft) */

  win = @call ComputerBattleView::MSG_GEN_VIEW_GET_WINDOW();
  gstate = GrCreateState(win);

  /* Notify view to redraw itself */
  GrInvalRect(gstate, 0, 0, boardLength, boardLength);
  GrDestroyState(gstate);
}


/***********************************************************************
 *              MSG_VIS_DRAW for ComputerBattleBoardClass
 ***********************************************************************
 * SYNOPSIS:    This method draws the board's outline, grid lines,
 *              waves and rocks.  It is sent each time
 *              a portion of the view window becomes invalid (such
 *              as when the primary is moved).   
 * PARAMETERS:  
 *      void (word drawFlags, GStateHandle gstate)
 *              The gstate is the handle of the graphics state
 *              associated with the exposed portion of the view
 *              window. 
 *
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      DR      1/31/94         Initial Revision
 *      DR      2/7/94          Rev 1.1 added monochrome fix.
 *
 ***********************************************************************/

@method ComputerBattleBoardClass, MSG_VIS_DRAW {

  int i = 0;
  int x, y;
  sword x1, y1;
  int boardLength;
  Bitmap	*dig;

  boardLength = g_gridsize * BATTLE_BLOCK + 1;

  /* 
   * First call the superclass to invoke any default behavior
   * for this message.
   */

  @callsuper();

  GrSetLineWidth(gstate, MakeWWFixed(1));
  GrSetLineColor(gstate, CF_INDEX, C_BLACK, 0, 0);

  /* Now draw the border of the game board. */
  GrDrawRect(gstate, FIRST_HORIZ -1, FIRST_VERT -1,
    FIRST_HORIZ -1 + boardLength, FIRST_VERT -1 + boardLength);
  /* and fill in the background color */
  GrSetAreaColor(gstate, CF_RGB, 243, 225, 153);
  GrFillRect(gstate, FIRST_HORIZ, FIRST_VERT,
    FIRST_HORIZ -2 + boardLength, FIRST_VERT -2 + boardLength);


  /* Set and draw the playing field grid lines. */
  do {
  
    GrDrawHLine(gstate, FIRST_HORIZ, FIRST_VERT - 1 + BATTLE_BLOCK * i,  
      FIRST_HORIZ + boardLength - 2);
    GrDrawVLine(gstate, FIRST_HORIZ - 1 + BATTLE_BLOCK * i, FIRST_VERT,  
      FIRST_VERT + boardLength - 2);
    i++;
  
  } while (i <= g_gridsize);

  /* Draw any holes and open chests where needed. */
  for (y = 0; y < g_gridsize; y ++) {
    for (x = 0; x < g_gridsize; x ++) {
      x1 = x * BATTLE_BLOCK + FIRST_HORIZ - 1 + BATTLE_BLOCK / 4;
      y1 = y * BATTLE_BLOCK + FIRST_VERT - 1 + BATTLE_BLOCK / 4;
	 if (pself->BR_board[y][x] == BR_ROCK) {
	   /* Draw a hole */
	   MemLock(OptrToHandle(@HoleBitmap));
	   dig = (Bitmap *)LMemDeref(@HoleBitmap);
	   GrDrawBitmap(gstate, x1-4, y1-4, dig, 0);
	   MemUnlock(OptrToHandle(@HoleBitmap));
	 } else if (pself->BR_board[y][x] & BR_ROCK) {
	   /* A hit! Draw an open chest */
	   MemLock(OptrToHandle(@TCOpenBitmap));
	   dig = (Bitmap *)LMemDeref(@TCOpenBitmap);
	   GrDrawBitmap(gstate, x1-4, y1-4, dig, 0);
	   MemUnlock(OptrToHandle(@TCOpenBitmap));
	 } else if ((pself->BR_board[y][x]) && (g_battleStarted == BR_SHOW_CHESTS)) {
		/* Reveal a closed chest */
		MemLock(OptrToHandle(@TCCloseBitmap));
		dig = (Bitmap *)LMemDeref(@TCCloseBitmap);
	   GrDrawBitmap(gstate, x1-4, y1-4, dig, 0);
	   MemUnlock(OptrToHandle(@TCCloseBitmap));
	 }
	 } /* next x */
  } /* next y */
}


/***********************************************************************
 *              MSG_META_START_SELECT for ComputerBattleBoardClass
 ***********************************************************************
 * SYNOPSIS:    This method handles your shots on the computer.
 *
 * PARAMETERS:  
 *      void (MouseReturnParams *retVal,
 *                      word xPosition, word yPosition, word inputState);    
 *
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      DR      1/31/94         Initial Revision
 *
 ***********************************************************************/

@method ComputerBattleBoardClass, MSG_META_START_SELECT {

  GStateHandle gstate;
  WindowHandle win;
  int x, y;
  int raft;  
  word id; /* temp placeholders for TimerStart id */
  optr tempOptr;

  /* Check to see if game has been reset and it is the player's turn */
  if ((g_battleStarted < BR_GAME_OVER) 
	&& (g_battleTurn == TURN_PLAYER)) {
  
  if (g_battleStarted == BR_GAME_NEW) {
    /* First shot on the computer. Start game. */
    g_battleStarted = BR_GAME_STARTED;
  }
  
  /* Convert mouse co-ordinates to grid location */
  x = (xPosition - FIRST_HORIZ + 1) / BATTLE_BLOCK;
  y = (yPosition - FIRST_VERT + 1) / BATTLE_BLOCK;

  if (((x * BATTLE_BLOCK + FIRST_HORIZ - 1) != xPosition) &&
      ((y * BATTLE_BLOCK + FIRST_VERT - 1) != yPosition)) {
      /* Mouse is not on a grid line*/
    
    if (pself->BR_board[y][x] & BR_ROCK) {
      /* There is already a rock here. Warn user.*/
		if (g_sound == SOUND_SYSTEM)
			UserStandardSound(SST_WARNING);
		else if (g_sound == SOUND_ON)
			UserStandardSound(SST_WARNING | SST_IGNORE_SOUND_OFF);
	 } else {
      raft = pself->BR_board[y][x] & BR_RAFT_MASK; /* block all but raft */
      pself->BR_board[y][x] |= BR_ROCK;         /* place rock in grid */
      
      /* Update the grid location visually */
      win = @call ComputerBattleView::MSG_GEN_VIEW_GET_WINDOW();
      gstate = GrCreateState(win);
      GrInvalRect(gstate, x * BATTLE_BLOCK + FIRST_HORIZ,
		 y * BATTLE_BLOCK + FIRST_VERT,
		 x * BATTLE_BLOCK + FIRST_HORIZ + BATTLE_BLOCK - 2,
		 y * BATTLE_BLOCK + FIRST_VERT + BATTLE_BLOCK - 2);
      GrDestroyState(gstate);
      
      if (raft != BR_EMPTY) {
			/* There must be something else here */
			if (g_sound == SOUND_SYSTEM)
				UserStandardSound(SST_NOTIFY);
			else if (g_sound == SOUND_ON)
				UserStandardSound(SST_NOTIFY | SST_IGNORE_SOUND_OFF);
			pself->BP_hitCount[raft] ++;
	
			/* check to see if raft has been sunk */
			if (pself->BP_hitCount[raft] == pself->BP_size[raft]) {
				/* You sunk a computer raft */
				pself->BP_sunk ++;
				if (pself->BP_sunk == NO_OF_RAFTS) {
					/* all computer rafts sunk */
					g_battleStarted = BR_GAME_OVER;
					/* Update Game Over dialog for Player win */
			      BattlePlaySound(winSound);
					@call BRGameOverText::MSG_GEN_USE_VIS_MONIKER(
					OptrToChunk(@PlayerWonText), VUM_DELAYED_VIA_UI_QUEUE);
					@send BRGameOver::MSG_GEN_INTERACTION_INITIATE();
				}
	      }
      } /* splash could go here in an 'else { }' */
    
      /* Let the computer take a turn */
      /* Delay a little so player's shot gets drawn and noticed */
      tempOptr = @call PlayerBattleBoard::MSG_META_GET_OPTR();
	 TimerStart(TIMER_EVENT_ONE_SHOT, tempOptr, 12,
		 MSG_COMPUTER_MAKE_SHOT, 0, &id);
    
    }
  } else {
    /* Mouse on grid line. Notify user. */
    UserStandardSound(SST_WARNING);
  }
  } /* New game not picked yet */

  retVal->flags = MRF_PROCESSED;      /* this event processed */
}


/****************************************************************
 *              CODE FOR PlayerBattlePieceClass                 *
 ***************************************************************/

/***********************************************************************
 *              MSG_PLAYER_PIECE_SETUP for PlayerBattlePieceClass
 ***********************************************************************
 * SYNOPSIS:    This message causes the piece to setup itself
 *              to to the given parameters.  It is invoked when the
 *              user presses the New Game trigger; the trigger sends
 *              MSG_BATTLE_NEW_GAME to the PlayerBattleBoard object, and
 *              the board object sends this message to each of
 *              the game piece objects.    
 * PARAMETERS:      
 *      void (int x, int y, int size, int direction, int type) 
 *
 * STRATEGY:
 *
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      DR      1/31/94         Initial Revision
 *
 ***********************************************************************/

@method PlayerBattlePieceClass, MSG_PLAYER_PIECE_SETUP {

int x1, x2, y1, y2;

  pself->PBP_type = type;
  pself->PBP_size = size;
  pself->PBP_direction = direction;
  pself->PBP_horizPos = x;
  pself->PBP_vertPos = y;
  pself->PBP_dragging = FALSE;

  /* set object to receive mouse clicks and visable */
  pself->VI_attrs |= (VA_FULLY_ENABLED | 
		     VA_DRAWABLE | VA_DETECTABLE);

  x1 = x * BATTLE_BLOCK + FIRST_HORIZ;     /* Calculate bounds */
  y1 = y * BATTLE_BLOCK + FIRST_VERT;
  if (direction == PBP_HORIZONTAL) {
    x2 = size * BATTLE_BLOCK + x1 - 2;       /* Bounds fit made to fit */
    y2 = BATTLE_BLOCK + y1 - 2;              /* inside grid lines     */
  } else {
    x2 = BATTLE_BLOCK + x1 - 2;
    y2 = size * BATTLE_BLOCK + y1 - 2;
  }
  pself->VI_bounds.R_left = x1;
  pself->VI_bounds.R_top = y1;
  pself->VI_bounds.R_right = x2;
  pself->VI_bounds.R_bottom = y2;

  /* Mark as invalid so UI can setup and use object */
  @call self::MSG_VIS_MARK_INVALID(VOF_IMAGE_INVALID | VOF_WINDOW_INVALID,
		       VUM_DELAYED_VIA_APP_QUEUE);
  
  /* Place the piece in the grid */
  @call PlayerBattleBoard::MSG_BOARD_PLACE_PIECE
			   (x, y, size, direction, type);
}


/***********************************************************************
 *              MSG_VIS_DRAW for PlayerBattlePieceClass
 ***********************************************************************
 * SYNOPSIS:    Draw the piece at the current location.
 *              This message is received whenever a portion
 *              of the view window becomes invalid; PlayerBattleView
 *              will send a MSG_META_EXPOSED to BattleBoard, which
 *              will send itself (by default) a MSG_VIS_DRAW.  The
 *              MSG_VIS_DRAW will be handled and then will be passed
 *              on to each of the game pieces.  Then each piece (in
 *              this handler) will draw itself at its own bounds.    
 * PARAMETERS:      
 *      void (word drawFlags GStateHandle gstate) 
 * SIDE EFFECTS:    
 *
 * STRATEGY:
 *
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      DR      1/31/94         Initial Revision
 *      DR      2/7/94          Rev 1.1 added monochrome fix
 *                              and fast log drawing.
 *
 ***********************************************************************/

@method PlayerBattlePieceClass, MSG_VIS_DRAW {

  int xPos, yPos, i;
  sword x, y;
  Bitmap		*dig;


  /* 
   * Set the mode to MM_COPY; this means that the image drawn
   * now will be drawn over whatever is there now.
   */
  GrSetMixMode(gstate, MM_COPY);
  
  GrSetLineColor(gstate, CF_INDEX, C_BLACK, 0, 0);
  GrSetLineWidth(gstate, MakeWWFixed(1));

  x = FIRST_HORIZ + 1 + (pself->PBP_horizPos) * BATTLE_BLOCK;
  y = FIRST_HORIZ + 1 + (pself->PBP_vertPos) * BATTLE_BLOCK;

    /* Just draw one big log for speed */
    if (pself->PBP_direction == PBP_HORIZONTAL) {
	 MemLock(OptrToHandle(@TCCloseBitmap));
	 for(i = 0; i < pself->PBP_size; i++) {
	    dig = (Bitmap *)LMemDeref(@TCCloseBitmap);
	    GrDrawBitmap(gstate, (x-1) + (BATTLE_BLOCK * i), y, dig, 0);
	    }
	 MemUnlock(OptrToHandle(@TCCloseBitmap));
    } else {
	 MemLock(OptrToHandle(@TCCloseBitmap));
	 for(i = 0; i < pself->PBP_size; i++) {
	    dig = (Bitmap *)LMemDeref(@TCCloseBitmap);
	    GrDrawBitmap(gstate, x-1, y + (BATTLE_BLOCK * i), dig, 0);
	    }
	 MemUnlock(OptrToHandle(@TCCloseBitmap));
    }

  /* Draw any needed open chests */
  xPos = pself->PBP_horizPos;
  yPos = pself->PBP_vertPos;
  x = xPos * BATTLE_BLOCK + FIRST_HORIZ - 1 + BATTLE_BLOCK / 4;
  y = yPos * BATTLE_BLOCK + FIRST_VERT - 1 + BATTLE_BLOCK / 4;

  for (i = 0; i < pself->PBP_size; i ++) {
    if (@call PlayerBattleBoard::MSG_BOARD_CHECK_GRID(xPos, yPos) 
						      & BR_ROCK) {  
      /* raft has been hit */
	 MemLock(OptrToHandle(@TCOpenBitmap));
	 dig = (Bitmap *)LMemDeref(@TCOpenBitmap);
	 GrDrawBitmap(gstate, x-4, y-4, dig, 0);
	 MemUnlock(OptrToHandle(@TCOpenBitmap));
    }
    /* Increment to next location in raft */
    if (pself->PBP_direction == PBP_HORIZONTAL) {
      x += BATTLE_BLOCK;
      xPos ++; 
    } else {
      y += BATTLE_BLOCK;
      yPos ++; 
    }
  } /* next i */
  
  /* 
   * After handling the message, call the superclass to ensure
   * that no default behavior has been mucked up.
   */

  @callsuper();
}


/***********************************************************************
 *              MSG_META_START_SELECT for PlayerBattlePieceClass
 ***********************************************************************
 * SYNOPSIS:    Grabs the mouse and calls for future pointer events.
 *              When the user clickes in the view, PlayerBattleView will
 *              pass the click event to PlayerBattleBoard. Since
 *              PlayerBattleBoardClass does not intercept the event,
 *              VisContentClass passes it on to its child object currently   
 *              under the pointer.
 * PARAMETERS:  
 *      void (MouseReturnParams *retVal,
 *                      word xPosition, word yPosition, word inputState);    
 * SIDE EFFECTS:    
 *
 * STRATEGY:    When the piece object receives this message, it means
 *              it has been clicked on by the user and the mouse button
 *              is still down.  The piece must grab the mouse so that it
 *              gets all future mouse events, and it must request that
 *              all future mouse events be sent to it.  This ensures
 *              that if the pointer leaves the object's bounds while
 *              the button is still pressed, the piece object will still
 *              receive all the pointer events (otherwise they would be
 *              sent to whatever object was under the new pointer
 *              position).
 *
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      DR      1/31/94         Initial Revision
 *
 ***********************************************************************/

@method PlayerBattlePieceClass, MSG_META_START_SELECT {

  if (g_battleStarted == BR_GAME_NEW) {
    /* don't move pieces when game over or battle started */
  
    /* Grab the gadget exclusive, so that we're allowed to grab
	* the mouse. */
    @call @visParent::MSG_VIS_TAKE_GADGET_EXCL(oself);
    /*
	* Grab the mouse.  This requests that all future pointer
	* events be passed directly to this game piece. */
    @call self::MSG_VIS_GRAB_MOUSE();
  }
    retVal->flags = MRF_PROCESSED;      /* this event processed */
}


/***********************************************************************
 *              MSG_META_DRAG_SELECT for PlayerBattlePieceClass
 ***********************************************************************
 * SYNOPSIS:    This message is sent to the piece object when the
 *              select button has been pressed and the mouse has been
 *              moved, resulting in a "drag-select" event.
 *              For event processing from the View, see the header
 *              for MSG_META_START_SELECT.    
 * PARAMETERS:  
 *      void (MouseReturnParams *retVal,
 *                      word xPosition, word yPosition, word inputState);    
 *
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      DR      1/31/94         Initial Revision
 *
 ***********************************************************************/

@method PlayerBattlePieceClass, MSG_META_DRAG_SELECT {

  GStateHandle gstate;
  WindowHandle win;
  sword x = 0;
  sword y = 0;

  if (g_battleStarted == BR_GAME_NEW) {
    /* don't move pieces when game over or battle started */

    /* Set flag indicating that we're being dragged. */
    pself->PBP_dragging = TRUE;

    /* Get the view's window handle and create a temporary gstate
	* for drawing into. */
    win = @call PlayerBattleView::MSG_GEN_VIEW_GET_WINDOW();
    gstate = GrCreateState(win);

    /* Set the color to black and the drawing mode to MM_INVERT
	* for outline drawing. */
    GrSetLineColor(gstate, CF_INDEX, C_BLACK, 0, 0);
    GrSetMixMode(gstate, MM_INVERT);

    /* Now set the current motion position so the top left of the raft is
	* centered on the pointer. */
    pself->PBP_vertPos = yPosition / BATTLE_BLOCK;
    pself->PBP_horizPos = xPosition / BATTLE_BLOCK;

    /* Draw the new outline at the current position. */
    x = FIRST_HORIZ + 1 + pself->PBP_horizPos * BATTLE_BLOCK;
    y = FIRST_VERT + 1 + pself->PBP_vertPos * BATTLE_BLOCK;
  
    /* Draw outline in proper direction */
    if (pself->PBP_direction == PBP_HORIZONTAL) {
	 GrDrawRoundRect(gstate, x, y,
			    x + pself->PBP_size * BATTLE_BLOCK - LOG_SIZE + 1,
			    y + LOG_LENGTH, LOG_CURVE);
    } else {
	 GrDrawRoundRect(gstate, x, y,
			    x + LOG_LENGTH + 1, 
			    y + pself->PBP_size * BATTLE_BLOCK - LOG_SIZE, 
			    LOG_CURVE);
    }

    GrDestroyState(gstate);
  }
  retVal->flags = MRF_PROCESSED;
}



/***********************************************************************
 *              MSG_META_PTR for PlayerBattlePieceClass
 ***********************************************************************
 * SYNOPSIS:    This message is received whenever the pointer passes
 *              over this game piece object's bounds (and another
 *              game piece is not sitting directly on top of it).
 *              See MSG_META_START_SELECT for a description of how the event
 *              gets passed from PlayerBattleView to this object.    
 * PARAMETERS:      
 *      void (MouseReturnParams *retVal,
 *                      word xPosition, word yPosition, word inputState);
 *
 * STRATEGY:    This message can be either a drag event or a simple
 *              pointer event.  If the latter, we want to do nothing
 *              because no mouse button is pressed.  If the latter,
 *              we want to execute the same function as MSG_DRAG.
 *
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      DR      1/31/94         Initial Revision
 *
 ***********************************************************************/
@method PlayerBattlePieceClass, MSG_META_PTR {

  GStateHandle gstate;
  WindowHandle win;
  sword x = 0;
  sword y = 0;
  int xnew = 0;
  int ynew = 0;

  if (g_battleStarted == BR_GAME_NEW) {
    /* don't move pieces when game over or battle started */

    /* First check if piece is being dragged. If not, do nothing
	* and return that this event was not processed. Also check
	* to see if raft changed grid positions. If this is a
	* true, then draw a new outline and erase the old outline. */

    xnew = xPosition / BATTLE_BLOCK;
    ynew = yPosition / BATTLE_BLOCK;

    if ((pself->PBP_dragging) && ((xnew != pself->PBP_horizPos)
	    || (ynew != pself->PBP_vertPos))) {

	 win = @call PlayerBattleView::MSG_GEN_VIEW_GET_WINDOW();
	 gstate = GrCreateState(win);

	 GrSetLineColor(gstate, CF_INDEX, C_BLACK, 0, 0);
  	 GrSetMixMode(gstate, MM_INVERT);

	 /* Erase the old outline by drawing an inverse outline at the
	  * old bounds. */

	 x = FIRST_HORIZ + 1 + pself->PBP_horizPos * BATTLE_BLOCK;
	 y = FIRST_VERT + 1 + pself->PBP_vertPos * BATTLE_BLOCK;
  
	 if (pself->PBP_direction == PBP_HORIZONTAL) {
	   GrDrawRoundRect(gstate, x, y,
			    x + pself->PBP_size * BATTLE_BLOCK - LOG_SIZE + 1,
			    y + LOG_LENGTH, LOG_CURVE);
	 } else {
	   GrDrawRoundRect(gstate, x, y,
			    x + LOG_LENGTH + 1, 
			    y + pself->PBP_size * BATTLE_BLOCK - LOG_SIZE,
			    LOG_CURVE);
	 }

	 /* Now set the current motion position so the top left of the raft is
	  * centered on the pointer. */
	 pself->PBP_horizPos = xnew;
	 pself->PBP_vertPos = ynew;
	 x = FIRST_HORIZ + 1 + pself->PBP_horizPos * BATTLE_BLOCK;
	 y = FIRST_VERT + 1 + pself->PBP_vertPos * BATTLE_BLOCK;

	 /* Draw the new outline at the current position. */
	 if (pself->PBP_direction == PBP_HORIZONTAL) {
	   GrDrawRoundRect(gstate, x, y,
			    x + pself->PBP_size * BATTLE_BLOCK - LOG_SIZE + 1,
			    y + LOG_LENGTH, LOG_CURVE);
	 } else {
	   GrDrawRoundRect(gstate, x, y,
			    x + LOG_LENGTH + 1, 
			    y + pself->PBP_size * BATTLE_BLOCK - LOG_SIZE, 
			    LOG_CURVE);
	 }

	 GrDestroyState(gstate);
    }
  }
  retVal->flags = MRF_PROCESSED;      /* this event processed */
}


/***********************************************************************
 *              MSG_META_END_SELECT for PlayerBattlePieceClass
 ***********************************************************************
 * SYNOPSIS:    This message is received when the selection button has
 *              been released and this game piece had the mouse grab.
 *              All it does is release the gadget exclusive, which will
 *              cause us to end any dragging in process, & release the
 *              mouse.    
 * PARAMETERS:  
 *      void (MouseReturnParams *retVal,
 *                      word xPosition, word yPosition, word inputState);    
 *
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      DR      1/31/94         Initial Revision
 *
 ***********************************************************************/

@method PlayerBattlePieceClass, MSG_META_END_SELECT {

  if (g_battleStarted == BR_GAME_NEW) {
    /* don't move pieces when game over or battle started */
    @call @visParent::MSG_VIS_RELEASE_GADGET_EXCL(oself);
  }
    retVal->flags = MRF_PROCESSED;      /* this event processed */
}


/***********************************************************************
 *              MSG_VIS_LOST_GADGET_EXCL for PlayerBattlePieceClass
 ***********************************************************************
 * SYNOPSIS:    This message is received when the selection button has
 *              been released and this game piece had the mouse grab.
 *              It first checks to see if the new, proposed bounds are
 *              on the game board.  If the bounds are valid, then
 *              it sets the objects VI_bounds field to the new values
 *              and causes the object to erase its original drawing
 *              and draw itself at its new bounds.  If the bounds are
 *              not on the game board, it will retain the original bounds.
 * PARAMETERS:      
 *      void ();
 *
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      DR      1/31/94         Initial Revision
 *
 ***********************************************************************/
@method PlayerBattlePieceClass, MSG_VIS_LOST_GADGET_EXCL {

  WindowHandle win;
  GStateHandle gstate;
  sword x, x1 = 0;
  sword y, y1 = 0;

  if (g_battleStarted == BR_GAME_NEW) {
    /* don't move pieces when game over or battle started */

    /* See if piece was being dragged or not.  If so, we have to
	* clear out outine. */
    if (pself->PBP_dragging) {

	 win = @call PlayerBattleView::MSG_GEN_VIEW_GET_WINDOW();
	 gstate = GrCreateState(win);

	 GrSetLineColor(gstate, CF_INDEX, C_BLACK, 0, 0);
	 GrSetMixMode(gstate, MM_INVERT);

	 /* Erase outline on screen. */
	 x = FIRST_HORIZ + 1 + pself->PBP_horizPos * BATTLE_BLOCK;
	 y = FIRST_VERT + 1 + pself->PBP_vertPos * BATTLE_BLOCK;
  
	 if (pself->PBP_direction == PBP_HORIZONTAL) {
	   x1 = x + pself->PBP_size * BATTLE_BLOCK - LOG_SIZE + 1;
	   y1 = y + LOG_LENGTH;
	   GrDrawRoundRect(gstate, x, y, x1, y1, LOG_CURVE);
	 } else {
	   x1 = x + LOG_LENGTH + 1;
	   y1 = y + pself->PBP_size * BATTLE_BLOCK - LOG_SIZE;
	   GrDrawRoundRect(gstate, x, y, x1, y1, LOG_CURVE);
	 }

	 /* Check to see if the new bounds are on the game board.  If
	  * they are, set the object's bounds to the new values.  If
	  * the are not, retain the original values and set the values
	  * to those last stored. */

	 if (@call PlayerBattleBoard::MSG_BOARD_PLACE_PIECE_CHECK(
	      pself->PBP_horizPos, pself->PBP_vertPos,
	      pself->PBP_size, pself->PBP_direction, pself->PBP_type)) {

	   /* Invalidate the original drawing of the game piece.  Send
	    * the VI_bounds rectangle as the parameters because they have
	    * not been changed since the START_SELECT.  This message is
	    * the equivalent of calling GrInvalRect() with the same
	    * bounds. */
	   @call self::MSG_VIS_BOUNDS_CHANGED(
				pself->VI_bounds.R_bottom,
				pself->VI_bounds.R_right + 1,
				pself->VI_bounds.R_top,
				pself->VI_bounds.R_left);

	   /* Erase the raft from the battle grid at old position */
	   @call PlayerBattleBoard::MSG_BOARD_PLACE_PIECE(
		 pself->VI_bounds.R_left / BATTLE_BLOCK,
		 pself->VI_bounds.R_top / BATTLE_BLOCK,
		 pself->PBP_size, pself->PBP_direction, BR_EMPTY);

	   /* Set the game piece object's bounds to the new coordinates. */
	   pself->VI_bounds.R_left = x - 1;
	   pself->VI_bounds.R_right = x1 + 1;
	   pself->VI_bounds.R_top = y - 1;
	   pself->VI_bounds.R_bottom = y1 + 1;

	   /* Place the raft in the battle grid at new position */
	   @call PlayerBattleBoard::MSG_BOARD_PLACE_PIECE(
		 pself->PBP_horizPos, pself->PBP_vertPos,
		 pself->PBP_size, pself->PBP_direction, pself->PBP_type);
    
	   /* Now, the game piece must draw itself at its newly-set
	    * bounds. */
	   @call self::MSG_VIS_DRAW(0, gstate);
    
	 } else {
	   /* If the bounds are not on the game board, then  reset the
	    * current positions to be the original bounds. Warn User.
	    */
	   pself->PBP_horizPos = pself->VI_bounds.R_left / BATTLE_BLOCK;
	   pself->PBP_vertPos = pself->VI_bounds.R_top / BATTLE_BLOCK;
	   UserStandardSound(SST_WARNING);
	 }

	 GrDestroyState(gstate);

	 /* Clear flag to indicate we are no longer dragging. */
	 pself->PBP_dragging = FALSE;
  
    }

    /* Release the mouse grab now that the move has finished.
	* Other objects in the view (other game pieces, for example)
	* may now receive pointer, select, and drag events. */
    @call self::MSG_VIS_RELEASE_MOUSE();
  }
}


/***********************************************************************
 *              MSG_META_START_MOVE_COPY for PlayerBattlePieceClass
 ***********************************************************************
 * SYNOPSIS:    This message is received when the move/copy button has
 *              been pressed.
 *              It first checks to see if the new, proposed bounds are
 *              on the game board.  If the bounds are valid, then
 *              it sets the objects VI_bounds field to the new values
 *              and causes the object to erase its original drawing
 *              and draw itself at its new bounds.  If the bounds are
 *              not on the game board, it will retain the original bounds
 *              and redraw using them.    
 * PARAMETERS:      
 *      void (MouseReturnParams *retVal,
 *                      word xPosition, word yPosition, word inputState);    
 *
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      DR      1/31/94         Initial Revision
 *
 ***********************************************************************/
@method PlayerBattlePieceClass, MSG_META_START_MOVE_COPY {

  WindowHandle win;
  GStateHandle gstate;
  int direction = PBP_HORIZONTAL;
  sword x, x1, y, y1;

  if (g_battleStarted == BR_GAME_NEW) {
    /* don't move pieces when game over or battle started */

    /*
	* Calculate proposed bounds of new direction.
	*/
    x = FIRST_HORIZ + 1 + pself->PBP_horizPos * BATTLE_BLOCK;
    y = FIRST_VERT + 1 + pself->PBP_vertPos * BATTLE_BLOCK;

    if (pself->PBP_direction == PBP_HORIZONTAL) {
	 x1 = x + LOG_LENGTH;
	 y1 = y + pself->PBP_size * BATTLE_BLOCK - LOG_SIZE;
	 /* Change direction for test */
	 direction = PBP_VERTICAL;
    } else {
	 x1 = x + pself->PBP_size * BATTLE_BLOCK - LOG_SIZE;
	 y1 = y + LOG_LENGTH;
    }

    /*
	* Check to see if the new bounds are on the game board.  If
	* they are, set the object's bounds to the new values.  If
	* the are not, retain the original values and set the values
	* to those last stored.
	*/
    if (@call PlayerBattleBoard::MSG_BOARD_PLACE_PIECE_CHECK(
	    pself->PBP_horizPos, pself->PBP_vertPos,
	    pself->PBP_size, direction, pself->PBP_type)) {

	 /*
	  * Piece will fit in new direction.
	  */
	 @call self::MSG_VIS_BOUNDS_CHANGED(
				pself->VI_bounds.R_bottom,
				pself->VI_bounds.R_right + 1,
				pself->VI_bounds.R_top,
				pself->VI_bounds.R_left);

	 /* Erase the raft from the battle grid at old position */
	 @call PlayerBattleBoard::MSG_BOARD_PLACE_PIECE(
	    pself->PBP_horizPos, pself->PBP_vertPos,
	    pself->PBP_size, pself->PBP_direction, BR_EMPTY);

	 /* Rotate piece */
	 pself->PBP_direction = direction;
    
	 /* Set the game piece object's bounds to the new coordinates. */
	 pself->VI_bounds.R_left = x - 1;
	 pself->VI_bounds.R_right = x1 + 1;
	 pself->VI_bounds.R_top = y - 1;
	 pself->VI_bounds.R_bottom = y1 + 1;

	 /* Place the raft in the battle grid at new position */
	 @call PlayerBattleBoard::MSG_BOARD_PLACE_PIECE(
	    pself->PBP_horizPos, pself->PBP_vertPos,
	    pself->PBP_size, pself->PBP_direction, pself->PBP_type);

	 /*
	  * Now, the game piece must draw itself at its newly-set
	  * bounds.
	  */
	 win = @call PlayerBattleView::MSG_GEN_VIEW_GET_WINDOW();
	 gstate = GrCreateState(win);

	 @call self::MSG_VIS_DRAW(0, gstate);

	 GrDestroyState(gstate);
    } else {
	 /* Piece will not fit. Warn user. */
	 UserStandardSound(SST_WARNING);
    }
  }  /* end of new game if */

  retVal->flags = MRF_PROCESSED;      /* this event processed */

}

