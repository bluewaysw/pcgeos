/***********************************************************************
 *
 *	Copyright (c) NewDeal 1999 -- All Rights Reserved
 *
 * PROJECT:	  GeoSafari
 * FILE:			safari2Game.goc
 * AUTHOR:  	  Gene Anderson
 *
 *	$Id$
 *
 ***********************************************************************/

@include "safari2.goh"
@include "global.goh"

@classdecl  SafGameCardClass;

/* I don't understand this but it was originally way down in this file
	and only those routines below it would take SWAT break points.
	Try it up here WHERE IT WORKS!!*/
#ifdef __BORLANDC__
#pragma codeseg GameFileCode
#endif
#ifdef __WATCOMC__
#pragma code_seg("GameFileCode")
#endif


/**************************************************************
 *          
 * FUNCTION:        ReportError()
 * DESCRIPTION:     report an error
 *
 * PASS:            errorMsg - chunk of error message in STRINGS
 *                  optStr - argument #1 string (NULL if none)
 * RETURN:          none
 * DESCRIPTION:
 *         
 *
 * REVISION HISTORY:
 *         Name      Date        Description
 *         ----      ----        -----------
 *         gene      12/4/98     Initial Revision
***************************************************************/

void
ReportError(optr errorMsg, TCHAR *optStr)
{
    MemLock(OptrToHandle(errorMsg));
    @call SafariAppObj::MSG_GEN_APPLICATION_DO_STANDARD_DIALOG(
	0,       /* dialogMethod */
	0,       /* dialogOD */
	NULL,    /* helpContext */
	NULL,    /* customTriggers */
	NULL,    /* arg2 */
	optStr,  /* arg1 */
	LMemDeref(errorMsg), /* string */
	(CDT_ERROR << CDBF_DIALOG_TYPE_OFFSET) |
	/* interaction type */
	(GIT_NOTIFICATION << CDBF_INTERACTION_TYPE_OFFSET)
	);
    MemUnlock(OptrToHandle(errorMsg));
}


/***********************************************************************
 *		PlaySound
 ***********************************************************************
 * SYNOPSIS:	    Play a sound as specified
 * PASS:            synthSound - ptr to note buffer
 *                  synthSize - size of note buffer
 *                  sampSound - ptr to filename of sample sound (*.WAV)
 *                  StandardPath - stdPath for .WAV
 *                  path - pathname for .WAV
 * RETURN:          none
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	gene	4/12/99		Initial Revision
 *
 ***********************************************************************/
void
PlaySound(word *synthSound, word synthSize, TCHAR *sampSound,
	  StandardPath stdPath, TCHAR *path)
{
    SoundStatus status;
    status = @call SoundList::MSG_GEN_BOOLEAN_GROUP_GET_SELECTED_BOOLEANS();

    if (status & SS_SYNTH && synthSound) {
	asm {push si}
	UserStandardSound(SST_CUSTOM_BUFFER, synthSound, synthSize);
	asm {pop si}
    }
    if (status & SS_SAMPLED && sampSound) {
	@call process::MSG_SAF_PROCESS_PLAY_SOUND(stdPath, path, sampSound);
    }
}



/***********************************************************************
 *	PlayRandomNote
 ***********************************************************************
 * SYNOPSIS:	    Play a random note
 * PASS:            none
 * RETURN:          none
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	gene	4/13/99		Initial Revision
 *
 ***********************************************************************/

word noteTable[] = {
    SSE_CHANGE, 0, IP_MARIMBA, IT_STANDARD_TABLE,
    SSE_GENERAL, GE_SET_PRIORITY, SP_GAME,
    SSDTT_TICKS, 4,
    SSE_VOICE_ON, 0, MIDDLE_C, DYNAMIC_F,
    SSDTT_TICKS, QUESTION_FLASH_TIME/2,
    SSE_VOICE_OFF, 0,
    SSE_GENERAL, GE_END_OF_SONG
};

static const word notes[] = {
    MIDDLE_C,
    MIDDLE_D,
    MIDDLE_E,
    MIDDLE_F,
    MIDDLE_G,
    MIDDLE_A,
    MIDDLE_B,
    HIGH_C
};

void
PlayRandomNote()
{
    word i;
    i = GameRandom(sizeof(notes)/sizeof(word));
    noteTable[11] = notes[i];
    PlaySound(&noteTable, sizeof(noteTable), NULL, 0, NULL);
}




/***********************************************************************
 *		MSG_SAF_GAME_CARD_ASK_QUESTION
 ***********************************************************************
 * SYNOPSIS:	    Ask a question
 * PASS:            none
 * RETURN:          none
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	gene	4/13/99		Initial Revision
 *
 ***********************************************************************/
@method SafGameCardClass, MSG_SAF_GAME_CARD_ASK_QUESTION
{
    VMBlockHandle mapBlock;
    SafariMapBlock *mapPtr;
    SafariQuestionStruct *qs;
    MemHandle mem;
    word i, q, numQuestions, eSize, indOn;
    optr ind;
    TCHAR *strP;
    WWFixed ptSize;

    pself->SBGCI_mode = GM_ASKING_QUESTION;

    /*
     * stop the indicator from flashing, in case we started
     * from the keyboard
     */
    if (pself->SBGCI_curPlayer == QS_PLAYER_1) {
	@call Player1Indicator::MSG_INDICATOR_SET_STATE(IS_ON);
    } else {
	@call Player2Indicator::MSG_INDICATOR_SET_STATE(IS_ON);
    }

    /*
     * find the handle for the document's map block and lock it
     */
    mapBlock = VMGetMapBlock(pself->GCI_fileHan);
    mapPtr = VMLock(pself->GCI_fileHan, mapBlock, &mem);
    numQuestions = ChunkArrayGetCount(ConstructOptr(mem, mapPtr->SMB_quiz));

    /*
     * flash some random indicators and play some notes
     */
    indOn = !(mapPtr->SMB_flags & SFO_NO_LEDS);
    for (i = 0; i < NUM_LED_FLASHES; i++) {
	q = GameRandom(numQuestions);
	qs = ChunkArrayElementToPtr(ConstructOptr(mem, mapPtr->SMB_quiz),
				    q, &eSize);
	if (indOn) {
	    ind = @call LeftIndicatorGroup::MSG_INDICATOR_GROUP_GET_NTH(qs->SQS_indicator);
	    @call ind::MSG_INDICATOR_SET_STATE(IS_ON);
	}
	PlayRandomNote();
	TimerSleep(QUESTION_FLASH_TIME);
	if (indOn) {
	    @call ind::MSG_INDICATOR_SET_STATE(0);
	}
    }
    if (@call QuestionOrderList::MSG_GEN_ITEM_GROUP_GET_SELECTION()) {
	/*
	 * choose a random question from those left
	 */
	q = QuizChooseQuestion(pself->SBGCI_quizArray, pself->SBGCI_curPlayer);
    } else {
	/*
	 * get the next question in order
	 */
	q = QuizNextQuestion(pself->SBGCI_quizArray, pself->SBGCI_curPlayer);
    }
    pself->SBGCI_curQuestion = q;
    /*
     * set the indicator for it flashing
     */
    qs = ChunkArrayElementToPtr(ConstructOptr(mem, mapPtr->SMB_quiz),
				q, &eSize);
    if (indOn) {
	ind = @call LeftIndicatorGroup::MSG_INDICATOR_GROUP_GET_NTH(qs->SQS_indicator);
	@call ind::MSG_INDICATOR_SET_STATE(IS_FLASHING);
    }
    /*
     * turn the question glyph on
     */
    @call QGlyph::MSG_SAFARI_GLYPH_SET_STATE(TRUE);
    @call AnswerText::MSG_VIS_TEXT_DELETE_ALL();

    /*
     * set the question text
     */
    @call QuestionText::MSG_META_SUSPEND();
    strP = (TCHAR *)((byte *)qs + sizeof(SafariQuestionStruct));
    @call QuestionText::MSG_VIS_TEXT_REPLACE_ALL_PTR(strP, 0);

    /*
     * set the pointsize according to the length
     * i.e., short text -> larger pointsize
     */
    i = strlen(strP);
    if (i < 40) {
	q = 14;
    } else {
	q = 10;
    }
    ptSize.WWF_int = q;
    ptSize.WWF_frac = 0;
    @call QuestionText::MSG_VIS_TEXT_SET_POINT_SIZE(ptSize,
						    TEXT_ADDRESS_PAST_END, 0);
    @call QuestionText::MSG_META_UNSUSPEND();

    /*
     * play any question sound
     */
    if (mapPtr->SMB_flags & SFO_QUESTION_SOUNDS) {
	strP += strlen(strP)+1;   /* skip question text */
	strP += strlen(strP)+1;   /* skip answer text */
	if (strP[0]) {
	    PlaySound(NULL, 0, strP, pself->GCI_stdPath, pself->GCI_path);
	}
    }

    VMUnlock(mem);

    /*
     * start the timer running
     */
    @call CountdownTimer::MSG_GAME_TIMER_START(FALSE);
}



/***********************************************************************
 *		CheckMousePos
 ***********************************************************************
 * SYNOPSIS:	    Check a mouse position
 * PASS:            arrHan - handle of array block
 *                  arrChunk - chunk of array
 *                  (xPosition, yPosition) - (x,y) of mouse (obj relative)
 * RETURN:          none
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	gene	10/15/99	Initial Revision
 *
 ***********************************************************************/

SafariQuestionStruct *
CheckQuestionPos(MemHandle arrHan, ChunkHandle arrChunk, word i, sword xPosition, sword yPosition)
{
    word eSize;
    SafariQuestionStruct *qs;

    qs = ChunkArrayElementToPtr(ConstructOptr(arrHan,arrChunk), i, &eSize);
    if (xPosition >= qs->SQS_bounds.R_left &&
	xPosition <= qs->SQS_bounds.R_right &&
	yPosition >= qs->SQS_bounds.R_top &&
	yPosition <= qs->SQS_bounds.R_bottom) {
	return(qs);
    }
    return(NULL);
}

SafariQuestionStruct *
CheckMousePos(MemHandle arrHan, ChunkHandle arrChunk, sword xPosition, sword yPosition)
{
    word i, num;
    Boolean found = FALSE;
    SafariQuestionStruct *qs;

    num = ChunkArrayGetCount(ConstructOptr(arrHan, arrChunk));
    for (i = 0; !found && i < num; i++) {
	qs = CheckQuestionPos(arrHan, arrChunk, i, xPosition, yPosition);
	if (qs) {
	    found = TRUE;
	}
    }
    /*
     * no match; return NULL
     */
    if (!found) {
	qs = NULL;
    }
    return(qs);
}


/***********************************************************************
 *		MSG_META_START_SELECT
 ***********************************************************************
 * SYNOPSIS:	    Handle a mouse press
 * PASS:            xPosition - x pos
 *                  yPosition - y pos
 *                  inputState
 *                  retVal - ptr to MouseReturnParams
 * RETURN:          retVal.flags - MRF_PROCESSED
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	gene	4/13/99		Initial Revision
 *
 ***********************************************************************/
@method SafGameCardClass, MSG_META_START_SELECT
{
    VMBlockHandle mapBlock;
    SafariMapBlock *mapPtr;
    SafariQuestionStruct *qs;
    MemHandle mem;
    XYValueAsDWord pos;

    retVal->flags = MRF_PROCESSED|MRF_CLEAR_POINTER_IMAGE;

    switch (pself->SBGCI_mode) {
    case GM_ASKING_QUESTION:
	break;
    case GM_IDLE:
 //	@call ChooseDB::MSG_GEN_INTERACTION_INITIATE();
	return;
    case GM_WAITING:
	@call oself::MSG_SAF_GAME_CARD_ASK_QUESTION();
	return;
    default:
	return;
    }

    /*
     * find the handle for the document's map block and lock it
     */
    mapBlock = VMGetMapBlock(pself->GCI_fileHan);
    mapPtr = VMLock(pself->GCI_fileHan, mapBlock, &mem);

    /*
     * see if the click is in the question bounds
     */
    pos = @call oself::MSG_VIS_GET_POSITION();
    xPosition -= DWORD_X(pos);
    yPosition -= DWORD_Y(pos);

    if (CheckQuestionPos(mem, mapPtr->SMB_quiz, pself->SBGCI_curQuestion, xPosition, yPosition)) {
	/*
	 * if mouse is in bounds of our question, right answer
	 */
	@send, forceQueue oself::MSG_SAF_GAME_CARD_RIGHT_ANSWER();
    } else {
	/*
	 * if mouse is in bounds of some other question, wrong answer
	 */
	qs = CheckMousePos(mem, mapPtr->SMB_quiz, xPosition, yPosition);
	if (qs) {
	    @send, forceQueue oself::MSG_SAF_GAME_CARD_WRONG_ANSWER(FALSE);
	}
    }

    VMUnlock(mem);
}


/***********************************************************************
 *		MSG_META_PTR
 ***********************************************************************
 * SYNOPSIS:	    Handle a mouse event
 * PASS:            xPosition - x pos
 *                  yPosition - y pos
 *                  inputState
 *                  retVal - ptr to MouseReturnParams
 * RETURN:          retVal.flags - MRF_PROCESSED
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	gene	4/13/99		Initial Revision
 *
 ***********************************************************************/
@method SafGameCardClass, MSG_META_PTR
{
    VMBlockHandle mapBlock;
    SafariMapBlock *mapPtr;
    SafariQuestionStruct *qs;
    MemHandle mem;
    XYValueAsDWord pos;

    retVal->flags = MRF_PROCESSED|MRF_CLEAR_POINTER_IMAGE;
    if (pself->SBGCI_mode != GM_ASKING_QUESTION) {
	return;
    }
    /*
     * find the handle for the document's map block and lock it
     */
    mapBlock = VMGetMapBlock(pself->GCI_fileHan);
    mapPtr = VMLock(pself->GCI_fileHan, mapBlock, &mem);

    /*
     * see if the ptr is in the bounds of any question
     */
    pos = @call oself::MSG_VIS_GET_POSITION();
    xPosition -= DWORD_X(pos);
    yPosition -= DWORD_Y(pos);
    qs = CheckMousePos(mem, mapPtr->SMB_quiz, xPosition, yPosition);
    if (qs) {
	@call oself::MSG_SAF_GAME_CARD_SET_SELECTION(qs->SQS_bounds.R_left,
						     qs->SQS_bounds.R_top,
						     qs->SQS_bounds.R_right,
						     qs->SQS_bounds.R_bottom);
    } else {
	@call oself::MSG_SAF_GAME_CARD_CLEAR_SELECTION();
    }
    VMUnlock(mem);
}




/***********************************************************************
 *		MSG_SAF_GAME_CARD_PLAY_ANSWER_SOUND
 ***********************************************************************
 * SYNOPSIS:	    play an answer sound
 * PASS:            synthSound - ptr to synthesized sound
 *                  synthSize - size of synthesized sound
 *                  sampSound - ptr to sampled sound filename (.WAV)
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	gene	6/25/99		Initial Revision
 *
 ***********************************************************************/

@method SafGameCardClass, MSG_SAF_GAME_CARD_PLAY_ANSWER_SOUND
{
    VMBlockHandle mapBlock;
    SafariMapBlock *mapPtr;
    SafariQuestionStruct *qs;
    MemHandle mem;
    word eSize;
    TCHAR *strP;
    Boolean playedSound = FALSE;

    mapBlock = VMGetMapBlock(pself->GCI_fileHan);
    mapPtr = VMLock(pself->GCI_fileHan, mapBlock, &mem);
    if (mapPtr->SMB_flags & SFO_QUESTION_SOUNDS) {
	qs = ChunkArrayElementToPtr(ConstructOptr(mem, mapPtr->SMB_quiz),
				    pself->SBGCI_curQuestion, &eSize);
	strP = (TCHAR *)((byte *)qs + sizeof(SafariQuestionStruct));
	strP += strlen(strP)+1;      /* skip question text */
	strP += strlen(strP)+1;      /* skip answer text */
	strP += strlen(strP)+1;      /* skip question sound */
	if (strP[0]) {
	    PlaySound(synthSound, synthSize, strP, pself->GCI_stdPath, pself->GCI_path);
	    playedSound--;
	}
    }
    VMUnlock(mem);
    /*
     * if no answer sound, play standard right, wrong, or time's up
     */
    if (!playedSound) {
	PlaySound(synthSound, synthSize, sampSound, SP_USER_DATA, "SOUNDS");
    }
}


/***********************************************************************
 *		MSG_SAF_GAME_CARD_RIGHT_ANSWER
 ***********************************************************************
 * SYNOPSIS:	    user got the right answer
 * PASS:            none
 * RETURN:          none
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	gene	4/13/99		Initial Revision
 *
 ***********************************************************************/


static const word rightSound[] = {
    SSE_CHANGE, 0, IP_TRUMPET, IT_STANDARD_TABLE,
    SSE_GENERAL, GE_SET_PRIORITY, SP_GAME,
    SSDTT_TICKS, 4,
    SSE_VOICE_ON, 0, MIDDLE_C, DYNAMIC_F,
    SSDTT_TICKS, EIGHTH,
    SSE_VOICE_ON, 0, MIDDLE_E, DYNAMIC_F,
    SSDTT_TICKS, EIGHTH,
    SSE_VOICE_ON, 0, MIDDLE_G, DYNAMIC_F,
    SSDTT_TICKS, EIGHTH,
    SSE_VOICE_ON, 0, MIDDLE_E, DYNAMIC_F,
    SSDTT_TICKS, EIGHTH,
    SSE_VOICE_ON, 0, MIDDLE_C, DYNAMIC_F,
    SSDTT_TICKS, EIGHTH,
    SSE_VOICE_OFF, 0,
    SSE_GENERAL, GE_END_OF_SONG
};

@method SafGameCardClass, MSG_SAF_GAME_CARD_RIGHT_ANSWER
{
    word score;

    /*
     * stop the countdown timer
     */
    @call CountdownTimer::MSG_GAME_TIMER_STOP();
    /*
     * mark the question as right
     */
    pself->SBGCI_quizArray[pself->SBGCI_curQuestion] |= QS_RIGHT;

    /*
     * play some sounds
     */
    @call  oself::MSG_SAF_GAME_CARD_PLAY_ANSWER_SOUND(&rightSound, sizeof(rightSound), "GS_RIGHT.WAV");

    /*
     * update the scores
     */
    score = QuizScore(pself->SBGCI_quizArray, QS_PLAYER_1);
    @call Player1Score::MSG_SAFARI_SCORE_SET_SCORE(score);
    score = QuizScore(pself->SBGCI_quizArray, QS_PLAYER_2);
    @call Player2Score::MSG_SAFARI_SCORE_SET_SCORE(score);

    @call LeftFeedback::MSG_SAFARI_FEEDBACK_START(0, 255, 0);
    @call RightFeedback::MSG_SAFARI_FEEDBACK_START(0, 255, 0);

    /*
     * start the show answer timer
     */
    @call oself::MSG_SAF_GAME_CARD_SHOW_ANSWER();
}


/***********************************************************************
 *		MSG_SAF_GAME_CARD_WRONG_ANSWER
 ***********************************************************************
 * SYNOPSIS:	    user got the wrong answer
 * PASS:            timesUp - TRUE if timer expired
 * RETURN:          none
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	gene	4/13/99		Initial Revision
 *
 ***********************************************************************/
static const word wrongSound[] = {
    SSE_CHANGE, 0, IP_TROMBONE, IT_STANDARD_TABLE,
    SSE_GENERAL, GE_SET_PRIORITY, SP_GAME,
    SSDTT_TICKS, 4,
    SSE_VOICE_ON, 0, LOW_E, DYNAMIC_F,
    SSDTT_TICKS, EIGHTH,
    SSE_VOICE_ON, 0, LOW_E, DYNAMIC_F,
    SSDTT_TICKS, EIGHTH,
    SSE_VOICE_ON, 0, LOW_E, DYNAMIC_F,
    SSDTT_TICKS, EIGHTH,
    SSE_VOICE_ON, 0, LOW_C, DYNAMIC_F,
    SSDTT_TICKS, QUARTER,
    SSE_VOICE_OFF, 0,
    SSE_GENERAL, GE_END_OF_SONG
};

@method SafGameCardClass, MSG_SAF_GAME_CARD_WRONG_ANSWER
{
    /*
     * stop the countdown timer
     */
    @call CountdownTimer::MSG_GAME_TIMER_STOP();
    /*
     * mark the question as right
     */
    pself->SBGCI_quizArray[pself->SBGCI_curQuestion] |= QS_WRONG;

    /*
     * play some sounds
     */
    if (timesUp) {
	@call oself::MSG_SAF_GAME_CARD_PLAY_ANSWER_SOUND(&wrongSound, sizeof(wrongSound), "GS_TIME.WAV");
    } else {
	@call oself::MSG_SAF_GAME_CARD_PLAY_ANSWER_SOUND(&wrongSound, sizeof(wrongSound), "GS_WRONG.WAV");
    }

    @call LeftFeedback::MSG_SAFARI_FEEDBACK_FLASH_ON();
    @call RightFeedback::MSG_SAFARI_FEEDBACK_FLASH_ON();

    /*
     * start the show answer timer
     */
    @call oself::MSG_SAF_GAME_CARD_SHOW_ANSWER();
}


/***********************************************************************
 *	SetFilters
 ***********************************************************************
 * SYNOPSIS:	    Set the filters on the player input objects
 * PASS:            obj - optr of PlayerInputClass object
 *                  filterType - SafariFilterType
 * RETURN:          none
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	gene	5/28/99		Initial Revision
 *
 ***********************************************************************/

void
SetFilters(optr obj, SafariFilterType filterType)
{
    VisTextFilters textFilter;
    ChunkHandle *vtfp;

    ObjLockObjBlock(OptrToHandle(obj));
    /*
     * remove existing hints
     */
    ObjVarDeleteData(obj, ATTR_VIS_TEXT_CUSTOM_FILTER);
    /*
     * set enabled in case switching from SFT_NO_KEYBOARD to something else
     */
    @call obj::MSG_GEN_SET_ENABLED(VUM_DLYD);
    /*
     * set hints according to the filterType
     */
    switch (filterType) {
 /*   case SFT_NORMAL:
	textFilter = VTF_NO_SPACES|VTFC_NUMERIC;
	break;  */
    case SFT_ALPHABETIC:
	vtfp = ObjVarAddData(obj, ATTR_VIS_TEXT_CUSTOM_FILTER, sizeof(ChunkHandle));
	*vtfp = (OptrToChunk(@alphaFilter));
	textFilter = VTF_NO_SPACES|VTF_UPCASE_CHARS|VTFC_ALPHA;
	break;
    case SFT_NUMERIC:
	textFilter = VTFC_NO_FILTER;
	vtfp = ObjVarAddData(obj, ATTR_VIS_TEXT_CUSTOM_FILTER, sizeof(ChunkHandle));
	*vtfp = (OptrToChunk(@fractionFilter));
	break;
    case SFT_NO_KEYBOARD:
	textFilter = VTFC_NO_FILTER;
	@call obj::MSG_GEN_SET_NOT_ENABLED(VUM_DLYD);
	break;
    case SFT_ANYTHING:
    default:
	textFilter = VTFC_NO_FILTER;
	break;
    }
    @call obj::MSG_VIS_TEXT_SET_FILTER(textFilter);

    MemUnlock(OptrToHandle(obj));
}


/***********************************************************************
 *		MSG_SAF_GAME_CARD_SHOW_ANSWER
 ***********************************************************************
 * SYNOPSIS:	    show the answer
 * PASS:            none
 * RETURN:          none
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	gene	4/13/99		Initial Revision
 *
 ***********************************************************************/
@method SafGameCardClass, MSG_SAF_GAME_CARD_SHOW_ANSWER
{
    VMBlockHandle mapBlock;
    SafariMapBlock *mapPtr;
    SafariQuestionStruct *qs;
    MemHandle mem;
    word eSize;
    TCHAR *strP;

    pself->SBGCI_mode = GM_SHOWING_ANSWER;

    /*
     * give something besides the answer text the focus so
     * we don't see the cursor
     */
    @call QuestionText::MSG_META_GRAB_FOCUS_EXCL();
    /*
     * turn the answer glyph on and the question glyph off
     */
    @call AGlyph::MSG_SAFARI_GLYPH_SET_STATE(TRUE);
    @call QGlyph::MSG_SAFARI_GLYPH_SET_STATE(FALSE);

    /*
     * show the text answer
     */
    mapBlock = VMGetMapBlock(pself->GCI_fileHan);
    mapPtr = VMLock(pself->GCI_fileHan, mapBlock, &mem);
    qs = ChunkArrayElementToPtr(ConstructOptr(mem, mapPtr->SMB_quiz),
				pself->SBGCI_curQuestion, &eSize);
    strP = (TCHAR *)((byte *)qs + sizeof(SafariQuestionStruct));
    strP += strlen(strP)+1;      /* skip question text */
    SetFilters(@AnswerText, SFT_ANYTHING);
    @call AnswerText::MSG_VIS_TEXT_REPLACE_ALL_PTR(strP, 0);
    ObjDerefGen(oself);
    SetFilters(@AnswerText, pself->SBGCI_filterType);

    /*
     * if any answer sound, play it
     */
    if (mapPtr->SMB_flags & SFO_QUESTION_SOUNDS) {
	strP += strlen(strP)+1;   /* skip answer text */
	strP += strlen(strP)+1;   /* skip question sound */
	if (strP[0]) {
	    PlaySound(NULL, 0, strP, pself->GCI_stdPath, pself->GCI_path);
	}
    }

    VMUnlock(mem);

    /*
     * deselect the user answer so we can show the answer the specified
     * number of times
     */
    @call oself::MSG_SAF_GAME_CARD_CLEAR_SELECTION();
    /*
     * start the show answer timer
     */
    ObjDerefGen(oself);
    pself->SBGCI_countdown = @call ShowMax::MSG_GEN_VALUE_GET_INTEGER_VALUE()*2;
    pself->SBGCI_timer = TimerStart(TIMER_EVENT_CONTINUAL,
				    oself,
				    INDICATOR_FLASH_TIME/2,
				    MSG_SAF_GAME_CARD_COUNTDOWN,
				    INDICATOR_FLASH_TIME,
				    &pself->SBGCI_timerID);
}


/***********************************************************************
 *		MSG_SAF_GAME_CARD_COUNTDOWN
 ***********************************************************************
 * SYNOPSIS:	    show the answer, countdown
 * PASS:            none
 * RETURN:          none
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	gene	4/13/99		Initial Revision
 *
 ***********************************************************************/
@method SafGameCardClass, MSG_SAF_GAME_CARD_COUNTDOWN
{
    VMBlockHandle mapBlock;
    SafariMapBlock *mapPtr;
    SafariQuestionStruct *qs;
    MemHandle mem;
    word eSize;
    optr ind;

    /*
     * find the handle for the document's map block and lock it
     */
    mapBlock = VMGetMapBlock(pself->GCI_fileHan);
    mapPtr = VMLock(pself->GCI_fileHan, mapBlock, &mem);
    qs = ChunkArrayElementToPtr(ConstructOptr(mem, mapPtr->SMB_quiz),
				pself->SBGCI_curQuestion, &eSize);
    
    /*
     * either set the selection or clear it
     */
    if (pself->SBGCI_countdown & 0x1) {
	@send oself::MSG_SAF_GAME_CARD_CLEAR_SELECTION();
    } else {
	@send oself::MSG_SAF_GAME_CARD_SET_SELECTION(qs->SQS_bounds.R_left,
						     qs->SQS_bounds.R_top,
						     qs->SQS_bounds.R_right,
						     qs->SQS_bounds.R_bottom);
    }
    /*
     * one more tick; stop if done
     */
    if (!(--pself->SBGCI_countdown)) {
	pself->SBGCI_mode = GM_WAITING;
	TimerStop(pself->SBGCI_timer, pself->SBGCI_timerID);
	pself->SBGCI_timer = 0;
	if (!(mapPtr->SMB_flags & SFO_NO_LEDS)) {
	    ind = @call LeftIndicatorGroup::MSG_INDICATOR_GROUP_GET_NTH(qs->SQS_indicator);
	    @call ind::MSG_INDICATOR_SET_STATE(0);
	}
	@send oself::MSG_SAF_GAME_CARD_NEXT_QUESTION();
    }

    VMUnlock(mem);
}



/***********************************************************************
 *		MSG_SAF_GAME_CARD_NEXT_QUESTION
 ***********************************************************************
 * SYNOPSIS:	    Set up to ask the next question, if any
 * PASS:            none
 * RETURN:          none
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	gene	4/13/99		Initial Revision
 *
 ***********************************************************************/
@method SafGameCardClass, MSG_SAF_GAME_CARD_NEXT_QUESTION
{
    word numQ1, numQ2;

    /*
     * turn the answer glyph off and delete the answer text
     */
    @call AGlyph::MSG_SAFARI_GLYPH_SET_STATE(FALSE);
    @call AnswerText::MSG_VIS_TEXT_DELETE_ALL();

    numQ1 = QuizNumLeft(pself->SBGCI_quizArray, QS_PLAYER_1);
    numQ2 = QuizNumLeft(pself->SBGCI_quizArray, QS_PLAYER_2);
    if (numQ1 + numQ2 == 0) {
	/*
	 * no more questions: see if any need to be asked again
	 */
	@call oself::MSG_SAF_GAME_CARD_END_OF_QUIZ();
	return;
    }
    
    /*
     * switch players if needed
     */
    if (@call NumPlayers::MSG_GEN_ITEM_GROUP_GET_SELECTION() != 1) {
	if (pself->SBGCI_curPlayer == QS_PLAYER_1 && numQ2) {
	    pself->SBGCI_curPlayer = QS_PLAYER_2;
	} else if (numQ1) {
	    pself->SBGCI_curPlayer = QS_PLAYER_1;
	}
    }
    @call oself::MSG_SAF_GAME_CARD_INIT_FOR_QUESTION(FALSE);
}


/***********************************************************************
 *		MSG_SAF_GAME_CARD_INIT_FOR_QUESTION
 ***********************************************************************
 * SYNOPSIS:	    Set up to ask a question
 * PASS:            noDelete - TRUE to not clear question text
 * RETURN:          none
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	gene	4/13/99		Initial Revision
 *
 ***********************************************************************/
@method SafGameCardClass, MSG_SAF_GAME_CARD_INIT_FOR_QUESTION
{
    pself->SBGCI_mode = GM_WAITING;
    @call QGlyph::MSG_SAFARI_GLYPH_SET_STATE(FALSE);
    /*
     * make sure the indicators match the current player
     * and the correct input has the focus
     */
    @call AnswerText::MSG_VIS_TEXT_DELETE_ALL();
    if (!noDelete) {
	@call QuestionText::MSG_VIS_TEXT_DELETE_ALL();
    }
    @send, forceQueue AnswerText::MSG_META_GRAB_FOCUS_EXCL();
    @send, forceQueue AnswerText::MSG_GEN_TEXT_SET_MODIFIED_STATE(TRUE);

    if (pself->SBGCI_curPlayer == QS_PLAYER_1) {
	@call Player1Indicator::MSG_INDICATOR_SET_STATE(IS_FLASHING);
	@call Player2Indicator::MSG_INDICATOR_SET_STATE(0);
    } else {
	@call Player1Indicator::MSG_INDICATOR_SET_STATE(0);
	@call Player2Indicator::MSG_INDICATOR_SET_STATE(IS_FLASHING);
    }
}


/***********************************************************************
 *		MSG_SAF_GAME_CARD_SET_SELECTION
 ***********************************************************************
 * SYNOPSIS:	    Set the selection
 * PASS:            left,top,right,bottom - bounds
 * RETURN:          none
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	gene	4/13/99		Initial Revision
 *
 ***********************************************************************/

@method SafGameCardClass, MSG_SAF_GAME_CARD_CLEAR_SELECTION
{
    @call oself::MSG_SAF_GAME_CARD_SET_SELECTION(0,0,0,0);
}

@method SafGameCardClass, MSG_SAF_GAME_CARD_SET_SELECTION
{
    GStateHandle gs;

    if (pself->SBGCI_selection.R_left != left ||
	pself->SBGCI_selection.R_top != top ||
	pself->SBGCI_selection.R_right != right ||
	pself->SBGCI_selection.R_bottom != bottom) {

	gs = @call oself::MSG_VIS_VUP_CREATE_GSTATE();
	/*
	 * erase old selection, if any
	 */
	@call oself::MSG_SAF_GAME_CARD_DRAW_SELECTION(gs);

	pself->SBGCI_selection.R_left = left;
	pself->SBGCI_selection.R_top = top;
	pself->SBGCI_selection.R_right = right;
	pself->SBGCI_selection.R_bottom = bottom;

	/*
	 * draw the new selection
	 */
	@call oself::MSG_SAF_GAME_CARD_DRAW_SELECTION(gs);

	GrDestroyState(gs);
    }
}


/***********************************************************************
 *		MSG_SAF_GAME_CARD_DRAW_SELECTION
 ***********************************************************************
 * SYNOPSIS:	    Set the selection
 * PASS:            gstate - GStateHandle
 * RETURN:          none
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	gene	4/13/99		Initial Revision
 *
 ***********************************************************************/

@method SafGameCardClass, MSG_SAF_GAME_CARD_DRAW_SELECTION
{
    Rectangle bounds;

    if (!(pself->SBGCI_selection.R_left | pself->SBGCI_selection.R_top | pself->SBGCI_selection.R_right | pself->SBGCI_selection.R_bottom)) {
	return;
    }
    GrSaveState(gs);
    @call oself::MSG_VIS_GET_BOUNDS(&bounds);
    /*
     * translate as needed
     */
    GrApplyTranslation(gs, 
		       MakeWWFixed(bounds.R_left),
		       MakeWWFixed(bounds.R_top));
    /*
     * invert
     */
    GrSetMixMode(gs, MM_INVERT);
    if (pself->SBGCI_frameRect) {
	GrSetLineWidth(gs, MakeWWFixed(2));
	GrDrawRect(gs,
		   pself->SBGCI_selection.R_left,
		   pself->SBGCI_selection.R_top,
		   pself->SBGCI_selection.R_right+1,
		   pself->SBGCI_selection.R_bottom+1);
    } else {
	GrFillRect(gs,
		   pself->SBGCI_selection.R_left,
		   pself->SBGCI_selection.R_top,
		   pself->SBGCI_selection.R_right,
		   pself->SBGCI_selection.R_bottom);
    }
    GrRestoreState(gs);
}



/***********************************************************************
 *		MSG_SAF_GAME_CARD_SET_SELECTION_TYPE
 ***********************************************************************
 * SYNOPSIS:	    Set the selection trype
 * PASS:            selection - TRUE for outline; FALSE for filled
 * RETURN:          none
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	gene	10/9/99		Initial Revision
 *
 ***********************************************************************/
@method SafGameCardClass, MSG_SAF_GAME_CARD_SET_SELECTION_TYPE
{
    GStateHandle gs;

    if (pself->SBGCI_selection.R_left ||
	pself->SBGCI_selection.R_top ||
	pself->SBGCI_selection.R_right ||
	pself->SBGCI_selection.R_bottom) {
	/*
	 * if there is any selection, erase it before setting
	 * the selection type then redraw it in the new type
	 */
	gs = @call oself::MSG_VIS_VUP_CREATE_GSTATE();
	@call oself::MSG_SAF_GAME_CARD_DRAW_SELECTION(gs);
	ObjDerefGen(oself);
	pself->SBGCI_frameRect = selection;
	@call oself::MSG_SAF_GAME_CARD_DRAW_SELECTION(gs);
	GrDestroyState(gs);
    } else {
	pself->SBGCI_frameRect = selection;
    }
}


/***********************************************************************
 *		MSG_VIS_DRAW
 ***********************************************************************
 * SYNOPSIS:	    Draw ourselves
 * PASS:            gstate - handle of GState
 *                  drawFlags - DrawFlags
 * RETURN:          none
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	gene	4/7/99		Initial Revision
 *
 ***********************************************************************/
@method SafGameCardClass, MSG_VIS_DRAW
{
    @callsuper();
    @call oself::MSG_SAF_GAME_CARD_DRAW_SELECTION(gstate);
}



/***********************************************************************
 *		MSG_SAF_GAME_CARD_ANSWER_QUESTION
 ***********************************************************************
 * SYNOPSIS:	    answer a question -
 * CALLED BY:		  called by PlayerInputClass MSG_META_KBD_CHAR
 *						  on the press of the Enter key
 * PASS:            none
 * RETURN:          none
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	gene	4/16/99		Initial Revision
 *
 ***********************************************************************/
@method SafGameCardClass, MSG_SAF_GAME_CARD_ANSWER_QUESTION
{
    sword answer;
    word eSize;
    VMBlockHandle mapBlock;
    SafariMapBlock *mapPtr;
    SafariQuestionStruct *qs;
    MemHandle mem, th;
    TCHAR *userAns, *rightAns;

    /*
     * see if we're asking a question
     */
	 if (pself->SBGCI_mode == GM_ASKING_QUESTION) {
		/*
		 * get the answer and see if it is right
		 */
/*		if (pself->SBGCI_filterType == SFT_NORMAL) {
			/* for SFT_NORMAL the correct answer is the question number */
/*			answer = @call AnswerText::MSG_PLAYER_INPUT_GET_ANSWER();
			if (answer > 0) {
				if (answer - 1 == pself->SBGCI_curQuestion) {
					@call oself::MSG_SAF_GAME_CARD_RIGHT_ANSWER();
				} else {
					@call oself::MSG_SAF_GAME_CARD_WRONG_ANSWER(FALSE);
				}
			}

		}  */
		/* throwing an else in here because when the type is NORMAL
		 * it is also going to be != NO_KEYBOARD*/
		/*else */if (pself->SBGCI_filterType != SFT_NO_KEYBOARD) {
			/*
			 * get the user's answer
			 */
			th = @call AnswerText::MSG_VIS_TEXT_GET_ALL_BLOCK(0);
			userAns = MemLock(th);
			/*
			 * find the handle for the document's map block and lock it
			 */
			mapBlock = VMGetMapBlock(pself->GCI_fileHan);
			mapPtr = VMLock(pself->GCI_fileHan, mapBlock, &mem);
			/*
			 * get the current question
			 */
			qs = ChunkArrayElementToPtr(ConstructOptr(mem, mapPtr->SMB_quiz),
					pself->SBGCI_curQuestion, &eSize);
			rightAns = (TCHAR *)((byte *)qs + sizeof(SafariQuestionStruct));
			rightAns += strlen(rightAns)+1;
			/*
			 * see if they match
			 */
			answer = LocalCmpStringsNoCase(rightAns, userAns, 0);
			/*
			 * clean up
			 */
			VMUnlock(mem);
			MemFree(th);
			/*
			 * tell the user about it
			 */
			if (!answer) {
				@call oself::MSG_SAF_GAME_CARD_RIGHT_ANSWER();
			} else {
				@call oself::MSG_SAF_GAME_CARD_WRONG_ANSWER(FALSE);
			}
		} /* end of != SFT_NO_KEYBOARD */

	 } else if (pself->SBGCI_mode == GM_WAITING) {
		/*
		 * otherwise if we're waiting, ask a new question
		 */
		@send oself::MSG_SAF_GAME_CARD_ASK_QUESTION();
	 }

}


/* I don't know why this is here but I think it is messing up SWAT */
/*#ifdef __BORLANDC__ */
/*#pragma codeseg GameFileCode */
/*#endif  */



/***********************************************************************
 *		MSG_SAF_GAME_CARD_GET_QUIZ
 ***********************************************************************
 * SYNOPSIS:	    Get the file 
 * PASS:            none
 * RETURN:          file handle of quiz else 0
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	gene	5/4/99		Initial Revision
 *
 ***********************************************************************/
@method SafGameCardClass, MSG_SAF_GAME_CARD_GET_QUIZ
{
    return(pself->GCI_fileHan);
}


/***********************************************************************
 *		MSG_SAF_GAME_CARD_SET_QUIZ
 ***********************************************************************
 * SYNOPSIS:	    Set the quiz
 * PASS:            path - ptr to PathName
 *                  stdPath - StandardPath
 *                  filename - FileLongName
 * RETURN:          none
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	gene	4/12/99		Initial Revision
 *
 ***********************************************************************/
@method SafGameCardClass, MSG_SAF_GAME_CARD_SET_QUIZ
{
	 VMBlockHandle mapBlock/*, bm*/;
    SafariMapBlock *mapPtr;
    MemHandle mem;
    SafariQuestionStruct *qs;
    word i, numQuestions, eSize, err;
    optr ind;
    /*Boolean force16; */
    SafariFilterType filterType;
    ProtocolNumber proto;

    pself->SBGCI_mode = GM_IDLE;
    @call LeftIndicatorGroup::MSG_INDICATOR_GROUP_SET_ALL(IS_DISABLED);
    /*
     * clear the old bitmap before we close the file and screw up our
     * notion of where the bitmap came from
     */
    @call oself::MSG_GAME_CARD_CLEAR_BITMAP();
    /*
     * if any old file, close it
     */
    if (pself->GCI_fileHan) {
	VMClose(pself->GCI_fileHan, FALSE);
	pself->GCI_fileHan = 0;
    }
    /*
     * set the path
     */
    @call oself::MSG_GAME_CARD_SET_PATH(path, stdPath);
    strcpy(pself->GCI_filename, filename);

    /*
     * open the file if any
     */
    FileSetCurrentPath(stdPath, path);
    if (!filename[0]) {
	return;
    }
    /*
     * make sure it's the right protocol
     */
    err = FileGetPathExtAttributes(filename, FEA_PROTOCOL, &proto, sizeof(ProtocolNumber));
    if (err) {
	ReportError(@fileErrMsg, filename);
	goto doRedraw;
    } else if (proto.PN_major != SAFARI_DOCUMENT_PROTOCOL_MAJOR) {
	ReportError(@protoMsg, NULL);
	goto doRedraw;
    }

    pself->GCI_fileHan = VMOpen(pself->GCI_filename,
				VMAF_FORCE_DENY_WRITE|VMAF_FORCE_READ_ONLY,
				VMO_OPEN, 0);
    if (pself->GCI_fileHan) {
	/*
	 * find the handle for the document's map block and lock it
	 */
	mapBlock = VMGetMapBlock(pself->GCI_fileHan);
	mapPtr = VMLock(pself->GCI_fileHan, mapBlock, &mem);

	/*
	 * set the correct bitmap
	 * JH - it will always be the 256 embedded so get rid of a bunch of this stuff
	 */
 /*	if (InitFileReadBoolean("safari", "force16", &force16)) {
	    force16 = FALSE;
	}  */
 /*	if (GetDisplayType() == DC_COLOR_4 || force16) {
	    /*
	     * if 16-color, use either the imbedded bitmap or
	     * the external one, depending on what's there
	     */
 /*	    if (mapPtr->SMB_i16Color) {
		@call oself::MSG_GAME_CARD_SET_IMPORTED_BITMAP(mapPtr->SMB_i16Color, pself->GCI_fileHan);
	    } else {
		@call oself::MSG_GAME_CARD_SET_BITMAP(mapPtr->SMB_16color);
	    }
	} else {  */
	    /*
	     * if 256-color, check for bitmaps:
	     * if (imbedded graphics):
	     *    1. 256-color imbedded
	     *    2. 16-color imbedded
	     * else:
	     *    3. 256-color external
	     *    4. 16-color external
	     */
	/*    if (mapPtr->SMB_flags & SFO_IMBED_GRAPHICS) {
		if (mapPtr->SMB_i256color) {
			 bm = mapPtr->SMB_i256color;
		} else {
		    bm = mapPtr->SMB_i16Color;
		}
		@call oself::MSG_GAME_CARD_SET_IMPORTED_BITMAP(bm, pself->GCI_fileHan); */
		@call oself::MSG_GAME_CARD_SET_IMPORTED_BITMAP(mapPtr->SMB_i256color, pself->GCI_fileHan);
  /*		 } else {
		if (mapPtr->SMB_256color[0]) {
		    @call oself::MSG_GAME_CARD_SET_BITMAP(mapPtr->SMB_256color);
		} else {
		    @call oself::MSG_GAME_CARD_SET_BITMAP(mapPtr->SMB_16color);
		}
		 }
	}   */

	/*
	 * turn on any needed indicators
	 */
	numQuestions = ChunkArrayGetCount(ConstructOptr(mem, mapPtr->SMB_quiz));
	if (!(mapPtr->SMB_flags & SFO_NO_LEDS)) {
	    for (i = 0; i < numQuestions; i++) {
		qs = ChunkArrayElementToPtr(ConstructOptr(mem, mapPtr->SMB_quiz),
					    i, &eSize);
		ind = @call LeftIndicatorGroup::MSG_INDICATOR_GROUP_GET_NTH(qs->SQS_indicator);
		@call ind::MSG_INDICATOR_SET_STATE(0);
	    }
	}
	/*
	 * set the filters on the player input
	 */
	filterType = mapPtr->SMB_flags >> SFO_FILTER_OFFSET;
	SetFilters(@AnswerText, filterType);
	pself->SBGCI_filterType = filterType;

	/*
	 * turn 'Next Quiz' on if appropriate
	 */
	if (mapPtr->SMB_nextQuiz[0]) {
	    @call NextButton::MSG_GEN_SET_ENABLED(VUM_DLYD);
	    @call NextDescription::MSG_GEN_SET_ENABLED(VUM_DLYD);
	} else {
	    @call NextButton::MSG_GEN_SET_NOT_ENABLED(VUM_DLYD);
	    @call NextDescription::MSG_GEN_SET_NOT_ENABLED(VUM_DLYD);
	}

	/*
	 * initialize the quiz
	 */
	QuizInit(pself->SBGCI_quizArray, numQuestions);

	VMUnlock(mem);
	 } else {
	/*
	 * if unable to open file
	 */
	ReportError(@fileErrMsg, filename);
    doRedraw:
	pself->SBGCI_mode = GM_IDLE;
	@call oself::MSG_VIS_REDRAW_ENTIRE_OBJECT();
	return;
    }
	 @call BackgroundObj::MSG_SAF_BACKGROUND_RANDOM_BACKGROUND();

    /*
     * initalize the player number, indicators, etc.
     */
	 @call oself::MSG_SAF_GAME_CARD_INIT_QUIZ();

    /*
     * @send, forceQueue so PlayerInputClass gets focus properly
     * when starting up with a document
     */
	 @send, forceQueue oself::MSG_SAF_GAME_CARD_INIT_FOR_QUESTION(TRUE);
}


/***********************************************************************
 *		MSG_SAF_GAME_CARD_NEXT_QUIZ
 ***********************************************************************
 * SYNOPSIS:	    Go to the next quiz
 * PASS:            none
 * RETURN:          file handle of quiz else 0
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	gene	5/4/99		Initial Revision
 *
 ***********************************************************************/
@method SafGameCardClass, MSG_SAF_GAME_CARD_NEXT_QUIZ
{
    VMBlockHandle mapBlock;
    SafariMapBlock *mapPtr;
    MemHandle mem;
    FileLongName nextQuiz;

    /*
     * close the status DB
     */
    @call StatusDB::MSG_GEN_INTERACTION_ACTIVATE_COMMAND(IC_DISMISS);
    /*
     * find the handle for the document's map block and lock it
     */
    mapBlock = VMGetMapBlock(pself->GCI_fileHan);
    mapPtr = VMLock(pself->GCI_fileHan, mapBlock, &mem);
    /*
     * Copy the name. We need to copy because SET_QUIZ will
     * close the current file.
     */
    strcpy(nextQuiz, mapPtr->SMB_nextQuiz);
    VMUnlock(mem);

    @call oself::MSG_SAF_GAME_CARD_SET_QUIZ(pself->GCI_path,
					    pself->GCI_stdPath,
					    nextQuiz);
}


/***********************************************************************
 *		MSG_SAF_GAME_CARD_END_OF_QUIZ
 ***********************************************************************
 * SYNOPSIS:	    all questions asked
 * PASS:            none
 * RETURN:          none
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	gene	4/13/99		Initial Revision
 *
 ***********************************************************************/

static const TCHAR goodStr[] = "GS_GOOD.WAV";
static const TCHAR workStr[] = "GS_KEEP.WAV";

TCHAR *
UpdateScore(TCHAR *buf, word numRight, word numTotal, optr playerName)
{
    TCHAR pName[PLAYER_NAME_MAX_LENGTH+1];
    TCHAR *sampStr = &goodStr;
    word pct = 0;
    optr fmtChunk;

    if (numTotal) {
	pct = 100 * numRight / numTotal;
    }
    @call playerName::MSG_VIS_TEXT_GET_ALL_PTR(pName);
    if (pct == 100) {
	fmtChunk = @allRightStr;
    } else if (pct >= 90 || numTotal - numRight == 1) {
	fmtChunk = @some90Str;
    } else if (pct >= 85) {
	fmtChunk = @some85Str;
    } else if (pct >= 80) {
	fmtChunk = @some80Str;
    } else if (pct >= 50) {
	sampStr = &workStr;
	fmtChunk = @someWorkStr;
    } else {
	sampStr = &workStr;
	fmtChunk = @studyHardStr;
    }
    sprintf(buf, LMemDeref(fmtChunk), pName, numRight, numTotal);
    return(sampStr);
 }

@method SafGameCardClass, MSG_SAF_GAME_CARD_END_OF_QUIZ
{
    TCHAR buf[128];
    word numR1, numR2, numT1, numT2, numLeft;
    TCHAR *sampStr;
    VMBlockHandle mapBlock;
    SafariMapBlock *mapPtr;
    MemHandle mem;

    pself->SBGCI_mode = GM_IDLE;

    numR1 = QuizNumRight(pself->SBGCI_quizArray, QS_PLAYER_1);
    numR2 = QuizNumRight(pself->SBGCI_quizArray, QS_PLAYER_2);
    numT1 = QuizNumTotal(pself->SBGCI_quizArray, QS_PLAYER_1);
    numT2 = QuizNumTotal(pself->SBGCI_quizArray, QS_PLAYER_2);


    MemLock(OptrToHandle(@allRightStr));
    /*
     * add appropriate text for player 1
     */
    sampStr = UpdateScore(buf, numR1, numT1, @Player1Name);
    @call StatusText::MSG_VIS_TEXT_REPLACE_ALL_PTR(buf, 0);
    PlaySound(NULL, 0, sampStr, SP_USER_DATA, "SOUNDS");
    /*
     * if two player, add appropriate text for player 2
     */
    if (@call NumPlayers::MSG_GEN_ITEM_GROUP_GET_SELECTION() != 1) {
		@call StatusText::MSG_VIS_TEXT_APPEND_PTR("\r\r", 0);
		UpdateScore(buf, numR2, numT2, @Player2Name);
		@call StatusText::MSG_VIS_TEXT_APPEND_PTR(buf, 0);
	 }

    /*
     * find the handle for the document's map block and lock it
     */
    mapBlock = VMGetMapBlock(pself->GCI_fileHan);
    mapPtr = VMLock(pself->GCI_fileHan, mapBlock, &mem);

    /*
     * if either player needs review, ask if they want to...
     * ...if we still have questions left
     */
    numLeft = QuizNumReview(pself->SBGCI_quizArray);
    if ((numR1 < numT1 || numR2 < numT2) && numLeft > 0) {
		@call StatusText::MSG_VIS_TEXT_APPEND_PTR(LMemDeref(@reviewStr), 0);
		@call StatusReview::MSG_GEN_SET_USABLE(VUM_NOW);
	 } else {
		/*
		* answered all questions; no review
		*/
		@call StatusReview::MSG_GEN_SET_NOT_USABLE(VUM_NOW);
		if (mapPtr->SMB_nextQuiz[0]) {
			@call StatusText::MSG_VIS_TEXT_APPEND_PTR(LMemDeref(@nextStr), 0);
		}
	 }
    /*
     * see if there is a next quiz
     */
    if (mapPtr->SMB_nextQuiz[0]) {
		@call StatusNext::MSG_GEN_SET_USABLE(VUM_NOW);
    } else {
		@call StatusNext::MSG_GEN_SET_NOT_USABLE(VUM_NOW);
    }
    VMUnlock(mem);

    MemUnlock(OptrToHandle(@allRightStr));
    /*
     * bring the dialog on screen
     */
    @call StatusDB::MSG_GEN_RESET_TO_INITIAL_SIZE(VUM_NOW);
    @call StatusDB::MSG_GEN_INTERACTION_INITIATE();
}


/***********************************************************************
 *		MSG_SAF_GAME_CARD_RESET_QUIZ
 ***********************************************************************
 * SYNOPSIS:	    reset the quiz to take again
 * PASS:            none
 * RETURN:          none
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	gene	4/12/99		Initial Revision
 *
 ***********************************************************************/
@method SafGameCardClass, MSG_SAF_GAME_CARD_RESET_QUIZ
{
    /*
     * close the status DB
     */
    @call StatusDB::MSG_GEN_INTERACTION_ACTIVATE_COMMAND(IC_DISMISS);
    /*
     * reset the quiz
     */
    if (QuizReset(pself->SBGCI_quizArray)) {
	@send oself::MSG_SAF_GAME_CARD_NEXT_QUESTION();
    } else {
	/*
	 * no more review. reset, and bring up the selector DB
	 */
	@call oself::MSG_SAF_GAME_CARD_STOP_QUIZ();
    }
}



/***********************************************************************
 *		MSG_SAF_GAME_CARD_STOP_QUIZ
 ***********************************************************************
 * SYNOPSIS:	    stop taking the quiz
 * PASS:            none
 * RETURN:          none
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	gene	4/22/99		Initial Revision
 *
 ***********************************************************************/
@method SafGameCardClass, MSG_SAF_GAME_CARD_STOP_QUIZ
{
    /*
     * close the status DB
     */
    @call StatusDB::MSG_GEN_INTERACTION_ACTIVATE_COMMAND(IC_DISMISS);

    pself->SBGCI_mode = GM_IDLE;
    @call Player1Indicator::MSG_INDICATOR_SET_STATE(0);
    @call Player2Indicator::MSG_INDICATOR_SET_STATE(0);
    @call OpenDB::MSG_GEN_INTERACTION_INITIATE();
}


/***********************************************************************
 *		MSG_SAF_GAME_CARD_CLOSE_FILE
 ***********************************************************************
 * SYNOPSIS:	    close any files
 * PASS:            none
 * RETURN:          none
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	gene	4/12/99		Initial Revision
 *
 ***********************************************************************/
@method SafGameCardClass, MSG_SAF_GAME_CARD_CLOSE_FILE
{
    TimerStop(pself->SBGCI_timer, pself->SBGCI_timerID);
    pself->SBGCI_timer = 0;
    @call oself::MSG_GAME_CARD_SET_BITMAP("");
    @call oself::MSG_SAF_GAME_CARD_SET_QUIZ("", SP_DOCUMENT, "");
}


/***********************************************************************
 *		MSG_SAF_GAME_CARD_RESTART_QUIZ
 ***********************************************************************
 * SYNOPSIS:	    restart the quiz after changing the number of player
 * PASS:            none
 * RETURN:          none
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	gene	10/10/99	Initial Revision
 *
 ***********************************************************************/
@method SafGameCardClass, MSG_SAF_GAME_CARD_RESTART_QUIZ
{
    if (pself->SBGCI_quizArray[0]) {
	@call oself::MSG_SAF_GAME_CARD_INIT_QUIZ();
	QuizRestart(pself->SBGCI_quizArray);
	@send, forceQueue oself::MSG_SAF_GAME_CARD_INIT_FOR_QUESTION(TRUE);
    }
}


/***********************************************************************
 *		MSG_SAF_GAME_CARD_INIT_QUIZ
 ***********************************************************************
 * SYNOPSIS:	    (re)initialize the quiz
 * PASS:            none
 * RETURN:          none
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	gene	10/10/99	Initial Revision
 *
 ***********************************************************************/
@method SafGameCardClass, MSG_SAF_GAME_CARD_INIT_QUIZ
{
    WWFixed ptSize;

    pself->SBGCI_mode = GM_IDLE;

    @call QuestionText::MSG_VIS_TEXT_DELETE_ALL();
    @call Player1Score::MSG_SAFARI_SCORE_SET_SCORE(-1);
    @call Player2Score::MSG_SAFARI_SCORE_SET_SCORE(-1);
    @call oself::MSG_SAF_GAME_CARD_CLEAR_SELECTION();
    /*
     * turn off the indicators
     */
    @call Player1Indicator::MSG_INDICATOR_SET_STATE(0);
    @call Player2Indicator::MSG_INDICATOR_SET_STATE(0);
    /*
     * get ready for a question
     */
    pself->SBGCI_curPlayer = QS_PLAYER_1;
    /*
     * put message telling user what to start with
     */
    @call QuestionText::MSG_META_SUSPEND();
    @call QuestionText::MSG_VIS_TEXT_REPLACE_ALL_OPTR(@clickToStart, 0);
    ptSize.WWF_int = 12;
    ptSize.WWF_frac = 0;
    @call QuestionText::MSG_VIS_TEXT_SET_POINT_SIZE(ptSize,
						    TEXT_ADDRESS_PAST_END, 0);
    @call QuestionText::MSG_META_UNSUSPEND();
}
