/***************************************************************************
 *  FILE:  LASERL.GOC                                                      *
 ***************************************************************************/

/*-------------------------------------------------------------------------
 | Program:  Laser Letter
 *-------------------------------------------------------------------------
 |
 | Objective:
 |    Allows the user to learn faster writing on the keyboard.
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  03/26/99  Created
 |    RB   02/06/24  QuickTips added
 |    RB   03/12/24  Game mode and select lessons added
 |
 *-----------------------------------------------------------------------*/

/***************************************************************************
 *		Include files
 ***************************************************************************/

@include <stdapp.goh>
@include <Objects/vLTextC.goh>
@include <Ansi/string.h>
@include <Ansi/stdio.h>
@include <Ansi/ctype.h>
@include <initfile.h>
@include "laserdb.goh"

/* Enable additional UI and routines for debugging purpose */
@define DEBUG_MODE	0

/***************************************************************************
 *		Constants and defines:
 ***************************************************************************/

/* Playing fields width and height */
#define FIELD_WIDTH    602
#define FIELD_HEIGHT   (G_fieldHeight)

/* The different states (graphics) a building can be in */
typedef byte BuildingState ;
#define BUILDING_STATE_SHIELDED    0
#define BUILDING_STATE_NORMAL      1
#define BUILDING_STATE_BOOM        2
#define BUILDING_STATE_DEAD        3

/* Number of buildings on the screen */
#define NUM_BUILDINGS              10

/* Buildings Y location (from the base of the bitmap) */
#define BUILDINGS_Y                (FIELD_HEIGHT-14)

/* Point size to show the ammo count */
#define AMMO_POINT_SIZE        10

/* Position of ammo numbers on the left and right */
#define AMMO_LEFT_X            14
#define AMMO_LEFT_Y            (FIELD_HEIGHT-7-AMMO_POINT_SIZE)
#define AMMO_RIGHT_X           (7+FIELD_WIDTH-23)
#define AMMO_RIGHT_Y           AMMO_LEFT_Y

/* Positions of the tower's laser being shot from */
#define TOWER_LEFT_X           15
#define TOWER_LEFT_Y           (FIELD_HEIGHT-54)
#define TOWER_RIGHT_X          (FIELD_WIDTH-15)
#define TOWER_RIGHT_Y          TOWER_LEFT_Y

/* Maximum number of letters on the screen at one time */
#define MAX_LETTERS            20

/* The point size to use for the letters */
#define LETTERS_POINT_SIZE     G_fontSize

/* How many pixels a letter steps down on the screen */
#define LETTER_STEP_Y_RATE     (G_stepRate)

/* Where the bottom of the screen is for a letter */
#define LETTER_BOTTOM_Y        (BUILDINGS_Y-LETTERS_POINT_SIZE-1)
#define LETTER_CHECK_Y         (BUILDINGS_Y-47-LETTERS_POINT_SIZE)

/* How fast the game is played */
typedef byte GameSpeed ;
#define GAME_SPEED_VERY_SLOW   0
#define GAME_SPEED_SLOW        1
#define GAME_SPEED_NORMAL      2
#define GAME_SPEED_FAST        3
#define GAME_SPEED_VERY_FAST   4
#define GAME_SPEED_DEFAULT     100
#define GAME_SPEED_INCREASING  101

/* How quickly letters are presented on the screen */
typedef byte GameDensity ;
#define GAME_DENSITY_VERY_LOW  0
#define GAME_DENSITY_LOW       1
#define GAME_DENSITY_NORMAL    2
#define GAME_DENSITY_HIGH      3
#define GAME_DENSITY_VERY_HIGH 4

/* Amount of time between any action occuring */
#define GAME_SMALLEST_TIME_UNIT     4

/* Number of time units a BOOM stays shown */
#define UNITS_BOOM_STAYS            (40/GAME_SMALLEST_TIME_UNIT)

/* Maximum number of shots that can get buffered up before being lost */
#define MAX_SHOOT_REQUESTS          20

/* Generic return value for bad indexes into arrays */
#define INDEX_NONE                  0xFFFF

/* Maximum number of levels actually in the tables */
#define MAX_LEVELS                  10

/* Number of sounds to allow to be played simultaneously */
#define MAX_SOUND_CHANNELS          2

/* Sounds below this frequency are not played */
#define SOUND_FREQ_CUTOFF           30

#define SOUND_GAME_OVER         2
#define SOUND_LEVEL_START       3
#define SOUND_SHOOTS_MISS       7
#define SOUND_SHOOTS_HIT        6
#define SOUND_SHOOTS            5
#define SOUND_OUT_OF_AMMO       10
#define SOUND_LETTERS_ADVANCE   8
#define SOUND_CITY_DESTROYED    9
#define SOUND_SHIELD_DESTROYED  13
#define SOUND_END_OF_LEVEL      4

#define GAME_FONT_ID            (G_fontID)
#define GAME_FONT_SIZE          (G_fontSize)

/* Present Quick Tips on startup */
#define	SHOW_ON_STARTUP		1

/***************************************************************************
 *		Custom types:
 ***************************************************************************/

/* All the information of a letter.   A letter is located by its top middle */
/* like the intersection of the letter T. */
typedef struct {
    char letter ;                  /* Actual letter (upper/lower cased) */
    byte halfwidth ;               /* Half the pixel width for centering */
    sword x ;                      /* x position of center */
    sword y ;                      /* y position of top */
    sword oldX ;                   /* last x position */
    sword oldY ;                   /* last y position */
    byte color ;
    byte special ;                 /* Special flags (not used yet) */
} T_letter ;

/* Player has a request to shoot a sound in a buffer in case typing */
/* gets ahead of the animation. */
typedef struct {
    char character ;
    Boolean isLeftTower ;
} T_shootRequest ;

/* Structure of a single sound */
typedef struct {
    word length ;
    word priority ;

    #define MAX_SOUND_SAMPLES  100
    word samples[MAX_SOUND_SAMPLES] ;
} T_simplePCSound ;

typedef struct {
    word soundNum ;             /* Value of INDEX_NONE means no sound */
    word pos      ;             /* Position within sample list */
    word priority ;             /* Level priority of sound */
} T_soundState ;

typedef struct {		/* Options saved to GEOS.INI */
    byte showTips;
    byte gameMode;
    byte soundIsOn;
    byte isBeginner;
    byte currentLevel;
    byte speed;
    byte unused1;		/* for further expansion */
    byte unused2;
} LaserLettersOptions;

/***************************************************************************
 *		Global variables:
 ***************************************************************************/

/* Number of shots left for the ammo */
word G_ammoLeft = 99 ;

/* Line of current fire.  A value of 0 in G_shotLineFromX means no firing */
sword G_shotLineFromX = 0;
sword G_shotLineFromY = 0;
sword G_shotLineToX = 0;
sword G_shotLineToY = 0 ;

/* Location of current explosion sprite (based on center) */
sword G_explodeX = 0 ;
sword G_explodeY = 0 ;

/* Array of falling letters on the screen currently and count thereof. */
/* A letter with a x coordinate of 0 is not active */
T_letter G_letterArray[MAX_LETTERS] ;

/* List of the buildings.  Game is over when all dead */
BuildingState G_buildingArray[NUM_BUILDINGS] ;
word G_buildingTiming[NUM_BUILDINGS] ;

/* Letters waiting to be shown.  It is a string of text with a null */
/* terminator at the end */
char G_lettersToPresent[512] ;
word G_numPresented = 0 ;

/* Game parameters to control difficulty (other than the letters used). */
GameSpeed G_gameSpeed = GAME_SPEED_NORMAL ;
GameDensity G_gameDensity = GAME_DENSITY_NORMAL ;

/* Note if the game is actually running */
Boolean G_isRunning = FALSE ;

/* Time til next letters update (in SMALLEST_TIME units) */
word G_countTilNextUpdate ;
word G_countPerUpdate ;

/* Number of updates until another letter is added */
word G_countTilNextAddition = 2 ;

/* Timer used to keep the game going */
TimerHandle G_timer = NullHandle ;
word G_timerId ;

/* Timer used to update sound */
TimerHandle G_soundTimer = NullHandle ;
word G_soundTimerId ;

/* Number of ticks gone by before an update (letters fall) occurs */
/* The timer we use updates at about 1/60 a second for the sound, */
/* but the game play changes at a different rate */
word G_ticksGoneBy = 0 ;

/* List of buffered up shoot request should the player get going fast */
T_shootRequest G_shootRequestArray[MAX_SHOOT_REQUESTS] ;
word G_shootRequestCount = 0 ;

/* What level we are in the game */
word G_level = 1 ;

/* Control if game is paused */
/* high word: paused/running, low word: counter */
word G_pauseState;
#define gameIsPaused (G_pauseState & 0xFF00)

T_simplePCSound G_sounds[16] ;
T_soundState G_channelArray[MAX_SOUND_CHANNELS] ;

Boolean G_isColor = TRUE ;
Boolean G_isSmall = FALSE ;

/* Actual field height */
word G_fieldHeight = 170 ;

/* Font type and size used for the letters.  It changes based on */
/* screen size */
word G_fontID = DEFAULT_FONT_ID ;
word G_fontSize = 12 ;

/* Base rate the letters are falling. */
word G_stepRate = 4 ;

/* Flag used to force the end of a level */
Boolean G_forceLevelComplete = FALSE ;

Boolean G_isSoundOn = TRUE ;

word G_driveLetter = 2 ; /* Default to C: */

extern char G_titleString[MAX_TITLE_LEN];
extern VMFileHandle G_exerciseDBFile;

/***************************************************************************
 *		Tables:
 ***************************************************************************/

sword G_buildingsX[NUM_BUILDINGS] = {
     4*12,
     8*12,
    12*12,
    16*12,
    20*12,

    26*12,
    30*12,
    34*12,
    38*12,
    42*12
} ;

word G_levelSpeed[MAX_LEVELS] = {
    GAME_SPEED_VERY_SLOW,
    GAME_SPEED_VERY_SLOW,
    GAME_SPEED_SLOW,
    GAME_SPEED_SLOW,
    GAME_SPEED_NORMAL,
    GAME_SPEED_NORMAL,
    GAME_SPEED_FAST,
    GAME_SPEED_FAST,
    GAME_SPEED_VERY_FAST,
    GAME_SPEED_VERY_FAST
} ;

word G_levelDensity[MAX_LEVELS] = {
    GAME_DENSITY_NORMAL,
    GAME_DENSITY_VERY_HIGH,
    GAME_DENSITY_NORMAL,
    GAME_DENSITY_VERY_HIGH,
    GAME_DENSITY_NORMAL,
    GAME_DENSITY_VERY_HIGH,
    GAME_DENSITY_VERY_LOW,
    GAME_DENSITY_NORMAL,
    GAME_DENSITY_LOW,
    GAME_DENSITY_HIGH
} ;

word G_numPerAdd[1+GAME_DENSITY_VERY_HIGH] = {
    1,
    1,
    1,
    1,
    1
} ;

/***************************************************************************
 *		Routine Prototypes:
 ***************************************************************************/

void AddFallingLetter(void) ;
void DrawAmmo(GStateHandle gstate) ;
void DrawBuilding(GStateHandle gstate, word i) ;
void DrawCompleteScreen(GStateHandle gstate) ;
void DrawExplode(GStateHandle gstate, Boolean doDraw) ;
void DrawLetter(GStateHandle gstate, word index) ;
void DrawLetters(GStateHandle gstate) ;
void DrawShooting(GStateHandle gstate, Boolean doDraw) ;
word FindBuildingAtX(word x, word halfwidth) ;
word FindFreeLetter(void) ;
word FindLowestLetter(char letter) ;
Boolean IsLetterSpotTaken(sword x, sword y, word selfIndex) ;
Boolean IsLevelDone(void) ;
Boolean IsPlayerDead(void) ;
void LoadSounds(void) ;
void MakeLettersFall(GStateHandle gstate, Boolean doFall) ;
void RecordShootRequest(char character, Boolean isLeftTower) ;
void PlayerShoots(char character, Boolean isLeftTower) ;
void PlayFrequency(word freq, word duration) ;
void PlaySimpleSound(word soundId, word priority) ;
void PrepareNewGame(Boolean isNewBuildings) ;
void PrepareNewLetters(void) ;
Boolean ShootFirstRecorded(void) ;
word RandomNumber(void) ;
void ResetSound(void) ;
void SoundStart(void) ;
void SoundStop(void) ;
void SoundsWaitUntilDone(void) ;
void UpdateBuildingAnimations(GStateHandle gstate) ;
void UpdateSound(void) ;
void UpdatePrimaryUI(Boolean isRunning);
word FindGameSpeed(int selectedSpeed);
void DisplayPauseState(void);
Boolean PrepareGameModeLetters(void);
void EnableDisableSelectLevelTriggers(word gameMode);

@if @DEBUG_MODE
void DInfo(char *txt);
void DInfoClear(void);
void DInfo1(char *txt, word num);
void DInfo2(char *txt, word num1, word num2);
@elseif
#define DInfo(txt)
#define DInfoClear()
#define DInfo1(txt, num)
#define DInfo2(txt, num1, num2)
@endif



/***************************************************************************
 *		Class & Message Definitions
 ***************************************************************************/

    /*---------------------------------------------------------------------*/
    @class LaserLettersProcessClass, GenProcessClass ;
        @message void MSG_GAME_UPDATE() ;
        @message void MSG_GAME_START() ;
        @message void MSG_GAME_START_VIA_UI() ;
        @message void MSG_GAME_STOP() ;
        @message void MSG_GAME_UPDATE_SOUND() ;
        @message void MSG_GAME_SKIP_LEVEL() ;
        @message (GEN_BOOLEAN_GROUP_APPLY_MSG) MSG_GAME_TOGGLE_SOUND;

        @message void MSG_GAME_SELECT_LESSON_START() ;
        @message void MSG_GAME_SELECT_LESSON_DONE() ;
        @message (GEN_ITEM_GROUP_APPLY_MSG) MSG_GAME_CHANGE_MODE;
        @message (GEN_DYNAMIC_LIST_QUERY_MSG) MSG_GAME_QUERY_LESSON_MONIKER;
        @message void MSG_GAME_DIFFICULTY_START() ;
        @message void MSG_GAME_DIFFICULTY_DONE() ;
        @message void MSG_GAME_PAUSE(Boolean pause);
    @endc

    @classdecl LaserLettersProcessClass, neverSaved ;
    /*---------------------------------------------------------------------*/


/***************************************************************************
 *		UI Objects
 ***************************************************************************/



/*=========================================================================*/



@start	AppResource ;
    /*---------------------------------------------------------------------*/
    @object GenApplicationClass LaserLettersApp = {
        GI_visMoniker = list { @LaserLettersTextMoniker,
                               @AppIconVGA,
                               @AppIconHGC,
                               @AppIconCGA,
                               @AppSmallIconVGA,
                               @AppSmallIconHGC }
        GI_comp       = @LaserLettersPrimary ;
        gcnList(MANUFACTURER_ID_GEOWORKS,GAGCNLT_WINDOWS)
                      = @LaserLettersPrimary;
        ATTR_GEN_HELP_FILE = "Laser Letters Help";
    }
    /*---------------------------------------------------------------------*/
    @visMoniker LaserLettersTextMoniker =
        "Laser Letters" ;
    /*---------------------------------------------------------------------*/
@end	AppResource


@start IconResource ;
    /*---------------------------------------------------------------------*/
    @include "Art/iconvga.goh"
    @include "Art/iconhgc.goh"
    @include "Art/iconcga.goh"
    @include "Art/iconsvga.goh"
	 @include "Art/iconshgc.goh"

    /*---------------------------------------------------------------------*/
@end IconResource ;

/*=========================================================================*/



@start	Interface		/* this resource is for misc UI objects */ ; ;
    /*---------------------------------------------------------------------*/
    @object GenPrimaryClass LaserLettersPrimary  = {
		  GI_comp = @LaserLettersGameMenu, @LaserLettersOptionsMenu,
		  	    @LaserLettersLevelText,
		            @LaserLettersView, @QTipsDialogBox
@if @DEBUG_MODE
		            , @LaserLettersDebugText
@endif
			    ;
        HINT_SIZE_WINDOW_AS_DESIRED ;
        HINT_CENTER_CHILDREN_HORIZONTALLY ;
        HINT_CENTER_CHILDREN_VERTICALLY ;
/*        HINT_DISPLAY_MAXIMIZED_ON_STARTUP; */
        HINT_KEEP_ENTIRELY_ONSCREEN;

        HINT_PRIMARY_NO_FILE_MENU ;
		  /*ATTR_GEN_HELP_CONTEXT = "TOC" ;*/
	HINT_PRIMARY_NO_HELP_BUTTON;
	 }
	 /*---------------------------------------------------------------------*/
	 @object GenInteractionClass LaserLettersGameMenu = {
		  GI_visMoniker = 'G', "Game" ;
		  GI_comp =	@LaserLettersStartTrigger,
		  		@LaserLettersPauseTrigger,
		  		@LaserLettersContinueTrigger,
		  		@LaserLettersMenuSubGroup;
		  GI_attrs = @default | GA_KBD_SEARCH_PATH;
		  GII_visibility = GIV_POPUP ;
		  ATTR_GEN_INTERACTION_GROUP_TYPE = (GIGT_FILE_MENU) ;
	 }
	 /*---------------------------------------------------------------------*/
	 @object GenInteractionClass LaserLettersMenuSubGroup = {
		  GI_comp =	@LaserLettersSkip,
				@LaserLettersQTipsTrigger;
		  GI_attrs = @default | GA_KBD_SEARCH_PATH;
	 }
	 /*---------------------------------------------------------------------*/
    @object GenTriggerClass LaserLettersStartTrigger = {
        GI_visMoniker = 'S', "Start" ;
        GTI_destination = process ;
        GTI_actionMsg = MSG_GAME_START_VIA_UI ;
	GI_attrs = @default | GA_KBD_SEARCH_PATH;
	GI_kbdAccelerator = ctrl 'R';
    }
	 /*---------------------------------------------------------------------*/
	 @object GenTriggerClass LaserLettersSkip = {
		  GI_visMoniker = 'k', "Skip level" ;
		  GTI_destination = process ;
		  GTI_actionMsg = MSG_GAME_SKIP_LEVEL ;
		  GI_attrs = @default | GA_KBD_SEARCH_PATH;
		  /* GI_kbdAccelerator = ctrl 'S'; */
	 }
	 /*---------------------------------------------------------------------*/
	 @object GenTriggerClass LaserLettersQTipsTrigger = {
		  GI_visMoniker   = 'Q', "Quick Tips" ;
		  GTI_destination = @QTipsDialogBox ;
		  GTI_actionMsg   = MSG_GEN_INTERACTION_INITIATE ;
		  HINT_TRIGGER_BRINGS_UP_WINDOW;
	 }

	 /*---------------------------------------------------------------------*/
	 @object GenInteractionClass LaserLettersOptionsMenu = {
		  GI_visMoniker = 'O', "Options" ;
		  GI_comp =	@GameModeSelector, 
				@LaserLettersToggleSound,
				@LaserLettersBeginnerMode,
		  		@GameMenuGroup,
				@LLSpeedDBox;
		  GII_visibility = GIV_POPUP ;
	 }
	 /*---------------------------------------------------------------------*/
    @object GenBooleanGroupClass LaserLettersToggleSound = {
		  GI_comp = @LLToggleSoundItem;
		  GBGI_destination = process ;
		  GBGI_applyMsg = MSG_GAME_TOGGLE_SOUND ;
		  GBGI_selectedBooleans = GAME_SOUND_IS_ON;
    }
    @object GenBooleanClass LLToggleSoundItem = {
		  GI_visMoniker = list { @SoundIsOnMoniker } ;
		  GBI_identifier = GAME_SOUND_IS_ON;
    }
	 /*---------------------------------------------------------------------*/
	 @visMoniker SoundIsOnMoniker = 'O', "Sound is ON" ;
	 /*---------------------------------------------------------------------*/
	 @visMoniker SoundIsOffMoniker = 'O', "Sound is OFF" ;
	 /*---------------------------------------------------------------------*/
	 @object GenInteractionClass LLSpeedDBox = {
		  GI_visMoniker = 'e', "Speed" ;
		  GI_comp = @LLSpeedGroup;
		  GII_visibility = GIV_POPUP ;
//	     GII_type = GIT_NOTIFICATION;
//		  ATTR_GEN_HELP_CONTEXT = "SpeedDBox" ;
	 }
	 /*---------------------------------------------------------------------*/
	 @object GenItemGroupClass LLSpeedGroup = {
		  GI_comp = @LLDefaultItem, @LLIncreasingItem, 
		  				@LLVSlowItem, @LLSlowItem,
						@LLNormalItem, @LLFastItem, @LLVFastitem;
		  GIGI_selection = GAME_SPEED_DEFAULT ;
		  HINT_ORIENT_CHILDREN_VERTICALLY;
	 }

	 @object GenItemClass LLDefaultItem = {
		  GI_visMoniker = 'D',"Default" ;
		  GII_identifier = GAME_SPEED_DEFAULT ;
	 }
	 @object GenItemClass LLIncreasingItem = {
		  GI_visMoniker = 'I',"Increasing" ;
		  GII_identifier = GAME_SPEED_INCREASING ;
	 }
	 @object GenItemClass LLVSlowItem = {
		  GI_visMoniker = 'V',"VerySlow" ;
		  GII_identifier = GAME_SPEED_VERY_SLOW ;
	 }
	 @object GenItemClass LLSlowItem = {
		  GI_visMoniker = 'S',"Slow" ;
		  GII_identifier = GAME_SPEED_SLOW ;
	 }
	 @object GenItemClass LLNormalItem = {
		  GI_visMoniker = 'N',"Normal" ;
		  GII_identifier = GAME_SPEED_NORMAL ;
	 }
	 @object GenItemClass LLFastItem = {
		  GI_visMoniker = 'F',"Fast" ;
		  GII_identifier = GAME_SPEED_FAST ;
	 }
	 @object GenItemClass LLVFastitem = {
		  GI_visMoniker = 't',"Very Fast" ;
		  GII_identifier = GAME_SPEED_VERY_FAST ;
	 }

	 /*---------------------------------------------------------------------*/
	 @object GenViewClass LaserLettersView = {
        GVI_content = process ;

        GVI_vertAttrs = @default & (~ GVDA_SCROLLABLE) ;
        GVI_horizAttrs = @default & (~ GVDA_SCROLLABLE) ;
        GVI_attrs = @default |
                    GVA_NO_WIN_FRAME |
                    GVA_WINDOW_COORDINATE_MOUSE_EVENTS |
                    GVA_FOCUSABLE ;

        HINT_FIXED_SIZE = {
            SST_PIXELS | FIELD_WIDTH,
            SST_PIXELS | 170 /* FIELD_HEIGHT */
        } ;

        HINT_DEFAULT_TARGET;
        HINT_DEFAULT_FOCUS;
        HINT_EXPAND_WIDTH_TO_FIT_PARENT ;
        HINT_EXPAND_HEIGHT_TO_FIT_PARENT ;
    }
    /*---------------------------------------------------------------------*/
	 @object GenInteractionClass QTipsDialogBox = {
		  GI_visMoniker = "Laser Letters Quick Tips";
		  GI_comp = @GoalText, @InfoGroup, @LearnText,
				@ShowOnStartupGroup,
				@OKTipsButton;
		  GII_visibility = GIV_DIALOG ;
		  GII_attrs = @default | GIA_MODAL | GIA_NOT_USER_INITIATABLE;
		  HINT_CENTER_CHILDREN_HORIZONTALLY ;
		  /*ATTR_GEN_HELP_CONTEXT = "TOC";*/
	 }

	 @object GenTextClass GoalText = {
		  GI_attrs = @default | GA_READ_ONLY;
		  GI_visMoniker = " ";
		  HINT_PLACE_MONIKER_TO_LEFT;
		  GTXI_text = "The goal of the game is to protect the city!";
		  ATTR_GEN_TEXT_NEVER_MAKE_SCROLLABLE;
	 }
	 @object GenInteractionClass InfoGroup = {
		  GI_visMoniker = " ";
		  HINT_PLACE_MONIKER_TO_LEFT;
		  HINT_EXPAND_WIDTH_TO_FIT_PARENT;
		  GI_comp = @InfoText;
		  }
	 @object GenTextClass InfoText = {
		  GI_attrs = @default | GA_READ_ONLY;
		  GI_visMoniker = list { @VisMonColorShieldedCityBitmap, @VisMonMonoShieldedCityBitmap };
		  HINT_PLACE_MONIKER_TO_LEFT;
		  GTXI_text = "Falling letters destroy the buildings. Use the laser guns on both sides to destroy the letters. To do this, simply press the corresponding key on the keyboard.";
		  ATTR_GEN_TEXT_NEVER_MAKE_SCROLLABLE;
	 }


	 @object GenTextClass LearnText = {
		  GI_attrs = @default | GA_READ_ONLY;
		  GI_visMoniker = " ";
		  HINT_PLACE_MONIKER_TO_LEFT;
		  GTXI_text = "This game offers various levels of increasing difficulty. This also allows you to learn to write faster with the keyboard.";
		  ATTR_GEN_TEXT_NEVER_MAKE_SCROLLABLE;
	 }

	 @object GenBooleanGroupClass ShowOnStartupGroup = {
		  GI_comp = @ShowOnStartupBoolean;
	 }

	 @object GenBooleanClass ShowOnStartupBoolean = {
		  GI_visMoniker = 'S', "Show this Dialog box when Laser Letters starts";
		  GBI_identifier = SHOW_ON_STARTUP;
	 }

	 @object GenTriggerClass OKTipsButton = {
		  GI_visMoniker   = 'O', "OK";
		  GI_attrs = @default | GA_SIGNAL_INTERACTION_COMPLETE ;
		  HINT_SEEK_REPLY_BAR;
		  HINT_DEFAULT_DEFAULT_ACTION;
	 }
	 
@if @DEBUG_MODE
	 @object GenTextClass LaserLettersDebugText = {
		/* GTXI_attrs = @default | GTA_INIT_SCROLLING;*/
		HINT_TEXT_WASH_COLOR = {C_LIGHT_CYAN,CF_INDEX,0,0 };
		HINT_EXPAND_WIDTH_TO_FIT_PARENT;
		/*HINT_EXPAND_HEIGHT_TO_FIT_PARENT;*/
        	HINT_MINIMUM_SIZE = {
        	    SST_PIXELS | 100,
        	    SST_LINES_OF_TEXT | 7, 0
        	    } ;
		GTXI_attrs = @default | GTA_TAIL_ORIENTED ;
	} 	
@endif	

@end Interface


@start Strings, data;

@chunk char LevelText[] = "Laser Letters -- Level %u";
@localize "do not localize the %u";
@chunk char OverText[] = "Game over!";
@chunk char ComplText[] = "Level completed!\rOn to level \01";
@localize "do not localize the @1";
@chunk char LeftKeys[] = "`12345qwert~!@#$%asdfgQWERTASDFGzxcvbZXCVB" ;
@localize "the keyboard's left hand keys - MUST fit to the keyboard layout of the target language";
@chunk char RightKeys[] = "67890^&*()yuiopYUIOPhjkl;HJKL:nm,./NM<>?'\"[]{}\\|-=_+" ;
@localize "the keyboard's right hand keys - MUST fit to the keyboard layout of the target language";
@chunk char NoExerciseFile[] = "No Typing Tutor exercise file found.  Using sample letters file (3 Levels).";

@chunk char Level1Samp[] = "jjjjffffjjjjffffddddkkkkddddkkkk";
@localize "the first sample level";
@chunk char Level2Samp[] = "jjjjffffjjjjffffddddkkkkddddkkkkssssllllssssllll";
@localize "the second sample level";
@chunk char Level3Samp[] = "jjjjffffjjjjffffddddkkkkddddkkkkssssllllssssllllaaaa;;;;aaaa;;;;";
@localize "the third & last sample level - respect the keyboard layout of the target language";

@chunk char Title1Samp[] = "Demo Lesson 1 - Home Row (Step 1)";
@localize "the name of the first sample level";
@chunk char Title2Samp[] = "Demo Lesson 2 - Home Row (Step 2)";
@localize "the name of the second sample level";
@chunk char Title3Samp[] = "Demo Lesson 3 - Home Row (Step 3)";
@localize "the name of the third sample level";

/* Texts for LevelText */
@chunk char GameReadyText[] = "Ready.";    
@localize "Game State: Ready. text";
@chunk char GameModeChangedText[] = "Game mode changed, reset to first level. Ready.";
@localize "Game State text when game mode has been changed";

@chunk char GamePausedText1[] = "Paused.";    
@localize "Game State: paused text 1";
//chunk char GamePausedText2[] = "________";    
@chunk char GamePausedText2[] = "--------";    
@localize "Game State: paused text 2";

/* Game mode Level strings */
/* Title string must not extend 79 characters! */
@chunk char GameLevel1TitleString[] = "Only lower case letters are falling - that's simple.";
@localize { "max 79 charachters" 1-79 };
@chunk char Game1LowerCaseLetters[] = "abcdefghijklmnopqrstuvwxyz";
@localize "Game level 1: all lower case letters of target language keyboard layout";

@chunk char GameLevel2TitleString[] = "All letters are falling - why not?";
@localize { "max 79 charachters" 1-79 };
@chunk char Game2AllLetters[] = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
@localize "Game level 2: all lower and upper case letters of target language keyboard layout";

@chunk char GameLevel3TitleString[] = "All letters and numbers are falling - crazy.";
@localize { "max 79 charachters" 1-79 };
@chunk char Game3AllLettersAndNumbers[] = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890";
@localize "Game level 3: all letters plus numbers of target language keyboard layout";

@chunk char GameLevel4TitleString[] = "Numbers and special characters are falling - what a fun.";
@localize { "max 79 charachters" 1-79 };
@chunk char Game4NumbersAndSpecialCharcters[] = "1234567890~!@#$%^&*()-_=+{}[]|\;:'\",<.>/?";
@localize "Game level 4: numbers and special charactes of target language keyboard layout";

@chunk char GameLevel5TitleString[] = "All characters are falling - holy cow!";
@localize { "max 79 charachters" 1-79 };
@chunk char Game5AllCharcters[] = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890~!@#$%^&*()-_=+{}[]|\;:'\",<.>/?";
@localize "Game level 5: all charactes of target language keyboard layout";

@end Strings;

/***************************************************************************
 *		Constants for game extension 
 ***************************************************************************/
#define  GAME_MODE_GAME		1	/* Random letters, just for fun */
#define  GAME_MODE_LESSON	2	/* Use exercise file to select letters*/
#define  GAME_USER_IS_BEGINNER	1	/* present less letters in this case */
#define  GAME_SOUND_IS_ON	1 
#define	 GAME_LEVEL_1		1
#define	 GAME_LEVEL_2		2
#define	 GAME_LEVEL_3		3
#define	 GAME_LEVEL_4		4
#define	 GAME_LEVEL_5		5
#define	 GAME_LAST_GAME_LEVEL	GAME_LEVEL_5

/***************************************************************************
 *		UI Objects for game extension 
 ***************************************************************************/

@start	GameUi;

@object GenInteractionClass GameMenuGroup = {
    GI_comp = 	@GameLevelTrigger, @SelectLessonTrigger, 
    		@GameLevelDialog, @SelectLessonDialog;
    GI_attrs = @default | GA_KBD_SEARCH_PATH;
    /*HINT_SAME_CATEGORY_AS_PARENT; */
}

@object GenItemGroupClass GameModeSelector = {
    GI_comp = @GameModeGame, @GameModeLesson;
    GIGI_selection = GAME_MODE_GAME;
    GIGI_destination = process;
    GIGI_applyMsg = MSG_GAME_CHANGE_MODE;
}

@object GenItemClass GameModeGame = {
    GI_visMoniker = 'G', "Game Mode";
    GII_identifier = GAME_MODE_GAME;
}

@object GenItemClass GameModeLesson = {
    GI_visMoniker = 'L', "Lesson Mode";
    GII_identifier = GAME_MODE_LESSON;
}

@object GenTriggerClass LaserLettersPauseTrigger = {
    GI_visMoniker = 'P', "Pause" ;
    GI_states = @default & ~GS_ENABLED;
    GTI_destination = process ;
    GTI_actionMsg = MSG_GAME_PAUSE ;
    ATTR_GEN_TRIGGER_ACTION_DATA = TRUE;
    GI_attrs = @default | GA_KBD_SEARCH_PATH;
    GI_kbdAccelerator = ctrl 'P';
}
@object GenTriggerClass LaserLettersContinueTrigger = {
    GI_visMoniker = 'C', "Continue" ;
    GI_states = @default & ~GS_ENABLED;
    GTI_destination = process ;
    GTI_actionMsg = MSG_GAME_PAUSE ;
    ATTR_GEN_TRIGGER_ACTION_DATA = FALSE;
    GI_attrs = @default | GA_KBD_SEARCH_PATH;
    GI_kbdAccelerator = ctrl 'C';
}

    /*
     * Dialogbox to select next lesson in lesson mode
     */
@object GenTriggerClass SelectLessonTrigger = { 
    GI_visMoniker = 'S', "Select Lesson";
    GTI_destination = process;
    GTI_actionMsg = MSG_GAME_SELECT_LESSON_START;
    GI_states = @default & ~GS_ENABLED;
    HINT_TRIGGER_BRINGS_UP_WINDOW;
}
@object GenInteractionClass SelectLessonDialog = {
    GI_visMoniker = "Select a Lesson";
    GI_comp = @SelectLessionList, @SelectLessonOKTrigger, @SelectLessonCancelTrigger;
    GII_visibility = GIV_DIALOG;
/*    GII_type = GIT_NOTIFICATION; */
    GII_attrs = GIA_NOT_USER_INITIATABLE
    		| GIA_MODAL;
    HINT_INTERACTION_MAKE_RESIZABLE;
}
@object GenDynamicListClass SelectLessionList =  {
    GDLI_numItems = 0;
    GDLI_queryMsg = MSG_GAME_QUERY_LESSON_MONIKER;
    GIGI_destination = process;
    HINT_ITEM_GROUP_DISPLAY_CURRENT_SELECTION;
    HINT_EXPAND_WIDTH_TO_FIT_PARENT;
    HINT_EXPAND_HEIGHT_TO_FIT_PARENT;
    HINT_ITEM_GROUP_SCROLLABLE;
    HINT_MINIMUM_SIZE = { 40 | SST_AVG_CHAR_WIDTHS, 10 | SST_LINES_OF_TEXT, 10 };
}
@object GenTriggerClass SelectLessonCancelTrigger = {
    GI_visMoniker = 'C',"Cancel";
    ATTR_GEN_TRIGGER_INTERACTION_COMMAND = IC_DISMISS;
    HINT_SEEK_REPLY_BAR;
}
@object GenTriggerClass SelectLessonOKTrigger = {
    GI_visMoniker = 'O',"OK";
    GTI_destination = process;
    GTI_actionMsg = MSG_GAME_SELECT_LESSON_DONE;
    HINT_SEEK_REPLY_BAR;
}
   


    /*
     * Dialog box to select diffculty in game mode
     */
@object GenTriggerClass GameLevelTrigger = { 
    GI_visMoniker = 'd', "Game mode difficulty";
    GTI_destination = process;
    GTI_actionMsg = MSG_GAME_DIFFICULTY_START;
    HINT_TRIGGER_BRINGS_UP_WINDOW;
}
@object GenInteractionClass GameLevelDialog = {
    GI_visMoniker = "Game Mode Difficulty";
    GI_comp = @GameLevelSelector, @GameModeOKTrigger, @GameModeCancelTrigger;
    GII_visibility = GIV_DIALOG;
    GII_attrs = GIA_NOT_USER_INITIATABLE
    		| GIA_MODAL;
    }
@object GenItemGroupClass GameLevelSelector = {
    GI_comp = @GameLevel1, @GameLevel2, @GameLevel3, @GameLevel4, @GameLevel5;
    HINT_ORIENT_CHILDREN_VERTICALLY;
    GIGI_selection = GAME_LEVEL_1;		/* The simplest level */
}
@object GenItemClass GameLevel1 = {
    GI_visMoniker = '1', "1. Lower case lettes only";
    GII_identifier = GAME_LEVEL_1;		/* Identifiers are simply the level itself */
}
@object GenItemClass GameLevel2 = {
    GI_visMoniker = '2', "2. Lower and upper case letters";
    GII_identifier = GAME_LEVEL_2;	
}
@object GenItemClass GameLevel3 = {
    GI_visMoniker = '3', "3. All letters and numbers";
    GII_identifier = GAME_LEVEL_3;	
}
@object GenItemClass GameLevel4 = {
    GI_visMoniker = '4', "4. Numbers and special characters";
    GII_identifier = GAME_LEVEL_4;	
}
@object GenItemClass GameLevel5 = {
    GI_visMoniker = '5', "5. All characters";
    GII_identifier = GAME_LEVEL_5;	
}
@object GenTriggerClass GameModeCancelTrigger = {
    GI_visMoniker = 'C',"Cancel";
    ATTR_GEN_TRIGGER_INTERACTION_COMMAND = IC_DISMISS;
    HINT_SEEK_REPLY_BAR;
}
@object GenTriggerClass GameModeOKTrigger = {
    GI_visMoniker = 'O',"OK";
    GTI_destination = process;
    GTI_actionMsg = MSG_GAME_DIFFICULTY_DONE;
    HINT_SEEK_REPLY_BAR;
}

    /*
     * more new UI stuff
     */
@object GenTextClass LaserLettersLevelText = {
    GI_visMoniker = " Game State:";
    GTXI_text = "Ready.";
    GI_attrs = @default | GA_READ_ONLY;
    HINT_PLACE_MONIKER_TO_LEFT;
    HINT_EXPAND_WIDTH_TO_FIT_PARENT;
    ATTR_GEN_TEXT_NEVER_MAKE_SCROLLABLE;
}
@object GenBooleanGroupClass LaserLettersBeginnerMode = {
    GI_comp = @LLBeginnerItem;
    /* This group has no apply handler, it will be polled */
    GBGI_selectedBooleans = 0;
}
@object GenBooleanClass LLBeginnerItem = {
    GI_visMoniker = 'B', "Beginner - less Letters";
    GBI_identifier = GAME_USER_IS_BEGINNER;
}
    

@end	GameUi;

/*

  The structure of the ui tree is as follows:

     LaserLettersPrimary
            |
     +------+------+
     |             |
  PlayButton   LaserLettersView - - - - - - - - + (GVI_content link)
                                                |
                                     LaserLettersProcessClass handler

*/

/*=========================================================================*/

@include "Art/art.goh"



/*=========================================================================*
 *  METHODS FOR CLASS:  LaserLettersProcessClass
 *=========================================================================*/

/*-------------------------------------------------------------------------
 | Method:  LaserLettersProcessClass::MSG_GEN_PROCESS_OPEN_APPLICATION
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Starts up the app by initializing the OText object.
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  03/30/99  Created
 |    RB   02/06/24  QuickTips added	
 |
 *-----------------------------------------------------------------------*/

@method LaserLettersProcessClass, MSG_GEN_PROCESS_OPEN_APPLICATION
{
    DisplayScheme scheme ;
    AppLaunchBlock *p_launch ;
    char buffer[200] ;
    char *p_buffer = buffer ;
    Boolean initError, tips;
    LaserLettersOptions	options;
    word len;

    /* Determine where the application's directory is really located */
    p_launch = MemLock(launchBlock) ;
    buffer[0] = 'C' ;
    FileConstructFullPath(&p_buffer, sizeof(buffer)-1,
					p_launch->ALB_appRef.AIR_diskHandle,
					p_launch->ALB_appRef.AIR_fileName,
					TRUE);
    G_driveLetter = toupper(buffer[0]) - 'A' ;
    MemUnlock(launchBlock) ;

    /* Determine the type of graphics we have to use */
    @call LaserLettersApp::MSG_GEN_APPLICATION_GET_DISPLAY_SCHEME(&scheme) ;
    if (((scheme.DS_displayType&DT_DISP_SIZE)>>DT_DISP_SIZE_OFFSET) == DS_TINY)  {
        G_isSmall = TRUE ;
        G_fieldHeight = 170 ;
    } else {
        G_isSmall = FALSE ;
    }
    if (((scheme.DS_displayType&DT_DISP_CLASS)>>DT_DISP_CLASS_OFFSET) < DC_COLOR_4)  {
        G_isColor = FALSE ;
    } else {
        G_isColor = TRUE ;
    }

/* TESTING */
//G_isColor = TRUE ;
//G_isSmall = FALSE ;

    if (!G_isSmall)  {
        G_fieldHeight = 368 ;
        @call LaserLettersView::MSG_GEN_SET_FIXED_SIZE(
                  VUM_MANUAL, 0,
                  SST_PIXELS|FIELD_HEIGHT,
                  SST_PIXELS|FIELD_WIDTH) ;
        G_fontID = FID_DTC_URW_SANS ;
        G_fontSize = 24 ;
        G_stepRate = 8 ;
    }
    if (G_isColor)  {
        @call LaserLettersView::MSG_GEN_VIEW_SET_COLOR(
                  C_LIGHT_BLUE,
                  CF_INDEX,
                  0) ;
    }

    LaserExerciseDBOpen() ;
    PrepareNewGame(TRUE) ;
    @callsuper() ;
    LoadSounds() ;
    SoundStart() ;
    
    /* load and apply options */
    initError = InitFileReadDataBuffer("LaserL", "options", &options, sizeof(LaserLettersOptions), &len);
    if (initError) { tips = TRUE; }
    else 
    {
    	tips = options.showTips ? TRUE : FALSE;
	
	@send GameModeSelector::MSG_GEN_ITEM_GROUP_SET_SINGLE_SELECTION (options.gameMode, FALSE);
	EnableDisableSelectLevelTriggers(options.gameMode);
    
	@send LaserLettersToggleSound::MSG_GEN_BOOLEAN_GROUP_SET_GROUP_STATE(options.soundIsOn, 0);
	@send LaserLettersToggleSound::MSG_GEN_BOOLEAN_GROUP_SET_GROUP_MODIFIED_STATE (0xFFFF, 0);
	@send LaserLettersToggleSound::MSG_GEN_APPLY();
	
	@send LaserLettersBeginnerMode::MSG_GEN_BOOLEAN_GROUP_SET_GROUP_STATE(options.isBeginner, FALSE);
	G_level = options.currentLevel;
	@send LLSpeedGroup::MSG_GEN_ITEM_GROUP_SET_SINGLE_SELECTION(options.speed, FALSE);	
    }
    if (tips) {
	@send ShowOnStartupGroup::MSG_GEN_BOOLEAN_GROUP_SET_BOOLEAN_STATE(
		SHOW_ON_STARTUP,
		TRUE);
	@send QTipsDialogBox::MSG_GEN_INTERACTION_INITIATE();
    }
    else {
	@send ShowOnStartupGroup::MSG_GEN_BOOLEAN_GROUP_SET_BOOLEAN_STATE(
		SHOW_ON_STARTUP,
		FALSE);
    }
    		
}

/*-------------------------------------------------------------------------
 | Method:  LaserLettersProcessClass::MSG_GEN_PROCESS_CLOSE_APPLICATION
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Ends the app but first cleans up the OText object.
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  03/26/99  Created
 |    RB   02/06/24  QuickTips added	
 |
 *-----------------------------------------------------------------------*/

@method LaserLettersProcessClass, MSG_GEN_PROCESS_CLOSE_APPLICATION
{
    LaserLettersOptions	options;
    
    @call oself::MSG_GAME_STOP() ;
    SoundsWaitUntilDone();
    LaserExerciseDBClose() ;
    
    /* save options */
    InitFileDeleteEntry("LaserL", "showTips");	/* obsolete */
    
    memset(&options, 0, sizeof(options));
    options.showTips = @call ShowOnStartupGroup::MSG_GEN_BOOLEAN_GROUP_IS_BOOLEAN_SELECTED(SHOW_ON_STARTUP);
    options.gameMode = @call GameModeSelector::MSG_GEN_ITEM_GROUP_GET_SELECTION();
    options.soundIsOn = @call LaserLettersToggleSound::MSG_GEN_BOOLEAN_GROUP_GET_SELECTED_BOOLEANS();
    options.isBeginner = @call LaserLettersBeginnerMode::MSG_GEN_BOOLEAN_GROUP_GET_SELECTED_BOOLEANS();
    options.currentLevel = G_level;
    options.speed = @call LLSpeedGroup::MSG_GEN_ITEM_GROUP_GET_SELECTION();
    InitFileWriteData("LaserL", "options", &options, sizeof(LaserLettersOptions));
    InitFileCommit();

    return @callsuper() ;
}

/*-------------------------------------------------------------------------
 | Method:  LaserLettersProcessClass::MSG_GAME_START
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Start the game.
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  03/30/99  Created
 |    LES  03/31/99  Updated so it has different levels of speed and
 |                   density.
 |    jfh  07/18/02  Added speed selection
 |    RB   03/09/24  Speed selection changed	
 *-----------------------------------------------------------------------*/
@method LaserLettersProcessClass, MSG_GAME_START
{
    word level, speed ;

    level = G_level ;
    if (level > MAX_LEVELS)
        level = MAX_LEVELS ;

	 /*
    G_gameSpeed = G_levelSpeed[level-1] ;
    */

	 /* and even more messing with speed - jfh - modified: RB */
	 speed = @call LLSpeedGroup::MSG_GEN_ITEM_GROUP_GET_SELECTION();
	 if ( (speed == GAME_SPEED_DEFAULT) || (speed==GAME_SPEED_INCREASING) ) {
			//G_gameSpeed = 0+(((G_level+3)*3)/G_numExercises) ;
			// ^--- this did assign GAME_SPEED_SLOW to most of the levels R.B.
			G_gameSpeed = FindGameSpeed(speed);
			}
	 else G_gameSpeed = speed;

    if (G_gameSpeed > GAME_SPEED_VERY_FAST)
		  G_gameSpeed = GAME_SPEED_VERY_FAST ;
/*    G_gameDensity = G_levelDensity[level-1] ; */
G_gameDensity = GAME_DENSITY_HIGH ;

    @call oself::MSG_GAME_STOP() ;
    PrepareNewGame(FALSE) ;
    G_isRunning = TRUE ;
    G_ticksGoneBy = 0 ;
    G_shootRequestCount = 0 ;
    ResetSound() ;
    PlaySimpleSound(SOUND_LEVEL_START, 0xFFFF) ;
    @call LaserLettersView::MSG_GEN_VIEW_REDRAW_CONTENT();
    SoundStart() ;
    if (!G_timer)
        G_timer = TimerStart(
                  TIMER_EVENT_CONTINUAL,
                  oself,
                  1,
                  MSG_GAME_UPDATE,
                  1,
                  &G_timerId) ;

    /* Enable/Disable Pause Triggers */
    @send LaserLettersPauseTrigger::MSG_GEN_SET_ENABLED(VUM_NOW);
    @send LaserLettersContinueTrigger::MSG_GEN_SET_NOT_ENABLED(VUM_NOW);

}

/*-------------------------------------------------------------------------
 | Method:  LaserLettersProcessClass::MSG_GAME_SKIP_LEVEL
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Skip the current level.
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  05/27/99  Created
 |
 *-----------------------------------------------------------------------*/
@method LaserLettersProcessClass, MSG_GAME_SKIP_LEVEL
{
    if (!G_isRunning)
        @call oself::MSG_GAME_START() ;
    G_forceLevelComplete = TRUE ;
    G_pauseState = 0;
}

/*-------------------------------------------------------------------------
 | Method:  LaserLettersProcessClass::MSG_GAME_START_VIA_UI
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Start the game completely.
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  03/30/99  Created
 |
 *-----------------------------------------------------------------------*/
@method LaserLettersProcessClass, MSG_GAME_START_VIA_UI
{
    @call oself::MSG_GAME_STOP() ;

    /* Restart current level */
    PrepareNewGame(TRUE) ;

    @call oself::MSG_GAME_START() ;
}

/*-------------------------------------------------------------------------
 | Method:  LaserLettersProcessClass::MSG_GAME_STOP
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Stop the current game.
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  03/30/99  Created
 |
 *-----------------------------------------------------------------------*/
@method LaserLettersProcessClass, MSG_GAME_STOP
{
    if (G_isRunning)  {
        /* Kill the current timer */
        TimerStop(G_timer, G_timerId) ;
        G_timer = NullHandle ;
        G_isRunning = FALSE ;
        G_shootRequestCount = 0 ;
        
        /* Disable Pause Triggers */
        @send LaserLettersPauseTrigger::MSG_GEN_SET_NOT_ENABLED(VUM_NOW);
	@send LaserLettersContinueTrigger::MSG_GEN_SET_NOT_ENABLED(VUM_NOW);
    }
}

/*-------------------------------------------------------------------------
 | Method:  LaserLettersProcessClass::MSG_GAME_TOGGLE_SOUND
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Toggle between having sound and not having sound.
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  05/28/99  Created
 |
 *-----------------------------------------------------------------------*/
@method LaserLettersProcessClass, MSG_GAME_TOGGLE_SOUND
{
	
    if (selectedBooleans & GAME_SOUND_IS_ON)  {
        G_isSoundOn = TRUE ;
        @call LLToggleSoundItem::MSG_GEN_REPLACE_VIS_MONIKER_OPTR(
                @SoundIsOnMoniker,
                VUM_NOW) ;
    } else {
        G_isSoundOn = FALSE ;
        @call LLToggleSoundItem::MSG_GEN_REPLACE_VIS_MONIKER_OPTR(
                @SoundIsOffMoniker,
                VUM_NOW) ;
    }
}

/*-------------------------------------------------------------------------
 | Method:  LaserLettersProcessClass::MSG_GAME_UPDATE
 *-------------------------------------------------------------------------
 |
 | Description:
 |    The interval timer has gone off and the game needs to update
 |    a single step.
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  03/30/99  Created
 |
 *-----------------------------------------------------------------------*/
@method LaserLettersProcessClass, MSG_GAME_UPDATE
{
    GStateHandle gstate ;
    WindowHandle win ;
    Boolean ammoNeedsRedraw = FALSE ;
    char levelText[10] ;
    static word flip = 0 ;

    if (G_isRunning)  {
        G_ticksGoneBy++ ;
        if (G_ticksGoneBy < GAME_SMALLEST_TIME_UNIT)
            return ;
		  G_ticksGoneBy = 0 ;
		  
    if (gameIsPaused) {
    	DisplayPauseState();	
    	return;
    	}

        if (IsPlayerDead())  {
            /* Game over */
            PlaySimpleSound(SOUND_GAME_OVER, 0xFFFF) ;
            SoundsWaitUntilDone() ;
            @call oself::MSG_GAME_STOP() ;
				MemLock (OptrToHandle(@OverText));
				UserStandardDialog(
						  NULL, NULL,
						  NULL, NULL,
						  LMemDeref(@OverText),
						  ( CDT_WARNING << CDBF_DIALOG_TYPE_OFFSET ) |
						  ( GIT_NOTIFICATION << CDBF_INTERACTION_TYPE_OFFSET )) ;
				MemUnlock (OptrToHandle(@OverText));
		  } else if (IsLevelDone()) {
            PlaySimpleSound(SOUND_END_OF_LEVEL, 0xFFFF) ;
            SoundsWaitUntilDone() ;
            @call oself::MSG_GAME_STOP() ;

            /* Level completed, on to the next level */
            sprintf(levelText, "%d", G_level+1) ;
				MemLock (OptrToHandle(@ComplText));
				UserStandardDialog(
                    NULL, NULL,
                    NULL, levelText,
						  LMemDeref(@ComplText),
                    ( CDT_WARNING << CDBF_DIALOG_TYPE_OFFSET ) |
                    ( GIT_NOTIFICATION << CDBF_INTERACTION_TYPE_OFFSET )) ;
				MemUnlock (OptrToHandle(@ComplText));
				G_level++ ;
            @call oself::MSG_GAME_START() ;
        } else {
            win = @call LaserLettersView::MSG_GEN_VIEW_GET_WINDOW() ;
            if (win)  {
                gstate = GrCreateState(win) ;

                /* Erase the last shot */
                DrawShooting(gstate, FALSE) ;
                G_shotLineFromX = 0 ;
                DrawExplode(gstate, FALSE) ;
                G_explodeX = 0 ;

                /* Update the new shooting info */
                ammoNeedsRedraw = ShootFirstRecorded() ;

                G_countTilNextUpdate-- ;
                if (!G_countTilNextUpdate)  {
                    if (flip)
                        MakeLettersFall(gstate, TRUE) ;
                    else
                        MakeLettersFall(gstate, FALSE) ;
                    flip ^= 1 ;
                    G_countTilNextUpdate = G_countPerUpdate ;
                }
                UpdateBuildingAnimations(gstate) ;

                DrawShooting(gstate, TRUE) ;
                DrawExplode(gstate, TRUE) ;
                if (ammoNeedsRedraw)
                    DrawAmmo(gstate) ;

                GrDestroyState(gstate) ;
            }
        }
    }
}

/*-------------------------------------------------------------------------
 | Method:  LaserLettersProcessClass::MSG_GAME_UPDATE_SOUND
 *-------------------------------------------------------------------------
 |
 | Description:
 |    The sound timer calls this method to update the sound system.
 |
 |    The reason I use a slightly slower method is to keep the system
 |    synced up so I don't have to semaphore actions.
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  04/01/99  Created
 |
 *-----------------------------------------------------------------------*/
@method LaserLettersProcessClass, MSG_GAME_UPDATE_SOUND
{
    UpdateSound() ;
}

/*-------------------------------------------------------------------------
 | Method:  LaserLettersProcessClass::MSG_META_EXPOSED
 *-------------------------------------------------------------------------
 |
 | Description:
 |    The main view has been exposed -- redraw it completely.
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  03/30/99  Created
 |
 *-----------------------------------------------------------------------*/
@method LaserLettersProcessClass, MSG_META_EXPOSED
{
    GStateHandle gstate ;

    @callsuper() ;

    gstate = GrCreateState(win) ;
    GrBeginUpdate(gstate) ;
    DrawCompleteScreen(gstate) ;
    GrEndUpdate(gstate) ;
    GrDestroyState(gstate) ;
}

/*-------------------------------------------------------------------------
 | Method:  LaserLettersProcessClass::MSG_META_KBD_CHAR
 *-------------------------------------------------------------------------
 |
 | Description:
 |    The main view has been exposed -- redraw it completely.
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  03/30/99  Created
 |
 *-----------------------------------------------------------------------*/
@method LaserLettersProcessClass, MSG_META_KBD_CHAR
{
    if ((G_isRunning) &&
            (!(flags & CF_REPEAT_PRESS)) &&
                (!(flags & CF_RELEASE)))  {
		  MemLock (OptrToHandle(@LeftKeys));
		  if (strchr(LMemDeref(@LeftKeys), character))  {
            RecordShootRequest(character, TRUE) ;
		  } else if (strchr(LMemDeref(@RightKeys), character))  {
            RecordShootRequest(character, FALSE) ;
        } else {
            @call oself::MSG_META_FUP_KBD_CHAR(character, flags, state) ;
        }
		  MemUnlock (OptrToHandle(@LeftKeys));
	 } else {
        @call oself::MSG_META_FUP_KBD_CHAR(character, flags, state) ;
    }
}

/*=========================================================================*
 *  ROUTINES:
 *=========================================================================*/

/*-------------------------------------------------------------------------
 | Routine:  AddFallingLetter
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Present a new letter (if there is any more to present).
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  03/30/99  Created
 |
 *-----------------------------------------------------------------------*/
void AddFallingLetter(void)
{
    char letter ;
    word i ;
    GStateHandle gstate ;
    T_letter *p_letter ;

    /* Get the current letter in the list */
    letter = G_lettersToPresent[G_numPresented] ;

    /* Only add if we have a letter to add */
    if (letter)  {
        i = FindFreeLetter() ;
        if (i != INDEX_NONE)  {
            G_numPresented++ ;
            gstate = GrCreateState(0) ;
            GrSetFont(
                gstate,
                GAME_FONT_ID,
                MakeWWFixed(GAME_FONT_SIZE));
            p_letter = G_letterArray + i ;
            memset(p_letter, 0, sizeof(*p_letter)) ;
            p_letter->letter = letter ;
            p_letter->y = -GAME_FONT_SIZE ;
            p_letter->halfwidth = (GrCharWidth(gstate, letter)>>17) ;
            do {
               p_letter->color = RandomNumber() & 15 ;
            } while (p_letter->color == C_LIGHT_BLUE) ;
            do {
                p_letter->x =
                    TOWER_LEFT_X + 40 +
                    (RandomNumber() % (TOWER_RIGHT_X-TOWER_LEFT_X-80)) ;
                p_letter->x = (p_letter->x & 0xFFF8)+1 ;
            } while (IsLetterSpotTaken(p_letter->x, 0, i)) ;
            GrDestroyState(gstate) ;
        }
    }
}

/*-------------------------------------------------------------------------
 | Routine:  DrawAmmo
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Draws the numbers at the bottom left and right showing the remaining
 |    ammo for shots.  The number is the same on the left and right.
 |
 | Inputs:
 |    GStateHandle gstate         -- Handle to drawing surface
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  03/30/99  Created
 |
 *-----------------------------------------------------------------------*/
void DrawAmmo(GStateHandle gstate)
{
    char buffer[10] ;
    word i, width = 0 ;

    GrSetFont(gstate, DEFAULT_FONT_ID, MakeWWFixed(AMMO_POINT_SIZE));
    sprintf(buffer, "%d", G_ammoLeft) ;

    for (i=0; buffer[i]; i++)
       width += (((dword)GrCharWidth(gstate, buffer[i]))>>16L) ;

    width >>= 1 ;
    GrSetAreaColor(gstate, CF_INDEX, (G_isColor)?C_LIGHT_GREEN:C_WHITE, 0, 0) ;
    GrFillRect(
        gstate,
        AMMO_LEFT_X-10, AMMO_LEFT_Y,
        AMMO_LEFT_X+12, AMMO_LEFT_Y+AMMO_POINT_SIZE+3) ;
    GrFillRect(
        gstate,
        AMMO_RIGHT_X-10, AMMO_RIGHT_Y,
        AMMO_RIGHT_X+12, AMMO_RIGHT_Y+AMMO_POINT_SIZE+3) ;
    GrDrawText(gstate, 1+AMMO_LEFT_X-width, 1+AMMO_LEFT_Y, buffer, 0) ;
    GrDrawText(gstate, 1+AMMO_RIGHT_X-width, 1+AMMO_RIGHT_Y, buffer, 0) ;

}

/*-------------------------------------------------------------------------
 | Routine:  DrawBuilding
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Draws a single building type after erasing it in place.
 |    Assumed:  Art bitmap is locked!
 |
 | Inputs:
 |    GStateHandle gstate         -- Handle to drawing surface
 |    word i                      -- Index to building to draw
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  03/30/99  Created
 |
 *-----------------------------------------------------------------------*/
void DrawBuilding(GStateHandle gstate, word i)
{
    Bitmap *p_bitmap ;
    static optr buildingBitmapArray[2][4] = {
        {
        @ShieldedCityBitmapMoniker,
        @CityBitmapMoniker,
        @BoomBitmapMoniker,
        @DeadCityBitmapMoniker
        },
        {
        @ColorShieldedCityBitmapMoniker,
        @ColorCityBitmapMoniker,
        @ColorBoomBitmapMoniker,
        @ColorDeadCityBitmapMoniker
        }
    } ;
    word array = (G_isColor)?1:0 ;

    MemLock(OptrToHandle(buildingBitmapArray[array][G_buildingArray[i]])) ;
    p_bitmap = (Bitmap *)LMemDeref(buildingBitmapArray[array][G_buildingArray[i]]) ;
    GrSetAreaColor(gstate, CF_INDEX, (G_isColor)?C_LIGHT_BLUE:C_WHITE, 0, 0) ;
    GrFillRect(
        gstate,
        G_buildingsX[i], BUILDINGS_Y-p_bitmap->B_height,
        G_buildingsX[i]+p_bitmap->B_width, BUILDINGS_Y) ;
    GrDrawImage(
        gstate,
        G_buildingsX[i], BUILDINGS_Y-p_bitmap->B_height,
        IBS_1,
        p_bitmap) ;
    MemUnlock(OptrToHandle(buildingBitmapArray[array][G_buildingArray[i]])) ;
}

/*-------------------------------------------------------------------------
 | Routine:  DrawCompleteScreen
 *-------------------------------------------------------------------------
 |
 | Description:
 |    When part of the view is exposed, the whole screen is redrawn.
 |
 | Inputs:
 |    GStateHandle gstate         -- Handle to drawing surface
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  03/30/99  Created
 |
 *-----------------------------------------------------------------------*/
void DrawCompleteScreen(GStateHandle gstate)
{
    Bitmap *p_bitmap ;
    word i ;
    optr bitmap = (G_isColor)?@ColorBaseBitmapMoniker:@BaseBitmapMoniker;

    MemLock(OptrToHandle(bitmap)) ;

    p_bitmap = (Bitmap *)LMemDeref(bitmap) ;
    GrDrawImage(
        gstate,
        0, FIELD_HEIGHT-((Bitmap *)p_bitmap)->B_height,
        IBS_1,
        p_bitmap) ;
    for (i=0; i<NUM_BUILDINGS; i++)
        DrawBuilding(gstate, i) ;
    DrawAmmo(gstate) ;
    DrawShooting(gstate, TRUE) ;
    DrawExplode(gstate, TRUE) ;
    DrawLetters(gstate) ;
    MemUnlock(OptrToHandle(bitmap)) ;
}

/*-------------------------------------------------------------------------
 | Routine:  DrawExplode
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Draw the current explosion at its given location.
 |    Assumed:  Art bitmap is locked!
 |
 | Inputs:
 |    GStateHandle gstate         -- Handle to drawing surface
 |    Boolean doDraw              -- TRUE=draw, FALSE=erase
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  03/30/99  Created
 |
 *-----------------------------------------------------------------------*/
void DrawExplode(GStateHandle gstate, Boolean doDraw)
{
    Bitmap *p_bitmap ;
    optr bitmap = (G_isColor)?@ColorShotBitmapMoniker:@ShotBitmapMoniker;

    if ((G_isColor) && (!doDraw))
        bitmap = @ColorClearShotBitmapMoniker ;

    if (G_explodeX)  {
        MemLock(OptrToHandle(bitmap)) ;
        p_bitmap = (Bitmap *)LMemDeref(bitmap) ;
        GrSaveState(gstate) ;

        if (!G_isColor)  {
            if (doDraw)
                GrSetMixMode(gstate, MM_COPY);
            else
                GrSetMixMode(gstate, MM_CLEAR);
        }

        GrDrawBitmap(
            gstate,
            G_explodeX-(p_bitmap->B_width>>1),
            G_explodeY-(p_bitmap->B_height>>1),
            p_bitmap,
            NULL) ;
        GrRestoreState(gstate) ;
        MemUnlock(OptrToHandle(bitmap)) ;
    }
}

/*-------------------------------------------------------------------------
 | Routine:  DrawLetter
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Draw a single letter erasing the old placement and drawing to the
 |    new place.
 |
 | Inputs:
 |    GStateHandle gstate         -- Handle to drawing surface
 |    word index                  -- Index to index to draw
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  03/30/99  Created
 |
 *-----------------------------------------------------------------------*/
void DrawLetter(GStateHandle gstate, word index)
{
    T_letter *p_letter ;

    p_letter = G_letterArray + index ;
    GrSetTextStyle(gstate, TS_BOLD, 0) ;

    if (p_letter->oldX)  {
        GrSetTextColor(gstate, CF_INDEX, (G_isColor)?C_LIGHT_BLUE:C_WHITE, 0, 0) ;
        if (G_isColor)  {
            GrDrawText(
                gstate,
                p_letter->oldX-p_letter->halfwidth+1,
                p_letter->oldY+1,
                &p_letter->letter,
                1) ;
        }
        GrDrawText(
            gstate,
            p_letter->oldX-p_letter->halfwidth,
            p_letter->oldY,
            &p_letter->letter,
            1) ;
        p_letter->oldX = 0 ;
    }
    if (p_letter->x)  {
        if (G_isColor)  {
            GrSetTextColor(gstate, CF_INDEX, C_BLACK, 0, 0) ;
            GrDrawText(gstate,
                p_letter->x-p_letter->halfwidth+1,
                p_letter->y+1,
                &p_letter->letter,
                1) ;
        }
        GrSetTextColor(gstate, CF_INDEX, (G_isColor)?p_letter->color:C_BLACK, 0, 0) ;
        GrDrawText(gstate,
            p_letter->x-p_letter->halfwidth,
            p_letter->y,
            &p_letter->letter,
            1) ;
    }
}

/*-------------------------------------------------------------------------
 | Routine:  DrawLetters
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Draw all the letters falling on the screen.
 |
 | Inputs:
 |    GStateHandle gstate         -- Handle to drawing surface
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  03/30/99  Created
 |
 *-----------------------------------------------------------------------*/
void DrawLetters(GStateHandle gstate)
{
    word i ;
    GrSaveState(gstate) ;
    GrSetFont(gstate, GAME_FONT_ID, MakeWWFixed(GAME_FONT_SIZE));
    for (i=0; i<MAX_LETTERS; i++)  {
        if ((G_letterArray[i].x) || (G_letterArray[i].oldX))
            DrawLetter(gstate, i) ;
    }
    GrRestoreState(gstate) ;
}

/*-------------------------------------------------------------------------
 | Routine:  DrawShooting
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Draws a shot from one of the towers (basically a dotted line)
 |
 | Inputs:
 |    GStateHandle gstate         -- Handle to drawing surface
 |    Boolean doDraw              -- Draw or clear?  TRUE=draw
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  03/30/99  Created
 |
 *-----------------------------------------------------------------------*/
void DrawShooting(GStateHandle gstate, Boolean doDraw)
{
    if (G_shotLineFromX)  {
        GrSaveState(gstate) ;
        if (G_isColor)  {
            if (doDraw)  {
                GrSetLineColor(gstate, CF_INDEX, C_LIGHT_GREEN, 0, 0) ;
            } else  {
                GrSetLineColor(gstate, CF_INDEX, C_LIGHT_BLUE, 0, 0) ;
            }
        } else {
            if (doDraw)  {
                GrSetLineColor(gstate, CF_INDEX, C_BLACK, 0, 0) ;
            } else  {
                GrSetLineColor(gstate, CF_INDEX, C_WHITE, 0, 0) ;
            }
            GrSetLineStyle(gstate, LS_DOTTED, 0, NULL, 0) ;
        }

        GrDrawLine(
            gstate,
            G_shotLineFromX,
            G_shotLineFromY,
            G_shotLineToX,
            G_shotLineToY) ;
        GrRestoreState(gstate) ;
    }
}

/*-------------------------------------------------------------------------
 | Routine:  FindBuildingAtX
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Find the tallest building that the given X position (and width)
 |    touches.
 |
 | Inputs:
 |    word x                      -- center of width
 |    word halfwidth              -- half of width to check
 |
 | Outputs:
 |    word                        -- Index into G_buildingArray or
 |                                   INDEX_NONE if none found.
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  03/31/99  Created
 |
 *-----------------------------------------------------------------------*/
word FindBuildingAtX(word x, word halfwidth)
{
    word left, right ;
    word i ;
    word width ;
    word bx ;
    word best = INDEX_NONE ;
    word bestType = INDEX_NONE ;

    left = x-halfwidth ;
    right = x+halfwidth ;

    MemLock(OptrToHandle(@CityBitmapMoniker)) ;
    width = ((Bitmap *)LMemDeref(@CityBitmapMoniker))->B_width ;
    MemUnlock(OptrToHandle(@CityBitmapMoniker)) ;

    for (i=0; i<NUM_BUILDINGS; i++)  {
        bx = G_buildingsX[i] ;

        /* See if we are touching the building */
        if ((right >= bx) && (left <= (bx + width)))  {
            if (G_buildingArray[i] < bestType)  {
                best = i ;
                bestType = G_buildingArray[i] ;
            }
        }
    }

    return best ;
}

/*-------------------------------------------------------------------------
 | Routine:  FindFreeLetter
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Find a free letter slot (if any)
 |
 | Outputs:
 |    word                        -- Index in G_letterArray or INDEX_NONE
 |                                   for NONE.
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  03/30/99  Created
 |
 *-----------------------------------------------------------------------*/
word FindFreeLetter(void)
{
    word i ;

    for (i=0; i<MAX_LETTERS; i++)  {
        if ((G_letterArray[i].x == 0) && (G_letterArray[i].oldX == 0))
            break ;
    }
    if (i == MAX_LETTERS)
        i = INDEX_NONE ;

    return i ;
}

/*-------------------------------------------------------------------------
 | Routine:  FindAnyUsedLetter
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Determine if any letters are being used
 |
 | Outputs:
 |    Boolean                     -- TRUE if any are used, else FALSE
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  05/27/99  Created
 |
 *-----------------------------------------------------------------------*/
Boolean FindAnyUsedLetter(void)
{
    word i ;
    Boolean used = FALSE ;

    for (i=0; i<MAX_LETTERS; i++)  {
        if ((G_letterArray[i].x != 0) || (G_letterArray[i].oldX != 0))  {
            used = TRUE ;
            break ;
        }
    }

    return used ;
}

/*-------------------------------------------------------------------------
 | Routine:  FindLowestLetter
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Find the letter falling on the screen that is lowest or pass
 |    back a bad value if none is found.
 |
 | Outputs:
 |    word                        -- Index in G_letterArray or INDEX_NONE
 |                                   for NONE.
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  03/31/99  Created
 |
 *-----------------------------------------------------------------------*/
word FindLowestLetter(char letter)
{
    word i ;
    sword lowest = -200 ;
    word lowestIndex = INDEX_NONE ;
    T_letter *p_letter ;

    /* Go through all the falling letters (ignored the empty spots) */
    /* and determine the if it has the same letter and if it is the */
    /* lowest on the screen */
    for (i=0, p_letter=G_letterArray; i<MAX_LETTERS; i++, p_letter++)  {
        if ((p_letter->x) && (p_letter->letter == letter))  {
            if (p_letter->y > lowest)  {
                lowest = p_letter->y ;
                lowestIndex = i ;
            }
        }
    }

    return lowestIndex ;
}

/*-------------------------------------------------------------------------
 | Routine:  IsAnyBuildingBlowingUp
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Check if any building is being blown
 |
 | Outputs:
 |    Boolean                     -- TRUE if any building in boom state,
 |                                   else FALSE
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  05/27/99  Created
 |
 *-----------------------------------------------------------------------*/
Boolean IsAnyBuildingBlowingUp(void)
{
    word i ;

    for (i=0; i<NUM_BUILDINGS; i++)
        if (G_buildingArray[i] == BUILDING_STATE_BOOM)
            return TRUE ;

    return FALSE ;
}

/*-------------------------------------------------------------------------
 | Routine:  IsLetterSpotTaken
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Check if any letter is already at the given location.
 |
 | Inputs:
 |    sword x                     -- X position of letter
 |    sword y                     -- Y position of letter
 |    word selfIndex              -- Index into G_lettersArray of current
 |                                   letter being checked.
 |
 | Outputs:
 |    Boolean                     -- TRUE if letter found there, else
 |                                   FALSE ;
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  03/31/99  Created
 |
 *-----------------------------------------------------------------------*/
Boolean IsLetterSpotTaken(sword x, sword y, word selfIndex)
{
    Boolean isFound = FALSE ;
    word i ;
    T_letter *p_letter ;

    y += 1+LETTERS_POINT_SIZE ;
    for (i=0, p_letter=G_letterArray; i<MAX_LETTERS; i++, p_letter++)  {
        if (i==selfIndex)
            continue ;
        if ((p_letter->x == x) && (p_letter->y <= y))  {
            isFound = TRUE ;
            break ;
        }
    }

    return isFound ;
}

/*-------------------------------------------------------------------------
 | Routine:  IsLevelDone
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Determine if the level has been completed.
 |
 | Outputs:
 |    Boolean                     -- TRUE if level completed, else FALSE
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  03/31/99  Created
 |
 *-----------------------------------------------------------------------*/
Boolean IsLevelDone(void)
{
    if (G_forceLevelComplete == TRUE)  {
        G_forceLevelComplete = FALSE ;
        return TRUE ;
    }

    if ((!FindAnyUsedLetter()) &&
            (!IsAnyBuildingBlowingUp()) &&
                (G_lettersToPresent[G_numPresented] == '\0'))
        return TRUE ;
    return FALSE ;
}

/*-------------------------------------------------------------------------
 | Routine:  IsPlayerDead
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Determine if all the buildings have been destroyed.
 |
 | Outputs:
 |    Boolean                     -- TRUE if player is dead, else FALSE
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  03/31/99  Created
 |
 *-----------------------------------------------------------------------*/
Boolean IsPlayerDead(void)
{
    word i ;

    /* All buildings should be up and/or shielded */
    for (i=0; i<NUM_BUILDINGS; i++)
        if (G_buildingArray[i] != BUILDING_STATE_DEAD)
            return FALSE ;

    return TRUE ;
}

/*-------------------------------------------------------------------------
 | Routine:  LoadSounds
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Load the sounds to be played later.
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  04/01/99  Created
 |
 *-----------------------------------------------------------------------*/
void LoadSounds(void)
{
    FileHandle file ;

    ResetSound() ;
    memset(G_sounds, 0, sizeof(G_sounds)) ;

    FilePushDir() ;
    FileSetCurrentPath(SP_PUBLIC_DATA, "laserl");
    file = FileOpen("sounds.dat", FILE_DENY_NONE|FILE_ACCESS_R) ;
    if (file)  {
        FileRead(file, &G_sounds, sizeof(G_sounds), FALSE) ;
        FileClose(file, FALSE) ;
    }
    FilePopDir() ;
}

/*-------------------------------------------------------------------------
 | Routine:  MakeLettersFall
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Update the placement of the letters by making them step down and
 |    take care of any interactions.
 |
 | Inputs:
 |    GStateHandle gstate         -- Handle to drawing surface
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  03/30/99  Created
 |
 *-----------------------------------------------------------------------*/
void MakeLettersFall(GStateHandle gstate, Boolean doFall)
{
    word i ;
    T_letter *p_letter ;
    word building ;
    word num ;
    Boolean anyLettersFall = FALSE ;
    // Use of G_level has been changed. R.B.
    int lev = (G_level+2)/3;

    p_letter = G_letterArray ;
    for (i=0; i<MAX_LETTERS; i++, p_letter++)  {
        if (p_letter->x)  {
            p_letter->oldX = p_letter->x ;
            p_letter->oldY = p_letter->y ;
            if (doFall)
                p_letter->y += 2*(LETTER_STEP_Y_RATE+(lev/5)) ;
            anyLettersFall = TRUE ;
            if (((sword)p_letter->y) >= ((sword)LETTER_BOTTOM_Y))  {
                /* GONE */
                p_letter->x = 0 ;
            } else if (((sword)p_letter->y) >= ((sword)(LETTER_CHECK_Y)))  {
                /* Which building are we touching? */
                building = FindBuildingAtX(
                               p_letter->x,
                               1+p_letter->halfwidth) ;
                if (building != INDEX_NONE)  {
                    switch(G_buildingArray[building])  {
                        case BUILDING_STATE_SHIELDED:
                            G_buildingArray[building] = BUILDING_STATE_NORMAL ;
                            DrawBuilding(gstate, building) ;
                            p_letter->x = 0 ;
                            PlaySimpleSound(SOUND_SHIELD_DESTROYED, 90) ;
                            break ;
                        case BUILDING_STATE_NORMAL:
                            G_buildingArray[building] = BUILDING_STATE_BOOM ;
                            G_buildingTiming[building] = UNITS_BOOM_STAYS ;
                            DrawBuilding(gstate, building) ;
                            p_letter->x = 0 ;
                            PlaySimpleSound(SOUND_CITY_DESTROYED, 100) ;
                            break ;
                        case BUILDING_STATE_BOOM:
                            p_letter->x = 0 ;
                            break ;
                        case BUILDING_STATE_DEAD:
                            if (p_letter->y >= LETTER_CHECK_Y+24)  {
                                p_letter->x = 0 ;
                            }
                            break ;
                    }
                }
            }
        }
    }
    if ((anyLettersFall) && (doFall))
        PlaySimpleSound(SOUND_LETTERS_ADVANCE, 5) ;

    /* Is it time to add a new letter */
    G_countTilNextAddition-- ;
    if (G_countTilNextAddition == 0)  {
        /* Add a new letter to the screen */
        num = 1+RandomNumber()%(G_numPerAdd[G_gameDensity]) ;
        for (i=0; i<num; i++)
            AddFallingLetter() ;

        /* Figure out when the next one should be added */
        G_countTilNextAddition = 1+(RandomNumber()&1) +
                                     (GAME_DENSITY_VERY_HIGH-G_gameDensity) ;
    }

    DrawLetters(gstate) ;
}

/*-------------------------------------------------------------------------
 | Routine:  RecordShootRequest
 *-------------------------------------------------------------------------
 |
 | Description:
 |    A shooting action has been requested.  First record it for later.
 |
 | Inputs:
 |    char character              -- character being shot
 |    Boolean isLeftTower         -- TRUE for left tower, else FALSE for
 |                                   right tower.
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  03/31/99  Created
 |
 *-----------------------------------------------------------------------*/
void RecordShootRequest(char character, Boolean isLeftTower)
{

    /* Only add if not paused */
    if (gameIsPaused) return;
    
    /* Only add if we have room */
    if (G_shootRequestCount < MAX_SHOOT_REQUESTS)  {
        /* Append to the end of the list */
        G_shootRequestArray[G_shootRequestCount].character = character ;
        G_shootRequestArray[G_shootRequestCount].isLeftTower = isLeftTower ;
        G_shootRequestCount++ ;
    }
}

/*-------------------------------------------------------------------------
 | Routine:  PlayerShoots
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Player has hit a key to shoot from a tower.
 |
 | Inputs:
 |    char character              -- character being shot
 |    Boolean isLeftTower         -- TRUE for left tower, else FALSE for
 |                                   right tower.
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  03/31/99  Created
 |
 *-----------------------------------------------------------------------*/
void PlayerShoots(char character, Boolean isLeftTower)
{
    word index ;

    /* Only shoot if we have ammo */
    if (G_ammoLeft)  {
        PlaySimpleSound(SOUND_SHOOTS, 10) ;
        G_ammoLeft-- ;
        if (isLeftTower)  {
            G_shotLineFromX = TOWER_LEFT_X ;
            G_shotLineFromY = TOWER_LEFT_Y ;
        } else {
            G_shotLineFromX = TOWER_RIGHT_X ;
            G_shotLineFromY = TOWER_RIGHT_Y ;
        }

        index = FindLowestLetter(character) ;
        if (index == INDEX_NONE)  {
            /* Missed.  Shoot randomly at the top of the screen */
            G_shotLineToX = 40+(RandomNumber()%(FIELD_WIDTH-80)) ;
            G_shotLineToY = 1 ;
            PlaySimpleSound(SOUND_SHOOTS_MISS, 20) ;
        } else {
            /* Hit.  Center the explosion there. */
            G_shotLineToX =
                G_explodeX =
                    G_letterArray[index].x ;
            G_shotLineToY =
                G_explodeY =
                    G_letterArray[index].y + (LETTERS_POINT_SIZE>>1) ;

            /* Remove the letter */
            G_letterArray[index].oldX = G_letterArray[index].x ;
            G_letterArray[index].oldY = G_letterArray[index].y ;
            G_letterArray[index].x = 0 ;
            PlaySimpleSound(SOUND_SHOOTS_HIT, 20) ;
        }
    } else {
        PlaySimpleSound(SOUND_OUT_OF_AMMO, 50) ;
    }
}

/*-------------------------------------------------------------------------
 | Routine:  PlayFrequency
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Play a frequency on the PC Speaker (with logical checks)
 |
 | Inputs:
 |    word freq                   -- Frequency to use (per GEOS sound.h)
 |    word duration               -- Length of time in 1/60ths of a second
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  04/01/99  Created
 |
 *-----------------------------------------------------------------------*/
void PlayFrequency(word freq, word duration)
{
    static word lastFreq = 0xFFFF ;

    if (freq == lastFreq)
        if (RandomNumber()&1)
            freq-- ;
        else
            freq++ ;
    lastFreq = freq ;
    if (G_isSoundOn)
        UserStandardSound(SST_CUSTOM_NOTE, freq, duration) ;
}

/*-------------------------------------------------------------------------
 | Routine:  PlaySimpleSound
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Plays a banked sound out the PC speaker.  Actually just sets up
 |    the sound for playing.
 |
 | Inputs:
 |    word soundId                -- Index into G_sounds
 |    word priority               -- 0-65535 priority level if the given
 |                                   sound doesn't have a priority already.
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  04/01/99  Created
 |
 *-----------------------------------------------------------------------*/
void PlaySimpleSound(word soundId, word priority)
{
    T_simplePCSound *p_sound ;
    word i ;
    word best = INDEX_NONE ;
    word bestPriority = 0xFFFF ;
    T_soundState *p_channel ;
    
    /* Do not setup sound if sound is not enabeld */
    if (!G_isSoundOn) return;

    p_sound = G_sounds + soundId ;
    if (p_sound->priority)
        priority = p_sound->priority ;

    /* Find the best free channel or one with a lower priority */
    for (i=0, p_channel=G_channelArray;
         i<MAX_SOUND_CHANNELS;
         i++, p_channel++)  {
        /* Take emty channels immediately */
        if (p_channel->soundNum == INDEX_NONE)  {
            best = i ;
            bestPriority = 0xFFFF ;
            break ;
        }

        /* Otherwise, look for the lowest priority sound */
        if (p_channel->priority <= bestPriority)  {
            best = i ;
            bestPriority = p_channel->priority ;
        }
    }

    /* Only process the sound if we found a channel */
    /* and the lowest priority sound is lower or equal to what we */
    /* want to play */
    if ((best != INDEX_NONE) &&
        ((bestPriority <= priority) || (bestPriority==0xFFFF)))  {
        p_channel = G_channelArray + best ;
        p_channel->soundNum = soundId ;
        p_channel->pos = 0 ;
        p_channel->priority = priority ;
    }
}

/*-------------------------------------------------------------------------
 | Routine:  PrepareNewGame
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Setup a new game's data.
 |
 | Inputs:
 |    Boolean isNewBuildings      -- TRUE if all new buildings, else FALSE
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  03/30/99  Created
 |
 *-----------------------------------------------------------------------*/
void PrepareNewGame(Boolean isNewBuildings)
{
    G_ammoLeft = 99 ;
    memset(G_letterArray, 0, sizeof(G_letterArray)) ;
    if (isNewBuildings)
        memset(G_buildingArray, BUILDING_STATE_SHIELDED, sizeof(G_buildingArray)) ;
    memset(G_buildingTiming, 0, sizeof(G_buildingTiming)) ;
    PrepareNewLetters() ;
    UpdatePrimaryUI(!isNewBuildings);

    /* Set up the timing */
    G_countPerUpdate = (1+GAME_SPEED_VERY_FAST - G_gameSpeed) *
                           (4/GAME_SMALLEST_TIME_UNIT) ;
/*    G_countPerUpdate *= 2 ; */
    G_countTilNextUpdate = (90/GAME_SMALLEST_TIME_UNIT) ;
    G_countTilNextAddition = 1 ;
    G_pauseState = 0;
}

/*-------------------------------------------------------------------------
 | Routine:  PrepareNewLetters
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Setup the letters to present as the game progresses (for the current
 |    level).
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  03/30/99  Created
 |
 *-----------------------------------------------------------------------*/
void PrepareNewLetters(void)
{
    word num ;
    char c ;
    word i ;
    word n ;
    int exercise ;
    Boolean isRandom = TRUE ;
    word len ;
    // Use of G_level has been changed. R.B.
    int lev = (G_level+2)/3;

	/*
	 * In game mode use another routine to prepare letters
	 */
    if ( GAME_MODE_GAME == @call GameModeSelector::MSG_GEN_ITEM_GROUP_GET_SELECTION() )
    {
    	PrepareGameModeLetters();
    	return;
    }
    
    if (lev > MAX_LEVELS) lev = MAX_LEVELS;
    num = 60 + (2*(lev-1)) ;	/* up to 78 letters to present */
    if ( GAME_USER_IS_BEGINNER & @call LaserLettersBeginnerMode::MSG_GEN_BOOLEAN_GROUP_GET_SELECTED_BOOLEANS() ) 
    	num = (6*num)/10;
    if (num > 95) num = 95;

    	/*
    	 * Select exercise based on the G_level
    	 * After all exercises are completed, select only text-based exercises.
    	 */
    exercise = (G_level-1) ;	
    while (exercise >= G_numExercises) {
    	exercise -= ( G_numExercises - (NUM_SPECIAL_GROUPS*NUM_EXERCISES));
    	if (exercise < 0) {
    		/* This happens in demo lesson mode or if the excercise.vm file is invald */
    		exercise = G_numExercises-1;
    		break;
    		}
    	}
    RetrieveExercise(exercise % G_numExercises) ;
    len = strlen(G_exerciseString) ;
    for (n=0; n<num; )  {
        if (isRandom)  {
            /* Pick a random location */
            i = RandomNumber() % len ;

            /* Go to the start of the word */
            /* Go back to the previous space (or start) */
            while (!isspace(G_exerciseString[i]) && (i))
                i-- ;

            /* Go forward past the space */
            if (isspace(G_exerciseString[i]))
                i++ ;

            isRandom = FALSE ;
        }

        /* Check to see if we are not using text letters. */
        c = G_exerciseString[i] ;
        if ((!c) || (isspace(c)) || (iscntrl(c)))  {
            isRandom = TRUE ;
            continue ;
        }
        G_lettersToPresent[n++] = c ;
        i++ ;
    }
    G_lettersToPresent[n] = '\0' ;
    G_numPresented = 0 ;
/*
    word num ;
    word level ;
    char *p_high ;
    char *p_low ;
    word highCount ;
    word lowCount ;
    word i ;
    word h, l ;
    word p = RandomNumber() ;

    level = G_level-1 ;
    if (level >= 19)
        level = 18 ;

    num = 60+(2*level) ;
    p_high = G_levelKeys[level][0] ;
    p_low = G_levelKeys[level][1] ;
    highCount = strlen(p_high) ;
    lowCount = strlen(p_low) ;

    h = 0 ;
    l = 0 ;
    for (i=0; i<num; i++)  {
        p += RandomNumber() ;
        if ((p>>8)&3)  {
            h += RandomNumber()%highCount ;
            while (h >= highCount)
                h -= highCount ;
            G_lettersToPresent[i] = p_high[h] ;
        } else {
            l += RandomNumber()%lowCount ;
            while (l >= lowCount)
                l -= lowCount ;
            G_lettersToPresent[i] = p_low[l] ;
        }
    }
    G_lettersToPresent[i] = '\0' ;
//    strcpy(G_lettersToPresent, "PjkjkjkdfdfdfjdjfdkfjdkfjdkfjdkkdkfjT") ;
*/
}

/*-------------------------------------------------------------------------
 | Routine:  RandomNumber
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Generate a RandomNumber of value 0 to 65535.
 |
 | Outputs:
 |    word                        -- 0 to 65535 number
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  03/31/99  Created
 |
 *-----------------------------------------------------------------------*/
word RandomNumber(void)
{
    static word rand1 = 0xf32d ;
    static word rand2 = 0x0103 ;
    static word rand3 = 0x4326 ;
    static word rand4 = 0x4878 ;
    word old ;

    old = rand1 ;
    rand1 = rand2 ;
    rand2 = rand3 ;
    rand3 = rand4 ;
    rand4 ^= old^rand1^rand2^rand3 ;
    rand3 += rand1+rand2+rand4 ;
    rand4 >>= 1 ;
    rand4 |= (old&0x8000) ;
    rand4 += TimerGetCount() ;
    rand2 ^= 0xFFFF ;
    return old ;
}

/*-------------------------------------------------------------------------
 | Routine:  ResetSound
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Reset the sound effects
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  04/01/99  Created
 |
 *-----------------------------------------------------------------------*/
void ResetSound(void)
{
    word i ;

    for (i=0; i<MAX_SOUND_CHANNELS; i++)  {
        G_channelArray[i].soundNum = INDEX_NONE ;
        G_channelArray[i].pos = 0 ;
        G_channelArray[i].priority = 0 ;
    }
}

/*-------------------------------------------------------------------------
 | Routine:  ShootFirstRecorded
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Shoot if there are any recorded events.
 |
 | Outputs:
 |    Boolean                     -- TRUE if shot occured.
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  03/31/99  Created
 |
 *-----------------------------------------------------------------------*/
Boolean ShootFirstRecorded(void)
{
    Boolean didShot = FALSE ;

    if (G_shootRequestCount)  {
        didShot = TRUE ;
        PlayerShoots(
            G_shootRequestArray[0].character,
            G_shootRequestArray[0].isLeftTower) ;
        G_shootRequestCount-- ;
        if (G_shootRequestCount)  {
            memcpy(
                G_shootRequestArray,
                G_shootRequestArray+1,
                sizeof(G_shootRequestArray[0])*G_shootRequestCount) ;
        }
    }

    return didShot ;
}

/*-------------------------------------------------------------------------
 | Routine:  SoundStart
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Start the sound system (mainly timer)
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  04/01/99  Created
 |
 *-----------------------------------------------------------------------*/
void SoundStart(void)
{
    if (!G_soundTimer)
        G_soundTimer = TimerStart(
                       TIMER_EVENT_CONTINUAL,
                       ConstructOptr(GeodeGetCodeProcessHandle(), 0),
                       1,
                       MSG_GAME_UPDATE_SOUND,
                       1,
                       &G_timerId) ;
}

/*-------------------------------------------------------------------------
 | Routine:  SoundStop
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Stops the sound system (mainly timer)
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  04/01/99  Created
 |
 *-----------------------------------------------------------------------*/
void SoundStop(void)
{
    TimerStop(G_soundTimer, G_soundTimerId) ;
    G_soundTimer = NullHandle ;
}

/*-------------------------------------------------------------------------
 | Routine:  SoundsWaitUntilDone
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Updates the sound effects until we are done.  Also stops the sound
 |    system.
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  04/01/99  Created
 |
 *-----------------------------------------------------------------------*/
void SoundsWaitUntilDone(void)
{
    word i ;
    Boolean isSoundPlaying ;

    SoundStop() ;

    do {
        isSoundPlaying = FALSE ;
        for (i=0; i<MAX_SOUND_CHANNELS; i++)  {
            if (G_channelArray[i].soundNum != INDEX_NONE)  {
                isSoundPlaying = TRUE ;
                break ;
            }
        }

        /* Stop if finally no sound is playing */
        if (!isSoundPlaying)
            break ;
        UpdateSound() ;
        TimerSleep(1) ;
    } while (1) ;
}

/*-------------------------------------------------------------------------
 | Routine:  UpdateBuildingAnimations
 *-------------------------------------------------------------------------
 |
 | Description:
 |    See if a building needs to be updated on its animation.
 |
 | Inputs:
 |    GStateHandle gstate         -- Drawing handle
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  03/31/99  Created
 |
 *-----------------------------------------------------------------------*/
void UpdateBuildingAnimations(GStateHandle gstate)
{
    word i ;

    for (i=0; i<NUM_BUILDINGS; i++)  {
        if (G_buildingTiming[i])   {
            if (--G_buildingTiming[i])
                continue ;

            switch (G_buildingArray[i])  {
                case BUILDING_STATE_BOOM:
                    G_buildingArray[i] = BUILDING_STATE_DEAD ;
                    DrawBuilding(gstate, i) ;
                    break ;
                default:
                    break ;
            }
        }
    }
}

/*-------------------------------------------------------------------------
 | Routine:  UpdateSound
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Update the sound effects using the current settings.
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  04/01/99  Created
 |
 *-----------------------------------------------------------------------*/
void UpdateSound(void)
{
    static word channel = 0 ;
    T_soundState *p_state ;
    T_simplePCSound *p_sound ;
    word sample ;

    p_state = G_channelArray + channel ;
    if (p_state->soundNum != INDEX_NONE)  {
        p_sound = G_sounds + p_state->soundNum ;
        sample = p_sound->samples[p_state->pos] ;
        if (sample > SOUND_FREQ_CUTOFF)  {
            /* Play that frequency */
            PlayFrequency(sample, 1) ;
            p_state->pos++ ;
        } else if (sample == 0)  {
            /* Sound is done.  Stop here */
            p_state->soundNum = INDEX_NONE ;
            p_state->priority = 0 ;
            p_state->pos = 0 ;
        } else {
            p_state->pos++ ;
        }
    }

    /* Go to the next channel next time */
    channel = ((channel+1)%MAX_SOUND_CHANNELS) ;
}

/*#########################################################################
 | 
 |
 |    ++++ Laser Letters game extension ++++
 |
 |    Most of the stuff to add game mode and allow to select the exercise level
 |
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    RB   03/06/24  Initial revision	
 |
 *#######################################################################*/

/* Some routines for debugging */
@if @DEBUG_MODE
void DInfo(char *txt) {
    @call LaserLettersDebugText::MSG_VIS_TEXT_APPEND_PTR(txt, 0);
}
void DInfo1(char *txt, word num) {
char buf[40];
    sprintf(buf, txt, num);
    @call LaserLettersDebugText::MSG_VIS_TEXT_APPEND_PTR(buf, 0);
}
void DInfo2(char *txt, word num1, word num2) {
char buf[40];
    sprintf(buf, txt, num1, num2);
    @call LaserLettersDebugText::MSG_VIS_TEXT_APPEND_PTR(buf, 0);
}
void DInfoClear(void) {
    @call LaserLettersDebugText::MSG_VIS_TEXT_DELETE_ALL();
}
@endif

/***************************************************************************
 *  Methods and Routines
 ***************************************************************************/

/*-------------------------------------------------------------------------
 | Method:  LaserLettersProcessClass::MSG_GAME_CHANGE_MODE
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Update menu UI
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    RB   03/06/24  Created
 |
 *-----------------------------------------------------------------------*/
@method LaserLettersProcessClass, MSG_GAME_CHANGE_MODE {

   EnableDisableSelectLevelTriggers(selection);

 	/*
 	 * Stop current game and reset to first level
 	 */
   @call process::MSG_GAME_STOP();
   G_level = 1;

	/*
	 * clean up game screen 
	 */
   PrepareNewGame(TRUE);
   @call LaserLettersView::MSG_GEN_VIEW_REDRAW_CONTENT();
   
   UpdatePrimaryUI(FALSE);   
   @call LaserLettersLevelText::MSG_VIS_TEXT_REPLACE_ALL_OPTR(@GameModeChangedText, 0);
   
}

/*-------------------------------------------------------------------------
 | EnableDisableSelectLevelTriggers
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Set triggers enabled or disableded, depending on game mode
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    RB   03/19/24  Created
 *-----------------------------------------------------------------------*/
void EnableDisableSelectLevelTriggers(word gameMode) {

   if (gameMode == GAME_MODE_GAME)
   {
   	@send SelectLessonTrigger::MSG_GEN_SET_NOT_ENABLED(VUM_NOW);
   	@send GameLevelTrigger::MSG_GEN_SET_ENABLED(VUM_NOW);
   }
   else
   {
   	@send SelectLessonTrigger::MSG_GEN_SET_ENABLED(VUM_NOW);
   	@send GameLevelTrigger::MSG_GEN_SET_NOT_ENABLED(VUM_NOW);
   }
   
}

/*-------------------------------------------------------------------------
 | Method:  LaserLettersProcessClass::MSG_GAME_SELECT_LESSON_START
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Put up the select lesson dialog box
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    RB   03/06/24  Created
 |
 *-----------------------------------------------------------------------*/
@method LaserLettersProcessClass, MSG_GAME_SELECT_LESSON_START {

    @send SelectLessionList::MSG_GEN_DYNAMIC_LIST_INITIALIZE(G_numExercises);
    @send SelectLessionList::MSG_GEN_ITEM_GROUP_SET_SINGLE_SELECTION(G_level-1, FALSE);

    @send SelectLessonDialog::MSG_GEN_INTERACTION_INITIATE();
    
}

/*-------------------------------------------------------------------------
 | Method:  LaserLettersProcessClass::MSG_GAME_SELECT_LESSON_DONE
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Select lesson dialog box has been finished
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    RB   03/06/24  Created
 |
 *-----------------------------------------------------------------------*/
@method LaserLettersProcessClass, MSG_GAME_SELECT_LESSON_DONE {
int selectedLevel;

    selectedLevel = @call SelectLessionList::MSG_GEN_ITEM_GROUP_GET_SELECTION();
    selectedLevel++;
    
    if (selectedLevel != G_level )
    {
    	/* New Level selected */
    	@call process::MSG_GAME_STOP();
    	G_level = selectedLevel;
	/*
	 * clean up game screen 
	 */
   	PrepareNewGame(TRUE);
   	@call LaserLettersView::MSG_GEN_VIEW_REDRAW_CONTENT();
    	UpdatePrimaryUI(FALSE);
    } 
    
    @send SelectLessonDialog::MSG_GEN_GUP_INTERACTION_COMMAND(IC_DISMISS);
    
}

/*-------------------------------------------------------------------------
 | Method:  LaserLettersProcessClass::MSG_GAME_QUERY_LESSON_MONIKER
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Create Moniker (lesson name) for select lesson list
 |
 |    Parameter:	GEN_DYNAMIC_LIST_QUERY_MSG (optr list, word item)
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    RB   03/06/24  Created
 |
 *-----------------------------------------------------------------------*/
@method LaserLettersProcessClass, MSG_GAME_QUERY_LESSON_MONIKER {
char less_name[MAX_TITLE_LEN + 5];	// be save
MemHandle memMap ;
VMBlockHandle mapBlock ;
T_exerciseDatabaseMap *p_map ; 
MemHandle mem ;
T_exerciseRecord *p_exercise ;

    if (G_exerciseDBFile == NullHandle)	    
    {
	/* This is bad and should not happen */
	sprintf(less_name, "Invalid lesson %u", item+1);
	@call list::MSG_GEN_DYNAMIC_LIST_REPLACE_ITEM_TEXT(item, less_name);
	return;
    }
    
    
    /* Lock the map block of the exercise file and check if the item is valid */
    mapBlock = VMGetMapBlock(G_exerciseDBFile) ;
    p_map = VMLock(G_exerciseDBFile, mapBlock, &memMap) ;

    if (p_map->MS_exercises[item] == NullHandle)
    {
        sprintf(less_name, "Lesson %u is empty.", item+1);
    }
    else
    {
    	/* Ok, let's get it */
    	p_exercise = VMLock(G_exerciseDBFile, p_map->MS_exercises[item], &mem);
	strcpy(less_name, p_exercise->ES_title);
	VMUnlock(mem);    
    }
    
    VMUnlock(memMap);    
    @call list::MSG_GEN_DYNAMIC_LIST_REPLACE_ITEM_TEXT(item, less_name);

}
   /*-------------------------------------------------------------------------
 | Method:  LaserLettersProcessClass::MSG_GAME_DIFFICULTY_START
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Put up the select lesson dialog box
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    RB   03/06/24  Created
 |
 *-----------------------------------------------------------------------*/
@method LaserLettersProcessClass, MSG_GAME_DIFFICULTY_START {

    @send GameLevelSelector::MSG_GEN_ITEM_GROUP_SET_SINGLE_SELECTION(G_level, FALSE);
    @send GameLevelDialog::MSG_GEN_INTERACTION_INITIATE();
    
}

/*-------------------------------------------------------------------------
 | Method:  LaserLettersProcessClass::MSG_GAME_DIFFICULTY_DONE
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Select lesson dialog box has been finished
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    RB   03/06/24  Created
 |
 *-----------------------------------------------------------------------*/
@method LaserLettersProcessClass, MSG_GAME_DIFFICULTY_DONE {
int selectedLevel;

    selectedLevel = @call GameLevelSelector::MSG_GEN_ITEM_GROUP_GET_SELECTION();
    
    if (selectedLevel != G_level )
    {
    	/* New Level selected */
    	@call process::MSG_GAME_STOP();
    	G_level = selectedLevel;
    	
	/*
	 * clean up game screen 
	 */
   	PrepareNewGame(TRUE);
   	@call LaserLettersView::MSG_GEN_VIEW_REDRAW_CONTENT();
    	UpdatePrimaryUI(FALSE);
    } 
    
    @send GameLevelDialog::MSG_GEN_GUP_INTERACTION_COMMAND(IC_DISMISS);
    
}

 
/*-------------------------------------------------------------------------
 | Method:  LaserLettersProcessClass::MSG_GAME_PAUSE
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Toggle pause mode
 |
 |    Parameter:	void(Boolean pause)
 |				TRUE: pause game	
 |				FASLE: continue game
 |
 |    G_pauseState: 	high word: paused/running, low word: counter
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    RB   03/10/24  Created
 |
 *-----------------------------------------------------------------------*/
@method LaserLettersProcessClass, MSG_GAME_PAUSE {

    	/* Do nothing if game is not running */	
    if (!G_isRunning) return;

    if (pause) { 
    	G_pauseState = 0xFF00; 
        @send LaserLettersPauseTrigger::MSG_GEN_SET_NOT_ENABLED(VUM_NOW);
	@send LaserLettersContinueTrigger::MSG_GEN_SET_ENABLED(VUM_NOW);
    	
    }
    else { 
    	G_pauseState = 0; 
        @send LaserLettersPauseTrigger::MSG_GEN_SET_ENABLED(VUM_NOW);
	@send LaserLettersContinueTrigger::MSG_GEN_SET_NOT_ENABLED(VUM_NOW);
    	UpdatePrimaryUI(TRUE);
    }

}

/*-------------------------------------------------------------------------
 | Routine:  UpdatePrimaryUI
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Update the the UI for running/stopped Game
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    RB   03/06/24  Created
 |
 *-----------------------------------------------------------------------*/
void UpdatePrimaryUI(Boolean isRunning) {
    char buffer[60] ;

    if (isRunning) 
    {
	MemLock (OptrToHandle(@LevelText));
	sprintf(buffer, LMemDeref(@LevelText), G_level) ;
	@call LaserLettersPrimary::MSG_GEN_REPLACE_VIS_MONIKER_TEXT(buffer, VUM_NOW) ;
	MemUnlock (OptrToHandle(@LevelText));
	@call LaserLettersLevelText::MSG_VIS_TEXT_REPLACE_ALL_PTR(G_titleString, 0);
    } else {
	@call LaserLettersPrimary::MSG_GEN_REPLACE_VIS_MONIKER_OPTR(@LaserLettersTextMoniker, VUM_NOW) ;
	@call LaserLettersLevelText::MSG_VIS_TEXT_REPLACE_ALL_OPTR(@GameReadyText, 0);
    }
	 
}

/*-------------------------------------------------------------------------
 | FindGameSpeed
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Find out default or increasing level game speed
 |
 |    speedSelected in Lesson mode:
 |	GAME_SPEED_DEFAULT: All non-text based exercises have GAME_SPEED_SLOW.
 |			Text based exercises may have higher speed.
 |	GAME_SPEED_INCREASING: Non-text based exercises consist of 9 groups
 |			with 3 exercises each. Speed starts with GAME_SPEED_SLOW
 | 			in every group and increases for the last exercise.
 |			The speed of text based exercises increases depending on G_level
 |
 |    speedSelected in Game mode:
 |	GAME_SPEED_DEFAULT: All levels have GAME_SPEED_SLOW in fist turn.
 | 			Levels higher than GAME_LAST_GAME_LEVEL (5) may have higher speed. 
 |	GAME_SPEED_INCREASING: Level 1 and 2 have speed GAME_SPEED_SLOW
 |			Then, speed increases with every level.
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    RB   03/09/24  Created
 *-----------------------------------------------------------------------*/
word FindGameSpeed(int selectedSpeed) {
word speed, limit;

    if ( GAME_MODE_GAME == @call GameModeSelector::MSG_GEN_ITEM_GROUP_GET_SELECTION() )
    {
    	limit = GAME_LAST_GAME_LEVEL;
    	if (selectedSpeed == GAME_SPEED_INCREASING) limit = (GAME_LAST_GAME_LEVEL/2);
    	speed = GAME_SPEED_SLOW;
    	if (G_level > limit ) speed += (G_level-limit);
    	if (speed > GAME_SPEED_VERY_FAST ) speed = GAME_SPEED_VERY_FAST;
    	
    	return speed;
    }


    switch (selectedSpeed) {
    case GAME_SPEED_DEFAULT:
	if (G_level <= (NUM_SPECIAL_GROUPS * NUM_EXERCISES) )
	{
	    speed = GAME_SPEED_SLOW;
	} else {
	    speed = GAME_SPEED_SLOW + (G_level - (NUM_SPECIAL_GROUPS * NUM_EXERCISES))/2;
	    if (speed > GAME_SPEED_VERY_FAST ) speed = GAME_SPEED_VERY_FAST;
	}
   	break;
   case GAME_SPEED_INCREASING:
	if (G_level <= (NUM_SPECIAL_GROUPS * NUM_EXERCISES) )
	{
	    speed = GAME_SPEED_SLOW;
	    speed += ((G_level-1) % NUM_EXERCISES)/2;	
	    // to increase speed on each exercise use:
	    //speed += ((G_level-1) % NUM_EXERCISES);	
	} else {
	    speed = GAME_SPEED_SLOW + (G_level-1 - (NUM_SPECIAL_GROUPS * NUM_EXERCISES));
	    if (speed > GAME_SPEED_VERY_FAST ) speed = GAME_SPEED_VERY_FAST;
	}
   	break;
   }
   
   return speed;
}

/*-------------------------------------------------------------------------
 | DisplayPauseState
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Toggle pause text in GameState text object
 |
 | G_pauseState: high word: paused/runnung
 |		 low word: counter
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    RB   03/09/24  Created
 *-----------------------------------------------------------------------*/
void DisplayPauseState (void) {
#define PAUSE_DELAY  12

    if ((G_pauseState &0xFF) == 0) {
	@call LaserLettersLevelText::MSG_VIS_TEXT_REPLACE_ALL_OPTR(@GamePausedText1,0);
	G_pauseState &= 0xFF00;
    	G_pauseState += 2*PAUSE_DELAY;
	}
    if ((G_pauseState &0xFF) == PAUSE_DELAY) {
	@call LaserLettersLevelText::MSG_VIS_TEXT_REPLACE_ALL_OPTR(@GamePausedText2,0);
	}
    G_pauseState--;

}

/*-------------------------------------------------------------------------
 | PrepareGameModeLetters
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Find letters to present when we are in game mode.
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    RB   03/14/24  Created
 *-----------------------------------------------------------------------*/
Boolean PrepareGameModeLetters(void) {
int level, num, n, i, count;
optr chars, title;
char *text;

	/* 
	 * We only have GAME_LAST_GAME_LEVEL game mode levels
	 */
    level = (G_level > GAME_LAST_GAME_LEVEL) ? GAME_LAST_GAME_LEVEL : G_level;

    switch (level) {
    case GAME_LEVEL_1: chars = @Game1LowerCaseLetters; 
    	    title = @GameLevel1TitleString; 
    	    break;
    case GAME_LEVEL_2: chars = @Game2AllLetters; 
    	    title = @GameLevel2TitleString; 
    	    break;
    case GAME_LEVEL_3: chars = @Game3AllLettersAndNumbers; 
    	    title = @GameLevel3TitleString; 
    	    break;
    case GAME_LEVEL_4: chars = @Game4NumbersAndSpecialCharcters; 
    	    title = @GameLevel4TitleString; 
    	    break;
    case GAME_LEVEL_5:
    default: chars = @Game5AllCharcters; 
    	     title = @GameLevel5TitleString; 
    	     break;
    }

    /* starting with level 6 (GAME_LAST_GAME_LEVEL+1): present more letteres than 60 (default)
     * or 36 (beginner) */
    num = (G_level > GAME_LAST_GAME_LEVEL) ? 35 + 5*G_level : 60;
    if ( GAME_USER_IS_BEGINNER & @call LaserLettersBeginnerMode::MSG_GEN_BOOLEAN_GROUP_GET_SELECTED_BOOLEANS() ) 
    		num = (6*num)/10;
    if (num > 95) num = 95;

    /* Find out title string */
    MemLock(OptrToHandle(title));
    text = LMemDeref(title);
    if ( strlen(text) > (MAX_TITLE_LEN-1) ) text[MAX_TITLE_LEN] = 0;
    strcpy(G_titleString, text);
    
    /* Find out the letters to present */
    /* By default, they are in the same resource like title strings - but be want to be sure. */
    MemLock(OptrToHandle(chars));
    text = LMemDeref(chars);
    count = strlen(text);
    
    for ( n = 0; n < num; n++ )
    {
    	i = RandomNumber() % count ;
    	G_lettersToPresent[n] = text[i];
    }

    MemUnlock(OptrToHandle(chars));
    MemUnlock(OptrToHandle(title));
    
    @call LaserLettersLevelText::MSG_VIS_TEXT_REPLACE_ALL_PTR(G_titleString, 0);
    G_numPresented = 0 ;
    
    return TRUE;
}
/***************************************************************************
 *  END OF FILE:  LASERL.GOC                                               *
 ***************************************************************************/
