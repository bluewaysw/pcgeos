/***************************************************************************
 *  FILE:  LASERL.GOC                                                      *
 ***************************************************************************/

/*-------------------------------------------------------------------------
 | Program:  Laser Letter
 *-------------------------------------------------------------------------
 |
 | Objective:
 |    Allows the user to learn faster writing on the keyboard.
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  03/26/99  Created
 |    RB   02/06/24  QuickTips added	
 |
 *-----------------------------------------------------------------------*/

/***************************************************************************
 *		Include files
 ***************************************************************************/

@include <stdapp.goh>
@include <Objects/vLTextC.goh>
@include <Ansi/string.h>
@include <Ansi/stdio.h>
@include <Ansi/ctype.h>
@include <initfile.h>
@include "laserdb.goh"

/***************************************************************************
 *		Constants and defines:
 ***************************************************************************/

/* Playing fields width and height */
#define FIELD_WIDTH    602
#define FIELD_HEIGHT   (G_fieldHeight)

/* The different states (graphics) a building can be in */
typedef byte BuildingState ;
#define BUILDING_STATE_SHIELDED    0
#define BUILDING_STATE_NORMAL      1
#define BUILDING_STATE_BOOM        2
#define BUILDING_STATE_DEAD        3

/* Number of buildings on the screen */
#define NUM_BUILDINGS              10

/* Buildings Y location (from the base of the bitmap) */
#define BUILDINGS_Y                (FIELD_HEIGHT-14)

/* Point size to show the ammo count */
#define AMMO_POINT_SIZE        10

/* Position of ammo numbers on the left and right */
#define AMMO_LEFT_X            14
#define AMMO_LEFT_Y            (FIELD_HEIGHT-7-AMMO_POINT_SIZE)
#define AMMO_RIGHT_X           (7+FIELD_WIDTH-23)
#define AMMO_RIGHT_Y           AMMO_LEFT_Y

/* Positions of the tower's laser being shot from */
#define TOWER_LEFT_X           15
#define TOWER_LEFT_Y           (FIELD_HEIGHT-54)
#define TOWER_RIGHT_X          (FIELD_WIDTH-15)
#define TOWER_RIGHT_Y          TOWER_LEFT_Y

/* Maximum number of letters on the screen at one time */
#define MAX_LETTERS            20

/* The point size to use for the letters */
#define LETTERS_POINT_SIZE     G_fontSize

/* How many pixels a letter steps down on the screen */
#define LETTER_STEP_Y_RATE     (G_stepRate)

/* Where the bottom of the screen is for a letter */
#define LETTER_BOTTOM_Y        (BUILDINGS_Y-LETTERS_POINT_SIZE-1)
#define LETTER_CHECK_Y         (BUILDINGS_Y-47-LETTERS_POINT_SIZE)

/* How fast the game is played */
typedef byte GameSpeed ;
#define GAME_SPEED_VERY_SLOW   0
#define GAME_SPEED_SLOW        1
#define GAME_SPEED_NORMAL      2
#define GAME_SPEED_FAST        3
#define GAME_SPEED_VERY_FAST   4
#define GAME_SPEED_DEFAULT     100

/* How quickly letters are presented on the screen */
typedef byte GameDensity ;
#define GAME_DENSITY_VERY_LOW  0
#define GAME_DENSITY_LOW       1
#define GAME_DENSITY_NORMAL    2
#define GAME_DENSITY_HIGH      3
#define GAME_DENSITY_VERY_HIGH 4

/* Amount of time between any action occuring */
#define GAME_SMALLEST_TIME_UNIT     4

/* Number of time units a BOOM stays shown */
#define UNITS_BOOM_STAYS            (40/GAME_SMALLEST_TIME_UNIT)

/* Maximum number of shots that can get buffered up before being lost */
#define MAX_SHOOT_REQUESTS          20

/* Generic return value for bad indexes into arrays */
#define INDEX_NONE                  0xFFFF

/* Maximum number of levels actually in the tables */
#define MAX_LEVELS                  10

/* Number of sounds to allow to be played simultaneously */
#define MAX_SOUND_CHANNELS          2

/* Sounds below this frequency are not played */
#define SOUND_FREQ_CUTOFF           30

#define SOUND_GAME_OVER         2
#define SOUND_LEVEL_START       3
#define SOUND_SHOOTS_MISS       7
#define SOUND_SHOOTS_HIT        6
#define SOUND_SHOOTS            5
#define SOUND_OUT_OF_AMMO       10
#define SOUND_LETTERS_ADVANCE   8
#define SOUND_CITY_DESTROYED    9
#define SOUND_SHIELD_DESTROYED  13
#define SOUND_END_OF_LEVEL      4

#define GAME_FONT_ID            (G_fontID)
#define GAME_FONT_SIZE          (G_fontSize)

/* Present Quick Tips on startup */
#define	SHOW_ON_STARTUP		1

/***************************************************************************
 *		Custom types:
 ***************************************************************************/

/* All the information of a letter.   A letter is located by its top middle */
/* like the intersection of the letter T. */
typedef struct {
    char letter ;                  /* Actual letter (upper/lower cased) */
    byte halfwidth ;               /* Half the pixel width for centering */
    sword x ;                      /* x position of center */
    sword y ;                      /* y position of top */
    sword oldX ;                   /* last x position */
    sword oldY ;                   /* last y position */
    byte color ;
    byte special ;                 /* Special flags (not used yet) */
} T_letter ;

/* Player has a request to shoot a sound in a buffer in case typing */
/* gets ahead of the animation. */
typedef struct {
    char character ;
    Boolean isLeftTower ;
} T_shootRequest ;

/* Structure of a single sound */
typedef struct {
    word length ;
    word priority ;

    #define MAX_SOUND_SAMPLES  100
    word samples[MAX_SOUND_SAMPLES] ;
} T_simplePCSound ;

typedef struct {
    word soundNum ;             /* Value of INDEX_NONE means no sound */
    word pos      ;             /* Position within sample list */
    word priority ;             /* Level priority of sound */
} T_soundState ;

/***************************************************************************
 *		Global variables:
 ***************************************************************************/

/* Number of shots left for the ammo */
word G_ammoLeft = 99 ;

/* Line of current fire.  A value of 0 in G_shotLineFromX means no firing */
sword G_shotLineFromX = 0;
sword G_shotLineFromY = 0;
sword G_shotLineToX = 0;
sword G_shotLineToY = 0 ;

/* Location of current explosion sprite (based on center) */
sword G_explodeX = 0 ;
sword G_explodeY = 0 ;

/* Array of falling letters on the screen currently and count thereof. */
/* A letter with a x coordinate of 0 is not active */
T_letter G_letterArray[MAX_LETTERS] ;

/* List of the buildings.  Game is over when all dead */
BuildingState G_buildingArray[NUM_BUILDINGS] ;
word G_buildingTiming[NUM_BUILDINGS] ;

/* Letters waiting to be shown.  It is a string of text with a null */
/* terminator at the end */
char G_lettersToPresent[512] ;
word G_numPresented = 0 ;

/* Game parameters to control difficulty (other than the letters used). */
GameSpeed G_gameSpeed = GAME_SPEED_NORMAL ;
GameDensity G_gameDensity = GAME_DENSITY_NORMAL ;

/* Note if the game is actually running */
Boolean G_isRunning = FALSE ;

/* Time til next letters update (in SMALLEST_TIME units) */
word G_countTilNextUpdate ;
word G_countPerUpdate ;

/* Number of updates until another letter is added */
word G_countTilNextAddition = 2 ;

/* Timer used to keep the game going */
TimerHandle G_timer = NullHandle ;
word G_timerId ;

/* Timer used to update sound */
TimerHandle G_soundTimer = NullHandle ;
word G_soundTimerId ;

/* Number of ticks gone by before an update (letters fall) occurs */
/* The timer we use updates at about 1/60 a second for the sound, */
/* but the game play changes at a different rate */
word G_ticksGoneBy = 0 ;

/* List of buffered up shoot request should the player get going fast */
T_shootRequest G_shootRequestArray[MAX_SHOOT_REQUESTS] ;
word G_shootRequestCount = 0 ;

/* What level we are in the game */
word G_level = 1 ;

T_simplePCSound G_sounds[16] ;
T_soundState G_channelArray[MAX_SOUND_CHANNELS] ;

Boolean G_isColor = TRUE ;
Boolean G_isSmall = FALSE ;

/* Actual field height */
word G_fieldHeight = 170 ;

/* Font type and size used for the letters.  It changes based on */
/* screen size */
word G_fontID = DEFAULT_FONT_ID ;
word G_fontSize = 12 ;

/* Base rate the letters are falling. */
word G_stepRate = 4 ;

/* Flag used to force the end of a level */
Boolean G_forceLevelComplete = FALSE ;

Boolean G_isSoundOn = TRUE ;

word G_driveLetter = 2 ; /* Default to C: */

/***************************************************************************
 *		Tables:
 ***************************************************************************/

sword G_buildingsX[NUM_BUILDINGS] = {
     4*12,
     8*12,
    12*12,
    16*12,
    20*12,

    26*12,
    30*12,
    34*12,
    38*12,
    42*12
} ;

word G_levelSpeed[MAX_LEVELS] = {
    GAME_SPEED_VERY_SLOW,
    GAME_SPEED_VERY_SLOW,
    GAME_SPEED_SLOW,
    GAME_SPEED_SLOW,
    GAME_SPEED_NORMAL,
    GAME_SPEED_NORMAL,
    GAME_SPEED_FAST,
    GAME_SPEED_FAST,
    GAME_SPEED_VERY_FAST,
    GAME_SPEED_VERY_FAST
} ;

word G_levelDensity[MAX_LEVELS] = {
    GAME_DENSITY_NORMAL,
    GAME_DENSITY_VERY_HIGH,
    GAME_DENSITY_NORMAL,
    GAME_DENSITY_VERY_HIGH,
    GAME_DENSITY_NORMAL,
    GAME_DENSITY_VERY_HIGH,
    GAME_DENSITY_VERY_LOW,
    GAME_DENSITY_NORMAL,
    GAME_DENSITY_LOW,
    GAME_DENSITY_HIGH
} ;

word G_numPerAdd[1+GAME_DENSITY_VERY_HIGH] = {
    1,
    1,
    1,
    1,
    1
} ;

/***************************************************************************
 *		Routine Prototypes:
 ***************************************************************************/

void AddFallingLetter(void) ;
void DrawAmmo(GStateHandle gstate) ;
void DrawBuilding(GStateHandle gstate, word i) ;
void DrawCompleteScreen(GStateHandle gstate) ;
void DrawExplode(GStateHandle gstate, Boolean doDraw) ;
void DrawLetter(GStateHandle gstate, word index) ;
void DrawLetters(GStateHandle gstate) ;
void DrawShooting(GStateHandle gstate, Boolean doDraw) ;
word FindBuildingAtX(word x, word halfwidth) ;
word FindFreeLetter(void) ;
word FindLowestLetter(char letter) ;
Boolean IsLetterSpotTaken(sword x, sword y, word selfIndex) ;
Boolean IsLevelDone(void) ;
Boolean IsPlayerDead(void) ;
void LoadSounds(void) ;
void MakeLettersFall(GStateHandle gstate, Boolean doFall) ;
void RecordShootRequest(char character, Boolean isLeftTower) ;
void PlayerShoots(char character, Boolean isLeftTower) ;
void PlayFrequency(word freq, word duration) ;
void PlaySimpleSound(word soundId, word priority) ;
void PrepareNewGame(Boolean isNewBuildings) ;
void PrepareNewLetters(void) ;
Boolean ShootFirstRecorded(void) ;
word RandomNumber(void) ;
void ResetSound(void) ;
void SoundStart(void) ;
void SoundStop(void) ;
void SoundsWaitUntilDone(void) ;
void UpdateBuildingAnimations(GStateHandle gstate) ;
void UpdateSound(void) ;

/***************************************************************************
 *		Class & Message Definitions
 ***************************************************************************/

    /*---------------------------------------------------------------------*/
    @class LaserLettersProcessClass, GenProcessClass ;
        @message void MSG_GAME_UPDATE() ;
        @message void MSG_GAME_START() ;
        @message void MSG_GAME_START_VIA_UI() ;
        @message void MSG_GAME_STOP() ;
        @message void MSG_GAME_UPDATE_SOUND() ;
        @message void MSG_GAME_SKIP_LEVEL() ;
        @message void MSG_GAME_TOGGLE_SOUND() ;
    @endc

    @classdecl LaserLettersProcessClass, neverSaved ;
    /*---------------------------------------------------------------------*/


/***************************************************************************
 *		UI Objects
 ***************************************************************************/



/*=========================================================================*/



@start	AppResource ;
    /*---------------------------------------------------------------------*/
    @object GenApplicationClass LaserLettersApp = {
        GI_visMoniker = list { @LaserLettersTextMoniker,
                               @AppIconVGA,
                               @AppIconHGC,
                               @AppIconCGA,
                               @AppSmallIconVGA,
                               @AppSmallIconHGC }
        GI_comp       = @LaserLettersPrimary ;
        gcnList(MANUFACTURER_ID_GEOWORKS,GAGCNLT_WINDOWS)
                      = @LaserLettersPrimary;
        ATTR_GEN_HELP_FILE = "Laser Letters Help";
    }
    /*---------------------------------------------------------------------*/
    @visMoniker LaserLettersTextMoniker =
        "Laser Letters" ;
    /*---------------------------------------------------------------------*/
@end	AppResource


@start IconResource ;
    /*---------------------------------------------------------------------*/
    @include "Art/iconvga.goh"
    @include "Art/iconhgc.goh"
    @include "Art/iconcga.goh"
    @include "Art/iconsvga.goh"
	 @include "Art/iconshgc.goh"

    /*---------------------------------------------------------------------*/
@end IconResource ;

/*=========================================================================*/



@start	Interface		/* this resource is for misc UI objects */ ; ;
    /*---------------------------------------------------------------------*/
    @object GenPrimaryClass LaserLettersPrimary  = {
		  GI_comp = @LaserLettersGameMenu, @LaserLettersOptionsMenu,
		            @LaserLettersView, @QTipsDialogBox;
        HINT_SIZE_WINDOW_AS_DESIRED ;
        HINT_CENTER_CHILDREN_HORIZONTALLY ;
        HINT_CENTER_CHILDREN_VERTICALLY ;
/*        HINT_DISPLAY_MAXIMIZED_ON_STARTUP; */
        HINT_KEEP_ENTIRELY_ONSCREEN;

        HINT_PRIMARY_NO_FILE_MENU ;
		  /*ATTR_GEN_HELP_CONTEXT = "TOC" ;*/
	HINT_PRIMARY_NO_HELP_BUTTON;
	 }
	 /*---------------------------------------------------------------------*/
	 @object GenInteractionClass LaserLettersGameMenu = {
		  GI_visMoniker = 'G', "Game" ;
		  GI_comp =
				@LaserLettersGameGroup;
		  GII_visibility = GIV_POPUP ;
		  ATTR_GEN_INTERACTION_GROUP_TYPE = (GIGT_FILE_MENU) ;
	 }
	 /*---------------------------------------------------------------------*/
	 @object GenInteractionClass LaserLettersGameGroup = {
		  GI_comp =	@LaserLettersStartTrigger,
				@LaserLettersSkip,
				@LaserLettersQTipsTrigger;
	 }
	 /*---------------------------------------------------------------------*/
    @object GenTriggerClass LaserLettersStartTrigger = {
        GI_visMoniker = 'S', "Start" ;
        GTI_destination = process ;
        GTI_actionMsg = MSG_GAME_START_VIA_UI ;
    }
	 /*---------------------------------------------------------------------*/
	 @object GenTriggerClass LaserLettersSkip = {
		  GI_visMoniker = 'k', "Skip level" ;
		  GTI_destination = process ;
		  GTI_actionMsg = MSG_GAME_SKIP_LEVEL ;
	 }
	 /*---------------------------------------------------------------------*/
	 @object GenTriggerClass LaserLettersQTipsTrigger = {
		  GI_visMoniker   = 'Q', "Quick Tips" ;
		  GTI_destination = @QTipsDialogBox ;
		  GTI_actionMsg   = MSG_GEN_INTERACTION_INITIATE ;
		  HINT_TRIGGER_BRINGS_UP_WINDOW;
	 }

	 /*---------------------------------------------------------------------*/
	 @object GenInteractionClass LaserLettersOptionsMenu = {
		  GI_visMoniker = 'O', "Options" ;
		  GI_comp =
				@LaserLettersToggleSound,
				@LLSpeedDBox;
		  GII_visibility = GIV_POPUP ;
	 }
	 /*---------------------------------------------------------------------*/
    @object GenTriggerClass LaserLettersToggleSound = {
		  GI_visMoniker = list { @SoundIsOnMoniker } ;
		  GTI_destination = process ;
		  GTI_actionMsg = MSG_GAME_TOGGLE_SOUND ;
    }
	 /*---------------------------------------------------------------------*/
	 @visMoniker SoundIsOnMoniker = 'O', "Sound is ON" ;
	 /*---------------------------------------------------------------------*/
	 @visMoniker SoundIsOffMoniker = 'O', "Sound is OFF" ;
	 /*---------------------------------------------------------------------*/
	 @object GenInteractionClass LLSpeedDBox = {
		  GI_visMoniker = 'S', "Speed" ;
		  GI_comp = @LLSpeedGroup;
		  GII_visibility = GIV_POPUP ;
//	     GII_type = GIT_NOTIFICATION;
//		  ATTR_GEN_HELP_CONTEXT = "SpeedDBox" ;
	 }
	 /*---------------------------------------------------------------------*/
	 @object GenItemGroupClass LLSpeedGroup = {
		  GI_comp = @LLDefaultItem, @LLVSlowItem, @LLSlowItem,
						@LLNormalItem, @LLFastItem, @LLVFastitem;
		  GIGI_selection = GAME_SPEED_DEFAULT ;
		  HINT_ORIENT_CHILDREN_VERTICALLY;
	 }

	 @object GenItemClass LLDefaultItem = {
		  GI_visMoniker = "Default" ;
		  GII_identifier = GAME_SPEED_DEFAULT ;
	 }
	 @object GenItemClass LLVSlowItem = {
		  GI_visMoniker = "VerySlow" ;
		  GII_identifier = GAME_SPEED_VERY_SLOW ;
	 }
	 @object GenItemClass LLSlowItem = {
		  GI_visMoniker = "Slow" ;
		  GII_identifier = GAME_SPEED_SLOW ;
	 }
	 @object GenItemClass LLNormalItem = {
		  GI_visMoniker = "Normal" ;
		  GII_identifier = GAME_SPEED_NORMAL ;
	 }
	 @object GenItemClass LLFastItem = {
		  GI_visMoniker = "Fast" ;
		  GII_identifier = GAME_SPEED_FAST ;
	 }
	 @object GenItemClass LLVFastitem = {
		  GI_visMoniker = "Very Fast" ;
		  GII_identifier = GAME_SPEED_VERY_FAST ;
	 }

	 /*---------------------------------------------------------------------*/
	 @object GenViewClass LaserLettersView = {
        GVI_content = process ;

        GVI_vertAttrs = @default & (~ GVDA_SCROLLABLE) ;
        GVI_horizAttrs = @default & (~ GVDA_SCROLLABLE) ;
        GVI_attrs = @default |
                    GVA_NO_WIN_FRAME |
                    GVA_WINDOW_COORDINATE_MOUSE_EVENTS |
                    GVA_FOCUSABLE ;

        HINT_FIXED_SIZE = {
            SST_PIXELS | FIELD_WIDTH,
            SST_PIXELS | 170 /* FIELD_HEIGHT */
        } ;

        HINT_DEFAULT_TARGET;
        HINT_DEFAULT_FOCUS;
        HINT_EXPAND_WIDTH_TO_FIT_PARENT ;
        HINT_EXPAND_HEIGHT_TO_FIT_PARENT ;
    }
    /*---------------------------------------------------------------------*/
	 @object GenInteractionClass QTipsDialogBox = {
		  GI_visMoniker = "Laser Letters Quick Tips";
		  GI_comp = @GoalText, @InfoGroup, @LearnText,
				@ShowOnStartupGroup,
				@OKTipsButton;
		  GII_visibility = GIV_DIALOG ;
		  GII_attrs = @default | GIA_MODAL | GIA_NOT_USER_INITIATABLE;
		  HINT_CENTER_CHILDREN_HORIZONTALLY ;
		  /*ATTR_GEN_HELP_CONTEXT = "TOC";*/
	 }

	 @object GenTextClass GoalText = {
		  GI_attrs = @default | GA_READ_ONLY;
		  GI_visMoniker = " ";
		  HINT_PLACE_MONIKER_TO_LEFT;
		  GTXI_text = "The goal of the game is to protect the city!";
		  ATTR_GEN_TEXT_NEVER_MAKE_SCROLLABLE;
	 }
	 @object GenInteractionClass InfoGroup = {
		  GI_visMoniker = " ";
		  HINT_PLACE_MONIKER_TO_LEFT;
		  HINT_EXPAND_WIDTH_TO_FIT_PARENT;
		  GI_comp = @InfoText;
		  }
	 @object GenTextClass InfoText = {
		  GI_attrs = @default | GA_READ_ONLY;
		  GI_visMoniker = list { @VisMonColorShieldedCityBitmap, @VisMonMonoShieldedCityBitmap };
		  HINT_PLACE_MONIKER_TO_LEFT;
		  GTXI_text = "Falling letters destroy the buildings. Use the laser guns on both sides to destroy the letters. To do this, simply press the corresponding key on the keyboard.";
		  ATTR_GEN_TEXT_NEVER_MAKE_SCROLLABLE;
	 }


	 @object GenTextClass LearnText = {
		  GI_attrs = @default | GA_READ_ONLY;
		  GI_visMoniker = " ";
		  HINT_PLACE_MONIKER_TO_LEFT;
		  GTXI_text = "This game offers various levels of increasing difficulty. This also allows you to learn to write faster with the keyboard.";
		  ATTR_GEN_TEXT_NEVER_MAKE_SCROLLABLE;
	 }

	 @object GenBooleanGroupClass ShowOnStartupGroup = {
		  GI_comp = @ShowOnStartupBoolean;
	 }

	 @object GenBooleanClass ShowOnStartupBoolean = {
		  GI_visMoniker = 'S', "Show this Dialog box when Laser Letters starts";
		  GBI_identifier = SHOW_ON_STARTUP;
	 }

	 @object GenTriggerClass OKTipsButton = {
		  GI_visMoniker   = 'O', "OK";
		  GI_attrs = @default | GA_SIGNAL_INTERACTION_COMPLETE ;
		  HINT_SEEK_REPLY_BAR;
		  HINT_DEFAULT_DEFAULT_ACTION;
	 }

@end Interface


@start Strings;

@chunk char LevelText[] = "Laser Letters -- Level %u";
@localize "do not localize the %u";
@chunk char OverText[] = "Game over!";
@chunk char ComplText[] = "Level completed!  On to level \01";
@localize "do not localize the @1";
@chunk char LeftKeys[] = "`12345qwert~!@#$%asdfgQWERTASDFGzxcvbZXCVB" ;
@localize "the keyboard's left hand keys - MUST fit to the keyboard layout of the target language";
@chunk char RightKeys[] = "67890^&*()yuiopYUIOPhjkl;HJKL:nm,./NM<>?'\"[]{}\\|-=_+" ;
@localize "the keyboard's right hand keys - MUST fit to the keyboard layout of the target language";
@chunk char NoExerciseFile[] = "No Typing Tutor exercise file found.  Using sample letters file (3 Levels).";
@chunk char Level1Samp[] = "jjjjffffjjjjffffddddkkkkddddkkkk";
@localize "the first sample level";
@chunk char Level2Samp[] = "jjjjffffjjjjffffddddkkkkddddkkkkssssllllssssllll";
@localize "the second sample level";
@chunk char Level3Samp[] = "jjjjffffjjjjffffddddkkkkddddkkkkssssllllssssllllaaaa;;;;aaaa;;;;";
@localize "the third & last sample level - respect the keyboard layout of the target language";

@end Strings;

/*

  The structure of the ui tree is as follows:

     LaserLettersPrimary
            |
     +------+------+
     |             |
  PlayButton   LaserLettersView - - - - - - - - + (GVI_content link)
                                                |
                                     LaserLettersProcessClass handler

*/

/*=========================================================================*/

@include "Art/art.goh"



/*=========================================================================*
 *  METHODS FOR CLASS:  LaserLettersProcessClass
 *=========================================================================*/

/*-------------------------------------------------------------------------
 | Method:  LaserLettersProcessClass::MSG_GEN_PROCESS_OPEN_APPLICATION
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Starts up the app by initializing the OText object.
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  03/30/99  Created
 |    RB   02/06/24  QuickTips added	
 |
 *-----------------------------------------------------------------------*/

@method LaserLettersProcessClass, MSG_GEN_PROCESS_OPEN_APPLICATION
{
    DisplayScheme scheme ;
    AppLaunchBlock *p_launch ;
    char buffer[200] ;
    char *p_buffer = buffer ;
    Boolean initError, tips;

    /* Determine where the application's directory is really located */
    p_launch = MemLock(launchBlock) ;
    buffer[0] = 'C' ;
    FileConstructFullPath(&p_buffer, sizeof(buffer)-1,
					p_launch->ALB_appRef.AIR_diskHandle,
					p_launch->ALB_appRef.AIR_fileName,
					TRUE);
    G_driveLetter = toupper(buffer[0]) - 'A' ;
    MemUnlock(launchBlock) ;

    /* Determine the type of graphics we have to use */
    @call LaserLettersApp::MSG_GEN_APPLICATION_GET_DISPLAY_SCHEME(&scheme) ;
    if (((scheme.DS_displayType&DT_DISP_SIZE)>>DT_DISP_SIZE_OFFSET) == DS_TINY)  {
        G_isSmall = TRUE ;
        G_fieldHeight = 170 ;
    } else {
        G_isSmall = FALSE ;
    }
    if (((scheme.DS_displayType&DT_DISP_CLASS)>>DT_DISP_CLASS_OFFSET) < DC_COLOR_4)  {
        G_isColor = FALSE ;
    } else {
        G_isColor = TRUE ;
    }

/* TESTING */
//G_isColor = TRUE ;
//G_isSmall = FALSE ;

    if (!G_isSmall)  {
        G_fieldHeight = 368 ;
        @call LaserLettersView::MSG_GEN_SET_FIXED_SIZE(
                  VUM_MANUAL, 0,
                  SST_PIXELS|FIELD_HEIGHT,
                  SST_PIXELS|FIELD_WIDTH) ;
        G_fontID = FID_DTC_URW_SANS ;
        G_fontSize = 24 ;
        G_stepRate = 8 ;
    }
    if (G_isColor)  {
        @call LaserLettersView::MSG_GEN_VIEW_SET_COLOR(
                  C_LIGHT_BLUE,
                  CF_INDEX,
                  0) ;
    }

	 LaserExerciseDBOpen() ;
    PrepareNewGame(TRUE) ;
    @callsuper() ;
    LoadSounds() ;
    SoundStart() ;
    
    /* check for quick tips */
    initError = InitFileReadBoolean("LaserL", "showTips", &tips);
    if (initError) tips = TRUE;
	if (tips) {
	    @send ShowOnStartupGroup::MSG_GEN_BOOLEAN_GROUP_SET_BOOLEAN_STATE(
			SHOW_ON_STARTUP,
			TRUE);
	    @send QTipsDialogBox::MSG_GEN_INTERACTION_INITIATE();
    	}
    	else {
    	    @send ShowOnStartupGroup::MSG_GEN_BOOLEAN_GROUP_SET_BOOLEAN_STATE(
    			SHOW_ON_STARTUP,
    			FALSE);
	}
    							
}

/*-------------------------------------------------------------------------
 | Method:  LaserLettersProcessClass::MSG_GEN_PROCESS_CLOSE_APPLICATION
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Ends the app but first cleans up the OText object.
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  03/26/99  Created
 |    RB   02/06/24  QuickTips added	
 |
 *-----------------------------------------------------------------------*/

@method LaserLettersProcessClass, MSG_GEN_PROCESS_CLOSE_APPLICATION
{
    Boolean tips;
    
    @call oself::MSG_GAME_STOP() ;
    SoundStop() ;
    LaserExerciseDBClose() ;
    
    /* set the quick tips */
    tips = @call ShowOnStartupGroup::MSG_GEN_BOOLEAN_GROUP_IS_BOOLEAN_SELECTED(SHOW_ON_STARTUP);
    InitFileWriteBoolean("LaserL", "showTips", tips);
    
    return @callsuper() ;
}

/*-------------------------------------------------------------------------
 | Method:  LaserLettersProcessClass::MSG_GAME_START
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Start the game.
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  03/30/99  Created
 |    LES  03/31/99  Updated so it has different levels of speed and
 |                   density.
 |    jfh  07/18/02  Added speed selection
 *-----------------------------------------------------------------------*/
@method LaserLettersProcessClass, MSG_GAME_START
{
	 word level, speed ;
    char buffer[60] ;

    level = G_level ;
    if (level > MAX_LEVELS)
        level = MAX_LEVELS ;

	 MemLock (OptrToHandle(@LevelText));
	 sprintf(buffer, LMemDeref(@LevelText), G_level) ;
    @call LaserLettersPrimary::MSG_GEN_REPLACE_VIS_MONIKER_TEXT(buffer, VUM_NOW) ;
	 MemUnlock (OptrToHandle(@LevelText));
	 /*
    G_gameSpeed = G_levelSpeed[level-1] ;
    */

	 /* and even more messing with speed - jfh */
	 speed = @call LLSpeedGroup::MSG_GEN_ITEM_GROUP_GET_SELECTION();
	 if (speed == GAME_SPEED_DEFAULT) {
			G_gameSpeed = 0+(((G_level+3)*3)/G_numExercises) ;
			}
	 else G_gameSpeed = speed;

    if (G_gameSpeed > GAME_SPEED_VERY_FAST)
		  G_gameSpeed = GAME_SPEED_VERY_FAST ;
/*    G_gameDensity = G_levelDensity[level-1] ; */
G_gameDensity = GAME_DENSITY_HIGH ;

    @call oself::MSG_GAME_STOP() ;
    PrepareNewGame(FALSE) ;
    G_isRunning = TRUE ;
    G_ticksGoneBy = 0 ;
    G_shootRequestCount = 0 ;
    ResetSound() ;
    PlaySimpleSound(SOUND_LEVEL_START, 0xFFFF) ;
    @call LaserLettersView::MSG_GEN_VIEW_REDRAW_CONTENT();
    SoundStart() ;
    if (!G_timer)
        G_timer = TimerStart(
                  TIMER_EVENT_CONTINUAL,
                  oself,
                  1,
                  MSG_GAME_UPDATE,
                  1,
                  &G_timerId) ;
}

/*-------------------------------------------------------------------------
 | Method:  LaserLettersProcessClass::MSG_GAME_SKIP_LEVEL
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Skip the current level.
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  05/27/99  Created
 |
 *-----------------------------------------------------------------------*/
@method LaserLettersProcessClass, MSG_GAME_SKIP_LEVEL
{
    if (!G_isRunning)
        @call oself::MSG_GAME_START() ;
    G_forceLevelComplete = TRUE ;
}

/*-------------------------------------------------------------------------
 | Method:  LaserLettersProcessClass::MSG_GAME_START_VIA_UI
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Start the game completely.
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  03/30/99  Created
 |
 *-----------------------------------------------------------------------*/
@method LaserLettersProcessClass, MSG_GAME_START_VIA_UI
{
    @call oself::MSG_GAME_STOP() ;

    /* Reset to level 1 */
    G_level = 1 ;
    PrepareNewGame(TRUE) ;

    @call oself::MSG_GAME_START() ;
}

/*-------------------------------------------------------------------------
 | Method:  LaserLettersProcessClass::MSG_GAME_STOP
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Stop the current game.
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  03/30/99  Created
 |
 *-----------------------------------------------------------------------*/
@method LaserLettersProcessClass, MSG_GAME_STOP
{
    if (G_isRunning)  {
        /* Kill the current timer */
        TimerStop(G_timer, G_timerId) ;
        G_timer = NullHandle ;
        G_isRunning = FALSE ;
        G_shootRequestCount = 0 ;
    }
}

/*-------------------------------------------------------------------------
 | Method:  LaserLettersProcessClass::MSG_GAME_TOGGLE_SOUND
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Toggle between having sound and not having sound.
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  05/28/99  Created
 |
 *-----------------------------------------------------------------------*/
@method LaserLettersProcessClass, MSG_GAME_TOGGLE_SOUND
{
    if (G_isSoundOn)  {
        G_isSoundOn = FALSE ;
        @call LaserLettersToggleSound::MSG_GEN_REPLACE_VIS_MONIKER_OPTR(
                @SoundIsOffMoniker,
                VUM_NOW) ;
    } else {
        G_isSoundOn = TRUE ;
        @call LaserLettersToggleSound::MSG_GEN_REPLACE_VIS_MONIKER_OPTR(
                @SoundIsOnMoniker,
                VUM_NOW) ;
    }
}

/*-------------------------------------------------------------------------
 | Method:  LaserLettersProcessClass::MSG_GAME_UPDATE
 *-------------------------------------------------------------------------
 |
 | Description:
 |    The interval timer has gone off and the game needs to update
 |    a single step.
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  03/30/99  Created
 |
 *-----------------------------------------------------------------------*/
@method LaserLettersProcessClass, MSG_GAME_UPDATE
{
    GStateHandle gstate ;
    WindowHandle win ;
    Boolean ammoNeedsRedraw = FALSE ;
    char levelText[10] ;
    static word flip = 0 ;

    if (G_isRunning)  {
        G_ticksGoneBy++ ;
        if (G_ticksGoneBy < GAME_SMALLEST_TIME_UNIT)
            return ;
		  G_ticksGoneBy = 0 ;

        if (IsPlayerDead())  {
            /* Game over */
            PlaySimpleSound(SOUND_GAME_OVER, 0xFFFF) ;
            SoundsWaitUntilDone() ;
            @call oself::MSG_GAME_STOP() ;
				MemLock (OptrToHandle(@OverText));
				UserStandardDialog(
						  NULL, NULL,
						  NULL, NULL,
						  LMemDeref(@OverText),
						  ( CDT_WARNING << CDBF_DIALOG_TYPE_OFFSET ) |
						  ( GIT_NOTIFICATION << CDBF_INTERACTION_TYPE_OFFSET )) ;
				MemUnlock (OptrToHandle(@OverText));
		  } else if (IsLevelDone()) {
            PlaySimpleSound(SOUND_END_OF_LEVEL, 0xFFFF) ;
            SoundsWaitUntilDone() ;
            @call oself::MSG_GAME_STOP() ;

            /* Level completed, on to the next level */
            sprintf(levelText, "%d", G_level+1) ;
				MemLock (OptrToHandle(@ComplText));
				UserStandardDialog(
                    NULL, NULL,
                    NULL, levelText,
						  LMemDeref(@ComplText),
                    ( CDT_WARNING << CDBF_DIALOG_TYPE_OFFSET ) |
                    ( GIT_NOTIFICATION << CDBF_INTERACTION_TYPE_OFFSET )) ;
				MemUnlock (OptrToHandle(@ComplText));
				G_level++ ;
            @call oself::MSG_GAME_START() ;
        } else {
            win = @call LaserLettersView::MSG_GEN_VIEW_GET_WINDOW() ;
            if (win)  {
                gstate = GrCreateState(win) ;

                /* Erase the last shot */
                DrawShooting(gstate, FALSE) ;
                G_shotLineFromX = 0 ;
                DrawExplode(gstate, FALSE) ;
                G_explodeX = 0 ;

                /* Update the new shooting info */
                ammoNeedsRedraw = ShootFirstRecorded() ;

                G_countTilNextUpdate-- ;
                if (!G_countTilNextUpdate)  {
                    if (flip)
                        MakeLettersFall(gstate, TRUE) ;
                    else
                        MakeLettersFall(gstate, FALSE) ;
                    flip ^= 1 ;
                    G_countTilNextUpdate = G_countPerUpdate ;
                }
                UpdateBuildingAnimations(gstate) ;

                DrawShooting(gstate, TRUE) ;
                DrawExplode(gstate, TRUE) ;
                if (ammoNeedsRedraw)
                    DrawAmmo(gstate) ;

                GrDestroyState(gstate) ;
            }
        }
    }
}

/*-------------------------------------------------------------------------
 | Method:  LaserLettersProcessClass::MSG_GAME_UPDATE_SOUND
 *-------------------------------------------------------------------------
 |
 | Description:
 |    The sound timer calls this method to update the sound system.
 |
 |    The reason I use a slightly slower method is to keep the system
 |    synced up so I don't have to semaphore actions.
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  04/01/99  Created
 |
 *-----------------------------------------------------------------------*/
@method LaserLettersProcessClass, MSG_GAME_UPDATE_SOUND
{
    UpdateSound() ;
}

/*-------------------------------------------------------------------------
 | Method:  LaserLettersProcessClass::MSG_META_EXPOSED
 *-------------------------------------------------------------------------
 |
 | Description:
 |    The main view has been exposed -- redraw it completely.
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  03/30/99  Created
 |
 *-----------------------------------------------------------------------*/
@method LaserLettersProcessClass, MSG_META_EXPOSED
{
    GStateHandle gstate ;

    @callsuper() ;

    gstate = GrCreateState(win) ;
    GrBeginUpdate(gstate) ;
    DrawCompleteScreen(gstate) ;
    GrEndUpdate(gstate) ;
    GrDestroyState(gstate) ;
}

/*-------------------------------------------------------------------------
 | Method:  LaserLettersProcessClass::MSG_META_KBD_CHAR
 *-------------------------------------------------------------------------
 |
 | Description:
 |    The main view has been exposed -- redraw it completely.
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  03/30/99  Created
 |
 *-----------------------------------------------------------------------*/
@method LaserLettersProcessClass, MSG_META_KBD_CHAR
{
    if ((G_isRunning) &&
            (!(flags & CF_REPEAT_PRESS)) &&
                (!(flags & CF_RELEASE)))  {
		  MemLock (OptrToHandle(@LeftKeys));
		  if (strchr(LMemDeref(@LeftKeys), character))  {
            RecordShootRequest(character, TRUE) ;
		  } else if (strchr(LMemDeref(@RightKeys), character))  {
            RecordShootRequest(character, FALSE) ;
        } else {
            @call oself::MSG_META_FUP_KBD_CHAR(character, flags, state) ;
        }
		  MemUnlock (OptrToHandle(@LeftKeys));
	 } else {
        @call oself::MSG_META_FUP_KBD_CHAR(character, flags, state) ;
    }
}

/*=========================================================================*
 *  ROUTINES:
 *=========================================================================*/

/*-------------------------------------------------------------------------
 | Routine:  AddFallingLetter
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Present a new letter (if there is any more to present).
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  03/30/99  Created
 |
 *-----------------------------------------------------------------------*/
void AddFallingLetter(void)
{
    char letter ;
    word i ;
    GStateHandle gstate ;
    T_letter *p_letter ;

    /* Get the current letter in the list */
    letter = G_lettersToPresent[G_numPresented] ;

    /* Only add if we have a letter to add */
    if (letter)  {
        i = FindFreeLetter() ;
        if (i != INDEX_NONE)  {
            G_numPresented++ ;
            gstate = GrCreateState(0) ;
            GrSetFont(
                gstate,
                GAME_FONT_ID,
                MakeWWFixed(GAME_FONT_SIZE));
            p_letter = G_letterArray + i ;
            memset(p_letter, 0, sizeof(*p_letter)) ;
            p_letter->letter = letter ;
            p_letter->y = -GAME_FONT_SIZE ;
            p_letter->halfwidth = (GrCharWidth(gstate, letter)>>17) ;
            do {
               p_letter->color = RandomNumber() & 15 ;
            } while (p_letter->color == C_LIGHT_BLUE) ;
            do {
                p_letter->x =
                    TOWER_LEFT_X + 40 +
                    (RandomNumber() % (TOWER_RIGHT_X-TOWER_LEFT_X-80)) ;
                p_letter->x = (p_letter->x & 0xFFF8)+1 ;
            } while (IsLetterSpotTaken(p_letter->x, 0, i)) ;
            GrDestroyState(gstate) ;
        }
    }
}

/*-------------------------------------------------------------------------
 | Routine:  DrawAmmo
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Draws the numbers at the bottom left and right showing the remaining
 |    ammo for shots.  The number is the same on the left and right.
 |
 | Inputs:
 |    GStateHandle gstate         -- Handle to drawing surface
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  03/30/99  Created
 |
 *-----------------------------------------------------------------------*/
void DrawAmmo(GStateHandle gstate)
{
    char buffer[10] ;
    word i, width = 0 ;

    GrSetFont(gstate, DEFAULT_FONT_ID, MakeWWFixed(AMMO_POINT_SIZE));
    sprintf(buffer, "%d", G_ammoLeft) ;

    for (i=0; buffer[i]; i++)
       width += (((dword)GrCharWidth(gstate, buffer[i]))>>16L) ;

    width >>= 1 ;
    GrSetAreaColor(gstate, CF_INDEX, (G_isColor)?C_LIGHT_GREEN:C_WHITE, 0, 0) ;
    GrFillRect(
        gstate,
        AMMO_LEFT_X-10, AMMO_LEFT_Y,
        AMMO_LEFT_X+12, AMMO_LEFT_Y+AMMO_POINT_SIZE+3) ;
    GrFillRect(
        gstate,
        AMMO_RIGHT_X-10, AMMO_RIGHT_Y,
        AMMO_RIGHT_X+12, AMMO_RIGHT_Y+AMMO_POINT_SIZE+3) ;
    GrDrawText(gstate, 1+AMMO_LEFT_X-width, 1+AMMO_LEFT_Y, buffer, 0) ;
    GrDrawText(gstate, 1+AMMO_RIGHT_X-width, 1+AMMO_RIGHT_Y, buffer, 0) ;

}

/*-------------------------------------------------------------------------
 | Routine:  DrawBuilding
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Draws a single building type after erasing it in place.
 |    Assumed:  Art bitmap is locked!
 |
 | Inputs:
 |    GStateHandle gstate         -- Handle to drawing surface
 |    word i                      -- Index to building to draw
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  03/30/99  Created
 |
 *-----------------------------------------------------------------------*/
void DrawBuilding(GStateHandle gstate, word i)
{
    Bitmap *p_bitmap ;
    static optr buildingBitmapArray[2][4] = {
        {
        @ShieldedCityBitmapMoniker,
        @CityBitmapMoniker,
        @BoomBitmapMoniker,
        @DeadCityBitmapMoniker
        },
        {
        @ColorShieldedCityBitmapMoniker,
        @ColorCityBitmapMoniker,
        @ColorBoomBitmapMoniker,
        @ColorDeadCityBitmapMoniker
        }
    } ;
    word array = (G_isColor)?1:0 ;

    MemLock(OptrToHandle(buildingBitmapArray[array][G_buildingArray[i]])) ;
    p_bitmap = (Bitmap *)LMemDeref(buildingBitmapArray[array][G_buildingArray[i]]) ;
    GrSetAreaColor(gstate, CF_INDEX, (G_isColor)?C_LIGHT_BLUE:C_WHITE, 0, 0) ;
    GrFillRect(
        gstate,
        G_buildingsX[i], BUILDINGS_Y-p_bitmap->B_height,
        G_buildingsX[i]+p_bitmap->B_width, BUILDINGS_Y) ;
    GrDrawImage(
        gstate,
        G_buildingsX[i], BUILDINGS_Y-p_bitmap->B_height,
        IBS_1,
        p_bitmap) ;
    MemUnlock(OptrToHandle(buildingBitmapArray[array][G_buildingArray[i]])) ;
}

/*-------------------------------------------------------------------------
 | Routine:  DrawCompleteScreen
 *-------------------------------------------------------------------------
 |
 | Description:
 |    When part of the view is exposed, the whole screen is redrawn.
 |
 | Inputs:
 |    GStateHandle gstate         -- Handle to drawing surface
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  03/30/99  Created
 |
 *-----------------------------------------------------------------------*/
void DrawCompleteScreen(GStateHandle gstate)
{
    Bitmap *p_bitmap ;
    word i ;
    optr bitmap = (G_isColor)?@ColorBaseBitmapMoniker:@BaseBitmapMoniker;

    MemLock(OptrToHandle(bitmap)) ;

    p_bitmap = (Bitmap *)LMemDeref(bitmap) ;
    GrDrawImage(
        gstate,
        0, FIELD_HEIGHT-((Bitmap *)p_bitmap)->B_height,
        IBS_1,
        p_bitmap) ;
    for (i=0; i<NUM_BUILDINGS; i++)
        DrawBuilding(gstate, i) ;
    DrawAmmo(gstate) ;
    DrawShooting(gstate, TRUE) ;
    DrawExplode(gstate, TRUE) ;
    DrawLetters(gstate) ;
    MemUnlock(OptrToHandle(bitmap)) ;
}

/*-------------------------------------------------------------------------
 | Routine:  DrawExplode
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Draw the current explosion at its given location.
 |    Assumed:  Art bitmap is locked!
 |
 | Inputs:
 |    GStateHandle gstate         -- Handle to drawing surface
 |    Boolean doDraw              -- TRUE=draw, FALSE=erase
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  03/30/99  Created
 |
 *-----------------------------------------------------------------------*/
void DrawExplode(GStateHandle gstate, Boolean doDraw)
{
    Bitmap *p_bitmap ;
    optr bitmap = (G_isColor)?@ColorShotBitmapMoniker:@ShotBitmapMoniker;

    if ((G_isColor) && (!doDraw))
        bitmap = @ColorClearShotBitmapMoniker ;

    if (G_explodeX)  {
        MemLock(OptrToHandle(bitmap)) ;
        p_bitmap = (Bitmap *)LMemDeref(bitmap) ;
        GrSaveState(gstate) ;

        if (!G_isColor)  {
            if (doDraw)
                GrSetMixMode(gstate, MM_COPY);
            else
                GrSetMixMode(gstate, MM_CLEAR);
        }

        GrDrawBitmap(
            gstate,
            G_explodeX-(p_bitmap->B_width>>1),
            G_explodeY-(p_bitmap->B_height>>1),
            p_bitmap,
            NULL) ;
        GrRestoreState(gstate) ;
        MemUnlock(OptrToHandle(bitmap)) ;
    }
}

/*-------------------------------------------------------------------------
 | Routine:  DrawLetter
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Draw a single letter erasing the old placement and drawing to the
 |    new place.
 |
 | Inputs:
 |    GStateHandle gstate         -- Handle to drawing surface
 |    word index                  -- Index to index to draw
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  03/30/99  Created
 |
 *-----------------------------------------------------------------------*/
void DrawLetter(GStateHandle gstate, word index)
{
    T_letter *p_letter ;

    p_letter = G_letterArray + index ;
    GrSetTextStyle(gstate, TS_BOLD, 0) ;

    if (p_letter->oldX)  {
        GrSetTextColor(gstate, CF_INDEX, (G_isColor)?C_LIGHT_BLUE:C_WHITE, 0, 0) ;
        if (G_isColor)  {
            GrDrawText(
                gstate,
                p_letter->oldX-p_letter->halfwidth+1,
                p_letter->oldY+1,
                &p_letter->letter,
                1) ;
        }
        GrDrawText(
            gstate,
            p_letter->oldX-p_letter->halfwidth,
            p_letter->oldY,
            &p_letter->letter,
            1) ;
        p_letter->oldX = 0 ;
    }
    if (p_letter->x)  {
        if (G_isColor)  {
            GrSetTextColor(gstate, CF_INDEX, C_BLACK, 0, 0) ;
            GrDrawText(gstate,
                p_letter->x-p_letter->halfwidth+1,
                p_letter->y+1,
                &p_letter->letter,
                1) ;
        }
        GrSetTextColor(gstate, CF_INDEX, (G_isColor)?p_letter->color:C_BLACK, 0, 0) ;
        GrDrawText(gstate,
            p_letter->x-p_letter->halfwidth,
            p_letter->y,
            &p_letter->letter,
            1) ;
    }
}

/*-------------------------------------------------------------------------
 | Routine:  DrawLetters
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Draw all the letters falling on the screen.
 |
 | Inputs:
 |    GStateHandle gstate         -- Handle to drawing surface
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  03/30/99  Created
 |
 *-----------------------------------------------------------------------*/
void DrawLetters(GStateHandle gstate)
{
    word i ;
    GrSaveState(gstate) ;
    GrSetFont(gstate, GAME_FONT_ID, MakeWWFixed(GAME_FONT_SIZE));
    for (i=0; i<MAX_LETTERS; i++)  {
        if ((G_letterArray[i].x) || (G_letterArray[i].oldX))
            DrawLetter(gstate, i) ;
    }
    GrRestoreState(gstate) ;
}

/*-------------------------------------------------------------------------
 | Routine:  DrawShooting
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Draws a shot from one of the towers (basically a dotted line)
 |
 | Inputs:
 |    GStateHandle gstate         -- Handle to drawing surface
 |    Boolean doDraw              -- Draw or clear?  TRUE=draw
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  03/30/99  Created
 |
 *-----------------------------------------------------------------------*/
void DrawShooting(GStateHandle gstate, Boolean doDraw)
{
    if (G_shotLineFromX)  {
        GrSaveState(gstate) ;
        if (G_isColor)  {
            if (doDraw)  {
                GrSetLineColor(gstate, CF_INDEX, C_LIGHT_GREEN, 0, 0) ;
            } else  {
                GrSetLineColor(gstate, CF_INDEX, C_LIGHT_BLUE, 0, 0) ;
            }
        } else {
            if (doDraw)  {
                GrSetLineColor(gstate, CF_INDEX, C_BLACK, 0, 0) ;
            } else  {
                GrSetLineColor(gstate, CF_INDEX, C_WHITE, 0, 0) ;
            }
            GrSetLineStyle(gstate, LS_DOTTED, 0, NULL, 0) ;
        }

        GrDrawLine(
            gstate,
            G_shotLineFromX,
            G_shotLineFromY,
            G_shotLineToX,
            G_shotLineToY) ;
        GrRestoreState(gstate) ;
    }
}

/*-------------------------------------------------------------------------
 | Routine:  FindBuildingAtX
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Find the tallest building that the given X position (and width)
 |    touches.
 |
 | Inputs:
 |    word x                      -- center of width
 |    word halfwidth              -- half of width to check
 |
 | Outputs:
 |    word                        -- Index into G_buildingArray or
 |                                   INDEX_NONE if none found.
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  03/31/99  Created
 |
 *-----------------------------------------------------------------------*/
word FindBuildingAtX(word x, word halfwidth)
{
    word left, right ;
    word i ;
    word width ;
    word bx ;
    word best = INDEX_NONE ;
    word bestType = INDEX_NONE ;

    left = x-halfwidth ;
    right = x+halfwidth ;

    MemLock(OptrToHandle(@CityBitmapMoniker)) ;
    width = ((Bitmap *)LMemDeref(@CityBitmapMoniker))->B_width ;
    MemUnlock(OptrToHandle(@CityBitmapMoniker)) ;

    for (i=0; i<NUM_BUILDINGS; i++)  {
        bx = G_buildingsX[i] ;

        /* See if we are touching the building */
        if ((right >= bx) && (left <= (bx + width)))  {
            if (G_buildingArray[i] < bestType)  {
                best = i ;
                bestType = G_buildingArray[i] ;
            }
        }
    }

    return best ;
}

/*-------------------------------------------------------------------------
 | Routine:  FindFreeLetter
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Find a free letter slot (if any)
 |
 | Outputs:
 |    word                        -- Index in G_letterArray or INDEX_NONE
 |                                   for NONE.
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  03/30/99  Created
 |
 *-----------------------------------------------------------------------*/
word FindFreeLetter(void)
{
    word i ;

    for (i=0; i<MAX_LETTERS; i++)  {
        if ((G_letterArray[i].x == 0) && (G_letterArray[i].oldX == 0))
            break ;
    }
    if (i == MAX_LETTERS)
        i = INDEX_NONE ;

    return i ;
}

/*-------------------------------------------------------------------------
 | Routine:  FindAnyUsedLetter
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Determine if any letters are being used
 |
 | Outputs:
 |    Boolean                     -- TRUE if any are used, else FALSE
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  05/27/99  Created
 |
 *-----------------------------------------------------------------------*/
Boolean FindAnyUsedLetter(void)
{
    word i ;
    Boolean used = FALSE ;

    for (i=0; i<MAX_LETTERS; i++)  {
        if ((G_letterArray[i].x != 0) || (G_letterArray[i].oldX != 0))  {
            used = TRUE ;
            break ;
        }
    }

    return used ;
}

/*-------------------------------------------------------------------------
 | Routine:  FindLowestLetter
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Find the letter falling on the screen that is lowest or pass
 |    back a bad value if none is found.
 |
 | Outputs:
 |    word                        -- Index in G_letterArray or INDEX_NONE
 |                                   for NONE.
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  03/31/99  Created
 |
 *-----------------------------------------------------------------------*/
word FindLowestLetter(char letter)
{
    word i ;
    sword lowest = -200 ;
    word lowestIndex = INDEX_NONE ;
    T_letter *p_letter ;

    /* Go through all the falling letters (ignored the empty spots) */
    /* and determine the if it has the same letter and if it is the */
    /* lowest on the screen */
    for (i=0, p_letter=G_letterArray; i<MAX_LETTERS; i++, p_letter++)  {
        if ((p_letter->x) && (p_letter->letter == letter))  {
            if (p_letter->y > lowest)  {
                lowest = p_letter->y ;
                lowestIndex = i ;
            }
        }
    }

    return lowestIndex ;
}

/*-------------------------------------------------------------------------
 | Routine:  IsAnyBuildingBlowingUp
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Check if any building is being blown
 |
 | Outputs:
 |    Boolean                     -- TRUE if any building in boom state,
 |                                   else FALSE
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  05/27/99  Created
 |
 *-----------------------------------------------------------------------*/
Boolean IsAnyBuildingBlowingUp(void)
{
    word i ;

    for (i=0; i<NUM_BUILDINGS; i++)
        if (G_buildingArray[i] == BUILDING_STATE_BOOM)
            return TRUE ;

    return FALSE ;
}

/*-------------------------------------------------------------------------
 | Routine:  IsLetterSpotTaken
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Check if any letter is already at the given location.
 |
 | Inputs:
 |    sword x                     -- X position of letter
 |    sword y                     -- Y position of letter
 |    word selfIndex              -- Index into G_lettersArray of current
 |                                   letter being checked.
 |
 | Outputs:
 |    Boolean                     -- TRUE if letter found there, else
 |                                   FALSE ;
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  03/31/99  Created
 |
 *-----------------------------------------------------------------------*/
Boolean IsLetterSpotTaken(sword x, sword y, word selfIndex)
{
    Boolean isFound = FALSE ;
    word i ;
    T_letter *p_letter ;

    y += 1+LETTERS_POINT_SIZE ;
    for (i=0, p_letter=G_letterArray; i<MAX_LETTERS; i++, p_letter++)  {
        if (i==selfIndex)
            continue ;
        if ((p_letter->x == x) && (p_letter->y <= y))  {
            isFound = TRUE ;
            break ;
        }
    }

    return isFound ;
}

/*-------------------------------------------------------------------------
 | Routine:  IsLevelDone
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Determine if the level has been completed.
 |
 | Outputs:
 |    Boolean                     -- TRUE if level completed, else FALSE
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  03/31/99  Created
 |
 *-----------------------------------------------------------------------*/
Boolean IsLevelDone(void)
{
    if (G_forceLevelComplete == TRUE)  {
        G_forceLevelComplete = FALSE ;
        return TRUE ;
    }

    if ((!FindAnyUsedLetter()) &&
            (!IsAnyBuildingBlowingUp()) &&
                (G_lettersToPresent[G_numPresented] == '\0'))
        return TRUE ;
    return FALSE ;
}

/*-------------------------------------------------------------------------
 | Routine:  IsPlayerDead
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Determine if all the buildings have been destroyed.
 |
 | Outputs:
 |    Boolean                     -- TRUE if player is dead, else FALSE
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  03/31/99  Created
 |
 *-----------------------------------------------------------------------*/
Boolean IsPlayerDead(void)
{
    word i ;

    /* All buildings should be up and/or shielded */
    for (i=0; i<NUM_BUILDINGS; i++)
        if (G_buildingArray[i] != BUILDING_STATE_DEAD)
            return FALSE ;

    return TRUE ;
}

/*-------------------------------------------------------------------------
 | Routine:  LoadSounds
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Load the sounds to be played later.
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  04/01/99  Created
 |
 *-----------------------------------------------------------------------*/
void LoadSounds(void)
{
    FileHandle file ;

    ResetSound() ;
    memset(G_sounds, 0, sizeof(G_sounds)) ;

    FilePushDir() ;
    FileSetCurrentPath(SP_PUBLIC_DATA, "laserl");
    file = FileOpen("sounds.dat", FILE_DENY_NONE|FILE_ACCESS_R) ;
    if (file)  {
        FileRead(file, &G_sounds, sizeof(G_sounds), FALSE) ;
        FileClose(file, FALSE) ;
    }
    FilePopDir() ;
}

/*-------------------------------------------------------------------------
 | Routine:  MakeLettersFall
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Update the placement of the letters by making them step down and
 |    take care of any interactions.
 |
 | Inputs:
 |    GStateHandle gstate         -- Handle to drawing surface
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  03/30/99  Created
 |
 *-----------------------------------------------------------------------*/
void MakeLettersFall(GStateHandle gstate, Boolean doFall)
{
    word i ;
    T_letter *p_letter ;
    word building ;
    word num ;
    Boolean anyLettersFall = FALSE ;

    p_letter = G_letterArray ;
    for (i=0; i<MAX_LETTERS; i++, p_letter++)  {
        if (p_letter->x)  {
            p_letter->oldX = p_letter->x ;
            p_letter->oldY = p_letter->y ;
            if (doFall)
                p_letter->y += 2*(LETTER_STEP_Y_RATE+(G_level/5)) ;
            anyLettersFall = TRUE ;
            if (((sword)p_letter->y) >= ((sword)LETTER_BOTTOM_Y))  {
                /* GONE */
                p_letter->x = 0 ;
            } else if (((sword)p_letter->y) >= ((sword)(LETTER_CHECK_Y)))  {
                /* Which building are we touching? */
                building = FindBuildingAtX(
                               p_letter->x,
                               1+p_letter->halfwidth) ;
                if (building != INDEX_NONE)  {
                    switch(G_buildingArray[building])  {
                        case BUILDING_STATE_SHIELDED:
                            G_buildingArray[building] = BUILDING_STATE_NORMAL ;
                            DrawBuilding(gstate, building) ;
                            p_letter->x = 0 ;
                            PlaySimpleSound(SOUND_SHIELD_DESTROYED, 90) ;
                            break ;
                        case BUILDING_STATE_NORMAL:
                            G_buildingArray[building] = BUILDING_STATE_BOOM ;
                            G_buildingTiming[building] = UNITS_BOOM_STAYS ;
                            DrawBuilding(gstate, building) ;
                            p_letter->x = 0 ;
                            PlaySimpleSound(SOUND_CITY_DESTROYED, 100) ;
                            break ;
                        case BUILDING_STATE_BOOM:
                            p_letter->x = 0 ;
                            break ;
                        case BUILDING_STATE_DEAD:
                            if (p_letter->y >= LETTER_CHECK_Y+24)  {
                                p_letter->x = 0 ;
                            }
                            break ;
                    }
                }
            }
        }
    }
    if ((anyLettersFall) && (doFall))
        PlaySimpleSound(SOUND_LETTERS_ADVANCE, 5) ;

    /* Is it time to add a new letter */
    G_countTilNextAddition-- ;
    if (G_countTilNextAddition == 0)  {
        /* Add a new letter to the screen */
        num = 1+RandomNumber()%(G_numPerAdd[G_gameDensity]) ;
        for (i=0; i<num; i++)
            AddFallingLetter() ;

        /* Figure out when the next one should be added */
        G_countTilNextAddition = 1+(RandomNumber()&1) +
                                     (GAME_DENSITY_VERY_HIGH-G_gameDensity) ;
    }

    DrawLetters(gstate) ;
}

/*-------------------------------------------------------------------------
 | Routine:  RecordShootRequest
 *-------------------------------------------------------------------------
 |
 | Description:
 |    A shooting action has been requested.  First record it for later.
 |
 | Inputs:
 |    char character              -- character being shot
 |    Boolean isLeftTower         -- TRUE for left tower, else FALSE for
 |                                   right tower.
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  03/31/99  Created
 |
 *-----------------------------------------------------------------------*/
void RecordShootRequest(char character, Boolean isLeftTower)
{
    /* Only add if we have room */
    if (G_shootRequestCount < MAX_SHOOT_REQUESTS)  {
        /* Append to the end of the list */
        G_shootRequestArray[G_shootRequestCount].character = character ;
        G_shootRequestArray[G_shootRequestCount].isLeftTower = isLeftTower ;
        G_shootRequestCount++ ;
    }
}

/*-------------------------------------------------------------------------
 | Routine:  PlayerShoots
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Player has hit a key to shoot from a tower.
 |
 | Inputs:
 |    char character              -- character being shot
 |    Boolean isLeftTower         -- TRUE for left tower, else FALSE for
 |                                   right tower.
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  03/31/99  Created
 |
 *-----------------------------------------------------------------------*/
void PlayerShoots(char character, Boolean isLeftTower)
{
    word index ;

    /* Only shoot if we have ammo */
    if (G_ammoLeft)  {
        PlaySimpleSound(SOUND_SHOOTS, 10) ;
        G_ammoLeft-- ;
        if (isLeftTower)  {
            G_shotLineFromX = TOWER_LEFT_X ;
            G_shotLineFromY = TOWER_LEFT_Y ;
        } else {
            G_shotLineFromX = TOWER_RIGHT_X ;
            G_shotLineFromY = TOWER_RIGHT_Y ;
        }

        index = FindLowestLetter(character) ;
        if (index == INDEX_NONE)  {
            /* Missed.  Shoot randomly at the top of the screen */
            G_shotLineToX = 40+(RandomNumber()%(FIELD_WIDTH-80)) ;
            G_shotLineToY = 1 ;
            PlaySimpleSound(SOUND_SHOOTS_MISS, 20) ;
        } else {
            /* Hit.  Center the explosion there. */
            G_shotLineToX =
                G_explodeX =
                    G_letterArray[index].x ;
            G_shotLineToY =
                G_explodeY =
                    G_letterArray[index].y + (LETTERS_POINT_SIZE>>1) ;

            /* Remove the letter */
            G_letterArray[index].oldX = G_letterArray[index].x ;
            G_letterArray[index].oldY = G_letterArray[index].y ;
            G_letterArray[index].x = 0 ;
            PlaySimpleSound(SOUND_SHOOTS_HIT, 20) ;
        }
    } else {
        PlaySimpleSound(SOUND_OUT_OF_AMMO, 50) ;
    }
}

/*-------------------------------------------------------------------------
 | Routine:  PlayFrequency
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Play a frequency on the PC Speaker (with logical checks)
 |
 | Inputs:
 |    word freq                   -- Frequency to use (per GEOS sound.h)
 |    word duration               -- Length of time in 1/60ths of a second
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  04/01/99  Created
 |
 *-----------------------------------------------------------------------*/
void PlayFrequency(word freq, word duration)
{
    static word lastFreq = 0xFFFF ;

    if (freq == lastFreq)
        if (RandomNumber()&1)
            freq-- ;
        else
            freq++ ;
    lastFreq = freq ;
    if (G_isSoundOn)
        UserStandardSound(SST_CUSTOM_NOTE, freq, duration) ;
}

/*-------------------------------------------------------------------------
 | Routine:  PlaySimpleSound
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Plays a banked sound out the PC speaker.  Actually just sets up
 |    the sound for playing.
 |
 | Inputs:
 |    word soundId                -- Index into G_sounds
 |    word priority               -- 0-65535 priority level if the given
 |                                   sound doesn't have a priority already.
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  04/01/99  Created
 |
 *-----------------------------------------------------------------------*/
void PlaySimpleSound(word soundId, word priority)
{
    T_simplePCSound *p_sound ;
    word i ;
    word best = INDEX_NONE ;
    word bestPriority = 0xFFFF ;
    T_soundState *p_channel ;

    p_sound = G_sounds + soundId ;
    if (p_sound->priority)
        priority = p_sound->priority ;

    /* Find the best free channel or one with a lower priority */
    for (i=0, p_channel=G_channelArray;
         i<MAX_SOUND_CHANNELS;
         i++, p_channel++)  {
        /* Take emty channels immediately */
        if (p_channel->soundNum == INDEX_NONE)  {
            best = i ;
            bestPriority = 0xFFFF ;
            break ;
        }

        /* Otherwise, look for the lowest priority sound */
        if (p_channel->priority <= bestPriority)  {
            best = i ;
            bestPriority = p_channel->priority ;
        }
    }

    /* Only process the sound if we found a channel */
    /* and the lowest priority sound is lower or equal to what we */
    /* want to play */
    if ((best != INDEX_NONE) &&
        ((bestPriority <= priority) || (bestPriority==0xFFFF)))  {
        p_channel = G_channelArray + best ;
        p_channel->soundNum = soundId ;
        p_channel->pos = 0 ;
        p_channel->priority = priority ;
    }
}

/*-------------------------------------------------------------------------
 | Routine:  PrepareNewGame
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Setup a new game's data.
 |
 | Inputs:
 |    Boolean isNewBuildings      -- TRUE if all new buildings, else FALSE
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  03/30/99  Created
 |
 *-----------------------------------------------------------------------*/
void PrepareNewGame(Boolean isNewBuildings)
{
    G_ammoLeft = 99 ;
    memset(G_letterArray, 0, sizeof(G_letterArray)) ;
    if (isNewBuildings)
        memset(G_buildingArray, BUILDING_STATE_SHIELDED, sizeof(G_buildingArray)) ;
    memset(G_buildingTiming, 0, sizeof(G_buildingTiming)) ;
    PrepareNewLetters() ;

    /* Set up the timing */
    G_countPerUpdate = (1+GAME_SPEED_VERY_FAST - G_gameSpeed) *
                           (4/GAME_SMALLEST_TIME_UNIT) ;
/*    G_countPerUpdate *= 2 ; */
    G_countTilNextUpdate = (90/GAME_SMALLEST_TIME_UNIT) ;
    G_countTilNextAddition = 1 ;
}

/*-------------------------------------------------------------------------
 | Routine:  PrepareNewLetters
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Setup the letters to present as the game progresses (for the current
 |    level).
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  03/30/99  Created
 |
 *-----------------------------------------------------------------------*/
void PrepareNewLetters(void)
{
    word num ;
    char c ;
    word i ;
    word n ;
    word exercise ;
    Boolean isRandom = TRUE ;
    word len ;

    num = 60 + (2*(G_level-1)) ;

    exercise = (G_level-1) ;
    if (exercise < 10)  {
        exercise = (G_level-1) * 3 ;
    } else {
        exercise = (exercise-10)+30 ;
    }
    RetrieveExercise(exercise % G_numExercises) ;
    len = strlen(G_exerciseString) ;
    for (n=0; n<num; )  {
        if (isRandom)  {
            /* PIck a random location */
            i = RandomNumber() % len ;

            /* Go to the start of the word */
            /* Go back to the previous space (or start) */
            while (!isspace(G_exerciseString[i]) && (i))
                i-- ;

            /* Go forward past the space */
            if (isspace(G_exerciseString[i]))
                i++ ;

            isRandom = FALSE ;
        }

        /* Check to see if we are not using text letters. */
        c = G_exerciseString[i] ;
        if ((!c) || (isspace(c)) || (iscntrl(c)))  {
            isRandom = TRUE ;
            continue ;
        }
        G_lettersToPresent[n++] = c ;
        i++ ;
    }
    G_lettersToPresent[n] = '\0' ;
    G_numPresented = 0 ;
/*
    word num ;
    word level ;
    char *p_high ;
    char *p_low ;
    word highCount ;
    word lowCount ;
    word i ;
    word h, l ;
    word p = RandomNumber() ;

    level = G_level-1 ;
    if (level >= 19)
        level = 18 ;

    num = 60+(2*level) ;
    p_high = G_levelKeys[level][0] ;
    p_low = G_levelKeys[level][1] ;
    highCount = strlen(p_high) ;
    lowCount = strlen(p_low) ;

    h = 0 ;
    l = 0 ;
    for (i=0; i<num; i++)  {
        p += RandomNumber() ;
        if ((p>>8)&3)  {
            h += RandomNumber()%highCount ;
            while (h >= highCount)
                h -= highCount ;
            G_lettersToPresent[i] = p_high[h] ;
        } else {
            l += RandomNumber()%lowCount ;
            while (l >= lowCount)
                l -= lowCount ;
            G_lettersToPresent[i] = p_low[l] ;
        }
    }
    G_lettersToPresent[i] = '\0' ;
//    strcpy(G_lettersToPresent, "PjkjkjkdfdfdfjdjfdkfjdkfjdkfjdkkdkfjT") ;
*/
}

/*-------------------------------------------------------------------------
 | Routine:  RandomNumber
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Generate a RandomNumber of value 0 to 65535.
 |
 | Outputs:
 |    word                        -- 0 to 65535 number
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  03/31/99  Created
 |
 *-----------------------------------------------------------------------*/
word RandomNumber(void)
{
    static word rand1 = 0xf32d ;
    static word rand2 = 0x0103 ;
    static word rand3 = 0x4326 ;
    static word rand4 = 0x4878 ;
    word old ;

    old = rand1 ;
    rand1 = rand2 ;
    rand2 = rand3 ;
    rand3 = rand4 ;
    rand4 ^= old^rand1^rand2^rand3 ;
    rand3 += rand1+rand2+rand4 ;
    rand4 >>= 1 ;
    rand4 |= (old&0x8000) ;
    rand4 += TimerGetCount() ;
    rand2 ^= 0xFFFF ;
    return old ;
}

/*-------------------------------------------------------------------------
 | Routine:  ResetSound
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Reset the sound effects
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  04/01/99  Created
 |
 *-----------------------------------------------------------------------*/
void ResetSound(void)
{
    word i ;

    for (i=0; i<MAX_SOUND_CHANNELS; i++)  {
        G_channelArray[i].soundNum = INDEX_NONE ;
        G_channelArray[i].pos = 0 ;
        G_channelArray[i].priority = 0 ;
    }
}

/*-------------------------------------------------------------------------
 | Routine:  ShootFirstRecorded
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Shoot if there are any recorded events.
 |
 | Outputs:
 |    Boolean                     -- TRUE if shot occured.
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  03/31/99  Created
 |
 *-----------------------------------------------------------------------*/
Boolean ShootFirstRecorded(void)
{
    Boolean didShot = FALSE ;

    if (G_shootRequestCount)  {
        didShot = TRUE ;
        PlayerShoots(
            G_shootRequestArray[0].character,
            G_shootRequestArray[0].isLeftTower) ;
        G_shootRequestCount-- ;
        if (G_shootRequestCount)  {
            memcpy(
                G_shootRequestArray,
                G_shootRequestArray+1,
                sizeof(G_shootRequestArray[0])*G_shootRequestCount) ;
        }
    }

    return didShot ;
}

/*-------------------------------------------------------------------------
 | Routine:  SoundStart
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Start the sound system (mainly timer)
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  04/01/99  Created
 |
 *-----------------------------------------------------------------------*/
void SoundStart(void)
{
    if (!G_soundTimer)
        G_soundTimer = TimerStart(
                       TIMER_EVENT_CONTINUAL,
                       ConstructOptr(GeodeGetCodeProcessHandle(), 0),
                       1,
                       MSG_GAME_UPDATE_SOUND,
                       1,
                       &G_timerId) ;
}

/*-------------------------------------------------------------------------
 | Routine:  SoundStop
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Stops the sound system (mainly timer)
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  04/01/99  Created
 |
 *-----------------------------------------------------------------------*/
void SoundStop(void)
{
    TimerStop(G_soundTimer, G_soundTimerId) ;
    G_soundTimer = NullHandle ;
}

/*-------------------------------------------------------------------------
 | Routine:  SoundsWaitUntilDone
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Updates the sound effects until we are done.  Also stops the sound
 |    system.
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  04/01/99  Created
 |
 *-----------------------------------------------------------------------*/
void SoundsWaitUntilDone(void)
{
    word i ;
    Boolean isSoundPlaying ;

    SoundStop() ;

    do {
        isSoundPlaying = FALSE ;
        for (i=0; i<MAX_SOUND_CHANNELS; i++)  {
            if (G_channelArray[i].soundNum != INDEX_NONE)  {
                isSoundPlaying = TRUE ;
                break ;
            }
        }

        /* Stop if finally no sound is playing */
        if (!isSoundPlaying)
            break ;
        UpdateSound() ;
        TimerSleep(1) ;
    } while (1) ;
}

/*-------------------------------------------------------------------------
 | Routine:  UpdateBuildingAnimations
 *-------------------------------------------------------------------------
 |
 | Description:
 |    See if a building needs to be updated on its animation.
 |
 | Inputs:
 |    GStateHandle gstate         -- Drawing handle
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  03/31/99  Created
 |
 *-----------------------------------------------------------------------*/
void UpdateBuildingAnimations(GStateHandle gstate)
{
    word i ;

    for (i=0; i<NUM_BUILDINGS; i++)  {
        if (G_buildingTiming[i])   {
            if (--G_buildingTiming[i])
                continue ;

            switch (G_buildingArray[i])  {
                case BUILDING_STATE_BOOM:
                    G_buildingArray[i] = BUILDING_STATE_DEAD ;
                    DrawBuilding(gstate, i) ;
                    break ;
                default:
                    break ;
            }
        }
    }
}

/*-------------------------------------------------------------------------
 | Routine:  UpdateSound
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Update the sound effects using the current settings.
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  04/01/99  Created
 |
 *-----------------------------------------------------------------------*/
void UpdateSound(void)
{
    static word channel = 0 ;
    T_soundState *p_state ;
    T_simplePCSound *p_sound ;
    word sample ;

    p_state = G_channelArray + channel ;
    if (p_state->soundNum != INDEX_NONE)  {
        p_sound = G_sounds + p_state->soundNum ;
        sample = p_sound->samples[p_state->pos] ;
        if (sample > SOUND_FREQ_CUTOFF)  {
            /* Play that frequency */
            PlayFrequency(sample, 1) ;
            p_state->pos++ ;
        } else if (sample == 0)  {
            /* Sound is done.  Stop here */
            p_state->soundNum = INDEX_NONE ;
            p_state->priority = 0 ;
            p_state->pos = 0 ;
        } else {
            p_state->pos++ ;
        }
    }

    /* Go to the next channel next time */
    channel = ((channel+1)%MAX_SOUND_CHANNELS) ;
}

/***************************************************************************
 *  END OF FILE:  LASERL.GOC                                               *
 ***************************************************************************/
