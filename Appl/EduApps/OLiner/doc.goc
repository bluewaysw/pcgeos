/***********************************************************************
 *
 *
 * PROJECT: Breadbox Outliner
 * FILE:        doc.goc
 * AUTHOR:  John F. Howard,   05/03
 *
 * DESCRIPTION:
 *  This file has the doc class for the application.
 *
 *
 ***********************************************************************/


/* ----------------------------------------------------------------------------
	Include files
-----------------------------------------------------------------------------*/
@include "oliner.goh"
@start TreeIconsResource, data;
	@include "art\tree.goh"
@end TreeIconsResource;

@extern object OLApp;
@extern object OLSpellControl;
@extern object CardDList;
@extern object CardTitle;
@extern object CardText;
@extern object CardApply;
@extern object CreateMTopicButton;
@extern object CreateSTopicButton;
@extern object CreateMTopicBox;
@extern object MTopicText;
@extern object CreateSTopicBox;
@extern object STopicText;
@extern object DeleteTopicTrigger;
@extern object DeleteCardTrigger;
@extern object MoveTopicTrigger;
@extern object MoveCardTrigger;
@extern object MTopicTrigger;
@extern object STopicTrigger;
@extern object NewCardButton;
@extern object SaveCardButton;
@extern object FindMenuItem;
@extern object PrintPreviewButton;

@extern object NewMTopicTool;
@extern object NewSTopicTool;
@extern object EditTopicTool;
@extern object MoveTopicTool;
@extern object DelTopicTool;
@extern object NewCardTool;
@extern object SaveCardTool;
@extern object DelCardTool;
@extern object MoveCardTool;
@extern object FindTool;
@extern object PrintPrevTool;

@extern object EditTopicTrigger;
@extern object EditTopicDBox;
@extern object ETopicText;
@extern object ListCreationDate;
@extern object ListModificationDate;

@extern chunk BDBCreateError;
@extern chunk BDBCreateIndexError;
@extern chunk ErrMsgCouldntCreateNewRec;
@extern chunk ErrMsgCouldntSaveRec;
@extern chunk BDBGetRecordError;
@extern chunk ConfirmDeleteCard;
@extern chunk ConfirmDeleteFullTopic;
@extern chunk ConfirmDeleteEmptyTopic;
@extern chunk AlertFullTopicMsg;
@extern chunk AlertCardTitleMsg;

@extern visMoniker InTopicMoniker;
@extern visMoniker BelowTopicMoniker;
@extern visMoniker CancelAddMoniker;
@extern chunk WhereToAddMsg;
@extern chunk AddLevelWarningMsg;
@extern chunk TopicText;
@extern chunk CardText1;


@classdecl  OLDocumentClass;

// methods in move.goc
@extern method OLDocumentClass, MSG_OLINER_DOC_OPEN_MOVE_BOX;
@extern method OLDocumentClass, MSG_OLINER_DOC_SELECT_MOVE_DESTINATION;
@extern method OLDocumentClass, MSG_OLINER_DOC_MOVE_ITEM_APPLY;
@extern method OLDocumentClass, MSG_OLINER_DOC_MOVE_ITEM_INTO;
@extern method OLDocumentClass, MSG_OLINER_DOC_MOVE_ITEM_BELOW;
@extern method OLDocumentClass, MSG_OLINER_DOC_MOVE_ITEM_ABOVE;
@extern method OLDocumentClass, MSG_OLINER_DOC_MOVE_ITEM_CANCEL;

// methods in find.goc
@extern method OLDocumentClass, MSG_OLINER_DOC_OPEN_FIND;
@extern method OLDocumentClass, MSG_OLINER_DOC_SEARCH_OUTLINE;

// methods in ecall.goc
@extern method OLDocumentClass, MSG_OLINER_DOC_EXPAND_ALL_TOPICS;
@extern method OLDocumentClass, MSG_OLINER_DOC_CONTRACT_ALL_TOPICS;

// methods in pprev.goc
@extern method OLDocumentClass, MSG_OLINER_DOC_OPEN_PRINT_PREVIEW;
@extern method OLDocumentClass, MSG_OLINER_DOC_PRINT_PREVIEW;

/* ----------------------------------------------------------------------------
	OLDocumentClass code
-----------------------------------------------------------------------------*/

/***********************************************************************
 *
 * MESSAGE: MSG_GEN_DOCUMENT_INITIALIZE_DOCUMENT_FILE for
 *                                    OLDocumentClass
 *
 *
 * DESCRIPTION: Called to initialize a newly created document.
 *
 *
 ***********************************************************************/
@method OLDocumentClass, MSG_GEN_DOCUMENT_INITIALIZE_DOCUMENT_FILE
{
 VMMapStruct		*VMmapPtr;
 MemHandle			mh;
 VMBlockHandle		vmbh;
 BasicDBError		error;


	/* create the top level database */
	error = BasicDBCreate(pself->GDI_fileHandle, &pself->OLDI_topDBHan, FALSE);
	if (error)  {
		NotifyDBox(0, @BDBCreateError);
		return(TRUE);
		}

	/* Create a VM block for the index list ------------------ */
	vmbh = VMAlloc(pself->GDI_fileHandle, 2048, INDEX_LIST);
	/* create a mem block to attach to it */
	mh = MemAlloc(2048, HF_SWAPABLE, HAF_LOCK);
	LMemInitHeap(mh, LMEM_TYPE_GENERAL, 0,
				 sizeof(LMemBlockHeader), STD_INIT_HANDLES, STD_INIT_HEAP);
	/* create the chunk array  */
	g_indexCArray = ChunkArrayCreate(mh, sizeof(IndexStruct), 0, 0);
	MemUnlock(mh);
	/* and attach the block to the VM - */
	VMAttach(pself->GDI_fileHandle, vmbh, mh);
	/* set the number of items in the list */
	pself->OLDI_indexItems = 0;

	/* Create a VM block for the closed list ------------------
		This array keeps track of closed topic contents.  When we contract
		a topic, we delete the lines from the index and copy them to the
      closed index so that we can re-expand the topic quickly */
	vmbh = VMAlloc(pself->GDI_fileHandle, 2048, CLOSED_LIST);
	/* create a mem block to attach to it */
	mh = MemAlloc(2048, HF_SWAPABLE, HAF_LOCK);
	LMemInitHeap(mh, LMEM_TYPE_GENERAL, 0,
				 sizeof(LMemBlockHeader), STD_INIT_HANDLES, STD_INIT_HEAP);
	/* create the chunk array  */
	pself->OLDI_closedCArray = ChunkArrayCreate(mh, sizeof(IndexStruct), 0, 0);
	MemUnlock(mh);
	/* and attach the block to the VM - */
	VMAttach(pself->GDI_fileHandle, vmbh, mh);


	/* ok - we have our DB and indices so carry on... */
	pself->OLDI_numTopItems = 0;

	/* now a VM Map Block */
	vmbh = VMAlloc(pself->GDI_fileHandle, sizeof(VMMapStruct), 0);
	VMSetMapBlock(pself->GDI_fileHandle, vmbh);
	VMmapPtr = VMLock(pself->GDI_fileHandle, vmbh, &mh);

	/* store some globals we'll need */
	VMmapPtr->VMMS_topDBHan = pself->OLDI_topDBHan;
	VMmapPtr->VMMS_numTopItems = 0;
	VMmapPtr->VMMS_indexCArray = g_indexCArray;
	VMmapPtr->VMMS_indexItems = 0;
	VMmapPtr->VMMS_closedCArray = pself->OLDI_closedCArray;
	VMDirty(mh);
	VMUnlock(mh);

	return(FALSE);
}

/***********************************************************************
 *
 * MESSAGE: MSG_GEN_DOCUMENT_ATTACH_UI_TO_DOCUMENT for
 *                                    OLDocumentClass
 *
 *
 * DESCRIPTION: Called to initialize a newly opened document.
 *
 *
 ***********************************************************************/
@method OLDocumentClass, MSG_GEN_DOCUMENT_ATTACH_UI_TO_DOCUMENT
{
 VMMapStruct        *VMmapPtr;
 MemHandle      mh;
 VMBlockHandle      vmbh;


	g_curDocHan = pself->GDI_fileHandle;
	/* get our VMmap block */
	vmbh = VMGetMapBlock(g_curDocHan);
	VMmapPtr = VMLock(g_curDocHan, vmbh, &mh);
	/* retrieve saved info to get started */
	pself->OLDI_topDBHan = VMmapPtr->VMMS_topDBHan;
	pself->OLDI_numTopItems = VMmapPtr->VMMS_numTopItems;
	g_indexCArray = VMmapPtr->VMMS_indexCArray;
	pself->OLDI_indexItems = VMmapPtr->VMMS_indexItems;
	pself->OLDI_closedCArray = VMmapPtr->VMMS_closedCArray;

	VMUnlock(mh);

	@send CardDList::MSG_GEN_DYNAMIC_LIST_INITIALIZE(pself->OLDI_indexItems);
	/* and since we init'ed the list we need to set the selection */
	if (pself->OLDI_indexItems)
		pself->OLDI_curSel = 0;
	else
		pself->OLDI_curSel = GIGS_NONE;
	@send CardDList::MSG_GEN_ITEM_GROUP_SET_SINGLE_SELECTION(pself->OLDI_curSel, FALSE);
	if (pself->OLDI_curSel != GIGS_NONE) {
		/* to set the buttons */
		@send CardDList::MSG_GEN_ITEM_GROUP_SET_MODIFIED_STATE(TRUE);
		@send CardDList::MSG_GEN_APPLY();
		}

	g_docClosing = FALSE;


}

/***********************************************************************
 *
 * MESSAGE:	MSG_GEN_DOCUMENT_SAVE_AS_COMPLETED for OLDocumentClass
 *
 * DESCRIPTION:	Called on Save As.
 *
 *
 ***********************************************************************/

@method OLDocumentClass, MSG_GEN_DOCUMENT_SAVE_AS_COMPLETED
{

    g_curDocHan = pself->GDI_fileHandle;

}

/***********************************************************************
 *
 * MESSAGE: MSG_GEN_DOCUMENT_DETACH_UI_FROM_DOCUMENT for
 *                                    OLDocumentClass
 *
 *
 * DESCRIPTION:
 *
 *
 ***********************************************************************/
@method OLDocumentClass, MSG_GEN_DOCUMENT_DETACH_UI_FROM_DOCUMENT
{

	g_curDocHan = 0;

	/* re-set a few buttons */
	@send CreateMTopicButton::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
	@send CreateSTopicButton::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
	@send DeleteTopicTrigger::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
	@send MoveTopicTrigger::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
	@send EditTopicTrigger::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
	@send SaveCardButton::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
	@send NewCardButton::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
	@send DeleteCardTrigger::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
	@send MoveCardTrigger::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
	@send FindMenuItem::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
	@send PrintPreviewButton::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
	/* and tools */
	@send NewMTopicTool::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
	@send NewSTopicTool::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
	@send DelTopicTool::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
	@send MoveTopicTool::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
	@send EditTopicTool::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
	@send SaveCardTool::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
	@send NewCardTool::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
	@send DelCardTool::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
	@send MoveCardTool::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
	@send FindTool::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
	@send PrintPrevTool::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);

	@send CardTitle::MSG_VIS_TEXT_DELETE_ALL();
	@send CardText::MSG_VIS_TEXT_DELETE_ALL();

}

/***********************************************************************
 *
 * MESSAGE:	MSG_GEN_DOCUMENT_CLOSE for OLDocumentClass
 *
 * DESCRIPTION:	Called on doc close before detatch from UI
 *
 *
 ***********************************************************************/
@extern method OLDocumentClass, MSG_GEN_DOCUMENT_CLOSE
{

	g_docClosing = TRUE;

	/* first see if we need to save any changes to a card */
	if (g_cardMayHaveChanged) {
		if (!CheckForChanges(pself->OLDI_curSel, oself)) {
			g_docClosing = FALSE;
			return(DQS_CANCEL); /* user needs to fix input */
			}
		}

	@callsuper();

}

/***********************************************************************
 *
 * MESSAGE:	MSG_OLINER_DOC_OPEN_CREATE_TOPIC for OLDocumentClass
 *                       (GEN_TRIGGER_ACTION)
 *
 * DESCRIPTION:
 *
 * PARAMETERS:   optr trigger
 *                                        
 *
 *
 ***********************************************************************/
@method OLDocumentClass, MSG_OLINER_DOC_OPEN_CREATE_TOPIC
{

	/* first see if we need to save any changes to a card */
	if (g_cardMayHaveChanged) 
		if (!CheckForChanges(pself->OLDI_curSel, oself))
			return;

	if (trigger == @CreateMTopicButton || trigger == @NewMTopicTool) {
		@send MTopicText::MSG_VIS_TEXT_DELETE_ALL();
		@send CreateMTopicBox::MSG_GEN_INTERACTION_INITIATE();
		}
	else  {
		@send STopicText::MSG_VIS_TEXT_DELETE_ALL();
		@send CreateSTopicBox::MSG_GEN_INTERACTION_INITIATE();
		}

}

/***********************************************************************
 *
 * MESSAGE:	MSG_OLINER_DOC_SAVE_CARD for OLDocumentClass
 *
 *
 * DESCRIPTION:  creates a new card when Enter is pressed in Card Title
 *               field - fakes the trigger for SAVE_ITEM
 *
 *               changes the info if this is an Enter press on a card
 *               that already exists
 *
 ***********************************************************************/
@method OLDocumentClass, MSG_OLINER_DOC_SAVE_CARD
{

	if (@call SaveCardTool::MSG_GEN_GET_ENABLED()) {
		@call oself::MSG_OLINER_DOC_SAVE_ITEM(@CardApply);
		@send CardText::MSG_META_GRAB_FOCUS_EXCL();
		}
	else
		@send oself::MSG_OLINER_DOC_CHANGE_ITEM(0);

}

/***********************************************************************
 *
 * MESSAGE:	MSG_OLINER_DOC_SAVE_ITEM for OLDocumentClass
 *                       (GEN_TRIGGER_ACTION)
 *
 * DESCRIPTION:  creates a new topic or card
 *
 * PARAMETERS:   optr trigger
 *
 *
 *
 ***********************************************************************/
@method OLDocumentClass, MSG_OLINER_DOC_SAVE_ITEM
{
 MemHandle		mh;
 VMBlockHandle		vmbh, dbHan;
 word				type, sel, recNum, level;
 IndexStruct	*indexElement;
 InteractionCommand	response;
 static const StandardDialog3ResponseTriggerTable addResponseTable [] = {
	  3, {@InTopicMoniker, IN_TOPIC},
	 {@BelowTopicMoniker, BELOW_TOPIC},
  	 {@CancelAddMoniker, CANCEL_ADD}};
 char				addTypeStr[15], tString[MAX_TITLE_LENGTH+1];


	/* first see if we need to save any changes to a card */
	if ((trigger != @SaveCardButton) && (trigger != @SaveCardTool) &&
								(trigger != @CardApply))
		if (!CheckForChanges(pself->OLDI_curSel, oself))
			return;

	/* check for card title */
	if ((trigger == @SaveCardButton) || (trigger == @SaveCardTool) ||
								 (trigger == @CardApply)) {
		g_cardMayHaveChanged = FALSE;
		if (!@call CardTitle::MSG_VIS_TEXT_GET_TEXT_SIZE()) {
			NotifyDBox (0, @AlertCardTitleMsg);
			return;
			}
		}

	/* OK - the rules ...
		-- If there are no items in the list the add is a main topic (first entry)
		-- If the sel item's level is 0 (main level) and the item to add
			is a card then the item has to go into the sel topic since
			we don't allow cards or subs on the main level
		-- If the item to add is a main topic put it [below the selected main
			topic] change to: at the end of the list
		-- If the selection is a topic, ask the user if the new item should
			go IN the selected topic or BELOW it as an item of the parent
			(selected) topic.
		-- If the selection is a card, the new item goes below it in the
			selected card's parent bdb. */

	/*	-- If there are no items in the list the add is a main topic (first entry) */
	if (!pself->OLDI_indexItems)  {
		/* this is our first entry */
		@send oself::MSG_OLINER_DOC_ADD_ITEM_BELOW(trigger, GIGS_NONE);
		return;
		}

	sel = @call CardDList::MSG_GEN_ITEM_GROUP_GET_SELECTION();
	/* first - check the selection's info */
	vmbh = VMFind(g_curDocHan, NullHandle, INDEX_LIST);
	VMLock(g_curDocHan, vmbh ,&mh);
	indexElement = ChunkArrayElementToPtrHandles(mh, g_indexCArray, sel, 0);
	type = indexElement->ISS_type;
	dbHan = indexElement->ISS_dbHan;
	recNum = indexElement->ISS_recNum;
	level = indexElement->ISS_level;
	VMUnlock(mh);

	/*	-- If the sel item's level is 0 (main level) and the item to add
			is a card/sub  then the item has to go into the sel topic since
			we don't allow cards or subs on the main level  */
	if (!level && (trigger == @SaveCardButton || trigger == @STopicTrigger ||
			trigger == @SaveCardTool || trigger == @CardApply))  {
		@send oself::MSG_OLINER_DOC_ADD_ITEM_INTO(trigger, sel);
		return;
		}

	/*	-- If the item to add is a main topic put it [below the selected main
			topic] change to: at the end of the list */
	if (trigger == @MTopicTrigger)  {
		@send oself::MSG_OLINER_DOC_ADD_ITEM_BELOW(trigger, sel);
		return;
		}

	/*	-- If the selection is a topic, ask the user if the new item should
			go INTO the selected topic or BELOW it as a sibling of the selected
			topic.  */
	if (type != T_CARD) {  /* put up a dbox */
		/* get the topic's title */
		GetItemTitle(dbHan, recNum, &tString);
	   /* now put up the question dialog box */
		MemLock(OptrToHandle(@WhereToAddMsg));
		if (trigger == @SaveCardButton || trigger == @SaveCardTool || trigger == @CardApply)
			strcpy(addTypeStr, LMemDeref(@CardText1));
		else strcpy(addTypeStr, LMemDeref(@TopicText));
		response = UserStandardDialog(0, (char *)&addResponseTable,
				tString, addTypeStr,
				LMemDeref(@WhereToAddMsg),
				((CDT_QUESTION << CDBF_DIALOG_TYPE_OFFSET) |
				(GIT_MULTIPLE_RESPONSE << CDBF_INTERACTION_TYPE_OFFSET)));
		MemUnlock(OptrToHandle(@WhereToAddMsg));
		if (response == BELOW_TOPIC)
			@send oself::MSG_OLINER_DOC_ADD_ITEM_BELOW(trigger, sel);
		else if (response == IN_TOPIC)
			@send oself::MSG_OLINER_DOC_ADD_ITEM_INTO(trigger, sel);
		else if (response == CANCEL_ADD) return;
		}

	/*	-- If the selection is a card, the new item goes below it in the
			selected card's parent bdb. */ 
	else
		@send oself::MSG_OLINER_DOC_ADD_ITEM_BELOW(trigger, sel);

}

/***********************************************************************
 *
 * MESSAGE:	MSG_OLINER_DOC_ADD_ITEM_INTO for OLDocumentClass
 *
 *
 * DESCRIPTION:	adds a new topic or card into the selected topic at the
 *						[beginning] change to: end of the items in that topic
 *
 * PARAMETERS:   optr trigger, word sel
 *
 *
 *
 ***********************************************************************/
@method OLDocumentClass, MSG_OLINER_DOC_ADD_ITEM_INTO
{
 BasicDBError		error;
 BasicDBRecordID    recordID;
 Boolean			wasProblem = FALSE;
 Boolean			savedOK;
 MemHandle		mh, vmh;
 VMMapStruct		*VMmapPtr;
 VMBlockHandle		vmbh, myDBHan, nextDBHan;
 word				numRecs, level, cType, i, insPos;
 IndexStruct	*indexElement, *insertElement;
 Boolean			keepChecking;
 Boolean			appendFlag = FALSE;


   /* get the info on the selected topic into which we'll put our item */
	/* find the selection's topic dbHan */
	vmbh = VMFind(g_curDocHan, NullHandle, INDEX_LIST);
	VMLock(g_curDocHan, vmbh ,&mh);
	indexElement = ChunkArrayElementToPtrHandles(
				mh, g_indexCArray, sel, 0);
	myDBHan = indexElement->ISS_myDBHan;
	numRecs = indexElement->ISS_numRecs;
	level = indexElement->ISS_level;
	VMUnlock(mh);

	if (level == MAX_LEVELS - 1) {
		NotifyDBox (0, @AddLevelWarningMsg);
		return;
		}


	if (trigger != @SaveCardButton && trigger != @SaveCardTool &&
					trigger != @CardApply) {
		/* create the next level database */
		error = BasicDBCreate(g_curDocHan, &nextDBHan, FALSE);
		if (error)  {
			NotifyDBox(0, @BDBCreateError);
			return;
			}
		/* and set the create type */
		cType = T_EMPTY_TOPIC;
		}
	else  {  /* it's a card */
		nextDBHan = 0;
		cType = T_CARD;
		}

	/* create a new record */
	mh = MakeNewRecord(myDBHan);
	if(!mh) {
		NotifyDBox(0, @ErrMsgCouldntCreateNewRec);
		return;
		}

	/* save the data */
	savedOK = SaveData(mh, cType, nextDBHan, trigger);

	if (savedOK) {
		/* store the record */
		error = BasicDBSaveRecord(g_curDocHan, myDBHan, mh, 0, &recordID);
		if (error) wasProblem = TRUE;
		}  /* end of saved ok if */
	else wasProblem = TRUE;

	if (wasProblem) {
		NotifyDBox(0, @ErrMsgCouldntSaveRec);
		return;
		}

	/* now save the index info */
	vmbh = VMFind(g_curDocHan, NullHandle, INDEX_LIST);
	VMLock(g_curDocHan, vmbh ,&mh);
	/* we need to insert/append as the [1st] change to: last item of the selected topic */
	/* check the exceptional case of the selected topic being the
		last item in the list */
	if (sel == (pself->OLDI_indexItems - 1)) {
		appendFlag = TRUE;
		insPos = sel + 1;
		}
	else {
		/* we need to insert/append it following the selected topic - BUT,
			there may be subtopics using lines so we need to account for
			any of those */
		i = 1;
		keepChecking = TRUE;
		while (keepChecking) {
			indexElement = ChunkArrayElementToPtrHandles(
						mh, g_indexCArray, sel + i, 0);
			if (indexElement->ISS_level <= level) {
				/* we found our insert point */
				keepChecking = FALSE;
				insPos = sel + i;
				}
			else  {
				/* check to see if we're at the last item in the dlist */
				if ((sel + i) == (pself->OLDI_indexItems - 1))  {
					/* we are */
					appendFlag = TRUE;
					keepChecking = FALSE;
					insPos = sel + i + 1;
					}
				else i++;
				}
			}  /* end of keepChecking while */
		} /* end of insert item else */

	/* ok - we have our insertion/append point */
	if (!appendFlag) {
		insertElement = ChunkArrayInsertAtHandle(
					g_indexCArray, indexElement, 0);
		}
	else {  /* just append it */
		insertElement = ChunkArrayAppendHandles(
					mh, g_indexCArray, 0);
		}
	insertElement->ISS_type = cType;
	insertElement->ISS_level = level + 1;
	insertElement->ISS_dbHan = myDBHan;
	insertElement->ISS_recNum = numRecs;
	insertElement->ISS_numRecs = 0;
	insertElement->ISS_myDBHan = nextDBHan;

	/* and if a topic was selected we need to increment its numRecs... and
		maybe its type */
	if (trigger != @MTopicTrigger) {
		numRecs++;
		indexElement = ChunkArrayElementToPtrHandles(
				mh, g_indexCArray, sel, 0);
		if (indexElement->ISS_numRecs == 0)  {
			/* this is the first item in this topic so change its type from
				empty to open */
         indexElement->ISS_type = T_OPEN_TOPIC;
			}
		indexElement->ISS_numRecs = numRecs;
		}
	VMDirty(mh);
	VMUnlock(mh);

	/* ok - update & save the mapblock stuff */
	pself->OLDI_indexItems++;
	vmbh = VMGetMapBlock(g_curDocHan);
	VMmapPtr = VMLock(g_curDocHan, vmbh, &vmh);
	if (trigger == @MTopicTrigger) {
		pself->OLDI_numTopItems++;
		VMmapPtr->VMMS_numTopItems = pself->OLDI_numTopItems;
		}
	VMmapPtr->VMMS_indexItems = pself->OLDI_indexItems;
	VMDirty(vmh);
	VMUnlock(vmh);

	/* update the list */
	@send CardDList::MSG_GEN_DYNAMIC_LIST_INITIALIZE(pself->OLDI_indexItems);
	/* and since we init'ed the list we need to reset the selection */
	if (pself->OLDI_indexItems == 1)  sel = 0;
	else if (trigger == @CardApply) sel = insPos;
	else sel = pself->OLDI_curSel;
	@send CardDList::MSG_GEN_ITEM_GROUP_SET_SINGLE_SELECTION(sel, FALSE);
	/* to set the buttons */
	@send CardDList::MSG_GEN_ITEM_GROUP_SET_MODIFIED_STATE(TRUE);
	@send CardDList::MSG_GEN_APPLY();

}

/***********************************************************************
 *
 * MESSAGE:	MSG_OLINER_DOC_ADD_ITEM_BELOW for OLDocumentClass
 *
 *
 * DESCRIPTION:  adds a new topic or card below the selected item
 *
 * PARAMETERS:   optr trigger, word sel
 *
 *
 *
 ***********************************************************************/
@method OLDocumentClass, MSG_OLINER_DOC_ADD_ITEM_BELOW
{
 BasicDBError		error;
 BasicDBRecordID    recordID;
 Boolean			wasProblem = FALSE;
 Boolean			savedOK, keepChecking;
 Boolean			appendFlag = FALSE;
 MemHandle		mh, vmh;
 VMMapStruct		*VMmapPtr;
 VMBlockHandle		vmbh, dbHan, nextDBHan;
 word				level, cType, i, recNum, insPos;
 IndexStruct	*indexElement, *insertElement;


	/* get the info on the selected item's parent into which we'll put
		our new item */
	if ((trigger == @STopicTrigger) || (trigger == @SaveCardButton)
				|| trigger == @SaveCardTool || trigger == @CardApply) {
		/* find the selection's parent dbHan & sel's level & type */
		vmbh = VMFind(g_curDocHan, NullHandle, INDEX_LIST);
		VMLock(g_curDocHan, vmbh ,&mh);
		indexElement = ChunkArrayElementToPtrHandles(
				         mh, g_indexCArray, sel, 0);
		dbHan = indexElement->ISS_dbHan;
		level = indexElement->ISS_level;
		VMUnlock(mh);
		}
	else if (trigger == @MTopicTrigger) {
		dbHan = pself->OLDI_topDBHan;
		level = 0;
		}

	if (trigger != @SaveCardButton && trigger != @SaveCardTool && trigger != @CardApply) {
		/* create the next level database */
		error = BasicDBCreate(g_curDocHan, &nextDBHan, FALSE);
		if (error)  {
			NotifyDBox(0, @BDBCreateError);
			return;
			}
		/* and set the create type */
		cType = T_EMPTY_TOPIC;
		}
	else  {  /* it's a card */
		nextDBHan = 0;
		cType = T_CARD;
		}

	/* create a new record */
	mh = MakeNewRecord(dbHan);
	if(!mh) {
		NotifyDBox(0, @ErrMsgCouldntCreateNewRec);
		return;
		}

	/* save the data */
	savedOK = SaveData(mh, cType, nextDBHan, trigger);

	if (savedOK) {
		/* store the record */
		error = BasicDBSaveRecord(g_curDocHan, dbHan, mh, 0, &recordID);
		if (error) wasProblem = TRUE;
		}  /* end of saved ok if */
	else wasProblem = TRUE;

	if (wasProblem) {
		NotifyDBox(0, @ErrMsgCouldntSaveRec);
		return;
		}

	/* now save the index info */
	vmbh = VMFind(g_curDocHan, NullHandle, INDEX_LIST);
	VMLock(g_curDocHan, vmbh ,&mh);
	/* figure out where to put it...  */
	/*	If it's a main topic - put it [below the selected main topic in the next
		available main topic slot] change to: at the end of the list */
	if (trigger == @MTopicTrigger)  {
		insertElement = ChunkArrayAppendHandles(mh, g_indexCArray, 0);
		insertElement->ISS_type = cType;
		insertElement->ISS_numRecs = 0;
		insertElement->ISS_myDBHan = nextDBHan;
		insertElement->ISS_level = 0;
		insertElement->ISS_dbHan = dbHan;
		insertElement->ISS_recNum = pself->OLDI_numTopItems;
		}  /* end of main topic trigger */


	else {  // inserting a sub or card
		/* Since we didn't add a main topic we need to increment the parent
			topic's numRecs and maybe its type, so go up the list to find
			our selection's parent.  Plus we need to snag the parent's
			numRecs which is the recNum of our new item */
		i = 1;
		keepChecking = TRUE;
		while (keepChecking) {
			indexElement = ChunkArrayElementToPtrHandles(
						mh, g_indexCArray, sel - i, 0);
			if (indexElement->ISS_level < level) {
				/* found it */
				keepChecking = FALSE;
				}
			else i++;
			}  /* end of keepChecking while */
		if (indexElement->ISS_numRecs == 0)  {
			/* this is the first item in this topic so change its type from
				empty to open */
			indexElement->ISS_type = T_OPEN_TOPIC;
			}
		recNum = indexElement->ISS_numRecs;
		indexElement->ISS_numRecs++;

		/* now back to finding the insertion point */
		/* check the exceptional case of the selected topic being the
			last item in the list */
		if (sel == (pself->OLDI_indexItems - 1)) {
			insPos = sel + 1;
			appendFlag = TRUE;
			}
		else {
			/* we need to insert/append it following the selected topic - BUT,
				there may be subtopics using lines so we need to account for
				any of those */
			i = 1;
			keepChecking = TRUE;
			while (keepChecking) {
				indexElement = ChunkArrayElementToPtrHandles(
						mh, g_indexCArray, sel + i, 0);
				if (indexElement->ISS_level <= level) {
					/* we found our insert point */
					keepChecking = FALSE;
					insPos = sel + i;
					}
				else  {
					/* check to see if we're at the last item in the dlist */
					if ((sel + i) == (pself->OLDI_indexItems - 1))  {
						/* we are */
						appendFlag = TRUE;
						keepChecking = FALSE;
						insPos = sel + i + 1;
						}
					else i++;
					}
				}  /* end of keepChecking while */
			} /* end of insert item else */

		/* ok - we have our insertion/append point */
		if (!appendFlag) {
			insertElement = ChunkArrayInsertAtHandle(
					g_indexCArray, indexElement, 0);
			}
		else {  /* just append it */
			insertElement = ChunkArrayAppendHandles(
					mh, g_indexCArray, 0);
			}
		insertElement->ISS_type = cType;
		insertElement->ISS_level = level;
		insertElement->ISS_dbHan = dbHan;
		insertElement->ISS_recNum = recNum;
		insertElement->ISS_numRecs = 0;
		insertElement->ISS_myDBHan = nextDBHan;
		}  /* end of sub or card trigger else */

	VMDirty(mh);
	VMUnlock(mh);

	/* ok - update & save the mapblock stuff */
	pself->OLDI_indexItems++;
	vmbh = VMGetMapBlock(g_curDocHan);
	VMmapPtr = VMLock(g_curDocHan, vmbh, &vmh);
	if (trigger == @MTopicTrigger) {
		pself->OLDI_numTopItems++;
		VMmapPtr->VMMS_numTopItems = pself->OLDI_numTopItems;
		}
	VMmapPtr->VMMS_indexItems = pself->OLDI_indexItems;
	VMDirty(vmh);
	VMUnlock(vmh);

	/* update the list */
	@send CardDList::MSG_GEN_DYNAMIC_LIST_INITIALIZE(pself->OLDI_indexItems);
	/* and since we init'ed the list we need to reset the selection */
	if (pself->OLDI_indexItems == 1)  sel = 0;
	else if (trigger == @CardApply) sel = insPos;
	else sel = pself->OLDI_curSel;
	@send CardDList::MSG_GEN_ITEM_GROUP_SET_SINGLE_SELECTION(sel, FALSE);
	/* to set the buttons */
	@send CardDList::MSG_GEN_ITEM_GROUP_SET_MODIFIED_STATE(TRUE);
	@send CardDList::MSG_GEN_APPLY();

}

/***********************************************************************
 *
 * MESSAGE:	MSG_OLINER_DOC_DELETE_ITEM for OLDocumentClass
 *
 * DESCRIPTION:	
 *
 * PARAMETERS:
 *
 *
 *
 ***********************************************************************/
@method OLDocumentClass, MSG_OLINER_DOC_DELETE_ITEM
{
 BasicDBError		error;
 MemHandle		mh, vmh, checkMH, delMH;
 VMMapStruct		*VMmapPtr;
 BasicDBFieldID	fieldID;
 VMBlockHandle		vmbh, dbHan, myDBHan, delDBHan, prntDBHan;
 word				type, sel, numRecs, recNum, level, numDels, i, start;
 IndexStruct	*indexElement;
 Boolean			keepChecking;
 word				check, checkType, topicPos, numItems;
 Boolean			doClosedAlert = FALSE;


	sel = @call CardDList::MSG_GEN_ITEM_GROUP_GET_SELECTION();
	if (sel == GIGS_NONE) return;

	numItems = pself->OLDI_indexItems;
	/* find the selection's topic dbHan */
	vmbh = VMFind(g_curDocHan, NullHandle, INDEX_LIST);
	VMLock(g_curDocHan, vmbh ,&mh);
	indexElement = ChunkArrayElementToPtrHandles(
				mh, g_indexCArray, sel, 0);
	type = indexElement->ISS_type;
	dbHan = indexElement->ISS_dbHan;
	myDBHan = indexElement->ISS_myDBHan;
	numRecs = indexElement->ISS_numRecs;
	recNum = indexElement->ISS_recNum;
	level = indexElement->ISS_level;
	VMUnlock(mh);

	/* confirm the delete */
	if (type == T_CARD)
		if(AckDBox(0, 0, @ConfirmDeleteCard) == ACK_NO) return;
	if (type != T_CARD && numRecs) {
		/* make sure there are no closed folders */
		i = 1;
		keepChecking = TRUE;
		vmbh = VMFind(g_curDocHan, NullHandle, INDEX_LIST);
		VMLock(g_curDocHan, vmbh ,&mh);
		while (keepChecking) {
			indexElement = ChunkArrayElementToPtrHandles(
										mh, g_indexCArray, sel + i, 0);
			if (indexElement->ISS_level > level) {
				/* this will be deleted - make sure it's not a closed topic */
				if (indexElement->ISS_type == T_CLOSED_TOPIC)  {
					doClosedAlert = TRUE;
					keepChecking = FALSE;
					}
				else  {
					/* ok to delete it, but check for last item in array */
					i++;
					if (numItems == sel + i)  keepChecking = FALSE;
					}
				}
			else  {
				/* we're outta the delete range */
				keepChecking = FALSE;
				}
			}  /* end of keepChecking while */
		VMUnlock(mh);
		if (doClosedAlert)  {
			NotifyDBox (0, @AlertFullTopicMsg);
			return;
			}
		else
			if(AckDBox(0, 0, @ConfirmDeleteFullTopic) == ACK_NO) return;
		}  /* end of full folder check if */
	if (type == T_EMPTY_TOPIC)
		if(AckDBox(0, 0, @ConfirmDeleteEmptyTopic) == ACK_NO) return;

	/* grab the record from the db */
	error = BasicDBGetRecordByElemNum(g_curDocHan, dbHan, recNum, &mh);
	if (error) {
		NotifyDBox(0, @BDBGetRecordError);
		return;
		}

	/* check to see if this was a topic - if so free its bdb block */
	if (type != T_CARD) {
		/* AND - need to see if there are any other topics below this level
			and free them too */
		delDBHan = myDBHan;
		prntDBHan = dbHan;
		topicPos = recNum;
		keepChecking = TRUE;
		while (keepChecking) {
			/* OK, this is very brute force and inelegant.  Start at this level
				opening records until we get a topic or an open error.  If we get
				an error then there are no more records at that level and we can
				delete the parent topic.  Then start over.  If we find a topic,
				save the dbHan, open it and keep looking.
				*/
			error = 0;
			check = 0;
			while (!error) {
				/*error = */BasicDBGetRecordByElemNum(g_curDocHan,
															delDBHan, check, &checkMH);
				if (!checkMH)  {
					/* no more records, we can safely delete this record's bdb */
					VMFree(g_curDocHan, delDBHan);
					if(delDBHan == myDBHan)  {
						/* we're done */
						keepChecking = FALSE;
						error = TRUE;
						}
					else {
						/* need to delete the record that holds this topic - so
							reopen the parent, get the topic rec & delete it */
						BasicDBGetRecordByElemNum(g_curDocHan,
															prntDBHan, topicPos, &delMH);
						BasicDBDeleteRecord(g_curDocHan, prntDBHan, delMH, 0);
						/* now go back to the top */
						error = TRUE;
						delDBHan = myDBHan;
						prntDBHan = dbHan;
						}
					}
				else  {
					/* a valid record - check its type */
					fieldID = BasicDBGetFieldID(checkMH, BDBFHE_CATEGORY,
																		 FIELD_CAT_TYPE, 1);
					BasicDBGetFieldData(checkMH, fieldID, &checkType, sizeof(word));
					if (checkType != T_CARD)  {
						/* it's a topic - snag its dbHan */
						prntDBHan = delDBHan;
						fieldID = BasicDBGetFieldID(checkMH, BDBFHE_CATEGORY,
																	FIELD_CAT_TOPIC_DBHAN, 1);
						BasicDBGetFieldData(checkMH, fieldID,
															&delDBHan, sizeof(VMBlockHandle));
						topicPos = check;
						error = TRUE;
						}
					else {
						/* it's a card - keep cycling through */
						check++;
						}
					BasicDBDiscardRecord(checkMH);
					}  /* end of valid record else */

				}  /* end of !error while */

			}  /* end of keepChecking while */

		}  /* end of topic type selection */

	/* and delete the selected record */
	BasicDBDeleteRecord(g_curDocHan, dbHan, mh, 0);
	numDels = 1;


	/* now update the index info  -  we first grab the array element,
		then, if the type is topic cycle through deleting each subsequent
		element whose level is greater than ours */
	vmbh = VMFind(g_curDocHan, NullHandle, INDEX_LIST);
	VMLock(g_curDocHan, vmbh ,&mh);
	indexElement = ChunkArrayElementToPtrHandles(
				mh, g_indexCArray, sel, 0);
	/* the element struct data is still good from above so we delete
		the card or topic item */
	ChunkArrayDeleteHandle(g_indexCArray, indexElement);
	numItems--;
	if ((type != T_CARD) && numRecs) {
		/* del all the children of this topic */
		while (numItems > sel) {
			indexElement = ChunkArrayElementToPtrHandles(
						mh, g_indexCArray, sel, 0);
			if (indexElement->ISS_level > level) {
				ChunkArrayDeleteHandle(g_indexCArray, indexElement);
				numItems--;
            numDels++;
				}
			else break;
			}
		}

	/* Now we need to update the recNums for the remaining elements in
		this level.  Since we can add records at any place in the cArray
		and we're getting the data by elemNum in the bdb, we need to go
		through the branch at the level being deleted and decrement
		recNums > the deleted recnum. */
	/* First we need to locate the first item at this level. */
	if (!level || !sel) start = 0;
	else {
		for (check = sel-1; check < 0xffff; check--) {
			indexElement = ChunkArrayElementToPtrHandles(
								mh, g_indexCArray, check, 0);
			if (indexElement->ISS_level < level) {
				start = check + 1;
				break;
				}
         }
		}
	/* now that we have a starting point... If the test level is < level
		we're done with decrementing this branch.  If test level is > level
		then we skip that sub branch and keep going.  And if the levels are
		equal then see if we need to decrement */
	for (check = start; check < numItems; check++)  {
		indexElement = ChunkArrayElementToPtrHandles(
						mh, g_indexCArray, check, 0);
		if (indexElement->ISS_level == level) {
				if (indexElement->ISS_recNum > recNum)
					indexElement->ISS_recNum--;
			}
		if(indexElement->ISS_level < level) break;
		}

	/* and we need to decrement our parent's numRecs - unless we were at
		the top level... */
	if (level)  {
		/* find our parent - go up until we get to an item 1 level less than us */
		check = 1;
		keepChecking = TRUE;
		while (keepChecking) {
			indexElement = ChunkArrayElementToPtrHandles(
					mh, g_indexCArray, sel - check, 0);
			if (indexElement->ISS_level == level - 1) {
				/* found parent */
				indexElement->ISS_numRecs--;
				/* change type if no more items in the folder */
				if (indexElement->ISS_numRecs == 0) {
					indexElement->ISS_type = T_EMPTY_TOPIC;
					}
				keepChecking = FALSE;
				}
			else check++;
			}
		}
	VMDirty(mh);
	VMUnlock(mh);


	/* ok - update & save the mapblock stuff */
	pself->OLDI_indexItems -= numDels;
	vmbh = VMGetMapBlock(g_curDocHan);
	VMmapPtr = VMLock(g_curDocHan, vmbh, &vmh);
	if (dbHan == pself->OLDI_topDBHan) {
		pself->OLDI_numTopItems--;
		VMmapPtr->VMMS_numTopItems = pself->OLDI_numTopItems;
		}
	VMmapPtr->VMMS_indexItems = pself->OLDI_indexItems;
	VMDirty(vmh);
	VMUnlock(vmh);

	/* update the ui */
	@send CardDList::MSG_GEN_DYNAMIC_LIST_INITIALIZE(pself->OLDI_indexItems);
	/* and since we init'ed the list we need to reset the selection */
	if (pself->OLDI_curSel > (pself->OLDI_indexItems - 1))
		pself->OLDI_curSel--;
	if (pself->OLDI_indexItems == 0) {
		pself->OLDI_curSel = GIGS_NONE;
		}
	@send CardDList::MSG_GEN_ITEM_GROUP_SET_SINGLE_SELECTION(pself->OLDI_curSel, FALSE);
	/* and set the buttons */
	@send CardDList::MSG_GEN_ITEM_GROUP_SET_MODIFIED_STATE(TRUE);
	@send CardDList::MSG_GEN_APPLY();

}

/***********************************************************************
 *
 * MESSAGE: (GEN_ITEM_GROUP_APPLY_MSG) MSG_OLINER_DOC_CARD_DLIST_APPLY
 *								for OLDocumentClass
 *
 * PARAMETERS:  void (word selection, numSelections, stateFlags)
 *
 * DESCRIPTION: 
 *
 ***********************************************************************/
@method OLDocumentClass, MSG_OLINER_DOC_CARD_DLIST_APPLY
{
 MemHandle		mh;
 char			tString[MAX_TITLE_LENGTH + 1];
 word			size, type, recNum/*, selection*/;
 BasicDBFieldID	fieldID;
 char 		*p_data;
 void			*p_record;
 VMBlockHandle		vmbh, dbHan;
 IndexStruct	*indexElement;
 char			dateString[DATE_TIME_BUFFER_SIZE + 1], timeString[15];
 TimerDateAndTime	date;


	/* first see if we need to save any changes to a card */
	if (g_cardMayHaveChanged) {
		if (!CheckForChanges(pself->OLDI_curSel, oself)) {
			/* OK - we do, so we need to reset the selection */
			@send CardDList::MSG_GEN_ITEM_GROUP_SET_SINGLE_SELECTION(
														  pself->OLDI_curSel, FALSE);
			return;
			}
		}

	pself->OLDI_curSel = selection;
	if (selection != GIGS_NONE) {

		/* get this line's information */
		vmbh = VMFind(g_curDocHan, NullHandle, INDEX_LIST);
		VMLock(pself->GDI_fileHandle, vmbh ,&mh);
		indexElement = ChunkArrayElementToPtrHandles(
				mh, g_indexCArray, selection, 0);
		type = indexElement->ISS_type;
		dbHan = indexElement->ISS_dbHan;
		recNum = indexElement->ISS_recNum;
		VMUnlock(mh);

		/* get the bdb info */
		BasicDBGetRecordByElemNum(g_curDocHan, dbHan, recNum, &mh);
		/* show the create date */
		fieldID = BasicDBGetFieldID(mh, BDBFHE_CATEGORY, FIELD_CAT_CREATE_DATE, 1);
		size = BasicDBGetFieldData(mh, fieldID, &date, sizeof(TimerDateAndTime));
		if (size) {
			LocalFormatDateTime(dateString, DTF_SHORT, &date);
			LocalFormatDateTime(timeString, DTF_HMS, &date);
			strcat(dateString, "  ");
			strcat(dateString, timeString);
			@call ListCreationDate::MSG_VIS_TEXT_REPLACE_ALL_PTR(dateString, 0);
			}
		else @send ListCreationDate::MSG_VIS_TEXT_DELETE_ALL();
		/* show the mod date */
		fieldID = BasicDBGetFieldID(mh, BDBFHE_CATEGORY, FIELD_CAT_MOD_DATE, 1);
		size = BasicDBGetFieldData(mh, fieldID, &date, sizeof(TimerDateAndTime));
		if (size) {
			LocalFormatDateTime(dateString, DTF_SHORT, &date);
			LocalFormatDateTime(timeString, DTF_HMS, &date);
			strcat(dateString, "  ");
			strcat(dateString, timeString);
			@call ListModificationDate::MSG_VIS_TEXT_REPLACE_ALL_PTR(dateString, 0);
			}
		else @send ListModificationDate::MSG_VIS_TEXT_DELETE_ALL();

		/* see if we need to show a card */
		if(type == T_CARD)  {
			/* show the title */
			fieldID = BasicDBGetFieldID(mh, BDBFHE_CATEGORY, FIELD_CAT_TITLE, 1);
			size = BasicDBGetFieldData(mh, fieldID, tString, MAX_TITLE_LENGTH+1);
			@call CardTitle::MSG_VIS_TEXT_REPLACE_ALL_PTR(tString, size);
			/* and the data */
			MemLock(mh);
			p_record = MemDeref(mh);
			fieldID = BasicDBGetFieldIDPtr(p_record, BDBFHE_CATEGORY, FIELD_CAT_CARD_DATA, 1);
			size = BasicDBGetPtrToFieldData(p_record, fieldID, &p_data);
			if (size) @call CardText::MSG_VIS_TEXT_REPLACE_ALL_PTR(p_data, size);
			else @send CardText::MSG_VIS_TEXT_DELETE_ALL();
			MemUnlock(mh);
			}
		BasicDBDiscardRecord(mh);
		}  /* end of valid selection if */

	/* now to set the buttons... */
	if (selection == GIGS_NONE)  {
		/* everything off except create main topic */
		@send SaveCardButton::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
		@send NewCardButton::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
		@send CreateSTopicButton::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
		@send DeleteTopicTrigger::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
		@send DeleteCardTrigger::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
		@send MoveTopicTrigger::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
		@send MoveCardTrigger::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
		@send EditTopicTrigger::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
		@send CreateMTopicButton::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
		@send FindMenuItem::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
		@send PrintPreviewButton::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
		@send NewMTopicTool::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
		@send NewSTopicTool::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
		@send DelTopicTool::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
		@send MoveTopicTool::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
		@send EditTopicTool::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
		@send SaveCardTool::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
		@send NewCardTool::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
		@send DelCardTool::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
		@send MoveCardTool::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
		@send FindTool::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
		@send PrintPrevTool::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
		@send OLSpellControl::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
		}
	else  {
		/* all the other situations... */
		@send FindMenuItem::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
		@send FindTool::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
		@send PrintPreviewButton::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
		@send PrintPrevTool::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
		if (type != T_CARD)  {
			@send NewCardButton::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
			@send NewCardTool::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
			@send SaveCardButton::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
			@send SaveCardTool::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
			@send EditTopicTrigger::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
			@send EditTopicTool::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
			@send DeleteTopicTrigger::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
			@send DelTopicTool::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
			@send DeleteCardTrigger::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
			@send DelCardTool::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
			@send CreateSTopicButton::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
			@send NewSTopicTool::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
			@send MoveTopicTrigger::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
			@send MoveTopicTool::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
			@send MoveCardTrigger::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
			@send MoveCardTool::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
			if (type == T_CLOSED_TOPIC)  {
				@send CreateSTopicButton::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
				@send NewSTopicTool::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
				@send DeleteTopicTrigger::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
				@send DelTopicTool::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
				@send MoveTopicTrigger::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
				@send MoveTopicTool::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
				}
			/* and erase any card info */
			@send CardTitle::MSG_VIS_TEXT_DELETE_ALL();
			@send CardText::MSG_VIS_TEXT_DELETE_ALL();
			@send OLSpellControl::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
			}
		else  {
			@send NewCardButton::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
			@send NewCardTool::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
			@send SaveCardButton::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
			@send SaveCardTool::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
			@send EditTopicTrigger::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
			@send EditTopicTool::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
			@send DeleteTopicTrigger::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
			@send DelTopicTool::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
			@send DeleteCardTrigger::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
			@send DelCardTool::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
			@send CreateSTopicButton::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
			@send NewSTopicTool::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
			@send MoveTopicTrigger::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
			@send MoveTopicTool::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
			@send MoveCardTrigger::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
			@send MoveCardTool::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
			@send OLSpellControl::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
			}
		}  /* end of all other else */

}

/***********************************************************************
 *
 * MESSAGE:		MSG_OLINER_DOC_CARD_DLIST_MONIKER_QUERY for OLDocumentClass
 *              (GEN_DYNAMIC_LIST_QUERY_MSG)
 *
 * DESCRIPTION:
 *
 * PARAMETERS:  	void (optr list, word item)
 *
 *
 *
 ***********************************************************************/
@method OLDocumentClass, MSG_OLINER_DOC_CARD_DLIST_MONIKER_QUERY
{
 MemHandle		mh;
 char			tString[MAX_TITLE_LENGTH + 1];
 word			type, recNum, level, indent, connector, i, lineHeight;
 word			textVPos;
 VMBlockHandle		vmbh, dbHan;
 IndexStruct	*indexElement;
 ChunkHandle		chunk ;
 MemHandle		mem ;
 GStateHandle		gstate ;
 word					bits[] = {1, 2, 4, 8, 16, 32, 64, 128, 256, 512};


	/* get the index item the list wants */
	vmbh = VMFind(g_curDocHan, NullHandle, INDEX_LIST);
	VMLock(g_curDocHan, vmbh ,&mh);
	indexElement = ChunkArrayElementToPtrHandles(
				mh, g_indexCArray, item, 0);
	type = indexElement->ISS_type;
	dbHan = indexElement->ISS_dbHan;
	recNum = indexElement->ISS_recNum;
	level = indexElement->ISS_level;
	connector = indexElement->ISS_connector;
	VMUnlock(mh);

	GetItemTitle(dbHan, recNum, &tString);

	/* set up the mem and gstate */
	mem = MemAllocLMem(LMEM_TYPE_GSTRING, 0) ;
	gstate = GrCreateGString(mem, GST_CHUNK, &chunk);

	/* calc the line height based on system font size (min is 20 so that
		icons look nice) */
	if (g_sysPointSize <= 12) lineHeight = 20;
	else lineHeight = g_sysPointSize + 8;
	textVPos = lineHeight - g_sysPointSize - 7;

	/* tell the list the size of the gstring */
	GrSetGStringBounds(gstate, 0, 0, 800, lineHeight);

	/* indent and draw connector lines */
	indent = level * INDENT;
	GrSetLineMaskSys(gstate, SDM_50);

	if (level) {
		GrDrawHLine(gstate, indent-10, 8, indent);
		GrDrawVLine(gstate, indent-10, 0, 8);
		/* now the other pieces of VLines as necessary */
		if(type == T_OPEN_TOPIC)
			/* the line under the folder to its 1st child */
			GrDrawVLine(gstate, indent+10, 10, 20);
		if (connector)  {
			/* draw the connectors at the lower levels */
			for (i = 0; i < level; i++)  {
				if (connector & bits[i])  {
					GrDrawVLine(gstate, (indent-10)-(level - i - 1)*INDENT, 0, 20);
					}
				}
			}
		}
	else {
		/* just for level 0 folders */
		if(type == T_OPEN_TOPIC)
			/* the line under the folder to its 1st child */
			GrDrawVLine(gstate, indent+10, 10, 20);
		}

   /* draw icon */
	MemLock(HandleOf(@CardMoniker));
	switch (type) {
		case T_CARD:
			GrDrawBitmap(gstate, indent, 3, LMemDeref(@CardMoniker), 0);
			break;
		case T_EMPTY_TOPIC:
			GrDrawBitmap(gstate, indent, 3, LMemDeref(@ETopicMoniker), 0);
			break;
		case T_CLOSED_TOPIC:
			GrDrawBitmap(gstate, indent, 3, LMemDeref(@CTopicMoniker), 0);
			break;
		case T_OPEN_TOPIC:
			GrDrawBitmap(gstate, indent, 3, LMemDeref(@OTopicMoniker), 0);
			break;
		}
	MemUnlock(HandleOf(@CardMoniker));
	indent += 25;

	/* draw the title */
	if (type == T_CARD)
		GrSetTextStyle(gstate, 0, TS_BOLD);
	else
		GrSetTextStyle(gstate, TS_BOLD, 0);
	GrDrawText(gstate, indent, textVPos, tString, 0);

	/* terminate the gstring */
	GrEndGString(gstate) ;
	/* and tell the DList */
	@call list::MSG_GEN_DYNAMIC_LIST_REPLACE_ITEM_MONIKER(
				  item,
				  0,
				  lineHeight,
				  800,
				  0,
				  VMDT_GSTRING,
				  VMST_OPTR,
				  ConstructOptr(mem, chunk)) ;

	/* and 86 the gstate and mem */
	GrDestroyGString(gstate, gstate, GSKT_KILL_DATA) ;
	MemFree(mem) ;

}

/***********************************************************************
 *
 * MESSAGE:		MSG_OLINER_DOC_CARD_DLIST_DOUBLE_CLICK for OLDocumentClass
 *
 * DESCRIPTION:	Double clicking toggles the open/closed state of a topic
 *
 *
 * PARAMETERS:
 *
 *
 *
 ***********************************************************************/
@method OLDocumentClass, MSG_OLINER_DOC_CARD_DLIST_DOUBLE_CLICK
{
 MemHandle			mh, vmh, cmh;
 VMBlockHandle    vmbh, myDBHan, cvmbh;
 VMMapStruct		*VMmapPtr;
 word					sel, type, level, numDels, numAdds, numClosed, i, numRecs;
 word					move, newType;
 IndexStruct		*indexElement, *closedElement, *insertElement;
 Boolean				keepGoing = TRUE;
 Boolean				appendFlag = FALSE;


	sel = @call CardDList::MSG_GEN_ITEM_GROUP_GET_SELECTION();
	if (sel == GIGS_NONE) return;

	/* find the selection's topic dbHan */
	vmbh = VMFind(g_curDocHan, NullHandle, INDEX_LIST);
	VMLock(g_curDocHan, vmbh ,&mh);
	indexElement = ChunkArrayElementToPtrHandles(
				mh, g_indexCArray, sel, 0);
	type = indexElement->ISS_type;
	numRecs = indexElement->ISS_numRecs;

	if ((type == T_CARD) || !numRecs){
		VMUnlock(mh);
		if (type == T_CARD && !g_cardWin)
			@send process::MSG_OLINER_PROC_TOGGLE_CARD_WINDOW();
		return;
		}

	level = indexElement->ISS_level;
	/* Here's where we open the topic and expand the dlist */
	if (type == T_CLOSED_TOPIC)  {
		numAdds = 0;
//		numRecs = indexElement->ISS_numRecs;
		myDBHan = indexElement->ISS_myDBHan;
		/* lock the closed array */
		cvmbh = VMFind(g_curDocHan, NullHandle, CLOSED_LIST);
		VMLock(g_curDocHan, cvmbh ,&cmh);
		numClosed = ChunkArrayGetCountHandles(cmh, pself->OLDI_closedCArray);
		/* and check the exceptional case of the selected topic being the
			last item in the list */
		if (sel == (pself->OLDI_indexItems - 1))  appendFlag = TRUE;
		/* The idea here is to add the children of the selected topic by going
			through the closed until finding an item which has our topic
			as its parent.  Then we move numRecs items from the closed array
			to the index, adding to numRecs when we encounter an open subtopic
			so we get those extra lines. */
		for (i = 0; i < numClosed; i++) {
			closedElement = ChunkArrayElementToPtrHandles(
						cmh, pself->OLDI_closedCArray, i, 0);
			if (closedElement->ISS_dbHan == myDBHan) {
				move = i;
				break;
				}
			}
		/* OK we found our first item... start moving em. */
		while (keepGoing) {
			closedElement = ChunkArrayElementToPtrHandles(
						cmh, pself->OLDI_closedCArray, move, 0);
			/* insert or append to index */
			if (appendFlag) {
				/* append it to the index array */
				insertElement = ChunkArrayAppendHandles(
								mh, g_indexCArray, 0);
				}
			else  {
				/* insert it into the index array */
				indexElement = ChunkArrayElementToPtrHandles(
								mh, g_indexCArray, sel + 1 + numAdds, 0);
				insertElement = ChunkArrayInsertAtHandle(
								g_indexCArray, indexElement, 0);
				}
			insertElement->ISS_type = closedElement->ISS_type;
			insertElement->ISS_level = closedElement->ISS_level;
			insertElement->ISS_dbHan = closedElement->ISS_dbHan;
			insertElement->ISS_recNum = closedElement->ISS_recNum;
			insertElement->ISS_numRecs = closedElement->ISS_numRecs;
			insertElement->ISS_myDBHan = closedElement->ISS_myDBHan;
			numAdds++;
			/* ok we've added it to the index - add to our number of passes thru
				this while loop if this is an open topic */
			if (closedElement->ISS_type == T_OPEN_TOPIC)
				numRecs += closedElement->ISS_numRecs;
			/* remove the item from the closed array */
			ChunkArrayDeleteHandle(pself->OLDI_closedCArray, closedElement);
			/* are we done? */
			if (numAdds == numRecs)
				keepGoing = FALSE;
			}  /* end of keepGoing while */
		VMDirty(cmh);
		VMUnlock(cmh);

		pself->OLDI_indexItems += numAdds;
		} /* end of T_CLOSED_TOPIC if */


	/* and here we close the topic and contract the dlist */
	else  {
		numDels = 0;
		/* lock the closed array */
		cvmbh = VMFind(g_curDocHan, NullHandle, CLOSED_LIST);
		VMLock(g_curDocHan, cvmbh ,&cmh);
		/* Go down the list and move each item to the closed array until
			we come across an item at or above our level */
		while (keepGoing) {
			indexElement = ChunkArrayElementToPtrHandles(
						mh, g_indexCArray, sel + 1, 0);
			if (indexElement->ISS_level > level) {
				/* add it to the closed array */
				closedElement = ChunkArrayAppendHandles(
							cmh, pself->OLDI_closedCArray, 0);
				closedElement->ISS_type = indexElement->ISS_type;
				closedElement->ISS_level = indexElement->ISS_level;
				closedElement->ISS_dbHan = indexElement->ISS_dbHan;
				closedElement->ISS_recNum = indexElement->ISS_recNum;
				closedElement->ISS_numRecs = indexElement->ISS_numRecs;
				closedElement->ISS_myDBHan = indexElement->ISS_myDBHan;
				/* remove it from the index array */
				ChunkArrayDeleteHandle(g_indexCArray, indexElement);
				numDels++;
				}
			else keepGoing = FALSE;
			}  /* end of keepGoing while */
		VMDirty(cmh);
		VMUnlock(cmh);

		pself->OLDI_indexItems -= numDels;
		}  /* end of T_OPEN_TOPIC else */

	/* now reset our type */
	indexElement = ChunkArrayElementToPtrHandles(
					mh, g_indexCArray, sel, 0);
	if (type == T_OPEN_TOPIC) {
		indexElement->ISS_type = T_CLOSED_TOPIC;
		newType = T_CLOSED_TOPIC;
		}
	else {
		indexElement->ISS_type = T_OPEN_TOPIC;
      newType = T_OPEN_TOPIC;
		}
	VMDirty(mh);
	VMUnlock(mh);

	/* save the new number of items */
	vmbh = VMGetMapBlock(g_curDocHan);
	VMmapPtr = VMLock(g_curDocHan, vmbh, &vmh);
	VMmapPtr->VMMS_indexItems = pself->OLDI_indexItems;
	VMDirty(vmh);
	VMUnlock(vmh);

	/* and redraw the list */
	@send CardDList::MSG_GEN_DYNAMIC_LIST_INITIALIZE(pself->OLDI_indexItems);
	@send CardDList::MSG_GEN_ITEM_GROUP_SET_SINGLE_SELECTION(pself->OLDI_curSel, FALSE);

	/* set the triggers */
	if (newType == T_CLOSED_TOPIC) {
		@send SaveCardButton::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
		@send SaveCardTool::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
		@send CreateSTopicButton::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
		@send NewSTopicTool::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
		@send DeleteTopicTrigger::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
		@send DelTopicTool::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
		@send MoveTopicTrigger::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
		@send MoveTopicTool::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
		}
	else  {
		@send SaveCardButton::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
		@send SaveCardTool::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
		@send CreateSTopicButton::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
		@send NewSTopicTool::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
		@send DeleteTopicTrigger::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
		@send DelTopicTool::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
		@send MoveTopicTrigger::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
		@send MoveTopicTool::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
		}

}

/***********************************************************************
 *
 * MESSAGE:		MSG_OLINER_DOC_OPEN_EDIT_TOPIC for OLDocumentClass
 *
 * DESCRIPTION:
 *
 *
 * PARAMETERS:
 *
 *
 *
 ***********************************************************************/
@method OLDocumentClass, MSG_OLINER_DOC_OPEN_EDIT_TOPIC
{
 word					sel, recNum;
 MemHandle			mh;
 VMBlockHandle    vmbh, dbHan;
 IndexStruct		*indexElement;
 char					tString[MAX_TITLE_LENGTH + 1];


	/* first see if we need to save any changes to a card */
	if (g_cardMayHaveChanged)
		if (!CheckForChanges(pself->OLDI_curSel, oself))
			return;

	sel = @call CardDList::MSG_GEN_ITEM_GROUP_GET_SELECTION();
	if (sel == GIGS_NONE) return;

	/* find the selection's topic dbHan */
	vmbh = VMFind(g_curDocHan, NullHandle, INDEX_LIST);
	VMLock(g_curDocHan, vmbh ,&mh);
	indexElement = ChunkArrayElementToPtrHandles(
				mh, g_indexCArray, sel, 0);
	dbHan = indexElement->ISS_dbHan;
	recNum = indexElement->ISS_recNum;
	VMUnlock(mh);

	/* show the current title */
	GetItemTitle(dbHan, recNum, &tString);
	@call ETopicText::MSG_VIS_TEXT_REPLACE_ALL_PTR(tString, 0);

	/* Open the dialog box */
	@send EditTopicDBox::MSG_GEN_INTERACTION_INITIATE();

}

/***********************************************************************
 *
 * MESSAGE:		MSG_OLINER_DOC_CHANGE_ITEM for OLDocumentClass
 *                (GEN_TRIGGER_ACTION)
 * DESCRIPTION:	NOTICE: trigger is 0 when this method is called after a check
 *                for changed card data
 *
 * PARAMETERS:
 *
 *
 *
 ***********************************************************************/
@method OLDocumentClass, MSG_OLINER_DOC_CHANGE_ITEM
{
 word					sel, recNum, type, size;
 MemHandle			mh;
 VMBlockHandle    vmbh, dbHan;
 IndexStruct		*indexElement;
 BasicDBError		error;
 Boolean				wasProblem = FALSE;
 Boolean				savedOK;
 EventHandle		event;
 BasicDBFieldID	fieldID;
 TimerDateAndTime	date;
 char			dateString[DATE_TIME_BUFFER_SIZE + 1], timeString[15];


	sel = pself->OLDI_curSel;
	if (sel == GIGS_NONE) return;

	/* find the selection's topic dbHan */
	vmbh = VMFind(g_curDocHan, NullHandle, INDEX_LIST);
	VMLock(g_curDocHan, vmbh ,&mh);
	indexElement = ChunkArrayElementToPtrHandles(
				mh, g_indexCArray, sel, 0);
	dbHan = indexElement->ISS_dbHan;
	recNum = indexElement->ISS_recNum;
	type = indexElement->ISS_type;
	VMUnlock(mh);

	/* grab the record from the db */
	if (BasicDBGetRecordByElemNum(g_curDocHan, dbHan, recNum, &mh)) {
		NotifyDBox(0, @BDBGetRecordError);
		return;
		}

	/* save the data */
	savedOK = SaveData(mh, type, dbHan, trigger);

	if (savedOK) {
		/* store the record */
		error = BasicDBSaveRecord(g_curDocHan, dbHan, mh, 0, 0);
		if (error) wasProblem = TRUE;
		}  /* end of saved ok if */
	else wasProblem = TRUE;

	if (wasProblem) {
		NotifyDBox(0, @ErrMsgCouldntSaveRec);
		BasicDBDiscardRecord(mh);
		return;
		}

	if (g_docClosing)  {
		/* don't need any redraws but need to make doc dirty */
		@call oself::MSG_GEN_DOCUMENT_MARK_DIRTY();
		return;
		}
	else {
		/* redraw the topic with the new name */
		event = @record OLDocumentClass::MSG_OLINER_DOC_CARD_DLIST_MONIKER_QUERY(
																  @CardDList, sel);
		@send, forceQueue OLApp::MSG_META_SEND_CLASSED_EVENT(event, TO_MODEL);

		/* and to set the mod date stamp */
//		@send CardDList::MSG_GEN_ITEM_GROUP_SET_MODIFIED_STATE(TRUE);
//		@send CardDList::MSG_GEN_APPLY();
		/* show the mod date */   
		BasicDBGetRecordByElemNum(g_curDocHan, dbHan, recNum, &mh);
		fieldID = BasicDBGetFieldID(mh, BDBFHE_CATEGORY, FIELD_CAT_MOD_DATE, 1);
		size = BasicDBGetFieldData(mh, fieldID, &date, sizeof(TimerDateAndTime));
		if (size) {
			LocalFormatDateTime(dateString, DTF_SHORT, &date);
			LocalFormatDateTime(timeString, DTF_HMS, &date);
			strcat(dateString, "  ");
			strcat(dateString, timeString);
			@call ListModificationDate::MSG_VIS_TEXT_REPLACE_ALL_PTR(dateString, 0);
			}
		else @send ListModificationDate::MSG_VIS_TEXT_DELETE_ALL();
		}


}

/***********************************************************************
 *
 * MESSAGE:		MSG_OLINER_DOC_NEW_CARD for OLDocumentClass
 *
 * DESCRIPTION:	just clears any text and enables save button
 *
 *
 * PARAMETERS:
 *
 *
 *
 ***********************************************************************/
@method OLDocumentClass, MSG_OLINER_DOC_NEW_CARD
{

	/* first see if we need to save any changes to a card */
	if (g_cardMayHaveChanged)
		if (!CheckForChanges(pself->OLDI_curSel, oself))
			return;

	@send CardTitle::MSG_VIS_TEXT_DELETE_ALL();
	@send CardText::MSG_VIS_TEXT_DELETE_ALL();

	@send NewCardButton::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
	@send NewCardTool::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
	@send SaveCardButton::MSG_GEN_SET_ENABLED(VUM_NOW);
	@send SaveCardTool::MSG_GEN_SET_ENABLED(VUM_NOW);

}


