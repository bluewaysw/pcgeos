/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	Copyright (c) Geoworks 1996 -- All Rights Reserved

PROJECT:	
MODULE:		
FILE:		lview.goh

AUTHOR:		jimmy, Mar 26, 1996

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	jimmy	3/26/96  	Initial version.

DESCRIPTION:
	

        $Id: lview.goc,v 1.3 98/10/14 02:13:59 martin Exp $
	$Revision: 1.3 $

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/

@include "lviewint.goh"
@include <Legos/gadget.goh>
@include <Legos/legosapp.goh>
#include <Legos/Internal/runtask.h>

void *
ECCheckPSelf(void *pself, optr oself , void *class);

#if ERROR_CHECK
#ifndef DO_DBCS

/* CURROOT will be spit out by goc, but not by DBCS goc */
#define ECP_join(x,y) x##y
#define ECP_join2(A,B) ECP_join(A,B)
#define ECPSelf(pself) (( ECP_join2(__CURROOT, Instance) *) ECCheckPSelf(pself, oself, &ECP_join2(__CURROOT, Class)))
#else
#define ECPSelf(pself) pself
#endif
#else
#define ECPSelf(pself) pself
#endif

typedef enum
{
    ERROR_PSELF_NOT_POINTING_TO_THE_RIGHT_PLACE=51,
    ERROR_PSELF_NOT_POINTING_TO_THE_RIGHT_OBJECT,

} FatalErrors;

extern FatalErrors phat;

@class LViewProcessClass, GenProcessClass;
@endc

/* pointer to gandalfs app object, so we can talk directly to the
 * builder when neccessary
 */
optr	gandalf;

/* Number of pending RunUnloadModule calls we have
 * Only when all of them are done, we can send off MSG_LA_STOP_COMPLETE()
 */
word	hack_pendingDestroys = 0;



@classdecl  LViewProcessClass, neverSaved;
@classdecl LViewInterpClass;
@classdecl LViewAppClass;

@start AppResource;

@object LViewAppClass LViewApp = 
{
/*    GI_visMoniker = list{ @monikerText } */
    
/*    gcnList(MANUFACTURER_ID_GEOWORKS,MGCNLT_ACTIVE_LIST) = @reloc @Interpreter;*/
/*    HINT_DEFAULT_TARGET;*/
}
/*
 * The app needs to have a moniker so minimizing the primary doesn't die
 */
@visMoniker monikerText = "Legos App";


@end AppResource;

@start Interface;

@object AlarmServerClass AlarmServer = {
}

@object LViewInterpClass Interpreter = {
    IC_alarmServer = @AlarmServer;
}

@end Interface;




/*********************************************************************
 *			RunDefaultModuleInView
 *********************************************************************
 * SYNOPSIS: 	When the viewer gets initiated, tell it to load
 *		the system module or whatever is specified in the .ini file.
 *		It is done here instead of in the view as the viewer doesn't
 *		really know when things are ready to roll (it sends this
 *		message back to us.)
 * CALLED BY:	Handshake 
 * PASS:	viewInterp		- optr
 *		viewTask		- MemHandle
 * RETURN:	nada
 * SIDE EFFECTS:
 * STRATEGY:
 *		See if they specify a module in the .ini file, else
 *		use the system module.
 *
 *	    	this code has been moved to view where it belongs
 *
 * REVISION HISTORY:
 *	Name	Date		Description			     
 *	----	----		-----------			     
 *	RON	9/ 7/95	Initial version
 * 
 *********************************************************************/
void
RunDefaultModuleInView(optr viewInterp)
{
    MemHandle	ptaskHan;
    RTaskHan	rtaskHan;
    TCHAR *modName = _TEXT("DOS://~T/LV_SYSTM");
    
    optr	app;

    app = GeodeGetAppObject(0);
    
    ptaskHan = @call viewInterp::MSG_INTERP_GET_STATE();
    rtaskHan = RunLoadModule(ptaskHan, modName, app);
    
    @call viewInterp::MSG_INTERP_SET_SYSTEM_MODULE(rtaskHan);
}


/***********************************************************************
 *		MSG_COMPILE_INTERP_CREATE_RTASK for LViewInterpClass
 ***********************************************************************
 * SYNOPSIS:	
 * PARAMETERS:	
 * SIDE EFFECTS:
 *
 * STRATEGY:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jimmy	4/12/96   	Initial Revision
 *
 ***********************************************************************/
@method LViewInterpClass, MSG_COMPILE_INTERP_CREATE_RTASK
{
    RTaskHan	rtaskHan;

    /* always start up a new system module first */
    RunDefaultModuleInView(@Interpreter);
    rtaskHan = @callsuper();

    /* Hack -- for dloft's idea of using loadmoduleshared to ease
     * multi-module debugging
     */
    ;{
	RunTask*	rtask;
	rtask = MemLock(rtaskHan);
	rtask->RT_shared = TRUE;
	MemUnlock(rtaskHan);
    }
    /* HACK -- BOOT_RTASK here because caller (gandalf) can't do it --
     * it must @send the CREATE_RTASK and so can't get the return value
     */
    @call self::MSG_COMPILE_INTERP_BOOT_RTASK(rtaskHan);
    /* might have been unloaded */
    rtaskHan = @call LViewApp::MSG_LVA_GET_ACTIVE_MODULE();

    return rtaskHan;
}	/* End of MSG_COMPILE_INTERP_CREATE_RTASK.	*/

/***********************************************************************
 *		MSG_COMPILE_INTERP_BOOT_RTASK for LViewInterpClass
 ***********************************************************************
 * SYNOPSIS:	
 * PARAMETERS:	
 * SIDE EFFECTS:
 *
 * STRATEGY:	
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	dubois	9/ 5/96   	Initial Revision
 *
 ***********************************************************************/
@method LViewInterpClass, MSG_COMPILE_INTERP_BOOT_RTASK
{
    byte	args[6] = {1, TYPE_STRING, 0,0,0,0};
    PTaskHan    ptaskHan;

    ptaskHan = @call Interpreter::MSG_INTERP_GET_STATE();

    @call LViewApp::MSG_LVA_SET_ACTIVE_MODULE(rtaskHan);
    @callsuper();		/* do duplo_ui */

    /* silly module might be unloaded by now */
    rtaskHan = @call LViewApp::MSG_LVA_GET_ACTIVE_MODULE();
    if (rtaskHan != NullHandle) 
	RunCallFunction(rtaskHan, _TEXT("module_goTo"), args, NULL, NULL);

    rtaskHan = @call LViewApp::MSG_LVA_GET_ACTIVE_MODULE();
    if (rtaskHan != NullHandle) 
	RunCallFunction(rtaskHan, _TEXT("module_show"), NULL, NULL, NULL);
    
}	/* End of MSG_COMPILE_INTERP_BOOT_RTASK.	*/

/* prevent a state file from being created */
@method LViewProcessClass, MSG_GEN_PROCESS_CREATE_NEW_STATE_FILE
{
    return NullHandle;
}

/*********************************************************************
 *			OpenApplication
 *********************************************************************
 * SYNOPSIS: 	do some initialization
 * CALLED BY:
 * PASS:	AppAttachFlags		attachFlags
 *		MemHandle		launchBlock
 *		MemHandle		extraState
 * RETURN:
 * SIDE EFFECTS:
 * STRATEGY:
 * REVISION HISTORY:
 *	Name	Date		Description			     
 *	----	----		-----------			     
 *	jimmy	6/20/94		Initial version			     
 * 
 *********************************************************************/

@method	LViewProcessClass,	MSG_GEN_PROCESS_OPEN_APPLICATION
{
    const char _far *code;
    AppLaunchBlock *alb;

    /* Required alarm server init shme
     * FIXME: can some of this be done by META_ATTACH since
     * it's on the active list?
     */
    @send LViewApp::MSG_META_GCN_LIST_ADD
	(@AlarmServer, MGCNLT_ACTIVE_LIST, MANUFACTURER_ID_GEOWORKS);
    @call AlarmServer::MSG_META_INITIALIZE();
    @call AlarmServer::MSG_AS_LOAD_DATA(0);

    @send LViewApp::MSG_META_GCN_LIST_ADD
	(@Interpreter, MGCNLT_ACTIVE_LIST, MANUFACTURER_ID_GEOWORKS);
    
    @callsuper();
    /*
     * Setup moniker on app
     */
    @call LViewApp::MSG_GEN_REPLACE_VIS_MONIKER_TEXT(_TEXT("Legos App"),VUM_DELAYED_VIA_APP_QUEUE);
    @call LViewApp::MSG_META_ADD_VAR_DATA(HINT_DEFAULT_TARGET, 0, 0);

    @call LViewApp::MSG_LVA_SET_STOP_TYPE(ST_STOP);
}


/*********************************************************************
 *			Handshake
 *********************************************************************
 * SYNOPSIS: 	sent after we were opened via IACP.
 *		We need to tell our client what our Interp Object is
 * CALLED BY:	IACP - MSG_LA_HANDSHAKE
 * PASS:	optr callerObject
 * RETURN:	nada, Send a message back to the optr passed in
 * SIDE EFFECTS:
 * STRATEGY:
 *		Our client wants to be notified via 
 *              The identical message
 * REVISION HISTORY:
 *	Name	Date		Description			     
 *	----	----		-----------			     
 *	ron	10/20/94	Initial version			     
 *
 *      jimmy     10/26/94        Smoothed it out a bit
 *********************************************************************/

@method LViewAppClass, MSG_LA_HANDSHAKE
{
    /* save away gandalfs app object optr so we can chat as needed */
    gandalf = callerObject;
    @send callerObject::MSG_LA_HANDSHAKE(@Interpreter);
}

/*********************************************************************
 *			EndProgram
 *********************************************************************
 * SYNOPSIS: 	Copied from Jimmy's changes to bastest to ensure
 *              clean shut down. Recorded by the process's CLOSE_APPLICATION
 *              message.
 * CALLED BY:	
 * PASS:
 * RETURN:
 * SIDE EFFECTS:
 * STRATEGY:
 * REVISION HISTORY:
 *	Name	Date		Description			     
 *	----	----		-----------			     
 *	jimmy	 2/ 9/95	Initial version
 * 
 *********************************************************************/
@method LViewAppClass, MSG_LA_END_PROGRAM
{
    if (pself->LVAI_stopType == ST_STOP)  {
	/* indicate that we are going to shutdown */
	pself->LVAI_stopType = ST_SHUTDOWN;
    }
    @send , forceQueue oself::MSG_LA_STOP();
}

/*********************************************************************
 *			EndProgram
 *********************************************************************
 * SYNOPSIS: 	Copied from Jimmy's changes to bastest to ensure
 *              clean shut down. Recorded by the process's CLOSE_APPLICATION
 *              message.
 * CALLED BY:	
 * PASS:
 * RETURN:
 * SIDE EFFECTS:
 * STRATEGY:
 * REVISION HISTORY:
 *	Name	Date		Description			     
 *	----	----		-----------			     
 *	jimmy	 2/ 9/95	Initial version			     
 * 
 *********************************************************************/
@method LViewAppClass, MSG_META_APP_SHUTDOWN
{
    ObjInitDetach(message, oself, callerID, ackOD);
    pself = ObjDerefEnt(oself);

    /* if stopType is ST_STOP then we have not yet recieved an END_PROGRAM
     * from gandalf, so just set up a detach count of one and wait for
     * gandalf to come around, this way our exit procedure is always
     * synced up with gandalf
     */	
    if (ECPSelf(pself)->LVAI_stopType == ST_STOP)
    {
	/* this tells LVA_STOP to do the EnableDetach */
	ECPSelf(pself)->LVAI_stopType = ST_SHUTDOWN_DETACH;
	ObjIncDetach(oself);
    }
    @callsuper();
    ObjEnableDetach(oself);
}


/***********************************************************************
 *		MSG_LA_DESTROY_COMPONENTS for LViewAppClass
 ***********************************************************************
 * SYNOPSIS:	
 * PARAMETERS:	
 * SIDE EFFECTS:
 *
 * STRATEGY:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jimmy	3/25/96   	Initial Revision
 *
 ***********************************************************************/
void
LViewDestroyComponents()
{
    EventHandle	event;

    event = @record EntClass::MSG_ENT_DESTROY();
    @call LViewApp::MSG_ENT_SEND_TO_CHILDREN(event);  /* frees event */
}


/*********************************************************************
 *			LVADestroyEntChildren
 *********************************************************************
 * SYNOPSIS: cleanup all the runtime stuff we can
 * CALLED BY:	
 * RETURN:
 * SIDE EFFECTS:    destroys ent children, frees non-main run tasks
 * STRATEGY:
 * REVISION HISTORY:
 *	Name	Date		Description			     
 *	----	----		-----------			     
 *	jimmy	 3/27/95	Initial version
 *	jmagasin 1/30/96	Clear out LAI_active<Form,Modal,etc.>
 * 
 *********************************************************************/

extern void InstallSysIdleHandler(void);
extern void UninstallSysIdleHandler(void);

@method LViewAppClass, MSG_LA_STOP
{
    @send , forceQueue LViewApp::MSG_LVA_STOP(0);
}

@method LViewAppClass, MSG_LVA_STOP
{
    EventHandle event;

    /* this was originally done as an extra level of synchronization
     * giving time for the components to go away, since that now does not
     * happen until Idle time, it may or may not be neccessary, but things
     * are working so well right now I don't want to touch it. Also there was
     * a lot of work done in making lview exit in sync with gandalf on system
     * shutdowns, so this might help that out as well so don't touch! - jimmy
     */
    if (quitLevel == 0)
    {
	event = @record LViewApp::MSG_LVA_STOP(1);
	@send process::MSG_META_OBJ_FLUSH_INPUT_QUEUE(event, 0, 
						      HandleOf(@LViewApp));
    }
    else
    {
	MemHandle   progTask;

	progTask = @call Interpreter::MSG_INTERP_GET_STATE();
	pself = ObjDerefEnt(oself);
	switch (ECPSelf(pself)->LVAI_stopType)
	{
	case ST_STOP:
#if 0	    
	    /* we are only stopping, not actually shutting down so just
	     * kill off any tasks that got loaded while we were running
	     * we do this be installing an idle handler and then killing
	     * stuff off at idle time
	     */
	    InstallSysIdleHandler();
#endif
	    @call LViewApp::MSG_LVA_DESTROY_MODULES();
	    break;
	case ST_SHUTDOWN_DETACH:
	    ProgDestroyTask(progTask);
	    ObjEnableDetach(oself);
	    break;
	case ST_SHUTDOWN:
#ifdef __BORLANDC__
	    UninstallSysIdleHandler();
#endif
	    ProgDestroyTask(progTask);
	    @call self::MSG_META_QUIT();
	    break;
	}
    }
}

@method LViewAppClass, MSG_LVA_SET_STOP_TYPE
{
    pself->LVAI_stopType = value;
}

@method LViewAppClass, MSG_LVA_GET_ACTIVE_MODULE
{
    return pself->LVAI_activeModule;
}

@method LViewAppClass, MSG_LVA_SET_ACTIVE_MODULE
{
    pself->LVAI_activeModule = activeModule;
}


/***********************************************************************
 *		MSG_LVI_INIT_PROGRAM for LViewInterpClass
 ***********************************************************************
 * SYNOPSIS:	do startup cruft
 * PARAMETERS:	vmFile handle
 * SIDE EFFECTS:
 *
 * STRATEGY:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jimmy	11/27/95   	Initial Revision
 *
 ***********************************************************************/
@method LViewInterpClass, MSG_LVI_INIT_PROGRAM
{
    PTaskHan	viewTask;

    viewTask = @call Interpreter::MSG_INTERP_INIT_PROGRAM(vmHandle);
    ProgTurboChargeFido(viewTask);
    @call Interpreter::MSG_INTERP_SET_STATE(viewTask);
    /*
     * Tell the view to run the default ui module on startup.
    RunDefaultModuleInView(@Interpreter);
     */
    return viewTask;
}	/* End of MSG_LVI_INIT_PROGRAM.	*/

/*********************************************************************
 *			GetProcessHandle
 *********************************************************************
 * SYNOPSIS: 	Return the process handle
 * CALLED BY:	Builder so it can compare dying apps against this one
 * PASS:
 * RETURN:
 * SIDE EFFECTS:
 * STRATEGY:
 * REVISION HISTORY:
 *	Name	Date		Description			     
 *	----	----		-----------			     
 *	jimmy	11/ 7/94		Initial version			     
 * 
 *********************************************************************/

@method LViewInterpClass, MSG_LVI_GET_PROCESS_HANDLE
{
    return GeodeGetProcessHandle();
}

/*********************************************************************
 *			GetContainerApp
 *********************************************************************
 * SYNOPSIS: 	Return optr of viewer app so builder can shut it
 *              down when needed
 * CALLED BY:	Builder.
 * PASS:
 * RETURN:
 * SIDE EFFECTS:
 * STRATEGY:
 * REVISION HISTORY:
 *	Name	Date		Description			     
 *	----	----		-----------			     
 *	jimmy	11/ 8/94		Initial version			     
 * 
 *********************************************************************/
@method LViewInterpClass, MSG_LVI_GET_CONTAINER_APP
{
    return @LViewApp;
}

/***********************************************************************
 *		MSG_INTERP_UNLOAD_COMPLETE for LViewAppClass
 ***********************************************************************
 * SYNOPSIS:	When all pending unloads are done, send LA_STOP_COMPLETE
 * PARAMETERS:	none
 * SIDE EFFECTS:
 *
 * STRATEGY:	
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	dubois	7/23/96   	Initial Revision
 *
 ***********************************************************************/
@method LViewInterpClass, MSG_INTERP_UNLOAD_COMPLETE
{
    /* Super has no default functionality */
    if (--hack_pendingDestroys == 0) {
	@send , forceQueue gandalf::MSG_LA_STOP_COMPLETE();
    }
}	/* End of MSG_INTERP_UNLOAD_COMPLETE.	*/


/*
 * Define the class to be void * so we can cast all classes to it without
 * getting silly warnings.  We'll turn off the warning inside here.
 */
#pragma argsused
void *ECCheckPSelf(void *pself, optr oself, void *class) {
#if ERROR_CHECK
    void *shouldBe;
    MemHandle ECBlock;
    
    ErrorCheckingFlags	ecFlags, newECFlags;
    
    ecFlags = SysGetECLevel(&ECBlock);
    newECFlags = ecFlags | ECF_HIGH | ECF_NORMAL;
    SysSetECLevel(newECFlags, ECBlock);

    shouldBe = ObjDeref(oself, ((const ClassStruct *) class)->Class_masterOffset);

    EC_ERROR_IF(pself != shouldBe, ERROR_PSELF_NOT_POINTING_TO_THE_RIGHT_PLACE);
    EC_ERROR_IF(!ObjIsObjectInClass(oself, class), ERROR_PSELF_NOT_POINTING_TO_THE_RIGHT_OBJECT);
    SysSetECLevel(ecFlags, ECBlock);
    
#endif

    
    return pself;
}




/***********************************************************************
 *		MSG_LVA_DESTROY_COMPONENTS for LViewAppClass
 ***********************************************************************
 * SYNOPSIS:	destroys components then sends message to destroy modules
 * PARAMETERS:	
 * SIDE EFFECTS:
 *
 * STRATEGY:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jimmy	3/26/96   	Initial Revision
 *
 ***********************************************************************/
@method LViewAppClass, MSG_LVA_DESTROY_COMPONENTS
{
    MemHandle   progTask;
    EventHandle	event;

#if 0
    LViewDestroyComponents();
#endif
    event = @record LViewApp::MSG_LVA_DESTROY_MODULES();

    /* once again, I found a need to go though a flush queue to sync things up.
     * here I am flushing all the object deletion stuff before going on to
     * destroy the modules so that we dont do an ObjFreeObjBlock until after
     * all object destruction is completely done
     */
    @send process::MSG_META_OBJ_FLUSH_INPUT_QUEUE(event, 0, 
					       HandleOf(@LViewApp));
}

/***********************************************************************
 *		MSG_LVA_DESTROY_MODULES for LViewAppClass
 ***********************************************************************
 * SYNOPSIS:	destroys components then sends message to destroy modules
 * PARAMETERS:	
 * SIDE EFFECTS:
 *
 * STRATEGY: this is the very last thing to happen when a STOP is pressed
 *	    	in the builder on the lview side. We now should be able
 *	    	to destroy the modules and send back a STOP_COMPLETE
 *	    	informing the builder we are really done
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jimmy	3/26/96   	Initial Revision
 *
 ***********************************************************************/
@method LViewAppClass, MSG_LVA_DESTROY_MODULES
{
    MemHandle	rtaskHan;
    MemHandle	bugHandle;
    rtaskHan = @call LViewApp::MSG_LVA_GET_ACTIVE_MODULE();
    if (rtaskHan != NullHandle) 
    {
	@call LViewApp::MSG_LVA_SET_ACTIVE_MODULE(NullHandle);

	/* clear out the bug handle so it allows us to unload the module */
	bugHandle = BugGetBugHandleFromRTask(rtaskHan);
	RunTaskSetBugHandle(rtaskHan, NullHandle);
	/* tell bug handle its not associated with a running rtask anymore */
	BugSetBugHandleNotRunning(bugHandle);
	hack_pendingDestroys++;
	RunUnloadModule(NULL, rtaskHan, TRUE, MSG_INTERP_UNLOAD_COMPLETE);
    }
    rtaskHan = @call Interpreter::MSG_INTERP_GET_SYSTEM_MODULE();
    if (rtaskHan != NullHandle)
    {
	@call Interpreter::MSG_INTERP_SET_SYSTEM_MODULE(NullHandle);
	hack_pendingDestroys++;
	RunUnloadModule(NULL, rtaskHan, TRUE, MSG_INTERP_UNLOAD_COMPLETE);
    }

    /* MSG_LA_STOP_COMPLETE moved to MSG_INTERP_UNLOAD_COMPLETE */
}	/* End of MSG_LVA_DESTROY_STUFF.	*/








