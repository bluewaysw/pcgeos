COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	(c) Copyright GeoWorks 1988-1995.  All Rights Reserved.
	GEOWORKS CONFIDENTIAL

PROJECT:	GEOS
MODULE:		CommonUI (common code for specific ui's to use.)
FILE:		cConstant.def

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	Tony	2/89		Initial version
	Eric	7/89		Motif additions

DESCRIPTION:

	This file contains constants global to the Open Look library

	$Id: cConstant.def,v 2.358 97/04/01 23:05:18 joon Exp $

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@

;------------------------------------------------------------------------------
;  FULL_EXECUTE_IN_PLACE : Indicates that the styles lib is going to
;	be used in a system where all geodes (or most, at any rate)
;	are to be executed out of ROM.  
;------------------------------------------------------------------------------
ifndef FULL_EXECUTE_IN_PLACE
	FULL_EXECUTE_IN_PLACE		equ	FALSE
endif


;------------------------------------------------------------------------------
;  The .GP file only understands defined/not defined;
;  it can not deal with expression evaluation.
;  Thus, for the TRUE/FALSE conditionals, we define
;  GP symbols that _only_ get defined when the
;  condition is true.
;-----------------------------------------------------------------------------
if	FULL_EXECUTE_IN_PLACE
	LAST_XIP_RESOURCE_HANDLE	equ	<handle -1>
	GP_FULL_EXECUTE_IN_PLACE	equ	TRUE
endif

; Be sure to clear this flag in Library/User/uiConstant.def &
; Library/User/UI/uiManager.ui as well.

FAKE_SIZE_OPTIONS	=	TRUE	; TRUE to include routines that check
					; .ini flags to allow alteration  of
					; screen & field size, allow addition
					; of on-screen hard icon sizes.

;------------------------------------------------------------------------------
;		Structures
;------------------------------------------------------------------------------

ColorSchemeFlags	record
	CSF_BW:1
	; Set if a DC_GREY_1, i.e. B&W system
	CSF_TINY:1
	; Set if a tiny screen
	CSF_VERY_NARROW:1		;DO NOT MOVE!   Assertions will die.
	; Set for DS_TINY systems only.
	CSF_VERY_SQUISHED:1		;DO NOT MOVE!   Assertions will die.
	; Set for both DAR_VERY_SQUISHED systems only.
	:4
ColorSchemeFlags	end

;------------------------------------------------------------------------------
;		Fatal errors
;------------------------------------------------------------------------------

	; The "FatalErrors" type is declared in errorcheck.def

if	ERROR_CHECK

OL_QUERY_NOT_ANSWERED					enum FatalErrors
OL_BUSY_COUNT_OVERFLOW					enum FatalErrors
OL_BUSY_COUNT_UNDERFLOW					enum FatalErrors
OL_HOLD_UP_INPUT_COUNT_OVERFLOW				enum FatalErrors
OL_HOLD_UP_INPUT_COUNT_UNDERFLOW			enum FatalErrors
OL_IGNORE_INPUT_COUNT_OVERFLOW				enum FatalErrors
OL_IGNORE_INPUT_COUNT_UNDERFLOW				enum FatalErrors
OL_BUTTON_LOST_ACTIVE_EXCL_WHILE_DOWN			enum FatalErrors
OPEN_WIN_ON_OPEN_WINDOW					enum FatalErrors
OL_MOVE_RESIZE_NO_WINDOW				enum FatalErrors
OL_SPEC_BUILD_NO_PARENT					enum FatalErrors
OL_OPEN_WIN_SPEC_BUILD_CANNOT_HANDLE_NON_WIN_GROUP_BUILD enum FatalErrors
OL_CANT_RESET_GEOMETRY_ON_NON_WIN_GROUP			enum FatalErrors
OL_CANT_DEAL_WITH_LONG_MONIKER_YOURE_HOSED		enum FatalErrors
OL_WIN_ICON_CREATED_IN_DIFF_OBJECT_BLOCK_THAN_PRIMARY	enum FatalErrors
OL_CANNOT_CENTER_WITHOUT_SIZE				enum FatalErrors
OL_CANNOT_EXTEND_WITHOUT_POSITION			enum FatalErrors
OL_WIN_POSITION_OR_SIZE_INVALID_AFTER_UPDATE		enum FatalErrors
OL_ILLEGAL_WIN_POSITION_FLAG				enum FatalErrors
OL_ILLEGAL_WIN_SIZE_FLAG				enum FatalErrors
OL_WIN_ICON_SHOULD_NOT_BE_ON_ACTIVE_LIST		enum FatalErrors
OL_OPENWINVISBUILD_CANNOT_HANDLE_PRIMARY_OR_DISPLAY_WIN	enum FatalErrors
OL_APPLICATION_CANNOT_SET_SIZE_FOR_WIN_ICON		enum FatalErrors
OL_BAD_VIS_UPDATE_MODE					enum FatalErrors
OL_BAD_WIN_POSITION_TYPE				enum FatalErrors
OL_BAD_WIN_SIZE_TYPE					enum FatalErrors
OL_BAD_WIN_CONSTRAIN_TYPE				enum FatalErrors
OL_BAD_RANGE_ATTRIBUTES					enum FatalErrors
OL_BAD_RANGE						enum FatalErrors
OL_BAD_SPIN_ATTRIBUTES					enum FatalErrors
OL_RANGE_MUST_BE_DELAYED_WHEN_EDITABLE			enum FatalErrors
OL_BUILD_FLAGS_MULTIPLE_TARGETS				enum FatalErrors
OL_BUILD_FLAGS_MULTIPLE_REPLIES				enum FatalErrors
OL_MASTER_DEFAULT_MUST_BE_ALLOWED_TEMPORARY_DEFAULT	enum FatalErrors
OL_WINDOW_CANNOT_HAVE_MORE_THAN_ONE_DEFAULT_TRIGGER	enum FatalErrors
OL_TEXT_DISPLAY_VIS_UNBUILD_DOES_NOT_SUPPORT_USABLE_UNBUILD enum FatalErrors
OL_TEXT_DISPLAY_VIS_UNBUILD_PASSED_NON_BUILT_OBJECT	enum FatalErrors
OL_NAVIGATION_QUERY_TO_FOCUSED_OBJECT_FAILED		enum FatalErrors
OL_NAVIGATION_QUERY_TO_PREVIOUS_OBJECT_FAILED		enum FatalErrors
OL_BAD_HIER_GRAB_FLAGS_PASSED_TO_MENUED_WINDOW		enum FatalErrors
OL_OPEN_WIN_BAD_VIS_BOUNDS				enum FatalErrors
OL_GEN_SUMMONS_MUST_BE_HAVE_INDEPENDENTLY_DISPLAYABLE_FLAG enum FatalErrors
OL_BROADCAST_FOR_DEFAULT_FOCUS_RETURNED_BAD_OWNER_INFO_FLAGS enum FatalErrors
OL_NON_META_MSG_SENT_TO_VIEW_OUTPUT_OD			enum FatalErrors
OL_NO_RESPONSE_FROM_VUP_QUERY				enum FatalErrors
OL_BUILD_CANT_FIND_MAP_GROUP_DATA			enum FatalErrors

;misc:

OL_SETTING_DYNAMIC_LIST_ENTRY_DIRTY			enum FatalErrors
OL_ILLEGAL_LIST_FLAG_PARAMETER				enum FatalErrors
;OL_ILLEGAL_LIST_EXCLUSIVE				enum FatalErrors
;OL_ILLEGAL_LIST_OPERATION				enum FatalErrors
OL_POPUP_IT_IS_ILLEGAL_TO_BE_BOTH_APP_MODAL_AND_SYS_MODAL enum FatalErrors
OL_TIMER_STARTED_WHILE_ONE_ALREADY_RUNNING		enum FatalErrors
OL_PTR_IN_THE_UNIV_OF_TWO_WINDOWS_AT_ONCE		enum FatalErrors
OL_PTR_LEAVING_UNIV_OF_WINDOW_IT_WAS_NOT_IN		enum FatalErrors
OL_CAN_NOT_FORCE_SYS_MODAL_GRAB_TO_NULL			enum FatalErrors
OL_PTR_IN_THE_RAW_UNIV_OF_TWO_WINDOWS_AT_ONCE		enum FatalErrors
OL_PTR_LEAVING_RAW_UNIV_OF_WINDOW_IT_WAS_NOT_IN		enum FatalErrors
OL_ERROR_ASSUMES_FIELD_AND_START_MENU_IN_SAME_RESOURCE	enum FatalErrors
OL_ASSUMES_STARTUP_MENU_TRIGGER_HAS_VARDATA_ALREADY	enum FatalErrors
USER_STANDARD_DIALOG_HELP_CONTEXT_TOO_LONG		enum FatalErrors

;GenList and GenListEntry setup errors:

OL_ERROR_EXCLUSIVE_GEN_LIST_HAS_TWO_USER_EXCLUSIVES	enum FatalErrors
OL_ERROR_EXCLUSIVE_GEN_LIST_HAS_TWO_ACTUAL_EXCLUSIVES	enum FatalErrors
OL_ERROR_EXCLUSIVE_GEN_LIST_CANNOT_USE_CHECKBOXES	enum FatalErrors
OL_ERROR_NON_EXCLUSIVE_GEN_LIST_CANNOT_BE_TOOLBOX	enum FatalErrors
OL_ERROR_SIZE_HINT_FOR_GEN_LIST_MUST_USE_SST_COUNT	enum FatalErrors

;GenList and GenListEntry usage errors:

OL_ERROR_ILLEGAL_MSG_FOR_EXCLUSIVE_GEN_LIST		enum FatalErrors
OL_ERROR_ILLEGAL_MSG_FOR_NON_EXCLUSIVE_GEN_LIST		enum FatalErrors
OL_ERROR_ILLEGAL_MSG_FOR_EXCLUSIVE_GEN_LIST_ENTRY	enum FatalErrors
OL_ERROR_MUST_REFERENCE_USER_OR_ACTUAL_EXCL		enum FatalErrors
OL_ERROR_GEN_LIST_NOT_ENABLED				enum FatalErrors
OL_ERROR_GEN_LIST_ENTRY_NOT_ENABLED			enum FatalErrors
OL_ERROR_GEN_LIST_ENTRY_NOT_FOUND			enum FatalErrors
OL_ERROR_SOME_LIST_ERROR				enum FatalErrors
OL_ERROR_GEN_LIST_WITHOUT_USABLE_AND_ENABLED_KIDS_GIVEN_FOCUS enum FatalErrors
OL_ERROR_GEN_LIST_EXCL_OD_HAS_BEEN_TRASHED		enum FatalErrors
OL_ERROR_DYNAMIC_LIST_CANNOT_USE_OD			enum FatalErrors
OL_ERROR_SETTING_SHOULD_HAVE_GAINED_FOCUS_EXCL_HERE_DAMMIT enum FatalErrors
OL_ERROR_DYN_LIST_CHILD_FAILED_TO_ACCEPT_FOCUS_EXCL	enum FatalErrors
OL_ERROR_DYN_LIST_FOCUS_EXCL_DOES_NOT_MATCH_CX		enum FatalErrors
OL_ERROR_DYN_LIST_SHOULD_BE_NO_FOCUS_EXCL_OD		enum FatalErrors
OL_ERROR_DYN_LIST_LOST_STATE_FLAG_FOR_FOCUS		enum FatalErrors
OL_ERROR_DYN_LIST_SUPERCLASS_FAILED_TO_RESET_FOCUS_EXCL_OD enum FatalErrors
OL_ERROR_LF_DIRECT_USER_ACTION_IS_RESERVED_FLAG		enum FatalErrors
OL_ERROR_PURGE_PARTIAL_DYN_LIST_PASSED_BAD_CX		enum FatalErrors

;OpenDrawMoniker error checking:

OL_ERROR_BAD_OL_MONIKER_ATTRS				enum FatalErrors
OL_ERROR_BAD_OPEN_MONIKER_ARGS_STRUCTURE_PASSED_ON_STACK enum FatalErrors

;GenFileSelector errors:

OL_FILE_SELECTOR_BAD_FILE_TYPES				enum FatalErrors
; Occurs if bad FileSelectorFileTypes are found in the GFSI_fileTypes instance
; field.  Make sure that the correct flags are set in the .ui/.goc file and
; the correct flags are passed to any MSG_GEN_FILE_SELECTOR_SET_FILE_TYPES.

OL_FILE_SELECTOR_BAD_FILE_CRITERIA			enum FatalErrors
; Occurs if bad FileSelectorFileCriteria are found in the GFSI_fileCriteria
; instance file.  Make sure that the correct flags are set in the .ui/.goc file
; and the correct flags passed to any MSG_GEN_FILE_SELECTOR_SET_FILE_CRIETIA.

OL_FILE_SELECTOR_CANT_FIND_CHILD			enum FatalErrors
; Occurs if the object tree for the file selector has been damaged while
; resolving the GenFileSelector into a specific UI class.  Most likely a
; memory trashing problem.

OL_FILE_SELECTOR_OBJECT_MISMATCH			enum FatalErrors
; Internal assumption failed, possibly trashed instance data.

OL_FILE_SELECTOR_DRIVE_TYPE_UNKNOWN			enum FatalErrors
; Drive type for the drive the file selector is attempting to log is
; unknown.

OL_FILE_SELECTOR_BAD_ENTRY_TYPE				enum FatalErrors
; File type of selection is neither file or subdirectory.

OL_FILE_SELECTOR_SORT_PROBLEM				enum FatalErrors
; Sorting of files failed.

OL_FILE_SELECTOR_BOGUS_ERROR				enum FatalErrors
; Rescan error flag incorrectly set.

OL_FILE_SELECTOR_DIDNT_RESOLVE_COMPLETE_PATH		enum FatalErrors
; Result of OLFSResolveVolPathDiskHan is not a complete path.

OL_FILE_SELECTOR_VOLUME_NOT_NULL_TERMED			enum FatalErrors
; GFSI_volume instance field does not contain a null-terminated name.  If
; setting a volume name in .ui/.goc file, make sure it is null-terminated.

OL_FILE_SELECTOR_BAD_ENTRY_NUMBER			enum FatalErrors
; Entry number passed to MSG_GEN_FILE_SELECTOR_OPEN_ENTRY is out of range.
; Valid entry numbers are 0 - (N-1) where N is the number of files in the
; currently displayed file listing.

OL_FILE_SELECTOR_TEMP_DATA_NOT_FOUND			enum FatalErrors
; Occurs whenever the GFSTempDataEntry variable data for a GenFileSelector
; is not found when it is expected to exists.  Most likely, the memory space
; for the object has been trashed.

OLFS_DRIVE_NAME_WONT_FIT				enum FatalErrors
; Some drive's name is longer than the space alloted for it when creating
; the moniker for a dynamic list entry...this is weird.

OLFS_CALLBACK_ATTRS_MISSING_NEEDED_FEA_NATIVE_NAME	enum FatalErrors
; The file selector as ATTR_GEN_FILE_SELECTOR_FILTER_ATTRS and specifies a
; file mask, but the array doesn't contain a descriptor for FEA_NATIVE_NAME,
; which is needed to perform the wildcarding. This is programmer error.
; 

OLFS_FILE_ATTR_MISSING_FROM_CALLBACK_DATA		enum FatalErrors
; The data passed to our callback routine doesn't contain a FileAttrs attribute
; for the file, which it should, since we always request it. This is a bug in
; the kernel or the IFS driver.

OLFS_FILTER_METHOD_CAUSED_OBJECT_TO_MOVE		enum FatalErrors
; Because all the match attributes passed to FileEnum are passed as far
; pointers, anything the handler for MSG_GEN_FILE_SELECTOR_FILTER_FILE does
; to cause the object to move causes the values to be matched to move, thus
; nuking the whole FileEnum process.

OL_WIN_ALREADY_DETACHED					enum FatalErrors
OL_WIN_ALREADY_ATTACHED					enum FatalErrors

;GenDisplay errors:

OL_ERROR_GEN_DISPLAY_PARENT_MUST_BE_GEN_DISPLAY_GROUP	enum FatalErrors

;View errors

OL_VIEW_BAD_SCALE_TYPE					enum FatalErrors
; Only certain scale types can be passed to MSG_GEN_VIEW_SET_SCALE_FACTOR:
; Legal ScaleViewType are SVT_AROUND_UPPER_LEFT, SVT_AROUND_CENTER, and 
; SVT_AROUND_POINT.
  
OL_VIEW_CHILDREN_MUST_BE_IN_SAME_BLOCK			enum FatalErrors
; Any generic children of the view must be placed in the same block.
	
OL_VIEW_CHILD_NEEDS_AREA_HINT				enum FatalErrors
; Any generic child of a view needs one of the hints that describe where around
; the view window the child should try to be placed.  Legal hints include
; HINT_SEEK_X_SCROLLER_AREA, HINT_SEEK_Y_SCROLLER_AREA, HINT_SEEK_LEFT_OF_VIEW,
; HINT_SEEK_TOP_OF_VIEW, HINT_SEEK_RIGHT_OF_VIEW, and HINT_SEEK_BOTTOM_OF_VIEW.
  
OL_VIEW_DOC_TOO_BIG_TO_NOT_BE_SCROLLABLE		enum FatalErrors
; This view can't possibly be sized small enough to fit on any normal screen,
; as the entire document must be visible (since GVA_NO_SMALLER_THAN_DOC_SIZE
; is set). Don't set GVA_NO_SMALLER_THAN_DOC_SIZE and make the view scrollable,
; or figure out how to make your content smaller.
  
OL_VIEW_SCROLLER_HAS_BEEN_DESTROYED			enum FatalErrors
; The view is trying to call a scroller that appears to no longer exist, and
; has been replaced by some other object.  Apps are not allowed to add or 
; remove scrollbars, or set them not usable while the view is onscreen.
; (You can, however, set the GVDA_DONT_DISPLAY_SCROLLBARS attribute to make
; scrollbars go away.)
  
OL_VIEW_SCROLLER_IS_NOT_IN_GEN_TREE			enum FatalErrors
; The view is trying to access a scroller that is no longer in the generic
; tree.  Apps are not allowed to add or remove scrollbars, or set them not
; usable while the view is onscreen.
; (You can, however, set the GVDA_DONT_DISPLAY_SCROLLBARS attribute to make
; scrollbars go away.)
	
OL_VIEW_SCROLLER_CANNOT_BE_MADE_NOT_USABLE		enum FatalErrors
; The view is trying to access a scroller that has been made not usable.
; tree.  Apps are not allowed to add or remove scrollbars, or set them not
; usable while the view is onscreen
; (You can, however, set the GVDA_DONT_DISPLAY_SCROLLBARS attribute to make
; scrollbars go away.)
  
OL_VIEW_CANT_RESOLVE_GEOMETRY_OF_CHILDREN		enum FatalErrors
; The view has made several passes trying to get the children to choose a 
; size that makes everyone happy.  Apparently some object has some complicated
; geometry which is messing things up.  Keep the objects underneath a view
; as simple as possible w.r.t. calculating a size for themselves.
  
OL_VIEW_CALC_WIN_SIZE_BAD_WIDTH				enum FatalErrors
; The view's MSG_GEN_VIEW_CALC_WIN_SIZE apparently has been subclassed and
; is returning a negative or zero width for the view window, which is not
; allowed.
  
OL_VIEW_CALC_WIN_SIZE_BAD_HEIGHT			enum FatalErrors
; The view's MSG_GEN_VIEW_CALC_WIN_SIZE apparently has been subclassed and
; is returning a negative or zero height for the view window, which is not
; allowed.
  
OL_VIEW_CANT_SEND_ABS_MOUSE_COORDS_TO_BIG_CONTENTS	enum FatalErrors
; The view has been told to send absolute mouse coordinates to the content
; (i.e. GVA_WINDOW_COORDINATE_MOUSE_EVENTS is clear).  The content is too
; large for these absolute mouse positions to fit in the legal graphics 
; coordinate space, so you should probably set the above flag and do the
; appropriate things in the content object to treat the coordinates as relative
; to the scrolled window.
  
OL_VIEW_BAD_DRAG_BOUNDS					enum FatalErrors
; Bad bounds were passed to the view in MSG_GEN_VIEW_SET_DRAG_BOUNDS.

OL_VIEW_BAD_FLAGS_PASSED_TO_SCROLLBAR_SETUP		enum FatalErrors
; A bad vertical flag has been passed to SetupScrollbarIfNeeded.  This is
; an internal flag, so probably someone broke the calling routine.
  
OL_VIEW_MUST_PASS_A_META_MSG_TO_NON_GEN_CONTENT	enum FatalErrors
; The view must only pass messages defined under MetaClass to non-generic
; content objects, since they could be a process or a visual object.  This is
; internal, so likely someone has broken the view.
  
OL_VIEW_TEXT_SHOULD_BE_FIRST_CHILD_OF_CONTENT		enum FatalErrors
; The view has OLPA_TEXT_OD set locally, and its content has no first child.
; This probably means that someone has trashed a scrollable text object
; in such a way that an OLTextDisplay object has been removed from the
; OLContent.  It should always be the first child of the content.
	
OL_VIEW_BAD_CHILD_AREA_OFFSET				enum FatalErrors
; This is an internal error -- somehow the view has screwed up its calculations
; for what area to look for one of the children under it.  Probably someone
; broke GetObjectAreaChoice, but perhaps a bad hint was added to an object
; that is a child of the view.
	
OL_VIEW_EXPECTED_A_CHILD_IN_AREA			enum FatalErrors
; A child was supposed to be in one of the view's four areas, and there wasn't
; anything there.  Probably someone broke OLPaneGetVisParent, but trashed
; vis instance data is also a likely culprit.
  
OL_BAD_FLAG_PASSED_TO_SCROLL_ROUTINE			enum FatalErrors
; Some internal routine has screwed up, and is no longer passing a legal
; vertical flag to ScrollIntoOneDimension.
							
OL_VIEW_BAD_WINDOW_SIZE_ADJUSTMENTS			enum FatalErrors
; Some adjustments were made to the size of a view window which caused its
; width or height to be zeroed.  Check to make sure your HINT_MINIMUM_SIZE,
; HINT_MAXIMUM_SIZE, HINT_FIXED_SIZE arguments don't cause this.  You also
; might be setting GVA_VIEW_FOLLOWS_CONTENT_GEOMETRY and that content's
; MSG_VIS_RECALC_SIZE is returning a zero height or width.
	
OL_VIEW_KEEP_ORIGIN_IN_BOUNDS_BAD_FLAGS_RETURNED	enum FatalErrors
; The internal routine KeepOriginInBounds has been broken by someone.
; Only OLPF_AT_RIGHT_EDGE or OLPF_AT_BOTTOM_EDGE should be returned in di.
	
OL_VIEW_BAD_FLAG_PASSED_TO_KEEP_VALUE_IN_BOUNDS		enum FatalErrors
; A bad vertical flag was passed to the internal routine KeepValueInBounds, 
; probably due to someone breaking the calling routine.
	
OL_VIEW_TRACK_SCROLLING_HANDLER_DID_NOT_CALL_SETUP	enum FatalErrors
; You MUST call GenSetupTrackingArgs (or call MSG_GEN_VIEW_SETUP_TRACKING_
; ARGS in C) at the beginning of a MSG_META_CONTENT_TRACK_SCROLLING 
; handler, to make sure you have the current bounds, doc offset, etc.
; (there are synchronization problems if you don't update various track
; scrolling parameters from the application thread.)

OL_VIEW_ALREADY_HAS_EXLUSIVE				enum FatalErrors
; Called if view receives a MSG_META_GAINED_FOCUS/TARGET/etc._EXCL when it 
; already has the exclusive.  This illegal condition should never happen,
; as GAIN/LOST messages should always be paired.

OL_VIEW_DOES_NOT_HAVE_EXLUSIVE				enum FatalErrors
; Called if view receives a MSG_META_LOST_FOCUS/TARGET/etc._EXCL when it does not
; have the exclusive.  This illegal condition should never happen,
; as GAIN/LOST messages should always be paired.

OL_VIEW_RECT_TO_MAKE_VISIBLE_HAS_NEGATIVE_SIZE		enum FatalErrors
; The rectangle specified to MSG_GEN_VIEW_MAKE_RECT_VISIBLE seems to
; have a negative height or width.  Make sure top < bottom, and left < right
; for the rect.

OL_VIEW_RECT_TO_MAKE_VISIBLE_TOO_LARGE			enum FatalErrors
; The rectangle specified by MSG_GEN_VIEW_MAKE_RECT_VISIBLE has a large
; (> 64K) width or height.  The routine only handles rectangles smaller
; than that.
  
OL_VIEW_GVIT_QUERY_OUTPUT_SET_WITH_NO_OUTPUT		enum FatalErrors
; The view has the QUERY_OUTPUT ink type set, but does not have an output
; set. This will cause the flow object to queue up mouse events forever,
; so is not a good thing.

OL_VIEW_GENERIC_CONTENTS_MUST_BE_IN_SAME_THREAD		enum FatalErrors
; You cannot use GVI_GENERIC_CONTENTS or GVI_VIEW_FOLLOWS_CONTENT_GEOMETRY
; if the content is running in a different thread as the view (i.e. the
; content is running in the main thread, the view in the UI thread.)  Either
; put the content in the same thread, or avoid using those constants.  Using
; GVDA_NO_SMALLER_THAN_CONTENT and GVDA_NO_LARGER_THAN_CONTENT on the view
; ought to cause the view sizing behavior you desire.
;

;Document control errors

CANNOT_DELETE_FILE_JUST_CLOSED				enum FatalErrors
CANNOT_CD_TO_DIR_FOR_DELETE				enum FatalErrors
CANNOT_MAP_LONGNAME_JUST_CLOSED				enum FatalErrors
OL_DOCUMENT_AUTO_SAVE_TIMER_SHOULD_NOT_EXIST		enum FatalErrors
OL_DOCUMENT_CHANGE_TIMER_SHOULD_NOT_EXIST		enum FatalErrors
OBJECT_NOT_A_GEN_DOCUMENT				enum FatalErrors
OBJECT_NOT_A_GEN_UI_DOC_CONTROL				enum FatalErrors
OL_DOCUMENT_INVALID_DOCUMENT_FILE_NAME			enum FatalErrors
; GDI_fileName isn't null-terminated and has likely been corrupted, therefore.
; 

OLDC_PATH_MUST_BE_ABSOLUTE				enum FatalErrors
; the path passed to reopen a file included a disk handle, so the path
; must be absolute, but it wasn't. Why? I don't know.

OLDC_PATH_MAY_NOT_BE_ABSOLUTE				enum FatalErrors
; the path passed to reopen a file did not include a disk handle, so the path
; may not be absolute, it having to be based on the object's current path.
; 

OL_DOCUMENT_PATH_STORED_INCORRECTLY			enum FatalErrors
; a path that was stored in the .ini file has been corrupted, either by
; the user or by us, as there's no initial null-terminated string (the path,
; after which comes the saved disk handle data).

OLDC_INVALID_TASK					enum FatalErrors
; the current task for a UI document control is not one for which a summons
; is required, yet someone is asking that a summons be built for it.

OLAPPDC_DEFAULT_NAME_TOO_LONG				enum FatalErrors
; the default filename bound to a GenDocumentGroup object is longer
; than a FileLongName. It must be shortened.

OLDC_MUST_HAVE_NO_NAME_TEXT				enum FatalErrors
; the noNameText field is empty. If the GDCF_NAME_ON_PRIMARY feature is
; set, there must be a noNameText string.

CANT_GET_FILE_ID_FOR_OPEN_FILE				enum FatalErrors
; Should never happen, but it means an error came back trying to get the
; disk and FileID for a document to register or unregister it with IACP.

;OLButtonClass and OLMenuButtonClass errors

OL_ERROR_BUTTON_SAVING_BORDERED_AND_DEPRESSED_STATE_TWICE enum FatalErrors
OL_ERROR_BUTTON_SHOULD_BE_ENABLED_TO_GET_KBD_EVENTS	enum FatalErrors
OL_ERROR_NON_MENU_OBJECT_TOOK_FOCUS_BEFORE_DELAYED_RESTORE enum FatalErrors
OL_ERROR_ATTR_GEN_TRIGGER_INTERACTION_COMMAND_WITHOUT_DATA enum FatalErrors

;OLApplicationClass errors

OL_ERROR_STANDARD_DIALOG_BLOCK_BEING_FREED_STILL_HAS_GRAB  enum FatalErrors
OL_STANDARD_DIALOG_DATA_CHUNK_NOT_FOUND			enum FatalErrors
; the application object has received a second response from a standard
; dialog. should never happen, and I can't think how it would...


;errors for recently-nuked features that are still being used by
;people that do not read their mail.

OL_ERROR_READ_YOUR_MAIL_YOU_BONEHEAD			enum FatalErrors

; BG file errors
OL_FIELD_BAD_BG_FILE_TYPE				enum FatalErrors
OL_FIELD_BAD_BG_FLAGS					enum FatalErrors
							
;OLCtrl geometry errors
	
OL_CTRL_CANT_HAVE_A_WRAP_COUNT_OF_ZERO			enum FatalErrors
; The object has a HINT_WRAP_AFTER_CHILD_COUNT with an argument of zero,
; which is not allowed.
  
OL_CTRL_CANT_HAVE_A_HUGE_WRAP_COUNT			enum FatalErrors
; The object has a HINT_WRAP_AFTER_CHILD_COUNT with a very large child count,
; which is not allowed.
  
OL_MNEMONIC_OFFSET_LARGER_THAN_MONIKER			enum FatalErrors
; Somehow a mnemonic offset for a textual VisMoniker has been set to be longer
; than the moniker text itself.  Since this is handled automatically by the
; assembler for .ui files, something probably has gotten trashed, or someone 
; has created their own VisMoniker structure and not set this correctly.
; The legal mnemonic offsets are either numbers less than the length of the
; text, -1 for no mnemonic, or -2 for the specific UI's cancel mnemonic.
  
OL_WINDOWED_GEN_OBJECT_NOT_IN_GEN_TREE			enum FatalErrors
OL_CANT_GET_SCREEN_WINDOW_HANDLE			enum FatalErrors
OL_CANT_GET_SCREEN_SIZE					enum FatalErrors
							

OL_BAD_HINT_DATA					enum FatalErrors
; Hint didn't contain correct amount of extra data it is defined as
; requiring.

OL_HINT_IF_SYSTEM_ATTRS_NO_CONDITIONS			enum FatalErrors
; No conditions were specified for HINT_IF_SYSTEM_ATTRS.

OL_HINT_IF_SYSTEM_ATTRS_NO_HINT_FOLLOWS			enum FatalErrors
; There was a HINT_IF_SYSTEM_ATTRS as the last hint in an object's hint
; chunk.   At least one hint must follow, which will be removed if
; conditions specified in data of HINT_IF_SYSTEM_ATTRS are not met.

OL_HINT_IF_SYSTEM_ATTRS_BAD_CONDITIONS			enum FatalErrors
; The SystemAttrs argument to HINT_IF_SYSTEM_ATTRS was set up incorrectly
; and has bad flags.

OL_HINT_IF_SYSTEM_ATTRS_COULDNT_FIND_ENDIF		enum FatalErrors
; There was a HINT_IF_SYSTEM_ATTRS and a HINT_ELSE without a HINT_ENDIF
; following the HINT_ELSE, which is required.

OL_INVALID_GESTURE					enum FatalErrors
; The handwriting recognition library returned an invalid gesture type.
;


; Lazy errors

OL_ERROR						enum FatalErrors

;GenInteraction errors

OL_ERROR_CANT_USE_INITIATE_ON_DO_DIALOG_OBJECT		enum FatalErrors
; MSG_GEN_INTERACTION_INITIATE cannot be used on GenInteractions that will
; be displayed by UserDoDialog.

OL_ERROR_BAD_GEN_INTERACTION_TYPE			enum FatalErrors
; GII_type field contains invalid entry.  Make sure that it contains a valid
; GenInteractionType.

OL_ERROR_CANT_USE_DO_DIALOG_ON_NON_MODAL_OBJECTS        enum FatalErrors
; UserDoDialog cannot be used on GenInteractions not marked with
; GIA_INITIATED_VIA_USER_DO_DIALOG and either GIA_MODAL or GIA_SYS_MODAL

OL_ERROR_ILLEGAL_INTERACTION_COMMAND			enum FatalErrors

OL_ERROR_CANT_HAVE_DUPLICATE_STANDARD_TRIGGERS		enum FatalErrors
; A dialog GenInteraction can only have one of any give type of standard
; trigger.  Make sure that the GenInteraction doesn't have more than one
; child GenTrigger with a given ATTR_GEN_TRIGGER_INTERACTION_COMMAND data.

OL_ERROR_CANT_HAVE_MULTIPLE_REPLY_BARS			enum FatalErrors
; A dialog GenInteraction can only have one reply bar (a child
; GenInteraction with HINT_MAKE_REPLY_BAR).  Make sure you don't have more
; than one of these under the dialog GenInteraction.

OL_ERROR_BAD_GEN_INTERACTION_GROUP_TYPE			enum FatalErrors
; A GenInteraction has ATTR_GEN_INTERACTION_GROUP_TYPE with invalid data.

OL_ERROR_ONLY_PRIMARIES_CAN_HAVE_CUSTOM_SYSTEM_MENUS	enum FatalErrors
; The gen parent of the custom sys menu must be a GenPrimary.

OL_ERROR_CANT_HAVE_MULTIPLE_CUSTOM_SYSTEM_MENUS		enum FatalErrors

; GenItemGroup errors

OL_ERROR_NO_TWO_ITEMS_CAN_HAVE_SAME_IDENTIFIER		enum FatalErrors
; An item group was found to have two child items with matching identifiers.
; This is not allowed.  Make sure all the items under a single item group
; (or under a set of linked item groups) have unique identifiers
;

OL_ERROR_NO_TWO_BOOLEANS_CAN_HAVE_COMMON_BITFIELDS	enum FatalErrors
; A boolean group was found to have two child booleans whose identifiers
; shared common bitfields (i.e. when or'ed together, produced a non-zero
; result).  Not only are booleans required to have unique identifiers, they
; cannot share any bitfield.  If you need your booleans to have one or more
; shared bitfields, try masking them out before setting identifiers and setting
; the boolean group state, and or them back in after retrieving the state.
;

OL_ERROR_ITEM_GROUPS_CANNOT_HAVE_NON_ITEM_CHILDREN	enum FatalErrors
; A GenItemGroup or GenBooleanGroup object was found to have at least one
; generic child that is not a class or subclass of GenItemClass or GenBoolean-
; Class.  If you need to intersperse other generic objects in between items
; or booleans, consider setting up linked item groups instead.

OL_ERROR_ITEM_NOT_CHILD_OF_ITEM_GROUP			enum FatalErrors
; Any GenItemClass object must be the child of a GenItemGroup object.  It
; cannot exist by itself.   (If you need your items to be grouped together,
; but visually appear in different parts of the screen, you probably 
; will want to put them each under their own GenItemGroups, then link the
; groups together.  See documentation for more details.)
;

OL_ERROR_BOOLEAN_NOT_CHILD_OF_BOOLEAN_GROUP		enum FatalErrors
; Any GenBooleanClass object must be the child of a GenBooleanGroup object.  It
; cannot exist by itself.   (If you need your booleans to be grouped together,
; but visually appear in different parts of the screen, you probably 
; will want to put them each under their own GenBooleanGroups, then link the
; groups together.  See documentation for more details.)
;

OL_ERROR_ITEMS_CANNOT_HAVE_GENERIC_CHILDREN		enum FatalErrors
; Items cannot have generic children.   Put them elsewhere.
;

OL_ERROR_EXCLUSIVE_ITEM_GROUPS_CANNOT_HAVE_MULTIPLE_SELECTIONS enum FatalErrors
; Exclusive item groups cannot have multiple selections.  Use a non-exclusive
; item group.  You can mimic exclusive behavior easily enough in non-exclusive
; item groups by clearing other items in response to the user setting an item,
; if you really need that kind of behavior.
;

OL_NON_EXCLUSIVE_ITEM_GROUPS_CANNOT_RESET	enum	Warnings
; non-exclusive item groups do not support MSG_GEN_RESET, even though
; exclusive item groups may.

; GenPrimary/GenDisplay/GenDisplayGroup errors

; GenField errors

OL_FIELD_NEW_PANEL_NOT_SUBCLASS_OF_GEN			enum FatalErrors
; The class given to MSG_GEN_FIELD_CREATE_EXPRESS_MENU_PANEL must be a
; subclass of GenClass, as the object is added as a generic child of the
; express menu.

OL_FIELD_TASK_ENTRY_NOT_SUBCLASS_OF_GEN_ITEM		enum FatalErrors
; The class given to MSG_GEN_FIELD_CREATE_TASK_ENTRY must be a subclass of
; GenItemClass, as the object is added as a generic child of a GenItemGroup
; object.

OL_GEN_DISPLAY_CAN_NOT_HANDLE_GSTRING_MONIKER		enum FatalErrors
; This spui implementation does not support GString monikers for GenDisplay
; objects.

OL_WIN_HINT_REQUIRES_SPEC_WIN_SIZE_PAIR_ARGUMENT	enum FatalErrors
; A bad argument was found for either HINT_POSITION_WINDOW_AT_RATIO_OF_PARENT,
; HINT_SIZE_WINDOW_AS_RATIO_OF_PARENT, or HINT_SIZE_WINDOW_AS_RATIO_OF_FIELD.
; Make sure you've specified a single argument of type SpecWinSizePair (or
; two words set to constants that make since for a SpecWinSizePair).

OL_FIELD_BAD_ASSUMPTION_REGARDING_DEFAULT_FIELD		enum FatalErrors
; OLField objects set themselves as being the system-wide default field on
; gaining the target.  They clear this reference when losing it.   This error
; results if the optr stored in the system isn't the fields, when it goes
; to clear the reference.

; OLWin errors

if 0
OL_ERROR_CANT_HAVE_MULTIPLE_TITLE_BAR_LEFT_GROUPS	enum FatalErrors
OL_ERROR_CANT_HAVE_MULTIPLE_TITLE_BAR_RIGHT_GROUPS	enum FatalErrors
endif

; Each window can only have one object subtree with HINT_SEEK_TITLE_BAR_LEFT
; and HINT_SEEK_TITLE_BAR_RIGHT.

WINDOW_REQUIRES_PARENT_OBJECT				enum FatalErrors
; An object was not in the gen linkage.

GEN_PATH_GET_RETURNED_ERROR				enum FatalErrors
GEN_PATH_GET_RETURNED_NO_ERROR_BUT_ZERO_HANDLE		enum FatalErrors
NULL_HANDLE_PASSED_TO_COPY_PATH_COMMON			enum FatalErrors

OL_BAD_WIN_PRIORITY					enum FatalErrors
; A bad WinPriority was supplied with ATTR_GEN_WINDOW_CUSTOM_WINDOW_PRIORITY

CANNOT_CALL_USER_DO_DIALOG_WITH_SAME_DIALOG_TWICE	enum FatalErrors
; UserDoDialog was called with the same dialog box twice at the same time
; (on different threads, I imagine).

SEEK_TITLE_BAR_PARENT_MUST_BE_DIRECT_CHILD_OF_WINDOW	enum FatalErrors
; Objects with HINT_SEEK_TITLE_BAR_LEFT or HINT_SEEK_TITLE_BAR_RIGHT must
; be a direct generic child of a window object (independently displayable
; GenInteraction, GenDisplay, or GenPrimary).

OL_ERROR_DIALOG_PLACED_BELOW_APP_OBJ_MUST_BE_MARKED_NOT_USER_INITIATABLE enum FatalErrors
; The dialog in *ds:si is immediately below the app object in the generic
; tree, & yet is not marked as GIA_NOT_USER_INITIATABLE nor
; GIA_INITIATED_VIA_USER_DO_DIALOG -- conditions which cause a button
; to be built for the user to gain access to the dialog -- only there's
; no place to put the button where the user can see it.  The dialog should
; be placed elsewhere, or one of the above mentioned attributes used.

PASSED_FILE_NOT_OPENED_BY_DOCUMENT_CONTROL		enum FatalErrors
; The file handle passed in CX does not belong to any GenDocument object
; located below this GenDocumentGroup. This message is sent by the method
; for MSG_META_VM_FILE_DIRTY located in GenProcessClass. If you are opening
; and dirtying VM files, with the VMA_NOTIFY_DIRTY attribute set, independent
; of the document control, you need to subclass MSG_META_VM_FILE_DIRTY in
; your process class and not call your superclass for any file you open
; without the aid of the document control.

OL_ONE_WAY_UPWARD_LINK_FROM_DISPLAY_TO_DISPLAY_GROUP_NOT_ALLOWED enum FatalErrors
; Having been asked to send current state notifcation to the display ctrl, a
; GenDisplay has discovered that it is not a child of it's generic parent --
; meaning that the downward linkage has been trashed, or the parent wasn't
; marked dirty when the child was added, thereby zeroing out the linkage when
; going to state.

OL_ERROR_FULL_SCREEN_EXCL_NOT_LEGAL_BELOW_APP_OBJ	enum FatalErrors
; An attempt has been made to grab or release the MAEF_FULL_SCREEN exclusive
; within the application, and this is not legal as the MAEF_FULL_SCREEN
; exclusive hierarchy exists purely for fields & application objects.  Unless
; the setting of this bit was intentional, the problem may be simply that
; garbage flags were passed in bp to the this handler for 
; MSG_META_MUP_ALTER_FTVMC_EXCL.
; 

if DBCS_PCGEOS

OL_ERROR_ILLEGAL_KEY_FOR_SHORTCUT			enum FatalErrors
; A shortcut was based on a control key that the SPUI did not recognize.
; Shortcuts will normally be alphanumeric [A-Z][0-9], punctuation, or one of
; the standard system keys, such as Enter, Tab, F1-F12, etc.

endif

DISCARDABLE_INTERACTION_MUST_NOT_BE_USER_INITIATABLE	enum FatalErrors
; An interaction with HINT_INTERACTION_DISCARD_WHEN_CLOSED was not marked
; NOT_USER_INITIATABLE.

DISCARDABLE_INTERACTION_MUST_HAVE_ONE_WAY_LINK		enum FatalErrors
; An interaction with HINT_INTERACTION_DISCARD_WHEN_CLOSED is not allowed
; to be in the generic linkage - it is only allowed to have a one-way
; upward generic link.

SAVE_FAILED_DUE_TO_BLOCK_LOCKED_BY_ANOTHER_THREAD	enum Warnings
; The document control tried to save the file out, but failed because one of
; the VM blocks was locked by another thread. It will deal gracefully with
; this situation (the file will remain dirty, and the next autosave will
; cause the data to be written out), but the programmer should be aware of
; it, as it is an odd case.

SAVE_ATTEMPTED_WHEN_NO_BLOCKS_WERE_DIRTY		enum Warnings
; The DocumentControl was sent MSG_GEN_DOCUMENT_PHYSICAL_UPDATE, even though
; no blocks in the document were empty.

if _RUDY

MUST_BE_COMPLEX_EXPANDING_MONIKER_CLASS_TO_RECEIVE_STD_TRIGGER_MKR enum Warnings
; Any trigger wishing to have a moniker bestowed on it due to an ATTR_GEN_-
; TRIGGER_INTERACTION_COMMAND must be of class ComplexExpandingMonikerClass.
;

endif
;------------------------------------------------------------------------------
;	Floating Keyboard fatal errors
;	Copied or moved from the UI, where the code that calls them
;	wass copied or moved from...
;------------------------------------------------------------------------------
UI_EXPECTED_DGROUP					enum FatalErrors
; Expected either DS or ES to contain dgroup, depeneding on the context.

ILLEGAL_KBD_SCAN_CODE					enum FatalErrors
; An illegal keyboard scan code value was found.

ILLEGAL_OBJECT_PASSED_TO_VIS_KEYBOARD_ROUTINE		enum FatalErrors
; VisKeyboardDeref_DSDI must be passed a pointer to an VisKeyboard object in
; *DS:SI. This fatal error is encountered if a non-VisKeyboard object was
; passed.

KBD_PTR_OUT_OF_BOUNDS					enum FatalErrors
; A ptr in the VisKbdClass was out of bounds.

ILLEGAL_KBD_MOD_STATE					enum FatalErrors
; An illegal keyboard modified state was found.

CHAR_NOT_SUPPORTED					enum FatalErrors
; The character could not be drawn because no string was provided for it.

ILLEGAL_KBD_CHAR_FLAGS					enum FatalErrors
; Illegal keyboard character flags were found.

ILLEGAL_KBD_SHIFT_STATE					enum FatalErrors
; An illegal keyboard shift state was found.

ILLEGAL_KBD_TOGGLE_STATE				enum FatalErrors
; An illegal keyboard toggle state was found.

KBD_KEY_DOES_NOT_EXIST					enum FatalErrors
; A key does not exist on the keyboard

NO_CUSTOM_CHAR_TABLE_MONIKER				enum FatalErrors
; No ATTR_GEN_PEN_INPUT_CONTROL_CUSTOM_CHAR_TABLE_MONIKER was present even
; though GPICF_CHAR_TABLE_CUSTOM was set.

NO_CUSTOM_CHAR_TABLE_DATA				enum FatalErrors
; No ATTR_GEN_PEN_INPUT_CONTROL_CUSTOM_CHAR_TABLE_DATA was present even though
; GPICF_CHAR_TABLE_CUSTOM was set.

CONTROLLER_OBJECT_INTERNAL_ERROR			enum FatalErrors
; Error used by lazy controller programmers (manly, yes, but I like it too!)

BAD_PEN_INPUT_DISPLAY_TYPE				enum FatalErrors
; A bad PenInputDisplayType was saved in the .ini file or in the 
; ATTR_GEN_PEN_INPUT_CONTROL_STARTUP_DISPLAY_TYPE

CHAR_TABLE_MUST_HAVE_AT_LEAST_ONE_LINE			enum FatalErrors
; The VisCharTable object must have at least one line of data to draw.

ILLEGAL_CHAR_TABLE_ROW_NUMBER				enum FatalErrors
; An illegal row number in the Character Table is found

ILLEGAL_CHAR_TABLE_COLUMN_NUMBER			enum FatalErrors
; An illegal column number in the Character Table is found

ILLEGAL_OBJECT_PASSED_TO_VIS_CHAR_TABLE_ROUTINE		enum FatalErrors
; VisCharTableDeref_DSDI must be passed a pointer to an VisCharTable object in
; *DS:SI. This fatal error is encountered if a non-VisCharTable object was
; passed.

INVALID_DELETE_RANGE					enum FatalErrors
; The range of chars to delete in the HWR Grid from a delete gesture was
; invalid.

ERROR_PEN_INPUT_CONTROL_BAD_KEYBOARD_SIZE		enum FatalErrors
; The .ini file category "keyboardSize" in the "[ui]" category can only
; have one of two sizes, KS_STANDARD (0) or KS_ZOOMER (1).  In Motif the
; standard size is for Bullet, and Zoomer is self documenting.  In Stylus
; (and other future SPUI's that have their own style of keyboard) this flag
; is ignored. If this flag contains any other number we will assume Zoomer
; in nonEC, but you will get this crash in EC so you know to fix your
; .ini file.

; More OL errors

OL_ERROR_CANT_HAVE_TITLE_BAR_GROUP_WITH_MINIMIZED_TITLE_BAR enum FatalErrors
; Objects cannot seek the title bar (via HINT_SEEK_TITLE_BAR_LEFT or
; HINT_SEEK_TITLE_BAR_RIGHT) if the window is supposed to have a minimized
; title bar (HINT_WINDOW_MINIMIZE_TITLE_BAR).

ERROR_HWR_GRID_INVALID_GESTURE				enum FatalErrors
; an invalid gesture type was returned to the HWR grid

;OL_ERROR_MUST_SET_INITIATED_VIA_USER_DO_DIALOG		enum FatalErrors
; If a dialog box is brought up with UserDoDialog, it must have the
; GIA_INITIATED_VIA_USER_DO_DIALOG attribute set.

OL_ERROR_HAVE_WRONG_ROW_NUMBER_IN_HEADING		enum FatalErrors
; We have only 1 heading in file selector. So if the row number is not 0, then
; the number must be wrong.

SIBLING_OBJECTS_MAY_NOT_HAVE_SAME_SLOT_HINT_NUMBERS	enum FatalErrors
; Two objects are requesting to be in the same parent-slot, which is
; illegal.

OL_ERROR_EXPECTED_MORE_CHILDREN_IN_MENU_BAR		enum FatalErrors
; Some specific UIs create extra objects in the menu bar.  This error
; means there's a bug in the specific UI.

EXPECTED_MORE_CHILDREN_IN_MENU_BAR			enum FatalErrors
; Another indicator of a bug in jmotif.

HINT_INDENT_TOO_LARGE					enum FatalErrors
; Negative sizes, and very large sizes, not allowed in HINT_INDENT_CHILDREN.   
; Or maybe you have a garbage value there.

OL_INTERNAL_ERROR_CANT_ACCESS_GEN_TEXT_INSTANCE		enum FatalErrors
; A GenValue has an internal error where it's trying to access
; GenText instance data, when it's not a GenText object.

OL_INTERNAL_ERROR_CANT_ACCESS_OL_CTRL_INSTANCE		enum FatalErrors
; A GenValue has an internal error where it's trying to access
; OLCtrl instance data, when it's not an OLCtrl object.

if _RUDY

OL_INTERNAL_ERROR_NON_WINDOW_SETTING_EMPHASIZED_OBJECT	enum FatalErrors
; A MSG_SPEC_SET_EMPHASIZED_OBJECT has been delivered to a
; non-windowed object.  Only windowed OLCtrl objects can
; reasonably handle this message.

OL_DIALOGS_INITIATED_ON_UI_THREAD_MUST_BE_SYS_MODAL	enum FatalErrors
; Doesn't make sense to have app-modal dialogs launched on UI thread.

OL_RUDY_FILE_SELECTORS_CANNOT_SHOW_PARENT_DIR		enum	FatalErrors
; For numerous reasons, mostly to do with non-exclusive file selectors,
; GenFileSelector cannot handle showing the parent directory.  This
; error should never occurr.


OL_NON_EXCLUSIVE_FILE_SELECTORS_CANNOT_ACT_ON_DOUBLE_PRESS	enum	FatalErrors
; non-exclusive file selectors cannot handle taking an action
; (such as opening a subdirectory) when double-clicked upon.
; Ostensibly, because it is ambiguous to act on multiple
; selections, but actually, because the code hasn't been
; written to support it :-)

OL_NON_EXCLUSIVE_FILE_SELECTOR_TOO_MANY_SELECTED_FILES	enum	FatalErrors
; Too many files were selected to fit into the selections chunk.

OL_NON_EXCLUSIVE_FILE_SELECTOR_UNSUPPORTED_OPERATION	enum	FatalErrors
; The non-exclusive file selector has been asked to do something
; unsupported.

endif		; _RUDY

endif		; end of if ERROR_CHECK

;------------------------------------------------------------------------------
;		Upward Queries
;------------------------------------------------------------------------------

;Additions to the standard "upward generic query" list for this specific ui.

SpecGenQueryTypes etype word, SPEC_GEN_QUERY_START

SGQT_BUILD_INFO			enum SpecGenQueryTypes
	; Pass:	bp - OLBuildFlags
	; Return: bp - new OLBuildFlags
	;	  cx:dx - vis parent

SGQT_FIND_MENU_BAR		enum SpecGenQueryTypes
	; Pass:
	; Return: ^lcx:dx - handle of OLMenuBarClass object below GenPrimary

SGQT_IS_CHILD_OF_PRIMARY	enum SpecGenQueryTypes
	; Pass: nothing
	; Return: cx = TRUE if is descendant of GenPrimary, rather
	; than GenApplication.

SGQT_BRING_UP_KEYBOARD		enum SpecGenQueryTypes
	; Pass: nothing
	; Return: nothing

if _DUI

SGQT_SET_KEYBOARD_TYPE		enum SpecGenQueryTypes
	; Pass:	dx:bp = KeyboardTypeParams
	; Return: nothing

endif

SGQT_WIN_GROUP			enum SpecGenQueryTypes
	; Return the OD and window handle of the nearest win group that is
	; currently opened (i.e. has non-zero window handle).
	; 
	; Pass: nothing
	; Return:	carry set if answered:
	; 			^lcx:dx	= optr of nearest win group
	; 			bp	= handle of its window.

;This record is used to pass requests to a Field window for window and icon
;staggered positions.

StaggerSlotPositionRequest	record
	SSPR_REASSIGN_IF_CONFLICT:1
				;set this TRUE if your window has just been
				;re-attached to the system. If another window
				;has that slot, will return a new slot #.
	SSPR_ICON:1		;TRUE if requesting position for icon
				;FALSE if window.
	SSPR_SLOT:6		;non zero if have been assigned a slot
				;number previously - see if is still OK to use.
StaggerSlotPositionRequest	end

StaggerSlotPositionRequest2	record	:2, SSPR_ROW:2, SSPR_COLUMN:4
		;these field names are used within cwinField.asm to find
		;the bit in the slot allocation map.

	.assert	(mask SSPR_ICON or mask SSPR_SLOT) eq (mask WPSS_STAGGERED_SLOT shr 8)

;Additions to the standard "upward visual query" list for this specific ui.

SpecVisQueryTypes etype word, SPEC_VIS_QUERY_START

SVQT_REQUEST_STAGGER_SLOT enum SpecVisQueryTypes
	;pass:	dl = StaggerSlotPositionRequest (see above)
	;returns:
	;	cx, dx	= staggered position
	;	bp (low)= StaggerSlotPositionRequest
	;			(SSPR_REASSIGN_IF_CONFLICT will be cleared)

SVQT_REQUEST_NEAREST_ICON_SLOT enum SpecVisQueryTypes
	;pass:  dx, bp = position to use
	;returns:
	;	cx, dx = staggered position
	;	bp (low)= StaggerSlotPositionRequest
	;			(SSPR_REASSIGN_IF_CONFLICT will be cleared)
	
SVQT_FREE_STAGGER_SLOT enum SpecVisQueryTypes
	;pass:	dl = StaggerSlotPositionRequest (see above)
	;returns: nothing

SVQT_SET_MASTER_DEFAULT		enum SpecVisQueryTypes
	; This query is sent from a GenTrigger to the window (OLWinClass) in
	; which it sits, when that GenTrigger wants to be the master default
	; trigger in the window. If no other trigger has the default exclusive,
	; this trigger will gain it immediately.
	; Pass: bp:dx = OD of GenTrigger

SVQT_RESET_MASTER_DEFAULT	enum SpecVisQueryTypes
	; This query is sent from a GenTrigger to the window (OLWinClass) in
	; which it sits, when that GenTrigger does not want to be the master
	; default in the window. If the trigger has the default exclusive
	; it will lose it immediately.
	; Pass: bp:dx = OD of GenTrigger

SVQT_TAKE_DEFAULT_EXCLUSIVE	enum SpecVisQueryTypes
	; This query is sent from a GenTrigger to the window (OLWinClass) in
	; which it sits, when that trigger wants to temporarily override the
	; master default trigger (if any).
	; Pass: bp:dx = OD of GenTrigger

SVQT_REQUEST_DEFAULT_EXCLUSIVE	enum SpecVisQueryTypes
	; This query is sent by the window to itself (on the UI queue),
	; when a button in the window releases the default exclusive.
	; Bascially, we want to wait a while before grabbing the default
	; exclusive for the master default button. If no other button
	; grabs the default before this query arrives, then the default
	; exclusive is given to the master default.
	; Pass: bp:dx = OD of GenTrigger

SVQT_RELEASE_DEFAULT_EXCLUSIVE	enum SpecVisQueryTypes
	; This query is sent from a GenTrigger to the window (OLWinClass) in
	; which it sits, when that trigger wants to release its temporarily
	; override on the master default trigger (if any).
	; Pass: bp:dx = OD of GenTrigger

SVQT_FORCE_RELEASE_DEFAULT_EXCLUSIVE	enum SpecVisQueryTypes
	; This query is sent from a GenSummons to itself, as it is dismissed,
	; to force the default exclusive back to the MASTER default.

SVQT_ACTIVATE_DEFAULT		enum SpecVisQueryTypes
	; This is sent my an object in a window (such as a text object) which
	; wants the default GenTrigger in the window to be activated.
	; Pass: nothing
	; Returns: nothing

SVQT_HAS_MENU_IN_STAY_UP_MODE	enum SpecVisQueryTypes
	; This is sent to an OLWinClass object when a child menu is placed
	; in stay-up-mode. It causes the OpenWinEndGrab routine to NOT
	; force the release of the gadget exclusive as the mouse is released.
	; Thus we preserve the gadget exclusive link to the menu.

SVQT_NO_MENU_IN_STAY_UP_MODE	enum SpecVisQueryTypes
	; This is sent to an OLWinClass object when a child menu is taken
	; out of stay-up-mode.

SVQT_REMOTE_GRAB_GADGET_EXCL		enum SpecVisQueryTypes
SVQT_NOTIFY_MENU_BUTTON_AND_REMOTE_GRAB_GADGET_EXCL enum SpecVisQueryTypes
SVQT_REMOTE_RELEASE_GADGET_EXCL		enum SpecVisQueryTypes
	;This is sent from a pinned submenu whose menu button is inside a menu
	;which is closing, OR from a popup menu. The menu is requesting the
	;GADGET exclusive because then it can be told to close if the
	;parent window (GenPrimary, etc) closes unexpectedly.
	;(The menu starts by sending the "NOTIFY" query, so that its menu
	;button can reset a state flag. The standard "REMOTE_GRAB" query
	;is then forwarded up the tree.)

SVQT_QUERY_WIN_GROUP_FOR_FOCUS_EXCL	enum SpecVisQueryTypes
	;This query is sent up to the window level from gadgets which
	;have been optimized so that they do not redraw if they know that
	;a pending FOCUS movement will cause them to redraw, such as
	;the GenList object. This is also used by some gadgets to decide if
	;they should grab the focus when the mouse is pressed on them.
	;Pass:		nothing
	;Returns:	^lcx:dx = OD of focused object (0:0 if none)
	;		bp	= TRUE if WIN_GROUP object has the FOCUS_WIN
	;			exclusive for its level.

SVQT_QUERY_FOR_REPLY_BAR		enum SpecVisQueryTypes
	;This query is sent up the visible tree from an OLButtonClass object
	;when it is specifically built. At this point, we don't need the OD of the
	;reply bar; just the fact that it exists.
	;Pass:		nothing
	;Returns:	carry set, meaning was answered by a reply bar

SVQT_GRAB_FOCUS_EXCL_FOR_MENU		enum SpecVisQueryTypes
	;This query is sent when the user drags off of a menu button inside
	;this menu window. Since we expect the sub-menu to close, we
	;want to grab the focus quickly, so that it is not restored to the
	;previous focus owner (some gadget inside the Primary)

SVQT_DELAYED_MODE			enum SpecVisQueryTypes
	;Returns whether the window we're in is in delayed mode.
	;Pass:		nothing
	;Return:	carry set if in delayed mode.

SVQT_BACKGROUND_COLORS			enum SpecVisQueryTypes
	;Returns background colors to use for various gadgets.
	;Pass:		nothing
	;Return:	carry set if custom colors, with:
	;			cx -- unselected color
	;			dx -- selected color

if _RUDY
HOLISTIC_SCROLLBAR_POSITIONING				equ	TRUE
else
HOLISTIC_SCROLLBAR_POSITIONING				equ	FALSE
endif

if HOLISTIC_SCROLLBAR_POSITIONING

SVQT_SCROLLBAR_POSITION			enum SpecVisQueryTypes
	;Returns holistic position information about where the
	;SpecUI thinks GenView scrollbars should go.  This only
	;nudges the scrollbars around, so it isn't
	;as radical as changing the vis parent of the scrollbar.
	;
	; Pass:		bp = ScrollbarPositionQueryFlags
	;			Passing info about what kind of
	;			scroller it is (vert, horiz)
	; Return:	carry = clear if not answered, else
	;		bp = ScrollbarPositionQueryFlags
	;		cx,dx = Guideline coordinates of scrollbar

ScrollbarPositionQueryFlags	record
	:7
	SPQF_LEFT_JUSTIFY:1		; How to position scrollbar
	SPQF_RIGHT_JUSTIFY:1		; with respect to cx,dx
	SPQF_TOP_JUSTIFY:1		
	SPQF_BOTTOM_JUSTIFY:1		

	SPQF_IS_MANAGED_BY_VIEW:1	; Pass this Set if we only care
					; about whether or not the
					; query will be answered

	SPQF_BOTTOM:1			; When passed: scrollbar to get
	SPQF_RIGHT:1			;   position info about
	SPQF_TOP:1			; When returned: scrollbars
	SPQF_LEFT:1			;   that are to be holisticly placed


ScrollbarPositionQueryFlags	end

SPQF_POSITION	equ	mask SPQF_LEFT or mask SPQF_RIGHT or \
			 mask SPQF_TOP or mask SPQF_BOTTOM

if ERROR_CHECK

OL_SCROLLBAR_NOT_PLACED_OUTSIDE_VIEW_WINDOW	enum	Warnings
	;
	; This warning is issued when a scrollbar is positioned
	; globally, but overlaps the view window.
	;

endif ; ERROR_CHECK

endif ; HOLISTIC_SCROLLBAR_POSITIONING

;This structure is used to pass data to OLMenuBarCallMDIMenuItem

OLMenuBarCallData	struct
    OLMBC_message	word		;must be first (is pushed last)
    OLMBC_dataBP	word
    OLMBC_dataDX	word
    OLMBC_dataCX	word		;pushed first
OLMenuBarCallData	ends

;These constants indicate the positions of the generic items in the
;Field's WorkspaceMenu (see cspecMotif.ui file).

OL_WORKSPACE_MENU_APPLICATIONS_GEN_LIST_OBJ	= 1-1
OL_WORKSPACE_MENU_OPTIONS_SUBGROUP_OBJ		= 2-1
OL_WORKSPACE_MENU_RUN_PROGRAMS_SUBMENU_OBJ	= 1-1

;------------------------------------------------------------------------------
;		Core display constants
;------------------------------------------------------------------------------

	; These constants are used when setting the display scheme for a window
	; DRAW methods use the display scheme to determine the colors to draw
	; with

BW_DEFAULT_COLOR_SCHEME    = (C_WHITE * 16) + C_BLACK   ;use this in B/W

;
; This enables the pen input control all the time, whether or not an editable
; text object has the focus.  This should be used with the generic UI's
; STATIC_PEN_INPUT_CONTROL.
;
; Currently only works with _GRAFFITI_UI (need additional support in
; cmainPenInputControl.ui to work with non-_GRAFFITI_UI).
;
; Set matching value in cmainManager.ui.
;
if _JEDIMOTIF
PEN_INPUT_CONTROL_ALWAYS_ACTIVE equ TRUE
else
PEN_INPUT_CONTROL_ALWAYS_ACTIVE equ FALSE
endif

;
; This enables code that allows a rectangular screen to rotate.
;
if _JEDIMOTIF
RECTANGULAR_ROTATION	equ	TRUE
else
RECTANGULAR_ROTATION	equ	FALSE
endif

;
; This removes the "Move File" option from the document control's out of disk
; space error handling
;
; Set matching value in cmainManager.ui
;
if _JEDIMOTIF
NO_LOW_DISK_MOVE equ TRUE
else
NO_LOW_DISK_MOVE equ FALSE
endif

;
;  More Jedi stuff.  GRAFFITI_ANYWHERE allows the user to start a
;  Graffiti gesture anywhere on the screen, and the gesture goes to
;  the currently focused object.  GRAFFITI_TEXT_CURSORS implements the
;  text cursor shape changing depending on the current HWR mode.
;
;  Important note:  If you turn on GRAFFITI_TEXT_CURSORS for your
;  project, you must go enable some Jedi-only code in tslMethodCursor.asm
;  (in VisTextFlashCursorOff).  If this bothers you, complain to me and
;  I'll fix it.  -stevey 1/3/96
;
if _JEDIMOTIF
GRAFFITI_ANYWHERE	equ	TRUE
GRAFFITI_TEXT_CURSORS	equ	FALSE
CTRL_F5_QUITS_APP	equ	TRUE
else
GRAFFITI_ANYWHERE	equ	FALSE
GRAFFITI_TEXT_CURSORS	equ	FALSE
CTRL_F5_QUITS_APP	equ	FALSE
endif

;
; This removes the "Delete <current doc>" option from the document control's
; out of disk space error handling
;
; Set matching value in cmainManager.ui
;
if _JEDIMOTIF
NO_LOW_DISK_DELETE_CURRENT equ FALSE	; re-added - brianc 4/25/95
else
NO_LOW_DISK_DELETE_CURRENT equ FALSE
endif

;
; This allows the disk full handling to come into play while doing a SaveAs.
; This affects the "prompt for name on closing untitled document" case.
;
if _JEDIMOTIF
HANDLE_DISK_FULL_ON_SAVE_AS equ TRUE
else
HANDLE_DISK_FULL_ON_SAVE_AS equ FALSE
endif

;
; This causes mnemonics to be highlighted instead of underlined for maximum
; visibility - feature not completed, brianc 1/30/92
;
HIGHLIGHT_MNEMONICS = FALSE

;
; This causes tiling to occur when DisplayControl is resized, and when Displays
; are added or removed - feature not completed, brianc 5/19/92; completed 9/94
;

if _NIKE
TRACK_TILING = TRUE
else
TRACK_TILING = FALSE
endif


;
; Tabbed dialogs: Dialogs with folder tabs
;

if _NIKE
DIALOGS_WITH_FOLDER_TABS = TRUE
else
DIALOGS_WITH_FOLDER_TABS = FALSE
endif


;
; Set if menu buttons that lead to menus should always be enabled,
; regardless of the enabled status of the menu itself.
;
if _RUDY
;
; We don't have menus in rudy...
;
ALLOW_ACTIVATION_OF_DISABLED_MENUS	=	FALSE
else
ALLOW_ACTIVATION_OF_DISABLED_MENUS	=	TRUE
endif


;
; Selects entire spin gadget text when they gained the focus.  If false,
; the end of the text is selected.   Not an issue for sliders and such.
;
if _RUDY
SELECT_ENTIRE_SPIN_GADGET_TEXT_ON_GAINED_FOCUS	=	FALSE
else
SELECT_ENTIRE_SPIN_GADGET_TEXT_ON_GAINED_FOCUS	=	TRUE
endif

;
; This constant puts shadows on all B/W gadgets if true.  For non-Motif to do
; this, some work would have to be done on various region and bitmap
; definitions at the very minimum.
;					
if _MOTIF and (not _STYLUS) and (not _JEDIMOTIF) and (not _RUDY) and (not _ODIE)
	DRAW_SHADOWS_ON_BW_GADGETS		=	TRUE
else
	; NOTE: this is INCOMPATIBLE with most visual features that
	; are defined for the Stylus UI.  Be sure the shadows are disabled!
	DRAW_SHADOWS_ON_BW_GADGETS		=	FALSE
endif

;
; Turning this on causes buttons to draw with black shadows.  This is
; a subset of the above which causes shadows for all gadgets.
;
if _DUI
	DRAW_SHADOWS_ON_BW_TRIGGERS_ONLY	=	TRUE
else
	DRAW_SHADOWS_ON_BW_TRIGGERS_ONLY	=	FALSE
endif

;
; This constant removes any space between gstring monikers and accelerators,
; if the accelerator is being drawn to the right.    Rudy turns this off because
; all of these "gstring" cases are actually textual anyway.
;
if _RUDY
	NO_SPACE_BETWEEN_GSTRING_MONIKERS_AND_ACCELERATORS	= FALSE
else
	NO_SPACE_BETWEEN_GSTRING_MONIKERS_AND_ACCELERATORS	= TRUE
endif

;
; This constant allows B/W GenItems to invert their entire moniker when
; selected.  There is a one pixel inset around the item which also inverts,
; so you can always tell which item is selected, no matter how weird the 
; moniker is.  When the flag false, only the inset outline is inverted.  
;
if _MOTIF
	INVERT_ENTIRE_BW_ITEM_IMAGE		=	TRUE
else
	INVERT_ENTIRE_BW_ITEM_IMAGE		=	FALSE
endif

SPEC_UI_T_COLOR	equ	C_BLACK


if _OPEN_LOOK	;START of OPEN LOOK specific code -----------------------------
OL_DEFAULT_COLOR_SCHEME	   = (C_LIGHT_GREY * 16) + C_DARK_GREY
_SUB_MENUS	= TRUE
_MENUS_PINNABLE	= TRUE
_CR_DEFAULT	= TRUE
_CR_NAVIGATION	= TRUE		;CR and TAB to move between text fields.
_KBD_NAVIGATION	= FALSE		;snobs!
_MENU_NAVIGATION= FALSE
endif		;END of OPEN LOOK specific code -------------------------------



if _CUA					;START of CUA specific code -----------
OL_DEFAULT_COLOR_SCHEME	= (C_WHITE * 16) + C_BLACK
_CR_DEFAULT	= TRUE
_CR_NAVIGATION	= TRUE		;CR and TAB to move between text fields.
_KBD_NAVIGATION	= TRUE		;130 million Americans can't afford their own
_MENU_NAVIGATION= TRUE		;mouse. Think about it.
endif					;END of CUA specific code -------------

if _MOTIF				;START of MOTIF specific code ---------
OL_DEFAULT_COLOR_SCHEME	= (C_LIGHT_GREY * 16) + C_DARK_GREY
_CR_DEFAULT	= TRUE
_CR_NAVIGATION	= TRUE		;CR and TAB to move between text fields.
_KBD_NAVIGATION	= TRUE
_MENU_NAVIGATION= TRUE
endif					;END of MOTIF specific code -----------

if _PM					;START of PM specific code ------------
OL_DEFAULT_COLOR_SCHEME	= (C_LIGHT_GREY * 16) + C_DARK_GREY
_CR_DEFAULT	= TRUE
_CR_NAVIGATION	= TRUE		;CR and TAB to move between text fields.
_KBD_NAVIGATION	= TRUE
_MENU_NAVIGATION= TRUE
endif					;END of PM specific code --------------

_SUB_MENUS	= TRUE

;
; Pinnable menus are in Motif, CUA and PM.  They aren't in Stylus, but
; since Stylus defines _MOTIF we have to set this constant to FALSE for
; Stylus after it is set to TRUE because of _MOTIF.
;
if _STYLUS or _JEDIMOTIF or _RUDY or _ODIE
_MENUS_PINNABLE = FALSE
else
_MENUS_PINNABLE	= TRUE
endif

;
; If Zoom lines are on: When a primary (with the hint
; HINT_PRIMARY_OPEN_ICON_BOUNDS) opens, a rectangle grows from the
; bounds specified in the hint to the window's bounds.  When a primary with
; this hint closes, a rectangle shrinks from the window's bounds to the
; center of the window.
;
if _WIZARDBA or _STYLUS
_ZOOM_LINES = TRUE
else
_ZOOM_LINES = FALSE
endif

;
; If the _ZOOM_ALL_PRIMARYS constant is set, all primarys (even those without
; the hint) will get zoom lines, starting from the mouse pointer if the hint
; doesn't exist.  WizardBA doesn't want this because it only puts this hint on
; the primarys of the FileManager, and the FileManager fills it with the right
; origin.  Stylus gets it because we want zoom lines for every Primary.
;
if _STYLUS
_ZOOM_ALL_PRIMARYS = TRUE
else
_ZOOM_ALL_PRIMARYS = FALSE
endif

;
; The Stylus UI has its own special floating keyboard, but all other
; UI's currently use the bullet (standard) or Zoomer I keyboards.  Because
; we don't want to have to have a bullet and Zoomer I special UI's just
; so they can have their own keyboard, we have all the other SPUI's using
; the initfile keyboard, which allows either bullet (standard) or Zoomer I
; keyboards without recompiling.  Any production versions the non-Stylus
; SPUIs will want to be recompiled with the STANDARD_KEYBOARD or 
; ZOOMER_KEYBOARD instead of the INITFILE_KEYBOARD, as it is bigger and 
; slower.
;
; These XXXXX_KEYBOARD constants are exclusive, so don't ever have two
; of them true at the same time.  Make sure they match the UIC versions
; in CommonUI/CMain/cmainManager.ui
;
if _STYLUS
INITFILE_KEYBOARD	equ FALSE
STANDARD_KEYBOARD	equ FALSE
ZOOMER_KEYBOARD		equ FALSE
STYLUS_KEYBOARD		equ TRUE
elseif _GRAFFITI_UI
INITFILE_KEYBOARD	equ FALSE	; no keyboards for _GRAFFITI_UI
STANDARD_KEYBOARD	equ FALSE
ZOOMER_KEYBOARD		equ FALSE
STYLUS_KEYBOARD		equ FALSE
else
INITFILE_KEYBOARD	equ TRUE
STANDARD_KEYBOARD	equ FALSE
ZOOMER_KEYBOARD		equ FALSE
STYLUS_KEYBOARD		equ FALSE
endif

;
; The Stylus keyboard requires the VisKeymapClass,
; but not the VisCharTableClass
;
if STYLUS_KEYBOARD
INCLUDE_VIS_KEYMAP_CLASS	equ	TRUE
INCLUDE_VIS_CHARTABLE_CLASS	equ	FALSE
elseif (INITFILE_KEYBOARD or STANDARD_KEYBOARD or ZOOMER_KEYBOARD)
INCLUDE_VIS_KEYMAP_CLASS	equ	FALSE
INCLUDE_VIS_CHARTABLE_CLASS	equ	TRUE
else
INCLUDE_VIS_KEYMAP_CLASS	equ	FALSE
INCLUDE_VIS_CHARTABLE_CLASS	equ	FALSE
endif


;
; _ROUND_NORMAL_BW_BUTTONS makes the normal BW buttons have round
; corners instead of square corners.  These buttons are also two
; pixels thick.
; 
; _THICK_DROP_MENU_BW_BUTTONS makes the drop menu buttons have the two
; pixel thick border.
;
; _TRIANGLE_MENU_DOWN_MARK makes the menu down mark for menu buttons
; be a triangle rather than a bar.
;
; _ROUND_THICK_DIALOGS makes the dialog windows have round corners and
; 3 pixel thick borders
;
; _ROUND_THICK_DIALOGS_HAVE_HALO makes the ROUND_THICK_DIALOGS have an extra
; pixel of white border outside of the black border.. a halo, if you will.
; This gives the dialog better contrast.
;
; _THICK_MENU_BOXES make the menu boxes have 2 point borders.
;
; _ADDITIONAL_VERTICAL_SPACE_IN_MENUS makes the menu items (triggers,
; exclusive and non-exclusive items) taller by 
; _HEIGHT_OF_ADDITIONAL_VERTICAL_SPACE_IN_MENUS pixels.
;
; _CASCADING_MENUS makes menus to stay up when their sub-menus are selected.
;
; _BW_MENU_ITEM_SELECTION_IS_DEPRESSED makes the currently selected menu
; item be depressed (drawn in reverse video) as well as bordered.  If this
; is disabled, they will be bordered only (box drawn around the item).
;
; _NO_FIELD_BACKGROUND makes the field draw the background color and bitmap.
;
; _SUBMENU_ALWAYS_OVERLAPS_PARENT forces submenus to always overlap their
; parent by _OVERLAPPING_MENU_LEFT_INSET pixels.
;
; _ASSUME_BW_ONLY allows some SPUI code to assume that it will only operate
; under B&W.
;
; _TITLE_BARS_HAVE_WHITE_BORDER makes the title bars have a one pixel white
; border around the black focus highlight.
;
; _MINIMAL_STANDARD_DIALOGS makes the standard dialogs have no title bar and
; no "Cute Glpyhs".  This variable has an analog for uic in CSpec/cspecFile.ui.
;
; _WINDOW_CLOSE_BUTTON_IS_BIG_X makes the close button a nice big X, white on
; black.  B&W only, please.  There is also an analogous constant in
; cGeode.uih for the ui files.  HINT_CLOSE_BUTTON needs to be defined and
; placed on the StandardWindowMenuButton in order for this to work.
;
; _DISABLE_APP_EXIT_UI puts the app in background instead of exiting
; it when user clicked on the window close button in the title bar. It
; also doesn't  create the File Menu and Exit button in the title bar.
;
; _DETACHED_MENUS_DRAW_AS_NORMAL_BUTTONS makes menus that are not in the
; menu bar (usually caused by giving the GenInteraction the
; HINT_AVOID_MENU_BAR) draw as normal buttons.  Without this option, they
; are drawn as pop-up lists.
;
; _POPUP_MARK_DRAWN_IN_REVERSE_VIDEO draws the right edge of a pop-up
; trigger (where the mark is) in reverse video.
;
; _ROUNDED_SCROLL_BAR_THUMB draws the scrollbar "thumb" as a rounded
; rectangle instead of a rectangle with a shadow.  B&W only!  Goes well with
; _NO_SHADOWS_ON_SCROLL_ARROWS.
;
; _NO_SHADOWS_ON_SCROLL_ARROWS draws the scrollbar's arrows with no shadows.
; B&W only!
;
; _BLACK_SCROLL_BAR_BACKGROUND draws the scrollbar's background in black.
; Note that is also makes sliders and twisty scrollbars (the GenValue
; spinner thingies) also have black backgrounds.
;
; _BLACK_NORMAL_BUTTON draws black buttons with white text if it is
; not inside the Menu, nor inside the Menu bar, nor is it a system icon.
; It draws grey background with white text if the button is disabled.
; B&W only!
;
;
; Nearly all of these options are enabled for the Stylus (pen-based) UI.
;
; NOTE: these options are incompatible with DRAW_SHADOWS_ON_BW_GADGETS.
;       Be sure that option is disabled if _STYLUS is true.
;
; NOTE: it is not clear that these options would work outside of Stylus,
;       and even less clear that they would work outside of Motif.  Also,
;	most of the code assumes that the device is B&W.
;
; NOTE: Some of this code is in the Stylus directory (not part of the
;	CommonUI, unfortunately).  Therefore, if you want to enable
;	some options for other SPUI's, you need to be sure that all of
;	the instances of the compile-time options are in the CommonUI
; 	(or you copy the changes into your SPUI's directory).
;	Specific examples of this are the title bar, window, and scrollbar
;	options.
;
; NOTE: CASCADING_MENUS and BW_MENU_ITEM_SELECTION_IS_DEPRESSED have been
;	tested under Motif and they seem to work with the following caveats:
;	  (1) Interactions between CASCADING_MENUS and pinned menus isn't
;	      clearly defined since the CASCADING_MENUS was not written with
;	      pinned menus in mind.
;	  (2) The pin visMoniker does not draw correctly in BW mode if the
;	      button is "ReDrawn" depressed.  This is because the visMoniker
;	      has the color of the pin built in and thus the button cannot
;	      this color to draw white on black.
;	--JimG 5/6/94
;
if _STYLUS ;-------------------------------------------------------------------
;_ASSUME_BW_ONLY = TRUE			; defined below
if _DUI
_ROUND_NORMAL_BW_BUTTONS = FALSE
_THICK_DROP_MENU_BW_BUTTONS = FALSE
else
_ROUND_NORMAL_BW_BUTTONS = TRUE
_THICK_DROP_MENU_BW_BUTTONS = TRUE
endif
_TRIANGLE_MENU_DOWN_MARK = TRUE
;_ROUND_THICK_DIALOGS = TRUE		; defined below
;_THICK_MENU_BOXES = TRUE		; ditto
_ADDITIONAL_VERTICAL_SPACE_IN_MENUS = TRUE
_CASCADING_MENUS = TRUE
_BW_MENU_ITEM_SELECTION_IS_DEPRESSED = TRUE
_NO_FIELD_BACKGROUND = FALSE
_SUBMENU_ALWAYS_OVERLAPS_PARENT = TRUE
_TITLE_BARS_HAVE_WHITE_BORDER = FALSE	; The UI-powers that be decided they
					; didn't like this, but I think it
					; looks cool.. we'll see... --JimG
_MINIMAL_STANDARD_DIALOGS = TRUE
_WINDOW_CLOSE_BUTTON_IS_BIG_X = TRUE
_DISABLE_APP_EXIT_UI = TRUE
if _DUI
_DETACHED_MENUS_DRAW_AS_NORMAL_BUTTONS = FALSE
_POPUP_MARK_DRAWN_IN_REVERSE_VIDEO = FALSE
else
_DETACHED_MENUS_DRAW_AS_NORMAL_BUTTONS = TRUE
_POPUP_MARK_DRAWN_IN_REVERSE_VIDEO = TRUE
endif

if _DUI
_ROUND_THICK_DIALOGS_HAVE_HALO = FALSE
_BLACK_NORMAL_BUTTON = FALSE
else
_ROUND_THICK_DIALOGS_HAVE_HALO = TRUE
_BLACK_NORMAL_BUTTON = TRUE
endif
_ROUNDED_SCROLL_BAR_THUMB = TRUE
_NO_SHADOWS_ON_SCROLL_ARROWS = TRUE
_BLACK_SCROLL_BAR_BACKGROUND = TRUE

	; ENSURE that shadows are not enabled simulatenously with Stylus.
if  DRAW_SHADOWS_ON_BW_GADGETS
    ErrMessage <_STYLUS and DRAW_SHADOWS_ON_BW_GADGETS cannot both be enabled>
endif ;DRAW_SHADOWS_ON_BW_GADGETS

endif	; _STYLUS -------------------------------------------------------------


;
;  Set all the stylus flags to false for other spui's, with
;  certain exceptions.
;

if (_STYLUS or _JEDIMOTIF or _RUDY)
_ASSUME_BW_ONLY = TRUE
else
_ASSUME_BW_ONLY = FALSE
endif

if (_STYLUS or _JEDIMOTIF) and (not _DUI)
_ROUND_THICK_DIALOGS = TRUE
_THICK_MENU_BOXES = TRUE
else
_ROUND_THICK_DIALOGS = FALSE
_THICK_MENU_BOXES = FALSE
endif

if (not _STYLUS) ;-------------------------------------------------------------
_ROUND_NORMAL_BW_BUTTONS = FALSE
_THICK_DROP_MENU_BW_BUTTONS = FALSE
_TRIANGLE_MENU_DOWN_MARK = FALSE
_ADDITIONAL_VERTICAL_SPACE_IN_MENUS = FALSE

if _JEDIMOTIF or _ODIE
_CASCADING_MENUS = TRUE
else
_CASCADING_MENUS = FALSE
endif

if _JEDIMOTIF
_BW_MENU_ITEM_SELECTION_IS_DEPRESSED = TRUE
_NO_FIELD_BACKGROUND = TRUE		; should be JediXIP-only, if possible
else
_BW_MENU_ITEM_SELECTION_IS_DEPRESSED = FALSE
_NO_FIELD_BACKGROUND = FALSE
endif

_SUBMENU_ALWAYS_OVERLAPS_PARENT = FALSE
_TITLE_BARS_HAVE_WHITE_BORDER = FALSE
_MINIMAL_STANDARD_DIALOGS = FALSE
if _ODIE
_WINDOW_CLOSE_BUTTON_IS_BIG_X = TRUE
else
_WINDOW_CLOSE_BUTTON_IS_BIG_X = FALSE
endif
_DISABLE_APP_EXIT_UI = FALSE
if _RUDY
_DETACHED_MENUS_DRAW_AS_NORMAL_BUTTONS = TRUE
else
_DETACHED_MENUS_DRAW_AS_NORMAL_BUTTONS = FALSE
endif
_POPUP_MARK_DRAWN_IN_REVERSE_VIDEO = FALSE
_ROUND_THICK_DIALOGS_HAVE_HALO = FALSE
_ROUNDED_SCROLL_BAR_THUMB = FALSE
_NO_SHADOWS_ON_SCROLL_ARROWS = FALSE
_BLACK_SCROLL_BAR_BACKGROUND = FALSE
_BLACK_NORMAL_BUTTON = FALSE
endif		; (not _STYLUS) -----------------------------------------------

; If popup mark's are drawn in reverse video, this variable describes the
; distance from the right edge of the button at which the inverse rectangle
; begins.
if _POPUP_MARK_DRAWN_IN_REVERSE_VIDEO
_REVERSE_RECTANGLE_OFFSET_FROM_RIGHT_EDGE = ((OL_MARK_WIDTH+BUTTON_INSET_X)-3)
endif

; Indicates the additional thickness of the thick dialog border used
; with the stylus ui.
if _ROUND_THICK_DIALOGS
   ; This internal base variable is used in case we want to add to the
   ; border (like _ROUND_THICK_DIALOGS_HAVE_HALO)
___ROUND_THICK_DIALOG_BORDER_BASE = 2
_ROUND_THICK_DIALOG_BORDER = ___ROUND_THICK_DIALOG_BORDER_BASE
endif

; Indicates the additional thickness of the halo around the dialog border.
; The "halo" is a small white border outside of the black border used for
; contrast.
if _ROUND_THICK_DIALOGS_HAVE_HALO
  ; Must have round thick dialogs enabled if halo is enabled.
  if not _ROUND_THICK_DIALOGS
      ErrMessage <_ROUND_THICK_DIALOGS must be enabled if ..._HAVE_HALO is enabled>
  endif ;not _ROUND_THICK_DIALOGS
  
; Add 1 pixel to whatever the border was before.
_ROUND_THICK_DIALOG_HALO = 1
_ROUND_THICK_DIALOG_BORDER = (___ROUND_THICK_DIALOG_BORDER_BASE+_ROUND_THICK_DIALOG_HALO)
endif


; Indicates the number of pixels to add to menu items if this option
; is enabled.  SHOULD BE AN EVEN NUMBER SO THE CENTERING IS DONE PROPERLY.
if _ADDITIONAL_VERTICAL_SPACE_IN_MENUS
_HEIGHT_OF_ADDITIONAL_VERTICAL_SPACE_IN_MENUS = 4
endif ;_ADDITIONAL_VERTICAL_SPACE_IN_MENUS

; If a submenu is always supposed to overlap its parent, then set the amount
; of overlap to be _OVERLAPPING_MENU_LEFT_INSET number of pixels.
if _SUBMENU_ALWAYS_OVERLAPS_PARENT
_OVERLAPPING_MENU_LEFT_INSET = 50
endif ;_SUBMENU_ALWAYS_OVERLAPS_PARENT

;
; _ALLOW_MINIMIZED_TITLE_BARS enables recognition of the
; HINT_WINDOW_MINIMIZE_TITLE_BAR hint and will draw the title bar void of
; any gadgets and moniker.  It will also not include the size of the
; would-be moniker into the title bar, and this reduces the vertical size of
; the title bar by about 1/2.
;
; Tested and implemented under Stylus and the real Motif.
;
if _STYLUS or (_MOTIF and (not _JEDIMOTIF) and (not  _REDMOTIF))
_ALLOW_MINIMIZED_TITLE_BARS = TRUE
else
_ALLOW_MINIMIZED_TITLE_BARS = FALSE
endif

;
; Various features for Jedi only, that others might want to use.
;
if _JEDIMOTIF or _RUDY
_NO_PRIMARY_HELP_TRIGGER = TRUE
else
_NO_PRIMARY_HELP_TRIGGER = FALSE
endif

if _JEDIMOTIF
_MENU_BUTTONS_SHOW_FOCUS_BY_INVERTING = TRUE
_DISABLE_SCROLLERS_WHEN_NOT_SCROLLABLE = TRUE
_DRAW_DISABLED_BUTTONS_WITH_SOLID_BORDER = TRUE
else
_MENU_BUTTONS_SHOW_FOCUS_BY_INVERTING = FALSE
_DISABLE_SCROLLERS_WHEN_NOT_SCROLLABLE = FALSE
_DRAW_DISABLED_BUTTONS_WITH_SOLID_BORDER = FALSE
endif

if _JEDIMOTIF or _ODIE
_ALLOW_MISC_GADGETS_IN_MENU_BAR	= TRUE
else
_ALLOW_MISC_GADGETS_IN_MENU_BAR	= FALSE
endif

;
; This enables a hack that BrianC made for Jedi but fixes problems with the
; menus when using a vertical hard icon bar on PC demos.  DO NOT LEAVE THIS
; OPTION ENABLED FOR THE ACTUAL SHIPPING DEVICE.  It will work on the
; hardware as well as on the demo, but it causes the spui to do extra
; translations that are not necessary if the field and the screen both start
; at the same upper-left coordinates.  If someone really figures out why
; this is happening, this hack should be deleted.
if _DUI
_NASTY_HACK_FOR_MENUS_WITH_VERTICAL_HARD_ICONS = FALSE
else
_NASTY_HACK_FOR_MENUS_WITH_VERTICAL_HARD_ICONS = FALSE
endif

;
; Selection boxes.  To create a selection box the user puts
; HINT_MINIMIZE_SIZE on a GenItemGroup.
;
if _ODIE
SELECTION_BOX				equ	TRUE
else
SELECTION_BOX				equ	FALSE
endif

if 	SELECTION_BOX and ERROR_CHECK
OL_ERROR_SELECTION_BOX					enum FatalErrors
; General selection box error.

OL_ERROR_SELECTION_BOX_CAN_NOT_HAVE_ZERO_CHILDREN	enum FatalErrors
; Selection boxes can not have zero children so DIE,DIE,DIE.

OL_ERROR_CANT_FIND_SELECTION_BOX_ITEM_GROUP		enum FatalErrors
; The selection box is visually represented by an OLMenuButton,
; but the list is an item group.  This error means we couldn't find
; the item group associated with the menu button for the selection
; box.

OL_ERROR_SELECTION_BOX_MUST_HAVE_INITIALLY_SELECTED_ITEM enum FatalErrors
; The selection box item group must have an initially selected item.

WRONG_NUMBER_OF_BACKGROUND_COLORS			enum FatalErrors
; If a selection box has the wrong number of colors as extra
; data for HINT_GADGET_BACKGROUND_COLORS.  For Selection Boxes,
; we can have either 4 (only moniker background) or 8 (moniker/
; arrow box background colors).

endif		; if SELECTION_BOX & ERROR_CHECK

;
; Some specific UI's require horizontal and/or vertical
; scrollbars to appear up in the title bar.
;

if _JEDIMOTIF
_VIEW_X_SCROLLERS_GO_IN_TITLE_BAR = TRUE
else
_VIEW_X_SCROLLERS_GO_IN_TITLE_BAR = FALSE
endif

if _JEDIMOTIF
_VIEW_Y_SCROLLERS_GO_IN_TITLE_BAR = TRUE
else
_VIEW_Y_SCROLLERS_GO_IN_TITLE_BAR = FALSE
endif

;
; Turn on and off various CUA-style keyboard accelerators.   They're
; currently on for everything.
;
if _ODIE
_USE_KBD_ACCELERATORS = FALSE
else
_USE_KBD_ACCELERATORS = TRUE
endif

;
; Whether we want to wrap around on list navigation.
;
if _RUDY
_WRAP_AROUND_LIST_NAVIGATION	= FALSE
else
_WRAP_AROUND_LIST_NAVIGATION	= TRUE
endif

;
; Whether we want to wrap around on list navigation.
;
if _RUDY
_DISABLED_SCROLL_ITEMS_DRAWN_WITH_SDM_50	= FALSE
else
_DISABLED_SCROLL_ITEMS_DRAWN_WITH_SDM_50	= TRUE
endif

;
; Whether we want to allow ALT to toggle menu navigation on, etc.
;
if _RUDY or _JEDIMOTIF
HANDLE_MENU_TOGGLING	= FALSE
else
HANDLE_MENU_TOGGLING	= TRUE
endif

;
; Whether we want the current selection to always be display in popup lists.
;
if _RUDY or SELECTION_BOX
POPUPS_ALWAYS_DISPLAY_CURRENT_SELECTION	= TRUE
else
POPUPS_ALWAYS_DISPLAY_CURRENT_SELECTION	= FALSE
endif

;
; Give lists in delayed-mode reset behavior
;
if _RUDY
DELAYED_LISTS_DO_RESET	= TRUE
else
DELAYED_LISTS_DO_RESET	= FALSE
endif

;
; Whether we want fields to be transparent, so the splash screen stays on
; the screen forever
;
if _RUDY
TRANSPARENT_FIELDS	= TRUE
else
TRANSPARENT_FIELDS	= FALSE
endif

;
; Whether we want a floating keyboard trigger on the primary
;
if _NIKE
_FLOATING_KEYBOARD_TRIGGER_ON_PRIMARY	= TRUE
else
_FLOATING_KEYBOARD_TRIGGER_ON_PRIMARY	= FALSE
endif

;
; Whethere minimum and maximum monikers (HINT_VALUE_SHOW_MIN_AND_MAX) align
; with slider/gauge
;
if _JEDIMOTIF
ALIGN_VALUE_MIN_MAX_MONIKERS		= TRUE
else
ALIGN_VALUE_MIN_MAX_MONIKERS		= FALSE
endif

;
; Whether GenValue's are turned into pure text objects, rather than spin
; gadgets.   
;
if _RUDY
GEN_VALUES_ARE_TEXT_ONLY		equ	TRUE
else
GEN_VALUES_ARE_TEXT_ONLY		equ	FALSE
endif

;
; Whether we want minimized primaries to appear as win_icons.
;
if _PM or _ODIE
_NO_WIN_ICON				equ	TRUE
else
_NO_WIN_ICON				equ	FALSE
endif

;
; GCM (General Consumer Mode)
;
if _PM
_GCM					equ	TRUE
else
_GCM					equ	FALSE
endif

;
; Whether items in scrollable lists can be drawn with gridlines and spacing
;
if _ODIE
SCROLL_LIST_GRID_LINES_AND_SPACING	equ	TRUE
else
SCROLL_LIST_GRID_LINES_AND_SPACING	equ	FALSE
endif

;
; Whether linked lists using HINT_ITEM_GROUP_{PREV/NEXT}_LINK are supported.
;
if _ODIE
SCROLL_LISTS_CAN_BE_LINKED		equ	TRUE
else
SCROLL_LISTS_CAN_BE_LINKED		equ	FALSE
endif

;
; Whether notification should be sent out when we scroll up from top item
; or down from bottom item.
;
if _ODIE
SCROLL_LIST_NOTIFY_ON_SCROLL_OUT_OF_BOUNDS	equ	TRUE
else
SCROLL_LIST_NOTIFY_ON_SCROLL_OUT_OF_BOUNDS	equ	FALSE
endif

;
; Allow app to specify window wash color.
;
if _ODIE
WINDOW_WASH_COLOR			equ	TRUE
else
WINDOW_WASH_COLOR			equ	FALSE
endif

;
; Allow subgroup GenInteration to look like a notebook binder.
;
if _ODIE
NOTEBOOK_INTERACTION			equ	TRUE
else
NOTEBOOK_INTERACTION			equ	FALSE
endif

;
; Place menubar inside a menu.
;
if _ODIE
MENU_BAR_IS_A_MENU			equ	TRUE
else
MENU_BAR_IS_A_MENU			equ	FALSE
endif

;
; Turn off menu marks.
;
if _ODIE
NO_MENU_MARKS				equ	TRUE
else
NO_MENU_MARKS				equ	FALSE
endif

;
; Bubble help
;
if _ODIE
BUBBLE_HELP				equ	TRUE
else
BUBBLE_HELP				equ	FALSE
endif

;
; Bubble Position
;
if _DUI
POSITION_BUBBLE_WRT_ACTIVATOR		equ	TRUE
else
POSITION_BUBBLE_WRT_ACTIVATOR		equ	FALSE
endif

;
; Popup menu button
;
if _DUI
_MENU_DOWN_MARKS_ARE_UP_ARROWS		equ	TRUE
else
_MENU_DOWN_MARKS_ARE_UP_ARROWS		equ	FALSE
endif

;
; TEXT_DISPLAY_FOCUSABLE turns on Penelope-style focus indication for
; text displays (i.e. non-editable).  The focus is indicated with a dotted
; box *inside* the border/frame of the text object.
;
if _ODIE
TEXT_DISPLAY_FOCUSABLE	equ	TRUE
else
TEXT_DISPLAY_FOCUSABLE	equ	FALSE
endif

;
; CLIP_SINGLE_LINE_TEXT will make single line text displays and single line
; text edits without the focus clip their text with ellipsis.  This ensures
; that the beginning of the text is visible.  When text edits gain the focus,
; the text can scroll.  Should also have TEXT_DISPLAY_FOCUSABLE and
; BUBBLE_HELP turned on so text displays can bring up a bubble to show all the
; text when they gain focus.
;
if _ODIE
CLIP_SINGLE_LINE_TEXT	equ	TRUE
else
CLIP_SINGLE_LINE_TEXT	equ	FALSE
endif

;
; CURSOR_ON_BACKGROUND_COLOR turns on code to choose a reasonable curosr
; (focus indication) color and to remove cursor drawing optimizations to
; fix greeble problems when HINT_GADGET_BACKGROUND_COLORS is used on
; objects.  Turning this on will slow down some gadget drawing operations,
; but will fix greebles.
;
; Only tested for _ODIE.  For other SPUIs, you'll have to check the
; appropriate places in the draw code and in OpenSetCursorColorFlags and
; OpenDrawSelectionCursor.
;
if _ODIE
CURSOR_ON_BACKGROUND_COLOR	equ	TRUE
else
CURSOR_ON_BACKGROUND_COLOR	equ	FALSE
endif

;
;
; DRAW_STYLES enables support for HINT_DRAW_STYLE_FLAT,
; HINT_DRAW_STYLE_3D_RAISED, HINT_DRAW_STYLE_3D_LOWERED.  The exact support
; depends on each gadget.
;
if _ODIE
DRAW_STYLES		equ	TRUE
else
DRAW_STYLES		equ	FALSE
endif

;
; ITEM_USES_BACKGROUND_COLOR enables support of HINT_GADGET_BACKGROUND_COLORS
; on simple checkbox and radio button GenItems/GenItemGroups and GenBooleans/
; GenBooleanGroups.
;
if _ODIE
ITEM_USES_BACKGROUND_COLOR	equ	TRUE
else
ITEM_USES_BACKGROUND_COLOR	equ	FALSE
endif

;
; CTRL_USES_BACKGROUND_COLOR enables support of HINT_GADGET_BACKGROUND_COLORS
; on GIV_SUB_GROUND GenInteractions.
;
if _ODIE
CTRL_USES_BACKGROUND_COLOR	equ	TRUE
else
CTRL_USES_BACKGROUND_COLOR	equ	FALSE
endif

;
; GLYPH_USES_BACKGROUND_COLOR enables support of HINT_GADGET_BACKGROUND_COLORS
; on GenGlyphs.
;
if _ODIE
GLYPH_USES_BACKGROUND_COLOR	equ	TRUE
else
GLYPH_USES_BACKGROUND_COLOR	equ	FALSE
endif

;
; SLIDER_INCLUDES_VALUES puts the min, max, and current values within the
; bounds of the slider and gauge.  Currently, only support for Odie.
;
if _ODIE
SLIDER_INCLUDES_VALUES		equ	TRUE
else
SLIDER_INCLUDES_VALUES		equ	FALSE
endif

;
; SLIDER_SNAPS_TO_INCREMENT will only allow a thumb of a slider to be
; dragged and placed on valid positions based on the increment set in
; the GenValue instance data.
;
if _ODIE
SLIDER_SNAPS_TO_INCREMENT	equ	TRUE
else
SLIDER_SNAPS_TO_INCREMENT	equ	FALSE
endif

;
; CURSOR_OUTSIDE_BOUNDS moves the focus indicator outside the bounds of the
; object.  This will be supported for buttons, sliders, selection box, and
; spinners.  This might also include some code to actually show focus
; indicator for the gadget (i.e. sliders).
;
if _ODIE
CURSOR_OUTSIDE_BOUNDS		equ	TRUE
else
CURSOR_OUTSIDE_BOUNDS		equ	FALSE
endif

if CURSOR_OUTSIDE_BOUNDS or CTRL_USES_BACKGROUND_COLOR
RGB_COLOR_NOT_SUPPORTED				enum	FatalErrors
;
; RGB color value not supported for window wash color (HINT_WINDOW_WASH_COLOR)
; or view wash color (GVI_color) for this SPUI.
;
endif

;
; SPINNER_GEN_VALUE will make digital GenValues have their scroll arrows
; on the left and right sides of the digital value.
;
if _ODIE
SPINNER_GEN_VALUE		equ	TRUE
else
SPINNER_GEN_VALUE		equ	FALSE
endif

;
; ANIMATED_BUSY_CURSOR enables an animated busy cursor.  The busy cursor
; pointer cycles through several frames.
;
if _ODIE
ANIMATED_BUSY_CURSOR	equ	TRUE
else
ANIMATED_BUSY_CURSOR	equ	FALSE
endif

;
; I_BEAM_TEXT_CURSOR makes the text object cursor an I-beam instead of a
; simple vertical line
;
if _ODIE
I_BEAM_TEXT_CURSOR	equ	TRUE
else
I_BEAM_TEXT_CURSOR	equ	FALSE
endif

;
; DIALOG_SHADOWS enables shadows on dialogs, both bubble and regular, if
; they have HINT_DRAW_SHADOW
;
if _ODIE
DIALOG_SHADOWS	equ	TRUE
else
DIALOG_SHADOWS	equ	FALSE
endif

;
; EVENT_MENU enables an Event Menu to be added to the title bar of apps
; using the Event Handler library.  Also set EVENT_MENU in cGeode.uih,
; and 'library evnthdlr' in odie.gp.
;
if _ODIE
EVENT_MENU	equ	TRUE
else
EVENT_MENU	equ	FALSE
endif

;
; TAKE_FOCUS_FROM_TEXT_OBJECT enables gadgets in a window with a text object
; to take the focus from that text object.  The default is off, since we
; want to keep the focus on the text object, so the user can continue editing.
;
if _ODIE or _DUI
TAKE_FOCUS_FROM_TEXT_OBJECT	equ	TRUE
else
TAKE_FOCUS_FROM_TEXT_OBJECT	equ	FALSE
endif

;
; DC_DISALLOW_SPACES_FILE_NAME will not allow creation of documents with
; trailing or leading spaces in their filename.
;
if _DUI
DC_DISALLOW_SPACES_FILENAME	equ	TRUE
else
DC_DISALLOW_SPACES_FILENAME	equ	FALSE
endif

;
; SHORT_LONG_TOUCH allows distinct action messages to be sent out for when
; the user selects an object for a short or long period of time.
;
if _ODIE
SHORT_LONG_TOUCH		equ	TRUE
else
SHORT_LONG_TOUCH		equ	FALSE
endif

;
; RADIO_STATUS_ICON_ON_PRIMARY causes a button to be added to the left side
; of the titlebar on GenPrimaries.  The icon indicates the status of the
; communication link.  (One could easily argue that this should be just
; 'if _ODIE' since it really is _ODIE specific.
;
if _ODIE
RADIO_STATUS_ICON_CYCLE_INTERVAL =	15	; 1/4 second
RADIO_STATUS_ICON_ON_PRIMARY	equ	TRUE
else
RADIO_STATUS_ICON_ON_PRIMARY	equ	FALSE
endif

;
; APPLICATION_MENU creates an application list menu in place of the
; express menu.
;
if _ODIE
APPLICATION_MENU		=	TRUE
else
APPLICATION_MENU		=	FALSE
endif

;
; ROUNDED_CORNERS causes draw-in-box OLCtrl's to draw a rounded box, thanks
; to Joon.   None of our specific UI's currently need the behavior, though.
;
CTRL_ROUNDED_BOX_CORNERS	=	FALSE

;
; TOOL_AREA_IS_TASK_BAR uses the tool area as a task bar.
; (also set TOOL_AREA_IS_TASK_BAR in cGeode.uih)
;
if _ISUI
TOOL_AREA_IS_TASK_BAR		=	TRUE
else
TOOL_AREA_IS_TASK_BAR		=	FALSE
endif

;
; allow extending the system tray via the mechanisms to extend the Express
; menu. also turn on EXTENDIBLE_SYSTEM_TRAY in cGeode.uih
;
if _ISUI
EXTENDIBLE_SYSTEM_TRAY	=	TRUE
else
EXTENDIBLE_SYSTEM_TRAY	=	FALSE
endif

if EXTENDIBLE_SYSTEM_TRAY and ERROR_CHECK
OL_ERROR_CANT_FIND_SYSTRAY_OBJECT			enum FatalErrors
endif

;
; Constants primarily for the dedicated word processor UI's.
;
; LIMITED_HEAPSPACE
;	There is a limited amount of heapspace compared to the size of the apps
;	that are running, probably only one big app can run at a time.  We
;	have some hacks in the system to disable the express menu when an
;	app is transparently detaching, to cover over some apparent problems
;	with an app immediately transparent detach when another is brought
; 	to the front.
;
; NO_USER_LEVELS
;	What you see is what you get.   No user levels, or simple/advanced
;	file selector stuff.

; SOLID_FOCUS_OUTLINE
;	Forces a black, solid, two pixel thick focus outline.  I recommend
; 	this for all keyboard-only UI's.
;
; ALL_DIALOGS_ARE_MODAL
;	We've made all the dialog boxes modal.    This may be necessary for
;	keyboard-only systems (rather than problems we encountered in Redwood
;	particularly) but I could be wrong.
;
; DISPLAY_SAVING_MESSAGE
;	An explicit message is displayed on user saves, usually because of
;	a very slow (i.e. floppy) disk drive.
;
; NO_NETWORK
;	There is no network attached to this system, so we'll attempt to
;	adjust error text as appropriate.
;

ifidn PRODUCT, <REDWOOD>

DISPLAY_SAVING_MESSAGE			equ	TRUE
SOLID_FOCUS_OUTLINE			equ	TRUE
ALL_DIALOGS_ARE_MODAL			equ	TRUE
LIMITED_HEAPSPACE			equ	TRUE
NO_USER_LEVELS				equ	TRUE
NO_NETWORK				equ	TRUE

else
ifidn PRODUCT, <DWP>

DISPLAY_SAVING_MESSAGE			equ	TRUE
SOLID_FOCUS_OUTLINE			equ	TRUE
ALL_DIALOGS_ARE_MODAL			equ	TRUE
LIMITED_HEAPSPACE			equ	FALSE
NO_USER_LEVELS				equ	TRUE
NO_NETWORK				equ	TRUE

else
if _NIKE

DISPLAY_SAVING_MESSAGE			equ	TRUE
SOLID_FOCUS_OUTLINE			equ	FALSE
ALL_DIALOGS_ARE_MODAL			equ	FALSE
LIMITED_HEAPSPACE			equ	FALSE
NO_USER_LEVELS				equ	TRUE
NO_NETWORK				equ	TRUE

else
if _RUDY

DISPLAY_SAVING_MESSAGE			equ	FALSE
SOLID_FOCUS_OUTLINE			equ	FALSE
ALL_DIALOGS_ARE_MODAL			equ	TRUE
LIMITED_HEAPSPACE			equ	FALSE
NO_USER_LEVELS				equ	TRUE
NO_NETWORK				equ	TRUE

else
if _JEDIMOTIF

DISPLAY_SAVING_MESSAGE			equ	FALSE
SOLID_FOCUS_OUTLINE			equ	FALSE
ALL_DIALOGS_ARE_MODAL			equ	FALSE
LIMITED_HEAPSPACE			equ	FALSE
NO_USER_LEVELS				equ	TRUE
NO_NETWORK				equ	FALSE

else
if _ODIE

DISPLAY_SAVING_MESSAGE			equ	FALSE
SOLID_FOCUS_OUTLINE			equ	FALSE
ALL_DIALOGS_ARE_MODAL			equ	FALSE
LIMITED_HEAPSPACE			equ	FALSE
NO_USER_LEVELS				equ	TRUE
NO_NETWORK				equ	TRUE

else
if _DUI

DISPLAY_SAVING_MESSAGE			equ	FALSE
SOLID_FOCUS_OUTLINE			equ	FALSE
ALL_DIALOGS_ARE_MODAL			equ	FALSE
LIMITED_HEAPSPACE			equ	FALSE
NO_USER_LEVELS				equ	TRUE
NO_NETWORK				equ	FALSE

else

DISPLAY_SAVING_MESSAGE			equ	FALSE
SOLID_FOCUS_OUTLINE			equ	FALSE
ALL_DIALOGS_ARE_MODAL			equ	FALSE
LIMITED_HEAPSPACE			equ	FALSE
NO_USER_LEVELS				equ	FALSE
NO_NETWORK				equ	FALSE

endif
endif
endif
endif
endif
endif
endif


if _MAC				;START of MAC specific code --------------------
OL_DEFAULT_COLOR_SCHEME	= BW_DEFAULT_COLOR_SCHEME
_CR_DEFAULT		= TRUE
_CR_NAVIGATION		= TRUE
_KBD_NAVIGATION		= FALSE
_MENU_NAVIGATION	= FALSE

_SUB_MENUS		= TRUE
_MENUS_PINNABLE		= FALSE
endif				;END of MAC specific code ----------------------


EXPRESS_MENU_ON_RIGHT	= FALSE	;Set if express menu should appear on right.
				;If false, will be on left next to system
				;menu (In MOTIF, anyway)

PRESERVE_FOCUS_IF_PEN_ONLY	=	TRUE
				;Set if we want to keep menus from grabbing
				;the focus on systems with no keyboard
				;navigation going.

NORMAL_HEADERS_ON_DISABLED_WINDOWS	= TRUE
				;Set if we want to draw headers normally on
				;disabled windows.  Gadgets will be enabled
				;AND active.

_IGNORE_STATES_MAXIMIZING = FALSE
				; If set, it will check the .ini file for
				; "ignoreStatesMaximizing" under the
				; "ui features" category.  If true if we want
				; windows to come up and conform to the
				; Maximizing behavior of the system instead
				; of believing their state file's.  This is
				; used pretty much only for the demo of the
				; SPUI, where we are switching between UI
				; models and don't want to believe the state
				; wrt Maximizing because it represents the
				; previous product's behavior.  dlitwin 9/21/94

if _RUDY or _JEDIMOTIF
FUNCTION_KEYS_MAPPED_TO_MENU_BAR_BUTTONS		equ	TRUE
else
FUNCTION_KEYS_MAPPED_TO_MENU_BAR_BUTTONS		equ	FALSE
endif

;
; Set TRUE to deal with problem where a GEOS file is create file selector
; get create notification before the file's extended attributes are set,
; thus causing file selector to incorrectly determine accept/reject status
; of file.  The fix is to save a list of all GEOS file on CREATE notification
; and when CHANGE_ATTRIBUTE notification comes, if the affected file is one
; in the list, we'll do a complete rescan.
;
if _JEDIMOTIF
HANDLE_CREATE_GEOS_FILE_NOTIFICATION	equ	TRUE
else
HANDLE_CREATE_GEOS_FILE_NOTIFICATION	equ	FALSE
endif

;
; Set TRUE to turn off application busy state when document control blocking
; dialogs are displayed.  This may be necessary to allow APO to function.
; It uses an extra word of instance data in OLDocumentClass.
;
if _JEDIMOTIF
TURN_OFF_BUSY_ON_DOC_CTRL_DIALOG	equ	FALSE	; replaced by below
else
TURN_OFF_BUSY_ON_DOC_CTRL_DIALOG	equ	FALSE
endif

;
; Set TRUE to disable APO on MSG_GEN_APPLICATION_MARK_BUSY and
; MSG_GEN_APPLICATION_MARK_COMPLETELY_BUSY.  (Kind of eliminates need for
; above)
;
if _JEDIMOTIF
DISABLE_APO_ON_BUSY			equ	FALSE
DISABLE_APO_ON_COMPLETELY_BUSY		equ	FALSE
else
DISABLE_APO_ON_BUSY			equ	TRUE
DISABLE_APO_ON_COMPLETELY_BUSY		equ	TRUE
endif

;
; Express Menu Constant
; If this constant equals TRUE, we have Express Menu in our product.
; If this constant equals FALSE, we have no Express Menu.
;
_EXPRESS_MENU				=	TRUE

if _JEDIMOTIF or _RUDY
_EXPRESS_MENU				=	FALSE
endif

; Allow items to look like tabs.  Use HINT_ITEM_GROUP_TAB_STYLE
; modified by HINT_ORIENT_CHILDREN_VERTICALLY,
; HINT_LEFT/RIGHT_JUSTIFY, and HINT_DRAW_STYLE_3D_RAISED to draw
; the desired tab.
;
if	_ODIE or _DUI
	ALLOW_TAB_ITEMS			equ	TRUE
else
	ALLOW_TAB_ITEMS			equ	FALSE
endif

if _DUI and ALLOW_TAB_ITEMS
	BW_TAB_ITEMS			equ	TRUE
else
	BW_TAB_ITEMS			equ	FALSE
endif

;
; More flags.  These are currently Rudy-specific flags, but will probably
; be useful elsewhere at some point.
;
; NO_WINDOW_FRAME_ON_VIEWS
; 	Views never draw their frames.
;
; BUBBLE_DIALOGS
;	When HINT_ACTIVATED_BY is on a menu, if possible an arrow is drawn from
;	the menu to the activator.   Currently only guaranteed to draw
;	arrows out to the left correctly, though there seems to be code
;	for arrows going out other sides of the window.
;
; DRAW_EXPRESS_MENU_ON_PRIMARY
;	Express menu is shown in the primary.    When false, express menu just
;	hangs out on the field.
;
; MENUS_HAVE_APPLY_CANCEL_BUTTONS
;	Funky menu stuff.   In this mode, visibility=popup is merely a special
;	kind of OK/Cancel type box.
;
; DISABLED_ITEMS_ARE_SELECTABLE
;	Disabled items in a list object (GenItemGroup, GenDynamicList)
;	can be navigated to.  Any IC_APPLY trigger will be disabled
;	to prevent the user from actually selecting it.
;
; FUNCTION_KEYS_MAPPED_TO_REPLY_BAR_BUTTONS
;	F1-F4 are the reply bar activators in this mode.   Uses slot hints
;	for the reply bar buttons as well.	
;
; MENU_BAR_AT_BOTTOM
;	Menu bar at bottom of window, instead of at top.  (Or at right edge
;	of window, if HORIZONTAL_WINDOWS is set.)	
;
; FUNCTION_KEYS_MAPPED_TO_MENU_BAR_BUTTONS
;	F1-F4 are the reply bar activators in this mode.   Uses slot hints
;	for the reply bar buttons as well.	
;	
; SINGLE_FIELD_SYSTEM
;	No need to worry about a lot of (slow) field switching stuff when
;	this flag is on.
;
; NO_REPLY_BAR_DRAWING
;	No special lines/colors drawn for the reply bar.
;
; NO_MENU_BAR_DRAWING
;	No special lines/colors drawn for the menu BARS
;	Menu bars and reply bars are place to the left or right of the main
;	elements of the window.   The main elements (
;
; DRAW_LEAF_IF_HAVE_FOCUS
;	Special code that handles HINT_INTERACTION_FOCUSABLE.   Interactions
;	can take the focus (rather than allowing a child to take the focus)
;	and draw an upturned leaf in these cases.  (Maybe also a bolder outline)
;
; PARENT_CTRLS_INVERTED_ON_CHILD_FOCUS
;	A weird mode where if an object gets the focus, the parent also will
;	be inverted, which allows center-children-on-monikers groups where
;	both the left and right sides of a line are inverted when a child
;	on the right side is selected.   This is very esoteric to the Rudy
;	UI design, but there it is.
;
; DRAW_WINDOW_MARK_IN_MONIKERS
;	"..." is displayed for buttons that open other windows.
;
; DRAW_SELECTION_CURSOR_FOR_FOCUSED_GADGETS
; 	We will draw a dotted selection rectangle around a focus item.
;
; FOCUSED_GADGETS_ARE_INVERTED
;	We'll invert the item with the focus, in this mode.
;
; DRAW_MNEMONIC_UNDERLINES
;	Mnemonic underlines are drawn.
;
; ASSUME_BOLD_STYLE_FOR_MONIKERS
;	If bold and italics are being automatically drawn for any gadgetry
;	in the UI, you better set this so the sizes of the gadgets are not
;	chosen to be too small.
;
; MONIKER_LIST_NEEDED_FOR_STD_DIALOG_MONIKERS
;	If the standard dialog boxes don't need moniker lists, this can be
;	set false to turn off some ugly relocation code.
;
; FSEL_HAS_CHANGE_DRIVE_POPUP
;	Change drive popup is needed for the file selector sometimes.
;
; FSEL_HAS_CHANGE_DIRECTORY_POPUP
;	Change directory popup is needed for the file selector sometimes.
;
; FSEL_HAS_DOCUMENT_BUTTON
;	Document button is at least sometimes needed for the file selector.
;
; DRAW_BUTTON_BORDERS, DRAW_ITEM_BORDERS
;	Borders should be drawn around buttons and items.   Flag selection
;	of borders are implemented for B/W gadgets only; the corresponding 
;	changes could be made in the color code very quickly if needed.
;
; FSEL_DISABLES_FILTERED_FILES
;	Files (not directories) rejected by filter are disable instead of
;	removed.
;
; HAVE_FAKE_FILE_SYSTEM
;	Enables alternate backends for File Selectors.  Right now, the
;	only example of this is the PCComFileSelector, which gets all
;	its data from the pccom library.  There's not a lot of
;	overhead, but enough that you probably want this off unless
;	you're doing something special.
;
;
; HOLISTIC_SCROLLBAR_POSITIONING
;	Uses VUP_QUERIES to help determine where Scrollbars should
;	be placed.  They are still children of the view, but their
;	positions are nudged around to appear in the correct place.
;	(defined earlier)
;
; USE_REDRAW_ITEMS_OPTIMIZATION
;     If TRUE, will use some additional logic to avoid unnecessary
;     redraws of trailing dynamic scrolling list items. (applicable to
;	all UI's, but can be turned off if horrible bugs pop up in it)
;
; INDENT_BOXED_CHILDREN
;	If TRUE, windows will indent HINT_DRAW_IN_BOX children by applying
;	left margin to gadget area.
;

USE_REDRAW_ITEMS_OPTIMIZATION				equ     TRUE

if _RUDY

NO_WINDOW_FRAME_ON_VIEWS				equ	TRUE
BUBBLE_DIALOGS						equ	TRUE
MENUS_HAVE_APPLY_CANCEL_BUTTONS				equ	TRUE
DISABLED_ITEMS_ARE_SELECTABLE				equ	TRUE
FUNCTION_KEYS_MAPPED_TO_REPLY_BAR_BUTTONS		equ	TRUE
MENU_BAR_AT_BOTTOM					equ	TRUE
SINGLE_FIELD_SYSTEM					equ	TRUE
NO_REPLY_BAR_DRAWING					equ	TRUE
NO_MENU_BAR_DRAWING					equ	TRUE
DRAW_LEAF_IF_HAVE_FOCUS					equ	TRUE
PARENT_CTRLS_INVERTED_ON_CHILD_FOCUS			equ	TRUE
FOCUSED_GADGETS_ARE_INVERTED				equ	TRUE
ASSUME_BOLD_STYLE_FOR_MONIKERS				equ	TRUE
NO_FILES_MONIKER					equ	TRUE
FSEL_DISABLES_FILTERED_FILES				equ	TRUE
HAVE_FAKE_FILE_SYSTEM					equ	TRUE
USE_REDRAW_ITEMS_OPTIMIZATION				equ     TRUE
INDENT_BOXED_CHILDREN					equ	TRUE

FSEL_HAS_CHANGE_DRIVE_POPUP				equ	FALSE
FSEL_HAS_CHANGE_DIRECTORY_POPUP				equ	FALSE
FSEL_HAS_DOCUMENT_BUTTON				equ	FALSE
MONIKER_LIST_NEEDED_FOR_STD_DIALOG_MONIKERS		equ	FALSE
DRAW_BUTTON_BORDERS					equ	FALSE
DRAW_ITEM_BORDERS					equ	FALSE
DRAW_SELECTION_CURSOR_FOR_FOCUSED_GADGETS		equ	FALSE
PLACE_EXPRESS_MENU_ON_PRIMARY				equ	FALSE
DRAW_WINDOW_MARK_IN_MONIKERS				equ	FALSE
DRAW_MNEMONIC_UNDERLINES				equ	FALSE
THREE_DIMENSIONAL_BORDERS				equ	FALSE
GRADIENT_TITLE_BAR					equ	FALSE

else
if _ODIE

NO_WINDOW_FRAME_ON_VIEWS				equ	FALSE
BUBBLE_DIALOGS						equ	TRUE
MENUS_HAVE_APPLY_CANCEL_BUTTONS				equ	FALSE
DISABLED_ITEMS_ARE_SELECTABLE				equ	TRUE
FUNCTION_KEYS_MAPPED_TO_REPLY_BAR_BUTTONS		equ	FALSE
MENU_BAR_AT_BOTTOM					equ	FALSE
SINGLE_FIELD_SYSTEM					equ	TRUE
NO_REPLY_BAR_DRAWING					equ	TRUE
NO_MENU_BAR_DRAWING					equ	TRUE
DRAW_LEAF_IF_HAVE_FOCUS					equ	FALSE
PARENT_CTRLS_INVERTED_ON_CHILD_FOCUS			equ	FALSE
FOCUSED_GADGETS_DO_NOT_HAVE_A_SELECTION_CURSOR		equ	FALSE
FOCUSED_GADGETS_ARE_INVERTED				equ	FALSE
NO_MNEMONICS						equ	FALSE
ASSUME_BOLD_STYLE_FOR_MONIKERS				equ	FALSE
NO_MONIKER_LIST_NEEDED_FOR_STD_DIALOG_MONIKERS		equ	TRUE
NO_FILES_MONIKER					equ	FALSE
FSEL_DISABLES_FILTERED_FILES				equ	FALSE
HAVE_FAKE_FILE_SYSTEM					equ	FALSE
INDENT_BOXED_CHILDREN					equ	FALSE
THREE_DIMENSIONAL_BORDERS				equ	FALSE
GRADIENT_TITLE_BAR					equ	FALSE

FSEL_HAS_CHANGE_DRIVE_POPUP				equ	TRUE
FSEL_HAS_CHANGE_DIRECTORY_POPUP				equ	TRUE
FSEL_HAS_DOCUMENT_BUTTON				equ	TRUE
MONIKER_LIST_NEEDED_FOR_STD_DIALOG_MONIKERS		equ	FALSE
DRAW_BUTTON_BORDERS					equ	TRUE
DRAW_ITEM_BORDERS					equ	TRUE
DRAW_SELECTION_CURSOR_FOR_FOCUSED_GADGETS		equ	TRUE
PLACE_EXPRESS_MENU_ON_PRIMARY				equ	TRUE
DRAW_WINDOW_MARK_IN_MONIKERS				equ	FALSE
DRAW_MNEMONIC_UNDERLINES				equ	TRUE

else
if _DUI

NO_WINDOW_FRAME_ON_VIEWS				equ	FALSE
BUBBLE_DIALOGS						equ	TRUE
MENUS_HAVE_APPLY_CANCEL_BUTTONS				equ	FALSE
DISABLED_ITEMS_ARE_SELECTABLE				equ	FALSE
FUNCTION_KEYS_MAPPED_TO_REPLY_BAR_BUTTONS		equ	FALSE
MENU_BAR_AT_BOTTOM					equ	FALSE
SINGLE_FIELD_SYSTEM					equ	FALSE
NO_REPLY_BAR_DRAWING					equ	FALSE
NO_MENU_BAR_DRAWING					equ	FALSE
DRAW_LEAF_IF_HAVE_FOCUS					equ	FALSE
PARENT_CTRLS_INVERTED_ON_CHILD_FOCUS			equ	FALSE
FOCUSED_GADGETS_DO_NOT_HAVE_A_SELECTION_CURSOR		equ	FALSE
FOCUSED_GADGETS_ARE_INVERTED				equ	FALSE
NO_MNEMONICS						equ	FALSE
ASSUME_BOLD_STYLE_FOR_MONIKERS				equ	FALSE
NO_MONIKER_LIST_NEEDED_FOR_STD_DIALOG_MONIKERS		equ	FALSE
NO_FILES_MONIKER					equ	FALSE
FSEL_DISABLES_FILTERED_FILES				equ	FALSE
HAVE_FAKE_FILE_SYSTEM					equ	FALSE
INDENT_BOXED_CHILDREN					equ	FALSE

FSEL_HAS_CHANGE_DRIVE_POPUP				equ	TRUE
FSEL_HAS_CHANGE_DIRECTORY_POPUP				equ	TRUE
FSEL_HAS_DOCUMENT_BUTTON				equ	TRUE
MONIKER_LIST_NEEDED_FOR_STD_DIALOG_MONIKERS		equ	TRUE
DRAW_BUTTON_BORDERS					equ	TRUE
DRAW_ITEM_BORDERS					equ	TRUE
DRAW_SELECTION_CURSOR_FOR_FOCUSED_GADGETS		equ	FALSE
PLACE_EXPRESS_MENU_ON_PRIMARY				equ	TRUE
DRAW_WINDOW_MARK_IN_MONIKERS				equ	FALSE
DRAW_MNEMONIC_UNDERLINES				equ	TRUE
THREE_DIMENSIONAL_BORDERS				equ	TRUE
GRADIENT_TITLE_BAR					equ	TRUE

else

NO_WINDOW_FRAME_ON_VIEWS				equ	FALSE
BUBBLE_DIALOGS						equ	FALSE
MENUS_HAVE_APPLY_CANCEL_BUTTONS				equ	FALSE
DISABLED_ITEMS_ARE_SELECTABLE				equ	FALSE
FUNCTION_KEYS_MAPPED_TO_REPLY_BAR_BUTTONS		equ	FALSE
MENU_BAR_AT_BOTTOM					equ	FALSE
SINGLE_FIELD_SYSTEM					equ	FALSE
NO_REPLY_BAR_DRAWING					equ	FALSE
NO_MENU_BAR_DRAWING					equ	FALSE
DRAW_LEAF_IF_HAVE_FOCUS					equ	FALSE
PARENT_CTRLS_INVERTED_ON_CHILD_FOCUS			equ	FALSE
FOCUSED_GADGETS_DO_NOT_HAVE_A_SELECTION_CURSOR		equ	FALSE
FOCUSED_GADGETS_ARE_INVERTED				equ	FALSE
NO_MNEMONICS						equ	FALSE
ASSUME_BOLD_STYLE_FOR_MONIKERS				equ	FALSE
NO_MONIKER_LIST_NEEDED_FOR_STD_DIALOG_MONIKERS		equ	FALSE
NO_FILES_MONIKER					equ	FALSE
FSEL_DISABLES_FILTERED_FILES				equ	FALSE
HAVE_FAKE_FILE_SYSTEM					equ	FALSE
INDENT_BOXED_CHILDREN					equ	FALSE
THREE_DIMENSIONAL_BORDERS				equ	FALSE
GRADIENT_TITLE_BAR					equ	FALSE

FSEL_HAS_CHANGE_DRIVE_POPUP				equ	TRUE
FSEL_HAS_CHANGE_DIRECTORY_POPUP				equ	TRUE
FSEL_HAS_DOCUMENT_BUTTON				equ	TRUE
MONIKER_LIST_NEEDED_FOR_STD_DIALOG_MONIKERS		equ	TRUE
DRAW_BUTTON_BORDERS					equ	TRUE
DRAW_ITEM_BORDERS					equ	TRUE
DRAW_SELECTION_CURSOR_FOR_FOCUSED_GADGETS		equ	TRUE
PLACE_EXPRESS_MENU_ON_PRIMARY				equ	TRUE
DRAW_WINDOW_MARK_IN_MONIKERS				equ	TRUE
DRAW_MNEMONIC_UNDERLINES				equ	TRUE

endif	; if _DUI
endif	; if _ODIE
endif	; if _RUDY

;
;  FLOATING_SCROLLERS makes Penelope-style scroll buttons:
;
;	* the buttons appear in the view itself, and the contents
;	  of the view show around the buttons
;	* if you don't tap directly on a scroll arrow, the tap goes
;	  to the view.
;
;  The code that went into the creation of this constant is documented
;  in the Odie design document, on the Engineering Web Server.
;
if _ODIE
FLOATING_SCROLLERS		equ	TRUE
SCROLLERS_SELECT_ON_PRESS	equ	TRUE
else
FLOATING_SCROLLERS		equ	FALSE
endif


if FLOATING_SCROLLERS and ERROR_CHECK

OL_ERROR_TRIED_TO_REMOVE_NONEXISTENT_FLOATER		enum	FatalErrors
; OLWin has been told to remove a floating scroller slave object that
; was never added.

OL_ERROR_NO_MORE_ROOM_FOR_FLOATERS			enum	FatalErrors
; Tried to add a floater to the chunkarray and the (re)alloc failed.

endif		; FLOATING_SCROLLERS
;
;  Some global constants for arrow positioning...
;
if FLOATING_SCROLLERS
UP_ARROW_TOP_OFFSET		equ	11
DOWN_ARROW_BOTTOM_OFFSET	equ	12
LEFT_ARROW_LEFT_OFFSET		equ	11
RIGHT_ARROW_RIGHT_OFFSET	equ	20

;
;  The "short margin" is how far a scroll arrow is from the nearest
;  two view borders, IF no other scroll arrow is present in its quadrant.
;  Otherwise, LONG_MARGIN is used.
;
SHORT_MARGIN			equ	2
LONG_MARGIN			equ	16

;
;  This bitfield is used to specify the presence (or absence) of Y and
;  X scrollers, and whether they're left/right or top/bottom justified,
;  respectively.  Used by GetFloaterPositionLow to decide whether to use
;  SHORT_MARGIN or LONG_MARGIN for the various windows.
;
ArrowPositions	record
	AP_TOP_LEFT_X:1
	AP_TOP_RIGHT_X:1
	AP_BOTTOM_LEFT_X:1
	AP_BOTTOM_RIGHT_X:1
	AP_TOP_LEFT_Y:1
	AP_TOP_RIGHT_Y:1
	AP_BOTTOM_LEFT_Y:1
	AP_BOTTOM_RIGHT_Y:1
ArrowPositions	end

endif	; FLOATING_SCROLLERS

;------------------------------------------------------------------------------
;		OL Properties
;------------------------------------------------------------------------------

	; These types are for various default properties of OpenLook (although
	; they can be extended to all UIs)

	; This type controls the situations in which the UI should produce an
	; audible beep.
	;	*** CURRENTLY UNUSED ***

OLBeep etype byte, 0
OLB_ALWAYS		enum OLBeep
OLB_NOTICES_ONLY	enum OLBeep
OLB_NEVER		enum OLBeep

	;  This type controls the size of the interface.
	;	*** CURRENTLY UNUSED ***

OLScale etype byte, 0
OLB_SMALL		enum OLScale
OLB_MED_SMALL		enum OLScale
OLB_MED			enum OLScale
OLB_MED_LARGE		enum OLScale
OLB_LARGE		enum OLScale

;------------------------------------------------------------------------------
; screen constants
;------------------------------------------------------------------------------

TINY_SCREEN_WIDTH_THRESHOLD	=	512
TINY_SCREEN_HEIGHT_THRESHOLD	=	320

;------------------------------------------------------------------------------
; constants for icons which appear in the window header area.
;------------------------------------------------------------------------------

OLS_WIN_ICON_SPACING	=	4	;space between icons
OLS_WIN_ICON_WIDTH	=	50	;Workspace and Application menu icons
OLS_WIN_ICON_HEIGHT	=	16

if _PM
CUAS_WIN_ICON_WIDTH	=	20	;Workspace and Application menu icons,
else
if _JEDIMOTIF
CUAS_WIN_ICON_WIDTH	=	16	;Exit button + 2 pixel spacing
					;	(nothing else uses this)
elif _WINDOW_CLOSE_BUTTON_IS_BIG_X
CUAS_WIN_ICON_WIDTH	=	18	;Workspace and Application menu icons,

else
CUAS_WIN_ICON_WIDTH	=	27	;Workspace and Application menu icons,
endif
endif

CUAS_WIN_ICON_HEIGHT	=	16	;and Maximize, Minimize, etc. icons

OLS_GCM_HEADER_HEIGHT	=	30
CUAS_GCM_HEADER_HEIGHT	=	30

OLS_GCM_HEADER_ICON_WIDTH =	48
OLS_GCM_HEADER_ICON_HEIGHT =	30

CUAS_GCM_HEADER_ICON_WIDTH =	48
CUAS_GCM_HEADER_ICON_HEIGHT =	29

CUAS_GCM_CGA_HEADER_HEIGHT 	= 	14
CUAS_GCM_CGA_HEADER_ICON_HEIGHT = 	13
			   
;------------------------------------------------------------------------------
; window constants required in both CWin and COpen modules
;------------------------------------------------------------------------------

if _JEDIMOTIF
;
; Opening position for JEDI App menu
;
APP_MENU_X = 240
APP_MENU_Y = 240
APP_MENU_Y_ADJUST = 17		;hand tuned
endif

;------------------------------------------------------------------------------
; Scrollbar and port window constants
;------------------------------------------------------------------------------

if _CUA or _MAC ;--------------------------------------------------
MO_SCROLLBAR_WIDTH		=	15	;width of scrollbar
MO_THUMB_HEIGHT			=	18
MO_ARROW_HEIGHT			=	16
MO_SCR_AREA_MARGIN		=	MO_ARROW_HEIGHT-1 ;arrow & thumb overlap
MO_UNUSED_HEIGHT		=	MO_SCR_AREA_MARGIN*2
MO_MIN_HEIGHT			=	MO_SCR_AREA_MARGIN + MO_ARROW_HEIGHT

; This is used to aid drawing.  The page down code will draw over where the
; old thumb would normally be, thanks to this obscure hack (it draws from the
; elevator offset, which will be right below the up arrow.)
;
NO_THUMB_ELEV_OFFSET		=	-(MO_THUMB_HEIGHT-1)

MO_MIN_NORMALIZING_HEIGHT	=	MO_MIN_HEIGHT
endif		;--------------------------------------------------------------
	
if _OPEN_LOOK
    MO_ARROW_WIDTH		=	10
    MO_SCROLLBAR_WIDTH		=	MO_ARROW_WIDTH+1
    MO_THUMB_HEIGHT		=	12
    CGA_HORIZ_ARROW_WIDTH		=	8
    CGA_HORIZ_SCROLLBAR_WIDTH	=	CGA_HORIZ_ARROW_WIDTH+2
endif
	
if (_MOTIF or _PM)	;------------------------------------------------------
if not _JEDIMOTIF

if	 _RUDY
    MO_ARROW_WIDTH		=	10
    MO_SCROLLBAR_WIDTH		=	MO_ARROW_WIDTH+1
    MO_ARROW_HEIGHT		=	MO_ARROW_WIDTH+1    ;not used!
    MO_THUMB_HEIGHT		=	12
    MO_UNUSED_HEIGHT		=	MO_SCR_AREA_MARGIN*2
	
else	;_RUDY is FALSE
	
    MO_ARROW_WIDTH		=	12	;can switch to 10? with no other
						;changes in the code!
    CGA_HORIZ_ARROW_WIDTH		=	8
    MO_ARROW_HEIGHT			=	MO_ARROW_WIDTH+1
    MO_SCROLLBAR_WIDTH		=	MO_ARROW_WIDTH+2
    CGA_HORIZ_SCROLLBAR_WIDTH	=	CGA_HORIZ_ARROW_WIDTH+2
    MO_SCR_AREA_MARGIN		=	MO_ARROW_HEIGHT+2   
    MO_THUMB_HEIGHT		=	MO_ARROW_WIDTH ;minimum thumb height
    MO_UNUSED_HEIGHT		=	MO_SCR_AREA_MARGIN*2

endif	;_RUDY
	
	
MO_MIN_HEIGHT			=	MO_SCR_AREA_MARGIN*2
NO_THUMB_ELEV_OFFSET		=	-(MO_ARROW_HEIGHT-1) ;see CUA comment
MO_MIN_NORMALIZING_HEIGHT	=	MO_MIN_HEIGHT
endif
endif		; if _MOTIF or _PM  -------------------------------------------
		
if _JEDIMOTIF	;--------------------------------------------------------------

JEDI_ARROW_WIDTH		=	14
JEDI_ARROW_HEIGHT		=	16
JEDI_ARROW_SPACING		=	1

JEDI_VALUE_ARROW_WIDTH		=	14
JEDI_VALUE_ARROW_HEIGHT		=	14

OL_SLIDER_DEFAULT_WIDTH		=	50
OL_SLIDER_DEFAULT_HEIGHT	=	50
OL_SLIDER_THUMB_WIDTH		=	10
OL_SLIDER_THUMB_HEIGHT		=	10

JEDI_TITLE_GROUP_DEFAULT_SPACING =	2
JEDI_APP_MENU_WIDTH		=	14
JEDI_MENU_BAR_HEIGHT		=	19

JEDI_MENU_BAR_BUTTON_WIDTH	=	41
JEDI_MENU_BAR_BUTTON_HEIGHT	=	17	; was 16 - 17 matches spacing
						;	above and below font
						;	shown in ERS

MO_ARROW_WIDTH			=	12	;can switch to 12 with no other
						;changes in the code!
CGA_HORIZ_ARROW_WIDTH		=	8
MO_ARROW_HEIGHT			=	MO_ARROW_WIDTH+2
MO_SCROLLBAR_WIDTH		=	MO_ARROW_WIDTH+2
CGA_HORIZ_SCROLLBAR_WIDTH	=	CGA_HORIZ_ARROW_WIDTH+2
MO_SCR_AREA_MARGIN		=	MO_ARROW_HEIGHT+2
MO_UNUSED_HEIGHT		=	MO_SCR_AREA_MARGIN*2
MO_THUMB_HEIGHT			=	MO_ARROW_WIDTH	;minimum thumb height
MO_MIN_HEIGHT			=	MO_SCR_AREA_MARGIN*2
NO_THUMB_ELEV_OFFSET		=	-(MO_ARROW_HEIGHT-1) ;see CUA comment
MO_MIN_NORMALIZING_HEIGHT	=	MO_MIN_HEIGHT
endif		; _JEDIMOTIF --------------------------------------------------


MO<	MO_CGA_THUMB_HEIGHT		=	CGA_HORIZ_ARROW_WIDTH	>
PMAN<	PM_SPIN_ARROW_HEIGHT		=	10			>

;------------------------------------------------------------------------------
; Ptr Image constants
;------------------------------------------------------------------------------

	; This type declares constants for all possible pointer images.
	; The routine OpenSetPtrImage is a value of this type.

if _CUA_STYLE and (not _MOTIF) and (not _PM)	;-------------------------------
;NOTE: if you change the order of declarations in this Enum, or add any new
;types, update "pointerTable" in copenUtils.asm.

OLPtrImage etype byte, 0
OLPI_NONE		enum OLPtrImage
OLPI_BASIC		enum OLPtrImage	; Basic arrow
OLPI_BUSY		enum OLPtrImage	; Stopwatch
OLPI_MODAL		enum OLPtrImage	; "X"
OLPI_RESIZE_HORIZ	enum OLPtrImage	; Arrows left and right
OLPI_RESIZE_VERT	enum OLPtrImage	; Arrows up and down
OLPI_RESIZE_UP_DIAG	enum OLPtrImage	; Arrows top-right and
					; bottom-left
OLPI_RESIZE_DOWN_DIAG	enum OLPtrImage ; Arrows top-left and
					; bottom-right

OLPI_MOVE	= OLPI_NONE		; No special cursor for move
OLPI_SCROLL	= OLPI_NONE		; No special cursor for scroll
OLPI_COPY	= OLPI_NONE		; No special cursor for copy
endif		;--------------------------------------------------------------

if _OPEN_LOOK
OLPtrImage etype byte, 0
OLPI_NONE		enum OLPtrImage
OLPI_BUSY		enum OLPtrImage	; Stopwatch
OLPI_MODAL		enum OLPtrImage	; "?"
endif

if _MOTIF or _PM	;------------------------------------------------------
;NOTE: if you change the order of declarations in this Enum, or add any new
;types, update "pointerTable" in copenUtils.asm.

OLPtrImage etype byte, 0
OLPI_NONE		enum OLPtrImage
OLPI_BASIC		enum OLPtrImage	; Basic arrow
OLPI_X			enum OLPtrImage	; "X"
OLPI_CROSSHAIRS		enum OLPtrImage	; Crosshairs for sighting
OLPI_BUSY		enum OLPtrImage	; Stopwatch
OLPI_MODAL		enum OLPtrImage	; "?"
OLPI_MOVE		enum OLPtrImage	; Move arrows
OLPI_RESIZE_LEFT	enum OLPtrImage	; Arrow left
OLPI_RESIZE_RIGHT	enum OLPtrImage	; Arrow right
OLPI_RESIZE_UP		enum OLPtrImage	; Arrow up
OLPI_RESIZE_DOWN	enum OLPtrImage	; Arrow down
OLPI_RESIZE_UPL_DIAG	enum OLPtrImage	; Arrow top-left
OLPI_RESIZE_UPR_DIAG	enum OLPtrImage	; Arrow top-right
OLPI_RESIZE_DOWNL_DIAG	enum OLPtrImage ; Arrow bottom-left
OLPI_RESIZE_DOWNR_DIAG	enum OLPtrImage ; Arrow bottom-right

OLPI_SCROLL	= OLPI_NONE		; No special cursor for scroll
OLPI_COPY	= OLPI_NONE		; No special cursor for copy
endif		;---------------------------------------------------------------


if _MAC and FALSE;--------------------------------------------------------------
;NOTE: if you change the order of declarations in this Enum, or add any new
;types, update "pointerTable" in copenUtils.asm.

OLPtrImage etype byte, 0
OLPI_NONE		enum OLPtrImage
OLPI_BASIC		enum OLPtrImage ; Basic arrow
OLPI_BUSY		enum OLPtrImage	; Watch

OLPI_MOVE	= OLPI_NONE		; No special cursor for move
OLPI_SCROLL	= OLPI_NONE		; No special cursor for scroll
OLPI_COPY	= OLPI_NONE		; No special cursor for copy
endif		;---------------------------------------------------------------

;
; Number of animated busy cursor frames.  Define the frames in
; cutilsVariable.def.
;
if ANIMATED_BUSY_CURSOR
NUM_BUSY_CURSOR_FRAMES	equ	8
endif


; Used for .INI file control of system window menu
;
ExtWinAttrs	record
    EWA_MOVABLE:1			; corresponds to OWA_MOVABLE
    EWA_RESIZABLE:1			; corresponds to OWA_RESIZABLE
    :14
ExtWinAttrs	end


;------------------------------------------------------------------------------
; Specific UI Moniker Flags
;------------------------------------------------------------------------------
;These flags are passed to OpenDrawMoniker to control how monikers
;are drawn and to control what extras (like window marks) get drawn.

OLMonikerAttrs record
    ;these are checked first, to determine what to draw

;this would be a nice enhancement in the future. At present, we must always
;draw the text, otherwise we do not have size info to draw the cursor with.
;   OLMA_DISP_MONIKER:1		;TRUE to draw text/graphic moniker, plus
    				;all other accessories except the select. cursor

    OLMA_DRAW_CURSOR_INSIDE_BOUNDS:1
				;TRUE to draw the cursor around the inside edge
				;of the toolbox.  USE_TOOLBOX_SELECTION_CURSOR
				;does similar things, but inverts, rather than
				;draws.

    OLMA_DISP_SELECTION_CURSOR:1 ;TRUE to draw/erase the dotted-outline box
				;around the actual moniker text and shortcut.

    OLMA_USE_TOOLBOX_SELECTION_CURSOR:1
				;when OLMA_DISP_SELECTION_CURSOR is TRUE, this
				;means the selection cursor should be drawn
				;by XORing a dotted box inside the object's
				;bounds.
    OLMA_IS_MENU_ITEM:1
    				;Set if parent we're a menu item - stuff is
				;drawn differently in that case.

    ; We would like to put this in the keyboard moniker section, but there is
    ; no room, given the bit placement requirements below
    OLMA_DRAW_SHORTCUT_BELOW:1
				;Set if keyboard accelerator should be draw
				;below moniker instead of to the right

    OLMA_DRAW_SHORTCUT_TO_RIGHT:1
				;Set to draw keyboard accelerator to the right.
				;(Not needed for menus b/c of OLMA_IS_MENU_ITEM,
				; but needed for system-menu icons and menu bar
				; buttons.)

    OLMA_BLACK_MONOCHROME_BACKGROUND:1
				;TRUE if drawing to monochrome screen,
				;and are drawing cursor over C_BLACK area,
				;such as a selected list item.

    OLMA_DARK_COLOR_BACKGROUND:1 ;TRUE in Motif to indicate that the cursor
				 ;is being drawn on a dark background, so
				 ;should be drawn in C_WHITE/C_DARK_GREY for ON/OFF.

    ;these must be the top three bits in the lower byte of the word.

    OLMA_DISP_DOWN_ARROW:1	;TRUE to draw a down-arrow, indicating that
				;this menu button opens a top-level menu.
    OLMA_DISP_RT_ARROW:1	;TRUE to draw a right-arrow, indicating that
				;this menu button opens a sub-menu
    OLMA_DISP_WIN_MARK:1	;TRUE to draw "..." after the text moniker,
				;indicating that this button opens a window.

    ;these flags affect how the selection cursor is drawn.

    OLMA_SELECTION_CURSOR_ON:1	;TRUE if the selection cursor is on this object.
				;FALSE if not (use to erase cursor)

    OLMA_LIGHT_COLOR_BACKGROUND:1 ;TRUE in Motif to indicate that the cursor
				 ;is being drawn on a light background, so
				 ;should be drawn in C_WHITE/C_LIGHT_GREY for ON/OFF.

    OLMA_USE_LIST_SELECTION_CURSOR:1
				;when OLMA_DISP_SELECTION_CURSOR is TRUE, this
				;means the selection cursor should be drawn
				;as a box around the entire object (used for
				;entries in scrolling lists)

    OLMA_USE_CHECKBOX_SELECTION_CURSOR:1
				;when OLMA_DISP_SELECTION_CURSOR is TRUE, this
				;means the selection cursor should be drawn
				;as a box 2 pixels inside the object (used for
				;entries in checkboxes)

    ;these flags affect how the keyboard moniker is drawn.

    OLMA_DISP_KBD_MONIKER:1	;TRUE to draw the keyboard shortcut next to
				;the moniker.
OLMonikerAttrs	end

.assert (mask OLMA_DISP_DOWN_ARROW eq mask OLBSS_MENU_DOWN_MARK), \
	"OLButtonSpecState does not match OpenMonikerFlags! Kill chris."
.assert (mask OLMA_DISP_RT_ARROW eq mask OLBSS_MENU_RIGHT_MARK), \
	"OLButtonSpecState does not match OpenMonikerFlags! Kill chris."
.assert (mask OLMA_DISP_WIN_MARK eq mask OLBSS_WINDOW_MARK), \
	"OLButtonSpecState does not match OpenMonikerFlags! Kill chris."

;------------------------------------------------------------------------------
;	OpenMonikerArgs structure
;------------------------------------------------------------------------------
;IMPORTANT: this structure is placed on the stack, and BP points to the
;SP value BEFORE the structure was placed onto the stack.

OpenMonikerArgs 	struct
    ;DO NOT MODIFY the following fields. They must be in this order, and
    ;must be at the start of this structure. See DrawMonikerArgs in VisClass.

    OMA_leftInset	word		;left inset 
    OMA_topInset	word		;top inset
    OMA_xMaximum	word		;maximum length to draw(used internally)
    OMA_yMaximum	word
    OMA_gState		hptr GState	;handle of graphics state
    OMA_textHeight	word    	;height of the font we'd use for text
    					;  monikers, or zero if we don't know.
					;  Speeds up various calculations.
					
    ;feel free to add additional fields here. 

EC< OMA_EC_id1		word		;id word #1			>

    OMA_monikerAttrs	OLMonikerAttrs <> ;window mark, cursored, etc.
    OMA_drawMonikerFlags word		;DrawMonikerFlags
    OMA_bottomInset	word		;bottom inset
    OMA_rightInset	word		;right inset

EC< OMA_EC_id2		word		;id word #2			>
OpenMonikerArgs		ends



if ERROR_CHECK
EC_OPEN_MONIKER_ARGS_ID1	equ	0x12ed
EC_OPEN_MONIKER_ARGS_ID2	equ	0xbd56
endif

.assert (OMA_gState eq DMA_gState)
.assert (OMA_xMaximum eq DMA_xMaximum)
.assert (OMA_yMaximum eq DMA_yMaximum)
.assert	(OMA_leftInset eq DMA_xInset)
.assert (OMA_topInset eq DMA_yInset)
.assert (OMA_textHeight eq DMA_textHeight)

;
; Flags passed to MSG_SPEC_GET_MENU_CENTER:
;
SpecGetMenuCenterFlags	record
	SGMCF_NEED_TO_RESET_GEO:1,	;Set if something requires a reset (had
					;  valid geometry)
	SGMCF_ALLOWING_WRAPPING:1,	;True if someone under us is allowing
					;  children to wrap.
	:14
SpecGetMenuCenterFlags	end

;------------------------------------------------------------------------------
; Toolbar expand threshold
;------------------------------------------------------------------------------
; This is a hacked limit on how much a toolbar button, itme, or spin gadget
; will expand vertically, before giving up on expanding at all.   The idea
; is to keep toolbar items from doubling in size when mixed in with 
; other objects that are wrapping.   (In general, toolbox gadgets are
; only set up to expand a couple of pixels so all the gadgets line up nicely.)

TOOLBAR_EXPAND_HEIGHT_THRESHOLD		equ	12

;------------------------------------------------------------------------------
; Tabbed window constants
;------------------------------------------------------------------------------

NUMBER_OF_TABS				equ	3
TAB_SHADOW_SIZE				equ	2
TAB_EXTRA_SIZE				equ	4
FIRST_TAB_OFFSET			equ	10

;------------------------------------------------------------------------------
; UI Template constants
;------------------------------------------------------------------------------
OLTemplateParamType etype word, 1

OLTPT_WINDOW		enum OLTemplateParamType
; Used for cases where the output OD should be the window that this popup
; menu/system menu, etc. came from originally.   This may be stored in the
; .uih file in place of the optr which can't be known at assembly time.
;

OLTPT_DISPLAY_CTRL	enum OLTemplateParamType
OLTPT_PRINT_CTRL	enum OLTemplateParamType
OLTPT_FIELD		enum OLTemplateParamType

;-----------------------------------------------------------------------------
; Title-bar stuff
;-----------------------------------------------------------------------------
;
;  Who knows -- maybe at some point in the far future someone will
;  implement more than two title-bar groups.   NOTE:  the order is
;  important (it must be the same as the order of the title bar
;  groups in OLWinInstance).
;
TitleGroupType	etype	word, 0, 4
	TGT_LEFT_GROUP		enum	TitleGroupType
	TGT_RIGHT_GROUP		enum	TitleGroupType

if _OL_STYLE	;START of OPEN LOOK specific code -----------------------------
BUTTON_MIN_WIDTH	=	12		;minimum size before blowing up
BUTTON_MIN_HEIGHT	=	11		;minimum size before blowing up

;For OLMenuItemGroup:

OL_MENU_ITEM_SEP_TOP_INSET_NOT_PINNED = 3	;distance from top bound and
						;separator line
OL_MENU_ITEM_SEP_TOP_INSET_PINNED = 1

OL_MENU_ITEM_SEP_BOTTOM_INSET_NOT_PINNED= 3	;distance from bottom bound and
						;separator line
OL_MENU_ITEM_SEP_BOTTOM_INSET_PINNED= 1
endif		;END of OPEN LOOK specific code -------------------------------


;------------------------------------------------------------------------------
; Motif/PM-specific constants
;------------------------------------------------------------------------------ 

if _MOTIF or _PM	;------------------------------------------------------
MO_ETCH_COLOR	= C_DARK_GREY			; Etch color
MO_RESIZE_COLOR	= C_DARK_GREY			; Resize bar = speckled dk grey
MO_BACKGROUND_COLOR	= C_LIGHT_GREY
REDO_GEOMETRY_FOR_EXPRESS_MENU = FALSE
endif		;--------------------------------------------------------------


CAN_SPLIT	=	FALSE			; No splitting available

; margins at top and bottom of non-primary windows
	
NOT_MO <OL_WIN_NON_PANE_X_MARGIN	=	6			>
NOT_MO <OL_WIN_NON_MENU_Y_MARGIN	=	5	 		>
       
MO <OL_WIN_NON_PANE_X_MARGIN		=	4	 		>
MO <OL_WIN_NON_MENU_Y_MARGIN		=	4	 		>

PMAN <OL_WIN_NON_PANE_X_MARGIN		=	4	 		>
PMAN <OL_WIN_NON_MENU_Y_MARGIN		=	4	 		>

MAC <OL_WIN_NON_PANE_X_MARGIN	=	6				>
MAC <OL_WIN_NON_MENU_Y_MARGIN	=	5	 			>

OLS <OL_WIN_NON_PANE_X_MARGIN	=	6				>
OLS <OL_WIN_NON_MENU_Y_MARGIN	=	5	 			>

if _RUDY or _ODIE
GADGET_AREA_MARGINS		=	0
elif _PM or _JEDIMOTIF
GADGET_AREA_MARGINS		=	1	;the real margins, for most
else						; windows, happens in the
GADGET_AREA_MARGINS		=	3	; gadget area.  I don't know
endif						; if the above margins are even
						; used anymore.  (Reduced from
						; 5, cbh 2/19/93)
if _ODIE
GADGET_AREA_TOP_MARGIN		=	3
endif

MINIMAL_Y_SPACING		=	1
MINIMAL_X_SPACING		=	2	;was 4, 2/22/93 cbh

if _OL_STYLE 	;--------------------------------------------------------------
;Space between children objects which are in window (below header)
OLS_BASE_WIN_CHILD_SPACING =	3	;for base windows
OLS_WIN_CHILD_SPACING	=	5	;for non-base windows
REDO_GEOMETRY_FOR_EXPRESS_MENU = FALSE
endif		;--------------------------------------------------------------

if _OL_STYLE 	;--------------------------------------------------------------
BW_TEST			=	0

CABLE_WIDTH		=	3	;width of cable

ANCHOR_HEIGHT		=	5	;height of anchors
CGA_ANCHOR_HEIGHT	=	4	;height of anchors on CGA vertical

ARROW_XOFF		=	5	;x offset to arrow in buttons
CGA_ARROW_XOFF		=	4	;x offset in horizontal Scrolls

ARROW_YOFF		=	5	;y offset to arrow in buttons
CGA_ARROW_YOFF		=	3	;y offset in vertical CGA scrollbars

ARROW_WIDTH		=	6	;width of the arrow at largest point

SCROLLBAR_WIDTH		=	13	;width of scrollbar
CGA_SCROLLBAR_WIDTH	=	11	;width of horizontal CGA scrollbar

CABLE_XOFF		=	(SCROLLBAR_WIDTH-CABLE_WIDTH)/2
CGA_CABLE_XOFF		=	(CGA_SCROLLBAR_WIDTH-CABLE_WIDTH)/2

SCR_BUTTON_HEIGHT	=	13	;height of scroll buttons
CGA_SCR_BUTTON_HEIGHT	=	9

ELEV_HEIGHT		=	SCR_BUTTON_HEIGHT * 3 + 2
CGA_ELEV_HEIGHT		=	CGA_SCR_BUTTON_HEIGHT * 3 + 2

UNUSED_HEIGHT		=	(ANCHOR_HEIGHT+1)*2
CGA_UNUSED_HEIGHT 	=	(CGA_ANCHOR_HEIGHT+1)*2

;Height of full scrollbar with no cables
MIN_FULL_HEIGHT		=	ELEV_HEIGHT + UNUSED_HEIGHT
CGA_MIN_FULL_HEIGHT	=	CGA_ELEV_HEIGHT + CGA_UNUSED_HEIGHT

DRAG_AREA_HEIGHT	=	SCR_BUTTON_HEIGHT	;height of drag area
CGA_DRAG_AREA_HEIGHT	=	CGA_SCR_BUTTON_HEIGHT	;height of drag area

;height of abbreviated scrollbar
ABBR_HEIGHT		=	MIN_FULL_HEIGHT - DRAG_AREA_HEIGHT
CGA_ABBR_HEIGHT		=	CGA_MIN_FULL_HEIGHT - CGA_DRAG_AREA_HEIGHT

;height of minimum scrollbar
MIN_HEIGHT		=	ABBR_HEIGHT - UNUSED_HEIGHT
CGA_MIN_HEIGHT		=	CGA_ABBR_HEIGHT - UNUSED_HEIGHT

MIN_NORMALIZING_HEIGHT	=	MIN_FULL_HEIGHT

MASK_50			=	SDM_50
MASK_100		=	SDM_100

endif	 	;--------------------------------------------------------------

if _ODIE				
MENU_SPACING			=	1	;1 pixel spacing between items
else
MENU_SPACING			=	0	;no space between menu items
endif

if THREE_DIMENSIONAL_BORDERS
THREE_D_BORDER_THICKNESS	=	3	; 3-d borders take
						; extra space
endif

; button constants, also used by settings

if _OPEN_LOOK
BUTTON_INSET_X		=	2
else
BUTTON_INSET_X		=	6
endif
BUTTON_INSET_Y		=	2

if _RUDY
MO_BUTTON_INSET_X	=	0	; distance from left or right edge of 
else
MO_BUTTON_INSET_X	=	6	; distance from left or right edge of 
endif

if _JEDIMOTIF
MO_BUTTON_INSET_X_NARROW=	6
else
MO_BUTTON_INSET_X_NARROW=	4	
endif

if _ROUND_NORMAL_BW_BUTTONS
ST_NORMAL_BUTTON_INSET_X_NARROW		=	5	
endif

if _THICK_DROP_MENU_BW_BUTTONS
ST_THICK_DROP_MENU_BUTTON_INSET_X_NARROW	=	5
endif

;For menu buttons (in the menu bar)

if _JEDIMOTIF
MO_MENU_BUTTON_INSET_X	= 1		;distance from left edge of button
elif _RUDY
MO_MENU_BUTTON_INSET_X	= 0		;distance from left edge of button
else
MO_MENU_BUTTON_INSET_X	= 7		;distance from left edge of button
endif
				;menu button region to text
if _JEDIMOTIF
MO_MENU_BUTTON_INSET_X_NARROW = 1
else
MO_MENU_BUTTON_INSET_X_NARROW = 4
endif

MO_MENU_BUTTON_INSET_Y	= 2		;distance from top edge of
					;menu button region to text
;Menu mark size & spacing

MAC <OL_MARK_WIDTH	=	8					>
OL <OL_MARK_WIDTH	=	8					>

;
;  Menu-right (or left-) arrow sizes & spacing.
;

if not _JEDIMOTIF
if _CUA_STYLE
if _TRIANGLE_MENU_DOWN_MARK
OL_MARK_WIDTH		=	14
else
OL_MARK_WIDTH		=	12
endif		; _TRIANGLE_MENU_DOWN_MARK
endif		; _CUA_STYLE
endif		; not _JEDIMOTIF

if _JEDIMOTIF
OL_MARK_WIDTH		=	8
endif

if _PM
OL_MARK_HEIGHT		=	7
OL_MARK_SPACING		=	6
else
OL_MARK_HEIGHT		=	8
OL_MARK_SPACING		=	4
endif

if _PM
OL_DOWN_MARK_WIDTH		=	8
else
if _TRIANGLE_MENU_DOWN_MARK
OL_DOWN_MARK_WIDTH		=	10
else
OL_DOWN_MARK_WIDTH		=	8	;was 12, 2/19/93 cbh
endif
endif

OL_EXTRA_DOWN_MARK_SPACING	=	OL_MARK_WIDTH - OL_DOWN_MARK_WIDTH


;Space between children objects which are in window (below header)

NOT_MO < CUA_BASE_WIN_CHILD_SPACING =	0ffh	;(children share borders)     >
NOT_MO < CUA_WIN_CHILD_SPACING	 =	5	;for non-base windows	      >
NOT_MO < CUA_WIN_CHILD_WRAP_SPACING =	5				      >

if _MOTIF or _PM    
MO_BASE_WIN_CHILD_SPACING   =	0	;(children next to each other)
MO_WIN_CHILD_SPACING	 =	5	;for non-base windows
MO_WIN_CHILD_WRAP_SPACING   =	5
endif

TOOLBOX_SPACING			=	3	;spacing for OLBF_TOOLBOX
TOOLBOX_WRAP_SPACING		=	1	; OLCtrl's and OLWin's
   
;----------------------

; it's easier to hack it than to fix it...

TOGGLE_CAPSLOCK		equ	mask TS_CAPSLOCK
TOGGLE_NUMLOCK		equ	mask TS_NUMLOCK
TOGGLE_SCROLLLOCK	equ	mask TS_SCROLLLOCK

LALT		= mask SS_LALT
RALT		= mask SS_RALT
LCTRL		= mask SS_LCTRL
RCTRL		= mask SS_RCTRL
LSHIFT		= mask SS_LSHIFT
RSHIFT		= mask SS_RSHIFT

ALT_KEYS	= LALT or RALT
CTRL_KEYS	= LCTRL or RCTRL
SHIFT_KEYS	= LSHIFT or RSHIFT

KSS_PHYSICAL	= mask KS_PHYSICAL
KSS_ALT		= mask KS_ALT
KSS_CTRL	= mask KS_CTRL
KSS_SHIFT	= mask KS_SHIFT
KSS_CHAR_SET	= mask KS_CHAR_SET
KSS_CHAR	= mask KS_CHAR

KSS_BSW		= ((CS_BSW shl 8) and KSS_CHAR_SET)
KSS_CONTROL	= ((CS_CONTROL shl 8) and KSS_CHAR_SET)
KSS_UI_FUNCS	= ((CS_UI_FUNCS shl 8) and KSS_CHAR_SET)
		
if _NIKE
KeyboardStatusFlags	record
	:4
	KSF_INS_OVER:1
	KSF_CAPSLOCK:1
	KSF_NUMLOCK:1
	KSF_SCROLLLOCK:1
KeyboardStatusFlags	end
endif


if _RUDY
; The height of the buttons on the right side of dialog boxes/primaries...
RUDY_RIGHT_BUTTON_HEIGHT	=	48

; Menu/reply bar top margin for command buttons
RUDY_SLOT_TOP_MARGIN		=	4

; Top margin for command buttons in a bubble window
;
; = RUDY_SLOT_TOP_MARGIN - (1 pixel in bubble offset)
;			- (2 pixels in bubble margin)
RUDY_SLOT_BUBBLE_TOP_MARGIN	=	1

; A special constant to signal that indicator window is closed
; already. It CANNOT be zero: zero means the window handle has not been
; searched for yet.
RUDY_INDICATOR_WINDOW_ALREADY_CLOSED	=	-1

endif


;If PAGE_KEYS_DO_INCREMENTAL_SCROLL is set to true, then hitting
; the "Page Up" or "Page Down" keys does not scroll the view a page - it
; scrolls the view one "scrolling increment" (the same as hitting the up/down
; arrow).

if _RUDY
PAGE_KEYS_DO_INCREMENTAL_SCROLL	= TRUE
else
PAGE_KEYS_DO_INCREMENTAL_SCROLL	= FALSE
endif

; Set this to have the file selector sort the files

	SORT_FILE_SELECTOR_ENTRIES	=	TRUE

if _RUDY or _DUI
	SORT_FILE_SELECTOR_ENTRIES_BY_CREATION_DATE	=	TRUE
else
	SORT_FILE_SELECTOR_ENTRIES_BY_CREATION_DATE	=	FALSE
endif
	SORT_FILE_SELECTOR_ENTRIES_BY_MODIFICATION_DATE	=	FALSE

if	SORT_FILE_SELECTOR_ENTRIES_BY_MODIFICATION_DATE or SORT_FILE_SELECTOR_ENTRIES_BY_CREATION_DATE
	SORT_FILE_SELECTOR_ENTRIES_BY_DATE	equ	TRUE
endif

if _FILE_TABLE
	;
	; There are only 2 columns in the Table object: date and file name.
	; Added size column.
	;
;	FILE_TABLE_FIRST_COL	=	0
	FILE_TABLE_DATE_COL	=	0
	FILE_TABLE_NAME_COL	=	1
	FILE_TABLE_SIZE_COL	=	2
;	FILE_TABLE_LAST_COL	=	2
endif

; Selected/Unselected text foreground and background colors.
; see also DISABLED_COLOR below.
if _RUDY
include Internal/rspcolor.def

	SELECTED_TEXT_FOREGROUND	equ	RC_BLACK
	SELECTED_TEXT_BACKGROUND	equ	RC_LIGHT_GRAY
	UNSELECTED_TEXT_BACKGROUND	equ	RC_WHITE
endif

; Thickness of box shadows and frames
if _RUDY
	RUDY_SHADOW_THICKNESS	equ	4	; thickness of shadows
	RUDY_FRAME_THICKNESS	equ	2	; draw_in_box frame
	RUDY_FRAME_DEAD_SPACE	equ	1	; blank space outside of both
	RUDY_TOTAL_FRAME_THICKNESS equ	RUDY_FRAME_THICKNESS + \
					RUDY_FRAME_DEAD_SPACE
	RUDY_THIN_FRAME_DIFFERENCE equ	1	; diff btw thin & thick frame

	;
	; Constants needed mostly for OLCtrlClass, but OLPane need them
	; too.  They control how much to indent children underneath
	; their parent moniker when made the child of a popup.
	;
;	RUDY_POPUP_CTRL_LEFT_MARGIN	equ	12
;no longer indent bubble contents -- brianc 1/29/96
	RUDY_POPUP_CTRL_LEFT_MARGIN	equ	0

endif

; Choice of either jagged bubble dialog arrows or
; haloed bubble dialog arrows.
if _RUDY
	JAGGED_BUBBLE_DIALOG_ARROWS	=	FALSE
endif

; Draw disabled  items in specified color, rather than in 50% mask
if _RUDY
	USE_COLOR_FOR_DISABLED_GADGETS	=	TRUE
else
	USE_COLOR_FOR_DISABLED_GADGETS	= 	FALSE
endif

if USE_COLOR_FOR_DISABLED_GADGETS
if _RUDY
	DISABLED_COLOR		=	RC_LIGHT_GRAY
	DISABLED_CURSORED_COLOR	=	RC_DARK_GRAY
else
	DISABLED_COLOR		=	C_LIGHT_GREY
	DISABLED_CURSORED_COLOR	=	C_LIGHT_GREY
endif
endif


; This  type is originally declared in the cmainConstant.def. However, some
; of its enums have to be used in other directory, e.g. CUtils. So
; StandardDialogBoxType has to be declared in this top level. 12/2/94 ChrisL.
; Tony approved.
;----------------------------------------------------------------------------


	;*** To add a new type:
	;	1) Add an enumerated constant here
	;	2) Add a string for the error message in
	;	   cmainUIDocumentControl.ui (SDS_???)
	;	3) Add a response trigger list (if GIT_MULTIPLE_RESPONSE) in
	;	   cmainDocDialog.asm (SDTG_???)
	;	3) Add response trigger monikers (if GIT_MULTIPLE_RESPONSE) in
	;	   cmainUIDocumentControl.ui (SDTG_???)
	;	4) Add an entry to the StdDialogTable table in
	;	   cmainDocDialog.asm

StandardDialogBoxType	etype	byte
SDBT_FILE_NEW_CANNOT_CREATE_TEMP_NAME	enum	StandardDialogBoxType
	; Trying to create a new file, cannot generate a temporary file name
	; CDT_ERROR, GIT_NOTIFICATION, arg1 = file name
SDBT_FILE_NEW_INSUFFICIENT_DISK_SPACE	enum	StandardDialogBoxType
	; Trying to create a new VM file, not enough disk space
	; CDT_ERROR, GIT_NOTIFICATION, arg1 = file name
SDBT_FILE_NEW_TOO_MANY_OPEN_FILES	enum	StandardDialogBoxType
	; Trying to create a new VM file, too many open files
	; CDT_ERROR, GIT_NOTIFICATION, arg1 = file name
SDBT_FILE_NEW_ERROR			enum	StandardDialogBoxType
	; Trying to create a new file, file error
	; CDT_ERROR, GIT_NOTIFICATION, arg1 = file name
SDBT_FILE_NEW_WRITE_PROTECTED		enum	StandardDialogBoxType
	; Trying to create a new file, write protected
	; CDT_QUESTION, GIT_AFFIRMATION, arg1 = file name


SDBT_FILE_OPEN_SHARING_DENIED		enum	StandardDialogBoxType
	; Trying to open a file, sharing error
	; CDT_ERROR, GIT_NOTIFICATION, arg1 = file name
SDBT_FILE_OPEN_FILE_NOT_FOUND		enum	StandardDialogBoxType
	; Trying to open a file, file not found
	; CDT_ERROR, GIT_NOTIFICATION, arg1 = file name
SDBT_FILE_OPEN_INVALID_VM_FILE		enum	StandardDialogBoxType
	; Trying to open a VM file, VM file is invalid
	; CDT_ERROR, GIT_NOTIFICATION, arg1 = file name
SDBT_FILE_OPEN_INSUFFICIENT_DISK_SPACE	enum	StandardDialogBoxType
	; Trying to open a VM file, disk is full
	; CDT_ERROR, GIT_NOTIFICATION, arg1 = file name
SDBT_FILE_OPEN_ERROR			enum	StandardDialogBoxType
	; Trying to open a file, file error
	; CDT_ERROR, GIT_NOTIFICATION, arg1 = file name
SDBT_FILE_OPEN_READ_ONLY_PUBLIC_IN_TRANSPARENT_MODE enum StandardDialogBoxType
	; Trying to open a read-only or public file in transparent mode
	; CDT_QUESTION, GIT_AFFIRMATION, arg1 = file name
SDBT_FILE_OPEN_VM_DIRTY			enum	StandardDialogBoxType
	; Opening a vm file, it has modifications
	; CDT_NOTIFICATION, GIT_NOTIFICATION, arg1 = file name
SDBT_FILE_OPEN_APP_MORE_RECENT_THAN_DOC		enum	StandardDialogBoxType
	; Opening a vm file, application more recent protocol than doc
	; CDT_ERROR, GIT_NOTIFICATION, arg1 = file name
SDBT_FILE_OPEN_DOC_MORE_RECENT_THAN_APP		enum	StandardDialogBoxType
	; Opening a vm file, document more recent protocol than app
	; CDT_ERROR, GIT_NOTIFICATION, arg1 = file name
SDBT_FILE_OPEN_FILE_TYPE_MISMATCH		enum	StandardDialogBoxType
	; Opening a vm file, token type mismatch
	; CDT_ERROR, GIT_NOTIFICATION, arg1 = file name


SDBT_FILE_SAVE_INSUFFICIENT_DISK_SPACE	enum	StandardDialogBoxType
	; Trying to open a file, disk is full
	; CDT_ERROR, GIT_NOTIFICATION, arg1 = file name
SDBT_FILE_SAVE_ERROR			enum	StandardDialogBoxType
	; Trying to open a file, file error
	; CDT_ERROR, GIT_NOTIFICATION, arg1 = file name, arg2 = error # string
SDBT_FILE_SAVE_WRITE_PROTECTED		enum	StandardDialogBoxType
	; Trying to save a file, write protected
	; CDT_QUESTION, GIT_AFFIRMATION, arg1 = file name


SDBT_FILE_SAVE_AS_FILE_EXISTS		enum	StandardDialogBoxType
	; Trying to save a file with a new name, file already exists
	; CDT_QUESTION, GIT_AFFIRMATION, arg1 = file name
SDBT_FILE_SAVE_AS_SHARING_DENIED	enum	StandardDialogBoxType
	; Trying to save a file with a new name, file already exists
	; CDT_ERROR, GIT_NOTIFICATION, arg1 = file name
SDBT_FILE_SAVE_AS_FILE_FORMAT_MISMATCH	enum	StandardDialogBoxType
	; Saving a vm file, file type mismatch
	; CDT_ERROR, GIT_NOTIFICATION, arg1 = file name


SDBT_FILE_CLOSE_SAVE_CHANGES_UNTITLED	enum	StandardDialogBoxType
	; Trying to close an untitled dirty file, user the user if changes
	; should be saved
	; CDT_QUESTION, GIT_MULTIPLE_RESPONSE, arg1 = file name
SDBT_FILE_CLOSE_SAVE_CHANGES_TITLED	enum	StandardDialogBoxType
	; Trying to close a titled dirty file, user the user if changes
	; should be saved
	; CDT_QUESTION, GIT_MULTIPLE_RESPONSE, arg1 = file name
SDBT_FILE_CLOSE_ATTACH_DIRTY		enum	StandardDialogBoxType
	; Trying to close a dirty file that was dirty from previous use
	; CDT_QUESTION, GIT_MULTIPLE_RESPONSE, arg1 = file name


SDBT_FILE_REVERT_CONFIRM		enum	StandardDialogBoxType
	; Trying to revert a file, ask for confirmation
	; CDT_WARNING, GIT_AFFIRMATION, arg1 = file name


SDBT_FILE_REVERT_ERROR			enum	StandardDialogBoxType
	; Trying to revert a file, file error
	; CDT_ERROR, GIT_NOTIFICATION, arg1 = file name


SDBT_FILE_ATTACH_DISK_NOT_FOUND		enum	StandardDialogBoxType
	; Trying to attach a file, cannot find disk
	; CDT_QUESTION, GIT_AFFIRMATION, arg1 = file name, arg2 = disk name

SDBT_CANNOT_CHANGE_TYPE			enum	StandardDialogBoxType
	; Error trying to change file type
	; CDT_ERROR, GIT_NOTIFICATION, arg1 = file name

SDBT_CANNOT_CHANGE_PASSWORD		enum	StandardDialogBoxType
	; Error trying to change file password
	; CDT_ERROR, GIT_NOTIFICATION, arg1 = file name

SDBT_PROMPT_MOVE_TEMPLATE	enum	StandardDialogBoxType
	; User is making a template, ask about moving it to SP_TEMPLATE
	; CDT_QUESTION, GIT_CUSTOM

SDBT_BAD_PASSWORD			enum	StandardDialogBoxType
	; Mismatched password
	; CDT_ERROR, GIT_NOTIFICATION

SDBT_RENAME_FILE_EXISTS			enum	StandardDialogBoxType
	; Rename to an existing name
	; CDT_ERROR, GIT_NOTIFICATION

SDBT_RENAME_ERROR			enum	StandardDialogBoxType
	; Error during rename
	; CDT_ERROR, GIT_NOTIFICATION

SDBT_BACKUP_ERROR			enum	StandardDialogBoxType
	; Error during backup
	; CDT_ERROR, GIT_NOTIFICATION

SDBT_REVERT_QUICK_CONFIRM		enum	StandardDialogBoxType
	; Confirm RevertQuick
	; CDT_QUESTION, GIT_AFFIRMATION

SDBT_REVERT_QUICK_ERROR			enum	StandardDialogBoxType
	; Error during revert quick
	; CDT_ERROR, GIT_NOTIFICATION

SDBT_QUERY_SET_EMPTY_NONE_EXISTS	enum	StandardDialogBoxType
	; User selected "Set Empty Document", no empty document exists
	; CDT_QUESTION, GIT_MULTIPLE_RESPONSE

SDBT_QUERY_SET_EMPTY_ONE_EXISTS		enum	StandardDialogBoxType
	; User selected "Set Empty Document", an empty document exists
	; CDT_QUESTION, GIT_MULTIPLE_RESPONSE

SDBT_QUERY_CLEAR_EMPTY			enum	StandardDialogBoxType
	; User selected "Clear Empty Document"
	; CDT_QUESTION, GIT_MULTIPLE_RESPONSE

SDBT_QUERY_SET_DEFAULT_NONE_EXISTS	enum	StandardDialogBoxType
	; User selected "Set Default Document", no default document exists
	; CDT_QUESTION, GIT_AFFIRMATION

SDBT_QUERY_SET_DEFAULT_ONE_EXISTS	enum	StandardDialogBoxType
	; User selected "Set Default Document", a default document exists
	; CDT_QUESTION, GIT_AFFIRMATION

SDBT_QUERY_CLEAR_DEFAULT		enum	StandardDialogBoxType
	; User selected "Clear Default Document"
	; CDT_QUESTION, GIT_AFFIRMATION

SDBT_SET_EMPTY_ERROR			enum	StandardDialogBoxType
	; Error during set empty
	; CDT_ERROR, GIT_NOTIFICATION

SDBT_TRANSPARENT_NEW_FILE_EXISTS	enum	StandardDialogBoxType
	; In transparent mode the user gave a file name for a new document
	; that already exists
	; CDT_ERROR, GIT_NOTIFICATION, arg1 = file name

SDBT_CONFIRM_PASSWORD_CHANGE		enum	StandardDialogBoxType
	; Confirm changing password
	; CDT_QUESTION, GIT_AFFIRMATION

SDBT_NOTIFY_SAVE_AS_TEMPLATE		enum	StandardDialogBoxType
	; Notify that we have saved-as tempate
	; CDT_NOTIFICATION, GIT_NOTIFICATION

SDBT_NOTIFY_SAVING_READ_ONLY		enum	StandardDialogBoxType
	; Notify that we are going to map save to save-as because the file
	; is a read-only file

SDBT_NOTIFY_SAVING_PUBLIC		enum	StandardDialogBoxType
	; Notify that we are going to map save to save-as because the file
	; is a public file

SDBT_DISK_RESTORE		enum	StandardDialogBoxType
	; Query the user about what to do when we cannot restore a disk
	; handle

SDBT_FILE_ILLEGAL_NAME			enum	StandardDialogBoxType
	; Trying to save a file, illegal file name
	; CDT_ERROR, GIT_NOTIFICATION, arg1 = file name

SDBT_FILE_OVERWRITING_ITSELF		enum	StandardDialogBoxType
	; Trying to "save as" a file over itself
	; CDT_ERROR, GIT_NOTIFICATION, arg1 = file name

if	VOLATILE_SYSTEM_STATE
SDBT_QUERY_SAVE_ON_APP_SWITCH_UNTITLED	enum	StandardDialogBoxType
SDBT_QUERY_SAVE_ON_APP_SWITCH_TITLED	enum	StandardDialogBoxType
	; Ask the user whether to save the file when switching applications.
	; For Redwood only.
endif


if 	LIMITED_UNTITLED_DOC_DISK_SPACE
SDBT_QUERY_AUTOSAVE_UNTITLED	enum	StandardDialogBoxType
SDBT_QUERY_AUTOSAVE_TITLED	enum	StandardDialogBoxType
	; Tell the user we're autosaving.
endif

if	FLOPPY_BASED_DOCUMENTS
SDBT_AUTOSAVE_TOTAL_FILES_TOO_LARGE	enum	StandardDialogBoxType
SDBT_AUTOSAVE_FILE_TOO_LARGE		enum	StandardDialogBoxType
SDBT_CANT_OPEN_TOTAL_FILES_TOO_LARGE	enum	StandardDialogBoxType
SDBT_CANT_CREATE_TOTAL_FILES_TOO_LARGE	enum	StandardDialogBoxType
SDBT_CANT_IMPORT_SAVE_TOTAL_FILES_TOO_LARGE	enum	StandardDialogBoxType
endif

SDBT_CANT_MOVE_READ_ONLY_DOCUMENT	enum	StandardDialogBoxType
SDBT_FILE_MOVE_WRITE_PROTECTED		enum	StandardDialogBoxType
SDBT_UNABLE_TO_OVERWRITE_EXISTING_FILE	enum	StandardDialogBoxType
SDBT_FILE_MOVE_INSUFFICIENT_DISK_SPACE	enum	StandardDialogBoxType
SDBT_FILE_MOVE_ERROR			enum	StandardDialogBoxType

SDBT_FILE_COPY_FILE_IS_PUBLIC_OR_READ_ONLY	enum	StandardDialogBoxType

if _NIKE
SDBT_FILE_OPEN_DEFAULT_DOCUMENT_NOT_FOUND	enum	StandardDialogBoxType
SDBT_FILE_OPEN_DEFAULT_DOCUMENT_NEW_DEFAULT	enum	StandardDialogBoxType
SDBT_FILE_SAVE_AS_DEFAULT_DOCUMENT_EXISTS	enum	StandardDialogBoxType
endif


if _RUDY

;
; Width and height of Rudy right arrows
;   These are in a file created by the convert script.
;
include	Art/mkrRightMarkSize.def

endif


; Space between left monikers and control children
	
if _CUA_STYLE
  if _RUDY
	MO_CONTROL_MKR_X_SPACING	=	5
	MO_CONTROL_MKR_X_SPACING_NARROW =	4
  else
	MO_CONTROL_MKR_X_SPACING	=	10			
	MO_CONTROL_MKR_X_SPACING_NARROW =	4		
  endif
endif
OLS <	OL_CONTROL_MKR_X_SPACING=	8			>

   
if _RUDY
	MO_CONTROL_MKR_Y_SPACING	=	3
else ; not _RUDY
CUAS <	MO_CONTROL_MKR_Y_SPACING	=	5		>
endif ; not _RUDY
CUAS <	MO_CONTROL_MKR_Y_SPACING_CGA	=	2		>
OLS <	OL_CONTROL_MKR_Y_SPACING	=	5		>

;
; Set if we want to find windows of a higher layer priority than passed
; rather than one which matches the exact layer priority.
;
if _RUDY
	FIND_HIGHER_LAYER_PRIORITY		= 	TRUE
else
	FIND_HIGHER_LAYER_PRIORITY		= 	FALSE
endif


if BUBBLE_DIALOGS

; Extra margins of bubble (popup) windows

BUBBLE_LEFT_EXTRA_MARGIN	=	15
BUBBLE_TOP_EXTRA_MARGIN		=	15	;Do not change from 
BUBBLE_RIGHT_EXTRA_MARGIN	=	15	; (what are you trying to say?)

BUBBLE_WEDGE_SIZE		=	16	;Size of bubble in Odie

;
; BUBBLE_DIALOG_INSET makes bubble dialogs draw a 3D inset
;
if _ODIE
BUBBLE_DIALOG_INSET	equ	TRUE
else
BUBBLE_DIALOG_INSET	equ	FALSE
endif

;
; BUBBLE_DIALOG_SHADOW gives bubble dialogs a shadow if they have
; HINT_DRAW_SHADOW
;
if DIALOG_SHADOWS
BUBBLE_DIALOG_SHADOW	equ	TRUE
else
BUBBLE_DIALOG_SHADOW	equ	FALSE
endif

endif


if BUBBLE_HELP
BUBBLE_HELP_WEDGE_SIZE		=	12
BUBBLE_HELP_TEXT_X_MARGIN	=	4
BUBBLE_HELP_TEXT_Y_MARGIN	=	2

;
; Info stored in vardata for bubble help
;
BubbleHelpData	struct
	BHD_window		hptr
	BHD_borderRegion	lptr
	BHD_timer		hptr
	BHD_timerID		word
BubbleHelpData	ends

;
; Used to hold .ini options for bubble help and bubble display
;
BubbleOptions	record
	BO_HELP:1			; set for bubble help on
	BO_DISPLAY:1			; set for bubble display on
BubbleOptions	end

;
; default times that bubble help and bubble displays remain open
; (in ticks)
;
BUBBLE_HELP_DEFAULT_DELAY_TIME	equ	30		; 1/2 second delay
BUBBLE_HELP_DEFAULT_TIME	equ	60*5		; 5 seconds
BUBBLE_DISPLAY_DEFAULT_TIME	equ	60*5		; 5 seconds
endif

; These insets are used to calculate the moniker size for items which
; have a selection box parent.  These replace MO_ITEM_INSET_LEFT/RIGHT.
;
if	SELECTION_BOX
VERTICAL_SELECTION_BOX_LEFT_INSET	equ	8
VERTICAL_SELECTION_BOX_RIGHT_INSET	equ	8
HORIZONTAL_SELECTION_BOX_LEFT_INSET	equ	4
HORIZONTAL_SELECTION_BOX_RIGHT_INSET	equ	4
endif

if SHORT_LONG_TOUCH
;
; default time for distinguishing a short touch from a long touch
;
SHORT_LONG_TOUCH_DEFAULT_TIME	equ	30		; 1/2 second
endif

	;
	; By default don't support Legos Looks.  Any SpecUI that wants
	; them can redefine this to be TRUE, but make sure they do it
	; after this FALSE setting, or it will have no effect.
	;
ifdef _HAS_LEGOS_LOOKS
ErrorMessage	"Don't define _HAS_LEGOS_LOOKS before this point.  Move this default setting earlier in the file if you have to, but it needs to be the first definition of _HAS_LEGOS_LOOKS."
endif
_HAS_LEGOS_LOOKS		= FALSE


if _PCV
_HAS_LEGOS_LOOKS		= TRUE	; we need legos looks support
_PCV_STYLE_BW_SHADOWS		= TRUE
_BLANK_STYLE_BUTTONS		= TRUE
_TOOL_STYLE_BUTTONS		= TRUE
_WINDOW_CONTROL_BUTTONS		= TRUE
_EDGE_STYLE_BUTTONS		= TRUE
_COMMAND_STYLE_BUTTONS		= TRUE
_ROUND_NORMAL_BW_BUTTONS	= FALSE	; make sure _ROUND_NORMAL_BW_BUTTONS
					;   is false, just in case the 'if
					;   (not STYLUS)' that currently sets
					;   it false ever changes.
ROLO_LEFT_PAD	equ 3		; left indent of the folder tab in pixels
ROLO_TAB_WIDTH	equ 108		; width of the folder tab in pixels
ROLO_TAB_HEIGHT	equ 15		; height of the folder tab in pixels

else
_PCV_STYLE_BW_SHADOWS		= FALSE
_BLANK_STYLE_BUTTONS		= FALSE
_TOOL_STYLE_BUTTONS		= FALSE
_WINDOW_CONTROL_BUTTONS		= FALSE
_EDGE_STYLE_BUTTONS		= FALSE
_COMMAND_STYLE_BUTTONS		= FALSE
endif


	;
	; Make sure you don't change the state of _HAS_LEGOS_LOOKS
	; after this point, as you may not get this warning defined
	; or may get it defined when you don't want it.
	;
if _HAS_LEGOS_LOOKS
WARNING_INVALID_LEGOS_LOOK	enum Warnings
endif

	; Warning if spurious timer comes through.  We can tell
	; because the OLMBOF_TIMER_PENDING will be cleared when the
	; MSG_TIMER_EXPIRED message arrives.
	;
if	SELECTION_BOX	and ERROR_CHECK
OL_WARNING_SPURIOUS_TIMER	enum Warnings
endif


;
; By default we MM_INVERT the text cursor, maybe we might want to MM_XOR it
; another time.
;
if _RUDY
	XOR_TEXT_CURSOR	= 	FALSE
else
	XOR_TEXT_CURSOR	= 	FALSE
endif

;
; Draw styles
;
if DRAW_STYLES

DrawStyle	etype	byte
DS_FLAT		enum	DrawStyle
DS_LOWERED	enum	DrawStyle
DS_RAISED	enum	DrawStyle

DRAW_STYLE_FRAME_WIDTH		=	1
if _ODIE
DRAW_STYLE_INSET_WIDTH		=	2
else
DRAW_STYLE_INSET_WIDTH		=	1
endif
DRAW_STYLE_THIN_INSET_WIDTH	=	1
DRAW_STYLE_DEFAULT_WIDTH	=	1

;
; for buttons
;
BUTTON_MONIKER_X_MARGIN		=	4
BUTTON_MONIKER_Y_MARGIN		=	1

BUTTON_MONIKER_X_TOOLBOX_MARGIN	=	0
BUTTON_MONIKER_Y_TOOLBOX_MARGIN	=	0

DrawInsetAndFrameFlags	record
	DIAFF_FRAME:1			; set to draw frame
	DIAFF_NO_WASH:1			; set to skip wash of interior
	DIAFF_FRAME_OUTSIDE:1		; set to always draw frame outside
					;	(if DIAFF_FRAME set)
DrawInsetAndFrameFlags	end

endif ; DRAW_STYLES

;
; cursor outside bounds
;
if CURSOR_OUTSIDE_BOUNDS
OUTSIDE_CURSOR_MARGIN	=	2		; single width and gutter
endif

;
; spinner constants
;
if SPINNER_GEN_VALUE
SPINNER_ARROW_HEIGHT	=	16
SPINNER_ARROW_WIDTH	=	16
SPINNER_ARROW_INSET	=	1
SPINNER_TEXT_MARGIN	=	2
endif

;
; focusable text display contants
;
if TEXT_DISPLAY_FOCUSABLE
TEXT_DISPLAY_FOCUS_WIDTH	=	1
endif
