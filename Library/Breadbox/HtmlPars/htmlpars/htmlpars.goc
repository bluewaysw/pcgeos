/***********************************************************************
 *
 * PROJECT:       HTMLPars
 * FILE:          htmlpars.goc
 *
 * AUTHOR:        Marcus Gr”ber
 *
 * NOTE:          To compile properly, this file requires the INCLUDE
 *                files from the OmniGo SDK or later, because the
 *                VisTextParaAttr structure is declared incorrectly in
 *                earlier versions.
 *
 ***********************************************************************/

/*
 ***************************************************************************
 *		Include files
 ***************************************************************************
 */
@include <stdapp.goh>
#include <chunkarr.h>

#include <Ansi/string.h>
#include <Ansi/stdio.h>
#include <Ansi/stdlib.h>
#include <Ansi/ctype.h>
#include <geoMisc.h>

@include <fixes.goh>
@include "htmlpars.goh"


#define HTML_MAXTAG   20        /* maximum tag size */
#define HTML_MAXSTACK 20        /* maximum # of tag nesting levels */


/***************************************************************************
 *              Default style constants
 ***************************************************************************/

const VisTextCharAttr vcaDefault =
  CHAR_ATTR_FONT_SIZE_STYLE(FID_DTC_URW_SANS, 12, 0);

const VisTextParaAttr vpaDefault=
  PARA_ATTR_STYLE_JUST_LEFT_RIGHT_PARA(2,CA_NULL_ELEMENT, J_LEFT, 0, 0, 0);

const VisTextCharAttr vcaHRule =
  CHAR_ATTR_FONT_SIZE_STYLE(FID_DTC_URW_SANS, 4, 0);

const VisTextParaAttr vpaHRule =
  {{{{2, 0}}, CA_NULL_ELEMENT}, VTPBF_TOP, {C_BLACK, CF_INDEX, 0, 0},
   J_LEFT << VTPAA_JUSTIFICATION_OFFSET, (0)*PIXELS_PER_INCH,
   (0)*PIXELS_PER_INCH, (0)*PIXELS_PER_INCH, 1<<8, 0, (0)*256, (0)*256,
   {C_WHITE, CF_INDEX, 0, 0}, 0, 2*8, 2*8, 1*8, SDM_100, SDM_0, {0},
   {0}, PIXELS_PER_INCH/2*8, VIS_TEXT_DEFAULT_STARTING_NUMBER, "", 0, 0,
   0, CA_NULL_ELEMENT, SL_ENGLISH, {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}};

const ColorQuad defaultLinkColor = {C_BLUE,CF_INDEX,0,0};

const sword fontRamp[7] = {9,10,12,14,16,18,20};

/***************************************************************************
 *              Include style and character definitions
 ***************************************************************************/

#define CSD_FONT   0x01                 /* change font */
#define CSD_SIZE   0x02                 /* change character size */
#define CSD_COLOR  0x04                 /* change color */
#define CSD_BASE   0x08                 /* revert to a basic font (cannot be
                                           used together with CSD_FONT) */

#define CSD_BASE_PLAIN          0       /* style is based on normal text */
#define CSD_BASE_EXAMPLE        1       /* style is based on example text */

typedef struct
{
  WordFlags CSD_which;                  /* which attributes to change */
  union {
    FontID    fontID;
    word      baseStyle;
  } CSD_fontOrBase;
  sword       CSD_pointSize;            /* point size to be used if the basic
                                           point size is 12pt */
  ColorQuad CSD_color;
  TextStyle CSD_textStyles;             /* style flags - added to current */
} CharStyleDelta;

/*
 * value to be added to VTPA_spaceOnBottom for additional
 * inter-paragraph spacing:
 */
#define INTER_PARAGRAPH_SPACING (12*8)
#define LR_ADDITIONAL_MARGIN    (1*PIXELS_PER_INCH)

#define PSD_MARGINS     0x01            /* change margins */
#define PSD_MARGINS_ADD 0x02            /* change margins (additive) -
                                           left and right margin contain the
                                           amount to add to current value,
                                           paraMargin contains the offset
                                           onto leftMargin */
#define PSD_JUSTIFY     0x04            /* use justification from attributes */
#define PSD_SPACING     0x08            /* change spacing above/below */

typedef struct
{
  WordFlags                 PSD_which;          /* which attributes to change */
  sword                     PSD_leftMargin,     /* margin settings or offsets */
                            PSD_rightMargin,
                            PSD_paraMargin;
  VisTextParaAttrAttributes PSD_attributes;     /* justifications/attributes
                                                   (added to current) */
} ParaStyleDelta;

/*
 * flags describing special tag properties
 */
#define TAG_PAR_BEFORE          0x0001  /* blank line before */
#define TAG_PAR_AFTER           0x0002  /* blank line afterwards */
#define TAG_VERB_FORM           0x0004  /* pass through multi whites & CR */
#define TAG_FLUSH_TEXT          0x0008  /* do not show text inside tag */
#define TAG_IMPLICIT_TERM       0x0010  /* may be terminated implicitly by a
                                           new paragraph style with the same
                                           flag (special handling for list
                                           items, definitions etc.) */
#define TAG_NO_FORMATTING       0x0020  /* do not cause visible change */
#define TAG_IS_PAR_STYLE        0x0040  /* affects paragraph style */
#define TAG_IS_CHAR_STYLE       0x0080  /* affects character style */
#define TAG_IS_BOTH             (TAG_IS_CHAR_STYLE | TAG_IS_PAR_STYLE)
#define TAG_PREPEND             0x0100  /* prepend string to start of para */
#define TAG_PREPEND_MAYBE       0x0200  /* inherit prepend from environment */

/* Flags which are affected by tags having the PSD_SPACING delta flag: */
#define TAG_SPACING_FLAGS (TAG_PAR_BEFORE | TAG_PAR_AFTER)

/* flags that are "inherited" by other styles embedded in them: */
#define TAG_CUMULATIVE_FLAGS (TAG_VERB_FORM | TAG_FLUSH_TEXT)

/* additional flags used for communications within the parser */
#define BREAK_LINE_BREAK        0x4000  /* insert line break, not para break */
#define BREAK_INSERT_HR         0x8000  /* insert hrule at para break */

/*
 * enumerated type describing tag types which require special handling
 */
typedef enum {
  SPEC_NONE,
  SPEC_A,
  SPEC_P,
  SPEC_HTML,    SPEC_HEAD,      SPEC_BODY,
  SPEC_TITLE,
  SPEC_HR,      SPEC_BR,        SPEC_IMG,
  SPEC_LI,      SPEC_OL,        SPEC_UL,
  SPEC_FONT,
} SpecialTagType;

typedef struct {
  char name[11];
  ChunkHandle ca,pa;                    /* handles of "delta" chunks */
  SpecialTagType spec;
  word flags;
} HTMLStylesTable;

typedef struct {
  unsigned char num;
  char name[7];
  unsigned char c;
} HTMLEntityTable;

typedef struct {
  char name[8];
  ColorQuad qc;
} HTMLColorTable;

/*
 * Include parsing tables for tags, entities and color names:
 */
@include "htmlsty.goh"

/*
 * Structures describing tag stacks used during parsing:
 */
typedef struct {
  word           style;
  Boolean        noterm;
  word           count;
  Boolean        linebr;
  SpecialTagType spec;
  word           flags;
  ParaStyleDelta delta;
} TagStackElement;

typedef struct {
  word           style;
  dword          startPos;
  optr           param;
  SpecialTagType spec;
  CharStyleDelta delta;
} TagCharStackElement;


/***************************************************************************
 *              Variables used during loading of the document
 ***************************************************************************/
optr HTMLObject;
static HTMLextra _far *HTMLext;
static dword textpos;
static int c2;

static VisTextCharAttr vcaBase;
static FontID fontExample;
static ColorQuad linkColor;

static Boolean insertParagraph;
static word insertParagraphFlags;
static VisTextCharAttr insertParagraphCS;
static VisTextParaAttr insertParagraphS;
static char insertPrepend[10];

static word            currentFlags;
static SpecialTagType  currentTopmost;
static VisTextCharAttr currentCS;
static VisTextParaAttr currentS;

static optr tagStackO,tagCharStackO;
static word tagStackPtr,tagCharStackPtr;


int TranslateCharNum(int num)
{
    HTMLEntityTable *xlate_table;
    int i,ret=0;

    MemLock( OptrToHandle(@xlateTable) );
    xlate_table = LMemDeref(@xlateTable);

    for(i=0; i<NUM_XLATE_ENTRIES; i++)
      if( xlate_table[i].num==num )
      {
        ret = xlate_table[i].c;
        break;
      }

    MemUnlock( OptrToHandle(@xlateTable) );
    return ret;
}

int TranslateChar(char *tag)
{
    HTMLEntityTable *xlate_table;
    int i;
    int ret=0;

    MemLock( OptrToHandle(@xlateTable) );
    xlate_table = LMemDeref(@xlateTable);

    if(*tag!='\x23')                    /* tag specified by name? */
    {
      for(i=0; i<NUM_XLATE_ENTRIES; i++)
        if( tag[0]==xlate_table[i].name[0] &&
            !strcmp(xlate_table[i].name,tag) )
        {
          ret = xlate_table[i].c;
          break;
        }
    }
    else
      ret = TranslateCharNum(atoi(tag+1));
                                        /* convert characters to number */
    MemUnlock( OptrToHandle(@xlateTable) );
    return ret;
}

void TranslateColor(char *p,ColorQuad *qc)
{
    char c;
    int i;
    unsigned long cval;
    HTMLColorTable *color_table;

    qc->CQ_info = CF_INDEX;             /* any color as long as its black */
    qc->CQ_redOrIndex = C_BLACK;

    if(*p=='\x23')                      /* skip over "#" sign */
      p++;

    MemLock( OptrToHandle(@colorTable) );
    color_table = LMemDeref(@colorTable);
    for(i=0; i<NUM_COLOR_ENTRIES; i++)
      if( !strcmpi(color_table[i].name,p) )
      {                                 /* found color id in table? */
        *qc = color_table[i].qc;        /* use associated color quad */
        break;
      }
    MemUnlock( OptrToHandle(@colorTable) );

    if(i>=NUM_COLOR_ENTRIES)            /* no color name found yet */
    {                                   /* try looking at it as hex */
      cval = 0;
      while( (c=toupper(*(p++)))!=0 && isxdigit(c) )
      {
        cval<<=4;
        if(isdigit(c))
          cval |= (c-'0');
        else
          cval |= (c-'A'+10);
      }
      if( c==0 )                        /* entire color id could be scanned? */
      {                                 /* use it as RGB value */
        qc->CQ_redOrIndex = (byte)(cval>>16);
        qc->CQ_green = (byte)(cval>>8);
        qc->CQ_blue = (byte)cval;
        qc->CQ_info = CF_RGB;
      }
    }
}

void SetTitle(char *title)
{
        ChunkHandle titleChunk;

        titleChunk = HTMLext->HE_documentTitle;

        if( titleChunk )
          LMemFreeHandles( HTMLext->HE_block, titleChunk );

        if( *title )
        {
          titleChunk = LMemAlloc( HTMLext->HE_block, strlen(title)+1 );
          strcpy(LMemDerefHandles( HTMLext->HE_block, titleChunk ), title);
        }
        else
          titleChunk = NullChunk;       /* no title */

        HTMLext->HE_documentTitle = titleChunk;
}

char *GetParamValue(optr array,char *par)
{
    word i,size;
    char *p = NULL,*q;

    if(!array) return NULL;             /* return NULL for non-array */

    for(i=ChunkArrayGetCount(array)-1; (int)i>=0; i--)
    {
      q = ChunkArrayElementToPtr(array,i,&size);
      if(strcmp(par,q)==0)              /* found parameter? */
      {
        p = q+strlen(q)+1;              /* set p to point after param name */
        break;                          /* we can stop searching */
      }
    }
    return p;
}

word StyleNum(char *name, SpecialTagType *spec)
{
        word i,ret;
        HTMLStylesTable *HTMLStyles;

        MemLock( OptrToHandle(@HTMLStylesChunk) );
                                        /* we will need the styles table now */

        HTMLStyles = LMemDeref( @HTMLStylesChunk );

        ret = 0;                        /* default: return first style */

        for(i=0; HTMLStyles[i].name[0]!='*'; i++)
          if(name[0]==HTMLStyles[i].name[0] && !strcmp(name,HTMLStyles[i].name))
          {
            *spec = HTMLStyles[i].spec;
            ret = i;                    /* return index of style found */
            break;
          }

        MemUnlock( OptrToHandle(@HTMLStylesChunk) );
                                        /* styles resource no longer needed */
        return ret;
}

void ApplyCharacterDelta(VisTextCharAttr *cs,CharStyleDelta *cd)
{
    if(cd->CSD_which & CSD_FONT)
      cs->VTCA_fontID = cd->CSD_fontOrBase.fontID;

    else if(cd->CSD_which & CSD_BASE)
      switch(cd->CSD_fontOrBase.baseStyle)
      {
        case CSD_BASE_PLAIN:
          cs->VTCA_fontID = vcaBase.VTCA_fontID;
          break;
        case CSD_BASE_EXAMPLE:
          cs->VTCA_fontID = fontExample;
          break;
      }

    if(cd->CSD_which & CSD_SIZE)        /* relative point size change */
    {
      cs->VTCA_pointSize.WBF_int =
        ((cd->CSD_pointSize * vcaBase.VTCA_pointSize.WBF_int + 6) / 12);
      cs->VTCA_pointSize.WBF_frac = 0;  /* round to nearest point size */
    }

    if(cd->CSD_which & CSD_COLOR)
      cs->VTCA_color = cd->CSD_color;

    cs->VTCA_textStyles |= cd->CSD_textStyles;
}

void ApplyParagraphGlobal(VisTextParaAttr *pa)
{
    if(HTMLext->HE_options & HTML_ADD_MARGIN)
    {                                   /* add "basic" left/right margin */
      pa->VTPA_leftMargin += LR_ADDITIONAL_MARGIN;
      pa->VTPA_rightMargin += LR_ADDITIONAL_MARGIN;
      pa->VTPA_paraMargin += LR_ADDITIONAL_MARGIN;
    }
}

/*
 * Requires localHeap to be locked.
 */
void GetCurrentStyles(Boolean getChar,Boolean getPara)
{
    sword p;
    TagStackElement *tagStack;
    TagCharStackElement *tagCharStack;

    if(getChar)
    {
      currentCS = vcaBase;
      tagCharStack = LMemDeref(tagCharStackO);
      for(p=0; p<tagCharStackPtr; p++,tagCharStack++)
        ApplyCharacterDelta( &currentCS, &(tagCharStack->delta) );
    }

    if(getPara)
    {
      currentS = vpaDefault;
      currentFlags = TAG_PAR_BEFORE|TAG_PAR_AFTER;
      tagStack = LMemDeref(tagStackO);

      if(tagStackPtr)                   /* store topmost element */
        currentTopmost = tagStack[tagStackPtr-1].spec;
      else
        currentTopmost = SPEC_NONE;

      for(p=0; p<tagStackPtr; p++,tagStack++)
      {
        if(tagStack->delta.PSD_which & PSD_MARGINS_ADD)
        {
          currentS.VTPA_rightMargin += tagStack->delta.PSD_rightMargin;
          currentS.VTPA_leftMargin += tagStack->delta.PSD_leftMargin;
          currentS.VTPA_paraMargin =
            currentS.VTPA_leftMargin + tagStack->delta.PSD_paraMargin;
        }
        else if(tagStack->delta.PSD_which & PSD_MARGINS)
        {
          currentS.VTPA_leftMargin = tagStack->delta.PSD_leftMargin;
          currentS.VTPA_rightMargin = tagStack->delta.PSD_rightMargin;
          currentS.VTPA_paraMargin = tagStack->delta.PSD_paraMargin;
        }

        if(tagStack->delta.PSD_which & PSD_JUSTIFY)
          currentS.VTPA_attributes &= ~VTPAA_JUSTIFICATION;

        if(tagStack->delta.PSD_which & PSD_SPACING)
        {                               /* modify vertical spacing flags */
          currentFlags &= ~TAG_SPACING_FLAGS;
          currentFlags |= (tagStack->flags & TAG_SPACING_FLAGS);
                                        /* set spacing to specified values */
        }

        currentS.VTPA_attributes |= tagStack->delta.PSD_attributes;

        if( tagStack->flags & TAG_NO_FORMATTING )
                                        /* is this a non-formatting tag? */
          currentFlags |= (tagStack->flags & TAG_CUMULATIVE_FLAGS);
                                        /* only update cumulative flags */
        else
        {
          currentFlags &= TAG_CUMULATIVE_FLAGS | TAG_SPACING_FLAGS |
            ((tagStack->flags & TAG_PREPEND_MAYBE)? TAG_PREPEND:0);
                                        /* reset non-cumulative flags */
          currentFlags |= tagStack->flags;
                                        /* update all flags */
        }
      }

      ApplyParagraphGlobal( &currentS );/* add global modifications */
    }
}

void ApplyGlobalStyle(CharStyleDelta *caDelta)
{
    VisTextCharAttr ca;
    VisTextParaAttr pa;

    /*
     * Set character attributes on entire text
     */
    ca = vcaBase;
    if( caDelta )                       /* apply character style if any */
      ApplyCharacterDelta( &ca, caDelta );
    @call HTMLObject::MSG_VIS_TEXT_SET_CHAR_ATTR( &ca,TEXT_ADDRESS_PAST_END,0 );

    /*
     * Set paragraph attributes on entire text
     */
    pa = vpaDefault;
    ApplyParagraphGlobal( &pa );        /* add global modifications */
    @call HTMLObject::MSG_VIS_TEXT_SET_PARA_ATTR( &pa,TEXT_ADDRESS_PAST_END,0 );
}

void AddText(VisTextCharAttr *ca,char *text)
{
    if(*text)                           /* do not append empty strings */
    {
      @call HTMLObject::MSG_VIS_TEXT_APPEND_PTR(text,0);

      if( (HTMLext->HE_options & HTML_READ_FAST)==0 )
        @call HTMLObject::MSG_VIS_TEXT_SET_CHAR_ATTR(
          ca, TEXT_ADDRESS_PAST_END, textpos);

      @call HTMLObject::MSG_VIS_TEXT_SET_CONTEXT(
        VTCF_TOKEN, CA_NULL_ELEMENT,
        TEXT_ADDRESS_PAST_END, textpos);

      @call HTMLObject::MSG_VIS_TEXT_SET_HYPERLINK(
        VTCF_TOKEN, VIS_TEXT_CURRENT_FILE_TOKEN, CA_NULL_ELEMENT,
        TEXT_ADDRESS_PAST_END, textpos);

      textpos += strlen(text);          /* update text position */
    }
}

void AddParagraph(VisTextCharAttr *ca,VisTextParaAttr *pa)
{
    if( !(HTMLext->HE_options & HTML_READ_FAST) )
      @call HTMLObject::MSG_VIS_TEXT_SET_PARA_ATTR(pa,
        TEXT_ADDRESS_PAST_END,TEXT_ADDRESS_PAST_END);

    AddText(ca,"\r");                   /* add a paragraph */
}

void AddParagraphCurStyle(void)
{
    AddParagraph(&currentCS,&currentS);
}

void AddTextCurStyle(char *buf)
{
    AddText(&currentCS, buf);
}

/*
 *  Check if there is a pending paragraph end. If so, physically put it into
 *  the text object, taking into account the attributes of the paragraph that
 *  is ended as well as those of the current one (i.e. the one to be started).
 */
void AddParaCond(void)
{
    dword pos;
    TagCharStackElement *tagCharStack;
    word i;

    if(insertParagraph)
    {
      if( ((insertParagraphFlags & TAG_PAR_AFTER)
          || (currentFlags & TAG_PAR_BEFORE))
        && !(insertParagraphFlags & BREAK_LINE_BREAK) )
      {
        insertParagraphS.VTPA_spaceOnBottom += INTER_PARAGRAPH_SPACING;
      }

      pos = textpos;                    /* remember starting position */

      AddParagraph(&insertParagraphCS,&insertParagraphS);

      if((currentFlags & TAG_PREPEND) && !*insertPrepend)
        strcpy(insertPrepend,"\t");     /* make sure it's indented */

      if(*insertPrepend)                /* prepend text to paragraph? */
        AddText(&vcaBase,insertPrepend);

      /*
       * Fix start positions of character runs starting at the end of the
       * previous paragraph to not include the end-of-paragraph mark and
       * the prepended text, if any.
       */
      tagCharStack = LMemDeref(tagCharStackO);
      for(i=0; i<tagCharStackPtr; i++)
        if( tagCharStack[i].startPos==pos )
                                        /* started right before end of para? */
          tagCharStack[i].startPos = textpos;
                                        /* advnace to real start of text */

      insertParagraph = FALSE;
    }
}

void EndParagraph(char *p)
{
        if(!insertParagraph)            /* can't close same paragraph twice */
        {
          if(c2!='\r')                  /* avoid empty paragraphs */
          {
            insertParagraph = TRUE;     /* pending paragraph */
            insertParagraphCS = currentCS;
            insertParagraphS = currentS;
            insertParagraphFlags = currentFlags;
            strcpy(insertPrepend,p);    /* store data affecting the paragraph */
            c2='\r';
          }
        }
        else                            /* already line/para break pending */
        {
          if( strlen(p) >= strlen(insertPrepend) )
            strcpy(insertPrepend, p);   /* prepend overrides non-prepend */

          insertParagraphFlags &= ~BREAK_LINE_BREAK;
                                        /* para break overrides line break */
          insertParagraphFlags |= (currentFlags & TAG_SPACING_FLAGS);
                                        /* always prefer maximum spacing */
        }
}

void EndLine(char *prep)
{
        if(!insertParagraph)            /* already at the end of a paragraph? */
        {
          EndParagraph(prep);
          insertParagraphFlags |= BREAK_LINE_BREAK;
                                        /* no inter-paragraph spacing */
        }                               
        else                            /* just add additional spacing */
          insertParagraphS.VTPA_spaceOnBottom += INTER_PARAGRAPH_SPACING;
}

void PopCharacterStyle(word n)
{
    dword cur_hl_pos;
    optr cur_hl_param;
    char *p;
    word token;
    TagCharStackElement *tagCharStack;
    VisTextNameData vtnd =
      {VTNT_CONTEXT, VTCT_TEXT, VIS_TEXT_CURRENT_FILE_TOKEN, 0};

    tagCharStack = LMemDeref(tagCharStackO);

    if( tagCharStack[n].spec==SPEC_A )  /* closing hyperlink or anchor name */
    {
      cur_hl_pos = tagCharStack[n].startPos;
                                        /* start of next hyperlink run */
      cur_hl_param = tagCharStack[n].param;
                                        /* link text for run */

      if( cur_hl_param && (HTMLext->HE_options & HTML_ADD_HYPERLINKS) )
      {
        p = GetParamValue(cur_hl_param,"NAME");
        if(p)
        {
          vtnd.VTND_helpText = (DBGroupAndItem)strlen(p);
          token = DWORD_TOKEN(
            @call HTMLObject::MSG_VIS_TEXT_ADD_NAME(
              vtnd, 0, 0, p ) );
          @call HTMLObject::MSG_VIS_TEXT_SET_CONTEXT(
            VTCF_TOKEN, token, TEXT_ADDRESS_PAST_END, cur_hl_pos);
        }
        else
        {
          p = GetParamValue(cur_hl_param,"HREF");

          if(p)
          {
            vtnd.VTND_helpText = (DBGroupAndItem)strlen(p);
            token = DWORD_TOKEN(
              @call HTMLObject::MSG_VIS_TEXT_ADD_NAME(
                vtnd, 0, 0, p ) );
            @call HTMLObject::MSG_VIS_TEXT_SET_HYPERLINK(
              VTCF_TOKEN, VIS_TEXT_CURRENT_FILE_TOKEN, token,
              TEXT_ADDRESS_PAST_END, cur_hl_pos);
          }
        }
      }

      if(cur_hl_param)                  /* if anything was allocated: */
        LMemFree(cur_hl_param);         /* release memory for link parameters */
    }

    for(; n<tagCharStackPtr-1; n++)     /* remove styles above current one */
      tagCharStack[n] = tagCharStack[n+1];

    tagCharStackPtr--;                  /* we've removed one element */
}

void PopParagraphStyle(void)
{
    EndParagraph("");                   /* end paragraph in current style */
    tagStackPtr--;                      /* we've removed one element */
}

void OpenTag(word tagStyle, HTMLStylesTable *tagStyleEntry, optr paramArray)
{
    char *p,*altName;
    CharStyleDelta ca;
    ParaStyleDelta pa;
    optr paramC = NullOptr;
    SpecialTagType spec;
    word flags;
    sword i;
    TagStackElement *tagStack;
    TagCharStackElement *tagCharStack;
    char prepend[4];

    tagStack = LMemDeref(tagStackO);
    tagCharStack = LMemDeref(tagCharStackO);

    spec = tagStyleEntry->spec;
    flags = tagStyleEntry->flags;
    *prepend = 0;

    MemLock( OptrToHandle(@HTMLStylesChunk) );
    memcpy( &ca, LMemDerefHandles( OptrToHandle(@HTMLStylesChunk),
      tagStyleEntry->ca ), sizeof(ca) );
    memcpy( &pa, LMemDerefHandles( OptrToHandle(@HTMLStylesChunk),
      tagStyleEntry->pa ), sizeof(pa) );
    MemUnlock( OptrToHandle(@HTMLStylesChunk) );

    switch( spec )
    {
    /*------------------------------------------------------------------------*/
    case SPEC_A:
      p = GetParamValue(paramArray,"NAME");
      if(p && *p)                       /* anchor name */
        paramC = paramArray;            /* remember target name on char stack */
      else
      {
        p = GetParamValue(paramArray,"HREF");
        if(p && *p)
        {
          paramC = paramArray;
          ca.CSD_which |= CSD_COLOR;    /* change character style */
          ca.CSD_textStyles |= TS_UNDERLINE;
          ca.CSD_color = linkColor;
        }
      }
      break;

    /*------------------------------------------------------------------------*/
    case SPEC_HR:
    {
      EndParagraph("");
      insertParagraphFlags |= TAG_PAR_AFTER;
      AddParaCond();                    /* flush pending para end */

      insertParagraph=TRUE;
      insertParagraphFlags = TAG_PAR_AFTER;
      insertParagraphCS = vcaHRule;
      insertParagraphS = vpaHRule;
      if( HTMLext->HE_options & HTML_ADD_MARGIN )
      {                                 /* add "basic" left/right margin */
        insertParagraphS.VTPA_leftMargin += LR_ADDITIONAL_MARGIN;
        insertParagraphS.VTPA_rightMargin += LR_ADDITIONAL_MARGIN;
        insertParagraphS.VTPA_paraMargin += LR_ADDITIONAL_MARGIN;
      }

      if(currentFlags & TAG_PREPEND)    /* prepend tab in all following paras */
        strcpy(insertPrepend,"\t");

      c2='\r';                          /* treat as paragraph */
      tagStyle = 0;                     /* no do not put onto stack */
      break;
    }

    /*------------------------------------------------------------------------*/
    case SPEC_BR:
      EndLine("");                      /* simulate line break */
      tagStyle = 0;                     /* no do not put onto stack */
      break;

    /*------------------------------------------------------------------------*/
    case SPEC_IMG:
    {
      HTMLimageData *id;
      VisTextCharAttr vcaImage;
      MemHandle mem ;
      ChunkHandle chunk ;
      word len ;

      AddParaCond();                    /* flush pending para end */

      altName = GetParamValue(paramArray,"ALT");
      if(!altName)                      
        altName = "Image";              /* default placeholder */

      p = GetParamValue(paramArray,"SRC");
      if(p && *p)                       /* image filename */
      {
        mem = HTMLext->HE_block ;
        chunk = HTMLext->HE_imageArray ;
        len = strlen(p) ;
        id = ChunkArrayAppendHandles(mem, chunk, sizeof(HTMLimageData)+len) ;
                                        /* add entry for image */
        id->pos = textpos;              /* store position of image */
        id->len = strlen(altName) + 4;  /* length of image placeholder */
        id->flags = 0;                  /* no special attributes */
        strcpy(id->name, p);            /* copy URL of image */

        p = GetParamValue(paramArray,"WIDTH");
        if(p)                           /* width specified? */
          id->size.XYS_width = atoi(p); /* yes: use specified width */
        else
          id->size.XYS_width = 0;       /* no: use default width */

        p = GetParamValue(paramArray,"HEIGHT");
        if(p)                           /* width specified? */
          id->size.XYS_height = atoi(p);/* yes: use specified width */
        else
          id->size.XYS_height = 0;      /* no: use default width */

        vcaImage = vcaBase;             /* image style based on default */
        MemLock( OptrToHandle(@HTMLStylesChunk) );
        ApplyCharacterDelta( &vcaImage,(CharStyleDelta *)LMemDeref(@vcdImage) );
        MemUnlock( OptrToHandle(@HTMLStylesChunk) );
                                        /* create image style */
        AddText( &vcaImage, " [");      /* add text in image style */
        AddText( &vcaImage, altName );  
        AddText( &vcaImage, "] ");
      }

      c2='.';                           /* treat as character */
      tagStyle = 0;                     /* no do not put onto stack */
      break;
    }

    /*------------------------------------------------------------------------*/
    case SPEC_BODY:
    {
      HTMLimageData *id;
      ColorQuad cq;
      VisTextWashColorModeRed wcModeRed;
      VisTextWashColorBlueGreen wcBlueGreen;

      if( (HTMLext->HE_options & HTML_MONOCHROME)==0 )
      {
        p = GetParamValue(paramArray,"BACKGROUND");
        if(p && *p)                     /* background image name */
        {
          id = ChunkArrayAppendHandles(
            HTMLext->HE_block, HTMLext->HE_imageArray,
            sizeof(HTMLimageData)+strlen(p) );
                                        /* add entry for image */
          id->pos = TEXT_ADDRESS_PAST_END;
                                        /* this is a background image */
          id->len = 0;                  /* length of image placeholder */
          id->flags = 0;                /* no special attributes */
          id->size.XYS_width = id->size.XYS_height = 0;
                                        /* use intrinsic size */
          strcpy(id->name, p);          /* copy URL of image */
        }

        p = GetParamValue(paramArray,"BGCOLOR");
        if(p && *p)                     /* background color */
        {
          TranslateColor(p, &cq);
          wcModeRed.VTWCMR_redOrIndex = cq.CQ_redOrIndex;
          wcModeRed.VTWCMR_mapMode = cq.CQ_info;
          wcBlueGreen.VTWCBG_green = cq.CQ_green;
          wcBlueGreen.VTWCBG_blue = cq.CQ_blue;
          @call HTMLObject::MSG_VIS_TEXT_SET_WASH_COLOR(
            wcModeRed, wcBlueGreen );
        }

        p = GetParamValue(paramArray,"TEXT");
        if(p && *p)                       /* text color */
          TranslateColor(p, &vcaBase.VTCA_color);

        p = GetParamValue(paramArray,"LINK");
        if(p && *p)                       /* link color */
          TranslateColor(p, &linkColor);
      }
      break;
    }

    /*------------------------------------------------------------------------*/
    case SPEC_FONT:
      if( (HTMLext->HE_options & HTML_MONOCHROME)==0 )
      {
        p = GetParamValue(paramArray,"COLOR");
        if(p && *p)                     /* text color */
        {
          TranslateColor(p, &ca.CSD_color);
          ca.CSD_which |= CSD_COLOR;    /* set new color */
        }
      }

      p = GetParamValue(paramArray,"SIZE");
      if(p && *p)                       /* text size */
      {
        if(*p=='+')                     /* relative or absolute change? */
          i = 3 + atoi(p+1);
        else if(*p=='-')
          i = 3 - atoi(p+1);
        else
          i = atoi(p);

        if(i<1) i = 1;                  /* restrict to range 1..7 */
        if(i>7) i = 7;

        ca.CSD_which |= CSD_SIZE;       /* set new font size from list */
        ca.CSD_pointSize = fontRamp[i-1];
      }
      break;

    /*------------------------------------------------------------------------*/
    case SPEC_P:
      p = GetParamValue(paramArray,"ALIGN");
      if(p && *p)                       /* alignment */
      {
        pa.PSD_which |= PSD_JUSTIFY;    /* change justifcation */
        pa.PSD_attributes &= ~VTPAA_JUSTIFICATION;
        if( 0==strcmpi(p,"CENTER") )
          pa.PSD_attributes |= (J_CENTER<<VTPAA_JUSTIFICATION_OFFSET);
        else if( 0==strcmpi(p,"RIGHT") )
          pa.PSD_attributes |= (J_RIGHT<<VTPAA_JUSTIFICATION_OFFSET);
        else                            /* default alignment: left */
          pa.PSD_attributes |= (J_LEFT<<VTPAA_JUSTIFICATION_OFFSET);
      }
      break;

    /*------------------------------------------------------------------------*/
    }

    /*
     * Handle implicitly terminated paragraph formatting tags,
     * like <LI> or <P> which do not require a corresponding </...> tag:
     * Here, they are terminated by another paragraph tag (probably of the
     * same type).
     */
    if( (flags & TAG_IS_PAR_STYLE) &&
        tagStackPtr &&
        (tagStack[tagStackPtr-1].flags & TAG_IMPLICIT_TERM) &&
        ((flags & TAG_IMPLICIT_TERM) || tagStack[tagStackPtr-1].spec==SPEC_P) )
    {
      if( spec==SPEC_P && (tagStack[tagStackPtr-1].spec!=SPEC_P) )
      {
        tagStack[tagStackPtr-1].flags |= TAG_PAR_AFTER;
        currentFlags |= TAG_PAR_AFTER;  /* (update cache as well) */
        EndParagraph("");
        flags &= ~TAG_IS_PAR_STYLE;     /* do not push <P> onto stack */
      }
      else
        PopParagraphStyle();            /* drop old tag */
    }

    /* opening paragraph tag */
    if( flags & TAG_IS_PAR_STYLE && tagStackPtr<HTML_MAXSTACK )
    {
      /* convert generic <LI> tag into specific form depending on
         enclosing list type */
      if( spec==SPEC_LI && tagStackPtr )
        switch( tagStack[tagStackPtr-1].spec )
        {
        case SPEC_UL:
          strcpy( prepend, "\xA5" );
          flags |= TAG_PREPEND;
          break;
        case SPEC_OL:
          strcpy( prepend, "%d." );
          flags |= TAG_PREPEND;
          tagStack[tagStackPtr-1].count++;
          break;
        }

      tagStack[tagStackPtr].style = tagStyle;
      tagStack[tagStackPtr].delta = pa;
      tagStack[tagStackPtr].flags = flags;
      tagStack[tagStackPtr].spec = spec;
      tagStack[tagStackPtr].count = 0;

      {
        char prepText[20];              /* short lived buffer for item prefix */

        if(flags & TAG_PREPEND)         /* prepend tab in all following paras */
        {
          sprintf(prepText, prepend, tagStack[tagStackPtr-1].count);
          strcat(prepText,"\t");        /* add tab to standard left margin */
        }
        else
          *prepText = 0;

        if( !(flags & TAG_NO_FORMATTING) )
          EndParagraph(prepText);
      }

      tagStackPtr++;
      GetCurrentStyles(FALSE,TRUE);     /* refresh cached style data */
    }

    /* open character tag */
    if( (flags & TAG_IS_CHAR_STYLE) && tagCharStackPtr<HTML_MAXSTACK )
    {
      tagCharStack[tagCharStackPtr].style = tagStyle;
      tagCharStack[tagCharStackPtr].delta = ca;
      tagCharStack[tagCharStackPtr].param = paramC;
      tagCharStack[tagCharStackPtr].spec = spec;
      tagCharStack[tagCharStackPtr].startPos = textpos;

      if(paramC)                        /* should we store the parmaters? */
        paramArray = NullOptr;          /* defer freeing of memory */

      tagCharStackPtr++;
      GetCurrentStyles(TRUE,FALSE);     /* refresh cached style data */
    }

    if(paramArray)                      /* if there is one to be released... */
      LMemFree(paramArray);             /* forget array with parameters */
}

void CloseTag(word tagStyle, HTMLStylesTable *tagStyleEntry, optr paramArray)
{
    int i;
    TagStackElement *tagStack;
    TagCharStackElement *tagCharStack;

    tagStack = LMemDeref(tagStackO);
    tagCharStack = LMemDeref(tagCharStackO);

    if(paramArray)                      /* if there is one to be released... */
      LMemFree(paramArray);             /* forget closing tag parameters */

    /* closing character style tag? */
    if( tagStyle && (tagStyleEntry->flags & TAG_IS_CHAR_STYLE) )
    {
      for(i=tagCharStackPtr-1; i>=0; i--)
        if( tagCharStack[i].style==tagStyle )
        {
          PopCharacterStyle(i);
          break;
        }
    }

    if( tagStyle && (tagStyleEntry->flags & TAG_IS_PAR_STYLE) )
    {
      if( tagStackPtr>1 &&
          (tagStack[tagStackPtr-1].flags & TAG_IMPLICIT_TERM) )
        PopParagraphStyle();

      if(tagStackPtr && tagStack[tagStackPtr-1].style==tagStyle)
        PopParagraphStyle();            /* pop tag to be closed */

      EndParagraph("");                 /* closing para style ends paragraph */

      /* pop pending character styles */
      while(tagCharStackPtr)
      {
        PopCharacterStyle(tagCharStackPtr-1);
      }
    }

    GetCurrentStyles(TRUE,TRUE);        /* refresh all cached style data */
}

#define HTML_READBUF 1024

typedef struct {
  FileHandle fileHTML;
  byte *HTMLbuf;
  word HTMLbufp,HTMLbufl;
} HTMLFILE;

dword OpenFileURL(FileHandle fh,HTMLFILE *f)
{
    f->fileHTML = fh;                   /* assign physical file */
    if( !(f->HTMLbuf = malloc(HTML_READBUF)) )
      return NULL;                      /* failure to allocate file buffer */
    f->HTMLbufp = f->HTMLbufl = 1;      /* no data in buffer yet */

    return (dword)f;
}

ReadHTML_getc getcFileURL
{
    if( ((HTMLFILE *)data)->HTMLbufp >= ((HTMLFILE *)data)->HTMLbufl )
    {
      ((HTMLFILE *)data)->HTMLbufl=FileRead(
        ((HTMLFILE *)data)->fileHTML, ((HTMLFILE *)data)->HTMLbuf,
        HTML_READBUF, FALSE);
      ((HTMLFILE *)data)->HTMLbufp = 0; /* set pointer to start of buffer */
      if( ((HTMLFILE *)data)->HTMLbufl==0 )
        return EOF;                     /* read against end of file */
    }
    return ((HTMLFILE *)data)->HTMLbuf[ ((HTMLFILE *)data)->HTMLbufp++ ];
                                        /* return next character from file */
}

void CloseFileURL(HTMLFILE *f)
{
    free(f->HTMLbuf);                   /* free read buffer */
}

int lc;
ReadHTML_getc *gc;
dword data;

int HTMLgetc(void)
{
    register int c;
    typedef int pcfm_getc(ReadHTML_getc *gc,dword data);

    if(gc)
      c = ((pcfm_getc *)ProcCallFixedOrMovable_cdecl)(gc,data);
    else
      c = getcFileURL(data);

    /* "CR after LF" or "LF after CF": skip over "the other one" */
    if( (c=='\n' && lc=='\r') || (c=='\r' && lc=='\n') )
      if(gc)
        c = ((pcfm_getc *)ProcCallFixedOrMovable_cdecl)(gc,data);
      else
        c = getcFileURL(data);

    lc = c;                             /* remember last character read */

    if(c<' ' && c!=EOF)                 /* handle control characters */
    {
      if( c=='\n' )                     /* use only '\r' for newline */
        c = '\r';
      if( c!='\r' && c!='\t' )          /* non-whitespace: treat as blanks */
        c = ' ';
    }

    return c;
}

/*
 *  Get a string of consecutive characters into buffer buf[]. This
 *  routine does all the decoding of special characters.
 *
 *  Passed in c is a one-character look-ahead; the next character after
 *    the string is returned from the call.
 *  Passed in ce is an alternative character to end parsing, other than the
 *    standard ones (tag delimiter, end of file). If ce contains a blank, a
 *    '\r' is also interpreted as a valid terminator (=any whitespace).
 *  If param==TRUE is passed, reading of characters is not terminated when
 *    the buffer is full; instead, excessive characters are flushed to the
 *    next terminated. In addition, the value of c2 is not touched.
 *
 *  Global variables changed: c2
 */
int GetText(int cc,int ce,char *buf,Boolean verbForm,Boolean param)
{
    register int q;
    register int c = cc;                /* use register for higher speed */
    int p = 0;                          /* start with empty buffer */
    int cp;

    cp = param? ' ' : c2;               /* c2: only for non-parameter text */

    /*
     * Terminating characters:
     *   - whatever was passed in ce
     *   - also '\r' or '\t' if ce specifies a blank
     *   - '<' and '>'
     *   - end of file
     */
    while( c!=ce && ((c!='\r' && c!='\t') || ce!=' ') && c!='>' && c!='<' &&
           c!=EOF )
    {
      if( p>=HTML_MAXBUF-HTML_MAXTAG-2 )/* safe to store data in buffer? */
      {
        if(param)                       /* no: flush characters? */
          c=HTMLgetc();                 /* yes: just skip over char */
        else
          break;                        /* no: abort immediately */
      }
      else if(c=='&')                   /* process entities */
      {
        char tag[HTML_MAXTAG+1];

        c=HTMLgetc();
        q=0;                            /* start tag */
        cp=0;                           /* no character identifed yet */

        if(c=='\x23')                   /* entity specified by number */
        {
          tag[q++]=(char)c;             /* get tag name */
          c=HTMLgetc();
          while( isdigit(c) && q<HTML_MAXTAG )
          {
            tag[q++]=(char)c;           /* get tag name */
            c=HTMLgetc();
          }
          tag[q]=0;                     /* terminate tag */
          cp=(char)TranslateChar(tag);
        }
        else                            /* entity specified by name */
        {
          while( isalpha(c) && q<HTML_MAXTAG && !cp )
          {
            tag[q++]=(char)c;           /* get entity name */
            tag[q]=0;
            cp=(char)TranslateChar(tag);/* abort as soon as char is known (this
                                           is bad HTML, but ok with NS) */
            c=HTMLgetc();
          }
          tag[q]=0;                     /* make sure tag is terminated */
        }

        if(cp)                          /* read a character? */
        {
          buf[p++]=cp;                  /* put it into the input stream */
          if(c==';')                    /* skip over terminating ";" if any */
            c=HTMLgetc();
        }
        else
        {
          buf[p++]='&';                 /* literally quote unknown tag */
          for(q=0; tag[q]; q++)
            buf[p++]=tag[q];
        }
      }
      else
      {
        if( !verbForm && (c=='\r' || c=='\t') )
          c = ' ';                      /* all whitespaces are equal... */

        if( c!=' ' || (cp!=' ' && cp!='\r') || verbForm )
        {
          if(c>=128)                    /* convert high-ASCII characters */
          {
            c=TranslateCharNum(c);
          }
          c=c?c:'?';                    /* zeroes get us all confused... */
          buf[p++]=(char)c;             /* add to "normal" text */
          cp=c;                         /* remember character... */
        }
        c=HTMLgetc();                   /* get next character */
      }
    }
    buf[p]=0;                           /* terminate string */

    if(!param)                          /* in main text: update previous */
      c2 = cp;                          /* character for whitespace handling */

    return c;
}

int HandleTag(MemHandle localHeap)
{
    register int c,p;
    int ce,q;
    char *e;
    Boolean endTag;
    word tagStyle;
    HTMLStylesTable tagStyleEntry;
    optr paramArray;
    SpecialTagType spec;

    c=HTMLgetc();
    if(c=='/')
    {
      c=HTMLgetc();
      endTag=TRUE;
    }
    else
      endTag=FALSE;

    {
      char tag[HTML_MAXTAG+1];          /* tag only needed until identified */

      /* get tag name */
      p=0;                              /* start tag */
      while( c!='>' && c!='=' && c!=' ' && c!='\r' && c!='\t' && c!=EOF )
      {
        if(p<HTML_MAXTAG)
          tag[p++]=(char)((c>='a' && c<='z')?(c-32):c);
                                        /* get tag name */
        if(c=='!') break;               /* "!": single character tag */
        c=HTMLgetc();
      }
      tag[p]=0;                         /* terminate tag */

      paramArray = NullOptr;            /* no parameters yet */

      /* identify tag */
      tagStyle=StyleNum(tag,&spec);     /* find if tag has an assigned style */
    }

    /* quickly skip over comments */
    if(c=='!')                          /* <!--..--> or <!..> */
    {
      c = HTMLgetc();                   /* skip over '!' */

      q = 0;
      if(c=='-')                        /* skip over '--' */
      {
        c = HTMLgetc();                 
        if(c=='-')
        {
          c = HTMLgetc();
          q = 2;                        /* '<!--' must be closed by '-->' */
        }
      }

      p = 0;                            /* no dashes seen yet */
      while( (c!='>' || p<q) && c!=EOF )
      {
        if(c=='-')                      /* count consecutive dashes */
          p++;
        else                            /* any non-dash resets count */
          p = 0;
        c = HTMLgetc();
      }
    }

    /* get tag arguments if any */
    while( c!='>' && c!='<' && c!=EOF ) /* while tag has more data in it... */
    {                                   
      char arg[HTML_MAXTAG+1],buf[HTML_MAXBUF];

      /* skip whites */
      while(c==' ' || c=='\r' || c=='\t') c=HTMLgetc();

      /* get argument name */
      p=0;                              /* start tag */
      while( c!='=' && c!=' ' && c!='\r' && c!='\t' && c!='>' && c!='<' &&
             c!=EOF )
      {
        if(p<HTML_MAXTAG)
          arg[p++]=(char)((c>='a' && c<='z')?(c-32):c);
                                        /* get argument name */
        c=HTMLgetc();
      }
      arg[p]=0;                         /* terminate arg name */

      /* skip whites */
      while(c==' ' || c=='\r' || c=='\t') c=HTMLgetc();

      /* get argument value if available */
      if(c=='=')
      {
        c=HTMLgetc();                   /* skip over "=" */

        /* skip whites */
        while(c==' ' || c=='\r' || c=='\t') c=HTMLgetc();

        if(c=='"' || c=='\'')           /* quoted argument? */
        {
          ce=c;                         /* quote terminates */
          c=HTMLgetc();                 /* skip over quote */
        }
        else
          ce=' ';                       /* whitespace terminates */

        c = GetText(c,ce,buf,FALSE,TRUE);
                                        /* parse text up to terminator,
                                           flush rest if too long */
      }
      else
        *buf=0;                         /* no value */

      if(arg[0])                        /* only if argument has been found */
      {
        if(!paramArray)                 /* no array yet? */
          paramArray = ConstructOptr( localHeap,
            ChunkArrayCreate( localHeap, 0, 0, 0 ) );
                                        /* create array for parameters */

        e = ChunkArrayAppend( paramArray, strlen(arg)+strlen(buf)+2 );
                                        /* add array for parameters (will be
                                           freed in OpenTag() or later...) */

        strcpy(e,arg);                  /* copy argument name */
        strcpy(e+strlen(arg)+1,buf);    /* append value */
      }
    }

    /* copy entry from HTML tag style definitions: */
    MemLock( OptrToHandle(@HTMLStylesChunk) );
    tagStyleEntry = ((HTMLStylesTable *)LMemDeref(@HTMLStylesChunk))[tagStyle];
    MemUnlock( OptrToHandle(@HTMLStylesChunk) );

    if(endTag)                          /* opening/closing a tag? */
      CloseTag( tagStyle, &tagStyleEntry, paramArray );
    else
      OpenTag( tagStyle, &tagStyleEntry, paramArray );

    if(c=='>')                          /* skip over trailing ">" */
      c=HTMLgetc();

    return c;                           /* pass back lookahead */
}

int _export _pascal ParseHTMLFile(ReadHTML_getc *p_gc,dword p_data,optr obj,
  HTMLextra *ext)
{
    int c;
    HTMLFILE fHTML;
    MemHandle localHeap;

    EC_BOUNDS(ext);

    localHeap = MemAllocLMem(LMEM_TYPE_GENERAL,0);

    if(!localHeap)                      /* couldn't allocate memory? */
      return 2;                         /* abort */

    MemLock(localHeap);

    tagStackO = ConstructOptr( localHeap,
      LMemAlloc(localHeap, sizeof(TagStackElement)*HTML_MAXSTACK) );
    tagCharStackO = ConstructOptr( localHeap,
      LMemAlloc(localHeap, sizeof(TagCharStackElement)*HTML_MAXSTACK) );
                                        /* allocate space for tag stacks */

    if(!(ChunkHandle)tagStackO || !(ChunkHandle)tagCharStackO)
    {
      MemFree(localHeap);
      return 2;                         /* return error */
    }

    /*
     * Transfer data to global variables for fast access
     */
    HTMLObject = obj;
    HTMLext = ext;
    gc = p_gc;
    data = p_data;

    if(!gc)                             /* standard mode: read from file */
      data = OpenFileURL(data,&fHTML);  /* open file */

    if(!gc && !data)                    /* no file available */
    {
      MemFree(localHeap);               
      return 1;                         /* return error */
    }

    /* create new anchor/image arrays */
    ext->HE_documentTitle = NullChunk;  /* no document title yet */
    ext->HE_imageArray =
      ChunkArrayCreate( HTMLext->HE_block, 0, 0, 0 );

    vcaBase = vcaDefault;               /* initialize default character style */
    linkColor = defaultLinkColor;       /* set default link color */

    /* make font/size data available globally */
    vcaBase.VTCA_pointSize.WBF_int = IntegerOf(ext->HE_pointSize);
    vcaBase.VTCA_pointSize.WBF_frac =
      (byte)(FractionOf(ext->HE_pointSize)>>8);
    vcaBase.VTCA_fontID = ext->HE_plainFont;
    fontExample = ext->HE_exampleFont;

    tagStackPtr = 0;                    /* no tags read yet */
    tagCharStackPtr = 0;

    c2='\r';
    textpos = @call HTMLObject::MSG_VIS_TEXT_GET_TEXT_SIZE();

    if( HTMLext->HE_options & HTML_ADD_MARGIN )
      AddParagraph( &vcaBase, &vpaDefault );

    lc=0;                               /* no prev character for CR/LF xlate */

    insertParagraph=FALSE;              /* no space before first line */

    MemLock( OptrToHandle(@HTMLStylesChunk) );
    GetCurrentStyles(TRUE,TRUE);        /* initialize style caching */
    MemUnlock( OptrToHandle(@HTMLStylesChunk) );

    c=HTMLgetc();                       /* get first character */
    while( c!=EOF )
    {
      {
        char buf[HTML_MAXBUF+1];

        /*
         * Parse string of characters (up to beginning of tag or newline);
         * abort immediately when buffer is full.
         */
        if( currentFlags & TAG_VERB_FORM )
          c = GetText(c,'\r',buf,TRUE,FALSE);
        else
          c = GetText(c,0,buf,FALSE,FALSE);

        /*
         * Transfer parsed characters into HTML text object
         */
        if( !(currentFlags & TAG_FLUSH_TEXT) && (*buf || c=='\r') )
        {
          AddParaCond();                /* flush pending para end */
          AddTextCurStyle(buf);         /* Add text in current style */
        }

        if( currentTopmost==SPEC_TITLE ) /* handle <TITLE> tag */
        {
          SetTitle(buf);                /* set title if requested */
          c2='\r';                      /* treat as if it was a paragraph */
        }
      }

      /*
       * Handle different reasons why parsing text was interrupted
       */
      switch(c)
      {
      case '<':                         /* text ended because of a tag */
        c = HandleTag(localHeap);       /* process the tag */
        break;

      case '>':                         /* ignore left-over closing tag */
        c = HTMLgetc();
        break;

      case '\r':                        /* pre-formatted CR? */
        EndLine("");                    /* simulate line break */
        c2 = ' ';                       /* multiple line breaks permitted */
        c = HTMLgetc();
        break;
      }

      if( MemGetInfo( HTMLext->HE_block, MGIT_SIZE ) >= 64000 )
        c = EOF;                        /* simulate EOF if memory almost full */
    }

    EndParagraph("");                   /* finish last paragraph */

    /* pop pending paragraph styles */
    while(tagStackPtr)
    {
      PopParagraphStyle();
    }

    /* pop pending character styles */
    while(tagCharStackPtr)
    {
      PopCharacterStyle(tagCharStackPtr-1);
    }

    AddParaCond();                      /* flush pending paragraph ending */

    if( HTMLext->HE_options & HTML_READ_FAST )    
      ApplyGlobalStyle( NULL );         /* fast mode: default style only */

    if(!gc)
      CloseFileURL( &fHTML );           /* close internally opened file */

    MemFree( localHeap );

    return 0;
}

int _export _pascal ParsePlainFile(ReadHTML_getc *p_gc,dword p_data,optr obj,
  HTMLextra *ext)
{
    char buf[HTML_MAXBUF];
    int c;
    word n;
    HTMLFILE fHTML;

    EC_BOUNDS(ext);

    /*
     * Transfer data to global variables for fast access
     */
    HTMLObject = obj;
    HTMLext = ext;
    gc = p_gc;
    data = p_data;

    if(!gc)                             /* standard mode: read from file */
      if( !(data = OpenFileURL(data,&fHTML)) )
                                        /* open file, data becomes file ptr */
        return 1;                       /* abort if error opening file */

    ext->HE_documentTitle = ext->HE_imageArray = NullChunk;
                                        /* no extended arrays are used */
    
    lc = 0;                             /* no prev character for CR/LF xlate */
    if( HTMLext->HE_options & HTML_ADD_MARGIN )
      @call obj::MSG_VIS_TEXT_APPEND_PTR( "\r", 0 );

    do {
      n = 0;                            /* no characters read yet */

      while( n<sizeof(buf) && (c=HTMLgetc())!=EOF )
      {
        if(c>=128)                      /* assume ISO Latin encoding */
        {
          c = TranslateCharNum(c);      /* translate char as in HTML file */
          if(c==0) c='?';
        }
        buf[n++] = (char)c;             /* read up to one buffer */
      }

      if(n)                             /* append text (if any) to object */
        @call obj::MSG_VIS_TEXT_APPEND_PTR(buf,n);
    } while(n!=0);

    if(!gc)
      CloseFileURL(&fHTML);             /* close internally opened file */

    vcaBase = vcaDefault;               /* initialize default character style */

    /* make font/size data available globally */
    vcaBase.VTCA_pointSize.WBF_int = IntegerOf(ext->HE_pointSize);
    vcaBase.VTCA_pointSize.WBF_frac =
      (byte)(FractionOf(ext->HE_pointSize)>>8);
    vcaBase.VTCA_fontID = ext->HE_plainFont;
    fontExample = ext->HE_exampleFont;

    /* default attributes for all text */
    MemLock( OptrToHandle(@HTMLStylesChunk) );
    ApplyGlobalStyle( (CharStyleDelta *)LMemDeref(@vcdMono) );
    MemUnlock( OptrToHandle(@HTMLStylesChunk) );

    return 0;
}
