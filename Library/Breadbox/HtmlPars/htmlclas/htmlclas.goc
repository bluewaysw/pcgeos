/***********************************************************************
 *
 * PROJECT:       HTMLView
 * FILE:          HTMLClas.goc
 *
 * AUTHOR:        Marcus Grï¿½ber
 *
 * NOTES:         This file implements the HTMLTextClass, which is a
 *                subclass of VisLargeTextClass. HTMLTextClass can
 *                load and display HTML data from a file, manage
 *                hyperlinks and send out notifications when the user
 *                moves the mouse over a hotspot or clicks on one.
 *                On the other hand, HTMLTextClass doesn't know
 *                anything about URLs or navigation issues.
 *
 ***********************************************************************/
@include <stdapp.goh>
@include <Objects/Text/tCtrlC.goh>
#include <initfile.h>

#include <Ansi/string.h>
#include <Ansi/stdio.h>
#include <Ansi/stdlib.h>

@include "htmlpars.goh"

#ifdef __WATCOMC__
void PurgeES();
#pragma aux PurgeES = "push cs" "pop es";

#define EC_PurgeES() EC(PurgeES())
#else
#define EC_PurgeES() EC(_asm{ push cs; pop es })
#endif

#define HTMLVIEW_CATEGORY "HTMLView"    /* Hack for saving font/size */


/*
 ***************************************************************************
 *              Utility routines
 ***************************************************************************
 */
typedef struct {
  optr text;
  word i;
} OPTRFILE;

/*ReadHTML_getc*/ int getcOptrURL(dword data)
{
    char c,*p;

    p = MemLock( OptrToHandle(((OPTRFILE *)data)->text) );

    if( OptrToChunk( ((OPTRFILE *)data)->text ) )
      p = LMemDeref( ((OPTRFILE *)data)->text );
    c = p[((OPTRFILE *)data)->i++];     /* get data and advance pointer */

    MemUnlock( OptrToHandle(((OPTRFILE *)data)->text) );

    return c?c:EOF;
}

/* required to create proper fixup: */
static ReadHTML_getc *pf_getc = getcOptrURL;

void SysNotifyWithData(void *Ptr,word size,word notificationType, word listType)
{
    MemHandle data;                     /* Extra data block sent along with the
					 * notification. */
    void *dataPtr;                      /* The extra data block, locked */
    EventHandle	notifyEvent;	    	/* Recorded notification event for
					 * the GCN list */

    data = MemAlloc(size, HF_DYNAMIC|HF_SHARABLE, 0);
                                        /* allocate space for data item */

    dataPtr = (void *)MemLock(data);
    memcpy(dataPtr,Ptr,size);           /* transfer data into shared memory */
    MemUnlock(data);

    MemInitRefCount(data, 1);

    notifyEvent = @record null::MSG_META_NOTIFY_WITH_DATA_BLOCK
                        (MANUFACTURER_ID_GEOWORKS,notificationType,
                         data);
    @call application::MSG_META_GCN_LIST_SEND
	(GCNLSF_SET_STATUS,
	 notifyEvent,
	 data,
         listType,
	 MANUFACTURER_ID_GEOWORKS);
}

/*
 ***************************************************************************
 *              HTML Viewer Object class
 ***************************************************************************
 */
@classdecl HTMLTextClass;

void HTMLTextSendNotification(optr oself,word event,word data)
{
    HTMLTextInstance *vself;
    Message msg;

    vself = ObjDerefVis(oself);
    if( vself->HTI_destination )
    {
      msg=vself->HTI_notificationMessage;
      @send vself->HTI_destination::{HTML_TEXT_EVENT_MSG}msg(oself,event,data);
    }
}

@method HTMLTextClass, MSG_HTML_TEXT_INIT_STORAGE
{
    ChunkHandle regChunk;

    regChunk = ChunkArrayCreate(OptrToHandle(oself),
      sizeof(VisLargeTextRegionArrayElement), 0, 0);
                                        /* allocate array for region data */

    pself = ObjDerefVis(oself);         /* refresh pointer */
    pself->VLTI_regionArray = regChunk; /* store pointer to region data */

    EC_PurgeES();

    @call self::MSG_VIS_TEXT_SET_VM_FILE(fileHan);
    @call self::MSG_VIS_LARGE_TEXT_CREATE_DATA_STRUCTURES();
    @call self::MSG_VIS_TEXT_CREATE_STORAGE(
      VTSF_MULTIPLE_CHAR_ATTRS | VTSF_MULTIPLE_PARA_ATTRS | VTSF_TYPES |
      VTSF_GRAPHICS,
      FALSE);
}

void FreeNameArray(optr oself)
{
    word *p;
    LMemBlockHeader *lmh;
    MemHandle mh;
    HTMLTextInstance *pself; 
    VMFileHandle vmf; 

    pself = ObjDerefVis(oself);
    vmf = pself->VTI_vmFile;

    p = ObjVarFindData( oself, ATTR_VIS_TEXT_NAME_ARRAY );
    if(p)
    {
      lmh = VMLock( vmf, *p, &mh );
      ChunkArrayZeroHandles( mh, lmh->LMBH_offset );
      LMemContract( mh );
      VMDirty( mh );
      VMUnlock( mh );
    }
}

void DeinitExtra(optr oself)
{
    HTMLTextInstance *pself;

    pself = ObjDerefVis(oself);         /* pointer to instance data */

    if(pself->HTI_documentTitle)
    {
      LMemFreeHandles(OptrToHandle(oself), pself->HTI_documentTitle);
      pself->HTI_documentTitle = NullChunk;
    }

    if(pself->HTI_imageArray)
    {
      LMemFreeHandles(OptrToHandle(oself), pself->HTI_imageArray);
      pself->HTI_imageArray = NullChunk;
    }

    FreeNameArray(oself);

    LMemContract( OptrToHandle(oself) );/* make sure block is resized */
}

int LoadFile(ReadHTML_getc *gc, dword data, optr oself, Boolean LoadAsPlain)
{
    HTMLTextInstance *pself;
    HTMLextra ext;
    int ret;

    pself = ObjDerefVis(oself);         /* pointer to instance data */

    ext.HE_block = OptrToHandle(oself); /* block to create arrays in */
    ext.HE_pointSize = pself->HTI_pointSize;
    ext.HE_plainFont = pself->HTI_plainFont;
    ext.HE_exampleFont = pself->HTI_exampleFont;
    ext.HE_options = pself->HTI_attrs | HTML_ADD_HYPERLINKS;

    if(LoadAsPlain)
      ret = ParsePlainFile( gc, data, oself, &ext );
    else
      ret = ParseHTMLFile( gc, data, oself, &ext );

    if( ret==0 )                        /* no error */
    {
      pself = ObjDerefVis(oself);       /* refresh pointer: return extra data */
      pself->HTI_documentTitle = ext.HE_documentTitle;
      pself->HTI_imageArray = ext.HE_imageArray;
    }

    return ret;
}

@method HTMLTextClass, MSG_HTML_TEXT_DEINIT_STORAGE
{
    DeinitExtra(oself);

    /*
     * Free the large text data structures and make the text object small
     * again.
     */
    @call self::MSG_VIS_TEXT_FREE_ALL_STORAGE(TRUE);
    @call self::MSG_VIS_TEXT_SET_VM_FILE(NullHandle);
}

@method HTMLTextClass, MSG_HTML_TEXT_START_LOAD
{
    NotifySearchReplaceEnableChange nsrec;
    VisTextWashColorModeRed wcModeRed = {0, CF_INDEX};
    VisTextWashColorBlueGreen wcBlueGreen = {0, 0};

    /*
     * set default wash color depending on monochrome/color mode
     */
    if(pself->HTI_attrs & HTML_MONOCHROME)
      wcModeRed.VTWCMR_redOrIndex = C_WHITE;
    else
      wcModeRed.VTWCMR_redOrIndex = C_LIGHT_GREY;

    EC_PurgeES();

    @call self::MSG_META_SUSPEND();     /* suspend updates */

    /*
     * Initialize text content
     */
    @call self::MSG_VIS_TEXT_SET_HYPERLINK( VTCF_TOKEN, CA_NULL_ELEMENT,
      CA_NULL_ELEMENT, TEXT_ADDRESS_PAST_END, 0);
                                        /* make sure that there are no links */
    @call self::MSG_VIS_TEXT_REPLACE_ALL_PTR( " ", 0 );
                                        /* remove all text (leaving one
                                           character is a workaround!) */
    DeinitExtra(oself);                 /* free old arrays */

    /*
     * Initialize color/background
     */
    @call self::MSG_VIS_TEXT_SET_WASH_COLOR( wcModeRed, wcBlueGreen );
                                        /* set default background color */
    @call self::MSG_HTML_TEXT_SET_BACKGROUND( 0, NullHandle, 0, 0 );
                                        /* free background image */

    EC_PurgeES();

    nsrec.flags = 0;
    SysNotifyWithData(&nsrec,sizeof(nsrec),
      GWNT_SEARCH_REPLACE_ENABLE_CHANGE,
      GAGCNLT_APP_TARGET_NOTIFY_SEARCH_REPLACE_CHANGE);
}

@method HTMLTextClass, MSG_HTML_TEXT_END_LOAD
{
    NotifySearchReplaceEnableChange nsrec;

    @call self::MSG_VIS_TEXT_SELECT_START();
                                        /* make sure we're looking at SOT */
    @call self::MSG_META_UNSUSPEND();

    nsrec.flags = SREF_SEARCH;
    SysNotifyWithData(&nsrec,sizeof(nsrec),
      GWNT_SEARCH_REPLACE_ENABLE_CHANGE,
      GAGCNLT_APP_TARGET_NOTIFY_SEARCH_REPLACE_CHANGE);
}

@method HTMLTextClass, MSG_HTML_TEXT_LOAD_BUF_OPTR
{
    OPTRFILE of;
    int ret;

    of.text = text;                     /* initialize block descriptor */
    of.i = 0;

    @call self::MSG_HTML_TEXT_START_LOAD();
    ret = LoadFile( pf_getc, (dword)&of, oself, FALSE );
    @call self::MSG_HTML_TEXT_END_LOAD();

    return ret;                         /* no errors */
}

@method HTMLTextClass, MSG_HTML_TEXT_LOAD_FILE
{
    FileHandle fh;
    int ret;

    @call self::MSG_HTML_TEXT_START_LOAD();

    fh = FileOpen(filePath,FILE_ACCESS_R | FILE_DENY_NONE);
    if(fh)
    {
      ret = LoadFile( NULL, (dword)fh, oself, FALSE );
      FileClose(fh,FILE_NO_ERRORS);     /* close data file */
    }
    else
      ret = 1;                          /* error opening file */

    @call self::MSG_HTML_TEXT_END_LOAD();

    return ret;                         /* return errors if any */
}

@method HTMLTextClass, MSG_HTML_TEXT_LOAD_PLAIN_BUF_OPTR
{
    OPTRFILE of;
    int ret;

    of.text = text;                     /* initialize block descriptor */
    of.i = 0;

    @call self::MSG_HTML_TEXT_START_LOAD();
    ret = LoadFile( pf_getc, (dword)&of, oself, TRUE );
    @call self::MSG_HTML_TEXT_END_LOAD();

    return ret;                         /* no errors */
}

@method HTMLTextClass, MSG_HTML_TEXT_LOAD_PLAIN_FILE
{
    FileHandle fh;
    int ret;

    @call self::MSG_HTML_TEXT_START_LOAD();

    fh = FileOpen(filePath,FILE_ACCESS_R | FILE_DENY_NONE);
    if(fh)
    {
      ret = LoadFile( NULL, (dword)fh, oself, TRUE );
      FileClose(fh,FILE_NO_ERRORS);     /* close data file */
    }
    else
      ret = 1;                          /* error opening file */

    @call self::MSG_HTML_TEXT_END_LOAD();

    return ret;                         /* return errors if any */
}

@method HTMLTextClass, MSG_HTML_TEXT_GOTO_ANCHOR
{
    dword len;
    word nameToken,typeToken;
    VisTextNameData vtnd;
    VisTextTypeDiffs diff;
    VisTextType type;
    VisTextRange range;

    len = @call self::MSG_VIS_TEXT_GET_TEXT_SIZE();
    nameToken = @call self::MSG_VIS_TEXT_FIND_NAME( &vtnd, 0, anchor );

    range.VTR_end = 0;

    do {
      @call self::MSG_VIS_TEXT_GET_RUN_BOUNDS( &range, OFFSET_FOR_TYPE_RUNS,
        range.VTR_end );
      typeToken = DWORD_TOKEN( @call self::MSG_VIS_TEXT_GET_TYPE(
        0, &diff, &type, range.VTR_end, range.VTR_start ) );
    } while( (!typeToken || type.VTT_context!=nameToken) && range.VTR_end<len );

    if( type.VTT_context==nameToken )
    {
      @call self::MSG_VIS_TEXT_SELECT_RANGE( range.VTR_start, range.VTR_start );
                                        /* if found: go there */
      return 0;                         /* success */
    }
    return 1;                           /* not successful */
}

@method HTMLTextClass, MSG_HTML_TEXT_GET_HOTSPOT
{
    NameArrayMaxElement nelm;

    struct vt_NameArrayMaxElement {
      RefElementHeader  reh;
      VisTextNameData   vtnd;
      char              name[NAME_ARRAY_MAX_NAME_SIZE];
    };

    @call self::MSG_VIS_TEXT_FIND_NAME_BY_TOKEN( number, &nelm );

    xstrncpy( buf,
      ((struct vt_NameArrayMaxElement *)&nelm)->name,
      (word)(((struct vt_NameArrayMaxElement *)&nelm)->vtnd.VTND_helpText)+1 );
                                        /* return name of hotspot */
}

@method HTMLTextClass, MSG_HTML_TEXT_GET_TITLE
{
    if(pself->HTI_documentTitle)       /* return title */
      xstrncpy( title,
        LMemDerefHandles( OptrToHandle(oself), pself->HTI_documentTitle ),
        bufsize );
    else
      *title = 0;                       /* return no title if none defined */
}

@method HTMLTextClass, MSG_HTML_TEXT_GET_IMAGE_COUNT
{
    if(!pself->HTI_imageArray)         /* no image array? */
      return 0;                         /* hence, no image */

    return
      ChunkArrayGetCountHandles( OptrToHandle(oself), pself->HTI_imageArray );
                                        /* return number of image entries */
}

@method HTMLTextClass, MSG_HTML_TEXT_GET_IMAGE
{
    word size;
    HTMLimageData *imageArrayElement;

    imageArrayElement = ChunkArrayElementToPtrHandles(
      OptrToHandle(oself), pself->HTI_imageArray, nImage, &size);
                                        /* deference token to image record */

    memcpy(data, imageArrayElement, sizeof(HTMLimageData));
    strcpy(title, imageArrayElement->name);
                                        /* return data on image */
    return TRUE;                        /* successful */
}

@method HTMLTextClass, MSG_HTML_TEXT_REPLACE_IMAGE
{
    dword pos;
    word size,len;
    HTMLimageData *imageArrayElement;

    imageArrayElement = ChunkArrayElementToPtrHandles(
      OptrToHandle(oself), pself->HTI_imageArray, nImage, &size);
                                        /* deference token to image record */

    pos = imageArrayElement->pos;
    len = imageArrayElement->len;

    imageArrayElement->len = 1;

    if( pos!=TEXT_ADDRESS_PAST_END )    /* not changing background? */
    {
      @call self::MSG_VIS_TEXT_REPLACE_WITH_GRAPHIC(
        *graphic, vmf, 0, pos+len, pos);/* replace image with graphic */
      @call self::MSG_HTML_TEXT_TRACK_REPLACE(pos, 1-len);
                                        /* update all positions */
    }
    else
      @call self::MSG_HTML_TEXT_SET_BACKGROUND(
        graphic->VTG_vmChain, vmf,
        graphic->VTG_size.XYS_width, graphic->VTG_size.XYS_height );

    return TRUE;                        /* successful */
}

@method HTMLTextClass, MSG_HTML_TEXT_MARK_IMAGE_RESOLVED
{
    word size;
    HTMLimageData *imageArrayElement;

    imageArrayElement = ChunkArrayElementToPtrHandles(
      OptrToHandle(oself), pself->HTI_imageArray, nImage, &size);
                                        /* deference token to image record */

    imageArrayElement->flags |= HTML_IDF_RESOLVED;
    return TRUE;                        /* successful */
}

@method HTMLTextClass, MSG_HTML_TEXT_TEST_UNRESOLVED_IMAGES
{
    optr array;
    HTMLimageData *imageArrayElement;
    word i,size;

    if(!pself->HTI_imageArray)          /* no image array? */
      return FALSE;                     /* hence, no images */

    array = ConstructOptr(OptrToHandle(oself), pself->HTI_imageArray);
    for(i=ChunkArrayGetCount(array)-1; (int)i>=0; i--)
    {
      imageArrayElement = ChunkArrayElementToPtr(array, i, &size);
      if( (imageArrayElement->flags & HTML_IDF_RESOLVED)==0 )
        return TRUE;                    /* found unresolved image? abort */
    }
    return FALSE;                       /* no unresolved images */
}

@method HTMLTextClass, MSG_HTML_TEXT_TRACK_REPLACE
{
    optr array;
    HTMLimageData *imageArrayElement;
    word i,size;

    if(len==0) return;                  /* zero change requires no action */

    /*
     * Update positions of images after modification.
     */
    array = ConstructOptr(OptrToHandle(oself), pself->HTI_imageArray);
    for(i=ChunkArrayGetCount(array)-1; (int)i>=0; i--)
    {
      imageArrayElement = ChunkArrayElementToPtr(array, i, &size);
      if( imageArrayElement->pos > pos &&
          imageArrayElement->pos != TEXT_ADDRESS_PAST_END )
        imageArrayElement->pos += len;
    }
}

@method HTMLTextClass, MSG_HTML_TEXT_GET_ATTRS
{
    return pself->HTI_attrs;
}

@method HTMLTextClass, MSG_HTML_TEXT_SET_ATTRS
{
    pself->HTI_attrs = attrs;
}

@method HTMLTextClass, MSG_HTML_TEXT_PREV_HOTSPOT
{
    VisTextTypeDiffs diff;
    VisTextType type;
    VisTextRange range;
    word token;
    Boolean second = FALSE;

    @call self::MSG_VIS_TEXT_GET_SELECTION_RANGE(&range);

    do {
      @call self::MSG_VIS_TEXT_GET_RUN_BOUNDS( &range, OFFSET_FOR_TYPE_RUNS,
        range.VTR_start?(range.VTR_start-1):0 );
      token = DWORD_TOKEN( @call self::MSG_VIS_TEXT_GET_TYPE( 0, &diff, &type,
        range.VTR_end, range.VTR_start) );

      if( token && type.VTT_hyperlinkName!=CA_NULL_ELEMENT )
      {                                 /* found hyperlink: show it */
        @call self::MSG_VIS_TEXT_SELECT_RANGE( range.VTR_end, range.VTR_start );
        HTMLTextSendNotification( oself, HTML_EV_HOTSPOT_PTR,
          type.VTT_hyperlinkName );
      }

      if( range.VTR_start==0 && !second)
      {                                 /* wrap around max. one time */
        second = TRUE;
        range.VTR_start = TEXT_ADDRESS_PAST_END;
      }
    } while( !(token && type.VTT_hyperlinkName!=CA_NULL_ELEMENT) &&
             range.VTR_start>0 );
}

@method HTMLTextClass, MSG_HTML_TEXT_NEXT_HOTSPOT
{
    VisTextTypeDiffs diff;
    VisTextType type;
    VisTextRange range;
    word token;
    dword len;
    Boolean second = FALSE;

    len = @call self::MSG_VIS_TEXT_GET_TEXT_SIZE();
    @call self::MSG_VIS_TEXT_GET_SELECTION_RANGE(&range);

    do {
      if( range.VTR_end>=len && !second)
      {                                 /* wrap around max. one time */
        second = TRUE;
        range.VTR_end = 0;
      }

      @call self::MSG_VIS_TEXT_GET_RUN_BOUNDS(&range, OFFSET_FOR_TYPE_RUNS,
        range.VTR_end);
      token = DWORD_TOKEN( @call self::MSG_VIS_TEXT_GET_TYPE(0, &diff, &type,
        range.VTR_end, range.VTR_start) );

      if( token && type.VTT_hyperlinkName!=CA_NULL_ELEMENT )
      {                                 /* found hyperlink: show it */
        @call self::MSG_VIS_TEXT_SELECT_RANGE( range.VTR_end, range.VTR_start );
        HTMLTextSendNotification(oself, HTML_EV_HOTSPOT_PTR,
          type.VTT_hyperlinkName);
      }
    } while( !(token && type.VTT_hyperlinkName!=CA_NULL_ELEMENT) &&
             !(range.VTR_end>=len && second) );
}

@method HTMLTextClass, MSG_HTML_TEXT_EXEC_HOTSPOT
{
    VisTextTypeDiffs diff;
    VisTextType type;
    VisTextRange range;
    dword ret;

    @call self::MSG_VIS_TEXT_GET_SELECTION_RANGE( &range );

    ret = @call self::MSG_VIS_TEXT_GET_TYPE(0, &diff, &type,
      range.VTR_end, range.VTR_start );

    if( ret && type.VTT_hyperlinkName!=CA_NULL_ELEMENT )
    {                                   /* inside a marked area? */
      HTMLTextSendNotification(oself,
        HTML_EV_HOTSPOT_SELECTED, type.VTT_hyperlinkName);

      return TRUE;                      /* we have executed a hotspot */
    }

    return FALSE;                       /* no hotspot */
}

@start POINTERRESOURCE;
  @chunk PointerDef16 HotspotPointer = {16,16,0,0,
        {
        0x7E,0x00,0xFF,0x00,0xFE,0x00,0xFE,0x00,
        0xFF,0xC0,0xFF,0xE0,0xFF,0xF0,0x4F,0xF0,
        0x07,0xF0,0x03,0xF0,0x01,0xE0,0x01,0xE0,
        0x00,0xC0,0x01,0xE0,0x01,0xE0,0x00,0xC0,
        },{
        0x7E,0x00,0x81,0x00,0x86,0x00,0x82,0x00,
        0x81,0xC0,0xA1,0x20,0xB2,0x10,0x4A,0x10,
        0x06,0x10,0x02,0x10,0x01,0x20,0x01,0x20,
        0x00,0xC0,0x01,0x20,0x01,0x20,0x00,0xC0,
        }
  };
@end POINTERRESOURCE;

word HTMLTextCheckHyperlink(optr oself,LargeMouseData *lmd,dword *posret)
{
    dword pos,len;
    VisTextTypeDiffs diff;
    VisTextType type;
    PointDWFixed p = lmd->LMD_location;

    len = @call oself::MSG_VIS_TEXT_GET_TEXT_SIZE();
    pos = @call oself::MSG_VIS_TEXT_GET_TEXT_POSITION_FROM_COORD( &p );

    /*
     * The following fix checks whether the text position returned by the
     * message represents the left or the right edge of the object under the
     * cursor. If the position was rounded to the left, the following
     * text position will be taken to ensure that the returned position is
     * always the one on the *right* side of the element which the cursor
     * is on (end of text must be handled specially to make code EC-clean).
     */
    if( p.PDF_x.DWF_int < lmd->LMD_location.PDF_x.DWF_int && pos<len )
      pos++;                            /* dropped to the left: fix position */

    if(posret)
      *posret = pos;

    if( @call oself::MSG_VIS_TEXT_GET_TYPE(0, &diff, &type, pos, pos) )
      return type.VTT_hyperlinkName;

    return CA_NULL_ELEMENT;
}

@method HTMLTextClass, MSG_META_LARGE_PTR
{
    word link;

    link = HTMLTextCheckHyperlink(oself,largeMouseDataStruct,NULL);

    if( link!=CA_NULL_ELEMENT )
    {
      HTMLTextSendNotification(oself, HTML_EV_HOTSPOT_PTR, link);
      retVal->flags = MRF_PROCESSED | MRF_SET_POINTER_IMAGE;
      retVal->ptrImage = @HotspotPointer;
      return;
    }

    HTMLTextSendNotification(oself, HTML_EV_HOTSPOT_LEFT, 0);
    @callsuper();
}

@method HTMLTextClass, MSG_META_LARGE_START_SELECT
{
    VisTextTypeDiffs diff;
    VisTextType type;
    VisTextRange range;
    dword p,ret;

    if( HTMLTextCheckHyperlink(oself,largeMouseDataStruct,&p)!=CA_NULL_ELEMENT )
    {                                   /* inside a "hot" area */
      /*
       * The following code handles the fact that the GET_ROUND_BOUNDS and
       * GET_TYPE messages react differently when faced with the edge of
       * two runs...
       */
      @call self::MSG_VIS_TEXT_GET_RUN_BOUNDS( &range, OFFSET_FOR_TYPE_RUNS,
        p?(p-1):0 );
      ret = @call self::MSG_VIS_TEXT_GET_TYPE( 0, &diff, &type,
        range.VTR_end, range.VTR_start );

      if( !ret || type.VTT_hyperlinkName==CA_NULL_ELEMENT )
      {
        @call self::MSG_VIS_TEXT_GET_RUN_BOUNDS( &range, OFFSET_FOR_TYPE_RUNS,
          p );
        ret = @call self::MSG_VIS_TEXT_GET_TYPE( 0, &diff, &type,
          range.VTR_end, range.VTR_start );
      }

      if( ret && type.VTT_hyperlinkName!=CA_NULL_ELEMENT )
      {                                 /* found a link */
        @call self::MSG_VIS_TEXT_SELECT_RANGE( range.VTR_end, range.VTR_start );

        HTMLTextSendNotification( oself,
          HTML_EV_HOTSPOT_SELECTED, type.VTT_hyperlinkName );
      }

      retVal->flags = MRF_PROCESSED;
    }
    else
      @callsuper();
}

@method HTMLTextClass, MSG_META_LARGE_START_MOVE_COPY
{
    dword pos;
    VisTextRange range;

    PointDWFixed p = largeMouseDataStruct->LMD_location;
                                        /* ..._FROM_COORD may change point */

    @call self::MSG_VIS_TEXT_GET_SELECTION_RANGE(&range);
    pos = @call self::MSG_VIS_TEXT_GET_TEXT_POSITION_FROM_COORD( &p );
                                        /* get position on which drag started */

    if( (pos<range.VTR_start || pos>=range.VTR_end) &&
      pos!=TEXT_ADDRESS_PAST_END )      /* position out of range: select it */
    {
      @call self::MSG_VIS_TEXT_GET_RUN_BOUNDS( &range,
        OFFSET_FOR_GRAPHIC_RUNS, pos );
      @call self::MSG_VIS_TEXT_SELECT_RANGE(
        range.VTR_start+1, range.VTR_start );
    }

    @callsuper();
}

@method HTMLTextClass, MSG_META_KBD_CHAR
{
    if(flags & (CF_FIRST_PRESS | CF_REPEAT_PRESS))
      switch((byte)character)           /* handle keypresses */
      {
        case VC_UP:
          @send self::MSG_HTML_TEXT_PREV_HOTSPOT();
          break;
        case VC_DOWN:
          @send self::MSG_HTML_TEXT_NEXT_HOTSPOT();
          break;
        case VC_TAB:
          if(flags & ((SS_LSHIFT | SS_RSHIFT)<<8))
            @send self::MSG_HTML_TEXT_PREV_HOTSPOT();
          else
            @send self::MSG_HTML_TEXT_NEXT_HOTSPOT();
          break;
        case VC_ENTER:
          @send self::MSG_HTML_TEXT_EXEC_HOTSPOT();
          break;
      }
    return;                             /* no key handling by VisTextClass */
}

@method HTMLTextClass, MSG_VIS_TEXT_FREE_ALL_STORAGE
{
    VisLargeTextInstance *vself;

    @callsuper();

    vself = ObjDerefVis(oself);
    vself->VTI_storageFlags &= ~VTSF_LARGE;
    vself->VI_optFlags |= VOF_GEOMETRY_INVALID;
}

typedef struct {
  struct {
    VMChainTree HTHH_tree;              /* standard tree header */
    XYSize      HTHH_backgroundSize;    /* size of background bitmap */
    VisTextGetWashColor HTHH_washColor; /* background color */
  } HTH_hdr;
  VMChain HTH_textObjTransfer;          /* VMChain with text transfer item */
  VMChain HTH_htmlObjTransfer;          /* VMChain with HTML-specifc info */
  VMChain HTH_nameTransfer;             /* VMChain with copy of name array */
  VMChain HTH_backTransfer;             /* VMChain with copy background GS */
} HTMLTransferHeader;

@method HTMLTextClass, MSG_HTML_TEXT_SAVE_CONTENTS
{
    VMBlockHandle vmb,toTrans,hoTrans,nameTrans;
    MemHandle mh;
    HTMLTransferHeader *hdr;
    ChunkHandle chunks[2];
    dword len;
    word *p;
    LMemBlockHeader *lmh;
    VMFileHandle my_vmf = pself->VTI_vmFile;

    /*
     * Create VMChain (single block) with variable size extra data
     */
    chunks[0] = pself->HTI_documentTitle;
    chunks[1] = pself->HTI_imageArray; /* collect list of chunks */

    hoTrans = ChunksToVMChainBlock(vmf,OptrToHandle(oself),chunks,2);
                                        /* copy chunks to chainable block */

    /*
     * Store name array to separate block
     */
    p = ObjVarFindData( oself, ATTR_VIS_TEXT_NAME_ARRAY );
    if(p)
    {
      lmh = VMLock( my_vmf, *p, &mh );
      chunks[0] = lmh->LMBH_offset;
      nameTrans = ChunksToVMChainBlock( vmf, mh, chunks, 1 );
      VMUnlock( mh );
    }
    else
      nameTrans = NullHandle;

    EC_PurgeES();

    len = @call self::MSG_VIS_TEXT_GET_TEXT_SIZE();
    toTrans = @call self::MSG_VIS_TEXT_CREATE_TRANSFER_FORMAT(0,vmf,0,len,0);

    /*
     * Create VMChain with description of text and formatting
     */
    vmb = VMAlloc(vmf,sizeof(HTMLTransferHeader),0x1111);
    hdr = VMLock(vmf,vmb,&mh);

    hdr->HTH_hdr.HTHH_tree.VMCT_meta.VMC_next = VM_CHAIN_TREE;
    hdr->HTH_hdr.HTHH_tree.VMCT_offset = sizeof(hdr->HTH_hdr);
    hdr->HTH_hdr.HTHH_tree.VMCT_count = 4;
    hdr->HTH_textObjTransfer = VMCHAIN_MAKE_FROM_VM_BLOCK(toTrans);
    hdr->HTH_htmlObjTransfer = VMCHAIN_MAKE_FROM_VM_BLOCK(hoTrans);
    hdr->HTH_nameTransfer = VMCHAIN_MAKE_FROM_VM_BLOCK(nameTrans);

    pself = ObjDerefVis(oself);         /* refresh pointer */
    if( pself->HTI_backgroundGString )
      hdr->HTH_backTransfer = VMCopyVMChain(
        my_vmf, pself->HTI_backgroundGString, vmf );
    else
      hdr->HTH_backTransfer = 0;

    hdr->HTH_hdr.HTHH_backgroundSize = pself->HTI_backgroundSize;
    EC_PurgeES();
    @call self::MSG_VIS_TEXT_GET_WASH_COLOR( &(hdr->HTH_hdr.HTHH_washColor) );

    VMDirty(mh);
    VMUnlock(mh);

    return VMCHAIN_MAKE_FROM_VM_BLOCK(vmb);
}

@method HTMLTextClass, MSG_HTML_TEXT_RESTORE_CONTENTS
{
    MemHandle mh;
    HTMLTransferHeader *hdr;
    VMBlockHandle toTrans,hoTrans,nameTrans;
    ChunkHandle chunks[2];
    word *p;
    LMemBlockHeader *lmh;
    VMFileHandle my_vmf = pself->VTI_vmFile;

    @call self::MSG_HTML_TEXT_START_LOAD();

    hdr = VMLock(vmf, VMCHAIN_GET_VM_BLOCK(vmc), &mh);
    toTrans = VMCHAIN_GET_VM_BLOCK(hdr->HTH_textObjTransfer);
    hoTrans = VMCHAIN_GET_VM_BLOCK(hdr->HTH_htmlObjTransfer);
    nameTrans = VMCHAIN_GET_VM_BLOCK(hdr->HTH_nameTransfer);

    EC_PurgeES();

    @call self::MSG_VIS_TEXT_SET_WASH_COLOR(
      hdr->HTH_hdr.HTHH_washColor.VTGWC_modeRed,
      hdr->HTH_hdr.HTHH_washColor.VTGWC_blueGreen);
                                        /* set background color */

    @call self::MSG_HTML_TEXT_SET_BACKGROUND(
      hdr->HTH_backTransfer, vmf,
      hdr->HTH_hdr.HTHH_backgroundSize.XYS_width,
      hdr->HTH_hdr.HTHH_backgroundSize.XYS_height );
                                        /* replace background */
    VMUnlock(mh);

    chunks[0] = chunks[1] = 0;          /* allocate new chunks */
    VMChainBlockToChunks( vmf, hoTrans, OptrToHandle(oself), chunks, 2 );
                                        /* copy chunks to chainable block */

    pself = ObjDerefVis(oself);         /* refresh pointer */
    pself->HTI_documentTitle = chunks[0];
    pself->HTI_imageArray    = chunks[1];
                                        /* collect list of chunks */

    p = ObjVarFindData( oself, ATTR_VIS_TEXT_NAME_ARRAY );
    if(nameTrans && p)
    {
      lmh = VMLock( my_vmf, *p, &mh );
      chunks[0] = lmh->LMBH_offset;     /* reusing existing name array */
      VMChainBlockToChunks( vmf, nameTrans, mh, chunks, 1 );
      VMDirty( mh );                    /* changed to name array block */
      VMUnlock( mh );
    }

    EC_PurgeES();

    @call self::MSG_VIS_TEXT_REPLACE_WITH_TEXT_TRANSFER_FORMAT(
      toTrans, vmf, 0, 0, 0);          /* replace content with new text */

    @call self::MSG_HTML_TEXT_END_LOAD();
}

/********************************************************************
 *              MSG_PRINT_GET_DOC_NAME
 ********************************************************************
 * SYNOPSIS:     Sent by the PrintControl before it spools the
 *               print job. Must send back a job "name" or it won't
 *               print.
 * CALLED BY:    PrintControl
 * PARAMETERS:   optr printCtrlOD
 * RETURNS:      void
 * SIDE EFFECTS: none
 * STRATEGY:     Set the name of the print job. If we don't handle
 *               this message then the print job will be cancelled
 *               by the spooler.
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      NF      9/5/92          Initial version
 *      MG      11/11/96        Modified for use with HTMLTextClass
 *******************************************************************/
@method HTMLTextClass, MSG_PRINT_GET_DOC_NAME
{
    char title[HTML_MAXBUF];

    @call self::MSG_HTML_TEXT_GET_TITLE( title, sizeof(title) );
    @call printCtrlOD::MSG_PRINT_CONTROL_SET_DOC_NAME( (*title)? title:"?" );
}

/********************************************************************
 *              MSG_PRINT_START_PRINTING
 ********************************************************************
 * SYNOPSIS:     Print the text object.
 * CALLED BY:    PrintControl
 * PARAMETERS:   optr         printCtrlOD
 *               GStateHandle gstate
 * RETURNS:      void
 * SIDE EFFECTS: none
 * STRATEGY:     Get printer margins, then send MSG_VIS_DRAW to
 *               text object with the DF_PRINT flag, then signal
 *               printing completed. Well, okay, it's a lot more
 *               than just that...
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      NF      4/1/95          Initial version
 *      MG      11/11/96        Modified for use with HTMLTextClass
 *******************************************************************/
@method HTMLTextClass, MSG_PRINT_START_PRINTING
{
      /*
       * iCurPage   - Current page being printed.
       * cNumPages  - Number of regions in text object (pages).
       * sPageSize  - Size of page from PrintControl.
       * pageWidth  - Width of paper.
       * pageHeight - Height of print area in points.
       * bContinue  - Indicates when to stop printing.
       * textSize   - Image size of text.
       * regPos     - Returned by MSG_VIS_LARGE_TEXT_GET_REGION_POS.
       *              Used to find the size of the text regions.
       */
    dword                                iCurPage;
    int                                  cNumPages;
    PageSizeReport                       sPageSize;
    word                                 pageWidth;
    dword                                pageHeight;
    Boolean                              bContinue;
    XYValueAsDWord                       textSize;
    VisLargeTextGetRegionPosReturnStruct regPos;

      /*
       * Get the paper size as set by the user and find the
       * page width and height without margins. Then set the
       * document size to reflect the current paper size.
       */
    if( pself->HTI_pageSizeControlOD )
      @call pself->HTI_pageSizeControlOD::MSG_PZC_GET_PAGE_SIZE( &sPageSize );
    else
      @call printCtrlOD::MSG_PRINT_CONTROL_GET_PAPER_SIZE_INFO( &sPageSize );

    EC_PurgeES();

    pageWidth  = sPageSize.PSR_width -
                 sPageSize.PSR_margins.PCMP_left -
                 sPageSize.PSR_margins.PCMP_right;
    pageHeight = sPageSize.PSR_height -
                 sPageSize.PSR_margins.PCMP_top -
                 sPageSize.PSR_margins.PCMP_bottom;

    @call printCtrlOD::MSG_PRINT_CONTROL_SET_DOC_SIZE(
        sPageSize.PSR_width, sPageSize.PSR_height );

      /*
       * Save text image size.
       * Set text width to printer page width.
       */
    textSize = @call self::MSG_VIS_LARGE_TEXT_GET_DRAFT_REGION_SIZE( 0 );
    @send self::MSG_VIS_LARGE_TEXT_SET_DRAFT_REGION_SIZE(
        pageWidth, pageHeight );

      /*
       * Set the number of pages to print by finding
       * the number of regions in the VisLargeText.
       */
    cNumPages = @call self::MSG_VIS_LARGE_TEXT_GET_REGION_COUNT();
    @call printCtrlOD::MSG_PRINT_CONTROL_SET_TOTAL_PAGE_RANGE(
        1, cNumPages );

      /*
       * This loop is from Concepts Code Display 23-1 on p809.
       * It is the main printing loop. It translates the text up
       * one page at a time while printing it. Actually, it
       * translates it one page the first time, two pages the
       * second time, three pages the third time, and so on.
       */
    for ( iCurPage = 0; iCurPage < cNumPages; iCurPage++ ) {
          /*
           * Check if the user wants to cancel printing.
           * If so, break out of the loop before we print
           * the current page.
           */
        bContinue = @call printCtrlOD::
            MSG_PRINT_CONTROL_REPORT_PROGRESS( PCPT_PAGE, iCurPage+1 );
        if ( !bContinue ) {
            break;
        }
          /*
           * Get the start position of the top of
           * the current page. We'll use it for translating
           * the text object upwards in order to
           * print the page we want.
           */
        GrSaveState( gstate );
        @call self::MSG_VIS_LARGE_TEXT_GET_REGION_POS( &regPos, iCurPage );
          /*
           * Set the clip region so we only include
           * exactly the height of this page. That is,
           * if the user has a page break in the text,
           * that will shorten the height of the page.
           * If we were to print more than the real height,
           * we'd get the text from the next page as well. Change
           * the sixth parameter to pageHeight to see what I mean.
           */
        GrSetClipRect( gstate, PCT_REPLACE,
                       sPageSize.PSR_margins.PCMP_left,
                       sPageSize.PSR_margins.PCMP_top,
                       pageWidth + sPageSize.PSR_margins.PCMP_right,
                       regPos.VLTGRPRS_height +
                       sPageSize.PSR_margins.PCMP_bottom );
          /*
           * Shift text up iCurPage pages and draw text.
           * Have printer form feed the page.
           */
        GrApplyTranslationDWord( gstate, sPageSize.PSR_margins.PCMP_left,
                                 -( regPos.VLTGRPRS_yPosition -
                                    sPageSize.PSR_margins.PCMP_top ) );
        GrInitDefaultTransform( gstate );
        @call self::MSG_VIS_DRAW( DF_PRINT, gstate );
        GrRestoreState( gstate );
        GrNewPage( gstate, PEC_FORM_FEED );
    } /* for iCurPage */

      /*
       * Restore previous text width and height.
       */
    @send self::MSG_VIS_LARGE_TEXT_SET_DRAFT_REGION_SIZE(
        DWORD_X( textSize ), DWORD_Y( textSize ) );

      /*
       * Wrap up the printing (tell PrintControl if
       * done printing or if user cancelled).
       */
    if ( FALSE == bContinue ) {
        @send printCtrlOD::MSG_PRINT_CONTROL_PRINTING_CANCELLED();
    }
    else {
        @send printCtrlOD::MSG_PRINT_CONTROL_PRINTING_COMPLETED();
    }
}

@method HTMLTextClass, MSG_VIS_TEXT_SET_POINT_SIZE
{
    NotifyPointSizeChange npsc;

    pself->HTI_pointSize = *(WWFixedAsDWord *)&pointSize;

    /* pass around info about current font size */
    npsc.NPSC_pointSize = pself->HTI_pointSize;
    npsc.NPSC_diffs = 0;
    SysNotifyWithData(&npsc,sizeof(npsc),
                      GWNT_POINT_SIZE_CHANGE,
                      GAGCNLT_APP_TARGET_NOTIFY_POINT_SIZE_CHANGE);
}

@method HTMLTextClass, MSG_HTML_TEXT_GET_POINT_SIZE
{
    return pself->HTI_pointSize;
}

@method HTMLTextClass, MSG_VIS_TEXT_SET_FONT_ID
{
    NotifyFontChange nfc;

    pself->HTI_plainFont = fid;

    /* pass around info about current font */
    nfc.NFC_fontID = pself->HTI_plainFont;
    nfc.NFC_diffs = 0;
    SysNotifyWithData(&nfc,sizeof(nfc),
                      GWNT_FONT_CHANGE,
                      GAGCNLT_APP_TARGET_NOTIFY_FONT_CHANGE);
}

@method HTMLTextClass, MSG_HTML_TEXT_GET_FONT_ID
{
    return pself->HTI_plainFont;
}

@method HTMLTextClass, MSG_HTML_TEXT_SAVE_OPTIONS
{
    char buf[6];

    sprintf(buf, "%u", @call self::MSG_HTML_TEXT_GET_FONT_ID());
    InitFileWriteString( HTMLVIEW_CATEGORY, "defaultFont", buf);
    sprintf(buf, "%u", IntegerOf(@call self::MSG_HTML_TEXT_GET_POINT_SIZE()));
    InitFileWriteString( HTMLVIEW_CATEGORY, "defaultPointSize", buf);
}

@method HTMLTextClass, MSG_META_GAINED_TARGET_EXCL
{
    NotifyFontChange nfc;
    NotifyPointSizeChange npsc;

    nfc.NFC_fontID = pself->HTI_plainFont;
    nfc.NFC_diffs = 0;
    npsc.NPSC_pointSize = pself->HTI_pointSize;
    npsc.NPSC_diffs = 0;

    SysNotifyWithData(&nfc,sizeof(nfc),
                      GWNT_FONT_CHANGE,
                      GAGCNLT_APP_TARGET_NOTIFY_FONT_CHANGE);

    SysNotifyWithData(&npsc,sizeof(npsc),
                      GWNT_POINT_SIZE_CHANGE,
                      GAGCNLT_APP_TARGET_NOTIFY_POINT_SIZE_CHANGE);

    @callsuper();                       /* let superclass do its thing... */
}

@method HTMLTextClass, MSG_VIS_DRAW
{
    GStateHandle gs;
    sword x,y,lx,ly;
    Rectangle clip;

    if( pself->HTI_backgroundGString ) /* special handling if background */
    {
      GrGetMaskBounds( gstate, &clip );

      lx = (clip.R_left / pself->HTI_backgroundSize.XYS_width)*
        pself->HTI_backgroundSize.XYS_width;
      ly = (clip.R_top / pself->HTI_backgroundSize.XYS_height)*
        pself->HTI_backgroundSize.XYS_height;

      gs = GrLoadGString( pself->VTI_vmFile, GST_VMEM,
        VMCHAIN_GET_VM_BLOCK(pself->HTI_backgroundGString) );

      for(y=ly; y<clip.R_bottom; y+=pself->HTI_backgroundSize.XYS_height)
        for(x=lx; x<clip.R_right; x+=pself->HTI_backgroundSize.XYS_width)
          GrDrawGString( gstate, gs, x, y, 0, NULL );

      GrDestroyGString( gs, gstate, GSKT_LEAVE_DATA );
    }

    @callsuper();
}

@method HTMLTextClass, MSG_VIS_TEXT_SCREEN_UPDATE
{
    if( pself->HTI_backgroundGString ) /* special handling if background */
    {
      EC_PurgeES();

      @callsuper();
      @call self::MSG_VIS_REDRAW_ENTIRE_OBJECT();
    }
    else
    {
      EC_PurgeES();

      @callsuper();
    }
}

@method HTMLTextClass, MSG_HTML_TEXT_SET_BACKGROUND
{
#if 0
    WindowHandle win;
    optr view;
#endif

    if( pself->HTI_backgroundGString ) /* remove old background if any */
    {
      VMFreeVMChain( pself->VTI_vmFile, pself->HTI_backgroundGString );
      pself->HTI_backgroundGString = 0;
    }

    if( block )                         /* passed a new background? */
    {
      pself->HTI_backgroundGString =
        VMCopyVMChain( pself->VTI_vmFile, block, pself->VTI_vmFile );
      pself->HTI_backgroundSize.XYS_width = width;
      pself->HTI_backgroundSize.XYS_height = height;

#if 0
      view = pself->HTI_myView;         /* associated view */
#endif

      EC_PurgeES();

      @call self::MSG_VIS_TEXT_SET_FEATURES( VTF_TRANSPARENT, 0 );
#if 0
      if( view )                        /* relay wash color to view? */
      {
        win = @call view::MSG_GEN_VIEW_GET_WINDOW();
        WinSetInfo( win, WIT_COLOR, WCF_TRANSPARENT<<8 );
                                        /* set view's window to transparent */
      }
#endif
    }
    else
      @call self::MSG_VIS_TEXT_SET_FEATURES( 0, VTF_TRANSPARENT );

    pself = ObjDerefVis(oself);         /* refresh pointer */
    if( (pself->VTI_intFlags & VTIF_SUSPENDED)==0 )
      @call self::MSG_VIS_REDRAW_ENTIRE_OBJECT();
                                        /* redraw if not suspended */
}

@method HTMLTextClass, MSG_VIS_TEXT_SET_WASH_COLOR
{
    if( (pself->VTI_intFlags & VTIF_SUSPENDED)==0 && pself->HTI_myView )
                                        /* relay wash color to view? */
      @call (pself->HTI_myView)::MSG_GEN_VIEW_SET_COLOR(
        modeRed.VTWCMR_redOrIndex, modeRed.VTWCMR_mapMode,
        *(word *)&blueGreen);           /* update view's color */

    EC_PurgeES();

    @callsuper();
}

@method HTMLTextClass, MSG_META_UNSUSPEND
{
    VisTextSuspendData *vtsd;

    vtsd = (VisTextSuspendData *)ObjVarFindData( oself,
      ATTR_VIS_TEXT_SUSPEND_DATA );     /* get info about suspend state */

    if( vtsd && vtsd->VTSD_count==1 && pself->HTI_myView )
    {                                   /* about to unsuspend? */
      @call (pself->HTI_myView)::MSG_GEN_VIEW_SET_COLOR(
        pself->VTI_washColor.CQ_redOrIndex, pself->VTI_washColor.CQ_info,
        ((word)pself->VTI_washColor.CQ_blue<<8)|pself->VTI_washColor.CQ_green);
                                        /* update view's color */
    }

    @callsuper();
}
