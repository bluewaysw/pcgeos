/***********************************************************************
 *
 * Copyright (C) 1998 Breadbox Computer Company
 *
 * PROJECT:       WebMagick
 * FILE:          wmg3http.goc
 *
 * AUTHOR:        Marcus Grï¿½ber
 *                originally based on HTGET 1.01 by Ken Yap
 *
 ***********************************************************************/

/**************************************************************************
 *                Include files
 **************************************************************************/
@include <stdapp.goh>
@include <library.h>
#include <Ansi/string.h>
#include <Ansi/stdio.h>
#include <Ansi/stdlib.h>
#include <Ansi/ctype.h>


@include "wmg3con.goh"

#ifdef SSL_ENABLE
    #include <ssl.h>
#endif

#ifdef COOKIE_ENABLE
#include <lmem.h>
#include <chunkarr.h>
#include <Internal/netutils.h>
#include <timedate.h>
#include <cookies.h>
#endif

#if 0
#ifdef COOKIE_ENABLE
    #include <lmem.h>
    #include <chunkarr.h>
    #include <Internal/netutils.h>

    void _far _pascal InitCookies(void);
void _far _pascal CleanupCookies(void);
void _far _pascal ParseCookie(T_HTTPConnection *anchor, char *cTxt);
optr _far _pascal FindCookies(T_HTTPConnection *anchor);
void _far _pascal WriteCookies(void);

/* not really cookie related, but ParseTime is included only for cookies,
   used for handling Expires: */
    #include <timedate.h>
void _far _pascal ParseTime(char *p, TimerDateAndTime *t);
#endif
#endif

#ifdef SOCKET_CLOSE_THREAD
#define SOCKET_CLOSE_STACK_SIZE 500
@class SocketCloseProcessClass, ProcessClass;
@message void MSG_SOCKET_CLOSE(Socket sock);
@endc
#endif

/**************************************************************************
 *        Global and local state variables
 **************************************************************************/

typedef struct {
    TCHAR pwdhost[URL_MAX_SERVER+1];
    word port;
    TCHAR userpwd[URL_MAX_USERNAME+URL_MAX_PASSWORD+2];
} HTTPPassword;

SemaphoreHandle G_syncPassword = NullHandle ;
MemHandle G_passwordBlock = NullHandle;

#ifdef SSL_ENABLE
static SSL_CTX *ssl_ctx;
SemaphoreHandle sslSem;
#endif

TCHAR videoStr[30] = _TEXT("");
TCHAR osVerStr[20] = _TEXT("");
TCHAR langStr[10] = _TEXT("");
TCHAR countryStr[10] = _TEXT("");

#if PROGRESS_DISPLAY
word progressMinCL = PROGRESS_DEFAULT_CL;
#endif

#ifdef PERSISTANT_CONNECTIONS
/* use HTTP 1.0 persistant connections, far fewer servers support this */
//#define HTTP10_PERSIST
/* allow persistant connections */
Boolean persistantConnections = TRUE;
/* socket cache */
MemHandle socketCacheBlock = NullHandle;
/* socket cache access semaphore */
SemaphoreHandle socketCacheSem = NullHandle;
/* this string is null'ed if persistantConnections == FALSE */
char persistHeader[] = "Connection: Keep-Alive\r\n";
#ifdef HTTP10_PERSIST
/* use HTTP 1.0 since:
   1) HTTP 1.0 has support for partial persistant connections
   2) we don't fully support Transfer-Coding: chunked as we don't
      handle trailers
   3) unlike HTTP 1.1, we don't assume that all connections are
      persistant, only those that return Connection: Keep-Alive
   4) as HTTP 1.0 client, we don't request persistant connection when
      using a proxy server
*/
char httpVer[] = HTTPVER10;
#else
/* use HTTP 1.1 since:
   1) far more servers support persistant connections over HTTP 1.1
   2) we don't care about any trailers (we ignore them all)
   3) there is no danger being safe on the non-persistant side
*/
char httpVer[] = HTTPVER11;
#endif
/* video string build semaphore */
SemaphoreHandle buildVideoStrSem = NullHandle;

#ifdef SOCKET_CLOSE_THREAD

ThreadHandle closeThread = NullHandle;
dword closeStart = 0L;

#define CLOSE_TOO_LONG (5L*60L)  /* 5 seconds */

void CloseSocketNow(Socket sock)
{
/*    SocketReset(sock);*/
    SocketClose(sock);
}

void CloseSocket(Socket sock)
{
    if (closeThread &&
	/* only if we are not taking too long for the current close
	   (there is a slim chance of checking incorrectly here if
	   the close thread is update the closeStart value, but if
	   we decide incorrectly in this case, that's fine, the problem
	   case we want to detect is a blocked close thread, in which case
	   the closeStart value won't be changing) */
	(!closeStart || (TimerGetCount()-closeStart < CLOSE_TOO_LONG))) {
	@send, forceQueue ConstructOptr(closeThread, 0)::MSG_SOCKET_CLOSE(sock);
    } else {
	CloseSocketNow(sock);
    }
}

@ifdef SOCKET_CLOSE_THREAD

@classdecl SocketCloseProcessClass;

@method SocketCloseProcessClass, MSG_SOCKET_CLOSE
{
    closeStart = TimerGetCount();  /* mark start time */
    CloseSocketNow(sock);
    closeStart = 0L;  /* done */
}

@endif

#else

void CloseSocket(Socket sock)
{
/*    SocketReset(sock);*/
    SocketClose(sock);
}

#define CloseSocketNow(s) CloseSocket(s)

#endif

int sock_getline(HTTPConnectionHandle conn, T_HTTPConnection **retptr);
#endif

TCHAR *xstrncpy(TCHAR *dst, TCHAR *src, word bufsize)
{
    strncpy(dst,src,bufsize-1);
    dst[bufsize-1] = 0;
    return dst;
}

@ifdef DO_DBCS
TCHAR *xstrncpysbcstodbcs(TCHAR *dst, char *src, word bufsize)
{
    int i;

    for (i = 0; i < bufsize-1; i++) {
	dst[i] = src[i];
	if (src[i] == 0) break;
    }
    dst[bufsize-1] = 0;
    return dst;
}
@endif

void ChunkStrcpy(MemHandle mh, ChunkHandle *ch, TCHAR *str)
{
    MemLock(mh);

    /* Note that *ch may not be in the block pointed to by mh, because the
       heap is likely to move when allocating a new buffer. */

    if (*ch)                             /* already some string? overwrite */
        LMemReAllocHandles(mh, *ch, strlen(str)+1);
    else                                /* allocate new chunk */
        *ch = LMemAlloc(mh, strlen(str)+1);

    strcpy(LMemDerefHandles(mh, *ch), str);

    MemUnlock(mh);
}

@ifdef DO_DBCS
void strcpysbcstodbcs(TCHAR *dbcs, char *sbcs)
{
    while(*sbcs) {
	*dbcs++ = *sbcs++;
    }
    *dbcs = 0;
}

void ChunkStrcpySBCS(MemHandle mh, ChunkHandle *ch, char *str)
{
    MemLock(mh);

    /* Note that *ch may not be in the block pointed to by mh, because the
       heap is likely to move when allocating a new buffer. */

    if (*ch)                             /* already some string? overwrite */
        LMemReAllocHandles(mh, *ch, (strlensbcs(str)+1)*2);
    else                                /* allocate new chunk */
        *ch = LMemAlloc(mh, (strlensbcs(str)+1)*2);

    strcpysbcstodbcs(LMemDerefHandles(mh, *ch), str);

    MemUnlock(mh);
}

Boolean UtilAsciiToHex32SBCS(const char *s, sdword *h)
{
    TCHAR dbcs[11];  /* 10 digits is enough for dword */
    xstrncpysbcstodbcs(dbcs, s, 11);
    return UtilAsciiToHex32(dbcs, h);
}

/* only need match/no-match */
sword LocalCmpStringsNoCaseSBCS(const char *s1, const char *s2, word len)
{
    int i;

    /* we only care about ASCII cases */
    for (i = 0; i < len; i++) {
	if (toupper(s1[i]) != toupper(s2[i])) return -1;  /* no-match */
    }
    return 0;  /* match */
}
@endif

optr ToolsFormatMessage(optr msg,TCHAR *res)
{
    word size;
    MemHandle mh;
    TCHAR *dst;

    MemLock(OptrToHandle(msg));         /* copy message to new data block */

    size = (strlen(LMemDeref(msg))+2)*sizeof(TCHAR);    /* basic size of HTML message */
    if (res)                             /* insert error message? */
        size += (2*strlen((char *)res))*sizeof(TCHAR);    /* leave room for two messages */

    mh = MemAlloc(size, HF_DYNAMIC, HAF_NO_ERR);
    dst = MemLock(mh);
    if (res)                             /* paste error message into block */
        /* there is no danger with too many args, needed for special errors */
        sprintf(dst, LMemDeref(msg), (TCHAR *)res, (TCHAR *)res);
    else
        strcpy(dst, LMemDeref(msg));
    MemUnlock(mh);

    MemUnlock(OptrToHandle(msg));

    return ConstructOptr(mh,0);         /* return optr to data block */
}

Boolean ToolsParseURL(TCHAR *url, TCHAR *type, TCHAR *server, TCHAR *path)
{
    word i,j;

    for (i=j=0; isalpha(url[i]); i++)
        if (type && j < URL_MAX_TYPE-1)
            type[j++] = toupper((unsigned char)url[i]);
        /* copy potential "type" to buffer */

    if (url[i] == ':' && i > 1 && i <= URL_MAX_TYPE-1) {                                   /* looks like a valid type? */
        if (type)
            type[j] = 0;                    /* terminate type string */
        url += i+1;                       /* advance to position after ":" */
    } else if (type)
        *type = 0;                        /* discard misread type info */

    if (url[0] == '/' && url[1] == '/') {  /* server name follows */
        url += 2;                         /* skip over "//" */
        for (i=j=0; url[i] && url[i] != '/' && url[i] != '?' ; i++)
            if (server && j < URL_MAX_SERVER-1)
                server[j++] = url[i];         /* copy server name */

        if (server)
            server[j] = 0;                  /* terminate server name */
        url += i;                         /* skip over server name */
    } else if (server)
        *server = 0;

    if (url[0]) {                          /* can only be a filename now... */
        for (i=j=0; url[i]; i++)
            if (path && j < HTML_MAX_BUF-1) {
		if (i == 0 && url[i] == '?' && *server) {
		    /* ensure we have root if we only have server and args */
		    path[j++] = '/';
		    path[j++] = '?';
		} else {
		    path[j++] = (url[i]=='\\') ? '/' : url[i];
		}
	    }
            /* copy path normalizing slashes */
        if (path)
            path[j] = 0;                    /* terminate path name */
        url += i;
    } else if (path)
        *path = 0;

    return TRUE;                        /* URL has been parsed */
}

int SocketRecvNice(
    HTTPConnectionHandle conn,
    int bufSize,
    int timeout)
{
    int count;
    int i ;
    int ret = -1;
    word error ;
    T_HTTPConnection *p_conn ;

    /* Connection is assumed to be unlocked at this point */
/*    count = timeout/60 ;*/
    count = timeout/5 ;
    if (count == 0) count++;
    for (i=0; i<=count; i++) {

        /* Do a receive -- but quickly to keep the resources from */
        /* staying locked. */
        p_conn = ConnectionLock(conn) ;
        if (!p_conn->aborted) {
#ifdef SSL_ENABLE
            if (p_conn->secure) {
                ret = SSL_read(p_conn->ssl, p_conn->buffer, bufSize);
                if ((ret < 0) && (ThreadGetError() == SE_CONNECTION_CLOSED)) {
                    /* let error handling below do its work */
                    ret = 0;
                }
            } else {
                ret = SocketRecv(p_conn->sock, p_conn->buffer, bufSize, 1, 0, NULL) ;
            }
#else
            ret = SocketRecv(p_conn->sock, p_conn->buffer, bufSize, 1, 0, NULL) ;
#endif
        } else {
            ret = -1;                     /* abort: get back with error */
        }
        error = ThreadGetError() ;
	p_conn->sockErr = error;
        ConnectionUnlock(conn) ;

        if (ret == 0) {                /* got no data... */
            if (error != SE_TIMED_OUT) {  /* something has happened */
#ifdef SSL_ENABLE
                if (error && (error != SE_CONNECTION_CLOSED))
#else
                if (error != SE_CONNECTION_CLOSED)
#endif
                    ret = -1;           /* return -1 for unknown problem */
                break ;
            } else {
                ret = -1;               /* timeout is also a real problem... */
            }

            /* Don't stay in the sub-routine, wait a while, then next try. */
/*            TimerSleep(59) ;*/
            TimerSleep(5) ;
        } else {
            break ;
        }
    }

    return ret ;
}

#ifdef PERSISTANT_CONNECTIONS
int htoi(char *str)
{
    int val = 0;

    while(1) {
	if (*str >= '0' && *str <= '9') {
	    val = val*16 + ((*str++)-'0');
	} else if (*str >= 'a' && *str <= 'f') {
	    val = val*16 + ((*str++)-'a')+10;
	} else if (*str >= 'A' && *str <= 'F') {
	    val = val*16 + ((*str++)-'A')+10;
	} else {
	    break;
	}
    }
    return val;
}
#endif

int SocketGetBlock(
    HTTPConnectionHandle conn,
    T_HTTPConnection **pp_conn, Boolean noWait)
{
    int size ;
#ifdef PERSISTANT_CONNECTIONS
    int chunkSizeLine;
    int readSize = sizeof((*pp_conn)->buffer);
    Boolean done = FALSE;

    if ((*pp_conn)->chunked) {
	if ((*pp_conn)->chunkSize == 0) {
	    /* read chunk-size */
	    chunkSizeLine = sock_getline(conn, pp_conn);
	    if (chunkSizeLine < 0) {
		/* error reading */
		return -1;
	    }
	    if (chunkSizeLine == 0) {
		/* we just got CRLF after a full chunk has been read,
		   now read next chunk size */
		if (sock_getline(conn, pp_conn) <= 0) {
		    /* error reading */
		    return -1;
		}
	    }
	    (*pp_conn)->chunkSize = htoi((*pp_conn)->buffer);
	    if ((*pp_conn)->chunkSize == 0) {
		/* read entity headers */
		while (sock_getline(conn, pp_conn) > 0) {
		    /* XXX */
		}
		done = TRUE;
	    }
	}
	if (readSize > (*pp_conn)->chunkSize) {
	    readSize = (*pp_conn)->chunkSize;
	}
	if (readSize) {
	    ConnectionUnlock(conn);
	    size = SocketRecvNice(conn, readSize, noWait ? 0 : HTTP_TIMEOUT);
	    *pp_conn = ConnectionLock(conn);
	} else {
	    size = 0;
	}
	if (size >= 0 && !done) {
	    /* accept new chunk data */
	    (*pp_conn)->chunkSize -= size;
	}
    } else {
	ConnectionUnlock(conn);
	size = SocketRecvNice(conn, readSize, noWait ? 0 : HTTP_TIMEOUT);
	*pp_conn = ConnectionLock(conn);
    }
#else
    /* SocketRecvNice needs to have the block unlocked.  This routine */
    /* assumes the block is locked once */
    ConnectionUnlock(conn) ;
    size = SocketRecvNice(conn, sizeof((*pp_conn)->buffer), noWait ? 0 : HTTP_TIMEOUT) ;
    *pp_conn = ConnectionLock(conn) ;
#endif

    return size ;
}

#ifdef PERSISTANT_CONNECTIONS
void RemoveSocketCacheEntry(SocketCacheEntry *sc)
{
    sc->host[0] = 0;
    sc->inUse = FALSE;
    sc->socket = 0;  /* release cache slot */
}

void RemoveSocketFromCache(T_HTTPConnection *p_conn)
{
    int i;
    SocketCacheEntry *sc;

    if (!socketCacheBlock) return;
    ThreadPSem(socketCacheSem);  /* use MemPLock instead? */
    sc = MemLock(socketCacheBlock);
    for (i = 0; i < NUM_CACHED_SOCKETS; i++) {
	if (sc[i].socket == p_conn->sock) {
	    RemoveSocketCacheEntry(&sc[i]);
	    p_conn->socketFromCache = FALSE;
	    break;
	}
    }
    MemUnlock(socketCacheBlock);
    ThreadVSem(socketCacheSem);
}

#if ERROR_CHECK
void EnsureSocketNotCached(T_HTTPConnection *p_conn)
{
    int i;
    SocketCacheEntry *sc;

    if (!socketCacheBlock) return;
    ThreadPSem(socketCacheSem);
    sc = MemLock(socketCacheBlock);
    for (i = 0; i < NUM_CACHED_SOCKETS; i++) {
	EC_ERROR_IF(sc[i].socket == p_conn->sock, -1);
    }
    MemUnlock(socketCacheBlock);
    ThreadVSem(socketCacheSem);
}
#endif
#endif

/* Close socket in a way that hopefully avoids blocking if the other side
   doesn't respond... */
#ifdef SSL_ENABLE
void SocketMyClose(T_HTTPConnection *p_conn)
{
    if (p_conn->sock) {
#ifdef PERSISTANT_CONNECTIONS
#if ERROR_CHECK
	/* The socket should not be in the cache at this point. */
	EnsureSocketNotCached(p_conn);
#endif
#endif
        if (p_conn->secure && p_conn->ssl) {
            SSL_shutdown(p_conn->ssl);
            SSL_free(p_conn->ssl);
        }
	CloseSocket(p_conn->sock);
        p_conn->sock = NullHandle;
    }
}
#else
void SocketMyClose(Socket sock)
{
    CloseSocket(sock);
}
#endif


/**************************************************************************
 *        Message strings
 **************************************************************************/
@start  HTMLResource, data;
@chunk TCHAR MsgOpenErr[] = _TEXT(
    "<! error7.htm><! %s>"
    "<H1>Error opening medium</H1>"
    "The physical connection connection could not be established. "
    "[Socket error code: %s]");
@chunk TCHAR MsgResolveErr[] = _TEXT(
    "<! error8.htm><! %s>"
    "<H1>Error locating host</H1>"
    "The host address could not be determined, or the modem connection "
    "was not established. [Socket error code: %s]");
/* most likely other resolver error is phone line, accpnt problems */
@chunk TCHAR MsgResolveLinkErr[] = _TEXT(
    "<! error20.htm>"
    "<H1>Check Internet settings and phone line</H1>"
    "Could not establish a connection. Make sure your "
    "Internet settings are correct. Make sure your phone line is plugged "
    "in and working.");
@chunk TCHAR MsgConnectErr[] = _TEXT(
    "<! error9.htm><! %s>"
    "<H1>Error contacting host</H1>"
    "A connection to the requested host could not be established. "
    "[Socket error code: %s]");
@chunk TCHAR MsgReceiveErr[] = _TEXT(
    "<! error10.htm><! %s>"
    "<H1>Error getting data</H1>"
    "There was a problem receiving the requested data.<BR>"
    "The error message was '<CODE>%s</CODE>'.");
@chunk TCHAR Msg404Err[] = _TEXT(
    "<! error16.htm><! %s>"
    "<H1>Error getting data</H1>"
    "There was a problem receiving the requested data.<BR>"
    "The error message was '<CODE>%s</CODE>'.");

@chunk TCHAR MsgInterrupt[] = _TEXT(
    "<! error11.htm>"
    "<H1>Transmission interrupted</H1>");
@chunk TCHAR MsgPostErr[] = _TEXT(
    "<! error12.htm>"
    "<H1>ERROR:  Cannot POST data</H1>"
    "The attempt to send data to the server has failed.");
@chunk TCHAR MsgFileError[] = _TEXT(
    "<! error13.htm>"
    "<H1>Temporary File Error</H1>"
    "The data received could not be stored in a local file. One possible "
    "cause for this is the storage medium having run out of space.");
@chunk TCHAR MsgNoData[] = _TEXT(
    "<! error14.htm>"
    "<H1>Empty document</H1>"
    "The request was answered by the server, but no actual data "
    "has been returned.");
@chunk TCHAR MsgBadLength[] = _TEXT(
    "<! error15.htm>"
    "<H1>Bad document size</H1>"
    "The request didn't return as much data as the other side indicated. This "
    "is either an error on the side of the remote server or the result of a "
    "transmission error.");

@end    HTMLResource;


@start  StatusResource, data;
@chunk TCHAR StatusLocating[] = _TEXT("Locating host.");
@chunk TCHAR StatusContacting[] = _TEXT("Contacting host.");
@chunk TCHAR StatusRequest[] = _TEXT("Sending request.");
@chunk TCHAR StatusWaiting[] = _TEXT("Waiting for data.");
@chunk TCHAR StatusReceiving[] = _TEXT("Receiving data.");
@chunk TCHAR StatusClosing[] = _TEXT("Closing connection.");

@chunk TCHAR ErrorEOF[] = _TEXT("EOF from server");
@chunk TCHAR ErrorHTTPVer[] = _TEXT("Not " HTTPVER " server");
@chunk TCHAR ErrorHTTPMalformed[] = _TEXT("Malformed " HTTPVER " line");
@chunk TCHAR ErrorGeneral[] = _TEXT("General failure receiving HTTP data");

/* These are here because this resource is locked when we might want them. */
@chunk TCHAR MimeTypeHTML[] = _TEXT("text/html");
@chunk char HTMLTag[] = {'<', 'H', 'T', 'M', 'L', '>', 0};

@end    StatusResource;

@include "userpass.goh"

/* a glue bug presents us from putting the above include in the AuthCode
   segment */

#pragma codeseg AuthCode

    void base64encode(TCHAR *in, char *out)
{
    const char basis_64[] =
        "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    int        c1, c2, c3;

    while (*in != '\0') {
        c1 = *in++;
@ifdef DO_DBCS
        /* DBCS TBD: base 64 encoding of Unicode */
        c1 &= 0xff;  /* if > 255, we'll just generate a mismatch */
@endif
        if (*in == '\0')
            c2 = c3 = 0;
        else {
            c2 = *in++;
@ifdef DO_DBCS
            /* DBCS TBD: base 64 encoding of Unicode */
            c2 &= 0xff;  /* if > 255, we'll just generate a mismatch */
@endif
            if (*in == '\0')
                c3 = 0;
            else {
                c3 = *in++;
@ifdef DO_DBCS
                /* DBCS TBD: base 64 encoding of Unicode */
                c3 &= 0xff;  /* if > 255, we'll just generate a mismatch */
@endif
	    }
        }
        *out++ = basis_64[c1>>2];
        *out++ = basis_64[((c1 & 0x3) << 4) | ((c2 & 0xF0) >> 4)];
        if (c2 == 0 && c3 == 0) {
            *out++ = '=';
            *out++ = '=';
        } else if (c3 == 0) {
            *out++ = basis_64[((c2 & 0xF) << 2) | ((c3 & 0xC0) >> 6)];
            *out++ = '=';
        } else {
            *out++ = basis_64[((c2 & 0xF) << 2) | ((c3 & 0xC0) >> 6)];
            *out++ = basis_64[c3 & 0x3F];
        }
    }
    *out = '\0';
}

#pragma codeseg

int sock_getline(HTTPConnectionHandle conn, T_HTTPConnection **retptr)
{
    int i;
    T_HTTPConnection *p_conn ;
    word len = sizeof(p_conn->buffer) ;
    char first ;
    word count = 0 ;
    char ch ;

    /* Connection is assumed to be locked once in this routine */
    ConnectionUnlock(conn) ;

    for (i=0, --len; ((i<=len) && (SocketRecvNice(conn, 1, HTTP_TIMEOUT) > 0)); ) {
        p_conn = ConnectionLock(conn) ;
        ch = p_conn->buffer[0] ;
        if (ch == '\n')
            i = 1+len;  /* Will break but finish this first */
        else if (ch != '\r') {
            /* Remember the first character since it will be overwritten */
            if (count == 0)
                first = ch;

            p_conn->buffer[count++] = ch;

            ++i;
        }
        ConnectionUnlock(conn) ;
    }

    /* Record the first and last character of the line */
    p_conn = ConnectionLock(conn) ;
    p_conn->buffer[0] = first ;
    p_conn->buffer[count] = '\0';
    ConnectionUnlock(conn) ;

    *retptr = ConnectionLock(conn) ;

    return(count);
}

/*
   printf function for socket data. buffer specifies a temporary storage
   space that must be big enough for the formatted output data. If buffer
   is NULL, the output data is not fed through printf formatting at all.
 */
#define SOCK_SEND_NO_ERR 0
#define SOCK_SEND_ERR 1
#define SOCK_SEND_ABORT 2
word sock_printf(T_HTTPConnection *p_conn, char *buffer, char *fmt, ...)
{
    va_list arg;
    char *data;
    word len;
    int err = SE_NORMAL;  /* no error */

    if (buffer) {                         /* go through vsprintf if requested */
        data = buffer;
        va_start(arg, fmt);
        len = vsprintfsbcs(data, fmt, arg);
        va_end(arg);
    } else {
        data = fmt;
        len = strlensbcs(data);
    }

#ifdef SSL_ENABLE
    if (p_conn->secure) {
        if (SSL_write(p_conn->ssl, data, len) != len) {
	    err = 1;  /* some SSL error */
	}
    } else {
        err = SocketSend(p_conn->sock, data, len, NULL, 0);
    }
#else
    err = SocketSend(p_conn->sock, data, len, NULL, 0);
#endif
    p_conn->sockErr = err;

    if (p_conn->aborted) return SOCK_SEND_ABORT;
    if (err) return SOCK_SEND_ERR;
    return SOCK_SEND_NO_ERR;
}

#pragma codeseg HeaderCode

/* rarely called from main code resource */
Boolean HeaderlessHTML(T_HTTPConnection *p_conn)
{
    Boolean retval = FALSE;
    char *p = p_conn->buffer;
    char *tag = LMemDeref(@HTMLTag);
    Boolean comment = TRUE;

    /* Skip any leading whitespace and comment. */
    while (*p && comment) {
@ifdef DO_DBCS
	while (*p != '\0' && (*p == ' ' || *p == '\t' || *p == C_CARRIAGE_RETURN || *p == C_LINE_FEED))
@else
	while (*p != '\0' && (*p == ' ' || *p == '\t' || *p == C_CR || *p == C_LF))
@endif
	    p++;
	if (strncmp(p, "<!", 2)==0) {
	    while(*p && (*p != '>')) p++;
	    if (*p && (*p == '>')) p++;  /* skip '>' */
	} else {
	    comment = FALSE;
	}
    }
    if (*p != '\0') {
        /* Do caseless comparison for starting tag. */
        if (!LocalCmpStringsNoCase(p, tag, strlen(tag)))
            /* Found it! */
            retval = TRUE;
    }
    return retval;
}
	
#ifdef CACHE_VALIDATION
/*
  Julian Day Number formula is this:

   if m < 3 then
     m = m + 12
     y = y - 1
   endif
   jd = d + (153*m - 457)/5 + 365*y + y/4 - y/100 + y/400 + 1721118.5

  Since we'll be computing days since 1/1/1980, we can eliminate the
  1721118.5 element.
*/

/* our number represents seconds since 1/1/1980 of target date/time */
#define N_1_1_1980 (1+(153*13-457)/5+365L*1979L+1979/4-1979/100+1979/400)

dword DateTimeToNumber(TimerDateAndTime *tdat)
{
    dword retVal;
    word year = tdat->TDAT_year;
    word month = tdat->TDAT_month;

    /* wrap non-leap months to end of previous year */
    if (month < 1) {
	month += 12;
	year--;
    }
    /* compute relative Julian Day Number */
    retVal = tdat->TDAT_day +
	(153*month - 457) / 5 +
	365L*(dword)year + year/4 - year/100 + year/400 - N_1_1_1980;

    retVal *= 24L*60L*60L;  /* seconds in each day */
    retVal += tdat->TDAT_hours*60*60 +
	tdat->TDAT_minutes*60 +
	tdat->TDAT_seconds;
    return retVal;
}
#endif

#define CL_UNKNOWN 0x7fffffffL          /* largest int, in case no CL header */

char *StripSpaces(char *string)
{
    word l;

    while (string && *string==C_SPACE)
	string++;
    while (string && ((l = strlen(string)) != 0) && (string[l-1]==C_SPACE))
	string[l-1] = C_NULL;
    return string;
}

long header(HTTPConnectionHandle conn, long *clret, word *responseCode)
{
    int       i;
    long      contentlength;
    char      *s, *p;
#ifdef RELAXED_INDENTS
    int       indent;
#ifndef IGNORE_CONTINUATION_LINES
    int	      indent2;
#endif
#endif
    T_HTTPConnection *p_conn ;
    Boolean   redirected = FALSE;
    Boolean   noCache = FALSE;
#ifdef COOKIE_ENABLE
    TimerDateAndTime httpExpires;
#endif
#ifdef CACHE_VALIDATION
    TimerDateAndTime httpDate;
    Boolean   dummyDST;
#endif

    *responseCode = 0;  /* in case of error */

    p_conn = ConnectionLock(conn) ;

    p_conn->msg = 0;                   /* default: no message */
#ifdef PERSISTANT_CONNECTIONS
    p_conn->chunked = FALSE;
#ifdef HTTP10_PERSIST
    p_conn->allowSocketCache = FALSE;  /* 1.0: assume non-persistant */
#else
    p_conn->allowSocketCache = TRUE;  /* 1.1: assume persistant */
#endif
    p_conn->connTimeOut = 0xffffffff;
#endif
#ifdef GET_RANGE
    p_conn->allowResume = FALSE;
#endif
#ifdef CACHE_VALIDATION
    TimerGetDateAndTime(&httpDate);  /* in case no Date: field */
    LocalNormalizeDateTime(&httpDate, &httpDate,
			   LocalGetTimezone(&dummyDST));  /* -> GMT */
    httpExpires.TDAT_year = 0;
    p_conn->maxAge = 0;  /* 0 to force validation */
    p_conn->lastModDate.CDT_year = 0; /* already used incoming cache item's
					 last-mod-date, so can clear this in
					 case new item doesn't have last-mod-
					 date */
#endif
#if PROGRESS_DISPLAY
    /* initialize mime type, we'll use this to determine whether we
       start an import */
    if (p_conn->loadProgressDataP)
        *p_conn->loadProgressDataP->LPD_mimeType = 0;
#endif
    contentlength = CL_UNKNOWN;
    if (sock_getline(conn, &p_conn) <= 0) {
        if (p_conn->aborted) {        /* abort signal? */
            ConnectionUnlock(conn) ;
            return URLRequestMakeRet(URL_RET_ABORTED);
        }

        strcpy(p_conn->errBuf, LMemDeref(@ErrorEOF));
        p_conn->msg = @MsgReceiveErr;
        ConnectionUnlock(conn) ;
        return URLRequestMakeRet(URL_RET_MESSAGE) | URB_RF_NOCACHE;
    }
    if (strncmpsbcs(s = p_conn->buffer, strn(HTTPVER10)) != 0 &&
        strncmpsbcs(s, strn(HTTPVER11)) != 0) {                                  /* no HTTP/1.[01]? */
	/* another non-spec case: we get blank line before headerless
	   response */
	char *sp = p_conn->buffer;
	while (*sp == C_SPACE) sp++;  /* leading spaces */
	if (*sp == C_NULL) {
	    if (sock_getline(conn, &p_conn) <= 0) {
		strcpy(p_conn->errBuf, LMemDeref(@ErrorHTTPVer));
		p_conn->msg = @MsgReceiveErr;
		ConnectionUnlock(conn) ;
		return URLRequestMakeRet(URL_RET_MESSAGE) | URB_RF_NOCACHE;
	    }
	}
        /* At least one server has been observed to send a headerless
           (simple) response to a "GET /".  Since RFC1945 says we should
           handle this, check to see if the first line has the usual HTML
           starter tag.  If so, fixup the mime type, length, etc.
           Otherwise, abort as usual. DH 9/1/99 */
        if (HeaderlessHTML(p_conn)) {
            word len = strlensbcs(s);

            *clret = CL_UNKNOWN;  /* Set unknown content length */
            ChunkStrcpy(p_conn->heap, &(p_conn->mimeTypeChunk),
                LMemDeref(@MimeTypeHTML));  /* Set HTML mime type */
            if (len < sizeof(p_conn->aborted)) {
                s += len;   /* Reappend the \n removed by sock_getline, */
                *(s++) = '\n';    /* but don't worry about missing \r's. */
                *s = '\0';
            }
            ConnectionUnlock(conn) ;
            return URLRequestMakeRet(URL_RET_FILE);
        } else {
            strcpy(p_conn->errBuf, LMemDeref(@ErrorHTTPVer));
            p_conn->msg = @MsgReceiveErr;
            ConnectionUnlock(conn) ;
            return URLRequestMakeRet(URL_RET_MESSAGE) | URB_RF_NOCACHE;
        }
    }
    s += sizeof(HTTPVER10)-1;          /* either 10 or 11 will do */
    if ((i = strspnsbcs(s, " \t")) <= 0) {   /* no whitespace? */
        strcpy(p_conn->errBuf, LMemDeref(@ErrorHTTPMalformed));
        p_conn->msg = @MsgReceiveErr;
        ConnectionUnlock(conn) ;
        return URLRequestMakeRet(URL_RET_MESSAGE) | URB_RF_NOCACHE;
    }
    s += i;
    *responseCode = atoisbcs(s);

    if (*responseCode == 401) {            /* authorization required: report */
        ConnectionUnlock(conn) ;
        return URLRequestMakeRet(URL_RET_AUTHORIZATION);
    }

#ifdef GET_RANGE
    if (*responseCode != 200 && *responseCode != 206 && *responseCode != 301 && *responseCode != 302 &&
        *responseCode != 304) {
#else
    if (*responseCode != 200 && *responseCode != 301 && *responseCode != 302 &&
        *responseCode != 304) {
#endif
@ifdef DO_DBCS
        xstrncpysbcstodbcs(p_conn->errBuf, s, ERRORSIZE);
@else
        xstrncpy(p_conn->errBuf, s, ERRORSIZE);
@endif
        if (*responseCode == 404) {
            p_conn->msg = @Msg404Err;
        } else {
            p_conn->msg = @MsgReceiveErr;
        }
    }

#ifdef RELAXED_INDENTS
#ifndef IGNORE_CONTINUATION_LINES
    indent2 = -1;
#endif
#endif

    /* eat up the other header lines here */
    while (sock_getline(conn, &p_conn) > 0) {
        s = strchrsbcs(p_conn->buffer,':');
        if (s)
            while ( isspace(*(++s)) )
                ;
        else
            s = NULL;
        p = p_conn->buffer;
#ifdef RELAXED_INDENTS
        indent = 0;
        while ( isspace(*p) )           // skip over indent...
          p++,indent++;                 // ...but keep track of amount
#endif
        if (LocalCmpStringsNoCaseSBCS(p, strn("Content-Length:")) == 0) {
            if (UtilAsciiToHex32SBCS(StripSpaces(s), &contentlength))
                contentlength = CL_UNKNOWN;
#ifndef RELAXED_INDENTS
        } else if (LocalCmpStringsNoCaseSBCS(p, strn(" Content-Length:")) == 0) {
	    /* ack, handle dljdirect header with leading space */
            if (UtilAsciiToHex32SBCS(StripSpaces(s), &contentlength))
                contentlength = CL_UNKNOWN;
#endif
        } else if (LocalCmpStringsNoCaseSBCS(p, strn("Content-Type:")) == 0) {
            ChunkStrcpySBCS(p_conn->heap, &(p_conn->mimeTypeChunk), s);
#if PROGRESS_DISPLAY
            /* get mime type from HTTP header */
            if (p_conn->loadProgressDataP)
@ifdef DO_DBCS
                xstrncpysbcstodbcs(p_conn->loadProgressDataP->LPD_mimeType, s, sizeof(p_conn->loadProgressDataP->LPD_mimeType)/sizeof(TCHAR));
@else
                xstrncpy(p_conn->loadProgressDataP->LPD_mimeType, s, sizeof(p_conn->loadProgressDataP->LPD_mimeType));
@endif
#endif
        } else if (LocalCmpStringsNoCaseSBCS(p, strn("Location:")) == 0) {
            if (*responseCode == 301 || *responseCode == 302) {
                ChunkStrcpySBCS(p_conn->heap, &(p_conn->urlChunk), s);
                /* delay redirection until other header fields are parsed */
                redirected = TRUE;
            }
        }
	else if (LocalCmpStringsNoCaseSBCS(p, strn("Pragma: no-cache")) == 0) {
	    noCache = TRUE;
	}
	/* handle "no-cache" among all "Cache-control" options, this only
	   detects case-sensitive "no-cache", but that should be fine */
	else if (LocalCmpStringsNoCaseSBCS(p, strn("Cache-control:")) == 0) {
#ifdef CACHE_VALIDATION
	    char *q = strstrsbcs(s, "max-age=");
	    if (q)
		p_conn->maxAge = atoisbcs(q+8);
#endif
	    if (strstrsbcs(s, "no-cache")) {
		noCache = TRUE;
	    }
	}
#ifdef COOKIE_ENABLE
	/* not really cookie-related, but ParseTime is only included for
	   cookies */
	else if (LocalCmpStringsNoCaseSBCS(p, strn("Expires:")) == 0) {
	    CookieParseTime(s, &httpExpires);  /* bad parse gives yr=0, so expired */
	    /* if expire date is 0, don't cache */
	    if (httpExpires.TDAT_year == 0) {
		noCache = TRUE;
	    } else {
		TimerDateAndTime nowTDAT;
		Boolean nowDST;
		/* if expires date is before now, don't cache */
		TimerGetDateAndTime(&nowTDAT);
		LocalNormalizeDateTime(&nowTDAT, &nowTDAT,
				       LocalGetTimezone(&nowDST));  /* GMT */
		if (LocalCompareDateTimes(&httpExpires, &nowTDAT) <= 0) {
		    noCache = TRUE;
		}
	    }
	}
#endif
#ifdef COOKIE_ENABLE
        else if (LocalCmpStringsNoCaseSBCS(p, strn("Set-Cookie:")) == 0) {
            /* only handles single line cookie */
            CookieParse(p_conn->path, p_conn->host, p+11);  /* advance past Set */
        }
#endif
#ifdef PERSISTANT_CONNECTIONS
	/* detect persistant connections */
#ifdef HTTP10_PERSIST
	/* HTTP 1.0 assume non-persistant, unless told otherwise */
	else if (LocalCmpStringsNoCaseSBCS(p, strn("Connection: Keep-Alive")) == 0) {
	    p_conn->allowSocketCache = TRUE;
	}
#else
	/* HTTP 1.1 assumes persistant, unless told otherwise */
	else if (LocalCmpStringsNoCaseSBCS(p, strn("Connection: Close")) == 0) {
	    p_conn->allowSocketCache = FALSE;
	}
#endif
	else if (LocalCmpStringsNoCaseSBCS(p, strn("Keep-Alive:")) == 0) {
	    char *q;
	    q = strstrsbcs(s, "timeout=");
	    if (q) {
		/* store timeout in ticks from seconds value */
		p_conn->connTimeOut = (dword)(atoisbcs(q+8)) * (dword)60;
	    }
	    q = strstrsbcs(s, "max=");
	    if (q) {
		/* if max=1, close after this usage */
		if (atoisbcs(q+4) == 1) {
		    p_conn->connTimeOut = 0;
		}
	    }
	}
	/* detected chunked encodings */
	else if (LocalCmpStringsNoCaseSBCS(p, strn("Transfer-Encoding: chunked")) == 0) {
	    p_conn->chunked = TRUE;
	    p_conn->chunkSize = 0;  /* ready for first chunk */
	}
#endif
#ifdef CACHE_VALIDATION
	else if (LocalCmpStringsNoCaseSBCS(p, strn("Date:")) == 0) {
	    CookieParseTime(s, &httpDate);  /* bad parse gives year=0 */
	}
	else if (LocalCmpStringsNoCaseSBCS(p, strn("Last-Modified:")) == 0) {
	    TimerDateAndTime lastModTDAT;
	    CookieParseTime(s, &lastModTDAT);  /* bad parse gives year=0 */
	    if (lastModTDAT.TDAT_year >= 1980) {  /* 1980+ is enough */
		p_conn->lastModDate.CDT_year = lastModTDAT.TDAT_year - 1980;
		p_conn->lastModDate.CDT_month = lastModTDAT.TDAT_month;
		p_conn->lastModDate.CDT_day = lastModTDAT.TDAT_day;
		p_conn->lastModDate.CDT_hours = lastModTDAT.TDAT_hours;
		p_conn->lastModDate.CDT_minutes = lastModTDAT.TDAT_minutes;
		p_conn->lastModDate.CDT_seconds = lastModTDAT.TDAT_seconds;
	    }
	}
#endif
#ifdef EMAIL_ACCT_CMD
	else if (LocalCmpStringsNoCaseSBCS(p, strn("GPCemail")) == 0) {
	    ChunkStrcpySBCS(p_conn->heap, &(p_conn->emailCmd), s);
	}
#endif
#ifdef GET_RANGE
	else if (LocalCmpStringsNoCaseSBCS(p, strn("Accept-ranges: bytes")) == 0) {
	    p_conn->allowResume = TRUE;
	} else if (p_conn->resumePos && LocalCmpStringsNoCaseSBCS(p, strn("Content-Range: bytes")) == 0) {
	    dword total = 0, start = 0;
	    char *p;
	    p = strchrsbcs(s, '/');
	    if (p) {
		UtilAsciiToHex32SBCS(p+1, &total);
	    }
	    p = strchrsbcs(s, '-');
	    if (p) {
		*p = C_NULL;  /* terminate start value */
		/* find start value start */
		while (*s && ((*s < '0') || (*s > '9'))) s++;
		UtilAsciiToHex32SBCS(s, &start);
	    }
	    if (start != p_conn->resumePos ||
		total != p_conn->resumePos + p_conn->resumeLength) {
		p_conn->msg = @MsgReceiveErr;
		ConnectionUnlock(conn);
		return URLRequestMakeRet(URL_RET_MESSAGE) | URB_RF_NOCACHE;
	    }
	}
#endif
#ifndef IGNORE_CONTINUATION_LINES
#ifdef RELAXED_INDENTS
        else if (indent2>=0 && indent>indent2) {
#else
        else if (p[0] == ' ' || p[0] == '\t') {
#endif
            strcpy(p_conn->errBuf, _TEXT("Continuation line encountered"));
            p_conn->msg = @MsgReceiveErr;
            ConnectionUnlock(conn) ;
            return URLRequestMakeRet(URL_RET_MESSAGE) | URB_RF_NOCACHE;
        }
#ifdef RELAXED_INDENTS
        indent2 = indent;               // remember indent for next line
#endif
#endif  /* IGNORE_CONTINUATION_LINES */
    }

#ifdef PERSISTANT_CONNECTIONS
#ifdef HTTP10_PERSIST
    /* can't have HTTP 1.0 persistant connection unless we know length */
    if (contentlength == CL_UNKNOWN) {
	p_conn->allowSocketCache = FALSE;
    }
#endif
#endif

#ifdef CACHE_VALIDATION
    /* compute maxAge from Expires: and Date:, if both set */
    if (!p_conn->maxAge &&  /* Cache-control: max-age overrides this */
	(httpExpires.TDAT_year >= 1980) && (httpDate.TDAT_year >= 1980) &&
	(LocalCompareDateTimes(&httpExpires, &httpDate) > 0)) {
	p_conn->maxAge = DateTimeToNumber(&httpExpires) -
	    DateTimeToNumber(&httpDate);
    }
#endif

    if (p_conn->aborted) {             /* abort signal? */
        ConnectionUnlock(conn) ;
        return URLRequestMakeRet(URL_RET_ABORTED);
    }

    *clret = (*responseCode == 304 ? 0L : contentlength) ;
    ConnectionUnlock(conn) ;

    /* handle redirection here, also allows aborting to have precedence
       over redirection */
    if (redirected) return URLRequestMakeRet(URL_RET_URL_REDIR);

    return URLRequestMakeRet(URL_RET_FILE) | (noCache ? URB_RF_NOCACHE : 0);
}

#pragma codeseg

#pragma codeseg COOKIES_TEXT

#ifdef COOKIE_ENABLE
/*
 * Send cookies
 */
word SendCookies(T_HTTPConnection *p_conn)
{
    word err = SOCK_SEND_NO_ERR;

    optr cookieList = CookieFind(p_conn->path, p_conn->host, p_conn->secure);
    if (cookieList) {
        int count;
        MemLock(OptrToHandle(cookieList));
        count = ChunkArrayGetCount(cookieList);
        if (count) {
            int i;
	    word elSize;
            optr tmp;
            char *c;
            err = sock_printf(p_conn, NULL, "Cookie: ");
	    if (!err) {
		for (i=0; i<count; i++) {
		    if (i != 0) {
			err = sock_printf(p_conn, NULL, "; ");
			if (err) break;
		    }
		    memcpy(&tmp, ChunkArrayElementToPtr(cookieList,
							i, &elSize),
			   sizeof(optr));
		    HugeLMemLock(OptrToHandle(tmp));
		    c = LMemDeref(tmp);
		    err = sock_printf(p_conn, NULL, c);
		    HugeLMemUnlock(OptrToHandle(tmp));
		    /* we need to free it also */
		    HugeLMemFree(tmp);
		    if (err) break;
		}
	    }
	    if (!err) {
		err = sock_printf(p_conn, NULL, "\r\n");
	    }
        }
        MemFree(OptrToHandle(cookieList));
    }
    return err;
}
#endif

#pragma codeseg

#pragma codeseg CacheCode

#ifdef PERSISTANT_CONNECTIONS
Boolean FindAndUseSocket(T_HTTPConnection *p_conn)
{
    int i;
    Boolean retVal = FALSE;
    SocketCacheEntry *sc;

    if (!socketCacheBlock) return FALSE;
    ThreadPSem(socketCacheSem);
    sc = MemLock(socketCacheBlock);
    for (i = 0; i < NUM_CACHED_SOCKETS; i++) {
	if (sc[i].socket &&
	    /* can't use in-use socket in parallel */
	    !sc[i].inUse &&
	    (strcmp(sc[i].host,
		    p_conn->useProxy ? p_conn->proxyHost :
		    p_conn->host) == 0)) {
	    /* if socket has timed-out, can't use */
	    if (TimerGetCount() >= sc[i].timeOut) {
		/* close socket (no SSL cached sockets, so no SSL_shutdown) */
		CloseSocket(sc[i].socket);
		/* remove from cache */
		RemoveSocketCacheEntry(&sc[i]);
	    } else {
		/* get cached socket and mark used */
		p_conn->sock = sc[i].socket;
		sc[i].inUse = TRUE;
		sc[i].lastUse = TimerGetCount();
		p_conn->socketFromCache = TRUE;
		retVal = TRUE;
		break;
	    }
	}
    }
    MemUnlock(socketCacheBlock);
    ThreadVSem(socketCacheSem);
    return retVal;
}

void DoneUsingCachedSocket(T_HTTPConnection *p_conn)
{
    int i;
    SocketCacheEntry *sc;

    if (!socketCacheBlock) return;
    ThreadPSem(socketCacheSem);
    sc = MemLock(socketCacheBlock);
    for (i = 0; i < NUM_CACHED_SOCKETS; i++) {
	if (sc[i].socket == p_conn->sock) {
	    sc[i].inUse = FALSE;
	    p_conn->socketFromCache = FALSE;
	    p_conn->sock = NullHandle;
	    /* set last use for LRU */
	    sc[i].lastUse = TimerGetCount();
	    /* set timeout for closing */
	    if (p_conn->connTimeOut != 0xffffffff) {
		sc[i].timeOut = sc[i].lastUse + p_conn->connTimeOut;
	    } else {
		/* never time out, let server timeout, we'll handle error */
		sc[i].timeOut = 0xffffffff;
	    }
	    break;
	}
    }
    MemUnlock(socketCacheBlock);
    ThreadVSem(socketCacheSem);
}

Boolean PutSocketInCache(T_HTTPConnection *p_conn)
{
    int i, oldest = NUM_CACHED_SOCKETS;
    dword oldestUse = 0xffffffff;
    Boolean retVal = FALSE;
    SocketCacheEntry *sc;

    if (!socketCacheBlock) return FALSE;
    ThreadPSem(socketCacheSem);
    sc = MemLock(socketCacheBlock);
    for (i = 0; i < NUM_CACHED_SOCKETS; i++) {
	if (sc[i].socket) {
	    if (!sc[i].inUse && sc[i].lastUse < oldestUse) {
		oldest = i;
		oldestUse = sc[i].lastUse;
	    }
	} else {
	    /* found empty slot */
	    sc[i].socket = p_conn->sock;
	    sc[i].inUse = TRUE;	/* MUST SET to avoid being closed by us */
	    strcpy(sc[i].host,
		   p_conn->useProxy ? p_conn->proxyHost : p_conn->host);
	    retVal = TRUE;
	    break;
	}
    }
    /* if didn't find free slot, replace oldest slot if possible */
    if (i == NUM_CACHED_SOCKETS && oldest != NUM_CACHED_SOCKETS) {
	/* close previous socket in not in use (no SSL cached sockets, so no SSL_shutdown) */
	CloseSocket(sc[oldest].socket);
	/* use vacated slot */
	sc[oldest].socket = p_conn->sock;
	sc[oldest].inUse = TRUE; /* MUST SET to avoid being closed by us */
	strcpy(sc[oldest].host, p_conn->host);
	retVal = TRUE;
    }
    MemUnlock(socketCacheBlock);
    ThreadVSem(socketCacheSem);
    return retVal;
}
#endif

#pragma codeseg

#ifdef PERSISTANT_CONNECTIONS
void HandleErrorFunc(T_HTTPConnection *p_conn, Boolean *retry)
{
    if (p_conn->socketFromCache) {
	RemoveSocketFromCache(p_conn);
	*retry = TRUE;
    }
}
#endif

/* we'll try twice with SSL2/SSL3/TLS1, then twice with SSL2 */
#define NUM_SSL_ALL_RETRIES 2
#define NUM_SSL_S2_RETRIES 2

word HTTPGet(HTTPConnectionHandle conn)
{
    int       i;
    TCHAR      *p;
    long      length, contentlength;
    TCHAR     *host2 ;
    word      rcode;
    word      size;
    Boolean   gotPassword = FALSE ;
    HTTPPassword *passwordP;
    Boolean   retry ;
    Boolean   doClose ;
    FileHandle output;
    SocketError err;
    word      interError ;
    Socket    sock ;
    T_formString* ppost;
    ResolvedTCPAddress hostaddr = {{{0,MANUFACTURER_ID_SOCKET_16BIT_PORT},
                sizeof(HTTP_DOMAIN)-1,HTTP_DOMAIN,
                0}};
    T_HTTPConnection *p_conn ;
#ifdef RECV_SPEED
    TCHAR     statusBuffer[80] ;
    long      bytesPerSec ;
#endif
    Boolean   bPostIsGet = FALSE;
    UnresolvedTCPAddress hostname;
#ifdef SSL_ENABLE
    int       sslRetries = NUM_SSL_ALL_RETRIES + NUM_SSL_S2_RETRIES;
#endif
#ifdef PERSISTANT_CONNECTIONS
    Boolean newSocket = TRUE;
#endif
#ifdef CACHE_VALIDATION
    Boolean conditionalRequest = FALSE;
    Boolean notModified = FALSE;
#endif
    word responseCode;
#ifdef GET_RANGE
    Boolean deleteFile = FALSE;
#endif
    MemHandle pathB = 0;
    int urlLen;

    p_conn = ConnectionLock(conn) ;
#ifdef PERSISTANT_CONNECTIONS
#define handle_error(rc) {HandleErrorFunc(p_conn, &retry); rcode = rc; goto error_exit;}
#else
#define handle_error(rc) {rcode = rc; goto error_exit;}
#endif

#ifdef GET_RANGE
    p_conn->resumePos = 0;
    p_conn->resumeLength = 0;
#endif

    *(p_conn->userpwd) = 0;                       /* default: no user name/password */

#ifdef SSL_ENABLE
    MemLock(p_conn->heap);
    p_conn->secure = (LocalCmpStringsNoCase(
        LMemDerefHandles(p_conn->heap, p_conn->urlChunk), _TEXT("HTTPS:"), 6) == 0);
    MemUnlock(p_conn->heap);
    if (p_conn->secure) ThreadPSem(sslSem);
#endif

    MemLock(p_conn->heap);
    urlLen = strlen(LMemDerefHandles(p_conn->heap, p_conn->urlChunk))+1;
    MemUnlock(p_conn->heap);
    if (urlLen*sizeof(TCHAR) > sizeof(p_conn->pathbuf)) {
	pathB = MemAlloc(urlLen*sizeof(TCHAR), HF_DYNAMIC, HAF_STANDARD_LOCK);
	if (!pathB)
	    return URLRequestMakeRet(URL_RET_NO_MEMORY) | URB_RF_NOCACHE ;
	p_conn->path = MemDeref(pathB);
    } else {
	p_conn->path = p_conn->pathbuf;
    }

    do {
        retry = FALSE ;
        doClose = FALSE ;
        *(p_conn->errBuf) = 0;                    /* default: no error message */
#ifdef PERSISTANT_CONNECTIONS
	newSocket = TRUE;
#endif

        MemLock(p_conn->heap);
        ToolsParseURL(
            LMemDerefHandles(p_conn->heap, p_conn->urlChunk),
            p_conn->type, p_conn->host, p_conn->path);
        MemUnlock(p_conn->heap);

        /* try to split username/password from host name */
        p = strchr(p_conn->host, '@');
        if ((p) && (!gotPassword)) {       /* host name contains user ID? */
            *p = 0;
            host2 = p+1;                  /* host name starts after "@" sign */

            xstrncpy(p_conn->userpwd, p_conn->host, sizeof(p_conn->userpwd));
            /* get username and/or password */

            /* Note that we have gotten a password */
            gotPassword = TRUE ;
        } else {
            host2 = p_conn->host;         /* use entire host name */

            /* Use the previous password this time if host is still the same */
            ThreadPSem(G_syncPassword);  /* use MemPLock instead? */
	    if (G_passwordBlock) {
		/* do a bit of work that'll be repeated later
		   to check for port number */
		TCHAR *portP = strchr(p_conn->host, ':');
		word portN;
		passwordP = MemLock(G_passwordBlock);
		if (portP) {
		    portN = atoi(portP+1);
		    *portP = 0;
		} else {
#ifdef SSL_ENABLE
		    portN = (p_conn->secure) ? 443 : 80;
#else
		    portN = 80;
#endif
		}
		if ((strcmp(p_conn->host, passwordP->pwdhost)==0) &&
		    (portN == passwordP->port))
		    strcpy(p_conn->userpwd, passwordP->userpwd) ;
		if (portP) {
		    *portP = ':';
		}
		MemUnlock(G_passwordBlock);
	    }
            ThreadVSem(G_syncPassword);
        }

#ifdef PERSISTANT_CONNECTIONS
	p_conn->dontUsePersistant = FALSE;
#endif
        if ((!InitFileReadStringBuffer("HTMLView", "WWWProxy", p_conn->buffer,
            IFRF_FIRST_ONLY | URL_MAX_SERVER, &size)) && (size != 0)) {

	    p = strchr(host2, ':');
	    if (p) {
		p_conn->hostPort = atoi(p+1);
		*p = 0;
	    } else                            /* default HTTP port */
#ifdef SSL_ENABLE
            if (p_conn->secure) {
		p_conn->hostPort = 443;
	    } else {
		p_conn->hostPort = 80;
	    }
#else
            p_conn->hostPort = 80;
#endif

            strcpy(host2 = p_conn->proxyHost, (TCHAR *)(p_conn->buffer));

#if 0
            MemLock(p_conn->heap);
            strcpy(p_conn->path,
                LMemDerefHandles(p_conn->heap, p_conn->urlChunk));
            /* request entire URL from proxy */
            MemUnlock(p_conn->heap);
#endif
#ifdef PERSISTANT_CONNECTIONS
#ifdef HTTP10_PERSIST  /* okay to use persist and proxy with 1.1 */
	    p_conn->dontUsePersistant = TRUE;
#endif
#endif
	    p_conn->useProxy = TRUE;
        }
	else {
	    p_conn->useProxy = FALSE;
	}

        /* try to split port number from host name */
        p = strchr(host2, ':');
        if (p) {
            hostaddr.RTA_sock.SA_port.SP_port = atoi(p+1);
            *p = 0;
        } else                            /* default HTTP port */
#ifdef SSL_ENABLE
            if (p_conn->secure && !p_conn->useProxy) {
            hostaddr.RTA_sock.SA_port.SP_port = 443;
        } else {
            hostaddr.RTA_sock.SA_port.SP_port = 80;
        }
#else
            hostaddr.RTA_sock.SA_port.SP_port = 80;
#endif

#ifdef PERSISTANT_CONNECTIONS
	p_conn->socketFromCache = FALSE;  /* not cached yet */
#ifdef HTTP10_PERSIST
	p_conn->allowSocketCache = FALSE;  /* 1.0: assume non-peristant */
#else
	p_conn->allowSocketCache = TRUE;  /* 1.1: assume persistant */
#endif
	/* SSL sockets aren't cached */
	if (!p_conn->secure && FindAndUseSocket(p_conn) == TRUE) {
	    newSocket = FALSE;
	    if (p_conn->aborted) { /* handle abort signal */
		handle_error(URL_RET_ABORTED);
	    }
	} else {  /* BBB */
#endif

        /* store link info into raw address buffer */
        p_conn->hostname.UTA_link.TAPEA_linkSize =
            sizeof(p_conn->hostname.UTA_link.TAPEA_linkType) +
            sizeof(p_conn->hostname.UTA_link.TAPEA_accPntID);

        /* TBD: currently, we hard code the use of access point #1. Must change. */
        p_conn->hostname.UTA_link.TAPEA_linkType = LT_ID;
        p_conn->hostname.UTA_link.TAPEA_accPntID = 1;

        xstrncpy(p_conn->hostname.UTA_ip, host2, MAX_IP_ADDR_STRING_LENGTH);

        if (p_conn->callback)
            ((pcfm_URLDrvCallback *)ProcCallFixedOrMovable_pascal)(
                LMemDeref(@StatusLocating), -1, -1, p_conn->token, p_conn->callback);

        if (p_conn->aborted)                     /* abort signal during preparation? */
            handle_error(URL_RET_ABORTED);

        /* Copy the resolve information so we can unlock the connection
           during the resolve. */

        memcpy(&hostname, &p_conn->hostname, sizeof(hostname));

        p_conn->socketState = STATE_RESOLVING;
        ConnectionUnlock(conn);

        hostaddr.RTA_sock.SA_addressSize = SocketResolve(
            HTTP_DOMAIN,
            (byte*)&hostname, sizeof(hostname.UTA_link)+strlen(hostname.UTA_ip)*sizeof(TCHAR),
            (byte*)&hostaddr.RTA_addr, sizeof(hostaddr.RTA_addr));

        p_conn = ConnectionLock(conn);

        if (p_conn->aborted)                     /* abort signal? */
            handle_error(URL_RET_ABORTED);

        /* Note: ThreadGetError() sometimes incorrectly reports an error
           after SocketResolve(), at least on the Yago. */
        if (!hostaddr.RTA_sock.SA_addressSize /* || ThreadGetError() != SE_NORMAL */) {
	    p_conn->sockErr = ThreadGetError();
            sprintf(p_conn->errBuf, _TEXT("%d"), ThreadGetError());
	    if (p_conn->sockErr == SE_LINK_FAILED) {
		p_conn->msg = @MsgResolveLinkErr;
	    } else {
		p_conn->msg = @MsgResolveErr;
	    }
            handle_error(URL_RET_MESSAGE);
        }

        p_conn->sock = SocketCreate(SDT_STREAM);
#ifdef PERSISTANT_CONNECTIONS
	}  /* BBB */
#endif

#ifdef SSL_ENABLE
        if (p_conn->secure) {
            if ((ssl_ctx == 0) || ((p_conn->ssl = SSL_new(ssl_ctx)) == 0)) {
                SocketMyClose(p_conn);
                sprintf(p_conn->errBuf, _TEXT("SSL"));
                p_conn->msg = @MsgConnectErr;
                doClose = FALSE;
                handle_error(URL_RET_MESSAGE);
            }
	    if (sslRetries <= NUM_SSL_S2_RETRIES &&
		(SSL_set_ssl_method(p_conn->ssl, SSLv2_client_method()) == 0)) {
                SocketMyClose(p_conn);  /* does SSL_free */
                sprintf(p_conn->errBuf, _TEXT("SSL"));
                p_conn->msg = @MsgConnectErr;
                doClose = FALSE;
                handle_error(URL_RET_MESSAGE);
	    }
            if (!SSL_set_fd(p_conn->ssl, p_conn->sock)) {
                SocketMyClose(p_conn);  /* does SSL_free */
                sprintf(p_conn->errBuf, _TEXT("SSL"));
                p_conn->msg = @MsgConnectErr;
                doClose = FALSE;
                handle_error(URL_RET_MESSAGE);
            }
        }
#endif

        p_conn->socketState = STATE_HTTP_REQUEST;
        doClose = TRUE;                 /* request is now starting */

#ifdef PERSISTANT_CONNECTIONS
	/* only need option/connect for new socket, not one from cache */
	err = SE_NORMAL;
	if (newSocket) {  /* AAA */
#endif

        SocketSetIntSocketOption(p_conn->sock, SO_RECV_BUF, RECV_BUFFER_SIZE);

        if (p_conn->callback)
            ((pcfm_URLDrvCallback *)ProcCallFixedOrMovable_pascal)(
                LMemDeref(@StatusContacting), -1, -1, p_conn->token, p_conn->callback);

        sock = p_conn->sock;
        ConnectionUnlock(conn);
        
        err = SocketConnect(sock, &hostaddr.RTA_sock, HTTP_TIMEOUT);

        p_conn = ConnectionLock(conn);

#ifdef PERSISTANT_CONNECTIONS
	} /* AAA */
#endif

        if (p_conn->aborted)                     /* abort signal? */
            handle_error(URL_RET_ABORTED);
	    
#ifdef SSL_ENABLE
        if ((p_conn->secure) && (err == SE_NORMAL) && (p_conn->ssl)) {
	    void *sslP = p_conn->ssl;

	    SSL_set_fd(p_conn->ssl, p_conn->sock);

	    if (p_conn->useProxy) {
#if 1
		/* Hack so this stuff isn't encrypted */
		p_conn->secure = FALSE;
		sock_printf(p_conn, p_conn->buffer,
#  ifdef PERSISTANT_CONNECTIONS
#    ifdef DO_DBCS
			    "CONNECT %S:%d %s\r\n"
#    else
			    "CONNECT %s:%d %s\r\n"
#    endif
#  else
#    ifdef DO_DBCS
			    "CONNECT %S:%d " HTTPVER10 "\r\n"
#    else
			    "CONNECT %s:%d " HTTPVER10 "\r\n"
#    endif
#  endif
#  ifdef DO_DBCS
			    "Host: %S:%d\r\n"
#  else
			    "Host: %s:%d\r\n"
#  endif
			    "User-Agent: " USER_AGENT "\r\n\r\n",
			    p_conn->host, p_conn->hostPort,
#  ifdef PERSISTANT_CONNECTIONS
			    httpVer,
#  endif
			    p_conn->host, p_conn->hostPort,
			    langStr, osVerStr, videoStr, countryStr);
		/* Check for errors. 2xx = success. This should be a valid
		   HTTP 1.x response, possibly multi-line. Will be followed
		   by a blank line. Anything after that is encrypted. */
		ConnectionUnlock(conn);
		responseCode = 100;
		while (responseCode == 100) {
		    rcode = header(conn, &contentlength, &responseCode);
		}
		if (!(responseCode >= 200 && responseCode < 300))
		    err = SE_CONNECTION_ERROR;
		/* after here we want stuff encrypted */
		p_conn = ConnectionLock(conn);
		p_conn->secure = TRUE;
	    } /* if (p_conn->useProxy) */
	    ConnectionUnlock(conn);
#else
	    /* SSL isn't working thru a proxy, and seems to cause memory
	       problems, so don't try using it */
	    err = SE_CONNECTION_ERROR;
            }
	    ConnectionUnlock(conn);
#endif

            if (err == SE_NORMAL && SSL_connect(sslP) <= 0) {
                err = SE_CONNECTION_ERROR;
            }
	    p_conn = ConnectionLock(conn);
        }
#endif

        if (err != SE_NORMAL) {
	    p_conn->sockErr = err;
#ifdef SSL_ENABLE
            SocketMyClose(p_conn);
#else
            sock = p_conn->sock ;
/*        ConnectionUnlock(conn) ; */
            if (sock)
                SocketMyClose(sock);
/*        p_conn = ConnectionLock(conn) ; */
            p_conn->sock = NullHandle ;
#endif
            sprintf(p_conn->errBuf, _TEXT("%d"), err);
            p_conn->msg = @MsgConnectErr;
            doClose = FALSE;
            handle_error(URL_RET_MESSAGE);
        }

        if (p_conn->callback)
            ((pcfm_URLDrvCallback *)ProcCallFixedOrMovable_pascal)(
                LMemDeref(@StatusRequest), -1, -1, p_conn->token, p_conn->callback);

        if (p_conn->postData) {
            ppost = MemLock(p_conn->postData) ;

            if (ppost->flags & FORM_STRING_FLAG_IS_GET_METHOD) {
		char postDataChar, *postDataPtr;
		word postDataSize;

		/* If there's any query data in our URI, lob it off.  The form
		   string holds all of that information. */
		if ((p = strchr(p_conn->path, '?')) != NULL)
		    *p = '\0';

                /* Do a different method of sending a GET because we are */
                /* storing information that is to be passed right on the URL */
                /* instead of being a true POST */
                bPostIsGet = TRUE;  /* Remind us to send final CR/LF later */
		if (p_conn->useProxy && !p_conn->secure) {
		    interError = sock_printf(p_conn, 
					     p_conn->buffer, 
#ifdef DO_DBCS
					     "GET %S://%S:%d%S?",
#else
					     "GET %s://%s:%d%s?",
#endif
					     p_conn->type, p_conn->host,
					     p_conn->hostPort, p_conn->path);
		}
		else {
		    interError = sock_printf(p_conn, 
					     p_conn->buffer, 
#ifdef DO_DBCS
					     "GET %S?",
#else
					     "GET %s?",
#endif
					     p_conn->path);
		}
                /* Notice the question mark MUST be prepended (above). */
		postDataPtr = ppost->data;
		while (!interError && strlen(postDataPtr)) {
		    postDataSize = strlen(postDataPtr);
		    if (postDataSize > sizeof(p_conn->buffer)-1) {
			postDataSize = sizeof(p_conn->buffer)-1;
		    }
		    postDataChar = *(postDataPtr + postDataSize);
		    *(postDataPtr + postDataSize) = C_NULL;
		    interError = sock_printf(
			p_conn,
			p_conn->buffer,
			"%s",
			postDataPtr);
		    *(postDataPtr + postDataSize) = postDataChar;
		    postDataPtr += postDataSize;
		}
                if (!interError) {
                    interError = sock_printf(
                                    p_conn,
                                    p_conn->buffer,
#ifdef PERSISTANT_CONNECTIONS
                                    " %s\r\n"
#else
                                    " " HTTPVER10 "\r\n"
#endif
#ifdef DO_DBCS
                                    "Host: %S\r\n"
#else
                                    "Host: %s\r\n"
#endif
                                    "User-Agent: " USER_AGENT "\r\n",
#ifdef PERSISTANT_CONNECTIONS
				    httpVer,
#endif
                                    p_conn->host,
				    langStr,
                                    osVerStr,
                                    videoStr,
				    countryStr) ;
                }
                if (interError) {
                    MemUnlock(p_conn->postData) ;
		    if (interError == SOCK_SEND_ABORT) {
			handle_error(URL_RET_ABORTED) ;
		    } else {
			p_conn->msg = @MsgConnectErr;
			handle_error(URL_RET_MESSAGE);
		    }
                }
            } else {
                /* Do a POST command */
		if (p_conn->useProxy && !p_conn->secure) {
                interError = sock_printf(p_conn, p_conn->buffer,
#ifdef PERSISTANT_CONNECTIONS
#ifdef DO_DBCS
                    "POST %S://%S:%d%S %s\r\n"
#else
                    "POST %s://%s:%d%s %s\r\n"
#endif
#else
#ifdef DO_DBCS
                    "POST %S://%S:%d%S " HTTPVER10 "\r\n"
#else
                    "POST %s://%s:%d%s " HTTPVER10 "\r\n"
#endif
#endif
#ifdef DO_DBCS
                    "Host: %S\r\n"
#else
                    "Host: %s\r\n"
#endif
                    "User-Agent: " USER_AGENT "\r\n",
		    p_conn->type, p_conn->host, p_conn->hostPort,
#ifdef PERSISTANT_CONNECTIONS
                    p_conn->path, httpVer, p_conn->host,
#else
                    p_conn->path, p_conn->host,
#endif
		    langStr, osVerStr, videoStr, countryStr);
		}
		else {
                interError = sock_printf(p_conn, p_conn->buffer,
#ifdef PERSISTANT_CONNECTIONS
#ifdef DO_DBCS
                    "POST %S %s\r\n"
#else
                    "POST %s %s\r\n"
#endif
#else
#ifdef DO_DBCS
                    "POST %S " HTTPVER10 "\r\n"
#else
                    "POST %s " HTTPVER10 "\r\n"
#endif
#endif
#ifdef DO_DBCS
                    "Host: %S\r\n"
#else
                    "Host: %s\r\n"
#endif
                    "User-Agent: " USER_AGENT "\r\n",
#ifdef PERSISTANT_CONNECTIONS
                    p_conn->path, httpVer, p_conn->host,
#else
                    p_conn->path, p_conn->host,
#endif
		    langStr, osVerStr, videoStr, countryStr);
		} /* if (p_conn->useProxy) */
		if (interError == SOCK_SEND_ABORT) {
		    handle_error(URL_RET_ABORTED);
		} else if (interError == SOCK_SEND_ERR) {
		    p_conn->msg = @MsgConnectErr;
		    handle_error(URL_RET_MESSAGE);
		}
            }

            MemUnlock(p_conn->postData) ;
        } else {
            /* Do a GET command */
	    if (p_conn->useProxy && !p_conn->secure) {
            interError = sock_printf(p_conn, p_conn->buffer,
#ifdef PERSISTANT_CONNECTIONS
#ifdef DO_DBCS
                "GET %S://%S:%d%S %s\r\n"
#else
                "GET %s://%s:%d%s %s\r\n"
#endif
#else
#ifdef DO_DBCS
                "GET %S://%S:%d%S " HTTPVER10 "\r\n"
#else
                "GET %s://%s:%d%s " HTTPVER10 "\r\n"
#endif
#endif
#ifdef DO_DBCS
                "Host: %S\r\n"
#else
                "Host: %s\r\n"
#endif
                "User-Agent: " USER_AGENT "\r\n",
		p_conn->type, p_conn->host, p_conn->hostPort,
#ifdef PERSISTANT_CONNECTIONS
                p_conn->path, httpVer, p_conn->host,
#else
                p_conn->path, p_conn->host,
#endif
			    langStr, osVerStr, videoStr, countryStr);
	    }
	    else {
            interError = sock_printf(p_conn, p_conn->buffer,
#ifdef PERSISTANT_CONNECTIONS
#ifdef DO_DBCS
                "GET %S %s\r\n"
#else
                "GET %s %s\r\n"
#endif
#else
#ifdef DO_DBCS
                "GET %S " HTTPVER10 "\r\n"
#else
                "GET %s " HTTPVER10 "\r\n"
#endif
#endif
#ifdef DO_DBCS
                "Host: %S\r\n"
#else
                "Host: %s\r\n"
#endif
                "User-Agent: " USER_AGENT "\r\n",
#ifdef PERSISTANT_CONNECTIONS
                p_conn->path, httpVer, p_conn->host,
#else
                p_conn->path, p_conn->host,
#endif
			    langStr, osVerStr, videoStr, countryStr);
	    } /* if (p_conn->useProxy) */
	    if (interError == SOCK_SEND_ABORT) {
		handle_error(URL_RET_ABORTED);
	    } else if (interError == SOCK_SEND_ERR) {
		p_conn->msg = @MsgConnectErr;
		handle_error(URL_RET_MESSAGE);
	    }
        }
	/* send Referer:, if any */
	if (p_conn->refererChunk) {
	    MemLock(p_conn->heap);
	    interError = sock_printf(p_conn, p_conn->buffer,
#ifdef DO_DBCS
			"Referer: %S\r\n",
#else
			"Referer: %s\r\n",
#endif
			LMemDerefHandles(p_conn->heap, p_conn->refererChunk));
	    MemUnlock(p_conn->heap);
	    if (interError == SOCK_SEND_ABORT) {
		handle_error(URL_RET_ABORTED);
	    } else if (interError == SOCK_SEND_ERR) {
		p_conn->msg = @MsgConnectErr;
		handle_error(URL_RET_MESSAGE);
	    }
	}

#ifdef PERSISTANT_CONNECTIONS
	/* send pesistant connection header, if not proxy */
	if (!p_conn->dontUsePersistant) {
	    interError = sock_printf(p_conn, NULL, persistHeader);
	    if (interError == SOCK_SEND_ABORT) {
		handle_error(URL_RET_ABORTED);
	    } else if (interError == SOCK_SEND_ERR) {
		p_conn->msg = @MsgConnectErr;
		handle_error(URL_RET_MESSAGE);
	    }
	}
#endif

#ifdef GET_RANGE
	/* handle retry range */
	if (p_conn->resumePos) {
	    interError = sock_printf(p_conn, p_conn->buffer,
				     "Range: bytes=%ld-%ld\r\n",
				     p_conn->resumePos,
				     p_conn->resumePos + p_conn->resumeLength-1);
	    if (interError == SOCK_SEND_ABORT) {
		handle_error(URL_RET_ABORTED);
	    } else if (interError == SOCK_SEND_ERR) {
		p_conn->msg = @MsgConnectErr;
		handle_error(URL_RET_MESSAGE);
	    }
	}
#endif

#ifdef CACHE_VALIDATION
	/* make conditional request, if we have last mod date and GET */
	if (p_conn->lastModDate.CDT_year &&
	    (!p_conn->postData || bPostIsGet)) {
	    TimerDateAndTime lastModTDAT;
	    /* format HTTP-date into p_conn->buffer */
	    lastModTDAT.TDAT_year = p_conn->lastModDate.CDT_year + 1980;
	    lastModTDAT.TDAT_month = p_conn->lastModDate.CDT_month;
	    lastModTDAT.TDAT_day = p_conn->lastModDate.CDT_day;
	    lastModTDAT.TDAT_hours = p_conn->lastModDate.CDT_hours;
	    lastModTDAT.TDAT_minutes = p_conn->lastModDate.CDT_minutes;
	    lastModTDAT.TDAT_seconds = p_conn->lastModDate.CDT_seconds;
	    lastModTDAT.TDAT_dayOfWeek = LocalCalcDayOfWeek(
		lastModTDAT.TDAT_year,
		lastModTDAT.TDAT_month,
		lastModTDAT.TDAT_day);
	    LocalCustomFormatDateTime(p_conn->buffer,
		"|SW|, |ZD| |SM| |LY| |Zh|:|Zm|:|Zs| GMT\r\n",  /* RFC822 */
		&lastModTDAT);
	    interError = sock_printf(p_conn, NULL, "If-Modified-Since: ");
	    if (!interError) {
		interError = sock_printf(p_conn, NULL, p_conn->buffer);
	    }
	    if (interError == SOCK_SEND_ABORT) {
		handle_error(URL_RET_ABORTED);
	    } else if (interError == SOCK_SEND_ERR) {
		p_conn->msg = @MsgConnectErr;
		handle_error(URL_RET_MESSAGE);
	    }
	    conditionalRequest = TRUE;
	}
#endif

        /* Send a password if there is one */
        if (*p_conn->userpwd) {
            base64encode(p_conn->userpwd, p_conn->buffer);
            interError = sock_printf(p_conn, NULL, "Authorization: Basic ");
	    if (!interError)
		interError = sock_printf(p_conn, NULL, p_conn->buffer);
	    if (!interError)
		interError = sock_printf(p_conn, NULL, "\r\n");
	    if (interError == SOCK_SEND_ABORT) {
		handle_error(URL_RET_ABORTED);
	    } else if (interError == SOCK_SEND_ERR) {
		p_conn->msg = @MsgConnectErr;
		handle_error(URL_RET_MESSAGE);
	    }
        }

#ifdef COOKIE_ENABLE
        /* Send cookies, if any */
	interError = SendCookies(p_conn);
	if (interError == SOCK_SEND_ABORT) {
            handle_error(URL_RET_ABORTED);
        } else if (interError == SOCK_SEND_ERR) {
	    p_conn->msg = @MsgConnectErr;
	    handle_error(URL_RET_MESSAGE);
	}
#endif

        /* Send a post if we are doing that */
        if (p_conn->postData && !bPostIsGet) {
            ppost = MemLock(p_conn->postData) ;

            if (ppost) {
		dword contentLength;
		FormStringCallbackStatus status = FSCS_NO_ERROR;

                /* send encoding type */
                switch (ppost->encoding) {
                case FORM_STRING_ENCODING_URL:
                    interError = sock_printf(p_conn, NULL,
                        "Content-Type: application/x-www-form-urlencoded\r\n");
		    contentLength = ppost->numChars-1;
                    break;
                case FORM_STRING_ENCODING_MULTI:
		    /* boundary string is at start of ppost->data */
                    interError = sock_printf(p_conn, p_conn->buffer,
                        "Content-Type: multipart/form-data; boundary=%s\r\n",
			ppost->data);
		    contentLength = ppost->contentLength;
                    break;
                }

                /* Tell how big the data is (and end the header) */
		if (!interError)
		    interError = sock_printf(p_conn, p_conn->buffer,
                    "Content-Length: %ld\r\n\r\n", contentLength) ;

		/* handle error */
		if (interError == SOCK_SEND_ABORT) {
		    handle_error(URL_RET_ABORTED);
		} else if (interError == SOCK_SEND_ERR) {
		    p_conn->msg = @MsgConnectErr;
		    handle_error(URL_RET_MESSAGE);
		}

                /* Now send the data */
		switch (ppost->encoding) {
		case FORM_STRING_ENCODING_URL:
#ifdef SSL_ENABLE
                if (p_conn->secure) {
                    if (SSL_write(p_conn->ssl, ppost->data, ppost->numChars-1) == ppost->numChars-1) {
                        err = SE_NORMAL;
                    } else {
                        /* typical SSL error, need expanded error info? */
                        err = SE_OUT_OF_MEMORY;
                    }
                } else {
                    err = SocketSend(p_conn->sock, ppost->data, ppost->numChars-1, NULL, 0);
                }
#else
                err = SocketSend(p_conn->sock, ppost->data, ppost->numChars-1, NULL, 0);
#endif
		break;
                case FORM_STRING_ENCODING_MULTI:
		{
		    word bufferUsed;
		    /* Send the status updates to trigger the upload progress
		       dialog, but only if there's enough data to make it 
		       remain visible long enough to warrant the effort. */
		    Boolean bSendStatus = (contentLength > 2 * sizeof(p_conn->buffer));
		    length = 0L;

		    if (bSendStatus && p_conn->callback) {
			((pcfm_URLDrvCallback *)ProcCallFixedOrMovable_pascal)(
			    _TEXT("multipart/form-data"),
			    -1, -1, p_conn->token, p_conn->callback);
		    }
#ifdef RECV_SPEED
		    p_conn->startTime = TimerGetCount();
#endif
		    /* Call the callback routine and send the returned data
		       until an error occurs, the end is reached, or the user
		       aborts. */
		    while (status != FSCS_DONE && !err && !p_conn->aborted && 
			   (status = ((pcfm_FormStringCallback *)
			    ProcCallFixedOrMovable_pascal)(
			    ppost, (byte *)p_conn->buffer, sizeof(p_conn->buffer),
			    &bufferUsed, ppost->callback)) != FSCS_ERROR) {

			/* Unlock the FormString while we send the data. */
			MemUnlock(p_conn->postData) ;
#ifdef SSL_ENABLE
			if (p_conn->secure) {
			    if (SSL_write(p_conn->ssl, p_conn->buffer, bufferUsed) == bufferUsed) {
				err = SE_NORMAL;
			    } else {
				/* typical SSL error, need expanded error info? */
				err = SE_OUT_OF_MEMORY;
			    }
			} else {
			    err = SocketSend(p_conn->sock, p_conn->buffer, bufferUsed, NULL, 0);
			}
#else
			err = SocketSend(p_conn->sock, p_conn->buffer, bufferUsed, NULL, 0);
#endif
			length += bufferUsed;

			/* Lock the FormString again. */
			ppost = MemLock(p_conn->postData) ;
#ifdef RECV_SPEED
			strcpy(statusBuffer, LMemDeref(@StatusRequest));
			if ((TimerGetCount() - p_conn->startTime + 1) > 30) {
			    bytesPerSec = 60*length/(TimerGetCount() -
						     p_conn->startTime + 1);
			    if (bytesPerSec < 1023) {
				sprintf(&(statusBuffer[strlen(statusBuffer)]),
					_TEXT(" (%ld b/s)"), bytesPerSec);
			    } else {
				sprintf(&(statusBuffer[strlen(statusBuffer)]),
					_TEXT(" (%ld.%ld Kb/s)"), (bytesPerSec/1024),
					(bytesPerSec-((bytesPerSec/1024)*1024))/103);
			    }
			}
#endif
			if (bSendStatus && p_conn->callback) /* notify caller of progress */
			    ((pcfm_URLDrvCallback *)ProcCallFixedOrMovable_pascal)(
#ifdef RECV_SPEED
				statusBuffer, length,
#else
				LMemDeref(@StatusReceiving), length,
#endif
				ppost->contentLength, p_conn->token,
				p_conn->callback);

			/* Give the user a chance to interrupt the send. */
			ConnectionUnlock(conn) ;
			p_conn = ConnectionLock(conn) ;
		    }
		    /* Tell the callback to cleanup its act. */
		    ((pcfm_FormStringCallback *)ProcCallFixedOrMovable_pascal)(
			ppost, NULL, 0, &bufferUsed, ppost->callback);
		    if (status == FSCS_ERROR)
		    {
			MemUnlock(p_conn->postData) ;
			handle_error(URL_RET_MESSAGE);
		    }
		}
                MemUnlock(p_conn->postData) ;

                if (err != SE_NORMAL || status == FSCS_ERROR) {
		    p_conn->sockErr = err;
                    p_conn->msg = @MsgPostErr;
                    handle_error(URL_RET_MESSAGE);
		} else if (p_conn->aborted) {
		    handle_error(URL_RET_ABORTED);
		}
		}
            } else {
                MemUnlock(p_conn->postData) ;
            }
        } else {
            interError = sock_printf(p_conn, NULL, "\r\n");
	    if (interError == SOCK_SEND_ABORT) {
		handle_error(URL_RET_ABORTED);
	    } else if (interError == SOCK_SEND_ERR) {
		p_conn->msg = @MsgConnectErr;
		handle_error(URL_RET_MESSAGE);
	    }
        }

        if (p_conn->callback)
            ((pcfm_URLDrvCallback *)ProcCallFixedOrMovable_pascal)(
                LMemDeref(@StatusWaiting), -1, -1, p_conn->token, p_conn->callback);

        /* receive and analyze header */
        ConnectionUnlock(conn) ;
        contentlength = 0L;  /* in case header() doesn't specify */
	responseCode = 100;  /* begin header processing */
	while (responseCode == 100) {
	    rcode = header(conn, &contentlength, &responseCode);
	}
#ifdef CACHE_VALIDATION
	notModified = (responseCode == 304);
#endif
        p_conn = ConnectionLock(conn) ;

#if PROGRESS_DISPLAY
        /* disable loading progress if small file */
        if (contentlength < progressMinCL) {
            if (p_conn->loadProgressDataP) {
                p_conn->loadProgressDataP->LPD_callback = NULL;
            }
        }
#endif

	length = 0L;  /* set here in case of header error when
		         re-using socket */

#ifdef CACHE_VALIDATION
	/* if not-modified, don't read body, just return URL_RET_FILE
	   with cached item */
	if ((URLRequestGetRet(rcode) == URL_RET_FILE &&
	    (!conditionalRequest || !notModified)) ||
	    /* or redirection with valid content */
	    (URLRequestGetRet(rcode) == URL_RET_URL_REDIR &&
	     contentlength != CL_UNKNOWN)) {
#else
        if (URLRequestGetRet(rcode) == URL_RET_FILE) {
#endif
            /*
               we wait until the last moment to open the output file
               if any specified so that we won't overwrite the file
               in case of error in contacting server
            */

#ifdef RECV_SPEED
            p_conn->startTime = TimerGetCount();
#endif

            MemLock(p_conn->heap);
#ifdef GET_RANGE
	    if (p_conn->resumePos && responseCode == 206) {
		output = FileOpen(
		    LMemDerefHandles(p_conn->heap, p_conn->fileChunk),
		    FILE_ACCESS_RW | FILE_DENY_RW);
		if (output) {
		    /* move to position to append new stuff */
		    FilePos(output, p_conn->resumePos, FILE_POS_START);
		}
	    } else {
		output = FileCreate(
		    LMemDerefHandles(p_conn->heap, p_conn->fileChunk),
		    (FILE_CREATE_TRUNCATE | FCF_NATIVE) |
		    (FILE_ACCESS_RW | FILE_DENY_RW),
		    0);
	    }
#else
            output = FileCreate(
                LMemDerefHandles(p_conn->heap, p_conn->fileChunk),
                (FILE_CREATE_TRUNCATE | FCF_NATIVE) |
                (FILE_ACCESS_RW | FILE_DENY_RW),
                0);
#endif
            MemUnlock(p_conn->heap);

            if (output) {
                length = 0L;
                /* Allow any buffered data from header() to be written in case
                   there was no header at all. */
@ifdef DO_DBCS
                i = strlensbcs(p_conn->buffer);
@else
                i = strlen(p_conn->buffer);
@endif

		/* report mime-type (if any), in case client wants
			   to use it */
		if (p_conn->callback && p_conn->mimeTypeChunk) {
		    MemLock(p_conn->heap);
		    ((pcfm_URLDrvCallback *)ProcCallFixedOrMovable_pascal)(
			LMemDerefHandles(p_conn->heap,
					 p_conn->mimeTypeChunk),
			-1, -1, p_conn->token, p_conn->callback);
		    MemUnlock(p_conn->heap);
		}

                do {
                    if (i) {                     /* already got some data? write it */
			/* handle no mime type (peek at start for <HTML>) */
			if ((length == 0) &&(p_conn->mimeTypeChunk == 0)) {
			    if (HeaderlessHTML(p_conn)) {
				ChunkStrcpy(p_conn->heap,
					    &(p_conn->mimeTypeChunk),
					    LMemDeref(@MimeTypeHTML));
			    }
			}

#if PROGRESS_DISPLAY
                /* notify of loading progress (only first time through) */
                if ((length == 0) && p_conn->loadProgressDataP && p_conn->loadProgressDataP->LPD_callback) {
                    ((pcfm_LoadProgressCallback *)ProcCallFixedOrMovable_pascal)(
                        p_conn->loadProgressDataP, LPCT_OPEN, 0, 0,
                        p_conn->loadProgressDataP->LPD_callback);
                }
#endif

                        if (FileWrite(output, p_conn->buffer, i, FALSE) != i) {
                            /* report error if write fails */
                            rcode = URLRequestMakeRet(URL_RET_MESSAGE) | URB_RF_NOCACHE;
                            p_conn->msg = @MsgFileError;
                            break;
                        }
                        length += i;

#if PROGRESS_DISPLAY
                        /* update loading progress data stream */
                        if (p_conn->loadProgressDataP && p_conn->loadProgressDataP->LPD_callback) {
                            /* notify of new data available */
                            ((pcfm_LoadProgressCallback *)ProcCallFixedOrMovable_pascal)(
                                p_conn->loadProgressDataP, LPCT_WRITE,
                                p_conn->buffer, i,
                                p_conn->loadProgressDataP->LPD_callback);
                        }
#endif
                    }

#ifdef RECV_SPEED
                    strcpy(statusBuffer, LMemDeref(@StatusReceiving));
                    if ((TimerGetCount() - p_conn->startTime + 1) > 30) {
                        bytesPerSec = 60*length/(TimerGetCount() -
                            p_conn->startTime + 1);
                        if (bytesPerSec < 1023) {
                            sprintf(&(statusBuffer[strlen(statusBuffer)]),
                                _TEXT(" (%ld b/s)"), bytesPerSec);
                        } else {
                            sprintf(&(statusBuffer[strlen(statusBuffer)]),
                                _TEXT(" (%ld.%ld Kb/s)"), (bytesPerSec/1024),
                                (bytesPerSec-((bytesPerSec/1024)*1024))/103);
                        }
                    }
#endif

                    if (p_conn->callback)      /* notify caller of progress */
                        ((pcfm_URLDrvCallback *)ProcCallFixedOrMovable_pascal)(
#ifdef GET_RANGE
#ifdef RECV_SPEED
                            statusBuffer, length + p_conn->resumePos,
#else
                            LMemDeref(@StatusReceiving), length + p_conn->resumePos,
#endif
                            (contentlength==CL_UNKNOWN)? -1:contentlength + p_conn->resumePos, p_conn->token,
#else
#ifdef RECV_SPEED
                            statusBuffer, length,
#else
                            LMemDeref(@StatusReceiving), length,
#endif
                            (contentlength==CL_UNKNOWN)? -1:contentlength, p_conn->token,
#endif
                            p_conn->callback);

                } while ((!p_conn->aborted) &&
			 /* stop if got desired amount */
			 length < contentlength &&
                    (i = SocketGetBlock(conn, &p_conn, FALSE)) > 0);

		/* can't re-use socket if data overflow */
		if (length > contentlength) {
		    p_conn->allowSocketCache = FALSE;
		    EC_WARNING(-1);
		}

                /* No content, but some error message: return it */
                if (!length && p_conn->msg)
                    rcode = URLRequestMakeRet(URL_RET_MESSAGE) | URB_RF_NOCACHE;
                else if (i<0) {                /* No data received because of error */
                    strcpy(p_conn->errBuf, LMemDeref(@ErrorGeneral));
                    p_conn->msg = @MsgReceiveErr;
                    rcode = URLRequestMakeRet(URL_RET_MESSAGE) | URB_RF_NOCACHE;
                }

                /* We got back a file, but it is either empty or not of the
                   size specified in the header: return an error. */
                if (URLRequestGetRet(rcode)==URL_RET_FILE) {
#if 0  /* have more tolerance for mismatching lengths */
                    if ((contentlength != CL_UNKNOWN) && length != contentlength) {
                        p_conn->msg = @MsgBadLength;
                        rcode = URLRequestMakeRet(URL_RET_MESSAGE) | URB_RF_NOCACHE;
                    } else
#endif
                        if (!length) {
                        p_conn->msg = @MsgNoData;
                        rcode = URLRequestMakeRet(URL_RET_MESSAGE) | URB_RF_NOCACHE;
                    }
                }

                if (p_conn->aborted)         /* abort signal? */
                    rcode = URLRequestMakeRet(URL_RET_ABORTED);

                FileClose(output, FALSE);

#if PROGRESS_DISPLAY
                /* finish loading progress data stream */
                if (p_conn->loadProgressDataP && p_conn->loadProgressDataP->LPD_callback) {
                    /* if have data, notify of data finished */
		    if (length) {
			((pcfm_LoadProgressCallback *)ProcCallFixedOrMovable_pascal)(
			    p_conn->loadProgressDataP, LPCT_CLOSE, 0, 0,
			    p_conn->loadProgressDataP->LPD_callback);
			/* signal progress finished (unless aborted) */
			if (p_conn->aborted) {
			    rcode = URLRequestMakeRet(URL_RET_PROGRESS_ABORT) | ((rcode & URB_RF_NOCACHE) ? URB_RF_NOCACHE : 0);
			} else {
			    rcode = URLRequestMakeRet(URL_RET_PROGRESS) | ((rcode & URB_RF_NOCACHE) ? URB_RF_NOCACHE : 0);
			}
		    } else {
			/* no data received */
			if (!p_conn->msg) {
			    p_conn->msg = @MsgNoData;
			}
			rcode = URLRequestMakeRet(URL_RET_MESSAGE) | URB_RF_NOCACHE;
		    }
                }
#endif

#if PROGRESS_DISPLAY
                if (URLRequestGetRet(rcode) != URL_RET_FILE &&
                    URLRequestGetRet(rcode) != URL_RET_PROGRESS)
#else
                if (URLRequestGetRet(rcode) != URL_RET_FILE)
#endif
		    /* this will clean up URL_RET_URL_REDIR files also */
                {
#ifdef GET_RANGE
		    deleteFile = TRUE;
#else
                    MemLock(p_conn->heap);
                    FileDelete(LMemDerefHandles(p_conn->heap, p_conn->fileChunk));
                    MemUnlock(p_conn->heap);  /* remove bad file */
#endif
#ifdef GET_RANGE
                } else {
		    deleteFile = FALSE;
#endif
		}
            } else {
                rcode = URLRequestMakeRet(URL_RET_MESSAGE) | URB_RF_NOCACHE;
                /* error if create fails */
                p_conn->msg = @MsgFileError;
            }
#ifdef PERSISTANT_CONNECTIONS
	} else {
	    /* eat data for non-URL_RET_FILE or not-modifieds */
	    do {
	    } while ((!p_conn->aborted) &&
		     (SocketGetBlock(conn, &p_conn, TRUE)) > 0);
#endif
        }

#ifdef PERSISTANT_CONNECTIONS  /********************************************/

	/* if success, cache socket */
	if (URLRequestGetRet(rcode) != URL_RET_MESSAGE &&
	    URLRequestGetRet(rcode) != URL_RET_PROGRESS_ABORT &&
	    p_conn->allowSocketCache &&
	    !p_conn->secure &&  /* SSL sockets aren't cached */
	    persistantConnections) {
	    if (!p_conn->socketFromCache) {  /* if not already cached */
		if (!PutSocketInCache(p_conn)) {
		    /* couldn't cache */
		    goto cacheErr;  /* ack too many conditionals, use goto */
		}
	    }
	    DoneUsingCachedSocket(p_conn);
	} else {
cacheErr:
	    /* close socket */
	    /* notify caller of progress */
	    if (p_conn->callback)
		((pcfm_URLDrvCallback *)ProcCallFixedOrMovable_pascal)(
		    LMemDeref(@StatusClosing), -1, -1,
		    p_conn->token, p_conn->callback);
	    /* if cached, remove from cache */
	    if (p_conn->socketFromCache) {
		RemoveSocketFromCache(p_conn);
		/* if error, retry (unless we actually got something) */
		if (!length && URLRequestGetRet(rcode) == URL_RET_MESSAGE) {
		    retry = TRUE;
		}
	    }
 #ifdef SSL_ENABLE
	    /* close socket (clears p_conn->sock) */
	    SocketMyClose(p_conn);
 #else
	    sock = p_conn->sock ;
/*          ConnectionUnlock(conn) ; */
	    if (sock)
		SocketMyClose(sock);        /* closing necessary? */
/*          p_conn = ConnectionLock(conn) ; */
	    p_conn->sock = NullHandle ;
 #endif  /* SSL_ENABLE */
	}

#else  /* PERSISTANT_CONNECTIONS ********************************************/

        /* Closing may also take a while... */
        if (p_conn->callback)                        /* notify caller of progress */
            ((pcfm_URLDrvCallback *)ProcCallFixedOrMovable_pascal)(
                LMemDeref(@StatusClosing), -1, -1, p_conn->token, p_conn->callback);

 #ifdef SSL_ENABLE
        SocketMyClose(p_conn);
 #else
        sock = p_conn->sock ;
/*      ConnectionUnlock(conn) ; */
        if (sock)
            SocketMyClose(sock);        /* closing necessary? */
/*      p_conn = ConnectionLock(conn) ; */
        p_conn->sock = NullHandle ;
 #endif  /* SLL_ENABLE */

#endif  /* PERSISTANT_CONNECTIONS *******************************************/

        doClose = FALSE;

        /* Check to see if we need to get authorization */
        if (URLRequestGetRet(rcode) == URL_RET_AUTHORIZATION) {
            ThreadPSem(G_syncPassword);
            /* Yep.  Sure do.  Let's ask for a username and password */
            if (GetUserPassword(p_conn->host, p_conn->userpwd)) {
		if (G_passwordBlock) {
		    passwordP = MemLock(G_passwordBlock);
		    strcpy(passwordP->pwdhost, p_conn->host);
		    passwordP->port = hostaddr.RTA_sock.SA_port.SP_port;
		    strcpy(passwordP->userpwd, p_conn->userpwd);
		    MemUnlock(G_passwordBlock);
		    retry = TRUE ;
		    /* if memory error and no G_passwordBlock, auth will
		       fail, user will have to quit browser and restart to
		       try to allocate G_passwordBlock */
		}
            }
            ThreadVSem(G_syncPassword);
        }

#ifdef GET_RANGE
	if (
	    /* resume supported */
	    p_conn->allowResume &&
	    /* ...and not already retrying */
	    !retry &&
	    /* ...and got some data and desired length */
	    length && contentlength && (contentlength != CL_UNKNOWN) &&
	    /* ...but not enough data */
	    (length != contentlength) &&
	    /* ...and short-read error */
	    (URLRequestGetRet(rcode) == URL_RET_MESSAGE)) {
	    p_conn->resumePos += length;
	    p_conn->resumeLength = contentlength - length;
	    retry = TRUE;
	} else {
/*	    asm {nop};*/
	    if (deleteFile) {
		MemLock(p_conn->heap);
		FileDelete(LMemDerefHandles(p_conn->heap, p_conn->fileChunk));
		MemUnlock(p_conn->heap);  /* remove bad file */
		deleteFile = FALSE;
	    }
	}
#endif

#ifdef PERSISTANT_CONNECTIONS
error_retry: ;
#endif
    } while (retry == TRUE) ;

#ifdef CACHE_VALIDATION
    /* if not-modified, just return URL_RET_FILE, and set special flag. */
    if (URLRequestGetRet(rcode) == URL_RET_FILE && 
        conditionalRequest && notModified)
    {
      rcode |= URB_RF_UNTOUCHED;
    }
#endif

    error_exit:
    if (doClose) {
#ifdef SSL_ENABLE
        SocketMyClose(p_conn);
#else
        sock = p_conn->sock ;
/*      ConnectionUnlock(conn) ; */
        if (sock)
            SocketMyClose(sock);
/*      p_conn = ConnectionLock(conn) ; */
        p_conn->sock = NullHandle ;
#endif
    }

#ifdef SSL_ENABLE
    /* handle retry for SSL errors (after closing socket) */
    if (p_conn->secure && sslRetries &&
	URLRequestGetRet(rcode) == URL_RET_MESSAGE) {
	sslRetries--;
	retry = TRUE;
    }
#endif

#ifdef PERSISTANT_CONNECTIONS
    /* if handle_error macro is hit, we'll retry from here for
       cached sockets */
    if (retry == TRUE) goto error_retry;
#endif

#ifdef SSL_ENABLE
    if (p_conn->secure) {
        ThreadVSem(sslSem);
        /* never cache HTTPS pages */
        rcode |= URB_RF_NOCACHE;
    }
#endif

    /* don't cache if POST */
    if (p_conn->postData) {
	ppost = MemLock(p_conn->postData);
	if (!(ppost->flags & FORM_STRING_FLAG_IS_GET_METHOD)) {
	    rcode |= URB_RF_NOCACHE;
	}
	MemUnlock(p_conn->postData);
    }

    if (pathB) MemFree(pathB);

    ConnectionUnlock(conn) ;

    return rcode;
}

void BuildVideoStr(void);

/* entry_URLDrvMain URLDrvMain */
word _pascal _export URLDrvMain(_URLMainParams_)
{
    word rcode;
    T_HTTPConnection *p_conn ;
    HTTPConnectionHandle conn ;
    URLRequestBlock *req;

    /* build video string for User-Agent string, if not built yet */
    BuildVideoStr();

    req = MemLock(request);

    conn = ConnectionAllocate(req->URB_token) ;
    if (conn == HTTP_CON_NONE) {
        MemUnlock(request);
        return URLRequestMakeRet(URL_RET_NO_MEMORY) ;
    }

    p_conn = ConnectionLock(conn) ;
    p_conn->abortState = URL_ABORT_STATE_NORMAL ;
    p_conn->socketState = STATE_PREPARING;      /* we have an operation going on */
    p_conn->aborted = FALSE;                    /* not aborted yet */

    p_conn->msg = NullOptr ;
    p_conn->callback = req->URB_progress ;
    p_conn->postData = postData ;

    p_conn->heap = request;
    p_conn->mimeTypeChunk = 0 ;
    p_conn->fileChunk = req->URB_file ;
    p_conn->urlChunk = req->URB_url ;
    p_conn->refererChunk = req->URB_referer;
#ifdef CACHE_VALIDATION
    p_conn->lastModDate = req->URB_lastModDate;
#endif
#ifdef EMAIL_ACCT_CMD
    p_conn->emailCmd = 0;
#endif
    p_conn->sockErr = 0;

    /* these aren't actually used */
    req->URB_date = URL_TIME_UNKNOWN;   /* dates unknown yet */
    req->URB_expireDate = URL_TIME_UNKNOWN;

#if PROGRESS_DISPLAY
    /* set up loading progress data */
    p_conn->loadProgressDataP = req->URB_loadProgressDataP;
#endif

    ConnectionUnlock(conn) ;
    MemUnlock(request);

    /* perform request after locking frequently used message resource */
    MemLock(OptrToHandle(@StatusLocating));
    rcode = HTTPGet(conn);
    MemUnlock(OptrToHandle(@StatusLocating));

    /* Interpret the return values */
    p_conn = ConnectionLock(conn) ;
    p_conn->socketState = STATE_UNCONNECTED; /* free again */
#if PROGRESS_DISPLAY
    if ((p_conn->aborted) && (p_conn->abortState ==
        URL_ABORT_STATE_IGNORE_USER_INTERRUPT_MESSAGE) &&
        URLRequestGetRet(rcode) != URL_RET_PROGRESS_ABORT)
#else
    if ((p_conn->aborted) && (p_conn->abortState ==
        URL_ABORT_STATE_IGNORE_USER_INTERRUPT_MESSAGE))
#endif
    {
        /* Return a blank message */
	p_conn->msg = NullOptr;  /* copied to req->URB_message below */
        rcode = URLRequestMakeRet(URL_RET_MESSAGE) | URB_RF_NOCACHE ;
    } else {
        if (URLRequestGetRet(rcode) == URL_RET_MESSAGE) {
            p_conn->msg = ToolsFormatMessage(p_conn->msg, p_conn->errBuf);
            /* return optr to data block */
        }
    }

    /* Set up request buffer with return values. */
    req = MemLock(request);
    req->URB_mimeType = p_conn->mimeTypeChunk ;
    req->URB_url = p_conn->urlChunk ;
    req->URB_message = p_conn->msg ;
#ifdef CACHE_VALIDATION
    /* using current system time is accurate enough for timestamp */
    req->URB_cacheTime = TimerGetCount()/60;  /* convert ticks to seconds */
    req->URB_maxAge = p_conn->maxAge;
    req->URB_lastModDate = p_conn->lastModDate;
#endif
#ifdef EMAIL_ACCT_CMD
    req->URB_extraData = p_conn->emailCmd;
#else
    req->URB_extraData = 0;
#endif
    req->URB_errorCode = p_conn->sockErr;
    MemUnlock(request);

    /* if we get here and there's something in the error buffer, make sure
       we don't cache it (it'll be an error HTML message from the server) */
    if (*p_conn->errBuf) rcode |= URB_RF_NOCACHE;

    /* Set STATE_FREE before unlocking so ConnectionFind will ignore us. */
    p_conn->socketState = STATE_FREE;

    ConnectionUnlock(conn) ;
    ConnectionFree(conn) ;

    return rcode;                       /* pass back return data type */
}

#pragma codeseg MiscCode

/* entry_URLDrvAbort URLDrvAbort */
void _pascal _export URLDrvAbort(_URLAbortParams_)
{
    T_HTTPConnection *p_conn ;
    HTTPConnectionHandle connHan ;

    connHan = ConnectionFind(token, &p_conn) ;
    if (connHan != HTTP_CON_NONE) {
	p_conn->abortState = state ;
	p_conn->aborted = TRUE;                     /* flag: abort as quickly as possible */
	if (p_conn->socketState != STATE_UNCONNECTED) {   /* are we doing something? */
#if 1
/* Perhaps multiple stops cause alot of problems. */
	    switch (p_conn->socketState) {
	    case STATE_RESOLVING:           /* interrupt resolution of address */
		SocketInterruptResolve(
		    HTTP_DOMAIN,
		    (byte*)&p_conn->hostname, sizeof(p_conn->hostname.UTA_link)+strlen(p_conn->hostname.UTA_ip)*sizeof(TCHAR));
		break;
	    case STATE_HTTP_REQUEST:        /* interrupt regular socket operation */
		if (p_conn->sock)
		    SocketInterrupt(p_conn->sock);
		break;
	    }
#endif
        }
        ConnectionUnlock(connHan) ;
    }
}

/* entry_URLDrvInfo URLDrvInfo */
char * _pascal _export URLDrvInfo(_URLInfoParams_)
{
#ifdef SSL_ENABLE
    #define SCHEMES _TEXT("HTTP\0") \
                    _TEXT("HTTPS\0") \
                    _TEXT("\0")
#else
    #define SCHEMES _TEXT("HTTP\0") \
                    _TEXT("\0")
#endif

    /* Return list of supported schemes */
    return memcpy(buf, SCHEMES, sizeof(SCHEMES));
}

/* entry_URLDrvFlush URLDrvFlush */
void _pascal _export URLDrvFlush(void)
{
#ifdef COOKIE_ENABLE
    CookiesWrite();
#endif
}

void BuildVideoStr(void)
{
    DisplayScheme disp;
    EventHandle ev;
    SizeAsDWord scrSize;

    /* Believe it or not, we need a semaphore around this operation. */
    ThreadPSem(buildVideoStrSem);

    /* build videoStr, if not built yet */
    if (*videoStr == C_NULL) {
	@call application::MSG_GEN_APPLICATION_GET_DISPLAY_SCHEME(&disp);
	strcpy(videoStr, ((disp.DS_displayType&DT_DISP_ASPECT_RATIO) ==
			  (DAR_TV << DT_DISP_ASPECT_RATIO_OFFSET) ?
			  _TEXT("TV") : _TEXT("Monitor")));
	ev = @record VisClass::MSG_VIS_GET_SIZE();
	scrSize = @call {MSG_VIS_GET_SIZE} application::MSG_GEN_CALL_PARENT(ev);
	sprintf(videoStr+strlen(videoStr), _TEXT(" %dx%d "), DWORD_WIDTH(scrSize),
		DWORD_HEIGHT(scrSize));
	strcat(videoStr, (UserGetDefaultUILevel() == UIIL_INTRODUCTORY) ?
	       _TEXT("CUI") : _TEXT("AUI"));
    }
    ThreadVSem(buildVideoStrSem);
}

void Initialize(void)
{
    word size;
#ifdef SOCKET_CLOSE_THREAD
    Boolean haveCloseThread = TRUE;  /* default = TRUE */
#endif

#ifdef SOCKET_CLOSE_THREAD
    /* allocate close thread */
    InitFileReadBoolean("http", "socketCloseThread", &haveCloseThread);
    if (haveCloseThread) {
	@call process::MSG_PROCESS_CREATE_EVENT_THREAD(&closeThread,
						       (ClassStruct *)SocketCloseProcessClass,
						       SOCKET_CLOSE_STACK_SIZE);
    }
#endif
    ConnectionsInit() ;
    G_syncPassword = ThreadAllocSem(1) ;
    HandleModifyOwner(G_syncPassword, GeodeGetCodeProcessHandle()) ;
    G_passwordBlock = MemAllocSetOwner(GeodeGetCodeProcessHandle(),
				       sizeof(HTTPPassword),
				       HF_DYNAMIC|HF_SHARABLE, HAF_STANDARD|HAF_ZERO_INIT);
#if 0
#ifdef COOKIE_ENABLE
    InitCookies();
#endif
#endif
#ifdef SSL_ENABLE
    SSLeay_add_ssl_algorithms();
//    ssl_ctx = SSL_CTX_new(SSLv2_client_method());
//enable SSL 3.0/TLS 1.0
    ssl_ctx = SSL_CTX_new(SSLv23_client_method());
    sslSem = ThreadAllocSem(1);
    HandleModifyOwner(sslSem, GeodeGetCodeProcessHandle()) ;
#endif
    /* get os version string */
    if (InitFileReadStringBuffer("system", "version",
        osVerStr, sizeof(osVerStr), &size)) {
        strcpy(osVerStr, _TEXT("1.0"));
    }
    /* get language string */
    if (InitFileReadStringBuffer("http", "language",
				 langStr, sizeof(langStr), &size)) {
	strcpy(langStr, _TEXT("en"));
    }
    /* get country string */
    if (InitFileReadStringBuffer("http", "country",
				 countryStr, sizeof(countryStr), &size)) {
	strcpy(countryStr, _TEXT("US"));
    }
#if PROGRESS_DISPLAY
    /* get minimum content length for progress display */
    InitFileReadInteger(PROGRESS_INI_CAT, PROGRESS_INI_CL_KEY, &progressMinCL);
#endif
#ifdef PERSISTANT_CONNECTIONS
    /* get persistant connections flag */
    InitFileReadBoolean("http", "persistantConnections", &persistantConnections);
    if (!persistantConnections) {
	*persistHeader = '\0';
	strcpysbcs(httpVer, HTTPVER10);
    }
    /* allocate empty socket cache */
    socketCacheBlock = MemAllocSetOwner(GeodeGetCodeProcessHandle(),
					sizeof(SocketCacheEntry)*
					NUM_CACHED_SOCKETS,
					HF_DYNAMIC|HF_SHARABLE,
					HAF_STANDARD|HAF_ZERO_INIT);
    /* allocate socket cache access semaphore */
    socketCacheSem = ThreadAllocSem(1);
    HandleModifyOwner(socketCacheSem, GeodeGetCodeProcessHandle());
#endif
    /* Allocate semaphore used when building the video string. */
    buildVideoStrSem = ThreadAllocSem(1);
    HandleModifyOwner(buildVideoStrSem, GeodeGetCodeProcessHandle());
}

#ifdef SOCKET_CLOSE_THREAD
void DestroySocketCloseThread(void)
{
    if (closeThread) {
	/*
	 * Allocate a queue and pass it as the destination to MSG_META_DETACH.
	 * When that message is handled and ThreadDestroy is called, it will
	 * as one of its last acts send MSG_META_ACK to the passed queue.
	 * When this happens, it is safe to continue execution and allow
	 * the thread process class (and this library) to go away.
	 *
	 * Note that this routine cannot be called as part of handling LCT_DETACH,
	 * as both FreeGeode and ThreadDestroy lock the geode semaphore,
	 * resulting in threadlock if one occurs as part of the other.
	 * LCT_CLIENT_EXIT is fine, so long as we verify our library reference
	 * count to be one.
	 */
	QueueHandle queue = GeodeAllocQueue();
	@send (ConstructOptr(closeThread, 0))::
	    MSG_META_DETACH(0, ConstructOptr(queue, NullChunk));
	ObjFreeMessage(QueueGetMessage(queue));
	GeodeFreeQueue(queue);
	closeThread = NullHandle;
    }
}
#endif

void Deinitialize(void)
{
#ifdef PERSISTANT_CONNECTIONS
    SocketCacheEntry *sc;
    int i;
#endif

    ConnectionsDeinit() ;

    ThreadFreeSem(G_syncPassword) ;
    MemFree(G_passwordBlock);
#if 0
#ifdef COOKIE_ENABLE
    CleanupCookies();
#endif
#endif
#ifdef SSL_ENABLE
    SSL_CTX_free(ssl_ctx);
    ThreadFreeSem(sslSem);
#endif
#ifdef PERSISTANT_CONNECTIONS
    if (socketCacheSem) ThreadFreeSem(socketCacheSem);
    if (socketCacheBlock) {
	sc = MemLock(socketCacheBlock);
	for (i = 0; i < NUM_CACHED_SOCKETS; i++) {
	    if (sc[i].socket) {
		CloseSocketNow(sc[i].socket);
	    }
	}
	MemFree(socketCacheBlock);
    }
#endif
    if (buildVideoStrSem != NullHandle) {
       ThreadFreeSem(buildVideoStrSem);
       buildVideoStrSem = NullHandle;
    }
}

#pragma argsused
Boolean _pascal _export WMG3HTTPEntry(LibraryCallType ty, GeodeHandle client)
{
    if (ty == LCT_ATTACH)
        Initialize();
#ifdef SOCKET_CLOSE_THREAD
    else if (ty == LCT_CLIENT_EXIT && GeodeGetInfo(GeodeGetCodeProcessHandle(),
      GGIT_GEODE_REF_COUNT, NULL) == 1)
	DestroySocketCloseThread();
#endif
    else if (ty == LCT_DETACH)
        Deinitialize();

    return FALSE;
}

#pragma codeseg
