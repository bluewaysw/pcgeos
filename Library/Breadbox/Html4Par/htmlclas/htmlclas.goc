/***********************************************************************
 *
 *                          ==CONFIDENTIAL INFORMATION==
 *
 * COPYRIGHT 1994-99 BREADBOX COMPUTER COMPANY -- ALL RIGHTS RESERVED  --
 * THE FOLLOWING CONFIDENTIAL INFORMATION IS BEING DISCLOSED TO YOU UNDER
 * A NON-DISCLOSURE AGREEMENT AND MAY NOT BE DISCLOSED OR FORWARDED BY THE
 * RECIPIENT TO ANY OTHER PERSON OR ENTITY NOT COVERED BY THE SAME
 * NON-DISCLOSURE AGREEMENT COVERING THE RECIPIENT. USE OF THE FOLLOWING
 * CONFIDENTIAL INFORMATION IS RESTRICTED TO THE TERMS OF THE NON-DISCLOSURE
 * AGREEMENT.
 *
 * PROJECT:       HTMLView
 * FILE:          HTMLClas.goc
 *
 * AUTHOR:        Marcus Grï¿½ber
 *
 * NOTES:         This file implements the HTMLTextClass, which is a
 *                subclass of VisLargeTextClass. HTMLTextClass can
 *                load and display HTML data from a file, manage
 *                hyperlinks and send out notifications when the user
 *                moves the mouse over a hotspot or clicks on one.
 *                On the other hand, HTMLTextClass doesn't know
 *                anything about URLs or navigation issues.
 *
 ***********************************************************************/
@include <stdapp.goh>
@include <Objects/Text/tCtrlC.goh>

#include <Ansi/string.h>
#include <Ansi/stdio.h>
#include <Ansi/stdlib.h>

@include "options.goh"
@include <html4par.goh>
#include <htmldrv.h>

#include <hwlib.h>
#include "regiont.h"
#include "internal.h"
#include "tableint.h"
#include "errors.h"

#define REPLACE_GRAPHIC_REGION_NEW_HEIGHT MAX_REGION_HEIGHT

/**************************************************************************
 *              HTML Viewer Object class
 **************************************************************************/
@classdecl HTMLTextClass;

/* Declared in HTMLCLRT.GOC */
@extern method HTMLTextClass, MSG_HTML_TEXT_HOTSPOT_NOTIFY;
@extern method HTMLTextClass, MSG_HTML_TEXT_HOTSPOT_PTR;
@extern method HTMLTextClass, MSG_HTML_TEXT_HOTSPOT_SELECT;
@extern method HTMLTextClass, MSG_HTML_TEXT_LINK_FROM_POS;
@extern method HTMLTextClass, MSG_HTML_TEXT_FOCUS_FROM_POS;
@extern method HTMLTextClass, MSG_HTML_TEXT_HIT_FROM_COORD;
@extern method HTMLTextClass, MSG_HTML_TEXT_LINK_FROM_MAP;
@extern method HTMLTextClass, MSG_HTML_TEXT_SELECT_LINK;
@extern method HTMLTextClass, MSG_HTML_TEXT_PREV_HOTSPOT;
@extern method HTMLTextClass, MSG_HTML_TEXT_NEXT_HOTSPOT;
@extern method HTMLTextClass, MSG_HTML_TEXT_EXEC_HOTSPOT;
@extern method HTMLTextClass, MSG_HTML_TEXT_EXEC_NTH_HOTSPOT;
@extern method HTMLTextClass, MSG_META_LARGE_START_SELECT,
                              MSG_META_LARGE_PTR;
@extern method HTMLTextClass, MSG_META_LARGE_START_MOVE_COPY;
@extern method HTMLTextClass, MSG_META_KBD_CHAR;
@extern method HTMLTextClass, MSG_VIS_DRAW;
@extern method HTMLTextClass, MSG_VIS_TEXT_GRAPHIC_VARIABLE_SIZE;
@extern method HTMLTextClass, MSG_VIS_TEXT_GRAPHIC_VARIABLE_DRAW;
@extern method HTMLTextClass, MSG_HTML_TEXT_FORM_ELEMENT_FROM_POS ;
@extern method HTMLTextClass, MSG_HTML_TEXT_FORM_ELEMENT_START ;
@extern method HTMLTextClass, MSG_HTML_TEXT_GET_LINK_COUNT;
@extern method HTMLTextClass, MSG_HTML_TEXT_GET_LINK;
@extern method HTMLTextClass, MSG_HTML_TEXT_SET_LINK;
@ifdef JAVASCRIPT_SUPPORT
@extern method HTMLTextClass, MSG_HTML_TEXT_FIRE_EVENT;
@extern method HTMLTextClass, MSG_HTML_TEXT_FOCUS_FORM_ELEMENT;
@extern method HTMLTextClass, MSG_HTML_TEXT_KBD_ACTIVATE;
@endif

/* Declared in HTMLFORM.GOC */
/* this fixed a bug (1436) where JS was used to move focus, not needed for
   JS version -- brianc 10/26/00 */
@ifndef JAVASCRIPT_SUPPORT
@extern method HTMLTextClass, MSG_META_GAINED_FOCUS_EXCL;
@endif
@extern method HTMLTextClass, MSG_HTML_TEXT_FIND_FOCUS_FORM_ELEMENT;

@extern method HTMLTextClass, MSG_HTML_TEXT_INITIALIZE_FORM_ELEMENTS ;
@extern method HTMLTextClass, MSG_HTML_TEXT_DEINITIALIZE_FORM_ELEMENTS ;

@extern method HTMLTextClass, MSG_HTML_TEXT_FORM_RESET ;
@extern method HTMLTextClass, MSG_HTML_TEXT_FORM_RESET_ELEMENT ;
@extern method HTMLTextClass, MSG_HTML_TEXT_FORM_SUBMIT ;
@extern method HTMLTextClass, MSG_HTML_TEXT_FORM_APPEND_ELEMENT ;

@extern method HTMLTextClass, MSG_HTML_TEXT_GET_FORM_ELEMENT_COUNT;
@extern method HTMLTextClass, MSG_HTML_TEXT_GET_FORM_ELEMENT;
@extern method HTMLTextClass, MSG_HTML_TEXT_SET_FORM_ELEMENT;
@extern method HTMLTextClass, MSG_HTML_TEXT_ADD_OPTION_ELEMENT;
@extern method HTMLTextClass, MSG_HTML_TEXT_REMOVE_OPTION_ELEMENT;
@extern method HTMLTextClass, MSG_HTML_TEXT_IDENTIFY_MIME_TYPE;

/* Declared in HTMLFEDI.GOC */
@extern method HTMLTextClass, MSG_HTML_TEXT_FORM_ELEMENT_INVALIDATE ;

/* Declared in HTMLTABL.GOC */
@extern method HTMLTextClass, MSG_VIS_LARGE_TEXT_APPEND_REGION;
@extern method HTMLTextClass, MSG_VIS_LARGE_TEXT_REGION_IS_LAST;
@extern method HTMLTextClass, MSG_VIS_TEXT_GENERATE_NOTIFY;
@extern method HTMLTextClass, MSG_HTML_TEXT_RECALC_PAGE;
@extern method HTMLTextClass, MSG_HTML_TEXT_RECALC_COLUMNS;
@extern method HTMLTextClass, MSG_HTML_TEXT_INITIALIZE_LAYOUT;
@extern method HTMLTextClass, MSG_HTML_TEXT_DRAW_TABLE_FRAME;
@extern method HTMLTextClass, MSG_HTML_TEXT_CALCULATE_LAYOUT ;
@extern method HTMLTextClass, MSG_HTML_TEXT_ANIMATIONS_UPDATE ;

/* Declared in HTMLTDRW.GOC */
@extern method HTMLTextClass, MSG_META_CONTENT_VIEW_SIZE_CHANGED;
@extern method HTMLTextClass, MSG_META_CONTENT_VIEW_SCALE_FACTOR_CHANGED;

/* Declared in HTMLTPOS.GOC */
@extern method HTMLTextClass, MSG_HTML_TEXT_CALCULATE_LAYOUT ;
@extern method HTMLTextClass, MSG_HTML_TEXT_CALCULATE_BOUNDARIES ;

/* Animation process */
@extern method HTMLTextClass, MSG_HTML_TEXT_ANIMATIONS_ON ;
@extern method HTMLTextClass, MSG_HTML_TEXT_ANIMATIONS_OFF ;
@extern method HTMLTextClass, MSG_HTML_TEXT_DRAW_ANIMATION_CHANGES ;
@extern method HTMLTextClass, MSG_HTML_TEXT_FORM_ELEMENT_GRAB ;
@extern method HTMLTextClass, MSG_HTML_TEXT_FORM_ELEMENT_RELEASE ;
@extern method HTMLTextClass, MSG_HTML_TEXT_FORM_ELEMENT_START_AFTER_GRAB ;
@extern method HTMLTextClass, MSG_HTML_TEXT_FORM_ELEMENT_REMOVE_TEXT_ENTRY;
/* @extern method HTMLTextClass, MSG_HTML_TEXT_INTERNAL_INVALIDATE_SWATH ; */

@extern method HTMLTextClass, MSG_HTML_TEXT_INTERNAL_LAYOUT_UPDATE_EVENT ;
@extern method HTMLTextClass, MSG_HTML_TEXT_LAYOUT_START ;
@extern method HTMLTextClass, MSG_HTML_TEXT_LAYOUT_STOP ;

@extern method HTMLTextClass, MSG_HTML_TEXT_INTERNAL_INIT_INVAL_AREA ;
@extern method HTMLTextClass, MSG_HTML_TEXT_INTERNAL_COLLECT_INVAL_AREA ;
@extern method HTMLTextClass, MSG_HTML_TEXT_INTERNAL_FLUSH_INVAL_AREA ;

#pragma codeseg HTMLCLAS_INIT_TEXT

/* "-dc" causes vptrs for text constants if different code segments are used */
#pragma option -dc-

@method HTMLTextClass, MSG_HTML_TEXT_INIT_STORAGE
{
#if COMPILE_OPTION_HUGE_ARRAY_REGIONS
    /* Text object will be created with a huge array */
    pself->VLTI_attrs |= VLTA_REGIONS_IN_HUGE_ARRAY | VLTA_CACHE_REGION_CALCS ;
#else
    ChunkHandle regionArray ;

    regionArray = ChunkArrayCreate(OptrToHandle(oself),
      sizeof(VisLargeTextRegionArrayElement), 0, 0);
                                        /* allocate array for region data */
    pself = ObjDerefVis(oself);         /* refresh pointer */
    pself->VLTI_regionArray = regionArray ; /* store pointer to region data */
#endif

    pself->HTI_emptyFile = fileHan;     // Store file to use for "empty" state

    EC_PurgeES();

    @call self::MSG_VIS_TEXT_SET_VM_FILE(fileHan);
    @call self::MSG_VIS_LARGE_TEXT_CREATE_DATA_STRUCTURES();
    @call self::MSG_VIS_TEXT_CREATE_STORAGE(
      VTSF_MULTIPLE_CHAR_ATTRS | VTSF_MULTIPLE_PARA_ATTRS | VTSF_GRAPHICS,
      TRUE);
    RegionPurgeCache(oself) ;
    @call oself::MSG_HTML_TEXT_WAITING_IMAGES_CREATE() ;
}

@method HTMLTextClass, MSG_HTML_TEXT_DEINIT_EXTRA
{
    int i, formCount;
    optr formArray;
    word size;
    HTMLformData *p_formData;

    if(pself->HTI_pendingAnchor != NAME_POOL_NONE)
    {
      NamePoolReleaseToken(pself->HTI_namePool, pself->HTI_pendingAnchor);
      pself->HTI_pendingAnchor = NAME_POOL_NONE;
    }

    if(pself->HTI_namePool)
    {
      NamePoolVMUnload(pself->HTI_namePool);
      pself->HTI_namePool = NullOptr;   // Detach from name pool
    }
    
    if(pself->HTI_imageArray)
    {
      MemFree(OptrToHandle(pself->HTI_imageArray));
      pself->HTI_imageArray = NullOptr;
    }

    if(pself->HTI_anchorArray)
    {
      MemFree(OptrToHandle(pself->HTI_anchorArray));
      pself->HTI_anchorArray = NullOptr;
    }

    if(pself->HTI_formArray)
    {
      MemLock(OptrToHandle(pself->HTI_formArray));
      /* free line info data */
      formArray = pself->HTI_formArray;
      formCount = ChunkArrayGetCount(formArray);
      for (i = 0; i < formCount; i++) {
	  p_formData = ChunkArrayElementToPtr(formArray, i, &size);
	  if (p_formData->HFD_itemType == HTML_FORM_TEXTAREA) {
	      /* free line info block */
	      if (p_formData->HFD_var.textarea.lines) {
		  MemFree(p_formData->HFD_var.textarea.lines);
		  p_formData->HFD_var.textarea.lines = 0;
	      }
	  }
      }
      MemFree(OptrToHandle(formArray));
      pself = ObjDerefVis(oself);
      pself->HTI_formArray = NullOptr;
    }
    pself->HTI_grabbedFormElement = FORM_ELEMENT_INVALID ;

    if(pself->HTI_mapArray)
    {
      MemFree(OptrToHandle(pself->HTI_mapArray));
      pself->HTI_mapArray = NullOptr;
    }

    if(pself->HTI_tableArray)
    {
#if (!COMPILE_OPTION_HUGE_ARRAY_CELLS)
      TableArrayDestroy(pself->HTI_tableArray);
      pself = ObjDerefVis(oself);
#endif
      pself->HTI_tableArray = NullHandle;
    }

    if(pself->HTI_cellArray)
    {
#if (!COMPILE_OPTION_HUGE_ARRAY_CELLS)
      CellArrayDestroy(pself->HTI_cellArray) ;
      pself = ObjDerefVis(oself);
#endif
      pself->HTI_cellArray = NullHandle ;
    }

    if(pself->HTI_eventArray)
    {
      MemFree(OptrToHandle(pself->HTI_eventArray));
      pself->HTI_eventArray = NullOptr;
    }

    @call self::MSG_HTML_TEXT_SET_BACKGROUND(CA_NULL_ELEMENT);
                                        /* free background image */
}

@method HTMLTextClass, MSG_VIS_TEXT_DELETE_ALL
{
    VisLargeTextRegionArrayElement *p;
    word i, size, n;
    T_regionArrayHandle rah ;

    /* Stop any ensuing animations */
    @call oself::MSG_HTML_TEXT_ANIMATIONS_OFF() ;

    /* Get rid of all the data related to the forms */
    @call oself::MSG_HTML_TEXT_DEINITIALIZE_FORM_ELEMENTS() ;

    /* work around problems with multi-section delete by removing section
       divisions before actually deleting. */

    /* Unmark all the sections */
    rah = RegionArrayConstruct(oself, pself) ;
    n = RegionArrayGetCount(rah);
    RegionPurgeCache(oself) ;
    for(i=0; i<n; i++)
    {
      RegionLock(rah, i, &p, &size) ;
      p->VLTRAE_section = 0;
      RegionDirty(p) ;
      RegionUnlock(p) ;
    }

    @call self::MSG_HTML_TEXT_DEINIT_EXTRA();

    @callsuper();
}

@method HTMLTextClass, MSG_HTML_TEXT_DEINIT_STORAGE
{
    RegionPurgeCache(oself) ;
    @call self::MSG_VIS_TEXT_DELETE_ALL();
                                        /* remove old text */

    /*
     * Free the large text data structures and make the text object small
     * again.
     */
    @call self::MSG_VIS_TEXT_FREE_ALL_STORAGE(TRUE);
    @call self::MSG_VIS_TEXT_SET_VM_FILE(NullHandle);
    @call oself::MSG_HTML_TEXT_WAITING_IMAGES_DESTROY() ;
}

/*
 * Magic character marking an anchor that describes a text position as an
 * 8-digit hex number.
 */ 
#define POSITION_ANCHOR_MARKER '\x01'

@method HTMLTextClass, MSG_HTML_TEXT_GOTO_ANCHOR
{
    optr array;
    optr view = pself->HTI_myView;
    HTMLanchorData *anchorArrayElement;
    word i = -1,size;
    dword pos;
    NameToken myAnchor;
    VisTextConvertOffsetParams vtcop;
    TCHAR buf[POSITION_ANCHOR_SIZE];

    myAnchor = NamePoolTokenizeFromPool(pself->HTI_namePool,
      pool, anchor, FALSE);               // Identify token in local pool

    if(myAnchor != NAME_POOL_NONE)
    {
      array = pself->HTI_anchorArray;
      if(array)
      {
        MemLock(OptrToHandle(array));

        for(i=ChunkArrayGetCount(array)-1; (int)i>=0; i--)
        {
          anchorArrayElement = ChunkArrayElementToPtr(array, i, &size);
          if( (anchorArrayElement->flags & HTML_ADF_NAME) &&
              anchorArrayElement->linkOrName == myAnchor )
          {
            pos = anchorArrayElement->pos; /* remember position */
            break;                         /* abort if anchor was found */
          }
        }

        MemUnlock(OptrToHandle(array));
      }
      
      /* not found - try default anchors */
      if ((int)i < 0) {
	  if (NamePoolTestEqualI(pself->HTI_namePool, myAnchor, _TEXT("top"))) {
	      i = 0;
	      pos = 0;
	  }
      }

      /* still no luck: try if it is a position anchor */
      if ((int)i < 0) {
          NamePoolCopy(pself->HTI_namePool, buf, sizeof(buf), myAnchor, NULL);
          if(buf[0]==POSITION_ANCHOR_MARKER)
          {                             /* is it a position anchor? */
            if(!UtilAsciiToHex32((char*) buf+1, &pos))
              i = 0;                    /* success: use this position */
          }
      }
    }
    else                                /* no anchor specified: go to top */
    {
      i = 0;
      pos = 0;
    }

    if((int)i >= 0)                     /* anchor found: go there */
    {
      vtcop.VTCOP_offset = pos;
      @call self::MSG_VIS_TEXT_CONVERT_OFFSET_TO_COORDINATE(&vtcop);

      /* If region is still hidden, save anchor for later */
      if(vtcop.VTCOP_yPos >= HTML_TEXT_REGION_HIDDEN_Y)
      {
        pself = ObjDerefVis(oself);
        if(pself->HTI_pendingAnchor != NAME_POOL_NONE)
          NamePoolReleaseToken(pself->HTI_namePool, pself->HTI_pendingAnchor);
        pself->HTI_pendingAnchor = myAnchor;
        if(myAnchor != NAME_POOL_NONE)
          NamePoolUseToken(pself->HTI_namePool, myAnchor);
      }
      else                              /* area present: go there */
      {
        @call view::MSG_GEN_VIEW_MAKE_RECT_VISIBLE(
          MRVF_ALWAYS_SCROLL | MRVF_USE_MARGIN_FROM_TOP_LEFT,
          0,
          MRVF_ALWAYS_SCROLL | MRVF_USE_MARGIN_FROM_TOP_LEFT,
          0,
          vtcop.VTCOP_yPos,
          vtcop.VTCOP_xPos,
          vtcop.VTCOP_yPos,
          vtcop.VTCOP_xPos) ;
      }
    }

   if(myAnchor != NAME_POOL_NONE)
      NamePoolReleaseToken(pself->HTI_namePool, myAnchor);

    return ((int)i >= 0);               /* return success state */
}

#pragma codeseg HTMLCLAS_IMAGE_TEXT

/* "-dc" causes vptrs for text constants if different code segments are used */
#pragma option -dc-

/**************************************************************************
 *            MSG_HTML_TEXT_CREATE_POSITION_ANCHOR for HTMLTextClass
 **************************************************************************
 *
 * Description:
 *     Create a pseudo anchor for marking the character position of a
 *     scrolled window. The anchor is returned in the form of
 *     "#<something>" in the passed buffer, which must be at least
 *     POSITION_ANCHOR_SIZE bytes long. This is only used internally
 *     for putting frame locations including their scroll position
 *     into the history list.
 *
 *     An empty string is returned if the document is at the top.
 *
 * Outputs:
 *     char *buf                  -- Anchor to be appended to URL
 *
 **************************************************************************/
@method HTMLTextClass, MSG_HTML_TEXT_CREATE_POSITION_ANCHOR
{
    dword pos;
    PointDWord origin;
    PointDWFixed p;
    
    /* Get current position of view... */
    @call pself->HTI_myView::MSG_GEN_VIEW_GET_ORIGIN(&origin);
    
    /* ...blow it up into a PointDWFixed... */
    p.PDF_x.DWF_int = origin.PD_x;
    p.PDF_y.DWF_int = origin.PD_y;
    p.PDF_x.DWF_frac = p.PDF_y.DWF_frac = 0;

    /* ...and convert it into a text position */
    pos = @call self::MSG_VIS_TEXT_GET_TEXT_POSITION_FROM_COORD(&p);

    if(pos)                             // Only use anchor for non-zero position
      sprintf(buf, _TEXT("\x23%c%08ld"), POSITION_ANCHOR_MARKER, pos);
    else
      *buf = 0;    
}

@method HTMLTextClass, MSG_HTML_TEXT_GET_IMAGE_COUNT
{
    word n;

    n = 0;                              /* default: no images  */

    if(pself->HTI_imageArray)           /* image array? */
    {
      MemLock(OptrToHandle(pself->HTI_imageArray));
      n = ChunkArrayGetCount(pself->HTI_imageArray);
                                        /* return number of image entries */
      MemUnlock(OptrToHandle(pself->HTI_imageArray));
    }

    return n;
}

@method HTMLTextClass, MSG_HTML_TEXT_GET_IMAGE
{
    word size;
    HTMLimageData *imageArrayElement;

    MemLock(OptrToHandle(pself->HTI_imageArray));

    imageArrayElement = ChunkArrayElementToPtr(pself->HTI_imageArray,
      nImage, &size);                   /* deference token to image record */
    memcpy(data, imageArrayElement, sizeof(HTMLimageData));

    MemUnlock(OptrToHandle(pself->HTI_imageArray));

    return TRUE;                        /* successful */
}

/**************************************************************************
 *            MSG_HTML_TEXT_MARK_IMAGE_??? for HTMLTextClass
 **************************************************************************
 *
 * Description:
 *     Modify state flags of images for the various phases in image
 *     loading: unresolved/resolving/broken. Marking an image as resolved
 *     takes place through MSG_HTML_TEXT_UPDATE_IMAGE because it also
 *     required additional information of what it has been resolved to.
 *
 * Inputs:
 *     word nImage                -- Index of image in image array
 *
 **************************************************************************/
@method HTMLTextClass, MSG_HTML_TEXT_MARK_IMAGE_UNRESOLVED,
                       MSG_HTML_TEXT_MARK_IMAGE_RESOLVING,
                       MSG_HTML_TEXT_MARK_IMAGE_BROKEN
{
    word size;
    HTMLimageData *iae;
    WordFlags toClear, toSet;

    switch(message)
    {
      case MSG_HTML_TEXT_MARK_IMAGE_BROKEN:
        toSet = HTML_IDF_BROKEN | HTML_IDF_RESOLVED;
        toClear = HTML_IDF_RESOLVING | HTML_IDF_SIZE_DIRTY;
        break;

      case MSG_HTML_TEXT_MARK_IMAGE_UNRESOLVED:
        toSet = 0;
        toClear = HTML_IDF_RESOLVING | HTML_IDF_RESOLVED | 
                  HTML_IDF_BROKEN | HTML_IDF_SIZE_DIRTY;
        break;
      
      case MSG_HTML_TEXT_MARK_IMAGE_RESOLVING:
        toSet = HTML_IDF_RESOLVING;
        toClear = HTML_IDF_RESOLVED | HTML_IDF_BROKEN | HTML_IDF_SIZE_DIRTY;
        break;
    }

    MemLock(OptrToHandle(pself->HTI_imageArray));

    iae = ChunkArrayElementToPtr(pself->HTI_imageArray,
      nImage, &size);                   /* deference token to image record */

    /* Modify flags */
    iae->flags |= toSet;
    iae->flags &= ~toClear;

    /* Make sure we're note associated with any graphic */
    iae->HID_cacheToken = 0;
    iae->HID_vmf = 0;
    iae->HID_vmb = 0;

    MemUnlock(OptrToHandle(pself->HTI_imageArray));

    /* force broken image to update */
    if(message == MSG_HTML_TEXT_MARK_IMAGE_BROKEN)
    {
      @call self::MSG_HTML_TEXT_INVALIDATE_IMAGE(NULL, nImage, 0, 0xFFFF) ;
    }

    return TRUE;                        /* successful */
}

@method HTMLTextClass, MSG_HTML_TEXT_TEST_UNRESOLVED_IMAGES
{
    optr array;
    HTMLimageData *imageArrayElement;
    word i,size;
    Boolean ret;

    ret = FALSE;                        /* default: no images found */
    if(pself->HTI_imageArray)
    {
      MemLock(OptrToHandle(pself->HTI_imageArray));

      array = pself->HTI_imageArray;
      for(i=ChunkArrayGetCount(array)-1; (int)i>=0; i--)
      {
        imageArrayElement = ChunkArrayElementToPtr(array, i, &size);
        if((imageArrayElement->flags & HTML_IDF_RESOLVED) == 0)
        {
          ret = TRUE;                   /* found unresolved image? abort */
          break;
        }
      }

      MemUnlock(OptrToHandle(pself->HTI_imageArray));
    }

    return ret;                         /* no unresolved images */
}

void LOCAL TrackArrayReplace(optr array, dword pos, sword len,
  word p_pos, word p_len)
{
    char *p;
    word i, size;

    if(array)
    {
      MemLock(OptrToHandle(array));
      for(i=ChunkArrayGetCount(array)-1; (int)i>=0; i--)
      {
        p = ChunkArrayElementToPtr(array, i, &size);

        /* fix ranges starting after change */
        if(pos < *(dword *)(p+p_pos))
          *(dword *)(p+p_pos) += len;

        /* fix ranges exclosing change */
        else if(p_len != 0xFFFF &&
                pos >= *(dword *)(p+p_pos) &&
                pos < *(dword *)(p+p_pos) + *(sword *)(p+p_len))
        {
          if(len>0 ||
             pos-len < *(dword *)(p+p_pos) + *(sword *)(p+p_len))
            *(sword *)(p+p_len) += len;
          else
            *(sword *)(p+p_len) = (pos - *(dword *)(p+p_pos));
        }
      }
      MemUnlock(OptrToHandle(array));
    }
}

@method HTMLTextClass, MSG_HTML_TEXT_TRACK_REPLACE
{
    /*
     * Update positions of images, links and form elements after modification.
     */
    if(len)                             /* zero change requires no action */
    {
      TrackArrayReplace(pself->HTI_imageArray, pos, len,
        word_offsetof(HTMLimageData, pos), 0xFFFF);
      TrackArrayReplace(pself->HTI_anchorArray, pos, len,
        word_offsetof(HTMLanchorData, pos), word_offsetof(HTMLanchorData, len));
      TrackArrayReplace(pself->HTI_formArray, pos, len,
        word_offsetof(HTMLformData, HFD_pos), 0xFFFF);
    }
}

#pragma codeseg HTMLCLAS_FREE_TEXT

/* "-dc" causes vptrs for text constants if different code segments are used */
#pragma option -dc-

void LOCAL FreeElementArray(VMFileHandle vmf, VMBlockHandle runs)
{
    TextLargeRunArrayHeader *tlrah;
    MemHandle memHandle;
    VMBlockHandle elements;

    if(runs)
    {
      tlrah = VMLock(vmf, runs, &memHandle);
      elements = tlrah->TLRAH_elementVMBlock;
      tlrah->TLRAH_elementVMBlock = 0;  /* array has been removed */
      VMDirty(memHandle);               /* make sure changes get saved */
      VMUnlock(memHandle);
    }

    VMFree(vmf, elements);              /* destroy element array */
}

void LOCAL FreeElementArrayVD(VMFileHandle vmf, optr obj, VardataKey key)
{
    VMBlockHandle *vmb;

    vmb = ObjVarFindData(obj, key);     /* attempt to find vardata with block */
    if(vmb)
      FreeElementArray(vmf, *vmb);      /* found? release it */
}

@method HTMLTextClass, MSG_VIS_TEXT_FREE_ALL_STORAGE
{
    /* Free elements in HugeArrays because the text object won't do it... */
    if(pself->VTI_storageFlags & VTSF_MULTIPLE_CHAR_ATTRS)
      FreeElementArray(pself->VTI_vmFile, pself->VTI_charAttrRuns);
    if(pself->VTI_storageFlags & VTSF_MULTIPLE_PARA_ATTRS)
      FreeElementArray(pself->VTI_vmFile, pself->VTI_paraAttrRuns);
    if(pself->VTI_storageFlags & VTSF_GRAPHICS)
      FreeElementArrayVD(pself->VTI_vmFile, oself, ATTR_VIS_TEXT_GRAPHIC_RUNS);
    if(pself->VTI_storageFlags & VTSF_TYPES)
      FreeElementArrayVD(pself->VTI_vmFile, oself, ATTR_VIS_TEXT_TYPE_RUNS);

    /* Override argument: we have already freed the element arrays, so
       don't try to do it again - this should ensure compatibility with a
       future fixed text object. */
    removeElementArrays = FALSE;

    @callsuper();

    pself = ObjDerefVis(oself);

    pself->VTI_storageFlags &= ~VTSF_LARGE;
    pself->VI_optFlags |= VOF_GEOMETRY_INVALID;

    pself->VLTI_regionArray = 0;        /* region array freed by superclass */
}

#pragma codeseg HTMLCLAS_TEXT

/* restore strings in code segment */
#pragma option -dc

#if 0
#if COMPILE_OPTION_HUGE_ARRAY_REGIONS
void near ICopyRegionPaths(
            VMBlockHandle srcRegionArray,
            VMBlockHandle destRegionArray,
            VMFileHandle srcFile,
            VMFileHandle destFile)
{
    word num ;
    VisLargeTextRegionArrayElement *p_src ;
    VisLargeTextRegionArrayElement *p_dest ;
    DBGroupAndItem path = NullHandle ;
    word size ;
    void *p_srcData ;
    void *p_destData ;

    /* Walk through both source and destination regions */
    /* (after copying over all the data) */
    num = HugeArrayGetCount(srcFile, srcRegionArray) ;
    HugeArrayLock(srcFile, srcRegionArray, 0, &p_src, &size) ;
    HugeArrayLock(destFile, destRegionArray, 0, &p_dest, &size) ;
    while (num)  {
        /* Found one to copy */
        if (p_src->VLTRAE_region)  {
            p_srcData = DBLockUngrouped(srcFile, p_src->VLTRAE_region) ;
            DBInfoUngrouped(srcFile, p_src->VLTRAE_region, &size) ;
            path = DBAllocUngrouped(destFile, size) ;
            p_destData = DBLockUngrouped(destFile, path) ;
            memcpy(p_destData, p_srcData, size) ;
            DBDirty(p_destData) ;
            DBUnlock(p_destData) ;
            DBUnlock(p_srcData) ;
        }

        /* Store in all cases and clear for the next */
        /* We want to make sure nothing in the destination has */
        /* references in the source */
        p_dest->VLTRAE_region = path ;
        HugeArrayDirty(p_dest) ;

        path = NullHandle ;
        HugeArrayNext(&p_src, &size) ;
        HugeArrayNext(&p_dest, &size) ;
        num-- ;
    }
    HugeArrayUnlock(p_src) ;
    HugeArrayUnlock(p_dest) ;
}
#else
void LOCAL ICopyRegionPaths(
            optr srcRegionArray,
            optr destRegionArray,
            VMFileHandle srcFile,
            VMFileHandle destFile)
{
    word num ;
    VisLargeTextRegionArrayElement *p_src ;
    VisLargeTextRegionArrayElement *p_dest ;
    DBGroupAndItem path = NullHandle ;
    word size ;
    void *p_srcData ;
    void *p_destData ;

    /* Walk through both source and destination regions */
    /* (after copying over all the data) */
    num = ChunkArrayGetCount(srcRegionArray) ;
    p_src = ChunkArrayElementToPtr(srcRegionArray, 0, NULL) ;
    p_dest = ChunkArrayElementToPtr(destRegionArray, 0, NULL) ;
    while (num)  {
        /* Found one to copy */
        if (p_src->VLTRAE_region)  {
            p_srcData = DBLockUngrouped(srcFile, p_src->VLTRAE_region) ;
            DBInfoUngrouped(srcFile, p_src->VLTRAE_region, &size) ;
            path = DBAllocUngrouped(destFile, size) ;
            p_destData = DBLockUngrouped(destFile, path) ;
            memcpy(p_destData, p_srcData, size) ;
            DBDirty(p_destData) ;
            DBUnlock(p_destData) ;
            DBUnlock(p_srcData) ;
        }

        /* Store in all cases and clear for the next */
        /* We want to make sure nothing in the destination has */
        /* references in the source */
        p_dest->VLTRAE_region = path ;
        path = NullHandle ;
        p_src++ ;
        p_dest++ ;
        num-- ;
    }
}
#endif
#endif


/**************************************************************************
 *            FreeHTMLTransferItem
 **************************************************************************
 *
 * Description:
 *     Free an HTML transfer item and all associated data not covered by
 *     the VMChain itself. Currently, these are only the DBItems for non-
 *     rectangular paths.
 *
 * Inputs:
 *     VMFileHandle vmf           -- VM file holding item
 *     VMChain vmc                -- VM chain of item
 *
 **************************************************************************/
void _export FreeHTMLTransferItem(VMFileHandle vmf, VMChain vmc)
{
    VisLargeTextRegionArrayElement *p;
    word i, size, n;
    T_regionArrayHandle rah ;
    HypertextTransferBlockHeader *htbh;
    MemHandle hypertextHeaderMem;
#if (!COMPILE_OPTION_HUGE_ARRAY_REGIONS)
    HypertextArrayBlockHeader *habh;
    MemHandle memHandle;
#endif

    /* lock down */
    htbh = VMLock(vmf, VMCHAIN_GET_VM_BLOCK(vmc), &hypertextHeaderMem);

#if (!COMPILE_OPTION_HUGE_ARRAY_REGIONS)
    /* lock down array block */
    habh = VMLockChainifiedLMemBlock(vmf,
      VMCHAIN_GET_VM_BLOCK(htbh->HTBH_arrayBlock), &memHandle);
    rah = ConstructOptr(memHandle, habh->HABH_regionArray);
#else
    rah = ConstructOptr(vmf, VMCHAIN_GET_VM_BLOCK(htbh->HTBH_regionArrayLink));
#endif

    /* remove all the DBitems for non-rectangular regions */
    if(OptrToChunk(rah))
    {
      n = RegionArrayGetCount(rah);
      for(i=0; i<n; i++)
      {
        RegionLock(rah, i, &p, &size) ;
        if(p->VLTRAE_region)
          DBFreeUngrouped(vmf, p->VLTRAE_region);
        RegionUnlock(p) ;
      }
    }

#if (!COMPILE_OPTION_HUGE_ARRAY_REGIONS)
    VMUnlock(memHandle);
#endif
    VMUnlock(hypertextHeaderMem);
        
    VMFreeVMChain(vmf, vmc);            // Remove the chain itself
}

#pragma codeseg HTMLCLAS_UPDATE_TEXT

/* "-dc" causes vptrs for text constants if different code segments are used */
#pragma option -dc-

void LOCAL IMarkAllImagesUnresolved(optr imageArray)
{
    HTMLimageData *imageArrayElement;
    word i ;

    /* Go through all the images and if a broken image is found, it */
    /* is converted to 'unresolved' and not broken. */
    if (imageArray)  {
      MemLock(OptrToHandle(imageArray));
      for(i=ChunkArrayGetCount(imageArray)-1; (int)i>=0; i--)  {
        imageArrayElement = ChunkArrayElementToPtr(imageArray, i, NULL);
        imageArrayElement->flags &= ~(HTML_IDF_RESOLVED | HTML_IDF_RESOLVING | 
                                      HTML_IDF_BROKEN | HTML_IDF_SIZE_DIRTY) ;

        /* Make sure we're note associated with any graphic */
        imageArrayElement->HID_cacheToken = 0;
        imageArrayElement->HID_resolvedURL = NAME_POOL_NONE;
        imageArrayElement->HID_vmf = 0;
        imageArrayElement->HID_vmb = 0;
      }
      MemUnlock(OptrToHandle(imageArray));
    }
}

#pragma codeseg HTMLCLAS_UPDATE_TEXT

/* "-dc" causes vptrs for text constants if different code segments are used */
#pragma option -dc-

optr LOCAL LMemCopyToBlock(MemHandle srcMem, ChunkHandle srcArray)
{
    optr array, newarr;
    word size;
    MemHandle newArrayMem;

    if(srcArray)
    {
      array = ConstructOptr(srcMem, srcArray);
      size = LMemGetChunkSize(array);

      newArrayMem = MemAllocLMem(LMEM_TYPE_GENERAL, 0);
      MemLock(newArrayMem);

      newarr = ConstructOptr(newArrayMem, LMemAlloc(newArrayMem, size));
      memcpy(LMemDeref(newarr), LMemDeref(array), size);

      MemUnlock(newArrayMem);
    }
    else
      newarr = 0;

    return newarr;
}

ChunkHandle LOCAL LMemCopyToChunk(MemHandle dstMem, ChunkHandle dstArray, optr array)
{
    optr newarr;
    word size;

    if(array)
    {
      MemLock(OptrToHandle(array));
      size = LMemGetChunkSize(array);

      if(dstArray)                      // do we have a chunk to update?
      {
        newarr = ConstructOptr(dstMem, dstArray);
        LMemReAlloc(newarr, size);      // reallocate to match source size
      }
      else                              // no: allocate a new one  
      {
        dstArray = LMemAlloc(dstMem, size);
        newarr = ConstructOptr(dstMem, dstArray);
      }
      memcpy(LMemDeref(newarr), LMemDeref(array), size);
      MemUnlock(OptrToHandle(array));
    }
    
    return dstArray;
}

#pragma codeseg HTMLCLAS_UPDATE_TEXT

/* "-dc" causes vptrs for text constants if different code segments are used */
#pragma option -dc-

@method HTMLTextClass, MSG_HTML_TEXT_UPDATE_ITEM
{
    HypertextArrayBlockHeader *habh;
    HypertextTransferBlockHeader *htbh;
    MemHandle memHandle, hypertextHeaderMem;
    ChunkHandle ch;
#if (!COMPILE_OPTION_HUGE_ARRAY_REGIONS)
    word size;   
#endif

    #define UpdateArray(_itemArray, _objArray) \
      ch = LMemCopyToChunk(memHandle, habh->_itemArray, pself->_objArray);\
      habh = MemDeref(memHandle);\
      habh->_itemArray = ch;

    RegionPurgeCache(oself) ;

    /* initialize main hypertext element header */
    htbh = VMLock(pself->VTI_vmFile, VMCHAIN_GET_VM_BLOCK(pself->HTI_transferItem),
      &hypertextHeaderMem);

    /* initialize array block */
    habh = VMLockChainifiedLMemBlock(pself->VTI_vmFile,
      VMCHAIN_GET_VM_BLOCK(htbh->HTBH_arrayBlock), &memHandle);

    /* update arrays in block */
    UpdateArray(HABH_imageArray, HTI_imageArray);
    UpdateArray(HABH_anchorArray, HTI_anchorArray);
    UpdateArray(HABH_formArray, HTI_formArray);
    UpdateArray(HABH_mapArray, HTI_mapArray);
    UpdateArray(HABH_eventArray, HTI_eventArray);
#if (!COMPILE_OPTION_HUGE_ARRAY_CELLS)
    UpdateArray(HABH_cellArray, HTI_cellArray);      
#endif
#if (!COMPILE_OPTION_HUGE_ARRAY_TABLES)
    UpdateArray(HABH_tableArray, HTI_tableArray);
#endif

    /* The small region array is updated in the same way as the others, but 
       it needs special treatment because it resides in our own block. */
#if (!COMPILE_OPTION_HUGE_ARRAY_REGIONS)
    size = LMemGetChunkSizeHandles(OptrToHandle(oself), pself->VLTI_regionArray);
    
    if(habh->HABH_regionArray)        // do we have a chunk to update?
    {
      LMemReAllocHandles(memHandle, habh->HABH_regionArray, size);      
                                      // reallocate to match source size
    }
    else                              // no: allocate a new one  
    {
      ch = LMemAlloc(memHandle, size);
      habh = MemDeref(memHandle);
      habh->HABH_regionArray = ch;
    }

    memcpy(
      LMemDerefHandles(memHandle, habh->HABH_regionArray), 
      LMemDerefHandles(OptrToHandle(oself), pself->VLTI_regionArray), 
      size);
#else
    htbh->HTBH_regionArrayLink = VMCHAIN_MAKE_FROM_VM_BLOCK(pself->VLTI_regionArray);
#endif

    htbh->HTBH_lineArrayLink = VMCHAIN_MAKE_FROM_VM_BLOCK(pself->VTI_lines);

    VMDirty(memHandle);                 /* make sure changes get saved */
    VMUnlockChainifiedLMemBlock(memHandle);

    /* Record the width we were last calculated at */
    htbh->HTBH_other.HTBHO_formattedWidth = pself->HTI_formattedWidth ;

    /* Record how many cells did get calculated */
    htbh->HTBH_other.HTBHO_numFormattedCells = pself->HTI_numFormattedCells ;

    /* Store the margins */
    htbh->HTBH_other.HTBHO_topMargin = pself->HTI_pageTopMargin ;
    htbh->HTBH_other.HTBHO_leftMargin = pself->HTI_pageLeftMargin ;

    VMDirty(hypertextHeaderMem);
    VMUnlock(hypertextHeaderMem);
}

@method HTMLTextClass, MSG_HTML_TEXT_ATTACH_TO_ITEM
{
    HypertextTransferBlockHeader *htbh;
    TextTransferBlockHeader *ttbh;
    VisTextWashColorModeRed wcModeRed;
    VisTextWashColorBlueGreen wcBlueGreen;
    MemHandle hypertextHeaderMem, textHeaderMem, hypertextArrayMem;
    HypertextArrayBlockHeader *habh;
    optr ret;
    word formattedWidth ;
#if !(COMPILE_OPTION_HUGE_ARRAY_REGIONS)       
    ChunkHandle newRegionArray ;
    word size ;
#endif
    word *runs;

    #define GetArray(_objArray, _item) \
      ret = LMemCopyToBlock(hypertextArrayMem, habh->_item); \
      pself = ObjDerefVis(oself); \
      pself->_objArray = ret;

    HWChecksumCheck() ;
    RegionPurgeCache(oself) ;

    /* Make sure that dynamic processes are deinitialized */
    @call oself::MSG_HTML_TEXT_LAYOUT_STOP();
    @call oself::MSG_HTML_TEXT_ANIMATIONS_OFF() ;
    @call oself::MSG_HTML_TEXT_DEINITIALIZE_FORM_ELEMENTS() ;

    /* Force a true purge of everything */
    RegionPurgeCache(oself) ;
    @call oself::MSG_VIS_LARGE_TEXT_PURGE_CACHED_INFO() ;

    HWChecksumCheck() ;
    @call oself::MSG_HTML_TEXT_WAITING_IMAGES_CLEAR() ;

    /*
     * Store old state information in current item, if any
     */
    pself = ObjDerefVis(oself);         // refresh pointer
    if(pself->HTI_transferItem)         // is there a previous item?
    {
      /* Update transfer item with current state */
      @call self::MSG_HTML_TEXT_UPDATE_ITEM();

      /* Free all items that are copied into the object on attaching */
      @call self::MSG_HTML_TEXT_DEINIT_EXTRA();

#if !(COMPILE_OPTION_HUGE_ARRAY_REGIONS)       
      /* Also free old copy of region array */
      pself = ObjDerefVis(oself);
      if (pself->VLTI_regionArray)
        LMemFreeHandles(OptrToHandle(oself), pself->VLTI_regionArray);

      RegionPurgeCache(oself) ;
#endif

      /* Set state in such a way that MSG_VIS_LARGE_TEXT_CREATE_DATA_STRUCTURES
         will not care about the existing transfer item. */
      pself = ObjDerefVis(oself);
      pself->VTI_storageFlags &= ~(VTSF_MULTIPLE_CHAR_ATTRS | 
        VTSF_MULTIPLE_PARA_ATTRS | VTSF_GRAPHICS | VTSF_LARGE);
      pself->VTI_lines = 0;
      pself->VTI_text = 0;
      pself->VLTI_regionArray = 0;
    }
    else
    {
      /* Clear everything we have at the moment */
      @call self::MSG_HTML_TEXT_DEINIT_STORAGE();
    }

    /* Ensure we have a waiting list */
    @call oself::MSG_HTML_TEXT_WAITING_IMAGES_CREATE() ;

    /*
     * Prepare for attaching to new item
     */
    @call oself::MSG_HTML_TEXT_DRAWING_ON_OFF(FALSE) ;
    pself = ObjDerefVis(oself);         /* refresh pointer */
    pself->HTI_layoutState &= ~(HTS_PAST_VIEW_HEIGHT | HTS_LAYOUT_NEED_TO_BLAST_HARD_MIN_WIDTHS) ;
                                        /* remove old text */
    HWChecksumCheck() ;
    pself = ObjDerefVis(oself);         /* refresh pointer */
    pself->VTI_vmFile = vmf;            // store our new VM file
    pself->HTI_transferItem = vmc;      // store our new transfer item

    if(vmc)                             // do we have an item to show?
    {
      htbh = VMLock(vmf, VMCHAIN_GET_VM_BLOCK(vmc), &hypertextHeaderMem);

      @call self::MSG_META_SUSPEND();   /* minimize screen update */

      /*
       * Transfer selected contents of regular text transfer item
       */
      ttbh = VMLock(vmf, VMCHAIN_GET_VM_BLOCK(htbh->HTBH_transferItem), 
        &textHeaderMem);

      pself = ObjDerefVis(oself);
      pself->VTI_storageFlags |= VTSF_MULTIPLE_CHAR_ATTRS | 
        VTSF_MULTIPLE_PARA_ATTRS | VTSF_GRAPHICS | VTSF_LARGE;
      pself->VTI_text = VMCHAIN_GET_VM_BLOCK(ttbh->TTBH_text);
      pself->VTI_charAttrRuns = VMCHAIN_GET_VM_BLOCK(ttbh->TTBH_charAttrRuns);
      pself->VTI_paraAttrRuns = VMCHAIN_GET_VM_BLOCK(ttbh->TTBH_paraAttrRuns);
      runs = ObjVarAddData(oself, ATTR_VIS_TEXT_GRAPHIC_RUNS, sizeof(word));
      *runs = VMCHAIN_GET_VM_BLOCK(ttbh->TTBH_graphicRuns);

      /* Transfer some data in array block from VM into our own memory block */
      if(htbh->HTBH_arrayBlock)
      {
        pself->HTI_namePool = NamePoolVMLoad(vmf, 
          htbh->HTBH_other.HTBHO_namePoolToUse);
                                          /* load copy of name pool */

        habh = VMLockChainifiedLMemBlock(vmf,
          VMCHAIN_GET_VM_BLOCK(htbh->HTBH_arrayBlock), &hypertextArrayMem);

        GetArray(HTI_imageArray, HABH_imageArray);
        GetArray(HTI_anchorArray, HABH_anchorArray);
        GetArray(HTI_formArray, HABH_formArray);
        GetArray(HTI_mapArray, HABH_mapArray);
        GetArray(HTI_eventArray, HABH_eventArray);

#if (!COMPILE_OPTION_HUGE_ARRAY_TABLES)
        GetArray(HTI_tableArray, HABH_tableArray);
#else
        if (htbh->HTBH_tableArrayLink)  {
          pself->HTI_tableArray = ConstructOptr(vmf, 
            VMCHAIN_GET_VM_BLOCK(htbh->HTBH_tableArrayLink));
        } else {
          pself->HTI_tableArray = 0 ;
        }
#endif

#if (!COMPILE_OPTION_HUGE_ARRAY_CELLS)
        GetArray(HTI_cellArray, HABH_cellArray);
#else
        if (htbh->HTBH_cellArrayLink)  {
          pself->HTI_cellArray = ConstructOptr(vmf,
            VMCHAIN_GET_VM_BLOCK(htbh->HTBH_cellArrayLink));
        } else {
          pself->HTI_cellArray = 0 ;
        }
#endif

        /* Set a number of parameters in a way that will keep us from
           crashing on an undefined intermediary state after changing the
           region array around. */
        pself->VTI_selectStart = 0;
        pself->VTI_selectEnd = 1;
        pself->VTI_cursorRegion = 0;              

#if !(COMPILE_OPTION_HUGE_ARRAY_REGIONS)       
        if (habh->HABH_regionArray)
        {
          ret = ConstructOptr(hypertextArrayMem, habh->HABH_regionArray) ;
          size = LMemGetChunkSize(ret) ;
          newRegionArray = LMemAlloc(OptrToHandle(oself), size) ;
          memcpy(LMemDerefHandles(OptrToHandle(oself), newRegionArray), LMemDeref(ret), size) ;
              
          pself = ObjDerefVis(oself) ;
          pself->VLTI_regionArray = newRegionArray ;
#else
        if (htbh->HTBH_regionArrayLink) 
        {
          pself->VLTI_regionArray = VMCHAIN_GET_VM_BLOCK(htbh->HTBH_regionArrayLink);
#endif
          pself->VTI_lines = VMCHAIN_GET_VM_BLOCK(htbh->HTBH_lineArrayLink);
          pself->VTI_intFlags |= VTIF_HAS_LINES;

          RegionPurgeCache(oself) ;
          if (pself->VI_optFlags & VOF_GEOMETRY_INVALID)
              @call self::MSG_VIS_NOTIFY_GEOMETRY_VALID();
          else
              @send,forceQueue @visParent::MSG_VIS_INVALIDATE();
        }
        else
        { 
          PrepareCellNextIndices(
              pself->HTI_cellArray, 
              pself->HTI_tableArray) ;

          @call self::MSG_VIS_TEXT_CREATE_STORAGE(0, TRUE);
          pself = ObjDerefVis(oself);
          pself->VTI_lines = 0;           // force creation of new line array
          pself->VTI_intFlags &= ~VTIF_HAS_LINES;

          /* Everything is set up, create line array */
          @call self::MSG_VIS_NOTIFY_GEOMETRY_VALID();
        }

        VMUnlockChainifiedLMemBlock(hypertextArrayMem);
      }
      
      RegionPurgeCache(oself) ;

      pself = ObjDerefVis(oself);
      IMarkAllImagesUnresolved(pself->HTI_imageArray);
                                        // we haven't checked the cache yet

      @call self::MSG_HTML_TEXT_INITIALIZE_FORM_ELEMENTS() ;

      RegionPurgeCache(oself) ;
      HWChecksumCheck() ;

      /* copy over the margins */
      pself = ObjDerefVis(oself);
      pself->HTI_pageTopMargin = htbh->HTBH_other.HTBHO_topMargin ;
      pself->HTI_pageLeftMargin = htbh->HTBH_other.HTBHO_leftMargin ;

      /* copy over formatted width */
      formattedWidth = htbh->HTBH_other.HTBHO_formattedWidth ;

      /* copy over the background color */
      if(htbh->HTBH_other.HTBHO_fileInfo & HTML_FI_BACK_COLOR)
      {                                 /* background color set in image? */
        wcModeRed.VTWCMR_mapMode = htbh->HTBH_other.HTBHO_backColor.CQ_info;
        wcModeRed.VTWCMR_redOrIndex =
          htbh->HTBH_other.HTBHO_backColor.CQ_redOrIndex;
        wcBlueGreen.VTWCBG_green = htbh->HTBH_other.HTBHO_backColor.CQ_green;
        wcBlueGreen.VTWCBG_blue = htbh->HTBH_other.HTBHO_backColor.CQ_blue;
      }
      else
      {                                 /* no - use default color: */
        wcModeRed.VTWCMR_mapMode = CF_INDEX;
        wcModeRed.VTWCMR_redOrIndex = C_LIGHT_GREY;
      }

      /* copy over the visitied link color */
      pself->HTI_vlinkColor = htbh->HTBH_other.HTBHO_vlinkColor;
      pself->HTI_linkColor = htbh->HTBH_other.HTBHO_linkColor;

      HWChecksumCheck() ;

      RegionPurgeCache(oself) ;

      VMUnlock(textHeaderMem);
      VMUnlock(hypertextHeaderMem);

      if (formattedWidth)  {
          word numTotalCells ;

          pself = ObjDerefVis(oself);
          pself->HTI_formattedWidth = htbh->HTBH_other.HTBHO_formattedWidth ;
          pself->HTI_numFormattedCells = htbh->HTBH_other.HTBHO_numFormattedCells ;

          /* If we didn't completely format the page, then we'll mark */
          /* the page dirty for another round of optimized formatting. */
          /* The formatting will continue on the page at where it */
          /* left off. */
          CellArrayStartAccess(pself->HTI_cellArray) ;
          numTotalCells = CellArrayGetCount(pself->HTI_cellArray) ;
          CellArrayEndAccess(pself->HTI_cellArray) ;

          if (pself->HTI_numFormattedCells < numTotalCells)  {
              /* Reset the formatting and dirty the layout */
              /* but make sure we draw everything.  We are coming in with */
              /* a blank page so we can't have optimized drawing occuring, */
              /* just optimized formatting.  -- lshields 09/03/2000 */
              pself->HTI_layoutState |= 
                  HTS_LAYOUT_DIRTY | HTS_LAYOUT_NEED_COMPLETE_PROGRESSIVE_REDRAW;
          }
      } else {
          @call oself::MSG_HTML_TEXT_INITIALIZE_LAYOUT() ;
      }

      @call self::MSG_VIS_TEXT_SET_WASH_COLOR(wcModeRed, wcBlueGreen);
    }
    else
    {
      @call self::MSG_META_SUSPEND();     /* minimize screen update */

      pself = ObjDerefVis(oself);

      /* Create all the data structures for the "empty" state */
      @call self::MSG_HTML_TEXT_INIT_STORAGE(pself->HTI_emptyFile);
      RegionPurgeCache(oself) ;

      pself = ObjDerefVis(oself);

      /* Set a number of parameters in a way that will keep us from
         crashing on an undefined intermediary state. */
      pself->VTI_selectStart = 0;
      pself->VTI_selectEnd = 1;
      pself->VTI_cursorRegion = 0;
           
      /* Everything is set up, create line array */
      @call self::MSG_VIS_NOTIFY_GEOMETRY_VALID();
    }
    
    RegionPurgeCache(oself) ;
    @call oself::MSG_VIS_TEXT_SELECT_START();
    HWChecksumCheck() ;
}

#pragma codeseg HTMLCLAS_TEXT

/* restore strings in code segment */
#pragma option -dc

@method HTMLTextClass, MSG_HTML_TEXT_SHOW_ITEM
{
    GStateHandle gstate ;
    WindowHandle win ;

    /* keep visual update suspended while width is still unknown */
    EC_ERROR_IF(pself != ObjDerefVis(oself), -1);

    if( (pself->HTI_state & HTS_VIEW_NOT_OPENED) &&
       !(pself->HTI_state & HTS_VIEW_SUSPENDED_FOR_OPEN))
    {
      pself->HTI_state |= HTS_VIEW_SUSPENDED_FOR_OPEN;
    }
    else
    {
      RegionPurgeCache(oself) ;
    EC_ERROR_IF(pself != ObjDerefVis(oself), -1);
      @call self::MSG_META_UNSUSPEND();
      pself = ObjDerefVis(oself);
    EC_ERROR_IF(pself != ObjDerefVis(oself), -1);
      RegionPurgeCache(oself) ;
    }

    HWChecksumCheck() ;
    /* Finish out the layout when we are ready */
    pself->HTI_layoutState |= HTS_NEED_TO_REACTIVE_DRAWING | HTS_NEED_BOUNDARY_CALCULATION ;
    EC_ERROR_IF(pself != ObjDerefVis(oself), -1);
    @call oself::MSG_HTML_TEXT_CALCULATE_LAYOUT() ;

    /* Scroll to the top and Redraw the View's background */
    EC_ERROR_IF(pself != ObjDerefVis(oself), -1);
    @call pself->HTI_myView::MSG_GEN_VIEW_MAKE_RECT_VISIBLE(
            MRVF_ALWAYS_SCROLL,
            0,
            MRVF_ALWAYS_SCROLL,
            0,
            0,
            0,
            0,
            0) ;
    EC_ERROR_IF(pself != ObjDerefVis(oself), -1);
    win = @call pself->HTI_myView::MSG_GEN_VIEW_GET_WINDOW() ;
    if (win)  {
        gstate = GrCreateState(win) ;
        GrBeginUpdate(gstate) ;

        GrSetAreaColor(
            gstate, 
            pself->VTI_washColor.CQ_info,
            pself->VTI_washColor.CQ_redOrIndex, 
            pself->VTI_washColor.CQ_green, 
            pself->VTI_washColor.CQ_blue) ;

        GrFillRect(gstate, 0, 0, 0x1FFF, 0x1FFF) ;
        GrEndUpdate(gstate) ;
        GrDestroyState(gstate) ;
    }

    HWChecksumCheck() ;
}

@method HTMLTextClass, MSG_HTML_TEXT_STORE_CONTENTS
{
/*
 * This code is currently disabled because it got broken when switching to
 * local name pools. It will eventually have to be adapted to the new design
 * for being able to save local pages.
 */
    return 0;
}

#pragma codeseg HTMLCLAS_PRINT_TEXT

/* "-dc" causes vptrs for text constants if different code segments are used */
#pragma option -dc-

/********************************************************************
 *              MSG_PRINT_NOTIFY_PRINT_DB
 ********************************************************************
 * SYNOPSIS:     Print the text object.
 * CALLED BY:    PrintControl
 * PARAMETERS:   optr               printCtrlOD
 *               PrintControlStatus pcs
 * RETURNS:      void
 * SIDE EFFECTS: Modifies state of PrintControl
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      MG      06/10/00        Initial version
 *******************************************************************/
@method HTMLTextClass, MSG_PRINT_NOTIFY_PRINT_DB
{
      /*
       * iCurPage   - Current page being printed.
       * cNumPages  - Number of regions in text object (pages).
       * sPageSize  - Size of page from PrintControl.
       * pageWidth  - Width of paper.
       * pageHeight - Height of print area in points.
       * bContinue  - Indicates when to stop printing.
       * page       - usable are of page within margins.
       */
    int             cNumPages;
    PageSizeReport  sPageSize;
    word            pageWidth, docWidth;
    dword           pageHeight, pageHeightDoc, docHeight;
    WWFixedAsDWord  scale;

    docWidth = pself->VLTI_displayModeWidth;
    docHeight = pself->VLTI_totalHeight;

      /*
       * Get the paper size as set by the user and find the
       * page width and height without margins. Then set the
       * document size to reflect the current paper size.
       */
    if( pself->HTI_pageSizeControlOD )
      @call pself->HTI_pageSizeControlOD::MSG_PZC_GET_PAGE_SIZE( &sPageSize );
    else
      @call printCtrlOD::MSG_PRINT_CONTROL_GET_PAPER_SIZE_INFO( &sPageSize );

    pageWidth  = sPageSize.PSR_width -
                 sPageSize.PSR_margins.PCMP_left -
                 sPageSize.PSR_margins.PCMP_right;
    pageHeight = sPageSize.PSR_height -
                 sPageSize.PSR_margins.PCMP_top -
                 sPageSize.PSR_margins.PCMP_bottom;

    // If page is too small for document, adjust scaling factor
    if(pageWidth<docWidth)              // Document too wide for page?
      scale = GrUDivWWFixed(MakeWWFixed(pageWidth), MakeWWFixed(docWidth));
    else
      scale = MakeWWFixed(1);           // Never scale *up* to fit page...

    // Compute amount of document coordinate space that fits on a page
    // after scaling (vertically):
    pageHeightDoc = IntegerOf(GrUDivWWFixed(
      MakeWWFixed(pageHeight - 2 * HTML_TEXT_ORNAMENT_MARGIN), scale));

      /*
       * Set the number of pages to print.
       */
    cNumPages = (int)(docHeight / pageHeightDoc + 1);
    @call printCtrlOD::MSG_PRINT_CONTROL_SET_TOTAL_PAGE_RANGE(1, cNumPages );

    @call printCtrlOD::MSG_PRINT_CONTROL_SET_DOC_SIZE(
      sPageSize.PSR_width, sPageSize.PSR_height );

    @call printCtrlOD::MSG_PRINT_CONTROL_SET_DOC_MARGINS(
      &sPageSize.PSR_margins);  
}

/********************************************************************
 *              MSG_PRINT_START_PRINTING
 ********************************************************************
 * SYNOPSIS:     Print the text object.
 * CALLED BY:    PrintControl
 * PARAMETERS:   optr         printCtrlOD
 *               GStateHandle gstate
 * RETURNS:      void
 * SIDE EFFECTS: none
 * STRATEGY:     Get printer margins, then send MSG_VIS_DRAW to
 *               text object with the DF_PRINT flag, then signal
 *               printing completed. Well, okay, it's a lot more
 *               than just that...
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      NF      4/1/95          Initial version
 *      MG      11/11/96        Modified for use with HTMLTextClass
 *      MG      03/26/97        Adapted for use with GeoWeb
 *      MG      01/25/98        Copied GeoWeb changes back into WM
 *******************************************************************/
@method HTMLTextClass, MSG_PRINT_START_PRINTING
{
      /*
       * iCurPage   - Current page being printed.
       * cNumPages  - Number of regions in text object (pages).
       * sPageSize  - Size of page from PrintControl.
       * pageWidth  - Width of paper.
       * pageHeight - Height of print area in points.
       * bContinue  - Indicates when to stop printing.
       * page       - usable are of page within margins.
       */
    dword           iCurPage;
    PageSizeReport  sPageSize;
    word            pageWidth, docWidth;
    dword           pageHeight, curPageHeight, pageHeightDoc;
    sdword          pageStartDoc;
    Boolean         bContinue;
    WWFixedAsDWord  scale;
    Rectangle       page;
    PCPageRange     range, total;

    docWidth = pself->VLTI_displayModeWidth;

      /*
       * Get the paper size as set by the user and find the
       * page width and height without margins. Then set the
       * document size to reflect the current paper size.
       */
    if( pself->HTI_pageSizeControlOD )
      @call pself->HTI_pageSizeControlOD::MSG_PZC_GET_PAGE_SIZE( &sPageSize );
    else
      @call printCtrlOD::MSG_PRINT_CONTROL_GET_PAPER_SIZE_INFO( &sPageSize );

    pageWidth  = sPageSize.PSR_width -
                 sPageSize.PSR_margins.PCMP_left -
                 sPageSize.PSR_margins.PCMP_right;
    pageHeight = sPageSize.PSR_height -
                 sPageSize.PSR_margins.PCMP_top -
                 sPageSize.PSR_margins.PCMP_bottom;

    // If page is too small for document, adjust scaling factor
    if(pageWidth<docWidth)              // Document too wide for page?
      scale = GrUDivWWFixed(MakeWWFixed(pageWidth), MakeWWFixed(docWidth));
    else
      scale = MakeWWFixed(1);           // Never scale *up* to fit page...

    // Page height in paper coordinates
    curPageHeight = pageHeight - 2 * HTML_TEXT_ORNAMENT_MARGIN;

    // Compute amount of document coordinate space that fits on a page
    // after scaling (vertically):
    pageHeightDoc = IntegerOf(GrUDivWWFixed(MakeWWFixed(curPageHeight), scale));

    /* compute usable area of page (including the space reserved for the
       "page ornaments" (header, footer, page number) */
    page.R_left = sPageSize.PSR_margins.PCMP_left;
    page.R_top = sPageSize.PSR_margins.PCMP_top;
    page.R_right = page.R_left + pageWidth;
    page.R_bottom = page.R_top + pageHeight;

      /*
       * Get page range the user wants to print
       */
    range = @call printCtrlOD::MSG_PRINT_CONTROL_GET_SELECTED_PAGE_RANGE();
    total = @call printCtrlOD::MSG_PRINT_CONTROL_GET_TOTAL_PAGE_RANGE();
    
      /*
       * This loop is from Concepts Code Display 23-1 on p809.
       * It is the main printing loop. It translates the text up
       * one page at a time while printing it. Actually, it
       * translates it one page the first time, two pages the
       * second time, three pages the third time, and so on.
       */
    for(iCurPage = range.PCPR_firstPage-1; 
        iCurPage < range.PCPR_lastPage; 
        iCurPage++)
    {
          /* 
           * Start of page in document space. We cut right through lines of
           * text or graphics if necessary...
           */
        pageStartDoc = pageHeightDoc * iCurPage;

          /*
           * Check if the user wants to cancel printing.
           * If so, break out of the loop before we print
           * the current page.
           */
        bContinue = @call printCtrlOD::
            MSG_PRINT_CONTROL_REPORT_PROGRESS( PCPT_PAGE, iCurPage+1 );

        if ( !bContinue )
          break;

          /*
           * The following message can be subclassed for printing page
           * header and footer.
           */
        @call self::MSG_HTML_TEXT_PRINT_PAGE_ORNAMENTS(
          gstate, iCurPage, total.PCPR_lastPage, &page);

          /*
           * Get the start position of the top of
           * the current page. We'll use it for translating
           * the text object upwards in order to
           * print the page we want.
           */
        GrSaveState(gstate);

        /* Set the clip region to the current page */
        GrSetClipRect( gstate, PCT_REPLACE,
          sPageSize.PSR_margins.PCMP_left,
          sPageSize.PSR_margins.PCMP_top + HTML_TEXT_ORNAMENT_MARGIN,
          pageWidth + sPageSize.PSR_margins.PCMP_left,
          curPageHeight + sPageSize.PSR_margins.PCMP_top +
            HTML_TEXT_ORNAMENT_MARGIN);

          /*
           * Shift text up iCurPage pages and draw text.
           * Have printer form feed the page.
           */
        GrApplyTranslationDWord( gstate,
          sPageSize.PSR_margins.PCMP_left,
          sPageSize.PSR_margins.PCMP_top + HTML_TEXT_ORNAMENT_MARGIN);
        GrApplyScale( gstate, scale, scale );
        GrApplyTranslationDWord( gstate, 0, -pageStartDoc );

        GrInitDefaultTransform( gstate );
	pself = ObjDerefVis(oself);
	pself->HTI_state |= HTS_PRINTING;
        @call self::MSG_VIS_DRAW( DF_PRINT, gstate );
	pself = ObjDerefVis(oself);
	pself->HTI_state &= ~HTS_PRINTING;

        GrRestoreState(gstate);
        GrNewPage(gstate, PEC_FORM_FEED);
    } /* for iCurPage */

      /*
       * Wrap up the printing (tell PrintControl if
       * done printing or if user cancelled).
       */
    if ( FALSE == bContinue )
    {
        @send printCtrlOD::MSG_PRINT_CONTROL_PRINTING_CANCELLED();
    }
    else
    {
        @send printCtrlOD::MSG_PRINT_CONTROL_PRINTING_COMPLETED();
    }
}

#pragma codeseg HTMLCLAS_TEXT

/* restore strings in code segment */
#pragma option -dc

@method HTMLTextClass, MSG_VIS_TEXT_SCREEN_UPDATE
{
    VMChain back = pself->HTI_backgroundImage;

    EC_PurgeES();

    @callsuper();

    if(back != CA_NULL_ELEMENT)         /* special handling if background */
      @call self::MSG_VIS_REDRAW_ENTIRE_OBJECT();
}

@method HTMLTextClass, MSG_HTML_TEXT_SET_BACKGROUND
{
    pself->HTI_backgroundImage = nImage;

    EC_PurgeES();

    /* redraw entire image (or make sure it's redrawn later) */
    @call @visParent::MSG_VIS_INVALIDATE();
}

@method HTMLTextClass, MSG_HTML_TEXT_SET_VIEW_OBJ
{
    pself->HTI_myView = viewObject;
}

@method HTMLTextClass, MSG_HTML_TEXT_GET_VIEW_OBJ
{
    return(pself->HTI_myView);
}

static word IReplaceTableBackground(
          optr oself,
          HTMLTextInstance *pself,
          RectDWord *p_invalArea,
          word imageIndex,
          word tableIndex) ;

static void IInvalAreaReset(RectDWord *p_invalArea)
{
    p_invalArea->RD_left = p_invalArea->RD_top = 0x7FFFFFFF ;
    p_invalArea->RD_right = p_invalArea->RD_bottom = 0 ;
}

static void IInvalAreaInvalidate(optr oself, RectDWord *p_invalArea)
{
    GStateHandle gstate ;

    /* Only process if we have something */
    if ((p_invalArea->RD_right > p_invalArea->RD_left) && 
            (p_invalArea->RD_bottom > p_invalArea->RD_top))  {
        /* Invalidate that large rectangle and reset */
        gstate = @call oself::MSG_VIS_VUP_CREATE_GSTATE() ;
        if (gstate)  {
            GrInvalRectDWord(gstate, p_invalArea);
            GrDestroyState(gstate) ;
        }
        IInvalAreaReset(p_invalArea) ;
    }
}

static void ICellMergeInvalArea(HTMLcellData *p_cell, RectDWord *p_invalArea)
{
    register dword value ;

    value = p_cell->HCD_x ;
    if (value < p_invalArea->RD_left)
        p_invalArea->RD_left = value ;
    value += p_cell->HCD_calcWidth ;
    if (value > p_invalArea->RD_right)
        p_invalArea->RD_right = value ;

    value = p_cell->HCD_y ;
    if (value < p_invalArea->RD_top)
        p_invalArea->RD_top = value ;
    value += p_cell->HCD_calcHeight ;
    if (value > p_invalArea->RD_bottom)
        p_invalArea->RD_bottom = value ;
}

static word IReplaceCellBackground(
        optr oself,
        HTMLTextInstance *pself,
        RectDWord *p_invalArea,
        word imageIndex,
        word firstCellIndex)
{
    HTMLcellData *p_cell ;
    HTMLtableData *p_table ;
    word size ;
    byte firstTableLevel = 0xFF ;
    byte tableLevel ;
    word index = firstCellIndex ;

    if (firstCellIndex == 0)
        IInvalAreaReset(p_invalArea) ;

    while (index < pself->HTI_numFormattedCells)  {
        /* Get access to this cell and the cell's table */
        CellLock(pself->HTI_cellArray, index, &p_cell, &size) ;
        TableLock(pself->HTI_tableArray, p_cell->HCD_table, &p_table, &size) ;
        tableLevel = TABLE_GET_LEVEL(p_table->HTD_flags) ;

        if (firstTableLevel == 0xFF)  {
            firstTableLevel = tableLevel ;

            /* Do the standard action */
            /* Only combine if they match in image and not a dirty layout */
            if ((p_cell->HCD_backgroundImage == imageIndex) &&
                   ((p_cell->HCD_flags2 & HTML_CELL_DIRTY_LAYOUT_MASK) == 0))
                ICellMergeInvalArea(p_cell, p_invalArea) ;
            index++ ;
            TableUnlock(p_table) ;
            CellUnlock(p_cell) ;
        } else {
            if (tableLevel > firstTableLevel)  {
                /* Let's go deeper and change all table backgrounds */
                /* But first unlock memory */
                TableUnlock(p_table) ;
                CellUnlock(p_cell) ;

                index = IReplaceTableBackground(oself, pself, p_invalArea, imageIndex, p_cell->HCD_table) ;
            } else if (tableLevel == firstTableLevel)  {
                /* Must be a continue cell */
                /* Only combine if they match in image and not a dirty layout */
                if ((p_cell->HCD_backgroundImage == imageIndex) &&
                       ((p_cell->HCD_flags2 & HTML_CELL_DIRTY_LAYOUT_MASK) == 0))
                    ICellMergeInvalArea(p_cell, p_invalArea) ;
                index++ ;
                TableUnlock(p_table) ;
                CellUnlock(p_cell) ;
            } else {
                /* Higher table.  Stop here */
                TableUnlock(p_table) ;
                CellUnlock(p_cell) ;
                break;
            }
        }

        /* Do the redraw on a per table basis */
        if (firstCellIndex == 0)
            IInvalAreaInvalidate(oself, p_invalArea) ;
    }

    return index ;
}

static word IReplaceTableBackground(
          optr oself,
          HTMLTextInstance *pself,
          RectDWord *p_invalArea,
          word imageIndex,
          word tableIndex)
{
    word size ;
    HTMLtableData *p_table ;
    HTMLcellData *p_cell ;
    word index ;

    TableLock(pself->HTI_tableArray, tableIndex, &p_table, &size) ;
    if (p_table->HTD_firstCell < pself->HTI_numFormattedCells)  {
        /* If the background here is a match and we don't need to recalcualte, */
        /* then make this section get invalidated */
        if ((p_table->HTD_backgroundImage == imageIndex) && 
                (!(p_table->HTD_flags & HTML_TABLE_DIRTY_LAYOUT_MASK))) {
            if (p_table->HTD_lastX < p_invalArea->RD_left)
                p_invalArea->RD_left = p_table->HTD_lastX ;
            if ((p_table->HTD_lastX + p_table->HTD_lastTableWidth) > p_invalArea->RD_right)
                p_invalArea->RD_right = (p_table->HTD_lastX + p_table->HTD_lastTableWidth) ;
            if (p_table->HTD_lastY < p_invalArea->RD_top)
                p_invalArea->RD_top = p_table->HTD_lastY ;
            if ((p_table->HTD_lastY + p_table->HTD_lastHeight) > p_invalArea->RD_bottom)
                p_invalArea->RD_bottom = (p_table->HTD_lastY + p_table->HTD_lastHeight) ;
        }

        /* Now check all the cells. */
        index = p_table->HTD_firstCell ;
        while ((index != CELL_NEXT_IN_TABLE_UNKNOWN) && (index <= pself->HTI_numFormattedCells))  {
            CellLock(pself->HTI_cellArray, index, &p_cell, &size) ;
            /* Only process while we are doing cells in this table */
            if (p_cell->HCD_table != tableIndex)  {
                CellUnlock(p_cell) ;
                break ;
            }
            CellUnlock(p_cell) ;
            index = IReplaceCellBackground(oself, pself, p_invalArea, imageIndex, index) ;
        }
    }
    TableUnlock(p_table) ;

    return index ;
}

@method HTMLTextClass, MSG_HTML_TEXT_SET_TABLE_OR_CELL_BACKGROUND
{
    RectDWord invalArea ;  /* We don't use it but provide it to the lower routines */
    WordFlags imageFlags ;
    word size ;

    MemLock(OptrToHandle(pself->HTI_imageArray));
    imageFlags = ((HTMLimageData *)ChunkArrayElementToPtr(
                        pself->HTI_imageArray, 
                        nImage, 
                        &size))->flags ;
    MemUnlock(OptrToHandle(pself->HTI_imageArray));

    /* Recursively go through our tree looking for matching backgrounds */
    /* but only if we are resolved */
    if (imageFlags & HTML_IDF_RESOLVED)
        IReplaceCellBackground(oself, pself, &invalArea, nImage, 0) ;
}

/**************************************************************************
 * Routine: IFindGraphicForImage
 **************************************************************************
 *
 * Description:
 *     Find the appropriate graphic for an image and return a pointer to
 *     the VisTextGraphic record associated with it in the text object.
 *     The caller is responsible for dirtying and unlocking the returned
 *     memory block when done with the record.
 *
 * Inputs:
 *     VMFileHandle file          -- VM file with text object data
 *     VMBlockHandle graphicRun   -- block with grahic run array
 *     word nImage                -- index of image in image table
 *
 * Outputs:
 *     VisTextGraphic *           -- pointer to graphic record
 *     MemHandle *mem             -- mem handle of VM block with graphic
 *
 **************************************************************************/
VisTextGraphic *IFindGraphicForImage(
         VMFileHandle file,
         VMBlockHandle graphicRun,
         word nImage,
         MemHandle *mem)
{
    MemHandle runmem ;
    VMBlockHandle graphicArray ;
    word size ;
    VisTextGraphic *graphic ;
    TextLargeRunArrayHeader *p_dir ;
    LMemBlockHeader *p_lmem ;
    word array ;
    word n,i;

    #define HIGV ((HTMLimageGraphicVariable *)\
      (graphic->VTG_data.VTGD_variable.VTGV_privateData))

    /* Start by extracting the handle to the huge array of graphics */
    /* from the header of the graphic run array. */
    p_dir = VMLock(file, graphicRun, &runmem) ;
    graphicArray = p_dir->TLRAH_elementVMBlock ;
    VMUnlock(runmem) ;

    /* Lock up this block */
    p_lmem = VMLockChainifiedLMemBlock(file, graphicArray, mem) ;

    /* Get the offset into the lmem for the first entry */
    array = p_lmem->LMBH_offset ;

    /* Now find in the particular VisTextGraphic element */
    n = ChunkArrayGetCountHandles(*mem, array);
    for(i=0; i<n; i++)
    {
      graphic = ChunkArrayElementToPtrHandles(*mem, array, i, &size);
      if(graphic->VTG_meta.REH_refCount.WAAH_high == 0 &&
         graphic->VTG_type==VTGT_VARIABLE &&
         graphic->VTG_data.VTGD_variable.VTGV_manufacturerID==HTML_VARGRAPH_MFGID && 
         graphic->VTG_data.VTGD_variable.VTGV_type==HTML_VARGRAPH_TYPE_IMAGE &&
         HIGV->HIGV_imageIndex==nImage)
      {
        return graphic;                 // Got it: return pointer to entry                      
      }
    }

    VMUnlockChainifiedLMemBlock(*mem);  // No need for this block any more
    return NULL;
}

/**************************************************************************
 *            MSG_HTML_TEXT_INVALIDATE_IMAGE for HTMLTextClass
 **************************************************************************
 *
 * Description:
 *     Invalidate the rectangle of a graphic causing the background 
 *     and graphic to redraw .
 *
 * Inputs:
 *     VisTextGraphic *p_graphic  -- VTG of image (can be NULL)
 *     word nImage                -- Index of image in image array                    
 *     word invalFrom             -- First line of updated range
 *     word invalTo               -- Last line of updated range
 *
 **************************************************************************/
@method HTMLTextClass, MSG_HTML_TEXT_INVALIDATE_IMAGE
{
    GStateHandle gstate ;
    HTMLimageData *imageArrayElement;
    word elsize;
    dword pos ;
    RectDWord regpos;
    sdword x, y ;
    VisTextGraphic vtg;
    word cell;
    HTMLcellData *p_cell ;
    ByteFlags dirty;
    optr pool = pself->HTI_namePool;

    if(pself->HTI_drawingOn<0)          /* if drawing is off, observe it */
      return;
    
    ObjLockObjBlock(OptrToHandle(pself->HTI_imageArray));
    imageArrayElement = ChunkArrayElementToPtr(pself->HTI_imageArray,
      nImage, &elsize);                 /* deference token to image record */
    x = imageArrayElement->HID_pos.P_x ;
    y = imageArrayElement->HID_pos.P_y ;
    pos = imageArrayElement->pos ;

    /* Only do this if the data is not -1, -1 (unknown) */
    if ((x != -1) && (y != -1) && (pos < HTML_IMAGE_POS_RESERVED))
    {
        gstate = @call oself::MSG_VIS_VUP_CREATE_GSTATE() ;

        cell = @call oself::MSG_HTML_TEXT_GET_REGION_POSITION(pos, &regpos);

        /* See if the cell has recovered from its latest change */
	if(regpos.RD_top >= HTML_TEXT_REGION_HIDDEN_Y)
	{
	  dirty = 1;
	}
        else if(imageArrayElement->flags & HTML_IDF_SIZE_DIRTY)
        {
          pself = ObjDerefVis(oself) ;

          CellArrayStartAccess(pself->HTI_cellArray) ;
          CellLock(pself->HTI_cellArray, cell, &p_cell, &elsize) ;
          dirty = p_cell->HCD_flags2 & HTML_CELL_DIRTY_LAYOUT_MASK ;
          CellUnlock(p_cell);
          CellArrayEndAccess(pself->HTI_cellArray) ;
        }
        else
        {
          dirty = 0;                    // Image wasn't changed - no problems
        }

        if(!dirty)                      // Only draw if image is fully resolved
        {
          if(!p_graphic)
          {
            @call oself::MSG_VIS_TEXT_GET_GRAPHIC_AT_POSITION(&vtg, pos);
            RegionPurgeCache(oself) ;
            p_graphic = &vtg;
          }

          GrApplyTranslationDWord(gstate, regpos.RD_left, regpos.RD_top) ;
          DrawVarGraphic(gstate, imageArrayElement, pool, invalFrom, invalTo);
        }

        GrDestroyState(gstate) ;
    }

    MemUnlock(OptrToHandle(pself->HTI_imageArray));
}

/**************************************************************************
 * Routine: MarkTableLayoutDirty
 **************************************************************************
 *
 * Description:
 *     MarkTableLayoutDirty is used to tell what tables may be affected
 *     by a change.  This gives the formatter a way to ensure that a
 *     reformat occurs on the given table and all the tables in between.
 *     (Don't worry.  When I say reformat, I mean to do the calculations
 *     and only change that that has changed.)
 *
 * Inputs:
 *     HTMLTextInstance *pself    -- HTML text object with cells and table
 *     word tableIndex            -- Table to start at
 *
 * Revision:
 *     Who  Date:     Comments:
 *     ---  --------  --------------------
 *     LES  00/01/16  Created.
 *
 **************************************************************************/
void MarkTableLayoutDirty(HTMLTextInstance *pself, word tableIndex)
{
    HTMLtableData *p_table ;
    HTMLcellData *p_cell ;
    word size ;
    word cellIndex ;

    /* Lock the table */
    TableArrayStartAccess(pself->HTI_tableArray);
    TableLock(pself->HTI_tableArray, tableIndex, &p_table, &size) ;
    /* Only work on this if it is not already dirty (this avoids us */
    /* recursively calling up the tree */
    if (!(p_table->HTD_flags & HTML_TABLE_DIRTY_LAYOUT_MASK))  {
        p_table->HTD_flags |= HTML_TABLE_DIRTY_LAYOUT_MASK ;
        TableDirty(p_table) ;
        if (tableIndex)  {
            cellIndex = p_table->HTD_firstCell-1 ;
            CellLock(pself->HTI_cellArray, cellIndex, &p_cell, &size) ;
            MarkTableLayoutDirty(pself, p_cell->HCD_table) ;
            CellUnlock(p_cell) ;
        }
    }
    TableUnlock(p_table) ;
    TableArrayEndAccess(pself->HTI_tableArray);
}

/**************************************************************************
 *               MSG_HTML_TEXT_RESOLVE_IMAGE for HTMLTextClass
 **************************************************************************
 *
 * Description:
 *     Notify text object when an image has been resolved and perform the
 *     necesary internal and visual updating.
 *
 * Inputs:
 *     word nImage                -- Index of image in image array
 *     HTMLimageData *data        -- Data to replace image with
 *     word invalFrom             -- First line of updated range
 *     word invalTo               -- Last line of updated range
 *
 **************************************************************************/
@method HTMLTextClass, MSG_HTML_TEXT_RESOLVE_IMAGE
{
    word size;
    HTMLimageData *iae;
    MemHandle mem ;
    VisTextGraphic *graphic ;
    XYSize oldSize;
    VMBlockHandle *p_run ;
    word region ;
    VisLargeTextRegionArrayElement *p_region ;
    T_regionArrayHandle regionArray ;
    HTMLcellData *p_cell ;
    word cellIndex ;
    /* Notes if the cell the image is in is marked dirty for layout */
    Boolean wasDirty = FALSE ;  

    RegionPurgeCache(oself) ;
    /* 
     * Update image record in table 
     */
    MemLock(OptrToHandle(pself->HTI_imageArray));
    iae = ChunkArrayElementToPtr(pself->HTI_imageArray, nImage, &size);                                                           
    *iae = *data;                        
    iae->flags |= HTML_IDF_RESOLVED;
    iae->flags &= ~(HTML_IDF_RESOLVING | HTML_IDF_BROKEN);
    MemUnlock(OptrToHandle(pself->HTI_imageArray));

    if(data->pos < HTML_IMAGE_POS_RESERVED)    
    {                                   // not changing background?
      p_run = ObjVarFindData(oself, ATTR_VIS_TEXT_GRAPHIC_RUNS) ;
      if (p_run)
      {
        /* Now let's find the corresponding token in the */
        /* graphic run array */
        graphic = IFindGraphicForImage(pself->VTI_vmFile, *p_run, nImage, &mem);

        if (graphic)                    // Found the graphic 
        {
          oldSize = graphic->VTG_size;  // Remember old size of graphic
          graphic->VTG_size = data->HID_size;
                                        // Update graphic size

          graphic->VTG_size.XYS_width += 2*data->hspace;
          graphic->VTG_size.XYS_height += 2*data->vspace;
                                      // add spacing around graphic
          
          if (graphic->VTG_size.XYS_height >= IMAGE_HEIGHT_FUDGE_FACTOR)
            graphic->VTG_size.XYS_height -= IMAGE_HEIGHT_FUDGE_FACTOR ;
          else
            graphic->VTG_size.XYS_height = 0 ;

          /* If we are doing a replace where the size of the graphic */
          /* changes, then mark the table layout dirty */
          if ((graphic->VTG_size.XYS_width != oldSize.XYS_width) ||
              (graphic->VTG_size.XYS_height != oldSize.XYS_height))  
          {
            /* mark layout as "dirty", meaning that we should redraw eventually */
            pself = ObjDerefVis(oself);
            pself->HTI_layoutState |= HTS_LAYOUT_DIRTY;

            /* tell image that its size has changed */
            MemLock(OptrToHandle(pself->HTI_imageArray));
            iae = ChunkArrayElementToPtr(pself->HTI_imageArray, nImage, &size);                                                           
            iae->flags |= HTML_IDF_SIZE_DIRTY;
            MemUnlock(OptrToHandle(pself->HTI_imageArray));

            /* Get the region so we can get the cell */
            regionArray = RegionArrayConstruct(oself, pself) ;
            region = FindRegionAtPosition(regionArray, data->pos) ;
            RegionLock(regionArray, region, &p_region, &size) ;
            cellIndex = p_region->VLTRAE_section ;
            RegionUnlock(p_region) ;

            /* Reset the cell's hard minium width */
            CellArrayStartAccess(pself->HTI_cellArray) ;
            CellLock(pself->HTI_cellArray, cellIndex, &p_cell, &size) ;
            if (p_cell->HCD_flags2 & HTML_CELL_DIRTY_LAYOUT_MASK)  {
                wasDirty = TRUE ;
            } else {
                p_cell->HCD_flags2 |= HTML_CELL_DIRTY_LAYOUT_MASK ;
                CellDirty(p_cell) ;
            }

            /* In the very rare case that we get smaller, we need */
            /* to reset the minimum width of the cell's width that the */
            /* image is within.  Do so here.  On the next formatting pass, */
            /* the whole area will get recalculated. */
            if ((graphic->VTG_size.XYS_width < oldSize.XYS_width) /* ||
                (graphic->VTG_size.XYS_height < oldSize.XYS_height) */ )  
            {
                p_cell->HCD_hardMinWidth = MINIMUM_COLUMN_WIDTH ;
                p_cell->HCD_minWidth = MINIMUM_COLUMN_WIDTH ;
                pself->HTI_layoutState |= HTS_LAYOUT_NEED_TO_BLAST_HARD_MIN_WIDTHS ;
            }

            if (graphic->VTG_size.XYS_width > p_cell->HCD_hardMinWidth)  
                p_cell->HCD_hardMinWidth = graphic->VTG_size.XYS_width ;
            else if (oldSize.XYS_width == DEFAULT_IMAGE_WIDTH)
                p_cell->HCD_hardMinWidth = graphic->VTG_size.XYS_width ;

            if (graphic->VTG_size.XYS_width > p_cell->HCD_minWidth)
                p_cell->HCD_minWidth = graphic->VTG_size.XYS_width ;
            else if (oldSize.XYS_width == DEFAULT_IMAGE_WIDTH)
                p_cell->HCD_minWidth = graphic->VTG_size.XYS_width ;
    
            /* Mark the table this cell is in as 'dirty' */
            if (!wasDirty)  {
                TableArrayStartAccess(pself->HTI_tableArray) ;
                MarkTableLayoutDirty(pself, p_cell->HCD_table) ;
                TableArrayEndAccess(pself->HTI_tableArray) ;

                /* Check to see if we are invalidating within a table */
                /* currently being formatted.  If so, we have to put the */
                /* formatter in a mode where we keep all dirty tags until */
                /* we are done with the master table and go at it again. */
                if (pself->HTI_layoutStack)  {
                    T_layoutStack *p_stack ;
                    p_stack = LayoutStackLock(pself->HTI_layoutStack) ;
                    if ((cellIndex >= p_stack->LS_currentMasterCell) &&
                        (cellIndex <= p_stack->LS_currentCell))  {
                        p_stack->LS_currentMasterCellGotImage = TRUE ;
                    } else if (cellIndex < p_stack->LS_currentCell)  {
                        /* If we passed up the graphic, we'll have to go */
                        /* back and format it again. */
                        p_stack->LS_oneMorePass = TRUE ;
                    }
                    LayoutStackUnlock(p_stack) ;
                }
            }

            CellUnlock(p_cell) ;
            CellArrayEndAccess(pself->HTI_cellArray) ;
            
            VMDirty(mem);

            /* If we found a dirty location, add it to the list */
            if (!wasDirty)
                @call oself::MSG_HTML_TEXT_WAITING_IMAGE_ADD(nImage, cellIndex) ;
          }

          /* Only invalidate if we are not already dirtied */
          if (!wasDirty)  {
              @call self::MSG_HTML_TEXT_INVALIDATE_IMAGE(graphic, nImage,
                invalFrom, invalTo) ;
          }
          /* Balance VMLockChainifiedLMemBlock() in IFindGraphicForImage() */
          VMUnlockChainifiedLMemBlock(mem);
        }
      }
    }
    else if (data->pos == HTML_IMAGE_POS_DOCUMENT_BACKGROUND)
    { 
                               /* change in background */
      @call self::MSG_HTML_TEXT_SET_BACKGROUND(nImage);
    } else {
      @call self::MSG_HTML_TEXT_SET_TABLE_OR_CELL_BACKGROUND(nImage);
    }

    return TRUE;                        /* successful */
}

/**************************************************************************
 *            MSG_HTML_TEXT_GET_REGION_POSITION for HTMLTextClass
 **************************************************************************
 *
 * Description:
 *     Retrieve upper right corner and index of associated cell record for
 *     the region starting at the passed position
 *
 * Inputs:
 *     dword rangeStart           -- Position within region
 *
 * Outputs:
 *     word                       -- index of associated cell
 *     RectDWord *position        -- Upper left corner of region in document
 *                                   coordinates
 *
 **************************************************************************/
@method HTMLTextClass, MSG_HTML_TEXT_GET_REGION_POSITION
{
    word region;
    word size;
    VisLargeTextRegionArrayElement *p_region;
    T_regionArrayHandle regionArray ;
    word cellIndex;

    RegionPurgeCache(oself) ;
    regionArray = RegionArrayConstruct(oself, pself);

    region = FindRegionAtPosition(regionArray, rangeStart);
    RegionLock(regionArray, region, &p_region, &size) ;
    position->RD_left = p_region->VLTRAE_spatialPosition.PD_x;
    position->RD_top = p_region->VLTRAE_spatialPosition.PD_y;
    cellIndex = p_region->VLTRAE_section ;
    RegionDirty(p_region) ;
    RegionUnlock(p_region) ;
    return cellIndex;
}

@method HTMLTextClass, MSG_HTML_TEXT_DRAWING_ON_OFF
{
    if (isOn)  {
        pself->HTI_drawingOn++ ;
        /* Did it just become visible */
        if (pself->HTI_drawingOn == 0)
            /* Make it visible */
            pself->VI_attrs |= (VA_MANAGED|VA_DRAWABLE|VA_DETECTABLE|VA_FULLY_ENABLED);
    } else  {
        pself->HTI_drawingOn-- ;
        /* Did it just become invisible? */
        if (pself->HTI_drawingOn == -1)
            pself->VI_attrs &= ~(VA_MANAGED|VA_DRAWABLE|VA_DETECTABLE|VA_FULLY_ENABLED);
    }
}

@method HTMLTextClass, MSG_HTML_TEXT_SET_PAGE_SIZE_CONTROLLER
{
    pself->HTI_pageSizeControlOD = controller ;
}

@method HTMLTextClass, MSG_HTML_TEXT_GET_NAME_POOL
{
    return pself->HTI_namePool;
}

@method HTMLTextClass, MSG_HTML_TEXT_TEST_BROKEN_AND_RESOLVING_IMAGES
{
    optr array;
    HTMLimageData *imageArrayElement;
    word i,size;
    Boolean ret;

    ret = FALSE;                        /* default: no images found */
    if(pself->HTI_imageArray)
    {
      MemLock(OptrToHandle(pself->HTI_imageArray));

      array = pself->HTI_imageArray;
      for(i=ChunkArrayGetCount(array)-1; (int)i>=0; i--)
      {
        imageArrayElement = ChunkArrayElementToPtr(array, i, &size);
        if(imageArrayElement->flags & (HTML_IDF_BROKEN | HTML_IDF_RESOLVING))
        {
          ret = TRUE;                   /* found unresolved image? abort */
          break;
        }
      }

      MemUnlock(OptrToHandle(pself->HTI_imageArray));
    }

    return ret;                         /* no unresolved images */
}

@method HTMLTextClass, MSG_HTML_TEXT_MARK_ALL_BROKEN_AND_RESOLVING_IMAGES_UNRESOLVED
{
    optr array;
    HTMLimageData *imageArrayElement;
    word i ;

    /* Go through all the images and if a broken image is found, it */
    /* is converted to 'unresolved' and not broken. */
    if (pself->HTI_imageArray)  {
      MemLock(OptrToHandle(pself->HTI_imageArray));
      array = pself->HTI_imageArray;
      for(i=ChunkArrayGetCount(array)-1; (int)i>=0; i--)  {
        imageArrayElement = ChunkArrayElementToPtr(array, i, NULL);
        if (imageArrayElement->flags & HTML_IDF_BROKEN) 
            imageArrayElement->flags &= 
                 ~(HTML_IDF_BROKEN | HTML_IDF_RESOLVED) ;
        if (imageArrayElement->flags & HTML_IDF_RESOLVING) 
            imageArrayElement->flags &= ~HTML_IDF_RESOLVING ;
      }
      MemUnlock(OptrToHandle(pself->HTI_imageArray));
    }
}

void IRegionPurgeCache(optr obj)
{
    @call obj::MSG_VIS_LARGE_TEXT_PURGE_REGION_CACHE() ;
}

/* --------------------- */

#define MAX_WAITING_IMAGES  200

typedef struct {
    word WIE_imageIndex ;
    word WIE_cellIndex ;
    word WIE_reserved ;       /* Align structure to 16 bytes */
    word WIE_next ;
} T_waitingImageEntry ;       /* Use WAITING_IMAGE_NULL if no next */

typedef struct {
    char WIB_tag[8] ;
    word WIB_timeCreated ;
    word WIB_timeUpdated ;
    word WIB_freeStart ;
    word WIB_usedStart ;
    T_waitingImageEntry WIB_imageArray[MAX_WAITING_IMAGES] ;
} T_waitingImagesBlock ;

/* Creates a block to hold a waiting images list */
@method HTMLTextClass, MSG_HTML_TEXT_WAITING_IMAGES_CREATE
{
    /* Only create if its not there */
    if (!pself->HTI_waitingImages)  {
        pself->HTI_waitingImages = MemAlloc(
                sizeof(T_waitingImagesBlock), 
                HF_DYNAMIC|HF_SHARABLE, 
                HAF_NO_ERR);
    }

    @call oself::MSG_HTML_TEXT_WAITING_IMAGES_CLEAR() ;
}

/* Determine where an image is in the list and its index (or WAITING_IMAGE_NULL if none) */
@method HTMLTextClass, MSG_HTML_TEXT_WAITING_IMAGE_FIND
{
    T_waitingImageEntry *p_entry ;
    T_waitingImagesBlock *p_block ;
    word i = WAITING_IMAGE_NULL ;

    EC_ERROR_IF(pself->HTI_waitingImages==NullHandle, ERROR_WAITING_IMAGES_LIST_DOES_NOT_EXIST) ;
    if (pself->HTI_waitingImages)  {
        p_block = MemLock(pself->HTI_waitingImages) ;

        /* Walk the list looking for a match */
        i = p_block->WIB_usedStart ;
        while (i != WAITING_IMAGE_NULL)  {
            EC_ERROR_IF(i >= MAX_WAITING_IMAGES, ERROR_WAITING_IMAGES_LIST_LINKS_CORRUPT) ;
            if (i >= MAX_WAITING_IMAGES)  {
                /* If we went corrupt, just abort */
                i = WAITING_IMAGE_NULL ;
                break ;
            }
            p_entry = p_block->WIB_imageArray + i ;
            if (p_entry->WIE_imageIndex == imageIndex)
                break ;
            i = p_entry->WIE_next ;
        }

        MemUnlock(pself->HTI_waitingImages) ;
    }

    return i ;
}

/* Note that an image is waiting for a calculation */
@method HTMLTextClass, MSG_HTML_TEXT_WAITING_IMAGE_ADD
   /* (word imageIndex, word cellIndex) ; */
{
    Boolean didAdd = FALSE ;
    T_waitingImagesBlock *p_block ;
    T_waitingImageEntry *p_entry ;
    word newEntry ;

    EC_ERROR_IF(pself->HTI_waitingImages==NullHandle, ERROR_WAITING_IMAGES_LIST_DOES_NOT_EXIST) ;
    if (pself->HTI_waitingImages)  {
        p_block = MemLock(pself->HTI_waitingImages) ;

        /* On the first try, if we are full try to empty and maybe do a recalculation */
        if (p_block->WIB_freeStart == WAITING_IMAGE_NULL)
            @call oself::MSG_HTML_TEXT_WAITING_IMAGES_RESOLVE(FALSE) ;

        /* If we are still full, force a recalculation and clear the list */
        if (p_block->WIB_freeStart == WAITING_IMAGE_NULL)
            @call oself::MSG_HTML_TEXT_WAITING_IMAGES_RESOLVE(TRUE) ;

        /* Add a new item to the list */
        if (p_block->WIB_freeStart != WAITING_IMAGE_NULL)  {
            /* Pull an entry off the free list and add it to the used list */
            newEntry = p_block->WIB_freeStart ;
            EC_ERROR_IF(newEntry >= MAX_WAITING_IMAGES, ERROR_WAITING_IMAGES_LIST_LINKS_CORRUPT) ;
            if (newEntry < MAX_WAITING_IMAGES)  {
                p_entry = p_block->WIB_imageArray + newEntry ;
                p_block->WIB_freeStart = p_entry->WIE_next ;
                p_entry->WIE_next = p_block->WIB_usedStart ;
                p_block->WIB_usedStart = newEntry ;

                /* Record the info and note the updated time */
                p_entry->WIE_imageIndex = imageIndex ;
                p_entry->WIE_cellIndex = cellIndex ;
                p_block->WIB_timeUpdated = TimerGetCount() ;

                /* Yes, we did an add */
                didAdd = TRUE ;
            }
        }
        MemUnlock(pself->HTI_waitingImages) ;
    }

    return didAdd ;
}

#pragma codeseg HTMLCLAS_FREE_TEXT

/* "-dc" causes vptrs for text constants if different code segments are used */
#pragma option -dc-

/* Remove from the list any images that have had their cell calculated.  This frees up */
/* the list of items that are no longer needed. */
@method HTMLTextClass, MSG_HTML_TEXT_WAITING_IMAGES_FLUSH_ONES_WITH_CELLS_CALCULATED
{
    T_waitingImageEntry *p_entry ;
    T_waitingImagesBlock *p_block ;
    word i = WAITING_IMAGE_NULL ;
    T_waitingImageEntry *p_previous = NULL ;
    HTMLcellData *p_cell ;
    word size ;
    word next ;
    word stillWaiting = 0 ;

    EC_ERROR_IF(pself->HTI_waitingImages==NullHandle, ERROR_WAITING_IMAGES_LIST_DOES_NOT_EXIST) ;
    if (pself->HTI_waitingImages)  {
        p_block = MemLock(pself->HTI_waitingImages) ;

        /* Walk the used list looking for ones with cells that are no longer dirty */
        i = p_block->WIB_usedStart ;
        while (i != WAITING_IMAGE_NULL)  {
            EC_ERROR_IF(i >= MAX_WAITING_IMAGES, ERROR_WAITING_IMAGES_LIST_LINKS_CORRUPT) ;
            if (i >= MAX_WAITING_IMAGES)  {
                /* If we went corrupt, just abort this whole action. */
                break ;
            }
            p_entry = p_block->WIB_imageArray + i ;
            next = p_entry->WIE_next ;

            CellLock(pself->HTI_cellArray, p_entry->WIE_cellIndex, &p_cell, &size) ;
            if (!(p_cell->HCD_flags2 & HTML_CELL_DIRTY_LAYOUT_MASK))  {
                /* No longer dirty.  Remove this item from the used list and put on the free list. */
                /* TBD:  Invalidate the image?  Or is it part of the recalc? */
                if (p_previous)  {
                    p_previous->WIE_next = p_entry->WIE_next ;
                } else {
                    p_block->WIB_usedStart = p_entry->WIE_next ;
                }
                p_entry->WIE_next = p_block->WIB_freeStart ;
                p_block->WIB_freeStart = i ;
            } else {
                stillWaiting++ ;
            }
            CellUnlock(p_cell) ;

            p_previous = p_entry ;
            i = next ;
        }

        MemUnlock(pself->HTI_waitingImages) ;
    }

    return stillWaiting ;
}

/* Force all the images to be freed. */
@method HTMLTextClass, MSG_HTML_TEXT_WAITING_IMAGES_CLEAR
{
    T_waitingImagesBlock *p_block ;
    word i ;
    T_waitingImageEntry *p_entry ;

    EC_ERROR_IF(pself->HTI_waitingImages==NullHandle, ERROR_WAITING_IMAGES_LIST_DOES_NOT_EXIST) ;
    if (pself->HTI_waitingImages)  {
        /* Just brute force reset everything */
        p_block = MemLock(pself->HTI_waitingImages) ;
EC(     memset(p_block, 0xCC, sizeof(*p_block)) ;  )
NEC(     memset(p_block, 0x00, sizeof(*p_block)) ;  )
        strcpy((TCHAR*)p_block->WIB_tag, _T("ImgWait")) ;
        p_block->WIB_timeCreated = p_block->WIB_timeUpdated = TimerGetCount() ;
        p_block->WIB_usedStart = WAITING_IMAGE_NULL ;

        /* Link together all the free blocks */
        for (i=0, p_entry = p_block->WIB_imageArray; i<MAX_WAITING_IMAGES; i++, p_entry++)
            p_entry->WIE_next = i+1 ;

        /* Fixup the end of the list and point the free list to the begining */
        p_block->WIB_imageArray[MAX_WAITING_IMAGES-1].WIE_next = WAITING_IMAGE_NULL ;
        p_block->WIB_freeStart = 0 ;

        MemUnlock(pself->HTI_waitingImages) ;
    }
}

  /* Tries to free all images, but if any are left, causes a recalculation to occur. */
@method HTMLTextClass, MSG_HTML_TEXT_WAITING_IMAGES_RESOLVE
{
    word numLeft ;

    /* TBD:  Do we want time based code in here? */
    /* Two cases to consider: */
    /* 1) Too much time between graphic updates */
    /* 2) Too much time for the complete update */
    /* Of course, if the list is FULL, then we need to do a recalc */
    EC_ERROR_IF(pself->HTI_waitingImages==NullHandle, ERROR_WAITING_IMAGES_LIST_DOES_NOT_EXIST) ;
    if (pself->HTI_waitingImages)  {
        numLeft = @call oself::MSG_HTML_TEXT_WAITING_IMAGES_FLUSH_ONES_WITH_CELLS_CALCULATED() ;
        if (numLeft)  {
            // Update layout (delayed through queue to allow for combining)
            @send ,checkDuplicate ,forceQueue self::MSG_HTML_TEXT_CALCULATE_LAYOUT();

            /* Clear the list if we are done. */
            if (isLastUpdate)
                @call oself::MSG_HTML_TEXT_WAITING_IMAGES_CLEAR() ;
        }
    }
}

#pragma codeseg HTMLCLAS_TEXT

/* restore strings in code segment */
#pragma option -dc

/* Get rid of the block associate with waiting images */
@method HTMLTextClass, MSG_HTML_TEXT_WAITING_IMAGES_DESTROY
{
    EC_ERROR_IF(pself->HTI_waitingImages==NullHandle, ERROR_WAITING_IMAGES_LIST_DOES_NOT_EXIST) ;
    if (pself->HTI_waitingImages)  {
        MemFree(pself->HTI_waitingImages) ;
        pself->HTI_waitingImages = NullHandle ;
    }
}

@method HTMLTextClass, MSG_HTML_TEXT_IS_EMPTY
{
    /* Determine if this text object is empty */
    if (pself->HTI_numFormattedCells == 0)
        return TRUE ;

    return FALSE ;
}

