#include <pnglib.goh>

/**
 * Reading and processing the PNG file
 ********************************************************************
 */

VMBlockHandle _pascal _export pngConvertFile(FileHandle fileHan, VMFileHandle vmFile)
{
    IHDRData ihdrData = {0};
    VMBlockHandle vmBlock = NullHandle;
    IDATChunkEntry idatChunks[MAX_IDAT_CHUNKS] = {0};
    int idatNumChunks = 0;
    PLTEChunkEntry plteChunk = {0};
    IDATState state = {0};
    BMFormat fmt = 0;

    if (pngCheckHeader(fileHan))
    {
        // Read PNG Chunks, get overview
        if (pngProcessChunks(fileHan, &ihdrData, &idatChunks, &idatNumChunks, &plteChunk))
        {
            fmt = pngWhatOutputFormat(ihdrData.colorType, ihdrData.bitDepth);
            if (fmt != 0)
            {
                // Initialize output bitmap
                vmBlock = pngInitiateOutputBitmap(vmFile, ihdrData, fmt);

                // transfers only if a palette exists
                pngHandlePalette(fileHan, plteChunk, vmFile, vmBlock);

                // Initialize the IDAT state
                state = pngInitIDATProcessingState(fileHan, idatChunks, idatNumChunks, ihdrData);

                // Process each scanline
                while (pngGetNextIDATScanline(&state) == 1)
                {
                    pngPauseIDATProcessing(&state);

                    pngApplyGEOSFormatTransformations(&state);

                    // Write the processed scanline (without the filter byte) to the VMFile
                    pngWriteScanlineToBitmap(vmFile, vmBlock, state.lineNo - 1, state.currentRow);

                    pngResumeIDATProcessing(&state);
                }

                // Clean up resources
                pngCleanupIDATProcessingState(&state);

                return vmBlock;
            }
        }
    }

    return NullHandle;
}

// Check PNG Header
int _pascal _export pngCheckHeader(FileHandle file)
{
    unsigned char header[8];

    // Read first 8 bytes
    if (FileRead(file, header, 8, FALSE) != 8)
    {
        return 0; // file not long enough, no PNG
    }

    // Compare first 8 bytes with PNG-signature
    if (memcmp(header, PNG_SIGNATURE, 8) != 0)
    {
        return 0; // no PNG signature
    }

    // a PNG-signature it is
    return 1;
}

// main function for processing PNG-Chunks
int _pascal _export pngProcessChunks(FileHandle file, IHDRData* ihdrData, IDATChunkEntry (*idatChunks)[MAX_IDAT_CHUNKS], int *idatNumChunks, PLTEChunkEntry* plteChunk)
{
    ChunkHeader chdr = {0};
    int idatChunkIdx = 0;

    while (FileRead(file, &chdr, sizeof(ChunkHeader), FALSE))
    {
        // Swap endianness for chunk length and type
        chdr.length = swapEndian(chdr.length);
        chdr.type = swapEndian(chdr.type);

        switch (chdr.type)
        {
            case CHUNK_IHDR:
            {
                // Read and store IHDR data
                if (FileRead(file, ihdrData, sizeof(IHDRData), FALSE) != sizeof(IHDRData))
                {
                    // Error reading IHDR chunk
                    return 0;
                }

                if (ihdrData->interlaceMethod != 0) return 0; // we don't support interlacing

                ihdrData->width = swapEndian(ihdrData->width);
                ihdrData->height = swapEndian(ihdrData->height);

                // Move file pointer forward by the remaining part of the IHDR chunk
                FilePos(file, chdr.length - sizeof(IHDRData), FILE_POS_RELATIVE);

                break;
            }

            case CHUNK_PLTE:
            {
                // Read PLTE chunk
                plteChunk->length = chdr.length;
                plteChunk->chunkPos = FilePos(file, 0, FILE_POS_RELATIVE); // Store current position

                // Skip the PLTE chunk's data only, but not the CRC (CRC will be skipped outside the switch)
                FilePos(file, chdr.length, FILE_POS_RELATIVE);

                break;
            }

            case CHUNK_IDAT:
            {
                if (idatChunkIdx < MAX_IDAT_CHUNKS) // Prevent buffer overflow
                {
                    (*idatChunks)[idatChunkIdx].length = chdr.length;
                    (*idatChunks)[idatChunkIdx].chunkPos = FilePos(file, 0, FILE_POS_RELATIVE); // Store current position

                    idatChunkIdx++;
                    *idatNumChunks = idatChunkIdx;
                }
                else
                {
                    // Handle error: too many IDAT chunks
                    return 0;
                }

                // Skip the IDAT chunk's data only, but not the CRC (CRC will be skipped outside the switch)
                FilePos(file, chdr.length, FILE_POS_RELATIVE);
                break;
            }

            case CHUNK_IEND:
            {
                // Stop processing at IEND
                return 1;
            }

            default:
            {
                // Skip unknown chunks
                FilePos(file, chdr.length, FILE_POS_RELATIVE);
                break;
            }
        }

        // Skip the CRC (4 bytes) for all chunks
        FilePos(file, 4, FILE_POS_RELATIVE);
    }

    return 0;
}

IDATState _pascal _export pngInitIDATProcessingState(FileHandle file, IDATChunkEntry* idatChunks, int idatNumChunks, IHDRData ihdr)
{
    IDATState state;
    unsigned long allocSize = NULL;

    // Initialize the zlib stream
    state.strm.zalloc = Z_NULL;
    state.strm.zfree = Z_NULL;
    state.strm.opaque = Z_NULL;
    state.strm.avail_in = 0;
    state.strm.next_in = Z_NULL;

    //inflateInit2(&state.strm, 15 + 32);
    inflateInit2(&state.strm, 15);

    // memory for the input data from file to zlib
    state.inHan = MemAlloc(CHUNK_SIZE, HF_SHARABLE | HF_SWAPABLE, HAF_ZERO_INIT);
    state.in = MemLock(state.inHan);

    // memory for what zlib decodes
    state.outHan = MemAlloc(CHUNK_SIZE, HF_SHARABLE | HF_SWAPABLE, HAF_ZERO_INIT);
    state.out = MemLock(state.outHan);

    // how many bytes in a pixel, how many bytes in a row?
    // TBD: how to to handle siutaions where we upgrade the bit depth afterward (padding)? - see "of"
    state.rowBytes = calcBytesPerRow(ihdr.width, ihdr.colorType, ihdr.bitDepth);
    state.bytesPerPixel = calcBytesPerPixel(ihdr.colorType, ihdr.bitDepth);

    // determine how much memory to allocate - we need to allocate a little more
    // for 1 and 2 bit pixel data as it gets "padded to 4"
    if ((ihdr.colorType == PNG_COLOR_TYPE_GREY) && (ihdr.bitDepth == 2))
    {
        allocSize = calcBytesPerRow(ihdr.width, ihdr.colorType, 4) + 1;
    }
    else if (
        ((ihdr.colorType == PNG_COLOR_TYPE_PALETTE) && (ihdr.bitDepth == 1)) ||
        ((ihdr.colorType == PNG_COLOR_TYPE_PALETTE) && (ihdr.bitDepth == 2))
    )
    {
        allocSize = calcBytesPerRow(ihdr.width, ihdr.colorType, 4) + 1;
    }
    else
    {
        allocSize = state.rowBytes + 1;
    }

    // Allocate memory for the zlib-decoded and unfiltered current row, raw pixel data
    state.currentRowHan = MemAlloc(allocSize, HF_SHARABLE | HF_SWAPABLE, HAF_ZERO_INIT); // +1 for filter byte
    state.currentRow = MemLock(state.currentRowHan);

    // Allocate memory for the previous row - needed for the PNG unfilter mechanism
    state.previousRowHandle = MemAlloc(allocSize, HF_SHARABLE | HF_SWAPABLE, HAF_ZERO_INIT); // +1 for filter byte
    state.previousRow = MemLock(state.previousRowHandle);

    state.rowBufferOffset = 0;
    state.lineNo = 0;
    state.file = file;
    state.ihdr = ihdr;
    state.have = 0;
    state.outBufferPos = 0;

    state.idatNumChunks = idatNumChunks;
    state.idatChunkIdx = 0;
    memcpy(state.idatChunks, idatChunks, state.idatNumChunks * sizeof(IDATChunkEntry));

    state.length = state.idatChunks[state.idatChunkIdx].length;
    FilePos(state.file, state.idatChunks[state.idatChunkIdx].chunkPos, FILE_POS_START);

    return state;
}

// temporarily unlock the memory not needed for just putting out the pixels we just decoded
// NOTE: currentRow stays locked for further processing
void _pascal _export pngPauseIDATProcessing(IDATState* state)
{
    MemUnlock(state->inHan);
    MemUnlock(state->outHan);
    MemUnlock(state->previousRowHandle);
}

// relock the memory needed for further IDAT chunk processing
void _pascal _export pngResumeIDATProcessing(IDATState* state)
{
    state->in = MemLock(state->inHan);
    state->out = MemLock(state->outHan);
    state->previousRow = MemLock(state->previousRowHandle);
}

// Verarbeitung von IDAT-Chunks
int _pascal _export pngGetNextIDATScanline(IDATState* state)
{
    unsigned long have;  // Amount of data decompressed into the output buffer
    unsigned char *src;  // Pointer to the current position in the output buffer
    int ret;  // Return value of the zlib inflate function

    unsigned long rowBytes = state->rowBytes;  // Total number of bytes per scanline (excluding the filter byte)

    do
    {
        // If there is previously decompressed data remaining in the output buffer, process it first
        if (state->have > 0)
        {
            src = state->out + state->outBufferPos;  // Start processing from where we left off in the output buffer
            have = state->have;  // Set the remaining decompressed data to be processed

            // Loop to process the remaining data in the output buffer
            while (have > 0)
            {
                // Calculate how many bytes to copy into the row buffer (excluding the filter byte)
                unsigned long toCopy = (rowBytes + 1 - state->rowBufferOffset) < have ? (rowBytes + 1 - state->rowBufferOffset) : have;
                memcpy(state->currentRow + state->rowBufferOffset, src, toCopy);  // Copy data from output buffer to row buffer
                state->rowBufferOffset += toCopy;  // Update the row buffer offset
                src += toCopy;  // Move source pointer forward
                have -= toCopy;  // Decrease the remaining data to be processed

                // If we have a full scanline (including the filter byte), process the scanline
                if (state->rowBufferOffset == rowBytes + 1)
                {
                    // Unfilter the scanline using the previous row's data
                    unfilterRow(state->currentRow, state->previousRow, state->bytesPerPixel, rowBytes);

                    // Move the pixel data in the row buffer to skip the filter byte
                    memmove(state->currentRow, state->currentRow + 1, rowBytes);

                    // Save the current scanline (after unfiltering) to use in the next unfilter operation
                    memcpy(state->previousRow, state->currentRow, rowBytes);

                    // Reset the row buffer offset for the next scanline
                    state->rowBufferOffset = 0;

                    // Store the remaining data in the output buffer for the next call
                    state->have = have;
                    state->outBufferPos = src - state->out;  // Update the position in the output buffer

                    state->lineNo++;  // Increment the line number (note: NOT zero-based)

                    return 1;  // Successfully processed one scanline
                }
            }

            // If all remaining decompressed data has been processed, reset the state
            state->have = 0;
            state->outBufferPos = 0;
        }

        // If there is still data to read from the file or data left in the zlib stream, continue processing
        while (state->length > 0 || state->strm.avail_in > 0)
        {
            // If there is no more input data in the zlib stream, read more from the file
            if (state->strm.avail_in == 0 && state->length > 0)
            {
                unsigned long bytesToRead = (state->length < CHUNK_SIZE) ? state->length : CHUNK_SIZE;

                // Read the next chunk of compressed data from the file
                if (FileRead(state->file, state->in, bytesToRead, FALSE) != bytesToRead)
                {
                    inflateEnd(&state->strm);  // Clean up if there is an error
                    return -1;  // Return error code
                }

                // Set the input data for the zlib stream
                state->strm.avail_in = bytesToRead;
                state->strm.next_in = state->in;
                state->length -= bytesToRead;  // Decrease the remaining length of the compressed data
            }

            // Set up the output buffer for decompression
            state->strm.avail_out = CHUNK_SIZE;
            state->strm.next_out = state->out;

            // Decompress the data from the input buffer into the output buffer
            ret = inflate(&state->strm, Z_NO_FLUSH);

            if (ret != Z_OK && ret != Z_STREAM_END)
            {
                inflateEnd(&state->strm);  // Clean up if decompression error occurs
                return -1;  // Return error code
            }

            // Calculate how much data was decompressed
            have = CHUNK_SIZE - state->strm.avail_out;
            src = state->out;  // Point to the start of the decompressed data

            // Process the decompressed data in the output buffer
            while (have > 0)
            {
                // Calculate how many bytes to copy into the row buffer
                unsigned long toCopy = (rowBytes + 1 - state->rowBufferOffset) < have ? (rowBytes + 1 - state->rowBufferOffset) : have;
                memcpy(state->currentRow + state->rowBufferOffset, src, toCopy);  // Copy the decompressed data to the row buffer
                state->rowBufferOffset += toCopy;  // Update the row buffer offset
                src += toCopy;  // Move the source pointer forward
                have -= toCopy;  // Decrease the remaining decompressed data to process

                // If a full scanline (including the filter byte) has been accumulated, process it
                if (state->rowBufferOffset == rowBytes + 1)
                {
                    // Unfilter the scanline
                    unfilterRow(state->currentRow, state->previousRow, state->bytesPerPixel, rowBytes);

                    // Move the pixel data to skip the filter byte
                    memmove(state->currentRow, state->currentRow + 1, rowBytes);

                    // Save the current scanline for future unfiltering
                    memcpy(state->previousRow, state->currentRow, rowBytes);

                    // Reset the row buffer offset for the next scanline
                    state->rowBufferOffset = 0;

                    // Store the remaining decompressed data for the next call
                    state->have = have;
                    state->outBufferPos = src - state->out;  // Update the position in the output buffer

                    state->lineNo++;  // Increment the line number (not zero-based)

                    return 1;  // Successfully processed one scanline
                }
            }
        }
    }
    while(nextIDATChunk(state));

    // Return 0 when all scanlines are processed
    return 0;
}

int nextIDATChunk(IDATState* state)
{
    if (state->idatChunkIdx + 1 < state->idatNumChunks) // zero based!
    {
        state->idatChunkIdx++;
        state->length = state->idatChunks[state->idatChunkIdx].length;
        FilePos(state->file, state->idatChunks[state->idatChunkIdx].chunkPos, FILE_POS_START);
        return 1;
    }

    return 0;
}

void _pascal _export pngCleanupIDATProcessingState(IDATState* state)
{
    inflateEnd(&state->strm);
    MemFree(state->inHan);
    MemFree(state->outHan);
    MemFree(state->currentRowHan);
    MemFree(state->previousRowHandle);
}

void _pascal _export pngHandlePalette(FileHandle file, PLTEChunkEntry plteChunk, VMFileHandle vmFile, VMBlockHandle vmBlock)
{
    if ((plteChunk.chunkPos != 0) && (plteChunk.length != 0))
    {
        byte* palette = NULL;
        MemHandle paletteHan = NullHandle;
        MemHandle bmmem;
        unsigned int offset;
        byte *bmblock;

        // Make sure the length is divisible by 3 (each color is 3 bytes)
        if (plteChunk.length % 3 != 0 || (plteChunk.length / 3) > MAX_PALETTE_ENTRIES)
        {
            return;  // Invalid palette length
        }

        // Create our temp. palette storage
        paletteHan = MemAlloc(plteChunk.length, HF_SHARABLE | HF_SWAPABLE, HAF_ZERO_INIT);
        palette = MemLock(paletteHan);

        // Read the palette data
        FilePos(file, plteChunk.chunkPos, FILE_POS_START);
        FileRead(file, palette, plteChunk.length, FALSE);

        // Copy palette data to Bitmap VM File
        bmblock = VMLock(vmFile, vmBlock, &bmmem);
        offset = bmblock[0x28]+256*(bmblock[0x29]); // WHUT?!
        offset += 0x1c;
        memcpy(&(bmblock[offset]), palette, plteChunk.length);
        VMDirty(bmmem);
        VMUnlock(bmmem);

        // Free Palette mem, no unlock needed
        MemFree(paletteHan);
    }
}

/**
 * Writing the GEOS Bitmap
 ********************************************************************
 */

// 1 BIT: BMF_MONO | BMT_COMPLEX | BMT_PALETTE
//         black & white
//
// 4 BIT: BMF_4BIT | BMT_COMPLEX | BMT_PALETTE
//         1 bit (2 color) paletted => add padding
//         2 bit (4 color) paletted => add padding
//         4 bit (16 color) paletted
//
//         2 bit (4 level) grayscale => add padding, use grayscale palette
//         4 bit (16 level) grayscale => use grayscale palette
//
//
// 8 BIT: BMF_8BIT | BMT_COMPLEX | BMT_PALETTE
//         8 bit (256 color) paletted
//
//         8 bit (256 level) grayscale => use grayscale palette
//         16 bit (64k level) grayscale => downcycle to 8-bit, then use 8 bit grayscale palette
//
//         8 bit grayscale + 8 bit alpha-channel => use grayscale palette, blend with alpha
//         16 bit grayscale + 16 bit alpha-channel  => downcycle to 8-bit, then use 8 bit grayscale palette, then blend with alpha
//
//
// 24 BIT: BMF_24BIT | BMT_COMPLEX
//         3x8 bits rgb color
//         3x16 bits rgb color => downcycle to 8 bit
//
//         3x8 bits rgb color + 8 bit alpha-channel => remove alpha by blending in with white
//         3x16 bits rgb color + 16 bit alpha-channel => downcycle to 8 bit / channel => remove alpha by blending in with white

BMFormat _pascal _export pngWhatOutputFormat(int colorType, int bitDepth)
{
    BMFormat output = 0;

    switch (colorType)
    {
        case PNG_COLOR_TYPE_GREY:
            switch (bitDepth)
            {
                case 1:
                    // Processing 1-bit Greyscale
                    output = BMF_MONO | BMT_COMPLEX | BMT_PALETTE;
                    break;
                case 2:
                    // Processing 2-bit Greyscale
                case 4:
                    // Processing 4-bit Greyscale
                    output = BMF_4BIT | BMT_COMPLEX | BMT_PALETTE;
                    break;
                case 8:
                    // Processing 8-bit Greyscale
                case 16:
                    // Processing 16-bit Greyscale
                    output = BMF_8BIT | BMT_COMPLEX | BMT_PALETTE;
                    break;
                default:
                    // Invalid BitDepth for Greyscale
                    break;
            }
            break;

        case PNG_COLOR_TYPE_RGB:
            switch (bitDepth)
            {
                case 8:
                    // Processing 8-bit Truecolor
                case 16:
                    // Processing 16-bit Truecolor
                    output = BMF_24BIT | BMT_COMPLEX;
                    break;
                default:
                    // Invalid BitDepth for Truecolor
                    break;
            }
            break;

        case PNG_COLOR_TYPE_GREY_ALPHA:
            switch (bitDepth)
            {
                case 8:
                    // Processing 8-bit Greyscale + Alpha
                case 16:
                    // Processing 16-bit Greyscale + Alpha
                    output = BMF_8BIT | BMT_COMPLEX | BMT_PALETTE;
                    break;
                default:
                    // Invalid BitDepth for Greyscale with Alpha
                    break;
            }
            break;

        case PNG_COLOR_TYPE_RGBA:
            switch (bitDepth)
            {
                case 8:
                    // Processing 8-bit Truecolor + Alpha
                case 16:
                    // Processing 16-bit Truecolor + Alpha
                    output = BMF_24BIT | BMT_COMPLEX;
                    break;
                default:
                    // Invalid BitDepth for Truecolor with Alpha
                    break;
            }
            break;

        case PNG_COLOR_TYPE_PALETTE:
            switch (bitDepth)
            {
                case 1:
                    // Processing 1-bit Palette (2 colors)
                case 2:
                    // Processing 2-bit Palette (4 colors)
                case 4:
                    // Processing 4-bit Palette (16 colors)
                    return BMF_4BIT | BMT_COMPLEX | BMT_PALETTE;
                    break;
                case 8:
                    // Processing 8-bit Palette (256 colors)
                    return BMF_8BIT | BMT_COMPLEX | BMT_PALETTE;
                    break;
                default:
                    // Invalid BitDepth for Palette
                    break;
            }
            break;

        default:
            // Invalid ColorType
            break;
    }

    return output;
}

VMBlockHandle _pascal _export pngInitiateOutputBitmap(VMFileHandle vmFile, IHDRData ihdrData, BMFormat fmt)
{
    GStateHandle bmstate;
    VMBlockHandle vmBlock;

    vmBlock = GrCreateBitmap(
        fmt,
        ihdrData.width, ihdrData.height,
        vmFile,
        0,
        &bmstate
    );

    // GrDestroyBitmap(bmstate, BMD_LEAVE_DATA);

    return vmBlock;
}

void _pascal _export pngApplyGEOSFormatTransformations(IDATState* state)
{
    RGBValue blendColor = {255, 255, 255};

    // Convert 16-bit to 8-bit if needed
    convert16BitLineTo8Bit(state->currentRow, state->ihdr.width, state->ihdr.colorType, state->ihdr.bitDepth);

    // Remove any alpha channel
    removeAlphaChannel(state->currentRow, state->ihdr.width, state->ihdr.colorType, blendColor);

    // add "padding" to 1- and 2-bitted paletted / indexed data bytes or to 2-bitted grayscale values
    pad_1bit_to_4bit(state->currentRow, state->ihdr.width, state->ihdr.colorType, state->ihdr.bitDepth);
    pad_2bit_to_4bit(state->currentRow, state->ihdr.width, state->ihdr.colorType, state->ihdr.bitDepth);
}

void _pascal _export pngWriteScanlineToBitmap(VMFileHandle vmFile, VMBlockHandle vmBlock, unsigned long lineNo, unsigned char* rowData)
{
    //unsigned char *lineptr;
    void *lineptr;
    word size;

    HugeArrayLock(
        vmFile,
        vmBlock,
        (dword) lineNo,
        &lineptr,
        &size
    );

    // CopyAndDither(lineptr, buffer[0], size) ;

    memcpy(lineptr, rowData, size);

    HugeArrayDirty(lineptr);
    HugeArrayUnlock(lineptr);
}


/**
 * Helpers and processing of image data itself
 ********************************************************************
 */

int abs(int x)
{
    return x >= 0 ? x : -x;
}

unsigned long swapEndian(unsigned long val)
{
    return ((val >> 24) & 0x000000FF) |
           ((val >> 8) & 0x0000FF00) |
           ((val << 8) & 0x00FF0000) |
           ((val << 24) & 0xFF000000);
}

// Calculate the number of bits per pixel based on bitDepth and colorType
unsigned long calcBytesPerRow(unsigned long width, unsigned char colorType, unsigned char bitDepth)
{
    unsigned long bitsPerPixel;
    unsigned long rowBytes;

    switch (colorType) {
        case 0: // Grayscale
            bitsPerPixel = bitDepth;
            break;
        case 2: // Truecolor (RGB)
            bitsPerPixel = 3 * bitDepth;
            break;
        case 3: // Indexed color
            bitsPerPixel = bitDepth;
            break;
        case 4: // Grayscale with Alpha
            bitsPerPixel = 2 * bitDepth;
            break;
        case 6: // Truecolor with Alpha (RGBA)
            bitsPerPixel = 4 * bitDepth;
            break;
        default:
            // Unsupported color type
            return 0;
    }

    rowBytes = (width * bitsPerPixel + 7) / 8; // Round up to the next whole byte

    return rowBytes;
}

// Bytes per Pixel.
unsigned long calcBytesPerPixel(unsigned char colorType, unsigned char bitDepth)
{
    return calcBytesPerRow(1, colorType, bitDepth);
}

// Paeth-PrÃ¤diktor-Funktion
static inline unsigned char paethPredictor(int a, int b, int c)
{
    int p = a + b - c;
    int pa = abs(p - a);
    int pb = abs(p - b);
    int pc = abs(p - c);

    if (pa <= pb && pa <= pc) return (unsigned char)a;
    else if (pb <= pc) return (unsigned char)b;
    else return (unsigned char)c;
}

void removeAlphaChannel(unsigned char *data, unsigned long width, int colorType, RGBValue blendColor)
{
    unsigned long j;
    unsigned char *src = data; // Start at the first pixel
    unsigned char *dst = data;

    if (colorType == 6) // RGBA (truecolor with alpha)
    {
        for (j = 0; j < width; j++)
        {
            unsigned char r = src[0];
            unsigned char g = src[1];
            unsigned char b = src[2];
            unsigned char a = src[3]; // Alpha value

            // Blend RGB with the provided background color
            dst[0] = (r * a + blendColor.RGB_red * (255 - a)) / 255;
            dst[1] = (g * a + blendColor.RGB_green * (255 - a)) / 255;
            dst[2] = (b * a + blendColor.RGB_blue * (255 - a)) / 255;

            // Move the source pointer forward by 4 (skip the alpha channel)
            src += 4;
            // Move the destination pointer forward by 3 (RGB only)
            dst += 3;
        }
    }
    else if (colorType == 4) // Grayscale with alpha
    {
        for (j = 0; j < width; j++)
        {
            unsigned char gray = src[0];
            unsigned char a = src[1]; // Alpha value

            // Blend grayscale value with the background (assume grayscale blend for simplicity)
            unsigned char blendedGray = (gray * a + blendColor.RGB_red * (255 - a)) / 255; // Use red from blendColor

            dst[0] = blendedGray; // Grayscale -> RGB, so all RGB channels are the same
            dst[1] = blendedGray;
            dst[2] = blendedGray;

            src += 2; // Move past grayscale and alpha
            dst += 3; // Move RGB
        }
    }
}

void convert16BitLineTo8Bit(unsigned char *line, unsigned long width, unsigned char colorType, unsigned char bitDepth)
{
    // Variable declarations
    unsigned long i;
    unsigned long bytes_per_pixel_16;
    unsigned long bytes_per_pixel_8;
    unsigned long rowBytes;

    MemHandle dstHan;
    unsigned char *dst;
    unsigned char *dstStart;

    int c;
    int channels;

    // Initialize variables
    dstHan = NullHandle;
    dst = NULL;
    dstStart = NULL;
    rowBytes = 0;
    c = 0;

    // Check if the bitDepth is 16 bits. If not, return as this function only handles 16-bit channels.
    if (bitDepth != 16)
    {
        return;
    }

    // Determine the number of channels and bytes per pixel based on colorType
    if (colorType == PNG_COLOR_TYPE_RGB)
    {
        channels = 3; // RGB: 3 channels
    }
    else if (colorType == PNG_COLOR_TYPE_RGBA)
    {
        channels = 4; // RGBA: 4 channels
    }
    else if (colorType == PNG_COLOR_TYPE_GREY)
    {
        channels = 1; // Grayscale: 1 channel
    }
    else if (colorType == PNG_COLOR_TYPE_GREY_ALPHA)
    {
        channels = 2; // Grayscale with alpha: 2 channels
    }
    else
    {
        // Unsupported or invalid colorType
        return;
    }

    // Calculate the number of bytes per row for both 16-bit (input) and 8-bit (output) data
    bytes_per_pixel_16 = channels * 2; // 2 bytes per channel in 16-bit data
    bytes_per_pixel_8 = channels * 1;  // 1 byte per channel in 8-bit data
    rowBytes = calcBytesPerRow(width, colorType, 8); // 8 bits per channel after conversion

    // Allocate memory for the destination buffer
    dstHan = MemAlloc(rowBytes, HF_SHARABLE | HF_SWAPABLE, HAF_ZERO_INIT);
    dst = MemLock(dstHan);
    dstStart = dst;

    // Process each pixel
    for (i = 0; i < width; i++)
    {
        unsigned long index16 = i * bytes_per_pixel_16; // Index in the 16-bit source line
        unsigned long index8 = i * bytes_per_pixel_8;   // Index in the 8-bit destination line

        // Convert each channel (R, G, B, A, grayscale, or alpha if applicable)
        for (c = 0; c < channels; c++)
        {
            // Combine two bytes to form the 16-bit value for the channel
            unsigned short value16 = (line[index16 + c * 2] << 8) | line[index16 + c * 2 + 1];

            // Convert the 16-bit value to 8-bit by right-shifting 8 bits
            dst[index8 + c] = value16 >> 8;
        }
    }

    // Copy the converted 8-bit values back to the original buffer
    memcpy(line, dstStart, bytes_per_pixel_8 * width);

    // Free the memory allocated for the destination buffer
    MemFree(dstHan);
}


// Function to convert 1-bit packed values to 4-bit padded values
void pad_1bit_to_4bit(unsigned char *input, unsigned int width, unsigned char colorType, unsigned char bitDepth)
{
    unsigned int in_index = 0;   // Index for the input array
    unsigned int out_index = 0;  // Index for the output array
    unsigned int bit;
    unsigned int x = 0;

    // Calculate the number of output bytes needed (4 bits per pixel, so 2 pixels per byte)
    unsigned int rowBytes = (width + 1) / 2;  // Each byte holds 2 pixels in 4-bit format

    MemHandle outputHan = NullHandle;
    unsigned char* output;

    // Apply only to paletted or grayscale colorTypes and only if bitDepth is 1 (but exclude 1-bit grayscale mono)
    if (
        (colorType != PNG_COLOR_TYPE_PALETTE) ||
        (colorType != PNG_COLOR_TYPE_GREY) ||
        ((colorType == PNG_COLOR_TYPE_GREY) && (bitDepth == 1))
    )
    {
        return; // Exit if the colorType or bitDepth is not supported
    }

    // Allocate memory for the output row
    outputHan = MemAlloc(rowBytes, HF_SHARABLE | HF_SWAPABLE, HAF_ZERO_INIT); // Allocate memory with zero-initialization
    output = (unsigned char*) MemLock(outputHan);  // Lock the memory to access the output array

    // Process each bit in the input array
    for (x = 0; x < width; x++)
    {
        // Get the current bit (extract from the input byte)
        bit = (input[in_index] >> (7 - (x % 8))) & 1;

        // Place the bit as a 4-bit value (0x0 or 0x1) into the correct nibble
        if (x % 2 == 0) {
            // If even index, put the 4-bit value in the high nibble
            output[out_index] = bit << 4;  // 0 or 1 shifted to the high nibble
        } else {
            // If odd index, put the 4-bit value in the low nibble
            output[out_index] |= bit;  // Place bit in the low nibble
            out_index++;  // Move to the next byte in the output array after filling both nibbles
        }

        // Move to the next byte in the input after processing 8 pixels (1 byte)
        if ((x % 8) == 7) {
            in_index++;
        }
    }

    // Copy the padded 4-bit values back to the input buffer
    memcpy(input, output, rowBytes);

    // Free the allocated memory
    MemFree(outputHan);
}

// Function to convert 2-bit packed values to 4-bit padded values
void pad_2bit_to_4bit(unsigned char *input, unsigned int width, unsigned char colorType, unsigned char bitDepth)
{
    unsigned int in_index = 0;   // Index for the input array
    unsigned int out_index = 0;  // Index for the output array
    unsigned int pixel;
    unsigned int x = 0;
    MemHandle outputHan = NullHandle;
    unsigned char* output = 0;

    // Calculate the number of output bytes needed (4 bits per pixel, so 2 pixels per byte)
    unsigned int rowBytes = (width + 1) / 2;  // Each byte holds 2 pixels in 4-bit format

    // Apply only to paletted or grayscale colorTypes and only if bitDepth is 2
    if ((colorType != PNG_COLOR_TYPE_PALETTE && colorType != PNG_COLOR_TYPE_GREY) || bitDepth != 2)
    {
        return; // Exit if the colorType or bitDepth is not supported
    }

    // Allocate memory for the output row
    outputHan = MemAlloc(rowBytes, HF_SHARABLE | HF_SWAPABLE, HAF_ZERO_INIT); // Allocate memory with zero-initialization
    output = (unsigned char*) MemLock(outputHan);  // Lock the memory to access the output array

    // Process each 2-bit pixel in the input array
    for (x = 0; x < width; x++)
    {
        // Get the current 2-bit pixel (extract from the input byte)
        pixel = (input[in_index] >> (6 - (x % 4) * 2)) & 0x03;

        // Place the 2-bit value as a 4-bit value (0x0 to 0x3) into the correct nibble
        if (x % 2 == 0)
        {
            // If even index, put the 4-bit value in the high nibble
            output[out_index] = pixel << 4;  // Shift 2-bit value to the high nibble
        }
        else
        {
            // If odd index, put the 4-bit value in the low nibble
            output[out_index] |= pixel;  // Place the 2-bit value in the low nibble
            out_index++;  // Move to the next byte in the output array after filling both nibbles
        }

        // Move to the next byte in the input after processing 4 pixels (1 byte)
        if ((x % 4) == 3)
        {
            in_index++;
        }
    }

    // Copy the padded 4-bit values back to the input buffer
    memcpy(input, output, rowBytes);

    // Free the allocated memory
    MemFree(outputHan);
}

// Unfilter-Funktion zur Verarbeitung der PNG-Bilddaten
void unfilterRow(unsigned char *data, unsigned char *previousRow, unsigned long bytesPerPixel, unsigned long rowBytes)
{
    unsigned char *currentRow = data;
    unsigned char filterType = *currentRow; // just the first byte!
    unsigned long i;

    // Pointer to the first byte after the filter type
    currentRow++;

    // Apply the filter
    switch (filterType)
    {
        case FILTER_NONE:
            // No filter, data is already in place
            break;
        case FILTER_SUB:
            for (i = bytesPerPixel; i < rowBytes; i++) {
                currentRow[i] += currentRow[i - bytesPerPixel];
            }
            break;
        case FILTER_UP:
            for (i = 0; i < rowBytes; i++) {
                currentRow[i] += previousRow[i];
            }
            break;
        case FILTER_AVERAGE:
            for (i = 0; i < rowBytes; i++)
            {
                unsigned char left = (i >= bytesPerPixel) ? currentRow[i - bytesPerPixel] : 0;
                unsigned char up = previousRow[i];
                currentRow[i] += (left + up) / 2;
            }
            break;
        case FILTER_PAETH:
            for (i = 0; i < rowBytes; i++)
            {
                unsigned char left = (i >= bytesPerPixel) ? currentRow[i - bytesPerPixel] : 0;
                unsigned char up = previousRow[i];
                unsigned char upLeft = (i >= bytesPerPixel) ? previousRow[i - bytesPerPixel] : 0;
                currentRow[i] += paethPredictor(left, up, upLeft);
            }
            break;
        default:
            // Invalid filter type
            return;
    }
}

