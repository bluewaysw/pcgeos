/***********************************************************************
 *
 *	Code-File for Bitmap Tool Library
 *
 *      Made by RABE-Soft 10/2002 - 07/2025
 *	Adapted for free PC/GEOS project 01/2024
 *
 *
 *	Note: Comments were translated from German to English with AI support
 *	and were not always manually reviewed in detail. Some may sound
 *	a little odd as a result.
 *
 *
 ***********************************************************************/

@include <stdlib.h>

#include <string.h>

@include "bmptools.goh"
@include "Code/rtools.goh"
@include "stdio.h"


/*
 ***************************************************************************
 *		Bitmap tools: Creating and managing offscreen bitmaps
 *			Accessing the header
 ***************************************************************************
 */


/*--------------------- BTCreateOffscreenBitmap ---------------------
 *	Purpose:	Create a HugeBitmap without relying on system graphics
 *			routines. Does not create a GState. The bitmap is
 *			intended for writing via direct access, but it can also
 *			be edited normally using GrEditBitmap().
 *
 *	Internal structure of a HugeBitmap
 *	Source: Source of GrCreateBitmapRaw(), Swat of GrCreateBitmap(),
 *		VideoDr.def
 *
 *	+------>+-------------------------------+
 *    	| E  B	| HugeArrayDirectory		|	sizeof(HugeArrayDirectory)
 *	| d  i	+-------------------------------+       sizeof(CBitmap)
 *    	| i  t	| Complex Bitmap Header		|       -> total 46 bytes
 *	| t  m	+-------------------------------+
 *   	| a  a	| BitmapMode flags 		|	1 word
 *	| b  p	+-------------------------------+
 *   	| l  	| hptr.ColorTransfer 		|	apparently 1 word
 *	| e    	+-------------------------------+
 *    	| 	| Device Info Block		|	sizeof(VideoDriverInfo), 32 bytes
 *	+------>+-------------------------------+	->defined in VideoDr.def
 *  		| 1-scan-line buff for vidmem	|	size depends on bitmap
 *		+-------------------------------+
 *		| [optional palette space]	|	either 16 or 256
 *		+-------------------------------+	3-byte entries
 *
 *	EditableBitmap (total size: 82 bytes)
 *	------------------------------------------
 *	is an internal structure used for accessing the data in the
 *	HugeArrayHeader. According to Swat, its size is 82 bytes (0x52h)
 *
 *	1-scan-line buff for vidmem
 *	------------------------------------------
 *	Used by system routines for editing the bitmap.
 *	Size: the larger of the two values:
 *		- BytesPerLine: width * bytesPerPixel + mask length
 *		- Double height (2 * height)
 *
 * ----------------------------------------------------------------------------
 *
 *	Parameters:	fh:	Handle to the file for the bitmap
 *			format:	Bitmap format. Must be one of the values
 *				BMF_MONO, BMF_4BIT, BMF_8BIT, BMF_24BIT,
 *				combined with the type flags
 *				BMT_PALETTE, BMT_MASK
 *                              The flags BMT_HUGE and BMT_COMPLEX are set automatically.
 *			width:	Width of the bitmap (in pixels)
 *			height: Height of the bitmap (in pixels, == number of lines)
 *				Height zero is allowed; in this case, the HugeArray
 *				contains no elements (yet). They can be added later.
 *			palette: if the BMT_PALETTE bit is set in format,
 *				a pointer to the palette values can be passed here.
 *				There must be as many entries as required by the
 *				color depth.
 *				A null pointer is allowed, in which case
 *				the palette values remain uninitialized.
 *	Return:		Handle of the newly created bitmap
 ---------------------------------------------------------------------------*/
extern VMBlockHandle BTLIB_EXPORT BTCreateOffscreenBitmap(VMFileHandle fh, BMFormat format,
	word width, word height, PaletteEntry *palette) {

CBitmap	defaultHeader = { { 0, 0, 0, 0 },	// CB_simple: uninitialized
	0, 0, 0x18, 0,                          // CB_startScan, CB_numScans,
						// CB_devInfo, CB_data:
						// probably internal.
	0, 0x48, 0x48 };			// CB_palette: uninitialized
						// CB_xres, CB_yRes: 72 dpi
int	numColors, paletteDataSize, maskLen, bytesPerLine;
VMBlockHandle	bmpHandle;
byte 	*rawData;
MemHandle  mh;
CBitmap    *cBmp;
word       *wPtr;
int	   headerSpaceSize, offsetToPalette;

/* Hardcode 82-byte EditableBitmap structure size. Determined via Swat. */
#define SIZE_OF_EDITABALE_BITMAP	82

   /* Calculate sizes required for creation */
   switch ( format & BMT_FORMAT ) {
   case BMF_MONO:
	numColors = 2;
	bytesPerLine = (width + 7) >> 3;
	break;
   case BMF_4BIT:
	numColors = 16;
	bytesPerLine = (width+1) >> 1;
	break;
   case BMF_8BIT:
	numColors = 256;
	bytesPerLine = width;
	break;
   case BMF_24BIT:
	numColors = 0;
	bytesPerLine = 3*width;
	break;
	}

   if ( format & BMT_MASK ) maskLen = (width + 7) >> 3;
	else maskLen = 0;
   if ( format & BMT_PALETTE ) paletteDataSize = numColors * sizeof(PaletteEntry);
	else paletteDataSize = 0;

   /* The HugeArrayHeader requires a certain amount of space: */
      // Scanline buffer for vidmem: max_of(SumBytesPerLine, 2 * height)
	headerSpaceSize = bytesPerLine + maskLen;
	if ( headerSpaceSize < ( 2*height) ) headerSpaceSize = 2*height;
      // EditableBitmap structure
	headerSpaceSize += SIZE_OF_EDITABALE_BITMAP; 	/* see above */
      // Space for palette
	headerSpaceSize += paletteDataSize + 2;	/* palette data */
      // Safety margin. Since I stepped through the assembler code,
      // and am therefore quite confident, this is actually not needed.
      // But I feel more comfortable this way.
//	headerSpaceSize += 64;

   /* Create HugeArray */
   bmpHandle = HugeArrayCreate( fh,
	bytesPerLine + maskLen,		// size of a single line
	headerSpaceSize);		// size for HugeArrayHeader

   /* Initialize ComplexBitmap header */
   rawData = VMLock(fh, bmpHandle , &mh);
   cBmp = (CBitmap *)(rawData + sizeof(HugeArrayDirectory));
   memset(cBmp, 0, headerSpaceSize - sizeof(HugeArrayDirectory));
   *cBmp = defaultHeader;
   cBmp->CB_simple.B_width = width;
   cBmp->CB_simple.B_height = height;
   cBmp->CB_simple.B_type = format | BMT_HUGE | BMT_COMPLEX;

   /* if needed: copy palette */
   if ( paletteDataSize ) {
      offsetToPalette = headerSpaceSize - paletteDataSize - 2;

      // Set number of colors
      cBmp->CB_palette = offsetToPalette - sizeof(HugeArrayDirectory);
      wPtr = (word*)(rawData + offsetToPalette);
      *wPtr = numColors;

      if (palette) {
	     // Copy palette
	     wPtr++;
	     memcpy(wPtr, palette, numColors * sizeof(PaletteEntry));
	     }         	// end of if (palette)

      }                 // end of if (paletteDataSize)

   VMDirty(mh);
   VMUnlock(mh);
   /* if height is not zero: create HugeArray elements */
   if ( height ) {
	byte *p;
	int k;

	/* Fill mask area with zeros (all transparent) and data area with 0xFF (usually white) */
	p = malloc(bytesPerLine + maskLen);
	if (maskLen) memset( p, 0x00, maskLen);
	memset( p + maskLen, 0xFF, bytesPerLine);

	for (k = 0; k < height; k++ ) HugeArrayAppend( fh, bmpHandle, 1, p);

	free(p);
	}

   return bmpHandle;
   }

/*--------------------- BTSetBitmapHeight ---------------------
 *	Purpose:        Change the height of the bitmap in the bitmap header.
 *			Used to adjust the bitmap height when, for example,
 *			a bitmap created via BTCreateOffscreenBitmap() has had
 *			its height changed by appending or deleting lines
 *			(HugeArray elements).
 *	Parameters:	fh:	Handle of the file containing the bitmap
 *			bmpHandle: handle of the bitmap
 *			height: new height of the bitmap. It should match the
 *				actual number of elements in the HugeArray.
 *	Return:		-
 ---------------------------------------------------------------------------*/
extern void BTLIB_EXPORT BTSetBitmapHeight(VMFileHandle vmFile, VMBlockHandle bmpHandle, word height) {
byte * rawData;
MemHandle   mh;
CBitmap * cBmp;

     rawData = VMLock(vmFile, bmpHandle , &mh);
     cBmp = (CBitmap *)(rawData + sizeof(HugeArrayDirectory));
     cBmp->CB_simple.B_height = height;
     VMDirty(mh);
     VMUnlock(mh);

     }

/* ------------------------------------------------------------------------
 * 	BTGetMoreBitmapInfos
 *      Retrieve bitmap type information (color depth and more)
 *		NULL pointers are allowed for width, height, mask,
 *		if you are not interested one of in these informations
 *	Return: 	BMType (e.g., (BMT_MASK | BMF_8BIT) )
 * ------------------------------------------------------------------------*/
extern int BTLIB_EXPORT BTGetMoreBitmapInfos(VMFileHandle fh, VMBlockHandle vmBlock,
	int *width, int *height, int *compact ) {
byte * rawData;
MemHandle   mh;
CBitmap * cBmp;
int 	retVal;

	rawData = VMLock(fh,vmBlock, &mh);
	cBmp = (CBitmap *)(rawData + sizeof(HugeArrayDirectory));
	retVal = cBmp->CB_simple.B_type;
	if ( compact ) *compact = cBmp->CB_simple.B_compact;
	if ( width ) *width = cBmp->CB_simple.B_width;
	if ( height ) *height = cBmp->CB_simple.B_height;
	VMUnlock(mh);
	return retVal;
	}

/*--------------------- BTBitmapToolLockHeader ---------------------
 *	Purpose:        Lock the HugeBitmap header. This is a low-level
 *			routine and should be used with care.
 *			Unlock is done with VMUnlock(), possibly preceded by VMDirty().
 *	Parameters:	fh:	Handle of the VM file
 *			bmpHandle: VM handle of the bitmap
 *			*mh: 	Pointer to a MemHandle used for VMDirty() and
 *				VMUnlock()
 *	Return:		Pointer to the locked CBitmap header
 ---------------------------------------------------------------------------*/
extern CBitmap* BTLIB_EXPORT BTBitmapToolLockHeader(VMFileHandle fh, VMBlockHandle bmpHandle,
			MemHandle  *mh) {
byte 	*rawData;
CBitmap    *cBmp;

   rawData = VMLock(fh, bmpHandle , mh);
   cBmp = (CBitmap *)(rawData + sizeof(HugeArrayDirectory));
   return cBmp;
   }

/*===========================================================================
	Palette Access Routines
 ===========================================================================*/

/*--------------------- BTGetBitmapPalette ---------------------
 *	Purpose:        Copy the bitmap palette into a buffer
 *	Parameters:	fh:	Handle of the VM file
 *			bmpHandle: VM handle of the bitmap
 *			*palette:  Pointer to the buffer into which the palette
 *				   should be copied
 *			numEntries: number of palette entries
 *	Return:		Error flag: FALSE == OK
 *				TRUE == error (bitmap has no palette)
 ---------------------------------------------------------------------------*/
extern Boolean BTLIB_EXPORT BTGetBitmapPalette(VMFileHandle fh, VMBlockHandle bmpHandle,
		PaletteEntry *palette, int numEntries) {
byte 	*palPtr, *bPtr;
MemHandle  mh;
CBitmap    *cBmp;
Boolean    err;

   /* Lock ComplexBitmap header, copy palette */
   cBmp = BTBitmapToolLockHeader(fh, bmpHandle, &mh);
   bPtr = (byte *)cBmp;
   if ( cBmp->CB_simple.B_type & BMT_PALETTE ) {
	   palPtr = bPtr + cBmp->CB_palette + 2;
	   memcpy(palette, palPtr, sizeof(PaletteEntry) * numEntries);
	   err = FALSE;
	   }
   else err = TRUE;

   VMUnlock(mh);
   return err;
   }


/*--------------------- BTSetBitmapPalette ---------------------
 *	Purpose:        Set the bitmap palette of a HugeBitmap
 *	Parameters:	fh:	Handle of the VM file
 *			bmpHandle: VM handle of the bitmap
 *			*palette:  Pointer to the buffer from which the palette
 *				   should be copied
 *			firstEntry: first entry to write (zero-based)
 *			numEntries: number of palette entries to write.
 *				If numEntries + firstEntry is too large, only the
 *				possible entries are written, the rest are ignored
 *	Return:		Error flag: FALSE == OK
 *				TRUE == error – bitmap has no palette
 *						– firstEntry is too large
 ---------------------------------------------------------------------------*/
extern Boolean BTLIB_EXPORT BTSetBitmapPalette(VMFileHandle fh, VMBlockHandle bmpHandle,
		PaletteEntry *palette, int firstEntry, int numEntries) {
byte 	*palPtr, *bPtr;
word 	*numPtr;
int numPalEntries;
MemHandle  mh;
CBitmap    *cBmp;
Boolean    err;

   /* Lock ComplexBitmap header, copy palette */

   cBmp = BTBitmapToolLockHeader(fh, bmpHandle, &mh);
   bPtr = (byte *)cBmp;
   err = TRUE;	// worst Case
   if ( cBmp->CB_simple.B_type & BMT_PALETTE ) {
	   palPtr = bPtr + cBmp->CB_palette + 2;
	   numPtr = (word*)(palPtr - 2);
	   numPalEntries = *numPtr;
	   if ( firstEntry < numPalEntries ) {	// otherwise initial value too large
		if ( firstEntry + numEntries > numPalEntries )
			// Final value too large -> limit
			numEntries = numPalEntries - firstEntry;

		// Now it's time to copy
		palPtr += sizeof(PaletteEntry) * firstEntry;
		memcpy(palPtr, palette, sizeof(PaletteEntry) * numEntries);
		err = FALSE;
		}
	   }

   VMDirty(mh);
   VMUnlock(mh);
   return err;
   }


@start PaletteResource, data;

@chunk PaletteEntry GEOSPalette[256] = {

  /* First 16 standard colors */
  0x00, 0x00, 0x00,  0x00, 0x00, 0xAA,  0x00, 0xAA, 0x00,  0x00, 0xAA, 0xAA,
  0xAA, 0x00, 0x00,  0xAA, 0x00, 0xAA,  0xAA, 0x55, 0x00,  0xAA, 0xAA, 0xAA,
  0x55, 0x55, 0x55,  0x55, 0x55, 0xFF,  0x55, 0xFF, 0x55,  0x55, 0xFF, 0xFF,
  0xFF, 0x55, 0x55,  0xFF, 0x55, 0xFF,  0xFF, 0xFF, 0x55,  0xFF, 0xFF, 0xFF,

  /* a 16-step gray bar */
  0x00, 0x00, 0x00,  0x11, 0x11, 0x11,  0x22, 0x22, 0x22,  0x33, 0x33, 0x33,
  0x44, 0x44, 0x44,  0x55, 0x55, 0x55,  0x66, 0x66, 0x66,  0x77, 0x77, 0x77,
  0x88, 0x88, 0x88,  0x99, 0x99, 0x99,  0xAA, 0xAA, 0xAA,  0xBB, 0xBB, 0xBB,
  0xCC, 0xCC, 0xCC,  0xDD, 0xDD, 0xDD,  0xEE, 0xEE, 0xEE,  0xFF, 0xFF, 0xFF,


  /* 8 unused Spots. */
  0x00, 0x00, 0x00,  0x00, 0x00, 0x00,  0x00, 0x00, 0x00,  0x00, 0x00, 0x00,
  0x00, 0x00, 0x00,  0x00, 0x00, 0x00,  0x00, 0x00, 0x00,  0x00, 0x00, 0x00,


  /* 6 x 6 x 6 RGB-cube. The steps are: 0, 51, 102, 153, 204, 255
	or as hex values: 0x33, 0x66, 0x99, 0xcc, 0xff */

  /* Indizes: C_R0_G0_B0 ... C_R0_G5_G5 */
	    0x00, 0x00, 0x00,  0x00, 0x00, 0x33,  0x00, 0x00, 0x66,
	    0x00, 0x00, 0x99,  0x00, 0x00, 0xcc,  0x00, 0x00, 0xff,
	    0x00, 0x33, 0x00,  0x00, 0x33, 0x33,  0x00, 0x33, 0x66,
	    0x00, 0x33, 0x99,  0x00, 0x33, 0xcc,  0x00, 0x33, 0xff,
	    0x00, 0x66, 0x00,  0x00, 0x66, 0x33,  0x00, 0x66, 0x66,
	    0x00, 0x66, 0x99,  0x00, 0x66, 0xcc,  0x00, 0x66, 0xff,
	    0x00, 0x99, 0x00,  0x00, 0x99, 0x33,  0x00, 0x99, 0x66,
	    0x00, 0x99, 0x99,  0x00, 0x99, 0xcc,  0x00, 0x99, 0xff,
	    0x00, 0xCC, 0x00,  0x00, 0xCC, 0x33,  0x00, 0xCC, 0x66,
	    0x00, 0xCC, 0x99,  0x00, 0xCC, 0xcc,  0x00, 0xCC, 0xff,
	    0x00, 0xFF, 0x00,  0x00, 0xFF, 0x33,  0x00, 0xFF, 0x66,
	    0x00, 0xFF, 0x99,  0x00, 0xFF, 0xcc,  0x00, 0xFF, 0xff,

  /* Indizes: C_R1_G0_B0 ... C_R1_G5_G5 */
	    0x33, 0x00, 0x00,  0x33, 0x00, 0x33,  0x33, 0x00, 0x66,
	    0x33, 0x00, 0x99,  0x33, 0x00, 0xcc,  0x33, 0x00, 0xff,
	    0x33, 0x33, 0x00,  0x33, 0x33, 0x33,  0x33, 0x33, 0x66,
	    0x33, 0x33, 0x99,  0x33, 0x33, 0xcc,  0x33, 0x33, 0xff,
	    0x33, 0x66, 0x00,  0x33, 0x66, 0x33,  0x33, 0x66, 0x66,
	    0x33, 0x66, 0x99,  0x33, 0x66, 0xcc,  0x33, 0x66, 0xff,
	    0x33, 0x99, 0x00,  0x33, 0x99, 0x33,  0x33, 0x99, 0x66,
	    0x33, 0x99, 0x99,  0x33, 0x99, 0xcc,  0x33, 0x99, 0xff,
	    0x33, 0xCC, 0x00,  0x33, 0xCC, 0x33,  0x33, 0xCC, 0x66,
	    0x33, 0xCC, 0x99,  0x33, 0xCC, 0xcc,  0x33, 0xCC, 0xff,
	    0x33, 0xFF, 0x00,  0x33, 0xFF, 0x33,  0x33, 0xFF, 0x66,
	    0x33, 0xFF, 0x99,  0x33, 0xFF, 0xcc,  0x33, 0xFF, 0xff,

  /* Indizes: C_R2_G0_B0 ... C_R2_G5_G5 */
	    0x66, 0x00, 0x00,  0x66, 0x00, 0x33,  0x66, 0x00, 0x66,
	    0x66, 0x00, 0x99,  0x66, 0x00, 0xcc,  0x66, 0x00, 0xff,
	    0x66, 0x33, 0x00,  0x66, 0x33, 0x33,  0x66, 0x33, 0x66,
	    0x66, 0x33, 0x99,  0x66, 0x33, 0xcc,  0x66, 0x33, 0xff,
	    0x66, 0x66, 0x00,  0x66, 0x66, 0x33,  0x66, 0x66, 0x66,
	    0x66, 0x66, 0x99,  0x66, 0x66, 0xcc,  0x66, 0x66, 0xff,
	    0x66, 0x99, 0x00,  0x66, 0x99, 0x33,  0x66, 0x99, 0x66,
	    0x66, 0x99, 0x99,  0x66, 0x99, 0xcc,  0x66, 0x99, 0xff,
	    0x66, 0xCC, 0x00,  0x66, 0xCC, 0x33,  0x66, 0xCC, 0x66,
	    0x66, 0xCC, 0x99,  0x66, 0xCC, 0xcc,  0x66, 0xCC, 0xff,
	    0x66, 0xFF, 0x00,  0x66, 0xFF, 0x33,  0x66, 0xFF, 0x66,
	    0x66, 0xFF, 0x99,  0x66, 0xFF, 0xcc,  0x66, 0xFF, 0xff,

  /* Indizes: C_R3_G0_B0 ... C_R3_G5_G5 */
	    0x99, 0x00, 0x00,  0x99, 0x00, 0x33,  0x99, 0x00, 0x66,
	    0x99, 0x00, 0x99,  0x99, 0x00, 0xcc,  0x99, 0x00, 0xff,
	    0x99, 0x33, 0x00,  0x99, 0x33, 0x33,  0x99, 0x33, 0x66,
	    0x99, 0x33, 0x99,  0x99, 0x33, 0xcc,  0x99, 0x33, 0xff,
	    0x99, 0x66, 0x00,  0x99, 0x66, 0x33,  0x99, 0x66, 0x66,
	    0x99, 0x66, 0x99,  0x99, 0x66, 0xcc,  0x99, 0x66, 0xff,
	    0x99, 0x99, 0x00,  0x99, 0x99, 0x33,  0x99, 0x99, 0x66,
	    0x99, 0x99, 0x99,  0x99, 0x99, 0xcc,  0x99, 0x99, 0xff,
	    0x99, 0xCC, 0x00,  0x99, 0xCC, 0x33,  0x99, 0xCC, 0x66,
	    0x99, 0xCC, 0x99,  0x99, 0xCC, 0xcc,  0x99, 0xCC, 0xff,
	    0x99, 0xFF, 0x00,  0x99, 0xFF, 0x33,  0x99, 0xFF, 0x66,
	    0x99, 0xFF, 0x99,  0x99, 0xFF, 0xcc,  0x99, 0xFF, 0xff,

  /* Indizes: C_R4_G0_B0 ... C_R4_G5_G5 */
	    0xCC, 0x00, 0x00,  0xCC, 0x00, 0x33,  0xCC, 0x00, 0x66,
	    0xCC, 0x00, 0x99,  0xCC, 0x00, 0xcc,  0xCC, 0x00, 0xff,
	    0xCC, 0x33, 0x00,  0xCC, 0x33, 0x33,  0xCC, 0x33, 0x66,
	    0xCC, 0x33, 0x99,  0xCC, 0x33, 0xcc,  0xCC, 0x33, 0xff,
	    0xCC, 0x66, 0x00,  0xCC, 0x66, 0x33,  0xCC, 0x66, 0x66,
	    0xCC, 0x66, 0x99,  0xCC, 0x66, 0xcc,  0xCC, 0x66, 0xff,
	    0xCC, 0x99, 0x00,  0xCC, 0x99, 0x33,  0xCC, 0x99, 0x66,
	    0xCC, 0x99, 0x99,  0xCC, 0x99, 0xcc,  0xCC, 0x99, 0xff,
	    0xCC, 0xCC, 0x00,  0xCC, 0xCC, 0x33,  0xCC, 0xCC, 0x66,
	    0xCC, 0xCC, 0x99,  0xCC, 0xCC, 0xcc,  0xCC, 0xCC, 0xff,
	    0xCC, 0xFF, 0x00,  0xCC, 0xFF, 0x33,  0xCC, 0xFF, 0x66,
	    0xCC, 0xFF, 0x99,  0xCC, 0xFF, 0xcc,  0xCC, 0xFF, 0xff,

  /* Indizes: C_R5_G0_B0 ... C_R5_G5_G5 */
	    0xFF, 0x00, 0x00,  0xFF, 0x00, 0x33,  0xFF, 0x00, 0x66,
	    0xFF, 0x00, 0x99,  0xFF, 0x00, 0xcc,  0xFF, 0x00, 0xff,
	    0xFF, 0x33, 0x00,  0xFF, 0x33, 0x33,  0xFF, 0x33, 0x66,
	    0xFF, 0x33, 0x99,  0xFF, 0x33, 0xcc,  0xFF, 0x33, 0xff,
	    0xFF, 0x66, 0x00,  0xFF, 0x66, 0x33,  0xFF, 0x66, 0x66,
	    0xFF, 0x66, 0x99,  0xFF, 0x66, 0xcc,  0xFF, 0x66, 0xff,
	    0xFF, 0x99, 0x00,  0xFF, 0x99, 0x33,  0xFF, 0x99, 0x66,
	    0xFF, 0x99, 0x99,  0xFF, 0x99, 0xcc,  0xFF, 0x99, 0xff,
	    0xFF, 0xCC, 0x00,  0xFF, 0xCC, 0x33,  0xFF, 0xCC, 0x66,
	    0xFF, 0xCC, 0x99,  0xFF, 0xCC, 0xcc,  0xFF, 0xCC, 0xff,
	    0xFF, 0xFF, 0x00,  0xFF, 0xFF, 0x33,  0xFF, 0xFF, 0x66,
	    0xFF, 0xFF, 0x99,  0xFF, 0xFF, 0xcc,  0xFF, 0xFF, 0xff

	    };

@end PaletteResource;



/*--------------------- BTLockGEOSStandardPalette ---------------------
 *  Purpose:	Tool to lock a chunk with the 256 color GEOS standard palette
 *  Parameters:
 *  Return:	Pointer to an array of 256 PaletteEntires
 ---------------------------------------------------------------------------*/
extern PaletteEntry* BTLIB_EXPORT BTLockGEOSStandardPalette(void) {
PaletteEntry* pal;
    MemLock ( OptrToHandle(@GEOSPalette) );
    pal = LMemDeref(@GEOSPalette);
    return pal;
}

/*--------------------- BTUnlockGEOSStandardPalette ---------------------
 *  Purpose:	Tool to unlock the chunk with the 256 color GEOS standard palette
 *		The chunk should have been locked with BTLockGEOSStandardPalette().
 *  Parameters:
 *  Return:GEOSStandardPalette
 ---------------------------------------------------------------------------*/
extern void BTLIB_EXPORT BTUnlockGEOSStandardPalette(void) {
    MemUnlock ( OptrToHandle(@GEOSPalette) );
}

/*--------------------- BTApproxRGBPaletteLinear ---------------------
 *  Purpose:	Find the "nearest" palette (index) color to a given RGB color
 *  Context:
 *  Strategy:	The palette cannot be assumed as sorted in any way. So we
 *		use a runtime optimized linear search.
 *  Parameters:	palette:  pointer to color palette
 *		color:	  RGB color to search for
 *		palentries: number of color entries to compare
 *  Return:	index found
 ---------------------------------------------------------------------------*/
#define diff(a, b) ( (a>b) ? (a-b) : (b-a) )
	/*
	 * diff2() is much more faster than diff() (Byte: 2,5x, Integer 1,5x)
	 */
#define diff2(d, a, b ) \
	d = (a) - (b); \
	if ( d < 0 ) d = -d;

#define diff2Plus(d, a, b ) \
	if ( (a) > (b)) { d += (a) - (b); } else { d += (b) - (a); }


int BTApproxRGBPaletteLinear(PaletteEntry *palette, PaletteEntry color, int palEntries) {
int rt, gn, bl;
int n, idx, d, dmin;

    rt = color.rt;
    gn = color.gn;
    bl = color.bl;

    idx = 0;
    dmin = 0x1000;

    /*
     * As a criterion for how “close” we are to the desired color, we take the sum
     * of the differences in the red, green, and blue values. The usual approach in
     * such cases, which is to use the sum of the squares of the differences, is not
     * only significantly slower (since we have to calculate in dword), but also
     * not noticeably better.
     */
    for ( n = 0; n < palEntries; n++ ) {
    	diff2(d, rt, palette->rt);		// d = | a-b |
    	if (d > dmin) { palette++; continue; }

    	diff2Plus(d, gn, palette->gn);		// d += | a-b |
    	if (d > dmin) { palette++; continue; }

    	diff2Plus(d, bl, palette->bl);
    	if (d < dmin) {
    	    idx = n;
    	    if (d==0) break;
    	    dmin = d;
    	    }
    	palette++;
    	}

    return idx;

}


/*
 ***************************************************************************
 *		Debugg helper routines
 ***************************************************************************
 */

static optr debugText = 0;

/*--------------------- BTSetDebugText ---------------------
 *	Purpose:	Enable debugging helper routines
 *			This routine can be used while debugging the bmptools library
 *	Parameters:	text object to print debug messages
 *	Return:
 ---------------------------------------------------------------------------*/
extern void BTLIB_EXPORT BTSetDebugText(optr textObj) {
	debugText = textObj;
EC(DebugInfo("\rEC-Version: bmptools"));
NEC(DebugInfo("\rbmptools (NC-Version)"));
}

void DebugInfo(char* text) {
    if ( debugText == 0 ) return;
    @call debugText::MSG_VIS_TEXT_APPEND_PTR(text, 0);
}

void DebugInfo1(char *text, word val) {
char buffer[100];
    if ( debugText == 0 ) return;
    sprintf(buffer, text, val);
    @call debugText::MSG_VIS_TEXT_APPEND_PTR(buffer, 0);
}

void DebugInfo2(char *text, word val, word val2) {
char buffer[100];
    if ( debugText == 0 ) return;
    sprintf(buffer, text, val, val2);
    @call debugText::MSG_VIS_TEXT_APPEND_PTR(buffer, 0);
}


void DebugInfo1DW(char *text, dword val) {
char buffer[100];
    if ( debugText == 0 ) return;
    sprintf(buffer, text, val);
    @call debugText::MSG_VIS_TEXT_APPEND_PTR(buffer, 0);
}

void DebugInfo2DW(char *text, dword val, dword val2) {
char buffer[100];
    if ( debugText == 0 ) return;
    sprintf(buffer, text, val, val2);
    @call debugText::MSG_VIS_TEXT_APPEND_PTR(buffer, 0);
}



void DebugClearText(void) {
    if ( debugText == 0 ) return;
    @call debugText::MSG_VIS_TEXT_DELETE_ALL();
}


void WWFToASCII(char *buffer, WWFixedAsDWord wwf, Boolean addHex) {
char *p;
word	i, f;
WWFixedAsDWord  sik;

     p = buffer;
     *p =0;
     sik = wwf;
     i = (wwf>>16) & 0xFFFF;
     f = wwf & 0xFFFF;



     // Negative Zahl?
     if ( i & 0x8000 ) {
     	wwf = 0-wwf;
	i = (wwf>>16) & 0xFFFF;
	f = wwf & 0xFFFF;
     	*p = '-';
     	p++;
     	}


     // Ganzzahligen Teil
     UtilHex32ToAscii(p, i, UHTAF_NULL_TERMINATE);
     strcat(p, ".");
     p = strchr(p, 0);

     // Gebrochener Teil: Q'Dirty - 3 Nachkommastellen ohne Runden
     i = 0;
     if (f & 0x8000) i  = 5000;	/* 1/2	*/
     if (f & 0x4000) i += 2500;	/* 1/4	*/
     if (f & 0x2000) i += 1250;	/* 1/8	*/
     if (f & 0x1000) i +=  625;	/* 1/16	*/
     if (f & 0x0800) i +=  313;	/* 1/32	*/
     if (f & 0x0400) i +=  156;	/* 1/64	*/
     if (f & 0x0200) i +=   78;	/* 1/128	*/
     if (f & 0x0100) i +=   39;	/* 1/256	*/
     if (f & 0x0080) i +=   20;	/* 1/512	*/
     if (f & 0x0040) i +=   10;	/* 1/1024	*/
     if (f & 0x0020) i +=    5;	/* 1/2048	*/
     if (f & 0x0010) i +=    2;	/* 1/4096	*/
     if (f & 0x0008) i +=    1;

     i = i/10;
     sprintf(p, "%03u", i);

     if ( addHex) {
     	i = (sik>>16) & 0xFFFF;
     	f = sik & 0xFFFF;
     	p = strchr(p, 0);
     	sprintf(p, " (%04X:%04X)", i,f);
	}

}


void DebugWWF(char *txt, WWFixedAsDWord wwf) {
char buf[30];

    if ( debugText == 0 ) return;
    DebugInfo(txt);
    WWFToASCII(buf, wwf, TRUE);
    DebugInfo(buf);
}

/*---------------------  ---------------------
 *	Purpose:
 *	Parameters:
 *	Return:
 ---------------------------------------------------------------------------*/

/* -------------------------- end of file ------------------------- */
