/***********************************************************************
 *
 *	Code-File for Bitmap Tool Library
 *
 *      Made by RABE-Soft for free PC/GEOS project 10/2025
 *
 *	File: 	transform.goc
 *
 *	Simple tranfomations such as flipping and rotating
 *
 ***********************************************************************/

@include <stdapp.goh>
@include <stdlib.h>

#include <string.h>

@include "bmptools.goh"
@include "Code/rtools.goh"



/*
 * Local header
 */
void LocalSetMaskMono(byte *dataPtr, int width, int index);
void LocalSetMask4Bit(byte *dataPtr,int width, int index);
void LocalSetMask8Bit(byte *dataPtr,int width, int index);
void LocalSetMask24Bit(byte *dataPtr, int width, int red1, int red2, int green1, int green2, int blue1, int blue2);

  /* -----------------------------------------------------------
   * SetColorLimits - a macro to set up color limits for LocalSetMask24Bit
   *	color1 is the lower limit - must be defined as int
   *	color2 is the upper limit - must be defined as int
   * -----------------------------------------------------------*/
#define SetColorLimits(color1, color2, color, variance) \
	color1 = color - variance; 			\
	if (color1 < 0) color1 = 0; 			\
	color2 = color + variance; 			\
	if (color2 < 255) color2 = 255;

/*
 ***************************************************************************
 *	Manipulate transparency mask
 ***************************************************************************
 */

/*--------------------- BTApplyTransparencyColor ---------------------
 *	Purpose:	Set a all pixels that have a specified color to be transparent.
 *			If no transparency mask exists yet, it will be created.
 *
 *	Parameters:	srcFile, bmpBlock:	handle of the bitmap
 *			destFile: 	file for the new bitmap
 *				- You may pass zero for destFile. In this case the bitmap
 *				  is not copied but modified instead.
 *				  Note! This will fail if:
 *				    - the bitmap does not yet have a transparency mask
 *				    - the bitmap is compacted
 *			redOrIndex: red color value
 *				- if the bitmap not a 24 bit bitmap, redOrIndex is the
 *				  color index to be set transparent.
 *				  For monochrome bitmaps this may be 0 or 1.
 *				  NOTE: The parameters green, blue and variance are
 *				  ignored in these cases
 *			green:	green color value
 *			blue:	blue color value
 *			variance: Permitted difference between the real color value and
 *				the passed color value for red, green and blue.
 *			progressText: optr of an text object to show progress
 *				if given, routine append dots  ('.') for every 16th line
 *				pass zero for no progress report
 *
 *	Example for variance:
 *		Assuming you have passed the values red = 200, green = 150, blue = 0 and
 *		a variance of 10. Then a pixel that fulfills the following conditions is
 *		set to transparent: red 190...210 AND green 140..160 AND blue 0...10.
 *
 *	Return:		VMBlockHandle of the new bitmap
 *			Null handle on error  (e.g. passed zero for destFile and souce is compacted)
 ---------------------------------------------------------------------------*/
extern VMBlockHandle EXPORT BTApplyTransparencyColor(VMFileHandle srcFile, VMBlockHandle bmpBlock, VMFileHandle destFile,
			int redOrIndex, int green, int blue, int variance,
			optr progressText) {

VMBlockHandle	workBmp;
VMFileHandle	workFile;
int format, width, height, compact;
int n;
int red1, red2, green1, green2, blue1, blue2;
BitmapAccessRecord bar;
byte *dataPtr;

    /*
     * Get information about the source bitmap.
     */
    format = BTGetMoreBitmapInfos(srcFile, bmpBlock, &width, &height, &compact);

    
    /*
     * Find out or create the bitmap to work with.
     * If destfile==zero has been passed, work with the original bitmap (if posible)
     * Otherwise, create a copy that has a transparency mask
     */
    if ( !destFile ) {
        /*
         * To work with the original bitmap, it must be have a mask
         * and it must not be compressed.
         */
    	if ( compact ) return 0;
    	if ( (format & BMT_MASK) == 0 ) return 0;
    	workFile = srcFile;
    	workBmp = bmpBlock;
    	
    } else {
    
    	/*
    	 * We need a masked bitmap to work with. 
    	 * If the original is already masked, create an (uncompacted) copy.
    	 * The copy will reside in the destFile.
    	 */
    	workFile = destFile;
    	
    	if (format & BMT_MASK) {
    	    if ( compact ) workBmp = GrUncompactBitmap(srcFile, bmpBlock, workFile);
    	    	else workBmp = BTCopyBitmap(srcFile, workFile, bmpBlock);
    	    	
    	    } else {
    	    	/* 
    	    	 * the original bitmap has no mask yet. Let's do another routine
    	    	 * stupid "copy-and-create-a-mask" job.
    	    	 */
    	    	 workBmp = BTBitmapGetMaskedCopy(srcFile, workFile, bmpBlock, 0);
    	    }
    }    

    /*
     * Now, we can process the bitmap. We can be sure, that the bitmap is uncompaced and has a mask.
     * If the bitmap is a 24 bit bitmap, we have to set up the color value limits fist.
     */
    if ( (format & BMT_FORMAT) == BMF_24BIT ) {
    	/* We use a macro ... see above */
    	SetColorLimits(red1, red2, redOrIndex, variance);
    	SetColorLimits(green1, green2, green, variance);
    	SetColorLimits(blue1, blue2, blue, variance);
    }

    dataPtr = BTBitmapLock(workFile, workBmp, &bar, 0);
    for ( n = 0; n < height; n++ ) {

	if ( progressText) {
	    if ( (n & 0x0F) == 0 ) @call progressText::MSG_VIS_TEXT_APPEND_PTR(".", 0);
	}

    	switch ( format & BMT_FORMAT ) {

    	case BMF_MONO:
    	    LocalSetMaskMono(dataPtr, width, redOrIndex);
    	    break;

    	case BMF_4BIT:
    	    LocalSetMask4Bit(dataPtr, width, redOrIndex);
	    break;

    	case BMF_8BIT:
	    LocalSetMask8Bit(dataPtr, width, redOrIndex);
	    break;

    	case BMF_24BIT:
	    LocalSetMask24Bit(dataPtr, width, red1, red2, green1, green2, blue1, blue2);
	    break;

	}
	dataPtr = BTBitmapNext(&bar, TRUE);
    }
    BTBitmapUnlock(&bar, TRUE);


    return workBmp;
}

/*--------------------- BTBitmapGetMaskedCopy ---------------------
 *	Purpose:	Copies a bitmap and ensures that the copy has a transparency mask 
 *			Also ensure that the copy is uncompressed
 *
 *	Parameters:	srcFile, bmpBlock:	handle of the bitmap
 *			destFile: 	file for the new bitmap
 *			progressText: optr of an text object to show progress
 *				if given, routine append dots  ('.') for every 16th line
 *				pass zero for no progress report
 *
 * 	Strategy:
 *		- if the bitmap has already a transparency mask, make a simple copy
 *		- if not:
 *		  * fetch the palette, if any
 *		  * create a new bitmap of same size and color depth
 *		  * copy data over
 *	Return:		VMBlockHandle of the new bitmap
 *			Null handle on error
 ---------------------------------------------------------------------------*/
extern VMBlockHandle EXPORT BTBitmapGetMaskedCopy(VMFileHandle srcFile, VMBlockHandle bmpBlock, VMFileHandle destFile,
			optr progressText) {
			
int format, width, height, compact;
int maskLen, dataSize;
void *maskPtr, *srcPtr, *destPtr;
VMBlockHandle newBmp;
byte *palPtr;

    /*
     * Get information about the source bitmap.
     */
    format = BTGetMoreBitmapInfos(srcFile, bmpBlock, &width, &height, &compact);
    
    /*
     * See if a mask is already present. If yes, make a (uncompressed) copy
     */
    if (format & BMT_MASK) {
	if ( compact ) newBmp = GrUncompactBitmap(srcFile, bmpBlock, destFile);
    	    	else newBmp = BTCopyBitmap(srcFile, destFile, bmpBlock);
    	return newBmp;
    }

    /*
     * See if the bitmap is compacted. If yes, we need an uncompacted copy first.
     * Ths copy will be the source to be copied, but it resides in the destFile.
     * Therefore we have to switch our "sourceFile" to the destFile in this case.
     */
    if ( compact) {
    	bmpBlock = GrUncompactBitmap(srcFile, bmpBlock, destFile);
    	srcFile = destFile;
    }
    
    
    /* 
     * Create the new, masked bitmap 
     * If present: retrieve and set the palette 
     */
    if ( format & BMT_PALETTE )	{
    	int numColors;
    	switch ( format & BMT_FORMAT ) {
    		case BMF_MONO: numColors = 2; break;
    		case BMF_4BIT: numColors = 16; break;
    		case BMF_8BIT: numColors = 256; break;
    		default: numColors = 0;
    		}
    	palPtr = malloc( sizeof(PaletteEntry) * 256 );
    	BTGetBitmapPalette(srcFile, bmpBlock, (PaletteEntry *)palPtr, numColors);
    	}
      else palPtr = 0;
    
    newBmp = BTCreateOffscreenBitmap(destFile,
    			format | BMT_MASK, width, height, (PaletteEntry *)palPtr);
    if ( palPtr )  free(palPtr);

    /*
     * Finally we can copy the bitmap data to the new bitmap. Don't forget to set the
     * mask area to "not transparent" and to calculate the pixel buffer size first.
     */ 	
    switch ( format & BMT_FORMAT ) {
	case BMF_MONO: dataSize = (width+7)/8; break;
	case BMF_4BIT: dataSize = (width+1)/2; break;
	case BMF_8BIT: dataSize = width; break;
	case BMF_24BIT: dataSize = 3*width; break;
	}
    maskLen = (width+7)/8;
    
    
    
    /*
     * Destroy the uncompaced copy, if any.
     */
    if ( compact ) {
    	HugeArrayDestroy(srcFile, bmpBlock);
    }
     

srcFile =  srcFile;
bmpBlock =  bmpBlock;
destFile = destFile;
progressText = progressText;
return 0;
}



/*--------------------- BTExtractTransparencyMask ---------------------
 *	Purpose:	Copies the transparency mask of a bitmap into a monochrome bitmap.
 *			Transparent pixels will be white, not transparent pixels will be black.
 *			If no transparency mask exists yet, the monochrome bitmap will be completely black.
 *
 *	Parameters:	srcFile, bmpBlock:	handle of the bitmap
 *			destFile: 	file for the new (monochrome) bitmap
 *			progressText: optr of an text object to show progress
 *				if given, routine append dots  ('.') for every 16th line
 *				pass zero for no progress report
 *
 *	Return:		VMBlockHandle of the new bitmap
 *			Null handle on error (e.g. passed zero for dertFile and souce is compacted)
 ---------------------------------------------------------------------------*/
extern VMBlockHandle EXPORT BTExtractTransparencyMask(VMFileHandle srcFile, VMBlockHandle bmpBlock, VMFileHandle destFile,
			optr progressText) {
VMBlockHandle	newBmp;
int format, width, height, compact;
int maskWidth, n;
byte *monoData, *srcData;
BitmapAccessRecord	srcBar, monoBar;

    /*
     * Get information about the source bitmap.
     * Create a monochrome bitmap of the same size.
     */
    format = BTGetMoreBitmapInfos(srcFile, bmpBlock, &width, &height, &compact);
    newBmp = BTCreateOffscreenBitmap(destFile, BMF_MONO, width, height, NULL);


    /*
     * If the source bitmap has no mask, fill the new bitmap black and we are done.
     */
    maskWidth = (width+7)/8;
    if ( (format & BMT_MASK) == 0 ) {
    	monoData = BTBitmapLock(destFile, newBmp, &monoBar, 0);
    	for ( n = 0; n < height; n++) {
    	    memset(monoData, 0xFF, maskWidth);
    	    monoData = BTBitmapNext(&monoBar, TRUE);
    	}
    	BTBitmapUnlock(&monoBar, TRUE);
    	return newBmp;
    }


     /*
      * If the bitmap is compacted, uncompact it first
      * The uncomapcted bitmap will be stored in destFile
      * --> "souceFile" must be switched to this file
      */
    if ( compact ) {
     	bmpBlock = GrUncompactBitmap(srcFile, bmpBlock, destFile);
     	srcFile = destFile;
     }


    /*
     * Now, we can copy the mask data to the new bitmap
     */
    monoData = BTBitmapLock(destFile, newBmp, &monoBar, 0);
    srcData = BTBitmapLock(srcFile, bmpBlock, &srcBar, 0);
    for (n = 0; n < height; n++ ) {

	if ( progressText) {
	    if ( (n & 0x0F) == 0 ) @call progressText::MSG_VIS_TEXT_APPEND_PTR(".", 0);
	}

    	memcpy(monoData, srcData, maskWidth);
    	monoData = BTBitmapNext(&monoBar, TRUE);
    	srcData = BTBitmapNext(&srcBar, TRUE);
    }
    BTBitmapUnlock(&monoBar, TRUE);
    BTBitmapUnlock(&srcBar, TRUE);

    /*
     * free uncompacted copy, if any
     */
    if ( compact ) {
     	HugeArrayDestroy(srcFile, bmpBlock);
     }

    return newBmp;
}

/*--------------------- BTApplyTransparencyMask ---------------------
 *	Purpose:	Replaces the transparency mask of a bitmap. The new mask is taken from a monochrome
 *			bitmap.
 *			If no transparency mask exists yet, it will be created.
 *
 *	Parameters:	srcFile, bmpBlock:	handle of the bitmap
 *			destFile: 	file for the new bitmap
 *				- Pass zero for destFile so that the bitmap is not copied
 *				  but modified instead.
 *				  This will fail if the bitmap does not yet have a transparency
 *				  mask.
 *			maskFile, maskBitmap: handle of a monochrome bitmap that holds the new mask
 *				- if the bitmap is not monochrome, the result will be unpredictable
 *				- if the bitmap also has a mask, picture bits and mask bits will be
 *				  combinded with AND, just as we draw the bitmap.
 *			progressText: optr of an text object to show progress
 *				if given, routine append dots  ('.') for every 16th line
 *				pass zero for no progress report
 *
 *	Return:		VMBlockHandle of the new bitmap
 *			Null handle on error
 ---------------------------------------------------------------------------*/
extern VMBlockHandle EXPORT BTApplyTransparencyMask(VMFileHandle srcFile, VMBlockHandle bmpBlock, VMFileHandle destFile,
			VMFileHandle maskFile, VMBlockHandle maskBitmap,
			optr progressText) {
srcFile =  srcFile;
bmpBlock =  bmpBlock;
destFile = destFile;
maskFile =  maskFile;
maskBitmap =  maskBitmap;
progressText = progressText;
return 0;
}

/*--------------------- LocalSetMaskMono ---------------------
 * Purpose:
 * Parameters:
 * Return:
 ---------------------------------------------------------------------------*/
void LocalSetMaskMono(byte *dataPtr, int width, int index) {
*dataPtr = width = index;
}

/*--------------------- LocalSetMask4Bit ---------------------
 * Purpose:
 * Parameters:
 * Return:
 ---------------------------------------------------------------------------*/
void LocalSetMask4Bit(byte *dataPtr,int width, int index) {
*dataPtr = width = index;
}

/*--------------------- LocalSetMask8Bit ---------------------
 * Purpose:
 * Parameters:
 * Return:
 ---------------------------------------------------------------------------*/
void LocalSetMask8Bit(byte *dataPtr,int width, int index) {
*dataPtr = width = index;
}

/*--------------------- LocalSetMask24Bit ---------------------
 * Purpose:
 * Parameters:
 * Return:
 ---------------------------------------------------------------------------*/
void LocalSetMask24Bit(byte *dataPtr, int width, int red1, int red2, int green1, int green2, int blue1, int blue2) {
*dataPtr = width = red1 = red2 = green1 = green2 = blue1 = blue2;
}

/*---------------------  ---------------------
 * Purpose:
 * Parameters:
 * Return:
 ---------------------------------------------------------------------------*/
