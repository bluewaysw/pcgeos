/***********************************************************************
 *
 *	Code-File for Bitmap Tool Library
 *
 *      Made by RABE-Soft for free PC/GEOS project 10/2025
 *
 *	File: 	transform.goc
 *
 *	Simple tranfomations such as flipping and rotating
 *
 ***********************************************************************/

@include <stdapp.goh>
@include <stdlib.h>

#include <string.h>

@include "bmptools.goh"
@include "Code/rtools.goh"



/*
 * Local header
 */
void LocalApplyTransparencyColorMono(byte *dataPtr, int width, int index);
void LocalApplyTransparencyColor4Bit(byte *dataPtr,int width, int index);
void LocalApplyTransparencyColor8Bit(byte *dataPtr,int width, int index);
void LocalApplyTransparencyColor24Bit(byte *dataPtr, int width, int red1, int red2, int green1, int green2, int blue1, int blue2);

void LocalSetHiddenColorMono(byte *maskPtr, byte *dataPtr, int width, int index);
void LocalSetHiddenColor4Bit(byte *maskPtr, byte *dataPtr,int width, int index);
void LocalSetHiddenColor8Bit(byte *maskPtr, byte *dataPtr,int width, int index);
void LocalSetHiddenColor24Bit(byte *maskPtr, byte *dataPtr, int width, PaletteEntry color);

  /* -----------------------------------------------------------
   * SetColorLimits - a macro to set up color limits for LocalApplyTransparencyColor24Bit
   *	color1 is the lower limit - must be defined as int
   *	color2 is the upper limit - must be defined as int
   * -----------------------------------------------------------*/
#define SetColorLimits(color1, color2, color, variance) \
	color1 = color - variance; 			\
	if (color1 < 0) color1 = 0; 			\
	color2 = color + variance; 			\
	if (color2 > 255) color2 = 255;

/*
 ***************************************************************************
 *	Manipulate transparency mask
 ***************************************************************************
 */

/*--------------------- BTApplyTransparencyColor ---------------------
 * Purpose:	Set a all pixels that have a specified color to be transparent.
 *		Pixels that are already transparent remain transparent.
 *		If no transparency mask exists yet, it will be created.
 *
 * Parameters:	srcFile, bmpBlock:	handle of the bitmap
 *		destFile: file for the new bitmap
 *			  Pass zero to modify the passed bitmap instead of copying it.
 *			  Note! This will fail (return zero) if:
 *			    - the bitmap does not yet have a transparency mask
 *			    - the bitmap is compacted
 *		progressText: optr of an text object to show progress
 *			  if given, routine append dots  ('.') for every 16th line
 *			  pass zero for no progress report
 *			
 *	If a true-color bitmap has been passed	
 *		redOrIndex: red color value for transparency color
 *		green:	    green color value for transparency color
 *		blue:	    blue color value for transparency color
 *		variance:   Permitted difference between the real color value and
 *			    the passed color value for red, green and blue.
 *
 *	If a 8-bit, 4-bit or monochrome bitmap has been passed	
 *		redOrIndex: index of the color to make transparent
 *			    for monochrome mitmaps this may be 0 or 1
 *		green, blue and variance will be ignored
 *			
 * Example for variance:
 *		Assuming you have passed the values red = 200, green = 150, blue = 0 and
 *		a variance of 10. Then a pixel that fulfills the following conditions is
 *		set to transparent: red 190...210 AND green 140..160 AND blue 0...10.
 *
 * Return:	VMBlockHandle of the new bitmap
 *		Null handle on error  (e.g. passed zero for destFile and source is compacted)
 ---------------------------------------------------------------------------*/
extern VMBlockHandle EXPORT BTApplyTransparencyColor(VMFileHandle srcFile, VMBlockHandle bmpBlock, VMFileHandle destFile,
			int redOrIndex, int green, int blue, int variance,
			optr progressText) {

VMBlockHandle	workBmp;
VMFileHandle	workFile;
int format, width, height, compact;
int n;
int red1, red2, green1, green2, blue1, blue2;
BitmapAccessRecord bar;
byte *dataPtr;


    /*
     * Check parameters
     */
    if ( (srcFile==0) || (bmpBlock==0) ) return 0;

    /*
     * Get information about the source bitmap.
     */
    format = BTGetMoreBitmapInfos(srcFile, bmpBlock, &width, &height, &compact);


    /*
     * Find out or create the bitmap to work with.
     * If destfile==zero has been passed, work with the original bitmap (if posible)
     * Otherwise, create a copy that has a transparency mask
     */
    if ( !destFile ) {
        /*
         * To work with the original bitmap, it must be have a mask
         * and it must not be compressed.
         */
    	if ( compact ) { /*DebugInfo("Transparency color: bmp is compacted"); */return 0; }
    	if ( (format & BMT_MASK) == 0 ) {/* DebugInfo("Transparency color: bmp is unmasked"); */return 0; }
    	workFile = srcFile;
    	workBmp = bmpBlock;

    } else {

    	/*
    	 * We need a masked bitmap to work with.
    	 *
    	 * BTCopyToBitmapWithMask() handles all cases:
    	 *	- original is compressed (or not)
    	 *	- original is already masked (or not)
    	 * The copy will reside in the destFile.
    	 */
    	workFile = destFile;
    	workBmp = BTCopyToBitmapWithMask(srcFile, bmpBlock, workFile, 0);

    }

    /*
     * Now, we can process the bitmap. We can be sure, that the bitmap is uncompaced and has a mask.
     * If the bitmap is a 24 bit bitmap, we have to set up the color value limits fist.
     */
    if ( (format & BMT_FORMAT) == BMF_24BIT ) {
    	/* We use a macro ... see above */
    	SetColorLimits(red1, red2, redOrIndex, variance);
    	SetColorLimits(green1, green2, green, variance);
    	SetColorLimits(blue1, blue2, blue, variance);
    }

    dataPtr = BTBitmapLock(workFile, workBmp, &bar, 0);
    for ( n = 0; n < height; n++ ) {

	if ( progressText) {
	    if ( (n & 0x0F) == 0 ) @call progressText::MSG_VIS_TEXT_APPEND_PTR(".", 0);
	}

    	switch ( format & BMT_FORMAT ) {

    	case BMF_MONO:
    	    LocalApplyTransparencyColorMono(dataPtr, width, redOrIndex);
    	    break;

    	case BMF_4BIT:
    	    LocalApplyTransparencyColor4Bit(dataPtr, width, redOrIndex);
	    break;

    	case BMF_8BIT:
	    LocalApplyTransparencyColor8Bit(dataPtr, width, redOrIndex);
	    break;

    	case BMF_24BIT:
	    LocalApplyTransparencyColor24Bit(dataPtr, width, red1, red2, green1, green2, blue1, blue2);
	    break;

	}
	dataPtr = BTBitmapNext(&bar, TRUE);

    }

    BTBitmapUnlock(&bar, TRUE);

    return workBmp;
}

/*--------------------- BTCopyToBitmapWithMask ---------------------
 *	Purpose:	Copies a bitmap and ensures that the copy has a transparency mask.
 *			Also ensure that the copy is uncompressed.
 *
 *	Parameters:	srcFile, bmpBlock: handles of the bitmap
 *			destFile: 	file for the new bitmap
 *			progressText: optr of an text object to show progress
 *				if given, routine append dots  ('.') for every 16th line
 *				pass zero for no progress report
 *
 * 	Strategy:
 *		- if the bitmap has already a transparency mask, make a simple copy
 *		- if not:
 *		  * fetch the palette, if any
 *		  * create a new bitmap of same size and color depth
 *		  * copy data over
 *	Return:		VMBlockHandle of the new bitmap
 *			Null handle on error
 ---------------------------------------------------------------------------*/
extern VMBlockHandle EXPORT BTCopyToBitmapWithMask(VMFileHandle srcFile, VMBlockHandle bmpBlock, VMFileHandle destFile,
			optr progressText) {

int format, width, height, compact;
int y, maskLen, dataSize;
byte *maskPtr, *srcPtr, *destPtr;
VMBlockHandle newBmp;
byte *palPtr;
BitmapAccessRecord	srcBar, destBar;

    /*
     * Check parameters
     */
    if ( (srcFile==0) || (bmpBlock==0)|| (destFile==0) ) return 0;
    
    /*
     * Get information about the source bitmap.
     */
    format = BTGetMoreBitmapInfos(srcFile, bmpBlock, &width, &height, &compact);
    
    /*
     * See if a mask is already present. If yes, make a (uncompressed) copy
     */
    if (format & BMT_MASK) {
	if ( compact ) newBmp = GrUncompactBitmap(srcFile, bmpBlock, destFile);
    	    	else newBmp = BTCopyBitmap(srcFile, destFile, bmpBlock);
    	return newBmp;
    }

    /*
     * See if the bitmap is compacted. If yes, we need an uncompacted copy first.
     * This copy will be the source to be copied, but it resides in the destFile.
     * Therefore we have to switch our "sourceFile" to the destFile in this case.
     */
    if ( compact) {
    	bmpBlock = GrUncompactBitmap(srcFile, bmpBlock, destFile);
    	srcFile = destFile;
    }


    /*
     * Create the new, masked bitmap
     * If present: retrieve and set the palette
     */
    if ( format & BMT_PALETTE )	{
    	int numColors;
    	switch ( format & BMT_FORMAT ) {
    		case BMF_MONO: numColors = 2; break;
    		case BMF_4BIT: numColors = 16; break;
    		case BMF_8BIT: numColors = 256; break;
    		default: numColors = 0;
    		}
    	palPtr = malloc( sizeof(PaletteEntry) * 256 );
    	BTGetBitmapPalette(srcFile, bmpBlock, (PaletteEntry *)palPtr, numColors);
    	}
      else palPtr = 0;

    newBmp = BTCreateOffscreenBitmap(destFile,
    			format | BMT_MASK, width, height, (PaletteEntry *)palPtr);
    if ( palPtr )  free(palPtr);


    /*
     * Next step is to calculate the sizes of the mask area and of the pixel data.
     */
    maskLen = (width+7)/8;
    switch ( format & BMT_FORMAT ) {
	case BMF_MONO: dataSize = (width+7)/8; break;
	case BMF_4BIT: dataSize = (width+1)/2; break;
	case BMF_8BIT: dataSize = width; break;
	case BMF_24BIT: dataSize = 3*width; break;
	}

    /*
     * Finally we can copy the bitmap data to the new bitmap. Don't forget to set the
     * mask area to "not transparent".
     */
    srcPtr = BTBitmapLock(srcFile, bmpBlock, &srcBar, 0);
    maskPtr = BTBitmapLock(destFile, newBmp, &destBar, 0);
    destPtr = maskPtr + maskLen;

    for ( y = 0; y < height; y++ ) {

	if ( progressText) {
	    if ( (y & 0x0F) == 0 ) @call progressText::MSG_VIS_TEXT_APPEND_PTR(".", 0);
	}

	memset(maskPtr, 0xFF, maskLen);
	memcpy(destPtr, srcPtr, dataSize);

	srcPtr = BTBitmapNext(&srcBar, FALSE);
	maskPtr = BTBitmapNext(&destBar, TRUE);
	destPtr = maskPtr + maskLen;

    }

    BTBitmapUnlock(&srcBar, FALSE);
    BTBitmapUnlock(&destBar, TRUE);

    /*
     * Destroy the uncompaced copy, if any.
     */
    if ( compact ) {
    	HugeArrayDestroy(srcFile, bmpBlock);
    }


    return newBmp;
}



/*--------------------- BTExtractTransparencyMask ---------------------
 *	Purpose:	Copies the transparency mask of a bitmap into a monochrome bitmap.
 *			Transparent pixels will be white, not transparent pixels will be black.
 *			If no transparency mask exists yet, the monochrome bitmap will be completely black.
 *
 *	Parameters:	srcFile, bmpBlock: handles of the bitmap
 *			destFile: 	file for the new (monochrome) bitmap
 *			progressText: optr of an text object to show progress
 *				if given, routine append dots  ('.') for every 16th line
 *				pass zero for no progress report
 *
 *	Return:		VMBlockHandle of the new bitmap
 *			Null handle on error (e.g. passed zero for dertFile and souce is compacted)
 ---------------------------------------------------------------------------*/
extern VMBlockHandle EXPORT BTExtractTransparencyMask(VMFileHandle srcFile, VMBlockHandle bmpBlock, VMFileHandle destFile,
			optr progressText) {
VMBlockHandle	newBmp;
int format, width, height, compact;
int maskWidth, n;
byte *monoData, *srcData;
BitmapAccessRecord	srcBar, monoBar;

    /*
     * Check parameters
     */
    if ( (srcFile==0) || (bmpBlock==0)|| (destFile==0) ) return 0;
    /*
     * Get information about the source bitmap.
     * Create a monochrome bitmap of the same size.
     */
    format = BTGetMoreBitmapInfos(srcFile, bmpBlock, &width, &height, &compact);
    newBmp = BTCreateOffscreenBitmap(destFile, BMF_MONO, width, height, NULL);


    /*
     * If the source bitmap has no mask, fill the new bitmap with black and we are done.
     */
    maskWidth = (width+7)/8;
    if ( (format & BMT_MASK) == 0 ) {
    	monoData = BTBitmapLock(destFile, newBmp, &monoBar, 0);
    	for ( n = 0; n < height; n++) {
    	    memset(monoData, 0xFF, maskWidth);
    	    monoData = BTBitmapNext(&monoBar, TRUE);
    	}
    	BTBitmapUnlock(&monoBar, TRUE);
    	return newBmp;
    }


     /*
      * If the bitmap is compacted, uncompact it first
      * The uncomapcted bitmap will be stored in destFile
      * --> "souceFile" must be switched to this file
      */
    if ( compact ) {
     	bmpBlock = GrUncompactBitmap(srcFile, bmpBlock, destFile);
     	srcFile = destFile;
     }


    /*
     * Now, we can copy the mask data to the new bitmap
     */
    monoData = BTBitmapLock(destFile, newBmp, &monoBar, 0);
    srcData = BTBitmapLock(srcFile, bmpBlock, &srcBar, 0);
    for (n = 0; n < height; n++ ) {

	if ( progressText) {
	    if ( (n & 0x0F) == 0 ) @call progressText::MSG_VIS_TEXT_APPEND_PTR(".", 0);
	}

    	memcpy(monoData, srcData, maskWidth);
    	monoData = BTBitmapNext(&monoBar, TRUE);
    	srcData = BTBitmapNext(&srcBar, TRUE);
    }
    BTBitmapUnlock(&monoBar, TRUE);
    BTBitmapUnlock(&srcBar, TRUE);

    /*
     * free uncompacted copy, if any
     */
    if ( compact ) {
     	HugeArrayDestroy(srcFile, bmpBlock);
     }

    return newBmp;
}

/*--------------------- BTApplyTransparencyMask ---------------------
 *	Purpose:	Replaces the transparency mask of a bitmap. The new mask is taken 
 *			from a monochrome bitmap.
 *			If no transparency mask exists yet, it will be created.
 *			The size of both bitmaps must be the same, or the result will be 
 *			unpredictable.
 *
 *	Tipp: 		To transfer (copy) a transparency mask form one colored bitmap to 
 *			 another, useBTExtractTransparencyMask() first.
 *
 *	Parameters:	srcFile, bmpBlock: handles of the bitmap
 *			destFile: file for the new bitmap
 *				  Pass zero to modify the passed bitmap instead of copying it.
 *				  Note! This will fail (return zero) if:
 *				    - the bitmap does not yet have a transparency mask
 *				    - the bitmap is compacted
 *			maskFile, maskBitmap: handle of a monochrome bitmap that holds the new mask
 *				- if this bitmap is not monochrome, the result will be unpredictable
 *				- if this bitmaps size does not fit to the size of image, the result
 *				  will be unpredictable.
 *				- if this bitmap also has a mask, picture bits and mask bits will be
 *				  combinded with AND, just as we draw the bitmap.
 *			progressText: optr of an text object to show progress
 *				if given, routine append dots  ('.') for every 16th line
 *				pass zero for no progress report
 *
 *	Return:		VMBlockHandle of the new bitmap
 *			Null handle on error
 ---------------------------------------------------------------------------*/
extern VMBlockHandle EXPORT BTApplyTransparencyMask(VMFileHandle srcFile, VMBlockHandle bmpBlock, VMFileHandle destFile,
			VMFileHandle maskFile, VMBlockHandle maskBitmap,
			optr progressText) {
VMBlockHandle	workBmp;
VMFileHandle	workFile;
int format, width, height, compact;
int n, maskLen;
BitmapAccessRecord maskBar, workBar;
byte *srcPtr, *destPtr;
int mFormat, maskIsMasked, x;


    /*
     * Check parameters
     */
    if ( (srcFile==0) || (bmpBlock==0) ) return 0;

    /*
     * Get information about the source bitmap.
     */
    format = BTGetMoreBitmapInfos(srcFile, bmpBlock, &width, &height, &compact);

    /*
     * Find out or create the bitmap to work with.
     * If destfile==zero has been passed, work with the original bitmap (if posible)
     * Otherwise, create a copy that has a transparency mask
     */
    if ( !destFile ) {
        /*
         * To work with the original bitmap, it must be have a mask
         * and it must not be compressed.
         */
    	if ( compact ) { /*DebugInfo("ApplyTransparencyMask: bmp is compacted"); */return 0; }
    	if ( (format & BMT_MASK) == 0 ) {/* DebugInfo("ApplyTransparencyMask: bmp is unmasked"); */return 0; }
    	workFile = srcFile;
    	workBmp = bmpBlock;

    } else {

    	/*
    	 * We need a masked bitmap to work with.
    	 *
    	 * BTCopyToBitmapWithMask() handles all cases:
    	 *	- original is compressed (or not)
    	 *	- original is already masked (or not)
    	 * The copy will reside in the destFile.
    	 */
    	workFile = destFile;
    	workBmp = BTCopyToBitmapWithMask(srcFile, bmpBlock, workFile, 0);

    }

    /*
     * find out if the maskBitmap itself has a mask
     */
    mFormat = BTGetMoreBitmapInfos(maskFile, maskBitmap, &width, &height, &compact);
    maskIsMasked = mFormat & BMT_MASK ? TRUE : FALSE;


    /*
     * Now, we can process the bitmap. We can be sure, that the bitmapa are uncompaced and have a mask.
     * If the size of the maskBitmap does not fit to the size of the working bitmap, the
     * results are unpredictable, but the handling is save in any case.
     */
    maskLen = (width+7)/8;

    srcPtr = BTBitmapLock(maskFile, maskBitmap, &maskBar, 0);
    destPtr = BTBitmapLock(workFile, workBmp, &workBar, 0);
    for ( n = 0; n < height; n++ ) {

	if ( progressText) {
	    if ( (n & 0x0F) == 0 ) @call progressText::MSG_VIS_TEXT_APPEND_PTR(".", 0);
	}

	/*
	 * Copy mask. If maskIsMasked combine mask and pixel-data with AND
	 */
	if ( maskIsMasked ) {
	    for ( x = 0; x < maskLen; x++ ) { destPtr[x] = srcPtr[x] & srcPtr[x + maskLen]; }
	} else {
	    memcpy(destPtr, srcPtr, maskLen);
	}

	srcPtr =  BTBitmapNext(&maskBar, FALSE);
	if ( !srcPtr) break;
	destPtr = BTBitmapNext(&workBar, TRUE);
	if ( !destPtr) break;

    }

    BTBitmapUnlock(&maskBar, FALSE);
    BTBitmapUnlock(&workBar, TRUE);

    return workBmp;

}

/*--------------------- LocalApplyTransparencyColorMono ---------------------
 * Purpose:	Set pixels with the given 'color' (0 or 1) to transparent
 * Parameters:	dataPtr: pointer to mask area, follewed by the pixel data
 *		width: width of the bitmap
 *		index: color value (0 or 1) to set transparent
 * Return:
 ---------------------------------------------------------------------------*/
void LocalApplyTransparencyColorMono(byte *dataPtr, int width, int index) {
int maskLen, maskBit, x;
byte *maskPtr, *pixelPtr, bits, pixels;


    /*
     * initialize values and pointers
     */
    maskLen = (width+7)/8;
    maskBit = 0x80;
    maskPtr = dataPtr;
    pixelPtr = dataPtr + maskLen;
    bits = *maskPtr;
    pixels = *pixelPtr;

    /*
     * Iterate over every pixel. If the color value of the bitmap fits to the passed
     * index value, clear the corresponding mask bit.
     */
    for ( x = 0; x < width; x++ ) {

	/*
	 * If index is 1, the data pixel must be set, if it is 0, the data pixel
	 * must be clear to reset the mask pixel
	 */
	if ( index ) {
	    if ( pixels & maskBit ) bits &= ~maskBit;
	} else {
	    if ( 0 == (pixels & maskBit) ) bits &= ~maskBit;
	}

    	/* Select next pixel-bit and next mask bit */
	maskBit >>= 1;

	/* If 8 bits are handled, save mask byte select next location */
	if ( !maskBit ) {
	    *maskPtr = bits;
	    maskPtr++;
	    pixelPtr++;
	    maskBit = 0x80;
	    bits = *maskPtr;
	    pixels = *pixelPtr;	    
	}


    }

    /*
     * Last mask byte may not be stored yet. This is the case if maskBit != 0x80
     */
    if ( maskBit != 0x80 ) *maskPtr = bits;
}


/*--------------------- LocalApplyTransparencyColorMono ---------------------
 * Purpose:	Set pixels with the given 'color' (0 or 1) to transparent
 * Parameters:	dataPtr: pointer to mask area, follewed by the pixel data
 *		width: width of the bitmap
 *		index: color value (0 or 1) to set transparent
 * Return:
 
 µµ - delme wenn fertig
 
 ---------------------------------------------------------------------------*/
void LocalApplyTransparencyColorMono_old(byte *dataPtr, int width, int index) {
int maskLen, x;
byte *maskPtr, *pixelPtr;

    /*
     * For monochrome bitmaps, there are two cases:
     * 1. the index is '1' (black): then copy the inverse bitmap data to the mask area
     * 2. the index is '0'(white): then simply copy the bitmap data to the mask area
     */


    /*
     * initialize values and pointers
     */
    maskLen = (width+7)/8;
    maskPtr = dataPtr;
    pixelPtr = dataPtr + maskLen;

    /*
     * Copy data
     */
    if ( index & 1 ) {
    	for ( x = 0; x < maskLen; x++ ) maskPtr[x] = pixelPtr[x] ^ 0xFF;
    } else {
    	memcpy(maskPtr, pixelPtr, maskLen);
    }

}

/*--------------------- LocalApplyTransparencyColor4Bit ---------------------
 * Purpose:	Set pixels with the given color (4 bit index) to transparent
 * Parameters:	dataPtr: pointer to mask area, follewed by the pixel data
 *		width: width of the bitmap
 *		index: color index to set transparent
 * Return:
 ---------------------------------------------------------------------------*/
void LocalApplyTransparencyColor4Bit(byte *dataPtr,int width, int index) {
int maskLen, maskBit, x;
byte *maskPtr, *pixelPtr, bits, twoPixels;


    /*
     * initialize values and pointers
     */
    maskLen = (width+7)/8;
    maskBit = 0x80;
    maskPtr = dataPtr;
    pixelPtr = dataPtr + maskLen;
    bits = *maskPtr;

    /*
     * Iterate over every pixel. If the color value of the bitmap fits to the passed
     * index value, clear the corresponding mask bit.
     */
    twoPixels = *pixelPtr;
    for ( x = 0; x < width; x++ ) {

	/*
	 * Even pixes are stored in the high half byte, odd pixels in the
	 * low half byte.
	 * So, we have two cases to handle.
	 */
	if ( x & 1 ) {
	    /* odd pixel - check index and move the pixel pointer */
	    if ( (twoPixels & 0x0F) == index ) {
		bits &= ~maskBit;			/* Clear the corresponding mask bit */
		}

	    /* Move pointer to next two pixels and fetch it */
    	    pixelPtr++;
    	    twoPixels = *pixelPtr;
    	}
    	else
    	{
    	    /* even pixel - check index only */
	    if ( (twoPixels >> 4) == index ) {
		bits &= ~maskBit;			/* Clear the corresponding mask bit */
		}
	}

	/* select next mask bit */
	maskBit >>= 1;

	/* If 8 bits are handled, save mask byte select next location */
	if ( !maskBit ) {
	    *maskPtr = bits;
	    maskPtr++;
	    maskBit = 0x80;
	    bits = *maskPtr;
	}


    }

    /*
     * Last mask byte may not be stored yet. This is the case if maskBit != 0x80
     */
    if ( maskBit != 0x80 ) *maskPtr = bits;

}

/*--------------------- LocalApplyTransparencyColor8Bit ---------------------
 * Purpose:	Set pixels with the given color (8 bit indext) to transparent
 * Parameters:	dataPtr: pointer to mask area, follewed by the pixel data
 *		width: width of the bitmap
 *		index: color index to set transparent
 * Return:
 ---------------------------------------------------------------------------*/
void LocalApplyTransparencyColor8Bit(byte *dataPtr,int width, int index) {
int maskLen, maskBit, x;
byte *maskPtr, *pixelPtr, bits;


    /*
     * initialize values and pointers
     */
    maskLen = (width+7)/8;
    maskBit = 0x80;
    maskPtr = dataPtr;
    pixelPtr = dataPtr + maskLen;
    bits = *maskPtr;

    /*
     * Iterate over every pixel. If the color value of the bitmap fits to the passed
     * index value, clear the corresponding mask bit.
     */
    for ( x = 0; x < width; x++ ) {

    	/* test pixel - this is quite simple for 8 bit bitmaps */
    	if ( *pixelPtr == index ) {

    	    /* Clear the corresponding mask bit */
    	    bits &= ~maskBit;
    	    }

    	/* Select next pixel and next mask bit */
    	pixelPtr++;
	maskBit >>= 1;

	/* If 8 bits are handled, save mask byte select next location */
	if ( !maskBit ) {
	    *maskPtr = bits;
	    maskPtr++;
	    maskBit = 0x80;
	    bits = *maskPtr;
	}


    }

    /*
     * Last mask byte may not be stored yet. This is the case if maskBit != 0x80
     */
    if ( maskBit != 0x80 ) *maskPtr = bits;

}

/*--------------------- LocalApplyTransparencyColor24Bit ---------------------
 * Purpose:	Set pixels with the given color (rgb) to transparent
 * Parameters:	dataPtr: pointer to mask area, follewed by the pixel data
 *		width: width of the bitmap
 *		red1, red2
 *		green1, green2
 *		blue1, int blue2: Allowed color range set to 'transparent'
 * Return:
 ---------------------------------------------------------------------------*/
void LocalApplyTransparencyColor24Bit(byte *dataPtr, int width, int red1, int red2, int green1, int green2, int blue1, int blue2) {
int maskLen, maskBit, x;
byte *maskPtr, bits;
PaletteEntry *pixelPtr, rgbVal;

    /*
     * initialize values and pointers
     */
    maskLen = (width+7)/8;
    maskBit = 0x80;
    maskPtr = dataPtr;
    pixelPtr = (void*) (dataPtr + maskLen);
    bits = *maskPtr;
    
    /*
     * Iterate over every pixel. If the color value of the bitmap fits to the passed
     * index value, clear the corresponding mask bit.
     */
    for ( x = 0; x < width; x++ ) {

    	/*
    	 * Test pixel - we use a sort of "endless-loop"
    	 * and leave the loop if one of the conditions fails.
    	 */
    	do {
	    rgbVal = *pixelPtr;
	    if ( rgbVal.rt < red1 ) break;
	    if ( rgbVal.rt > red2 ) break;
	    if ( rgbVal.gn < green1 ) break;
	    if ( rgbVal.gn > green2 ) break;
	    if ( rgbVal.bl < blue1 ) break;
	    if ( rgbVal.bl > blue2 ) break;

	    /*
	     * All checks passed
    	     * Clear the corresponding mask bit
    	     */
    	    bits &= ~maskBit;
    	} while (FALSE);


    	/* Select next pixel and next mask bit */
    	pixelPtr++;
	maskBit >>= 1;

	/* If 8 bits are handled, save mask byte select next location */
	if ( !maskBit ) {
	    *maskPtr = bits;
	    maskPtr++;
	    maskBit = 0x80;
	    bits = *maskPtr;
	}


    }

    /*
     * Last mask byte may not be stored yet. This is the case if maskBit != 0x80
     */
    if ( maskBit != 0x80 ) *maskPtr = bits;

}

/*--------------------- BTCopyBitmapAndRemoveMask ---------------------
 *	Purpose:	Copies a bitmap and removes the transparency mask, if any
 *			Also ensure that the copy is uncompressed
 *
 *	Parameters:	srcFile, bmpBlock:	handle of the bitmap
 *			destFile: 	file for the new bitmap
 *			progressText: optr of an text object to show progress
 *				if given, routine append dots  ('.') for every 16th line
 *				pass zero for no progress report
 *
 * 	Strategy:
 *		- if the bitmap already has no transparency mask, make a simple copy
 *		- if there is a transparency mask:
 *		  * fetch the palette, if any
 *		  * create a new non-masked bitmap of same size and color depth
 *		  * copy data over. Replace color for formerly transparent pixels.
 *	Return:		VMBlockHandle of the new bitmap
 *			Null handle on error
 ---------------------------------------------------------------------------*/
extern VMBlockHandle EXPORT BTCopyBitmapAndRemoveMask(VMFileHandle srcFile, VMBlockHandle bmpBlock, VMFileHandle destFile,
			int redOrIndex, int green, int blue, optr progressText) {

int format, width, height, compact;
int y, maskLen, dataSize;
byte *maskPtr, *srcPtr, *destPtr;
VMBlockHandle newBmp;
byte *palPtr;
BitmapAccessRecord	srcBar, destBar;
PaletteEntry	rgbColor;

    /*
     * Check parameters
     */
    if ( (srcFile==0) || (bmpBlock==0)|| (destFile==0) ) return 0;

    /*
     * Get information about the source bitmap.
     */
    format = BTGetMoreBitmapInfos(srcFile, bmpBlock, &width, &height, &compact);


    /*
     * See if a mask is present. If not, make a (uncompressed) copy
     */
    if ( (format & BMT_MASK) == 0 )  {
	if ( compact ) newBmp = GrUncompactBitmap(srcFile, bmpBlock, destFile);
    	    	else newBmp = BTCopyBitmap(srcFile, destFile, bmpBlock);
    	return newBmp;
    }

    /*
     * See if the bitmap is compacted. If yes, we need an uncompacted copy first.
     * Ths copy will be the source to be copied, but it resides in the destFile.
     * Therefore we have to switch our "sourceFile" to the destFile in this case.
     */
    if ( compact) {
    	bmpBlock = GrUncompactBitmap(srcFile, bmpBlock, destFile);
    	srcFile = destFile;
    }


    /*
     * Create the new, unmasked bitmap
     * If present: retrieve and set the palette
     */
    if ( format & BMT_PALETTE )	{
    	int numColors;
    	switch ( format & BMT_FORMAT ) {
    		case BMF_MONO: numColors = 2; break;
    		case BMF_4BIT: numColors = 16; break;
    		case BMF_8BIT: numColors = 256; break;
    		default: numColors = 0;
    		}
    	palPtr = malloc( sizeof(PaletteEntry) * 256 );
    	BTGetBitmapPalette(srcFile, bmpBlock, (PaletteEntry *)palPtr, numColors);
    	}
      else palPtr = 0;

    newBmp = BTCreateOffscreenBitmap(destFile,
    			format & ~BMT_MASK, width, height, (PaletteEntry *)palPtr);
    if ( palPtr )  free(palPtr);


    /*
     * Next step is to calculate the sizes of the mask area and of the pixel data.
     */
    maskLen = (width+7)/8;
    switch ( format & BMT_FORMAT ) {
	case BMF_MONO: dataSize = (width+7)/8; break;
	case BMF_4BIT: dataSize = (width+1)/2; break;
	case BMF_8BIT: dataSize = width; break;
	case BMF_24BIT:
		dataSize = 3*width;
		rgbColor.rt = redOrIndex;
		rgbColor.gn = green;
		rgbColor.bl = blue;
		break;
	}


    /*
     * Finally we can copy the bitmap data to the new bitmap.
     * We can be sure that the source has a mask, but the destination not
     */
    maskPtr = BTBitmapLock(srcFile, bmpBlock, &srcBar, 0);
    srcPtr = maskPtr + maskLen;
    destPtr = BTBitmapLock(destFile, newBmp, &destBar, 0);

    for ( y = 0; y < height; y++ ) {

	if ( progressText) {
	    if ( (y & 0x0F) == 0 ) @call progressText::MSG_VIS_TEXT_APPEND_PTR(".", 0);
	}

	/*
	 * Copy data. Replace color for formerly transparent pixels when requested
	 */
	memcpy(destPtr, srcPtr, dataSize);

	if ( redOrIndex >= 0 ) {
	    switch ( format & BMT_FORMAT ) {
		case BMF_MONO:
		    LocalSetHiddenColorMono(maskPtr, destPtr, width, redOrIndex);
		    break;
		case BMF_4BIT:
		    LocalSetHiddenColor4Bit(maskPtr, destPtr, width, redOrIndex);
		    break;
		case BMF_8BIT:
		    LocalSetHiddenColor8Bit(maskPtr, destPtr, width, redOrIndex);
		    break;
		case BMF_24BIT:
		    LocalSetHiddenColor24Bit(maskPtr, destPtr, width, rgbColor);
		    break;
		}
	}

	/*
	 * enter next line
	 */
	maskPtr = BTBitmapNext(&srcBar, FALSE);
    	srcPtr = maskPtr + maskLen;
	destPtr = BTBitmapNext(&destBar, TRUE);

    }

    BTBitmapUnlock(&srcBar, FALSE);
    BTBitmapUnlock(&destBar, TRUE);

    /*
     * Destroy the uncompaced copy, if any.
     */
    if ( compact ) {
    	HugeArrayDestroy(srcFile, bmpBlock);
    }


    return newBmp;
}

/*--------------------- BTBitmapFillMask ---------------------
 *	Purpose:	Makes the bitmap non transparent at all
 *			The bitmap must already have a transparency
 *			mask and must be not compacted.
 *			
 *	Return:		FALSE if successful
 *			TRUE in any case of error
 ---------------------------------------------------------------------------*/
extern VMBlockHandle EXPORT BTBitmapFillMask(VMFileHandle srcFile, VMBlockHandle bmpBlock) {
int format, width, height, compact;
int y, maskLen;
byte *maskPtr;
BitmapAccessRecord	bar;

    /*
     * Check parameters
     */
    if ( (srcFile==0) || (bmpBlock==0) ) return TRUE;

    /*
     * Get information about the source bitmap and check conditions
     */
    format = BTGetMoreBitmapInfos(srcFile, bmpBlock, &width, &height, &compact);
    if ( (format & BMT_MASK) == 0 )  return TRUE;
    if (compact) return TRUE;
    
    /*
     * Now fill mask
     */
    maskLen =(width+7)/8;
    maskPtr = BTBitmapLock(srcFile, bmpBlock, &bar, 0);

    for ( y = 0; y < height; y++ ) {
	memset(maskPtr, 0xFF, maskLen);
	maskPtr = BTBitmapNext(&bar, FALSE);
    }

    BTBitmapUnlock(&bar, TRUE);
  
    return FALSE;
    
}


/*--------------------- LocalSetHiddenColorMono ---------------------
 * Purpose:	Set transparent pixels to the given 'color' (0 or 1)
 * Parameters:	maskPtr: pointer to mask data
 *		dataPtr: pointer to pixel data
 *		width: width of the bitmap
 *		index: color value: 0 (white) or 1 (black)
 *		       any number greater than zero counts as black
 * Return:
 ---------------------------------------------------------------------------*/
void LocalSetHiddenColorMono(byte *maskPtr, byte *dataPtr, int width, int index) {
int maskBit, x;
byte *pixelPtr, bits;


    /*
     * initialize values and pointers
     */
    maskBit = 0x80;
    pixelPtr = dataPtr;

    /*
     * Iterate over every pixel. If the mask bit is zero (transparent)
     * write passed color to the pixelData
     */
    bits = *maskPtr;

    for ( x = 0; x < width; x++ ) {

    	/* Test transparency bit. If clear, write color */
    	if ( (bits & maskBit) == 0 ) {
    	    if (index) {	 	/* set pixel bit (make it black) */
	    	*pixelPtr = *pixelPtr | maskBit;
	    } else {			/* clear pixel bit (make it white) */
	    	*pixelPtr = *pixelPtr & ~maskBit;
    	    }
	}

    	/* Select next pixel and next mask bit */
	maskBit >>= 1;

	/* If 8 bits are handled, re-initialize maskPtr and bits */
	if ( !maskBit ) {
	    maskBit = 0x80;
	    maskPtr++;
	    bits = *maskPtr;
	    pixelPtr++;
	}

    }
}


/*--------------------- LocalSetHiddenColor4Bit ---------------------
 * Purpose:	Set transparent pixels to the given index (4 bit)
 * Parameters:	maskPtr: pointer to mask data
 *		dataPtr: pointer to pixel data
 *		width: width of the bitmap
 *		index: color index (4 bit) to set
 * Return:
 ---------------------------------------------------------------------------*/
void LocalSetHiddenColor4Bit(byte *maskPtr, byte *dataPtr,int width, int index) {
int maskBit, x, twoPixels;
byte *pixelPtr, bits;
int indexHeight = index << 4;	// usable for even pixels


    /*
     * initialize values and pointers
     */
    maskBit = 0x80;
    pixelPtr = dataPtr;

    /*
     * Iterate over every pixel. If the mask bit is zero (transparent)
     * write passed color to the pixelData
     */
    bits = *maskPtr;
    twoPixels = *pixelPtr;

    for ( x = 0; x < width; x++ ) {

    	/*
    	 * Test transparency bit. If clear, write color
    	 * Even pixels must be written to high half byte, odd pixels to the low half byte.
    	 **/
    	if ( (bits & maskBit) == 0 ) {

	    if ( x & 1 ) {
		/*
		 * odd pixel - store index in lower half byte and write
		 * twoPixels. the upper half byte of twoPixels has been
		 * properly updated i the else branch, if even pixel was
		 * formerly transparent too.
		 */
		*pixelPtr = (twoPixels & 0xF0) | index;

    	    }
    	    else
    	    {
		/*
		 * even pixel - update the upper half byte of twoPixels
		 * with indexHeigh and and write both pixels.
		 */
		twoPixels = (twoPixels & 0x0F) | indexHeight;
		*pixelPtr = twoPixels;
    	    }

    	}


    	/* Select next mask bit and - if necessary - the pointer to the next two pixels */
	maskBit >>= 1;
	if (x & 1 ) {
	    pixelPtr++;
	    twoPixels = *pixelPtr;
	}

	/* If 8 bits are handled, re-initialize maskPtr and bits */
	if ( !maskBit ) {
	    maskBit = 0x80;
	    maskPtr++;
	    bits = *maskPtr;
	}
    }

}

/*--------------------- LocalSetHiddenColor8Bit ---------------------
 * Purpose:	Set transparent pixels to the given index (8 bit)
 * Parameters:	maskPtr: pointer to mask data
 *		dataPtr: pointer to pixel data
 *		width: width of the bitmap
 *		index: color index (8 bit) to set
 * Return:
 ---------------------------------------------------------------------------*/
void LocalSetHiddenColor8Bit(byte *maskPtr, byte *dataPtr,int width, int index) {
int maskBit, x;
byte *pixelPtr, bits;


    /*
     * initialize values and pointers
     */
    maskBit = 0x80;
    pixelPtr = dataPtr;

    /*
     * Iterate over every pixel. If the mask bit is zero (transparent)
     * write passed color to the pixelData
     */
    bits = *maskPtr;

    for ( x = 0; x < width; x++ ) {

    	/* Test transparency bit. If clear, write color */
    	if ( (bits & maskBit) == 0 ) {
	    *pixelPtr = index;
    	    }

    	/* Select next pixel and next mask bit */
    	pixelPtr++;
	maskBit >>= 1;

	/* If 8 bits are handled, re-initialize maskPtr and bits */
	if ( !maskBit ) {
	    maskBit = 0x80;
	    maskPtr++;
	    bits = *maskPtr;
	}
    }

}

/*--------------------- LocalSetHiddenColor24Bit ---------------------
 * Purpose:	Set transparent pixels to the given rgb color
 * Parameters:	maskPtr: pointer to mask data
 *		dataPtr: pointer to pixel data
 *		width: width of the bitmap
 *		red, green, blue: color (rgb) to set
 * Return:
 ---------------------------------------------------------------------------*/
void LocalSetHiddenColor24Bit(byte *maskPtr, byte *dataPtr, int width, PaletteEntry color) {
int maskBit, x;
byte bits;
PaletteEntry *pixelPtr;


    /*
     * initialize values and pointers
     */
    maskBit = 0x80;
    pixelPtr = (void*)dataPtr;

    /*
     * Iterate over every pixel. If the mask bit is zero (transparent)
     * write passed color to the pixelData
     */
    bits = *maskPtr;

    for ( x = 0; x < width; x++ ) {

    	/* Test transparency bit. If clear, write color */
    	if ( (bits & maskBit) == 0 ) {
	    *pixelPtr = color;
    	    }

    	/* Select next pixel and next mask bit */
    	pixelPtr++;
	maskBit >>= 1;

	/* If 8 bits are handled, re-initialize maskPtr and bits */
	if ( !maskBit ) {
	    maskBit = 0x80;
	    maskPtr++;
	    bits = *maskPtr;
	}
    }

}


@if 0

/*--------------------- LocalApplyTransparencyColorMono ---------------------
 * Purpose:	Set pixels with the given 'color' (0 or 1) to transparent
 * Parameters:	dataPtr: pointer to mask area, follewed by the pixel data
 *		width: width of the bitmap
 *		index: color value (0 or 1) to set transparent
 * Return:
 ---------------------------------------------------------------------------*/
void LocalApplyTransparencyColorMono(byte *dataPtr, int width, int index) {
int maskLen, x;
byte *maskPtr, *pixelPtr;

    /*
     * For monochrome bitmaps, there are two cases:
     * 1. the index is '1' (black): then copy the inverse bitmap data to the mask area
     * 2. the index is '0'(white): then simply copy the bitmap data to the mask area
     */


    /*
     * initialize values and pointers
     */
    maskLen = (width+7)/8;
    maskPtr = dataPtr;
    pixelPtr = dataPtr + maskLen;

    /*
     * Copy data
     */
    if ( index & 1 ) {
    	for ( x = 0; x < maskLen; x++ ) maskPtr[x] = pixelPtr[x] ^ 0xFF;
    } else {
    	memcpy(maskPtr, pixelPtr, maskLen);
    }

}

/*--------------------- LocalApplyTransparencyColor4Bit ---------------------
 * Purpose:	Set pixels with the given color (4 bit index) to transparent
 * Parameters:	dataPtr: pointer to mask area, follewed by the pixel data
 *		width: width of the bitmap
 *		index: color index to set transparent
 * Return:
 ---------------------------------------------------------------------------*/
void LocalApplyTransparencyColor4Bit(byte *dataPtr,int width, int index) {
int maskLen, maskBit, x;
byte *maskPtr, *pixelPtr, bits, twoPixels;


    /*
     * initialize values and pointers
     */
    maskLen = (width+7)/8;
    maskBit = 0x80;
    bits = 0xFF;
    maskPtr = dataPtr;
    pixelPtr = dataPtr + maskLen;

    /*
     * Iterate over every pixel. If the color value of the bitmap fits to the passed
     * index value, clear the corresponding mask bit.
     */
    twoPixels = *pixelPtr;
    for ( x = 0; x < width; x++ ) {

	/*
	 * Even pixes are stored in the high half byte, odd pixels in the
	 * low half byte.
	 * So, we have two cases to handle.
	 */
	if ( x & 1 ) {
	    /* odd pixel - check index and move the pixel pointer */
	    if ( (twoPixels & 0x0F) == index ) {
		bits &= ~maskBit;			/* Clear the corresponding mask bit */
		}

	    /* Move pointer to next two pixels and fetch it */
    	    pixelPtr++;
    	    twoPixels = *pixelPtr;
    	}
    	else
    	{
    	    /* even pixel - check index only */
	    if ( (twoPixels >> 4) == index ) {
		bits &= ~maskBit;			/* Clear the corresponding mask bit */
		}
	}

	/* select next mask bit */
	maskBit >>= 1;

	/* If 8 bits are handled, save mask byte select next location */
	if ( !maskBit ) {
	    *maskPtr = bits;
	    maskPtr++;
	    maskBit = 0x80;
	    bits = 0xFF;
	}


    }

    /*
     * Last mask byte may not be stored yet. This is the case if maskBit != 0x80
     */
    if ( maskBit != 0x80 ) *maskPtr = bits;

}

/*--------------------- LocalApplyTransparencyColor8Bit ---------------------
 * Purpose:	Set pixels with the given color (8 bit indext) to transparent
 * Parameters:	dataPtr: pointer to mask area, follewed by the pixel data
 *		width: width of the bitmap
 *		index: color index to set transparent
 * Return:
 ---------------------------------------------------------------------------*/
void LocalApplyTransparencyColor8Bit(byte *dataPtr,int width, int index) {
int maskLen, maskBit, x;
byte *maskPtr, *pixelPtr, bits;


    /*
     * initialize values and pointers
     */
    maskLen = (width+7)/8;
    maskBit = 0x80;
    bits = 0xFF;
    maskPtr = dataPtr;
    pixelPtr = dataPtr + maskLen;

    /*
     * Iterate over every pixel. If the color value of the bitmap fits to the passed
     * index value, clear the corresponding mask bit.
     */
    for ( x = 0; x < width; x++ ) {

    	/* test pixel - this is quite simple for 8 bit bitmaps */
    	if ( *pixelPtr == index ) {

    	    /* Clear the corresponding mask bit */
    	    bits &= ~maskBit;
    	    }

    	/* Select next pixel and next mask bit */
    	pixelPtr++;
	maskBit >>= 1;

	/* If 8 bits are handled, save mask byte select next location */
	if ( !maskBit ) {
	    *maskPtr = bits;
	    maskPtr++;
	    maskBit = 0x80;
	    bits = 0xFF;
	}


    }

    /*
     * Last mask byte may not be stored yet. This is the case if maskBit != 0x80
     */
    if ( maskBit != 0x80 ) *maskPtr = bits;

}

/*--------------------- LocalApplyTransparencyColor24Bit ---------------------
 * Purpose:	Set pixels with the given color (rgb) to transparent
 * Parameters:	dataPtr: pointer to mask area, follewed by the pixel data
 *		width: width of the bitmap
 *		red1, red2
 *		green1, green2
 *		blue1, int blue2: Allowed color range set to 'transparent'
 * Return:
 ---------------------------------------------------------------------------*/
void LocalApplyTransparencyColor24Bit(byte *dataPtr, int width, int red1, int red2, int green1, int green2, int blue1, int blue2) {
int maskLen, maskBit, x;
byte *maskPtr, bits;
PaletteEntry *pixelPtr, rgbVal;

    /*
     * initialize values and pointers
     */
    maskLen = (width+7)/8;
    maskBit = 0x80;
    bits = 0xFF;
    maskPtr = dataPtr;
    pixelPtr = (void*) (dataPtr + maskLen);

    /*
     * Iterate over every pixel. If the color value of the bitmap fits to the passed
     * index value, clear the corresponding mask bit.
     */
    for ( x = 0; x < width; x++ ) {

    	/*
    	 * Test pixel - we use a sort of "endless-loop"
    	 * and leave the loop if one of the conditions fails.
    	 */
    	do {
	    rgbVal = *pixelPtr;
	    if ( rgbVal.rt < red1 ) break;
	    if ( rgbVal.rt > red2 ) break;
	    if ( rgbVal.gn < green1 ) break;
	    if ( rgbVal.gn > green2 ) break;
	    if ( rgbVal.bl < blue1 ) break;
	    if ( rgbVal.bl > blue2 ) break;

	    /*
	     * All checks passed
    	     * Clear the corresponding mask bit
    	     */
    	    bits &= ~maskBit;
    	} while (FALSE);


    	/* Select next pixel and next mask bit */
    	pixelPtr++;
	maskBit >>= 1;

	/* If 8 bits are handled, save mask byte select next location */
	if ( !maskBit ) {
	    *maskPtr = bits;
	    maskPtr++;
	    maskBit = 0x80;
	    bits = 0xFF;
	}


    }

    /*
     * Last mask byte may not be stored yet. This is the case if maskBit != 0x80
     */
    if ( maskBit != 0x80 ) *maskPtr = bits;

@endif

/*---------------------  ---------------------
 * Purpose:
 * Parameters:
 * Return:
 ---------------------------------------------------------------------------*/
