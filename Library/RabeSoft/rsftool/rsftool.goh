/***************************************************************************
 *
 *  Header file for FileTool-Library
 *  Routines and structures
 *  (c) by RABE-Soft 12/99
 *
 *  Note: The comments were translated from German to English with AI assistance
 *  and were not checked in detail. They may therefore occasionally sound a bit odd.
 *
 ***************************************************************************/

@deflib rsftool

/*###########################################################################
 #  Short description of the routines
 ###########################################################################
 #  Generally useful
 #
 #  FTSetAttrText(attr,str)     // Macro
 #      Assigns a string str according to the attributes attr
 #      e.g. "  HRA  "
 #
 ###########################################################################
 #  Support for FileSelectors
 ###########################################################################

 ---- Tool routines ----

 void FileToolPrintDateAndSize(char *buffer, char * fileName);
        Output the file date and file size into a
        buffer. The file is passed by name and not opened

 void FileToolGetFileSelectorFullPath(char *fullPath, optr fsel,
            Boolean addDriveLetter);
        Get complete path string (with selection) from the FileSelector

 void FileToolGetFileSelectorDirectoryPath(char *fullPath, optr fsel,Boolean addDriveLetter);
        Get complete path string from the FileSelector.
        Possibly selected files are ignored

 Boolean FileToolSetCurrentPathFromFileSelector(optr fsel);
        Switch to a directory selected by the FileSelector.
        The current selection is considered if it is a directory.
    Return: TRUE if a file was selected, otherwise FALSE

optr    FileToolGetTextOptr (FileToolDefaultTexte txt);
        Returns the optr of one of the predefined texts

 ---- Dialog boxes ----

 int FileToolRequestChangeDir(optr infoText, char *titel,
                char *customTriggerMoniker,
                Boolean hasCancelTrigger);
    Task:       Request a directory via a dialog box
            Start point is the current dir
    Side effect:    The corresponding directory is switched to,
            if OK or custom trigger is activated,
            but not if cancel trigger is pressed
    Return:     IC_OK | IC_NO | IC_YES | IC_NULL

 int FileToolRequestSelectFile(fileName,infoText, titel,
        customTriggerMoniker,hasCancelTrigger ) //Macro

 int FileToolExtendedRequestSelectFile(char * fileName,
            optr infoText, char *titel,
            char *customTriggerMoniker, Boolean hasCancelTrigger,
            word fileAttrsMatch, word fileAttrsMismatch,
            FileSelectorFileCriteria fileCriteria,
            GeodeToken *creatorToken,
            GeodeToken *fileToken,
            char *fileMask );

    Tasks:      Request a file via a dialog box in which all
            or the specified files are offered
            Start point is the current dir
    Side effect:    The corresponding directory is switched to,
            if OK or custom trigger is activated,
            but not if cancel trigger is pressed
    Return:     IC_OK | IC_NO | IC_YES | IC_NULL

 ###########################################################################
 #  Comparing and converting
 ###########################################################################

 int FileToolCompareProtocol (  ProtocolNumber fileProtocol,
                ProtocolNumber compProtocol);
            Compares two protocol numbers
        Return: CRP_FILE_SAME | CRP_FILE_OLDER | CRP_FILE_NEWER

 int FileToolCompareRelease (   ReleaseNumber fileRelease,
                ReleaseNumber compRelease);
            Compares two release numbers
        Return: CRP_FILE_SAME | CRP_FILE_OLDER | CRP_FILE_NEWER

 int FileToolCompareFileDateAndTime(FileDateAndTime fdat1,
            FileDateAndTime fdat2);
           Date and time comparison of two FileDateAndTime structures
    return     (fdat1 - fdat2)  -> (-1) | (0) | (1)

 void FileToolFileDateToTimeDate( TimerDateAndTime *tdat,
            FileDateAndTime fdat);
       Task:        Convert the Geos data structures
       Params/Return:   void ( target structure, source structure)

 ###########################################################################
 #  Editing path strings
 ###########################################################################

 int FileToolDropBackslash(char * path, Boolean slashAlso );
        Cuts off the backslash (or slash, if requested) at the end.
        But only if there is one there.
       Return: New path length

 Boolean FileToolMakeParentPath(char * path, Boolean slashAlso );
        Shortens a path to the parent path.
    Return: TRUE if no parent is possible (usually empty string or "\")
        FALSE if OK

 int FileToolAddPathElement(char * path, char *tail);
        Appends a new element to a directory path.
        If necessary, a backslash is inserted in between.
    Return: Old path length

 word FileToolParseNameFromPath ( char ** path, Boolean useGeosNameConvention);
    Changes the passed pointer so that it points to the last element
    of the path string, i.e. to the file or current dir name.
    Parameter:
    path:   Pointer to the path string, is modified
    useGeosNameConvention:
        GEOS names may have a slash (/) in the name, in Windows
        and other systems it is also used as a path separator (like backslash)
        --> TRUE if GEOS conventions, otherwise FALSE
    Return: Length of the new string


 ###########################################################################
 #  Paths and files (not opened)
 ###########################################################################

 Boolean FileToolExistFile(char *name);
    Return TRUE if a file with this name exists

 FTExistFilesValue FileToolExistFileGD(char * geosName, char * dosName);
        Tests whether a file with the specified Geos and
        DOS name exists. The file name must not contain
        a path part
    Return: FTEF_YES | FTEF_NO | FTEF_INVALID_DOSNAME |
        FTEF_IVALID_GEOSNAME | FTEF_DIFFERENT_FILES

 int FileToolCreateSubdir( char *path );
        Create subdirectory relative to working dir
        If necessary, recursive call
    Return:      -1 if the path cannot be created
            or error code from FileCreateDir()
            OK: FALSE  ( == 0 )

 int FileToolCreatePath (DiskHandle dh, char *path);
        Create a path on a data carrier
    Return:     -1 if the path cannot be created
            or error code from FileToolCreateSubdir()
            OK: FALSE ( ==0 )

 Boolean FileToolGetCurrentDirName(char * name, Boolean rootFlag);
        Returns the name of the current dir.
    Return: TRUE, the current dir is a root directory.
        FALSE if the current dir is not a root directory.

 ---------------------------------------------------------------------------
    Searching directories
 ---------------------------------------------------------------------------

 int FileToolEnumSubdir (MemHandle * mh, word flags);
        Search a directory. For each file that matches flags,
        a structure FTStandardEnumType is returned in the allocated
        memory mh. The array is sorted if necessary.
    Return: Number of files found

 int FileToolExtendedEnumSubdir(MemHandle * mh, word flags,
            FileExtAttrDesc * returnAttrs, word returnSize);
        Search a directory. For each file that matches flags,
        a structure is returned in the allocated memory mh,
        which is described by returnDesc and returnSize.

 int FileToolExtEnumSubdirWithSkip(MemHandle * mh, word flags,
            FileExtAttrDesc * returnAttrs, word returnSize,
            word skipCount, word *noFitCount);
        Search a directory. For each file that matches flags,
        a structure is returned in the allocated memory mh,
        which is described by returnDesc and returnSize.
        Functionally extended FileToolExtendedEnumSubdir():
        skipCount and noFitCount allow complete searching
        of directories, even if only step by step.


 int FileToolEnumDirsAndFiles( MemHandle * mh, int * dirCount, word flags);
        Search a directory.
        First, the directory is searched with FileToolEnumSubdir,
        then the found entries of type FTStandardEnumType
        are sorted (directories first), stored in a memory block,
        and the corresponding handle is returned.
        The array is also sorted alphabetically if necessary (FT_EF_SORT).
    Return: Total number of entries found (files+dirs)
        (-1) if a memory block could not be created

 void FileToolSortFileEnumResult( MemHandle mh,
                int structSize, int structCount,
                int nameOffs, int attrOffs);
        Sort a search result from FileEnum().
        Goal: alphabetical display in a file list

 int FileToolAdjustLinkDirs( MemHandle *mh, int structSize, int structCount,
                int flags, int attrOffset);
        Fix a system bug: hide links to directories
        (or real directories) if they were not specified by flags.
        (FileEnum always returns "everything")
        Before release 3.2, FileEnum always returns directories,
        even if they were not specified. The library takes this into account.


 ###########################################################################
 #  Reading and writing files
 ###########################################################################

 int FileToolDeleteFile(char * fileName, FileToolDeleteFlags flags);
        Deletes a file, asks if necessary
    Return: TRUE if error
        -> Error number from FileDelete();

 int FileToolInsertBuffer ( FileHandle fh, void *buf, word bufSize,
            char * fileNameForErrorMsg);
 Boolean FileToolDeleteRange (FileHandle fh, dword range,
                    char * fileNameForErrorMsg);

 Boolean FileToolReplaceBuffer(FileHandle fh, void * buffer,
             word oldSize, word bufSize, char * fileNameForErrorMsg);
 Boolean FileToolRenameFile( char * oldName,char *newName, Boolean msgOnError);

 Boolean FileToolModifyDosName( char * oldName,char *newName, Boolean msgOnError);

 Boolean FileToolSetExtAttr( char * fileName,word feaToSet, void * buffer, word attrSize, Boolean msgOnError);

 FTReadLineReturnValue FileToolReadLine ( FileHandle file,
            char * line, word bufSize );
    Read a text line from a file
    Return  FTRL_OK | FTRL_EOF | FTRL_NO_LINE | FTRL_ERROR

 void FileToolTrimLine(char * line);
        Remove all leading and trailing spaces or tabs
        from a string

/*###########################################################################
 #  End of short description
 ###########################################################################*/

/* bugfixes */

#ifndef FEP_BUFSIZE_UNLIMITED
#define FEP_BUFSIZE_UNLIMITED   FE_BUFSIZE_UNLIMITED
#endif

#define EXPORT _export _pascal

#define FTSetAttrTextElement(atr,AT,str,ch,n)   \
	if ( atr & AT ) str[n] = ch ; else str[n] = ' '
#define	FTSetAttrText(attr,str)	FTSetAttrTextElement(attr,FA_ARCHIVE,str,'A',0);\
			FTSetAttrTextElement(attr,FA_RDONLY,str,'R',1);\
			FTSetAttrTextElement(attr,FA_SUBDIR,str,'D',2);\
			FTSetAttrTextElement(attr,FA_HIDDEN,str,'H',3);\
			FTSetAttrTextElement(attr,FA_SYSTEM,str,'S',4);\
			FTSetAttrTextElement(attr,FA_LINK,str,'L',5);\
			FTSetAttrTextElement(attr,FA_VOLUME,str,'V',6);\
			str[7]=0


/*###########################################################################
 #  Support for FileSelectors
 ###########################################################################*/

/*--------------------- FileToolPrintDateAndSize ---------------------
 *  Task:   Output the file date, file size, and file
 *      attributes into a buffer.
 *      The file is passed by name and not
 *      opened
 *      - The buffer must be at least 40 bytes in size
 *      - Geos headers are (probably) not counted in the size
 ---------------------------------------------------------------------------*/
extern void EXPORT FileToolPrintDateAndSize(char *buffer, char * fileName);

/*--------------------- FileToolGetFileSelectorFullPath ---------------------
 *  Task:   Get complete path string (with selection) from
 *      the FileSelector
 *  Parameter:  void ( char * fullPath, // return: path
 *                      // at least PATH_BUFFER_SIZE in size
 *          optr fsel,      // GenFileSelector
 *          Boolean addDriveLetter) // With drive letter?
 ---------------------------------------------------------------------------*/
extern void EXPORT FileToolGetFileSelectorFullPath(char *fullPath,
            optr fsel,Boolean addDriveLetter);

/*--------------------- FileToolGetFileSelectorDirectoryPath ---------------------
 *  Task:   Get complete path string from
 *      the FileSelector. Possibly selected files are
 *      ignored
 *  Parameter:  void ( char * fullPath, // return: path
 *                      // at least PATH_BUFFER_SIZE in size
 *          optr fsel,      // GenFileSelector
 *          Boolean addDriveLetter) // With drive letter?
 ---------------------------------------------------------------------------*/
extern void EXPORT FileToolGetFileSelectorDirectoryPath(char *fullPath,
            optr fsel,Boolean addDriveLetter);

/*--------------------- FileToolSetCurrentPathFromFileSelector -----------------
 *  Task:   Switch to a directory selected by the FileSelector.
 *      The current selection is considered if it is a directory.
 *  Return: TRUE if a file was selected, otherwise FALSE
 ---------------------------------------------------------------------------*/
extern Boolean EXPORT FileToolSetCurrentPathFromFileSelector(optr fsel);


/*--------------------- FileToolGetTextOptr ---------------------
 *  Task:        Returns the optr of one of the predefined texts
 ---------------------------------------------------------------------------*/
typedef enum {
    FT_TXT_DELETE_FILE
    } FileToolDefaultTexte;

extern optr  EXPORT FileToolGetTextOptr(FileToolDefaultTexte txt);



/*--------------------- FileToolRequestChangeDir ---------------------
 *  Task:        Request a directory via a dialog box
 *      Start point is the current dir
 *  Side effect:    The corresponding directory is switched to,
 *      if OK or custom trigger is activated,
 *      but not if cancel trigger is pressed
 *  Parameter:  infoText:   optr of an info text, Null for none
 *          titel:      Dialog box title,
 *                  Null for "Select directory"
 *          customTriggerMoniker: Moniker of an extra button that
 *                  returns IC_YES, NULL for no such button
 *          hasCancelTrigger: TRUE if cancel trigger should be present
 *  Return:     IC_OK       if OK trigger pressed
 *          IC_NO           if cancel trigger pressed
 *          IC_YES          if custom trigger pressed
 *          IC_NULL     systemShutDown or similar
 ---------------------------------------------------------------------------*/

extern int EXPORT FileToolRequestChangeDir(optr infoText, char *titel,
            char *customTriggerMoniker, Boolean hasCancelTrigger);

/*--------------------- FileToolRequestSelectFile ---------------------
 *  Task:        Request a file via a dialog box in which all
 *      files are offered
 *      Start point is the current dir
 *
/*--------------------- FileToolExtendedRequestSelectFile ---------------------
 *  Task:        Request a file via a dialog box in which only
 *      the files that match the selection criteria are offered
 *      Start point is the current dir
 *---------------------------------------------------------------------------
 *  Side effect:    The corresponding directory is switched to,
 *      if OK or custom trigger is activated,
 *      but not if cancel trigger is pressed
 *  Parameters for both routines:
 *      fileName:   Selected file. Empty string if none
 *              file was selected (e.g. because
 *              cancel was chosen)
 *      infoText:   optr of an info text, Null for none
 *      titel:      Dialog box title,
 *              Null for "Select file"
 *      customTriggerMoniker: Moniker of an extra button that
 *                returns IC_YES
 *              - NULL for no such button
 *              - If the moniker starts with ~, it is
 *                *not* displayed, but the button
 *                                is only enabled if a file
 *                                is selected (otherwise it is always
 *                enabled)
 *      hasCancelTrigger: TRUE if cancel trigger should be present
 *  Parameters only for Extended... :
 *      fileAttrsMatch: Attributes that *must* be set
 *              0 to not hide any files
 *      fileAttrsMismatch: Attributes that must *not* be set
 *              0 to not hide any files
 *      fileCriteria:   FileSelectorFileCriteria value
 *              GFSFC_xxx constants
 *      creatorToken:   GeodeToken* of the creator
 *              NULL to not hide any files
 *      fileToken:      GeodeToken* of the file
 *              NULL to not hide any files
 *      fileMask:   File mask, case-sensitive
 *              -> uppercase for DOS files
 *              NULL to not hide any files
 *  Return:     IC_OK       if OK trigger pressed
 *          IC_NO           if cancel trigger pressed
 *          IC_YES          if custom trigger pressed
 *          IC_NULL     systemShutDown or similar
 ---------------------------------------------------------------------------*/
extern int EXPORT FileToolExtendedRequestSelectFile(char * fileName,
            optr infoText, char *titel,
            char *customTriggerMoniker, Boolean hasCancelTrigger,
            word fileAttrsMatch, word fileAttrsMismatch,
            FileSelectorFileCriteria fileCriteria,
            GeodeToken *creatorToken,
            GeodeToken *fileToken,
            char *fileMask );

#define FileToolRequestSelectFile(fileName,infoText, titel,customTriggerMoniker,\
    hasCancelTrigger ) FileToolExtendedRequestSelectFile \
        (fileName,infoText, titel,customTriggerMoniker, hasCancelTrigger,\
        0,0, FSFC_DIRS | FSFC_NON_GEOS_FILES | FSFC_GEOS_EXECUTABLES | \
        FSFC_GEOS_NON_EXECUTABLES, NULL, NULL, NULL);

/*******************************************************************************
 *
 *  Dialogs for entering file names, e.g. for file operations
 *
 *******************************************************************************/

/*
 * Flags for configuring the input text for
 * FileToolRequestInputFileName() and FileToolExtendedRequestInputFileName()
 */
typedef enum {
    IFNIF_DOS_FILE = 1,     /* Only allow DOS-compliant names */
    IFNIF_AUTO_RENAME = 2,          /* Automatically change default text
                     * "Copy of " or "...~1.xxx" */
    IFNIF_SELECT_ALL = 4,       /* Select entire input text */
    IFNIF_SELECT_DOS_BODY = 8   /* Select only name up to . */
    } FTInputFileNameInputFlags;


/*
 * Dialog type for FileToolRequestInputFileName()
 * Simplifies the call to FileToolExtendedRequestInputFileName()
 */
typedef enum {
    IFNDT_SAVE = 0,         /* Save file */
    IFNDT_SAVE_AS,          /* Save file as ..*/
    IFNDT_COPY_NEW_NAME,        /* Copy file with option
                     * to choose a new name */
    IFNDT_DUPLICATE,        /* Duplicate file in place
                     * No FileSelector present */
    IFNDT_RENAME                    /* Rename file
                     * No FileSelector present */
    } FTInputFileNameDialogType;

/*
 * Flags to control the UI properties of
 * FileToolExtendedRequestInputFileName() and FileToolRequestInputCommonName()
 */
typedef enum {
    IFNUIF_HAS_CANCEL_TRIGGER = 1,  /* Cancel trigger present */
    IFNUIF_HAS_FILE_SELECTOR = 2,   /* FileSelector present */
    IFNUIF_TITEL_IS_OPTR    = 4,    /* otherwise char* Important: the optr
        points to a chunk char, NOT to a @visMoniker !!!!*/
    IFNUIF_INFO_TEXT_IS_OPTR = 8,   /* otherwise char* */
    IFNUIF_INPUT_TEXT_MONIKER_NEW = 0x10, /* VisMoniker of the input text
                    * is "New name for the file:" instead of
                    * default: "Name of the file:" */
    IFNUIF_HIDE_OK_TRIGGER = 0x20,  /* Hide OK button ->
                     * Custom trigger can take over its function */
    IFNUIF_AUTO_SHOW_DOS_FILENAME_INFO = 0x40 /* The info text "The file name
                    * must be of the type FILENAME.EXT." is
                    * displayed IF the flag
                    * IFNIF_DOS_FILE is also set (from
                    * FTInputFileNameInputFlags) */
    } FTInputFileNameUIFlags;

/*--------------------- FileToolRequestInputFileName --------------------
 *  Task:        Dialog for entering a file name for
 *      file operations. A cancel trigger is always
 *      present, a FileSelector usually (depending
 *      on dialogType)
 *  Parameter:  fileName:   Return: name of the file. Must contain a
 *                                  default value or an empty string
 *                  Unchanged if cancel is chosen
 *          dialogType: Type of input dialog
 *                  IFNDT_SAVE, IFNDT_SAVE_AS
 *                  IFNDT_COPY_NEW_NAME,
 *                  IFNDT_DUPLICATE, IFNDT_RENAME
 *          inputFlags: Properties of the input text
 *                  IFNIF_DOS_FILE | IFNIF_AUTO_RENAME
 *                  | IFNIF_SELECT_ALL | IFNIF_SELECT_DOS_BODY
 *          customTriggerMoniker: Label for extra button
 *                  NULL: no extra button present
 *  Return:     Interaction command of the dialog box:
 *                      IC_OK:  OK trigger pressed
 *          IC_NO:  Cancel trigger pressed
 *          IC_YES: Custom trigger pressed
 *          IC_NULL: System shutdown or similar
 *-----------------------------------------------------------------------*/
extern InteractionCommand EXPORT FileToolRequestInputFileName(
    char *fileName,
    FTInputFileNameDialogType   dialogType,
    FTInputFileNameInputFlags   inputFlags,
    char *customTriggerMoniker);

/*--------------------- FileToolExtendedRequestInputFileName --------------------
 *  Task:        Universal customizable dialog box for saving a file.
 *      Directory and file name can be selected if needed.
 *  Side effect:    The corresponding directory is switched to,
 *      if OK or custom trigger is activated,
 *      but not if cancel trigger is pressed
 *  Parameter:  fileName: Return: name of the file. Must contain a
 *                                default value or an empty string
 *                Unchanged if cancel is chosen
 *          infoText: Info text above the input line
 *                   char* or optr. NULL -> "Save file"
 *          titel:    Title line
 *                   char* or optr. NULL: none
 *          customTriggerMoniker: Label for extra button
 *                  NULL: no extra button present
 *          inputFlags: Properties of the input text
 *                  IFNIF_DOS_FILE | IFNIF_AUTO_RENAME
 *                  | IFNIF_SELECT_ALL | IFNIF_SELECT_DOS_BODY
 *          uiFlags:    Properties of the UI of the dialog
 *                      IFNUIF_HAS_CANCEL_TRIGGER
 *                  | IFNUIF_HAS_FILE_SELECTOR
 *                      | IFNUIF_TITEL_IS_OPTR
 *                  | IFNUIF_INFO_TEXT_IS_OPTR
 *                      | IFNUIF_INPUT_TEXT_MONIKER_NEW
 *                  | IFNUIF_HIDE_OK_TRIGGER
 *                  | IFNUIF_AUTO_SHOW_DOS_FILENAME_INFO
 *  Return:     Interaction command of the dialog box:
 *                      IC_OK:  OK trigger pressed
 *          IC_NO:  Cancel trigger pressed
 *          IC_YES: Custom trigger pressed
 *          IC_NULL: System shutdown or similar
 *-----------------------------------------------------------------------*/
extern InteractionCommand EXPORT FileToolExtendedRequestInputFileName(
    char *fileName,
    void *infoText,     /* char* or optr. NULL -> "Save file" */
    void *titel,        /* char* or optr. NULL: none */
    char *customTriggerMoniker,
    FTInputFileNameInputFlags   inputFlags,
    FTInputFileNameUIFlags      uiFlags);

/*--------------------- FileToolRequestInputCommonName --------------------
 *  Task:        Universal dialog for entering a name for
 *      various purposes (e.g. folder name)
 *  Parameter:  name:     Return: name to be entered. Must contain a
 *                                default value or an empty string
 *                Unchanged if cancel is chosen
 *          bufferSize: max. length for name (incl. null)
 *          infoText:       Info text above the input line
 *                  char* or optr. NULL: no info text
 *          titel:      Title line
 *                  char* or optr. NULL -> "Enter name"
 *          customTriggerMoniker: Label for extra button
 *                  NULL: no extra button present
 *          allowEmptyText: TRUE: input field may be empty
 *                  FALSE: error message if text field
 *                      is empty and OK or custom trigger
 *                      pressed (dialog reappears)
 *          uiFlags:    FTInputFileNameUIFlags
 *      Accepted UI flags :
 *          IFNUIF_HAS_CANCEL_TRIGGER
 *          IFNUIF_TITEL_IS_OPTR
 *          IFNUIF_INFO_TEXT_IS_OPTR
 *          IFNUIF_HIDE_OK_TRIGGER
 *      Unsupported flags:
 *          IFNUIF_HAS_FILE_SELECTOR |  IFNUIF_INPUT_TEXT_MONIKER_NEW
 *          IFNUIF_AUTO_SHOW_DOS_FILENAME_INFO
 *  Return:     Interaction command of the dialog box:
 *                      IC_OK:  OK trigger pressed
 *          IC_NO:  Cancel trigger pressed
 *          IC_YES: Custom trigger pressed
 *          IC_NULL: System shutdown or similar
 *-----------------------------------------------------------------------*/
extern InteractionCommand EXPORT FileToolRequestInputCommonName(
    char *name,     /* name to be entered */
    int  bufferSize,    /* max length for name (incl. null) */
    void *infoText,     /* char* or optr. NULL: none */
    void *titel,        /* char* or optr. NULL -> "Enter name" */
    char *customTriggerMoniker,
    Boolean allowEmptyText,
    FTInputFileNameUIFlags      uiFlags);

/*--------------------- FileToolRequestInputFolderName --------------------
 *  Task:        Customized dialog for entering a name for
 *      a new folder.
 *      Cancel button is present.
 *      There is NO FileSelector
 *  Parameter:  folderName:   Return: name to be entered. Must contain a
 *                                default value or an empty string
 *                Unchanged if cancel is chosen
 *          customTriggerMoniker: Label for extra button
 *                  NULL: no extra button present
 *          hideOKTrigger: Hide OK button or not.
 *  Return:     Interaction command of the dialog box:
 *                      IC_OK:  OK trigger pressed
 *          IC_NO:  Cancel trigger pressed
 *          IC_YES: Custom trigger pressed
 *          IC_NULL: System shutdown or similar
 *-----------------------------------------------------------------------*/
extern InteractionCommand EXPORT FileToolRequestInputFolderName(
    char *folderName,       /* name to be entered */
    char *customTriggerMoniker,
    Boolean hideOKTrigger);


/*###########################################################################
 #  DOS long filename support: multiple dots in the file name
 ###########################################################################*/

extern char* EXPORT FileToolFindLastDotChar(char *text);
extern int EXPORT FileToolGetDOSExtension(char *fileName, char *extension, int maxChars);

/*###########################################################################
 #  Comparing and converting
 ###########################################################################*/

/*--------------------- FileToolCompareProtocol ---------------------
 *  Task:        Compares two protocol numbers
 *  Return:     CRP_FILE_SAME   : numbers are equal
 *          CRP_FILE_OLDER  : fileProtocol is older than compProtocol
 *          CRP_FILE_NEWER  : fileProtocol is newer than compProtocol
 ---------------------------------------------------------------------------*/

typedef enum {  CRP_FILE_SAME,  // file has same protocol / release
        CRP_FILE_OLDER, // file has older protocol / release
        CRP_FILE_NEWER  // file has newer protocol / release
        } CompareReleaseAndProtocolValue;

#define CRP_COMP_SAME   CRP_FILE_SAME
#define CRP_COMP_NEWER  CRP_FILE_OLDER
#define CRP_COMP_OLDER  CRP_FILE_NEWER


extern int EXPORT FileToolCompareProtocol
        (ProtocolNumber fileProtocol,ProtocolNumber compProtocol);

/*--------------------- FileToolCompareRelease ---------------------
 *  Task:        Compares two release numbers
 *  Return:     CRP_FILE_SAME   : numbers are equal
 *          CRP_FILE_OLDER  : fileRelease is older than compRelease
 *          CRP_FILE_NEWER  : fileRelease is newer than compRelease
 ---------------------------------------------------------------------------*/
extern int EXPORT FileToolCompareRelease
        (ReleaseNumber fileRelease,ReleaseNumber compRelease);

/*--------------------- FileToolCompareFileDateAndTime ---------------------
   Date and time comparison of two FileDateAndTime structures
   return   fdat1 < fdat2   (-1):
        fdat1 = fdat2   (0):
        fdat1 > fdat2   ( 1):
 ---------------------------------------------------------------------------*/
extern int EXPORT FileToolCompareFileDateAndTime(FileDateAndTime fdat1,
            FileDateAndTime fdat2);

/*--------------------- FileToolFileDateToTimeDate ---------------------
 *      Task:        Convert the Geos data structures
 *      Params/Return:  void ( target structure, source structure)
 ---------------------------------------------------------------------------*/
extern void EXPORT FileToolFileDateToTimeDate( TimerDateAndTime *tdat,
            FileDateAndTime fdat);

/*###########################################################################
 #  Editing path strings
 ###########################################################################*/

/*--------------------- FileToolDropBackslash ---------------------
   FileToolDropBackslash: Cuts off the backslash (or slash, if requested) at the end.
   But only if there is one there.
   Return: New path length
 ---------------------------------------------------------------------------*/
extern int EXPORT FileToolDropBackslash(char * path, Boolean slashAlso );

/*--------------------- FileToolMakeParentPath ---------------------
   Shortens a path to the parent path.
   Return: TRUE if no parent is possible (usually empty string or "\")
       FALSE if OK
   "PAUL" or "PAUL\" returns empty string and OK (FALSE)
   "C:" and "C:\" also return empty string and OK (FALSE)
 ---------------------------------------------------------------------------*/
extern Boolean EXPORT FileToolMakeParentPath(char * path, Boolean slashAlso );

/*--------------------- FileToolAddPathElement ---------------------
*   Task:   Appends a new element to a directory path.
*       If necessary, a backslash is inserted in between.
*       No backslash is appended
*   Return: Old path length
---------------------------------------------------------------------------*/
extern int EXPORT FileToolAddPathElement(char * path, char *tail);

/*--------------------- FileToolParseNameFromPath ---------------------
    Changes the passed pointer so that it points to the last element
    of the path string, i.e. to the file or current dir name.
    Parameter:
    path:   Pointer to the path string, is modified
    useGeosNameConvention:
        GEOS names may have a slash (/) in the name, in Windows
        and other systems it is also used as a path separator (like backslash)
        --> TRUE if GEOS conventions, otherwise FALSE
    Return: Length of the new string
 ---------------------------------------------------------------------------*/
extern word EXPORT FileToolParseNameFromPath ( char ** path, Boolean useGeosNameConvention);
#define FT_GEOS_NAME_CONVENTION     TRUE
#define FT_WINDOWS_NAME_CONVENTION  FALSE

/*###########################################################################
 #  Paths and files (not opened)
 ###########################################################################*/

/*--------------------- FileToolExistFileGD ---------------------
 *  Task:        Tests whether a file with the specified Geos and
 *      DOS name exists. The file name must not contain
 *      a path part
 *  Parameter:  geosName:   (must be set)
 *          dosName     (may be null. In this case,
 *                   geosName may also refer to a DOS file)
 *  Return:     FTEF_YES | FTEF_NO | FTEF_INVALID_DOSNAME |
 *          FTEF_IVALID_GEOSNAME | FTEF_DIFFERENT_FILES
 *          { FTExistFilesValue }
 ---------------------------------------------------------------------------*/
typedef enum {
    FTEF_YES,
    FTEF_NO,
    FTEF_INVALID_DOSNAME,
    FTEF_INVALID_GEOSNAME,
    FTEF_DIFFERENT_FILES
    } FTExistFilesValue;

/* Boolean FileToolExistFile(char *name); */
#define FileToolExistFile(name) (FileToolExistFileGD(name,0)==FTEF_YES)

extern FTExistFilesValue EXPORT  FileToolExistFileGD(char *geosName,char *dosName);

/*--------------------- FileToolCreateSubdir ---------------------
 *  Task:   Create subdirectory relative to working dir
 *      If necessary, recursive call
 *  Strategy:
 *  Return:      -1 if the path cannot be created
 *          or error code from FileCreateDir()
 *          OK: FALSE  ( == 0 )
 ---------------------------------------------------------------------------*/
extern int EXPORT FileToolCreateSubdir( char *path );

/*--------------------- FileToolCreatePath ---------------------
 *  Task:   Create a path on a data carrier
 *  Strategy:
 *  Return:     -1 if the path cannot be created
 *          or error code from FileToolCreateSubdir()
 *          OK: FALSE ( ==0 )
 ---------------------------------------------------------------------------*/
extern int EXPORT FileToolCreatePath (DiskHandle dh, char *path);

/*--------------------- FileToolGetCurrentDirName ---------------------
 Task:  Returns the name of the current dir.
 Parameter: rootFlag: TRUE  root directory is returned as "C:\"
              FALSE root directory is returned as empty string
 Return:        TRUE, the current dir is a root directory.
        FALSE if the current dir is not a root directory.
 ---------------------------------------------------------------------------*/
extern Boolean EXPORT FileToolGetCurrentDirName(char * name, Boolean rootFlag);

/* ---------------------------------------------------------------------------
    Searching directories
 ---------------------------------------------------------------------------*/

/*
FileToolEnumSubdir and FileToolEnumDirsAndFiles return a memory block,
that contains an array with the following structure (one for each found file)
*/

typedef struct {
    FileLongName    FT_SET_fileName;
    GeosFileType    FT_SET_fileType; /* GFT_xxx */
    byte        FT_SET_attrs;   /* FileAttrs FA_xxx */
    dword       FT_SET_size;
    } FTStandardEnumType;

/* the offsets are used in FileToolEnumSubdir to describe the data structure of the
   return values */
#define FT_SET_NAME_OFFSET  0
#define FT_SET_TYPE_OFFSET  (FT_SET_NAME_OFFSET+sizeof(FileLongName))
#define FT_SET_ATTR_OFFSET  (FT_SET_TYPE_OFFSET+sizeof(GeosFileType))
#define FT_SET_SIZE_OFFSET      (FT_SET_ATTR_OFFSET+1)
/* the following values can be passed as parameter flags to the
    FileToolEnum~ routines
    FT_EF_DIRS and FT_EF_FILES find links only if FT_EF_LINKS
    was also passed.
    At least FT_EF_DIRS or FT_EF_FILES must be passed.
*/

/* FileToolEnumFlags */
#define FT_EF_DIRS  1
#define FT_EF_FILES 2
#define FT_EF_LINKS 4
#define FT_EF_LINKS_ONLY    8
#define FT_EF_SORT  16
/* Examples:    All files and subdirs, including links, sorted:
            FT_EF_DIRS | FT_EF_FILES | FT_EF_LINKS | FT_EF_SORT
        Only file links:
            FT_EF_FILES | FT_EF_LINKS_ONLY
        Only directories, no directory links
            FT_EF_DIRS
        */


/*--------------------- FileToolEnumSubdir ---------------------
    Search a directory. For each file that matches flags,
    a structure FTStandardEnumType is returned in the allocated
    memory mh
    - flags determines whether directories (FT_EF_DIRS), files (FT_EF_FILES)
      and links (FT_EF_LINKS, FT_EF_LINKS_ONLY) should be found
      Combination with | (e.g. FT_EF_FILES | FT_EF_DIRS) is allowed
      : FT_EF_LINKS | FT_EF_LINKS_ONLY == FT_EF_LINKS_ONLY
      : FT_EF_SORT causes sorting of the files (directories
        first), but for large directories this takes a long time!
    Return: Number of files found
 ---------------------------------------------------------------------------*/
extern int EXPORT FileToolEnumSubdir (MemHandle * mh, word flags);

/*--------------------- FileToolExtendedEnumSubdir ---------------------
    Search a directory. For each file that matches flags,
    a structure is returned in the allocated memory mh,
    which is described by returnDesc and returnSize.
    - returnDesc is passed directly via the field FEP_returnAttrs
      and returnSize via FEP_returnSize to FileEnum()
    - Description of the layout of returnDesc: Concepts, File System, p.656
    - flags determines whether directories (FT_EF_DIRS), files (FT_EF_FILES)
      and links (FT_EF_LINKS, FT_EF_LINKS_ONLY) should be found
      Combination with | (e.g. FT_EF_FILES | FT_EF_DIRS) is allowed
      : FT_EF_LINKS | FT_EF_LINKS_ONLY == FT_EF_LINKS_ONLY
    Return: Number of files found
 ---------------------------------------------------------------------------*/
extern int EXPORT FileToolExtendedEnumSubdir(MemHandle * mh, word flags,
        FileExtAttrDesc * returnAttrs, word returnSize);

/*--------------------- FileToolExtEnumSubdirWithSkip ---------------------
 *  Search a directory. Functionally like
 *  FileToolExtendedEnumSubdir(), but with the possibility to specify the number
 *  of files to skip and to return the number of files not analyzed.
 *  This makes it possible to process a directory completely, even in steps.
 *  Unlike FileToolExtendedEnumSubdir(), no error box is displayed
 *  if not all files can be processed.
 *  Parameter:   - See FileToolExtendedEnumSubdir()
 *           - skipCount: number of files to skip
 *           - noFitCount: number of files not analyzed
 *  Return: Number of files found
 *      *mh: handle of the block with the array according to returnAttrs
 *           NullHandle if number == 0
 ---------------------------------------------------------------------------*/
extern int EXPORT FileToolExtEnumSubdirWithSkip(MemHandle * mh, word flags,
        FileExtAttrDesc * returnAttrs, word returnSize,
        word skipCount, word *noFitCount);

/*--------------------- FileToolEnumDirsAndFiles ---------------------
    Search a directory.
    First, the directory is searched with FileToolEnumSubdir, then
    the found entries of type FTStandardEnumType
    are sorted (directories first), stored in a memory block,
    and the corresponding handle is returned.
    - For flags, only FT_EF_LINKS, FT_EF_LINKS_ONLY or FT_EF_SORT
      are valid, other flags are ignored

    Return: Total number of entries found (files+dirs)
        (-1) if a memory block could not be created
 ---------------------------------------------------------------------------*/
extern int EXPORT FileToolEnumDirsAndFiles( MemHandle * mh, int * dirCount,
                                word flags);

/*--------------------- FileToolSortFileEnumResult ---------------------
    Sort a search result from FileEnum().
    Goal: alphabetical display in a file list
    - Arrange directories before files (if attrOffs != (-1) )
    - Sort in alphabetical order
    mh: block returned by FileEnum
    structSize, structCount     size and number of structures in the block
    nameOffs, typeOffs      offset of the fields for FileName and
                    FileAttrs (FA_xxx), for the actual
                    comparison
    If attrOffs == (-1) -> type is ignored (or not present)
 ---------------------------------------------------------------------------*/

extern void EXPORT FileToolSortFileEnumResult( MemHandle mh,
                int structSize, int structCount,
                int nameOffs, int attrOffs);

/*--------------------- FileToolAdjustLinkDirs ---------------------
    Fix a bug in the system: FileEnum always returns ALL directories if directories
    are requested, regardless of whether they are links or not.
    -> the unnecessary directories must be hidden.

    mh: block returned by FileEnum
    structSize, structCount     size and number of structures in the block
    flags               flags as passed to the DirListEnumXXXX
                    routines
    attrOffs            offset of the field FileAttrs (FA_xxx),
                    for the actual comparison
 ---------------------------------------------------------------------------*/
extern int EXPORT FileToolAdjustLinkDirs( MemHandle *mh,
                int structSize, int structCount,
                int flags, int attrOffset);


/*###########################################################################
 #  Reading and writing files
 ###########################################################################*/

/*---------------------------------------------------------------------------
 *  FileToolCopyFlags: determine behavior when copying files
 ---------------------------------------------------------------------------*/
// Message on error? Is format mismatch an error?
#define FT_CF_MSG_ON_ERROR  1
#define FT_CF_FORMAT_MISM_IS_NO_ERR  2
// Read-only files: skip or ask?
#define FT_CF_RO_ASK        4
#define FT_CF_RO_SKIP       8
// Replace existing files ... ask when:
#define FT_CF_FILE_BY_FILE      0x10
#define FT_CF_FILE_BY_LINK      0x20
#define FT_CF_LINK_BY_FILE      0x40
#define FT_CF_LINK_BY_LINK  0x80
// Decision whether to return an error message on user cancel and RO_SKIP
#define FT_CF_USER_CANCEL_RETURN_ERROR  0x100
#define FT_CF_RO_SKIP_RETURN_ERROR  0x200

// Since a possible query for deleting system files exists,
// the corresponding value for the CopyFlags must be blocked, otherwise
// the handling of the "Yes, all" button does not work
#define CF_USED_BY_DELETE_FLAGS         0x400

// default_ask asks if target exists and again if it is RO
#define FT_CF_DEFAULT_ASK   ( FT_CF_MSG_ON_ERROR | FT_CF_RO_ASK \
                | FT_CF_FILE_BY_FILE | FT_CF_FILE_BY_LINK )

// default only asks if the target is to be replaced by a link
#define FT_CF_DEFAULT       ( FT_CF_MSG_ON_ERROR | FT_CF_FILE_BY_LINK )

/*---------------------------------------------------------------------------
 *     FTYesAllStruct:  Support for the "Yes, all" button when copying,
 *              moving and deleting files
 *          Also support for "Cancel"
 ---------------------------------------------------------------------------*/
typedef struct {
    word    supportedYesAllTrigger; /* For which query should a
                     * "Yes, all" button appear
                     * Prerequisite: the corresponding
                     * FT..ASK flag is set */
    word    pressedYesAllTrigger;   /* Return info: Which "Yes, all"
                     * buttons were pressed by the user? */
    word    flagsModified;      /* How must the flags look on the next
                     * call so that the pressed
                     * "Yes, all" buttons are correctly considered.
        * If no "Yes, all" button was pressed, this field
        * only contains a copy of the passed flags */

    /* Support "Cancel" via two booleans, not via
     * returned error message (for compatibility) */
    Boolean hasCancelTrigger;   /* "Cancel button" present? */
    Boolean cancelTriggerPressed;   /* "Cancel" was pressed */

    word    reserveUnused[8];   /* In case I think of something later */

    } FTYesAllStruct;

#define InitYesAllStruct(yas, triggers, enableCancelTrigger)      { \
    memset(&yas, 0, sizeof(FTYesAllStruct)); \
    yas.supportedYesAllTrigger = triggers;  \
    yas.hasCancelTrigger = enableCancelTrigger; }


/* For passing in supportedYesAllTrigger and return in pressedYesAllTrigger:
 * The bits must match the associated FT_CF_Flags
 * Too many passed flags (invalid, e.g. for ..Delete() ) are ignored
 *  available flags:                valid for:  */
#define FT_YES_ALL_FILE_BY_FILE      FT_CF_FILE_BY_FILE /* Copy, Move */
#define FT_YES_ALL_FILE_BY_LINK      FT_CF_FILE_BY_LINK /* Copy, Move */
#define FT_YES_ALL_LINK_BY_FILE      FT_CF_LINK_BY_FILE /* Copy, Move */
#define FT_YES_ALL_LINK_BY_LINK      FT_CF_LINK_BY_LINK /* Copy, Move */
#define FT_YES_ALL_FORMAT_MISMATCH   FT_CF_FORMAT_MISM_IS_NO_ERR /* Copy, Move */
#define FT_YES_ALL_READ_ONLY         FT_CF_RO_ASK   /* Copy, Move, Delete */
#define FT_YES_ALL_DELETE_SYSTEM     FT_DF_SYSTEM_ASK   /* Delete */

#define FT_YES_ALL_ALL           0xFFFF /* always works */


/*--------------------- FileToolCopyFile ---------------------
 *  Task:   Copy a file with error handling strategy
 *  Note:   ERROR_FORMAT_MISMATCH - handling
 *      - it is a normal error, but is queried separately
 *        -> user can force overwrite.
 *      - if FT_CF_FORMAT_MISM_IS_NO_ERR is set, it is not
 *        considered an error: the target is automatically deleted
 *        before the copy attempt (otherwise FileCopy() complains)
 *        If deletion fails, there is NO message about it,
 *        instead the routine behaves as if
 *        FT_CF_FORMAT_MISM_IS_NO_ERR is not set (i.e. dumb
 *        message to the user or main program)
 *  Strategy:
 *  Parameter:
 *  Return:     Error code (FALSE if all OK)
 *          User cancel on query returns:
 *              if FT_CF_USER_CANCEL_RETURN_ERROR is set:
 *                  ERROR_CANCELED_BY_USER (-1)
 *              else    Null (FALSE)
 *          Skipped RO file returns
 *              if FT_CF_RO_SKIP_RETURN_ERROR is set:
 *                  ERROR_RO_SKIPPED (-2)
 *              else    Null (FALSE)
 ---------------------------------------------------------------------------*/
extern int EXPORT FileToolCopyFile(char * sourceFile, char * destFile,
        DiskHandle sdh, DiskHandle ddh, word flags,
        FTYesAllStruct *yas);


/*--------------------- FileToolMoveFile ---------------------
 *  Task:   Move a file with error handling strategy
 *  Strategy:   First, FileToolCopyFile is executed and if that
 *      was successful, the file is deleted.
 *  Note:   FileToolCopyFlags are passed as flags
 *      and suitable DeleteFlags are converted for deletion
 *  Parameter:
 *  Return:     Error code (FALSE if all OK)
 *          User cancel on query returns:
 *              if FT_CF_USER_CANCEL_RETURN_ERROR is set:
 *                  ERROR_CANCELED_BY_USER (-1)
 *              else    Null (FALSE)
 *          Skipped RO file returns
 *              if FT_CF_RO_SKIP_RETURN_ERROR is set:
 *                  ERROR_RO_SKIPPED (-2)
 *              else    Null (FALSE)
 ---------------------------------------------------------------------------*/
extern int EXPORT FileToolMoveFile(char * sourceFile, char * destFile,
        DiskHandle sdh, DiskHandle ddh, word flags,
        FTYesAllStruct *yas);

/*--------------------- FileToolRequestDisk ---------------------
 *  Task:   Request a new, non-empty disk,
 *      with warning if minSpace is not met
 *  Parameter:  lwNr: drive number
 *          freeSpace: free space on new disk
 *          minSpace: minimum space on disk, zero if doesnt matter
 *              if not met, a warning is given
 *              and the option to insert another disk
 *  Return:     DiskHandle of the new disk
 *          NullHandle if user chooses cancel
 ---------------------------------------------------------------------------*/
extern DiskHandle EXPORT FileToolRequestDisk(int lwNr, dword *freeSpace,
                        dword minSpace);

/*--------------------- FileToolDeleteFileNA ---------------------
 *  Task:   Delete a file without asking
 *  Return:     TRUE if OK
 *          FALSE (error number) if not OK
 ---------------------------------------------------------------------------*/
//int FileToolDeleteFileNA(char *fileName); - Macro, defined below

/*--------------------- FileToolDeleteFile ---------------------
 *  Task:   Delete a file comfortably
 *  Strategy:      Flags control the behavior
 *          FT_DF_DEFAULT
 *              RO files are also deleted
 *              No error message if file not found
 *          FT_DF_RO_SKIP
 *              RO files are not deleted. If this flag
 *              is set, FT_DF_RO_ASK is ignored!
 *          FT_DF_RO_ASK | FT_DF_NOT_FOUND_ASK
 *              Ask for read-only or not found
 *              "Delete all" button is not yet
 *                  supported
 *          FT_DF_MSG_ON_ERR
 *              In case of error, not only the error number
 *              is returned but also an info box
 *              is opened indicating the failure.
 *              This saves the main program from doing it.
 *  Return:     TRUE if error
 *          -> Error number from FileDelete();
 *          FALSE if deletion OK
 *              or user has chosen cancel
 ---------------------------------------------------------------------------*/
typedef WordFlags FileToolDeleteFlags;  // FT_DF_xxx
// Ask for read-only files or if file not found
#define FT_DF_NOT_FOUND_ASK 1
#define FT_DF_RO_SKIP       2
#define FT_DF_RO_ASK        4   /* identical to FT_CF_RO_ASK */
#define FT_DF_MSG_ON_ERR    8
#define FT_DF_NOT_FOUND_IS_ERROR  0x10
#define FT_DF_SYSTEM_ASK    CF_USED_BY_DELETE_FLAGS    /* =0x400, hidden or system */

// Default value: delete RO files and ignore not-found (== OK)
#define FT_DF_DEFAULT       (0)

extern int EXPORT FileToolDeleteFile(char * fileName,
    FileToolDeleteFlags flags, FTYesAllStruct *yas);

#define FileToolDeleteFileNA(fileName) FileToolDeleteFile(fileName, FT_DF_DEFAULT, 0)

/*****************************************************************************
 *  $ID New FileCopy/Move/Delete API in version 1.8
 *  I had to think hard to get back into the ideas behind the
 *  FT_CF_ and FT_DF_ values and the YAS ideas - with the
 *  result that they are complex and not really suitable for R-BASIC
 *      --> its easier to make a second API
 *****************************************************************************/
/* FileCopy always returns FILE_NOT_FOUND when trying to copy a link
 * If I ever work around this, I can set this define to 1 */
#define     EASY_CAN_COPY_MOVE_LINK     0

typedef enum {
    /* Useful for Copy, Move and Delete: */
    ECDF_MSG_ON_ERROR =     1,  /* otherwise only set error code */
    ECDF_RO_FORCES_ERROR =      2,  /* target is write-protected */
    ECDF_HIDDEN_SYS_FORCES_ERROR =  4,    /* target is hidden or system */

    /* Useful only for Copy and Move (ignored by Delete) */
    ECDF_TYPE_MISMATCH_FORCES_ERROR = 8,  /* overwrite DOS <--> GEOS file */

        /* The FORCES_ERROR flags have absolute priority,
         * even over the OVERWRITE flags
         * If I want to block other file types from being safely overwritten / deleted,
         * I have to do it myself beforehand */

    /* Reserved: Copy and Move currently cannot handle links,
     * (due to system FileCopy)
     * Bit 0x10 is still ignored by the Easy routines
    CAN_COPY_MOVE_LINK      0x10
     * Whether it makes sense to handle this later via a reserved bit,
     * I dont know yet - but a reserve cant hurt */

    /* Useful only for Delete (ignored by Copy and Move) */
    ECDF_NOT_FOUND_IS_ERROR =   0x20,

    /* Specify which file types can be deleted
     * without asking */
    ECDF_OVERWRITE_TYPE_MISMATCH =  0x40,
    ECDF_OVERWRITE_EXEC =       0x80,   /* GEOS Executables */
    ECDF_OVERWRITE_VM =         0x100,
    ECDF_OVERWRITE_DATA =       0x200,
    ECDF_OVERWRITE_LINK =       0x400,
    ECDF_OVERWRITE_DOS =        0x800,

    ECDF_OVERWRITE_RO =     0x1000,
    ECDF_OVERWRITE_HIDDEN_SYS = 0x2000,

    /* The top two bits determine what happens if a file
     * is not automatically deleted because the OVERWRITE bits do not match.
     * --> The values are _a_l_t_e_r_n_a_t_i_v_e_l_y_ to be set */
    /* Variant 1: Return error code (ERROR_ACCESS_DENIED)*/
       ECDF_NOT_OVERWRITE_IS_ERROR =    0x4000,

    /* Variant 2: Ask, if yes: delete, if no: return OK */
       ECDF_NOT_OVERWRITE_ASK =     0x8000,

    /* Variant 3: Ask, if yes: delete,
     *  if no: error code: ERROR_CANCELED_BY_USER */
       ECDF_NOT_OVERWRITE_ASK_ERROR =   (0x8000+0x4000)

    /* Variant 4: (both bits zero) still unused */
    /* If used: possibly adjust FileToolMoveFileEasy */

    } EasyCopyDeleteFlags;

#define ECDF_NOT_OVERWRITE_MASK (0x8000 + 0x4000)

#define ECDF_DELETE_ALL ( ECDF_OVERWRITE_TYPE_MISMATCH \
        | ECDF_OVERWRITE_EXEC | ECDF_OVERWRITE_VM \
        | ECDF_OVERWRITE_DATA | ECDF_OVERWRITE_LINK \
        | ECDF_OVERWRITE_DOS | ECDF_OVERWRITE_RO \
        | ECDF_OVERWRITE_HIDDEN_SYS )


/* self-defined error codes as return values for all
 * Copy, Move and Delete routines. They are negative */
#define ERROR_CANCELED_BY_USER  (-1)
        /* ^- "No" pressed on query
         * For Easy routines: always
         * For FileToolMove/CopyFile: only if
         * FT_CF_USER_CANCEL_RETURN_ERROR is set */
#define ERROR_RO_SKIPPED    (-2)
        /* ^- Only for FileToolMove/CopyFile: RO skipped and
         * FT_CF_RO_SKIP_RETURN_ERROR is set */
#define ERROR_CANNOT_COPY_FOLDERS       (-3)
#define ERROR_FILE_CANNOT_REPLACE_FOLDER    (-4)
#define ERROR_CANNOT_DELETE_FOLDERS     (-5)
        /* ^- Only for Easy routines. FileToolDeleteFile returns FILE_NOT_FOUND */
#define ERROR_CANNOT_COPY_MOVE_LINK     (-6)

/*--------------------- FileToolDeleteFileEasy ---------------------
 *  Task:   Delete a file comfortably with a simple API
 *      "Yes, all" is currently not supported, must
 *      be added in a new library version if needed
 *  Strategy:      Flags control the behavior
 *  Return:     Error flag:
 *          FALSE (==0) OK
 *          TRUE  ( >0) error code from FileRead() or FileWrite()
 *          TRUE (-1)   ERROR_CANCELED_BY_USER
 *                  ECDF_NOT_OVERWRITE_ASK_ERROR is set
 *                  and user answers NO on query
 *               (-2)   Not returned: ERROR_RO_SKIPPED
 *                  (compatibility with old routine)
 *               (-3)   Not returned: ERROR_CANNOT_COPY_FOLDERS
 *               (-4)   Not returned: ERROR_FILE_CANNOT_REPLACE_FOLDER
 *               (-5)   ERROR_CANNOT_DELETE_FOLDERS
 ---------------------------------------------------------------------------*/
extern int EXPORT FileToolDeleteFileEasy(char * fileName, EasyCopyDeleteFlags flags);


/*--------------------- FileToolCopyFileEasy ---------------------
 *  Task:   Copy a file comfortably with a simple API
 *      "Yes, all" is currently not supported, must
 *      be added in a new library version if needed
 *  Strategy:      Flags control the behavior
 *  Return:     Error flag:
 *          FALSE (==0) OK
 *          TRUE  ( >0) error code from FileRead() or FileWrite()
 *          TRUE (-1)   ERROR_CANCELED_BY_USER
 *                  ECDF_NOT_OVERWRITE_ASK_ERROR is set
 *                  and user answers NO on query
 *               (-2)   Not returned: ERROR_RO_SKIPPED
 *                  (compatibility with old routine)
 *               (-3) ERROR_CANNOT_COPY_FOLDERS
 *               (-4) ERROR_FILE_CANNOT_REPLACE_FOLDER
 *               (-5) Not returned: ERROR_CANNOT_DELETE_FOLDERS
 ---------------------------------------------------------------------------*/
extern int EXPORT FileToolCopyFileEasy(char * sourceFile, char * destFile,
        DiskHandle sdh, DiskHandle ddh, EasyCopyDeleteFlags flags);


/*--------------------- FileToolMoveFileEasy ---------------------
 *  Task:   Move a file comfortably with a simple API
 *      "Yes, all" is currently not supported, must
 *      be added in a new library version if needed
 *  Strategy:      Flags control the behavior
 *  Return:     Error flag:
 *          FALSE (==0) OK
 *          TRUE  ( >0) error code from FileRead() or FileWrite()
 *          TRUE (-1)   ERROR_CANCELED_BY_USER
 *                  ECDF_NOT_OVERWRITE_ASK_ERROR is set
 *                  and user answers NO on query
 *               (-2)   Not returned: ERROR_RO_SKIPPED
 *                  (compatibility with old routine)
 *               (-3) ERROR_CANNOT_COPY_FOLDERS
 *               (-4) ERROR_FILE_CANNOT_REPLACE_FOLDER
 *               (-5) Not returned: ERROR_CANNOT_DELETE_FOLDERS
 ---------------------------------------------------------------------------*/
extern int EXPORT FileToolMoveFileEasy(char * sourceFile, char * destFile,
        DiskHandle sdh, DiskHandle ddh, EasyCopyDeleteFlags flags);


/*****************************************************************************
 *  $ID
 *****************************************************************************/

/*--------------------- FileToolInsertBuffer ---------------------
 *  Task:        Inserts a buffer at the current position in a file
 *  Strategy:   The file is first extended by the size of the buffer,
 *      then the old file content is shifted "from back to front"
 *      and finally the actual buffer is written
 *  Parameter:  int ( FileHandle fh, void *buf, word bufSize,
 *                  char * fileNameForErrorMsg)
 *       fh     Handle of the file
 *       buf    Pointer to the buffer to be inserted
 *       bufSize    Size of the buffer
 *       fileNameForErrorMsg
 *          Pointer to the file name, if a message should be
 *          displayed in case of errors.
 *          NullPointer if no error messages should be displayed
 *          msgOnError: TRUE if a message box
 *          "Error writing to..." should appear on error
 *  Side effect:    The file pointer is moved to the position after the
 *      inserted buffer
 *  Return:     Error flag:
 *          FALSE (==0) OK
 *          TRUE  ( >0) error code from FileRead() or FileWrite()
 *          TRUE (-1) No more memory available (MemAlloc failed)
 ---------------------------------------------------------------------------*/

extern int EXPORT FileToolInsertBuffer ( FileHandle fh, void *buf, word bufSize,
            char * fileNameForErrorMsg);

/*--------------------- FileToolDeleteRange ---------------------
 *  Task:   Delete a range from a file at the
 *      current position of the file pointer
 *      The file pointer is not changed
 *  Strategy:   Ranges are copied blockwise from front to back,
 *      then the file is truncated.
 *  Parameter:      Boolean (FileHandle fh, dword range,
 *                  char * fileNameForErrorMsg)
 *       fh     Handle of the file
 *       range      Number of bytes to be deleted from the file
 *       fileNameForErrorMsg
 *          Pointer to the file name, if a message should be
 *          displayed in case of errors.
 *          NullPointer if no error messages should be displayed
 *  Return:     Error flag:
 *          FALSE (==0) OK
 *          TRUE  ( >0) error code from FileRead() or FileWrite()
 *          TRUE (-1) No more memory available (MemAlloc failed)
 ---------------------------------------------------------------------------*/
extern Boolean EXPORT FileToolDeleteRange (FileHandle fh, dword range,
                    char * fileNameForErrorMsg);

/*--------------------- FileToolReplaceBuffer ---------------------
 *  Task:   Replaces a range at the current file position
 *      with a new one
 *  Parameter:  Boolean (fh, *buffer, oldSize, bufSize, msgOnError)
 *       fh     Handle of the file
 *       buffer Pointer to the buffer to be inserted
 *       oldSize    Size of the area to be overwritten
 *       bufSize    Size of the new area
 *       fileNameForErrorMsg
 *          Pointer to the file name, if a message should be
 *          displayed in case of errors.
 *          NullPointer if no error messages should be displayed
 *  Side effect:    The file pointer is moved to the position after the
 *      inserted buffer
 *  Return:     Error flag:
 *          FALSE (==0) OK
 *          TRUE  ( >0) error code from FileRead() or FileWrite()
 *          TRUE (-1) No more memory available (MemAlloc failed)
 ---------------------------------------------------------------------------*/
extern Boolean EXPORT FileToolReplaceBuffer(FileHandle fh, void * buffer,
             word oldSize, word bufSize, char * fileNameForErrorMsg);

/*--------------------- FileToolRenameFile ---------------------
 *  Task:   Rename a file
 *      with error message if desired
 *  Parameter:      Boolean ( char *oldName, *newName, Boolean msgOnError)
 *  Side effect:   possibly the directory is changed
 *      any file selectors could be prompted to rescan
 *      and possibly lose their selection
 *  Return:     Error flag:
 *          FALSE (==0) OK
 *          TRUE  ( >0) error code from FileRename();
 ---------------------------------------------------------------------------*/
extern Boolean EXPORT FileToolRenameFile( char * oldName,char *newName, Boolean msgOnError);

/*--------------------- FileToolRenameFileNoRetry ---------------------
 *  Task:   Rename a file, but user is not allowed
 *      to search for the file or fix access violations
 *      with error message if desired
 *  Parameter:      Boolean ( char *oldName, *newName, Boolean msgOnError)
 *  Return:     Error flag:
 *          FALSE (==0) OK
 *          TRUE  ( >0) error code from FileRename();
 ---------------------------------------------------------------------------*/
extern Boolean EXPORT FileToolRenameFileNoRetry( char * oldName,char *newName, Boolean msgOnError);

/*--------------------- FileToolModifyDosName ---------------------
 *  Task:   Change the DOS name of a file
 *      Geos files get a different DOS name
 *      DOS files are renamed
 *      with error message if desired
 *  Warning:    The new DOS name of the GEOS file is NOT checked
 *      for validity
 *  Parameter:      Boolean ( char *oldName, *newName, Boolean msgOnError)
 *          oldName can be the Geos or DOS name for Geos files
 *  Side effect:   possibly the directory is changed
 *      any file selectors could be prompted to rescan
 *      and possibly lose their selection
 *  Return:     Error flag:
 *          FALSE (==0) OK
 *          TRUE  ( >0) error code from FileRename();
 ---------------------------------------------------------------------------*/
extern Boolean EXPORT FileToolModifyDosName( char * oldName,char *newName, Boolean msgOnError);

/*--------------------- FileToolModifyDosNameNoRetry ---------------------
 *  Task:   Change the DOS name of a file, but user cannot
 *      search for the file or fix access problems
 *      with error message if desired
 *  Return:     Error flag:
 *          FALSE (==0) OK
 *          TRUE  ( >0) error code from FileRename();
 ---------------------------------------------------------------------------*/
extern Boolean EXPORT FileToolModifyDosNameNoRetry( char * oldName,char *newName, Boolean msgOnError);

/*--------------------- FileToolSetExtAttr ---------------------
 *  Task:   Change an extended attribute via
 *      FileSetPathExtAttributes with error handling
 *      RO files can also be handled
 *  Parameter:      Boolean ( char * fileName,  // file name
 *              word feaToSet,      // FEA_xx constant
 *              void * buffer,      // value of the attribute
 *              word attrSize,      // size of the attribute
 *              Boolean msgOnError) // TRUE if an error message
 *                          // should be displayed automatically
 *  Return:     Error flag:
 *          FALSE (==0) OK
 *          TRUE  ( >0) error code from FileSetPathExtAttributes();
 ---------------------------------------------------------------------------*/
extern Boolean EXPORT FileToolSetExtAttr( char * fileName,word feaToSet, void * buffer, word attrSize, Boolean msgOnError);



/*--------------------- FileToolReadLine ---------------------
/*--------------------- FileToolReadLine2 ---------------------
 *  Read a text line from a file
 *      -Line end 0D, 0A, 0A0D or 0D0A
 *      -File pointer is set to 1st character after line
 *      -bufSize must be at least 2 (1 character read + terminator)
 *
 *  FileToolReadLine2 additionally returns what terminated the line
 *
 *  Return  FTRL_OK | FTRL_EOF | FTRL_NO_LINE | FTRL_ERROR
 ---------------------------------------------------------------------------*/

typedef enum {
    FTRL_OK,    // line found
    FTRL_EOF,   // end of file
    FTRL_NO_LINE,   // line end not found (e.g. line too long)
    FTRL_ERROR  // data error, parameter error, etc.
    } FTReadLineReturnValue;


extern FTReadLineReturnValue EXPORT FileToolReadLine
        ( FileHandle file, char * line, word bufSize );

extern FTReadLineReturnValue EXPORT FileToolReadLine2
        ( FileHandle file, char * line, word bufSize, word *terminator );

/*--------------------- FileToolTrimLine ---------------------
 *  Remove all leading and trailing spaces or tabs
 *      from a string
 ---------------------------------------------------------------------------*/
extern void EXPORT FileToolTrimLine(char * line);

/****************************************************************************
 *
 *  Support for files from which data should only be read in chunks.
 *  For performance reasons, much more data is read at once and
 *  cached. The request can then usually be satisfied from the buffer.
 *
 *****************************************************************************/

typedef struct {
    FileHandle  file;
    byte    *buffer;        // Buffer for reading from the file
    byte    *nextByte;      // current position in the buffer
    byte    *extraBuffer;       // additional buffer for data decompression
                    // Null if not present
    word    bufferSize;
    int bytesLeft;      // int, so that in case of error subtraction
                    // can result in negative values, which
                    // lead to abort
    } FileBufferStruct;

/*--------------------- FTCreateFileBuffer ---------------------
 *  Task:   Create a buffer structure to read data from a
 *      file more efficiently
 *  Parameter:      fh : handle of the open file
 *          fbPtr:  pointer to the buffer structure
 *          extraSize: size of the extra buffer, which can be used
 *              as workspace for decompression, for example
 *  return:     Error flag: TRUE if the buffer could not be created
 *          FALSE: all OK
 ---------------------------------------------------------------------------*/
extern Boolean EXPORT FTCreateFileBuffer(FileHandle fh, FileBufferStruct *fbPtr, int extraSize);

/*--------------------- FTReadBufferedFile ---------------------
 *  Task:   Read data from a buffered file.
 *      Refill the buffer if necessary
 *  Parameter:  fbPtr:  pointer to the buffer structure
 *          dest:   pointer to where to put the data
 *          count:  how many bytes
 *  Return:     Number of bytes copied
 ---------------------------------------------------------------------------*/
extern int EXPORT FTReadBufferedFile(FileBufferStruct *fbPtr, byte *dest, int count);

/*--------------------- FTGetFilePosAtBufferedPosition ---------------------
 *  Task:   Calculate the file position corresponding to the current
 *      position of the pointer fbPtr->nextByte
 *  Parameter:  fbPtr:  pointer to the buffer structure
 *  Return:
 ---------------------------------------------------------------------------*/
extern dword EXPORT FTGetFilePosAtBufferedPosition(FileBufferStruct *fbPtr);

/*--------------------- FTBufferedFileSkip ---------------------
 *  Task:   Skip a number of bytes without copying them anywhere
 *  Parameter:  fbPtr:  pointer to the buffer structure
 *          count:  number to skip
 *  Return:     Error flag: FALSE: all OK, data skipped
 *                  It holds: fbPtr->bytesLeft >= 0
 *                  The case == 0 occurs when the data to
 *                  be skipped exactly reaches the end of file.
 *              TRUE: end of file: rest of file is too short
 *                  It holds: fbPtr->bytesLeft == 0
 *                       fbPtr->nextByte is invalid.
 ---------------------------------------------------------------------------*/
extern Boolean EXPORT FTBufferedFileSkip(FileBufferStruct *fbPtr, word count);

/*--------------------- FTDestroyFileBuffer ---------------------
 *  Task:   Destroy buffer structure. The file is not closed
 *  Parameter:      fbPtr:  pointer to the buffer structure
 ---------------------------------------------------------------------------*/
extern void EXPORT FTDestroyFileBuffer(FileBufferStruct *fbPtr);


/*--------------------- FTBufferedFileRefill ---------------------
 *  Task:        Refill empty buffer
 *      Outsourced action for optimization.
 *  Parameter:
 *  Return:
 ---------------------------------------------------------------------------*/
#define FTBufferedFileRefill(fbPtr) { (fbPtr)->bytesLeft = \
    FileRead((fbPtr)->file, (fbPtr)->buffer, (fbPtr)->bufferSize, FALSE); \
    (fbPtr)->nextByte = (fbPtr)->buffer; }

/*--------------------- FTBufferedFileGetByte ---------------------
     *  Task:        Get one byte, optimized
 *  Parameter:      fbPtr: pointer to FileBufferStruct
 *          aByte:  byte variable
 ---------------------------------------------------------------------------*/
#define FTBufferedFileGetByte(fbPtr, aByte) { aByte = *((fbPtr)->nextByte); \
    (fbPtr)->nextByte++;    \
    (fbPtr)->bytesLeft--;   \
    if ( (fbPtr)->bytesLeft <= 0 ) FTBufferedFileRefill(fbPtr); }


/*###########################################################################
 #  End of the library
 ###########################################################################*/

@endlib