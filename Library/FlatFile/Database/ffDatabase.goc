/***********************************************************************
 *
 *	copyright (c) Geoworks 1992 -- All Rights Reserved
 *
 * PROJECT:	GEOS
 * MODULE:	FlatFile/Database
 * FILE:	ffDatabase.goc
 *
 * AUTHOR:  	Jeremy Dashe : Jan 24, 1992
 *
 * DESCRIPTION:
 *	This file holds code for the flat file database object.
 *
 * RCS STAMP:
 *	$Id: ffDatabase.goc,v 1.1 97/04/04 18:03:11 newdeal Exp $
 *
 ***********************************************************************/

@include <stdapp.goh>
#include <geoworks.h>
#include <system.h>

#include <Ansi/stdio.h>
#include <Ansi/string.h>

#include <chunkarr.h>
#include <ec.h>
@include <Objects/FlatFile/ffileC.goh>
#include <Objects/FlatFile/ffTChst.h>
@include <Objects/FlatFile/ffDbase.goh>
@include <Objects/Text/tCtrlC.goh>
@include <Objects/uiInputC.goh>
@include <Objects/vTextC.goh>
@include <Objects/vCntC.goh>
@include <math.goh>
#include <cell.h>
#include <char.h>
#include <input.h>
#include <parse.h>
@include <ffile.goh>
@include <grobj.goh>
#include <extern.h>
#include <ffFatal.h>
@include <Objects/FlatFile/ffRecC.goh>
#include <Objects/FlatFile/ffKbd.h>
#include <extern.h>
#include <Database/ffdExtrn.h>

#define FFD_CURRENT_RECORD(x)   (x->FFI_showOnlyMarked ? \
				 x->FFI_currentMarkedRecord : \
				 x->SSI_active.CR_row)

/* max # of fields to move at one time, to avoid accumulating too many
   messages on thread 0 and hence running out of handles.  --- AY 8/19/93 */
#define MAX_NUM_FIELDS_TO_MOVE	20

/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		Class Declarations
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/

@classdecl	FlatFileDatabaseClass ;



/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	External Message Declarations for FlatFileDatabaseClass
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/

/*
 * The following are defined in ffDatabaseCreate.goc.
 */
@extern method FlatFileDatabaseClass,
			MSG_FFD_CREATE_NEW_FIELD_WITH_RESPONSE;
@extern method FlatFileDatabaseClass, MSG_FFD_CREATE_NEW_FIELD;
@extern method FlatFileDatabaseClass,
			MSG_FFD_CHANGE_FIELD_ATTRIBUTES_WITH_RESPONSE;
@extern method FlatFileDatabaseClass, MSG_FFD_CHANGE_FIELD_ATTRIBUTES;
@extern method FlatFileDatabaseClass, MSG_FFD_ADD_FIELD_TO_LAYOUT ;
@extern method FlatFileDatabaseClass, MSG_FFD_GET_DOCUMENT_HANDLE;
@extern method FlatFileDatabaseClass, MSG_FFD_DELETE_FIELD_FROM_LAYOUT ;
@extern method FlatFileDatabaseClass,
			MSG_FFD_DELETE_CHUNK_ELEMENT_FROM_LAYOUT; 
@extern method FlatFileDatabaseClass, MSG_FFD_REQUEST_UNIQUE_FIELD_NAME;
@extern method FlatFileDatabaseClass,
			MSG_FFD_REQUEST_UNIQUE_FIELD_NAME_WITH_RESPONSE;
@extern method FlatFileDatabaseClass, MSG_FFD_ADD_EXISTING_GROBJ_TO_LAYOUT;
@extern method FlatFileDatabaseClass, MSG_FFD_ADD_PAGE_NUMBER_TO_LAYOUT;
@extern method FlatFileDatabaseClass, 
			MSG_FFD_CREATE_DATA_BLOCK_AND_SEND_NOTIFICATION;

/*
 * The following are defined in ffDatabaseFieldOrder.goc.
 */
@extern method FlatFileDatabaseClass, MSG_FFD_FNO_INFO_SHADOW_SAVE;
@extern method FlatFileDatabaseClass, MSG_FFD_FNO_INFO_SHADOW_RESTORE;
@extern method FlatFileDatabaseClass, MSG_FFD_FNO_INFO_SHADOW_DELETE;
@extern method FlatFileDatabaseClass, MSG_FFD_FNO_INFO_GET_NUM_ITEMS;
@extern method FlatFileDatabaseClass, MSG_FFD_FNO_INFO_ADD_ITEM;
@extern method FlatFileDatabaseClass, MSG_FFD_FNO_INFO_DELETE_ITEM;
@extern method FlatFileDatabaseClass, MSG_FFD_FNO_INFO_DELETE_ALL_ITEMS;
@extern method FlatFileDatabaseClass, MSG_FFD_FNO_INFO_QUERY_ITEM;
@extern method FlatFileDatabaseClass, MSG_FFD_FNO_INFO_LIST_MONIKER_QUERY;
@extern method FlatFileDatabaseClass, MSG_FFD_FNO_INFO_GET_FIELD;
@extern method FlatFileDatabaseClass, MSG_FFD_FNO_INFO_GET_NEXT_FIELD;
@extern method FlatFileDatabaseClass, MSG_FFD_FNO_INFO_INCREASE_PRIORITY;
@extern method FlatFileDatabaseClass, MSG_FFD_FNO_INFO_DECREASE_PRIORITY;
@extern method FlatFileDatabaseClass, MSG_FFD_FNO_INFO_NUKE_FIELD;

/*
 * The following are defined in ffDatabaseFloatController.goc.
 */
@extern method FlatFileDatabaseClass, MSG_FLOAT_CTRL_REQUEST_MONIKER;
@extern method FlatFileDatabaseClass, MSG_FLOAT_CTRL_UPDATE_UI;
@extern method FlatFileDatabaseClass, MSG_FLOAT_CTRL_FORMAT_SELECTED;
@extern method FlatFileDatabaseClass, MSG_FLOAT_CTRL_USER_DEF_INVOKE;
@extern method FlatFileDatabaseClass, MSG_FLOAT_CTRL_USER_DEF_OK;
@extern method FlatFileDatabaseClass, MSG_FLOAT_CTRL_FORMAT_DELETE;
@extern method FlatFileDatabaseClass, MSG_FLOAT_CTRL_FORMAT_APPLY;
@extern method FlatFileDatabaseClass, MSG_FFD_DISPLAY_USER_DEFINED_FORMAT;

/*
 * The following are defined in ffDatabaseImpex.goc.
 */
@extern method FlatFileDatabaseClass, MSG_FFD_IMPORT_TRANSFER_FILE;
@extern method FlatFileDatabaseClass, MSG_FFD_EXPORT_TRANSFER_FILE;
@extern method FlatFileDatabaseClass, MSG_FFD_EXPORT_TO_CLIPBOARD;

/*
 * The following are defined in ffDatabaseLayout.goc.
 */
@extern method FlatFileDatabaseClass, MSG_FFD_SET_CURRENT_MODE_TO_DESIGN;
@extern method FlatFileDatabaseClass,
			MSG_FFD_SET_CURRENT_MODE_TO_DATA_ENTRY; 
@extern method FlatFileDatabaseClass, MSG_FFD_SET_CURRENT_MODE;
@extern method FlatFileDatabaseClass, MSG_FFD_GET_CURRENT_MODE;
@extern method FlatFileDatabaseClass, MSG_FFD_LOAD_FIELD_WITH_PAGE_NUMBER;
@extern method FlatFileDatabaseClass, MSG_FFD_CREATE_NEW_LAYOUT;
@extern method FlatFileDatabaseClass, MSG_FFD_GET_INDEXED_LAYOUT_NAME;
@extern method FlatFileDatabaseClass, MSG_FFD_GET_CURRENT_LAYOUT;
@extern method FlatFileDatabaseClass, MSG_FFD_GET_CURRENT_LAYOUT_INDEX;
@extern method FlatFileDatabaseClass, MSG_FFD_GET_LAYOUT_NAME;
@extern method FlatFileDatabaseClass, MSG_FFD_GET_CURRENT_LAYOUT_NAME;
@extern method FlatFileDatabaseClass, MSG_FFD_GET_LAYOUT_NUM_FROM_INDEX;
@extern method FlatFileDatabaseClass, MSG_FFD_GET_LAYOUT_NOTES;
@extern method FlatFileDatabaseClass, MSG_FFD_STORE_LAYOUT_NOTES;
@extern method FlatFileDatabaseClass, MSG_FFD_SWITCH_TO_LAYOUT;
@extern method FlatFileDatabaseClass, MSG_FFD_RENAME_LAYOUT;
@extern method FlatFileDatabaseClass, MSG_FFD_DELETE_LAYOUT;
@extern method FlatFileDatabaseClass, MSG_FFD_SET_LAYOUT_TYPE;
@extern method FlatFileDatabaseClass, MSG_FFD_GET_GROBJ_BODY_FOR_LAYOUT;
@extern method FlatFileDatabaseClass,
			MSG_FFD_GET_GROBJ_BODIES_FOR_CURRENT_LAYOUT;
@extern method FlatFileDatabaseClass, MSG_FFD_GET_LAYOUT_TYPE;
@extern method FlatFileDatabaseClass, MSG_FFD_INIT_SINGLE_RECORD_LAYOUT;
@extern method FlatFileDatabaseClass, MSG_FFD_INIT_MULTI_RECORD_LAYOUT;
@extern method FlatFileDatabaseClass, MSG_FFD_SET_RECORD_ORDER_FOR_LAYOUT;
@extern method FlatFileDatabaseClass,
			MSG_FFD_SET_RECORD_ORDER_FOR_CURRENT_LAYOUT;
@extern method FlatFileDatabaseClass, MSG_FFD_GET_RECORD_ORDER_FOR_LAYOUT;
@extern method FlatFileDatabaseClass, 
			MSG_FFD_GET_RECORD_ORDER_FOR_CURRENT_LAYOUT;
@extern method FlatFileDatabaseClass, MSG_FFD_SET_SINGLE_RECORD_BOUNDS;
@extern method FlatFileDatabaseClass, MSG_FFD_GET_SINGLE_RECORD_BOUNDS;
@extern method FlatFileDatabaseClass, MSG_FFD_SET_MULTI_RECORD_BOUNDS;
@extern method FlatFileDatabaseClass, MSG_FFD_GET_MULTI_RECORD_BOUNDS;
@extern method FlatFileDatabaseClass, MSG_FFD_SET_PAGE_BOUNDS;
@extern method FlatFileDatabaseClass, MSG_FFD_GET_PAGE_BOUNDS;
@extern method FlatFileDatabaseClass, MSG_FFD_REDRAW_MULTI_RECORD;
@extern method FlatFileDatabaseClass, MSG_FFD_SWITCH_TO_INDEXED_LAYOUT;
@extern method FlatFileDatabaseClass, MSG_FFD_SET_MULTI_RECORD_WITHIN_MARGINS;

/*
 * The following are defined in ffDatabaseMeta.goc.
 */
@extern method FlatFileDatabaseClass, MSG_VIS_DRAW;
@extern method FlatFileDatabaseClass, MSG_META_INITIALIZE;
@extern method FlatFileDatabaseClass, MSG_META_KBD_CHAR;
@extern method FlatFileDatabaseClass, MSG_META_LARGE_PTR;
@extern method FlatFileDatabaseClass, MSG_META_LARGE_START_SELECT;
@extern method FlatFileDatabaseClass, MSG_META_LARGE_END_SELECT;
@extern method FlatFileDatabaseClass, MSG_META_LARGE_START_MOVE_COPY;
@extern method FlatFileDatabaseClass, MSG_META_LARGE_END_MOVE_COPY;
@extern method FlatFileDatabaseClass, MSG_META_LARGE_START_FEATURES;
@extern method FlatFileDatabaseClass, MSG_META_LARGE_END_FEATURES;
@extern method FlatFileDatabaseClass, MSG_META_LARGE_START_OTHER;
@extern method FlatFileDatabaseClass, MSG_META_LARGE_END_OTHER;
@extern method FlatFileDatabaseClass, MSG_META_LARGE_DRAG_SELECT;
@extern method FlatFileDatabaseClass, MSG_META_LARGE_DRAG_FEATURES;
@extern method FlatFileDatabaseClass, MSG_META_LARGE_DRAG_MOVE_COPY;
@extern method FlatFileDatabaseClass, MSG_META_LARGE_DRAG_OTHER;
@extern method FlatFileDatabaseClass,
			MSG_META_CONTENT_VIEW_SCALE_FACTOR_CHANGED;
@extern method FlatFileDatabaseClass, MSG_META_MUP_ALTER_FTVMC_EXCL;
@extern method FlatFileDatabaseClass, MSG_META_FUP_KBD_CHAR;
@extern method FlatFileDatabaseClass, MSG_META_GAINED_TARGET_EXCL,
				      MSG_META_GAINED_SYS_TARGET_EXCL,
				      MSG_META_LOST_SYS_TARGET_EXCL;
@extern method FlatFileDatabaseClass, MSG_META_LOST_TARGET_EXCL;
@extern method FlatFileDatabaseClass, MSG_META_GET_TARGET_EXCL;
@extern method FlatFileDatabaseClass, MSG_META_GAINED_FOCUS_EXCL,
				      MSG_META_LOST_FOCUS_EXCL,
				      MSG_META_GAINED_SYS_FOCUS_EXCL,
				      MSG_META_LOST_SYS_FOCUS_EXCL;
@extern method FlatFileDatabaseClass, MSG_META_GET_FOCUS_EXCL;
@extern method FlatFileDatabaseClass, MSG_META_SEND_CLASSED_EVENT;
@extern method FlatFileDatabaseClass, MSG_FFD_DRAW_MARGINS;
@extern method FlatFileDatabaseClass, _reloc;

@if 0
@extern method FlatFileDatabaseClass, MSG_META_CONTENT_TRACK_SCROLLING;
@endif

/*
 * The following are defined in ffDatabaseParse.goc.
 */
@extern method FlatFileDatabaseClass, MSG_FFD_EDIT_EXPRESSION;
@extern method FlatFileDatabaseClass, MSG_FFD_PARSE_EXPRESSION;
@extern	method FlatFileDatabaseClass, MSG_FFD_PARSE_PARSE_STRING;

/*
 * The following is defined in ffDatabasePaste.goc.
 */
@extern method FlatFileDatabaseClass, MSG_FFD_NOTIFY_CLIPBOARD_PASTE;
@extern method FlatFileDatabaseClass, MSG_FFD_ADD_PASTED_FIELD_TO_LAYOUT;

/*
 * The following are defined in ffDatabaseRCP.goc.
 */
@extern method FlatFileDatabaseClass, MSG_FFD_RECORD_CONTROL;
@extern method FlatFileDatabaseClass, MSG_FFD_GET_NUMBER_OF_PAGES;
@extern method FlatFileDatabaseClass, MSG_FFD_GO_TO_PAGE;

/*
 * The following are defined in ffDatabaseSort.goc.
 */
@extern method FlatFileDatabaseClass, MSG_SEARCH;
@extern	method FlatFileDatabaseClass, MSG_FFD_SORT_INFO_SHADOW_SAVE;
@extern	method FlatFileDatabaseClass, MSG_FFD_SORT_INFO_SHADOW_RESTORE;
@extern	method FlatFileDatabaseClass, MSG_FFD_SORT_INFO_SHADOW_DELETE;
@extern method FlatFileDatabaseClass, MSG_FFD_SORT_INFO_SORT;
@extern method FlatFileDatabaseClass, MSG_FFD_SORT_INFO_GET_NUM_ITEMS;
@extern method FlatFileDatabaseClass, MSG_FFD_SORT_INFO_ADD_ITEM;
@extern method FlatFileDatabaseClass, MSG_FFD_SORT_INFO_DELETE_ITEM;
@extern method FlatFileDatabaseClass, MSG_FFD_SORT_INFO_DELETE_ALL_ITEMS;
@extern method FlatFileDatabaseClass, MSG_FFD_SORT_INFO_ITEM_SEARCH;
@extern method FlatFileDatabaseClass, MSG_FFD_SORT_INFO_QUERY_ITEM;
@extern method FlatFileDatabaseClass, MSG_FFD_SORT_INFO_LIST_MONIKER_QUERY;
@extern method FlatFileDatabaseClass, MSG_FFD_SORT_INFO_LIST_REQUEST_NOTES;
@extern method FlatFileDatabaseClass, MSG_FFD_SORT_INFO_GET_SORT_DIRECTION;
@extern method FlatFileDatabaseClass, MSG_FFD_SORT_INFO_SET_SORT_DIRECTION;
@extern method FlatFileDatabaseClass, MSG_FFD_SORT_INFO_INCREASE_PRIORITY;
@extern method FlatFileDatabaseClass, MSG_FFD_SORT_INFO_DECREASE_PRIORITY;
@extern method FlatFileDatabaseClass, MSG_FFD_SORT_INFO_SET_SORT_OPTIONS;
@extern method FlatFileDatabaseClass, MSG_FFD_SORT_INFO_GET_SORT_OPTIONS;
@extern method FlatFileDatabaseClass, MSG_FFD_SORT_INFO_NUKE_FIELD;

/*
 * The following are defined in ffDatabaseSubset.goc.
 */
@extern method FlatFileDatabaseClass, MSG_FFD_SUBSET_APPLY;
@extern method FlatFileDatabaseClass, MSG_FFD_SUBSET_MARK_ALL;
@extern method FlatFileDatabaseClass, MSG_FFD_SUBSET_UNMARK_ALL;
@extern method FlatFileDatabaseClass, MSG_FFD_SUBSET_INVERT_MARKS;
@extern method FlatFileDatabaseClass, MSG_FFD_SUBSET_SHOW_ALL_RECORDS;
@extern method FlatFileDatabaseClass,
			MSG_FFD_SUBSET_SHOW_ONLY_MARKED_RECORDS;
@extern method FlatFileDatabaseClass, MSG_FFD_SUBSET_DELETE_MARKED_RECORDS;
@extern method FlatFileDatabaseClass, MSG_FFD_GET_SUBSET_TOKEN_STREAM;
@extern method FlatFileDatabaseClass, MSG_FFD_GET_FIRST_MARKED_RECORD;
@extern method FlatFileDatabaseClass, MSG_FFD_SUBSET_AUTO_APPLY_MARK;
@extern method FlatFileDatabaseClass, MSG_FFD_SUBSET_CLEAR_MARKS_FIRST;
@extern	method FlatFileDatabaseClass, MSG_FFD_SUBSET_GET_OPTIONS;


/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		External Object Declarations
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/

@extern chunk @FFDType_text;
@extern chunk @FFDType_computed;
@extern chunk @FFDType_integer;
@extern chunk @FFDType_real;
@extern chunk @FFDType_date;
@extern chunk @FFDType_time;

@extern chunk @FFDErr_field_range_error;
@extern chunk @FFDErr_field_not_legal;
@extern chunk @FFDErr_min_only_field_range_error;
@extern chunk @FFDErr_max_only_field_range_error;

@extern chunk @FFDErr_circular_dep;

@extern chunk @FFDLayoutName;

@extern	chunk @FFConfirmRevertRecordString;
@extern	chunk @FFConfirmDeleteRecordString;

@extern	chunk @FFDConfirmDeleteField;
@extern	chunk @FFDFieldHadDependents;
@extern chunk @FFDCannotEditComputedField;

@extern	chunk @FFMemoryFullError;

@extern chunk @FFFDTooComplexError;
@extern chunk @FFFDRangeError;
@extern chunk @FFFDNameError;
@extern chunk @FFFDArgCountError;
@extern chunk @FFFDTypeError;
@extern chunk @FFFDDivByZeroError;
@extern chunk @FFFDCircularRefError;
@extern chunk @FFFDGeneralError;
@extern chunk @FFFDNAError;
@extern chunk @FFFDFloatPosInfinityError;
@extern chunk @FFFDFloatNegInfinityError;
@extern chunk @FFFDNumOutOfRangeError;
@extern chunk @FFFDCircNameRefError;
@extern chunk @FFFDCircDependencyError;  
@extern chunk @FFFDDependenciesError;

@extern chunk @FFFPCantMoveTooManyFieldsError;

@extern chunk @FFFDUnknownError;


/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		Internal Structure Definitions
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/

optr FFDFieldTypeTextTable[] = {
    @FFDType_text,
    @FFDType_computed,
    @FFDType_integer,
    @FFDType_real,
    @FFDType_date,
    @FFDType_time,
};

optr FFDFieldErrorTextTable[] = {
    NullOptr,
    @FFDErr_field_range_error,
    @FFDErr_field_range_error,
    @FFDErr_field_not_legal,
    NullOptr,
    NullOptr,
};

EvalErrorItem FFDEvalErrorStrings[] = {
    {CE_TOO_COMPLEX, 	    	     @FFFDTooComplexError},
    {CE_REF_OUT_OF_RANGE,   	     @FFFDRangeError},
    {CE_NAME, 	    	    	     @FFFDNameError},
    {CE_ARG_COUNT,  	    	     @FFFDArgCountError},
    {CE_TYPE, 	    	    	     @FFFDTypeError},
    {CE_DIVIDE_BY_ZERO,     	     @FFFDDivByZeroError},
    {CE_CIRCULAR_REF, 	    	     @FFFDCircularRefError},
    {CE_GEN_ERR,    	    	     @FFFDGeneralError},
    {CE_NA,     	    	     @FFFDNAError},
    {CE_FLOAT_POS_INF, 	    	     @FFFDFloatPosInfinityError},
    {CE_FLOAT_NEG_INF, 	    	     @FFFDFloatNegInfinityError},
    {CE_FLOAT_GEN_ERR, 	    	     @FFFDNumOutOfRangeError},
    {CE_CIRC_NAME_REF, 	    	     @FFFDCircNameRefError},
    {CE_CIRC_DEPEND, 	    	     @FFFDCircDependencyError},
    {CE_NUM_OUT_OF_RANGE,   	     @FFFDNumOutOfRangeError},
    {PSEE_ROW_OUT_OF_RANGE, 	     @FFFDRangeError},
    {PSEE_COLUMN_OUT_OF_RANGE, 	     @FFFDRangeError},
    {PSEE_FUNCTION_NO_LONGER_EXISTS, @FFFDNameError},
    {PSEE_BAD_ARG_COUNT,    	     @FFFDArgCountError},
    {PSEE_WRONG_TYPE, 	    	     @FFFDTypeError},
    {PSEE_DIVIDE_BY_ZERO,   	     @FFFDDivByZeroError},
    {PSEE_UNDEFINED_NAME,   	     @FFFDNameError},
    {PSEE_CIRCULAR_REF,     	     @FFFDCircularRefError},
    {PSEE_CIRCULAR_DEP,     	     @FFFDCircDependencyError},
    {PSEE_CIRC_NAME_REF,    	     @FFFDCircNameRefError},
    {PSEE_NUMBER_OUT_OF_RANGE, 	     @FFFDNumOutOfRangeError},
    {PSEE_GEN_ERR,  	    	     @FFFDGeneralError},
    {PSEE_NA, 	    	    	     @FFFDNAError},
    {PSEE_TOO_MANY_DEPENDENCIES,     @FFFDDependenciesError},
    {PSEE_FLOAT_POS_INFINITY, 	     @FFFDFloatPosInfinityError},
    {PSEE_FLOAT_NEG_INFINITY, 	     @FFFDFloatNegInfinityError},
    {PSEE_FLOAT_GEN_ERR,     	     @FFFDGeneralError}
};


/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		Internal Function Prototypes
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/

word FFDEnterFieldName(optr oself,
		       byte colNum,
		       FFFieldPropertiesMessageBlock *dataPtr,
		       FieldCreateRequest whichList,
		       byte *fieldColumnNum,
		       Boolean *sameName);


void FFDGrabTargetOnFirstField(optr oself);
FieldID *FFDWhichList(FieldListQuery type, FlatFileDatabaseInstance *pself);
byte FFDHowManyInList(FieldListQuery type, FlatFileDatabaseInstance *pself);
void FFDAddToFieldCount(FieldListQuery type,
			FlatFileDatabaseInstance *pself,
			int howMuch);

FieldID DeleteFieldFromList(FieldID list[],
			    FieldListID index,
			    FieldListID numFields);
FieldListID DeleteAbsoluteFieldFromList(FieldID list[],
					FieldID index,
					FieldListID numFields);

MemHandle _pascal FFDGetColumnFieldName(optr oself, word columnNum, TCHAR *textBuffer);

word FFDConvertDateTimeToAscii(TCHAR *string,
			       FloatNum *number,
			       DateTimeFormat dtf);

TCHAR *FFDGetCellNotes(FieldDataAttrs *cellPtr);
void FFDFillFieldAttrs(FFFieldPropertiesMessageBlock *fpData,
		       FieldDataAttrs *cellPtr);

Boolean FFDFieldDependedUpon(optr oself, FieldID colnum);

void FFDRemoveDependencies(optr oself, word rowNum, FieldID colNum);

Boolean FFDDeleteField(byte colNum, optr oself);

FieldListID FindFieldListElement(FieldID list[],
				 FieldListID colNum,
				 FieldListID numFields);

void DeleteListElementFromAllLists(optr databaseObject,
				   FieldListID colNum);
void DeleteFieldName(optr selfOptr, byte colNum);

FieldListID AddFieldToLayoutList(optr oself, byte fieldColumnNum,
				 TCHAR *fieldName);
FieldListID AddFieldToNotInLayoutList(optr oself, byte fieldColumnNum,
				      TCHAR *fieldName);

MemHandle StoreFieldPropertiesInBlock(byte colNum, optr oself);

void FFDEvalComputedField(optr oself, FieldID colNum);

void FFDRecalculateDependents(optr oself, FieldID colNum, RedrawFlag redraw);

void _pascal FFDUpdateExprRedraw(optr oself, word row, word column);

void FFDSetEvalErrorText(word errNum, TCHAR *text);

void FFDLoadFormulaResults(CellFormula *formulaCell, CellCommon *dest,
			   word *dataSize);

void FFDLoadFormulaCell(optr oself, FieldID colNum, CellFormula *dest);

void FFDLoadFormulaCellFromExistingCell(optr oself, word sourceRecord,
					FieldID sourceField, FieldID destField);

FFFieldValidationType FFDValidateScreenField(optr oself,
					     optr textOptr,
					     FieldID colNum,
					     Boolean formatText);

FFFieldValidationType FFDValidateScreenFieldWithMessage(optr oself,
							optr textOptr,
							FieldID colNum,
							Boolean formatText);

optr FFDGetFieldTextGrObject(optr oself, FieldID fieldNum);

void FFDForceFieldOnScreen(optr oself, FieldID columnNum);

void FFDClearCellToType(optr oself, FieldID colNum);

void FFDCopyCellDependencies(optr oself, FieldID colNum, CellCommon *dest);

void FFDCopyFieldFromTempDataRow(optr oself, FieldID sourceField,
			    word destRecord, FieldID destField);

void FFDCopyFieldToTempDataRow(optr oself, word sourceRecord,
			       FieldID sourceField, FieldID destField);

CellCommon *FFDLoadEvaluationResults(optr oself, FieldID field,
				     byte *evalBuffer, TextCellStruct *textCell,
				     CellConstant *numCell,
				     FormulaCellStruct *formulaCell,
				     CellEmpty *emptyCell, word *dataSize);

void FFDLoadFormulaFromEvaluationResults(optr oself, FieldID field,
					 byte *evalBuffer,
					 FormulaCellStruct *formulaCell,
					 word *dataSize);

Boolean FFDConvertToFloat(FieldDataType dataType, char *data, FloatNum *num);
void FFDConvertFromFloat(FieldDataType dataType, FloatNum num, char *text);

void FFDDisplayFieldContents(optr oself,
			     FieldID colNum,
			     optr textOptr,
			     MemHandle textHandle,
			     Boolean formatText);

FieldDataType FFDGetDataTypeAndFlags(optr oself,
				     FieldID fieldNum,
				     FieldDataTypesFlags *flags);

Boolean FFDDoNotPutUpValidationErrorMessage(optr oself);

Boolean FFDHorribleHackToSeeIfTheDocHasTheTarget(optr oself);

Boolean FFDApplicationInAClosingState(optr oself);





/***********************************************************************
 *
 * MESSAGE:	MSG_FFD_GET_CUR_COL for FlatFileDatabaseClass
 *
 * DESCRIPTION:	Returns the current column number
 *
 * PARAMETERS: 	byte ()
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	anna	4/16/92		Initial version
 *
 ***********************************************************************/
@method FlatFileDatabaseClass, MSG_FFD_GET_CUR_COL
{
    return(pself->SSI_active.CR_column);
}

/***********************************************************************
 *
 * MESSAGE:	MSG_FFD_CURRENTLY_EDITING_A_RECORD for FlatFileDatabaseClass
 *
 * DESCRIPTION:	This message returns TRUE if a new record is being
 * 	    	edited or an existing record is being edited and
 *	    	has been changed.
 *
 * PARAMETERS:
 *	Boolean ()
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	5/21/92		Initial version
 *
 ***********************************************************************/
@method FlatFileDatabaseClass, MSG_FFD_CURRENTLY_EDITING_A_RECORD
{
    return (pself->FFI_editingNewRecord || pself->FFI_dirtyRecord);
}

/***********************************************************************
 *
 * MESSAGE:	MSG_FFD_IS_THIS_A_NEW_RECORD for FlatFileDatabaseClass
 *
 * DESCRIPTION:	This message returns TRUE if a new record is being
 * 	    	edited. 
 *
 * PARAMETERS:
 *	Boolean ()
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	anna	6/8/92		Initial version
 *
 ***********************************************************************/
@method FlatFileDatabaseClass, MSG_FFD_IS_THIS_A_NEW_RECORD
{
    return (pself->FFI_editingNewRecord);
}

/***********************************************************************
 *
 * MESSAGE:	MSG_FFD_GET_NEXT_COL for FlatFileDatabaseClass
 *
 * DESCRIPTION:	Returns the next column number
 *
 * PARAMETERS: 	byte ()
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	anna	4/21/92		Initial version
 *
 ***********************************************************************/
@method FlatFileDatabaseClass, MSG_FFD_GET_NEXT_COL
{
    FieldID curIndex;

    curIndex = FindFieldListElement(pself->FFI_databaseNameList,
				    pself->SSI_active.CR_column,
				    pself->FFI_numFields);

    /*
     * See if we're already at the last field
     */
    if (curIndex == (pself->FFI_numFields - 1)) {
	return(-1);
    }
    else {
        return(pself->FFI_databaseNameList[curIndex + 1]);
    }
}

/***********************************************************************
 *
 * MESSAGE:	MSG_FFD_SET_CUR_ROW for FlatFileDatabaseClass
 *
 * DESCRIPTION:	Changes the current row (in the instance data).
 *
 * PARAMETERS:
 *	void (word rowNumber)
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	anna	4/16/92		Initial version
 *
 ***********************************************************************/
@method FlatFileDatabaseClass, MSG_FFD_SET_CUR_ROW
{
    pself->SSI_active.CR_row = rowNumber;
}

/***********************************************************************
 *
 * MESSAGE:	MSG_FFD_GET_CUR_ROW for FlatFileDatabaseClass
 *
 * DESCRIPTION:	Returns the current row number
 *
 * PARAMETERS: 	word ()
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	anna	4/16/92		Initial version
 *
 ***********************************************************************/
@method FlatFileDatabaseClass, MSG_FFD_GET_CUR_ROW
{
	 return(pself->SSI_active.CR_row);
}

/***********************************************************************
 *
 * MESSAGE:	MSG_FFD_GET_NUM_FIELDS for FlatFileDatabaseClass
 *
 * DESCRIPTION:	Returns the number of fields in the database 
 *
 * PARAMETERS: 	byte ()
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	anna	4/21/92		Initial version
 *
 ***********************************************************************/
@method FlatFileDatabaseClass, MSG_FFD_GET_NUM_FIELDS
{
    return(pself->FFI_numFields);
}

/***********************************************************************
 *
 * MESSAGE:	MSG_FFD_GET_NUM_RECORDS for FlatFileDatabaseClass
 *
 * DESCRIPTION:	Returns the number of records in the database 
 *
 * PARAMETERS: 	word ()
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	5/21/92		Initial version
 *
 ***********************************************************************/
@method FlatFileDatabaseClass, MSG_FFD_GET_NUM_RECORDS
{
    return(pself->FFI_totalNumRecordsInDatabase);
}

/***********************************************************************
 *
 * MESSAGE:	MSG_FFD_GET_NUM_MARKED_RECORDS for FlatFileDatabaseClass
 *
 * DESCRIPTION:	Returns the number of marked records in the database 
 *
 * PARAMETERS: 	word ()
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	ted	2/5/93		Initial version
 *
 ***********************************************************************/
@method FlatFileDatabaseClass, MSG_FFD_GET_NUM_MARKED_RECORDS
{
    return(pself->FFI_numMarkedRecords);
}

/***********************************************************************
 *
 * MESSAGE:	MSG_FFD_GET_SHOW_ONLY_MARKED for FlatFileDatabaseClass
 *
 * DESCRIPTION:	Returns the flag indicating "show only marked" mode. 
 *
 * PARAMETERS: 	Boolean ()
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	ted	2/5/93		Initial version
 *
 ***********************************************************************/
@method FlatFileDatabaseClass, MSG_FFD_GET_SHOW_ONLY_MARKED
{
    return(pself->FFI_showOnlyMarked);
}

/***********************************************************************
 *
 * MESSAGE:	MSG_FFD_GET_NUM_LAYOUTS for FlatFileDatabaseClass
 *
 * DESCRIPTION:	Returns the number of layouts in the database 
 *
  * PARAMETERS: 	word ()
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	anna	6/16/92		Initial version
 *
 ***********************************************************************/
@method FlatFileDatabaseClass, MSG_FFD_GET_NUM_LAYOUTS
{
    return(pself->FFI_numLayouts);
}

/***********************************************************************
 *
 * MESSAGE:	MSG_FFD_GET_MAX_LENGTH for FlatFileDatabaseClass
 *
 * DESCRIPTION:	Returns the user-defined maximum length for a field of
 *		datatype = General/Text 
 *		Else returns MAX_TEXT_FIELD_LENGTH.
 *
 * PARAMETERS: 	word (byte colNum)
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	anna	6/9/92		Initial version
 *
 ***********************************************************************/
@method FlatFileDatabaseClass, MSG_FFD_GET_MAX_LENGTH
{
    FieldDataAttrs  	     *cellDataPtr;
    word fieldLength;

    cellDataPtr = CellLock(&pself->SSI_cellParams,
	     		       FIELD_TYPE_ROW, 
     	     		       colNum);

    if (cellDataPtr->FDA_type != FDT_GENERAL_TEXT) {
	fieldLength = MAX_TEXT_FIELD_LENGTH + 1;
    }
    else {
	fieldLength = ((TextFieldDataAttrs *)cellDataPtr)->TFDA_maxLength;
    }

    CellUnlock(cellDataPtr);
    return(fieldLength);
}

/***********************************************************************
 *
 * MESSAGE:	MSG_FFD_GET_INDEXED_COL_NUM for FlatFileDatabaseClass
 *
 * DESCRIPTION:	Returns the column number in the given position of the
 *		sorted fields list. 
 *
 * PARAMETERS: 	byte (byte index)
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	anna	4/21/92		Initial version
 *
 ***********************************************************************/
@method FlatFileDatabaseClass, MSG_FFD_GET_INDEXED_COL_NUM
{
    return(pself->FFI_databaseNameList[index]);
}

/***********************************************************************
*
* MESSAGE:    MSG_FFD_GET_COLUMN_FIELD_NAME
*
* DESCRIPTION:  Get field name for specified column.  This message
*	        retrieves a field's name from its spreadsheet token
*	        number.  If textBuffer is non-NULL, the name will be
*	        strcpy()'d into the area pointed to by the textBuffer.
*	        Else, a block will be allocated as sharable, the name
*	        copied into the block, the block will be unlocked, and
*	        the block's handle returned.
*
*	    	If the field doesn't exist, a 0 is returned and the
*	    	textBuffer set to \0.
*
* PARAMETERS:	MemHandle (word columnNum, TCHAR *textBuffer)
*
* KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
*
* REVISION HISTORY:
*      Name    Date            Description
*      ----    ----            -----------
*      anna    2/92            Initial Revision
*      anna    3/92	       "Real" version; first one was
*			       just a hack (MSG_SPREADSHEET_ADD_NAME
*			       wasn't working for C yet)
*      jeremy  3/31/92	       Changed return value to a MemHandle/block.
*      jeremy  4/3/92	       Now takes advantage of FFDGetColumnFieldName.
*
***********************************************************************/
@method FlatFileDatabaseClass, MSG_FFD_GET_COLUMN_FIELD_NAME 
{
    return(FFDGetColumnFieldName(oself, columnNum, textBuffer));
}

/***********************************************************************
 *
 * FUNCTION:	FFDGetColumnFieldName
 *
 * DESCRIPTION:  Get field name for specified column.  This function
 *	         retrieves a field's name from its spreadsheet token
 *	         number.  If textBuffer is non-NULL, the name will be
 *	         strcpy()'d into the area pointed to by the textBuffer
 *	    	 (and note that the textBuffer must be at least
 *	    	 MAX_FIELD_NAME_LENGTH bytes big).
 *	         Else, a block will be allocated as sharable, the name
 *	         copied into the block, the block will be unlocked, and
 *	         the block's handle returned.
 *
 *	    	 If the field doesn't exist, a 0 is returned and the
 *	    	 textBuffer set to \0.
 *
 * PARAMETERS:
 *
 * CALLED BY:	INTERNAL
 *
 * STRATEGY:
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	6/ 9/92		Initial Revision
 *
 ***********************************************************************/
MemHandle _pascal
FFDGetColumnFieldName(optr oself, word columnNum, TCHAR *textBuffer)
{
    FlatFileDatabaseInstance *pself;
    FieldDataAttrs *cellDataPtr;
    word nameToken;
    word nameLength;
    MemHandle textBlock, retval;
    TCHAR *textPtr, namePtr[MAX_FIELD_NAME_LENGTH + 1];

    /* 
     * Lock the cell 
     */
    pself = ObjDerefGen(oself);
    cellDataPtr = CellLock(&pself->SSI_cellParams,
	     		   FIELD_TYPE_ROW, 
     	     		   columnNum);
    retval = NullHandle;

    if (cellDataPtr) {
	nameToken = cellDataPtr->FDA_nameToken;
	CellUnlock(cellDataPtr);
	
	pself = ObjDerefGen(oself);
	nameLength = SpreadsheetNameTextFromToken((SpreadsheetInstance *)pself,
						  nameToken,
						  namePtr,
						  MAX_FIELD_NAME_LENGTH);
	namePtr[nameLength] = _TEXT('\0');
	
	if (textBuffer != NULL) {
	    /* Fill the passed text buffer. */
	    strcpy(textBuffer, namePtr); 
	} else {
	    /* Allocate a text buffer. */
	    textBlock = MemAlloc(strlen(namePtr)*sizeof(TCHAR),
				 HF_SWAPABLE | HF_SHARABLE, 
				 HAF_NO_ERR);

	    textPtr = MemLock(textBlock);
	    strcpy(textPtr, namePtr);
	    MemUnlock(textBlock);
	    retval = textBlock;
	}
    } else {	/* no cell exists */
	if (textBuffer != NULL) {
	    textBuffer[0] = _TEXT('\0');
	}
    }

    return (retval);
}

/***********************************************************************
*
* MESSAGE:    MSG_FFD_GET_INDEXED_FIELD_NAME
*
* DESCRIPTION:  
* 	This message returns a MemHandle to the text of a field in one
*	of the indexed lists (or fills a passed textBuffer -- see
*	MSG_FFD_GET_COLUMN_FIELD_NAME for details) based on whichList
*	is being requested.  The main, alphabetized list of every
*	field in the database is selected by DATABASE_NAME_LIST; the list
*	of fields in the current layout is used with LAYOUT_NAME_LIST; and
*	the fields in the database which are not in the current layout
*	are available though the NOT_IN_LAYOUT_NAME_LIST.
*
* CALLED BY:   
*		
*
* PARAMETERS:	word fieldNum - index into the list
*	    	FieldListQuery whichList - are we asking for the whole
*	    	    database, the layout list, or the whole database
*	    	    minus the layout list (DATABASE_NAME_LIST, LAYOUT_NAME_LIST,
*	    	    and NOT_IN_LAYOUT_NAME_LIST, respectively)?
*	    	textBuffer - where to place text (NULL if you want
*	    	    a text buffer allocated).
*
* STRATEGY:	
*
* KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
*
* REVISION HISTORY:
*      Name    Date            Description
*      ----    ----            -----------
*      anna    2/92            Initial Revision
*      jeremy  3/31/92	       Changed it to use handles/blocks.
*
***********************************************************************/
@method FlatFileDatabaseClass, MSG_FFD_GET_INDEXED_FIELD_NAME 
{
    word max_index;
    byte *list;

    switch (whichList) {
	case DATABASE_NAME_LIST:
	    max_index = pself->FFI_numFields;
	    list = pself->FFI_databaseNameList;
	    break;
	case LAYOUT_NAME_LIST:
	    max_index = pself->FFI_numInLayoutNameList;
	    list = pself->FFI_layoutNameList;
	    break;
	case NOT_IN_LAYOUT_NAME_LIST:
	    max_index = pself->FFI_numInNotInLayoutNameList;
	    list = pself->FFI_notInLayoutNameList;
	    break;
    }

    /* 
     * First see if requested column is valid 
     */
    if (fieldNum >= max_index) {
	if (textBuffer != NULL) {
	    textBuffer[0] = _TEXT('\0');
	}
	return(0);
    }

    return(FFDGetColumnFieldName(oself, (word) list[fieldNum], textBuffer));
}

/***********************************************************************
 *
 * MESSAGE:     MSG_FFD_LOAD_FIELD_WITH_NAME for FlatFileDatabaseClass
 *
 * DESCRIPTION: This message loads a text field with its own name.  Pass the OD
 *              of the field, and the column to find the name.
 *
 * PARAMETERS:
 *      void (optr fieldOptr, FieldID colNum)
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      jeremy  6/17/92         Initial version
 *
 ***********************************************************************/
@method FlatFileDatabaseClass, MSG_FFD_LOAD_FIELD_WITH_NAME
{
    TCHAR name[MAX_TOTAL_NAME_LENGTH];

    (void) FFDGetColumnFieldName(oself, (word) colNum, name);
    @call fieldOptr::MSG_VIS_TEXT_REPLACE_ALL_PTR(name, 0);
}


/***********************************************************************
 *
 * MESSAGE:	MSG_FFD_LOAD_FIELD_WITH_UNFORMATED_TEXT for
 *	    	    	    	    	    	    FlatFileDatabaseClass
 *
 * DESCRIPTION:	
 *	This message loads a text field with the unformatted text
 *	that was typed into it.  Pass the OD of the field and its column
 *	number.
 *
 * PARAMETERS:
 *	void (optr fieldOptr, FieldID colNum)
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	12/ 1/92	Initial version
 *
 ***********************************************************************/
@method FlatFileDatabaseClass, MSG_FFD_LOAD_FIELD_WITH_UNFORMATTED_TEXT
{
    MemHandle textHandle;

    /*
     * Allocate a text buffer for the redrawing code.
     */
    textHandle = MemAlloc((MAX_TEXT_FIELD_LENGTH + 1)*sizeof(TCHAR),
			  HF_SHARABLE | HF_SWAPABLE, HAF_NO_ERR);

    FFDDisplayFieldContents(oself, colNum, fieldOptr, textHandle, FALSE);
    
    /*
     * Done with the text buffer.
     */
    MemFree(textHandle);
}

/***********************************************************************
 *
 * MESSAGE:	MSG_FFD_CHANGE_SCREEN_FIELD_ATTRIBUTES for FlatFileDatabaseClass
 *
 * DESCRIPTION:	This message sets a field's display type to the default
 *	    	for its specific field data type.  It affects only the
 *	    	field in the current layout, if it exists.
 *
 *	    	Pass the field's column number and its FieldDataType.
 *
 * PARAMETERS:
 *	void (FieldID colNum, FieldDataType dataType)
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	12/ 3/92	Initial version
 *
 ***********************************************************************/
@method FlatFileDatabaseClass, MSG_FFD_CHANGE_SCREEN_FIELD_ATTRIBUTES
{
    optr fieldOptr;
    RecordLayoutChunkArrayHeader *cellDataPtr;
    CellRef cellOptr;
    RecordLayoutChunkArrayElement *currentIndexElement;
    MemHandle grObjectMemBlock;
    optr grObjectOptr;
    byte indexIntoList;

    /*
     * First, retrieve the record layout chunk array.
     */
    cellDataPtr = CellLockGetRef(&pself->SSI_cellParams,
				 RECORD_LAYOUT_ROW, 
				 pself->FFI_currentLayout,
				 &cellOptr);
#if ERROR_CHECK
    if (!cellDataPtr) {
	EC_ERROR(CELL_DOES_NOT_EXIST);
    }
#endif /* ERROR_CHECK */

    /*
     * Get a pointer to this element
     */
    indexIntoList = FindFieldListElement(
				 cellDataPtr->RLCAH_layoutSortedFieldList,
				 colNum,
			         cellDataPtr->RLCAH_numFieldsInLayout);

    /*
     * The field does not exist in this layout; do nothing.
     */
    if (indexIntoList == (byte) -1) {
	CellUnlock(cellDataPtr);
	return;
    }

    currentIndexElement = ChunkArrayElementToPtr(cellOptr, 
						 indexIntoList, 
						 (word *)0);

    /*
     * Get the field's optr.
     */
    pself = ObjDerefGen(oself);
    grObjectMemBlock = VMVMBlockToMemBlock(pself->documentHandle, 
				   currentIndexElement->GOEOP_grObjectVMBlock);

    grObjectOptr = ConstructOptr(grObjectMemBlock, 
				 currentIndexElement->GOEOP_grObjectChunk);

    /*
     * Let the record layout chunk array go.
     */
    CellUnlock(cellDataPtr);

    /*
     * Tell the field to reset its display type to the appropriate default.
     */
    fieldOptr = @call grObjectOptr::MSG_GOVG_GET_VIS_WARD_OD();
    @send fieldOptr::MSG_FFT_SET_FIELD_TYPE(dataType, TRUE);
}

/***********************************************************************
*
* MESSAGE:    MSG_FFD_GET_COLUMN_MIN_OR_MAX_STRING
*
* DESCRIPTION:  Get min or max value for specified column, and convert it
*		to a text string. Requested column must represent
*		an integer, real number, date, or time.
*
*	    	If the number was not valid (like the cell was empty,
*	    	for example), FALSE will be returned.  Otherwise,
*	    	TRUE will be.
*
* PARAMETERS:	Boolean (word columnNum, TCHAR *textBuffer,
*	    	    	 MinOrMaxValue minOrMax)
*
* KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
*
* REVISION HISTORY:
*      Name    Date            Description
*      ----    ----            -----------
*      anna    4/23/92         Initial Revision
*      jeremy  11/9/93	       Added time and date support
*
***********************************************************************/
@method FlatFileDatabaseClass, MSG_FFD_GET_COLUMN_MIN_OR_MAX_STRING 
{
    ValueFieldDataAttrs *cellDataPtr;
    FloatNum dataValue;
    word numFractionalDigits;

    /* 
     * Lock the cell 
     */
    cellDataPtr = CellLock(&pself->SSI_cellParams,
	     		   FIELD_TYPE_ROW, 
     	     		   columnNum);
    #if ERROR_CHECK
        if (!cellDataPtr) {
	    EC_ERROR(CELL_DOES_NOT_EXIST);
	}
    #endif

    if (minOrMax == MIN) {
        memcpy(&dataValue, &cellDataPtr->VFDA_min, sizeof(FloatNum));
    } else {
    	memcpy(&dataValue, &cellDataPtr->VFDA_max, sizeof(FloatNum));
    }

    if (cellDataPtr->VFDA_common.FDA_type == FDT_INTEGER) {
        numFractionalDigits = 0;
    }
    else if (cellDataPtr->VFDA_common.FDA_type == FDT_REAL) {
        numFractionalDigits = NUM_ASCII_FRACTIONAL_DIGITS;
    }

    CellUnlock(cellDataPtr);

    /*
     * Do the conversion, and return TRUE if the result was a number,
     * FALSE if the result was a non-number (an error, for example).
     */
    switch (cellDataPtr->VFDA_common.FDA_type) {
    	case FDT_INTEGER:
    	case FDT_REAL:
	    return (FloatFloatToAscii_StdFormat(textBuffer,
						&dataValue,
						(FFAF_FROM_ADDR |
						    FFAF_NO_TRAIL_ZEROS),
						NUM_ASCII_DIGITS,
						numFractionalDigits) 
		    != 0);

	case FDT_DATE:
	    return (FFDConvertDateTimeToAscii(textBuffer,
					      &dataValue,
					      DTF_SHORT)
		    != 0);

	case FDT_TIME:
	    return (FFDConvertDateTimeToAscii(textBuffer,
					      &dataValue,
					      DTF_HMS)
		    != 0);
    }
}

/***********************************************************************
 *
 * FUNCTION:	FFDConvertDateTimeToAscii 
 *
 * DESCRIPTION:	Converts the given FloatNum Date/Time expression to
 *		ascii, and stores the result in string.
 *
 *	    	Pass the format you require in dtf.  One could use
 *	    	DTF_SHORT, for example, for a date format.
 *
 *	    	If the number doesn't convert correctly, a zero is
 *	    	returned.  Otherwise, the length of the string is
 *	    	returned.
 *
 * 		The floating point stack must already exist when this
 *		routine is called.
 *
 * PARAMETERS:  word (TCHAR *string, FloatNum *Number, DateTimeFormat dtf)
 *
 * STRATEGY:
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	anna	4/27/92		Initial Revision
 *
 **********************************************************************/
word
FFDConvertDateTimeToAscii(TCHAR *string, FloatNum *number, DateTimeFormat dtf)
{
    FFA_stackFrame stackFrame;

    stackFrame.FFA_float.FFA_params.formatFlags = FFAF_FROM_ADDR;
    stackFrame.FFA_float.FFA_params.totalDigits = NUM_ASCII_DIGITS;
    stackFrame.FFA_float.FFA_params.decimalLimit = NUM_ASCII_FRACTIONAL_DIGITS;
    stackFrame.FFA_float.FFA_params.decimalOffset = 0;
    stackFrame.FFA_dateTime.FFA_dateTimeParams.FFA_dateTimeFlags = 
		FFDT_DATE_TIME_OP | FFDT_FROM_ADDR | dtf;

    return FloatFloatToAscii(&stackFrame, string, number);
}


/***********************************************************************
 *
 * MESSAGE:	MSG_FFD_GET_NUMBER_OF_FIELDS for FlatFileDatabaseClass
 *
 * DESCRIPTION:	This handles when someone needs to know
 *	    	how many fields there are in one of the database's
 *	    	field lists.
 *
 * PARAMETERS:
 *	byte (optr dList, FieldListQuery whichList)
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	2/27/92		Initial version
 *	JDM	92.08.11	Added check for null list optr and
 *				return of the list count.
 *
 ***********************************************************************/
@method FlatFileDatabaseClass, MSG_FFD_GET_NUMBER_OF_FIELDS
{
    byte howMany;

    howMany = FFDHowManyInList(whichList, pself);

    /* Is there a list to initialize?	*/
    if (NullOptr != dList)
        {
	/* Yep.  Initialize it!	*/
	@call dList::MSG_GEN_DYNAMIC_LIST_INITIALIZE(howMany);
	}

    /* Return the number of items in the specified list.	*/
    return (howMany);
}

/***********************************************************************
 *
 * MESSAGE:	MSG_FFD_GET_NUMBER_OF_LAYOUTS for FlatFileDatabaseClass
 *
 * DESCRIPTION:	Returns the number of layouts in the database.
 *
 * PARAMETERS:
 *	void ()
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	anna	7/6/92		Initial version
 *
 ***********************************************************************/
@method FlatFileDatabaseClass, MSG_FFD_GET_NUMBER_OF_LAYOUTS
{
    return(pself->FFI_numLayouts);
}

/***********************************************************************
 *
 * MESSAGE:	MSG_FFD_REQUEST_FIELD_MONIKER for FlatFileDatabaseClass
 *
 * DESCRIPTION:	This handles when somebody needs a field name moniker
 *	    	for a specific list item.
 *
 * PARAMETERS:
 *	void (optr dList, word entryNum, FieldListQuery whichList)
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	2/27/92		Initial version
 *
 ***********************************************************************/
@method FlatFileDatabaseClass, MSG_FFD_REQUEST_FIELD_MONIKER
{
    TCHAR name[MAX_TOTAL_NAME_LENGTH];

    (void) @call self::MSG_FFD_GET_INDEXED_FIELD_NAME
		(entryNum, whichList, name);

    /* Send the text to the list. */
    @call dList::MSG_GEN_DYNAMIC_LIST_REPLACE_ITEM_TEXT(entryNum, name);
}


/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		MSG_FFD_REQUEST_FIELD_MONIKER_DISABLED
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

DESCRIPTION:	Supply the requested field list moniker to the given list
		but make it disabled.

PASS: 		optr	dynList		= Dynamic list to send the moniker.
		word	entryNum	= Entry in the 'whichList'.
		FieldListQuery	whichList	= Which of the database's
						  list to consult for the
						  requested moniker.
RETURN:		Void.

PSEUDO CODE/STRATEGY:
	Get the moniker from ourself.
	Insert it into the given entry in the given list marked as disabled.

CHECKS:		None.

KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:	???

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	JDM	92.05.27	Initial version.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/

@method  FlatFileDatabaseClass, MSG_FFD_REQUEST_FIELD_MONIKER_DISABLED
{
    TCHAR name [MAX_TOTAL_NAME_LENGTH+1];
    
    /* Get the name.	*/
    (void) @call oself::
	MSG_FFD_GET_INDEXED_FIELD_NAME(entryNum, whichList, name);
    
    /* Send the name to the list and mark the entry as disabled.	*/
    @call dynList:: MSG_GEN_DYNAMIC_LIST_REPLACE_ITEM_MONIKER
	(entryNum, RIMF_NOT_ENABLED, 0, 0, 0, VMDT_TEXT, VMST_FPTR,
	 (dword) name);
}


/***********************************************************************
 *
 * MESSAGE:	MSG_FFD_REQUEST_FIELD_NOTES
 *	    	for FlatFileDatabaseClass
 *
 * DESCRIPTION:	This handles when somebody needs a field's notes
 *	    	for a specific list item.
 *
 * PARAMETERS:
 *	void (word entryNum, FieldListQuery whichList,
 *	      optr notesDisplay)
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	4/2/92		Initial version
 *
 ***********************************************************************/
@method FlatFileDatabaseClass, MSG_FFD_REQUEST_FIELD_NOTES
{
    byte *list;
    FieldDataAttrs *cellDataPtr;

    list = FFDWhichList(whichList, pself);

    /* 
     * Lock the cell 
     */
    cellDataPtr = CellLock(&pself->SSI_cellParams,
	     		   FIELD_TYPE_ROW, 
     	     		   list[entryNum]);
		
    if (!cellDataPtr) {
	return;	/* No cell... */
    }

    /* Send any notes to the text item. */
    @call notesDisplay::
	   MSG_VIS_TEXT_REPLACE_ALL_PTR(FFDGetCellNotes(cellDataPtr), 0);

    /* Free the cell */
    CellUnlock(cellDataPtr);
}

/***********************************************************************
 *
 * MESSAGE:	MSG_FFD_EXPRESSION_BUILDER_GET_FIELD_NAME for
 *	    	    	    FlatFileDatabaseClass
 *
 * DESCRIPTION:	This handles when an expression builder needs a text string
 *	    	to be blasted into its text editing area.
 *
 * PARAMETERS:
 *	void (MemHandle childBlock,
 *	      ChunkHandle textEditor,
 *	      word fieldID);
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	2/27/92		Initial version
 *
 ***********************************************************************/
@method FlatFileDatabaseClass, MSG_FFD_EXPRESSION_BUILDER_GET_FIELD_NAME
{
    TCHAR name[MAX_TOTAL_NAME_LENGTH];

    (void) @call self::MSG_FFD_GET_INDEXED_FIELD_NAME(fieldID,
						      DATABASE_NAME_LIST,
						      name);

    @call childBlock, (ChunkHandle)textEditor::
	MSG_VIS_TEXT_REPLACE_SELECTION_PTR(name, strlen(name));
}

/********* Beginning of DatabaseInitialization resource *********/

#ifdef __HIGHC__
pragma Code ("DATABASEINITIALIZATION");
#endif
#ifdef __BORLANDC__
#pragma codeseg DATABASEINITIALIZATION
#endif
#ifdef __WATCOMC__
#pragma code_seg("DATABASEINITIALIZATION")
#endif

/***********************************************************************
*
* MESSAGE:    MSG_FFD_SET_DOCUMENT_HANDLE
*
* DESCRIPTION: 	Set the current document's file handle in the instance
*		data for the Flat file object. We need this later to
*		get optrs to the GrObjBody and the GrObjects.
*
*		Also tells the document handle of the current layout's
*		record layout boundary to reset itself.
*
* CALLED BY:   GLOBAL
*
* PARAMETERS:	void (VMFileHandle documentFileHandle);
*
* STRATEGY:	
*
* KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
*
* REVISION HISTORY:
*      Name    Date            	Description
*      ----    ----            	-----------
*      anna    5/7/92     	Initial Revision
*
***********************************************************************/
@method FlatFileDatabaseClass, MSG_FFD_SET_DOCUMENT_HANDLE 
{
    pself->documentHandle = documentFileHandle;
}

/***********************************************************************
*
* MESSAGE:    MSG_FFD_SET_GROBJ_AM
*
* DESCRIPTION: 	Set the GrObj's Attribute Manager optr 
*		in the instance data for the Flat file object. 
*
* CALLED BY:   GLOBAL
*
* PARAMETERS:	void (optr grObjAMOptr)
*
* STRATEGY:	
*
* KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
*
* REVISION HISTORY:
*      Name    Date            	Description
*      ----    ----            	-----------
*      anna    7/1/92     	Initial Revision
*
***********************************************************************/
@method FlatFileDatabaseClass, MSG_FFD_SET_GROBJ_AM 
{
    pself->FFI_grObjAM = grObjAMOptr;
}

/********* End of DatabaseInitialization resource *********/

/********* Beginning of DatabaseFieldProperties resource *********/ 

#ifdef __HIGHC__
pragma Code ("DATABASEFIELDPROPERTIES");
#endif
#ifdef __BORLANDC__
#pragma codeseg DATABASEFIELDPROPERTIES
#endif
#ifdef __WATCOMC__
#pragma code_seg("DATABASEFIELDPROPERTIES")
#endif

/***********************************************************************
 *
 * MESSAGE:	MSG_FFD_NOTIFY_ATTRIBUTE_CHANGES for FlatFileDatabaseClass
 *
 * DESCRIPTION:	...
 *	This message tells the database that a field's attributes might have
 *	changed.
 *	Currently, the only thing that happens is that the Treasure Chest
 *	is told to updates its notes field.
 *
 * PARAMETERS:
 *	void ()
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	6/19/92		Initial version
 *
 ***********************************************************************/
@method FlatFileDatabaseClass, MSG_FFD_NOTIFY_ATTRIBUTE_CHANGES
{
    SendListNotifications(LAYOUT_NAME_LIST, oself, 0, SHOW_NOTES, 0);
    SendListNotifications(DATABASE_NAME_LIST, oself, 0, SHOW_NOTES, 0);
}

/***********************************************************************
 *
 * MESSAGE:	MSG_FFD_MOVE_FIELDS_INTO_LAYOUT_LIST
 *
 * DESCRIPTION:
 *	This message moves fields from the not_in_layout_list
 *	into the layout_list.  Pass the indices of the
 *	fields WRT to the not_in_layout_list.
 *
 * PARAMETERS:
 * 	void (optr fieldIDListHandle, word numItems)
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	3/30/92		Initial version
 *	jeremy	4/29/92	    	Updated to handle multiple fields.
 *	jeremy	6/5/92	    	Broke into two simpler messages.
 *
 ***********************************************************************/
@method FlatFileDatabaseClass, MSG_FFD_MOVE_FIELDS_INTO_LAYOUT_LIST
{
    word *fieldIDList;
    TCHAR fieldName[MAX_TOTAL_NAME_LENGTH];
    FieldListID layoutIndex, databaseIndex;
    int i;
    optr appObject = GeodeGetAppObject(0);

    if (numItems > MAX_NUM_FIELDS_TO_MOVE) {
	DisplayUserError(@FFFPCantMoveTooManyFieldsError);
	MemFree(fieldIDListHandle);
	return;
    }

    fieldIDList = MemLock(fieldIDListHandle);

    /*
     * Put up the hourglass, since this operation can be slooow.
     */
    @call appObject::MSG_GEN_APPLICATION_MARK_BUSY();

    /* Dereference the fields to the absolute column reference. */
    pself = ObjDerefGen(oself);
    for (i = 0; i < numItems; i++) {
	fieldIDList[i] = (pself->FFI_notInLayoutNameList)[fieldIDList[i]];
    }

    for (i = 0; i < numItems; i++) {
	/* Remove item from the not_in_layout_list. */
	databaseIndex = DeleteAbsoluteFieldFromList(
				    pself->FFI_notInLayoutNameList, 
				    (FieldID)fieldIDList[i],
				    pself->FFI_numInNotInLayoutNameList);

	/* Add the removed field to the layout_list. */
	(void) FFDGetColumnFieldName(oself, fieldIDList[i], fieldName);
	pself = ObjDerefGen(oself);
	layoutIndex = InsertSortedFieldArray(FFDGetColumnFieldName,
					  pself->FFI_layoutNameList,
					  fieldIDList[i],
					  pself->FFI_numInLayoutNameList,
					  fieldName,
					  oself);

	/* Update field list counts */
	pself = ObjDerefGen(oself);
	pself->FFI_numInNotInLayoutNameList--;
	pself->FFI_numInLayoutNameList++;

	/* Notify lists of changes. */
	SendDatabaseListNotification(oself, databaseIndex, DELETED, 0);
	SendLayoutListNotification(oself, layoutIndex, ADDED, 0);

	/*
	 * Add the field to the screen.
	 */
	@call self::MSG_FFD_ADD_FIELD_TO_LAYOUT(layoutIndex, 0);
	pself = ObjDerefGen(oself);
    }

    MemFree(fieldIDListHandle);

    /*
     * Take down that hourglass.
     */
    @call appObject::MSG_GEN_APPLICATION_MARK_NOT_BUSY();

    ObjMarkDirty(oself);
}

/***********************************************************************
 *
 * MESSAGE:	MSG_FFD_MOVE_FIELDS_OUT_OF_LAYOUT_LIST
 *
 * DESCRIPTION:
 *	This message moves fields from the layout_list
 *	into the not_in_layout_list.  Pass the indices of the
 *	fields WRT to the layout_list.
 *
 * PARAMETERS:
 * 	void (fieldIDListHandle, word numItems)
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	3/30/92		Initial version
 *	jeremy	4/29/92	    	Updated to handle multiple fields.
 *	jeremy	6/5/92	    	Broke into two simpler messages.
 *	AY	8/19/93		limit the max. # of fields to move at one time
 *
 ***********************************************************************/
@method FlatFileDatabaseClass, MSG_FFD_MOVE_FIELDS_OUT_OF_LAYOUT_LIST
{
    word *fieldIDList;
    FieldListID layoutIndex;
    int i;
    optr appObject = GeodeGetAppObject(0);

    if (numItems > MAX_NUM_FIELDS_TO_MOVE) {
	DisplayUserError(@FFFPCantMoveTooManyFieldsError);
	MemFree(fieldIDListHandle);
	return;
    }

    fieldIDList = MemLock(fieldIDListHandle);

    /*
     * Put up the hourglass, since this operation can be slooow.
     */
    @call appObject::MSG_GEN_APPLICATION_MARK_BUSY();

    /* If there is only one item changed, remember what it was. */
    layoutIndex = fieldIDList[0];

    /* Dereference the fields to the absolute column reference. */
    pself = ObjDerefGen(oself);
    for (i = 0; i < numItems; i++) {
	fieldIDList[i] = (pself->FFI_layoutNameList)[fieldIDList[i]];
    }

    for (i = 0; i < numItems; i++) {
	/* Remove item from the layout_list.
	 * Remove the element from the field navigation order list.
	 * Add the removed field to the layout_list. 
	 * NOTE:  These are actually taken care of in
	 *	  MSG_FFD_DELETE_CHUNK_ELEMENT_FROM_LAYOUT.
	 */

	layoutIndex = FindFieldListElement(pself->FFI_layoutNameList,
					   fieldIDList[i],
					   pself->FFI_numInLayoutNameList);

	@call self::MSG_FFD_DELETE_FIELD_FROM_LAYOUT(layoutIndex);

	pself = ObjDerefGen(oself);
    }

    MemFree(fieldIDListHandle);

    /*
     * Take down the hourglass.
     */
    @call appObject::MSG_GEN_APPLICATION_MARK_NOT_BUSY();
}

/***********************************************************************
 *
 * FUNCTION:	FFDWhichList
 *
 * DESCRIPTION:	Given a FieldListRequest and a pointer to a
 *	    	FlatFileDatabaseInstance, this function returns the
 *	    	appropriate sorted field list.
 *
 * PARAMETERS:	type - which list do you want?
 *	    	pself - which FlatFileDatabaseInstance do you want it from?
 *
 * CALLED BY:	INTERNAL
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	3/30/92		Initial Revision
 *
 ***********************************************************************/
FieldID *
FFDWhichList(FieldListQuery type, FlatFileDatabaseInstance *pself)
{
    switch (type) {
	case DATABASE_NAME_LIST:
	    return (pself->FFI_databaseNameList);
	case NOT_IN_LAYOUT_NAME_LIST:
	    return (pself->FFI_notInLayoutNameList);
	case LAYOUT_NAME_LIST:
	    return (pself->FFI_layoutNameList);
	#if ERROR_CHECK
        default:
	    EC_ERROR(BAD_FIELD_LIST_REQUEST);
	#endif

    }
}

/***********************************************************************
 *
 * FUNCTION:	FFDHowManyInList
 *
 * DESCRIPTION:	Given a FieldListRequest and a pointer to a
 *	    	FlatFileDatabaseInstance, this function returns the
 *	    	number of fields in a sorted field list.
 *
 * PARAMETERS:	type - which list do you want?
 *	    	pself - which FlatFileDatabaseInstance do you want it from?
 *
 * CALLED BY:	INTERNAL
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	3/30/92		Initial Revision
 *
 ***********************************************************************/
 byte
 FFDHowManyInList(FieldListQuery type, FlatFileDatabaseInstance *pself)
{
    switch (type) {
	case DATABASE_NAME_LIST:
	    return (pself->FFI_numFields);
	case NOT_IN_LAYOUT_NAME_LIST:
	    return (pself->FFI_numInNotInLayoutNameList);
	case LAYOUT_NAME_LIST:
	    return (pself->FFI_numInLayoutNameList);
	case ABSOLUTE_COLUMN_NUMBER:
	    return (pself->FFI_numFields);
	#if ERROR_CHECK
        default:
	    EC_ERROR(BAD_FIELD_LIST_REQUEST);
	#endif

    }
}

/***********************************************************************
 *
 * FUNCTION:	FFDAddToFieldCount
 *
 * DESCRIPTION:	Given a FieldListRequest a pointer to a
 *	    	FlatFileDatabaseInstance and a number, this function
 *	    	adds the number to the appropriate field count. 
 *
 * PARAMETERS:	type - which list do you want?
 *	    	pself - which FlatFileDatabaseInstance do you want it from?
 *	    	howMuch - how much to add?
 *
 * CALLED BY:	INTERNAL
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	3/30/92		Initial Revision
 *
 ***********************************************************************/
void
FFDAddToFieldCount(FieldListQuery type, FlatFileDatabaseInstance *pself,
		   int howMuch)
{
    switch (type) {
	case DATABASE_NAME_LIST:
	    pself->FFI_numFields += howMuch;
	    break;
	case NOT_IN_LAYOUT_NAME_LIST:
	    pself->FFI_numInNotInLayoutNameList += howMuch;
	    break;
	case LAYOUT_NAME_LIST:
	    pself->FFI_numInLayoutNameList += howMuch;
	    break;
	#if ERROR_CHECK
        default:
	    EC_ERROR(BAD_FIELD_LIST_REQUEST);
	#endif
    }
}

/***********************************************************************
 *
 * FUNCTION:	DeleteFieldFromList
 *
 * DESCRIPTION:	This function removes an element from a field list
 *	    	and returns its FieldID.
 *
 * PARAMETERS:  list	  - the field list array
 *	    	index 	  - the element from the list to remove
 *	    	numFields - the number of elements in the list
 *
 * CALLED BY:	INTERNAL
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	3/30/92		Initial version
 *
 ***********************************************************************/
FieldID
DeleteFieldFromList(FieldID list[],
		    FieldListID index,
		    FieldListID numFields)
{
    FieldID retval;
    FieldListID i;

    /* Grab the FieldID that's to be deleted. */
    retval = list[index];
    
    /*
     * Nuke the element.  It'd be nice to use memcpy() here, but it's an
     * overlapping copy, hence one that might "yield surprises."
     */
    for (i = index; i < numFields; i++) {
	list[i] = list[i+1];
    }

    return (retval);
}

/***********************************************************************
 *
 * FUNCTION:	DeleteAbsoluteFieldFromList
 *
 * DESCRIPTION:	This function removes an element from a field list
 *	    	based on its column number.  It returns the index
 *	    	of the deleted field (or -1 if the field is not
 *	    	in the list).
 *
 * PARAMETERS:	databaseObject - optr to flatfile database object
 *		list	  - the field list array
 *	    	colNum 	  - the column number to search and destroy.
 *	    	numFields - the number of elements in the list
 *
 * CALLED BY:	INTERNAL
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	5/5/92		Initial version
 *	anna	5/7/92		Changed to call DeleteListElement,
 *				so it also does the right layout things
 *
 ***********************************************************************/
FieldListID
DeleteAbsoluteFieldFromList(FieldID list[],
			    FieldID colNum,
			    FieldListID numFields)
{
    FieldListID i;

    i = FindFieldListElement(list, colNum, numFields);

    if (i != (byte) -1) {
	DeleteFieldFromList(list, i, numFields);
    }

    return (i);
}

/***********************************************************************
 *
 * FUNCTION:	StoreFieldPropertiesInBlock
 *
 * DESCRIPTION:	Given a column number, looks up field property information
 *		and copies it into a data block. Returns the handle of the
 *		(unlocked) data block.
 *
 * PARAMETERS:	MemHandle(byte colNum, optr oself)
 *
 * CALLED BY:	
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy  4/3/92		Initial Revision
 *
 ***********************************************************************/
MemHandle
StoreFieldPropertiesInBlock(byte colNum, optr oself) 
{
    MemHandle fpBlock;
    FFFieldPropertiesMessageBlock *fpData;
    FieldDataAttrs *cellDataPtr;
    CellFormula *expr;
    FlatFileDatabaseInstance *pself;

    pself = ObjDerefGen(oself);

    /* 
     * Allocate a message block. 
     */
    fpBlock = MemAlloc(sizeof(FFFieldPropertiesMessageBlock),
		       HF_DYNAMIC | HF_SHARABLE | HF_SWAPABLE, 
		       HAF_STANDARD | HAF_ZERO_INIT);
    /*
     * If there's not enough memory, return...
     */
    if (fpBlock == 0) {
	DisplayUserError(@FFMemoryFullError);
	return(0);
    }

    fpData = MemLock(fpBlock);
		      
    /* 
     * Lock the cell 
     */
    cellDataPtr = CellLock(&pself->SSI_cellParams,
	     		   FIELD_TYPE_ROW, 
     	     		   colNum);
		
    if (!cellDataPtr) {
	MemUnlock(fpBlock);
	return(0);	/* No cell... */
    }

    fpData->colNum = colNum;

    SpreadsheetNameTextFromToken((SpreadsheetInstance *) pself,
				 cellDataPtr->FDA_nameToken,
				 fpData->fieldName,
				 MAX_FIELD_NAME_LENGTH);

    strcpy(fpData->notes, FFDGetCellNotes(cellDataPtr));

    /* Get the remaining field attributes. */
    FFDFillFieldAttrs(fpData, cellDataPtr);

    /* Free the cell */
    CellUnlock(cellDataPtr);

    /* Now get the computed/default token stream for this field. */
    pself = ObjDerefGen(oself);
    expr = CellLock(&pself->SSI_cellParams,
		    FIELD_DEFAULT_VALUE_ROW, 
		    colNum);
#if ERROR_CHECK
    if (!expr) {
	EC_ERROR(CELL_DOES_NOT_EXIST);
    }
#endif /* ERROR_CHECK */

    fpData->numTokensInTokenStream = expr->CF_formulaSize;
    memcpy(fpData->computedDefaultTokenStream,
	   (char *) expr +sizeof(CellFormula),
	   expr->CF_formulaSize);

    /* Free the cell. */
    CellUnlock(expr);

    /* Unlock the message block */
    MemUnlock(fpBlock);
    MemInitRefCount(fpBlock, (word) 1);

    return(fpBlock);
}

/***********************************************************************
 *
 * MESSAGE:	MSG_FFD_EDIT_FIELD_PROPERTIES for FlatFileDatabaseClass
 *
 * DESCRIPTION:	This message loads up a request to edit a field's
 *	    	properties from a particular field list, sends it
 *	    	off to anyone listening for this particular GCN
 *	    	notification, then initiated the field properties box
 *	    	pointed to by the editFieldOptr.
 *
 * PARAMETERS:
 *	void (FieldListQuery whichList, word fieldID, optr editFieldOptr)
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	4/3/92		Initial version
 *
 ***********************************************************************/
@method FlatFileDatabaseClass, MSG_FFD_EDIT_FIELD_PROPERTIES
{
    MemHandle fpBlock;
    EventHandle msg;
    byte *list;
    byte colNum;

#if ERROR_CHECK
    if (fieldID >= FFDHowManyInList(whichList, pself)) {
	EC_ERROR(BAD_FIELD_ID);
    }
#endif /* ERROR_CHECK */

    /*
     * Get the absolute column number from whichever list the index is
     * for.  It might be a column number already, too.
     */
    if (whichList != ABSOLUTE_COLUMN_NUMBER) {
	list = FFDWhichList(whichList, pself);
	colNum = list[fieldID];
    } else {
	colNum = fieldID;
    }

    fpBlock = StoreFieldPropertiesInBlock(colNum, oself);

    if (!fpBlock) {
       return; /* no cell... */
    }

    @call editFieldOptr::MSG_FFFP_INITIATE_INTERACTION();

    msg = @record (optr) NullClass::MSG_META_NOTIFY_WITH_DATA_BLOCK(
		      MANUFACTURER_ID_GEOWORKS,    /* Manufacturer's ID */
    	    	      GWNT_FLAT_FILE_FIELD_PROPERTIES_STATUS_CHANGE,
    	    	    	    	    	      /* Manufacturer's list type */
    	    	      fpBlock);     	      /* Handle of data block */

    @call GeodeGetAppObject(0)::MSG_META_GCN_LIST_SEND(
    		      (word) 0,	    	      /* GCNListSendFlags */
    		      (EventHandle) msg,      /* Handle to classed event */
    		      (MemHandle) fpBlock,    /* Handle of extra data block */
    (word) GAGCNLT_APP_TARGET_NOTIFY_FLAT_FILE_FIELD_PROPERTIES_STATUS_CHANGE,
    	    	    	    	    	      /* Manufacturer's list type */
    		      (word) MANUFACTURER_ID_GEOWORKS);
    	    	    	    	    	      /* Manufacturer's ID */

}

/***********************************************************************
 *
 * FUNCTION:	FFDGetCellNotes
 *
 * DESCRIPTION:	Given a pointer to a LOCKED cell, this routine returns
 *	    	a pointer to its notes field.
 *
 * PARAMETERS:	cellPtr - pointer to a LOCKED cell.
 *
 * CALLED BY:	INTERNAL
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	4/ 3/92		Initial Revision
 *
 ***********************************************************************/
TCHAR *
FFDGetCellNotes(FieldDataAttrs *cellPtr)
{
    TCHAR *notesrc;

    /* If no cell pointer, then we can't really do anything. */
    if (!cellPtr) {
	EC_ERROR(BAD_CELL_POINTER);
	return (NULL);
    }

    /* Get a field's notes. */
    switch (cellPtr->FDA_type) {
	case FDT_GENERAL_TEXT:
	    notesrc=(char *)cellPtr + sizeof(TextFieldDataAttrs);
	    break;

	case FDT_COMPUTED:
	    notesrc = (char *) cellPtr + sizeof(ComputedFieldDataAttrs);
	    break;

	case FDT_INTEGER:
	case FDT_REAL:
	    notesrc = (char *) cellPtr + sizeof(ValueFieldDataAttrs);
	    break;

	case FDT_DATE:
	case FDT_TIME:
	    notesrc = (char *) cellPtr + sizeof(DateFieldDataAttrs);
	    break;
    }

    return (notesrc);
}

/***********************************************************************
 *
 * FUNCTION:	FFDFillFieldAttrs
 *
 * DESCRIPTION:	This function fills a field property message block
 *	    	with default, length, max, and min 
 *		values as appropriate to a field's type from a LOCKED cell
 *	    	pointer.
 *
 * PARAMETERS:	fpData - pointer to a field property message block to fill
 *	    	cellPtr - pointer to a LOCKED cell.
 *
 * CALLED BY:	INTERNAL
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	4/ 3/92		Initial Revision
 *
 ***********************************************************************/
void
FFDFillFieldAttrs(FFFieldPropertiesMessageBlock *fpData,
		  FieldDataAttrs *cellPtr)
{
    /* If no cell pointer, then we can't really do anything. */
    if (!cellPtr) {
	EC_ERROR(BAD_CELL_POINTER);
	return;
    }

    fpData->dataType = ((FieldDataAttrs *)cellPtr)->FDA_type;

    switch (cellPtr->FDA_type) {
	case FDT_GENERAL_TEXT:
	    fpData->maxNumCharsAllowedInThisTextField = 
		   ((TextFieldDataAttrs *)cellPtr)->TFDA_maxLength;
	    break;

	case FDT_COMPUTED:
	    break;

	case FDT_INTEGER:
	case FDT_REAL:
	    fpData->minValue = ((ValueFieldDataAttrs *)(cellPtr))->VFDA_min;
	    fpData->maxValue = ((ValueFieldDataAttrs *)(cellPtr))->VFDA_max;
	    break;

	case FDT_DATE:
	case FDT_TIME:
	    fpData->minValue = ((DateFieldDataAttrs *)(cellPtr))->DFDA_min;
	    fpData->maxValue = ((DateFieldDataAttrs *)(cellPtr))->DFDA_max;
	    break;
    }
}


/***********************************************************************
 *
 * FUNCTION:	FindFieldListElement
 *
 * DESCRIPTION:	This function finds an element in a field list
 *	    	and returns its FieldListID.
 *
 * PARAMETERS:	list	  - the field list array
 *	    	colNum 	  - the element from the list to find
 *	    	numFields - the number of elements in the list
 *
 *		Returns: the field index if found
 *			 -1 otherwise
 *
 * CALLED BY:	INTERNAL
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	anna	4/2/92		Initial Revision
 *
 ***********************************************************************/
FieldListID
FindFieldListElement(FieldID list[],
		     FieldListID colNum,
		     FieldListID numFields)
{
    FieldListID i;
    Boolean found = FALSE;

    /*
     * Loop around looking for the element
     */
    for (i = 0; i < numFields; i++) {
	if (list[i] == colNum) {
	    found = TRUE;
	    break;
	}
    }

    return(found ? i : -1);
}

/***********************************************************************
 *
 * FUNCTION:    AddFieldToLayoutList
 *
 * DESCRIPTION: Add given field to the layout_list. Puts the field
 *	       in the proper alphabetic place in the list and returns
 *	       the field's new index.
 *
 * CALLED BY:   INTERNAL
 *		
 * PARAMETERS: oself - optr to the current database.
 *	       fieldColumnNum - the column number of the new field. 
 *	       fieldName - the field's name.
 *
 *	       Returns the field's new index.
 *
 * STRATEGY:	
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *     	Name    Date            Description
 *     	----    ----            -----------
 *	a/j 	6/5/92	    	Initial version based on the old AddFieldToList
 *
 ***********************************************************************/
FieldListID
AddFieldToLayoutList(optr oself, byte fieldColumnNum, TCHAR *fieldName)
{
    byte newIndex;
    FlatFileDatabaseInstance *pself;

    pself = ObjDerefGen(oself);
    newIndex = InsertSortedFieldArray(FFDGetColumnFieldName,
				      pself->FFI_layoutNameList,
				      fieldColumnNum,
				      pself->FFI_numInLayoutNameList,
				      fieldName,
				      oself);
    pself = ObjDerefGen(oself);
    pself->FFI_numInLayoutNameList++;   /* increment field count */

    ObjMarkDirty(oself);
    return (newIndex);
}

/***********************************************************************
 *
 * FUNCTION:	FFDAddFieldNameToLayoutListAndTellControllers
 *
 * DESCRIPTION:	This function adds the field name for the given
 *		column number to the layoutNameList and lets the
 *		controllers know.
 *
 * PARAMETERS:	FieldID colNum	- the field's column number
 *		optr oself	- optr to flatfile instance data
 *
 *		returns index (into the layoutNameList) of new field 
 *
 * CALLED BY:	INTERNAL
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	anna	6/5/92		Initial Revision
 *
 ***********************************************************************/
FieldListID
FFDAddFieldNameToLayoutListAndTellControllers(FieldID colNum, optr oself)
{
    TCHAR fieldName[MAX_FIELD_NAME_LENGTH + 1];
    FieldListID newIndex;

    FFDGetColumnFieldName(oself, colNum, fieldName);

    /*
     * Add the name to the layout list
     */
    newIndex = AddFieldToLayoutList(oself, colNum, fieldName);

    /*
     * Notify controllers that are listening
     */
    SendLayoutListNotification(oself, newIndex, ADDED, 0);

    /*
     * Copy the new list into the current layout's data record.
     */
    
    ObjMarkDirty(oself);
    return(newIndex);
}

/***********************************************************************
 *
 * MESSAGE:	MSG_FFD_ADD_NAME_TO_LAYOUT_LIST 
 *		for FlatFileDatabaseClass
 *
 * DESCRIPTION:	
 *		This method finds the field name corresponding to the
 *		given column number, and adds it to the layout list.
 *		It also adds a GrObject for this field to the GrObjBody.
 *		And it notifies the appropriate controllers.
 *
 * PARAMETERS:
 *	void (byte colNum, word width)
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	anna	6/5/92		Initial version
 *	JDM	92.08.26	Added (un)suspension of GrObj body.
 *	ted	1/23/93		Added one more argument
 *
 ***********************************************************************/
@method FlatFileDatabaseClass, MSG_FFD_ADD_NAME_TO_LAYOUT_LIST
{
    FieldID	newIndex;
    int	    	numRecords, i;
    optr	grObjBody;

    numRecords = pself->FFI_totalNumRecordsInDatabase;

    /* Suspend the screen updating of the GrObj Body for this layout.	*/
    grObjBody = @call oself::MSG_FFD_GET_GROBJ_BODY_FOR_LAYOUT
			(pself->FFI_currentLayout,
			 pself->FFI_currentLayoutType);
    @call grObjBody::MSG_META_SUSPEND ();

    newIndex = FFDAddFieldNameToLayoutListAndTellControllers(colNum, oself);

    /*
     * Create a new screen display for the field
     */
    @send oself::MSG_FFD_ADD_FIELD_TO_LAYOUT(newIndex, width);

    /* Unsuspend the GrObj Body.	*/
    @call grObjBody::MSG_META_UNSUSPEND ();

    if (FFDGetDataTypeAndFlags(oself, colNum, NULL) == FDT_COMPUTED) {
	for (i=0 ; i < numRecords ; i++) {
	    @call oself::MSG_FFD_LOAD_TEMP_ROW_FROM_ANOTHER_ROW(i);
		 FFDEvalComputedField(oself,colNum);
		 @call oself::MSG_FFD_STORE_TEMP_ROW_INTO_ANOTHER_ROW(i);
	}
    }

    /* notify map control */
    CreateDataBlockAndSendNotification(oself);

    ObjMarkDirty(oself);
}

/***********************************************************************
 *
 * FUNCTION:    AddFieldToNotInLayoutList
 *
 * DESCRIPTION: Add given field to the not_in_layout_list. Puts the field
 *	       in the proper alphabetic place in the list and returns
 *	       the field's new index.
 *
 * CALLED BY:   INTERNAL
 *		
 * PARAMETERS:  oself - optr to the current database.
 *	       fieldColumnNum - the column number of the new field. 
 *	       fieldName - the field's name.
 *
 *	       Returns the field's new index.
 *
 * STRATEGY:	
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *     	Name    Date            Description
 *     	----    ----            -----------
 *	j/a 	6/5/92	    	Initial version based on the old AddFieldToList
 *
 ***********************************************************************/
FieldListID
AddFieldToNotInLayoutList(optr oself, byte fieldColumnNum, TCHAR *fieldName)
{
    byte newIndex;
    FlatFileDatabaseInstance *pself;

    pself = ObjDerefGen(oself);
    newIndex = InsertSortedFieldArray(FFDGetColumnFieldName,
				      pself->FFI_notInLayoutNameList,
				      fieldColumnNum,
				      pself->FFI_numInNotInLayoutNameList,
				      fieldName,
				      oself);
    pself = ObjDerefGen(oself);
    pself->FFI_numInNotInLayoutNameList++;   /* increment field count */

    ObjMarkDirty(oself);
    return (newIndex);
}

/***********************************************************************
 *
 * MESSAGE:	MSG_FFD_ADD_NAME_TO_NOT_IN_LAYOUT_LIST 
 *		for FlatFileDatabaseClass
 *
 * DESCRIPTION:	
 *		This method finds the field name corresponding to the
 *		given column number, and adds it to the "not in layout" 
 *		list. 
 *
 * PARAMETERS:
 *	void (byte colNum)
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	anna	6/5/92		Initial version
 *
 ***********************************************************************/
@method FlatFileDatabaseClass, MSG_FFD_ADD_NAME_TO_NOT_IN_LAYOUT_LIST
{
    TCHAR fieldName[MAX_FIELD_NAME_LENGTH + 1];
    FieldID newIndex;

    (void) FFDGetColumnFieldName(oself, colNum, fieldName);

    /*
     * The following routine adds the name to the layout list,
     * and adds a screen display for the new field
     */
    newIndex = AddFieldToNotInLayoutList(oself, colNum, fieldName);

    /*
     * Notify any controllers that are listening
     */
    SendDatabaseListNotification(oself, newIndex, ADDED, 0);
    ObjMarkDirty(oself);
}


/***********************************************************************
 *
 * FUNCTION:	FFDChangeGrObjectNameInLayout
 *
 * DESCRIPTION:	This routine looks up a GrObject for a particular field,
 *		and changes its name (text) to the given string.
 *		This is used whenever a field name is changed.
 *
 * PARAMETERS:	dbaseOptr - optr to database object
 *		colNum - which field? 
 *	    	newName	  - self-explanatory 
 *
 * CALLED BY:	INTERNAL
 *
 * STRATEGY:
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	anna	6/10/92		Initial Revision
 *	jeremy	8/7/92	    	Made it work with multiple layouts.
 *
 ***********************************************************************/
void
FFDChangeGrObjectName(optr dbaseOptr, byte colNum, TCHAR *newName)
{
    RecordLayoutChunkArrayHeader *cellDataPtr;
    FieldListID oldIndex, newIndex;
    CellRef cellOptr;
    FlatFileDatabaseInstance *pself;
    RecordLayoutChunkArrayElement *oldIndexElement, *newIndexElement;
    VMFileHandle documentHandle;
    MemHandle grObjectMemBlock;
    VMBlockHandle grObjectVMBlock;
    ChunkHandle grObjectChunk;
    optr grObjectFieldOptr, grObjectLabelOptr, textOptr;
    FieldDataType dataType;

    pself = ObjDerefGen(dbaseOptr);

    /*
     * Look for this particular column in the old, out of date layout.
     */
    cellDataPtr = CellLockGetRef(&pself->SSI_cellParams,
	     		         RECORD_LAYOUT_ROW, 
			         pself->FFI_currentLayout,
			         &cellOptr);

    oldIndex = FindFieldListElement(cellDataPtr->RLCAH_layoutSortedFieldList, 
				    colNum, 
				    cellDataPtr->RLCAH_numFieldsInLayout);

#if ERROR_CHECK
    if (oldIndex == (FieldListID) -1) {
	EC_ERROR(BAD_FIELD_ID);
    }
#endif /* ERROR_CHECK */

    /*
     * Store the new sorted field list in the chunk array header.
     */
    pself = ObjDerefGen(dbaseOptr);
    memcpy(&cellDataPtr->RLCAH_layoutSortedFieldList, 
	   &pself->FFI_layoutNameList,
	   MAX_NUM_FIELDS);

    /*
     * Grab the field's grobj vm block and grobj chunk for the new
     * chunk array element.
     */
    oldIndexElement = ChunkArrayElementToPtr(cellOptr, 
					     oldIndex, 
					     (word *)0);
    grObjectVMBlock = oldIndexElement->GOEOP_grObjectVMBlock;
    grObjectChunk   = oldIndexElement->GOEOP_grObjectChunk;
    
    /*
     * We have the old chunk's crucial data.  Nuke it from the chunk array.
     */
    ChunkArrayDelete(cellOptr, oldIndexElement);
    
    /*
     * Ok, now figure out where in the new list to put the new
     * chunk array element.
     */
    cellDataPtr = LMemDeref(cellOptr);
    newIndex = FindFieldListElement(cellDataPtr->RLCAH_layoutSortedFieldList, 
				    colNum, 
				    cellDataPtr->RLCAH_numFieldsInLayout);
    /*
     * The new index is where we want to insert the new chunk element.
     */
    pself = ObjDerefGen(dbaseOptr);
    if (newIndex == pself->FFI_numInLayoutNameList - 1) {
	newIndexElement = ChunkArrayAppend(cellOptr, 0);
    } else {
        /*
         * Get a pointer to the grobject we want to insert _before_
         */
        oldIndexElement = ChunkArrayElementToPtr(cellOptr, 
						 newIndex, 
						 (word *)0);

        newIndexElement = ChunkArrayInsertAt(cellOptr, 
					     oldIndexElement, 
					     0);
    }

    /*
     * Fill in the VM block and chunk handle for the new GrObject
     */
    newIndexElement->GOEOP_grObjectVMBlock = grObjectVMBlock;
    newIndexElement->GOEOP_grObjectChunk = grObjectChunk;
    
    /*
     * Dirty & unlock the cell 
     */
    cellDataPtr = LMemDeref(cellOptr);
    CellDirty(cellDataPtr);
    CellUnlock(cellDataPtr);

    /*
     * Get the associated field and label GrObjects
     */
    pself = ObjDerefGen(dbaseOptr);
    documentHandle = pself->documentHandle;
    grObjectMemBlock = VMVMBlockToMemBlock(documentHandle, grObjectVMBlock);
    grObjectFieldOptr = ConstructOptr(grObjectMemBlock, grObjectChunk);
    grObjectLabelOptr = @call grObjectFieldOptr::
	MSG_FFTFG_GET_LABEL_OPTR(documentHandle);

    /*
     * Tell the field what its new type is.
     */
    dataType = FFDGetDataTypeAndFlags(dbaseOptr, colNum, NULL);
    @send grObjectFieldOptr::MSG_FFTFG_SET_FIELD_TYPE(dataType);
    @send grObjectFieldOptr::MSG_FFTFG_SET_FOR_DESIGN_MODE();
    
    /*
     * Replace the field and label's text
     */
    textOptr = @call grObjectFieldOptr::MSG_GOVG_GET_VIS_WARD_OD();
    @send textOptr::MSG_VIS_TEXT_REPLACE_ALL_PTR(newName, 0);

    if (grObjectLabelOptr) {
	TCHAR labelText[MAX_TOTAL_NAME_LENGTH + 2];

    	sprintf(labelText, _TEXT("%s:"), newName);
	textOptr = @call grObjectLabelOptr::MSG_GOVG_GET_VIS_WARD_OD();
	@send textOptr::MSG_VIS_TEXT_REPLACE_ALL_PTR(labelText, 0);
    }
}

/***********************************************************************
 *
 * MESSAGE:	MSG_FFD_CHANGE_NAME_IN_LAYOUT_LIST 
 *		for FlatFileDatabaseClass
 *
 * DESCRIPTION:	
 *      This message changes a name in the layout_name_list and
 *      changes its screen label as well.  Pass the column number of the
 *      changed name.  The field will be repositioned in the list, and
 *      appropriate list notifications will be made.
 *
 * PARAMETERS:
 *	void (byte colNum)
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	anna	6/5/92		Initial version
 *
 ***********************************************************************/
@method FlatFileDatabaseClass, MSG_FFD_CHANGE_NAME_IN_LAYOUT_LIST
{
    FieldListID indexIntoLayoutList;
    byte numFields;
    TCHAR newName[MAX_TOTAL_NAME_LENGTH];

    numFields = FFDHowManyInList(LAYOUT_NAME_LIST, pself);

    indexIntoLayoutList = FindFieldListElement(pself->FFI_layoutNameList,
				   	       colNum, 
				               numFields);
    /*
     * See if the field exists in this list. If not, do nothing.
     */
    if (indexIntoLayoutList == (byte) -1) {
	return;
    }

    /*
     * Delete the current name from the layoutNameList
     */
    (void) DeleteFieldFromList(pself->FFI_layoutNameList,
				  indexIntoLayoutList,
				  numFields);
    pself->FFI_numInLayoutNameList--;

    /*
     * Notify controllers of the deletion
     */
    SendLayoutListNotification(oself, indexIntoLayoutList, DELETED, 0);

    /*
     * Add the new name to the layoutNameList
     */
    (void) FFDAddFieldNameToLayoutListAndTellControllers(colNum, oself);

    /*
     * Change the text in the GrObject 
     */
    @call oself::MSG_FFD_GET_COLUMN_FIELD_NAME(colNum, newName);

    FFDChangeGrObjectName(oself, colNum, newName);

    ObjMarkDirty(oself);
}

/***********************************************************************
 *
 * MESSAGE:	MSG_FFD_CHANGE_NAME_IN_NOT_IN_LAYOUT_LIST 
 *		for FlatFileDatabaseClass
 *
 * DESCRIPTION:	
 *      This message changes a name in the not_in_layout_name_list 
 *      Pass the column number of the changed name.  The field will 
 *	be repositioned in the list, and
 *      appropriate list notifications will be made.
 *
 * PARAMETERS:
 *	void (byte colNum)
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	anna	3/4/92		Initial version
 *
 ***********************************************************************/
@method FlatFileDatabaseClass, MSG_FFD_CHANGE_NAME_IN_NOT_IN_LAYOUT_LIST
{
    FieldListID indexIntoNotInLayoutList;
    byte numFields;

    numFields = FFDHowManyInList(NOT_IN_LAYOUT_NAME_LIST, pself);

    indexIntoNotInLayoutList = FindFieldListElement(
					pself->FFI_notInLayoutNameList,
				   	       colNum, 
				               numFields);
    /*
     * See if the field exists in this list. If not, do nothing.
     */
    if (indexIntoNotInLayoutList == (byte) -1) {
	return;
    }

    /*
     * Delete the current name from the notInLayoutNameList
     */
    (void) DeleteFieldFromList(pself->FFI_notInLayoutNameList,
				  indexIntoNotInLayoutList,
				  numFields);
    pself->FFI_numInNotInLayoutNameList--;

    /*
     * Notify controllers of the deletion
     */
    SendDatabaseListNotification(oself, indexIntoNotInLayoutList, DELETED, 0);

    /*
     * Add the new name to the layoutNameList
     */
    @call self::MSG_FFD_ADD_NAME_TO_NOT_IN_LAYOUT_LIST(colNum);

    ObjMarkDirty(oself);
}

/***********************************************************************
 *
 * FUNCTION:	DeleteListElementFromAllLists
 *
 * DESCRIPTION:	This function removes an element from all of the
 *		instance data lists:
 *		FFI_databaseNameList
 *		FFI_layoutNameList
 *		FFI_notInLayoutNameList
 *		Also updates all of the "number of fields in each list"
 *		instance data.
 *
 * PARAMETERS:	databaseObject - an optr to the current database
 *	    	colNum - the column of the field to delete
 *
 * CALLED BY:	INTERNAL
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	anna	4/02/92		Initial Revision
 *
 ***********************************************************************/
void
DeleteListElementFromAllLists(optr databaseObject,
			      FieldListID colNum)
{
    word numFields;
    FlatFileDatabaseInstance *instancePtr;

    instancePtr = ObjDerefGen(databaseObject);

    /*
     * Delete the column number from the "whole database" list in
     * the instance data
     */
    numFields = FFDHowManyInList(DATABASE_NAME_LIST, instancePtr);

    (void) DeleteAbsoluteFieldFromList(instancePtr->FFI_databaseNameList,
				       colNum,
				       numFields);
    instancePtr->FFI_numFields--;

    /*
     * Delete the column number from the "layout" list in
     * the instance data
     */
    numFields = FFDHowManyInList(LAYOUT_NAME_LIST, instancePtr);
    (void) DeleteAbsoluteFieldFromList(instancePtr->FFI_layoutNameList,
				       colNum,
				       numFields);
    instancePtr->FFI_numInLayoutNameList--;

    /*
     * Delete the column number from the "not in layout" list in
     * the instance data
     */
    numFields = FFDHowManyInList(NOT_IN_LAYOUT_NAME_LIST, instancePtr);

    (void) DeleteAbsoluteFieldFromList(instancePtr->FFI_notInLayoutNameList,
				      colNum,
				      numFields);
    instancePtr->FFI_numInNotInLayoutNameList--;

    ObjMarkDirty(databaseObject);
}


/***********************************************************************
 *
 * MESSAGE:	MSG_FFD_DELETE_FIELDS_BUT_ASK_FIRST for FlatFileDatabaseClass
 *
 * DESCRIPTION:	This message takes a list of field indices from a field
 *	    	list and prompts the user if they really want to delete
 *	    	each one.  If so, MSG_FFD_DELETE_FIELD is called.
 *
 * PARAMETERS:
 *	void (MemHandle fieldIDListHandle, FieldListQuery list, word numItems);
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	4/28/92		Initial version
 *	jeremy	5/5/92	    	Updated to handle multiple selections
 *
 ***********************************************************************/
@method FlatFileDatabaseClass, MSG_FFD_DELETE_FIELDS_BUT_ASK_FIRST
{
    word i;
    FieldListID *fromList;
    word *fieldIDList;
    TCHAR name[MAX_TOTAL_NAME_LENGTH];
    InteractionCommand response;

    /* Lock down the list. */
    fieldIDList = MemLock(fieldIDListHandle);
    fromList = FFDWhichList(list, pself);

    /* Dereference the items in this list. */
    for (i = 0; i < numItems; i++) {
	fieldIDList[i] = (word)fromList[fieldIDList[i]];
    }
	
    /* For each item, ask if it's really to be deleted. */
    for (i = 0; i < numItems; i++) {
	/* Get the name of the field to be deleted. */
    	(void) FFDGetColumnFieldName(oself, (word) fieldIDList[i], name);

	/*
	 * Check to make sure the field has no dependents.
	 * If it does, warn the user that the field will not be
	 * deleted.  If the field does NOT have dependents, ask
	 * the user for permission before deleting the thing.
	 */
	if (FFDFieldDependedUpon(oself, fieldIDList[i])) {
	    /*
	     * The field has dependents.  Put up an error message,
	     * and don't remove the thing from any name lists.
	     */
	    MemLock(OptrToHandle(@FFDFieldHadDependents));
	    
	    response = UserStandardDialog(
	    	(TCHAR *)0,
                /* not GIT_MULTIPLE_RESPONSE, so no custom triggers  */
                (TCHAR *)0,
                /* One string argument: the field name. */
                (TCHAR *)0, name,
                /* dialog string */
		LMemDeref(@FFDFieldHadDependents),
                /* dialog type */
                (CDT_WARNING << CDBF_DIALOG_TYPE_OFFSET) |
                /* interaction type */
                (GIT_NOTIFICATION << CDBF_INTERACTION_TYPE_OFFSET));

	    /* Release the warning string */
	    MemUnlock(OptrToHandle(@FFDFieldHadDependents));
	} else {
	    /*
	     * The field has no dependents.  Now
	     * prompt the user: are you serious?
	     */
	    MemLock(OptrToHandle(@FFDConfirmDeleteField));
    
	    response = UserStandardDialog(
	    	(TCHAR *)0,
                /* not GIT_MULTIPLE_RESPONSE, so no custom triggers  */
                (TCHAR *)0,
                /* One string argument: the field name. */
                (TCHAR *)0, name,
                /* dialog string */
		LMemDeref(@FFDConfirmDeleteField),
                /* dialog type */
                (CDT_QUESTION << CDBF_DIALOG_TYPE_OFFSET) |
                /* interaction type */
                (GIT_AFFIRMATION << CDBF_INTERACTION_TYPE_OFFSET)); 

	    if (response == IC_YES) {
		/* The user said OK, so let's go. */
		pself = ObjDerefGen(oself);
		(void) FFDDeleteField(fieldIDList[i], oself);

		/*
		 * List notification is handled here.
		 */
		@send self::
		    MSG_FFD_DELETE_NAME_FROM_NOT_IN_LAYOUT_LIST(fieldIDList[i]);
	    }

	    /* Release the warning string */
	    MemUnlock (OptrToHandle (@FFDConfirmDeleteField));
	}
    }

    MemFree(fieldIDListHandle);

    /* Always reset the whole database.  Why?  Because we've got only 5
     * weeks to implement this product, that's why. */
    if (response == IC_YES) {
	pself = ObjDerefGen(oself);
        SendWholeListNotification(oself, 0, RESET,
			      FFDHowManyInList(DATABASE_NAME_LIST, pself));
    }
}

/***********************************************************************
 *
 * MESSAGE:	MSG_FFD_DELETE_FIELD for FlatFileDatabaseClass
 *
 * DESCRIPTION:	
 *		This message deletes a field from the database.
 *	    	TRUE is returned if the field was deleted successfully,
 *	    	FALSE is returned otherwise.
 *
 *	    	See FFDDeleteField() for details. 
 *
 * PARAMETERS:
 *	Boolean (byte colNum)
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	anna	4/02/92		Initial version
 *	jeremy	5/5/92	    	Moved most of the functionality to
 *	    	    	    	FFDDeleteField.
 *	anna	6/4/92		Revamped to *only* delete fields from
 *				the database, and the "database name"
 *				list (no extra list/GrObj manipulation)
 *	jeremy	12/20/92    	Added return values for success/failure.
 *
 ***********************************************************************/
@method FlatFileDatabaseClass, MSG_FFD_DELETE_FIELD
{
    FieldListID fieldIndexInDatabaseNameList;

    fieldIndexInDatabaseNameList = FindFieldListElement(
			     pself->FFI_databaseNameList,
			     colNum, 
			     FFDHowManyInList(DATABASE_NAME_LIST, pself));

    /* Delete the element. */
    if (!FFDDeleteField(colNum, oself)) {
	/*
	 * The field had dependents, so was not deleted.
	 */
	return FALSE;
    }

    /*
     * Send notification to the controllers to update themselves
     */
    SendWholeListNotification(oself, 
			      fieldIndexInDatabaseNameList, 
			      DELETED, 
			      0);

    /*
     * Signal that the field was deleted.
     */
    return TRUE;
}

/***********************************************************************
 *
 * FUNCTION:	FFDDeleteFieldFromAllLayouts
 *
 * DESCRIPTION:	This message deletes the given field from all layouts except
 *		the current one.
 *
 * PARAMETERS:	oself - FlatFileDatabase optr.
 *		colNum - field column number
 *
 * CALLED BY:	INTERNAL
 *
 * STRATEGY:
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	anna	9/28/92		Initial Revision
 *
 ***********************************************************************/
void 
FFDDeleteFieldFromAllLayouts(optr oself, byte colNum)
{
    byte i, layoutNum, layoutIndex;
    FlatFileDatabaseInstance *pself = ObjDerefGen(oself);

    layoutIndex = 1;	/* Start at one; it can never be 0, because the
				layout names are stored in column 0 */

    for (i = 0; i < pself->FFI_numLayouts; i++) {
        layoutNum = 0;	
	while (layoutNum == 0) {
	    if (pself->FFI_layoutColumnsTaken[layoutIndex/8] & 
				(0x80 >> (layoutIndex % 8))) {
		layoutNum = layoutIndex;
	    }
	    layoutIndex++;
 	}

	if (layoutNum != pself->FFI_currentLayout) {
	    /*
	     * This routine gets rid of the GrObjects associated with the
	     * field and label
	     */
	    FFDDeleteFieldFromLayout(oself, colNum, layoutNum);

	    /*
	     * This routine cleans up the chunk array for the grobjects
	     * associated with this field
	     */
	    FFDDeleteChunkElementFromLayout(oself, colNum, layoutNum);

  	}

	pself = ObjDerefGen(oself);
    }
}

/***********************************************************************
 *
 * FUNCTION:	FFDFieldDependedUpon
 *
 * DESCRIPTION:	This function checks whether or not a specific field
 *	    	has dependents.  If it does, TRUE is returned.  If it
 *	    	does not have any dependents, FALSE is returned.
 *
 * PARAMETERS:	oself - an optr to the current database
 *	    	colNum - the column of the field to be checked.
 *
 * CALLED BY:	INTERNAL
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	12/20/92	Initial version
 *
 ***********************************************************************/
Boolean
FFDFieldDependedUpon(optr oself, FieldID colNum)
{
    FlatFileDatabaseInstance *pself;
    CellCommon *cell;
    Boolean dependedUpon;

    pself = ObjDerefGen(oself);
    cell = CellLock(&pself->SSI_cellParams,
		    TEMP_DATA_ROW,
		    colNum);

    if (cell) {
	dependedUpon = (cell->CC_dependencies != 0);
	CellUnlock(cell);
    } else {
	dependedUpon = FALSE;
    }

    if (!dependedUpon) {
	/*
	 * Check to see if it was depended upon by a default expression.
	 */
	cell = CellLock(&pself->SSI_cellParams,
			FIELD_DEFAULT_VALUE_ROW,
			colNum);
	if (cell) {
	    dependedUpon = (cell->CC_dependencies != 0);
	    CellUnlock(cell);
	} /* else dependedUpon already == FALSE */
    }
	
    return dependedUpon;
}


/***********************************************************************
 *
 * MESSAGE:	MSG_FFD_FIELD_DEPENDED_UPON for FlatFileDatabaseClass
 *
 * DESCRIPTION:	This method checks whether or not a specific field
 *	    	has dependents.  If it does, TRUE is returned.  If it
 *	    	does not have any dependents, FALSE is returned.
 *
 * PARAMETERS:  FieldID colNum - the column of the field to be checked.
 *
 * PARAMETERS:
 *	Boolean (FieldID colNum)
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	12/20/92	Initial version
 *
 ***********************************************************************/
@method FlatFileDatabaseClass, MSG_FFD_FIELD_DEPENDED_UPON
{
    return (FFDFieldDependedUpon(oself, colNum));
}

/***********************************************************************
 *
 * FUNCTION:	FFDDeleteField
 *
 * DESCRIPTION:	This message deletes a field from the database.
 *	    	If the field is still depended upon by a computed
 *	    	field, THE FIELD WILL NOT BE DELETED.
 *
 *	    	TRUE will be returned if the field was deleted;
 *	    	FALSE will be returned if there was a dependency.
 *
 *		Specifically, it:
 *		(an x below means this part has been implemented)
 *x		- Clears the column of data associated with the field
 *x		  (doesn't delete it)
 *x		- Clears the data in the current row (TEMP_DATA_ROW)
 *x		- Clears the field definition from the data type row.
 *x		- Deletes the field name from the name database.
 *x		- Deletes the default value/computed value from the default 
 *x		  row.
 *x		- Updates instance data like FFI_numFields and
 *x		  FFI_sortedFields.
 *x		- Updates FFI_columnsTaken
 *x		- Updates the list of names (FFI_databaseNameList)
 *x		- Goes through all layouts and deletes the field
 *x		- Delete all references to the field from the sort data.
 *x		- Delete all references to the field from the field
 *		  navigation order data.
 *
 * PARAMETERS:	colNum - field column number
 *	    	oself - FlatFileDatabase optr.
 *
 * CALLED BY:	INTERNAL
 *
 * STRATEGY:
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	5/ 5/92		Initial Revision
 *	anna	6/4/92		Revamped to *only* delete fields from
 *				the database, and the "whole database"
 *				list (no extra list/GrObj manipulation)
 *	jeremy	12/18/92    	Added check for dependencies and return value.
 *	JDM	92.12.29	Sort data reference nuking.
 *
 ***********************************************************************/
Boolean
FFDDeleteField(byte colNum, optr oself)
{
    FlatFileDatabaseInstance *pself;
    word i; 
    byte numFields;
    FieldListID indexIntoList;

    /*
     * First check to see if there is a dependency for this field.
     */
    if (FFDFieldDependedUpon(oself, colNum)) {
	/*
	 * The cell still has dependents.  Bail.
	 */
	return FALSE;
    }

    /*
     * Nuke any reference to the field/column in the field navigation
     * order and/or in the sort data.
     * Note that these calls (may) rely on the fact that the
     * databaseNameList has *not* yet been updated.
     */
    @call oself::MSG_FFD_SORT_INFO_NUKE_FIELD (colNum);

    /*
     * If the field has an expression, alert the fields it depends on
     * that it's going away.
     */
    FFDRemoveDependencies(oself, TEMP_DATA_ROW, colNum);
    FFDRemoveDependencies(oself, FIELD_DEFAULT_VALUE_ROW, colNum);

    /*
     * run through the data cells, clearing them along the way 
     */
    pself = ObjDerefGen(oself);
    for (i = 0; i < pself->FFI_totalNumRecordsInDatabase; i++) {
        CellReplace(&pself->SSI_cellParams,
		    i, 
		    (word) colNum,
		    (void *) 0,
		    0);
	pself = ObjDerefGen(oself);
    }

    /*
     * Clear the cell with data for the current row
     */
    CellReplace(&pself->SSI_cellParams,
		TEMP_DATA_ROW, 
		(word) colNum,
		(void *) 0,
		0);

    /*
     * Delete the name from the name database
     */
    DeleteFieldName(oself, colNum);

    /* 
     * Clear the cell with Field Properties information 
     */
    pself = ObjDerefGen(oself);
    CellReplace(&pself->SSI_cellParams,
		FIELD_TYPE_ROW, 
		(word) colNum,
		(void *) 0,
		0);
		
    /*
     * Clear the default/computed value
     */
    pself = ObjDerefGen(oself);
    CellReplace(&pself->SSI_cellParams,
		FIELD_DEFAULT_VALUE_ROW, 
		(word) colNum,
		(void *) 0,
		0);

    /*
     * Delete the column number from the "database name" list in
     * the instance data
     */
    pself = ObjDerefGen(oself);
    numFields = FFDHowManyInList(DATABASE_NAME_LIST, pself);

    indexIntoList = FindFieldListElement(pself->FFI_databaseNameList,
					 colNum, 
					 numFields);

    (void) DeleteFieldFromList(pself->FFI_databaseNameList,
			       indexIntoList,
			       numFields);
    pself->FFI_numFields--;

    /*
     * Was there only one field? If so, then number of records now = 0
     */
    if (pself->FFI_numFields == 0) {
	pself->FFI_totalNumRecordsInDatabase = 0;
	pself->FFI_numRecords = 0;
	pself->FFI_numMarkedRecords = 0;
	pself->SSI_active.CR_row = 0;
    }

    FFDDeleteFieldFromAllLayouts(oself, colNum);

    /*
     * Update "columns taken" array
     */
    pself = ObjDerefGen(oself);
    pself->FFI_columnsTaken[colNum/8] =
	    	pself->FFI_columnsTaken[colNum/8] & (~(0x80 >> (colNum % 8))); 

    ObjMarkDirty(oself);
    return TRUE;
}


/***********************************************************************
 *
 * FUNCTION:	FFDRemoveDependencies
 *
 * DESCRIPTION:	This function alerts the fields that we depend on
 *	    	that we no longer depend on them.  Pass the row and
 *	    	column of the field that might depend on other fields.
 *
 * PARAMETERS:	oself - an optr to the current database
 *	        rowNum - the field's row number
 *	    	colNum - the field's column
 *
 * CALLED BY:	INTERNAL
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	12/21/92	Initial version
 *
 ***********************************************************************/
void
FFDRemoveDependencies(optr oself, word rowNum, FieldID colNum)
{
    CellFormula *cell;
    FlatFileDatabaseInstance *pself = ObjDerefGen(oself);

    cell = CellLock(&pself->SSI_cellParams, rowNum, colNum);

    /*
     * If there's no cell, we're done.
     */
    if (!cell) {
	return;
    }
    
    /*
     * If we're not a formula or we have no tokens, we're all done.
     */
    if ((cell->CF_common.CC_type != CT_FORMULA) || (cell->CF_formulaSize == 0)){
	CellUnlock(cell);
	return;
    }

    /*
     * We have an expression to deref any dependencies!  Do it.
     */
    CellUnlock(cell);
    SpreadsheetCellAddRemoveDeps((SpreadsheetInstance *)pself,
				 (dword) &(pself->SSI_cellParams),
				 FFDParseLibraryCallback,
				 (word) 1,  /* <- remove dependencies */
				 (word) EF_MAKE_DEPENDENCIES,
				 (word) rowNum,
				 (word) colNum,
				 (word) rowNum,
				 (word) pself->SSI_maxCol);
}


/***********************************************************************
 *
 * FUNCTION:	DeleteFieldName
 *
 * DESCRIPTION:	This function deletes a field name from the database
 *
 * PARAMETERS:	colNum	  - column number  
 *
 * CALLED BY:	INTERNAL
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	anna	4/06/92		Initial Revision
 *
 ***********************************************************************/
void
DeleteFieldName(optr selfOptr, byte colNum)
{
    SpreadsheetNameParams fieldNameParams;
    GetNameInfo	fieldNameInfo;
    FieldDataAttrs *cellDataPtr;
    FlatFileDatabaseInstance *pself;

    pself = ObjDerefGen(selfOptr);

    /* 
     * Lock the cell 
     */
    cellDataPtr = CellLock(&pself->SSI_cellParams,
	     		   FIELD_TYPE_ROW, 
     	     		   colNum);
		
    if (cellDataPtr) {
        fieldNameParams.SNP_flags = NAF_BY_TOKEN;
        fieldNameParams.SNP_listEntry = cellDataPtr->FDA_nameToken;
        CellUnlock(cellDataPtr);

        @call selfOptr::MSG_SPREADSHEET_DELETE_NAME(&fieldNameInfo, 
						&fieldNameParams); 
    }
}

/***********************************************************************
 *
 * MESSAGE:	MSG_FFD_DELETE_NAME_FROM_LAYOUT_LIST 
 *		for FlatFileDatabaseClass
 *
 * DESCRIPTION:	
 *		This method 
 *		(1) deletes the given name (column) from the
 *		    layout list.
 *		(2) updates FFI_numInLayoutNameList.
 *		(3) sends out a notification to listening controllers
 *		(4) deletes the screen representation (GrObject) for
 *		    this field in this layout.
 *		Note: if the given column does not exists in the
 *			layout list, this method does nothing.
 *
 *		When we have layouts, this will also cycle through
 *		the layouts and delete the field wherever it's found. 
 *
 * PARAMETERS:
 *	void (byte colNum)
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	anna	6/4/92		Initial version
 *
 ***********************************************************************/
@method FlatFileDatabaseClass, MSG_FFD_DELETE_NAME_FROM_LAYOUT_LIST
{
    byte numFields;
    FieldID indexIntoLayoutList;

    numFields = FFDHowManyInList(LAYOUT_NAME_LIST, pself);

    indexIntoLayoutList = FindFieldListElement(pself->FFI_layoutNameList,
					       colNum, 
					       numFields);

    if (indexIntoLayoutList != (byte) -1) {
        (void) DeleteFieldFromList(pself->FFI_layoutNameList,
				      indexIntoLayoutList,
				      numFields);
        pself->FFI_numInLayoutNameList--;

	/*
	 * Get rid of the GrObject representation of the
	 * field in the current layout
	 */
        @send self::MSG_FFD_DELETE_FIELD_FROM_LAYOUT(indexIntoLayoutList);

	/* 
	 * Let the controller(s) know
	 */
	SendLayoutListNotification(oself, indexIntoLayoutList, DELETED, 0);

	ObjMarkDirty(oself);
    }
}

/***********************************************************************
 *
 * MESSAGE:	MSG_FFD_DELETE_NAME_FROM_NOT_IN_LAYOUT_LIST 
 *		for FlatFileDatabaseClass
 *
 * DESCRIPTION:	
 *		This method 
 *		(1) deletes the given name (column) from the
 *		    "not in layout" list.
 *		(2) updates FFI_numInNotInLayoutNameList.
 *		(3) sends out a notification to listening controllers
 *		Note: if the given column does not exists in the
 *			"not in layout" list, this method does nothing.
 *
 * PARAMETERS:
 *	void (byte colNum)
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	anna	6/4/92		Initial version
 *
 ***********************************************************************/
@method FlatFileDatabaseClass, MSG_FFD_DELETE_NAME_FROM_NOT_IN_LAYOUT_LIST
{
    byte numFields;
    FieldListID indexIntoList;

    numFields = FFDHowManyInList(NOT_IN_LAYOUT_NAME_LIST, pself);

    indexIntoList = FindFieldListElement(pself->FFI_notInLayoutNameList,
					 colNum, 
					 numFields);

    if (indexIntoList != (byte) -1) {
        (void) DeleteFieldFromList(pself->FFI_notInLayoutNameList,
				   indexIntoList,
				   numFields);
        pself->FFI_numInNotInLayoutNameList--;

	/* 
	 * Let the controller(s) know
	 */
	SendDatabaseListNotification(oself, indexIntoList, DELETED, 0);

	ObjMarkDirty(oself);
    }
}

/***********************************************************************
 *
 * MESSAGE:	MSG_FFD_DELETE_CURRENT_RECORD 
 *		for FlatFileDatabaseClass
 *
 * DESCRIPTION:	
 *		Deletes the current record (SSI_active.CR_row) from the 
 *		database.
 *		Updates FFI_*num*Records.
 *		Leaves SSI_active.CR_row the same, unless it is the last row,
 *		in which case it gets set to the *new* last row.
 *
 * PARAMETERS:
 *	void ()
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	anna	6/8/92		Initial version
 *
 ***********************************************************************/
@method FlatFileDatabaseClass, MSG_FFD_DELETE_CURRENT_RECORD
{
    SpreadsheetRangeParams selectionRange;
    word lastMarkedRecord;

    /*
     * Even if we are showing all records right now, if we just deleted
     * a marked record, we'll need to update the number of marked records
     */
    if (!pself->FFI_showOnlyMarked) {
	if (FFDGetRecordMarkStatus(pself, pself->SSI_active.CR_row)) {
	    pself = ObjDerefGen(oself);
	    pself->FFI_numMarkedRecords--;	
	}
    }

    /*
     * First set the selection
     */
    selectionRange.SRP_selection.CR_start.CR_row = pself->SSI_active.CR_row;
    selectionRange.SRP_selection.CR_start.CR_column = 0;

    selectionRange.SRP_selection.CR_end.CR_row = pself->SSI_active.CR_row;
    selectionRange.SRP_selection.CR_end.CR_column = MAX_NUM_FIELDS-1;

    /*
     * Set the active cell 
     */
    selectionRange.SRP_active.CR_row = pself->SSI_active.CR_row;
    selectionRange.SRP_active.CR_column = 0;

    @call self::MSG_SPREADSHEET_SET_SELECTION(&selectionRange);

    /*
     * Clear the data out of the cells first, to avoid the infinitely-growing-
     * file-problem(tm).
     */
    @call self::MSG_SPREADSHEET_CLEAR_SELECTED(SCF_CLEAR_ATTRIBUTES |
					       SCF_CLEAR_DATA 	    |
					       SCF_CLEAR_NOTES);

    /*
     * Now delete the range.
     */
    @call self::MSG_SPREADSHEET_INSERT_SPACE(SIF_COMPLETE | SIF_DELETE);


    /*
     * Update the number of records in the database
     */
    pself = ObjDerefGen(oself);
    pself->FFI_totalNumRecordsInDatabase--;
    pself->FFI_numRecords--;

    if (!pself->FFI_showOnlyMarked) {
	/*
	 * We're showing all records.   Were we on the last row? If so,
	 * reset the current row to be the new last row.
	 */
	if (pself->FFI_numRecords == pself->SSI_active.CR_row) {
	    pself->SSI_active.CR_row--;
	}
    } else {
	/*
	 * We're showing only marked records.
	 */
	if (--(pself->FFI_numMarkedRecords) == 0) {
	    /*
	     * We just deleted all of the marked records.  Leave it to the
	     * caller to determine this through FFI_numMarkedRecords.
	     */
	    return;
	}

	/*
	 * There are still marked records left, so jump to the nearest
	 * marked record.
	 */
	if (pself->FFI_currentMarkedRecord >= pself->FFI_numMarkedRecords) {
	    /*
	     * We deleted the last marked record.  Find the previous one.
	     */
	    lastMarkedRecord =
		FFDGetNthMarkedRecord(oself, pself->FFI_numMarkedRecords);

	    #if ERROR_CHECK
	    	/*
		 * Hey! I thought there were some marked records left!
		 */
    	    	if (lastMarkedRecord == NOT_A_RECORD) {
		    EC_ERROR(NO_MARKED_RECORDS);
		}
 	    #endif /* ERROR_CHECK */

	    pself->SSI_active.CR_row = lastMarkedRecord;
	    pself->FFI_currentMarkedRecord = pself->FFI_numMarkedRecords - 1;
	}
    }

    /*
     * Dirty ourself, since we changed instance data.
     */
    ObjMarkDirty(oself);
}

/***********************************************************************
 *
 * FUNCTION:	CheckNumber 
 *
 * DESCRIPTION:	Check whether given text string is a legal number.  
 *		If it is, places the FloatNum representation of it in
 *		the passed address.
 *
 * PARAMETERS:  Boolean CheckNumber (
 *			FieldDataType dataType,
 *			MemHandle textBlock,
 *			dword FloatAddress)
 *		
 *		Returns TRUE if OK (block is locked)
 *			FALSE otherwise (block is freed)
 *
 * STRATEGY:	
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	anna	3/92		Initial Revision
 *	anna	4/20/92		Moved to Database library
 *
 **********************************************************************/
Boolean
CheckNumber(FieldDataType dataType, MemHandle textBlock, 
	    dword floatAddress)
{
    TCHAR *textPtr;
    sdword intValue;
    FloatNum *floatPtr;

    textPtr = MemLock(textBlock);

    if (*textPtr != _TEXT('\0')) {
	if (dataType == FDT_INTEGER) {
            if (UtilAsciiToHex32(textPtr, &intValue) != 0) {
	        /* error! */
		MemFree(textBlock);
	        return(FALSE);
	    }
 	}

        if ((FloatAsciiToFloat(FAF_STORE_NUMBER, strlen(textPtr), 
				textPtr, (void *)floatAddress)) != 0) {
	    /* error! */
	    MemFree(textBlock);
	    return(FALSE);
        }
    }
    else {
    /*
     * value does not exist
     */
        floatPtr = (FloatNum *)floatAddress;
/* 	floatPtr->F_exponent = FP_NAN; */
	FLOAT_EXPONENT(floatPtr) = FP_NAN;
    }

    return(TRUE);
}

/***********************************************************************
 *
 * FUNCTION:	CheckDateTime
 *
 * DESCRIPTION:	Check whether given text string is a 
 *		legal date or time.  
 *
 * PARAMETERS:  Boolean CheckDateTime (
 *			FieldDataType dataType,
 *			MemHandle textBlock,
 *			dword FloatAddress)			)
 *
 *		returns TRUE if data's OK (block is locked)
 *			FALSE otherwise	  (frees the block)
 *
 * STRATEGY:	
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	anna	3/92		Initial Revision
 *	anna	4/20/92		moved from FieldProperties to Database
 *
 **********************************************************************/
Boolean
CheckDateTime(FieldDataType dataType, MemHandle textBlock, 
	      dword floatAddress)
{
    TCHAR *textPtr;
    FloatNum *floatPtr;

    textPtr = MemLock(textBlock);

    if (*textPtr != _TEXT('\0')) {
	if (dataType == FDT_DATE) {
            if (FloatStringGetDateNumber(textPtr) != 0) {
	        /* error! */
		MemFree(textBlock);
	        return(FALSE);
	    }
 	}
	else {
            if (FloatStringGetTimeNumber(textPtr) != 0) {
	        /* error! */
		MemFree(textBlock);
	        return(FALSE);
	    }
	}
	/*
	 * Date number is put on floating point stack
	 */
	FloatPopNumber((FloatNum *)floatAddress);
    }
    else {
    /*
     * value does not exist
     */
        floatPtr = (FloatNum *)floatAddress;
/* 	floatPtr->F_exponent = FP_NAN; */
	FLOAT_EXPONENT(floatPtr) = FP_NAN;
    }

    return(TRUE);
}

/***********************************************************************
 *
 * MESSAGE:	MSG_FFD_CHECK_FIELD_DATA_TYPE
 *		for FlatFileDatabaseClass
 *
 * DESCRIPTION:	Type-checks the data for the given column.
 *		Returns TRUE if OK, FALSE otherwise.
 *		If FALSE, the text block is freed.
 *		If the number can be converted into a Float Number
 *		(data type = integer, real, date or time)
 *
 * PARAMETERS: 	Boolean (word column, MemHandle dataHandle, 
 *			 dword floatAddress)
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	anna	4/20/92		Initial version
 *
 ***********************************************************************/
@method FlatFileDatabaseClass, MSG_FFD_CHECK_FIELD_DATA_TYPE
{
    FieldDataType dataType;
    FieldDataAttrs  *cellDataPtr;

    /*
     * Get the data
     */
    cellDataPtr = CellLock(&pself->SSI_cellParams,
	     		   FIELD_TYPE_ROW, 
     	     		   (word) column);

    #if ERROR_CHECK
	if (!cellDataPtr) {
	    EC_ERROR(CELL_DOES_NOT_EXIST);
	}
    #endif	/* ERROR_CHECK */

    dataType = cellDataPtr->FDA_type;

    CellUnlock(cellDataPtr);

    switch (dataType) {
	case FDT_INTEGER:
	case FDT_REAL:
		if (!CheckNumber(dataType, dataHandle, floatAddress)) {
		    return(FALSE);
		}
		break;
	case FDT_DATE:
	case FDT_TIME:
		if (!CheckDateTime(dataType, dataHandle, floatAddress)) {
		    return(FALSE);
		}
		break;
    }
    return(TRUE);
}

/***********************************************************************
 *
 * FUNCTION:	CheckValue1LTEValue2
 *
 * DESCRIPTION:	Check whether value1 <= value2. (they are both FloatNums)
 *
 * PARAMETERS:  Boolean CheckValue1LTEValue2 (
 *			FloatNum value1,
 *			FloatNum value2)
 *
 *		returns TRUE if data's OK
 *			FALSE otherwise
 *
 * STRATEGY:	
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	anna	4/21/92		Initial Revision
 *
 **********************************************************************/
Boolean
CheckValue1LTEValue2(FloatNum value1, FloatNum value2) 
{
    /* 
     * Check value1 <= value2; first make sure that both values exist
     */
    if ((FLOAT_EXPONENT((&value1)) != FP_NAN) && 
	(FLOAT_EXPONENT((&value2)) != FP_NAN)) {
        FloatPushNumber(&value1);
        FloatPushNumber(&value2);
        if (FloatComp() == 1) {
            FloatPopNumber(&value2);
            FloatPopNumber(&value1);
	    return(FALSE);
        }
        FloatPopNumber(&value2);
        FloatPopNumber(&value1);
     }

    return(TRUE);
}

/***********************************************************************
 *
 * MESSAGE:	MSG_FFD_LOAD_FLOAT_FORMAT_BLOCK for FlatFileDatabaseClass
 *
 * DESCRIPTION: This message loads up a NotifyFloatFormatChange data block
 *	    	with the document file's handle and the block stored in
 *	    	FFI_floatControlBlock.
 *
 * PARAMETERS:
 *	void (MemHandle floatFormatDataBlock, FormatIdType fieldFormat)
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	11/20/92	Initial version
 *
 ***********************************************************************/
@method FlatFileDatabaseClass, MSG_FFD_LOAD_FLOAT_FORMAT_BLOCK
{
    NotifyFloatFormatChange *floatFormatChange = MemLock(floatFormatDataBlock);

    floatFormatChange->NFFC_vmFileHan = pself->documentHandle;
    floatFormatChange->NFFC_vmBlkHan  = pself->FFI_floatControlBlock;
    floatFormatChange->NFFC_format    = fieldFormat;
    floatFormatChange->NFFC_count     = pself->FFI_floatControlCount++;

    MemUnlock(floatFormatDataBlock);
}

/********* End of DatabaseFieldProperties resource *********/ 



/********* Beginning of DatabaseDataEntrySupport resource *********/
#ifdef __HIGHC__
pragma Code("DATABASEDATAENTRYSUPPORT");
#endif
#ifdef __BORLANDC__
#pragma codeseg DATABASEDATAENTRYSUPPORT
#endif
#ifdef __WATCOMC__
#pragma code_seg("DATABASEDATAENTRYSUPPORT")
#endif

/***********************************************************************
 *
 * FUNCTION:	FFDGetDataTypeAndFlags
 *
 * DESCRIPTION:	Returns the data type and its flags for the given field.
 *	    	If the flags pointer is NULL, no flags values will be
 *	    	returned.
 *
 * PARAMETERS:	oself - an optr to the current database
 *	    	fieldNum - column of field
 *	    	flgas - a pointer where to place the field's flags
 *
 * CALLED BY:	INTERNAL
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	10/27/92	Initial version
 *
 ***********************************************************************/
FieldDataType
FFDGetDataTypeAndFlags(optr oself, FieldID fieldNum, FieldDataTypesFlags *flags)
{
    FieldDataAttrs *cellDataPtr;
    FieldDataType dataType;
    FlatFileDatabaseInstance *pself = ObjDerefGen(oself);

    cellDataPtr = CellLock(&pself->SSI_cellParams,
	     		   FIELD_TYPE_ROW, 
     	     		   (word) fieldNum);

    #if ERROR_CHECK
	if (!cellDataPtr) {
	    EC_ERROR(CELL_DOES_NOT_EXIST);
	}
    #endif	/* ERROR_CHECK */

    dataType = cellDataPtr->FDA_type;

    if (flags) {
	*flags = cellDataPtr->FDA_flags;
    }

    CellUnlock(cellDataPtr);

    return(dataType);
}

/***********************************************************************
 *
 * MESSAGE:	MSG_FFD_GET_DATA_TYPE_AND_FLAGS for FlatFileDatabaseClass
 *
 * DESCRIPTION:	Returns the data type and its flags for the given field.
 *	    	If the flags pointer is NULL, no flags values will be
 *	    	returned.
 *
 * PARAMETERS: 	FieldDataType (fieldNum, FieldDataTypesFlags *flags)
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	anna	4/20/92		Initial version
 *
 ***********************************************************************/
@method FlatFileDatabaseClass, MSG_FFD_GET_DATA_TYPE_AND_FLAGS
{
    return (FFDGetDataTypeAndFlags(oself, fieldNum, flags));
}

/***********************************************************************
 *
 * FUNCTION:	FFDConvertToFloat
 *
 * DESCRIPTION:	This function converts a string to a FloatNum and
 *	    	places the value into a passed FloatNum address.  If
 *	    	the string is legal, TRUE will be returned.
 *	    	Otherwise, FALSE will be returned.
 *
 * PARAMETERS:	dataType - the data type
 *	    	data - pointer to the string
 *	    	num - pointer to a place to put the number
 *
 * CALLED BY:	INTERNAL
 *
 * STRATEGY:
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	5/20/92		Initial Revision
 *
 ***********************************************************************/
Boolean
FFDConvertToFloat(FieldDataType dataType, char *data, FloatNum *num)
{
    int len;

    switch (dataType) {
	case FDT_INTEGER:
	case FDT_REAL:
	case FDT_DATE:
	case FDT_TIME:
	    break;

	case FDT_GENERAL_TEXT:
	case FDT_COMPUTED:
	default:
	    EC_ERROR(BAD_FIELD_DATA_TYPE);
	    NEC(return FALSE;)
    }

    /*
     * The data type was a float.  Convert the thing.
     */
    if ((len = strlen(data)) != 0) {
        if ((FloatAsciiToFloat(FAF_STORE_NUMBER, len,
			       data, (void *)num)) != 0) {
	    /* error! */
	    FLOAT_EXPONENT(num) = FP_NAN;
	    return FALSE;
        }
    } else {
	/*
	 * value does not exist
	 */
	FLOAT_EXPONENT(num) = FP_NAN;
    }

    if (dataType == FDT_INTEGER) {
	/*
	 * Round the value up (or down).
	 */
	FloatPushNumber(num);
	FloatRound(0);
	FloatPopNumber(num);
    }

    return TRUE;
}

/***********************************************************************
 *
 * FUNCTION:	FFDConvertDateToNum
 *
 * DESCRIPTION:	This function takes a string and attempts to convert it
 *	    	into a spreadsheet-formatted FloatNum.  If the string
 *	    	is successfully converted, TRUE is returned.  Otherwise,
 *	    	FALSE is.
 *
 * PARAMETERS:	text - a pointer to the string to convert
 *	    	num - a pointer to the FloatNum that should receive the
 *	    	      results.
 *
 * CALLED BY:	INTERNAL
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	6/24/92		Initial version
 *
 ***********************************************************************/
Boolean
FFDConvertDateToNum(TCHAR *text, FloatNum *num)
{
    if (FloatStringGetDateNumber(text)) {
	/*
	 * There was an error of some sort.
	 */
	return FALSE;
    }

    /*
     * The string converted!  Send off bar mitzvah invites.
     */
    FloatPopNumber(num);
    return TRUE;
}

/***********************************************************************
 *
 * FUNCTION:	FFDConvertTimeToNum
 *
 * DESCRIPTION:	This function takes a string and attempts to convert it
 *	    	into a spreadsheet-formatted FloatNum.  If the string
 *	    	is successfully converted, TRUE is returned.  Otherwise,
 *	    	FALSE is.
 *
 * PARAMETERS:	text - a pointer to the string to convert
 *	    	num - a pointer to the FloatNum that should receive the
 *	    	      results.
 *
 * CALLED BY:	INTERNAL
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	6/24/92		Initial version
 *
 ***********************************************************************/
Boolean
FFDConvertTimeToNum(TCHAR *text, FloatNum *num)
{
    if (FloatStringGetTimeNumber(text)) {
	/*
	 * There was an error of some sort.
	 */
	return FALSE;
    }

    /*
     * The string converted!  Send off bar mitzvah invites.
     */
    FloatPopNumber(num);
    return TRUE;
}

/***********************************************************************
 *
 * MESSAGE:	MSG_FFD_TRANSFER_TEMP_ROW_TO_SCREEN_FIELDS
 *	    	for FlatFileDatabaseClass
 *
 * DESCRIPTION:	This method runs through the current layout's fields
 *	    	and loads each field's text object with data from the
 *	    	TEMP_DATA_ROW.
 *
 * PARAMETERS:
 *	void ()
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	5/20/92		Initial version
 *
 ***********************************************************************/
@method FlatFileDatabaseClass, MSG_FFD_TRANSFER_TEMP_ROW_TO_SCREEN_FIELDS
{
    MemHandle scratchHandle;
    RecordLayoutChunkArrayHeader *cellDataPtr;
    CellRef cellOptr;
    RecordLayoutChunkArrayElement *currentIndexElement;
    MemHandle grObjectMemBlock;
    FieldID actualColumn;
    optr grObjectOptr;
    optr textOptr;
    int i;
    int numInLayoutNameList = pself->FFI_numInLayoutNameList;

    /*
     * Allocate a big text buffer for displaying the individual fields.
     */
    scratchHandle = MemAlloc((MAX_TEXT_FIELD_LENGTH + 1)*sizeof(TCHAR),
			     HF_SWAPABLE, HAF_NO_ERR);
    
    /*
     * Get the temp row data and store it into the text object.
     */
    for (i = 0; i < numInLayoutNameList; i++) {	
	/*
	 * Retrieve the record layout chunk array.
	 */
	pself = ObjDerefGen(oself);
	cellDataPtr = CellLockGetRef(&pself->SSI_cellParams,
				     RECORD_LAYOUT_ROW, 
				     pself->FFI_currentLayout,
				     &cellOptr);
#if ERROR_CHECK
	if (!cellDataPtr) {
	    EC_ERROR(CELL_DOES_NOT_EXIST);
	}
#endif	/* ERROR_CHECK */

	/*
	 * Get a pointer to this element
	 */
	currentIndexElement = ChunkArrayElementToPtr(cellOptr, 
						     i, (word *)0);

	/*
	 * Get the associated GrObj
	 */
	pself = ObjDerefGen(oself);
	grObjectMemBlock = VMVMBlockToMemBlock(pself->documentHandle, 
				   currentIndexElement->GOEOP_grObjectVMBlock);
	grObjectOptr = ConstructOptr(grObjectMemBlock, 
				   currentIndexElement->GOEOP_grObjectChunk);

	/*
	 * Unlock the record layout chunk -- you can't have two cells locked
	 * at the same time.
	 */
	CellUnlock(cellDataPtr);

	/*
	 * Get the OD for this text object.
	 */
	textOptr = @call grObjectOptr::MSG_GOVG_GET_VIS_WARD_OD();

	pself = ObjDerefGen(oself);
	actualColumn = pself->FFI_layoutNameList[i];

	FFDDisplayFieldContents(oself, actualColumn, textOptr, scratchHandle,
				TRUE);
    }

    /*
     * All done with the scratch buffer.
     */
    MemFree(scratchHandle);
    
    return TRUE;
}

/***********************************************************************
 *
 * FUNCTION:	FFDDisplayFieldContents
 *
 * DESCRIPTION:	This function displays a cell from the TEMP_DATA_ROW
 *	    	in a text field.
 *
 * PARAMETERS:	oself - an optr to the current database
 *	    	colNum - the column of the field we're displaying
 *	    	textOptr - optr to the text object in which the string
 *	    	    	   is placed.
 *	    	textHandle - a handle to a scratch buffer that's at least
 *	    	    	     MAX_TEXT_FIELD_LENGTH in size.
 *	    	formatText - a flag: should the text be formatted (TRUE), or
 *	    	    	     displayed "raw" (FALSE)?
 *
 * CALLED BY:	INTERNAL
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	6/23/92		Initial version
 *
 ***********************************************************************/
void
FFDDisplayFieldContents(optr oself,
			FieldID colNum,
			optr textOptr,
			MemHandle textHandle,
			Boolean formatText)
{
    CellCommon *dataCellPtr;
    FlatFileDatabaseInstance *pself;

    /*
     * Get the temp row data for this field.
     */
    pself = ObjDerefGen(oself);
    dataCellPtr = CellLock(&pself->SSI_cellParams, TEMP_DATA_ROW, (word)colNum);

    /*
     * Tell the field to redraw its contents with this information.  Individual
     * field objects know about their own display format.
     */
    if (dataCellPtr) {
	@call textOptr::MSG_FFT_DISPLAY_FIELD_CONTENTS(dataCellPtr,
						       textHandle,
						       formatText);
    
	/* Done with cell data now.	*/
	CellUnlock(dataCellPtr);
    }
}

/***********************************************************************
 *
 * MESSAGE:	MSG_FFD_VALIDATE_SCREEN_FIELD_WITH_MESSAGE for
 *	    	    FlatFileDatabaseClass
 *
 * DESCRIPTION:	This message validates a screen field via the
 *	    	FFDValidateScreenFieldWithMessage function and displays an
 *	    	error message if something went wrong.  The return
 *	    	value from MSG_FFD_VALIDATE_SCREEN_FIELD is returned.
 *
 * PARAMETERS:
 *	FFFieldValidationType (optr textOptr, FieldID colNum,
 *	    	    	       Boolean formatText)
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	8/19/92		Initial version
 *	jeremy	3/15/93	    	Added formatText flag
 *
 ***********************************************************************/
@method FlatFileDatabaseClass, MSG_FFD_VALIDATE_SCREEN_FIELD_WITH_MESSAGE
{
    return FFDValidateScreenFieldWithMessage(oself,
					     textOptr,
					     colNum,
					     formatText);
}

/***********************************************************************
 *
 * FUNCTION:	FFDValidateScreenFieldWithMessage
 *
 * DESCRIPTION:	This function validates a screen field via the
 *	    	FFDValidateScreenField function and displays an
 *	    	error message if something went wrong.  The return
 *	    	value from MSG_FFD_VALIDATE_SCREEN_FIELD is returned.
 *
 *	    	If the data in the field shouldn't be reformatted (that is,
 *	    	displayed in a raw, editable form), pass FALSE in the
 *	    	reformat flag.  Otherwise, pass TRUE.
 *
 * PARAMETERS:	oself - optr to the current database
 *	    	textOptr - optr to the source text
 *	    	colNum - column number of the field
 *	    	formatText - TRUE if the field should be displayed
 *	    	    	     formatted to its numerical format, FALSE
 *	    	    	     if it should be displayed in a raw, editable
 *	    	    	     format.
 *
 * CALLED BY:	INTERNAL
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	6/22/92		Initial Revision
 *
 ***********************************************************************/
FFFieldValidationType
FFDValidateScreenFieldWithMessage(optr oself, optr textOptr, FieldID colNum,
				  Boolean formatText)
{
    FFFieldValidationType retval;
    
    retval = FFDValidateScreenField(oself, textOptr, colNum, formatText);
    
    switch (retval) {
	case FFFV_FIELD_OK:
	case FFFV_FIELD_NOT_DIRTY:
	case FFFV_NOT_IN_DESIGN_MODE:
	    return retval;

	default:
	    break;
    }

    /*
     * There was a problem with this field.  Forcequeue an error message
     * so we can deal with it after all the mysterious behavior we're in
     * the middle of is complete.
     */
/*    @send ,forceQueue ,insertAtFront oself:: */
    @send ,forceQueue ,replace ,checkDuplicate oself::
	MSG_FFD_DISPLAY_VALIDATION_ERROR(colNum, retval);

    return retval;
}

/***********************************************************************
 *
 * MESSAGE:	MSG_FFD_DISPLAY_VALIDATION_ERROR for FlatFileDatabaseClass
 *
 * DESCRIPTION:	This message puts up an error message describing an
 *	    	invalid value in a field, unless for some reason we
 *	    	should not put up an error.
 *
 * PARAMETERS:
 *	void (FieldID colNum, FFFieldValidationType retval)
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	3/ 3/93		Initial version
 *
 ***********************************************************************/
@method FlatFileDatabaseClass, MSG_FFD_DISPLAY_VALIDATION_ERROR
{
    FieldDataType dataType;
    TCHAR *typeText;
    TCHAR *formatText;
    TCHAR errmsg[256];
    TCHAR minval[FLOAT_TO_ASCII_NORMAL_BUF_LEN],
    	 maxval[FLOAT_TO_ASCII_NORMAL_BUF_LEN];
    Boolean minOk, maxOk;
    optr fieldGrObject, textOptr, grObjBody;

    /*
     * Highlight the offending field and put up an error message,
     * unless our application no longer has the target or the app is
     * in some other state where we don't want the message to go up.
     */
    if (FFDDoNotPutUpValidationErrorMessage(oself)) {
	/*
	 * The document did not have the target, or the application was
	 * in some other state so that we do NOT want to put up the error
	 * message.
	 */
	return;
    }

    /*
     * Put up an error message.  Lock down a string for the type of the
     * bogus field...
     */
    dataType = FFDGetDataTypeAndFlags(oself, colNum, NULL);
    (void) MemLock(HandleOf(FFDFieldTypeTextTable[dataType]));
    typeText = LMemDeref(FFDFieldTypeTextTable[dataType]);
    
    /*
     * ...and a string to format the error message.
     */
    (void) MemLock(HandleOf(FFDFieldErrorTextTable[retval]));
    formatText = LMemDeref(FFDFieldErrorTextTable[retval]);
    
    /*
     * Now create the error message using the magic of sprintf().
     */
    switch (retval) {
	case FFFV_FIELD_SMALLER_THAN_MIN:
	case FFFV_FIELD_LARGER_THAN_MAX:
	    minOk = @call oself::
		MSG_FFD_GET_COLUMN_MIN_OR_MAX_STRING(colNum, minval, MIN);
	    maxOk = @call oself::
		MSG_FFD_GET_COLUMN_MIN_OR_MAX_STRING(colNum, maxval, MAX);
	    if (minOk && maxOk) {
		sprintf(errmsg, formatText, typeText, minval, maxval);
	    } else if (minOk) {
		/*
		 * Only the minimum value was set.  Grab a specific error
		 * message for this case.
		 */
		(void) MemLock(HandleOf(@FFDErr_min_only_field_range_error));
		formatText = LMemDeref(@FFDErr_min_only_field_range_error);
		sprintf(errmsg, formatText, typeText, minval);
		(void) MemUnlock(HandleOf(@FFDErr_min_only_field_range_error));
	    } else /* maxOk */ {
		/*
		 * Only the maximum value was set.  Grab a specific error
		 * message for this case.
		 */
		(void) MemLock(HandleOf(@FFDErr_max_only_field_range_error));
		formatText = LMemDeref(@FFDErr_max_only_field_range_error);
		sprintf(errmsg, formatText, typeText, maxval);
		(void) MemUnlock(HandleOf(@FFDErr_max_only_field_range_error));
	    }
	    break;
	case FFFV_FIELD_NOT_LEGAL:
	    sprintf(errmsg, formatText, typeText);
	    break;
    }

    /*
     * Tell the current layout's grobj body to re-grab the target and focus.
     */
    pself = ObjDerefGen(oself);
    grObjBody = @call oself::MSG_FFD_GET_GROBJ_BODY_FOR_LAYOUT(
					pself->FFI_currentLayout,
					pself->FFI_currentLayoutType);
    @call grObjBody::MSG_META_GRAB_TARGET_EXCL();
    @call grObjBody::MSG_META_GRAB_FOCUS_EXCL();

    /*
     * Get the text object for this layout.
     */
    fieldGrObject = FFDGetFieldTextGrObject(oself, colNum);
    textOptr = @call fieldGrObject::MSG_GOVG_GET_VIS_WARD_OD();

    /*
     * Highlight the text.
     */
    @call textOptr::MSG_META_GRAB_TARGET_EXCL();
    @call textOptr::MSG_META_GRAB_FOCUS_EXCL();
    @call textOptr::MSG_VIS_TEXT_SELECT_ALL();

    /*
     * Put up the error message.
     */
    UserStandardDialog(
	    	(TCHAR *)0,
		/* not GIT_MULTIPLE_RESPONSE, so no custom triggers  */
                (TCHAR *)0,
                /* One string argument: the error message. */
                (TCHAR *)0, errmsg,
                /* dialog string */
                _TEXT("\001"),
                /* dialog type */
                (CDT_WARNING << CDBF_DIALOG_TYPE_OFFSET) |
                /* interaction type */
                (GIT_NOTIFICATION << CDBF_INTERACTION_TYPE_OFFSET));

    MemUnlock(HandleOf(FFDFieldErrorTextTable[retval]));
    MemUnlock(HandleOf(FFDFieldTypeTextTable[dataType]));
}

/***********************************************************************
 *
 * FUNCTION:	FFDDoNotPutUpValidationErrorMessage
 *
 * DESCRIPTION:	This routine calls others to determine whether or
 *	    	not we should put up error messages.  If we've just
 *	    	closed the document, for example, we're not interested in
 *	    	putting up error boxes that apply to thing that are no
 *	    	longer on the screen.
 *
 *	    	Returns a TRUE if a box should NOT be put up, or a
 *	    	FALSE if the box SHOULD go up.
 *
 * PARAMETERS:	oself - an optr to the current database
 *
 * CALLED BY:	INTERNAL
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	3/ 2/93		Initial version
 *
 ***********************************************************************/
Boolean
FFDDoNotPutUpValidationErrorMessage(optr oself)
{
    return (!FFDHorribleHackToSeeIfTheDocHasTheTarget(oself) ||
	    FFDApplicationInAClosingState(oself));
}

/***********************************************************************
 *
 * FUNCTION:	FFDHorribleHackToSeeIfTheDocHasTheTarget
 *
 * DESCRIPTION:	As advertised, this is a horrible hack to determine whether
 *	    	or not the document in the visual tree above us has the
 *	    	app target.
 *
 *	    	TRUE is returned if the document does have the app target,
 *	    	FALSE is returned if not.
 *
 * PARAMETERS:	oself - an optr to the current flat file database object
 *
 * CALLED BY:	INTERNAL
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *	    	It's pretty gross: we VUP up to get the document's OD,
 *	    	lock it down, then look at its instance data to see if
 *	    	some Vis instance data flags imply that the object has
 *	    	app target.  Bleah.
 *	
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	3/ 2/93		Initial version
 *
 ***********************************************************************/
Boolean
FFDHorribleHackToSeeIfTheDocHasTheTarget(optr oself)
{
    optr docOptr;
    VisContentInstance *doc;
    Boolean retval;
    
    docOptr = @call oself::MSG_VIS_VUP_FIND_OBJECT_OF_CLASS(&GenDocumentClass);
    if (!docOptr) {
	return FALSE;
    }
    
    (void) MemLock(HandleOf(docOptr));

    doc = ObjDerefVis(docOptr);
    retval = (doc->VCNI_targetExcl.FTVMC_flags & MAEF_APP_EXCL);

    MemUnlock(HandleOf(docOptr));
    return retval;
}

/***********************************************************************
 *
 * FUNCTION:	FFDApplicationInAClosingState
 *
 * DESCRIPTION:	This routine checks to see if the current application
 *	    	is closing, quitting, or in some other way is not
 *	    	sitting around.
 *
 *	    	Returns TRUE if the allpication is closing, FALSE
 *	    	if the application is in a steady state.
 *
 * PARAMETERS:	oself - an optr to the current database
 *
 * CALLED BY:	INTERNAL
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	3/ 2/93		Initial version
 *
 ***********************************************************************/
Boolean
FFDApplicationInAClosingState(optr oself)
{
    ApplicationStates states;
    
    states = @call GeodeGetAppObject(0)::MSG_GEN_APPLICATION_GET_STATE();

    return (states & (AS_QUITTING | AS_DETACHING));
}

/***********************************************************************
 *
 * MESSAGE:	MSG_FFD_VALIDATE_SCREEN_FIELD for FlatFileDatabaseClass
 *
 * DESCRIPTION:	This message is sent when a field's text object is to
 *	    	be entered into the database.
 *	    	It grabs the text from the field, and sends it off to
 *	    	MSG_FFD_STORE_FIELD_DATA_IN_TEMP_ROW_CELL.  If the text
 *	    	is illegal for some reason, the appropriate error
 *	    	value will be returned.  Otherwise, FFFV_FIELD_OK or
 *	    	one of the other benign values is returned.
 *
 *	    	If the data in the field shouldn't be reformatted (that is,
 *	    	displayed in a raw, editable form), pass FALSE in the
 *	    	reformat flag.  Otherwise, pass TRUE.
 *
 * PARAMETERS:
 *	FFFieldValidationType (optr textOptr, FieldID colNum,
 *	    	    	       Boolean formatText)
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	6/10/92		Initial version
 *	jeremy	6/19/92	    	Added validation return types.
 *
 ***********************************************************************/
@method FlatFileDatabaseClass, MSG_FFD_VALIDATE_SCREEN_FIELD
{
    return (FFDValidateScreenField(oself, textOptr, colNum, formatText));
}


/***********************************************************************
 *
 * FUNCTION:	FFDValidateScreenField
 *
 * DESCRIPTION:	This function is sent when a field's text object is to
 *	    	be entered into the database.
 *	    	It grabs the text from the field, and sends it off to
 *	    	MSG_FFD_STORE_FIELD_DATA_IN_TEMP_ROW_CELL.  If the text
 *	    	is illegal for some reason, the appropriate error
 *	    	value will be returned.  Otherwise, FFFV_FIELD_OK or
 *	    	one of the other benign values is returned.
 *
 *	    	If the data in the field shouldn't be reformatted (that is,
 *	    	displayed in a raw, editable form), pass FALSE in the
 *	    	reformat flag.  Otherwise, pass TRUE.
 *
 * PARAMETERS:	oself - optr to the current database
 *	    	textOptr - optr to the source text
 *	    	colNum - column number of the field
 *	    	formatText - TRUE if the field should be displayed
 *	    	    	     formatted to its numerical format, FALSE
 *	    	    	     if it should be displayed in a raw, editable
 *	    	    	     format.
 *
 * CALLED BY:	INTERNAL
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	8/19/92		Initial version
 *	jeremy	3/15/93	    	Added formatText flag
 *
 ***********************************************************************/
FFFieldValidationType
FFDValidateScreenField(optr oself,
		       optr textOptr,
		       FieldID colNum,
		       Boolean formatText)
{
    FlatFileDatabaseInstance *pself;
    MemHandle textHandle;
    TCHAR *fieldText;
    FFFieldValidationType retval;

    /*
     * If we're not in data entry mode, we just don't care.
     * In fact, we should NEVER get this when not in data entry mode.
     */
    pself = ObjDerefGen(oself);
    if (pself->FFI_currentMode & MT_DESIGN) {
	EC_ERROR(BAD_MODE_TYPE);
	NEC(return FFFV_NOT_IN_DESIGN_MODE;)
    }

    /*
     * Allocate a text block.
     */
    textHandle = MemAlloc((MAX_TEXT_FIELD_LENGTH + 1)*sizeof(TCHAR),
			       HF_SHARABLE | HF_SWAPABLE, HAF_NO_ERR);

    /*
     * If the field hasn't been changed, don't enter it into the database,
     * but redisplay it.
     */
    if (!(@call textOptr::MSG_VIS_TEXT_GET_USER_MODIFIED_STATE())) {
	/*
	 * The field hasn't been changed.  Redisplay the thing, then leave.
	 */
	FFDDisplayFieldContents(oself,
				colNum,
				textOptr,
				textHandle,
				formatText);
	MemFree(textHandle);
	return FFFV_FIELD_NOT_DIRTY;
    }
    
    fieldText = MemLock(textHandle);

    /*
     * Get the text from the field.
     */
    (void) @call textOptr::MSG_VIS_TEXT_GET_ALL_PTR(fieldText);
    
    /*
     * Now store the text into the temp row's cell.
     */
    pself = ObjDerefGen(oself);
    retval = @call self::
	MSG_FFD_STORE_FIELD_DATA_IN_TEMP_ROW_CELL(colNum, fieldText);

    /*
     * Unlock the text buffer for later use.
     */
    MemUnlock(textHandle);

    if (retval != FFFV_FIELD_OK) {
	MemFree(textHandle);
	return (retval);
    }
    
    /*
     * The field might have changed its appearance, so redisplay it.
     */
    FFDDisplayFieldContents(oself, colNum, textOptr, textHandle, formatText);
    
    /*
     * We're done with the text buffer.
     */
    MemFree(textHandle);
    
    /*
     * The field was successfully entered into the temp row!  Dirty the
     * record, and set the field as clean.
     */
    @send textOptr::MSG_VIS_TEXT_SET_NOT_USER_MODIFIED();
    pself = ObjDerefGen(oself);
    pself->FFI_dirtyRecord = TRUE;

    /*
     * Update the computed fields that depend upon this field and redraw
     * them.
     */
    FFDRecalculateDependents(oself, colNum, REDRAW);

    return FFFV_FIELD_OK;
}

/***********************************************************************
 *
 * FUNCTION:	FFDGetFieldBounds
 *
 * DESCRIPTION:	Gets the bounds for the given field
 *
 * PARAMETERS:	oself - an optr to the current database
 *	    	fieldNum - column of field
 *		*fieldBounds - filled in by this routine
 *
 * CALLED BY:	INTERNAL
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	anna	1/19/93		Initial version
 *
 ***********************************************************************/
void
FFDGetFieldBounds(optr oself, FieldID fieldNum, RectDWord *fieldBounds)
{
    optr fieldOptr;

    /*
     * Get the field from the current layout.
     */
    fieldOptr = FFDGetFieldTextGrObject(oself, fieldNum);

    /*
     * Get the bounds of this field
     */
    @call fieldOptr::MSG_GO_GET_DW_PARENT_BOUNDS(fieldBounds);
}


/***********************************************************************
 *
 * FUNCTION:	FFDGetFieldTextGrObject
 *
 * DESCRIPTION:	This function returns an optr to the text object for
 *	    	a given field in the current layout.
 *
 * PARAMETERS:	oself - an optr to the current database
 *	    	fieldNum - the column of the field
 *
 * CALLED BY:	INTERNAL
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	10/26/93	Initial version
 *
 ***********************************************************************/
optr
FFDGetFieldTextGrObject(optr oself, FieldID fieldNum)
{
    RecordLayoutChunkArrayHeader *cellDataPtr;
    CellRef cellOptr;
    RecordLayoutChunkArrayElement *currentIndexElement;
    MemHandle grObjectMemBlock;
    VMFileHandle documentHandle;
    optr fieldOptr;
    FlatFileDatabaseInstance *pself;
    FieldListID index;

    pself = ObjDerefGen(oself);

    documentHandle = pself->documentHandle;

    cellDataPtr = CellLockGetRef(&pself->SSI_cellParams,
				 RECORD_LAYOUT_ROW, 
				 pself->FFI_currentLayout,
				 &cellOptr);

#if ERROR_CHECK
	if (!cellDataPtr) {
	    EC_ERROR(CELL_DOES_NOT_EXIST);
	}
#endif	/* ERROR_CHECK */

    /*
     * Get a pointer to this element
     */
    index = FindFieldListElement(pself->FFI_layoutNameList, fieldNum,
				 FFDHowManyInList(LAYOUT_NAME_LIST, pself));
    currentIndexElement = ChunkArrayElementToPtr(cellOptr, index, (word *)0);
    
    /*
     * Get the associated field GrObj.
     */
    grObjectMemBlock = VMVMBlockToMemBlock(documentHandle, 
				currentIndexElement->GOEOP_grObjectVMBlock);
    fieldOptr = ConstructOptr(grObjectMemBlock, 
			      currentIndexElement->GOEOP_grObjectChunk);

    CellUnlock(cellDataPtr);

    return fieldOptr;
}


/***********************************************************************
 *
 * FUNCTION:	FFDIsFieldWithinRecordBounds
 *
 * DESCRIPTION:	Checks whether the given field's grobject is within the
 *		single-record bounds. If it is, returns TRUE, otherwise
 *		FALSE
 *
 * PARAMETERS:	oself - an optr to the current database
 *	    	fieldNum - column of field
 *
 * CALLED BY:	INTERNAL
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	anna	1/19/93		Initial version
 *
 ***********************************************************************/
Boolean
FFDIsFieldWithinRecordBounds(optr oself, FieldID fieldNum)
{
    RectDWord fieldBounds;
    LayoutSize layoutSize;

    FFDGetFieldBounds(oself, fieldNum, &fieldBounds);
    
    /*
     * Get the bounds of the single record
     */
    FFDGetSingleRecordBounds(oself, &layoutSize);

    /*
     * If the upper left corner is negative, but the field is partially
     * on the layout (i.e. the lower right corner is positive), then
     * treat the field's upper left as being positive.
     */
    if ((fieldBounds.RD_top < 0) && (fieldBounds.RD_bottom > 0)) {
	fieldBounds.RD_top = 0;
    }

    if ((fieldBounds.RD_left < 0) && (fieldBounds.RD_right > 0)) {
	fieldBounds.RD_left = 0;
    }

    /*
     * Check if the upper right corner of the field is within the bounds
     * (i.e. visible)
     */
    if ((fieldBounds.RD_top < layoutSize.LS_height) &&
       (fieldBounds.RD_top >= 0)) {
        if ((fieldBounds.RD_left < layoutSize.LS_width) &&
           (fieldBounds.RD_left >= 0)) {
	    return(TRUE);
	}
    }

    return(FALSE);
}

/***********************************************************************
 *
 * FUNCTION:	FFDNavigateToNextField
 *
 * DESCRIPTION:	This function is used to check the current record's data,
 *	    	enter it if possible into the temporary data row, then
 *	    	navigate to the next or previous field (in the user
 *	    	specified order).
 *
 *	    	Set the forwardFlag to TRUE to navigate to the following
 *	    	field; set it to FALSE to navigate to the previous field.
 *
 * PARAMETERS:	oself - optr to the current database
 *	    	textOptr - optr to the current field's text
 *	    	colNum - column of this field
 *
 * CALLED BY:	INTERNAL
 *
 * STRATEGY:
 *		If the screen fields are okay then
 *		Move to the next non-computed field in the user specified
 *		navigation order.
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	6/11/92		Initial version
 *	JDM	92.08.12	Modified to use field navigation info.
 *	jeremy	12/16/92    	Added navigate to previous field.
 *	anna	1/19/93		In multi-record, skip over field if it's
 *				not within the record bounds
 *	jeremy	3/30/93	    	Added a fix so it won't go into an infinite
 *	    	    	    	loop in some cases.
 *
 ***********************************************************************/
void
FFDNavigateToNextField(optr oself, optr textOptr, FieldID colNum,
		       Boolean forwardFlag)
{
    FieldID nextFieldColNum;
    FFFieldValidationType validation;

    /*
     * Attempt to enter the field.  If something goes wrong, put up a
     * message.
     */
    validation = FFDValidateScreenFieldWithMessage(oself, textOptr, colNum,
						   TRUE);
    switch (validation) {
	case FFFV_FIELD_OK:
	case FFFV_FIELD_NOT_DIRTY:
	    break;

	default:
	    return;
    }

    /*
     * The field was valid!  Figure out which field to traverse to.
     */
    nextFieldColNum= @call oself::MSG_FFD_FNO_INFO_GET_NEXT_FIELD(colNum,
								  forwardFlag);

    while ((!FFDIsFieldWithinRecordBounds(oself, nextFieldColNum)) ||
	   (FFDGetDataTypeAndFlags(oself, nextFieldColNum, NULL) ==
	    FDT_COMPUTED)) {

	/*
	 * If we're back at the first field, bail: we're done.
	 */
	if (nextFieldColNum == colNum) {
	    break;
	}

	nextFieldColNum = @call oself::MSG_FFD_FNO_INFO_GET_NEXT_FIELD
				(nextFieldColNum, forwardFlag);
    }

    if (nextFieldColNum != colNum) {
	FFDFieldGrabTargetAndForceOnScreen(oself, nextFieldColNum);
    }
}
/***********************************************************************
 *
 * FUNCTION:	FFDFieldGrabTargetAndForceOnScreen
 *
 * DESCRIPTION:	This function moves the target and focus to a field
 *	    	in the current layout, and makes that object come on screen.
 *
 * PARAMETERS:	oself - optr to the current database
 *	    	columnNum - column number of the field
 *
 * CALLED BY:	INTERNAL
 *
 * STRATEGY:
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	atw	3/9/93		Initial Revision
 *	jeremy	3/21/93	    	Broke out force field on screen
 *
 ***********************************************************************/
void
FFDFieldGrabTargetAndForceOnScreen(optr oself, FieldID columnNum)
{
    FieldListID fieldIndex;
    FlatFileDatabaseInstance *pself = ObjDerefGen(oself);

    /*
     * Give the new field the target and focus.
     */
    fieldIndex = FindFieldListElement(pself->FFI_layoutNameList,
				      columnNum,
				      pself->FFI_numInLayoutNameList);

    /*
     * Make sure the field is displayed on the screen.
     */
    FFDForceFieldOnScreen(oself, columnNum);

    /*
     * Now move the target and focus to the field.
     */
    FFDFieldGrabTarget(oself, fieldIndex);
}

/***********************************************************************
 *
 * FUNCTION:	FFDForceFieldOnScreen
 *
 * DESCRIPTION:	Given the absolute column number of a field, this function
 *	    	will redraw the screen so the field will be visible.
 *
 *	    	Note: any references to science-fiction "force fields" will
 *	    	be removed immediately.  :)
 *
 * PARAMETERS:	oself - an optr to the current database
 *	    	columnNum - the column number of the field
 *
 * CALLED BY:	INTERNAL
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	3/21/93		Initial version
 *
 ***********************************************************************/
void
FFDForceFieldOnScreen(optr oself, FieldID columnNum)
{
    RectDWord fieldBounds, layoutBounds;
    optr recordLayoutGrObjBody;
    word horRec, verRec;
    EventHandle event;
    FlatFileDatabaseInstance *pself;

    pself = ObjDerefGen(oself);

    FFDGetFieldBounds(oself, columnNum, &fieldBounds);
    recordLayoutGrObjBody = @call oself::
	MSG_FFD_GET_GROBJ_BODY_FOR_LAYOUT(pself->FFI_currentLayout,
					  LT_SINGLE_RECORD);

    /*
     *	Get the position of the current field, so we can force it on screen
     */
    pself = ObjDerefGen(oself);
    if (pself->FFI_currentLayoutType == LT_SINGLE_RECORD) {
	@call recordLayoutGrObjBody::MSG_GB_GET_BOUNDS(&layoutBounds);
    } else {
	FFDCalculateNumRecordsPerPage(oself, &horRec, &verRec);
        pself = ObjDerefGen(oself);
	FFDCalculateBoundsForActiveRecord(oself, recordLayoutGrObjBody,
					  FFD_CURRENT_RECORD(pself),
					  horRec, verRec,
					  &layoutBounds);
    }

    /*
     * Make sure the field is displayed on screen
     */
    event = @record GenViewClass::MSG_GEN_VIEW_MAKE_RECT_VISIBLE(
				0, MRVM_0_PERCENT, 
				0, MRVM_0_PERCENT,
				fieldBounds.RD_bottom + layoutBounds.RD_top,
				fieldBounds.RD_right + layoutBounds.RD_left,
				fieldBounds.RD_top + layoutBounds.RD_top,
				fieldBounds.RD_left + layoutBounds.RD_left);

    @send oself::MSG_VIS_VUP_CALL_OBJECT_OF_CLASS(event);
}
    

/***********************************************************************
 *
 * FUNCTION:	FFDFieldGrabTarget
 *
 * DESCRIPTION:	This function moves the target and focus to a field
 *	    	in the current layout, and displays the data in a
 *	    	raw, editable format.
 *
 *	    	Pass the current layout field index.
 *
 * PARAMETERS:	oself - optr to the current database
 *	    	fieldIndex - layout name list field ID
 *
 * CALLED BY:	INTERNAL
 *
 * STRATEGY:
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	6/12/92		Initial Revision
 *	jeremy	3/14/93	    	Field now displayed in raw format.
 *
 ***********************************************************************/
void
FFDFieldGrabTarget(optr oself, FieldListID fieldIndex)
{
    FlatFileDatabaseInstance *pself;
    RecordLayoutChunkArrayHeader *cellDataPtr;
    CellRef cellOptr;
    RecordLayoutChunkArrayElement *currentIndexElement;
    MemHandle grObjectMemBlock;
    optr grObjectOptr;
    optr fieldOptr;
    optr textHandle;
    EventHandle event;
    optr recordLayoutGrObjBody;

    pself = ObjDerefGen(oself);
    cellDataPtr = CellLockGetRef(&pself->SSI_cellParams,
				 RECORD_LAYOUT_ROW, 
				 pself->FFI_currentLayout,
				 &cellOptr);
#if ERROR_CHECK
    if (!cellDataPtr) {
	EC_ERROR(CELL_DOES_NOT_EXIST);
    }
#endif

    /*
     * Get a pointer to this element
     */
    pself = ObjDerefGen(oself);
    currentIndexElement = ChunkArrayElementToPtr(cellOptr, 
						 fieldIndex,
						 (word *)0);

    /*
     * Get the associated GrObj
     */
    pself = ObjDerefGen(oself);
    grObjectMemBlock = VMVMBlockToMemBlock(pself->documentHandle, 
				   currentIndexElement->GOEOP_grObjectVMBlock);
    grObjectOptr = ConstructOptr(grObjectMemBlock, 
				 currentIndexElement->GOEOP_grObjectChunk);

    /*
     * Unlock the record layout chunk array -- two consecutive CellLocks
     * is a bad thing.
     */
    CellUnlock(cellDataPtr);
    
    fieldOptr = @call grObjectOptr::MSG_GOVG_GET_VIS_WARD_OD();

    /*
     * Make sure the record layout has the target
     */
    pself = ObjDerefGen(oself);
    recordLayoutGrObjBody = @call oself::MSG_FFD_GET_GROBJ_BODY_FOR_LAYOUT(
					pself->FFI_currentLayout,
					LT_SINGLE_RECORD);
    @call recordLayoutGrObjBody::MSG_META_GRAB_TARGET_EXCL();
    @call recordLayoutGrObjBody::MSG_META_GRAB_FOCUS_EXCL();

    /*
     * Give the field object the target and focus.
     */
    @call fieldOptr::MSG_META_GRAB_TARGET_EXCL();
    @call fieldOptr::MSG_META_GRAB_FOCUS_EXCL();
 
    /*
     * Make sure the data is editable, so redisplay the field's
     * information as RAW.
     */
    pself = ObjDerefGen(oself);
    textHandle = MemAlloc((MAX_TEXT_FIELD_LENGTH + 1) *sizeof(TCHAR),
			  HF_SHARABLE | HF_SWAPABLE, HAF_NO_ERR);
    FFDDisplayFieldContents(oself,
			    pself->FFI_layoutNameList[fieldIndex],
			    fieldOptr,
			    textHandle,
			    FALSE);
    MemFree(textHandle);

    /*
     * Put the cursor at the end of the text.
     */
    (void) @call fieldOptr::MSG_VIS_TEXT_SELECT_RANGE(
		     TEXT_ADDRESS_PAST_END, TEXT_ADDRESS_PAST_END); 

    /*
     * Make sure the primary has the focus.
     */
    event = @record GenPrimaryClass::MSG_META_GRAB_FOCUS_EXCL();
    @send oself::MSG_VIS_VUP_SEND_TO_WIN_GROUP(event);
}

/***********************************************************************
 *
 * FUNCTION:	FFDNavigateToAnotherRecord
 *
 * DESCRIPTION:	This function is used to check the current record's data,
 *	    	enter it if possible into the temporary data row, then
 *	    	navigate to some record.
 *
 * PARAMETERS:	oself - optr to the current database
 *	    	textOptr - optr to the current field's text
 *	    	colNum - column of this field
 *	    	rcpRequest - record control command, like
 *	    	    	     FFRCR_GOTO_FIRST_RECORD or some such.  0 will
 *	    	    	     be passed as the data for the request.
 *
 * CALLED BY:	INTERNAL
 *
 * STRATEGY:
 *		If the record data is okay then
 *			Commit the current record and start editing
 *			another record.
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	2/20/93		Initial version
 *
 ***********************************************************************/
void
FFDNavigateToAnotherRecord(optr oself, optr textOptr, FieldID colNum,
			   FFRecordControlRequest rcpRequest)
{
    /*
     * Attempt to enter the field.
     */
    switch (FFDValidateScreenFieldWithMessage(oself, textOptr, colNum, TRUE)) {
	case FFFV_FIELD_OK:
	case FFFV_FIELD_NOT_DIRTY:
	    @call oself::MSG_FFD_RECORD_CONTROL(rcpRequest, 0);
	    break;

	default:
	    /* The field wasn't valid.  Do nothing. */
	    break;
    }
}

/***********************************************************************
 *
 * MESSAGE:	MSG_FFD_NOTIFY_FIELD_NAVIGATION
 *		for FlatFileDatabaseClass
 *
 * DESCRIPTION:	This message is sent by fields when they detect certain
 * 	    	control keys.  We handle them here.
 *
 * PARAMETERS: 	 void (optr textOptr, FieldID colNum,
 *	    	       ShortcutCode shortcut)
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	6/11/92	    	Initial version
 *	jeremy	2/20/93	    	Revamped the thing as per Gene's advice;
 *	    	    	    	added mode control keys.
 *
 ***********************************************************************/
@method FlatFileDatabaseClass, MSG_FFD_NOTIFY_FIELD_NAVIGATION
{
    /*
     * If we're in data entry mode, check for keyboard navigation.
     */
    if (pself->FFI_currentMode & MT_DATA_ENTRY) switch (shortcut) {
    	case SC_NEXT_FIELD:
    	case SC_NEXT_FIELD_2:
	    /*
	     * NEXT_FIELD: Enter the current field's contents (if possible),
	     * then navigate to the next field.
	     */
	    FFDNavigateToNextField(oself, textOptr, colNum, TRUE);
	    break;
	    
    	case SC_PREVIOUS_FIELD:
    	case SC_PREVIOUS_FIELD_2:
    	case SC_PREVIOUS_FIELD_3:
	    /*
	     * PREVIOUS_FIELD: Enter the current field's contents (if possible),
	     * then navigate to the previous field.
	     */
	    FFDNavigateToNextField(oself, textOptr, colNum, FALSE);
	    break;

    	case SC_NEW_RECORD:
    	case SC_NEW_RECORD_2:
	    /*
	     * NEW_RECORD: Enter the current field's contents
	     * (if possible), then enter the current record
	     * into the database (if possible).
	     */
	    FFDNavigateToAnotherRecord(oself, textOptr, colNum,
				       FFRCR_CREATE_NEW_RECORD);
	    break;

    	case SC_PREVIOUS_RECORD:
	    FFDNavigateToAnotherRecord(oself, textOptr, colNum,
				       FFRCR_GOTO_PREVIOUS_RECORD);
	    break;
	    
    	case SC_NEXT_RECORD:
	    FFDNavigateToAnotherRecord(oself, textOptr, colNum,
				       FFRCR_GOTO_NEXT_RECORD);
	    break;

    	case SC_FIRST_RECORD:
	    FFDNavigateToAnotherRecord(oself, textOptr, colNum,
				       FFRCR_GOTO_FIRST_RECORD);
	    break;

    	case SC_LAST_RECORD:
	    FFDNavigateToAnotherRecord(oself, textOptr, colNum,
				       FFRCR_GOTO_LAST_RECORD);
	    break;

    	case SC_MARK_RECORD:
	    if (FFDGetRecordMarkStatus(pself, TEMP_DATA_ROW)) {
		FFDNavigateToAnotherRecord(oself, textOptr, colNum,
					   FFRCR_UNMARK_CURRENT_RECORD);
	    } else {
		FFDNavigateToAnotherRecord(oself, textOptr, colNum,
					   FFRCR_MARK_CURRENT_RECORD);
	    }
	    break;

    	case SC_COMMIT_RECORD:
	    FFDNavigateToAnotherRecord(oself, textOptr, colNum,
				       FFRCR_COMMIT_CURRENT_RECORD);
	    break;

	default:
	    EC_ERROR(BAD_KEYBOARD_SHORTCUT);
	    break;
    }
}

/***********************************************************************
 *
 * MESSAGE:	MSG_FFD_STORE_FIELD_DATA_IN_TEMP_ROW_CELL 
 *		for FlatFileDatabaseClass
 *
 * DESCRIPTION:	Stores the given string in the cell for given field(column).
 *	    	If the text is illegal for some reason, the
 *	    	appropriate error value will be returned.  Otherwise,
 *	    	FFFV_FIELD_OK or one of the other benign values is
 *	    	returned.
 *
 * PARAMETERS: 	FFFieldValidationType (word colNum, void *data)
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	anna	4/17/92		Initial version
 *	jeremy	5/19/92	    	Switched data arg from byte * to char *,
 *	    	    	    	because that's what it is.
 *	jeremy	5/25/92	    	Now stores cells in the correct cell format.
 *	jeremy	7/23/92	        Now deals correctly with dependencies.
 *
 ***********************************************************************/
@method FlatFileDatabaseClass, MSG_FFD_STORE_FIELD_DATA_IN_TEMP_ROW_CELL
{
    word dataSize;
    FieldDataType dataType;
    union {
	TextCellStruct	  textCell;
	CellConstant	  numCell;
	CellEmpty   	  emptyCell;
    } cellStruct;

    /*
     * Set cell info that's common across all types.
     */
    cellStruct.numCell.CC_common.CC_recalcFlags = 0;
    cellStruct.numCell.CC_common.CC_attrs = 0;
    cellStruct.numCell.CC_common.CC_notes = 0;

    /*
     * Set the cell's dependencies from the existing TEMP_DATA_ROW cell.
     */
    FFDCopyCellDependencies(oself, colNum, (CellCommon *) &cellStruct.numCell);
    
    dataType = FFDGetDataTypeAndFlags(oself, colNum, NULL);

    /*
     * If there is no data, store the cell as EMPTY and preserve any
     * dependencies.
     *
     * Otherwise, set the cell as appropriate.
     */
    if (*data == _TEXT('\0')) {
	cellStruct.emptyCell.CE_common.CC_type = CT_EMPTY;
	dataSize = sizeof(CellEmpty);
    } else switch (dataType) {
	case FDT_GENERAL_TEXT:
	    dataSize = sizeof(CellText) + (strlen(data) + 1)*sizeof(TCHAR);
	    strcpy(cellStruct.textCell.string, data);
	    cellStruct.textCell.cellTextStruct.CT_common.CC_type = CT_TEXT;
	    break;

	case FDT_DATE:
	case FDT_TIME:
	case FDT_INTEGER:
	case FDT_REAL:
	    switch (dataType) {
	        case FDT_DATE:
	            if (!FFDConvertDateToNum(data,
					    &(cellStruct.numCell.CC_current))){
			return FFFV_FIELD_NOT_LEGAL;
		    }
		    break;

		case FDT_TIME:
		    if (!FFDConvertTimeToNum(data,
					    &(cellStruct.numCell.CC_current))){
			return FFFV_FIELD_NOT_LEGAL;
		    }
		    break;

		case FDT_INTEGER:
		case FDT_REAL:
		    if (FFDConvertToFloat(dataType, data,
				  &(cellStruct.numCell.CC_current)) != TRUE) {
			return FFFV_FIELD_NOT_LEGAL;
		    }
		    break;
	    }
	    /*
	     * Make sure the numbers are in the min/max range.
	     */
	    switch (@call oself::
		    MSG_FFD_CHECK_FIELD_DATA_BETWEEN_MIN_AND_MAX(colNum,
			cellStruct.numCell.CC_current)) {
	        case FIELD_IN_RANGE:
		     break;
		case FIELD_BELOW_MIN:
		     return FFFV_FIELD_SMALLER_THAN_MIN;
		case FIELD_ABOVE_MAX:
		     return FFFV_FIELD_LARGER_THAN_MAX;
	    }

	    /*
	     * The value was fine.
	     */
	    cellStruct.numCell.CC_common.CC_type = CT_CONSTANT;
	    dataSize = sizeof(CellConstant);
	    break;

	case FDT_COMPUTED:
	    /*
	     * Computed fields are not stored from text, they're computed.
	     */
	default:
	    EC_ERROR(BAD_FIELD_DATA_TYPE);
	    break;
    }

    pself = ObjDerefGen(oself);
    CellReplace(&pself->SSI_cellParams,
		TEMP_DATA_ROW, (word) colNum, (void *)&cellStruct, dataSize);

    /*
     * Success!
     */
    return FFFV_FIELD_OK;
}

/***********************************************************************
 *
 * MESSAGE:	MSG_FFD_LOAD_TEMP_ROW_FROM_ANOTHER_ROW
 *	    	for FlatFileDatabaseClass
 *
 * DESCRIPTION:	This method loads up the TEMP_DATA_ROW with fields from
 *	    	a database record.
 *
 *	    	The "marked" flag is copied as well.
 *
 *	    	NOTE: only fields from the current layout are loaded!
 *
 * PARAMETERS:
 *	void (word recordToLoad)
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	5/20/92		Initial version
 *	jeremy	1/9/93	    	Added the marked flag copy
 *
 ***********************************************************************/
@method FlatFileDatabaseClass, MSG_FFD_LOAD_TEMP_ROW_FROM_ANOTHER_ROW
{
    FieldID i, actualColumn;
    Boolean marked;

    /*
     * Copy all of the fields over and recalculate its dependents,
     * if necessary.
     */
    pself = ObjDerefGen(oself);
    for (i=0; i < pself->FFI_numInLayoutNameList; i++) {
	actualColumn = pself->FFI_layoutNameList[i];
	/*
	 * Load the field, even if it's an expression.
	 */
	FFDCopyFieldToTempDataRow(oself, recordToLoad,
				  actualColumn, actualColumn);
	pself = ObjDerefGen(oself);
    }

    /*
     * Now load up the list of computed fields not in the current
     * layout.
     */
    for (i=0; i < pself->FFI_numInNotInLayoutNameList; i++) {
	actualColumn = pself->FFI_notInLayoutNameList[i];
	if (FFDGetDataTypeAndFlags(oself, actualColumn, NULL) == FDT_COMPUTED){
	    FFDCopyFieldToTempDataRow(oself, recordToLoad,
				      actualColumn, actualColumn);
	}
	pself = ObjDerefGen(oself);
    }	    

    /*
     * Copy the "marked" flag from this row.
     */
    marked = FFDGetRecordMarkStatus(pself, recordToLoad);
    
    pself = ObjDerefGen(oself);
    FFDSetRecordMarkStatus(pself, TEMP_DATA_ROW, marked);
}

/***********************************************************************
 *
 * MESSAGE:	MSG_FFD_STORE_TEMP_ROW_INTO_ANOTHER_ROW
 *		for FlatFileDatabaseClass
 *
 * DESCRIPTION:	We keep data for the current row in a temporary row
 *		(TEMP_DATA_ROW). This message stores the data 
 *		from the temporary row into another row.
 *
 *	    	The "marked" flag os copied over as well.
 *
 *	    	NOTE: only fields from the current layout are loaded,
 *	    	except for all computed fields, which might have
 *	    	changed.
 *
 * PARAMETERS: 	void (word rowToStoreInto)
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	anna	4/17/92		Initial version
 *	jeremy	1/9/93	    	Added the marked flag copy
 *	jeremy	2/8/93	    	Added all computed fields copy
 *
 ***********************************************************************/
@method FlatFileDatabaseClass, MSG_FFD_STORE_TEMP_ROW_INTO_ANOTHER_ROW
{
    FieldListID i;
    FieldID actualColumn;
    Boolean marked;

    for (i=0; i < pself->FFI_numInLayoutNameList; i++) {
	actualColumn = pself->FFI_layoutNameList[i];

	FFDCopyFieldFromTempDataRow(oself, actualColumn,
				    rowToStoreInto, actualColumn);
	pself = ObjDerefGen(oself);
    }

    /*
     * Now save off the list of computed fields not in the current
     * layout.
     */
    for (i=0; i < pself->FFI_numInNotInLayoutNameList; i++) {
	actualColumn = pself->FFI_notInLayoutNameList[i];
	if (FFDGetDataTypeAndFlags(oself, actualColumn, NULL) == FDT_COMPUTED){
	    FFDCopyFieldFromTempDataRow(oself, actualColumn,
					rowToStoreInto, actualColumn);
	}
	pself = ObjDerefGen(oself);
    }	    

    /*
     * Copy the "marked" flag to the row.
     */
    marked = FFDGetRecordMarkStatus(pself, TEMP_DATA_ROW);
    
    pself = ObjDerefGen(oself);
    FFDSetRecordMarkStatus(pself, rowToStoreInto, marked);
}


/***********************************************************************
 *
 * FUNCTION:	FFDCopyCellDependencies
 *
 * DESCRIPTION:	This function copies the dependency dword for a specific
 *	    	column into a CellCommon field.
 *
 * PARAMETERS:	oself - an optr to the current database
 *	    	colNum - the column of the field we're getting the dependency
 *	    	    	 from.
 *	    	dest - a pointer to a structure that has a CellCommon
 *	    	       as its first element.
 *
 * CALLED BY:	INTERNAL
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 >*	    	WARNING!: Do not use this function if a cell is already
 >*	    	    	  locked!  Bad things can happen!
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	7/23/92		Initial version
 *
 ***********************************************************************/
void
FFDCopyCellDependencies(optr oself, FieldID colNum, CellCommon *dest)
{
    FlatFileDatabaseInstance *pself;
    CellCommon *source;

    pself = ObjDerefGen(oself);
    source = CellLock(&pself->SSI_cellParams,
		      TEMP_DATA_ROW,
		      colNum);
    if (source) {
	dest->CC_dependencies = source->CC_dependencies;
	CellUnlock(source);
    } else {
	dest->CC_dependencies = 0;
    }
}

/***********************************************************************
 *
 * FUNCTION:	FFDCopyFieldToTempDataRow
 *
 * DESCRIPTION:	This function copies the data in one cell into a cell
 *	    	in the TEMP_DATA_ROW.  The dependencies of the cells
 *	    	already in the TEMP_DATA_ROW will be preserved.
 *
 *	    	Note that formula cells are loaded up from the column's
 *	    	formula definition row, not from the "source" row.
 *
 * PARAMETERS:	sourceRecord, sourceField - what you'd think.
 *	    	destField - the column of the TEMP_DATA_ROW to be replaced.
 *	    	oself - optr to the database this operation is affecting.
 *
 * CALLED BY:	INTERNAL
 *
 * STRATEGY:
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	6/ 2/92		Initial Revision
 *	jeremy	7/23/92	    	Updated for formulae and dependencies.
 *
 ***********************************************************************/
void
FFDCopyFieldToTempDataRow(optr oself, word sourceRecord, FieldID sourceField,
			  FieldID destField)
{
    FieldDataType dataType;
    word dataSize;
    TCHAR *text;
    MemHandle tcbHandle;
    byte *tempCellBuffer;
    CellCommon *cellDataPtr;
    CellEmpty emptyCell;
    FlatFileDatabaseInstance *pself;

    /*
     * Are we copying to a formula cell?
     */
    dataType = FFDGetDataTypeAndFlags(oself, destField, NULL);
    
    if (dataType == FDT_COMPUTED) {
	/*
	 * The destination type is a formula.  Load up the cell as a
	 * FormulaCell.
	 */
	FFDLoadFormulaCellFromExistingCell(oself, sourceRecord, sourceField,
					   destField);
	return;
    }
    
    /*
     * No formula.  Create a temporary buffer in which to copy the cell
     * data.
     */
    tcbHandle = MemAlloc(MAX_CELL_DATA_SIZE, HF_SHARABLE | HF_SWAPABLE,
			      HAF_NO_ERR);
    tempCellBuffer = MemLock(tcbHandle);
    
    /*
     * Use the empty cell as a place to store the dependency.
     */
    FFDCopyCellDependencies(oself, destField, (CellCommon *)&emptyCell);
    
    /*
     * Copy the data over.
     */
    pself = ObjDerefGen(oself);
    cellDataPtr = CellLock(&pself->SSI_cellParams,
			   sourceRecord, 
			   (word) sourceField);

    /*
     * If the cell is empty, clear out the destination cell but preserve
     * its dependencies (which were just set above).
     */
    if ((cellDataPtr == NULL) ||
    	(cellDataPtr->CC_type == CT_EMPTY)) {
	pself = ObjDerefGen(oself);
	emptyCell.CE_common.CC_type = CT_EMPTY;
	emptyCell.CE_common.CC_recalcFlags = 0;
	emptyCell.CE_common.CC_attrs = 0;
	emptyCell.CE_common.CC_notes = 0;
	if (cellDataPtr) {
	    CellUnlock(cellDataPtr);
	}
	CellReplace(&pself->SSI_cellParams,
		    TEMP_DATA_ROW,
		    (word) destField,
		    &emptyCell, sizeof(CellEmpty));
	MemFree(tcbHandle);
	return;
    }

    /*
     * Determine its length from its type.
     */
    switch (cellDataPtr->CC_type) {
	case CT_TEXT:
	    text = (char *) cellDataPtr + sizeof(CellText);
	    dataSize = sizeof(CellText) + (strlen(text) + 1)*sizeof(TCHAR);
	    break;
	
	case CT_CONSTANT:
	    dataSize = sizeof(CellConstant);
	    break;

	default:
	    EC_ERROR(BAD_FIELD_DATA_TYPE);
	    break;
    }

#if ERROR_CHECK
    if (dataSize > MAX_CELL_DATA_SIZE) {
	EC_ERROR(CELL_DATA_TOO_BIG);
    }
#endif /* ERROR_CHECK */

    /*
     * Copy the cell data into a temp buffer.
     */
    memcpy(tempCellBuffer, cellDataPtr, dataSize);
    CellUnlock(cellDataPtr);  
    
    /*
     * Set up the dependency, then copy data over to the TEMP_DATA_ROW.
     */
    pself = ObjDerefGen(oself);
    cellDataPtr = (CellCommon *) tempCellBuffer;
    cellDataPtr->CC_dependencies = emptyCell.CE_common.CC_dependencies;
    CellReplace(&pself->SSI_cellParams,
		TEMP_DATA_ROW,
		(word) destField,
		cellDataPtr,
		dataSize);

    MemFree(tcbHandle);
}

/***********************************************************************
 *
 * FUNCTION:	FFDCopyFieldFromTempDataRow
 *
 * DESCRIPTION:	This function copies the data in a TEMP_DATA_ROW cell
 *	    	into another row's cell.  Formula results are NOT saved,
 *	    	since formulae are recalculated on the fly.
 *
 *	    	If, for some reason, a formula's results are needed
 *	    	in a cell format, use FFDLoadFormulaResults().
 *
 * PARAMETERS:	sourceField - the field in the TEMP_DATA_ROW that's being
 *	    	    	      copied.
 *	    	destRecord, destField - what you'd think.
 *	    	oself - optr to the database this operation is affecting.
 *
 * CALLED BY:	INTERNAL
 *
 * STRATEGY:
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	7/23/92		Initial version
 *
 ***********************************************************************/
void
FFDCopyFieldFromTempDataRow(optr oself, FieldID sourceField,
			    word destRecord, FieldID destField)
{
    word dataSize;
    TCHAR *text;
    MemHandle tcbHandle;
    byte *tempCellBuffer;
    CellCommon *cellDataPtr;
    FlatFileDatabaseInstance *pself;

    tcbHandle = MemAlloc(MAX_CELL_DATA_SIZE, HF_SHARABLE | HF_SWAPABLE,
			      HAF_NO_ERR);
    tempCellBuffer = MemLock(tcbHandle);

    /*
     * Get the source data
     */
    pself = ObjDerefGen(oself);
    cellDataPtr = CellLock(&pself->SSI_cellParams,
			   TEMP_DATA_ROW,
			   (word) sourceField);

    /*
     * If the cell is empty, then copy it straight over as empty.
     */
    if (cellDataPtr == NULL) {
	pself = ObjDerefGen(oself);
	CellReplace(&pself->SSI_cellParams,
		    destRecord,
		    (word) destField,
		    NULL, 0);
	MemFree(tcbHandle);
	return;
    } else if (cellDataPtr->CC_type == CT_FORMULA) {
	/*
	 * The cell is a formula.  Load up the cell according to the type
	 * it evaluated to.
	 */
	FFDLoadFormulaResults((CellFormula *) cellDataPtr,
			      (CellCommon *) tempCellBuffer,
			      &dataSize);
    } else {
	/*
	 * The cell is a constant.  Determine its length from its type.
	 */
	switch (cellDataPtr->CC_type) {
	    case CT_TEXT:
	        text = (char *) cellDataPtr + sizeof(CellText);
		dataSize = sizeof(CellText) + (strlen(text) + 1)*sizeof(TCHAR);
		break;

	    case CT_CONSTANT:
		dataSize = sizeof(CellConstant);
		break;

	    case CT_EMPTY:
		dataSize = 0;
		break;

	    default:
		EC_ERROR(BAD_FIELD_DATA_TYPE);
		break;
	 }

	/*
	 * Copy the cell data into a temp buffer.
	 */
	memcpy(tempCellBuffer, cellDataPtr, dataSize);

	/*
	 * We don't want to copy over the dependency, however...
	 */
	((CellCommon *)tempCellBuffer)->CC_dependencies = 0;
    }

    CellUnlock(cellDataPtr);  

#if ERROR_CHECK
    if (dataSize > MAX_CELL_DATA_SIZE) {
	EC_ERROR(CELL_DATA_TOO_BIG);
    }
#endif /* ERROR_CHECK */

    /*
     * If the resulting data length is 0, clear out the destination field.
     */
    pself = ObjDerefGen(oself);
    if (dataSize == 0) {
	CellReplace(&pself->SSI_cellParams,
		    destRecord,
		    (word) destField,
		    NULL, 0);
    } else {
	/*
	 * Copy data over to the destination row
	 */
	CellReplace(&pself->SSI_cellParams,
		    destRecord,
		    (word) destField,
		    tempCellBuffer,
		    dataSize);
    }
    MemFree(tcbHandle);
}

/***********************************************************************
 *
 * MESSAGE:	MSG_FFD_LOAD_CURRENT_RECORD_TO_SCREEN for
 *	    	    FlatFileDatabaseClass
 *
 * DESCRIPTION:	This method loads the TEMP_DATA_ROW with field info from
 *	    	the current record, then loads the current layout's screen
 *	    	fields with the info for the user's editing pleasure.
 *
 * PARAMETERS:
 *	void ()
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	5/20/92		Initial version
 *
 ***********************************************************************/
@method FlatFileDatabaseClass, MSG_FFD_LOAD_CURRENT_RECORD_TO_SCREEN
{
    @call self::
	MSG_FFD_LOAD_TEMP_ROW_FROM_ANOTHER_ROW(pself->SSI_active.CR_row);

    @call self::MSG_FFD_TRANSFER_TEMP_ROW_TO_SCREEN_FIELDS();
}


/***********************************************************************
 *
 * MESSAGE:	MSG_FFD_EDIT_NEW_RECORD for FlatFileDatabaseClass
 *
 * DESCRIPTION:	This method clears the TEMP_DATA_ROW's fields (the
 *	    	ones used by the the current layout, anyway), loads up
 *	    	the fields that have computed defaults, loads up the
 *	    	screen's fields from the temp row, and sets the
 *	    	FFI_editingNewRecord flag.
 *		If successful then clears FFI_dirtyRecord flag.
 *
 *	    	This is the method to call when the user wants to create
 *	    	a new field.
 *
 * PARAMETERS:	Pass: Boolean moveGrObjBody - When you request
 *					a new record and are in multi-record
 *					mode, it's possible that the 
 *					GrObjBody associated with the new
 *					record needs to be moved. If the
 *					GrObjBody is not necessarily in
 *					the right place, pass TRUE
 *		NewRecordType newRecordType - NRT_REGULAR or
 *				NRT_LOAD_FROM_TEMP_VISUAL_UPDATE_ROW
 *				In multi-record data entry mode,
 *				it's possible that we're editing a
 *				dirtied new record and we have to
 *				redraw everything. In order to redraw,
 *				we cycle through all of the records
 *				In the process, we commit all dirty
 *				records. But we don't really want to
 *				commit the data of the new record yet,
 *				so we store it in the temporary
 *				data row reserved for visual updates.
 *				Then, when we go back to edit this
 *				record, we read back in the data from
 *				this row. If we want to do this here,
 *				send NRT_LOAD_FROM_TEMP_VISUAL_UPDATE_ROW
 *					
 *		Boolean fieldGrabTarget - TRUE if you want the first field
 *						to grab the target; FALSE if
 *						you do not want the targets
 *						to be mucked with
 *		Return: nothing
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	5/21/92		Initial version
 *	JDM	92.07.29	Clears dirty record flag.
 *	anna	9/25/92		Code to deal with multi-record.
 *	JDM	93.01.05	Field Navigation Order shme.
 *
 ***********************************************************************/
@method FlatFileDatabaseClass, MSG_FFD_EDIT_NEW_RECORD
{
    Boolean stayOnThisPage, noVisibleFields;
    EventHandle event;
    FieldID fieldNum;
    byte fieldCount;

    stayOnThisPage = TRUE;
    
    /* the following check is commented out since if one is
     * importing a file, one can be in design mode when
     * this routine is called  -TED 11/13/92
     *
     * #if ERROR_CHECK
     * if (!(pself->FFI_currentMode & MT_DATA_ENTRY)) {
     * EC_ERROR(BAD_MODE_TYPE);
     * }
     * #endif
     */

    if ((moveGrObjBody) && (pself->FFI_currentLayoutType == LT_MULTI_RECORD)) {
	stayOnThisPage = FFDRCCreateNewRecordForMultiRecDataEntry(oself); 
    }

    /*
     * Only clear the dirty flag if we're not copying the data out
     */
    if (newRecordType == NRT_REGULAR) {
	pself = ObjDerefGen(oself);
        pself->FFI_dirtyRecord = FALSE;		/* Isn't dirty yet.	*/
    }

    /*
     * If we are creating a regular new record,
     * fill the TEMP_DATA_ROW with computed defaults, or empty strings.
     * Otherwise, load in the values that are currently in the temporary
     * data row reserved for visual updates.
     *
     * NOTE: only the fields in the current layout are used.
     */
    if (newRecordType == NRT_REGULAR) {
        @call self::MSG_FFD_SET_TEMP_DATA_ROW_FOR_NEW_RECORD();
    }
    else {
	@call self::MSG_FFD_LOAD_TEMP_ROW_FROM_ANOTHER_ROW(
				TEMP_DATA_ROW_FOR_VISUAL_UPDATES);
    }
    
    /*
     * Load up the screen fields with the TEMP_DATA_ROW's new data.
     */
    @call self::MSG_FFD_TRANSFER_TEMP_ROW_TO_SCREEN_FIELDS();

    /*
     * Set the "currently editing a new record" flag.
     */
    pself = ObjDerefGen(oself);
    pself->FFI_editingNewRecord = TRUE;

    /*
     * If we had to move to a new page, redraw the view 
     */
    if (!stayOnThisPage) {
        /*
         * Force the view to redraw
         */
        event = @record GenViewClass::MSG_GEN_VIEW_REDRAW_CONTENT();

        @send self::MSG_VIS_VUP_CALL_OBJECT_OF_CLASS(event);
    }

    /*
     * If we aren't mucking with the target, we're done
     */
    if (!fieldGrabTarget) {
	return;
    }

    /*
     * Move the focus/target to the first visible field in the tab order list.
     */
    pself = ObjDerefGen(oself);
    fieldNum = @call oself::MSG_FFD_FNO_INFO_GET_FIELD
		(pself->FFI_fieldOrderInfo.FNOI_fieldOrderList [0],
		 FOMC_FIRST_FIELD);
    noVisibleFields = FALSE;
    fieldCount = 0;

    /*
     * Make sure we find a visible field
     */
    pself = ObjDerefGen(oself);
    if (pself->FFI_numInLayoutNameList == 0) {
	noVisibleFields = TRUE;
    }
    else {
        while (!FFDIsFieldWithinRecordBounds(oself, fieldNum)) {
            fieldCount++;
	    if (fieldCount == pself->FFI_numInLayoutNameList) {
	        /*
	         * There are no visible fields! Do nothing...
	         */
	        noVisibleFields = TRUE;
	        break;
	    }
            fieldNum = @call oself::MSG_FFD_FNO_INFO_GET_NEXT_FIELD
		        (fieldNum, TRUE);
	    pself = ObjDerefGen(oself);
	}
    }

    /*
     * If we're not in multi-record, give the new field the target and focus.
     */
    if (!noVisibleFields) {
        pself = ObjDerefGen(oself);
        if (((moveGrObjBody) ||
	     (pself->FFI_currentLayoutType == LT_SINGLE_RECORD)) &&
	    ((FieldListID)(-1) != fieldNum)) {
            FFDFieldGrabTargetAndForceOnScreen(oself, fieldNum);
	}
    }
}

/***********************************************************************
 *
 * FUNCTION:	MSG_FFD_GRAB_TARGET_ON_FIRST_FIELD 
 *
 * DESCRIPTION:	
 *		Finds the first visible field in the current layout and has it
 *		grab the target
 *
 * PARAMETERS:
 *	void (optr oself - optr to database object)
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	anna	3/9/93		Initial version
 *
 ***********************************************************************/
@method FlatFileDatabaseClass, MSG_FFD_GRAB_TARGET_ON_FIRST_FIELD 
{
    FFDGrabTargetOnFirstField(oself);
}

/***********************************************************************
 *
 * FUNCTION:	FFDGrabTargetOnFirstField 
 *
 * DESCRIPTION:	
 *		Finds the first visible field in the layout and has it
 *		grab the target
 *
 * PARAMETERS:
 *	void (optr oself - optr to database object)
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	anna	3/9/93		Initial version
 *
 ***********************************************************************/
void
FFDGrabTargetOnFirstField(optr oself)
{
    Boolean noVisibleFields;
    byte fieldCount;
    FieldID fieldNum;
    FlatFileDatabaseInstance *pself;

    pself = ObjDerefGen(oself);

    if (pself->FFI_currentMode & MT_DESIGN) {
	/*
	 * We're in design mode!  Get out of here, since we don't want to
	 * grab the target, for goodness's sake.
	 */
	return;
    }

    /*
     * Move the focus/target to the first visible field in the tab order list.
     */
    fieldNum = @call oself::MSG_FFD_FNO_INFO_GET_FIELD
		(pself->FFI_fieldOrderInfo.FNOI_fieldOrderList [0],
		 FOMC_FIRST_FIELD);

    noVisibleFields = FALSE;
    fieldCount = 0;

    /*
     * Make sure we find a visible field
     */
    pself = ObjDerefGen(oself);
    if (pself->FFI_numInLayoutNameList == 0) {
	noVisibleFields = TRUE;
    }
    else {
        while (!FFDIsFieldWithinRecordBounds(oself, fieldNum)) {
            fieldCount++;
	    if (fieldCount == pself->FFI_numInLayoutNameList) {
	        /*
	         * There are no visible fields! Do nothing...
	         */
	        noVisibleFields = TRUE;
	        break;
	    }
            fieldNum = @call oself::MSG_FFD_FNO_INFO_GET_NEXT_FIELD
		(fieldNum, TRUE);
	    pself = ObjDerefGen(oself);
	}
    }

    /*
     * Give the new field the target and focus.
     */
    if (!noVisibleFields) {
        if ((FieldListID)(-1) != fieldNum) {
	    FFDFieldGrabTargetAndForceOnScreen (oself, fieldNum);
        }
    }
}

/***********************************************************************
 *
 * MESSAGE:	MSG_FFD_EDIT_EXISTING_RECORD for FlatFileDatabaseClass
 *
 * DESCRIPTION:	
 *	This method loads the TEMP_DATA_ROW's fields (the
 *   	ones used by the the current layout, anyway) with data
 *	from a record and loads up the screen's fields with the
 *	data. It also clears the FFI_editingNewRecord flag.
 *	If successful then clears FFI_dirtyRecord flag.
 *
 *    	This is the method to call when the user wants to edit
 *    	an existing record.
 *
 * PARAMETERS:
 *	void (word recordToEdit
 *		Boolean moveGrObjBody)	- When you request
 *					an existing record and are 
 *					in a multi-record layout,
 *					it's possible that the 
 *					GrObjBody associated with the new
 *					record needs to be moved. If the
 *					GrObjBody is not necessarily in
 *					the right place, pass TRUE
 *		Boolean fieldGrabTarget - TRUE if you want the first field
 *						to grab the target; FALSE if
 *						you do not want the targets
 *						to be mucked with
 *		NewRecordType editRecordType - ERT_REGULAR or
 *				ERT_LOAD_FROM_TEMP_VISUAL_UPDATE_ROW
 *				In multi-record data entry mode,
 *				it's possible that we're editing a
 *				dirtied record and we have to
 *				redraw everything. In order to redraw,
 *				we cycle through all of the records
 *				In the process, we commit all dirty
 *				records. But we don't really want to
 *				commit the data of this record yet,
 *				so we store it in the temporary
 *				data row reserved for visual updates.
 *				Then, when we go back to edit this
 *				record, we read back in the data from
 *				this row. If we want to do this here,
 *				send ERT_LOAD_FROM_TEMP_VISUAL_UPDATE_ROW
 *					
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	5/21/92		Initial version
 *	JDM	92.07.29	Clears dirty record flag.
 *	JDM	93.01.05	Field Navigation Order shme.
 *
 ***********************************************************************/
@method FlatFileDatabaseClass, MSG_FFD_EDIT_EXISTING_RECORD
{
    Boolean stayOnThisPage;
    EventHandle event;

    stayOnThisPage = TRUE;
/* 
#if ERROR_CHECK
    if (!(pself->FFI_currentMode & MT_DATA_ENTRY)) {
	EC_ERROR(BAD_MODE_TYPE);
    }
#endif /* ERROR_CHECK */

    if (moveGrObjBody) {
	/*
  	 * Are we in multi-record data entry? If so, we may have
	 * to move over the grObjBody
	 */
  	FFDRCMoveGrObjBodyForMultiRecDataEntry(oself, recordToEdit, 
						 &stayOnThisPage);
    }

    if (editRecordType == ERT_REGULAR) {
        @call self::MSG_FFD_LOAD_TEMP_ROW_FROM_ANOTHER_ROW(recordToEdit);
    }
    else {
        @call self::MSG_FFD_LOAD_TEMP_ROW_FROM_ANOTHER_ROW(
				TEMP_DATA_ROW_FOR_VISUAL_UPDATES);
    }
    
    /*
     * Load up the screen fields with the TEMP_DATA_ROW's new data.
     */
    @call self::MSG_FFD_TRANSFER_TEMP_ROW_TO_SCREEN_FIELDS();

    /*
     * Set the current row to the new record.
     */
    pself = ObjDerefGen(oself);
    pself->SSI_active.CR_row = recordToEdit;

    /*
     * Set the current marked record position, if we're showing only
     * marked records.
     * Also reset the page number, taking into consideration if we're showing
     * only marked records.
     */
    if (pself->FFI_showOnlyMarked) {
	pself->FFI_currentMarkedRecord =
	    FFDDetermineMarkedPosition(oself, recordToEdit) - 1;
	pself->FFI_currentPage =
	    (word)((pself->FFI_currentMarkedRecord + 1)/
		   FFDCalculateNumRecordsPerPage(oself, 0, 0));
    } else {
	pself->FFI_currentPage =
	    (word)(recordToEdit / FFDCalculateNumRecordsPerPage(oself, 0, 0));
    }

    /*
     * Clear the "currently editing a new record" flag.
     */
    pself = ObjDerefGen(oself);
    pself->FFI_editingNewRecord = FALSE;
    if (editRecordType == ERT_REGULAR) {
        pself->FFI_dirtyRecord = FALSE;		/* Isn't dirty yet.	*/
    }

    if (pself->FFI_currentLayoutType == LT_MULTI_RECORD) {
        if (!stayOnThisPage) {
            /*
             * Force the view to redraw
             */
            event = @record GenViewClass::MSG_GEN_VIEW_REDRAW_CONTENT();

            @send self::MSG_VIS_VUP_CALL_OBJECT_OF_CLASS(event);
        }
    }

    if (fieldGrabTarget) {
        FFDGrabTargetOnFirstField(oself);
    }
}


/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		MSG_FFD_REVERT_CURRENT_RECORD
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

DESCRIPTION:	Revert the currently selected to the contents of the record
		prior to this editing session (empty iff new record).

PASS: 		Void.

RETURN:		Boolean	= TRUE iff successful.
			  FALSE otherwise.

PSEUDO CODE/STRATEGY:
	Confirm the revert operation with the user.
	If ok then
		If Editing a new record then
			Clear out the temporary record to the neutral
			state.
		Otherwise, if editing an already existing record then
			Reset the temporary record to the record's data.

REQUIRES:	???

ASSERTS:	???

CHECKS:		None.

KNOWN DEFECTS/SIDE EFFECTS/CAVEATS/IDEAS:	???

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	JDM	92.07.15	Initial version.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/

@method FlatFileDatabaseClass, MSG_FFD_REVERT_CURRENT_RECORD
{
    TCHAR *dialogString;
    InteractionCommand usdReply;
    
    /*
     * Verfiy the operation with the user.
     * First, get access to the user message string.
     */
    MemLock (OptrToHandle(@FFConfirmRevertRecordString));
    dialogString = LMemDeref(@FFConfirmRevertRecordString);
    
    /* Find out what the user wants to do.	*/
    usdReply = UserStandardDialog
    	((TCHAR *) 0,	/* No help context	*/
    	 (TCHAR *) 0, 	/* No custom responses.	*/
	 (TCHAR *) 0,	/* No arguments	    	*/
	 (TCHAR *) 0,
	 dialogString,		/* User prompt string.	*/
	 ((GIT_AFFIRMATION << CDBF_INTERACTION_TYPE_OFFSET) |
	  (CDT_QUESTION << CDBF_DIALOG_TYPE_OFFSET)));
    
    /* Get rid of the string block.	*/
    MemUnlock (OptrToHandle (@FFConfirmRevertRecordString));
    
    /* User wants to bail?	*/
    if (IC_NO == usdReply) {
	/* Yep.  Don't revert.	*/
	return (FALSE);
    }
    
    /*
     * Right, the user said OK, so let's do it!
     * Editing a new record?
     */
    if (pself->FFI_editingNewRecord) {
	/* Yep, so reset the temporary row to the neutral state.	*/
	@send oself::MSG_FFD_EDIT_NEW_RECORD(FALSE, NRT_REGULAR, FALSE);
    }
    /*
     * Not a new record.
     * Editing a record that already exists in the database?
     */
    else if (pself->FFI_dirtyRecord) {
	/* Yep, so reset the temporary from the database entry.	*/
	@send oself::MSG_FFD_EDIT_EXISTING_RECORD (pself->SSI_active.CR_row,
						   FALSE, FALSE, NRT_REGULAR);
    }
    
    /* Otherwise, not editing anything so nothing to do!	*/
    return (TRUE);
}


/***********************************************************************
 *
 * MESSAGE:	MSG_FFD_COMMIT_TEMP_DATA_ROW_TO_DATABASE
 *	    	for FlatFileDatabaseClass
 *
 * DESCRIPTION:	This method saves the information in the TEMP_DATA_ROW's
 *	    	fields (the fields used by the current layout, anyway)
 *	    	to the current layout's row, unless the
 *	    	FFI_editingNewRecord flag is set.  If this is set,
 *	    	then a new row will be saved, the total number of
 *	    	records will be incremented, the current record will
 *	    	be set to the new record, and the FFI_editingNewRecord
 *	    	flag will be cleared.
 *
 *		If we are editing a new record in multi-record mode, and
 *		we are re-drawing things, then we want to save off the
 *		data in the new record without committing it to the
 *		database. In this case, pass commitRecordType =
 *		CRT_VISUAL_UPDATE_COMMIT. The data will be saved out to
 *		a temporary row.
 *		If you do want the data committed to the database as
 *		normal, pass CRT_REGULAR_COMMIT.
 *
 * PARAMETERS:
 *	Pass:	Boolean displayErrorMessages - true if you want
 *						errors displayed in a 
 *						UserStandardDialog error box
 *		CommitRecordType commitRecordType - CRT_REGULAR_COMMIT,
 *						CRT_VISUAL_UPDATE_COMMIT, or
 *	    	    	    	    	    	CRT_SAVE_FILE_COMMIT
 *		
 *	Returns: InsertResult
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	5/21/92		Initial version
 *	JDM	92.07.14	Modified for Record Control Panel.
 *	anna	11/11/192	Added commitRecordType param
 *
 ***********************************************************************/
@method FlatFileDatabaseClass, MSG_FFD_COMMIT_TEMP_DATA_ROW_TO_DATABASE
{
    FieldID fieldColumn;
    optr grObjBody, fieldTextOptr;
    optr fieldTextGuardianOptr;
    EventHandle event;

#if ERROR_CHECK

    /* the following check is commented out since if one is
     * importing a file, one can be in design mode when
     * this routine is called  -TED 11/13/92
     *
     * if (!(pself->FFI_currentMode & MT_DATA_ENTRY)) {
     * EC_ERROR(BAD_MODE_TYPE);
     * }
     */

    switch(commitRecordType) {
	case CRT_REGULAR_COMMIT:
	case CRT_VISUAL_UPDATE_COMMIT:
	case CRT_SAVE_FILE_COMMIT:
	    break;
	default:
	    EC_ERROR(BAD_COMMIT_RECORD_TYPE);
    }
#endif /* ERROR_CHECK */
    
    /*
     * If there are no fields in this layout, return
     */
    if (pself->FFI_numInLayoutNameList == 0) {
	return(NO_INSERT_DONE);
    }

    /*
     * If we're currently editing a field, force it to be validated.
     */
    grObjBody = @call self::
	    MSG_FFD_GET_GROBJ_BODY_FOR_LAYOUT(pself->FFI_currentLayout,
					      LT_SINGLE_RECORD);

    (void) @call grObjBody::
	MSG_META_GET_TARGET_EXCL(&fieldTextGuardianOptr);


    /* If there is a target below the GrObjBody, check it */

    pself = ObjDerefGen(oself);
    if (fieldTextGuardianOptr && (pself->FFI_currentMode & MT_DATA_ENTRY)) {
        fieldTextOptr = @call fieldTextGuardianOptr::
					MSG_GOVG_GET_VIS_WARD_OD();

        fieldColumn = @call fieldTextOptr::
				MSG_GET_FIELD_COLUMN_FROM_TEXT_OBJECT();

	/*
	 * If we want error messages displayed, use the validation routine
	 * that displays errors.  Otherwise, use the message that doesn't.
	 * Both return the same results.
	 */
	switch ((displayErrorMessages ?
	  FFDValidateScreenFieldWithMessage (oself,
					     fieldTextOptr,
					     fieldColumn,
					     FALSE) :
	  FFDValidateScreenField(oself, fieldTextOptr, fieldColumn, FALSE))) {
	    case FFFV_FIELD_OK:
	    case FFFV_FIELD_NOT_DIRTY:
	    case FFFV_NOT_IN_DESIGN_MODE:
	    	break;
	    default:
		/*
		 * If we're not saving to a file, simply return a fail flag.
		 */
		if (commitRecordType != CRT_SAVE_FILE_COMMIT) {
	            return INSERT_FAILED;
		}
		break;
	}
    }

    pself = ObjDerefGen(oself);
    if (pself->FFI_editingNewRecord) {
	/*
	 * Was any data entered?  If not, leave.
	 */
	if (!(pself->FFI_dirtyRecord)) {
	    return NO_INSERT_DONE;
	}

	/*
	 * The fields were all entered correctly.  Find a new row to insert
	 * into, and copy the TEMP_DATA_ROW into it.
	 */
	if ((commitRecordType == CRT_REGULAR_COMMIT) ||
	    (commitRecordType == CRT_SAVE_FILE_COMMIT)) {
	    
	    pself->SSI_active.CR_row = pself->FFI_totalNumRecordsInDatabase;
	    pself->FFI_totalNumRecordsInDatabase++;

	    /*
	     * Increment the number of records to display, if we should.
	     */
	    if (pself->FFI_showOnlyMarked) {
		/*
		 * We're showing only marked records, so only increment
		 * the number of displayable records if the one just created
		 * was evaluated as being marked.
		 */
		if (FFDGetRecordMarkStatus(pself,
 	    	        pself->FFI_totalNumRecordsInDatabase)){
		    pself->FFI_numRecords = ++(pself->FFI_numMarkedRecords);
		}
		else {
		    /* 
		     * The record is not marked. If we're in multi-record
		     * mode we want to redraw the screen
		     */
		    if (pself->FFI_currentLayoutType == LT_MULTI_RECORD) {
        		/*
         		* Force the view to redraw
         		*/
        		event = @record GenViewClass::
					MSG_GEN_VIEW_REDRAW_CONTENT();
        		@send self::MSG_VIS_VUP_CALL_OBJECT_OF_CLASS(event);
		    }
		}
	    } else {
		/*
		 * Since we're showing all records in the database,
		 * set the number of displayable records to the
		 * total number of records in the database.
		 */
		pself->FFI_numRecords = pself->FFI_totalNumRecordsInDatabase;
	    }

	    pself = ObjDerefGen(oself);
	    @call self::
	        MSG_FFD_STORE_TEMP_ROW_INTO_ANOTHER_ROW(
						pself->SSI_active.CR_row);

	}
	else {
	    /* We don't want to commit this data to the database; we want
	       it stored in a temporary row */
	    @call self::
		MSG_FFD_STORE_TEMP_ROW_INTO_ANOTHER_ROW(
					TEMP_DATA_ROW_FOR_VISUAL_UPDATES);	
	}

	pself = ObjDerefGen(oself);
	pself->FFI_editingNewRecord = FALSE;
	pself->FFI_dirtyRecord = FALSE;
    } else /* (committing an existing record) */{
	/*
	 * Was any data entered?  If not, leave.
	 */
	if (!(pself->FFI_dirtyRecord)) {
	    return NO_INSERT_DONE;
	}

	/*
	 * The fields are all entered correctly.  Insert the data.
	 */
	if (commitRecordType == CRT_VISUAL_UPDATE_COMMIT) {
	    @call self::MSG_FFD_STORE_TEMP_ROW_INTO_ANOTHER_ROW(
					TEMP_DATA_ROW_FOR_VISUAL_UPDATES);
 	}
	else {
	    @call self::MSG_FFD_STORE_TEMP_ROW_INTO_ANOTHER_ROW(
					pself->SSI_active.CR_row);
	}

	pself = ObjDerefGen(oself);
	pself->FFI_dirtyRecord = FALSE;
    }	

    /*
     * Adjust the number of records to display, if we should.
     */
    if (pself->FFI_showOnlyMarked) {
	/*
	 * We're showing only marked records, so only decrement
	 * the number of displayable records if the one just committed
	 * was unmarked.
	 */
	pself->FFI_numRecords = pself->FFI_numMarkedRecords =
	    FFDGetNumberOfMarkedRecords(oself);
    }

    /*
     * Mark ourselves dirty so we're sure data gets changed 
     */
    ObjMarkDirty(oself);

    return INSERT_OK;
}


/***********************************************************************
 *
 * FUNCTION:	FFDEvalComputedField
 *
 * DESCRIPTION:	This function evaluates a computed field (but not its
 *	    	dependents), and does not redraw the field.
 *
 * PARAMETERS:	oself - optr to the current database.
 *	    	colNum - column of the computed field to evaluate
 *
 * CALLED BY:	INTERNAL
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	7/20/92	    	Initial version
 *
 ***********************************************************************/
void
FFDEvalComputedField(optr oself, FieldID colNum)
{
    FlatFileDatabaseInstance *pself;
    byte expressionResultBuffer[EVAL_BUFFER_SIZE];
    MemHandle formulaHandle;
    FormulaCellStruct *formulaCell;
    word dataSize;

    /*
     * Allocate enough space for a beeeeg computed cell.
     */
    if ((formulaHandle = MemAlloc(sizeof(FormulaCellStruct), HF_SWAPABLE,
				   HAF_ZERO_INIT)) == 0) {
	/*
	 * No memory is left.  Bummer.  Notify the user & leave.
	 */
	DisplayUserError(@FFMemoryFullError);
	return;
    }
    formulaCell = MemLock(formulaHandle);
    
    /*
     * Evaluate the darn thing.  Its return type will determine what
     * we'll store the expression as.
     */
    if (!FFDEvaluateDefaultExpression(oself, colNum,
				      expressionResultBuffer)) {
	/*
	 * Figure out what type the cell is, and replace away.
	 */
	FFDLoadFormulaFromEvaluationResults(oself, colNum,
					    expressionResultBuffer,
					    formulaCell, &dataSize);
    } else {
	/*
	 * Uh, oh.  A bad thing happened while evaluating the expression.
	 * Save the formula as an error.
	 */
	FFDLoadFormulaCell(oself, colNum, (CellFormula *)formulaCell);
	formulaCell->cf.CF_return = RT_ERROR;
	formulaCell->cf.CF_current.RV_ERROR = CE_GEN_ERR;
	dataSize = sizeof(CellFormula) + formulaCell->cf.CF_formulaSize;
    }

    /*
     * Set the cell.
     */
    pself = ObjDerefGen(oself);
    CellReplace(&pself->SSI_cellParams,
		TEMP_DATA_ROW,
		(word) colNum,
		(void *) formulaCell,
		dataSize);

    MemFree(formulaHandle);
}

/***********************************************************************
 *
 * FUNCTION:	FFDRecalculateDependents
 *
 * DESCRIPTION:	This function reevaluates all of the computed fields
 *	    	that depend on the value of a specific field.
 *
 * PARAMETERS:	oself - optr to the current database.
 *	    	colNum - column of the field that just changed
 *	    	redraw - set to REDRAW or NO_REDRAW.  Should the
 *	    	    	 fields be redrawn as the dependents are
 *	    	    	 figured out?
 *
 * CALLED BY:	INTERNAL
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	6/15/92		Initial Revision
 *	jeremy	7/20/92	    	Changed to deal with dependents.
 *
 ***********************************************************************/
void
FFDRecalculateDependents(optr oself, FieldID colNum, RedrawFlag redraw)
{
    FlatFileDatabaseInstance *pself;
    CellCommon *cell;

    pself = ObjDerefGen(oself);
    /*
     * If the cell has no dependencies, then return.
     */
    cell = CellLock(&pself->SSI_cellParams,
		    TEMP_DATA_ROW,
		    (word) colNum);

    if (!cell || cell->CC_dependencies == 0) {
	if (cell) {
	    CellUnlock(cell);
	}
	return;
    }

    /*
     * The cell has dependents.  Reevaluate them.
     */
    CellUnlock(cell);
    pself = ObjDerefGen(oself);
    pself->SSI_active.CR_column = colNum;
    SpreadsheetRecalcDependents((SpreadsheetInstance *)pself,
				(redraw == REDRAW ? FFDUpdateExprRedraw :
			           (void _pascal (*)(optr, word, word))0),
				(word) TEMP_DATA_ROW,
				(word) colNum);
}

/***********************************************************************
 *
 * FUNCTION:	FFDUpdateExprRedraw
 *
 * DESCRIPTION:	This function is called by the spreadsheet code when an
 *	    	expression needs to be redrawn because it depended on
 *	    	another field that changed.
 *
 * PARAMETERS:	oself - an optr to the current database
 *	    	row - the row to redraw (always TEMP_DATA_ROW)
 *	    	column - column of the field to redraw
 *
 * CALLED BY:	INTERNAL
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	7/20/92		Initial version
 *
 ***********************************************************************/
void _pascal
FFDUpdateExprRedraw(optr oself, word row, word column)
{
    FlatFileDatabaseInstance *pself;
    FieldListID	layoutIndex;
    RecordLayoutChunkArrayHeader *cellDataPtr;
    CellRef cellOptr;
    RecordLayoutChunkArrayElement *currentIndexElement;
    MemHandle grObjectMemBlock;
    optr grObjectOptr;
    optr textOptr;
    MemHandle textHandle;
    
    row = row;	    	     	/* <- To stop a compiler warning. */

    /*
     * First, make sure that the expression is in the current layout.
     */
    pself = ObjDerefGen(oself);
    layoutIndex = FindFieldListElement(pself->FFI_layoutNameList,
				       column,
				       pself->FFI_numInLayoutNameList);

    if (layoutIndex == (FieldListID) -1) {
	return;
    }

    /*
     * Yes, the expression is in the current layout.  Continue...
     */
    cellDataPtr = CellLockGetRef(&pself->SSI_cellParams,
				 RECORD_LAYOUT_ROW, 
				 pself->FFI_currentLayout,
				 &cellOptr);
#if ERROR_CHECK
    if (!cellDataPtr) {
	EC_ERROR(CELL_DOES_NOT_EXIST);
    }
#endif	/* ERROR_CHECK */

    /*
     * Get a pointer to this element
     */
    currentIndexElement = ChunkArrayElementToPtr(cellOptr, 
						 layoutIndex,
						 (word *)0);
    /*
     * Get the associated GrObj
     */
    pself = ObjDerefGen(oself);
    grObjectMemBlock = VMVMBlockToMemBlock(pself->documentHandle, 
				currentIndexElement->GOEOP_grObjectVMBlock);
    grObjectOptr = ConstructOptr(grObjectMemBlock, 
			   	currentIndexElement->GOEOP_grObjectChunk);

    /*
     * Unlock the record layout chunk -- you can't have two cells locked
     * at the same time.
     */
    CellUnlock(cellDataPtr);

    /*
     * Get the OD for this text object.
     */
    textOptr = @call grObjectOptr::MSG_GOVG_GET_VIS_WARD_OD();

    /*
     * Allocate a text buffer for the redrawing code.
     */
    textHandle = MemAlloc((MAX_TEXT_FIELD_LENGTH + 1)*sizeof(TCHAR),
			       HF_SHARABLE | HF_SWAPABLE, HAF_NO_ERR);

    /*
     * Redraw the thing.
     */
    FFDDisplayFieldContents(oself, column, textOptr, textHandle, TRUE);

    MemFree(textHandle);
}

/***********************************************************************
 *
 * FUNCTION:	FFDLoadFormulaResults
 *
 * DESCRIPTION:	This function loads up a cell buffer with the results
 *	    	of a formula that depends upon other fields.
 *
 * PARAMETERS:	formulaCell - the pointer to a locked formula cell
 *	    	dest - a pointer to where to put the results
 *	    	dataSize - a pointer where to store the size of the result
 *
 * CALLED BY:	INTERNAL
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	7/23/92		Initial version
 *
 ***********************************************************************/
void
FFDLoadFormulaResults(CellFormula *formulaCell, CellCommon *dest,
		      word *dataSize)
{
    CellCommon *result;
    TextCellStruct textCell;
    CellConstant numCell;
    TCHAR *text;
    word textLen;
    
#if ERROR_CHECK
    if (formulaCell->CF_common.CC_type != CT_FORMULA) {
	EC_ERROR(BAD_FIELD_DATA_TYPE);
    }
#endif

    switch(formulaCell->CF_return) {
	case RT_TEXT:
	    /*
	     * It's a string!  Load up the text cell structure.
	     */
	    textLen = formulaCell->CF_current.RV_TEXT/sizeof(TCHAR);
	    text = (char *) formulaCell + sizeof (CellFormula) +
	      formulaCell->CF_formulaSize;	
	    textCell.string[0] = _TEXT('\0');	  /* For metaware */
	    strncpy(textCell.string, text, textLen);
	    textCell.string[textLen] = _TEXT('\0');
	    textCell.cellTextStruct.CT_common.CC_type = CT_TEXT;
	    textCell.cellTextStruct.CT_common.CC_dependencies = 0;
	    textCell.cellTextStruct.CT_common.CC_recalcFlags = 0;
	    textCell.cellTextStruct.CT_common.CC_attrs = 0;
	    textCell.cellTextStruct.CT_common.CC_notes = 0;
	    *dataSize = sizeof(CellText) + (textLen + 1)*sizeof(TCHAR);
	    result = (CellCommon *) &textCell;
	    break;

	case RT_VALUE:
	    /*
	     * The results are a number, date, or time.  They all use
	     * the same cell structure...
	     */
	    numCell.CC_common.CC_type = CT_CONSTANT;
	    numCell.CC_common.CC_dependencies = 0;
	    numCell.CC_common.CC_recalcFlags = 0;
	    numCell.CC_common.CC_attrs = 0;
	    numCell.CC_common.CC_notes = 0;
	    numCell.CC_current = formulaCell->CF_current.RV_VALUE;
	    *dataSize = sizeof(CellConstant);
	    result = (CellCommon *) &numCell;
	    break;

	case RT_ERROR:
	    /*
	     * An error occurred.  Give an error message.
	     */
	    textCell.cellTextStruct.CT_common.CC_type = CT_TEXT;
	    textCell.cellTextStruct.CT_common.CC_dependencies = 0;
	    textCell.cellTextStruct.CT_common.CC_recalcFlags = 0;
	    textCell.cellTextStruct.CT_common.CC_attrs = 0;
	    textCell.cellTextStruct.CT_common.CC_notes = 0;

	    FFDSetEvalErrorText(formulaCell->CF_current.RV_ERROR,
				textCell.string);

	    *dataSize = sizeof(CellText) + 
	                (strlen(textCell.string) + 1)*sizeof(TCHAR);
	    result = (CellCommon *) &textCell;
	    break;

	default:
	    /*
	     * This shouldn't happen, but in case it does: unknown return
	     * type.  Make it empty.
	     */
	    textCell.cellTextStruct.CT_common.CC_type = CT_TEXT;
	    textCell.cellTextStruct.CT_common.CC_dependencies = 0;
	    textCell.cellTextStruct.CT_common.CC_recalcFlags = 0;
	    textCell.cellTextStruct.CT_common.CC_attrs = 0;
	    textCell.cellTextStruct.CT_common.CC_notes = 0;
	    textCell.string[0] = _TEXT('\0');

	    *dataSize = sizeof(CellText) + sizeof(TCHAR);
	    result = (CellCommon *) &textCell;
	    break;
	    
    }

    /*
     * Copy the results and return.
     */
    memcpy(dest, result, *dataSize);
}

/***********************************************************************
 *
 * MESSAGE:	MSG_FFD_CHECK_FIELD_DATA_BETWEEN_MIN_AND_MAX
 *		for FlatFileDatabaseClass
 *
 * DESCRIPTION:	Checks the data for the given column. 
 *		If: 
 *		min <= value <= max, returns FIELD_IN_RANGE
 *		value < min, returns FIELD_BELOW_MIN
 *		value > max, returns FIELD_ABOVE_MAX
 *
 * PARAMETERS: 	FieldRangeCheck (word column, FloatNum dataValue)
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	anna	4/21/92		Initial version
 *	jeremy	6/18/92	    	Enumerated the return values.
 *
 ***********************************************************************/
@method FlatFileDatabaseClass, MSG_FFD_CHECK_FIELD_DATA_BETWEEN_MIN_AND_MAX
{
    FieldDataAttrs *cellDataPtr;
    FloatNum minValue, maxValue;
    FieldDataType dataType;

    /*
     * Get the data
     */
    cellDataPtr = CellLock(&pself->SSI_cellParams,
	     		   FIELD_TYPE_ROW, 
     	     		   (word) column);

    #if ERROR_CHECK
	if (!cellDataPtr) {
	    EC_ERROR(CELL_DOES_NOT_EXIST);
	}
    #endif	/* ERROR_CHECK */

    dataType = cellDataPtr->FDA_type;

    switch (dataType) {
	case FDT_REAL:
	case FDT_INTEGER:
	    minValue = ((ValueFieldDataAttrs *) cellDataPtr)->VFDA_min;
	    maxValue = ((ValueFieldDataAttrs *) cellDataPtr)->VFDA_max;
	    break;
	case FDT_DATE:
	case FDT_TIME:
	    minValue = ((DateFieldDataAttrs *) cellDataPtr)->DFDA_min;
	    maxValue = ((DateFieldDataAttrs *) cellDataPtr)->DFDA_max;
	    break;
	default:
    	    CellUnlock(cellDataPtr);
	    return(0);
    }

    CellUnlock(cellDataPtr);

    /*
     * Check that dataValue >= minValue
     */
    if (!CheckValue1LTEValue2(minValue, dataValue)) {
	return(FIELD_BELOW_MIN);
    }

    /*
     * Check that dataValue <= maxValue
     */
    if (!CheckValue1LTEValue2(dataValue, maxValue)) {
	return(FIELD_ABOVE_MAX);
    }

    return(FIELD_IN_RANGE);
}
/********* End of DatabaseDataEntrySupport resource *********/

/********* Beginning of DatabaseNewRecordSupport resource *********/
#ifdef __HIGHC__
pragma Code("DATABASENEWRECORDSUPPORT");
#endif
#ifdef __BORLANDC__
#pragma codeseg DATABASENEWRECORDSUPPORT
#endif
#ifdef __WATCOMC__
#pragma code_seg("DATABASENEWRECORDSUPPORT")
#endif

/***********************************************************************
 *
 * MESSAGE:	MSG_FFD_SET_TEMP_DATA_ROW_FOR_NEW_RECORD for
 *	    	FlatFileDatabaseClass
 *
 * DESCRIPTION:	This method loads up the TEMP_DATA_ROW's fields (well,
 *	    	the ones used by the current layout, anyway) with
 *	    	default computed values or blanks, as the case may be.
 *
 * PARAMETERS:
 *	void ()
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	5/21/92		Initial version
 *
 ***********************************************************************/
@method FlatFileDatabaseClass, MSG_FFD_SET_TEMP_DATA_ROW_FOR_NEW_RECORD
{
    FieldID 	    	i, actualColumn;
    word    	    	dataSize;
    FieldDataType   	dataType;
    FieldDataTypesFlags flags;
    byte    	    	expressionResultBuffer[EVAL_BUFFER_SIZE];
    MemHandle	    	textHandle;
    TextCellStruct	*textCell;
    CellConstant	numCell;
    MemHandle	    	formulaHandle;
    FormulaCellStruct	*formulaCell;
    CellEmpty	    	emptyCell;
    CellCommon	    	*cellStruct;

    /*
     * Allocate enough space for a beeeeg computed cell and a beeeeg text
     * object.
     */
    if ((formulaHandle = MemAlloc(sizeof(FormulaCellStruct), HF_SWAPABLE,
				   HAF_ZERO_INIT)) == 0) {
	/*
	 * No memory is left.  Bummer.  Notify the user & leave.
	 */
	DisplayUserError(@FFMemoryFullError);
	return;
    }
    if ((textHandle = MemAlloc(sizeof(TextCellStruct), HF_SWAPABLE,
				   HAF_ZERO_INIT)) == 0) {
	/*
	 * No memory is left.  Bummer.  Notify the user & leave.
	 */
	DisplayUserError(@FFMemoryFullError);
	return;
    }
    formulaCell = MemLock(formulaHandle);
    textCell = MemLock(textHandle);

    /*
     * Set common cell info.
     */
    numCell.CC_common.CC_recalcFlags = 0;
    emptyCell.CE_common.CC_recalcFlags = 0;
    textCell->cellTextStruct.CT_common.CC_recalcFlags = 0;

    numCell.CC_common.CC_attrs = 0;
    emptyCell.CE_common.CC_attrs = 0;
    textCell->cellTextStruct.CT_common.CC_attrs = 0;

    numCell.CC_common.CC_notes = 0;
    emptyCell.CE_common.CC_notes = 0;
    textCell->cellTextStruct.CT_common.CC_notes = 0;

    numCell.CC_common.CC_type = CT_CONSTANT;
    textCell->cellTextStruct.CT_common.CC_type = CT_TEXT;
    emptyCell.CE_common.CC_type = CT_EMPTY;

    /*
     * First clear out the temp data row.
     */
    for (i=0; i < pself->FFI_numInLayoutNameList; i++) {
	actualColumn = pself->FFI_layoutNameList[i];
	FFDClearCellToType(oself, actualColumn);
    }

    /*
     * Now load the cells with default or computed info.
     */
    for (i=0; i < pself->FFI_numInLayoutNameList; i++) {
	actualColumn = pself->FFI_layoutNameList[i];
	dataType = FFDGetDataTypeAndFlags(oself, actualColumn, &flags);

	/*
	 * If the field is computed or has a default expression,
	 * evaluate it.
	 */
	if ((dataType == FDT_COMPUTED) || (flags & FDTF_HAS_DEFAULT)) {
	    /*
	     * The cell has a default expression.  Evaluate the thing,
	     * and fill a result structure to fill the cell with.
	     */
	    if (!FFDEvaluateDefaultExpression(oself,
					      actualColumn,
					      expressionResultBuffer)) {
		/*
		 * Figure out what type the cell is, and replace away.
		 */
		cellStruct = FFDLoadEvaluationResults(oself, actualColumn,
						      expressionResultBuffer,
						      textCell, &numCell,
						      formulaCell, &emptyCell,
						      &dataSize);
		/*
		 * Set the cell.
		 */
		CellReplace(&pself->SSI_cellParams,
			    TEMP_DATA_ROW,
			    (word) actualColumn,
			    (void *) cellStruct,
			    dataSize);

		/*
		 * Mark the record dirty, since a value got placed into it.
		 */
		pself = ObjDerefGen(oself);
		pself->FFI_dirtyRecord = TRUE;
	    }
	}

	/*
	 * Now recalculate all of the fields dependent on this field.
	 */
	FFDRecalculateDependents(oself, actualColumn, NO_REDRAW);
	pself = ObjDerefGen(oself);
    }

    /*
     * Set the temp row not marked.
     */
    FFDSetRecordMarkStatus(pself, TEMP_DATA_ROW, FALSE);

    MemFree(formulaHandle);
    MemFree(textHandle);
}


/***********************************************************************
 *
 * FUNCTION:	FFDClearCellToType
 *
 * DESCRIPTION:	This function clears a cell in the TEMP_DATA_ROW to an
 *	    	empty version of its type.
 *
 * PARAMETERS:	oself - an optr to the current database
 *	    	colNum - the column of the cell to clear to type
 *
 * CALLED BY:	INTERNAL
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	7/29/92		Initial version
 *
 ***********************************************************************/
void
FFDClearCellToType(optr oself, FieldID colNum)
{
    FlatFileDatabaseInstance *pself;
    word    	    	dataSize = 0;
    FieldDataType   	dataType;
    struct {
	CellText	ct;
	TCHAR	    	eoln;
    } textCell = {{0, CT_TEXT, 0, 0, 0}, _TEXT('\0')};
 	    	      /* <- CellCommon */  /* _TEXT('\0')*/
    CellEmpty	    	emptyCell =
    	    	    	   {0, CT_EMPTY, 0, 0, 0};    /* <- CellCommon */
    MemHandle	    	fHandle = 0;
    CellFormula	    	*formulaCell;
    CellCommon	    	*cellStruct;

    dataType = FFDGetDataTypeAndFlags(oself, colNum, NULL);

    switch (dataType) {
	case FDT_GENERAL_TEXT:
	    cellStruct = (CellCommon *) &textCell;
	    dataSize = sizeof(CellText) + sizeof(TCHAR);
	    break;
	case FDT_INTEGER:
	case FDT_REAL:
	case FDT_TIME:
	case FDT_DATE:	    
	    /*
	     * Make this an empty cell, since any other value will come up
	     * as a zero.
	     */
	    cellStruct = (CellCommon *) &emptyCell;
	    dataSize = sizeof(CellEmpty);
	    break;
	case FDT_COMPUTED:	    
	    fHandle = MemAlloc(MAX_CELL_DATA_SIZE, HF_SWAPABLE, HAF_NO_ERR);
	    formulaCell = MemLock(fHandle);
	    cellStruct = (CellCommon *) formulaCell;
	    FFDLoadFormulaCell(oself, colNum, formulaCell);
	    dataSize = sizeof(CellFormula) + formulaCell->CF_formulaSize;
	    break;
	default :
	    EC_ERROR(BAD_FIELD_DATA_TYPE);
	    break;
    }

    FFDCopyCellDependencies(oself, colNum, cellStruct);

    pself = ObjDerefGen(oself);
    CellReplace(&pself->SSI_cellParams,
		TEMP_DATA_ROW,
		(word) colNum,
		(void *)cellStruct, dataSize);

    if (fHandle) {
	MemFree(fHandle);
    }
}

/***********************************************************************
 *
 * FUNCTION:	FFDLoadEvaluationResults
 *
 * DESCRIPTION:	This function puzzles through the results of an evaluated
 *	    	expression and loads up a cell structure with
 *	    	appropriate values.  A pointer to one of the passed
 *	    	cells is returned, along with the cell's total size.
 *
 *	    	The evaluation's result's type is encoded in the
 *	    	result byte stream.  If the type is a string, the
 *	    	TextCellStruct is loaded with appropriate info and its
 *	    	pointer is returned.  If the result type is a
 *	    	number, then the CellConstant struct is loaded up.
 *
 *	    	If the resulting type is a Boolean, the appropriate
 *	    	string value (True/False) is copied to the TextCellStruct,
 *	    	which is returned.  If it's a time result, the CellConstant is
 *	    	filled out.
 *
 *	    	If the thing evaluated to nothing, then the CellEmpty is
 *	    	filled out and returned.
 *	    	
 *	    	And now, when the field is a formula, its results are
 *	    	put in a CellFormula cell.
 *
 * PARAMETERS:	oself - an optr to the current database.
 *	    	field - the evaluated field's column.  Used for
 *	    	    	copying dependencies and determining field type.
 *	    	evalBuffer - pointer to the results from an evaluated
 *	    	    	     expression.
 *	    	textCell - pointer to a text cell structure.
 *	    	numCell - pointer to a numeric cell structure.
 *	    	formulaCell - pointer to a formula cell structure.  Make it
 *	    	    	      big.
 *	    	emptyCell - pointer to an empty cell structure.
 *	    	dataSize - pointer to a word to be loaded with the
 *	    	    	     size of the returned structure.
 *
 * CALLED BY:	INTERNAL
 *
 * STRATEGY:
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	5/27/92		Initial version
 *	jeremy	7/27/92	    	Added special case for computed fields
 *
 ***********************************************************************/
CellCommon *
FFDLoadEvaluationResults(optr oself,
    	    	    	 FieldID field,
    	    	    	 byte *evalBuffer,
			 TextCellStruct *textCell,
			 CellConstant *numCell,
			 FormulaCellStruct *formulaCell,
			 CellEmpty *emptyCell,
			 word *dataSize)
{
    EvalStackArgumentType valueType;
	 FieldDataType         fieldType;
	 ArgumentStackElement  *evalElement;
	 FloatNum	    	  dummyHackToBeNukedLater;
	 TCHAR    	    	  *text;
	 word    	    	  textLen;

	 /*
	  * If it's is a computed field, load up the formula cell.
	  */
	 fieldType = FFDGetDataTypeAndFlags(oself, field, NULL);
	 if (fieldType == FDT_COMPUTED) {
	FFDLoadFormulaFromEvaluationResults(oself, field, evalBuffer,
					    formulaCell, dataSize);
	return ((CellCommon *) formulaCell);
    }
    
    /*
     * The cell is not a formula.  Now assume that the cell will be empty.
     */
    *dataSize = sizeof(CellEmpty);
    FFDCopyCellDependencies(oself, field, (CellCommon *) emptyCell);

    /*
     * Now figure out what type the expression evaluated to...
     */
    evalElement = (ArgumentStackElement *)evalBuffer;
    valueType = evalElement->ASE_type;

    if (valueType & ESAT_EMPTY) {
	/*
	 * The expression evaluated to nothing.  Return with an empty cell.
	 * Drop the zero from the top of the FP stack.
	 */
	FloatPopNumber(&dummyHackToBeNukedLater);
	return ((CellCommon *) emptyCell);
    }

    /*
     * The results have a value!  Determine what kind of results, now.
     */
    if (valueType & ESAT_STRING) {
	/*
	 * It's a string!  Load up the text cell structure.
	 */
	textLen = evalElement->ASE_data.ESAD_string.ESD_length;
	/*
	 * point to the end of the structure where the string 
	 * is stored
	 */
	text = (TCHAR *) &evalElement[1];
	strncpy(textCell->string, text, textLen);
	textCell->string[textLen] = _TEXT('\0');
	textCell->cellTextStruct.CT_common.CC_type = CT_TEXT;
	textCell->cellTextStruct.CT_common.CC_recalcFlags = 0;
	textCell->cellTextStruct.CT_common.CC_attrs = 0;
	textCell->cellTextStruct.CT_common.CC_notes = 0;
	*dataSize = sizeof(CellText) + (textLen + 1)*sizeof(TCHAR);
	FFDCopyCellDependencies(oself, field, (CellCommon *) textCell);
	return (CellCommon *) textCell;
    }

    if (valueType & ESAT_NUMBER) {
	/*
	 * The results are a number, date, or time.  They all use
	 * the same cell structure...
	 */
	numCell->CC_common.CC_type = CT_CONSTANT;
	numCell->CC_common.CC_recalcFlags = 0;
	numCell->CC_common.CC_attrs = 0;
	numCell->CC_common.CC_notes = 0;
	if (FloatPopNumber(&(numCell->CC_current))) {
	    /* An error occurred.  Set the thing as a N/A. */
	    FLOAT_EXPONENT((&(numCell->CC_current))) = FP_NAN;
	}
	*dataSize = sizeof(CellConstant);
	FFDCopyCellDependencies(oself, field, (CellCommon *) numCell);
	return (CellCommon *) numCell;
    }

    if (valueType & ESAT_ERROR) {
	/*
	 * An error occurred.  Give an error message.
	 */
	textCell->cellTextStruct.CT_common.CC_type = CT_TEXT;
	textCell->cellTextStruct.CT_common.CC_recalcFlags = 0;
	textCell->cellTextStruct.CT_common.CC_attrs = 0;
	textCell->cellTextStruct.CT_common.CC_notes = 0;

	FFDSetEvalErrorText(evalElement->ASE_data.ESAD_error.EED_errorCode,
			    textCell->string);
	*dataSize = sizeof(CellText) + (strlen(textCell->string) + 1)
	  * sizeof(TCHAR);
	FFDCopyCellDependencies(oself, field, (CellCommon *) textCell);
	return (CellCommon *) textCell;
    }
 
    if (valueType & ESAT_RANGE) {
	/*
	 * How should we deal with these?
	EC_ERROR(BAD_EVAL_TYPE);
	 */
    }

    return ((CellCommon *) emptyCell);
}


/***********************************************************************
 *
 * FUNCTION:	FFDSetEvalErrorText
 *
 * DESCRIPTION:	This function loads a text buffer with an eval error code.
 *	    	Pass the code and a pointer to the buffer, and we'll
 *	    	do the rest.
 *
 * PARAMETERS:	word errNum - the parser/spreadsheet eval error number
 *	    	TCHAR    *text - a pointer to the buffer to fill
 *
 * CALLED BY:	INTERNAL
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	12/18/92	Initial version
 *
 ***********************************************************************/
void
FFDSetEvalErrorText(word errNum, TCHAR *text)
{
    optr errOptr;
    word i;
    
    *text = _TEXT('\0');
    for (i = 0;
	 i < (sizeof(FFDEvalErrorStrings) / sizeof(EvalErrorItem));
	 i++) {
	if (FFDEvalErrorStrings[i].error == errNum) {
	    errOptr = FFDEvalErrorStrings[i].errorChunk;
	    MemLock(OptrToHandle(errOptr));
	    strcpy(text, LMemDeref(errOptr));
	    MemUnlock(OptrToHandle(errOptr));
	    break;
	}
    }

    /*
     * If the error message was unknown, put out a general error.
     */
    if (*text == _TEXT('\0')) {
	MemLock(OptrToHandle(@FFFDUnknownError));
	sprintf(text, LMemDeref(@FFFDUnknownError), errNum);
	MemUnlock(OptrToHandle(@FFFDUnknownError));
    }		
}

/***********************************************************************
 *
 * FUNCTION:	FFDLoadFormulaFromEvaluationResults
 *
 * DESCRIPTION:	This function puzzles through the results of an evaluated
 *	    	expression and loads up a formula cell structure with
 *	    	appropriate values.   The cell's total size is returned in a
 *	    	passed pointer.
 *
 * PARAMETERS:	oself - an optr to the current database.
 *	    	field - the evaluated field's column.  Used for
 *	    	    	copying dependencies and determining field type.
 *	    	evalBuffer - pointer to the results from an evaluated
 *	    	    	     expression.
 *	    	formulaCell - pointer to a formula cell structure that has
 *	    	    	      some space for the results.
 *	    	dataSize - pointer to a word to be loaded with the
 *	    	    	     size of the returned structure.
 *
 * CALLED BY:	INTERNAL
 *
 * STRATEGY:
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	7/27/92	    	Initial version
 *
 ***********************************************************************/
void
FFDLoadFormulaFromEvaluationResults(optr oself,
    	    	    	 FieldID field,
    	    	    	 byte *evalBuffer,
			 FormulaCellStruct *formulaCell,
			 word *dataSize)
{
    EvalStackArgumentType valueType;
    ArgumentStackElement  *evalElement;
    FloatNum	    	  dummyHackToBeNukedLater;
    TCHAR    	    	  *text;
    word    	    	  textLen;

    /*
     * Copy the formula and its dependencies, and set the size that will be
     * correct for most cases...
     */
    FFDLoadFormulaCell(oself, field, (CellFormula *) formulaCell);
    *dataSize = sizeof(CellFormula) + formulaCell->cf.CF_formulaSize;
    
    /*
     * Now figure out what type the expression evaluated to...
     */
    evalElement = (ArgumentStackElement *)evalBuffer;
    valueType = evalElement->ASE_type;

    if (valueType & ESAT_EMPTY) {
	/*
	 * The expression evaluated to nothing.  Return as a text field
	 * with nothing in it.
	 * Drop the zero from the top of the FP stack.
	 */
	FloatPopNumber(&dummyHackToBeNukedLater);
	formulaCell->cf.CF_return = RT_TEXT;
	formulaCell->cf.CF_current.RV_TEXT = 0;
	return;
    }

    /*
     * The results have a value!  Determine what kind of results, now.
     */
    if (valueType & ESAT_STRING) {
	/*
	 * It's a string!  Load up the text cell structure.
	 */
	textLen = evalElement->ASE_data.ESAD_string.ESD_length;
	/*
	 * point at end of structure to where the string is stored
	 */
	text = (TCHAR *) &evalElement[1];
	formulaCell->cf.CF_return = RT_TEXT;
	formulaCell->cf.CF_current.RV_TEXT = textLen*sizeof(TCHAR);
	    /* cast to char to advance X bytes instead of X wchars in DBCS */
	strncpy( (char *)&formulaCell->cf + sizeof(CellFormula)
		+ formulaCell->cf.CF_formulaSize,
		text,
		textLen);
	*dataSize += (textLen + 1)*(sizeof(TCHAR));
	return;
    }

    if (valueType & ESAT_NUMBER) {
	/*
	 * The results are a number, date, or time.  They all use
	 * the same cell structure...
	 */
	formulaCell->cf.CF_return = RT_VALUE;
	if (FloatPopNumber(&(formulaCell->cf.CF_current.RV_VALUE))) {
	    /* An error occurred.  Set the thing as a N/A. */
	    FLOAT_EXPONENT((&(formulaCell->cf.CF_current.RV_VALUE))) = FP_NAN;
	}
	return;
    }

    if (valueType & ESAT_ERROR) {
	/*
	 * An error occurred.
	 */
	formulaCell->cf.CF_return = RT_ERROR;
	formulaCell->cf.CF_current.RV_ERROR =
	    evalElement->ASE_data.ESAD_error.EED_errorCode;
	return;
    }
 
    if (valueType & ESAT_RANGE) {
	/*
	 * How should we deal with these?
	EC_ERROR(BAD_EVAL_TYPE);
	 */
    }

    return;
}

/***********************************************************************
 *
 * FUNCTION:	FFDLoadFormulaCell
 *
 * DESCRIPTION:	This function loads up a formula cell with the correct
 *	    	formula and dependencies for a computed field (which should
 *	    	be at least MAX_CELL_DATA_SIZE in length).
 *
 * PARAMETERS:	oself - an optr to the current database
 *	    	colNum - the column of the computed field to copy
 *	    	dest - the CellFormula destination.  Make sure it's at
 *	    	       least MAX_CELL_DATA_SIZE.
 *
 * CALLED BY:	INTERNAL
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	7/27/92		Initial version
 *
 ***********************************************************************/
void
FFDLoadFormulaCell(optr oself, FieldID colNum, CellFormula *dest)
{
    FlatFileDatabaseInstance *pself;
    CellFormula *tsa;

    /*
     * First, copy the field's dependencies and set up other common
     * values.
     */
    FFDCopyCellDependencies(oself, colNum, (CellCommon *) dest);
    dest->CF_common.CC_attrs = 0;
    dest->CF_common.CC_notes = 0;
    dest->CF_common.CC_recalcFlags = 0;

    /*
     * Get the formula for this cell.
     */
    pself = ObjDerefGen(oself);
    tsa = CellLock(&pself->SSI_cellParams, FIELD_DEFAULT_VALUE_ROW, colNum);

    #if ERROR_CHECK
    	if (!tsa) {
	    EC_ERROR(CELL_DOES_NOT_EXIST);
	}
    #endif

    /*
     * If there is no formula, pretend we're empty.
     */
    dest->CF_common.CC_type = (tsa->CF_formulaSize ? CT_FORMULA : CT_EMPTY);

    dest->CF_formulaSize = tsa->CF_formulaSize;
    memcpy((char *) dest + sizeof(CellFormula),
	   (char *) tsa + sizeof (CellFormula),
	   tsa->CF_formulaSize);
    CellUnlock(tsa);
}

/***********************************************************************
 *
 * FUNCTION:	FFDLoadFormulaCellFromExistingCell
 *
 * DESCRIPTION:	This function loads up a formula cell with the correct
 *	    	formula, dependencies, current result type, and data
 *	    	from a source cell.
 *
 * PARAMETERS:	sourceRecord, sourceField - what you'd think.
 *	    	destField - the column of the TEMP_DATA_ROW to be replaced.
 *	    	oself - optr to the database this operation is affecting.
 *
 * CALLED BY:	INTERNAL
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	8/19/92		Initial version
 *
 ***********************************************************************/
void
FFDLoadFormulaCellFromExistingCell(optr oself, word sourceRecord,
				   FieldID sourceField, FieldID destField)
{
    word dataSize;
    TCHAR *text;
    word textLen;
    MemHandle tcbHandle;
    FormulaCellStruct *tempCellBuffer;
    CellCommon *sourceDataPtr;
    FlatFileDatabaseInstance *pself;

    /*
     * Create a temporary buffer in which to copy the formula
     * data.
     */
    tcbHandle = MemAlloc(MAX_CELL_DATA_SIZE, HF_SHARABLE | HF_SWAPABLE,
			      HAF_NO_ERR);
    tempCellBuffer = MemLock(tcbHandle);

    /*
     * Copy the formula and dependencies for a start.
     */
    FFDLoadFormulaCell(oself, destField, &(tempCellBuffer->cf));
    dataSize = sizeof(CellFormula) + tempCellBuffer->cf.CF_formulaSize;
    
    /*
     * If the cell is empty, then we're done.
     */
    pself = ObjDerefGen(oself);
    if (tempCellBuffer->cf.CF_common.CC_type == CT_EMPTY) {
	/*
	 * It's empty, all right.  Replace the destination cell.
	 */
	CellReplace(&pself->SSI_cellParams,
		    TEMP_DATA_ROW,
		    (word) destField,
		    tempCellBuffer, dataSize);
	MemFree(tcbHandle);
	return;
    }

    /*
     * There's a formula there.  Set the return type and following data
     * from the source cell.
     */
    sourceDataPtr = CellLock(&pself->SSI_cellParams,
			     sourceRecord,
			     sourceField);
     
    if (!sourceDataPtr) {
	/*
	 * No source data.  Set the formula as having no data.
	 */
	tempCellBuffer->cf.CF_return = RT_TEXT;
	tempCellBuffer->cf.CF_current.RV_TEXT = 0;
    } else {
	/*
	 * The results have a value!  Determine what kind of results, now.
	 */
	switch (sourceDataPtr->CC_type) {
	    case CT_TEXT:
		/*
		 * It's a string!  Load up the text cell structure.
		 */
		text = (char *) sourceDataPtr + sizeof(CellText);
		textLen = strlen(text);
		strncpy((char *) &tempCellBuffer->cf + sizeof(CellFormula) +
			         tempCellBuffer->cf.CF_formulaSize,	
			text,
			textLen);
		tempCellBuffer->cf.CF_return = RT_TEXT;
		tempCellBuffer->cf.CF_current.RV_TEXT = textLen*sizeof(TCHAR);
		dataSize += (textLen + 1)*sizeof(TCHAR);
		break;

	    case CT_CONSTANT:
		/*
		 * The results are a number, date, or time.  They all use
		 * the same cell structure...
		 */
		tempCellBuffer->cf.CF_return = RT_VALUE;
		tempCellBuffer->cf.CF_current.RV_VALUE =
		    ((CellConstant *) sourceDataPtr)->CC_current;
		break;

	    default:
		EC_ERROR(BAD_FIELD_DATA_TYPE);
	}

	CellUnlock(sourceDataPtr);
    }

    pself = ObjDerefGen(oself);
    CellReplace(&pself->SSI_cellParams,
		TEMP_DATA_ROW,
		destField,
		tempCellBuffer,
		dataSize);

    MemFree(tcbHandle);
}

/********* End of DatabaseNewRecordSupport resource *********/

/********* Beginning of DatabaseFile resource *********/
#ifdef __HIGHC__
pragma Code ("DATABASEFILE");
#endif
#ifdef __BORLANDC__
#pragma codeseg DATABASEFILE
#endif
#ifdef __WATCOMC__
#pragma code_seg("DATABASEFILE")
#endif


/***********************************************************************
 *
 * FUNCTION:	FlatFileInitFile 
 *
 * CALLED BY:	External
 *
 * DESCRIPTION:	Routine for initializing a flatfile file.
 *
 * PARAMETERS:
 *	pass:    vmFileHandle -- VM file handle of the data file
 *		 spreadsheetFlags - draw flags
 *	returns: VMBlockHandle  -- VM handle of flatfile header block
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	anna	6/15/92		Initial version
 *
 ***********************************************************************/
VMBlockHandle _pascal FLATFILEINITFILE(FileHandle vmFileHandle,
			       					   word spreadsheetFlags)
{
    SpreadsheetInitFileData ifd;
    VMBlockHandle spreadsheetHeaderBlock;

    /*
     * SpreadsheetInitFile sets up the mystery row block structure and
     * the data cache; uses fixed ruler options and draw flags for now
     */
    ifd.SIFD_file = vmFileHandle;
    ifd.SIFD_numRows = TEMP_DATA_ROW;
    ifd.SIFD_numCols = MAX_NUM_FIELDS;
    ifd.SIFD_drawFlags = spreadsheetFlags;

    spreadsheetHeaderBlock = SpreadsheetInitFile(&ifd);

    return(spreadsheetHeaderBlock);
}

/***********************************************************************
 *
 * MESSAGE:	MSG_FFD_INIT_CELL_PARAMS for FlatFileDatabaseClass
 *
 * DESCRIPTION:	This function serves to set the document handle in
 *		the Spreadsheet's CellParams structure.
 *		This is because we need to access the CellParams
 *		structure while initializing a file, but this
 *		documentHandle isn't set in the spreadsheet until
 *		MSG_SPREADSHEET_ATTACH_UI. So this is hopefully
 *		a temporary beast.
 *
 *	    	New and unpleasant feature: we need to keep a VMBlock
 *	    	handle around for the float format controller.  Bleah.
 *
 * PARAMETERS:
 *	void (FileHandle documentHandle, VMBlockHandle floatControllerVMBlock)
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	anna	9/29/92		Initial version
 *	jeremy	11/20/92    	Added float format controller arg.
 *
 ***********************************************************************/
@method FlatFileDatabaseClass, MSG_FFD_INIT_CELL_PARAMS
{
    pself->SSI_cellParams.CFP_file = documentHandle;
    pself->FFI_floatControlBlock = floatControllerVMBlock;
    ObjMarkDirty(oself);
}

/***********************************************************************
 *
 * MESSAGE:	MSG_FFD_NOTIFY_MAP_CONTROL for FlatFileDatabaseClass
 *
 * DESCRIPTION:	Sends a notification data block to map controller.
 *
 * PARAMETERS:
 *	void ()
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	ted	10/29/92	Initial version
 *
 ***********************************************************************/
@method FlatFileDatabaseClass, MSG_FFD_NOTIFY_MAP_CONTROL
{
    /* send a notification to map controller */
    CreateDataBlockAndSendNotification(oself);
}

/***********************************************************************
 *
 * MESSAGE:	MSG_FFD_FLUSH_MAP_CONTROL for FlatFileDatabaseClass
 *
 * DESCRIPTION:	Sends no data block to map controller.
 *
 * PARAMETERS:
 *	void ()
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	ted	11/16/92	Initial version
 *
 ***********************************************************************/
@method FlatFileDatabaseClass, MSG_FFD_FLUSH_MAP_CONTROL
{
    /* send a notification to map controller */
    FlushMapControl(oself);
}

/***********************************************************************
 *
 * MESSAGE:	MSG_FFD_ATTACH_FILE for FlatFileDatabaseClass
 *
 * DESCRIPTION:	Attach a (new) file to the flatfile
 *
 * PARAMETERS:
 *	void (VMBlockHandle ssMapBlock, VMFileHandle fileHandle)
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	anna	6/15/92		Initial version
 *
 ***********************************************************************/
@method FlatFileDatabaseClass, MSG_FFD_ATTACH_FILE
{
    @call self::MSG_SPREADSHEET_ATTACH_FILE(ssMapBlock, fileHandle);
}

/***********************************************************************
 *
 * MESSAGE:	MSG_FFD_ATTACH_UI for FlatFileDatabaseClass
 *
 * DESCRIPTION:	Attach UI file to the flatfile
 *
 * PARAMETERS:
 *	void (MemHandle setupData, FileHandle fileHandle)
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	anna	6/30/92		Initial version
 *
 ***********************************************************************/
@method FlatFileDatabaseClass, MSG_FFD_ATTACH_UI
{
    @call self::MSG_SPREADSHEET_ATTACH_UI(setupData, fileHandle);

}

/***********************************************************************
 *
 * MESSAGE:	MSG_FFD_SET_CUR_COL for FlatFileDatabaseClass
 *
 * DESCRIPTION:	Changes the current column (in the instance data).
 *
 * PARAMETERS:
 *	void (byte colNumber)
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	anna	4/16/92		Initial version
 *
 ***********************************************************************/
@method FlatFileDatabaseClass, MSG_FFD_SET_CUR_COL
{
    pself->SSI_active.CR_column = (word) colNumber;
    ObjMarkDirty(oself);
}


/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		MSG_FFD_FIELD_ORGANIZER_ENABLE_DISABLE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

DESCRIPTION:	Enable/Disable the given Field Organizer based on the
		current layout mode.

PASS: 		optr	fieldOrganizer		= Field Organizer to modify.
		VisUpdateMode	updateMode	= Manner in which to update
						  the Field Organizer.
RETURN:		Void.

SIDE EFFECTS:
	Requires:	???

	Asserts:	???

CHECKS:			None.

PSEUDO CODE/STRATEGY:
	Get the current layout type mode.
	If in Single Record mode then
		Enable the given Field Organizer.
	Otherwise,
		Disable the given Field Organizer.

KNOWN DEFECTS/CAVEATS/IDEAS:	???

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	JDM	92.12.17	Initial version.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/

@method FlatFileDatabaseClass, MSG_FFD_FIELD_ORGANIZER_ENABLE_DISABLE
{
    LayoutType	layoutType;

    /*
     * Get the current layout type.
     * Default to single record mode iff no current layout specified.
     */
    layoutType = @call self::MSG_FFD_GET_LAYOUT_TYPE (0, TRUE);
    if ((LT_NO_LAYOUT_TYPE == layoutType) ||
        (LT_SINGLE_RECORD == layoutType))
	{
	/* Enable the Field Organizer in Single Record mode.	*/
	@send fieldOrganizer::MSG_GEN_SET_ENABLED (updateMode);
	}
    else	/* Assume Multi-Record mode.	*/
	{
	/* Disable the Field Organizer in Multi-Record mode.	*/
	@send fieldOrganizer::MSG_GEN_SET_NOT_ENABLED (updateMode);
	}
}	/* End of MSG_FFD_FIELD_ORGANIZER_ENABLE_DISABLE.	*/


/***********************************************************************
 *
 * MESSAGE:	MSG_FFD_DATA_RECALCULATE for FlatFileDatabaseClass
 *
 * DESCRIPTION:	recalculates all computed fields
 *
 * PARAMETERS:		none
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jfh	3/10/04	Initial version
 *
 ***********************************************************************/
@method FlatFileDatabaseClass, MSG_FFD_DATA_RECALCULATE
{
 word					numRecs, numFields, curRec, i, j, numCompFields = 0;
 byte					compField[MAX_NUM_FIELDS];


	numRecs = pself->FFI_totalNumRecordsInDatabase;
	if (!numRecs) return;
	numFields = pself->FFI_numFields;
	if (numFields <= 1) return;
	curRec = pself->SSI_active.CR_row;

	for (i = 0; i < MAX_NUM_FIELDS; i++) {
		compField[i] = 0;
		}

	/* make sure we have 1 or more computed fields */
	for (i = 0; i < numFields; i++) {
		if (FFDGetDataTypeAndFlags(oself, i, NULL) == FDT_COMPUTED) {
			compField[numCompFields] = i;
			numCompFields++;
			}
		}

	if (!numCompFields) return;

	@call GeodeGetAppObject(0)::MSG_GEN_APPLICATION_MARK_BUSY();

	/* OK - we know we have something to recalc.  Go thru the records, and
		do any recalcs */
	for (i = 0; i < numRecs; i++) {
      /* make each computed field recalc */
		for (j = 0; j < numCompFields; j++) {
			@call oself::MSG_FFD_LOAD_TEMP_ROW_FROM_ANOTHER_ROW(i);
			FFDEvalComputedField(oself, compField[j]);
			if (i == curRec) {
				/* force the computed field to redraw */
				FFDUpdateExprRedraw(oself, TEMP_DATA_ROW, compField[j]);
				}
			@call oself::MSG_FFD_STORE_TEMP_ROW_INTO_ANOTHER_ROW(i);
			}
		}

	@call GeodeGetAppObject(0)::MSG_GEN_APPLICATION_MARK_NOT_BUSY();

	ObjMarkDirty(oself);


}

/********* End of DatabaseFile resource *********/

