/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	Copyright (c) GeoWorks 1992 -- All Rights Reserved

PROJECT:        GEOS
MODULE:         FlatFile/Database
FILE:           ffDatabaseSubset.goc

AUTHOR:         John D. Mitchell

METHODS:

Name                    Description
----                    -----------

FUNCTIONS:

Scope   Name                    Description
-----   ----                    -----------

REVISION HISTORY:
	Name    Date            Description
	----    ----            -----------
	JDM     92.08.18        Initial version.
	JDM     93.01.10        Big implementation.

DESCRIPTION:
	This file contains the FlatFile Database Library's Subset
	implemenation. 

	$Id: ffDatabaseSubset.goc,v 1.1 97/04/04 18:03:00 newdeal Exp $

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/


/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		Code Resource
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/

#ifdef __HIGHC__
pragma Code ("DATABASESUBSET");
#endif
#ifdef __BORLANDC__
#pragma codeseg DATABASESET
#endif
#ifdef __WATCOMC__
#pragma code_seg("DATABASESET")
#endif


/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		Include Files
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/

@include <stdapp.goh>                   /* PC/GEOS.     */
#include <cell.h>
#include <geoworks.h>
#include <math.h>
#include <parse.h>
@include <ssheet.goh>
#include <system.h>

#include <Ansi/stdio.h>
#include <Ansi/string.h>
#include <Ansi/ctype.h>

@include <ffile.goh>                    /* FlatFile.    */
@include <Objects/FlatFile/ffileC.goh>
#include <ffFatal.h>
#include <Database/ffdExtrn.h>


/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		External Object Declarations
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/

@extern chunk @FFNoMarkedRecordsString;
@extern chunk @FFNoMarkedRecordsToDeleteString;
@extern chunk @FFReallyDeleteAllMarkedRecords;

/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		Internal Function Prototypes
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/

static int FFDMarkRecordsViaExpression (optr oself,
					byte *tokenStream,
					word numRecords,
					Boolean clearMarksFirst);

SubsetEvalResult FFDSubsetTestExpression (optr oself,
					  byte *tokenStream,
					  word recordNum);

Boolean FFDSubsetShowOnlyMarkedRecords(optr oself);

Boolean FFDGetRecordMarkStatus (FlatFileDatabaseInstance *pself,
				word recordIndex);

void FFDSetRecordMarkStatus (FlatFileDatabaseInstance *pself,
			     word recordNum,
			     Boolean mark);

void FFDModifySubsetMarks(FlatFileDatabaseInstance *pself,
			  SubsetMarkModification markFlag,
			  RangeEnumFlags ref,
			  byte matchFlags);

word FFDGetNumberOfMarkedRecords(optr oself);

word FFDGetFirstMarkedRecord(optr oself);

word FFDGetNextMarkedRecord (optr oself, word curRecord);

word FFDGetPreviousMarkedRecord (optr oself, word curRecord);

RANGE_ENUM_CALLBACK_RETURN_TYPE _pascal
	FFDGetNextMarkedCallback (RangeEnumCallbackParams recp);

RANGE_ENUM_CALLBACK_RETURN_TYPE _pascal
	FFDGetPreviousMarkedCallback (RangeEnumCallbackParams recp);

RANGE_ENUM_CALLBACK_RETURN_TYPE _pascal
	FFDMarkModificationCallback(RangeEnumCallbackParams recp);

RANGE_ENUM_CALLBACK_RETURN_TYPE _pascal
	FFDGetNthMarkedCallback(RangeEnumCallbackParams recp);

RANGE_ENUM_CALLBACK_RETURN_TYPE _pascal
	FFDDetermineMarkedPositionCallback(RangeEnumCallbackParams recp);

RANGE_ENUM_CALLBACK_RETURN_TYPE _pascal
	FFDGetNumberOfMarkedCallback(RangeEnumCallbackParams recp);


/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		Internal Structure Declarations
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/

typedef struct {
    word    MPOS_record;
    word    MPOS_position;
} MarkedPositionStruct;



/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		Message Handlers
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/

/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		MSG_FFD_SUBSET_APPLY
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

DESCRIPTION:    Create a marked subset in the database using the given
		tokenized expression as the acceptance test.

PASS:           MemHandle       tokenStreamHandle
					= Handle to the candidate record
					  marking expression's token stream.
		word    numTokens       = Number of tokens in the given
					  token stream.

RETURN:         Boolean = TRUE iff the given record marking expression was
			  successfully applied to the database.
			  FALSE otherwise (see caveat below).

SIDE EFFECTS:
	Requires:
		FFI_clearMarksFirst != FALSE specifies that any and all
		preexisting marks should be (logically) cleared prior to
		applying the given record marking expression.

	Asserts:
		FFI_VAR_SUBSET_TOKEN_STREAM vardata contains a copy of the
		given record marking token stream.

		FFI_numMarkedRecords will be set as appropriate.

		The given token stream block will be freed after the stream
		has been internalized [see below -- JDM].

		If given a valid record marking expression then all records
		in the current database, which an application of the given
		record marking expression returns non-FALSE, is marked.
		Otherwise if FFI_clearMarksFirst then all of the non-marked
		records' record marks are cleared. Otherwise, the
		non-marked records' record marks are left untouched.

CHECKS:         None.

PSEUDO CODE/STRATEGY:   ???

KNOWN DEFECTS/CAVEATS/IDEAS:
	Note that if FALSE is returned then the current record marking
	informaiton is indeterminate. [Jeremy, this is probably a Bad
	Thing.  Can't we handle this more gracefully?  --JDM]

	Note that the routine MemFree's the given tokenStreamHandle after
	is has copied the data over.  There are no easy to define semantics
	for this case at this point as there is no way for the caller to
	know whether or not they need to free the token stream block.

REVISION HISTORY:
	Name    Date            Description
	----    ----            -----------
	JDM     92.08.18        Initial version.
	jdashe  1/6/93          Made changes for the new version.
	JDM     93.01.11        Big merge.  Updated documenation.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/

@extern method FlatFileDatabaseClass, MSG_FFD_SUBSET_APPLY
{
    word        numRecords;
    int         numMarkedRecords;
    byte        *newTokenStream;
    byte        *tokenStream;
    CellReference       oldCurrentCell;

    /*
     * Save the expression in vardata.
     */
    tokenStream = MemLock(tokenStreamHandle);
    if (!tokenStream) {
	return FALSE;
    }

    /*
     * If there's nothing there but an end-of-expression marker, signal
     * an illegal expression, and clear out whatever expression used to
     * be there.
     */
    if (*tokenStream == PARSER_TOKEN_END_OF_EXPRESSION) {
	(void) ObjVarDeleteData(oself, FFI_VAR_SUBSET_TOKEN_STREAM);
	return FALSE;
    }

    newTokenStream = (byte *) ObjVarAddData(oself,
					    FFI_VAR_SUBSET_TOKEN_STREAM,
					    numTokens);
    memcpy(newTokenStream, tokenStream, numTokens);
    
    /*
     * Are any fields defined yet?
     */
    pself = ObjDerefGen (oself);
    if (! FFDGetFieldColumnExtents(pself, NULL, NULL)) {
	/* No fields to apply against.  */
	MemFree (tokenStreamHandle);
	return TRUE;
    }

    /*
     * Any records to work on?
     */
    numRecords = pself->FFI_totalNumRecordsInDatabase;
    if (!numRecords) {
	/* Nope.  Bail. */
	MemFree(tokenStreamHandle);
	return TRUE;
    }

    /*
     * Save the database's current row.
     */
    oldCurrentCell = pself->SSI_active;

    /*
     * Iterate through all of the records in the database and test them
     * against the user specified expression for acceptance into the
     * subset.
     */
    numMarkedRecords = FFDMarkRecordsViaExpression(oself,
						   tokenStream,
						   numRecords,
						   pself->FFI_clearMarksFirst);
    MemFree(tokenStreamHandle);

    /* Restore the currently selected record.   */
    pself = ObjDerefGen(oself);
    pself->SSI_active = oldCurrentCell;

    /*
     * If there was a problem, return with an error flag.
     */
    if (numMarkedRecords == -1) {
	return FALSE;
    }

    /*
     * Set the number of marked records in the instance data, and
     * return a success flag.
     */
    pself->FFI_numMarkedRecords = numMarkedRecords;
    return TRUE;
}


/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		MSG_FFD_GET_FIRST_MAKRED_RECORD
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

DESCRIPTION:    Figure out the first marked record in the database.

PASS:           Void.

RETURN:         word    = NOT_A_RECORD iff unable to find a marked record.
			  Otherwise, the index of the first marked record.

SIDE EFFECTS:
	Requires:       ???

	Asserts:        ???

CHECKS:         None.

PSEUDO CODE/STRATEGY:   ???

KNOWN DEFECTS/CAVEATS/IDEAS:    ???

REVISION HISTORY:
	Name    Date            Description
	----    ----            -----------
	jeremy  1/ 9/93         Initial version

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/

@extern method FlatFileDatabaseClass, MSG_FFD_GET_FIRST_MARKED_RECORD
{
    return FFDGetFirstMarkedRecord(oself);
}


/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		MSG_FFD_GET_SUBSET_TOKEN_STREAM
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

DESCRIPTION:    Retrieve a 

PASS:           Void.

RETURN:         MemHandle       = Block handle of the tokenized record
				  marking expression stream.

SIDE EFFECTS:
	Requires:       ???

	Asserts:        ???

CHECKS:                 ???

PSEUDO CODE/STRATEGY:   ???

KNOWN DEFECTS/CAVEATS/IDEAS:    ???

REVISION HISTORY:
	Name    Date            Description
	----    ----            -----------
	jeremy  1/ 8/93         Initial version.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/

@extern method FlatFileDatabaseClass, MSG_FFD_GET_SUBSET_TOKEN_STREAM
{
    MemHandle   tokenStreamHandle;
    byte        *tokenStream;
    byte        *newTokenStream;

    /* Get a grip on the expresion token stream handle. */
    tokenStreamHandle = NullHandle;
    if (0 != (tokenStream = ObjVarFindData (oself,
					    FFI_VAR_SUBSET_TOKEN_STREAM)))
	{
	/*
	 * There is an existing token stream.  Copy it.
	 */
	tokenStreamHandle = MemAlloc (VarDataSizePtr (tokenStream),
				      HF_DYNAMIC | HF_SHARABLE,
				      HAF_STANDARD);
	if (tokenStreamHandle)
	    {
	    /*
	     * Lock down the block and copy the token stream into it.
	     */
	    newTokenStream = MemLock (tokenStreamHandle);
	    memcpy (newTokenStream,
		    tokenStream,
		    VarDataSizePtr (tokenStream));

	    /*
	     * Unlock the block and return its handle.
	     */
	    MemUnlock (tokenStreamHandle);
	    }
	}

    return tokenStreamHandle;
}       /* End of MSG_FFD_GET_SUBSET_TOKEN_STREAM.      */

/***********************************************************************
 *
 * MESSAGE:     MSG_FFD_SUBSET_MARK_ALL for FlatFileDatabaseClass
 *
 * DESCRIPTION: This message marks all records in the database.
 *
 * PARAMETERS:
 *      void ()
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      jeremy  1/11/93         Initial version
 *
 ***********************************************************************/
@extern method FlatFileDatabaseClass, MSG_FFD_SUBSET_MARK_ALL
{
    FFDModifySubsetMarks(pself,
			 SMM_SET_MARK_FLAG,
			 REF_MATCH_ROW_FLAGS | REF_ROW_FLAGS,
			 UNMARKED_RECORD);

    pself = ObjDerefGen(oself);
    pself->FFI_numMarkedRecords = pself->FFI_totalNumRecordsInDatabase;
    if (pself->FFI_showOnlyMarked) {
	pself->FFI_numRecords = pself->FFI_numMarkedRecords;
    }

    /*
     * Mark the temp data row, too.
     */
    FFDSetRecordMarkStatus(pself, TEMP_DATA_ROW, TRUE);

    /*
     * Update the RCP.
     */
    (void) @call self::MSG_FFD_RECORD_CONTROL(FFRCR_REFRESH, 0);
}    

/***********************************************************************
 *
 * MESSAGE:     MSG_FFD_SUBSET_UNMARK_ALL for FlatFileDatabaseClass
 *
 * DESCRIPTION: This method clears the mark flag for every record in the
 *              database, then updates the RCP.
 *
 *              Note: if we're currently in SHOW_ONLY_MARKED mode,
 *              we immediately get shunted to SHOW_ALL mode.
 *
 * PARAMETERS:
 *      void ()
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      jeremy  1/11/93         Initial version
 *
 ***********************************************************************/
@extern method FlatFileDatabaseClass, MSG_FFD_SUBSET_UNMARK_ALL
{
    Boolean showOnlyMarked = pself->FFI_showOnlyMarked;
    
    FFDModifySubsetMarks(pself,
			 SMM_UNSET_MARK_FLAG,
			 REF_MATCH_ROW_FLAGS | REF_ROW_FLAGS,
			 MARKED_RECORD);

    /*
     * Unmark the temp data row, too.
     */
    pself = ObjDerefGen(oself);
    pself->FFI_numMarkedRecords = 0;
    FFDSetRecordMarkStatus(pself, TEMP_DATA_ROW, FALSE);

    /*
     * If we're in SHOW_ONLY_MARKED mode, reset to SHOW_ALL.
     */
    if (showOnlyMarked) {
	pself->FFI_numRecords = 0;
	@call oself::MSG_FFD_SUBSET_SHOW_ALL_RECORDS();
    } else {
	/*
	 * Update the RCP.
	 */
	(void) @call self::MSG_FFD_RECORD_CONTROL(FFRCR_REFRESH, 0);
    }
}
    

/***********************************************************************
 *
 * MESSAGE:     MSG_FFD_SUBSET_INVERT_MARKS for FlatFileDatabaseClass
 *
 * DESCRIPTION: This method inverts the mark flag for every record
 *              in the database, then updates the RCP.
 *
 *              If we're in SHOW_ONLY_MARKED mode and there are no
 *              marked records left, we'll switch to SHOW_ALL.
 *
 * PARAMETERS:
 *      void ()
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      jeremy  1/11/93         Initial version
 *
 ***********************************************************************/
@extern method FlatFileDatabaseClass, MSG_FFD_SUBSET_INVERT_MARKS
{
    word numMarkedRecords;
    word curRow;
    word newMarkedRecord;
    EventHandle event;
    
    FFDModifySubsetMarks(pself,
			 SMM_INVERT_MARK_FLAG,
			 REF_ALL_CELLS | REF_ROW_FLAGS,
			 0);
    /*
     * Invert the temp data row, too.
     */
    pself = ObjDerefGen(oself);
    FFDSetRecordMarkStatus(pself,
			   TEMP_DATA_ROW,
			   !FFDGetRecordMarkStatus(pself, TEMP_DATA_ROW));

    /*
     * Reset the number of marked records.
     */
    numMarkedRecords = FFDGetNumberOfMarkedRecords(oself);
    pself = ObjDerefGen(oself);
    pself->FFI_numMarkedRecords = numMarkedRecords;

    /*
     * If we're in SHOW_ONLY_MARKED mode, make sure we have records to
     * show.
     */
    if (pself->FFI_showOnlyMarked) {
	if (numMarkedRecords == 0) {
	    /*
	     * Jump to SHOW_ALL mode.  If we call the SHOW_ONLY_MARKED
	     * routine, it'll put up a warning message that there are no
	     * marked records and jump to SHOW_ALL.
	     */
	    @call oself::MSG_FFD_SUBSET_SHOW_ONLY_MARKED_RECORDS();
	} else {
	    /*
	     * There are some marked records left.  We know that the current
	     * record isn't marked anymore, so find the closest one.
	     */
	    pself->FFI_numRecords = numMarkedRecords;

	    curRow = pself->SSI_active.CR_row;
	    newMarkedRecord = FFDGetNextMarkedRecord(oself, curRow);

	    if (newMarkedRecord == NOT_A_RECORD) {
		/*
		 * Ok, look up, then.
		 */
		newMarkedRecord = FFDGetPreviousMarkedRecord(oself, curRow);
						     
		#if ERROR_CHECK
		    if (newMarkedRecord == NOT_A_RECORD) {
			EC_ERROR(UH_OH_NOT_A_RECORD);
		    }
		#endif /* ERROR_CHECK */
	    }

	    /*
	     * We've found our new current marked record.  Jump to it.
	     */
	    pself = ObjDerefGen(oself);
	    pself->FFI_currentMarkedRecord =
		FFDDetermineMarkedPosition(oself, newMarkedRecord) - 1;

	    @call oself::MSG_FFD_RECORD_CONTROL(FFRCR_GOTO_RECORD,
						pself->FFI_currentMarkedRecord);
	    /*
	     * If we are displaying multiple records, we'll want to
	     * redraw the screen
	     */
	    pself = ObjDerefGen(oself);
	    if (pself->FFI_currentLayoutType == LT_MULTI_RECORD) {
		/*
		 * Force the View to redraw
		 */
		event = @record GenViewClass::MSG_GEN_VIEW_REDRAW_CONTENT();

		@send oself::MSG_VIS_VUP_CALL_OBJECT_OF_CLASS(event);
	    }
	}
    } else /* (not in SHOW_ONLY_MARKED mode.) */ {
	/*
	 * Just update the RCP.
	 */
	@call oself::MSG_FFD_RECORD_CONTROL(FFRCR_REFRESH, 0);
    }
}

/***********************************************************************
 *
 * FUNCTION:    FFDModifySubsetMarks
 *
 * DESCRIPTION: This function calls RangeEnum to modify marked records.
 *
 * PARAMETERS:  pself - a pointer to the current database
 *              markFlag - what action you'd like to be done to the
 *                         records.
 *              matchFlags - column flags (if any) to match.
 *              ref - RangeEnumFlags for the call.
 *
 * CALLED BY:   INTERNAL
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      jeremy  1/11/93         Initial version
 *
 ***********************************************************************/
void
FFDModifySubsetMarks(FlatFileDatabaseInstance *pself,
		     SubsetMarkModification markFlag,
		     RangeEnumFlags ref,
		     byte matchFlags)
{
    CRangeEnumParams crep;

    /*
     * If there are no records to mark, then we're done.
     */
    if (pself->FFI_totalNumRecordsInDatabase == 0) {
	return;
    }

    crep.CREP_params.REP_callback           = FFDMarkModificationCallback;
    crep.CREP_params.REP_bounds.R_left      = 0;
    crep.CREP_params.REP_bounds.R_right     = 0;
    crep.CREP_params.REP_bounds.R_top       = 0;
    crep.CREP_params.REP_bounds.R_bottom    =
				    pself->FFI_totalNumRecordsInDatabase - 1;
    crep.CREP_params.REP_locals             = &markFlag;
    crep.CREP_params.REP_matchFlags         = matchFlags;

    @call GeodeGetAppObject(0)::MSG_GEN_APPLICATION_MARK_BUSY();
    (void) RangeEnum(&pself->SSI_cellParams, &crep, ref);
    @call GeodeGetAppObject(0)::MSG_GEN_APPLICATION_MARK_NOT_BUSY();
}


/***********************************************************************
 *
 * FUNCTION:    FFDGetNumberOfMarkedRecords
 *
 * DESCRIPTION: This function returns how many records are marked in the
 *              database.
 *
 * PARAMETERS:  oself - an optr to the current database.
 *
 * CALLED BY:   INTERNAL
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      jeremy  1/15/93         Initial version
 *
 ***********************************************************************/
word
FFDGetNumberOfMarkedRecords(optr oself)
{
    CRangeEnumParams crep;
    FlatFileDatabaseInstance *pself = ObjDerefGen(oself);
    word markedRecords = 0;

    /*
     * If there are no records to check, then return 0.
     */
    if (pself->FFI_totalNumRecordsInDatabase == 0) {
	return 0;
    }

    crep.CREP_params.REP_callback           = FFDGetNumberOfMarkedCallback;
    crep.CREP_params.REP_bounds.R_left      = 0;
    crep.CREP_params.REP_bounds.R_right     = 0;
    crep.CREP_params.REP_bounds.R_top       = 0;
    crep.CREP_params.REP_bounds.R_bottom    =
				    pself->FFI_totalNumRecordsInDatabase - 1;
    crep.CREP_params.REP_locals             = &markedRecords;
    crep.CREP_params.REP_matchFlags         = MARKED_RECORD;

    @call GeodeGetAppObject(0)::MSG_GEN_APPLICATION_MARK_BUSY();
    (void) RangeEnum(&pself->SSI_cellParams, &crep, REF_MATCH_ROW_FLAGS);
    @call GeodeGetAppObject(0)::MSG_GEN_APPLICATION_MARK_NOT_BUSY();

    return markedRecords;
}

/***********************************************************************
 *
 * MESSAGE:     MSG_FFD_SUBSET_DELETE_MARKED_RECORDS for FlatFileDatabaseClass
 *
 * DESCRIPTION: This message deletes any/all marked records in the
 *              database.  It will then jump to the first remaining
 *              record in the database, or a new one if all were
 *              deleted.
 *
 * PARAMETERS:
 *      void ()
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      jeremy  1/11/93         Initial version
 *
 ***********************************************************************/
@extern method FlatFileDatabaseClass, MSG_FFD_SUBSET_DELETE_MARKED_RECORDS
{
    int numMarkedRecords;
	 int i, numRecs, numDels = 0;
    word curRecord;
    SpreadsheetFlags oldFlags;
	 SpreadsheetRecalcParams recalcParams;
	 TCHAR	numStr[13];
	 optr primary, dbox, counter;

    /*
     * If we've been editing a record, commit the thing.
     */
    @call oself::MSG_FFD_RECORD_CONTROL(FFRCR_COMMIT_CURRENT_RECORD, 0);

	 numMarkedRecords = FFDGetNumberOfMarkedRecords(oself);
    if (!numMarkedRecords) {
	/*
	 * Nothing to delete.
	 */
	MemLock (OptrToHandle (@FFNoMarkedRecordsToDeleteString));
	UserStandardDialog
		((TCHAR *)0,
		 /* not GIT_MULTIPLE_RESPONSE, so no custom triggers  */
		 (TCHAR *)0,
		 /* No string arguments. */
		 (TCHAR *)0, (TCHAR *)0,
		 /* dialog string */
		 LMemDeref (@FFNoMarkedRecordsToDeleteString),
		 /* dialog type */
		 (CDT_WARNING << CDBF_DIALOG_TYPE_OFFSET) |
		 /* interaction type */
		 (GIT_NOTIFICATION << CDBF_INTERACTION_TYPE_OFFSET));

	/* Release the warning string */
	MemUnlock (OptrToHandle (@FFNoMarkedRecordsToDeleteString));
	return;
    }

    /*
     * Put up a warning message: are they serious?
     */
	 UtilHex32ToAscii(numStr, (dword)numMarkedRecords, UHTAF_NULL_TERMINATE);
	 MemLock(OptrToHandle(@FFReallyDeleteAllMarkedRecords));
    if (UserStandardDialog(
		(TCHAR *)0,
		/* not GIT_MULTIPLE_RESPONSE, so no custom triggers  */
		(TCHAR *)0,
		/* string arguments. */
		(TCHAR *)0, numStr,
		/* dialog string */
		LMemDeref(@FFReallyDeleteAllMarkedRecords),
		/* dialog type */
		(CDT_QUESTION << CDBF_DIALOG_TYPE_OFFSET) |
		/* interaction type */
		(GIT_AFFIRMATION << CDBF_INTERACTION_TYPE_OFFSET)) == IC_NO) {
	MemUnlock(OptrToHandle(@FFReallyDeleteAllMarkedRecords));
	return;
	 }

    /*
     * The user really wants to delete the things.  Ok, they asked for it.
     */
    MemUnlock(OptrToHandle(@FFReallyDeleteAllMarkedRecords));

	 @call GeodeGetAppObject(0)::MSG_GEN_APPLICATION_MARK_BUSY();
	 /*
     * Turn off auto recalc so we'll get done faster.
     */
    @call oself::MSG_SPREADSHEET_GET_RECALC_PARAMS(&recalcParams);
    oldFlags = recalcParams.SRP_flags;
    recalcParams.SRP_flags = SF_MANUAL_RECALC;
    @call oself::MSG_SPREADSHEET_CHANGE_RECALC_PARAMS(&recalcParams);
    
	 /* put up the status dbox */
	 primary = @call GeodeGetAppObject(0)::MSG_GEN_FIND_CHILD_AT_POSITION(0);
	 dbox = @call primary::MSG_GEN_FIND_CHILD_AT_POSITION(20);
	 counter = @call dbox::MSG_GEN_FIND_CHILD_AT_POSITION(0);
	 @send dbox::MSG_GEN_INTERACTION_INITIATE();

/*    for (i = 0; i < numMarkedRecords; i++) {
	curRecord = FFDGetFirstMarkedRecord(oself);
	if (curRecord == NOT_A_RECORD) {
	    /*
		  * This should NEVER happen.
		  * jfh - but it does :-(.  After the routine finds the first marked
		  * record and deletes it properly it doesn't find any more.
	     */
/*	    EC_ERROR(UH_OH_NOT_A_RECORD);
	    break;
	}

	pself = ObjDerefGen(oself);
	pself->SSI_active.CR_row = curRecord;
	@call oself::MSG_FFD_DELETE_CURRENT_RECORD();
	 }
	/* jfh - so instead of the above for loop, let's try some brute force... */
	numRecs = pself->FFI_totalNumRecordsInDatabase;
	for(i = numRecs; i > 0; i--) {
		if (FFDGetRecordMarkStatus(pself, i - 1)) {
         /* it's marked - delete it */
			pself = ObjDerefGen(oself);
			pself->SSI_active.CR_row = i - 1;
			@call oself::MSG_FFD_DELETE_CURRENT_RECORD();
			numMarkedRecords--;
			/* and tell the user */
			numDels++;
			UtilHex32ToAscii(numStr, (dword)numDels, UHTAF_NULL_TERMINATE);
			@call counter::MSG_VIS_TEXT_REPLACE_ALL_PTR(numStr, 0);
			if (!numMarkedRecords) break;
			}
		}
	/* end of jfh brute force */

	@send dbox::MSG_GEN_GUP_INTERACTION_COMMAND(IC_DISMISS);
	 /*
     * Turn on auto recalc.
     */
    recalcParams.SRP_flags = oldFlags;
    @call oself::MSG_SPREADSHEET_CHANGE_RECALC_PARAMS(&recalcParams);

    /*
     * At this point, all of the marked records have been nuked.
     * Now see if there is anything left to show.
     */
    pself = ObjDerefGen(oself);
    if (!pself->FFI_totalNumRecordsInDatabase) {
	/*
	 * All records were nuked.  Edit a new record.
	 */
	@call oself::MSG_FFD_EDIT_NEW_RECORD(TRUE, NRT_REGULAR, TRUE);
	@call oself::MSG_FFD_SUBSET_SHOW_ALL_RECORDS();
    } else {
	/*
	 * Jump to the first record, and show all records.
	 */
	pself->SSI_active.CR_row = 0;
	@call oself::MSG_FFD_SUBSET_SHOW_ALL_RECORDS();
    }

    @call GeodeGetAppObject(0)::MSG_GEN_APPLICATION_MARK_NOT_BUSY();
}


/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		MSG_FFD_SUBSET_GET_OPTIONS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

DESCRIPTION:    Return the state of each of the record marking (subset)
		options.

PASS:           Void.

RETURN:         FFDSubsetOptionsInfo = Any combination of:
			FFDSOI_SHOW_ONLY_MARKED,
			FFDSOI_AUTO_APPLY_MARK,
			FFDSOI_CLEAR_MARKS_FIRST.

SIDE EFFECTS:
	Requires:       FFDSubsetOptionsInfo values are bit patterns.

	Asserts:        ???

CHECKS:         None.

PSEUDO CODE/STRATEGY:
	Build the bitflags indicating which options are on/off.

KNOWN DEFECTS/CAVEATS/IDEAS:    ???

REVISION HISTORY:
	Name    Date            Description
	----    ----            -----------
	JDM     93.01.11        Initial version.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/

@extern method FlatFileDatabaseClass, MSG_FFD_SUBSET_GET_OPTIONS
{
    FFDSubsetOptionsInfo        options;

    /* Displaying only marked records?  */
    options = (pself->FFI_showOnlyMarked) ? FFDSOI_SHOW_ONLY_MARKED : 0;

    /* Automatic application of the marking expression? */
    options |= (pself->FFI_autoApplyMark) ? FFDSOI_AUTO_APPLY_MARK : 0;

    /* Clearing marks prior to record marking expression?       */
    options |= (pself->FFI_clearMarksFirst) ? FFDSOI_CLEAR_MARKS_FIRST : 0;

    return (options);
}       /* End of MSG_FFD_SUBSET_GET_OPTIONS.   */


/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		MSG_FFD_SUBSET_AUTO_APPLY_MARK
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

DESCRIPTION:    Instruct the database to apply the current record
		marking expression to each newly created record.

PASS:           Boolean         applyFlag       = FALSE = Do *not* apply
						  the current expression.
						  Otherwise, it will.
RETURN:         Void.

SIDE EFFECTS:
	Requires:       ???

	Asserts:        FFI_autoApplyMark == FALSE iff the given applyFlag
			was FALSE.  Otherwise, TRUE.

CHECKS:         None.

PSEUDO CODE/STRATEGY:
	Set the database instance data flag based on the given flag.

KNOWN DEFECTS/CAVEATS/IDEAS:    ???

REVISION HISTORY:
	Name    Date            Description
	----    ----            -----------
	JDM     93.01.08        Initial version.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/

@extern method FlatFileDatabaseClass, MSG_FFD_SUBSET_AUTO_APPLY_MARK
{
    FFRecordControlStatusMessageBlock rcpblock;

    /* Set the database flag.   */
    pself->FFI_autoApplyMark = (applyFlag) ? TRUE : FALSE;

    /*
     * Tell the RCP to enable or disable the marking trigger.
     */
    FFRCPSMB_INDICATE_AUTO_MARKING_CHANGE(rcpblock, (pself->FFI_autoApplyMark));
    FFDSendRCPNotification (oself, &rcpblock);
    
    ObjMarkDirty(oself);
}


/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		MSG_FFD_SUBSET_CLEAR_MARKS_FIRST
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

DESCRIPTION:    Instruct the database to clear any and all preexisting
		record marks prior to apply the record marking expression.

PASS:           Boolean         applyFlag       = FALSE = Do *not* clear
						  preexisting marks.
						  Otherwise, clear them.
RETURN:         Void.

SIDE EFFECTS:
	Requires:       ???

	Asserts:        FFI_clearMarksFirst == FALSE iff the given
			applyFlag was FALSE.  Otherwise, TRUE.

CHECKS:         None.

PSEUDO CODE/STRATEGY:
	Set the database instance data flag based on the given flag.

KNOWN DEFECTS/CAVEATS/IDEAS:    ???

REVISION HISTORY:
	Name    Date            Description
	----    ----            -----------
	JDM     93.01.08        Initial version.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/

@extern method FlatFileDatabaseClass, MSG_FFD_SUBSET_CLEAR_MARKS_FIRST
{
    /* Set the database flag.   */
    pself->FFI_clearMarksFirst = (applyFlag) ? TRUE : FALSE;
    ObjMarkDirty(oself);
}       /* End of MSG_FFD_SUBSET_CLEAR_MARKS_FIRST.     */


/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		Messages That Deal With The RCP
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/

/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		MSG_FFD_SUBSET_SHOW_ONLY_MARKED_RECORDS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

DESCRIPTION:    Display only records in the database that are in the
		currently marked subset.

PASS:           Void.

RETURN:         TRUE if the transition was successful, FALSE otherwise.

REVISION HISTORY:
	Name    Date            Description
	----    ----            -----------
	jeremy  1/7/93          Initial version
	anna    2/22/93         Make screen redraw for multi-record

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
@extern method FlatFileDatabaseClass, MSG_FFD_SUBSET_SHOW_ONLY_MARKED_RECORDS
{
    /*
     * Commit the current record and continue if the insert was ok.
     */
    if (@call oself::MSG_FFD_RECORD_CONTROL(FFRCR_COMMIT_CURRENT_RECORD, 0)) {
	/*
	 * It was a successful commit.  Now do the rest.
	 */
	return(FFDSubsetShowOnlyMarkedRecords(oself));
    } else {
	return FALSE;
    }
}

/***********************************************************************
 *
 * FUNCTION:    FFDSubsetShowOnlyMarkedRecords
 *
 * DESCRIPTION: Display only records in the database that are in the
 *              currently marked subset.
 *
 * PARAMETERS:  oself - an optr to the current database
 *
 * CALLED BY:   INTERNAL
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *              An incidental warning: NEVER call
 *              MSG_FFD_RECORD_CONTROL with the
 *              FFRCR_COMMIT_CURRENT_RECORD request from within
 *              FFDSubsetShowOnlyMarkedRecords, because a hideous
 *              infinite calling loop will occur.
 *
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      jeremy  2/26/93         Initial version
 *
 ***********************************************************************/
Boolean
FFDSubsetShowOnlyMarkedRecords(optr oself)
{
    word markedRecord;
    EventHandle event;
    Boolean outcome;
    FlatFileDatabaseInstance *pself;
    
    /*
     * If there are no marked records, put up a message to that effect
     * and leave.
     */
    markedRecord = FFDGetNumberOfMarkedRecords(oself);
    pself = ObjDerefGen(oself);
    pself->FFI_numMarkedRecords = markedRecord;

    if (!pself->FFI_numMarkedRecords) {
	pself->FFI_showOnlyMarked = FALSE;
	
	/*
	 * Set the temp data row as not marked.
	 */
	FFDSetRecordMarkStatus(pself, TEMP_DATA_ROW, FALSE);
	
	MemLock (OptrToHandle (@FFNoMarkedRecordsString));
	UserStandardDialog
		((TCHAR *)0,
		 /* not GIT_MULTIPLE_RESPONSE, so no custom triggers  */
		 (TCHAR *)0,
		 /* No string arguments. */
		 (TCHAR *)0, (TCHAR *)0,
		 /* dialog string */
		 LMemDeref (@FFNoMarkedRecordsString),
		 /* dialog type */
		 (CDT_WARNING << CDBF_DIALOG_TYPE_OFFSET) |
		 /* interaction type */
		 (GIT_NOTIFICATION << CDBF_INTERACTION_TYPE_OFFSET));

	/* Release the warning string */
	MemUnlock (OptrToHandle (@FFNoMarkedRecordsString));

	/*
	 * Show all records.
	 */
	@call oself::MSG_FFD_SUBSET_SHOW_ALL_RECORDS();

	return FALSE;
    }
    
    /*
     * Find to the first marked record (including this one.)
     */
    if (! FFDGetRecordMarkStatus(pself, TEMP_DATA_ROW)) {
	/*
	 * We need to find the next marked record, then.  Is there one
	 * below the current record?
	 */
	markedRecord = FFDGetNextMarkedRecord(oself,
					      pself->SSI_active.CR_row);
	if (markedRecord == NOT_A_RECORD) {
	    /*
	     * Hmmm.  No marked records below us, so get the previous one.
	     */
	    markedRecord = FFDGetPreviousMarkedRecord(oself,
						      pself->SSI_active.CR_row);
	}
    } else {
	/*
	 * Current record is marked.
	 */
	markedRecord = pself->SSI_active.CR_row;
    }

    /*
     * Figure out the position of this record.
     */
    pself->FFI_currentMarkedRecord =
	FFDDetermineMarkedPosition(oself, markedRecord) - 1;

    #if ERROR_CHECK
	/*
	 * If there are no marked records, then we got big problems.
	 */
	if (markedRecord == NOT_A_RECORD) {
	    EC_ERROR (NO_MARKED_RECORDS);
	}
    #endif      /* ERROR_CHECK */

    /*
     * Set the flag indicating that we're showing marked flags only now.
     */
    pself->FFI_showOnlyMarked = TRUE;

    /*
     * Tell the RCP that we're showing marked records only, and jump to
     * the first appropriate marked record.
     *
     * An incidental warning: NEVER call FFD_RECORD_CONTROL with the
     * FFRCR_COMMIT_CURRENT_RECORD request, because a hideous infinite
     * calling loop will occur.
     */
    pself->FFI_numRecords = pself->FFI_numMarkedRecords;
    outcome =  (@call self::MSG_FFD_RECORD_CONTROL(FFRCR_GOTO_RECORD,
				       pself->FFI_currentMarkedRecord));

    /*
     * If we are displaying multiple records, we'll want to
     * redraw the screen
     */
    pself = ObjDerefGen(oself);
    if (pself->FFI_currentLayoutType == LT_MULTI_RECORD) {
	/*
	 * Force the View to redraw
	 */
	event = @record GenViewClass::MSG_GEN_VIEW_REDRAW_CONTENT();

	@send oself::MSG_VIS_VUP_CALL_OBJECT_OF_CLASS(event);
    }
    return(outcome);
}


/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		MSG_FFD_SUBSET_SHOW_ALL_RECORDS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

DESCRIPTION:    Display all records in the database (regardless of
		inclusion in the currently marked subset).

PASS:           Void.

RETURN:         TRUE if we were able to do the trick, FALSE otherwise.

SIDE EFFECTS:
	Requires:       ???

	Asserts:        ???

CHECKS:                 ???

PSEUDO CODE/STRATEGY:   ???

KNOWN DEFECTS/CAVEATS/IDEAS:    ???

REVISION HISTORY:
	Name    Date            Description
	----    ----            -----------
	jeremy  1/7/93          Initial version.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/

@extern method FlatFileDatabaseClass, MSG_FFD_SUBSET_SHOW_ALL_RECORDS
{
    /*
     * Clear the flag for showing only marked records.
     */
    pself->FFI_showOnlyMarked = FALSE;

    /*
     * Set the number of records to be all of the records in the
     * database.
     */
    pself->FFI_numRecords = pself->FFI_totalNumRecordsInDatabase;
    
    /*
     * Tell the RCP to update itself.
     */
    return (@call self::MSG_FFD_RECORD_CONTROL(FFRCR_REFRESH, 0));
}


/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		Utility Functions
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/

/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		FFDMarkRecordsViaExpression
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:       Test and mark all records in the database record for
		inclusion in the currently defined subset.  

PASS:           oself - an optr to the current database
		tokenStream - a pointer to the expression with which
			      we test inclusion
		numRecords - the number of records in the database
		clearMarksFirst - flag: set if the mark flag is to be
				  cleared if the record is not included
				  in the set.
				  
RETURN:         The number of records in the new subset, or a -1
		if the expression was bogus.

REVISION HISTORY:
	Name    Date            Description
	----    ----            -----------
	JDM     92.08.18        Initial version.
	JDM     92.09.08        Rewrote for cell library changes.
	jdashe  1/6/93          Rewrote for the mark records revamping.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/

static int
FFDMarkRecordsViaExpression(optr oself,
			    byte *tokenStream,
			    word numRecords,
			    Boolean clearMarksFirst)
{
    word        curRecord;
    word        numRecordsInSubset = 0;
    FlatFileDatabaseInstance    *pself = ObjDerefGen (oself);
    optr        appObject = GeodeGetAppObject(0);
    
    /*
     * Put up an hourglass.
     */
    @call appObject::MSG_GEN_APPLICATION_MARK_APP_COMPLETELY_BUSY(); 
    
    /*
     * Loop through every record in the database...
     */
    for (curRecord = 0; curRecord < numRecords; curRecord++) {
	/*
	 * Is this record part of the current mark criteria?
	 */
	switch (FFDSubsetTestExpression(oself, tokenStream, curRecord)) {
	    case SER_TRUE:
		/*
		 * We have a winnah.  Set the marked flag for this record.
		 */
		RowSetFlags(&pself->SSI_cellParams,
			    curRecord,
			    MARKED_RECORD);
		numRecordsInSubset++;
		break;

	    case SER_FALSE:
		/*
		 * Clear the marked flag if clearMarksFirst is set;
		 * otherwise, leave it be.
		 */
		if (clearMarksFirst) {
		    RowSetFlags(&pself->SSI_cellParams,
				curRecord,
				UNMARKED_RECORD);
		}
		break;

	    case SER_BOGUS:
		/* FALL THROUGH!        */

	    default:
		/*
		 * An error occurred.  Bail.
		 */
		@call appObject::
		    MSG_GEN_APPLICATION_MARK_APP_NOT_COMPLETELY_BUSY();
		return (-1);
	}
    }   /* End of for each record.      */

    /* Return the current marked record count.  */
    @call appObject::MSG_GEN_APPLICATION_MARK_APP_NOT_COMPLETELY_BUSY();
    return numRecordsInSubset;
}


/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		FFDSubsetTestExpression
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:       This function evaluates a supposedly Boolean expression
		on a specific record, and returns a value indicating
		if the expression evaluated to TRUE, FALSE, or an error.

CALLED BY:      Internal --
			FFDMarkRecordsViaExpression.

PASS:           optr    oself           = Current database.
		byte    *tokenStream    = Current record marking expression.
		word    recordNum       = Evaluate given expression against
					  this record in the database.

RETURN:         SubsetEvalResult        =
			SER_TRUE iff the expression evaluated as TRUE.
			SER_FALSE iff the expression evaluated as FALSE.
			SER_BOGUS otherwise (if the expression was bogus
			or evaluated to anything else).

SIDE EFFECTS:
	Requires:       ????

	Asserts:        ????

CHECKS:         None.

PSEUDO CODE/STRATEGY:   ????

KNOWN DEFECTS/CAVEATS/IDEAS:    ????

REVISION HISTORY:
	Name    Date            Description
	----    ----            -----------
	jeremy  1/ 6/93         Big reorganization.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/

SubsetEvalResult
FFDSubsetTestExpression(optr oself, byte *tokenStream, word recordNum)
{
    FloatNum    floatNum;
    byte        exprResultBuffer [EVAL_BUFFER_SIZE];
    ArgumentStackElement        *evalElement;
    FlatFileDatabaseInstance    *pself;
    word        oldRecord;

    /* Get ahold of ourself.    */
    pself = ObjDerefGen(oself);

    /* Set the database's current row to given record/row.      */
    oldRecord = pself->SSI_active.CR_row;
    pself->SSI_active.CR_row = recordNum;

    /* Evaluate the given record against the test expression.   */
    if (FFD_EvaluateExpression(tokenStream,
			       exprResultBuffer,
			       recordNum,
			       oself)) {
	return SER_BOGUS;
    }

    /*
     * Recover the old current record.
     */
    pself->SSI_active.CR_row = oldRecord;

    /*
     * Figure out the result type of the given expression.
     * Clean up the stack for all of the uninteresting cases (i.e. ignore
     * all of the cases that don't leave anything on the floating point
     * stack).
     * Is the result type a number?
     */
    evalElement = (ArgumentStackElement *) exprResultBuffer;
    if (ESAT_NUMBER & evalElement->ASE_type) {
	/*
	 * Yep, it's a number.  Return TRUE if it's non-zero, FALSE
	 * otherwise.
	 */
	return ((FloatEq0()) ? SER_FALSE : SER_TRUE);
    }

    /*
     * The eval result was not a Boolean.  Clean up if necessary and return
     * an error flag.
     */
    if (ESAT_EMPTY & evalElement->ASE_type) {
	/* Clean up the floating point stack.   */
	FloatPopNumber (&floatNum);
    }

    /* If we made it here, then the expression was invalid. */
    return SER_BOGUS;
}


/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		FFDGetRecordMarkStatus
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:       Figure out if the given record in the current database is
		marked as being in the currently defined subset.

CALLED BY:      External.

PASS:           FlatFileDatabaseInstance *pself = Current database instance
						  data.
		word    recordNum       = Record to query.

RETURN:         Boolean = TRUE iff the record is in the subset (marked).
			  FALSE otherwise.

REVISION HISTORY:
	Name    Date            Description
	----    ----            -----------
	JDM     92.09.18        Initial version.
	jdashe  1/6/93          Updated.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/

Boolean
FFDGetRecordMarkStatus (FlatFileDatabaseInstance *pself, word recordIndex)
{
    return (MARKED_RECORD & RowGetFlags (&pself->SSI_cellParams,
						recordIndex));
}


/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		FFDSetRecordMarkStatus
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:       Set the subset marking flag for the given record in the
		current database to the given state.

		If the record to be marked has no data, an empty cell is
		created to make it possible to mark and unmark the empty
		record.
		
CALLED BY:      External.

PASS:           FlatFileDatabaseInstance *pself = Current database instance
						  data.
		word    recordIndex     = Record to modify.
		Boolean mark            = TRUE if record in current subset.
					  FALSE otherwise.
RETURN:         Void.

REVISION HISTORY:
	Name    Date            Description
	----    ----            -----------
	JDM     92.09.18        Initial version.
	jdashe  1/6/93          Updated.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/

void
FFDSetRecordMarkStatus (FlatFileDatabaseInstance *pself,
			word recordNum,
			Boolean mark)
{
    CellEmpty emptyCell = {0, CT_EMPTY, 0, 0, 0};

    if (!RowGetFlags(&pself->SSI_cellParams, recordNum)) {
	/*
	 * This is a totally empty record.  To mark a record, you
	 * need at least one cell in the row, so create an empty one.
	 */
	CellReplace(&pself->SSI_cellParams,
		    recordNum,
		    0,
		    &emptyCell,
		    sizeof(CellEmpty));
    }
	 
    RowSetFlags (&pself->SSI_cellParams,
		 recordNum,
		 (mark ? MARKED_RECORD : UNMARKED_RECORD));
}


/***********************************************************************
 *
 * FUNCTION:    FFDGetFirstMarkedRecord
 *
 * DESCRIPTION: Return the first marked record in the database.  If there
 *              are none, return NOT_A_RECORD.
 *
 * PARAMETERS:  oself - an optr to the current database
 *
 * CALLED BY:   INTERNAL
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      jeremy  1/12/93         Initial version
 *
 ***********************************************************************/
word
FFDGetFirstMarkedRecord(optr oself)
{
    word firstMarkedRecord = NOT_A_RECORD;
    FlatFileDatabaseInstance *pself = ObjDerefGen(oself);

    if (pself->FFI_totalNumRecordsInDatabase) {
	/*
	 * Ok, there's at least one record in here.
	 */
	if (FFDGetRecordMarkStatus(pself, 0)) {
	    firstMarkedRecord = 0;
	} else {
	    firstMarkedRecord = FFDGetNextMarkedRecord(oself, 0);
	}
    }

    return firstMarkedRecord;
}


/***********************************************************************
 *
 * FUNCTION:    FFDGetNextMarkedRecord
 *
 * DESCRIPTION: This function returns the next marked record in the data-
 *              base, given a record number to begin with.
 *
 *              If no marked record could be found, NOT_A_RECORD is returned.
 *
 * PARAMETERS:  oself - an optr to the current database
 *              curRecord - the record with which to base the search
 *
 * CALLED BY:   INTERNAL
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      jeremy  1/ 6/93         Initial version
 *
 ***********************************************************************/
word
FFDGetNextMarkedRecord (optr oself, word curRecord)
{
    FlatFileDatabaseInstance *pself;
    CRangeEnumParams crep;
    word nextRecord = NOT_A_RECORD;
    
    pself = ObjDerefGen (oself);
    
    crep.CREP_params.REP_callback        = FFDGetNextMarkedCallback;
    crep.CREP_params.REP_bounds.R_left   = 0;
    crep.CREP_params.REP_bounds.R_right  = 0;
    crep.CREP_params.REP_bounds.R_top    = curRecord + 1;
    crep.CREP_params.REP_bounds.R_bottom =
				       pself->FFI_totalNumRecordsInDatabase - 1;
    crep.CREP_params.REP_locals          = &nextRecord;
    crep.CREP_params.REP_matchFlags      = MARKED_RECORD;

    @call GeodeGetAppObject(0)::MSG_GEN_APPLICATION_MARK_BUSY();
    (void) RangeEnum(&pself->SSI_cellParams, &crep, REF_MATCH_ROW_FLAGS);
    @call GeodeGetAppObject(0)::MSG_GEN_APPLICATION_MARK_NOT_BUSY();

    return nextRecord;
}


/***********************************************************************
 *
 * FUNCTION:    FFDGetPreviousMarkedRecord
 *
 * DESCRIPTION: This function returns the previous marked record in the data-
 *              base, given a record number to begin with.
 *
 * PARAMETERS:  oself - an optr to the current database
 *              curRecord - the record with which to base the search
 *
 *              If no marked record could be found, NOT_A_RECORD is returned.
 *
 * CALLED BY:   INTERNAL
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      jeremy  1/ 6/93         Initial version
 *
 ***********************************************************************/
word
FFDGetPreviousMarkedRecord (optr oself, word curRecord)
{
    FlatFileDatabaseInstance *pself;
    CRangeEnumParams crep;
    word previousRecord = NOT_A_RECORD;
    
    if (curRecord == 0) {
	return NOT_A_RECORD;
    }
    
    pself = ObjDerefGen(oself);
    
    crep.CREP_params.REP_callback        = FFDGetPreviousMarkedCallback;
    crep.CREP_params.REP_bounds.R_left   = 0;
    crep.CREP_params.REP_bounds.R_right  = 0;
    crep.CREP_params.REP_bounds.R_top    = 0;
    crep.CREP_params.REP_bounds.R_bottom = curRecord - 1;
    crep.CREP_params.REP_locals          = &previousRecord;
    crep.CREP_params.REP_matchFlags      = MARKED_RECORD;

    @call GeodeGetAppObject(0)::MSG_GEN_APPLICATION_MARK_BUSY();
    (void) RangeEnum(&pself->SSI_cellParams, &crep, REF_MATCH_ROW_FLAGS);
    @call GeodeGetAppObject(0)::MSG_GEN_APPLICATION_MARK_NOT_BUSY();

    return previousRecord;
}


/***********************************************************************
 *
 * FUNCTION:    FFDGetNthMarkedRecord
 *
 * DESCRIPTION: This function returns the absolute record number of the Nth
 *              marked record in the database.  If no nth record exists,
 *              NOT_A_RECORD is returned.
 *
 * PARAMETERS:  oself - an optr to the current database
 *              n - the nth marked record to return.
 *              NOTE:   n starts counting at 1, not 0! So if you want the
 *                      first marked record in the database, pass n = 1.
 *
 * CALLED BY:   INTERNAL
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      jeremy  1/12/93         Initial version
 *
 ***********************************************************************/
word
FFDGetNthMarkedRecord(optr oself, word n)
{
    FlatFileDatabaseInstance *pself;
    CRangeEnumParams crep;
    word nthMarkedRecord = n;
    
    pself = ObjDerefGen(oself);
    
    /*
     * Let's catch some simple bogus cases.
     */
    if (pself->FFI_numMarkedRecords == 0 ||
	pself->FFI_numMarkedRecords < n) {
	EC_ERROR(UH_OH_NOT_A_RECORD);
	return NOT_A_RECORD;
    }

    if (n == 0) {
	/*
	 * We're already sitting on the record.
	 */
	return 0;
    }
    
    /*
     * Go for it.  The nth marked record number will be
     * placed in nthMarkedRecord.
     */
    crep.CREP_params.REP_callback        = FFDGetNthMarkedCallback;
    crep.CREP_params.REP_bounds.R_left   = 0;
    crep.CREP_params.REP_bounds.R_right  = 0;
    crep.CREP_params.REP_bounds.R_top    = 0;
    crep.CREP_params.REP_bounds.R_bottom =
				       pself->FFI_totalNumRecordsInDatabase - 1;
    crep.CREP_params.REP_locals          = &nthMarkedRecord;
    crep.CREP_params.REP_matchFlags      = MARKED_RECORD;

    @call GeodeGetAppObject(0)::MSG_GEN_APPLICATION_MARK_BUSY();
    (void) RangeEnum(&pself->SSI_cellParams, &crep, REF_MATCH_ROW_FLAGS);
    @call GeodeGetAppObject(0)::MSG_GEN_APPLICATION_MARK_NOT_BUSY();

    return nthMarkedRecord;
}


/***********************************************************************
 *
 * FUNCTION:    FFDDetermineMarkedPosition
 *
 * DESCRIPTION: This routine figures out how many marked records come before
 *              a passed absolute record number, then adds one to return
 *              the marked position of the record.
 *
 *              In other words, this routine will tell you if this is the
 *              7th marked record, the 142nd, or whatever.
 *
 *              If the current record is not marked, NOT_A_RECORD will
 *              be returned.
 *
 *              NOTE: The marked position starts counting at 1; if 1 is
 *                      returned, it means recordNum is the FIRST marked
 *                      record.
 *
 * PARAMETERS:  oself - an optr to the current database
 *              recordNum - the absolute record number to match.
 *
 * CALLED BY:   INTERNAL
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      jeremy  1/13/93         Initial version
 *
 ***********************************************************************/
word
FFDDetermineMarkedPosition(optr oself, word recordNum)
{
    FlatFileDatabaseInstance *pself;
    CRangeEnumParams crep;
    MarkedPositionStruct markedPosition;

    pself = ObjDerefGen(oself);

    #if ERROR_CHECK
	if (recordNum >= pself->FFI_totalNumRecordsInDatabase) {
	    EC_ERROR(BAD_MARKED_RECORD_REQUEST);
	}
    #endif /* ERROR_CHECK */

    if (FFDGetRecordMarkStatus(pself, recordNum) == FALSE) {
	EC_ERROR(UH_OH_NOT_A_RECORD);
	return NOT_A_RECORD;
    }
    
    /*
     * Get rid of a simple case: If this is record 0, we're the first
     * record.
     */
    if (recordNum == 0) {
	return 1;
    }
    
    /*
     * Set up the structure to be passed to the callback.  The MPOS_position
     * element will be incremented each time the callback is executed.
     */
    markedPosition.MPOS_record = recordNum;
    markedPosition.MPOS_position = 0;
    
    crep.CREP_params.REP_callback        = FFDDetermineMarkedPositionCallback;
    crep.CREP_params.REP_bounds.R_left   = 0;
    crep.CREP_params.REP_bounds.R_right  = 0;
    crep.CREP_params.REP_bounds.R_top    = 0;
    crep.CREP_params.REP_bounds.R_bottom = recordNum;
    crep.CREP_params.REP_locals          = &markedPosition;
    crep.CREP_params.REP_matchFlags      = MARKED_RECORD;

    @call GeodeGetAppObject(0)::MSG_GEN_APPLICATION_MARK_BUSY();
    (void) RangeEnum(&pself->SSI_cellParams, &crep, REF_MATCH_ROW_FLAGS);
    @call GeodeGetAppObject(0)::MSG_GEN_APPLICATION_MARK_NOT_BUSY();

    return markedPosition.MPOS_position;
}


/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		RangeEnum Callback Routines
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/

/***********************************************************************
 *
 * FUNCTION:    FFDGetNextMarkedCallback
 *
 * DESCRIPTION: This routine sets a passed variable to the current record
 *              number, then returns an ABORT flag.
 *
 *              We do all this because all we're trying to do is find the
 *              first marked record in a range.
 *
 * PARAMETERS:  recp - a RangeEnumCallbackParams structure.
 *
 * RETURNS:     a dword:
 *                  high word:
 *                      high byte - Boolean: TRUE if the enum should stop.
 *                      low byte - RangeEnumFlags: new flags.
 *                  low word:
 *                      undefined.
 *
 * CALLED BY:   INTERNAL
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      jeremy  1/ 6/93         Initial version
 *
 ***********************************************************************/
RANGE_ENUM_CALLBACK_RETURN_TYPE _pascal
FFDGetNextMarkedCallback (RangeEnumCallbackParams recp)
{
    word        *recordNum;
    
    recordNum = (word *)(recp.RECP_params->REP_locals);
    *recordNum = recp.RECP_row;
    
    return RANGE_ENUM_CALLBACK_RETURN_VALUE (TRUE, recp.RECP_rangeFlags);
}


/***********************************************************************
 *
 * FUNCTION:    FFDGetPreviousMarkedCallback
 *
 * DESCRIPTION: This routine sets a passed variable to the current record
 *              number, then returns a CONTINUE flag.
 *
 *              We do all this because all we're trying to do is find the
 *              last marked record in a range.
 *
 * PARAMETERS:  recp - a RangeEnumCallbackParams structure.
 *
 * RETURNS:     a dword:
 *                  high word:
 *                      high byte - Boolean: TRUE if the enum should stop.
 *                      low byte - RangeEnumFlags: new flags.
 *                  low word:
 *                      undefined.
 *
 * CALLED BY:   INTERNAL
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      jeremy  1/ 6/93         Initial version
 *
 ***********************************************************************/
RANGE_ENUM_CALLBACK_RETURN_TYPE _pascal
FFDGetPreviousMarkedCallback (RangeEnumCallbackParams recp)
{
    word        *recordNum;
    
    recordNum = (word *) (recp.RECP_params->REP_locals);
    *recordNum = recp.RECP_row;
    
    return RANGE_ENUM_CALLBACK_RETURN_VALUE (FALSE, recp.RECP_rangeFlags);
}


/***********************************************************************
 *
 * FUNCTION:    FFDMarkModificationCallback
 *
 * DESCRIPTION: This callback modifies the marked flag of the passed
 *              row as indicated by the SubsetMarkModification enum
 *              passed in the recp structure.
 *
 * PARAMETERS:  recp - a RangeEnumCallbackParams structure.
 *
 * RETURNS:     a dword:
 *                  high word:
 *                      high byte - Boolean: TRUE if the enum should stop.
 *                      low byte - RangeEnumFlags: new flags.
 *                  low word:
 *                      undefined.
 *
 * CALLED BY:   INTERNAL
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      jeremy  1/11/93         Initial version
 *
 ***********************************************************************/
RANGE_ENUM_CALLBACK_RETURN_TYPE _pascal
FFDMarkModificationCallback(RangeEnumCallbackParams recp)
{
    /*
     * Change the marked record column flag as indicated by REP_locals.
     */
    switch (*(SubsetMarkModification *) recp.RECP_params->REP_locals) {
	case SMM_SET_MARK_FLAG:
	    /*
	     * Set the column as marked.
	     */
	    recp.RECP_params->REP_rowFlags = MARKED_RECORD;
	    break;

	case SMM_UNSET_MARK_FLAG:
	    /*
	     * Clear the column's mark.
	     */
	    recp.RECP_params->REP_rowFlags = UNMARKED_RECORD;
	    break;

	case SMM_INVERT_MARK_FLAG:
	    recp.RECP_params->REP_rowFlags = (recp.RECP_params->REP_rowFlags & MARKED_RECORD) ?
		UNMARKED_RECORD : MARKED_RECORD;
	    break;

    }
    /*
     * Tell RangeEnum to keep on going, but that we've modified the
     * row flags.
     */
    return RANGE_ENUM_CALLBACK_RETURN_VALUE(FALSE,
	       recp.RECP_rangeFlags | REF_ROW_FLAGS_MODIFIED);
}

/***********************************************************************
 *
 * FUNCTION:    FFDGetNthMarkedCallback
 *
 * DESCRIPTION: This routine decrements a passed variable, then checks to
 *              see if it has reached zero.  If so, it places the current
 *              record number in the passed variable and signals that the
 *              enum should halt.
 *
 *              We do all this because we're trying to find the nth marked
 *              record in a range.
 *
 * PARAMETERS:  recp - a RangeEnumCallbackParams structure.
 *
 * RETURNS:     a dword:
 *                  high word:
 *                      high byte - Boolean: TRUE if the enum should stop.
 *                      low byte - RangeEnumFlags: new flags.
 *                  low word:
 *                      undefined.
 *
 * CALLED BY:   INTERNAL
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      jeremy  1/ 12/93        Initial version
 *
 ***********************************************************************/
RANGE_ENUM_CALLBACK_RETURN_TYPE _pascal
FFDGetNthMarkedCallback (RangeEnumCallbackParams recp)
{
    word *nthMarkedRecord;
    
    nthMarkedRecord = (word *) (recp.RECP_params->REP_locals);
    (*nthMarkedRecord)--;

    if (*nthMarkedRecord < 1) {
	/*
	 * We've found the nth marked record!  Set the variable to the
	 * current row number and signal an end to all this.
	 */
	*nthMarkedRecord = recp.RECP_row;
	return RANGE_ENUM_CALLBACK_RETURN_VALUE (TRUE, recp.RECP_rangeFlags);
    }
    
    /*
     * Keep looking.
     */
    return RANGE_ENUM_CALLBACK_RETURN_VALUE (FALSE, recp.RECP_rangeFlags);
}


/***********************************************************************
 *
 * FUNCTION:    FFDDetermineMarkedPositionCallback
 *
 * DESCRIPTION: This callback increments a counter in a passed structure,
 *              then compares the current record number with a passed
 *              record number.  If the numbers don't match, we indicate
 *              that the RangeEnum should continue; otherwise, we signal
 *              that we should stop.
 *
 * PARAMETERS:  recp - a RangeEnumCallbackParams structure.
 *
 * RETURNS:     a dword:
 *                  high word:
 *                      high byte - Boolean: TRUE if the enum should stop.
 *                      low byte - RangeEnumFlags: new flags.
 *                  low word:
 *                      undefined.
 *
 *
 * CALLED BY:   INTERNAL
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      jeremy  1/13/93         Initial version
 *
 ***********************************************************************/
RANGE_ENUM_CALLBACK_RETURN_TYPE _pascal
FFDDetermineMarkedPositionCallback(RangeEnumCallbackParams recp)
{
    MarkedPositionStruct *markedPosition;
    
    markedPosition = (MarkedPositionStruct *)(recp.RECP_params->REP_locals);
    markedPosition->MPOS_position++;

    if (recp.RECP_row == markedPosition->MPOS_record) {
	/*
	 * We've found the nth marked record!  Set the variable to the
	 * current row number and signal an end to all this.
	 */
	return RANGE_ENUM_CALLBACK_RETURN_VALUE(TRUE, recp.RECP_rangeFlags);
    }
    
    /*
     * Keep looking.
     */
    return RANGE_ENUM_CALLBACK_RETURN_VALUE(FALSE, recp.RECP_rangeFlags);
}


/***********************************************************************
 *
 * FUNCTION:    FFDGetNumberOfMarkedCallback
 *
 * DESCRIPTION: This callback increments a counter in a passed structure.
 *
 * PARAMETERS:  recp - a RangeEnumCallbackParams structure.
 *
 * RETURNS:     a dword:
 *                  high word:
 *                      high byte - Boolean: TRUE if the enum should stop.
 *                      low byte - RangeEnumFlags: new flags.
 *                  low word:
 *                      undefined.
 *
 *
 * CALLED BY:   INTERNAL
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      jeremy  1/15/93         Initial version
 *
 ***********************************************************************/
RANGE_ENUM_CALLBACK_RETURN_TYPE _pascal
FFDGetNumberOfMarkedCallback(RangeEnumCallbackParams recp)
{
    word *markedRecords;
    
    markedRecords = (word *)(recp.RECP_params->REP_locals);
    (*markedRecords)++;

    /*
     * Keep going.
     */
    return RANGE_ENUM_CALLBACK_RETURN_VALUE(FALSE, recp.RECP_rangeFlags);
}
