/***********************************************************************
 *
 *	Copyright (c) Geoworks 1992 -- All Rights Reserved
 *
 * PROJECT:	  PC/GEOS
 * MODULE:	  ffDatabaseParse.goc
 * FILE:	  ffDatabaseParse.goc
 *
 * AUTHOR:  	  Jeremy Dashe : Apr 13, 1992
 *
 * DESCRIPTION:
 *	This file contains functions for parsing expressions
 *	in the flat file database library.
 *
 * RCS STAMP:
 *	$Id: ffDatabaseParse.goc,v 1.1 97/04/04 18:02:53 newdeal Exp $
 *
 ***********************************************************************/

#ifdef __HIGHC__
pragma Code ("DATABASEPARSER");
#endif
#ifdef __BORLANDC__
#pragma codeseg DATABASEPARSER
#endif

@include <stdapp.goh>			/* PC/GEOS	*/
#include <geoworks.h>
#include <math.h>
#include <parse.h>
#include <system.h>

#include <Ansi/string.h>		/* Standard C.	*/

@include <Objects/FlatFile/ffileC.goh>	/* FlatFile Library.	*/
#include <Objects/FlatFile/ffTChst.h>
@include <ffile.goh>
#include <ffFatal.h>
#include <extern.h>
#include <Database/ffdExtrn.h>

/*
 **********************************************************************
 *	    	    	      External Declarations
 **********************************************************************
 */

@extern chunk @FFDErr_bad_number;
@extern chunk @FFDErr_bad_cell_reference;
@extern chunk @FFDErr_no_close_quote;
@extern chunk @FFDErr_column_too_large;
@extern chunk @FFDErr_row_too_large;
@extern chunk @FFDErr_illegal_token;
@extern chunk @FFDErr_general;
@extern chunk @FFDErr_too_many_tokens;
@extern chunk @FFDErr_expected_open_paren;
@extern chunk @FFDErr_expected_close_paren;
@extern chunk @FFDErr_bad_expression;
@extern chunk @FFDErr_expected_end_of_expression;
@extern chunk @FFDErr_missing_close_paren;
@extern chunk @FFDErr_unknown_identifier;
@extern chunk @FFDErr_not_enough_name_space;
@extern chunk @FFDErr_out_of_stack_space;
@extern chunk @FFDErr_nesting_too_deep;
@extern chunk @FFDErr_row_out_of_range;
@extern chunk @FFDErr_column_out_of_range;
@extern chunk @FFDErr_function_no_longer_exists;
@extern chunk @FFDErr_bad_arg_count;
@extern chunk @FFDErr_wrong_type;
@extern chunk @FFDErr_divide_by_zero;
@extern chunk @FFDErr_undefined_name;
@extern chunk @FFDErr_circular_ref;
@extern chunk @FFDErr_circular_dep;
@extern chunk @FFDErr_circ_name_ref;
@extern chunk @FFDErr_number_out_of_range;
@extern chunk @FFDErr_gen_err;
@extern chunk @FFDErr_float_pos_infinity;
@extern chunk @FFDErr_float_neg_infinity;
@extern chunk @FFDErr_float_gen_err;
@extern chunk @FFMemoryFullError;

optr FFDErrorTextTable[] =
    {@FFDErr_bad_number,
     @FFDErr_bad_cell_reference,
     @FFDErr_no_close_quote,
     @FFDErr_column_too_large,
     @FFDErr_row_too_large,
     @FFDErr_illegal_token,
     @FFDErr_general,
     @FFDErr_too_many_tokens,
     @FFDErr_expected_open_paren,
     @FFDErr_expected_close_paren,
     @FFDErr_bad_expression,
     @FFDErr_expected_end_of_expression,
     @FFDErr_missing_close_paren,
     @FFDErr_unknown_identifier,
     @FFDErr_not_enough_name_space,
     @FFDErr_out_of_stack_space,
     @FFDErr_nesting_too_deep,
     @FFDErr_row_out_of_range,
     @FFDErr_column_out_of_range,
     @FFDErr_function_no_longer_exists,
     @FFDErr_bad_arg_count,
     @FFDErr_wrong_type,
     @FFDErr_divide_by_zero,
     @FFDErr_undefined_name,
     @FFDErr_circular_ref,
     @FFDErr_circular_dep,
     @FFDErr_circ_name_ref,
     @FFDErr_number_out_of_range,
     @FFDErr_gen_err,
     @FFDErr_float_pos_infinity,
     @FFDErr_float_neg_infinity,
     @FFDErr_float_gen_err
};

/**********************************************************************
 *	    	    	      Forward Declarations  	    	      *
 **********************************************************************/

void _pascal FFDParseLibraryCallback(C_CallbackStruct *callbackStruct);

void FFD_ParserFormatExpression(MemHandle tokenStreamHandle,
			  TCHAR *textBuffer,
			  optr ffdOptr);

Boolean FFD_ParserParseString(MemHandle stringHandle,
			MemHandle tokenBufferHandle,
			word tokenBufferSize,
			optr ffdOptr,
			word *numTokens,
			VisTextRange *errorOffsetPtr);

int FFD_EvaluateExpression(byte *tokenStream,
			   byte *resultBuffer,
			   word row,
			   optr ffdOptr);

word FFDGetTokenNumber(optr oself, FieldID colNum);

/***********************************************************************
 *
 * MESSAGE:	MSG_FFD_EDIT_EXPRESSION for FlatFileDatabaseClass
 *
 * DESCRIPTION: This message handles when an expression or computed
 *	    	expression is to be edited.  Given a token stream, the
 *	    	number of tokens in the stream, and an Expression
 *	    	Builder OD, this message translates the token stream
 *	    	into a string and gives the string to the expression
 *	    	builder. MSG_FFD_PARSE_EXPRESSION deals with parsing
 *	    	the new string and dealing with errors.
 *
 *	    	If the resultDestinationOptr is non-NULL, it will be
 *	    	sent the passed resultMessage. The resultMessage's one
 *	    	argument is a MemHandle to the resulting token stream
 *	    	(so it's up to the resultDestination to determine if
 *	    	the stream changed or not).
 *
 * PARAMETERS:
 *	void (MemHandle tokenStreamHandle,
 *	      optr expressionBuilderOptr,
 *	      optr resultDestinationOptr,
 *	      Message resultMessage);
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	4/13/92		Initial version
 *	jeremy	6/17/92	    	Added numTokens
 *
 ***********************************************************************/
@extern method FlatFileDatabaseClass, MSG_FFD_EDIT_EXPRESSION
{
    MemHandle textHandle;
    TCHAR *text;

    /*
     * Remember who should receive the token stream and which expression
     * builder is being called.
     */
    pself->FFI_tokenStreamDestOptr = resultDestinationOptr;
    pself->FFI_tokenStreamDestMsg = resultMessage;
    pself->FFI_expressionBuilderOptr = expressionBuilderOptr;

    /*
     * Allocate a text buffer to send to the expression builder, and
     * assume there's no expression to edit.
     */
    textHandle = MemAlloc((MAX_EXPRESSION_STRING_LENGTH + 1)*sizeof(TCHAR),
			  HF_DYNAMIC | HF_SHARABLE, 
			  HAF_STANDARD | HAF_NO_ERR);
    text = MemLock(textHandle);
    text[0] = _TEXT('\0');

    /*
     * If there's a token stream to expand, fill the expression builder's
     * string.
     */
    if (tokenStreamHandle != NullHandle) {
	FFD_ParserFormatExpression(tokenStreamHandle, text, oself);
    }
    
    MemUnlock(textHandle);

    @send expressionBuilderOptr::MSG_FFEB_EDIT_EXPRESSION(
	textHandle, (dword) 0, (dword) 0, oself, MSG_FFD_PARSE_EXPRESSION);
}

/***********************************************************************
 *
 * MESSAGE:	MSG_FFD_PARSE_EXPRESSION for FlatFileDatabaseClass
 *
 * DESCRIPTION:	
 *	This message handles when an expresion builder is done
 *	building a string out and wants it to be parsed and translated
 *	into a token stream.
 *
 *	The parse library is called to parse the string. Any
 *	errors that might occur are displayed here.  If an error does
 *	occur, the calling expression builder is requested to
 *	highlight (select) the offending part of the string.
 *
 *	If the string parses successfully, then the expression builder
 *	is called to shut itself down.
 *
 *	If the tokenStreamDestOptr (a FlatFileDatabaseClass instance
 *	datum set in MSG_FFD_EDIT_EXPRESSION) is non-NULL, it will be
 *	sent the tokenStreamDestMsg with a token stream's MemHandle.
 *
 *	NOTE: The string will be freed in here.
 *
 * PARAMETERS:
 *	void MSG_FFD_PARSE_EXPRESSION(MemHandle stringHandle);
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	4/13/92		Initial version
 *
 ***********************************************************************/
@extern method FlatFileDatabaseClass, MSG_FFD_PARSE_EXPRESSION
{
    MemHandle tokenStreamHandle;
    VisTextRange errOffsets;
    word numTokens;

#if ERROR_CHECK
    /*
     * The only legal way to call this message is through a
     * convoluted journey that must start with MSG_FFD_EDIT_EXPRESSION.
     * Otherwise, these three instance data won't be set correctly...
     */
    /*if (pself->FFI_tokenStreamDestOptr == NullOptr ||
	pself->FFI_tokenStreamDestMsg  == 0 ||
	pself->FFI_expressionBuilderOptr == NullOptr) {
	EC_ERROR(BAD_PARSE_EXPRESSION_SETUP);
    }*/
#endif	

    /*
     * Allocate space for a new token stream.
     */
    tokenStreamHandle = MemAlloc(MAX_TOKEN_STREAM_SIZE,
				 (HF_DYNAMIC | HF_SHARABLE),
				 HAF_STANDARD | HAF_ZERO_INIT);
    /*
     * Was there enough memory to allocate this block?
     */
    if (tokenStreamHandle == 0) {
	/* error */
	DisplayUserError(@FFMemoryFullError);
	return;
    }

    if (FFD_ParserParseString(stringHandle,
			tokenStreamHandle,
			MAX_TOKEN_STREAM_SIZE,
			oself,
			&numTokens,
			&errOffsets) == FALSE) {
	/*
	 * An error occurred.  Call the expression builder to edit the
	 * string again, highlighting the problem area.
	 */
	MemFree(tokenStreamHandle);
	pself = ObjDerefGen(oself);
	@send (pself->FFI_expressionBuilderOptr)::
	    MSG_FFEB_EDIT_EXPRESSION(stringHandle,
				     errOffsets.VTR_start,
				     errOffsets.VTR_end,
				     oself,
				     MSG_FFD_PARSE_EXPRESSION);
    } else {
	/*
	 * The string parsed!  Return the token stream to the
	 * result destination (set in MSG_FFD_EDIT_EXPRESSION),
	 * and tell the expression builder to shut down.
	 */
	MemFree(stringHandle);
	pself = ObjDerefGen(oself);
	@send (pself->FFI_expressionBuilderOptr)::MSG_FFEB_CLOSE_DOWN();

	pself = ObjDerefGen(oself);
	@send {MSG_FFD_PARSE_RETURN_TEMPLATE}
	    (pself->FFI_tokenStreamDestOptr)::
			(pself->FFI_tokenStreamDestMsg)
				(tokenStreamHandle, numTokens);

#if ERROR_CHECK
	pself = ObjDerefGen(oself);
	pself->FFI_tokenStreamDestOptr   = NullOptr;
	pself->FFI_tokenStreamDestMsg    = 0;
	pself->FFI_expressionBuilderOptr = NullOptr;
#endif	
    }
}

/***********************************************************************
 *
 * FUNCTION:	FFDEvaluateDefaultExpression
 *
 * DESCRIPTION:	This function evaluates a field's default expression
 *	    	and puts the results of the evaluation in a passed buffer.
 *	    	The PSEE eval error code is returned.
 *
 * PARAMETERS:	oself - an optr to the current database
 *	    	fieldNum - the field's column
 *	    	resultBuffer - pointer to a buffer to place the evaluation
 *	    	    	       results.  NOTE!  This buffer must be
 *	    	    	       EVAL_BUFFER_SIZE bytes big.
 *
 * CALLED BY:	INTERNAL
 *
 * STRATEGY:
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	5/27/92		Initial Revision
 *
 ***********************************************************************/
int
FFDEvaluateDefaultExpression(optr oself, FieldID fieldNum, byte *resultBuffer)
{
    FlatFileDatabaseInstance *pself;
    CellFormula *tsa;
    byte defaultTokenStream[MAX_TOKEN_STREAM_SIZE];

    pself = ObjDerefGen(oself);
    tsa = CellLock(&pself->SSI_cellParams, FIELD_DEFAULT_VALUE_ROW,
		   (word) fieldNum);

#if ERROR_CHECK
    if (!tsa) {
	EC_ERROR(NO_TOKEN_STREAM);
    }
#endif /* ERROR_CHECK */

    /*
     * If there is a formula to evaluate, eval the thing.
     */
    if (tsa->CF_formulaSize) {

	memcpy(defaultTokenStream, (char *) tsa + sizeof(CellFormula),
	       tsa->CF_formulaSize);

	/*
	 * Release the token stream cell.
	 */
	CellUnlock(tsa);
    
	/*
	 * Evaluate the stream and return its value.
	 */
	return(FFD_EvaluateExpression(defaultTokenStream, resultBuffer,
				      TEMP_DATA_ROW, oself));
    }

    /*
     * If we got this far, then there's no formula to evaluate.  Load
     * up the result buffer with an ESAT_EMPTY, push a dummy variable,
     * and return.
     */
    CellUnlock(tsa);
    resultBuffer[0] = ESAT_EMPTY;
    Float0();

    return (0);
}


/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		MSG_FFD_PARSE_PARSE_STRING
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

DESCRIPTION:	Parse the given string into a token stream.

PASS: 		MemHandle	stringHandle	= Handle of block
						  containing expression.
		MemHandle	tokenBufferHandle
						= Handle of block in which
						  to place the tokenized
						  expression stream.
		word	tokenBufferSize		= Size of given token
						  stream block.
		word	*numTokens		= ???
		VisTextRange	*errorOffsetPtr	= ???

RETURN:		Boolean	= FALSE iff unsuccesful.
			  TRUE if successfully parsed the given expression.
		*numTokens	= Number of tokens in the token stream.
		*errorOffsetPtr	= Starting and ending offsets in the given
				  expression string where the error
				  occurred.

SIDE EFFECTS:
	Requires:	???

	Asserts:	???

CHECKS:		None.

PSEUDO CODE/STRATEGY:
	Pass off all of the work to FFD_ParserParseString().

KNOWN DEFECTS/CAVEATS/IDEAS:	???

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	JDM	93.01.11	Initial version.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/

@extern method FlatFileDatabaseClass, MSG_FFD_PARSE_PARSE_STRING
{
    return (FFD_ParserParseString (stringHandle,
				   tokenBufferHandle,
				   tokenBufferSize,
				   oself,
				   numTokens,
				   errorOffsetPtr));
}	/* End of MSG_FFD_PARSE_PARSE_STRING.	*/

/***********************************************************************
 *
 * FUNCTION:	FFD_ParserParseString
 *
 * DESCRIPTION: This function calls the parse library to parse a string
 *	    	into a token stream.  Error messages are displayed here.
 *
 *	    	If an error occurred, FALSE will be returned.
 *	    	Otherwise, TRUE will be.
 *
 * PARAMETERS:  string - pointer to string to parse
 *	    	tokenBuffer - Zero-initialized buffer where the token stream
 *	    	 is to be placed
 *		tokenBufferSize - size of the token buffer (in bytes)
 *	    	ffdOptr - flat file object optr
 *	    	numTokens - pointer to a word to be filled with the number
 *	    	 of tokens in the new token stream.
 *	    	errorOffsetPtr - pointer to a VisTextRange.  VTR_start
 *	    	 and VTR_end will outline problem areas if an error
 *	    	 occurs.
 *
 * CALLED BY:	INTERNAL
 *
 * STRATEGY:
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	4/17/92		Initial Revision
 *
 ***********************************************************************/
Boolean
FFD_ParserParseString(MemHandle stringHandle,
		MemHandle tokenBufferHandle,
		word tokenBufferSize,
		optr ffdOptr,
		word *numTokens,
		VisTextRange *errorOffsetPtr)
{
    CParserStruct parserParams;
    CParserReturnStruct retStruct;
    FlatFileDatabaseInstance *ffdInstance;
    TCHAR *string, *error;
    byte *tokenBuffer;
    int i;

    string = MemLock(stringHandle);
    tokenBuffer = MemLock(tokenBufferHandle);

    /* If the string is empty, no need to parse. */
    if (strlen(string) == 0) {
	tokenBuffer[0] = PARSER_TOKEN_END_OF_EXPRESSION;
	*numTokens = 0;
	MemUnlock(stringHandle);
	MemUnlock(tokenBufferHandle);
	return TRUE;
    }

    /*
     * Load up the parser parameters structure.
     */
    ffdInstance = ObjDerefGen(ffdOptr);
    parserParams.C_parameters.PP_common.CP_row = ffdInstance->SSI_active.CR_row;
    parserParams.C_parameters.PP_common.CP_column = ffdInstance->SSI_active.CR_column;
    parserParams.C_parameters.PP_common.CP_maxRow = TEMP_DATA_ROW;
    parserParams.C_parameters.PP_common.CP_maxColumn = ffdInstance->SSI_maxCol;
    parserParams.C_parameters.PP_common.CP_cellParams = ffdInstance;
    parserParams.C_parameters.PP_parserBufferSize = tokenBufferSize;
    parserParams.C_parameters.PP_flags = PF_OPERATORS |
	    	    	    	    	 PF_NUMBERS |
					 PF_FUNCTIONS |
					 PF_NAMES;
    parserParams.C_callbackPtr = FFDParseLibraryCallback;

    /* Ask the parse library to turn it into a token stream. */
    if (ParserParseString(string, tokenBuffer, &parserParams, &retStruct)) {
	/*
	 * An error occurred.  Display an error message, set up
	 * the text offsets to the problem area, then return with an
	 * error flag.
	 */

        (void) MemLock(HandleOf(FFDErrorTextTable[retStruct.PRS_errorCode]));
        error = LMemDeref(FFDErrorTextTable[retStruct.PRS_errorCode]);

	(void) UserStandardDialog(
	    	(TCHAR *)0,
                /* not GIT_MULTIPLE_RESPONSE, so no custom triggers  */
                (TCHAR *)0,
                /* One string argument: the error code. */
                (TCHAR *)0, error,
                /* dialog string */
                _TEXT("\001"),
                /* dialog type */
                (CDT_ERROR << CDBF_DIALOG_TYPE_OFFSET) |
                /* interaction type */
                (GIT_NOTIFICATION << CDBF_INTERACTION_TYPE_OFFSET));

	errorOffsetPtr->VTR_start = (dword) retStruct.PRS_textOffsetStart;
	errorOffsetPtr->VTR_end = (dword) retStruct.PRS_textOffsetEnd;
	MemUnlock(stringHandle);
	MemUnlock(tokenBufferHandle);
        MemUnlock(HandleOf(FFDErrorTextTable[retStruct.PRS_errorCode]));
	return FALSE;
    }

    /* Success! */
    MemUnlock(stringHandle);

    /*
     * Figure out how many tokens exist in the stream.
     */
    *numTokens = 0;
    for (i = tokenBufferSize - 1; i >= 0; i--) {
	if (tokenBuffer[i] == PARSER_TOKEN_END_OF_EXPRESSION) {
	    *numTokens = i + 1;
	    break;
	}
    }

    MemUnlock(tokenBufferHandle);
    return TRUE;
}

/***********************************************************************
 *
 * FUNCTION:	FFD_ParserFormatExpression
 *
 * DESCRIPTION:	This function calls the parse library to format
 *	    	a token stream into a string.
 *
 * PARAMETERS:	tokenStreamHandle - handle to a token stream
 *	    	textBuffer  	  - buffer in which to place the string
 *	    	ffdOptr	    	  - flat file object optr
 *
 * CALLED BY:	INTERNAL
 *
 * STRATEGY:
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	4/14/92		Initial Revision
 *
 ***********************************************************************/
void
FFD_ParserFormatExpression(MemHandle tokenStreamHandle,
			   TCHAR *textBuffer,
			   optr ffdOptr)
{
    CFormatStruct formatParams;
    FlatFileDatabaseInstance *ffdInstance;
    byte *tokenStream;

    /* Lock down the token stream. */
    tokenStream = MemLock(tokenStreamHandle);
    
    /*
     * Load up the format parameters structure.
     * Note that CP_callback in the common parameters is not used here.
     */
    ffdInstance = ObjDerefGen(ffdOptr);
    formatParams.CF_parameters.FP_common.CP_row = ffdInstance->SSI_active.CR_row;
    formatParams.CF_parameters.FP_common.CP_column = ffdInstance->SSI_active.CR_column;
    formatParams.CF_parameters.FP_common.CP_maxRow = TEMP_DATA_ROW;
    formatParams.CF_parameters.FP_common.CP_maxColumn = ffdInstance->SSI_maxCol;
    formatParams.CF_parameters.FP_common.CP_cellParams = ffdInstance;
    formatParams.CF_parameters.FP_nChars = MAX_EXPRESSION_STRING_LENGTH;
    formatParams.CF_callbackPtr = FFDParseLibraryCallback;

    /* Ask to parser library to turn it into a string. */
    (void) ParserFormatExpression(tokenStream, textBuffer, &formatParams);
}


/***********************************************************************
 *
 * FUNCTION:	FFD_EvaluateExpression
 *
 * DESCRIPTION:	This function evaluates a tokenized expression and returns
 *	    	its computed value.
 *	    	The PSEE eval error, if any, is returned.
 *
 * PARAMETERS:	tokenStream - address of the expression
 *	    	resultBuffer - where to put the results of the parsing.
 *	    	    	       NOTE!  Must be EVAL_BUFFER_SIZE bytes long!
 *	    	row - the row to operate on
 *	    	ffdOptr - optr to the current database.  Remember that
 *	    	    	  SSI_active.CR_row is very important here...
 *
 * CALLED BY:	INTERNAL
 *
 * STRATEGY:
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	5/26/92		Initial Revision
 *
 ***********************************************************************/
int
FFD_EvaluateExpression(byte *tokenStream,
		       byte *resultBuffer,
		       word row,
		       optr ffdOptr)
{
    CEvalStruct evalParams;
    FlatFileDatabaseInstance *ffdInstance;
    byte scratchBuffer[EVAL_BUFFER_SIZE];

    /*
     * Load up the eval parameters structure.
     */
    ffdInstance = ObjDerefGen(ffdOptr);
    evalParams.CE_parameters.EP_common.CP_row = row;
    evalParams.CE_parameters.EP_common.CP_column =
	ffdInstance->SSI_active.CR_column;
    evalParams.CE_parameters.EP_common.CP_maxRow = TEMP_DATA_ROW;
    evalParams.CE_parameters.EP_common.CP_maxColumn = ffdInstance->SSI_maxCol;
    evalParams.CE_parameters.EP_common.CP_cellParams = ffdInstance;
    evalParams.CE_parameters.EP_flags = 0;
    evalParams.CE_callbackPtr = FFDParseLibraryCallback;

    return (ParserEvalExpression(tokenStream, scratchBuffer, resultBuffer,
			   (word)EVAL_BUFFER_SIZE, &evalParams));
}


/***********************************************************************
 *
 * FUNCTION:	FFDGetTokenNumber
 *
 * DESCRIPTION:	This function returns the token number for a specific
 *	    	column's field.  If no such field, then -1 is returned.
 *
 * PARAMETERS:	oself - an optr to the current database
 *	    	colNum - the column of the field
 *
 * CALLED BY:	INTERNAL
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	6/25/92		Initial version
 *
 ***********************************************************************/
word
FFDGetTokenNumber(optr oself, FieldID colNum)
{
    FieldDataAttrs *cellDataPtr;
    FlatFileDatabaseInstance *pself;
    word retval;

    pself = ObjDerefGen(oself);

    /* 
     * Lock the cell 
     */
    cellDataPtr = CellLock(&pself->SSI_cellParams,
	     		   FIELD_TYPE_ROW, 
     	     		   colNum);
		
#if ERROR_CHECK
    if (!cellDataPtr) {
	EC_ERROR(CELL_DOES_NOT_EXIST);
    }
#endif /* ERROR_CHECK */
    
    if (cellDataPtr) {
	retval = cellDataPtr->FDA_nameToken;
        CellUnlock(cellDataPtr);
	return retval;
    }

    return -1;
}

/***********************************************************************
 *
 * FUNCTION:	FFDFunctionToToken
 *
 * Description:
 *	Convert a function name to a function id token.
 *	NOTE: we ALWAYS return a mo match flag..
 *
 * Pass:
 *	Pointer to CT_FTT_CallbackStruct:
 *	callbackType  	= CT_FUNCTION_TO_TOKEN
 *	params 	      	= Pointer to ParserParameters
 *	text   	    	= Pointer to the text of the identifier
 *	length 	    	= Length of the identifier
 *
 * Return:
 *	isFunctionName 	= set this to non-zero if the text is a function name
 *	funcID	      	= The Function-ID for the identifier
 *
 * CALLED BY:	INTERNAL
 *
 * STRATEGY:
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	4/15/92		Initial Revision
 *
 ***********************************************************************/
void _near
FFDFunctionToToken(C_CallbackStruct *cb_s)
{
    /* Say that there is no match for this function. */
    cb_s->C_u.CT_ftt.isFunctionName = FALSE;
}

/***********************************************************************
 *
 * FUNCTION:	FFDNameToToken
 *
 * Description:
 *	Convert a name to a name id token.
 * Pass:
 *	CT_NTT_CallbackStruct:
 *	callbackType  	= CT_NAME_TO_TOKEN
 *	params 	    	= Pointer to ParserParameters
 *	text   	    	= Pointer to the text of the identifier
 *	length 	    	= Length of the identifier
 * Return:
 *	nameID	      	= Token for the name
 *	errorOccurred 	= set to non-zero if an error occurred.
 *	error	     	= error code
 *
 * CALLED BY:	INTERNAL
 *
 * STRATEGY:
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	4/15/92		Initial Revision
 *
 ***********************************************************************/
void _near
FFDNameToToken(C_CallbackStruct *cb_s)
{
    /*
     * Call the spreadsheet to deal with this.  All return values are 
     * set correctly.
     */
    SpreadsheetParseNameToToken(cb_s);
}

/***********************************************************************
 *
 * FUNCTION:	FFDCheckNameExists
 *
 * Description:
 *	Check to see if a name already exists
 * Pass:
 *	pointer to CT_CNE_CallbackStruct:
 *
 *	callbackType  	= CT_CHECK_NAME_EXISTS
 *	params 	    	= Pointer to ParserParameters
 *	text   	    	= Pointer to the text of the identifier
 *	length 	    	= Length of the identifier
 * Return:
 *	nameExists  	= non-zero if the name does exist
 * CALLED BY:	INTERNAL
 *
 * STRATEGY:
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	4/15/92		Initial Revision
 *
 ***********************************************************************/
void _near
FFDCheckNameExists(C_CallbackStruct *cb_s)
{
    FlatFileDatabaseInstance *pself;
    word nameToken;
    NameFlags nameFlags;

    /* Get the pointer to the flat file instance. */
    pself = cb_s->C_params.CP_params->PP_common.CP_cellParams;

    cb_s->C_u.CT_cne.nameExists = SpreadsheetNameTokenFromText(
						  (SpreadsheetInstance *) pself,
						  cb_s->C_u.CT_cne.text,
				     	    	  cb_s->C_u.CT_cne.length,
				     	    	  &nameToken,
				     	    	  &nameFlags);
}

/***********************************************************************
 *
 * FUNCTION:	FFDCheckNameSpace
 *
 * Description:
 *	Signal the need to allocate a certain number of names.
 *	This is used to avoid the problem of getting part way through
 *	allocating names for an expression and then finding we don't
 *	have any more space for names.
 * Pass:
 *	Pointer to CT_CNS_CallbackStruct:
 *
 *	callbackType  	= CT_CHECK_NAME_SPACE
 *	params 	    	= Pointer to ParserParameters
 *	numToAllocate 	= # of names we want to allocate
 * Return:
 *	enoughSpace 	= set to non-zero if there was enough space.
 *	errorOccurred 	= set to non-zero if an error occurred.
 *	error	     	= error code
 *
 * CALLED BY:	INTERNAL
 *
 * STRATEGY:
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	4/15/92		Initial Revision
 *
 ***********************************************************************/
void _near
FFDCheckNameSpace(C_CallbackStruct *cb_s)
{
    /* For now, assume that we have enough name space. */
    cb_s->C_u.CT_cns.enoughSpace = TRUE;
    cb_s->C_u.CT_cns.errorOccurred = FALSE;
}

/***********************************************************************
 *
 * FUNCTION:	FFDEvalFunction
 *
 * Description:
 *	Evaluate a function with parameters.
 * Pass:
 *	pointer to CT_EF_CallbackStruct:
 *
 *	callbackType  	= CT_CHECK_NAME_EXISTS
 *	params 	    	= Pointer to EvalParameters
 *	numArgs	    	= # of arguments
 *	funcID	    	= Function ID
 * Return:
 *	errorOccurred 	= set to non-zero if an error occurred.
 *	error	     	= error code
 *
 * CALLED BY:	INTERNAL
 *
 * STRATEGY:
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	4/15/92		Initial Revision
 *
 ***********************************************************************/
void _near
FFDEvalFunction(C_CallbackStruct *cb_s)
{
    EC_ERROR(UNSUPPORTED_PARSER_CALLBACK);
}

/***********************************************************************
 *
 * FUNCTION:	FFDLockName
 *
 * Description:
 *	Lock a name definition.
 * Pass:
 *	Pointer to CT_LN_CallbackStruct
 *
 *	callbackType  	= CT_LOCK_NAME
 *	params 	    	= Pointer to ParserParameters
 *	nameToken   	= Name token
 * Return:
 *	defPtr	    	= Far pointer to the definition
 *	errorOccurred 	= set to non-zero if an error occurred
 *	error	     	= error code
 *
 * CALLED BY:	INTERNAL
 *
 * STRATEGY:
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	4/15/92		Initial Revision
 *
 ***********************************************************************/
void _near
FFDLockName(C_CallbackStruct *cb_s)
{
    FlatFileDatabaseInstance *pself;
    byte error;

    /* Get the pointer to the flat file instance. */
    pself = cb_s->C_params.CE_params->EP_common.CP_cellParams;

    /*
     * Lock the name.
     */
    error = SpreadsheetNameLockDefinition((SpreadsheetInstance *) pself,
					  cb_s->C_u.CT_ln.nameToken,
					  (void **) &(cb_s->C_u.CT_ln.defPtr));

    cb_s->C_u.CT_ln.error = error;
    cb_s->C_u.CT_ln.errorOccurred = (error ? TRUE : FALSE);
}


/***********************************************************************
 *
 * FUNCTION:	FFDUnlock
 *
 * Description:
 *	Unlock a name/function definition.
 * Pass:
 *	Pointer to CT_UL_CallbackStruct:
 *
 *	callbackType  	= CT_UNLOCK
 *	params 	    	= Pointer to ParserParameters
 *	dataPtr	    	= Pointer to data to unlock
 * Return:
 *	nothing
 *
 * CALLED BY:	INTERNAL
 *
 * STRATEGY:
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	4/15/92		Initial Revision
 *
 ***********************************************************************/
void _near
FFDUnlock(C_CallbackStruct *cb_s)
{
    CellUnlock(cb_s->C_u.CT_ul.dataPtr);
}

/***********************************************************************
 *
 * FUNCTION:	FFDFormatFunction
 *
 * Description:
 *	Format a function name into a buffer.
 * Pass:
 *	Pointer to CT_FF_CallbackStruct:
 *
 *	callbackType  	= CT_FORMAT_FUNCTION
 *	params	    	= Pointer to ParserParameters
 *	textPtr	    	= Pointer to place to store the text
 *	funcToken    	= Function token
 *	maxChars    	= Maximum number of characters that can be written
 * Return:
 *	resultPtr   	= Pointer past the inserted text
 *	numWritten  	= # of characters that were written
 *
 * CALLED BY:	INTERNAL
 *
 * STRATEGY:
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	4/15/92		Initial Revision
 *
 ***********************************************************************/
void _near
FFDFormatFunction(C_CallbackStruct *cb_s)
{
    TCHAR funcNameBuffer[MAX_FUNCTION_STRING_LENGTH];
    word len;
    
#if ERROR_CHECK
    /* If this is a bogus function ID, sound the alarms. */
    if (cb_s->C_u.CT_ff.funcToken > ParserGetNumberOfFunctions(FT_ALL) - 1) {
	EC_ERROR(BAD_FUNCTION_ID);
    }

    if (cb_s->C_u.CT_ff.maxChars >= MAX_FUNCTION_STRING_LENGTH) {
	EC_ERROR(BAD_MAX_FUNCTION_STRING_LENGTH);
    }
#endif /* ERROR_CHECK */    

    /* Get the function's name. */
    len = ParserGetFunctionMoniker(cb_s->C_u.CT_ff.funcToken, FT_ALL, funcNameBuffer);

    /* Be absoultely sure that the name is NULL-terminated. */ 
    funcNameBuffer[cb_s->C_u.CT_ff.maxChars] = _TEXT('\0');

    len = (len <= cb_s->C_u.CT_ff.maxChars ? len : cb_s->C_u.CT_ff.maxChars);
    strcpy(cb_s->C_u.CT_ff.textPtr, funcNameBuffer);
    cb_s->C_u.CT_ff.resultPtr = (TCHAR *) cb_s->C_u.CT_ff.textPtr + len;
    cb_s->C_u.CT_ff.numWritten = len;
}


/***********************************************************************
 *
 * FUNCTION:	FFDFormatName
 *
 * Description:
 *	Format a name into a buffer.
 * Pass:
 *	Pointer to CT_FN_CallbackStruct:
 *
 *	callbackType  	= CT_FORMAT_NAME
 *	params	    	= Pointer to ParserParameters
 *	textPtr	    	= Pointer to place to store the text
 *	nameToken    	= Name token
 *	maxChars    	= Maximum number of characters that can be written
 * Return:
 *	resultPtr   	= Pointer past the inserted text
 *	numWritten  	= # of characters that were written
 *
 * CALLED BY:	INTERNAL
 *
 * STRATEGY:
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	4/15/92		Initial Revision
 *
 ***********************************************************************/
void _near
FFDFormatName(C_CallbackStruct *cb_s)
{
    FlatFileDatabaseInstance *pself;
    word numChars;

    /* Get the pointer to the flat file instance. */
    pself = cb_s->C_params.CP_params->PP_common.CP_cellParams;

    numChars = SpreadsheetNameTextFromToken((SpreadsheetInstance *) pself,
					    cb_s->C_u.CT_fn.nameToken,
					    cb_s->C_u.CT_fn.textPtr,
					    cb_s->C_u.CT_fn.maxChars);

    cb_s->C_u.CT_fn.resultPtr = (TCHAR *) cb_s->C_u.CT_fn.textPtr + numChars;
    cb_s->C_u.CT_fn.numWritten = numChars;
}


/***********************************************************************
 *
 * FUNCTION:	FFDCreateCell
 *
 * Description:
 *	Create a new empty cell. Used by the dependency code to
 *	create a cell to add dependencies to.
 * Pass:
 *	Pointer to CT_CC_CallbackStruct:
 *
 *	callbackType  	= CT_CREATE_CELL
 *	params 	    	= Pointer to DependencyParameters
 *	row 	    	= Row of the cell to create
 *	column	    	= Column of the cell to create
 * Return:
 *	errorOccurred 	= set to non-zero if an error occurred
 *	error	     	= error code
 *
 * CALLED BY:	INTERNAL
 *
 * STRATEGY:
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	4/15/92		Initial Revision
 *
 ***********************************************************************/
void _near
FFDCreateCell(C_CallbackStruct *cb_s)
{
    /*
     * Call the spreadsheet to deal with this.  All return values are 
     * set correctly.
     */
    SpreadsheetParseCreateCell(cb_s);
}


/***********************************************************************
 *
 * FUNCTION:	FFDEmptyCell
 *
 * Description:
 *	Remove a cell if it's appropriate. This is called when a cell
 *	has its last dependency removed.
 * Pass:
 *	Pointer to CT_EC_CallbackStruct:
 *
 *	callbackType  	= CT_EMPTY_CELL
 *	params 	    	= Pointer to ParserParameters
 *	row 	    	= Row of the cell that now has no dependencies
 *	column	    	= Column of the cell that now has no dependencies
 * Return:
 *	errorOccurred 	= set to non-zero if an error occurred
 *	error	     	= error code
 *
 * CALLED BY:	INTERNAL
 *
 * STRATEGY:
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	4/15/92		Initial Revision
 *
 ***********************************************************************/
void _near
FFDEmptyCell(C_CallbackStruct *cb_s)
{
    /*
     * Call the spreadsheet to deal with this.  All return values are 
     * set correctly.
     */
    SpreadsheetParseEmptyCell(cb_s);
}


/***********************************************************************
 *
 * FUNCTION:	FFDNameToCell
 *
 * Description:
 *	Convert a name to a cell so we can add a dependency to it.
 * Pass:
 *	Pointer to CT_NTC_CallbackStruct:
 *
 *	callbackType  	= CT_NAME_TO_CELL
 *	params 	    	= Pointer to ParserParameters
 *	nameToken   	= Name token
 * Return:
 *	row 	    	= Row of the cell containing the names dependencies
 *	column	    	= Column of the cell containing the names dependencies
 *
 * CALLED BY:	INTERNAL
 *
 * STRATEGY:
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	4/15/92		Initial Revision
 *
 ***********************************************************************/
void _near
FFDNameToCell(C_CallbackStruct *cb_s)
{
    /*
     * Give the NAME_ROW for the row, and the passed column number
     * for the column.  Simple.
     */
    cb_s->C_u.CT_ntc.row = NAME_ROW;
    cb_s->C_u.CT_ntc.column = cb_s->C_u.CT_ntc.nameToken;
}


/***********************************************************************
 *
 * FUNCTION:	FFDFunctionToCell
 *
 * Description:
 *	Convert a function to a cell so we can add a dependencies to
 *	it.
 * Pass:
 *	Pointer to CT_FTC_CallbackStruct:
 *
 *	callbackType  	= CT_FUNCTION_TO_CELL
 *	params 	    	= Pointer to ParserParameters
 *	funcID	    	= Function-ID
 * Return:
 *	row 	    	= Row of the cell containing the functions dependencies
 *	    	    	= 0 if no dependency is required
 *	column	    	= Column of the cell containing the functions
 *
 * CALLED BY:	INTERNAL
 *
 * STRATEGY:
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	4/15/92		Initial Revision
 *
 ***********************************************************************/
void _near
FFDFunctionToCell(C_CallbackStruct *cb_s)
{
    /*
     * Since we don't support new functions, set the row to 0 (which is
     * what the spreadsheet does).
     */
    cb_s->C_u.CT_ftc.row = 0;
}


/***********************************************************************
 *
 * FUNCTION:	FFDDerefCell
 *
 * Description:
 *	Get the contents of a cell. The callback is responsible for
 *	popping the cell reference off the stack.
 * Pass:
 *	Pointer to CT_DC_CallbackStruct:
 *
 *	callbackType  	= CT_DEREF_CELL
 *	params 	    	= Pointer to EvalParameters
 *	argStack    	= Pointer to the argument stack
 *	opFnStack   	= Pointer to operator/function stack
 *	row 	    	= Row of the cell to dereference
 *	column	    	= Column of the cell to dereference
 *	derefFlags  	= DerefFlags
 * Return:
 *	newArgStack 	= New pointer to the argument stack
 *	errorOccurred 	= set to non-zero if an error occurred
 *	error	     	= error code
 *
 * CALLED BY:	INTERNAL
 *
 * STRATEGY:
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	4/15/92		Initial Revision
 *
 ***********************************************************************/
void _near
FFDDerefCell(C_CallbackStruct *cb_s)
{
    /*
     * Call the spreadsheet to deal with this.  All return values are 
     * set correctly.
     */
    SpreadsheetParseDerefCell(cb_s);
}


/***********************************************************************
 *
 * FUNCTION:	FFDSpecialFunction
 *
 * Description:
 *	Get the value of one of the special functions.
 * Pass:
 *	Pointer to CT_SF_CallbackStruct:
 *
 *	callbackType  	= CT_SPECIAL_FUNCTION
 *	params 	    	= Pointer to EvalParameters
 *	argStack    	= Pointer to the argument stack
 *	opFnStack   	= Pointer to operator/function stack
 *	specialFunction	= Special function
 * Return:
 *	newArgStack 	= New pointer to the argument stack
 *	errorOccurred 	= set to non-zero if an error occurred
 *	error	     	= error code
 *
 * CALLED BY:	INTERNAL
 *
 * STRATEGY:
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	4/15/92		Initial Revision
 *
 ***********************************************************************/
void _near
FFDSpecialFunction(C_CallbackStruct *cb_s)
{
    EC_ERROR(UNSUPPORTED_PARSER_CALLBACK);
}

/***********************************************************************
 *
 * FUNCTION:	FFDParseLibraryCallback
 *
 * DESCRIPTION:	This function is the main callback handler for all
 *	    	parse library functions.
 *	    	
 * PARAMETERS:	callbackStruct - pointer to a structure that contains
 *	    	the callback type, appropriate passed parameters, and
 *	    	variables in which return values are placed.
 *
 * CALLED BY:	INTERNAL
 *
 * STRATEGY:
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	4/15/92		Initial Revision
 *
 ***********************************************************************/
void _pascal
FFDParseLibraryCallback(C_CallbackStruct *callbackStruct)
{
    typedef void _near CBFunction(C_CallbackStruct *);
    CBFunction *functable[] = {
	 FFDFunctionToToken, FFDNameToToken, FFDCheckNameExists,
	 FFDCheckNameSpace, FFDEvalFunction, FFDLockName, FFDUnlock,
	 FFDFormatFunction, FFDFormatName, FFDCreateCell, FFDEmptyCell,
	 FFDNameToCell, FFDFunctionToCell, FFDDerefCell, FFDSpecialFunction
    };

    /* Call the appropriate function. */
    (functable[callbackStruct->C_callbackType])(callbackStruct);
}
