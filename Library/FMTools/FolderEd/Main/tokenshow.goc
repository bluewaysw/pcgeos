/**************************************************************************
 *	Project: IconEdit file manager tool
 *
 *	File:	tokenshow.goc
 *		Rouines that deal with displaying token monikers
 *
 *	By RABE-Soft, Rainer Bettsteller, for Free PC/GEOS Project
 *
 **************************************************************************/

@include <stdapp.goh>
@include <fmtool.goh>
#include <Ansi/string.h>
#include <Ansi/stdio.h>
#include <token.h>

@include "foldered.goh"
@include "UI/fedui.goh"

extern optr		g_dialog = NullOptr;
extern MemHandle 	g_mh;
extern MemHandle	g_tokenList;
extern	word		g_displaySize;
extern	word		g_tokenStyle;


/*--------------------- InternalGetTokenMonikerBlock ---------------------
 * Purpose:	Get the moniker in a memory block
 *		Allways try to fetch true color gstring moniker
 * Pass		dispSize DS_TINY  0
 *			DS_STANDARD  1
 *			DS_LARGE  2
 *			DS_HUGE  3
 *		style	VMS_TEXT  0
 *			VMS_ABBREV_TEXT  1
 *			VMS_GRAPHIC_TEXT  2
 *			VMS_ICON  3
 *			VMS_TOOL  4
 * 		*monikerSize: return: bytes read
 * Return:	Handle of memory block containing the moniker image
 ---------------------------------------------------------------------------*/
// swat stop in foldered::InternalGetTokenMonikerBlock
MemHandle InternalGetTokenMonikerBlock(GeodeToken token, 
				word dispSize, word style, 
				word *monikerSize) {
dword tokenDW;
MemHandle mh;
Boolean	found;

    mh = 0;
    memcpy(&tokenDW, &token.GT_chars[0], 4);

	/*
	 * TokenLoadMonikerBlock returns an 'alternative' moniker if the
	 * passed displaySize/style combination was not found
	 * e.g it retuns the 16 color moniker if no true color and
	 * no 8 bit color moniker was found
	 */
    found = TokenLoadMonikerBlock( tokenDW, token.GT_manufID,
	(dispSize << DT_DISP_SIZE_OFFSET)|
	(DAR_NORMAL << DT_DISP_ASPECT_RATIO_OFFSET)|
	DC_CF_RGB, 
	(style << VMSF_STYLE_OFFSET) | VMSF_GSTRING,
	monikerSize, &mh );

    if ( !found ) {
    	*monikerSize = 0;
    	return 0;
    	}
    return mh;
	
}




/*-------------------------------------------------------------
 *	FEDTokenIdToText
 *-------------------------------------------------------------
 *	convert token to text like "GDAT,0"
 *	return 'centered' text, if minLen > len(plain-token-id-text)
 *		you may pass zero to minLen
 -------------------------------------------------------------*/
// swat stop in foldered::FEDTokenIdToText 
void FEDTokenIdToText(GeodeToken tok, int minLen, char *retBuf) {
char buf[15];
int  n, left, l;

    /* setup token string */
    for ( n = 0; n< 4; n++ ) if (tok.GT_chars[n]==0) {tok.GT_chars[n]='-'; }
    sprintf(buf, "%c%c%c%c,%u", tok.GT_chars[0], tok.GT_chars[1], 
    			tok.GT_chars[2], tok.GT_chars[3], tok.GT_manufID);

    /*
     * center string, if minLen > strlen(buf)
     */
    l= strlen(buf);
    left = (minLen - (int)strlen(buf))/2;	// spaces on the left side
    if (left < 0) left = 0;
    retBuf[0] = 0;
    while (strlen(retBuf) < left) strcat(retBuf, " ");
    
    strcat(retBuf, buf);
    while( strlen(retBuf) < minLen) strcat(retBuf, " ");	    			
    
}

/*-------------------------------------------------------------
 *	FEDShowTokenMoniker
 *-------------------------------------------------------------
 *	Display Icon Moniker and ID
 *	fileType is used to replace moniker, if token was not found
 -------------------------------------------------------------*/
// swat stop in foldered::FEDShowTokenMoniker 
void  FEDShowTokenMoniker(GeodeToken tok, optr monikerObj, GeosFileType fileType) {
MemHandle	mh;
//word 		sizeRead;

dword tokenDW;
Boolean	found;
word monikerSize;

    mh = 0;
    memcpy(&tokenDW, &tok.GT_chars[0], 4);

// µµ Replace muss noch gemacht werden

{ fileType = fileType; }

/*-------- TokenLoadMonikerBlock --------------------- */
@if 0
-- Anzeige OK, Fehlerwerte OK

    found = TokenLoadMonikerBlock( tokenDW, tok.GT_manufID,
	(g_displaySize << DT_DISP_SIZE_OFFSET)|
	(DAR_NORMAL << DT_DISP_ASPECT_RATIO_OFFSET)|
	DC_CF_RGB, 
	(g_tokenStyle << VMSF_STYLE_OFFSET) | VMSF_GSTRING,

	&monikerSize, &mh );

    if ( found ) {
    	@call monikerObj::MSG_GEN_REPLACE_VIS_MONIKER(VUM_NOW, 
				30,48,monikerSize,
				VMDT_VIS_MONIKER ,VMST_FPTR,(dword)MemLock(mh));
	MemFree(mh);
	}
    else {
    	char buf[30];
    	sprintf(buf, "mh=%u,sz=%u", mh, monikerSize);
	@call monikerObj::MSG_GEN_REPLACE_VIS_MONIKER_TEXT(buf, 0);
	}	
@endif
/*
   _pascal TokenLoadMonikerBlock (dword tokenChars,
			  ManufacturerID manufacturerID,
			  DisplayType displayType,
			  VisMonikerSearchFlags searchFlags,
			  
			  word *blockSize,
			  MemHandle *blockHandle);
*/

/*
	_pascal TokenLoadMonikerChunk (dword tokenChars,
			  ManufacturerID manufacturerID,
			  DisplayType displayType,
			  VisMonikerSearchFlags searchFlags,
			  
			  MemHandle lmemBlock,
			  word *chunkSize,
			  ChunkHandle *chunkHandle);
*/			  

/*
extern Boolean /*XXX
    _pascal TokenLoadMonikerBuffer (dword tokenChars,
			   ManufacturerID manufacturerID,
			   DisplayType displayType,
			   VisMonikerSearchFlags searchFlags,
			   
			   void *buffer,
			   word bufferSize,
			   word *bytesReturned);
*/

/*-------- TokenLoadMonikerChunk --------------------- */
/*
	_pascal TokenLoadMonikerChunk (dword tokenChars,
			  ManufacturerID manufacturerID,
			  DisplayType displayType,
			  VisMonikerSearchFlags searchFlags,
			  
			  MemHandle lmemBlock,
			  word *chunkSize,
			  ChunkHandle *chunkHandle);
*/
@if 0
{

ChunkHandle cnk;
-- Anzeige OK, Fehlerwerte OK

  mh = MemAllocLMem(LMEM_TYPE_GENERAL,0);
  
    found = TokenLoadMonikerChunk( tokenDW, tok.GT_manufID,
	(g_displaySize << DT_DISP_SIZE_OFFSET)|
	(DAR_NORMAL << DT_DISP_ASPECT_RATIO_OFFSET)|
	DC_CF_RGB, 
	(g_tokenStyle << VMSF_STYLE_OFFSET) | VMSF_GSTRING,

	mh, &monikerSize, &cnk );

    if ( found ) {
    	char buf[30];
    	sprintf(buf, "%u bytes", monikerSize);
	@call monikerObj::MSG_GEN_REPLACE_VIS_MONIKER_TEXT(buf, 0);
    	MemLock(mh);
/*    	@call monikerObj::MSG_GEN_REPLACE_VIS_MONIKER(VUM_NOW, 
				30,48,monikerSize,
				VMDT_VIS_MONIKER ,VMST_FPTR,(dword)LMemDerefHandles(mh, cnk));
*/	MemFree(mh);
	}
    else {
    	char buf[30];
    	sprintf(buf, "a=%u, b=%u", (word)cnk, monikerSize);
	@call monikerObj::MSG_GEN_REPLACE_VIS_MONIKER_TEXT(buf, 0);
	}	
}
@endif
/*-------- TokenLoadMonikerBuffer --------------------- */

/*
extern Boolean /*XXX
    _pascal TokenLoadMonikerBuffer (dword tokenChars,
			   ManufacturerID manufacturerID,
			   DisplayType displayType,
			   VisMonikerSearchFlags searchFlags,
			   
			   void *buffer,
			   word bufferSize,
			   word *bytesReturned);
*/
{
#include <stdlib.h>
void *buffer;


    buffer = malloc(4000);

    found = TokenLoadMonikerBuffer( tokenDW, tok.GT_manufID,
	(g_displaySize << DT_DISP_SIZE_OFFSET)|
	(DAR_NORMAL << DT_DISP_ASPECT_RATIO_OFFSET)|
	DC_CF_RGB, 
	(g_tokenStyle << VMSF_STYLE_OFFSET) | VMSF_GSTRING,

	buffer, 4000, &monikerSize);

    if ( found ) {
    	@call monikerObj::MSG_GEN_REPLACE_VIS_MONIKER(VUM_NOW, 
				30,48,monikerSize,
				VMDT_VIS_MONIKER ,VMST_FPTR,(dword)buffer);
	free(buffer);
	}
    else {
    	char buf[30];
    	sprintf(buf, "sz=%u", monikerSize);
	@call monikerObj::MSG_GEN_REPLACE_VIS_MONIKER_TEXT(buf, 0);
	}	

}

@if 0
    /*
     * Set up token moniker
     */
//    mh = 0;
//    memcpy(&tokenDW, &token.GT_chars[0], 4);
    
    mh = InternalGetTokenMonikerBlock(tok, g_displaySize, g_tokenStyle, &sizeRead);
	if ( mh ) {
		@call monikerObj::MSG_GEN_REPLACE_VIS_MONIKER(VUM_NOW, 
				30,48,sizeRead,
				VMDT_VIS_MONIKER ,VMST_FPTR,(dword)MemLock(mh));
		MemFree(mh);
		}
	else {
		@call monikerObj::MSG_GEN_REPLACE_VIS_MONIKER_TEXT("NOT found", 0);
			// µµ grafischer not found moniker
			// und/oder TRT
	}	
@endif	
@if 0
/* Replace-Typen fr Tokenazeige setzen */
  switch ( fileType ) {
  case GFT_NOT_GEOS_FILE:       if ( fileAttrs & FA_SUBDIR )
					*tokenReplaceType = TRT_SUBDIR;
				   else *tokenReplaceType = TRT_DOSFILE;
				*creatorReplaceType = TRT_DOSEXEC;
				break;
  case GFT_EXECUTABLE:          *tokenReplaceType = TRT_NO;
				*creatorReplaceType = TRT_GEOSEXEC;
				break;
  case GFT_DIRECTORY:		*tokenReplaceType = TRT_SUBDIR;
				*creatorReplaceType = TRT_GEOSEXEC;
				break;
  default:                      /* GFT_VM | GFT_DATA | GFT_LINK */
				*tokenReplaceType = TRT_NO;
				*creatorReplaceType = TRT_GEOSEXEC;
				break;
				}

/* Wenn DOS-File: Leertoken setzen */
  if (fileType == GFT_NOT_GEOS_FILE) {
	  TokShowFindDosTokens(fileName,fileAttrs,token,creator);
	  }
@endif

}


