/**************************************************************************
 *	GEODE-File for Token-Show Library
/**************************************************************************/

@include <stdapp.goh>
@include <file.h>
@include <token.h>
@include <stdio.h>
@include <string.h>

@include "Oldlibs/rstoks.goh"
@include "Art/art.goh"
//include "dosicon.goh"
@include "Oldlibs/toktoolinternals.goh"


/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  +		Header lokaler Routinen	und lokale Strukturen		    +
  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
/* ------- Anlegen der Token_confirm-Struktur --------------------*/
optr TokLocalGetCharsArray(optr idList,word tokID); 	// mit Anlegen eines neuen
void TokLocalInsertChars(optr charArray,dword tchars);
typedef struct {
	word 		manufID;	// die Manufacturer-ID
	ChunkHandle     charArray;	// das Handle des TopkenChar-Arrays
	} IDArrayElem;

/* Aufbau der TokenConfirm-Struktur
1. Zu jeder ManufacturerID gehîrt ein Chunk-Array, in dem die TokenChars
	(als DWord) abgelegt sind
2. Die Manuf-ID's werden in einem Chunk-Array verwaltet, das fÅr jede
	Manuf-ID einen Eintrag vom Typ IDArrayElem enthÑlt. Dies
	Chunk-Array ist der Ansprechpartner fÅr die gesamte Struktur
3.  Um die Suche zu beschleunigen, ist jedes Array intern sortiert. */

/* -------- Tools fÅr die Suche in der Token-Confirm-Struktur --------- */
int TokLocalFindIDIndex(optr idArray, word tokID, word * foundIndex);
int TokLocalFindCharsIndex(optr charArray, dword tchars, word * foundIndex);
// RÅckehrwerte fÅr TokLocalFindIDIndex und TokLocalFindCharsIndex
// Beschreibung siehe dort
#define	LFII_APPEND	0
#define	LFII_FOUND	1
#define	LFII_INSERT	2

@define SetAttrDesc(ad,attr,value,size) ad.FEAD_attr = attr; \
	ad.FEAD_value = value; ad.FEAD_size  = size;	ad.FEAD_name  = NULL;


/**************************************************************************
 *	Routine zur Anzeige von Icons
/**************************************************************************/

/*--------------------- TokShowDisplayToken ---------------------
 *	Aufgabe:	HauptRoutine zur Tokenanzeige
 *			Veranla·t das displayObjekt das Åbergebene Token als
 *			visMoniker anzuzeigen.
 * 			Zuvor wird geprÅft, ob das Token Åberhaupt in der
 *			Database ist (anhand der ConfirmParams)
 *	Ist tokenReplaceType != TRT_NO wird es notfalls ersetzt, wenn
 * 	tokenReplaceType == TRT_NO ist wird ein NotFoundMoniker angezeigt.
 ---------------------------------------------------------------------------*/

extern void EXPORT TokShowDisplayToken(optr displayObj, GeodeToken tok,
		word tokenReplaceType, ConfirmParams *cp) {
@if 1		
Boolean found;

	if ( displayObj == 0 ) return;
	found =	TokShowValidateToken(&tok,tokenReplaceType,cp);
	if ( (!found) && ( tokenReplaceType == TRT_NO) ) {
		@call displayObj::MSG_GEN_REPLACE_VIS_MONIKER_OPTR(
					@IconNotFoundMoniker,VUM_NOW);
		}
	    else {
		/* GeodeToken befindet sich auf den Stack -> Pointer ist OK */
		@call displayObj::MSG_GEN_REPLACE_VIS_MONIKER(
			VUM_NOW, 0,0,0,VMDT_TOKEN,VMST_FPTR,(dword)&tok);
		}
@endif
}

/*--------------------- TokShowDisplayTokenOfText ---------------------
 *	Aufgabe:	verhÑlt sich wie TokShowDisplayToken, nur das das
 *			Token als Token-String Åbergeben wurde
 *		movePointer: TRUE: text wird auf erstes Zeichen nach dem
 *			Token-String gesetzt, FALSE: text bleibt erhalten
 ---------------------------------------------------------------------------*/
extern void EXPORT TokShowDisplayTokenOfText(optr displayObj, char **text,
		word replaceTyp, ConfirmParams *cp, Boolean movePointer) {
@if 1
GeodeToken t;
char *p;

	p = *text;
	TokShowConvertTextToToken(&p,&t);
	TokShowDisplayToken(displayObj, t, replaceTyp,cp);
	if (movePointer) *text = p; /* evt Zeiger nach Text setzen */
	return;
@endif
}

/*--------------------- TokShowDisplayFileInfo ---------------------
 *	Aufgabe:	Anzeige von FileToken, CreatorToken,
 *			sowie der entsprechenden ID einer Datei durch die
 *			angegbenen Objekte. FÅr die Objekte kann ein NullOptr
 *			Åbergeben werden, wenn eine der Infos nicht angezeigt
 *			werden soll.
 *	  tMinL, cMinL: MinlÑngen fÅr DisplayIDString
 *	Return:		FileToken der Datei, fÅr anderweitige Verwendung
 ---------------------------------------------------------------------------*/
extern GeodeToken EXPORT TokShowDisplayFileInfo(
			optr tokenDisplayObj, optr tokenIDDisplayObj, int tMinL,
			optr creatorDisplayObj, optr creatorIDDisplayObj, int cMinL,
			ConfirmParams * cp,
			char *fileName,	DiskHandle dh, char *path) {
@if 1
word tokenReplaceType,creatorReplaceType, fileAttrs;
GeodeToken fileToken, creatorToken;


  FilePushDir();
  FileSetCurrentPath(dh,path);

/* Anzeige der Informationen */
  fileAttrs = TokShowGetFileInfo(fileName, &fileToken,
	&tokenReplaceType, &creatorToken, &creatorReplaceType);
  TokShowDisplayTokenAndID(tokenDisplayObj, tokenIDDisplayObj,
			fileToken, tokenReplaceType, cp, tMinL);
  TokShowDisplayTokenAndID(creatorDisplayObj,creatorIDDisplayObj,
			creatorToken, creatorReplaceType, cp, cMinL);

  FilePopDir();
  return fileToken;
@endif
}


/*--------------------- TokShowDisplayIDString ---------------------
 *	Aufgabe:	ID-String des Tokens durch das Objekt
 *			als VisMoniker anzeigen
 *	       minLen: 	MindestLÑnge des erzeugten Textes (max 20)
 *			Null, wenn nur so lang wie erforderlich
 *			>0 ( z.B.10 ) wenn Leerzeichen angehÑngt werden sollen,
 *			   solange der String kÅrzer als minLen ist
 *			   -> alte Texte kînnen sicher Åberschrieben werden
 ---------------------------------------------------------------------------*/
extern void EXPORT TokShowDisplayIDString(
		optr displayObj, GeodeToken tok, int minLen) {
@if 1		
char buffer[22],buffer2[22];
int n, pre;

   if ( displayObj == 0 ) return;
   if ( TestTokenFor(tok,0,0,0,0,0) ) {
	  buffer[0] ='-'; buffer[1] = 0;	/* kein Token */
	  }
	  else {
	     WriteTokenIDString(buffer,tok);
	     }
/* StringlÑnge anpassen */
   if ( minLen > 20 ) minLen = 20;
   n = strlen(buffer);
   memset(buffer2,' ',22);	// buffer 2 vorbereiten
   pre = 0;
   if ( minLen < 0 ) {   	// Hack: Symmetrie erzeugen
	minLen = -minLen;
	if ( minLen > 20 ) minLen = 20;
	if ( n < minLen)
		pre = (minLen-n) >> 1;
	}
   buffer2[pre] = 0;		// Terminator setzen
   strcat(buffer2,buffer);

   n = strlen(buffer2);
   while (n < minLen) { buffer2[n] = ' '; n++; buffer2[n] = 0; }
   @call displayObj::
		MSG_GEN_REPLACE_VIS_MONIKER_TEXT(buffer2,VUM_NOW);
@endif
}



/*--------------------- TokShowDisplayTokenAndID ---------------------
 *	Aufgabe:	Anzeige des Grafischen Tokens und des ID-Strings
 *		replaceType, cp : siehe TokShowDisplayToken
 *	        idMinLen:  Siehe TokShowDisplayIDString, != Null, wenn
 *			   idString durch Leerzeichen aufgefÅllt werden soll
 ---------------------------------------------------------------------------*/
extern void EXPORT TokShowDisplayTokenAndID(optr tokenDisplayObj,
				optr idDisplayObj, GeodeToken tok,
				word replaceType, ConfirmParams *cp,
				int idMinLen) {
@if 1				
   TokShowDisplayToken(tokenDisplayObj, tok, replaceType, cp);
   TokShowDisplayIDString(idDisplayObj, tok, idMinLen);
@endif
}

/**************************************************************************
 *	Tool-Routinen zur Tokenanzeige
/**************************************************************************/

/*--------------------- TokShowConvertTextToToken ---------------------
 *	Aufgabe:	Wandelt eine Text der Formen
 *			TTTT,id oder "TTTT",id in ein GeodeToken um
 *			text zeigt anschlie·end auf das erste Zeichen nach
 *			dem Token-Text
 ---------------------------------------------------------------------------*/
extern void EXPORT TokShowConvertTextToToken(char **text, GeodeToken *tok) {
@if 1
char *p, buf[10];
int i;
dword erg;

	SetTokenTo(*tok,0,0,0,0,0);	/* Leertoken */
	p = *text;		/* Zeiger auf den Text  */
	while ( (*p==' ') || (*p== 9 )) p++;
				/* Leerzeichen oder Tabs Åbergehen */
	if ( *p=='"' ) p++;	/* " Åbergehen */
     /* TokenChars lesen */
	i=0;while ((*p!= ',') && (*p!='"') && (i<4)  && (*p!=0))
		{ tok->GT_chars[i] = *p; i++; p++; }
     /* Token ID in Buffer kopieren */
	while ( (*p=='"') || (*p==',') || (*p==' ') ) p++;  /* Zahl anwÑhlen */
	i = 0;
	while ( (*p>='0') && (*p<='9' ) && ( i<6 ))
			{ buf[i]=*p; p++; i++; }	/* Zahl kopieren */
	buf[i] = 0;
     /* Zahl von Text nach numerisch konvertieren */
	i = 0; erg =0; while ( buf[i] != 0 ) { 
		//erg *= 10;	<<- forces asnsic protocol 1.008
		erg = erg<<3 + erg<<1;	// 8*erg + 2*erg = 10*erg
		erg += (dword)(buf[i] - '0');i++;}
	tok->GT_manufID =(word)erg;
	*text = p;
@endif
}


/*--------------------- TokShowValidateToken ---------------------
 *	Aufgabe:	Sucht ein Token in der Tokendatabase, unter Verwendung
 *			der ConfirmParameter cp. Fall es nicht gefunden wird,
 *			wird es durch ein passendes ersetzt (au·er wenn
 *                      replaceType == TRT_NO ist )
 *	Return:		TRUE wenn das Token gefunden wurde,
 *			FALSE wenn nicht
 ---------------------------------------------------------------------------*/
extern Boolean EXPORT TokShowValidateToken(GeodeToken * gt, word replaceType,
					ConfirmParams *cp) {
Boolean found;

	found = !TokConfirmToken( cp, *gt);
	if ( !found ) {
		/* Token nicht gefunden: ersetzen */
		if (replaceType & TRT_SUBDIR) {
			SetTokenToFOLDER(*gt); }
		else if ( replaceType & TRT_DOSFILE ) {
			SetTokenToDOSFILE(*gt); }
		else if ( replaceType & TRT_GEOSEXEC ) {
			SetTokenToAPPL(*gt);}
		else if ( replaceType & TRT_DOSEXEC ) {
			SetTokenToDOSEXEC(*gt); }
		else { SetTokenToFILE(*gt);}
		}
	return found;
	}


/*--------------------- TokShowGetFileInfo ---------------------
 *	Aufgabe:	Liefert Informationen Åber die anzuzeigenden
 *			Token fÅr eine Datei "fileName"
 *	Warnung:        - Keine Null-Pointer Åbergeben, auch wenn
 *			  einzelne Info nicht gewÅnscht
 *			- Es gibt keine Fehlermeldung, wenn die Datei nicht
 *			  existiert oder sich nicht lesen lÑsst.
 *	Return:		Attribute der Datei
 ---------------------------------------------------------------------------*/
extern word EXPORT TokShowGetFileInfo(char * fileName, GeodeToken *token,
	word *tokenReplaceType, GeodeToken * creator, word *creatorReplaceType) {

word fileAttrs;
GeosFileType fileType;
FileExtAttrDesc	attrDesc[4];	/* Array 0..3 */

/* Lesen von 3 Extended Attributen */
  @SetAttrDesc(attrDesc[0],FEA_TOKEN,token,sizeof(GeodeToken));
  @SetAttrDesc(attrDesc[1],FEA_CREATOR,creator,sizeof(GeodeToken));
  @SetAttrDesc(attrDesc[2],FEA_FILE_TYPE,&fileType,sizeof(GeosFileType));
  @SetAttrDesc(attrDesc[3],FEA_FILE_ATTR,&fileAttrs,1);
  FileGetPathExtAttributes(fileName,FEA_MULTIPLE,attrDesc,4);

/* Replace-Typen fÅr Tokenazeige setzen */
  switch ( fileType ) {
  case GFT_NOT_GEOS_FILE:       if ( fileAttrs & FA_SUBDIR )
					*tokenReplaceType = TRT_SUBDIR;
				   else *tokenReplaceType = TRT_DOSFILE;
				*creatorReplaceType = TRT_DOSEXEC;
				break;
  case GFT_EXECUTABLE:          *tokenReplaceType = TRT_NO;
				*creatorReplaceType = TRT_GEOSEXEC;
				break;
  case GFT_DIRECTORY:		*tokenReplaceType = TRT_SUBDIR;
				*creatorReplaceType = TRT_GEOSEXEC;
				break;
  default:                      /* GFT_VM | GFT_DATA | GFT_LINK */
				*tokenReplaceType = TRT_NO;
				*creatorReplaceType = TRT_GEOSEXEC;
				break;
				}

/* Wenn DOS-File: Leertoken setzen */
  if (fileType == GFT_NOT_GEOS_FILE) {
	  TokShowFindDosTokens(fileName,fileAttrs,token,creator);
	  }
  return fileAttrs;
  }

/*--------------------- TokShowGetValidFileToken ---------------------
 *	Aufgabe:	Liefert ein Token aus der TokenDatabase, das zur
 *			Åbergeben Datei passt. Wenn das Datei-Token nicht
 *			in der TokenDB ist, wird ein passendes Default-Token
 *			aus der TokenDB geliefert.
 *	Return:		TRUE (Fehler) wenn das Token nicht gefunden und durch
 *			ein passendes ersetzt wurde
 ---------------------------------------------------------------------------*/
extern Boolean EXPORT TokShowGetValidFileToken(char * fileName,
		GeodeToken *token, ConfirmParams * cp) {
GeodeToken c;
word tokenReplaceType, crt;
Boolean found;

	TokShowGetFileInfo(fileName, token,&tokenReplaceType,&c,&crt);
	found =	TokShowValidateToken(token,tokenReplaceType, cp);
	return found;
	}

/*--------------------- TokShowFindDosTokens ---------------------
 *	Aufgabe:	Liest die File-Zuordnungen aus der GEOS.INI und
 *			liefert die zur DOS-Datei passenden Token. Wird keine
 *			Zuordnung gefunden, liefert es Null-Token
 *	Wichtig:	Wenn es ein Link ist ( FA_LINK in fileAttrs gesetzt )
 *			werden die Token nur ersetzt, wenn es Nulltoken sind
 ---------------------------------------------------------------------------*/
extern void EXPORT TokShowFindDosTokens(char * fileName,  word fileAttrs,
		GeodeToken *token, GeodeToken * application) {
@if 0
	µµ
DosFileEntry info;
DosFileListStruct dosList;

     if ( fileAttrs & FA_SUBDIR ) return;

     SetTokenTo((info.fileToken),0,0,0,0,0);			/* Start: Leertoken */
     SetTokenTo((info.appToken),0,0,0,0,0);

     DosIconReadDosFileList(&dosList);
     DosIconFindTokenInfo(&dosList,&info, fileName);
     DosIconDestroyDosFileList(&dosList);
     if ( fileAttrs & FA_LINK )
	{
	// wenn ein Link auf DOS-Files wider erwarten Åber Token verfÅgt,
	// werden sie auch nicht angetastet
	if (TestTokenFor(*token,0,0,0,0,0)) *token = info.fileToken;
	if (TestTokenFor(*application,0,0,0,0,0)) *application = info.appToken;
	}
     else
	{
	*token = info.fileToken;
	*application = info.appToken;
	}

@endif
     }

/**************************************************************************
 *	Routinen zur Suche in der TokenDatabase
/**************************************************************************/

/*--------------------- TokConfirmTokenList ---------------------
 *	Aufgabe:	prÅft, ob alle gelisteten Icons in der DataBase
 *			enthalten sind.
 *		list :	enthÑlt ein Array of GeodeToken
 *		count:	Anzahl der GeodeToken in der Liste
 *	cp->confirmList enthÑlt optr der Confirm-Liste (ChunkArray)
 *			falls nicht, wird sie angelegt und zurÅckgegeben
 *			(es sei denn, CF_DO_NOT_RETURN_CONFIRM_LIST ist gesetzt)
 *	cp->confirmFlags bestimmt das nÑhere Verhalten der Routine
 *		CF_DO_NOT_RETURN_CONFIRM_LIST  ConfirmListe wieder zerstîren,
 *				wenn keine Åbergeben wurde
 *		CF_WARN_IF_INVALID_LIST			Allgemeine Info-Box, wenn
 *				Liste ungÅltige Token enthÑlt
 *		CF_DO_NOT_MODIFY_IF_INVALID_LIST 	Liste nicht Ñndern, auch
 *				wenn ungÅltige Token enthalten sind. DefaultmÑ·ig
 *				wird die Liste angepasst
 *	Return: 	TRUE, wenn ungÅltige Icons enthalten waren / sind
			FALSE wenn Liste OK war
 ---------------------------------------------------------------------------*/
extern Boolean EXPORT TokConfirmTokenList(ConfirmParams *cp, MemHandle list, word * count) {
GeodeToken *tokList;
int 	n;
Boolean	err, destroyCList, retVal = FALSE;

// Sicherstellen, das ConfirmList nicht bei Jedem TokenTest neu gebildet wird
	if ( ( cp->confirmList == 0 ) &&
	     ( cp->confirmFlags & CF_DO_NOT_RETURN_CONFIRM_LIST ) ) {
	     cp->confirmFlags &= ~CF_DO_NOT_RETURN_CONFIRM_LIST;
	     destroyCList = TRUE;
	     }
	else destroyCList = FALSE;

// List abklappern
	tokList = MemLock(list);
	for ( n= *count; n > 0; n-- ) {
		/* Anlegen und evt zurÅckgeben der ConfirmList macht
						TokConfirmToken */
		err = TokConfirmToken(cp, tokList[n-1]);
		retVal |= err;
		if (err ) {
		    if ( !(cp->confirmFlags & CF_DO_NOT_MODIFY_IF_INVALID_LIST) )
			{
			TokDeleteTokenFromTokenList(list, count, tokList[n-1]);
			}
		    }		// end of: if ( err )
		}		// end of: for
	MemUnlock(list);

	if ( retVal ) {		// evt Fehlermeldungen ausgeben
		if ( cp->confirmFlags & CF_WARN_IF_INVALID_LIST ) {
			@extern object InvalidTokensFound;
			UserStandardDialogOptr(0,0,0,0,@InvalidTokensFound,
				( (CDT_WARNING << CDBF_DIALOG_TYPE_OFFSET) |
				  (GIT_NOTIFICATION << CDBF_INTERACTION_TYPE_OFFSET)));
			}
		}

// ConfirmListe wieder freigeben, falls das gefordert war
	if ( destroyCList ) {
		TokDestroyConfirmList(cp->confirmList,TRUE);
		cp->confirmList = 0;
		cp->confirmFlags |= CF_DO_NOT_RETURN_CONFIRM_LIST;
		}

	return retVal;
	}

/*--------------------- TokConfirmToken ---------------------
 *	Aufgabe:	prÅft, das Token in der DataBase enthalten ist.
 *	cp->confirmList enthÑlt optr der Confirm-Liste (ChunkArray)
 *			falls nicht, wird sie angelegt und zurÅckgegeben
 *			(es sei denn, CF_DO_NOT_RETURN_CONFIRM_LIST ist gesetzt)
 *	cp->confirmFlags bestimmt das nÑhere Verhalten der Routine
 *		CF_DO_NOT_RETURN_CONFIRM_LIST  ConfirmListe wieder zerstîren,
 *				wenn keine Åbergeben wurde
 *		andere CF_xx-Flags werden ignoriert
 *	Return: 	TRUE, wenn Token ungÅltig ist
 *			FALSE wenn Token OK war
 ---------------------------------------------------------------------------*/
extern Boolean EXPORT TokConfirmToken(ConfirmParams *cp, GeodeToken t) {
int findRet;
word foundIndex, size;
optr	confirmList, cArray;
IDArrayElem  *idPtr;
dword tchars;

// Bei bedarf ConfirmList anlegen
	if ( !(cp->confirmList) ) confirmList = TokCreateConfirmList(0);
		else confirmList = cp->confirmList;

// ID in der Liste suchen. Return wenn nicht enthalten
	findRet = TokLocalFindIDIndex(confirmList, t.GT_manufID, &foundIndex);
	if ( findRet !=  LFII_FOUND ) return TRUE;

	MemLock(HandleOf(confirmList));

// Array der TokenChars besorgen
	idPtr = ChunkArrayElementToPtr(confirmList,foundIndex,&size);
	cArray = ConstructOptr(HandleOf(confirmList),idPtr->charArray);

// Suchen der TokenChars im Array
	memcpy(&tchars, &(t.GT_chars), 4);
	findRet = TokLocalFindCharsIndex(cArray, tchars, &foundIndex);
	MemUnlock(HandleOf(confirmList));

// bei Bedarf Confirm-Liste zurÅckgeben oder Lîschen
	if ( !(cp->confirmList) ) {	// wurde nicht Åbergeben -> handeln
		if ( (cp->confirmFlags) & CF_DO_NOT_RETURN_CONFIRM_LIST )
			{
			TokDestroyConfirmList(confirmList,TRUE);
			}
		  else	{
			cp->confirmList = confirmList;
			}
		}

	return ( findRet != LFII_FOUND );  // TRUE wenn nicht gefunden -> Fehler

	}

/*--------------------- TokCreateConfirmList ---------------------
 *	Aufgabe:	Legt die Confirmstruktur fÅr die ConfirmToken-
 *			Routinen an. Liefert den optr des Basis-Chunk-Arrays
 *		block:	MemHandle des Block, in dem die Struktur angelegt
 *			werden soll
 *                      NULL, wenn neuer Block angefordert werden soll
 *	Return: 	optr der Confirm-Struktur (ChunkArray der Manuf-ID's)
 ---------------------------------------------------------------------------*/
extern optr EXPORT TokCreateConfirmList(MemHandle block)	{
dword listInfo, tchars;
optr	idList,charArray;
GeodeToken *tokList;
MemHandle okList;
word okCount, n, tokID;
ChunkHandle	ch;

  // ChunkArray fÅr ID-Liste anlegen
  if ( !block )	block = MemAllocLMem(LMEM_TYPE_GENERAL,0);
  MemLock(block);
  ch = ChunkArrayCreate(block,sizeof(IDArrayElem),0,OCF_DIRTY);
  idList = ConstructOptr(block,ch);

  // Liste *aller* gÅltigenToken anlegen
  listInfo = TokenListTokens(0,0,0);
  okList = TokenListTokensHandleFromDWord(listInfo);
  okCount = TokenListTokensCountFromDWord(listInfo);

  // Jedes Token zur Liste hinzufÅgen
  for ( n = 0 ; n < okCount; n++)
	    {
	    tokList = MemLock(okList);
	    tokID = tokList[n].GT_manufID;
	    memcpy(&tchars,&(tokList[n].GT_chars),4);
	    MemUnlock(okList);

	    charArray = TokLocalGetCharsArray(idList,tokID);
	    TokLocalInsertChars(charArray,tchars);
	    }			// end of for
  MemFree(okList);
  MemUnlock(block);
  return idList;
  }

/*--------------------- TokDestroyConfirmList ---------------------
 *	Aufgabe:	Vernichtet die Confirm-Struktur wieder.
 *		freeBlock: TRUE-> gesamter Speicherblock mit der Struktur
 *				wird freigegeben
 *			   FALSE-> Speicherblock bleibt Alloziiert
 ---------------------------------------------------------------------------*/
extern void EXPORT TokDestroyConfirmList(optr list, Boolean freeBlock) {
	if ( freeBlock ) {
	/*ÊÊ*/	MemFree(HandleOf(list));
		}
	/*
	else {
		MessageBox("Die Struktur wurde nicht freigegeben");
		}
	*/
	}

/**************************************************************************
 *	Tool-Routinen zur Verwaltung von Token-Listen
/**************************************************************************/

/*--------------------- TokGetTokenFromTokenList ---------------------
 *	Aufgabe:	liefert das Token, das zum Eintrag Item in der durch listHandle
 *			referenzierten Tokenliste gehîrt
 ---------------------------------------------------------------------------*/
extern void EXPORT TokGetTokenFromTokenList(word item,MemHandle listHandle, GeodeToken *t) {
GeodeToken *toklist;

	toklist = MemLock(listHandle);
	*t = toklist[item];
	MemUnlock(listHandle);
	}

/*--------------------- TokGetItemFromTokenList ---------------------
 *	Aufgabe:	Liefert Nummer des Tokens in der Liste oder - 1
 * 	      listCount: mu· die Anzahl der Token in der Liste enthalten
 ---------------------------------------------------------------------------*/
extern int EXPORT TokGetItemFromTokenList(MemHandle list, word listCount, GeodeToken t) {
	/*  */
int i,n;
GeodeToken *toklist;
	toklist = MemLock(list);
	for ( i=0, n=-1; i< listCount; i++ ) {
		if ( (memcmp(t.GT_chars,toklist[i].GT_chars,4)==0)
			&& (t.GT_manufID == toklist[i].GT_manufID) ) {
			n=i;
			break;
			}
		}
	MemUnlock(list);
	return n;
	}

/*--------------------- TokDeleteTokenFromTokenList ---------------------
 *	Aufgabe:	entfernt ein Token aud der Tokenliste
 * 	      listCount: Anzahl der Token in der Liste, wird verÑndert, wenn
 *			ein Token entfernt wurde
 *			Der vom Block belegte Speicher wird nicht (!) verkleinert
 *	Return:    	FALSE (==ok) wenn Token gefunden und gelîscht,
 *			TRUE bei Fehler
 ---------------------------------------------------------------------------*/
extern Boolean EXPORT TokDeleteTokenFromTokenList(MemHandle list, word *listCount, GeodeToken t) {
int i,n,c;
GeodeToken *toklist;

	n = TokGetItemFromTokenList(list, *listCount, t);
	if ( n == (-1) ) return TRUE;

	c = (*listCount) - n - 1;	// Anzahl der zu verschiebenden Elemente
	if ( c > 0 ) {
	    toklist = MemLock(list);
	    for ( i = 0; i<c ; i++) {
		toklist[n+i] = toklist[n+i+1];
		}
	    MemUnlock(list);
	    }
	*listCount = *listCount - 1;
	return FALSE;
	}

/**************************************************************************
 *	Lokale Tool-Routinen
/**************************************************************************/

/*--------------------- TokLocalInsertChars ---------------------*/

optr TokLocalGetCharsArray(optr idList,word tokID) {
// Liefert das Chunk-Array das die Liste der TokenChars zu tokID enthÑlt.
// Falls sie noch nicht existiert, wird sie angelegt
word foundIndex, size;
IDArrayElem *idPtr;
optr 	list;
ChunkHandle ch;
int strategie;

	strategie = TokLocalFindIDIndex(idList, tokID, &foundIndex);

	MemLock(HandleOf(idList));

	switch ( strategie ) {
	case	LFII_FOUND:
		idPtr = ChunkArrayElementToPtr(idList,foundIndex,&size);
		list = ConstructOptr(HandleOf(idList),idPtr->charArray);
		break;
	case	LFII_APPEND:
	case	LFII_INSERT:
			if ( strategie == LFII_APPEND ) {
				ChunkArrayAppend(idList,sizeof(IDArrayElem));
				}
			  else  {
				idPtr = ChunkArrayElementToPtr(idList,foundIndex,&size);
				ChunkArrayInsertAt(idList,
						idPtr,sizeof(IDArrayElem));
				}
			// Neues Chars-Array erzeugen
			// und neues ID-Array-Element initialisieren
			ch = ChunkArrayCreate(HandleOf(idList),
					sizeof(dword),0,OCF_DIRTY);
			list = ConstructOptr(HandleOf(idList),ch);
			idPtr = ChunkArrayElementToPtr(idList,foundIndex,&size);
			idPtr->manufID = tokID;
			idPtr->charArray = ch;
			break;
		}

	MemUnlock(HandleOf(idList));
	return list;			// opt des TChars Liste
	}

/*--------------------- TokLocalInsertChars ---------------------*/

void TokLocalInsertChars(optr charArray,dword tchars) {
// FÅgt die als dword vorliegenden TokenChars tchars in ein
// Chunkarray ein. Keine Fehlermeldung, wenn Wert schon existiert
word foundIndex, size;
dword * tcPtr;
int strategie;

	strategie = TokLocalFindCharsIndex(charArray, tchars, &foundIndex);

	switch ( strategie ) {
	case	LFII_FOUND:
		return;		// keine DoppeleintrÑge
	case	LFII_APPEND:
	case	LFII_INSERT:
			MemLock(HandleOf(charArray));
			if ( strategie == LFII_APPEND ) {
				ChunkArrayAppend(charArray,sizeof(dword));
				}
			  else  {
				tcPtr = ChunkArrayElementToPtr(charArray,foundIndex,&size);
				ChunkArrayInsertAt(charArray,tcPtr,sizeof(dword));
				}
			// Neues Element belegen
			tcPtr = ChunkArrayElementToPtr(charArray,foundIndex,&size);
			*tcPtr = tchars;
			MemUnlock(HandleOf(charArray));
			break;
		}
	}

/*--------------------- TokLocalFindIDIndex ---------------------*/

int TokLocalFindIDIndex(optr idArray, word tokID, word * foundIndex) {
// Sucht nach dem Index, der zur TokenID passt
// liefert Strategie, wie die ID in das ID-Array enzufÅgen ist
// LFII_APPEND		neuer Wert ist anzuhÑngen
// LFII_FOUND		ID gefunden -> foundIndex verwenden
// LFII_INSERT		nicht gefunden, an foundIndex einzufÅgen

word count, index, size;
IDArrayElem *idPtr;
int retVal;

	MemLock(HandleOf(idArray));
	count = ChunkArrayGetCount(idArray);	// Anzahl der erfassten IDs
	retVal = LFII_APPEND; 			// default: anhÑngen
	*foundIndex = count;			// das ist dann der neue Index

	if ( !count ) {				// Leer - > AnhÑngen
		MemUnlock(HandleOf(idArray));
		return	LFII_APPEND;
		}

	idPtr = ChunkArrayElementToPtr(idArray,0,&size);
	for ( index = 0; index < count; index++, idPtr++ )
		{
		if (idPtr->manufID >= tokID) {
			* foundIndex = index;
			if (idPtr->manufID == tokID) retVal = LFII_FOUND;
				else retVal = LFII_INSERT;
			break;
			}
		}

	MemUnlock(HandleOf(idArray));
	return retVal;
	}

/*--------------------- TokLocalFindCharsIndex ---------------------*/

int TokLocalFindCharsIndex(optr charArray, dword tchars, word * foundIndex) {
// Sucht nach dem Index, der zu den TokenChars tchars passt
// liefert Strategie, wie die Chars in das charArray enzufÅgen sind
// LFII_APPEND		neuer Wert ist anzuhÑngen
// LFII_FOUND		chars gefunden -> ignorieren (keine BoppeleintrÑge)
// LFII_INSERT		nicht gefunden, an foundIndex einzufÅgen

word count, index, size;
dword *tcPtr;
int retVal;

	MemLock(HandleOf(charArray));
	count = ChunkArrayGetCount(charArray);	// Anzahl der erfassten IDs
	retVal = LFII_APPEND; 			// default: anhÑngen
	*foundIndex = count;			// das ist dann der neue Index

	if ( !count ) {				// Leer - > AnhÑngen
		MemUnlock(HandleOf(charArray));
		return	LFII_APPEND;
		}

	tcPtr = ChunkArrayElementToPtr(charArray,0,&size);
	for ( index = 0; index < count; index++, tcPtr++ )
		{
		if ( *tcPtr >= tchars) {
			* foundIndex = index;
			if ( *tcPtr == tchars ) retVal = LFII_FOUND;
				else retVal = LFII_INSERT;
			break;
			}
		}

	MemUnlock(HandleOf(charArray));
	return retVal;
	}

/*--------------------- TokDeleteTokenFromTokenList ---------------------
 *	Aufgabe:
 *	Return:
 ---------------------------------------------------------------------------*/

