COMMENT @----------------------------------------------------------------------

	Copyright (c) GeoWorks 1988 -- All Rights Reserved
	GEOWORKS CONFIDENTIAL

PROJECT:	GEOS
MODULE:		Library/User
FILE:		uiConstant.def

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	Tony	2/89		Initial version

DESCRIPTION:
	This file contains constants global to the user interface

	$Id: uiConstant.def,v 1.1 97/04/07 11:45:46 newdeal Exp $

------------------------------------------------------------------------------@



EXTRA_INPUT_TYPES	= 	FALSE	; This flag set to include code for
					; handling Pressure & Direction methods,
					; grabs  (Note that the grab, force
					; grab & release routines for each 
					; need to be added back into ui.gp
					; to be able to be used by apps again,
					; if set TRUE).   Code commented out
					; since not used in first release...

BETA_ERROR_CHECKING	=	FALSE	; TRUE to include error checking that
					; is sometimes needed in non-ec
					; versions

TEST_FLOW		=	FALSE	; TRUE to time Flow routines

_EXPRESS_MENU		=	TRUE	; include code for Express Menu
SELECT_DISABLED_LIST_ITEMS = 	FALSE	; disallow disabled items to be
					; selected in non-exclusive lists


; Be sure to clear this flag in UI/uiManager.ui & Motif as well.

FAKE_SIZE_OPTIONS	=	TRUE	; TRUE to include routines that check
					; .ini flags to allow alteration  of
					; screen & field size, allow addition
					; of on-screen hard icon sizes.

if	FAKE_SIZE_OPTIONS
GP_FAKE_SIZE_OPTIONS	equ	TRUE
endif


;----------------------------------------------------------------------
; Set this flag "on" if your product does not want to use the Geos
; HWR library, even though Pen and Ink input is possible.
;----------------------------------------------------------------------
_UI_NO_HWR		=	FALSE


;----------------------------------------------------------------------
; This part is the flag setting for Jedi. Basically, we don't need charting
; and graphical objects in Spreadsheet lib. So we turn the flag off.
;----------------------------------------------------------------------
	_JEDI		=	FALSE

;----------------------------------------------------------------------
; Define .gp variable for Jedi
;----------------------------------------------------------------------

;------------------------------------------------------------------------------
;  FULL_EXECUTE_IN_PLACE : Indicates that the ui lib is going to
;	be used in a system where all geodes (or most, at any rate)
;	are to be executed out of ROM.  
;------------------------------------------------------------------------------
ifndef FULL_EXECUTE_IN_PLACE
        FULL_EXECUTE_IN_PLACE           equ     FALSE
endif

;------------------------------------------------------------------------------
;  The .GP file only understands defined/not defined;
;  it can not deal with expression evaluation.
;  Thus, for the TRUE/FALSE conditionals, we define
;  GP symbols that _only_ get defined when the
;  condition is true.
;-----------------------------------------------------------------------------
if	FULL_EXECUTE_IN_PLACE
	GP_FULL_EXECUTE_IN_PLACE	equ	TRUE
endif

;-----------------------------------------------------------------------------
;  This constant is used primarily for the mulitple-SPUI demo, where
;  you may come up with a new default launcher, and the geode for the 
;  old default launcher isn't available anymore.  In this case the
;  Prefspui module will have written out the old default launcher's name
;  into the .ini file, and so we know when an app restoring from state
;  fails to find its geode, check it against the old default launcher and
;  start up the new default launcher if it was. dlitwin 9/21/94
;-----------------------------------------------------------------------------
_HANDLE_NEW_DEFAULT_LAUNCHER_ON_RESTART = FALSE

;-----------------------------------------------------------------------------
;  STATIC_PEN_INPUT_CONTROL: Indicates that the system has a single persistent
;  pen input control box.  With this set, the
;  MSG_GEN_APPLICATION_TOGGLE_FLOATING_KEYBOARD will also only bring up the
;  keyboard.  The keyboard itself should have a button to bring down the
;  keyboard.
;
;  Be sure to set matching value in UI/uiManager.ui and to declare
;  SystemHWRUI in ui.gp.
;
;  This should be used with the SpecificUI's PEN_INPUT_CONTROL_ALWAYS_ACTIVE.
;
;  _GRAFFITI_ANYWHERE:  turn on if you turn on the equivalent constant
;  in the specific UI.  See documentation in cConstant.def.
;
;-----------------------------------------------------------------------------
STATIC_PEN_INPUT_CONTROL	equ	FALSE
_GRAFFITI_ANYWHERE		equ	FALSE

;-----------------------------------------------------------------------------
;
; This is an attempt to use generalized error strings that don't refer to
; DOS, networks, calling customer service, error codes, etc.
;
; Before using, check User/userStrings.asm to make sure its got what you want
;
;-----------------------------------------------------------------------------
GENERAL_DEVICE_STRINGS		equ	FALSE


;----------------------------------------------------------------------
; Dove: features desired.
;----------------------------------------------------------------------



;-----------------------------------------------------------------------------
; PLAY_STARTUP_SHUTDOWN_MUSIC: If TRUE, music from .wav files are played when
; the system boots and shuts down.  The files are specified in the .INI file
; under [ui]/startupMusic and [ui]/shutdownMusic, and are relative to
; SP_USER_DATA\SOUNDS.
; PLAY_WAV_FOR_ERRORS: Use WAV files for SST_NO_INPUT and SST_NO_HELP. The files
; must be specified in the geos.ini file. See WavPlayInitSound for details.
; If PLAY_WAV_FOR_ERRORS is not defined, FM sounds will be played instead.
;-----------------------------------------------------------------------------
PLAY_STARTUP_SHUTDOWN_MUSIC	equ	TRUE
; PLAY_WAV_FOR_ERRORS		equ	TRUE

PCMCIA_SUPPORT			equ	FALSE


;------------------------------------------------------------------------------
;	Fatal errors
;------------------------------------------------------------------------------

if	ERROR_CHECK

;------------------------------------------------------------------------------
;	PROCESS ERRORS
;------------------------------------------------------------------------------
UI_PROCESS_NESTED_DETACH				       enum FatalErrors
UI_PROCESS_INVALID_QUIT_LEVEL				       enum FatalErrors
UI_MULTIPLE_MSG_DETACHES_SENT_TO_APP_OBJ		       enum FatalErrors
UI_MSG_QUIT_RECEIVED_AFTER_MSG_META_DETACH		       enum FatalErrors
UI_PROCESS_CANNOT_ABORT_QUIT_AFTER_DETACH		       enum FatalErrors
UI_PROCESS_CANNOT_DELETE_STATE_FILE			       enum FatalErrors
UI_USER_LOAD_APP_BAD_FLAGS				       enum FatalErrors
UI_USER_LOAD_APP_BAD_GEN_UI_LEVEL			       enum FatalErrors
APP_LAUNCH_BLOCK_MUST_BE_SHARABLE			       enum FatalErrors
RELATIVE_PATH_PASSED_TO_USER_LOAD_APPLICATION		       enum FatalErrors
UI_APP_RECEIVED_INITIATE_QUIT_BEFORE_MSG_META_QUIT	       enum FatalErrors
DISK_HANDLE_PASSED_WITHOUT_FULL_PATHNAME		       enum FatalErrors
UI_OBJECT_NOT_RUN_BY_UI_THREAD_AS_IS_REQUIRED		       enum FatalErrors

;------------------------------------------------------------------------------
;	GENERIC ERRORS
;------------------------------------------------------------------------------

UI_MSG_DETACH_ABORT_SENT_TO_INVALID_CLASS                      enum FatalErrors
; MSG_META_DETACH_ABORT can only be sent to a GenSystemClass object or a
; GenFieldClass object.

BAD_FLAGS_PASSED_TO_GEN_COPY_CHUNK                             enum FatalErrors
; GenCopyChunk utility routine can only be passed the CCF_MARK_DIRTY flag.
; None of the other CompChildFlags should be set.

GEN_GET_DISPLAY_SCHEME_REQUIRES_GEN_OBJECT                     enum FatalErrors
; GenGetDisplayScheme utility routine must be passed a generic object as it
; might need to get the generic parent to find the display scheme.

UI_VUM_MANUAL_NOT_ALLOWED_FOR_GEN_SET_NOT_USABLE               enum FatalErrors
; VUM_MANUAL has been outlawed with a FATAL_ERROR for the same reason that there
; is a warning in MSG_GEN_UPDATE_VISUAL about needing to send a
; MSG_GEN_UPDATE_VISUAL to EVERY generic object you've marked as needing
; visual updating via VUM_MANUAL.  The problem is this:
; An application should make no assumption
; about the visual construction of a generic tree; in other words, if you
; mark two triggers as IMAGE_INVALID, you shouldn't assume that you can
; just update the display that they are on, since the buttons may visually
; be placed on some window other than the display.  This problem is solved
; by having the MSG_GEN_UPDATE_VISUAL, since the specific UI can implement
; this method by invalidating all visual aspects of the object wherever
; (as in whatever window they're in) they may be.  Whew!
;
; So, how does this relate to VUM_MANUAL & MSG_GEN_SET_NOT_USABLE?  Well,
; when an object is marked not usable, it is visually torn down, & may actually
; have the visible instance data discarded.  In this state,
; MSG_GEN_UPDATE_VISUAL does nothing, since the object isn't specifically built.
;
; How to get around this?  I'd recommend using one of the
; VUM_DELAYED_VIA_??_QUEUE modes for these calls, if you're trying to avoid
; flickering of your display in bringing down UI components.  Note that
; calling multiple MSG_GEN_SET_NOT_USABLE's w/ a DELAYED update mode only
; generates one method which goes through the queue to perform the udpate later.

UI_GEN_USED_BEFORE_GROWN                                       enum FatalErrors
; Generic part of object must be grown before this operation can occur.  Make
; sure that the object is a generic object.

NO_SPECIFIC_UI                                                 enum FatalErrors
; Unable to find specific UI to use when trying to resolve specific UI class
; for a generic object.

UI_ERROR_CAN_NOT_SET_USABLE_IF_NOT_IN_GEN_COMPOSITE            enum FatalErrors
; Occurs when MSG_GEN_SET_USABLE is sent to object that is not attached to a
; generic object tree.  Make sure that you've added the object to the
; appropriate place in you application's object tree.

UI_ERROR_CAN_NOT_ADD_OR_REMOVE_OBJECT_WHILE_USABLE             enum FatalErrors
; An object must be set not usable before it can be added with MSG_GEN_ADD_CHILD
; or removed with MSG_GEN_REMOVE_CHILD.  Make sure that either the object is
; marked not usable in your .ui/.goc file or that you set it not usable with
; MSG_GEN_SET_NOT_USABLE.

OBJECT_NOT_GENERIC                                             enum FatalErrors
; NOT CURRENTLY USED

UI_ERROR_CAN_NOT_DO_OPERATION_WHEN_USABLE		       enum FatalErrors
; An object must be not usable before this operation can occur.  Make sure that
; either the object is marked not usable in your .ui/.goc file or that you set
; it not usable with MSG_GEN_SET_NOT_USABLE.

UI_GEN_COPY_TREE_SOURCE_AND_DEST_CANNOT_BE_SAME_BLOCK	       enum FatalErrors
; MSG_GEN_COPY_TREE cannot be used to copy a generic object tree to the same
; object block as the source object tree.  Usually, you can define a seperate
; "template" object block as the source block and attach the copied tree to
; your working destination block.

UI_FUNCTION_REQUIRES_THAT_GENERIC_OBJECT_BE_IN_TREE	       enum FatalErrors
; An object must be attached to a generic parent before this operation can
; occur.  Make sure that either the object is a child of some object in your
; .ui/.goc file or that you add it to some generic parent with
; MSG_GEN_ADD_CHILD.

UI_GEN_OBJECT_REQUIRED_FOR_THIS_OPERATION		       enum FatalErrors
; This operation can only operation on generic objects.  Make sure that the
; object is of one of the predefined generic class or is a subclass thereof.

UI_GEN_GET_APPLICATION_OD_FOUND_IN_GUP			       enum FatalErrors
; (Internal)  The owner of the object block passed to GenGetApplicationOD
; does not have an application object associated with it, though an
; application object was found up in the generic tree.

UI_GEN_APPLICATION_COULDNT_FIND_A_VIS_PARENT		       enum FatalErrors

UI_GEN_FIND_CHILD_BAD_OD				       enum FatalErrors
; MSG_GEN_FIND_CHILD was passed a bad child optr to find.  Make sure the
; handle and chunk are valid.

UI_GEN_CANT_SET_GEN_ATTRIBUTES_WHEN_USABLE		       enum FatalErrors
; MSG_GEN_SET_ATTRS cannot be used on a generic object that is already
; usable as the attributes are used to specifically resolve the object.  Set
; GenAttributes when object is not usable then set object usable with
; MSG_GEN_SET_USABLE.

UI_ERROR_NO_OWNING_PROCESS					enum FatalErrors
; MSG_GEN_SEND_TO_PROCESS can't do it's job, because the block that the
; current object is in has no owner.

BAD_ASSUMPTION_IN_GenCheckIfFullyUsable				enum FatalErrors
; Internal error within GenCheckIfFullyUsable

BAD_ASSUMPTION_IN_GenCheckIfFullyEnabled			enum FatalErrors
; Internal error within GenCheckIfFullyEnabled

UI_ILLEGAL_REQUEST_OF_GEN_APPLICATION_OBJECT			enum FatalErrors
; Generally the result of attempting to set an GenApplication object USABLE or
; not USABLE, which is an illegal operation.  Application objects are made
; USABLE via MSG_META_ATTACH, & made NOT_USABLE via MSG_META_DETACH, both
; messages which should originate only from with the default behavior of
; GenProcessClass for handling the startup & shutdown of apps.

UI_GEN_CLASS_ILLEGALLY_USED					enum FatalErrors
; This occurs if GenClass receives a MSG_META_RESOLVE_VARIANT_SUPERCLASS,
; which should never happen, as the only legal generic classes are those
; subclassed off of GenClass, not GenClass itself, which exists only to 
; provide common behavior.

UI_TEMP_GEN_FIELD_ACTIVATION_DIALOG_NOT_PRESENT			enum FatalErrors

UI_APP_OBJ_HAS_NO_GENERIC_PARENT				enum FatalErrors
; The app object needs to be grown out in order for some message to reach
; the specific instance data, but the app isn't yet hooked into the generic
; tree, & so the field can't be asked which specific UI library should be used.
; Generally caused by sending messages to the app very early or very late in
; its life (i.e. while it is illegal to do so)

;------------------------------------------------------------------------------
;	CREATE MONIKER ERRORS
;------------------------------------------------------------------------------

UI_ERROR_CREATE_VIS_MONIKER_SOURCE_TOO_LARGE		       enum FatalErrors
; Size field passed to MSG_VIS_CREATE_VIS_MONIKER and MSG_GEN_CREATE_VIS_MONIKER
; must be less than 8192.  Larger monikers are not supported by these messages.

UI_ERROR_CREATE_VIS_MONIKER_BAD_SOURCE_TYPE		       enum FatalErrors
; sourceType passed to MSG_VIS_CREATE_VIS_MONIKER and MSG_GEN_CREATE_VIS_MONIKER
; must be a valid VisMonikerSourceType.

UI_ERROR_CREATE_VIS_MONIKER_BAD_DATA_TYPE		       enum FatalErrors
; dataType passed to MSG_VIS_CREATE_VIS_MONIKER and MSG_GEN_CREATE_VIS_MONIKER
; must be a valid VisMonikerDataType.

UI_ERROR_CREATE_VIS_MONIKER_CANNOT_USE_VMDT_NULL	       enum FatalErrors
; VMDT_NULL cannot be used with MSG_VIS_CREATE_VIS_MONIKER and
; MSG_GEN_CREATE_VIS_MONIKER.

UI_ERROR_CREATE_VIS_MONIKER_CANNOT_USE_VMDT_TOKEN	       enum FatalErrors
; VMDT_TOKEN cannot be used with MSG_VIS_CREATE_VIS_MONIKER and
; MSG_GEN_CREATE_VIS_MONIKER as VMDT_TOKEN must have an associated object
; which the specific UI can use to determine which moniker in the Token
; Database's moniker list for the passed token is to be used.  So, only
; MSG_GEN_REPLACE_VIS_MONIKER, MSG_GEN_PRIMARY_REPLACE_LONG_TERM_MONIKER, and
; MSG_GEN_DYNAMIC_LIST_COPY_ITEM_MONIKER can use VMDT_TOKEN.

UI_ERROR_CREATE_VIS_MONIKER_GSTRING_SIZE_0_NOT_ALLOWED	       enum FatalErrors
; When using VMDT_GSTRING, the size field must be passed.  It cannot be 0.

;------------------------------------------------------------------------------
;	VISUAL ERRORS
;------------------------------------------------------------------------------
UI_BAD_COORDINATE						       enum FatalErrors
; Some value passed to this routine (usually a mouse position or an object's
; bounds) is illegal coordinate under the PC graphics system.
  
UI_EXPOSURE_OF_NON_WINDOW_OBJECT                               enum FatalErrors
; Only visual objects that have VTF_IS_WINDOW should receive MSG_META_EXPOSED events.
; Perhaps you are not using VisContent type object as the output of a view
; somewhere.
  
UI_VIS_USED_BEFORE_GROWN                                       enum FatalErrors
; Some routine assumes that an object's visual master class has been grown,
; and it isn't.  This could be the specific UI's fault for trying to muck with
; visual or specific instance data for an object that is not yet built,
; or possibly something trashed Vis_offset for the object.
  
UI_BAD_FLAGS_RETURNED_FROM_MOUSE_MESSAGE                        enum FatalErrors
; Visual objects are required to return MouseReturnFlags (most often MRF_-
; PROCESSED) from certain mouse messages (MSG_META_START_SELECT, MSG_META_PTR, etc.)
							       
							       
UI_VIS_OBJECT_ALREADY_OPENED                                   enum FatalErrors
; A MSG_VIS_OPEN was passed to an object that already has VA_REALIZED already
; set, indicating that the object has been previously opened.
							       
UI_CAN_NOT_WIN_RESIZE_NON_WINDOW                               enum FatalErrors
; A MSG_VIS_MOVE_RESIZE_WIN was somehow passed to an object with VTF_IS_WINDOW
; cleared (i.e. a non-window object).  This shouldn't happen.
							       
UI_NESTED_VISUAL_UPDATE                                        enum FatalErrors
; Somehow a MSG_VIS_UPDATE_WIN_GROUP was sent to a win group where one is
; already in progress.  Most commonly the result of an object handling a visual
; update message such as MSG_VIS_OPEN passing VUM_NOW in some message to
; an object in the same window.  VUM_NOW may not be used while performing
; a visual update.  VUM_MANUAL, or one oof the delayed VUM modes, must be used
; instead.

UI_NULL_GWIN_RETURNED_FROM_MSG_VIS_OPEN_WIN                    enum FatalErrors
; A MSG_VIS_OPEN_WIN should return the handle of the window that has been
; opened, so that it can passed to the appropriate children.
  
UI_VIS_COMP_OBJECT_MARKED_REALIZED_WITHOUT_GWIN                enum FatalErrors
; An object already has VA_REALIZED bit set (i.e. has received a MSG_VIS_OPEN)
; but doesn't have a gWin set for it, as it is supposed to after a MSG_VIS_
; OPEN.
  
UI_VIS_COMP_OBJECT_NOT_REALIZED_YET_HAS_GWIN                   enum FatalErrors
; An object that has not yet received a MSG_VIS_OPEN (as indicated by the
; VA_REALIZED bit) already has a gWin set for it.  This should only get set
; in a MSG_VIS_OPEN, and always cleared during a MSG_VIS_CLOSE.
	
UI_BAD_SET_VIS_ATTR_FLAGS                                      enum FatalErrors
; Only VA_VISIBLE, VA_MANAGED, VA_DRAWABLE, VA_DETECTABLE, or VA_FULLY_ENABLED
; are allowed to be set or cleared via VisSetVisAttrs.
  
UI_UPDATE_OF_NON_WIN_GROUP_OBJECT                              enum FatalErrors
; A MSG_VIS_UPDATE_WIN_GROUP was sent to a non-win-group object.  Use MSG_VIS_-
; VUP_UPDATE_WIN_GROUP instead, which finds the win group object from the object
; you send the message to.  Better yet, make sure what you are doing isn't
; better (or more correctly) served VisMarkInvalid.
  
UI_BAD_VIS_UPDATE_MODE                                         enum FatalErrors
; Caller to the routine that fatal errored didn't pass a legal VisUpdateMode,
; either VUM_NOW, VUM_MANUAL, VUM_DELAYED_VIA_APP_QUEUE, VUM_DELAYED_VIA_UI_-
; QUEUE.

UI_BAD_UPDATE_WINDOW_FLAGS				       enum FatalErrors
; Bad UpdateWindowFlags passed to MSG_META_UPDATE_WINDOW or
; MSG_GEN_GUP_ENSURE_UPDATE_WINDOW.
  
UI_VIS_NON_COMPOSITE_OBJECT_MARKED_AS_IS_WINDOW                enum FatalErrors
; Any object marked as VTF_IS_WINDOW must also have VTF_IS_COMPOSITE set.
; Either subclass your windowed object off of VisCompClass or figure out where
; the VI_typeFlags for the object got screwed up.
	
UI_VIS_WIN_GROUP_OBJECT_MUST_BE_MARKED_AS_IS_WINDOW            enum FatalErrors
; Win group objects must have VTF_IS_WINDOW set.  Most likely you are trashing
; the VisTypeFlags that were set by your object's superclass, or not executing
; your superclass' MSG_SPEC_BUILD or MSG_META_INITIALIZE.
	
UI_VIS_WIN_GROUP_OBJECT_MARKED_AS_IS_PORTAL                    enum FatalErrors
; A win group object cannot be a portal.  Re-think what type flags to give your
; object, or figure out how you're trashing the VI_typeFlags instance data.
  
UI_VIS_SPEC_CANT_GET_A_FIELD_SIZE                              enum FatalErrors
; VisConvertSpecVisSize (called by the HINT_FIXED_SIZE, etc. handlers) couldn't
; find a GenField object up the generic tree from this object.  Do a "vup"
; to try to see what's going on.  NOTE: one possibility is that you are using
; HINT_FIXED_SIZE, etc. on a windowed object -- this is a bad thing.  You
; should be using something like HINT_SIZE_WINDOW_AS_RATIO_OF_PARENT, not
; HINT_FIXED_SIZE for windowed objects.

UI_VIS_BAD_SPEC_SIZE_ARGUMENT				       enum FatalErrors
; An illegal SpecSizeSpec argument was passed to VisConvertSpecVisSize (and 
; typically was an argument to HINT_FIXED_SIZE or a related hint.)  Make
; sure your hint is of the correct format.

UI_VIS_SPEC_SIZE_CANT_USE_COUNT_HERE			       enum FatalErrors
; A count is being passed to VisConvertSpecVisSize.  The caller should have
; dealt with this on its own.  SST_COUNT is not a legal argument to the
; width or height arguments of HINT_FIXED_SIZE, HINT_MINIMUM_SIZE, HINT_MAXIMUM
; _SIZE or HINT_INITIAL_SIZE.
  
UI_SIZE_HINT_MUST_HAVE_ARGUMENTS			       enum FatalErrors
; Any of the size hints (HINT_FIXED_SIZE, HINT_MINIMUM_SIZE, HINT_MAXIMUM_SIZE,
; HINT_INITIAL_SIZE) require at least a SpecWidth argument, and optionally
; a SpecHeightArgument and a count (for composites).
  
UI_SIZE_HINT_TOO_MANY_ARGUMENTS				       enum FatalErrors
; None of the size hints (HINT_FIXED_SIZE, HINT_MINIMUM_SIZE, HINT_MAXIMUM_SIZE,
; HINT_INITIAL_SIZE) should be larger than CompSizeHintArgs.

UI_SIZE_HINT_ILLEGAL_TYPE_FOR_HEIGHT_ARGUMENT		       enum FatalErrors
; Only certain SpecSizeSpec arguments (SST_LINES_OF_TEXT, SST_PIXELS,
; SST_PCT_OF_FIELD_HEIGHT) are allowable as a height argument to
; HINT_FIXED_SIZE, HINT_MINIMUM_SIZE, HINT_MAXIMUM_SIZE or HINT_INITIAL_SIZE.
  
UI_SIZE_HINT_ILLEGAL_TYPE_FOR_WIDTH_ARGUMENT		       enum FatalErrors
; Only certain SpecSizeSpec arguments (SST_AVG_CHAR_WIDTHS, 
; SST_WIDE_CHAR_WIDTHS, SST_PIXELS, SST_PCT_OF_FIELD_WIDTH) 
; are allowable as a height argument to HINT_FIXED_SIZE, HINT_MINIMUM_SIZE, 
; HINT_MAXIMUM_SIZE or HINT_INITIAL_SIZE.
  
UI_SIZE_HINT_COUNT_ARGUMENT_MUST_BE_A_PLAIN_NUMBER             enum FatalErrors
; A simple number, not a SpecSizeSpec value, should be passed as the count
; argument to HINT_FIXED_SIZE, HINT_MINIMUM_SIZE, HINT_MAXIMUM_SIZE, or HINT_
; INITIAL_SIZE.
							       
UI_SIZE_HINT_CHILD_COUNT_TOO_LARGE			       enum FatalErrors
; A rather large child count is being passed as the count argument to
; HINT_FIXED_SIZE, HINT_MINIMUM_SIZE, HINT_MAXIMUM_SIZE or HINT_INITIAL_SIZE.
; Currently this routine fatal errors for more than 255 children -- hopefully
; this maximum is not a problem.

UI_BAD_GEO_UPDATE_PATH					       enum FatalErrors
; Somewhere a VOF_GEO_UPDATE_PATH path bit is set in an object whose children
; all have valid geometry, or a VOF_GEOMETRY_INVALID bit is set in a child,
; but the corresponding path bit is not set in the parent.  Do a "vup *ds:si
; VI_optFlags to view all the flags leading up from the object, or a 
; "vistree {addr} VI_optFlags" from the win group object to try to see where
; the offending bit is located.   This often occurs from a composite that
; doesn't have a well behaved MSG_VIS_RECALC_SIZE handler (doesn't clear
; the path or invalid bits correctly, typically done by VisRecalcSizeAndInvalIfNeeded).
  
UI_BAD_WINDOW_UPDATE_PATH				       enum FatalErrors
; Somewhere a VOF_WINDOW_UPDATE_PATH path bit is set in an object whose children
; all have valid windows, or a VOF_WINDOW_INVALID bit is set in a child,
; but the corresponding path bit is not set in the parent.  Do a "vup *ds:si
; VI_optFlags to view all the flags leading up from the object, or a 
; "vistree {addr} VI_optFlags" from the win group object to try to see where
; the offending bit is located.
  
UI_BAD_IMAGE_UPDATE_PATH				       enum FatalErrors
; Somewhere a VOF_GEO_IMAGE_PATH path bit is set in an object whose children
; all have valid images, or a VOF_IMAGE_INVALID bit is set in a child,
; but the corresponding path bit is not set in the parent.  Do a "vup *ds:si
; VI_optFlags to view all the flags leading up from the object, or a 
; "vistree {addr} VI_optFlags" from the win group object to try to see where
; the offending bit is located.
  
VIS_ADD_OR_REMOVE_CHILD_BAD_FLAGS			       enum FatalErrors
; Bad InsertChildFlags are being passed to VisInsertChild (probably via MSG_
; VIS_ADD_CHILD or MSG_VIS_REMOVE_CHILD).  Check what you're passing in bp.
; Also for GenInsertChild.
	
UI_REQUIRES_VISUAL_COMPOSITE				       enum FatalErrors
; Certain VisClass utilities require that the object in *ds:si be a composite.
; Check to make sure you have made your object is VisComp and set VTF_IS_COMP-
; OSITE, or look for where you might have trashed VI_typeFlags.
  
UI_REALIZED_VIS_OBJECT_CAN_NOT_BE_FREED			       enum FatalErrors
; A MSG_VIS_DESTROY was sent to a visual object that has not yet been closed.
; An object must receive a MSG_VIS_CLOSE first (or prehaps a MSG_GEN_SET_NOT-
; _USABLE for generic objects).
	
UI_VIS_OBJECT_IN_TREE_CAN_NOT_BE_FREED			       enum FatalErrors
; This object has received a MSG_VIS_DESTROY without being removed from the
; visual tree first.  Call MSG_VIS_REMOVE_CHILD on the parent, or for generic
; objects, do a MSG_GEN_SET_NOT_USABLE on the object first.
  
UI_VIS_OBJECT_WITH_CHILDREN_CAN_NOT_BE_FREED		       enum FatalErrors
; This object has received a MSG_VIS_DESTROY while it still has visual children.
; They must be removed (and probably destroyed) first via a MSG_VIS_REMOVE_-
; CHILD.

UI_BAD_VIS_TYPE_FLAGS					       enum FatalErrors
; Error checking code discovered an illegal combination of VI_typeFlags.
; Objects with VTF_IS_CONTENT or VTF_IS_ROOT must also be VTF_IS_WIN_GROUP;
; Objects with VTF_IS_WIN_GROUP must also be VTF_IS_WINDOW and VTF_IS_COMPOSITE
; and can't be VTF_IS_PORTAL.
  
UI_BAD_VIS_ATTRIBUTES					       enum FatalErrors
; A bad combination of VI_attrs was found.  Non win-group objects cannot ever
; have VA__VISIBLE set.
  
UI_BAD_VIS_SPEC_ATTRIBUTES				       enum FatalErrors
; A bad combination of VI_attrs was found.  Non win-group objects cannot have
; SA_USES_DUAL_BUILD or SA_TREE_BUILT_BUT_NOT_REALIZED or SA_REALIZABLE set.
  
UI_VIS_UPDATE_SPEC_BUILD_BUT_VIS_NOT_GROWN		       enum FatalErrors
; A MSG_SPEC_BUILD_BRANCH has been delivered to an object that doesn't have
; a vis part.  An assumption has been made that this can't happen.
							       
UI_STILL_VISIBLE_AFTER_VIS_UNBUILD			       enum FatalErrors
; An object has been unbuilt, but is still marked as VA_VISIBLE.  This should
; have been cleared as part of MSG_VIS_CLOSE.
	
UI_WIN_GROUP_HAS_NO_VIS_PARENT				       enum FatalErrors
; The default MSG_VIS_UPDATE_WIN_GROUP assumes that when it's setting a win-
; group object not visible, that it has a visual parent (i.e. is in the visible
; tree).  If it doesn't, something is really wrong.  Likely its a trashed 
; link pointer of some kind.
							       
UI_RELEASE_GADGET_EXCL_NO_OBJECT_PASSED			       enum FatalErrors
; MSG_VIS_RELEASE_GADGET_EXCL requires that an object be passed in ^lcx:dx.
  
UI_VIS_CONTENT_OPEN_WIN_WITH_NO_WIN			       enum FatalErrors
; When a MSG_VIS_OPEN_WIN is passed to VisContent object, it is assumed that
; the content has already received a window from the view via a MSG_VIS_CONTENT_
; VIEW_WIN_CREATED.  Perhaps something is wrong with the view; more likely,
; an object subclassed the latter message without calling the superclass, which
; is a no-no.
							       
UI_VIS_GET_PARENT_GEOMETRY_NO_PARENT			       enum FatalErrors
; VisGetParentGeometry requires that the object in *ds:si has a visual parent.
  
UI_VIS_GET_PARENT_GEOMETRY_PARENT_NOT_GROWN		       enum FatalErrors
; VisGetParentGeometry requires that the object's parent have its Vis master 
; class grown.
	
UI_VIS_GET_PARENT_GEOMETRY_PARENT_NOT_COMPOSITE		       enum FatalErrors
; VisGetParentGeometry requires that the object's parent have VTF_IS_COMPOSITE 
; set. If you get this, then something is really fishy (VI_typeFlags trashed on
; the parent?)
  
UI_NO_WINDOW_TO_CLOSE					       enum FatalErrors
; A MSG_VIS_WIN_ABOUT_TO_BE_CLOSED was passed to a non-window object (VTF_
; IS_WINDOW was clear.)  Either the update mechanism is screwed up, or some
; instance data was trashed.
  
UI_RATIO_OF_FIELD_WITH_FIELD_SIZE_ZERO			       enum FatalErrors
; We were trying to get the ratio of the field, but we think the size of the
; field is zero, which is probably quite wrong.   Check for a trashed field
; object or some other object along the way that might have masqueraded as a 
; field object.
  
UI_VIS_ADD_CHILD_REL_NO_GEN_PARENT			       enum FatalErrors
; The specific UI was trying to add a child to the visible tree based on its
; position in the generic tree.   Alas, for some reason it's not in the generic
; tree (has no gen parent).   The MSG_GEN_SET_USABLE mechanism should have
; caught this flaw earlier, so perhaps its not as obvious as not being in the
; generic tree.
	
UI_VIS_REMOVE_NO_VIS_PARENT				       enum FatalErrors
; Somehow during in VisRemove utility, the object being removed from the visual
; tree prematurely lost its visible parent.
  
UI_VIS_TEST_MONIKER_BAD_VALUE				       enum FatalErrors
; VisTestMoniker has internally broken some of its assumptions.  Perhaps there's
; a badly set up VisMoniker involved.
							       
VIS_MSG_VIS_VUP_CREATE_GSTATE_NOT_ANSWERED		       enum FatalErrors
; The above-mentioned method was sent & not responded to.  This should be
; impossible, since there is a VisClass default method handler which always
; returns a response.  Perhaps the method has been subclassed, & the handler
; for the subclass is not setting carry before returning, to indicate a
; response.

VIS_CANT_SET_TYPE_FLAGS_WHEN_REALIZED			       enum FatalErrors
; You must close your visual object before changing its type flags.
  
	; GEOMETRY MANAGER ERRORS
	
UI_BAD_GEO_FLAGS                                               enum FatalErrors
; VisGeoAttrs or VisGeoDimensionAttrs flags are passed which are not available.
  
UI_BAD_CHOOSE_OWN_SIZE					       enum FatalErrors
; If this occurred in the generic world, then you`ve likely set up some
; combination of object attributes that the system can't handle.  Make
; sure sizes and hints of all the objects seem within reasonable limits.  Try
; doing a vistree on the primary or other main windowed object to see what
; object might be getting too large.   For those working with visual objects 
; and  RSA_CHOOSE_OWN_SIZE bit was passed to a composite's MSG_VIS_RECALC_SIZE
; handler, but some kind of suggested size was passed as well, which is illegal.
; This can also occur from a ridiculous size being set for an object.
  
UI_CANT_WRAP_AND_DO_ONE_PASS				       enum FatalErrors
; This is just a bad idea.  The GA_ONE_PASS_OPTIMIZATION flag should not be
; set in a wrapping composite, or things won't work properly.
  
UI_RESIZE_BAD_CHILD_HANDLE                                     enum FatalErrors
; Shouldn't happen.  A bad handle was passed to the resize routine.
	
UI_GEOMETRY_SUGGESTED_WIDTH_TOO_LARGE			       enum FatalErrors
; If this occurred in the generic world, then you`ve likely set up some
; combination of object attributes that the system can't handle.  Make
; sure sizes and hints of all the objects seem within reasonable limits.  Try
; doing a vistree on the primary or other main windowed object to see what
; object might be getting too large.   For those working with visual objects:
; a very large suggested value has been calculated for an object's size or
; center.  This is usually from objects growing a little bit on each pass,
; and never stopping.  Historically, this has happened from a HINT_CENTER_
; CHILDREN_ON_MONIKERS.  Try setting VGA_ALWAYS_SEND_CALC_NEW_SIZE on the
; child and all its siblings.  More likely, you've created some recalc size
; handler that keeps returning a larger size than what was passed no matter
; what.

UI_GEOMETRY_SUGGESTED_HEIGHT_TOO_LARGE			       enum FatalErrors
; If this occurred in the generic world, then you`ve likely set up some
; combination of object attributes that the system can't handle.  Make
; sure sizes and hints of all the objects seem within reasonable limits.  Try
; doing a vistree on the primary or other main windowed object to see what
; object might be getting too large.   For those working with visual objects:
; a very large suggested value has been calculated for an object's size or
; center.  This is usually from objects growing a little bit on each pass,
; and never stopping.  Historically, this has happened from a HINT_CENTER_
; CHILDREN_ON_MONIKERS.  Try setting VGA_ALWAYS_SEND_CALC_NEW_SIZE on the
; child and all its siblings.  More likely, you've created some recalc size
; handler that keeps returning a larger size than what was passed no matter
; what.

UI_GEOMETRY_WIDTH_TOO_LARGE				       enum FatalErrors
; If this occurred in the generic world, then you`ve likely set up some
; combination of object attributes that the system can't handle.  Make
; sure sizes and hints of all the objects seem within reasonable limits.  Try
; doing a vistree on the primary or other main windowed object to see what
; object might be getting too large.   For those working with visual objects:
; a very large suggested value has been calculated for an object's size or
; center.  This is usually from objects growing a little bit on each pass,
; and never stopping.  Historically, this has happened from a HINT_CENTER_
; CHILDREN_ON_MONIKERS.  Try setting VGA_ALWAYS_SEND_CALC_NEW_SIZE on the
; child and all its siblings.  More likely, you've created some recalc size
; handler that keeps returning a larger size than what was passed no matter
; what.

UI_GEOMETRY_HEIGHT_TOO_LARGE				       enum FatalErrors
; If this occurred in the generic world, then you`ve likely set up some
; combination of object attributes that the system can't handle.  Make
; sure sizes and hints of all the objects seem within reasonable limits.  Try
; doing a vistree on the primary or other main windowed object to see what
; object might be getting too large.   For those working with visual objects:
; a very large suggested value has been calculated for an object's size or
; center.  This is usually from objects growing a little bit on each pass,
; and never stopping.  Historically, this has happened from a HINT_CENTER_
; CHILDREN_ON_MONIKERS.  Try setting VGA_ALWAYS_SEND_CALC_NEW_SIZE on the
; child and all its siblings.  More likely, you've created some recalc size
; handler that keeps returning a larger size than what was passed no matter
; what.

UI_GEOMETRY_SIZE_LEFT_OF_CENTER_TOO_LARGE		       enum FatalErrors
; If this occurred in the generic world, then you`ve likely set up some
; combination of object attributes that the system can't handle.  Make
; sure sizes and hints of all the objects seem within reasonable limits.  Try
; doing a vistree on the primary or other main windowed object to see what
; object might be getting too large.   For those working with visual objects:
; a very large suggested value has been calculated for an object's size or
; center.  This is usually from objects growing a little bit on each pass,
; and never stopping.  Historically, this has happened from a HINT_CENTER_
; CHILDREN_ON_MONIKERS.  Try setting VGA_ALWAYS_SEND_CALC_NEW_SIZE on the
; child and all its siblings.  More likely, you've created some recalc size
; handler that keeps returning a larger size than what was passed no matter
; what.

UI_GEOMETRY_SIZE_RIGHT_OF_CENTER_TOO_LARGE		       enum FatalErrors
; If this occurred in the generic world, then you`ve likely set up some
; combination of object attributes that the system can't handle.  Make
; sure sizes and hints of all the objects seem within reasonable limits.  Try
; doing a vistree on the primary or other main windowed object to see what
; object might be getting too large.   For those working with visual objects:
; a very large suggested value has been calculated for an object's size or
; center.  This is usually from objects growing a little bit on each pass,
; and never stopping.  Historically, this has happened from a HINT_CENTER_
; CHILDREN_ON_MONIKERS.  Try setting VGA_ALWAYS_SEND_CALC_NEW_SIZE on the
; child and all its siblings.  More likely, you've created some recalc size
; handler that keeps returning a larger size than what was passed no matter
; what.

UI_GEOMETRY_SIZE_ABOVE_CENTER_TOO_LARGE			       enum FatalErrors
; If this occurred in the generic world, then you`ve likely set up some
; combination of object attributes that the system can't handle.  Make
; sure sizes and hints of all the objects seem within reasonable limits.  Try
; doing a vistree on the primary or other main windowed object to see what
; object might be getting too large.   For those working with visual objects:
; a very large suggested value has been calculated for an object's size or
; center.  This is usually from objects growing a little bit on each pass,
; and never stopping.  Historically, this has happened from a HINT_CENTER_
; CHILDREN_ON_MONIKERS.  Try setting VGA_ALWAYS_SEND_CALC_NEW_SIZE on the
; child and all its siblings.  More likely, you've created some recalc size
; handler that keeps returning a larger size than what was passed no matter
; what.

UI_GEOMETRY_SIZE_BELOW_CENTER_TOO_LARGE			       enum FatalErrors
; If this occurred in the generic world, then you`ve likely set up some
; combination of object attributes that the system can't handle.  Make
; sure sizes and hints of all the objects seem within reasonable limits.  Try
; doing a vistree on the primary or other main windowed object to see what
; object might be getting too large.   For those working with visual objects:
; a very large suggested value has been calculated for an object's size or
; center.  This is usually from objects growing a little bit on each pass,
; and never stopping.  Historically, this has happened from a HINT_CENTER_
; CHILDREN_ON_MONIKERS.  Try setting VGA_ALWAYS_SEND_CALC_NEW_SIZE on the
; child and all its siblings.  More likely, you've created some recalc size
; handler that keeps returning a larger size than what was passed no matter
; what.
	
UI_CAN_ONLY_FULL_JUSTIFY_IN_DIRECTION_OF_CHILDREN	       enum FatalErrors
; Fix the full-justify hint or attribute.  A horizontal full-justify should
; only be set for a horizontal composite; a vertical full-justify only
; for a vertical composite.
  
UI_MUST_BE_VIS_COMP_TO_HAVE_MARGINS			       enum FatalErrors
; You should only call VisGetBoundsInsideMargins on a composite object.

UI_CANT_DO_CUSTOM_RECALC_SIZE_AND_DO_SPECIAL_JUSTIFICATION     enum FatalErrors
; The VisComp's default MSG_VIS_POSITION_BRANCH handler (part of the geometry 
; manager) was is being used to try an center, right, or bottom justify 
; children in a composite, without information that is usually generated from 
; the VisComp's default MSG_VIS_RECALC_SIZE handler.   If you are going to
; subclass an object's MSG_VIS_RECALC_SIZE handler to provide custom geometry
; management, you must either subclass the MSG_VIS_POSITION_BRANCH handler
; as well, or stop trying to use center, right or bottom justification.  (If
; none of this applies to you, there must be some memory trashing of the 
; internal ATTR_VIS_GEOMETRY_DATA going on.

UI_LARGE_DOCUMENT_FLAG_NOT_SET				enum FatalErrors 
; MSG_VIS_CONTENT_SET_DOC_BOUNDS was called on a VisContent
; that didn't have its VCNA_LARGE_DOCUMENT_MODEL flag set.  Make sure
; this flag is set before calling this method.

UI_POSITION_HINT_FORCES_OBJECT_OUTSIDE_VIS_PARENT_BOUNDS  enum FatalErrors
;
; A positioning hint (ATTR_GEN_POSITION, ATTR_GEN_POSITION_X, ATTR_GEN_POSITION_Y,
; HINT_ALIGN_TOP_EDGE_WITH_OBJECT, HINT_ALIGN_BOTTOM_EDGE_WITH_OBJECT,
; HINT_ALIGN_RIGHT_EDGE_WITH_OBJECT, HINT_ALIGN_LEFT_EDGE_WITH_OBJECT)
; has caused the object's bounds to be at least partially outside that of its
; visual parent.  You may need to allocate a fixed size (via HINT_FIXED_SIZE)
; for the parent to make it large enough to hold the object, or it could be
; that the object is being placed by the specific UI under some other composite,
; in which case you probably can't apply a positioning hint to it.

UI_EXPECTED_VIS_CLASS_OBJECT				  enum FatalErrors

UI_VIS_UPDATE_GEOMETRY_FAILED				enum FatalErrors
; Error reported if within the MSG_VIS_UPDATE_WIN_GROUP handler, 
; MSG_VIS_UPDATE_GEOMETRY is called, & yet on return, the 
; VOF_GEOMETRY_INVALID bit is still set in the object.

UI_BAD_WIN_SIZE_TYPE					enum FatalErrors
; The WinSizeType passed to MSG_GEN_SET_WIN_SIZE is not a legal value.

UI_BAD_WIN_POSITION_TYPE				enum FatalErrors
; The WinPositionType passed to MSG_GEN_SET_WIN_POSITION is not a legal value.

UI_BAD_WIN_CONSTRAIN_TYPE				enum FatalErrors
; The WinConstrainType passed to MSG_GEN_SET_WIN_CONSTRAIN is not a legal value.

;------------------------------------------------------------------------------
; 	SPECIFIC/VISUAL ERRORS
;------------------------------------------------------------------------------

VIS_ERROR_PASSIVE_GRAB_CHUNK_MISSING		       		enum FatalErrors
; VisContent's instance data holds references to assorted passive grab 
; chunks.  These chunks are created in MSG_VIS_INITIALIZE_WORKING_VARS,
; which is called from MSG_META_INITIALIZE.  This error results if somehow the
; chunk do not exist when input data is attempted to be sent through them.

UI_BAD_MSG_PASSED_TO_TRANSLATE_BUTTON                       enum FatalErrors
; The utility TranslateButton only handles MSG_META_BUTTON, MSG_META_PRE_PASSIVE_BUTTON,
; and MSG_META_POST_PASSIVE_BUTTON.  There must be some internal problem if this
; is not the case (or ax is trashed).

UI_MISSING_HANDLER_FOR_SPEC_GET_SPECIFIC_VIS_OBJECT	       enum FatalErrors
; SA_SIMPLE_GEN_OBJ cannot be set for an object uses a dual build (SA_USES_
; DUAL_BUILD).
	
UI_SPEC_BUILD_NO_VIS_PARENT                                    enum FatalErrors
; A visible parent cannot be found for this object, for some reason (MSG_SPEC_
; GET_VIS_PARENT didn't return anything).
  
UI_NO_PARENT_WIN_FOUND                                         enum FatalErrors
; In the default MSG_VIS_OPEN handler for an object, a window was not found
; for the object.
  
UI_VIS_PARENT_NOT_BUILT                                        enum FatalErrors
; An object has received a MSG_SPEC_BUILD, but its visual parent has not yet 
; been visually built.  If you have a custom MSG_SPEC_BUILD routine for the
; visual parent, make sure it's doing the right wrong.
  
UI_SPEC_BUILD_NOT_IN_GENERIC_TREE                               enum FatalErrors
; A MSG_SPEC_BUILD has been sent to an object that is not in the generic tree.
  
UI_BAD_SET_SPEC_ATTR_FLAGS 	                                enum FatalErrors
; The arguments passed to MSG_SPEC_SET_ATTRS had some illegal bits set.
  
UI_SPEC_BUILD_DEFAULT_MSG_CANNOT_HANDLE_DUAL_BUILD             enum FatalErrors
UI_SPEC_BUILD_BRANCH_DEFAULT_MSG_CANNOT_HANDLE_DUAL_BUILD      enum FatalErrors
; You have to specially subclass these messages if your object uses a 
; dual build (has SA_USES_DUAL_BUILD set).
  
UI_VIS_MONIKER_IS_STILL_VIS_MONIKER_LIST                       enum FatalErrors
; The moniker draw and size routines assume that any moniker lists have been
; converted to a particular moniker by now.  Perhaps a moniker list was passed
; to MSG_GEN_USE_VIS_MONIKER, which is not allowed.
  
UI_BAD_SEARCH_SPEC_IN_VIS_FIND_MONIKER                         enum FatalErrors
; Bad VisMonikerSearchFlags were passed to VisFindMoniker.
  
UI_BAD_DISPLAY_TYPE_IN_VIS_FIND_MONIKER                        enum FatalErrors
; A bad DisplayType was passed to VisFindMoniker.
  
UI_EXPECTED_VIS_TYPE_VTF_IS_GEN		                       enum FatalErrors
; A number of specific UI utility routines expect the Vis object passed to
; be generic (VTF_IS_GEN must be set).  These can't be used for non-generic
; objects.  If you expected your object to be generic, check to make sure you're
; not trashing VI_typeFlags.
  
UI_VIS_MASTER_NOT_READY_FOR_UNBUILD			       enum FatalErrors
; Generic objects are trying to be visually unbuilt (as a result of MSG_GEN_
; SET_NOT_USABLE), but there is something already wrong with the object's
; visual data.  Either its visual master class is not visually grown, 
; it doesn't have a parent link, or it's not a visual composite.
  
UI_GENERIC_WIN_GROUP_MUST_BE_NOT_VISIBLE_BEFORE_REMOVING       enum FatalErrors
; A generic object that is being set not realized is still open and visible.
; MSG_VIS_UPDATE_GEN_WIN_GROUP was supposed to have taken care of this.
							       
UI_BAD_NAVIGATE_COMMON_FLAGS				enum FatalErrors
; Bad NavigateCommonFlags were passed to VisNavigateCommon.
  
UI_NAVIGATION_CIRCUIT_BROKEN				enum FatalErrors
; Some object probably didn't handle MSG_SPEC_NAVIGATION_QUERY, or if it did,
; didn't return the carry set.
							
UI_NAVIGATION_QUERY_REACHED_ROOT_NODE_TWICE		enum FatalErrors
; It appears that the navigation stuff didn't find anything to navigate to.
; Make sure your vis objects are handling navigation correctly.
  
UI_NAVIGATION_QUERY_ROOT_NODE_MUST_BE_COMPOSITE		enum FatalErrors
; Navigation always starts from a composite.  Make sure you're doing the right
; thing or passing the correct flags to VisNavigateCommon.
  
UI_NAVIGATION_QUERY_MUST_TRAVEL_CIRCUIT_TO_BACKTRACK	enum FatalErrors
; If NF_BACKTRACK_AFTER_TRAVELING is passed to VisNavigateCommon, it must 
; also have NF_TRAVEL_CIRCUIT set as well.  See the navigation documentation.
  
UI_BAD_NAVIGATION_QUERY_FLAGS				enum FatalErrors
; NF_COMPLETED_CIRCUIT cannot be passed to VisNavigateCommon.  See the
; navigation documentation.
  
UI_NAVIGATION_QUERY_REACHED_WIN_GROUP			enum FatalErrors
; This shouldn't happen.  Navigation queries are always passed between 
; children of a win group.
  
UI_NAVIGATION_BROADCAST_FOR_ID_FAILED			enum FatalErrors
; At the start of VisNavigateCommon, a MSG_SPEC_START_BROADCASE_FOR_NAV_ID was 
; passed to the object's visual parent, to get an ID to find, and parent didn't
; return the carry set.
							
UI_NAVIGATION_NOT_SPEC_NAV_QUERY			enum FatalErrors
; VisNavigateCommon was called without ax being set to MSG_SPEC_NAVIGATION_
; QUERY, even though this is certainly being called in response to that 
; message.  Make sure you haven't biffed ax.
  
UI_BAD_FLAGS_IN_HIERARCHICAL_GRAB			enum FatalErrors
; An object passed to either FlowGainedExcl or FlowLostExcl had bad 
; HierarchicalGrabFlags.
  
UI_GENERIC_BRANCH_MUST_BE_NOT_USABLE_BEFORE_VISIBLY_UNGROWN    enum FatalErrors
; A MSG_SPEC_UNBUILD_BRANCH was sent to a generic object that wasn't already
; fully usable.  Something fishy is going on.
							       
UI_BAD_DRAW_MONIKER_FLAGS				enum FatalErrors
; Bad DrawMonikerFlags were passed to VisDrawMoniker.

UI_NON_MOUSE_EVENT					enum FatalErrors
; Error in ConvertToLargeMouseEvent which occurs if the method in AX is
; not a mouse event which can be turned into a LARGE mouse event.

UI_MOUSE_GRAB_WINDOW_BEING_DESTROYED			enum FatalErrors
; If object has grabbed but not yet release the mouse on a window which
; is being destroyed, this will result.

UI_GUP_QUERY_CALLED_ON_NON_GEN_OBJECT			enum FatalErrors
; For some reason, a MSG_SPEC_GUP_QUERY_VIS_PARENT was sent to a non-generic
; vis object.  Either the caller doesn't know what it's doing, or instance
; data got trashed.
  
;------------------------------------------------------------------------------
;	 DATA TRANSFER ERRORS (userTransfer.asm)
;------------------------------------------------------------------------------
BAD_TRANSFER_FLAGS                                             enum FatalErrors
; Bad ClipboardItemFlags passed to ClipboardRegisterItem, ClipboardQueryItem,
; or ClipboardRequestItemFormat.  Or bad ClipboardItemFlags stored in
; ClipboardItemHeader.  Make sure correct flags are passed.

BAD_TRANSFER_FORMAT_COUNT                                      enum FatalErrors
; CIH_formatCount field in ClipboardItemHeader is out of range.  Must be
; between 1 and CLIPBOARD_MAX_FORMATS.

NON_UI_TRANSFER_ITEM_EXISTS				       enum FatalErrors
; A transfer item from a VM file other than the UI's transfer VM file has
; been registered.  This is not supported.

UI_CANNOT_CREATE_TRANSFER_FILE				       enum FatalErrors
; Unable to open or create the UI's transfer VM file (clipboard file).  This
; may indicated a disk problem.

TRANSFER_ITEM_IS_ALREADY_ACTIVE				       enum FatalErrors
; Attempt to register a transfer item (normal or quick) that is already the
; current transfer item.  This is illegal.  If you are registering a new item,
; make sure your create a new item.

TRANSFER_ITEM_ALREADY_IN_FREE_LIST			       enum FatalErrors
TRANSFER_ITEM_DONE_REF_COUNT_IS_ZERO			       enum FatalErrors
TRANSFER_ITEM_DONE_NOT_FOUND				       enum FatalErrors
; Internal error

TRANSFER_FREE_LIST_NOT_EMPTY				       enum FatalErrors
; Attempt to exit the system when ClipboardQueryItems are still active
; (corresponding ClipboardDoneWithItem haven't been called).

WRONG_QUICK_NOTIFY_FLAGS_FOR_TRANSFER_DONE		       enum FatalErrors
; Bad ClipboardQuickNotifyFlags passed to ClipboardEndQuickTransfer.  Only one of CQNF_MOVE,
; CQNF_COPY, and CQNF_NO_OPERATION is allowed.  Pass the correct one, depending
; on the operation that occured.

BAD_QUICK_TRANSFER_XOR_REGION				       enum FatalErrors
; The region to use for quick-tranfser cursor must be in a block that is in
; memory already.  You can ensure this by locking the block before calling
; ClipboardStartQuickTransfer or specifying the block has 'fixed'.

BAD_TRANSFER_FILE_CLOSE_MISSING				       enum FatalErrors
BAD_TRANSFER_FILE_CLOSE_NO_MAP				       enum FatalErrors
; UI's transfer VM file (clipboard file) has been damaged during the current
; session.  It could not be closed successfully.

BAD_FLOW_QUICK_TRANSFER_FLAGS			       	       enum FatalErrors
; Bad ClipboardQuickTransferFlags passed to ClipboardStartQuickTransfer.  Make sure
; only valid flags are passed.

BAD_QUICK_TRANSFER_CURSOR				       enum FatalErrors
; Bad ClipboardQuickTransferFeedback enum passed to QuickTransferSetCursor.  Make sure
; a valid value is passed.

BAD_TRANSFER_HEADER_SIZE				       enum FatalErrors
; The ClipboardItemHeader of a transfer item is too small.  Make sure the
; correct VM block handle is passed to ClipboardRegisterItem.

QUICK_TRANSFER_ITEM_STILL_HAS_REFERENCES			enum Warnings
UNDO_TRANSFER_ITEM_STILL_HAS_REFERENCES				enum Warnings
NORMAL_TRANSFER_ITEM_STILL_HAS_REFERENCES			enum Warnings
; A transfer item still has references, mostly likely meaning some geode
; called ClipboardQueryItem() but failed to call ClipboardDoneWithItem()
; when it was finished.

;------------------------------------------------------------------------------
;	 TOKEN DATABASE ERRORS
;------------------------------------------------------------------------------

SHARED_TOKEN_DATABASE_FILE_HAS_BAD_PROTOCOL_NUMBER	       enum FatalErrors
; The shared token database file on the path specified in the .INI
; file is out of date and must be replaced.
;

COULD_NOT_OPEN_SHARED_TOKEN_DATABASE_FILE		       enum FatalErrors
; Either the path for the shared token database is wrongly specified
; in the .INI file (note that the file name should *not* be included
; in the path specification) or VMOpen returned an error, in which
; case the file may be invalid.
;

COULD_NOT_OPEN_LOCAL_TOKEN_DATABASE_FILE		       enum FatalErrors
; No local token database file could be opened and no shared token
; database file path appears in the .INI file. If you're running on a
; read-only file-system then you *must* have a shared token database.
;

NO_TOKEN_DATABASE_FILE_HANDLE				       enum FatalErrors
; The stored file handle for either the local or the shared token
; database file (whichever one an attempt was made to use) appears
; to be null. Is ds equal to dgroup?
;

TOKEN_DB_ITEM_IS_NOT_MONIKER_LIST                              enum FatalErrors
; The database item which has just been locked should contain the
; moniker list for the token presently being defined, but it doesn't.
; Make sure the correct group and item are being passed from
; TokenDefineToken to AddMonikers.
;

ALLOCATE_TOKEN_DB_ITEM_PASSED_BAD_CHUNK_HANDLE                 enum FatalErrors
; AllocateTokenDBItem has been passed an invalid chunk handle from
; TokenDefineToken or AddMonikers.
;

;------------------------------------------------------------------------------
;	 ILLEGAL GENERIC INSTANCE DATA ERRORS
;------------------------------------------------------------------------------
LA_LIST_MSG_IS_DATA_REQUIRES_LA_LIST_MESSAGE                   enum FatalErrors
GA_SEND_USER_CHANGES_REQUIRES_GA_DELAYED                       enum FatalErrors
UI_ERROR_ADD_MODE_REQUIRES_NON_EXCLUSIVE_LIST		       enum FatalErrors
UI_ERROR_GEN_LIST_ENTRY_STATE_MUST_MATCH_GEN_LIST_STATE	       enum FatalErrors
FID_LIST_MUST_BE_IGNORE_DIRTY				       enum FatalErrors
GEN_FIELD_DOESNT_HAVE_APP_REF_CHUNK			       enum FatalErrors
GEN_FIELD_BAD_NUM_RESTARTED_APPS			       enum FatalErrors
GEN_BAD_OBJECT_REFERENCE				       enum FatalErrors
UI_DYNAMIC_LIST_MAY_NOT_HAVE_STATIC_CHILDREN		       enum FatalErrors
CANNOT_FIND_APP_IN_LIST					       enum FatalErrors
RECEIVED_MULTIPLE_MSG_GEN_APP_OBJECT_DETACHES	               enum FatalErrors
MSG_DETACH_SENT_TO_PROCESS_BEFORE_APPLICATION_OBJECT	       enum FatalErrors
NO_DISK_HANDLE_IN_APP_INSTANCE_REFERENCE                       enum FatalErrors
UI_BAD_APP_ACK_ID		                               enum FatalErrors
UI_STARTUP_DONE_MSG_RECEIVED_BEFORE_STARTUP_NOTIFY	       enum FatalErrors
UI_NO_CURRENT_FIELD_EXCLUSIVE                                  enum FatalErrors
UI_CANNOT_LOAD_SPECIFIC_UI                                     enum FatalErrors
UI_CANNOT_REPLACE_APPLICATION_MONIKER_LIST		       enum FatalErrors
UI_PROCESS_UNKOWN_ACK_SOURCE				       enum FatalErrors
GEN_PROCESS_UNKOWN_ACK_SOURCE				       enum FatalErrors
GEN_FIELD_DETACH_CONFIRM_BAD_FLAG			       enum FatalErrors
UI_GEN_FIELD_GEN_APPLICATION_LIST_CORRUPT		       enum FatalErrors
UI_GEN_APPLICATION_PARENT_NOT_GEN_FIELD			       enum FatalErrors

UI_FLOW_RECEIVED_TWO_INK_REPLIES			       enum FatalErrors
;	The flow object received a MSG_FLOW_INK_REPLY when it was not expecting
;	it.

UI_INVALID_INK_RETURN_VALUE				       enum FatalErrors
; 	Some object returned an invalid value to the MSG_META_QUERY_IF_PRESS_IS_INK
;	message.
;

UI_BAD_INK_RETURN_VALUE_PASSED_TO_GEN_APP_INK_QUERY_REPLY      enum FatalErrors
;	An object passed a bad InkReturnValue in CX with 
;	MSG_GEN_APPLICATION_INK_QUERY_REPLY.
;

GASP_CHOKE_WHEEZE						enum FatalErrors
; This is generated by some of the IACP support code in GenApplication when
; something unexpected happens. Either vardata has been corrupted, or I
; messed up -- ardeb
; 

INVALID_ADDITIONAL_TOKENS_ATTRIBUTE				enum FatalErrors
; The ATTR_GEN_APPLICATION_ADDITIONAL_TOKENS attribute for a GenApplication
; object ends with an incomplete GeodeToken structure.

;------------------------------------------------------------------------------
;	 FLOW OBJECT ERRORS
;------------------------------------------------------------------------------
FLOW_IMPLIED_MOUSE_GRAB_HOLDS_DYING_OBJECT		       enum FatalErrors

FLOW_MOUSE_GRAB_NOT_RELEASED_BY_DYING_OBJECT		       enum FatalErrors
; Most common cause:   Destruction of a generic object which is still
; GS_USABLE & attached to the generic tree, or a visible object which
; is still in the visible tree.  This can happen if LMemFree, MSG_META_OBJ_FREE,
; MSG_META_BLOCK_FREE are called on the chunk/object/block
; that the object resides in, while it is still active.  These primitives may
; only be used AFTER the object/block has been properly shutdown, i.e. set
; NOT_USABLE & removed from the generic tree for generic objects, &
; MSG_VIS_REMOVE'd from the visual tree for vis objects.   Note that if the 
; intent is to destroy only individual objects or branches, & not an entire
; block, MSG_GEN_DESTROY & MSG_VIS_DESTROY do the job quite nicely, performing
; the pre-requisite shutdown procedures, and then nuking the objects.

FLOW_KBD_GRAB_NOT_RELEASED_BY_DYING_OBJECT		       enum FatalErrors
; Most common cause:   Destruction of a generic object which is still
; GS_USABLE & attached to the generic tree, or a visible object which
; is still in the visible tree.  This can happen if LMemFree, MSG_META_OBJ_FREE,
; MSG_META_BLOCK_FREE are called on the chunk/object/block
; that the object resides in, while it is still active.  These primitives may
; only be used AFTER the object/block has been properly shutdown, i.e. set
; NOT_USABLE & removed from the generic tree for generic objects, &
; MSG_VIS_REMOVE'd from the visual tree for vis objects.   Note that if the 
; intent is to destroy only individual objects or branches, & not an entire
; block, MSG_GEN_DESTROY & MSG_VIS_DESTROY do the job quite nicely, performing
; the pre-requisite shutdown procedures, and then nuking the objects.

FLOW_MOUSE_GRAB_NOT_RELEASED_BY_OBJECT_IN_CLOSED_WINDOW	       enum FatalErrors
FLOW_IMPLIED_GRAB_CONTAINS_CLOSED_WINDOW		       enum FatalErrors
FLOW_PASSIVE_MOUSE_GRAB_NOT_RELEASED_BY_CLOSED_WINDOW	       enum FatalErrors
FLOW_RELEASE_GRAB_UNCHANGED	       			       enum FatalErrors
FLOW_REQUEST_GRAB_UNCHANGED	       			       enum FatalErrors
FLOW_GRAB_NO_MASTER					       enum FatalErrors
FLOW_SEND_MSG_IF_MISMATCH_BAD_ASSUMPTION		       enum FatalErrors

USER_STANDARD_DIALOG_CANNOT_BE_CALLED_FROM_UI		       enum FatalErrors
USER_DO_DIALOG_CANNOT_BE_CALLED_FROM_SINGLE_THREADED_APP       enum FatalErrors
USER_STANDARD_DIALOG_BAD_PARAMS				       enum FatalErrors
UI_NEW_INPUT_EVENT_PROCESSED_BEFORE_HOLD_UP_QUEUE_FLUSHED      enum FatalErrors
UI_HELD_UP_INPUT_EVENT_RE_ROUTED_TO_BACK_OF_HOLD_UP_QUEUE      enum FatalErrors
UI_ERROR_NEGATIVE_HOLD_UP_INPUT_COUNT			       enum FatalErrors
UI_ERROR_CURRENT_MOUSE_MSG_SHOULD_NOT_BE_NULL		       enum FatalErrors
UI_FLOW_OBJECT_NO_LONGER_SUPPORTS_PASSIVE_GRABS		       enum FatalErrors

UI_FLOW_INK_HOLD_UP_INPUT_FAILED			       enum FatalErrors
; The flow object tried to hold up input while waiting to see if the button 
; press should be ink or not, but it couldn't for some reason.

UI_FLOW_RECEIVED_UNEXPECTED_INK				       enum FatalErrors
; The flow object received ink when it wasn't expecting one (had not
; told the IM that it wanted Ink)

UI_FLOW_GRAB_WITHIN_LEVEL_ILLEGAL_FLAGS 		       enum FatalErrors
; FlowGrabWithinLevel has received bad flags in bp.

FLOW_HIERARCHICAL_GRAB_ERROR_CAN_NOT_GRAB_FROM_SELF 		enum FatalErrors
; This happens when FlowGrabWithinLevel, or MSG_VUP_GRAB_* is handled by the
; same object as the optr which is passed requesting the grab.  This isn't 
; allowed, for infinite loops would result on MSG_META_GAINED_* coming into a node
; which has grabbed itself.
  
FLOW_ERROR_HIERARCHICAL_NODE_ALREADY_HAS_APP_EXCL 		enum FatalErrors
; This happens if FlowGainedAppExcl is called on a hierarchical grab node that
; already has the app exclusive, i.e. HGF_APP_EXCL is true.   Check to make
; sure that you haven't intercepted the LOST_APP_XXX_EXCL and forgotten to
; pass it onto the superclass (at the end of the method handler).

FLOW_ERROR_HIERARCHICAL_NODE_DOES_NOT_HAVE_APP_EXCL 		enum FatalErrors
; This happens if FlowLostAppExcl or FlowGainedSysExcl is called on a
; hierarchical grab node that does not have the app exclusive, i.e.
; HGF_APP_EXCL is false.  Check to see make sure you haven't intercepted the
; GAINED_APP_XXX_EXCL message & not called the superclass with it (at the
; start of the method handler).

FLOW_ERROR_HIERARCHICAL_NODE_ALREADY_HAS_SYS_EXCL		enum FatalErrors
; Happens if FlowGainedSysExcl called on hierarchical grab node that already
; has the system-wide exclusive, i.e. the HGF_SYS_EXCL bit is set.  Check
; to make sure you haven't intercepted the LOST_SYS_XXX_EXCL and forgotten to
; call the superclass (at the end of the method handler).

FLOW_ERROR_HIERARCHICAL_NODE_DOES_NOT_HAVE_SYS_EXCL	enum FatalErrors
; Happens if FlowLostSysExcl called on hierarchical grab node that does not
; have the system-wide exclusive, i.e. the HGF_SYS_EXCL bit is clear.  Check
; to make sure you haven't intercepted the GAINED_SYS_XXX_EXCL and forgotten
; to call the superclass (at the start of the method handler).

FLOW_ERROR_BAD_MASTER_OFFSET					enum FatalErrors
; This happens if a master offset is passed which is to large to be valid.

MAX_INSTANCE_OFFSET	equ	2048
; Maximum legal offset within an object's instance data to a
; HierarchicalGrab structure.  Allows checking for bad offset being
; passed to a number of utility routines.  Yes, this number is rather
; arbitrary.

FLOW_ERROR_BAD_INSTANCE_OFFSET					enum FatalErrors
; This happens if an offset within a master instance level is passed which
; is too large to be valid (the comparison is made against MAX_INSTANCE_OFFSET)

UI_ILLEGAL_MOUSE_RETURN_FLAGS					enum FatalErrors
; All handlers of mouse events are responsible for returning valid
; MouseReturnFlags in AX.  Failure to do so will result in this death,
; immediately upon return to the VisContentClass object which has called the
; active/implied mouse grab to process the current mouse event.  ^lbx:si will
; either be pointing to the active mouse grab, or if there is no active
; grab, then to the VisContent above the implied mouse grab.
; NOTE:  If you have no particular directives for the input system after
; having processed a mouse event, just return AX = 0.
;
FLOW_BAD_MESSAGE_COMBO_PASSED_TO_FlowUpdateHierarchicalGrab			enum FatalErrors
; Just what it says -- either the base message, or the operation message, or
; both, are bad, based on the simple test of operation message - base message
; not falling into a valid range.

FLOW_BAD_FLAGS_PASSED_TO_FlowAlterHierarchicalGrab			enum FatalErrors
; This is the result of passing HGF_SYSTEM to FlowAlterHierarchicalGrab, which
; isn't allowed.

;------------------------------------------------------------------------------
;	PROCESS CLASS ERRORS
;------------------------------------------------------------------------------
STATE_FILE_PASSED_BUT_MODE_WAS_NOT_RESTORE_FROM_STATE	       enum FatalErrors
NO_APP_LAUNCH_BLOCK_PASSED_TO_APPLICATION		       enum FatalErrors
NO_STATE_FILE						       enum FatalErrors
STATE_FILE_ALREADY_SET					       enum FatalErrors

;------------------------------------------------------------------------------
;	SOUND ERRORS
;------------------------------------------------------------------------------
BAD_STANDARD_SOUND_TYPE					       enum FatalErrors

;------------------------------------------------------------------------------
;	VIEW ERRORS
;------------------------------------------------------------------------------
UI_BAD_GEN_VIEW_INK_TYPE				       enum FatalErrors
; The GVI_inkType field had an invalid value

UI_VIEW_NEG_WIDTH_PASSED_TO_SET_SIMPLE_BOUNDS			enum FatalErrors
UI_VIEW_NEG_HEIGHT_PASSED_TO_SET_SIMPLE_BOUNDS			enum FatalErrors
; You can't use the simpler GenViewSetSimpleBounds if you're going to have
; negative bounds.
	
UI_VIEW_BAD_MESSAGE_FLAGS_PASSED_TO_SET_SIMPLE_BOUNDS		enum FatalErrors
; The only flags that can be passed to GenViewSetSimpleBounds in di are
; MF_FIXUP_DS and MF_FIXUP_ES.  If you're hoping to record the message, or
; use the message flags some other way, use the full-featured MSG_GEN_VIEW_-
; SET_DOC_BOUNDS.

UI_VIEW_BAD_DOC_BOUNDS						enum FatalErrors
; Something`s wrong with the bounds you passed to MSG_GEN_VIEW_SET_DOC_BOUNDS.
; Likely the width or height of the content is negative, which is bad.
	
UI_VIEW_BAD_INCREMENT						enum FatalErrors
; The increment is negative, which is not allowed.
  
UI_VIEW_LINKAGE_MUST_BE_CIRCULAR			       enum FatalErrors
; Either the horizontal or the vertical linkage is not continuous.  The
; vertical or horizontal linkage, if there is any, must be continuous and
; pass through each view exactly once, and be circular (i.e. last node
; is linked to the first).
  
UI_CX_DX_MUST_BE_VALID_VIEW_OBJECT			       enum FatalErrors
; A view object hasn't been passed to MSG_META_CONTENT_VIEW_OPENING.  Something
; internal is probably wrong.
  
UI_VIS_CONTENT_NEEDS_TO_HANDLE_TRACK_SCROLLING_BETTER	enum FatalErrors
; The content didn't have a target object or even a visible child to send the
; MSG_META_CONTENT_TRACK_SCROLLING to.  This message must be answered.  Either
; add a child who can respond to the message, subclass the VisContent handler
; to do it yourself, or turn off track scrolling in the view.

UI_VIS_CONTENT_MUST_BE_OWNED_BY_AN_APPLICATION	       enum FatalErrors
; When a MSG_META_QUERY_IF_PRESS_IS_INK is received by a VisContent, it needs to
; be able to send a reply to an associated GenApplication object, which it
; can only do if it is owned by an application (not the UI).

UI_VIS_CONTENT_CAN_NOT_GRAB_OR_RELEASE_THIS_EXCL		enum FatalErrors
; Occurs if MSG_VIS_VUP_ALTER_INPUT_FLOW is called on VisContent w/
; VIFGF_NOT_HERE flag set, which can happen if the VisContent attempts
; to grab the active mouse or keyboard exclusive.  Since the VisContent 
; & GenView are effectively one single node in the input flow hierarchy, it
; is illegal for the VisContent to attempt to grab exclusives from the
; GenView, for they do not exists.

UI_CANT_MAKE_SPLITTABLE_VIA_MESSAGE			       enum FatalErrors

UI_REALIZED_VIS_OBJECT_HAD_NO_WINDOW			       enum FatalErrors
; Occurs if VisCallChildrenInBounds tried to get the gwin of a realized
; windowed VisComp object, and VisQueryWindow returned 0.
;

UI_WINDOWED_VIS_OBJECT_HAD_SAME_WINDOW_AS_PARENT	       enum FatalErrors
; Occurs if an object with VTF_IS_WINDOW/PORTAL had the same VCI_gwin as its
; parent.	

;------------------------------------------------------------------------------
;	 FILE SELECTOR ERRORS
;------------------------------------------------------------------------------
GEN_FILE_SELECTOR_BAD_ATTRS					enum FatalErrors
; Occurs if bad FileSelectorAttrs are passed to MSG_GEN_FILE_SELECTOR_SET_ATTRS.
; Make sure only valid flags are set.

GEN_FILE_SELECTOR_BAD_FILE_TYPES				enum FatalErrors
; Occurs if bad FileSelectorFileTypes are passed to
; MSG_GEN_FILE_SELECTOR_SET_FILE_TYPES.  Make sure only valid flags are set.

GEN_FILE_SELECTOR_BAD_FILE_CRITERIA				enum FatalErrors
; Occurs if bad FileSelectorFileCriteria are passed to
; MSG_GEN_FILE_SELECTOR_SET_FILE_CRITERIA.  Make sure only valid flags are set.

GEN_FILE_SELECTOR_BAD_DOS_ATTRS					enum FatalErrors
; Occurs if bad FileAttrs are passed to MSG_GEN_FILE_SELECTOR_SET_DOS_ATTRS.
; Make sure only valid flags are set.

GEN_FILE_SELECTOR_BAD_GEODE_ATTRS				enum FatalErrors
; Occurs if bad GeodeAttrs are passed to MSG_GEN_FILE_SELECTOR_SET_GEODE_ATTRS
; for either the match attrs or the mismatch attrs.  Make sure only valid flags
; are set.

GEN_FILE_SELECTOR_TEMP_DATA_NOT_FOUND				enum FatalErrors
; Occurs whenever the GFSTempDataEntry variable data for a GenFileSelector
; is not found when it is expected to exists.  Most likely, the memory space
; for the object has been trashed.

;------------------------------------------------------------------------------
;	GenControl errors
;------------------------------------------------------------------------------

GEN_CONTROL_INTERNAL_ERROR					enum FatalErrors
; Error within GenControl logic, presumably caused by the UI not behaving
; as advertised.

GEN_APP_GCN_INTERNAL_ERROR					enum FatalErrors
; Error within GenApplication GCN optimization mechanism -- something happened
; to the GCN lists which isn't supposed to be able to happen.

ROUTINE_REQUIRES_GEN_CONTROL_OBJECT_AS_INPUT			enum FatalErrors
; GenControlOutputActionRegs/Stack or GenControlSendToOutputRegs/Stack was
; not passed a valid GenControlObject as the input	

GEN_CONTROL_MUST_BE_ON_ACTIVE_LIST				enum FatalErrors
; The GenControl object must be placed on the active list.  You can do this in
; your .ui/.goc file with gcnList(MANUFACTURER_ID_GEOWORKS,MGCNLT_ACTIVE_LIST)
; or dynamically with MSG_META_GCN_LIST_ADD sent to the appropriate
; GenApplication object.

GEN_CONTROL_CANNOT_SET_ALWAYS_INTERACTABLE_IF_NOT_ON_ACTIVE_LIST enum FatalErrors
; This GenControl class has GCBF_ALWAYS_INTERACTABLE set but not
; GCBF_IS_ON_ACTIVE_LIST

GEN_CONTROL_CANNOT_SET_ALWAYS_ON_GCN_LIST_IF_NOT_ON_ACTIVE_LIST	enum FatalErrors
; This GenControl class has GCBF_ALWAYS_ON_GCN_LIST set but not
; GCBF_IS_ON_ACTIVE_LIST

GEN_CONTROL_MUST_BE_ON_SELF_LOAD_OPTIONS_LIST			enum FatalErrors
; The GenControl object must be placed on the self-load options list.  You can
; do this in your .ui/.goc file with
; gcnList(MANUFACTURER_ID_GEOWORKS,GAGCNLT_SELF_LOAD_OPTIONS) or dynamically
; with MSG_META_GCN_LIST_ADD sent to the appropriate GenApplication object.

GEN_CONTROL_MUST_BE_ON_STARTUP_LOAD_OPTIONS_LIST		enum FatalErrors
; The GenControl object must be placed on the startup options list.  You can
; do this in your .ui/.goc file with
; gcnList(MANUFACTURER_ID_GEOWORKS,GAGCNLT_STARTUP_LOAD_OPTIONS) or dynamically
; with MSG_META_GCN_LIST_ADD sent to the appropriate GenApplication object.

GEN_CONTROL_NO_DUP_BLOCKS					enum FatalErrors
; A GenControl object had neither normal UI nor toolbox UI to duplicate.
; The help mechanism uses these to get the library a controller is defined in,
; and both are NULL, something is probably wrong.

TEMP_INSTANCE_IS_MARKED_SAVE_TO_STATE				enum FatalErrors
; A GenControl object has some TEMP vardata marked SAVE_TO_STATE, which is
; bad.
;

GEN_CONTROL_HELP_CONTEXT_TOO_LONG				enum FatalErrors
; The help context for the controller is too long.  This probably means that
; the string is not null-terminated.  The maximum length is 30

GEN_CONTROL_DIDNT_BUILD_TO_VIS_COMP				enum FatalErrors
; A GenControl object is being detached and wishes to quickly sever the
; visible link between itself and its presumed children, but cannot do so
; as it finds it is not a subclass of VisComp. This is a Bad Thing, as it means
; the controller can't actually have any visual children. Since I can't think
; where the controller's children might actually go otherwise, I hereby declare
; it illegal.

;------------------------------------------------------------------------------
;	GenPath errors
;------------------------------------------------------------------------------
GEN_PATH_DISK_HANDLE_NOT_SAVED					enum FatalErrors
; Need to restore a disk handle saved by the GenPath code, but the vardata entry
; that holds the information doesn't exist. Either the application, the kernel
; or fate has nuked it, as it's supposed to be there...

GEN_PATH_PATH_TO_SET_MAY_NOT_BE_IN_SAME_BLOCK_AS_OBJECT		enum FatalErrors
; Because the act of setting the path bound to an object may cause the chunks
; in the object's block (owing to the creation of a new vardata entry for
; the object), the path being set may not be in the same block as the object
; (because it would also likely move and GenPathSetObjectPath has no way of
; tracking it).

GEN_PATH_CANT_UNRELOCATE_DISK_HANDLE				enum FatalErrors
; For an object with GenPath info, if the path has never been set with
; MSG_GEN_PATH_SET, the disk handle can only be relocated if there is
; accompanying disk handle vardata or if the disk handle is a standard path.

GEN_PATH_UNHANDLED_DISK_RESTORE_ERROR				enum FatalErrors
; DiskRestore (or the callback for it) returned an error code for which we
; have no message to display.
; 

;------------------------------------------------------------------------------
;	GenToolControl errors
;------------------------------------------------------------------------------

GEN_TOOL_CONTROL_REQUIRES_AT_LEAST_ONE_TOOLBOX_TO_BE_SPECIFIED	enum FatalErrors
GEN_TOOL_CONTROL_BAD_TOOLBOX_LIST				enum FatalErrors
GEN_TOOL_CONTROL_INTERNAL_ERROR					enum FatalErrors

;------------------------------------------------------------------------------
;	GenDisplay/GenDisplayGroup/GenPrimary errors
;------------------------------------------------------------------------------

UI_GEN_DISPLAY_PARENT_NOT_GEN_DISPLAY_GROUP		       enum FatalErrors

UI_GEN_DISPLAY_GROUP_BAD_ATTRS			       enum FatalErrors
; Bad GenDisplayGroupAttrs passed to MSG_GEN_DISPLAY_GROUP_SET_ATTRS.

UI_GEN_DISPLAY_BAD_ATTRS			       	       enum FatalErrors
; Bad GenDisplayAttrs passed to MSG_GEN_DISPLAY_SET_ATTRS.

;------------------------------------------------------------------------------
;	GenItemGroup errors
;------------------------------------------------------------------------------

GEN_ITEM_GROUP_SELECTION_MARKED_INCORRECTLY_FOR_ZERO_SELECTIONS enum FatalErrors
; If GIGI_numSelections is zero, GIGI_selection must be set to GIGS_NONE_-
; SELECTED.  Likely this error was caused by incorrect setup of these variables
; in the .ui or .goc definition of the object.  Less likely, but possible,  is 
; there is an internal error in the GenItemGroup code that is causing this to
; happen.

GEN_ITEM_GROUP_INCORRECT_SIZE_FOR_SELECTION_CHUNK		enum FatalErrors
; Apparently GIGI_numSelections is set to some value greater than one, which
; implies that GIGI_selections should be a chunk handle of a chunk of words
; describing the selections.  The size of this chunk does not correspond to
; the value in GIGI_numSelections.  Most likely, an error was made in setting
; up the .ui or .goc definition for a GenItemGroup.  Less likely, but possible,
; is there is an internal error in the GenItemGroup code that is causing this to
; happen.
;

GEN_DYNAMIC_LIST_SAME_ITEM_TWICE_IN_REMOVAL_LIST		enum FatalErrors
; When calling MSG_GEN_DYNAMIC_LIST_REMOVE_ITEM_LIST, the same item should not 
; be passed twice in the list of items to remove.
;

UNDO_START_COUNT_OVERFLOW				       enum FatalErrors
; MSG_GEN_PROCESS_START_UNDO_CHAIN was sent to the process 65536 times.
;

UNDO_START_COUNT_UNDERFLOW				       enum FatalErrors
; MSG_GEN_PROCESS_END_UNDO_CHAIN was sent to the process more times than
; MSG_GEN_PROCESS_START_UNDO_CHAIN
;

MUST_SET_CONTEXT_BEFORE_SENDING_UNDO_MESSAGES		       enum FatalErrors
; No undo context was set when an UNDO message was sent.
;

BAD_START_OF_CHAIN_TOKEN				       enum FatalErrors
; The start of the undo chain was invalid
;

ADD_ACTION_SENT_BEFORE_START_UNDO			       enum FatalErrors
; A MSG_GEN_PROCESS_ADD_UNDO_ACTION was received when there was no active
; undo chain.

BAD_UNDO_ACTION_DATA_TYPE				       enum FatalErrors
; An invalid UndoActionDataType was passed to GenProcessAddUndoAction.
;

FLUSH_SENT_BEFORE_END_OF_UNDO_CHAIN			       enum FatalErrors
; A MSG_GEN_PROCESS_FLUSH_UNDO_ACTIONS was sent before the current Undo
; chain was terminated.	
;

UNDO_CONTEXT_SWITCHED_BEFORE_END_OF_UNDO_CHAIN		       enum FatalErrors
; A MSG_GEN_PROCESS_SET_UNDO_CONTEXT was sent before the current undo chain
; was terminated.
;

UNDO_CHAIN_PLAYED_BACK_BEFORE_ENDED			       enum FatalErrors
; A MSG_GEN_PROCESS_PLAYBACK_UNDO_CHAIN was sent before the current undo chain
; was terminated.
;

UNDO_START_COUNT_NON_ZERO_WHEN_PROCESS_EXITED		       enum FatalErrors
; The process exited with more calls to MSG_GEN_PROCESS_START_UNDO_CHAIN
; than END_UNDO_CHAIN.	
;

UNDO_IGNORE_COUNT_NON_ZERO_WHEN_PROCESS_EXITED		       enum FatalErrors
; The process exited with more calls to MSG_GEN_PROCESS_IGNORE_ACTIONS
; than ACCEPT_ACTIONS
;

NO_UNDO_CHAIN						       enum FatalErrors
; A MSG_GEN_PROCESS_PLAYBACK_UNDO_CHAIN was sent when there was no current
; undo chain.
;

BAD_ADD_UNDO_ACTION_FLAGS				       enum FatalErrors
; A bad AddUndoActionFlags was passed with MSG_GEN_PROCESS_ADD_UNDO_CHAIN
;

CANNOT_PLAYBACK_WHILE_IGNORING				       enum FatalErrors
; Received a MSG_GEN_PROCESS_UNDO_PLAYBACK_CHAIN while ignore was active.

IGNORE_COUNT_UNDERFLOW					       enum FatalErrors
; Received more MSG_GEN_PROCESS_UNDO_ACCEPT_ACTIONS messages than
; IGNORE_ACTIONS.

IGNORE_COUNT_OVERFLOW					       enum FatalErrors
; Received too many MSG_GEN_PROCESS_UNDO_IGNORE_ACTIONS messages.

UI_TRIED_TO_GET_WINDOW_SIZE_WITHOUT_VIS_PARENT		       enum FatalErrors
; A windowed object apparently was trying to calculate a size or position
; for itself that was some ratio of its parent window or the field, but the
; window didn't have a visible parent, which causes problems in the routine.
; See Chris or Doug and whine.

UNDO_OBJECT_MUST_BE_RUN_BY_PROCESS_THREAD		       enum FatalErrors
; An object associated with an undo action/chain must be run by the process
; thread to ensure synchronicity.	

VIS_CHAR_TABLE_LINE_OPTR_IS_NULL			enum FatalErrors
; The instance data of the VisCharTableObj is null

TOO_MANY_UNDO_ACTIONS					       enum FatalErrors
; Too many undo actions were added to the undo chain.

UNDO_INTERNAL_ERROR					       enum FatalErrors

NON_ZERO_TITLE_PASSED_WITH_UD_NOT_UNDOABLE		       enum FatalErrors
; This error occurs if UD_NOT_UNDOABLE is sent to the edit controller with
; GWNT_UNDO_STATE_CHANGE, and a non-zero title is passed

BAD_SELECTION_TYPE					       enum FatalErrors
; An invalid SelectionType enumerated type was passed with a
; NotifySelectionStateChange structure.

KBD_INDEX_TO_KBDLAYOUT_TBL_OUT_OF_BOUNDS		enum FatalErrors
; An index to the KeyboardLayout table was out of bounds.

ILLEGAL_KBD_CHARACTER_VALUE				enum FatalErrors
; An illegal keyboard character value was found.

ILLEGAL_CHAR_TABLE_COORDINATE				enum FatalErrors
; An illegal coordinate in the Character Table is found

TOO_MANY_REGISTERED_OBJECTS				       enum FatalErrors
; 65536 objects called VisTextRegisterForContext without unregistering (let's
; face it, what this really means is that somebody trashed the count).

OBJECT_NEVER_REGISTERED					       enum FatalErrors
; An object called VisTextUnregisterForContext without calling
; VisTextRegisterForContext.


;------------------------------------------------------------------------------
;			IACP Errors
;------------------------------------------------------------------------------
IACP_INVALID_SERVER_NUMBER				enum FatalErrors
; Caller passed a number to IACPSendMessageToServer that is greater than
; the number of servers returned by IACPConnect.

IACP_INVALID_CONNECTION					enum FatalErrors

MUST_CONNECT_TO_FIRST_ONLY_IF_OBEYING_LAUNCH_MODEL	enum FatalErrors
MUST_CONNECT_IN_APP_MODE_IF_OBEYING_LAUNCH_MODEL	enum FatalErrors
CANNOT_HOLD_UP_IACP_MESSAGES_FOR_MORE_THAN_ONE_SERVER	enum FatalErrors
FIRST_ONLY_MUST_BE_SET_IF_DOCUMENT_SPECIFIED		enum FatalErrors
SERVER_FOR_DOCUMENT_NOT_REGISTERED			enum FatalErrors
CANT_SHUT_DOWN_IACP_CONNECTION_THAT_WAS_NEVER_FINISHED	enum FatalErrors
DOC_SERVER_CHANGED					enum FatalErrors

DOCUMENT_NOT_REGISTERED					enum Warnings

WARNING_VIEW_SHOULD_NOT_SCALE_UI_GADGETS		enum Warnings
; Generic objects under a content cannot be scaled, so be careful.


endif

;-----------------------------------------------------------------------------
;		Help Control
;-----------------------------------------------------------------------------

if ERROR_CHECK

HELP_FILE_HAS_NO_MAP_BLOCK				       enum FatalErrors
; The help file specified has no map block (which is where all the cool
; and very necessary stuff like the names are kept).

HELP_HISTORY_BUFFER_NOT_EMPTY				       enum FatalErrors
; The buffer the history information is stored in was not empty on startup.

HELP_HISTORY_ILLEGAL_NUMBER				       enum FatalErrors
; An invalid history number was passed to a history routine.

HELP_NAME_TOO_LONG					       enum FatalErrors
; A name larger than MAX_CONTEXT_NAME_SIZE or FILE_LONGNAME_LENGTH was passed.

HELP_NO_HISTORY						       enum FatalErrors
; No history was saved for the help object, but it was a point where it needed
; at least one item of saved history.  Basically, whenever there is help
; text displayed there should be at least one item of history -- the current.

HELP_NO_FILENAME_FOUND					       enum FatalErrors
; No filename was found by calling up the generic tree from a help trigger.
; Either a ATTR_GEN_HELP_FILE must be specified in the tree, or the help
; trigger must be part of a controller (in which case the name of the geode
; defining the controller class is used).

HELP_NO_HELP_TYPE_FOUND					       enum FatalErrors
; No type for help was defined in the generic tree.  Depending on which type
; of help you want a trigger to bring up, somewhere above it in the generic
; tree should be a ATTR_GEN_HELP_TYPE specifying a HelpType.

HELP_FOCUS_HELP_NOT_SUPPORTED					enum FatalErrors
; Focus help is not yet supported.  It was once, and shall rise from the
; ashes into a new, more streamlined and glorious beast.  Sigh...

HELP_RECORDED_HELP_MISSING					enum FatalErrors
; The user attempted to go to an item in the history list (meaning they
; had already been there so we know it existed at some point), but the
; text/context/file is now missing.

HELP_CANNOT_HAVE_HISTORY_FOR_FIRST_AID_HELP			enum FatalErrors
; You cannot have a history list (HPCF_HISTORY) for First Aid help.

HELP_FIRST_AID_MODE_NOT_FOUND					enum FatalErrors
; The help object was unable to figure out what mode First Aid help was in.

HELP_CONTROL_MUST_HAVE_TEXT					enum FatalErrors
; If you set custom features on a HelpControl object, you must include HPCF_TEXT

HELP_FILE_IS_NOT_A_HELP_FILE					enum FatalErrors
; A file that was to be opened in the help directory was not a valid help file.

HELP_LINK_TO_NO_WHERE						enum FatalErrors
; The user clicked on a link in help that didn't go anywhere.  The cause for
; this is a name is missing -- it was most likely deleted.

endif

;------------------------------------------------------------------------------
;	Hard Icon Bar fatal errors
;------------------------------------------------------------------------------
NO_INDEXED_APP_KEY_FOUND				       enum Warnings
;
;	The key correspoding to an indexed app doesn't exist
;

BAD_GEODE_LOAD_ERROR					       enum FatalErrors
;
;	A bad GeodeLoadError was passed
;

;------------------------------------------------------------------------------
;	Express Menu Control
;------------------------------------------------------------------------------
EXPRESS_MENU_CONTROL_BAD_ASSUMPTION			       enum FatalErrors
; Bad assumption made in Express Menu Control code.  Notify the authorities.

EXPRESS_MENU_CONTROL_ILLEGAL_CREATE_ITEM_FEATURE	       enum FatalErrors
; An illegal feature was requested for MSG_EXPRESS_MENU_CONTROL_CREATE_ITEM.
; Use one of the CreateExpressMenuControlItemFeatures.

INVALID_MONIKER						       enum FatalErrors
; GrDrawGStringAtCP died trying to draw the moniker for an object.

BAD_TOOL_GROUP_BOUNDS					       enum FatalErrors
; A ToolGroup had invalid bounds, even though it had Gen children.

BAD_HIGHLIGHT_TYPE					       enum FatalErrors
; An invalid ToolGroupHighlightType was encountered

TOOL_NOT_FOUND						       enum FatalErrors
; The tool was not a child of the toolbar that the tool control thought it was.

TOOL_FOUND_TWICE					       enum FatalErrors
; Someone trashed a register while trying to move a tool around within a
; toolbar

TOOL_CONTROL_ERROR					       enum FatalErrors

BAD_HELP_COMPACT_TYPE					       enum FatalErrors
BAD_NUM_BYTES_WRITTEN_OUT				       enum FatalErrors
IGNORE_COUNT_IS_NON_ZERO_AFTER_END_OF_ABORTED_CHAIN	       enum FatalErrors

SELECTION_DID_NOT_INCLUDE_LINK				       enum FatalErrors

;------------------------------------------------------------------------------
;	Warnings!
;------------------------------------------------------------------------------

MSG_GEN_PROCESS_UNDO_PLAYBACK_CHAIN_SENT_WHEN_NO_CHAIN_EXISTED	enum   Warnings
; Should be self explanatory. 
;

UNDO_FLUSH_ACTIONS_OR_ABORT_CHAIN_IGNORED_IS_THIS_WHAT_YOU_EXPECT enum   Warnings
;
; MSG_GEN_PROCESS_UNDO_FLUSH_ACTIONS or MSG_GEN_PROCESS_UNDO_ABORT_CHAIN was
; sent while undo actions were being ignored. This means that nothing will
; get flushed.   
;

RECEIVED_TRANSFER_PACKET					enum Warnings
; This message is sent out as debugging information whenever a remote transfer
; packet is exchanged.
;

ABORTING_CLIPBOARD_TRANSFER					enum Warnings
; This message is sent out if the transfer got out of sync (a new start packet
; was received unexpectedly).
;


;------------------------------------------------------------------------------
;	More errors
;------------------------------------------------------------------------------

DOING_PLAYBACK_BUT_NOT_IN_MIDDLE_OF_CHAIN			enum FatalErrors
;
; A MSG_GEN_PROCESS_UNDO_ABORT_CHAIN was sent with ds:[ULMBH_currentChain] set
; to non-zero (indicating that we are playing back an undo chain), but
; ds:[ULMBH_startCount] (indicating that we are creating a redo chain) is not
; set.
;

UNDO_CHAIN_LEFT_OPEN						enum FatalErrors
;
; The current Undo chain was not ended - it is illegal for any messages to get
; through to the process before the undo chain has ended, and
; MSG_GEN_PROCESS_DO_UNDO_EC got through.	
;

IGNORE_COUNT_IS_NON_ZERO_AT_END_OF_PLAYBACK			enum FatalErrors
;
; The ignore count was non-zero at the end of playing back an undo chain. This
; just isn't allowed (someone turn on ignore in the middle of the playback,
; and didn't turn it off).
;

;Misc errors:

UI_LOADER_PASSED_BAD_DEFAULT_SIMPLE_GRAPHICS_MODE		enum FatalErrors
; The loader, in its attempt to determine which one of the simple graphics
; modes is a good fallback, passed an illegal SysSimpleGraphicsMode to
; the kernel.


GVA_GENERIC_CONTENTS_MUST_BE_RUN_BY_SAME_THREAD		       enum FatalErrors
;
; When using GVA_GENERIC_CONTENTS with a GenView, the GVI_contents object
; must be run by the same thread as the GenView.
;

NET_ROUTINE_TRASHED_BPDI				      enum FatalErrors
;
; One of the routines in the net library trashed BP or DI.
;

CANNOT_BRING_UP_KEYBOARD_WITHOUT_FLOATING_KEYBOARD_INFO	      enum FatalErrors
;
; BringUpKeyboard was called when the floating keyboard information had not
; been setup.
;

FLOATING_KEYBOARD_MUST_BE_SUBCLASS_OF_GEN_INTERACTION	       enum FatalErrors
;
; The object specified in ATTR_GEN_APPLICATION_KBD_OBJ must be a subclass
; of GenInteraction.
;

CANNOT_DESTROY_SOCKET					enum FatalErrors
CANNOT_CLOSE_PORT					enum FatalErrors
;
; Error given when we cannot close the socket/port that we just opened in
; ClipboardRemoteSend/Receive
;


UI_MALFORMED_PATH					enum FatalErrors
;
; Bad path passed to MSG_GEN_PATH_SET.

;

CLIPBOARD_SEND_SOCKET_RECEIVED_DATA			enum FatalErrors
;
; We were doing a clipboard send, and we received data over the
; socket...	
;

UI_ERROR_SECOND_REAL_DETACH				enum FatalErrors
; This error occurs if the UI is about to send a second
; MSG_GEN_PROCESS_REAL_DETACH to the process in any one detach cycle

UI_MESSAGE_ARRIVING_AFTER_SAVED_TO_STATE		enum FatalErrors
; "Build" handlers spits out this warning if the application has no generic
; parent & the object tree has been shrunk down to not include specific
; versions of the objects.  This is usually the result of a message arriving
; at the application in the final states of detaching, after it is legal
; to message objects in the application.

CLIPBOARD_TRANSFER_INTERNAL_ERROR			enum FatalErrors

NOT_A_DISCARDABLE_OBJECT				enum FatalErrors
; MSG_GEN_INTERACTION_DISABLE_DISCARDING was sent to an object that did
; not have HINT_INTERACTION_DISCARD_WHEN_CLOSED on it.

ALL_CHILDREN_OF_DISCARDABLE_DIALOG_MUST_BE_IN_THE_SAME_RESOURCE enum FatalErrors
; If a dialog is marked discardable (has HINT_INTERACTION_DISCARD_WHEN_CLOSED)
; all of its generic children must be in the block in which it resides
;

UI_VALUE_REMOVING_MORE_ITEMS_THAN_EXIST			enum FatalErrors
; The number of items to remove passed to MSG_GEN_DYNAMIC_LIST_REMOVE_ITEMS
; exceeded the number of items in the list (GDLI_numItems).
;

;------------------------------------------------------------------------------
;	Global UI constants
;------------------------------------------------------------------------------

UIFlags	record
	UIF_DETACHING_SYSTEM:1
	; Set if the UI has already started shutting down the system.
	; Used to prevent nested start-ups of the shutdown procedure.

	UIF_DETACHING_APP:1
	; Set if the UI is has already started shutting down itself as an
	; application (i.e. the GenProcessClass detach).  Used to prevent
	; nested start-ups of the shutdown procedure.

	UIF_HAVE_DISPLAY_TYPE:1
	; Set if uiDisplayType has been set to a real value.

	UIF_INIT:1
	; Set during intialization (Tested to keep "Activating" box from
	; coming up for UI load of the spooler at startup) -- Doug 4/14/93

	:4
UIFlags	end


;
;	This is a subclass of GenApplication that we use to intercept mouse
;	messages, etc while shutting down, so we don't die trying to build
;	out the app after the SPUI has been freed.
;
UIApplicationClass	class	GenApplicationClass
UIApplicationClass	endc


EMOM_COULD_NOT_FIND_MATCHING_CLASS			enum FatalErrors
; could not find the entry in the EMOMI_classes array that had a
; responseData field which matched the response data of the object created.

EMOM_SLOT_ALREADY_FILLED				enum FatalErrors
; in the array of objects kept for each express menu, there were two
; objects that mapped to the same array entry.  This is probably
; caused because the EMOMI_classes did not contain unique
; CEMCIP_responseData for each object.

NOT_DGROUP						enum FatalErrors
; A segment register was not passed as dgroup to a routine that expected it

INVALID_TOKEN_DB_FLAG					enum FatalErrors
; An invalid local/shared token DB flag was passed to TokenLockTokenMoniker

INTERACTION_CANNOT_BE_MODAL_AND_SYS_MODAL		enum FatalErrors
; You cannot have both the GIA_MODAL and GIA_SYS_MODAL attributes set on
; an interaction.

GEN_DYNAMIC_LIST_NUM_VISIBLE_ITEMS_CHANGED_BAD_ARGUMENT	enum FatalErrors
; Items were being added to the dynamic list in
; GenDynamicListNumVisibleItemsChanged and there was not a valid value
; in dx to indicate whether or not to validate those new items

IACP_FILENAME_AND_PATHNAME_MUST_RESIDE_IN_SAME_SEGMENT	enum FatalErrors
; Two of the arguments passed to this routine, the filename and the pathname,
; are presumed to reside in the same segment; The filename and pathname
; passed in this time were from different segments, which would lead to 
; confusion a short while down the road.

INVALID_FOAM_HELP_CONTROL_CLASS				enum FatalErrors
; Some hoser rearranged the entry points in the foam library, so you need
; to do a "pmake lib" on the foam library, and remake and redownload the UI.
; If *you* are the hoser, then go back into foam.gp, and un-rearrange the
; entry points (you should always add new classes at the end).

UI_CORRUPT_MONIKER_LIST				enum FatalErrors
; When parsing a moniker list some other internal data did not 
; pass the assertions on how this data structure should arranged.  
; Specifically, the size of the list was not an even multiple of 
; the size of one entry. 

UISound	etype	word
;
; This is an enumerated types of sound that UI plays
;
UIS_STARTUP	enum	UISound
UIS_SHUTDOWN	enum	UISound
UIS_NO_INPUT	enum	UISound
UIS_NO_HELP	enum	UISound
