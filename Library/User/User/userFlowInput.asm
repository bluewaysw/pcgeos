COMMENT @----------------------------------------------------------------------

	Copyright (c) GeoWorks 1988 -- All Rights Reserved
	GEOWORKS CONFIDENTIAL

PROJECT:	GEOS
MODULE:		UserInterface/User
FILE:		userFlowInput.asm

ROUTINES:
	Name			Description
	----			-----------
    MTD MSG_VIS_VUP_ALTER_INPUT_FLOW
				TEMPORARY handler for VUP method, starting
				to look like VisContent code...

    INT CallGrabRoutine         TEMPORARY handler for VUP method, starting
				to look like VisContent code...

    INT UpdateGeodeCPUPriorities
				TEMPORARY handler for VUP method, starting
				to look like VisContent code...

    INT RaisePriorities         Raise priorites for passed geode, saving
				away its old priorities

    INT RestorePriorities       Restore passed CPU priorites to passed
				geode

    INT AdjustPtrMode           Adjusts mouse ptr mode to perform some
				automatic behavior:

				If the active mouse grab has just been
				changed, then the ptr behavior is set to
				IGNORE_PTR_EVENTS.

				If the active mouse grab has just been
				released, then the ptr behavior is set back
				to the state that it was in the last time
				the implied grab changed it.

    MTD MSG_VIS_VUP_GET_MOUSE_STATUS

    MTD MSG_VIS_VUP_BUMP_MOUSE

    GLB NukePressHoldTimer      Calls TimerStop() with the
				inkPressHoldTimer...

    MTD MSG_META_MOUSE_PTR      Disperses PTR to the current mouse grab

    INT AdjustMousePosForBump   Process mouse x,y position passed from IM

    INT CheckOnInputHoldUpLow   Implement UI-hold up scheme.

    INT CombineMouseEvent       Implement UI-hold up scheme.

    INT SendMouseToActiveOrImpliedGrab
				Send mouse data to active/implied grab

    INT ECEnsureEventsNotOutOfOrder
				Make sure the hold-up queue is empty

    MTD MSG_META_OBJ_FLUSH_INPUT_QUEUE
				Process this MetaClass method which the
				flow object normally doesn't have to handle
				by redirecting it to the HoldUpInputQueue
				if hold-up mode is in progress.

				Currently used to process
				MSG_META_OBJ_FLUSH_INPUT_QUEUE, to make
				sure that it doesn't pass up
				MSG_META_WIN_CHANGE's in the queue, which
				would result in nasty deaths.

    MTD MSG_META_WIN_CHANGE     Handles notification from window system
				that pointer has moved & may possibly be in
				a new window

    MTD MSG_META_RAW_UNIV_ENTER Handle reciept of the various enter/leave
				messages generated by the window system, &
				relay them on to the proper geode.

    MTD MSG_META_IMPLIED_WIN_CHANGE
				Handles notification from window system
				that the implied window, or window that the
				mouse is in, has changed.  This method is
				generally called directly, as in NOT via
				the UI queue, from the window system, just
				before a MSG_META_VIS_ENTER is delivered.
				This is so that method handlers for
				MSG_META_VIS_ENTER can request changes in
				ptr handling for a window that has just
				become the implied grab.

    MTD MSG_FLOW_GRAB_MOUSE     Creates an active grab for the geode which
				the mouse is currently over.  Generally
				caused as the result of the user pressing a
				mouse button down over a window.

    MTD MSG_FLOW_RELEASE_MOUSE  Releases active grab, so that mouse is free
				to interact with whatever geode it is over.
				Generally a result of all buttons going up
				on the mouse.

    MTD MSG_FLOW_RELEASE_MOUSE_IF_GRABBED
				release active mouse grab, if passed optr
				has it grabbed

    MTD MSG_FLOW_SET_MODAL_GEODE
				TEMPORARY notification from system object
				(until flow & system object are merged), to
				keep flow object up to date on whether
				there is a system-modal window active

    INT FlowUpdateWinGeodeActive
				Update window system with which geode is
				active, if any.

    MTD MSG_FLOW_TEST_WIN_INTERACTIBILITY
				Check to see wether mouse should be allowed
				to interact with window passed, on an
				implied basis.

				The mouse is generally allowed to interact
				with a window, except under certain
				circumstances:

				* There is a FI_modalGeode, & it is not the
				geode that owns the passed window

				* There is an FI_activeMouseGrab, & it is
				not the geode that owns the passed window

    MTD MSG_FLOW_GET_MODAL_GEODE
				Fetch modal geode, if any

    INT FlowUpdateImpliedMouseGrab
				Sets FI_impliedMouseGrab based on current
				implied win info, & whether or not the
				mouse is allowed to interact with that
				window on an implied basis.

    INT FlowSetImpliedMouseGrabFromWin
				Sets FI_impliedMouseGrab based on current
				implied win info, & whether or not the
				mouse is allowed to interact with that
				window on an implied basis.

    INT GetOwningInputObj       Given Window, return Geode & InputObj to
				handle input directed towards it.  By
				definition, the owner of the window is the
				one which will handle input for it.  The
				optr of the InputObj is stored in that
				geode's private data.

    MTD MSG_META_ENSURE_MOUSE_NOT_ACTIVELY_TRESPASSING
				*ds:si - instance data es - segment of
				FlowClass

				ax -
				MSG_META_ENSURE_MOUSE_NOT_ACTIVELY_TRESPASSING

    MTD MSG_META_NOTIFY_WITH_DATA_BLOCK
				This routine passes on MSG_META_NOTIFIES.

    INT FNCheckDuplicateHardIconEvent
				Callback routine to replace or drop
				duplicated hard icon events.

    MTD MSG_FLOW_INK_PRESS_AND_HOLD_TIMEOUT
				This is the method invoked when the ink
				press and hold timeout timer expires.

    MTD MSG_FLOW_INK_REPLY      This method handler is invoked when an
				geode has determined whether or not a
				previous press is ink or not.

    MTD MSG_META_MOUSE_BUTTON   Disperses BUTTON to the current mouse grab

    INT CheckForFlowGrabMouse   Figure out if the mouse has been newly
				pressed. If so, generate
				MSG_FLOW_GRAB_MOUSE to instruct system-wide
				input controller (currently us) to set up
				an active grab for the geode the mouse is
				over.

    INT CheckForFlowReleaseMouse
				Figure out if the mouse has been fully
				released.  If so, generate
				MSG_FLOW_GEODE_RELEASE to instruct
				system-wide input controller to release
				geode grab set up earlier

    INT DefaultBehaviorOnMousePress
				Perform default, system-wide behavior for
				mouse click in a window. Default behavior
				is:

				* "Click to raise":

				By default, we'd like applications that are
				clicked in to be raised to the top.  Almost
				always, that is... apps having windows that
				float on top of the field/screen may not
				wished to be raised themselves if those
				windows are clicked in (e.g. Keycaps).
				Because of this, we stipulate that only
				windows having LayerID = owning geode of
				window, which sit directly on a window
				owned by a different geode, if clicked in,
				will be cause for the Layer they reside in
				to be raised to the top (This is the case
				for Primary, command, & app modal windows).
				Note that the layer is raised as a whole, &
				no raising of individual windows within the
				layer is performed -- this should be
				handled locally within the app.

				* Focus/Target

				Also by default, we'd like to give any
				application clicked on the Focus & Target,
				if they'll have it.  Here we're slightly
				more lenient than above, removing the
				stipulation that the parent window must be
				owned by a different geode in order to
				perform the default behavior.  This means
				that ANY window within the app (including
				things like views), if having LayerID =
				owning geode of window, if clicked in, will
				result in the geode's InputObj being given
				the focus/target within their parent FT
				node object.

				* More CPU power for top geode,
				accomplished by modifying priority of its
				thread(s).

				* Multiple windows under an Application
				with different LayerID's

				In some situations there are applications
				in which all the windows under the
				application are not in the same layer.  In
				this case, there is different default
				behavior.  The LayerID of a window is
				either its owning Geode (almost all of the
				time) or (by convention) the block handle
				of the block that the window object is in.
				When a window is clicked in that does not
				have the LayerID equal to its owning Geode
				we bring this layer to the top and give the
				object the focus and target, then bring the
				owning geode LayerID to the top *without*
				changing the focus and target.

    INT FindBoundary            Starting at passed window, walk up tree to
				find field or screen

    INT UpdateFunctionsActive   Update the flow variable used to record the
				active button functions.

    MTD MSG_VIS_VUP_TERMINATE_ACTIVE_MOUSE_FUNCTION
				Terminates any active mouse function,
				forcing it to become a lowly "OTHER"
				function in progress.  Used by the specific
				UI to "Kill" the START_SELECT in progress
				when the system menu is double-clicked on &
				held.  The problems was that PTR events
				following were marked as being a SELECT
				operation, & the window UNDER the window
				which was closed starts reacting to the
				SELECT operation. NOTE: This function may
				only be called from the UI thread
				(i.e. must be kept synchronous w/UI)

    INT UpdateBPHighWithFunctionsActive
				A code snippet to save bytes

    INT TranslateButton         Convert PC/GEOS button methods to generic
				methods.

    MTD MSG_META_MOUSE_DRAG     Disperses DRAG event to the current mouse
				grab

    MTD MSG_META_KBD_CHAR       Disperses MSG_META_KBD_CHAR to the current
				focus

    INT UpdateConstrainState    Updates status of UIFA_CONSTRAIN

    INT UpdateMoveCopy          Updates status of move-copy, if necessary.

    MTD MSG_META_PRESSURE       Disperses MSG_META_PRESSURE to the current
				focus

    MTD MSG_META_DIRECTION      Disperses MSG_META_DIRECTION to the current
				focus

    MTD MSG_META_MOUSE_BUMP_NOTIFICATION
				MSG_META_MOUSE_BUMP_NOTIFICATION for
				FlowClass

    INT FlowGetActiveOrImpliedMouseGrab
				Returns current mouse grab OD & window

    MTD MSG_VIS_CONTENT_DISABLE_HOLD_UP
				Change input state to force allowance of
				input data to flow

    MTD MSG_VIS_CONTENT_ENABLE_HOLD_UP
				Change input state to allow hold-up mode

    INT FlowFlushHoldUpInputQueue
				Flush the hold-up input queue by moving all
				events in it to the front of the UI queue,
				in order.

    MTD MSG_FLOW_REGISTER_NO_INK_WIN
				Add/remove a window to the no-ink list

    MTD MSG_FLOW_SET_SCREEN     Change display screens

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	Doug	3/89		Initial version
	Doug	12/89		Cleaned up FlowClass organization, doc.

DESCRIPTION:
	This file contains routines to handle input processing for the
	User Interface.  The following mechanisms are handled here:

	GRABS:
		Mouse grab
			Implied mouse grab
			Active mouse grab
			Passive mouse grabs
		Kbd grab
		Direction grab
		Pressure grab
		Window grab

	EXCLUSIVES:
		App exclusive

	INPUT CONTROL:
		FlowBumpMouse

	$Id: userFlowInput.asm,v 1.1 97/04/07 11:46:03 newdeal Exp $

------------------------------------------------------------------------------@

include Internal/prodFeatures.def

FlowCommon segment resource


COMMENT @----------------------------------------------------------------------

METHOD:		FlowVupGrabWithinView

DESCRIPTION:	TEMPORARY handler for VUP method, starting to look like
		VisContent code...

PASS:		*ds:si 	- instance data
		es     	- segment of VisContentClass
		ax 	- MSG_VIS_VUP_ALTER_INPUT_FLOW
		dx	- size VupAlterInputFlowData
		ss:bp	- ptr to VupAlterInputFlowData structure one stack

VupAlterInputFlowData	struct
	VAIFD_flags		VisInputFlowGrabFlags
	VAIFD_grabType		VisInputFlowGrabType
	VAIFD_object		optr
	VAIFD_gWin		hptr.Window
	VAIFD_translation	PointDWord
VupAlterInputFlowData	ends

RETURN:		nothing

DESTROYED:	ax, cx, dx, bp

PSEUDO CODE/STRATEGY:

KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	Doug	11/89		Initial version
	Doug	5/91		Revised to handle 32-bit stuff

------------------------------------------------------------------------------@

FlowVupGrabWithinView	method dynamic	FlowClass, MSG_VIS_VUP_ALTER_INPUT_FLOW
	mov	bx, word ptr ss:[bp].VAIFD_flags
	mov	cx, ss:[bp].VAIFD_object.handle
	mov	dx, ss:[bp].VAIFD_object.chunk
	mov	bp, ss:[bp].VAIFD_gWin

	test	bl, mask VIFGF_MOUSE
	jz	notMouse

EC <	ERROR	UI_FLOW_OBJECT_NO_LONGER_SUPPORTS_PASSIVE_GRABS		>
NEC<	jmp	short done						>

notMouse:
	test	bl, mask VIFGF_KBD
	jz	notKbd

	cmp	bh, VIFGT_ACTIVE
	jne	passiveKbd

	push	ds:[di].FI_activeKbdGrab.KG_OD.handle

	mov     di, offset FI_activeKbdGrab
	mov	ax, MSG_META_GAINED_KBD_EXCL
	call	CallGrabRoutine

	pop	bx		; get handle of old grab owner in bx

	; Give more CPU power to geode having keyboard exclusive, take
	; it away from losing geode.  Love that perceived performance
	; factor, yes we do!
	;
	call	UpdateGeodeCPUPriorities

	jmp	short done

passiveKbd:

EC <	ERROR	UI_FLOW_OBJECT_NO_LONGER_SUPPORTS_PASSIVE_GRABS		>
NEC<	jmp	short done						>

notKbd:
done:
	ret

FlowVupGrabWithinView	endm


CallGrabRoutine	proc	near
	; ax = "GAINED" message

	test	bl, mask VIFGF_GRAB
	jz	release

	test	bl, mask VIFGF_FORCE
	jz	requestGrab

;forceGrab:
	clr	bx
	call	FlowForceGrab
	ret

requestGrab:
	clr	bx
	call	FlowRequestGrab
	ret

release:
	clr	bx
	call	FlowReleaseGrab
	ret

CallGrabRoutine	endp


UpdateGeodeCPUPriorities	proc	near
	class	FlowClass

	tst	bx
	jz	haveOldOwner
	call	MemOwner		; get owning geode of "old" grab
haveOldOwner:
	mov	ax, bx			; keep around in ax

	mov	di, ds:[si]		; get ptr to instance data
	mov	bx, ds:[di].FI_activeKbdGrab.KG_OD.handle
	tst	bx
	jz	haveNewOwner
	call	MemOwner		; get owning geode of "new" grab
haveNewOwner:

	cmp	ax, bx
	je	done			; if same, nothing for us to do

	push	ax			; save "old" geode on stack for a moment
					; along with its old priorities...
	push	{word} ds:[di].FI_prevUIPriority
	push	{word} ds:[di].FI_prevPriority

	mov	ds:[di].FI_prevPriority, 0	; just to prevent oddities...
	mov	ds:[di].FI_prevUIPriority, 0

	call	RaisePriorities		; Raise priorities of "new" geode

	pop	ax			; get saved prio of old focus geode
	pop	cx			; & saved ui prio
	pop	bx			; get old geode

	call	RestorePriorities	; Restore priorities of "old" geode

done:
	ret
UpdateGeodeCPUPriorities	endp



COMMENT @----------------------------------------------------------------------

FUNCTION:	RaisePriorities

DESCRIPTION:	Raise priorites for passed geode, saving away its old
		priorities

CALLED BY:	INTERNAL
		UpdateGeodeCPUPriorities

PASS:		bx 	- geode
		ds:di	- pointer to FlowInstance to store old prios in.

RETURN:		nothing

DESTROYED:	ax

PSEUDO CODE/STRATEGY:

KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	Doug	6/1/92		Initial version
------------------------------------------------------------------------------@

RaisePriorities	proc	near
	class	FlowClass
	tst	bx
	jz	done

	mov	dl, PRIORITY_UI		; Priority for singled threaded
					; applications, or UI thread in
					; two-threaded apps.

	; Start w/UI thread, if there is one.
	;
	push	bx
	push	ds
	call	MemLock
	mov	ds, ax
	mov	ax, ds:[PH_uiThread]
	call	MemUnlock
	pop	ds
	mov	bx, ax
	tst	bx
	jz	doneWithUI

	; Get previous priority of that thread, save it away, so we can
	; restore it later.
	;
	mov	ax, TGIT_PRIORITY_AND_USAGE
	call	ThreadGetInfo
	mov	ds:[di].FI_prevUIPriority, al	; save it away

	; Raise priority, if necessary
	;
	cmp	al, dl
	jbe	doneWithUI		; the lower, the more CPU cycles given
	mov	al, dl
	mov	ah, mask TMF_BASE_PRIO
	call	ThreadModify

	mov	dl, PRIORITY_FOCUS	; 2nd thread, if there is one, only
					; gets to run at PRIORITY_FOCUS.
doneWithUI:
	pop	bx


	push	bx
	call	ProcInfo		; get first thread
	tst	bx
	jz	doneWithFirst

	; Get previous priority of that thread, save it away, so we can
	; restore it later.
	;
	mov	ax, TGIT_PRIORITY_AND_USAGE
	call	ThreadGetInfo
	mov	ds:[di].FI_prevPriority, al	; save it away

	; Raise priority, if necessary
	;
	cmp	al, dl
	jbe	doneWithFirst		; the lower, the more CPU cycles given
	mov	al, dl
	mov	ah, mask TMF_BASE_PRIO
	call	ThreadModify

doneWithFirst:
	pop	bx


done:
	ret
RaisePriorities	endp




COMMENT @----------------------------------------------------------------------

FUNCTION:	RestorePriorities

DESCRIPTION:	Restore passed CPU priorites to passed geode

CALLED BY:	INTERNAL
		UpdateGeodeCPUPriorities

PASS:		bx 	- geode
		al	- priority for first thread
		cl	- priority for ui thread

RETURN:		nothing

DESTROYED:	ax

PSEUDO CODE/STRATEGY:

KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	Doug	6/1/92		Initial version
------------------------------------------------------------------------------@
RestorePriorities	proc	near
	tst	bx			; if no geode, done
	jz	done

	push	bx
	tst	al
	jz	doneWithFirst
	call	ProcInfo		; get first thread
	tst	bx
	jz	doneWithFirst
	mov	ah, mask TMF_BASE_PRIO
	call	ThreadModify
doneWithFirst:
	pop	bx

	push	bx
	tst	cl
	jz	doneWithUI
	push	ds
	call	MemLock
	mov	ds, ax
	mov	ax, ds:[PH_uiThread]
	call	MemUnlock
	pop	ds
	mov	bx, ax
	tst	bx
	jz	doneWithUI
	mov	al, cl			; get prio to restore
	mov	ah, mask TMF_BASE_PRIO
	call	ThreadModify
doneWithUI:
	pop	bx

done:
	ret
RestorePriorities	endp


COMMENT @----------------------------------------------------------------------

FUNCTION:	AdjustPtrMode	- adjust mouse ptr mode.

DESCRIPTION:	Adjusts mouse ptr mode to perform some automatic behavior:

		If the active mouse grab has just been changed, then the
		ptr behavior is set to IGNORE_PTR_EVENTS.

		If the active mouse grab has just been released, then the
		ptr behavior is set back to the state that it was in the
		last time the implied grab changed it.

PASS:
	*ds:si	- flow object
	carry	- set if OD changed

RETURN:
	carry	- unchanged

DESTROYED:
	Nothing

PSEUDO CODE/STRATEGY:

KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	Doug	11/89		Initial version

------------------------------------------------------------------------------@

if	(0)	; DISABLED for now -- doug 5/91
AdjustPtrMode	proc	near	uses	ax, bx, cx, dx, si
	class	FlowClass
	.enter

	pushf
	mov	si, ds:[si]
				; If there is an active grab,
	tst	ds:[si].FI_activeMouseGrab.GG_OD.handle
	jnz	ignorePtrEvents	; then ignore all ptr events until
					; told otherwise.

				; Else figure out which way to set mouse
				; ptr events handling mode.
	test	ds:[si].FI_flowFlags, \
			mask FF_IGNORE_PTR_EVENTS_WHEN_USING_IMPLIED_GRAB
	jnz	ignorePtrEvents

;sendPtrEvents:
	clr	si			; Request ALL ptr events
	jmp	setPtrMode

ignorePtrEvents:
				; Request ptr event on crossing of rect
	mov	si, mask FPM_ON_ENTER_LEAVE

setPtrMode:
				; Call IM routine to change pointer mode
	mov	ax, EOREGREC	; Pass NULL rectangle
	mov	bx, ax
	mov	cx, ax
	mov	dx, ax
	call	ImSetPtrMode	; call IM routine to change pointer mode

	popf
	.leave
	ret

AdjustPtrMode	endp
endif



COMMENT @----------------------------------------------------------------------

METHOD:		FlowVupGetMouseStatus

DESCRIPTION:

CALLED BY:	OLPaneRawLeave (In Motif's CView/cviewPaneWindow.asm file)
		AnyMouseButtonDown? (In Motif's CWin/cwinClassCommon.asm file)

PASS:		*ds:si 	- instance data
		es     	- segment of VisContentClass
		ax 	- MSG_VIS_VUP_GET_MOUSE_STATUS

RETURN:		bp low  - ButtonInfo
                         mask BI_PRESS         - set if press
                         mask BI_DOUBLE_PRESS  - set if double-press
                         mask BI_B3_DOWN       - state of button 3
                         mask BI_B2_DOWN       - state of button 2
                         mask BI_B1_DOWN       - state of button 1
                         mask BI_B0_DOWN       - state of button 0

                bp high - UIFunctionsActive


DESTROYED:	ax, bx, cx, dx, si, di, ds, es

PSEUDO CODE/STRATEGY:

KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	Doug	5/91		Initial version

------------------------------------------------------------------------------@

FlowVupGetMouseStatus	method dynamic	FlowClass, MSG_VIS_VUP_GET_MOUSE_STATUS
	; Fetch current ButtonInfo & UIFunctionsActive
	;
	mov	al, ds:[di].FI_activeMouseButtonInfo
	mov	ah, ds:[di].FI_activeMouseUIFunctionsActive
	mov	bp, ax

	Destroy	ax, cx, dx
	ret

FlowVupGetMouseStatus	endm


COMMENT @----------------------------------------------------------------------

FUNCTION:	FlowVupBumpMouse

CALLED BY:	VisTextPtr

DESCRIPTION:

PASS:		*ds:si 	- instance data
		es     	- segment of VisContentClass
		ax 	- MSG_VIS_VUP_BUMP_MOUSE

		cx	- X amount to bump mouse
		dx	- Y amount to bump mouse

RETURN:		nothing

DESTROYED:	ax, bx, cx, dx, si, di, ds, es

REGISTER/STACK USAGE:

PSEUDO CODE/STRATEGY:

KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	Doug	8/89		Initial version
	Doug	5/91		Changed to VUP method

------------------------------------------------------------------------------@
FlowVupBumpMouse	method dynamic	FlowClass, MSG_VIS_VUP_BUMP_MOUSE

					; Bump all events coming through UI
					; by this amount, until we receive
					; a MSG_META_MOUSE_BUMP_NOTIFICATION

	add	ds:[di].FI_mouseBump.XYO_x, cx
	add	ds:[di].FI_mouseBump.XYO_y, dx

					; Method to send ourselves
	mov	ax, MSG_META_MOUSE_BUMP_NOTIFICATION
	call	ImBumpMouse	; call IM routine to bump mouse, send method.
	ret

FlowVupBumpMouse	endm



COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		NukePressHoldTimer
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Calls TimerStop() with the inkPressHoldTimer...

CALLED BY:	GLOBAL
PASS:		ds:di, *ds:si - FlowObject
		ax - if MSG_META_MOUSE_BUTTON, we want to set the "have override flag"
RETURN:		nada
DESTROYED:	nada

PSEUDO CODE/STRATEGY:

KNOWN BUGS/SIDE EFFECTS/IDEAS:

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	atw	12/17/91	Initial version

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@
NukePressHoldTimer	proc	near
	uses	bp, bx
	class	FlowClass
	.enter

;	Stop the press and hold timer

	push	ax
	clr	bx
	xchg	bx, ds:[di].FI_inkPressHoldTimerHan
	clr	ax
	xchg	ax, ds:[di].FI_inkPressHoldTimerID
	call	TimerStop
	pop	ax
	test	ds:[di].FI_flowFlags, mask FF_AWAITING_PRESS_AND_HOLD_TIMER
	jz	notWaitingForTimer

;	We were waiting for the press and hold timer to expire
;	If the user moved the mouse, draw ink instead.
;	If the user released the mouse w/o moving it, then it should be a mouse
;	event.
;

	push	ax, cx, dx
	mov	cx, IRV_DESIRES_INK
;if not _JEDI
;they've decided they want to use the two-stroke punctunation shift, so
;a click should always position the cursor - brianc 3/16/95
	;
	; we don't do this for JEDI -- we want a mouse release before the
	; timer expires to be ink so we can enter a punctuation shift/period
	; in text objects.  Text object cursor positioning is done by holding
	; the pen down for a short time (PRESS_AND_HOLD_TIME)
	;
	cmp	ax, MSG_META_MOUSE_BUTTON
	jne	10$
	mov	cx, IRV_NO_INK		;If this was a quick press/release,
					; then we don't want any ink - just
					; send the mouse events.
10$:
;endif
	clr	bp
	mov	ax, MSG_FLOW_INK_REPLY
	mov	di, mask MF_INSERT_AT_FRONT or mask MF_FORCE_QUEUE
	mov	bx, ds:[LMBH_handle]
	call	ObjMessage
	pop	ax, cx, dx

	mov	di, ds:[si]
exit:
	.leave
	ret
notWaitingForTimer:
	cmp	ax, MSG_META_MOUSE_BUTTON
	jne	exit

;	If this is a click/release, then set the "ink override" flag.

	ornf	ds:[di].FI_flowFlags, mask FF_HAS_INK_OVERRIDE
	jmp	exit
NukePressHoldTimer	endp


COMMENT @----------------------------------------------------------------------

METHOD:		FlowPtr -- MSG_META_MOUSE_PTR for FlowClass

DESCRIPTION:	Disperses PTR to the current mouse grab

CALLED BY:	Input Manager (see Library/IM/imMain.asm)

PASS:
	*ds:si - instance data
	es - segment of FlowClass

	ax	 - MSG_META_MOUSE_PTR

	cx	- x position, mouse source window coordinates
	dx	- y position, mouse source window coordinates
	bp	- high byte shiftState, low byte buttonInfo

RETURN:
	carry - ?
	ax - ?
	cx - ?
	dx - ?
	bp - ?

DESTROYED:
	bx, si, di, ds, es

REGISTER/STACK USAGE:

PSEUDO CODE/STRATEGY:

KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	Doug	3/89		Initial version
	Jim	12/89		Added support for screen saver function

------------------------------------------------------------------------------@
FlowPtr	method dynamic	FlowClass, MSG_META_MOUSE_PTR

;	If eating events and waiting for ink, just exit...

	test	ds:[di].FI_flowFlags, mask FF_PROCESSING_INK
	jnz	done
	tst	ds:[di].FI_inkPressHoldTimerHan
	jnz	checkToNukePressHoldTimer
afterPressHoldTimer:

	; If holding up UI input, send event to HoldUpInputQueue, to be
	; processed later
	;
	call	CheckOnInputHoldUpLow
	jc	done		; If held up, all done.

	call	AdjustMousePosForBump	; Adjust x, y pos for previous bump


	; Convert to MSG_META_PTR
	;

	; bp = [shiftState | buttonInfo] from Input Manager.
	; set high byte = UIFunctionsActive (such as UIFA_SELECT, etc.)
	;
	call	UpdateBPHighWithFunctionsActive

				; Send mouse to active/implied grab
	mov	ax, MSG_META_PTR
	call	SendMouseToActiveOrImpliedGrab
done:
	ret


checkToNukePressHoldTimer:

;	Should we nuke the ink press/hold timer?


	mov	bx, cx
	sub	bx, ds:[di].FI_inkStartPoint.P_x
	jns	10$
	neg	bx
10$:
	cmp	bx, MAX_X_MOVEMENT_FOR_PRESS_AND_HOLD
	ja	nukeTimer

	mov	bx, dx
	sub	bx, ds:[di].FI_inkStartPoint.P_y
	jns	20$
	neg	bx
20$:
	cmp	bx, MAX_Y_MOVEMENT_FOR_PRESS_AND_HOLD
	jbe	afterPressHoldTimer

nukeTimer:
	call	NukePressHoldTimer
	jmp	afterPressHoldTimer

FlowPtr	endm



COMMENT @----------------------------------------------------------------------

METHOD:		FlowGadgetRepeatPress --
		MSG_GADGET_REPEAT_PRESS for FlowClass

DESCRIPTION:	Sends this method on to the active grab.  This originates from
		a gadget, and is sent through the input manager and flow object
		to keep it somewhat synchronous with other mouse events.

		Note: commented out for now.  If we ever want to send gadget
		repeat events through the IM and flow objects again, we will
		comment this back in.

PASS:		*ds:si 	- instance data
		es     	- segment of MetaClass
		ax 	- MSG_GADGET_REPEAT_PRESS

RETURN:		nothing

DESTROYED:	bx, si, di, ds, es

PSEUDO CODE/STRATEGY:

KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	Chris	10/22/90		Initial version

------------------------------------------------------------------------------@
if 0
FlowGadgetRepeatPress	method FlowClass, MSG_GADGET_REPEAT_PRESS
	mov	bx, ds:[si]		; get ptr to instance data
					; Assume that we'll use active grab
	mov	di, bx
	add	di, offset FI_activeMouseGrab
					; Make sure active grab exists
	cmp	ds:[bx].FI_activeMouseGrab.GG_OD.handle, 0
	je	exit			; if it doesn't, give up
					; Save OD to receive data
	mov	bx, ds:[di].GG_OD.handle
	mov	si, ds:[di].GG_OD.chunk
	mov	di, mask MF_FORCE_QUEUE or mask MF_FIXUP_DS
	call	ObjMessage
exit:
	ret				;
FlowGadgetRepeatPress	endm
endif


COMMENT @----------------------------------------------------------------------

FUNCTION:	AdjustMousePosForBump

DESCRIPTION:	Process mouse x,y position passed from IM

CALLED BY:	INTERNAL

PASS:	*ds:si	- flow object
	cx, dx	- x, y position of mouse

RETURN:
	ds:bx	- flow object
	cx, dx	- corrected position

DESTROYED:
	ax

PSEUDO CODE/STRATEGY:

KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	Doug	6/90		Initial version
------------------------------------------------------------------------------@
AdjustMousePosForBump	proc	near
	class	FlowClass
	mov	bx, ds:[si]
				; Bump the mouse by any amount
				; required
	add	cx, ds:[bx].FI_mouseBump.XYO_x
	add	dx, ds:[bx].FI_mouseBump.XYO_y

EC <	call	ECCheckVisCoords				>
	ret

AdjustMousePosForBump	endp



COMMENT @----------------------------------------------------------------------

FUNCTION:	CheckOnInputHoldUpLow

DESCRIPTION:	Implement UI-hold up scheme.

CALLED BY:	INTERNAL

PASS:
	*ds:si	- flow object

RETURN:
	ds:bx	- flow object
	carry	- set if input held up in uiHoldUpInputQueue

DESTROYED:	di

PSEUDO CODE/STRATEGY:

KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	Doug	3/91		Broken out from CheckOnInputHoldUp
------------------------------------------------------------------------------@
CheckOnInputHoldUpLow	proc	near
	class	FlowClass

	mov	bx, ds:[si]

				; Test for HOLD UP mode
	test	ds:[bx].FI_holdUpInputFlags, mask HUIF_HOLD_UP_MODE_DISABLED
	jnz	passInput
	tst	ds:[bx].FI_holdUpInputCount
	jnz	holdUpInput
passInput:

EC <	call	ECEnsureEventsNotOutOfOrder				>
	clc
	ret

holdUpInput:
	push	bx
	push	di

	cmp	ax, MSG_META_MOUSE_PTR
	jne	nonPtrMethod

	; SEND EVENT FOR PTR
	;
	push	cs		; push custom vector on stack
	mov	di, offset CombineMouseEvent
	push	di

	mov	di, mask MF_FORCE_QUEUE or \
		    mask MF_CHECK_DUPLICATE or \
		    mask MF_CUSTOM or mask MF_CHECK_LAST_ONLY
	jmp	short doObjMessage

nonPtrMethod:
	mov	di, mask MF_FORCE_QUEUE

doObjMessage:
	mov	bx, ds:[bx].FI_holdUpInputQueue	; fetch queue to send events to
	call	ObjMessage
	pop	di
	pop	bx
	stc			; Indicate input held up (eaten by queue)
	ret

CheckOnInputHoldUpLow	endp


;
; Custom combination routine for ptr events, called by ObjMessage in
; OutputMonitor above.
;
CombineMouseEvent	proc	far
	mov	ax, ds:[bx].HE_method	; get event type of entry
	cmp	ax, MSG_META_MOUSE_PTR		; see if we should update
	je	Update
	cmp	ax, MSG_META_MOUSE_BUTTON	; see if button event
					; (can't compress past button
					;	event)
	je	CantUpdate
Ignore:
	mov	di, PROC_SE_CONTINUE	; if other type event, ignore
	ret
Update:
	cmp	ds:[bx].HE_bp, bp	; different button flags?
	jne	Ignore			; yes!, can't combine
	mov	ds:[bx].HE_cx, cx	; update event
	mov	ds:[bx].HE_dx, dx	; update event
	mov	di, PROC_SE_EXIT		; show we're done
	ret
CantUpdate:
	mov	di, PROC_SE_STORE_AT_BACK	; just put at the back.
	ret
CombineMouseEvent	endp



COMMENT @----------------------------------------------------------------------

FUNCTION:	SendMouseToActiveOrImpliedGrab

DESCRIPTION:	Send mouse data to active/implied grab

CALLED BY:	INTERNAL

PASS:
	*ds:si - instance data

	ax	- method
	cx	- x position, screen coordinates
	dx	- y position, screen coordinates
	bp	- flags to send

RETURN:
	*ds:si  - instance data of object
	ax	- unchanged
	cx, dx, bp	- unchanged

DESTROYED:

PSEUDO CODE/STRATEGY:

KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	Doug	4/89		Initial version
------------------------------------------------------------------------------@
SendMouseToActiveOrImpliedGrab	proc	near
	uses	ax, bx, cx, dx, si, di, bp
	class	FlowClass
	.enter
	mov	bx, ds:[si]	; get ptr to instance data
				; Assume that we'll use active grab
	mov	di, bx
	add	di, offset FI_activeMouseGrab
				; Make sure active grab exists
	tst	ds:[bx].FI_activeMouseGrab.GG_OD.handle
	jne	thisObj		; if it does, use it.
				; if it doesn't, use implied mouse grab instead
	mov	di, bx
	add	di, offset FI_impliedMouseGrab

thisObj:
				; get OD to send method to
	mov	bx, ds:[di].GG_OD.handle
	mov	si, ds:[di].GG_OD.chunk
				; Save OD to receive data
	; Always set UIFA_IN when sending mouse input to a a geode
	; though this is not entirely meaningful, it is better than it
	; having a random value in it.
	;
	ornf	bp, (mask UIFA_IN) shl 8

	tst	bx
	jz	unwantedMouseEvent

	cmp	ax, MSG_META_PTR
	jne	nonPtrEvent

	push	cs				;push custom vector on stack
	mov	di, offset CombineMouseEvent
	push	di
	mov	di, mask MF_FORCE_QUEUE or mask MF_CHECK_DUPLICATE or \
		    mask MF_CUSTOM or mask MF_CHECK_LAST_ONLY or \
		    mask MF_FIXUP_DS
	call	ObjMessage
	.leave
	ret

nonPtrEvent:
	mov	di, mask MF_FORCE_QUEUE or mask MF_FIXUP_DS
	call	ObjMessage

done:
	.leave
	ret

unwantedMouseEvent:
	test	bp, mask BI_PRESS	; See if press or not
	jz	afterLostInputCheck
				; Let user know that he is annoying
				; us ;)
	mov	ax, SST_NO_INPUT
	call	UserStandardSound
afterLostInputCheck:
	jmp	short done

SendMouseToActiveOrImpliedGrab	endp




COMMENT @----------------------------------------------------------------------

FUNCTION:	ECEnsureEventsNotOutOfOrder

DESCRIPTION:	Make sure the hold-up queue is empty

CALLED BY:	INTERNAL

PASS:	*ds:si	- instance data

RETURN:		nothing
DESTROYED:	nothing

PSEUDO CODE/STRATEGY:

KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	Doug	5/91		Initial header
------------------------------------------------------------------------------@

if	ERROR_CHECK
ECEnsureEventsNotOutOfOrder	proc	near	uses	ax, bx
	class	FlowClass
	.enter
	; Make sure nothing is backed up
	;
	mov	bx, ds:[si]
	mov	bx, ds:[bx].FI_holdUpInputQueue
	call	GeodeInfoQueue		; see if we've got any events in queue
	tst	ax
	ERROR_NZ    UI_NEW_INPUT_EVENT_PROCESSED_BEFORE_HOLD_UP_QUEUE_FLUSHED
	.leave
	ret

ECEnsureEventsNotOutOfOrder	endp
endif


COMMENT @----------------------------------------------------------------------

METHOD:		FlowObjFlushInputQueue

DESCRIPTION:	Process this MetaClass method which the flow object
		normally doesn't have to handle by redirecting it to
		the HoldUpInputQueue if hold-up mode is in progress.

	Currently used to process MSG_META_OBJ_FLUSH_INPUT_QUEUE, to make sure
	that it doesn't pass up MSG_META_WIN_CHANGE's in the queue, which would
	result in nasty deaths.

PASS:
	*ds:si - instance data
	es - segment of FlowClass

	ax 	- MSG_META_OBJ_FLUSH_INPUT_QUEUE
	cx	- Event
	dx	- Block handle
	bp	- ObjFlushInputQueueNextStop

RETURN:		nothing

DESTROYED:	bx, si, di, ds, es

PSEUDO CODE/STRATEGY:

KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	Doug	4/90		Initial version
	Doug	5/92		New thread model

------------------------------------------------------------------------------@
FlowObjFlushInputQueue	method dynamic	FlowClass, \
					MSG_META_OBJ_FLUSH_INPUT_QUEUE
	; If holding up UI input, send event to HoldUpInputQueue, to be
	; processed later
	;
	call	CheckOnInputHoldUpLow
	jc	done		; If held up, all done.

	; Pass on to superclass (MetaClass) to handle
	;
	mov	di, offset FlowClass
	GOTO	ObjCallSuperNoLock
done:
	ret

FlowObjFlushInputQueue	endm



COMMENT @----------------------------------------------------------------------

METHOD:		FlowWinChange -- MSG_META_WIN_CHANGE for FlowClass

DESCRIPTION:	Handles notification from window system that pointer has
		moved & may possibly be in a new window

CALLED BY:	IM, UI & other threads:
		WinSendWinChange
			WinForceWinChange
				WinEnsureChangeNotification
					OutputNonPtr (IM final output stage)
				WinChangePtrNotification
					WinClose
					WinPerformVis (window recalc)
					WinPerformObscure (window recalc)
			WinMovePtr
				OutputMonitor (IM final output stage)
			WinCheckPtr
				WinRedoMovePtr
					WinChangeAck

PASS:
	*ds:si - instance data
	es - segment of FlowClass

	ax - MSG_META_WIN_CHANGE

	cx, dx, bp - Private data to return to WinChangeAck.  Currently:

        cx, dx  - screen location to traverse to
        bp      - window handle of tree to traverse to


RETURN:		nothing

DESTROYED:	bx, si, di, ds, es

REGISTER/STACK USAGE:

PSEUDO CODE/STRATEGY:

KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	Doug	3/89		Initial version

------------------------------------------------------------------------------@

if	TEST_FLOW
winChangeStart	word	0
winChangeEnd	word	0
endif

FlowWinChange	method dynamic	FlowClass, MSG_META_WIN_CHANGE

if	TEST_FLOW
if	_FXIP
		PrintError	<Cannot use TEST_FLOW on full XIP systems>
endif
	push	ax, bx
	call	TimerGetCount
	mov	cs:[winChangeStart], ax
	pop	ax, bx
endif

	; If holding up UI input, send event to HoldUpInputQueue, to be
	; processed later
	;
	call	CheckOnInputHoldUpLow
	jc	done		; If held up, all done.

				; Acknowledge change, send out any enter/leaves
				;	that have build up.
	call	WinChangeAck	; Returns Implied Grab Window & its input OD
				; NOTE: can move object blocks

if	TEST_FLOW
if	_FXIP
		PrintError	<Cannot use TEST_FLOW on full XIP systems>
endif
	push	ax, bx
	call	TimerGetCount
	mov	cs:[winChangeEnd], ax
	pop	ax, bx
endif

done:
	ret

FlowWinChange	endm


COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		FlowEnterLeave
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

DESCRIPTION:	Handle reciept of the various enter/leave messages generated
		by the window system, & relay them on to the proper geode.

PASS:		*ds:si	- instance data
		ds:di	- ptr to start of master instance data
		es	- segment of class
		ax 	- MSG_META_RAW_UNIV_ENTER, MSG_META_RAW_UNIV_LEAVE

		cx:dx	- InputOD of window
		bp	- handle of window

RETURN:		nothing

ALLOWED TO DESTROY:
		bx, si, di, ds, es

PSEUDO CODE/STRATEGY/KNOWN BUGS/SIDE EFFECTS/IDEAS:

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	doug	3/93		Initial version

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@

FlowEnterLeave	method dynamic	FlowClass, MSG_META_RAW_UNIV_ENTER,
						MSG_META_RAW_UNIV_LEAVE
	push	cx, dx, bp
	call	GetOwningInputObj	; Get Geode InputObj for Window
	mov	bx, cx
	mov	si, dx
	pop	cx, dx, bp
	mov	di, mask MF_FORCE_QUEUE
	call	ObjMessage		; send message on...
	ret
FlowEnterLeave	endm



COMMENT @----------------------------------------------------------------------

METHOD:		FlowImpliedWinChange -- MSG_META_IMPLIED_WIN_CHANGE for FlowClass

DESCRIPTION:	Handles notification from window system that the implied
		window, or window that the mouse is in, has changed.  This
		method is generally called directly, as in NOT via the UI
		queue, from the window system, just before a
		MSG_META_VIS_ENTER is delivered.  This is so that method
		handlers for MSG_META_VIS_ENTER can request changes in ptr
		handling for a window that has just become the implied grab.

CALLED BY:	WinFlushSendQueue
			WinCommonEnd
				WinCommonTraverse
					WinChangeAck

PASS:
	*ds:si - instance data
	es - segment of FlowClass

	ax - MSG_META_IMPLIED_WIN_CHANGE
        cx:dx	- Input OD of implied window, or 0 no window actually has
		  the implied grab.
	bp      - window that ptr is in



RETURN:		nothing

DESTROYED:	bx, si, di, ds, es

PSEUDO CODE/STRATEGY:

KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	Doug	9/89		Initial version
	Doug	6/91		Changes for 2.0:  Figures out & stores implied
				a a geode instead of window, sends window
				info on to geode's input objects, generally
				the GenApplication object.

------------------------------------------------------------------------------@
FlowImpliedWinChange	method dynamic	FlowClass, MSG_META_IMPLIED_WIN_CHANGE

				; Call standard routine to store these
				; values in the Implied window grab struct.

					; Is ptr in same window as before?
	cmp	bp, ds:[di].FI_impliedWin.MG_gWin
	je	afterChange		; If so, skip taking note of change

					; OR in flag to indicate that window
					; has changed.
	ornf	ds:[di].FI_flowFlags, \
			mask FF_WIN_CHANGE_SINCE_LAST_MSG_META_BUTTON

	call	ImForcePtrMethod	; Make IM generate a PTR METHOD,
					; in case the windows actually changed
					; out from underneath the mouse,
					; just so that the new implied window
					; will get a MSG_META_PTR.

afterChange:
					; Store new implied window
	mov	ds:[di].FI_impliedWin.MG_OD.handle, cx
	mov	ds:[di].FI_impliedWin.MG_OD.chunk, dx
	mov	ds:[di].FI_impliedWin.MG_gWin, bp

	call	FlowUpdateImpliedMouseGrab	; Update implied geode

	call	ImForcePtrMethod	; Make IM generate a PTR METHOD,
					; in case the windows actually changed
					; out from underneath the mouse,
					; just so that the new implied window
					; will get a MSG_META_MOUSE_PTR.

	ret

FlowImpliedWinChange	endm



COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		FlowGrabMouse
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

DESCRIPTION:	Creates an active grab for the geode which the mouse is
		currently over.  Generally caused as the result of the
		user pressing a mouse button down over a window.

PASS:		*ds:si	- instance data
		ds:di	- ptr to start of master instance data
		es	- segment of class
		ax 	- MSG_FLOW_GRAB_MOUSE

RETURN:		nothing

ALLOWED TO DESTROY:
		bx, si, di, ds, es

PSEUDO CODE/STRATEGY/KNOWN BUGS/SIDE EFFECTS/IDEAS:

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	doug	2/92		Initial version

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@

FlowGrabMouseHandler	method dynamic	FlowClass, MSG_FLOW_GRAB_MOUSE

	; Get geode that mouse is over
	;
	mov	cx, ds:[di].FI_impliedMouseGrab.GG_OD.handle
	mov	dx, ds:[di].FI_impliedMouseGrab.GG_OD.chunk
	mov	bp, ds:[di].FI_impliedMouseGrab.GG_geode

	; Make that the active geode for mouse activity
	;
	mov	ds:[di].FI_activeMouseGrab.GG_OD.handle, cx
	mov	ds:[di].FI_activeMouseGrab.GG_OD.chunk, dx
	mov	ds:[di].FI_activeMouseGrab.GG_geode, bp

	call	FlowUpdateWinGeodeActive	; Update window sys active geode
	call	FlowUpdateImpliedMouseGrab	; Update implied geode
	ret
FlowGrabMouseHandler	endm



COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		FlowReleaseMouse
		FlowAllowGlobalTransfer
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

DESCRIPTION:	Releases active grab, so that mouse is free to interact with
		whatever geode it is over.  Generally a result of all buttons
		going up on the mouse.

PASS:		*ds:si	- instance data
		ds:di	- ptr to start of master instance data
		es	- segment of class
		ax 	- MSG_FLOW_RELEASE_MOUSE or
			  MSG_FLOW_ALLOW_GLOBAL_TRANSFER

RETURN:		nothing

ALLOWED TO DESTROY:
		bx, si, di, ds, es

PSEUDO CODE/STRATEGY/KNOWN BUGS/SIDE EFFECTS/IDEAS:

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	doug	2/92		Initial version

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@

FlowReleaseMouseHandler	method dynamic	FlowClass, MSG_FLOW_RELEASE_MOUSE,
					MSG_FLOW_ALLOW_GLOBAL_TRANSFER
	; Do nothing if somehow already released.
	;
	tst	ds:[di].FI_activeMouseGrab.GG_OD.handle
	jz	done

	mov	ds:[di].FI_activeMouseGrab.GG_OD.handle, 0
	mov	ds:[di].FI_activeMouseGrab.GG_OD.chunk, 0
	mov	ds:[di].FI_activeMouseGrab.GG_geode, 0

	call	FlowUpdateWinGeodeActive	; Update window sys active geode
	call	FlowUpdateImpliedMouseGrab	; Update implied geode
done:
	ret
FlowReleaseMouseHandler	endm


COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		FlowReleaseMouseIfGrabbed
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	release active mouse grab, if passed optr has it grabbed

CALLED BY:	MSG_FLOW_RELEASE_MOUSE_IF_GRABBED

PASS:		*ds:si	= FlowClass object
		ds:di	= FlowClass instance data
		es 	= segment of FlowClass
		ax	= MSG_FLOW_RELEASE_MOUSE_IF_GRABBED

		^lcx:dx	= optr to check

RETURN:		nothing

ALLOWED TO DESTROY:
		ax, cx, dx, bp
		bx, si, di, ds, es

SIDE EFFECTS:

PSEUDO CODE/STRATEGY:

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	brianc	12/10/92  	Initial version

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@
FlowReleaseMouseIfGrabbed	method	dynamic	FlowClass,
					MSG_FLOW_RELEASE_MOUSE_IF_GRABBED
	cmp	cx, ds:[di].FI_activeMouseGrab.GG_OD.handle
	jne	done
	cmp	dx, ds:[di].FI_activeMouseGrab.GG_OD.chunk
	jne	done
	mov	ax, MSG_FLOW_RELEASE_MOUSE
	call	ObjCallInstanceNoLock
done:
	ret
FlowReleaseMouseIfGrabbed	endm


COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		FlowSetModalGeode
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

DESCRIPTION:	TEMPORARY notification from system object (until flow &
		system object are merged), to keep flow object up to date
		on whether there is a system-modal window active

PASS:		*ds:si	- instance data
		ds:di	- ptr to start of master instance data
		es	- segment of class
		ax 	- MSG_FLOW_SET_MODAL_GEODE

		cx:dx	- optr of input object of system modal geode
			  (Normally its GenApplication object)
		bp	- system modal geode

RETURN:		<return info>

ALLOWED TO DESTROY:
		bx, si, di, ds, es

PSEUDO CODE/STRATEGY/KNOWN BUGS/SIDE EFFECTS/IDEAS:

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	doug	2/92		Initial version

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@

FlowSetModalGeode	method dynamic	FlowClass, MSG_FLOW_SET_MODAL_GEODE

	; Just exit out if no change.
	;
	cmp	cx, ds:[di].FI_modalGeode.GG_OD.handle
	jne	set
	cmp	dx, ds:[di].FI_modalGeode.GG_OD.chunk
	jne	set
	cmp	bp, ds:[di].FI_modalGeode.GG_geode
	je	done

set:
	mov	ds:[di].FI_modalGeode.GG_OD.handle, cx
	mov	ds:[di].FI_modalGeode.GG_OD.chunk, dx
	mov	ds:[di].FI_modalGeode.GG_geode, bp

	call	FlowUpdateWinGeodeActive	; Update window sys active Layer
	call	FlowUpdateImpliedMouseGrab	; Update implied geode
done:
	ret
FlowSetModalGeode	endm




COMMENT @----------------------------------------------------------------------

FUNCTION:	FlowUpdateWinGeodeActive

DESCRIPTION:	Update window system with which geode is active, if any.


CALLED BY:	INTERNAL

PASS:		*ds:si	- Flow object

RETURN:		nothing

DESTROYED:	ax, cx, dx, bp, di

PSEUDO CODE/STRATEGY:
		if FI_modalGeode {
			Make FI_modalGeode geode active;
		} else {
			if FI_activeMouseGrab make its geode active {
			} else
				Make no geode active.
			}
		}


KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	Doug	2/92		Initial version
------------------------------------------------------------------------------@
FlowUpdateWinGeodeActive	proc	near
	class	FlowClass
	mov	di, ds:[si]

	mov	bx, ds:[di].FI_modalGeode.GG_geode
	tst	ds:[di].FI_modalGeode.GG_OD.handle
	jnz	setThisGeodeActive

	mov	bx, ds:[di].FI_activeMouseGrab.GG_geode
	tst	ds:[di].FI_activeMouseGrab.GG_OD.handle
	jnz	setThisGeodeActive

	clr	bx		; set NO geode active

setThisGeodeActive:

	call	WinSysSetActiveGeode
	ret
FlowUpdateWinGeodeActive	endp



COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		FlowTestWinInteractibility
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

DESCRIPTION:	Check to see wether mouse should be allowed to interact with
		window passed, on an implied basis.

		The mouse is generally allowed to interact with a window,
		except under certain circumstances:

			* There is a FI_modalGeode, & it is not the geode
			  that owns the passed window

			* There is an FI_activeMouseGrab, & it is not the geode
			  that owns the passed window


PASS:		*ds:si	- instance data
		ds:di	- ptr to start of master instance data
		es	- segment of class
		ax 	- MSG_FLOW_TEST_WIN_INTERACTIBILITY

		cx:dx	- InputOD of Window
		bp	- handle of Window

RETURN:		carry	- clear if mouse allowed to interact, set if not

ALLOWED TO DESTROY:
		bx, si, di, ds, es

PSEUDO CODE/STRATEGY/KNOWN BUGS/SIDE EFFECTS/IDEAS:

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	doug	2/92		Initial version

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@

FlowTestWinInteractibility	method dynamic	FlowClass, \
					MSG_FLOW_TEST_WIN_INTERACTIBILITY

	call	GetOwningInputObj	; Get Geode InputObj for Window

	mov	di, ds:[si]

	; Don't allow interaction of there is a system modal window up
	; & the owning geode is different than the owner of the
	; passed window.
	;
	tst	ds:[di].FI_modalGeode.GG_OD.handle
	jz	afterSysModal
	cmp	cx, ds:[di].FI_modalGeode.GG_OD.handle
	jne	doNotAllowInteraction
	cmp	dx, ds:[di].FI_modalGeode.GG_OD.chunk
	jne	doNotAllowInteraction
afterSysModal:

	; Don't allow interaction of there is an active geode grab,
	; & the geode is different than the owner of the passed window.
	;
	tst	ds:[di].FI_activeMouseGrab.GG_OD.handle
	jz	afterActiveGeode
	cmp	cx, ds:[di].FI_activeMouseGrab.GG_OD.handle
	jne	doNotAllowInteraction
	cmp	dx, ds:[di].FI_activeMouseGrab.GG_OD.chunk
	jne	doNotAllowInteraction
afterActiveGeode:

;ok:
	clc
	ret

doNotAllowInteraction:
	stc
	ret
FlowTestWinInteractibility	endm



COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		FlowGetModalGeode
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

DESCRIPTION:	Fetch modal geode, if any

PASS:		*ds:si	- instance data
		ds:di	- ptr to start of master instance data
		es	- segment of class
		ax 	- MSG_FLOW_GET_MODAL_GEODE

RETURN:		^lcx:dx	- input obj of modal geode, or 0 if none
		bp	- process of modal geode, or 0 if none

ALLOWED TO DESTROY:
		bx, si, di, ds, es

PSEUDO CODE/STRATEGY/KNOWN BUGS/SIDE EFFECTS/IDEAS:

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	doug	3/26/93		Initial version

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@

FlowGetModalGeode	method dynamic	FlowClass, \
				MSG_FLOW_GET_MODAL_GEODE
	mov	di, ds:[si]
	mov	cx, ds:[di].FI_modalGeode.GG_OD.handle
	mov	dx, ds:[di].FI_modalGeode.GG_OD.chunk
	mov	bp, ds:[di].FI_modalGeode.GG_geode
	ret
FlowGetModalGeode	endm



COMMENT @----------------------------------------------------------------------

FUNCTION:	FlowUpdateImpliedMouseGrab

DESCRIPTION:	Sets FI_impliedMouseGrab based on current implied win info, &
		whether or not the mouse is allowed to interact with that
		window on an implied basis.

CALLED BY:	INTERNAL

PASS:		*ds:si	- Flow object

RETURN:		nothing

DESTROYED:	ax, cx, dx, bp, di

PSEUDO CODE/STRATEGY:

KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	Doug	2/92		Initial version
------------------------------------------------------------------------------@

FlowUpdateImpliedMouseGrab	proc	near
	class	FlowClass
	.enter

	; Get window mouse is over
	;

	mov	di, ds:[si]
	mov	cx, ds:[di].FI_impliedWin.MG_OD.handle
	mov	dx, ds:[di].FI_impliedWin.MG_OD.chunk
	mov	bp, ds:[di].FI_impliedWin.MG_gWin

	; Ask ourselves (while allowing developers to subclass & give us a
	; different answer), whether the mouse should be allowed in this
	; window or not.
	;
	push	cx, dx, bp
	mov	ax, MSG_FLOW_TEST_WIN_INTERACTIBILITY
	call	ObjCallInstanceNoLock
	pop	cx, dx, bp
	jnc	haveDecision
	clr	cx, dx, bp	; if not allowed in, clear out implied win optr
haveDecision:

	call	FlowSetImpliedMouseGrabFromWin
	.leave
	ret

FlowUpdateImpliedMouseGrab	endp


FlowSetImpliedMouseGrabFromWin	proc	near
	uses	ax, bx, si, di
	class	FlowClass
	.enter

	; cx:dx = optr of object owning window,
	; bp = handle of window

	push	cx, dx, bp		; save implied mouse grab

	call	GetOwningInputObj	; Get Geode InputObj for Window
					; object that mouse is over in cx:dx
	mov	bx, cx			; Make that bx:si
	mov	si, dx
	push	bx, si			; Save new geode's InputOD

	; Store new IMPLIED APPLICATION, get old
	;
	xchg	ds:[di].FI_impliedMouseGrab.GG_OD.handle, bx
	xchg	ds:[di].FI_impliedMouseGrab.GG_OD.chunk, si
	mov	ds:[di].FI_impliedMouseGrab.GG_geode, bp

	; See if IMPLIED APPLICATION has changed
	;
	cmp	ds:[di].FI_impliedMouseGrab.GG_OD.handle, bx
	jne	impliedMouseGrabChanged
	cmp	ds:[di].FI_impliedMouseGrab.GG_OD.chunk, si
	je	afterChangeTest
impliedMouseGrabChanged:

	; Tell old IMPLIED APPLICATION that the mouse is off in a black hole
	; somewhere (another geode, in reality)
	;
	clr	cx, dx, bp
	mov	ax, MSG_META_IMPLIED_WIN_CHANGE
	mov	di, mask MF_FORCE_QUEUE or mask MF_FIXUP_DS
	call	ObjMessage

afterChangeTest:
	pop	bx, si			; get new geode's InputOD
	pop	cx, dx, bp		; get implied mouse grab

	; Send IMPLIED_WIN_CHANGE on to geode owning object mouse is over
	;
	mov	ax, MSG_META_IMPLIED_WIN_CHANGE
	mov	di, mask MF_FORCE_QUEUE or mask MF_FIXUP_DS
	call	ObjMessage

	.leave
	ret
FlowSetImpliedMouseGrabFromWin	endp



COMMENT @----------------------------------------------------------------------

FUNCTION:	GetOwningInputObj

DESCRIPTION:	Given Window, return Geode & InputObj to handle input directed
		towards it.  By definition, the owner of the window is the
		one which will handle input for it.  The optr of the
		InputObj is stored in that geode's private data.

CALLED BY:	INTERNAL

PASS:		^hbp	- Window

RETURN:		^hbp	- Geode
		^lcx:dx	- InputObj of Geode

DESTROYED:	nothing

PSEUDO CODE/STRATEGY:

KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	Doug	3/92		Initial version
------------------------------------------------------------------------------@
GetOwningInputObj	proc	near
	uses	bx, si
	.enter
if	(0)
	tst	cx
	jz	noObject
thisBlock:
	mov	bx, cx
	call	MemOwner
	call	WinGeodeGetInputObj
	jmp	short done

noObject:
	mov	cx, bp
	tst	cx
	jnz	thisBlock

done:
	tst	bp			; get geode owning window
	jz	haveGeode
	mov	bx, bp
	call	MemOwner
	mov	bp, bx
haveGeode:
else
	clr	cx, dx
	tst	bp
	jz	done
	mov	bx, bp
	call	MemOwner
	mov	bp, bx
	call	WinGeodeGetInputObj
done:
endif
	.leave
	ret
GetOwningInputObj	endp



COMMENT @----------------------------------------------------------------------

METHOD:		FlowEnsureMouseNotActivelyTrespassing

DESCRIPTION:

PASS:
	*ds:si - instance data
	es - segment of FlowClass

	ax	 - MSG_META_ENSURE_MOUSE_NOT_ACTIVELY_TRESPASSING

RETURN:		nothing

DESTROYED:	bx, si, di, ds, es

PSEUDO CODE/STRATEGY:

KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	Doug	6/90		Initial version

------------------------------------------------------------------------------@

FlowEnsureMouseNotActivelyTrespassing	method dynamic	FlowClass, \
				MSG_META_ENSURE_MOUSE_NOT_ACTIVELY_TRESPASSING

	; Get active/implied geode
	;
	call	FlowGetActiveOrImpliedMouseGrab
	mov	bx, cx				; ^bx:si = app object
	mov	si, dx

	; Have it send the method on to all items on its application's window
	; list.
	;
	push	bx, si
	clr	bx, si				; message for all list entries
	mov	ax, MSG_META_ENSURE_MOUSE_NOT_ACTIVELY_TRESPASSING
	mov	di, mask MF_RECORD
	call	ObjMessage			; di = event
	pop	bx, si
	mov	dx, size GCNListMessageParams
	sub	sp, dx
	mov	bp, sp
	mov	ss:[bp].GCNLMP_ID.GCNLT_manuf, MANUFACTURER_ID_GEOWORKS
	mov	ss:[bp].GCNLMP_ID.GCNLT_type, GAGCNLT_WINDOWS
	mov	ss:[bp].GCNLMP_block, 0
	mov	ss:[bp].GCNLMP_event, di
	mov	ss:[bp].GCNLMP_flags, 0
	mov	ax, MSG_META_GCN_LIST_SEND
	mov	di, mask MF_FORCE_QUEUE or mask MF_FIXUP_DS or mask MF_STACK
	call	ObjMessage
	add	sp, size GCNListMessageParams
	ret

FlowEnsureMouseNotActivelyTrespassing	endm



COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		FlowNotify
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	This routine passes on MSG_META_NOTIFIES.

CALLED BY:	GLOBAL
PASS:		nada
RETURN:		nada
DESTROYED:	nada

PSEUDO CODE/STRATEGY:

KNOWN BUGS/SIDE EFFECTS/IDEAS:

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	atw	11/22/91	Initial version
	IP	04/16/94	changed for new hwr spec
	lester	12/ 5/96  	modified to handle GWNT_INK_DIGITIZER_COORDS

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@
FlowNotify	method	dynamic FlowClass, MSG_META_NOTIFY_WITH_DATA_BLOCK,
					MSG_META_NOTIFY
	cmp	dx, GWNT_INK
	je	checkManufacturerID
if INK_DIGITIZER_COORDS
	cmp	dx, GWNT_INK_DIGITIZER_COORDS
	je	checkManufacturerID
endif
	cmp	dx, GWNT_INK_GESTURE
	jne	sendToActiveApp

checkManufacturerID:
	cmp	cx, MANUFACTURER_ID_GEOWORKS
	jne	sendToActiveApp

EC <	test	ds:[di].FI_flowFlags, mask FF_PROCESSING_INK		>
EC <	ERROR_Z	UI_FLOW_RECEIVED_UNEXPECTED_INK				>
;
; if the message is a gesture, do not want to clear the processing ink
; flag yet.  This is because there could still be more gesture messages
; to come, or there could still be ink that was not recognized as a
; gesture to process.  After all the ink has been processed the ink
; input management will send a GWNT_INK to clear the processing ink flag.
;
	cmp	dx, GWNT_INK_GESTURE
	je	notInkData

if INK_DIGITIZER_COORDS
	; We don't want to clear the processing ink flag on the
	; GWNT_INK_DIGITIZER_COORDS notification; we want to wait
	; until we get the GWNT_INK notification.
	cmp	dx, GWNT_INK_DIGITIZER_COORDS
	je	doNotClearProccessingInk
endif

	andnf	ds:[di].FI_flowFlags, not mask FF_PROCESSING_INK
if INK_DIGITIZER_COORDS
doNotClearProccessingInk:
endif
	tst	bp		;If there was no ink, due to a memory error
	jz	exit		; or because the window was null, just eat
				; this notification.

;
; if the data is ink, set the destination object
;
	mov	bx, bp
	call	MemLock
	mov	es, ax
if INK_DIGITIZER_COORDS
	mov	si, offset IDCH_destination
	cmp	dx, GWNT_INK_DIGITIZER_COORDS
	je	gotOffset
	mov	si, offset IH_destination
gotOffset:
	movdw	es:[si], ds:[di].FI_inkDestination.IG_OD, ax
else
	movdw	es:[IH_destination], ds:[di].FI_inkDestination.IG_OD, ax
endif
	call	MemUnlock

notInkData:
;	Send the data to the geode.

	movdw	bxsi, ds:[di].FI_inkDestination.IG_OD
	mov	ax, MSG_META_NOTIFY_WITH_DATA_BLOCK
	mov	di, mask MF_FORCE_QUEUE
	GOTO	ObjMessage
sendToActiveApp:
	mov	di, ds:[si]


;	Send this off to the "current app" - the app with the kbd grab.
;	If nobody has a kbd grab, send it to the active or mouse grab.
;	If there nobody has any grabs, send it to the UI app itself, to allow
;	for default handling of things like the hard icon bar.

.assert offset KG_OD eq offset GG_OD

	mov	bx, offset FI_activeKbdGrab
	tst	ds:[di].FI_activeKbdGrab.KG_OD.handle
	jnz	sendToGrab
	mov	bx, offset FI_activeMouseGrab
	tst	ds:[di].FI_activeMouseGrab.GG_OD.handle
	jnz	sendToGrab
	tst	ds:[di].FI_impliedMouseGrab.GG_OD.handle
	jz	sendToUI
	mov	bx, offset FI_impliedMouseGrab
sendToGrab:
	mov	si, ds:[di][bx].GG_OD.chunk
	mov	bx, ds:[di][bx].GG_OD.handle
sendIt:
	mov	di, mask MF_FIXUP_DS

	;
	; Check duplicate if it's a hard icon event.  Drop it if we're low on
	; handles.
	;
		CheckHack <MANUFACTURER_ID_GEOWORKS eq 0>
	tst	cx			; see if MANUFACTURER_ID_GEOWORKS
	jne	hasFlags
	cmp	dx, GWNT_STARTUP_INDEXED_APP
	je	checkDup
	cmp	dx, GWNT_HARD_ICON_BAR_FUNCTION
	jne	hasFlags
checkDup:
		CheckHack <segment FNCheckDuplicateHardIconEvent eq @CurSeg>
	push	cs			; ObjMessage is in a fixed segment ...
	mov	di, offset FNCheckDuplicateHardIconEvent
	push	di
	mov	di, mask MF_FIXUP_DS or mask MF_FORCE_QUEUE \
			or mask MF_CHECK_DUPLICATE or mask MF_CUSTOM \
			or mask MF_CAN_DISCARD_IF_DESPERATE

hasFlags:
	call	ObjMessage
exit:
	ret
sendToUI:
	mov	si, offset UIApp
	mov	bx, handle UIApp
	jmp	short sendIt
FlowNotify	endp


COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		FNCheckDuplicateHardIconEvent
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Callback routine to replace or drop duplicated hard icon
		events.

CALLED BY:	(INTERNAL) FlowNotify, UserMetaNotify (via ObjMessage)
PASS:		ax, cx, dx, bp	= event being sent
		ds:bx	= HandleEvent in queue
RETURN:		di	= flags (PROC_SE_EXIT, PROC_SE_STORE_AT_BACK,
			  PROC_SE_CONTINUE)
DESTROYED:	nothing
SIDE EFFECTS:

PSEUDO CODE/STRATEGY:
	- For GWNT_HARD_ICON_BAR_FUNCTION, drop new event if there exists one
	  in the queue with the same index.
	- For GWNT_STARTUP_INDEXED_APP, replace the index in any existing
	  event with the index of the new event, then drop the new one.

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	AY	5/ 3/95    	Initial version

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@
FNCheckDuplicateHardIconEvent	proc	far

if ERROR_CHECK
	;
	; This routine is supposed to be used for only MSG_META_NOTIFY(
	; MANUFACTURER_ID_GEOWORKS, GWNT_HARD_ICON_BAR_FUNCTION /
	; GWNT_STARTUP_INDEXED_APP)
	;
	Assert	e, ax, MSG_META_NOTIFY
	Assert	e, cx, MANUFACTURER_ID_GEOWORKS
	cmp	dx, GWNT_HARD_ICON_BAR_FUNCTION
	je	EC_ok
	Assert	e, dx, GWNT_STARTUP_INDEXED_APP
EC_ok:
endif	; ERROR_CHECK

		CheckHack <PROC_SE_CONTINUE eq 0>
	clr	di			; di = PROC_SE_CONTINUE
	cmp	ax, ds:[bx].HE_method
	jne	checkDone
	cmp	cx, ds:[bx].HE_cx
	jne	checkDone
	cmp	dx, ds:[bx].HE_dx
	jne	checkDone

	cmp	dx, GWNT_HARD_ICON_BAR_FUNCTION
	jne	checkStartApp

	;
	; Events are GWNT_HARD_ICON_BAR_FUNCTION.  If indices match, drop new
	; event.  Else continue.
	;
	cmp	bp, ds:[bx].HE_bp
	je	drop

	ret				; <--- RETURNS HERE

checkStartApp:
	;
	; Events are GWNT_STARTUP_INDEXED_APP.  Replace index in queued event
	; with new index.
	;
	mov	ds:[bx].HE_bp, bp
drop:
	mov	di, PROC_SE_EXIT

checkDone:
	ret
FNCheckDuplicateHardIconEvent	endp


COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		FlowInkPressAndHoldTimeout
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	This is the method invoked when the ink press and hold timeout
		timer expires.

CALLED BY:	GLOBAL
PASS:		bp - timer id
RETURN:		nada
DESTROYED:	ax, cx, dx, bp

PSEUDO CODE/STRATEGY:

KNOWN BUGS/SIDE EFFECTS/IDEAS:

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	atw	12/17/91	Initial version

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@
FlowInkPressAndHoldTimeout	method dynamic FlowClass,
					MSG_FLOW_INK_PRESS_AND_HOLD_TIMEOUT
	.enter

;	If BP != inkPressHoldTimerID, then we have already stopped this timer,
;	so ignore this event.

	cmp	bp, ds:[di].FI_inkPressHoldTimerID
	jne	exit

	mov	ax, SST_KEY_CLICK
	call	UserStandardSound

	clr	ds:[di].FI_inkPressHoldTimerID
	clr	ds:[di].FI_inkPressHoldTimerHan
	test	ds:[di].FI_flowFlags, mask FF_AWAITING_PRESS_AND_HOLD_TIMER
	jne	sendMsg
	ornf	ds:[di].FI_flowFlags, mask FF_HAS_INK_OVERRIDE
exit:
	.leave
	ret
sendMsg:
	mov	ax, MSG_FLOW_INK_REPLY
	mov	cx, IRV_NO_INK
	call	ObjCallInstanceNoLock
	jmp	exit
FlowInkPressAndHoldTimeout	endp


COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		FlowInkReply
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	This method handler is invoked when an geode has
		determined whether or not a previous press is ink or not.

CALLED BY:	GLOBAL
PASS:		cx - InkReturnValue
		bp - 0 or handle of block with InkDestinationInfo
RETURN:		nada
DESTROYED:	nada

PSEUDO CODE/STRATEGY:

KNOWN BUGS/SIDE EFFECTS/IDEAS:

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	atw	12/ 2/91	Initial version

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@
FlowInkReply	method	dynamic FlowClass, MSG_FLOW_INK_REPLY
	cmp	cx, IRV_NO_INK	;
	je	noInk		;
	tst	bp
	jz	noDestInfo

	mov	bx, bp
	call	MemLock
	mov	es, ax
	movdw	ds:[di].FI_inkDestination.IG_OD, es:[IDI_destObj], ax
	mov	bp, es:[IDI_gstate]
	push	es:[IDI_brushSize]
	mov_tr	ax, cx
	movdw	cxdx, es:[IDI_gestureCallback]
	call	MemFree
	pop	bx			;BX <- brush width/height
	jmp	10$
noDestInfo:
	mov_tr	ax, cx
	mov	bp, ds:[di].FI_inkDestination.IG_gState
	mov	bx, ds:[di].FI_inkBrushSize
	movdw	cxdx, ds:[di].FI_inkGestureCallback
10$:
EC <	cmp	ax, IRV_INK_WITH_STANDARD_OVERRIDE			>
EC <	je	11$							>
EC <	cmp	ax, IRV_DESIRES_INK					>
EC <	ERROR_NZ	UI_INVALID_INK_RETURN_VALUE			>
EC <	11$:								>
	cmp	ax, IRV_DESIRES_INK
	mov	ax, TRUE
	je	doReply


	test	ds:[di].FI_flowFlags, mask FF_HAS_INK_OVERRIDE
	jne	noInk		;If the press/hold timer has expired, this
				; isn't ink.

;	We don't have an ink override yet - there are 2 possible reasons:
;
;	1) The timer hasn't expired yet
;	2) The user has moved the mouse or has somehow indicated that
;	   he wants ink.

	mov	ax, TRUE	;If it is case #2 above, branch to force ink
	tst	ds:[di].FI_inkPressHoldTimerHan
	jz	doReply

;	Otherwise, the user hasn't done anything to force us to have ink
;	or not, but the timer hasn't expired yet, so just set the bit saying
;	that we are waiting for the timer.

	mov	ds:[di].FI_inkDestination.IG_gState, bp
	mov	ds:[di].FI_inkBrushSize, bx
	movdw	ds:[di].FI_inkGestureCallback, cxdx
	ornf	ds:[di].FI_flowFlags, mask FF_AWAITING_PRESS_AND_HOLD_TIMER
	ret
noInk:
	clr	ax
	tst	ds:[di].FI_inkDestination.IG_gState
	jz	doReply

	push	di
	mov	di, ds:[di].FI_inkDestination.IG_gState
	call	GrDestroyState
	pop	di

doReply:

;	Nuke the press-hold timer if necessary

	tst	ds:[di].FI_inkPressHoldTimerHan
	jz	20$

	call	NukePressHoldTimer
20$:
	call	ImInkReply	;Notify the IM about the status of this last
				; ink press.

;	If it was ink, set the flag telling the flow object to eat all the
;	incoming events until a MSG_META_NOTIFY_WITH_DATA_BLOCK w/GWNT_INK is
;	received.
;
;	If it wasn't ink then set the flag telling the flow object to let the
;	next START_SELECT pass through unmolested.

	tst	ax
	mov	al, mask FF_LAST_PRESS_WAS_NOT_INK
	jz	notInk
	mov	al, mask FF_PROCESSING_INK
notInk:
	or	ds:[di].FI_flowFlags, al
	andnf	ds:[di].FI_flowFlags, 	not (mask FF_HAS_INK_OVERRIDE or \
					mask FF_AWAITING_PRESS_AND_HOLD_TIMER)
	GOTO	FlowResumeInput
FlowInkReply	endp


COMMENT @----------------------------------------------------------------------

METHOD:		FlowWheel -- 	MSG_META_MOUSE_WHEEL_VERTICAL for FlowClass

DESCRIPTION:	Disperses WHEEL event to the current mouse grab

CALLED BY:	Input Manager (see Library/IM/imMain.asm)

PASS:
	*ds:si - instance data
	es - segment of FlowClass

	ax - MSG_META_MOUSE_WHEEL_VERTICAL

	cx	- x position, mouse source window coordinates
	dx	- y position, mouse source window coordinates
	bp	- high byte shiftState, low byte wheel data

RETURN:		nothing

DESTROYED:	bx, si, di, ds, es

PSEUDO CODE/STRATEGY:

KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	MeyerK	09/2021		initial implementation
------------------------------------------------------------------------------@
FlowWheel	method	dynamic	FlowClass, 	MSG_META_MOUSE_WHEEL_VERTICAL

	call 	SendMouseToActiveOrImpliedGrab
	ret

FlowWheel endm


COMMENT @----------------------------------------------------------------------

METHOD:		FlowButton -- MSG_META_MOUSE_BUTTON for FlowClass

DESCRIPTION:	Disperses BUTTON to the current mouse grab

CALLED BY:	Input Manager (see Library/IM/imMain.asm)

PASS:
	*ds:si - instance data
	es - segment of FlowClass

	ax - MSG_META_MOUSE_BUTTON

	cx	- x position, mouse source window coordinates
	dx	- y position, mouse source window coordinates
	bp	- high byte shiftState, low byte buttonInfo

RETURN:		nothing

DESTROYED:	bx, si, di, ds, es

PSEUDO CODE/STRATEGY:

KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	Doug	3/89		Initial version
	Jim	12/89		Added support for screen saver function
	AY	5/17/94		Added list of no-ink windows

------------------------------------------------------------------------------@

if	TEST_FLOW
pressStart	word	0
releaseStart	word	0
pressEnd	word	0
releaseEnd	word	0
testBP		word	0
endif

FlowButton	method dynamic	FlowClass, MSG_META_MOUSE_BUTTON

if	TEST_FLOW
if	_FXIP
		PrintError	<Cannot use TEST_FLOW on full XIP systems>
endif
	push	ax, bx
	call	TimerGetCount
	mov	cs:[testBP], bp
	test	bp, mask BI_PRESS
	jz	testRelease
	mov	cs:[pressStart], ax
	jmp	testCommon
testRelease:
	mov	cs:[releaseStart], ax
testCommon:
	pop	ax, bx
endif

	; If we are eating mouse events until a MSG_META_NOTIFY_WITH_DATA_BLOCK
	; w/GWNT_INK is received then exit (eat this event).

	test	ds:[di].FI_flowFlags, mask FF_PROCESSING_INK
	jnz	done

	tst	ds:[di].FI_inkPressHoldTimerHan
	jnz	checkToNukePressHoldTimer
afterPressHoldTimer:

	; If holding up UI input, send event to HoldUpInputQueue, to be
	; processed later
	;
	call	CheckOnInputHoldUpLow
	jc	done		; If held up, all done.

	call	SysGetPenMode		; checks for ink.
	tst	ax
	jnz	doInkCheck
afterInkCheck:

	; Generate MSG_FLOW_GRAB_MOUSE, if mouse newly pressed.
	; Leave registers alone, thank you.
	;
	call	CheckForFlowGrabMouse

	mov	ax, MSG_META_MOUSE_BUTTON
	test	bp, mask BI_PRESS	; See if press or not
	jz	afterFirstPressCheck

	;Check to see if this is the first button press in a new window
	;
	test	ds:[bx].FI_flowFlags, \
			mask FF_WIN_CHANGE_SINCE_LAST_MSG_META_BUTTON
	pushf
	andnf	ds:[bx].FI_flowFlags, \
			not mask FF_WIN_CHANGE_SINCE_LAST_MSG_META_BUTTON
	popf
	jz	afterFirstPressCheck
				; clear the double-press flag if first
				; press in new window
	andnf	bp, not mask BI_DOUBLE_PRESS

afterFirstPressCheck:

	;update some Flow object variables
	;	activeMouseButtonInfo
	;	activeMouseUIFunctionsActive
	;	activeMouseFunction
	;
	segmov	es, dgroup, bx		; SH
	call	UpdateFunctionsActive	; returns bp = [UIFunctionsActive
					;			| buttonInfo ]

	call	AdjustMousePosForBump	; Adjust x, y pos for previous bump

	mov	bx, ds:[si]		;If we are in pen mode, branch to do
	mov	ax, ds:[bx].FI_activeMouseMethod	;get method
	call	SendMouseToActiveOrImpliedGrab

	; Generate MSG_FLOW_GEODE_RELEASE, if mouse newly released.
	; Leave registers alone, thank you.
	;
	call	CheckForFlowReleaseMouse

done:

if	TEST_FLOW
if	_FXIP
		PrintError	<Cannot use TEST_FLOW on full XIP systems>
endif
	push	ax, bx
	call	TimerGetCount
	test	cs:[testBP], mask BI_PRESS
	jz	testRelease2
	mov	cs:[pressEnd], ax
	jmp	testCommon2
testRelease2:
	mov	cs:[releaseEnd], ax
testCommon2:
	pop	ax, bx
endif

	ret

checkToNukePressHoldTimer:

;	Should we nuke the ink press/hold timer?

	test	bp, mask BI_B0_DOWN	;If the mouse is still down, no...
	jnz	afterPressHoldTimer

	call	NukePressHoldTimer
	jmp	afterPressHoldTimer

doInkCheck:


;	DO INK-SPECIFIC CHECKING

;	If the event is a START_SELECT, and we are in pen mode, then check to
;	see if the press is on an "actionable" gadget. If the gadget is not
;	actionable, then begin ignoring mouse events and processing ink.

	test	bp, mask BI_B1_DOWN or mask BI_B2_DOWN or mask BI_B3_DOWN
	jne	afterInkCheck
	test	bp, mask BI_B0_DOWN
	jz	afterInkCheck

	test	ds:[bx].FI_flowFlags, mask FF_LAST_PRESS_WAS_NOT_INK
	jz	90$
	andnf	ds:[bx].FI_flowFlags, not mask FF_LAST_PRESS_WAS_NOT_INK
	jmp	afterInkCheck
90$:

	test	ds:[bx].FI_holdUpInputFlags, mask HUIF_HOLD_UP_MODE_DISABLED
	LONG jnz notInk
;
;	This is a possible ink item, so:
;
;	1) Send a MSG_QUERY_IF_HANDLES_INK to the active geode (if none, then
;	   there is no ink).
;
;	2) Begin holding up input, and pass this MSG_META_START_SELECT off to
;	   the holdup queue.
;
;

;	Save the OD of the geode the QUERY_IF_PRESS_IS_INK is being
;	sent to, so we know where to send the ink to.

	push	si
	mov	si, ds:[si]
	mov	bx, ds:[si].FI_activeMouseGrab.GG_OD.handle
	mov	ax, ds:[si].FI_activeMouseGrab.GG_OD.chunk
	tst	bx
	jnz	10$

	; No active mouse grab.  See if implied window is in the no-ink list
	mov	bx, cx			; save x pos in bx
	segmov	es, ds, di
	lea	di, ds:[si].FI_noInkWin	; es:di = window handle list
	mov	ax, ds:[si].FI_impliedWin.MG_gWin	; ax = window under pen
	mov	cx, ds:[si].FI_numNoInkWin
	tst	di			; clear ZF, since di always != 0
	repne	scasw
	mov	cx, bx			; cx = x pos
	je	notInkPopSI		; if found, window doesn't accept ink

	mov	bx, ds:[si].FI_impliedMouseGrab.GG_OD.handle
	mov	ax, ds:[si].FI_impliedMouseGrab.GG_OD.chunk
10$:
	movdw	ds:[si].FI_inkDestination.IG_OD, bxax

;	Clear out ink gstate/brush size

	clr	ds:[si].FI_inkDestination.IG_gState
	clr	ds:[si].FI_inkBrushSize
	clrdw	ds:[si].FI_inkGestureCallback
	tst	bx				;If noone has a grab, then
						; the press is not ink.
notInkPopSI:
	pop	si
	jz	notInk

;	Startup "press and hold" timer

	push	cx, dx
	mov	al, TIMER_EVENT_ONE_SHOT
	mov	bx, ds:[LMBH_handle]
	mov	cx, PRESS_AND_HOLD_TIME
	mov	dx, MSG_FLOW_INK_PRESS_AND_HOLD_TIMEOUT
	call	TimerStart
	pop	cx, dx

	mov	di, ds:[si]
	mov	ds:[di].FI_inkPressHoldTimerHan, bx
	mov	ds:[di].FI_inkPressHoldTimerID, ax

	mov	ds:[di].FI_inkStartPoint.P_x, cx
	mov	ds:[di].FI_inkStartPoint.P_y, dx

	mov	ax, MSG_META_QUERY_IF_PRESS_IS_INK
	call	SendMouseToActiveOrImpliedGrab

	call	FlowHoldUpInput		;Hold up all input until the geode
					; says if it has ink or not

	mov	ax, MSG_META_MOUSE_BUTTON		;Add event to input queue
	call	CheckOnInputHoldUpLow
EC <	ERROR_NC	UI_FLOW_INK_HOLD_UP_INPUT_FAILED		>
	jmp	done

notInk:
	clr	ax			;Tell the IM that this wasn't ink,
	call	ImInkReply		; as we can't hold up input...
	mov	ax, MSG_META_MOUSE_BUTTON
	mov	bx, ds:[si]
	jmp	afterInkCheck

FlowButton	endm



COMMENT @----------------------------------------------------------------------

FUNCTION:	CheckForFlowGrabMouse

DESCRIPTION:	Figure out if the mouse has been newly pressed. If so,
		generate MSG_FLOW_GRAB_MOUSE to instruct system-wide input
		controller (currently us) to set up an active grab for the
		geode the mouse is over.


CALLED BY:	INTERNAL
		FlowButton

PASS:		*ds:si	- flow object
		bp low	- ButtonFlags

RETURN:		nothing
DESTROYED:	nothing

PSEUDO CODE/STRATEGY:

KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	Doug	11/91		Initial version
------------------------------------------------------------------------------@
CheckForFlowGrabMouse	proc	near
	uses	ax, cx, dx, bp, di
	class	FlowClass
	.enter

	mov	di, ds:[si]

	; See if mouse has transitioned from no buttons down to any button(s)
	; down, or visa-versa
	;
	mov	ax, bp
	and	al, mask BI_B3_DOWN or mask BI_B2_DOWN or mask BI_B1_DOWN or \
		    mask BI_B0_DOWN
	jz	done

	test	ds:[di].FI_flowFlags, mask FF_MOUSE_DOWN
	jnz	done			; exit if already down

	ornf	ds:[di].FI_flowFlags, mask FF_MOUSE_DOWN ; transition DOWN

	; Perform default, system-wide behavior for mouse click in a window
	;
	call	DefaultBehaviorOnMousePress

done:
	.leave
	ret
CheckForFlowGrabMouse	endp



COMMENT @----------------------------------------------------------------------

FUNCTION:	CheckForFlowReleaseMouse

DESCRIPTION:	Figure out if the mouse has been fully released.  If so,
		generate MSG_FLOW_GEODE_RELEASE to instruct system-wide
		input controller to release geode grab set up earlier


CALLED BY:	INTERNAL
		FlowButton

PASS:		*ds:si	- flow object
		bp low	- ButtonFlags

RETURN:		nothing
DESTROYED:	nothing

PSEUDO CODE/STRATEGY:

KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	Doug	11/91		Initial version

------------------------------------------------------------------------------@
CheckForFlowReleaseMouse	proc	near
	uses	ax, di
	class	FlowClass
	.enter

	mov	di, ds:[si]

	; See if mouse has transitioned from no buttons down to any button(s)
	; down, or visa-versa
	;
	mov	ax, bp
	and	al, mask BI_B3_DOWN or mask BI_B2_DOWN or mask BI_B1_DOWN or \
		    mask BI_B0_DOWN
	jnz	done

	test	ds:[di].FI_flowFlags, mask FF_MOUSE_DOWN
	jz	done			; exit if already up

	andnf	ds:[di].FI_flowFlags, not mask FF_MOUSE_DOWN ; transition UP
	push	cx, dx, bp
	mov	ax, MSG_FLOW_RELEASE_MOUSE
	call	ObjCallInstanceNoLock
	pop	cx, dx, bp
done:
	.leave
	ret
CheckForFlowReleaseMouse	endp



COMMENT @----------------------------------------------------------------------

FUNCTION:	DefaultBehaviorOnMousePress

DESCRIPTION:	Perform default, system-wide behavior for mouse click in a
		window. Default behavior is:

		* "Click to raise":

		  By default, we'd like applications that are clicked in to be
		  raised to the top.  Almost always, that is... apps having
		  windows that float on top of the field/screen may not wished
		  to be raised themselves if those windows are clicked in
		  (e.g. Keycaps).  Because of this, we stipulate that only
		  windows having LayerID = owning geode of window, which sit
		  directly on a window owned by a different geode, if clicked
		  in, will be cause for the Layer they reside in to be
		  raised to the top (This is the case for Primary, command,
		  & app modal windows).  Note that the layer is raised as
		  a whole, & no raising of individual windows within the layer
		  is performed -- this should be handled locally within the app.

		* Focus/Target

		  Also by default, we'd like to give any application clicked
		  on the Focus & Target, if they'll have it.  Here we're
		  slightly more lenient than above, removing the stipulation
		  that the parent window must be owned by a different geode
		  in order to perform the default behavior.  This means that
		  ANY window within the app (including things like views),
		  if having LayerID = owning geode of window, if clicked in,
		  will result in the geode's InputObj being given the
		  focus/target within their parent FT node object.

		* More CPU power for top geode, accomplished by modifying
		  priority of its thread(s).

		* Multiple windows under an Application with different LayerID's

		  In some situations there are applications in which all the
		  windows under the application are not in the same layer.  In
		  this case, there is different default behavior.  The LayerID
		  of a window is either its owning Geode (almost all of the
		  time) or (by convention) the block handle of the block that
		  the window object is in.  When a window is clicked in that
		  does not have the LayerID equal to its owning Geode we bring
		  this layer to the top and give the object the focus and
		  target, then bring the owning geode LayerID to the top
		  *without* changing the focus and target.


CALLED BY:	INTERNAL
		CheckForFlowGrabMouse

PASS:		*ds:si	- flow object

RETURN:		nothing

DESTROYED:	ax, bx, cx, dx, di, bp

PSEUDO CODE/STRATEGY:

KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	Doug	3/92		Initial version
	dlitwin	8/11/92		New behavior for multiple LayerID's

------------------------------------------------------------------------------@
DefaultBehaviorOnMousePress	proc	near
	uses	bx, si
	class	FlowClass
	.enter

	; Grab mouse for geode
	;
	mov	ax, MSG_FLOW_GRAB_MOUSE
	call	ObjCallInstanceNoLock

	; If currently in a modal state, that's it.
	mov	di, ds:[si]
	tst	ds:[di].FI_modalGeode.GG_OD.handle
	jnz	done

	; If the window that's been clicked on is a member of the common
	; Geode LayerID (LayerID = geode handle), then raise the layer to
	; the top, & give the geode the focus & target.

	clr	dx		; in case no window clicked on
	mov	di, ds:[si]
				; save geode on stack
	push	ds:[di].FI_impliedMouseGrab.GG_geode
	mov	di, ds:[di].FI_impliedWin.MG_gWin	; get Window clicked in
	tst	di
	jz	afterAutoRaiseParams
	call	FindBoundary	; Get parent window in di,
				; WinPriorityData of window in al,
				; LayerID of window in dx
	mov	bp, di
afterAutoRaiseParams:
	pop	cx
	tst	dx
	jz	goForIt

	;
	; We check if the layerID is greater than or equal to LAYER_PRIO_STD
	; because the the higher the layer Priority, the lower the number.
	; This means that any layers below Standard get raised in their own
	; layer when clicked on, and any layers above Standard most likely
	; won't (see check below)
	;
	and	al, mask WPD_LAYER
	cmp	al, LAYER_PRIO_STD shl (offset WPD_LAYER)
	jge	goForIt

	;
	; If a layer has higher priority than Standard and is not the owning
	; geode's layer the default behavior is to NOT raise it.  This is to
	; support windows in layers like LAYER_PRIO_ON_TOP not getting the
	; focus and target even though they are clicked on (specifically used
	; in KeyCaps).
	;
	cmp	cx, dx				; LayerID = the owning geode?
	jne	done				; if not skip bring to top

goForIt:
	push	cx, dx, bp	; save owning Geode, LayerID, parent window
	mov	ax, MSG_GEN_SYSTEM_BRING_GEODE_TO_TOP
	call	UserCallSystem
	pop	cx, dx, bp	; restore owning Geode, LayerID, parent window

	;
	; If a geode other than the UI is clicked on, we must ensure that the
	; UIApplication is not hogging the focus exclusive within in the
	; system object.  (The UIApplication's FT parent node is the system
	; object.)
	;
	cmp	cx, handle 0			; UI?
	je	afterUI
	push	cx, dx, bp, si
	mov	ax, MSG_META_RELEASE_FOCUS_EXCL
	mov	bx, handle UIApp
	mov	si, offset UIApp
	mov	di, mask MF_CALL or mask MF_FIXUP_DS
	call	ObjMessage
	mov	ax, MSG_META_ENSURE_ACTIVE_FT
	call	UserCallSystem
	pop	cx, dx, bp, si
afterUI:

	;
	; The LayerID of a window is either its owning Geode (almost all
	; of the time) or (by convention) the block handle of the block
	; that the window object is in.  In the first case we just continue
	; by skipping to the exit of the routine.  We can check if the
	; LayerID is the owning Geode like above.  In the second case the
	; default behavior is that when a window is clicked in that does not
	; have the LayerID equal to its owning Geode we bring this layer to
	; the top and give the object the focus and target and then bring the
	; owning geode to the top without changing the focus and target.
	;

	cmp	cx, dx
	je	done				; if LayerID = Owning Geode

	mov	ax, MSG_GEN_SYSTEM_BRING_GEODE_TO_TOP
	mov	dx, cx				; Owning Geode is LayerID
	clr	cx				; no Focus/Target change
	call	UserCallSystem

done:
	.leave
	ret

DefaultBehaviorOnMousePress	endp



COMMENT @----------------------------------------------------------------------

FUNCTION:	FindBoundary

DESCRIPTION:	Starting at passed window, walk up tree to find field or
		screen

CALLED BY:	INTERNAL
		DerfaultBehaviorOnMousePress

PASS:		*ds:si	- object
		di	- window

RETURN:		di	- First field, screen or other window up tree from
			  window passed which is owned by a different geode.
			  (or 0 if same owner as the top window in tree)
		dx	- LayerID of last window before above window up tree
		al	- WinPriorityData of last window before above window up
			  tree

DESTROYED:	ah

PSEUDO CODE/STRATEGY:

KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	Doug	3/92		Initial version

------------------------------------------------------------------------------@
FindBoundary	proc	near
	uses	bx, cx, si
	.enter

	mov	bx, di
	call	MemOwner		; get owner of window passed
	mov	dx, bx			; keep around in dx for comparison

searchLoop:
	mov	si, WIT_PARENT_WIN
	call	WinGetInfo		; get ax = parent window
	mov	cx, di			; save child window in cx
	mov	di, ax			; put new window in di
	tst	di			; if NULL, can't go any farther.
	jz	haveParentWinIfAny
	mov	bx, di
	call	MemOwner
	cmp	bx, dx
	je	searchLoop		; keep looking if same owner

haveParentWinIfAny:
	push	di
	mov	di, cx			; get LayerID of child window
	mov	si, WIT_LAYER_ID
	call	WinGetInfo
	mov	dx, ax			; return in dx
	mov	si, WIT_PRIORITY	; get WinPriorityData
	call	WinGetInfo		; return in al
	pop	di

	.leave
	ret
FindBoundary	endp




COMMENT @----------------------------------------------------------------------

FUNCTION:	UpdateFunctionsActive

DESCRIPTION:	Update the flow variable used to record the active button
		functions.

CALLED BY:	FlowButton (ONLY)

PASS:		*ds:si	- Instance data
		ax, cx, dx, bp - MSG_META_MOUSE_BUTTON data
		es	= dgroup

RETURN:		bp high = UIFunctionsActive (UIFA_SELECT, etc)
		bp low - buttonInfo (from Input Manager)

DESTROYED:	nothing

PSEUDO CODE/STRATEGY:

KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	Tony	9/89		Initial version
	Eric	12/89		Updated header and comments

------------------------------------------------------------------------------@
UpdateFunctionsActive	proc	near
	class	FlowClass
	push	ax, bx, di		;bp

EC <	push	ax, bx							>
EC <	mov	bx, es							>
EC <	mov	ax, segment dgroup					>
EC <	cmp	ax, bx							>
EC <	ERROR_NZ	0						>
EC <	pop	ax, bx							>

	; translate to generic method

	call	TranslateButton			; translate to generic method
						; ax = generic mouse method
						; di = Init preferences for
						;	function type chosen

	; Set bp high to use old UIFunctionsActive
	;
	call	UpdateBPHighWithFunctionsActive

	; NOW, update active function & UIFunctionsActive info

	push	di
				;compute function number using method #
	clr	bx				;clear result flags
	mov	di, ax
	sub	di, MSG_META_START_SELECT
	shr	di, 1				;shift out start/stop bit
	mov	bh, cs:[activeFunctionMasks][di];get "mask UIFA_SELECT" etc
	pop	di
	jc	endMethod			;skip if is END method...

;startMethod:
	; is a START method -- set flag in UI global Flow Object variable:far

	ornf	bp, bx
	cmp	ax, MSG_META_START_OTHER		; Is this button not attached
						; to a function, or pressed
						; while another function
						; active?
	je	done				; if so, store new method
						; & flags, but LEAVE original
						; "Function" in progress.

	; HERE IF REAL, NEW UI FUNCTION STARTING
	;
						; Clear out preferences
						; associated w/function
	andnf	bp, not (mask UIFA_PREF_A or mask UIFA_PREF_B or \
				mask UIFA_PREF_C) shl 8
	ornf	bp, di				; OR in new preferences

	mov	bx, bp				; Store away button # which
	andnf	bl, mask BI_BUTTON		; started the function

	mov	di, ds:[si]
	mov	ds:[di].FI_activeMouseButton, bl
						; Store current active function
	mov	ds:[di].FI_activeMouseFunction,ax
	jmp	short done


endMethod:
	mov	di, ds:[si]

	; stopping a method -- reset "UIFA_SELECT", etc. flag.

						; Clear out preference bits
	not	bx
	andnf	bp, bx
	cmp	ax, MSG_META_END_OTHER		; Is this a button not
						; attached to a function, or
						; release while another button
						; active?
	je	done				; if so, store new method
						; & flags, but LEAVE original
						; "Function" in progress.

	; HERE IF REAL, UI FUNCTION ENDING
	;
	mov	ds:[di].FI_activeMouseButton, -1; NO button causing active
						;	function
	mov	ds:[di].FI_activeMouseFunction, 0 ; NO mouse function in action

done:
	mov	di, ds:[si]
	mov	bx, bp
	mov	ds:[di].FI_activeMouseButtonInfo, bl
	mov	ds:[di].FI_activeMouseUIFunctionsActive, bh
	mov	ds:[di].FI_activeMouseMethod,ax	; save current method

EC <	tst	ax				; Must be a method...	>
EC <	ERROR_Z	UI_ERROR_CURRENT_MOUSE_MSG_SHOULD_NOT_BE_NULL	>

					;save [UIFunctionsActive | buttonInfo]
	pop	ax, bx, di
	ret

UpdateFunctionsActive	endp


;index this table with:
;	( method - MSG_META_START_SELECT ) / 2
;to translate a method to one of these masks

activeFunctionMasks	label	byte
	byte	mask UIFA_SELECT
	byte	mask UIFA_MOVE_COPY
	byte	mask UIFA_FEATURES
	byte	0				; "OTHER" bit


COMMENT @----------------------------------------------------------------------

FUNCTION:	FlowTerminateActiveMouseFunction

DESCRIPTION:	Terminates any active mouse function, forcing it to become
		a lowly "OTHER" function in progress.  Used by the specific UI
		to "Kill" the START_SELECT in progress when the system menu
		is double-clicked on & held.  The problems was that PTR events
		following were marked as being a SELECT operation, & the window
		UNDER the window which was closed starts reacting to the SELECT
		operation.
		NOTE:  This function may only be called from the UI thread
			(i.e. must be kept synchronous w/UI)

CALLED BY:	GLOBAL
		OLMenuButtonStartSelect		(In Motif, via VisCallParent)

PASS:		nothing
RETURN:		nothing
DESTROYED:	nothing

PSEUDO CODE/STRATEGY:

KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	Doug	10/90		Initial version

------------------------------------------------------------------------------@
FlowTerminateActiveMouseFunction	method	dynamic FlowClass,
				MSG_VIS_VUP_TERMINATE_ACTIVE_MOUSE_FUNCTION

					; See if there really is an
					; active function in progress
	mov	ax, ds:[di].FI_activeMouseFunction
	cmp	ax, MSG_META_START_SELECT
	je	haveActiveFunction
	cmp	ax, MSG_META_START_MOVE_COPY
	je	haveActiveFunction
	cmp	ax, MSG_META_START_FEATURES
	jne	done
haveActiveFunction:
	mov	ds:[di].FI_activeMouseButton, -1; NO button causing active
						;	function
	mov	ds:[di].FI_activeMouseFunction, 0

	; Clear the active function flags (both places it is stored)
	;
	and	ds:[di].FI_activeMouseUIFunctionsActive, \
				  not ( mask UIFA_SELECT or \
					mask UIFA_MOVE_COPY or \
					mask UIFA_FEATURES )
done:
	ret
FlowTerminateActiveMouseFunction	endm



COMMENT @----------------------------------------------------------------------

FUNCTION:	UpdateBPHighWithFunctionsActive

DESCRIPTION:	A code snippet to save bytes

CALLED BY:	INTERNAL

PASS:		*ds:si	- Instance data

RETURN:		bp high	- activeMouseUIFunctionsActive

DESTROYED:	nothing

PSEUDO CODE/STRATEGY:

KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	Doug	6/90		Initial version
------------------------------------------------------------------------------@
UpdateBPHighWithFunctionsActive	proc	near
	uses	ax
	class	FlowClass
	.enter

	; Set bp high to be old UIFunctionsActive
	;
	mov	ax, bp		;send bp high = UIFunctionsActive
	mov	bp, ds:[si]
	mov	ah, ds:[bp].FI_activeMouseUIFunctionsActive
	mov	bp, ax

	.leave
	ret

UpdateBPHighWithFunctionsActive	endp


COMMENT @----------------------------------------------------------------------

FUNCTION:	TranslateButton

DESCRIPTION:	Convert PC/GEOS button methods to generic methods.

CALLED BY:	UpdateFunctionsActive (ONLY -10/26/89)

PASS:		*ds:si	- Instance data
		ax - MSG_META_MOUSE_BUTTON, MSG_META_PRE_PASSIVE_BUTTON,
	     		MSG_META_POST_PASSIVE_BUTTON
		cx - x Position
		dx - y Position
		bp - [ shiftState | buttonInfo ]	(from Input Manager)
		es - dgroup

RETURN:		ax - new method to send (see below)
		cx, dx  - position (unchanged)
		bp	- unchanged
		di	- Initial "Preferences" if starting a new function
			  type

DESTROYED:	nothing

PSEUDO CODE/STRATEGY:

	if MSG_META_MOUSE_BUTTON, convert to:
		MSG_META_START_SELECT
		MSG_META_END_SELECT
		...etc...
		MSG_META_START_FEATURE
		MSG_META_END_FEATURE

	else if MSG_META_PRE_PASSIVE_BUTTON, convert to:
		MSG_META_PRE_PASSIVE_START_SELECT
		MSG_META_PRE_PASSIVE_END_SELECT
		...etc...
		MSG_META_PRE_PASSIVE_FEATURE
		MSG_META_PRE_PASSIVE_FEATURE

	else if MSG_META_POST_PASSIVE_BUTTON, convert to:
		MSG_META_POST_PASSIVE_START_SELECT
		MSG_META_POST_PASSIVE_END_SELECT
		...etc...
		MSG_META_POST_PASSIVE_FEATURE
		MSG_META_POST_PASSIVE_FEATURE
	else ERROR

KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	Tony	8/89		Initial version
	Eric	12/89		Updated header and comments

------------------------------------------------------------------------------@
TranslateButton	proc	near
	class	FlowClass
	push	bx, cx, es

EC <	push	ax, bx							>
EC <	mov	bx, es							>
EC <	mov	ax, segment dgroup					>
EC <	cmp	ax, bx							>
EC <	ERROR_NZ	0						>
EC <	pop	ax, bx							>
EC <	cmp	ax, MSG_META_MOUSE_BUTTON				>
EC <	je	TB_e10							>
EC <	cmp	ax, MSG_META_PRE_PASSIVE_BUTTON				>
EC <	je	TB_e10							>
EC <	cmp	ax, MSG_META_POST_PASSIVE_BUTTON			>
EC <	ERROR_NZ	UI_BAD_MSG_PASSED_TO_TRANSLATE_BUTTON		>
EC <TB_e10:								>


	clr	cx			; assume button
	cmp	ax,MSG_META_MOUSE_BUTTON
	jz	TB_foundType
	mov	cx,MSG_META_PRE_PASSIVE_START_SELECT - MSG_META_START_SELECT
	cmp	ax,MSG_META_PRE_PASSIVE_BUTTON
	jz	TB_foundType
	mov	cx,MSG_META_POST_PASSIVE_START_SELECT - MSG_META_START_SELECT
TB_foundType:

	mov	di, bp			; di = button number
	andnf	di, mask BI_BUTTON
	test	bp, mask BI_PRESS	; handling press, or release?
	jz	release			; branch if release...

;press:
	; PROCESS PRESS

	mov	ax, MSG_META_START_OTHER		; In case function already
						; active, have ax= OTHER method
	mov	bx, ds:[si]
	cmp	ds:[bx].FI_activeMouseFunction, 0 ; If any functions already
						; active, then force to be
						; an OTHER.
	jne	done

	push	di			;save button number
	push	cx			;push conversion amount

	mov	bx, es:[uiInputMapHandle]
	call	MemLock
	mov	es, ax				;es = table
	mov	di, es:[IMH_buttonMapTable]	;es:di = table
	mov	cx, es:[IMH_buttonMapCount]

	mov	ax, bp			;ax = shift state and button stuff
	andnf	al, mask BI_BUTTON	;only use button number

	;loop looking for a modifier (al = button #)

TB_loop:
	scasw
	jz	TB_match			;if found then branch
	add	di, size ButtonMapEntry-2	; else skip rest of entry
	loop	TB_loop

	; no match found, return MSG_META_START_OTHER

	mov	ax, MSG_META_START_OTHER
	jmp	short TB_pressCommon

	; found a match, return it

TB_match:
						; di points to ButtonMapEntry+2
	mov	ax,es:[di].BME_genericMethod-2		;ax = method to send
	clr	bl
	mov	bh, es:[di].BME_preferences-2		;Initial preferences

TB_pressCommon:
	pop	cx				;recover conversion amount
	pop	di				;di = button number

	push	bx
	mov	bx, segment idata
	mov	es, bx
	mov	bx, es:[uiInputMapHandle]
	call	MemUnlock
	pop	bx
	jmp	done


release:
	mov	bx, ds:[si]

	;PROCESS RELEASE by using saved method (di = button #)
	;
	mov	ax, di
	cmp	al, ds:[bx].FI_activeMouseButton; Release of button
						; which is running
						; active function?
	jne	releaseOther			; If not, force use of
						; "OTHER" method

	mov	ax, ds:[bx].FI_activeMouseFunction	;ax = current function
	tst	ax
	jne	haveReleaseFunction

releaseOther:
	mov	ax, MSG_META_START_OTHER			; if no mouse function,
							; use OTHER
haveReleaseFunction:
	inc	ax					;ax = END method

done:
	add	ax, cx				; ax = real method
	mov	di, bx				; return "Preferences"
						; in di

	pop	bx, cx, es
	ret
TranslateButton	endp



COMMENT @----------------------------------------------------------------------

METHOD:		FlowDrag -- MSG_DRAG for FlowClass

DESCRIPTION:	Disperses DRAG event to the current mouse grab

CALLED BY:	Input Manager (see Library/IM/imMain.asm)

PASS:		*ds:si - instance data
		es - segment of FlowClass

		ax - MSG_DRAG

		cx	- x position, mouse source window coordinates
		dx	- y position, mouse source window coordinates
		bp	- high byte shiftState, low byte buttonInfo

RETURN:		nothing

DESTROYED:	bx, si, di, ds, es

PSEUDO CODE/STRATEGY:

KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	Doug	11/89		Initial version

------------------------------------------------------------------------------@
FlowDrag	method dynamic	FlowClass, MSG_META_MOUSE_DRAG

;	If eating events and waiting for ink, just exit...

	test	ds:[di].FI_flowFlags, mask FF_PROCESSING_INK
	jnz	done


	; If holding up UI input, send event to HoldUpInputQueue, to be
	; processed later
	;
	call	CheckOnInputHoldUpLow
	jc	done		; If held up, all done.

	call	AdjustMousePosForBump	; Adjust x, y pos for previous bump

	; NOW, convert MSG_DRAG to generic method

	mov	bx, ds:[si]

	mov	ax, bp			; al = button number
	andnf	al, mask BI_BUTTON
	cmp	al, ds:[bx].FI_activeMouseButton
	jne	OtherButton

	mov	ax,ds:[bx].FI_activeMouseFunction	; ax = current function
							; convert to DRAG method
	tst	ax
	jnz	UseThisFunction

OtherButton:
	mov	ax, MSG_META_START_OTHER			; Misc grab-bag method,
							; for button events
							; which aren't UI
							; functions
UseThisFunction:
	sub	ax, MSG_META_START_SELECT			; Get offset from
							; first 'START' method
	shr	ax, 1					; divide by 2 for
							; START/END pairs
	add	ax, MSG_META_DRAG_SELECT			; Get single drag
							; version of method

				; Send button event to active/implied grab,
				; replay if requested
	; Set bp high to be old UIFunctionsActive
	;
	call	UpdateBPHighWithFunctionsActive
	call	SendMouseToActiveOrImpliedGrab
done:
	ret

FlowDrag	endm



COMMENT @----------------------------------------------------------------------

METHOD:		FlowKbd -- MSG_META_KBD_CHAR for FlowClass

DESCRIPTION:	Disperses MSG_META_KBD_CHAR to the current focus

PASS:		*ds:si - instance data
		es - segment of FlowClass

		ax - MSG_META_KBD_CHAR

		cx	- charValue
		dx	- low byte charFlags, high byte shiftState
		bp	- low byte toggleState, high byte scanCode

RETURN:		nothing

DESTROYED:	bx, si, di, ds, es

PSEUDO CODE/STRATEGY:

KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	Doug	3/89		Initial version
	Jim	12/89		Added support for screen saver function

------------------------------------------------------------------------------@
FlowKbd	method dynamic	FlowClass, MSG_META_KBD_CHAR


	; If eating events and waiting for ink, just exit...

	test	ds:[di].FI_flowFlags, mask FF_PROCESSING_INK
	jnz	done

	; If holding up UI input, send event to HoldUpInputQueue, to be
	; processed later
	;
	call	CheckOnInputHoldUpLow
	jc	done		; If held up, all done.

	call	UpdateConstrainState	; update UIFunctionsActive

	call	UpdateMoveCopy		; If doing move-copy, possibly change
					;     UI functions...
	push	ax
	push	cx
	push	dx
	push	bp
	push	si
				; SEND TO ACTIVE GRAB
	mov	di, ds:[si]
	add	di, offset FI_activeKbdGrab
				; fetch grab data
	mov	si, ds:[di].KG_OD.chunk
	mov	bx, ds:[di].KG_OD.handle
	tst	bx
	jz	unwantedKbdEvent

	mov	di, mask MF_FORCE_QUEUE or mask MF_FIXUP_DS or \
		    mask MF_CAN_DISCARD_IF_DESPERATE or \
		    mask MF_CHECK_DUPLICATE

	test	dl, mask CF_REPEAT_PRESS
	jnz	sendIt

	mov	di, mask MF_FORCE_QUEUE or mask MF_FIXUP_DS

sendIt:				; Send it!
	mov	ax, MSG_META_KBD_CHAR		; method to send as
	call	ObjMessage
afterSend:
	pop	si
	pop	bp
	pop	dx
	pop	cx
	pop	ax
done:
	ret

unwantedKbdEvent:
				; No destination!
				; See if first press or not
	test	dl, mask CF_FIRST_PRESS
	jz	afterSend	; if not, no beep
				; Let user know that he is annoying us ;)
	mov	ax, SST_NO_INPUT
	call	UserStandardSound
	jmp	short afterSend

FlowKbd	endm


COMMENT @----------------------------------------------------------------------

ROUTINE:	UpdateConstrainState

SYNOPSIS:	Updates status of UIFA_CONSTRAIN

CALLED BY:	FlowKbd

PASS:		*ds:si	- Instance data
		cx	- charValue
		dx	- low byte CharFlags, high byte ShiftState
		bp	- low byte toggleState, high byte scanCode

RETURN:		nothing
DESTROYED:	nothing

PSEUDO CODE/STRATEGY:

KNOWN BUGS/SIDE EFFECTS/IDEAS:

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	brianc	2/12/91		Initial version

------------------------------------------------------------------------------@
UpdateConstrainState	proc	near
	uses	ax, di
	class	FlowClass
	.enter

SBCS <	cmp	ch, VC_ISCTRL			;not ctrl char, exit	>
SBCS <	jne	exit							>
SBCS <	cmp	cl, VC_LSHIFT			;left shift?		>
DBCS <	cmp	cx, C_SYS_LEFT_SHIFT					>
	je	handleConstrain			;yes, handle
SBCS <	cmp	cl, VC_RSHIFT			;right shift?		>
DBCS <	cmp	cx, C_SYS_RIGHT_SHIFT					>
	jne	exit				;exit if some other character
handleConstrain:

	mov	di, ds:[si]

	mov	al, ds:[di].FI_activeMouseUIFunctionsActive ; al = old functions
	test	dl, mask CF_FIRST_PRESS
	jnz	handlePress			;it's a press, branch
	test	dl, mask CF_RELEASE		;check if release
	jz	exit				;not press or release, exit
	andnf	ds:[di].FI_activeMouseUIFunctionsActive, not mask UIFA_CONSTRAIN
	jmp	short done
handlePress:
	ornf	ds:[di].FI_activeMouseUIFunctionsActive, mask UIFA_CONSTRAIN
done:
	cmp	al, ds:[di].FI_activeMouseUIFunctionsActive	;any changes?
	je	exit				;nope
	;
	; constrain function changed, force out a PTR method so the
	; grab will know this even though the mouse doesn't move
	;
	call	ImForcePtrMethod
exit:
	.leave
	ret
UpdateConstrainState	endp


COMMENT @----------------------------------------------------------------------

ROUTINE:	UpdateMoveCopy

SYNOPSIS:	Updates status of move-copy, if necessary.

CALLED BY:	FlowKbd

PASS:		*ds:si	- Instance data
		cx	- charValue
		dx	- low byte CharFlags, high byte ShiftState
		bp	- low byte toggleState, high byte scanCode

RETURN:		nothing
DESTROYED:	nothing

PSEUDO CODE/STRATEGY:

KNOWN BUGS/SIDE EFFECTS/IDEAS:

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	Chris	6/15/90		Initial version
	brianc	3/14/91		Updated for 2.0 quick-transfer

------------------------------------------------------------------------------@
UpdateMoveCopy	proc	near
	uses	ax, bx, cx, di
	class	FlowClass
	.enter

	push	ds
	mov	ax, segment quickTransferFlags	;get quick transfer flags
	mov	ds, ax
	mov	bx, ds:[quickTransferFlags]
	pop	ds

	test	bx, mask CQTF_IN_PROGRESS	;no transfer in progress, exit
	jz	exit

	mov	di, ds:[si]

	mov	ah, ds:[di].FI_activeMouseUIFunctionsActive
	test	ah, mask UIFA_MOVE_COPY		;see if doing move-copy
	jz	exit				;not doing move copy, get out

SBCS <	cmp	ch, VC_ISCTRL			;not ctrl char, exit	>
DBCS <	cmp	ch, CS_CONTROL_HB					>
	jne	exit
	mov	al, mask UIFA_COPY		;assume copy
SBCS <	cmp	cl, VC_LCTRL			;left ctrl?		>
DBCS <	cmp	cl, C_SYS_LEFT_CTRL and 0x00ff	;left ctrl?		>
	je	checkUpDown			;yes, handle
SBCS <	cmp	cl, VC_RCTRL			;right ctrl?		>
DBCS <	cmp	cl, C_SYS_RIGHT_CTRL and 0x00ff	;right ctrl?		>
	je	checkUpDown			;yes, handle
	test	bx, mask CQTF_COPY_ONLY		;is transfer item copy-only?
	jnz	exit				;yes, force-move has no effect
	mov	al, mask UIFA_MOVE		;assume move
SBCS <	cmp	cl, VC_LALT			;left alt press?	>
DBCS <	cmp	cl, C_SYS_LEFT_ALT and 0x00ff	;left alt press?	>
	je	checkUpDown			;handle if so
SBCS <	cmp	cl, VC_RALT			;right alt?		>
DBCS <	cmp	cl, C_SYS_RIGHT_ALT and 0x00ff	;right alt?		>
	jne	exit				;exit if some other character

	;
	; CTRL/ALT press/release
	;	al = UIFA_COPY if CTRL
	;	al = UIFA_MOVE if ALT
	;
checkUpDown:
	clr	bl				; clear no bits
	test	dl, mask CF_FIRST_PRESS
	jnz	handleIt			;it's a press, branch
	test	dl, mask CF_RELEASE		;check if release
	jz	exit				;not press or release, exit

	mov	bl, al				;it's a release, clear
	clr	al				; either UIFA_MOVE or UIFA_COPY
						; (and set none)
handleIt:
	;
	; Change activeMouseUIFunctionsActive appropriately and
	; update the cursor.
	;	al = bits to set
	;	bl = bits to clear
	;
	push	ax				;save ah value
						;(activeMouseUIFunctionsActive)
	xor	al, bl				;keeping same setup?
	pop	ax				;restore ah value
						;(activeMouseUIFunctionsActive)
	jz	exit				;yes, exit
	not	bl				; clear bl bits in ah
	andnf	ah, bl
	ornf	ah, al				; set al bits in ah
						; store new preferences
	mov	ds:[di].FI_activeMouseUIFunctionsActive, ah
	;
	; move/copy state changed, force out a PTR method so the
	; grab will know this even though the mouse doesn't move
	;
	call	ImForcePtrMethod
exit:
	.leave
	ret
UpdateMoveCopy	endp



COMMENT @----------------------------------------------------------------------

METHOD:		FlowPressure -- MSG_META_PRESSURE for FlowClass

DESCRIPTION:	Disperses MSG_META_PRESSURE to the current focus

PASS:		*ds:si - instance data
		es - segment of FlowClass

		ax - MSG_META_PRESSURE

		cx, dx, bp - event data to pass on

RETURN:		nothing
DESTROYED:	nothing

PSEUDO CODE/STRATEGY:

KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	Doug	3/89		Initial version
	Jim	12/89		Added support for screen saver function

------------------------------------------------------------------------------@

if	EXTRA_INPUT_TYPES
FlowPressure	method dynamic	FlowClass, MSG_META_PRESSURE
	; If holding up UI input, send event to HoldUpInputQueue, to be
	; processed later
	;
	call	CheckOnInputHoldUpLow
	jc	done		; If held up, all done.

	mov	bx, ds:[si]
	mov	si, ds:[bx].FI_activePressureGrab.GG_OD.chunk
	mov	bx, ds:[bx].FI_activePressureGrab.GG_OD.handle
	tst	bx	; if no grab, just quit
	jz	done
					; send to grab
	mov	di, mask MF_FORCE_QUEUE or mask MF_FIXUP_DS or \
			mask MF_CAN_DISCARD_IF_DESPERATE
	GOTO	ObjMessage
done:
	ret

FlowPressure	endm
endif	; EXTRA_INPUT_TYPES



COMMENT @----------------------------------------------------------------------

METHOD:		FlowDirection -- MSG_META_DIRECTION for FlowClass

DESCRIPTION:	Disperses MSG_META_DIRECTION to the current focus

PASS:	*ds:si - instance data
	es - segment of FlowClass

	ax - MSG_META_DIRECTION

	cx, dx, bp - event data to pass on

RETURN:		nothing
DESTROYED:	nothing

PSEUDO CODE/STRATEGY:

KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	Doug	3/89		Initial version
	Jim	12/89		Added support for screen saver function

------------------------------------------------------------------------------@

if	EXTRA_INPUT_TYPES
FlowDirection	method dynamic	FlowClass, MSG_META_DIRECTION
	; If holding up UI input, send event to HoldUpInputQueue, to be
	; processed later
	;
	call	CheckOnInputHoldUpLow
	jc	done		; If held up, all done.

	mov	bx, ds:[si]
	mov	si, ds:[bx].FI_activeDirectionGrab.GG_OD.chunk
	mov	bx, ds:[bx].FI_activeDirectionGrab.GG_OD.handle
	tst	bx	; if no grab, just quit
	jz	done
					; send to grab
	mov	di, mask MF_FORCE_QUEUE or mask MF_FIXUP_DS or \
			mask MF_CAN_DISCARD_IF_DESPERATE
	GOTO	ObjMessage
done:
	ret

FlowDirection	endm
endif	; EXTRA_INPUT_TYPES


COMMENT @----------------------------------------------------------------------

FUNCTION:	FlowMouseBumpNotify

DESCRIPTION:	MSG_META_MOUSE_BUMP_NOTIFICATION for FlowClass

CALLED BY:	INTERNAL

PASS:	*ds:si - instance data
	es - segment of FlowClass

	ax - MSG_META_MOUSE_BUMP_NOTIFICATION

	cx	- x mouse bump performed by IM
	dx	- y mouse bump performed by IM

RETURN:		nothing
DESTROYED:	nothing

PSEUDO CODE/STRATEGY:

KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	Doug	8/89		Initial version

------------------------------------------------------------------------------@
FlowMouseBumpNotify	method	dynamic	FlowClass, \
					MSG_META_MOUSE_BUMP_NOTIFICATION
	; If holding up UI input, send event to HoldUpInputQueue, to be
	; processed later
	;
	call	CheckOnInputHoldUpLow
	jc	done		; If held up, all done.

				; Adjust total mouseBump downwards, as we
				; don't have to adjust for this anymore
	mov	bx, ds:[si]	; get ptr to flow object
	sub	ds:[bx].FI_mouseBump.XYO_x, cx
	sub	ds:[bx].FI_mouseBump.XYO_y, dx

done:
	ret

FlowMouseBumpNotify	endm



COMMENT @----------------------------------------------------------------------

FUNCTION:	FlowGetActiveOrImpliedMouseGrab

DESCRIPTION:	Returns current mouse grab OD & window

CALLED BY:	INTERNAL

PASS:		*ds:si - instance data

RETURN:		cx:dx	- OD of object have active or implied geode

DESTROYED:	bx, si, di, ds, es

PSEUDO CODE/STRATEGY:

KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	Doug	6/90		Initial version

------------------------------------------------------------------------------@
FlowGetActiveOrImpliedMouseGrab	proc near
	class	FlowClass
	mov	bx, ds:[si]	; get ptr to instance data
				; Assume that we'll use active grab
	mov	di, bx
	add	di, offset FI_activeMouseGrab
				; Make sure active grab exists
	cmp	ds:[bx].FI_activeMouseGrab.GG_OD.handle, 0
	jne	useThisGrab	; if it does, use it.
				; if it doesn't, use implied mouse grab instead
	mov	di, bx
	add	di, offset FI_impliedMouseGrab

useThisGrab:
				; Return object OD & window handle
	mov	cx, ds:[di].GG_OD.handle
	mov	dx, ds:[di].GG_OD.chunk
	ret

FlowGetActiveOrImpliedMouseGrab	endp



COMMENT @----------------------------------------------------------------------

METHOD:		FlowDisableHoldUpInput

DESCRIPTION:	Change input state to force allowance of input data to flow

PASS:		*ds:si  - instance data
		ds:di   - ptr to VisContentInstance
		es      - segment of VisContentClass
		ax      - MSG_VIS_CONTENT_DISABLE_HOLD_UP

RETURN:		nothing

DESTROYED:	ax, cx, dx, bp

PSEUDO CODE/STRATEGY:

KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	Doug	6/90		Initial version
	Doug	5/91		Now a method

------------------------------------------------------------------------------@
FlowDisableHoldUpInput	method	dynamic FlowClass, \
			MSG_VIS_CONTENT_DISABLE_HOLD_UP
						; Disable hold-up for awhile
	ornf	ds:[di].FI_holdUpInputFlags, mask HUIF_HOLD_UP_MODE_DISABLED
	call	FlowFlushHoldUpInputQueue	; Let 'er rip
	ret

FlowDisableHoldUpInput	endm



COMMENT @----------------------------------------------------------------------

METHOD:		FlowEnableHoldUpInput

DESCRIPTION:	Change input state to allow hold-up mode

PASS:		*ds:si  - instance data
		ds:di   - ptr to VisContentInstance
		es      - segment of VisContentClass
		ax      - MSG_VIS_CONTENT_ENABLE_HOLD_UP

RETURN:		nothing

DESTROYED:	ax, cx, dx, bp

PSEUDO CODE/STRATEGY:

KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	Doug	6/90		Initial version
	Doug	5/91		Now a method
------------------------------------------------------------------------------@
FlowEnableHoldUpInput	method	dynamic FlowClass, \
				MSG_VIS_CONTENT_ENABLE_HOLD_UP
	;
	; Disable hold-up for awhile
	;
	andnf	ds:[di].FI_holdUpInputFlags, \
				not mask HUIF_HOLD_UP_MODE_DISABLED
	ret

FlowEnableHoldUpInput	endm


COMMENT @----------------------------------------------------------------------

METHOD:		FlowHoldUpInput

DESCRIPTION:	Start holding up all UI input events, in a separate queue,
		until FlowResumeInput is called  (A count is kept, so
		multiple patients can use)

PASS:		If called via MSG_VIS_CONTENT_HOLD_UP_INPUT_FLOW:
			*ds:si  - instance data
			ds:di   - ptr to FlowInstance
			es      - segment of FlowClass
			ax      - MSG_VIS_CONTENT_HOLD_UP_INPUT_FLOW
		If called directly:
			*ds:si	= FlowClass object

RETURN:		nothing

DESTROYED:	ax, cx, dx, bp

PSEUDO CODE/STRATEGY:

KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	Doug	6/90		Initial version
	Doug	5/91		Now a method
------------------------------------------------------------------------------@
FlowHoldUpInput	method	FlowClass, MSG_VIS_CONTENT_HOLD_UP_INPUT_FLOW
	mov	di, ds:[si]
	inc	ds:[di].FI_holdUpInputCount	; inc hold up count -- all
	ret					; input will start to be
						; redirected to the hold-up
						; queue
FlowHoldUpInput	endm



COMMENT @----------------------------------------------------------------------

METHOD:		FlowResumeInput

DESCRIPTION:	Allow UI input to flow again.

PASS:		If called via MSG_VIS_CONTENT_RESUME_INPUT_FLOW:
			*ds:si  - instance data
			ds:di   - ptr to VisContentInstance
			es      - segment of VisContentClass
			ax      - MSG_VIS_CONTENT_RESUME_INPUT_FLOW
		If called directly:
			*ds:si	= FlowClass object
RETURN:
		Nothing

DESTROYED:	ax, cx, dx, bp

PSEUDO CODE/STRATEGY:

KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	Doug	6/90		Initial version
	Doug	5/91		Now a method
------------------------------------------------------------------------------@
FlowResumeInput	method	FlowClass, MSG_VIS_CONTENT_RESUME_INPUT_FLOW
	mov	di, ds:[si]
	dec	ds:[di].FI_holdUpInputCount	; dec hold up count -- if
						; back to 0, flush out
						; hold up queue & allow
						; input to proceed.
EC <	ERROR_S	UI_ERROR_NEGATIVE_HOLD_UP_INPUT_COUNT			>
	jnz	done
	call	FlowFlushHoldUpInputQueue
done:
	ret

FlowResumeInput	endm



COMMENT @----------------------------------------------------------------------

FUNCTION:	FlowFlushHoldUpInputQueue

DESCRIPTION:	Flush the hold-up input queue by moving all events in it
		to the front of the UI queue, in order.

CALLED BY:	INTERNAL
		NOTE:  This routine MUST be called by the UI thread.

PASS:		*ds:si	- FlowInstance

RETURN:		nothing
DESTROYED:	nothing

PSEUDO CODE/STRATEGY:

KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	Doug	6/90		Initial version

------------------------------------------------------------------------------@
FlowFlushHoldUpInputQueue	proc	near
	uses ax, bx, cx, dx, si, di
	class	FlowClass
	.enter

	mov	 bx, ds:[si]

	; If hold-up mode is disabled (i.e. there is a system-modal dialog
	; box up & in progress), then let the queue flow regardless of any
	; hold-up modes in progress, so that the user can interact with
	; the system-modal dialog box.
	;
	test	ds:[bx].FI_holdUpInputFlags, mask HUIF_HOLD_UP_MODE_DISABLED
	jnz	letErRip

	; If holding up UI input, we're done -- hold up must have been turned
	; back on while we weren't looking.
	;
	tst	ds:[bx].FI_holdUpInputCount
	jnz	done

letErRip:
					; Direct events back to this object
	mov	cx, ds:[LMBH_handle]
	mov	dx, si

					; Save queue handle on stack
	push	ds:[bx].FI_holdUpInputQueue

	clr	bx			; Get queue handle for this thread
					; 	(UI thread)
	call	GeodeInfoQueue
	mov	si, bx			; Put queue handle in si, as destination
					; queue for following routine

					; Setup hold up input queue as source
	pop	bx
					; Move all of these events to the
					; front of the UI queue
	mov	di, mask MF_INSERT_AT_FRONT
	call	GeodeFlushQueue
done:
	.leave
	ret

FlowFlushHoldUpInputQueue	endp


COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		FlowRegisterNoInkWin
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Add/remove a window to the no-ink list

CALLED BY:	MSG_FLOW_REGISTER_NO_INK_WIN

PASS:		*ds:si	= FlowClass object
		ds:di	= FlowClass instance data
		ds:bx	= FlowClass object (same as *ds:si)
		es 	= segment of FlowClass
		ax	= message #
		dx	= non-zero if add window, zero if remove window
		bp	= handle of window

RETURN:		nothing
DESTROYED:	ax, cx, dx, bp

SIDE EFFECTS:

PSEUDO CODE/STRATEGY:
	If the list is full, any add request will be ignored.  This means
	that ui object that adds it's window to the no-ink list may still
	receive MSG_META_QUERY_IF_PRESS_IS_INK, and should reply accordingly.

	If the window passed in an add request already exists in the list,
	the request is ignored.

	If the window handle passed in a remove request is not found in
	the list, it's ignored.

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	AY	5/16/94   	Initial version

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@
FlowRegisterNoInkWin	method dynamic FlowClass,
					MSG_FLOW_REGISTER_NO_INK_WIN

if ERROR_CHECK
	; make sure all entries in the list are still valid
	push	bp
	mov	bp, ds:[di].FI_numNoInkWin
	shl	bp

checkNext:
	tst	bp
	jz	checkDone
	dec	bp
	dec	bp
	mov	bx, ds:[di].FI_noInkWin[bp]
	call	ECCheckWindowHandle
	jmp	checkNext

checkDone:
	pop	bp
endif

	Assert	window	bp
	mov	bx, ds:[di].FI_numNoInkWin
	Assert	be, bx, MAX_NO_INK_WIN

	; set up for scanning handle list for passed window
	mov_tr	ax, bp			; ax = window hptr
	mov	si, di			; ds:si = instance data
	segmov	es, ds
	add	di, offset FI_noInkWin	; es:di = start of list
	tst	cx
	mov	cx, bx			; cx = count
	jz	removeWin

	; It's an add request.  ZF already cleared
	repne	scasw
	je	done			; neglect if hptr already exist in list
	cmp	bx, MAX_NO_INK_WIN
	je	done			; neglect if list is full

	; add handle to end of list
	stosw
	inc	ds:[si].FI_numNoInkWin
	ret

removeWin:
	; It's a remove request
	tst	di			; clear ZF (since di != 0)
	repne	scasw
	jne	done			; neglect if not found

	; move handle at end of list to this empty slot
	dec	bx
	mov	ds:[si].FI_numNoInkWin, bx
	shl	bx
	mov	ax, ds:[si].FI_noInkWin[bx]	; ax = last entry in list
	mov	ds:[di - size hptr], ax	; move last entry to empty slot

done:
	ret
FlowRegisterNoInkWin	endm

FlowCommon ends

;---------------------

Init segment resource


COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		FlowSetScreen
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Change display screens

CALLED BY:	MSG_FLOW_SET_SCREEN (UserScreenSetCur)
PASS:		cx:dx 	= strategy routine of new video driver
		bp	= handle of field object to become the default
			  visual parent for geodes
		*ds:si	= instance data
		es	= segment of FlowClass
		ax	= MSG_FLOW_SET_SCREEN

RETURN:		nothing
DESTROYED:	si, di, bx, es, ds, ax, cx, dx

PSEUDO CODE/STRATEGY:

KNOWN BUGS/SIDE EFFECTS/IDEAS:

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	ardeb	9/23/89		Initial version

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@
FlowSetScreen	method dynamic	FlowClass, MSG_FLOW_SET_SCREEN
		mov	bx, ds:[si]
		;
		; Store the strategy routine in our instance data first.
		;
		mov	ds:[bx].FI_curVideoStrategy.segment, cx
		mov	ds:[bx].FI_curVideoStrategy.offset, dx
		;
		; Set the proper image in the new driver.
		;
		push	bp		; preserve handle of field object
		clr	cx
		mov	dx, PIV_UPDATE	; Re-use current ptr image
		call	ImSetPtrImage
		pop	bp

		;
		; Give the driver the final kick to get the pointer up on
		; screen.
		;
		push	bx, bp, ds		; Preserve from video driver
						;  depredations...
		mov	di, DR_VID_SHOWPTR
		call	ds:[bx].FI_curVideoStrategy
		pop	bx, bp, ds

		;
		; Contact the System object to set the default visual parent.
		; NOTE: ASSUMES UI SINGLE-THREADED
		;
		tst	bp			; any field yet?
		jz	done
		mov	bx, ss:uiSystemObj.handle
		mov	si, ss:uiSystemObj.chunk
		mov	dx, bp		; Pass field object in CX:DX
		mov	cx, handle SystemFieldUI
		mov	ax, MSG_GEN_SYSTEM_SET_DEFAULT_FIELD
		mov	di, mask MF_CALL
		call	ObjMessage
done:
		ret

FlowSetScreen	endm

Init	ends
