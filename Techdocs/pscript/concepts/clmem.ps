%!PS-Adobe-3.0
%%BoundingBox: (atend)
%%Pages: (atend)
%%PageOrder: (atend)
%%DocumentFonts: (atend)
%%Creator: Frame 4.0
%%DocumentData: Clean7Bit
%%EndComments
%%BeginProlog
%
% Frame ps_prolog 4.0, for use with Frame 4.0 products
% This ps_prolog file is Copyright (c) 1986-1993 Frame Technology
% Corporation.  All rights reserved.  This ps_prolog file may be
% freely copied and distributed in conjunction with documents created
% using FrameMaker, FrameBuilder and FrameViewer as long as this 
% copyright notice is preserved.
%
% Frame products normally print colors as their true color on a color printer
% or as shades of gray, based on luminance, on a black-and white printer. The
% following flag, if set to True, forces all non-white colors to print as pure
% black. This has no effect on bitmap images.
/FMPrintAllColorsAsBlack             false def
%
% Frame products can either set their own line screens or use a printer's 
% default settings. Three flags below control this separately for no 
% separations, spot separations and process separations. If a flag
% is true, then the default printer settings will not be changed. If it is
% false, Frame products will use their own settings from a table based on
% the printer's resolution.
/FMUseDefaultNoSeparationScreen      true  def
/FMUseDefaultSpotSeparationScreen    true  def
/FMUseDefaultProcessSeparationScreen false def
%
% For any given PostScript printer resolution, Frame products have two sets of 
% screen angles and frequencies for printing process separations, which are 
% recomended by Adobe. The following variable chooses the higher frequencies
% when set to true or the lower frequencies when set to false. This is only
% effective if the appropriate FMUseDefault...SeparationScreen flag is false.
/FMUseHighFrequencyScreens true def
%
% PostScript Level 2 printers contain an "Accurate Screens" feature which can
% improve process separation rendering at the expense of compute time. This 
% flag is ignored by PostScript Level 1 printers.
/FMUseAcccurateScreens true def
%
% The following PostScript procedure defines the spot function that Frame
% products will use for process separations. You may un-comment-out one of
% the alternative functions below, or use your own.
%
% Dot function
/FMSpotFunction {abs exch abs 2 copy add 1 gt 
		{1 sub dup mul exch 1 sub dup mul add 1 sub }
		{dup mul exch dup mul add 1 exch sub }ifelse } def
%
% Line function
% /FMSpotFunction { pop } def
%
% Elipse function
% /FMSpotFunction { dup 5 mul 8 div mul exch dup mul exch add 
%		sqrt 1 exch sub } def
%
%
/FMversion (4.0) def 
/FMLevel1 /languagelevel where {pop languagelevel} {1} ifelse 2 lt def
/FMPColor
	FMLevel1 {
		false
		/colorimage where {pop pop true} if
	} {
		true
	} ifelse
def
/FrameDict 400 dict def 
systemdict /errordict known not {/errordict 10 dict def
		errordict /rangecheck {stop} put} if
% The readline in PS 23.0 doesn't recognize cr's as nl's on AppleTalk
FrameDict /tmprangecheck errordict /rangecheck get put 
errordict /rangecheck {FrameDict /bug true put} put 
FrameDict /bug false put 
mark 
% Some PS machines read past the CR, so keep the following 3 lines together!
currentfile 5 string readline
00
0000000000
cleartomark 
errordict /rangecheck FrameDict /tmprangecheck get put 
FrameDict /bug get { 
	/readline {
		/gstring exch def
		/gfile exch def
		/gindex 0 def
		{
			gfile read pop 
			dup 10 eq {exit} if 
			dup 13 eq {exit} if 
			gstring exch gindex exch put 
			/gindex gindex 1 add def 
		} loop
		pop 
		gstring 0 gindex getinterval true 
		} bind def
	} if
/FMshowpage /showpage load def
/FMquit /quit load def
/FMFAILURE { 
	dup = flush 
	FMshowpage 
	/Helvetica findfont 12 scalefont setfont
	72 200 moveto
	show FMshowpage 
	FMquit 
	} def 
/FMVERSION {
	FMversion ne {
		(Frame product version does not match ps_prolog!) FMFAILURE
		} if
	} def 
/FMBADEPSF { 
	(PostScript Lang. Ref. Man., 2nd Ed., H.2.4 says EPS must not call X              )
	dup dup (X) search pop exch pop exch pop length 
	4 -1 roll 
	putinterval 
	FMFAILURE
	} def
/FMLOCAL {
	FrameDict begin
	0 def 
	end 
	} def 
/concatprocs
	{
	/proc2 exch cvlit def/proc1 exch cvlit def/newproc proc1 length proc2 length add array def
	newproc 0 proc1 putinterval newproc proc1 length proc2 putinterval newproc cvx
}def
FrameDict begin 
/FMnone 0 def
/FMcyan 1 def
/FMmagenta 2 def
/FMyellow 3 def
/FMblack 4 def
/FMcustom 5 def
/FrameNegative false def 
/FrameSepIs FMnone def 
/FrameSepBlack 0 def
/FrameSepYellow 0 def
/FrameSepMagenta 0 def
/FrameSepCyan 0 def
/FrameSepRed 1 def
/FrameSepGreen 1 def
/FrameSepBlue 1 def
/FrameCurGray 1 def
/FrameCurPat null def
/FrameCurColors [ 0 0 0 1 0 0 0 ] def 
/FrameColorEpsilon .001 def	
/eqepsilon {		
	sub dup 0 lt {neg} if
	FrameColorEpsilon le
} bind def
/FrameCmpColorsCMYK { 
	2 copy 0 get exch 0 get eqepsilon {
		2 copy 1 get exch 1 get eqepsilon {
			2 copy 2 get exch 2 get eqepsilon {
				3 get exch 3 get eqepsilon
			} {pop pop false} ifelse
		}{pop pop false} ifelse
	} {pop pop false} ifelse
} bind def
/FrameCmpColorsRGB { 
	2 copy 4 get exch 0 get eqepsilon {
		2 copy 5 get exch 1 get eqepsilon {
			6 get exch 2 get eqepsilon
		}{pop pop false} ifelse
	} {pop pop false} ifelse
} bind def
/RGBtoCMYK { 
	1 exch sub 
	3 1 roll 
	1 exch sub 
	3 1 roll 
	1 exch sub 
	3 1 roll 
	3 copy 
	2 copy 
	le { pop } { exch pop } ifelse 
	2 copy 
	le { pop } { exch pop } ifelse 
	dup dup dup 
	6 1 roll 
	4 1 roll 
	7 1 roll 
	sub 
	6 1 roll 
	sub 
	5 1 roll 
	sub 
	4 1 roll 
} bind def
/CMYKtoRGB { 
	dup dup 4 -1 roll add 						  
	5 1 roll 3 -1 roll add 						  
	4 1 roll add 								  
	1 exch sub dup 0 lt {pop 0} if 3 1 roll 	  
	1 exch sub dup 0 lt {pop 0} if exch 	      
	1 exch sub dup 0 lt {pop 0} if exch	  		  
} bind def
/FrameSepInit {
	1.0 RealSetgray
} bind def
/FrameSetSepColor { 
	/FrameSepBlue exch def
	/FrameSepGreen exch def
	/FrameSepRed exch def
	/FrameSepBlack exch def
	/FrameSepYellow exch def
	/FrameSepMagenta exch def
	/FrameSepCyan exch def
	/FrameSepIs FMcustom def
	setCurrentScreen	
} bind def
/FrameSetCyan {
	/FrameSepBlue 1.0 def
	/FrameSepGreen 1.0 def
	/FrameSepRed 0.0 def
	/FrameSepBlack 0.0 def
	/FrameSepYellow 0.0 def
	/FrameSepMagenta 0.0 def
	/FrameSepCyan 1.0 def
	/FrameSepIs FMcyan def
	setCurrentScreen	
} bind def
 
/FrameSetMagenta {
	/FrameSepBlue 1.0 def
	/FrameSepGreen 0.0 def
	/FrameSepRed 1.0 def
	/FrameSepBlack 0.0 def
	/FrameSepYellow 0.0 def
	/FrameSepMagenta 1.0 def
	/FrameSepCyan 0.0 def
	/FrameSepIs FMmagenta def
	setCurrentScreen
} bind def
 
/FrameSetYellow {
	/FrameSepBlue 0.0 def
	/FrameSepGreen 1.0 def
	/FrameSepRed 1.0 def
	/FrameSepBlack 0.0 def
	/FrameSepYellow 1.0 def
	/FrameSepMagenta 0.0 def
	/FrameSepCyan 0.0 def
	/FrameSepIs FMyellow def
	setCurrentScreen
} bind def
 
/FrameSetBlack {
	/FrameSepBlue 0.0 def
	/FrameSepGreen 0.0 def
	/FrameSepRed 0.0 def
	/FrameSepBlack 1.0 def
	/FrameSepYellow 0.0 def
	/FrameSepMagenta 0.0 def
	/FrameSepCyan 0.0 def
	/FrameSepIs FMblack def
	setCurrentScreen
} bind def
 
/FrameNoSep { 
	/FrameSepIs FMnone def
	setCurrentScreen
} bind def
/FrameSetSepColors { 
	FrameDict begin
	[ exch 1 add 1 roll ]
	/FrameSepColors  
	exch def end
	} bind def
/FrameColorInSepListCMYK { 
	FrameSepColors {  
       		exch dup 3 -1 roll 
       		FrameCmpColorsCMYK 
       		{ pop true exit } if
    	} forall 
	dup true ne {pop false} if
	} bind def
/FrameColorInSepListRGB { 
	FrameSepColors {  
       		exch dup 3 -1 roll 
       		FrameCmpColorsRGB 
       		{ pop true exit } if
    	} forall 
	dup true ne {pop false} if
	} bind def
/RealSetgray /setgray load def
/RealSetrgbcolor /setrgbcolor load def
/RealSethsbcolor /sethsbcolor load def
end 
/setgray { 
	FrameDict begin
	FrameSepIs FMnone eq
		{ RealSetgray } 
		{ 
		FrameSepIs FMblack eq 
			{ RealSetgray } 
			{ FrameSepIs FMcustom eq 
			  FrameSepRed 0 eq and
			  FrameSepGreen 0 eq and
			  FrameSepBlue 0 eq and {
			  	RealSetgray
			  } {
				1 RealSetgray pop 
			  } ifelse
			} ifelse
		} ifelse
	end
} bind def
/setrgbcolor { 
	FrameDict begin
	FrameSepIs FMnone eq
	{  RealSetrgbcolor }
	{
		3 copy [ 4 1 roll ] 
		FrameColorInSepListRGB
		{
				FrameSepBlue eq exch 
			 	FrameSepGreen eq and exch 
			 	FrameSepRed eq and
			 	{ 0 } { 1 } ifelse
		}
		{
			FMPColor {
				RealSetrgbcolor
				currentcmykcolor
			} {
				RGBtoCMYK
			} ifelse
			FrameSepIs FMblack eq
			{1.0 exch sub 4 1 roll pop pop pop} {
			FrameSepIs FMyellow eq
			{pop 1.0 exch sub 3 1 roll pop pop} {
			FrameSepIs FMmagenta eq
			{pop pop 1.0 exch sub exch pop } {
			FrameSepIs FMcyan eq
			{pop pop pop 1.0 exch sub } 
			{pop pop pop pop 1} ifelse } ifelse } ifelse } ifelse 
		} ifelse
		RealSetgray
	} 
	ifelse
	end
} bind def
/sethsbcolor {
	FrameDict begin
	FrameSepIs FMnone eq 
	{ RealSethsbcolor } 
	{
		RealSethsbcolor 
		currentrgbcolor  
		setrgbcolor 
	} 
	ifelse
	end
} bind def
FrameDict begin
/setcmykcolor where {
	pop /RealSetcmykcolor /setcmykcolor load def
} {
	/RealSetcmykcolor {
		4 1 roll
		3 { 3 index add 0 max 1 min 1 exch sub 3 1 roll} repeat 
		setrgbcolor pop
	} bind def
} ifelse
userdict /setcmykcolor { 
		FrameDict begin
		FrameSepIs FMnone eq
		{ RealSetcmykcolor } 
		{
			4 copy [ 5 1 roll ]
			FrameColorInSepListCMYK
			{
				FrameSepBlack eq exch 
				FrameSepYellow eq and exch 
				FrameSepMagenta eq and exch 
				FrameSepCyan eq and 
				{ 0 } { 1 } ifelse
			}
			{
				FrameSepIs FMblack eq
				{1.0 exch sub 4 1 roll pop pop pop} {
				FrameSepIs FMyellow eq
				{pop 1.0 exch sub 3 1 roll pop pop} {
				FrameSepIs FMmagenta eq
				{pop pop 1.0 exch sub exch pop } {
				FrameSepIs FMcyan eq
				{pop pop pop 1.0 exch sub } 
				{pop pop pop pop 1} ifelse } ifelse } ifelse } ifelse 
			} ifelse
			RealSetgray
		}
		ifelse
		end
	} bind put
FMLevel1 not { 
	
	/patProcDict 5 dict dup begin
		<0f1e3c78f0e1c387> { 3 setlinewidth -1 -1 moveto 9 9 lineto stroke 
											4 -4 moveto 12 4 lineto stroke
											-4 4 moveto 4 12 lineto stroke} bind def
		<0f87c3e1f0783c1e> { 3 setlinewidth -1 9 moveto 9 -1 lineto stroke 
											-4 4 moveto 4 -4 lineto stroke
											4 12 moveto 12 4 lineto stroke} bind def
		<8142241818244281> { 1 setlinewidth -1 9 moveto 9 -1 lineto stroke
											-1 -1 moveto 9 9 lineto stroke } bind def
		<03060c183060c081> { 1 setlinewidth -1 -1 moveto 9 9 lineto stroke 
											4 -4 moveto 12 4 lineto stroke
											-4 4 moveto 4 12 lineto stroke} bind def
		<8040201008040201> { 1 setlinewidth -1 9 moveto 9 -1 lineto stroke 
											-4 4 moveto 4 -4 lineto stroke
											4 12 moveto 12 4 lineto stroke} bind def
	end def
	/patDict 15 dict dup begin
		/PatternType 1 def		
		/PaintType 2 def		
		/TilingType 3 def		
		/BBox [ 0 0 8 8 ] def 	
		/XStep 8 def			
		/YStep 8 def			
		/PaintProc {
			begin
			patProcDict bstring known {
				patProcDict bstring get exec
			} {
				8 8 true [1 0 0 -1 0 8] bstring imagemask
			} ifelse
			end
		} bind def
	end def
} if
/combineColor {
    FrameSepIs FMnone eq
	{
		graymode FMLevel1 or not {
			
			[/Pattern [/DeviceCMYK]] setcolorspace
			FrameCurColors 0 4 getinterval aload pop FrameCurPat setcolor
		} {
			FrameCurColors 3 get 1.0 ge {
				FrameCurGray RealSetgray
			} {
				FMPColor graymode and {
					0 1 3 { 
						FrameCurColors exch get
						1 FrameCurGray sub mul
					} for
					RealSetcmykcolor
				} {
					4 1 6 {
						FrameCurColors exch get
						graymode {
							1 exch sub 1 FrameCurGray sub mul 1 exch sub
						} {
							1.0 lt {FrameCurGray} {1} ifelse
						} ifelse
					} for
					RealSetrgbcolor
				} ifelse
			} ifelse
		} ifelse
	} { 
		FrameCurColors 0 4 getinterval aload
		FrameColorInSepListCMYK {
			FrameSepBlack eq exch 
			FrameSepYellow eq and exch 
			FrameSepMagenta eq and exch 
			FrameSepCyan eq and
			FrameSepIs FMcustom eq and
			{ FrameCurGray } { 1 } ifelse
		} {
			FrameSepIs FMblack eq
			{FrameCurGray 1.0 exch sub mul 1.0 exch sub 4 1 roll pop pop pop} {
			FrameSepIs FMyellow eq
			{pop FrameCurGray 1.0 exch sub mul 1.0 exch sub 3 1 roll pop pop} {
			FrameSepIs FMmagenta eq
			{pop pop FrameCurGray 1.0 exch sub mul 1.0 exch sub exch pop } {
			FrameSepIs FMcyan eq
			{pop pop pop FrameCurGray 1.0 exch sub mul 1.0 exch sub } 
			{pop pop pop pop 1} ifelse } ifelse } ifelse } ifelse 
		} ifelse
		graymode FMLevel1 or not {
			
			[/Pattern [/DeviceGray]] setcolorspace
			FrameCurPat setcolor
		} { 
			graymode not FMLevel1 and {
				
				dup 1 lt {pop FrameCurGray} if
			} if
			RealSetgray
		} ifelse
	} ifelse
} bind def
/savematrix {
	orgmatrix currentmatrix pop
	} bind def
/restorematrix {
	orgmatrix setmatrix
	} bind def
/dmatrix matrix def
/dpi    72 0 dmatrix defaultmatrix dtransform
    dup mul exch   dup mul add   sqrt def
	
/freq dpi dup 72 div round dup 0 eq {pop 1} if 8 mul div def
/sangle 1 0 dmatrix defaultmatrix dtransform exch atan def
/dpiranges   [  2540    2400    1693     1270    1200     635      600      0      ] def
/CMLowFreqs  [ 100.402  94.8683 89.2289 100.402  94.8683  66.9349  63.2456 47.4342 ] def
/YLowFreqs   [  95.25   90.0    84.65    95.25   90.0     70.5556  66.6667 50.0    ] def
/KLowFreqs   [  89.8026 84.8528 79.8088  89.8026 84.8528  74.8355  70.7107 53.033  ] def
/CLowAngles  [  71.5651 71.5651 71.5651 71.5651  71.5651  71.5651  71.5651 71.5651 ] def
/MLowAngles  [  18.4349 18.4349 18.4349 18.4349  18.4349  18.4349  18.4349 18.4349 ] def
/YLowTDot    [  true    true    false    true    true     false    false   false   ] def
/CMHighFreqs [ 133.87  126.491 133.843  108.503 102.523  100.402   94.8683 63.2456 ] def
/YHighFreqs  [ 127.0   120.0   126.975  115.455 109.091   95.25    90.0    60.0    ] def
/KHighFreqs  [ 119.737 113.137 119.713  128.289 121.218   89.8026  84.8528 63.6395 ] def
/CHighAngles [  71.5651 71.5651 71.5651  70.0169 70.0169  71.5651  71.5651 71.5651 ] def
/MHighAngles [  18.4349 18.4349 18.4349  19.9831 19.9831  18.4349  18.4349 18.4349 ] def
/YHighTDot   [  false   false   true     false   false    true     true    false   ] def
/PatFreq     [	10.5833 10.0     9.4055  10.5833 10.0	  10.5833  10.0	   9.375   ] def
/screenIndex {
	0 1 dpiranges length 1 sub { dup dpiranges exch get 1 sub dpi le {exit} {pop} ifelse } for
} bind def
/getCyanScreen {
	FMUseHighFrequencyScreens { CHighAngles CMHighFreqs} {CLowAngles CMLowFreqs} ifelse
		screenIndex dup 3 1 roll get 3 1 roll get /FMSpotFunction load
} bind def
/getMagentaScreen {
	FMUseHighFrequencyScreens { MHighAngles CMHighFreqs } {MLowAngles CMLowFreqs} ifelse
		screenIndex dup 3 1 roll get 3 1 roll get /FMSpotFunction load
} bind def
/getYellowScreen {
	FMUseHighFrequencyScreens { YHighTDot YHighFreqs} { YLowTDot YLowFreqs } ifelse
		screenIndex dup 3 1 roll get 3 1 roll get { 3 div
			{2 { 1 add 2 div 3 mul dup floor sub 2 mul 1 sub exch} repeat
			FMSpotFunction } } {/FMSpotFunction load } ifelse
			0.0 exch
} bind def
/getBlackScreen  {
	FMUseHighFrequencyScreens { KHighFreqs } { KLowFreqs } ifelse
		screenIndex get 45.0 /FMSpotFunction load 
} bind def
/getSpotScreen {
	getBlackScreen
} bind def
/getCompositeScreen {
	getBlackScreen
} bind def
/FMSetScreen 
	FMLevel1 { /setscreen load 
	}{ {
		8 dict begin
		/HalftoneType 1 def
		/SpotFunction exch def
		/Angle exch def
		/Frequency exch def
		/AccurateScreens FMUseAcccurateScreens def
		currentdict end sethalftone
	} bind } ifelse
def
/setDefaultScreen {
	FMPColor {
		orgrxfer cvx orggxfer cvx orgbxfer cvx orgxfer cvx setcolortransfer
	}
	{
		orgxfer cvx settransfer
	} ifelse
	orgfreq organgle orgproc cvx setscreen
} bind def
/setCurrentScreen {
	FrameSepIs FMnone eq {
		FMUseDefaultNoSeparationScreen {
			setDefaultScreen
		} {
			getCompositeScreen FMSetScreen
		} ifelse
	} {
		FrameSepIs FMcustom eq {
			FMUseDefaultSpotSeparationScreen {
				setDefaultScreen
			} {
				getSpotScreen FMSetScreen
			} ifelse
		} {
			FMUseDefaultProcessSeparationScreen {
				setDefaultScreen
			} {
				FrameSepIs FMcyan eq {
					getCyanScreen FMSetScreen
				} {
					FrameSepIs FMmagenta eq {
						getMagentaScreen FMSetScreen
					} {
						FrameSepIs FMyellow eq {
							getYellowScreen FMSetScreen
						} {
							getBlackScreen FMSetScreen
						} ifelse
					} ifelse
				} ifelse
			} ifelse
		} ifelse
	} ifelse 
} bind def
end
	/gstring FMLOCAL
	/gfile FMLOCAL
	/gindex FMLOCAL
	/orgrxfer FMLOCAL
	/orggxfer FMLOCAL
	/orgbxfer FMLOCAL
	/orgxfer FMLOCAL
	/orgproc FMLOCAL
	/orgrproc FMLOCAL
	/orggproc FMLOCAL
	/orgbproc FMLOCAL
	/organgle FMLOCAL
	/orgrangle FMLOCAL
	/orggangle FMLOCAL
	/orgbangle FMLOCAL
	/orgfreq FMLOCAL
	/orgrfreq FMLOCAL
	/orggfreq FMLOCAL
	/orgbfreq FMLOCAL
	/yscale FMLOCAL
	/xscale FMLOCAL
	/edown FMLOCAL
	/manualfeed FMLOCAL
	/paperheight FMLOCAL
	/paperwidth FMLOCAL
/FMDOCUMENT { 
	array /FMfonts exch def 
	/#copies exch def
	FrameDict begin
	0 ne /manualfeed exch def
	/paperheight exch def
	/paperwidth exch def
	0 ne /FrameNegative exch def 
	0 ne /edown exch def 
	/yscale exch def
	/xscale exch def
	FMLevel1 {
		manualfeed {setmanualfeed} if
		/FMdicttop countdictstack 1 add def 
		/FMoptop count def 
		setpapername 
		manualfeed {true} {papersize} ifelse 
		{manualpapersize} {false} ifelse 
		{desperatepapersize} {false} ifelse 
		{ (Can't select requested paper size for Frame print job!) FMFAILURE } if
		count -1 FMoptop {pop pop} for
		countdictstack -1 FMdicttop {pop end} for 
		}
		{{1 dict dup /PageSize [paperwidth paperheight]put setpagedevice}stopped
		{ (Can't select requested paper size for Frame print job!) FMFAILURE } if
		 {1 dict dup /ManualFeed manualfeed put setpagedevice } stopped pop }
	ifelse 
	
	FMPColor {
		currentcolorscreen
			cvlit /orgproc exch def
				  /organgle exch def 
				  /orgfreq exch def
			cvlit /orgbproc exch def
				  /orgbangle exch def 
				  /orgbfreq exch def
			cvlit /orggproc exch def
				  /orggangle exch def 
				  /orggfreq exch def
			cvlit /orgrproc exch def
				  /orgrangle exch def 
				  /orgrfreq exch def
			currentcolortransfer 
			FrameNegative {
				1 1 4 { 
					pop { 1 exch sub } concatprocs 4 1 roll
				} for
				4 copy
				setcolortransfer
			} if
			cvlit /orgxfer exch def
			cvlit /orgbxfer exch def
			cvlit /orggxfer exch def
			cvlit /orgrxfer exch def
	} {
		currentscreen 
			cvlit /orgproc exch def
				  /organgle exch def 
				  /orgfreq exch def
				  
		currenttransfer 
		FrameNegative {
			{ 1 exch sub } concatprocs
			dup settransfer
		} if 
		cvlit /orgxfer exch def
	} ifelse
	end 
} def 
/pagesave FMLOCAL
/orgmatrix FMLOCAL
/landscape FMLOCAL
/pwid FMLOCAL
/FMBEGINPAGE { 
	FrameDict begin 
	/pagesave save def
	3.86 setmiterlimit
	/landscape exch 0 ne def
	landscape { 
		90 rotate 0 exch dup /pwid exch def neg translate pop 
	}{
		pop /pwid exch def
	} ifelse
	edown { [-1 0 0 1 pwid 0] concat } if
	0 0 moveto paperwidth 0 lineto paperwidth paperheight lineto 
	0 paperheight lineto 0 0 lineto 1 setgray fill
	xscale yscale scale
	/orgmatrix matrix def
	gsave 
} def 
/FMENDPAGE {
	grestore 
	pagesave restore
	end 
	showpage
	} def 
/FMFONTDEFINE { 
	FrameDict begin
	findfont 
	ReEncode 
	1 index exch 
	definefont 
	FMfonts 3 1 roll 
	put
	end 
	} def 
/FMFILLS {
	FrameDict begin dup
	array /fillvals exch def
	dict /patCache exch def
	end 
	} def 
/FMFILL {
	FrameDict begin
	 fillvals 3 1 roll put
	end 
	} def 
/FMNORMALIZEGRAPHICS { 
	newpath
	0.0 0.0 moveto
	1 setlinewidth
	0 setlinecap
	0 0 0 sethsbcolor
	0 setgray 
	} bind def
	/fx FMLOCAL
	/fy FMLOCAL
	/fh FMLOCAL
	/fw FMLOCAL
	/llx FMLOCAL
	/lly FMLOCAL
	/urx FMLOCAL
	/ury FMLOCAL
/FMBEGINEPSF { 
	end 
	/FMEPSF save def 
	/showpage {} def 
% See Adobe's "PostScript Language Reference Manual, 2nd Edition", page 714.
% "...the following operators MUST NOT be used in an EPS file:" (emphasis ours)
	/banddevice {(banddevice) FMBADEPSF} def
	/clear {(clear) FMBADEPSF} def
	/cleardictstack {(cleardictstack) FMBADEPSF} def 
	/copypage {(copypage) FMBADEPSF} def
	/erasepage {(erasepage) FMBADEPSF} def
	/exitserver {(exitserver) FMBADEPSF} def
	/framedevice {(framedevice) FMBADEPSF} def
	/grestoreall {(grestoreall) FMBADEPSF} def
	/initclip {(initclip) FMBADEPSF} def
	/initgraphics {(initgraphics) FMBADEPSF} def
	/initmatrix {(initmatrix) FMBADEPSF} def
	/quit {(quit) FMBADEPSF} def
	/renderbands {(renderbands) FMBADEPSF} def
	/setglobal {(setglobal) FMBADEPSF} def
	/setpagedevice {(setpagedevice) FMBADEPSF} def
	/setshared {(setshared) FMBADEPSF} def
	/startjob {(startjob) FMBADEPSF} def
	/lettertray {(lettertray) FMBADEPSF} def
	/letter {(letter) FMBADEPSF} def
	/lettersmall {(lettersmall) FMBADEPSF} def
	/11x17tray {(11x17tray) FMBADEPSF} def
	/11x17 {(11x17) FMBADEPSF} def
	/ledgertray {(ledgertray) FMBADEPSF} def
	/ledger {(ledger) FMBADEPSF} def
	/legaltray {(legaltray) FMBADEPSF} def
	/legal {(legal) FMBADEPSF} def
	/statementtray {(statementtray) FMBADEPSF} def
	/statement {(statement) FMBADEPSF} def
	/executivetray {(executivetray) FMBADEPSF} def
	/executive {(executive) FMBADEPSF} def
	/a3tray {(a3tray) FMBADEPSF} def
	/a3 {(a3) FMBADEPSF} def
	/a4tray {(a4tray) FMBADEPSF} def
	/a4 {(a4) FMBADEPSF} def
	/a4small {(a4small) FMBADEPSF} def
	/b4tray {(b4tray) FMBADEPSF} def
	/b4 {(b4) FMBADEPSF} def
	/b5tray {(b5tray) FMBADEPSF} def
	/b5 {(b5) FMBADEPSF} def
	FMNORMALIZEGRAPHICS 
	[/fy /fx /fh /fw /ury /urx /lly /llx] {exch def} forall 
	fx fw 2 div add fy fh 2 div add  translate
	rotate
	fw 2 div neg fh 2 div neg translate
	fw urx llx sub div fh ury lly sub div scale 
	llx neg lly neg translate 
	/FMdicttop countdictstack 1 add def 
	/FMoptop count def 
	} bind def
/FMENDEPSF {
	count -1 FMoptop {pop pop} for 
	countdictstack -1 FMdicttop {pop end} for 
	FMEPSF restore
	FrameDict begin 
	} bind def
FrameDict begin 
/setmanualfeed {
%%BeginFeature *ManualFeed True
	 statusdict /manualfeed true put
%%EndFeature
	} bind def
/max {2 copy lt {exch} if pop} bind def
/min {2 copy gt {exch} if pop} bind def
/inch {72 mul} def
/pagedimen { 
	paperheight sub abs 16 lt exch 
	paperwidth sub abs 16 lt and
	{/papername exch def} {pop} ifelse
	} bind def
	/papersizedict FMLOCAL
/setpapername { 
	/papersizedict 14 dict def 
	papersizedict begin
	/papername /unknown def 
		/Letter 8.5 inch 11.0 inch pagedimen
		/LetterSmall 7.68 inch 10.16 inch pagedimen
		/Tabloid 11.0 inch 17.0 inch pagedimen
		/Ledger 17.0 inch 11.0 inch pagedimen
		/Legal 8.5 inch 14.0 inch pagedimen
		/Statement 5.5 inch 8.5 inch pagedimen
		/Executive 7.5 inch 10.0 inch pagedimen
		/A3 11.69 inch 16.5 inch pagedimen
		/A4 8.26 inch 11.69 inch pagedimen
		/A4Small 7.47 inch 10.85 inch pagedimen
		/B4 10.125 inch 14.33 inch pagedimen
		/B5 7.16 inch 10.125 inch pagedimen
	end
	} bind def
/papersize {
	papersizedict begin
		/Letter {lettertray letter} def
		/LetterSmall {lettertray lettersmall} def
		/Tabloid {11x17tray 11x17} def
		/Ledger {ledgertray ledger} def
		/Legal {legaltray legal} def
		/Statement {statementtray statement} def
		/Executive {executivetray executive} def
		/A3 {a3tray a3} def
		/A4 {a4tray a4} def
		/A4Small {a4tray a4small} def
		/B4 {b4tray b4} def
		/B5 {b5tray b5} def
		/unknown {unknown} def
	papersizedict dup papername known {papername} {/unknown} ifelse get
	end
	statusdict begin stopped end 
	} bind def
/manualpapersize {
	papersizedict begin
		/Letter {letter} def
		/LetterSmall {lettersmall} def
		/Tabloid {11x17} def
		/Ledger {ledger} def
		/Legal {legal} def
		/Statement {statement} def
		/Executive {executive} def
		/A3 {a3} def
		/A4 {a4} def
		/A4Small {a4small} def
		/B4 {b4} def
		/B5 {b5} def
		/unknown {unknown} def
	papersizedict dup papername known {papername} {/unknown} ifelse get
	end
	stopped 
	} bind def
/desperatepapersize {
	statusdict /setpageparams known
		{
		paperwidth paperheight 0 1 
		statusdict begin
		{setpageparams} stopped 
		end
		} {true} ifelse 
	} bind def
/DiacriticEncoding [
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /space /exclam /quotedbl
/numbersign /dollar /percent /ampersand /quotesingle /parenleft
/parenright /asterisk /plus /comma /hyphen /period /slash /zero /one
/two /three /four /five /six /seven /eight /nine /colon /semicolon
/less /equal /greater /question /at /A /B /C /D /E /F /G /H /I /J /K
/L /M /N /O /P /Q /R /S /T /U /V /W /X /Y /Z /bracketleft /backslash
/bracketright /asciicircum /underscore /grave /a /b /c /d /e /f /g /h
/i /j /k /l /m /n /o /p /q /r /s /t /u /v /w /x /y /z /braceleft /bar
/braceright /asciitilde /.notdef /Adieresis /Aring /Ccedilla /Eacute
/Ntilde /Odieresis /Udieresis /aacute /agrave /acircumflex /adieresis
/atilde /aring /ccedilla /eacute /egrave /ecircumflex /edieresis
/iacute /igrave /icircumflex /idieresis /ntilde /oacute /ograve
/ocircumflex /odieresis /otilde /uacute /ugrave /ucircumflex
/udieresis /dagger /.notdef /cent /sterling /section /bullet
/paragraph /germandbls /registered /copyright /trademark /acute
/dieresis /.notdef /AE /Oslash /.notdef /.notdef /.notdef /.notdef
/yen /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/ordfeminine /ordmasculine /.notdef /ae /oslash /questiondown
/exclamdown /logicalnot /.notdef /florin /.notdef /.notdef
/guillemotleft /guillemotright /ellipsis /.notdef /Agrave /Atilde
/Otilde /OE /oe /endash /emdash /quotedblleft /quotedblright
/quoteleft /quoteright /.notdef /.notdef /ydieresis /Ydieresis
/fraction /currency /guilsinglleft /guilsinglright /fi /fl /daggerdbl
/periodcentered /quotesinglbase /quotedblbase /perthousand
/Acircumflex /Ecircumflex /Aacute /Edieresis /Egrave /Iacute
/Icircumflex /Idieresis /Igrave /Oacute /Ocircumflex /.notdef /Ograve
/Uacute /Ucircumflex /Ugrave /dotlessi /circumflex /tilde /macron
/breve /dotaccent /ring /cedilla /hungarumlaut /ogonek /caron
] def
/ReEncode { 
	dup 
	length 
	dict begin 
	{
	1 index /FID ne 
		{def} 
		{pop pop} ifelse 
	} forall 
	0 eq {/Encoding DiacriticEncoding def} if 
	currentdict 
	end 
	} bind def
FMPColor 
	
	{
	/BEGINBITMAPCOLOR { 
		BITMAPCOLOR} def
	/BEGINBITMAPCOLORc { 
		BITMAPCOLORc} def
	/BEGINBITMAPTRUECOLOR { 
		BITMAPTRUECOLOR } def
	/BEGINBITMAPTRUECOLORc { 
		BITMAPTRUECOLORc } def
	}
	
	{
	/BEGINBITMAPCOLOR { 
		BITMAPGRAY} def
	/BEGINBITMAPCOLORc { 
		BITMAPGRAYc} def
	/BEGINBITMAPTRUECOLOR { 
		BITMAPTRUEGRAY } def
	/BEGINBITMAPTRUECOLORc { 
		BITMAPTRUEGRAYc } def
	}
ifelse
/K { 
	FMPrintAllColorsAsBlack {
		dup 1 eq 2 index 1 eq and 3 index 1 eq and not
			{7 {pop} repeat 0 0 0 1 0 0 0} if
	} if 
	FrameCurColors astore 
	pop combineColor
} bind def
/graymode true def
	/bwidth FMLOCAL
	/bpside FMLOCAL
	/bstring FMLOCAL
	/onbits FMLOCAL
	/offbits FMLOCAL
	/xindex FMLOCAL
	/yindex FMLOCAL
	/x FMLOCAL
	/y FMLOCAL
/setPatternMode {
	FMLevel1 {
		/bwidth  exch def
		/bpside  exch def
		/bstring exch def
		/onbits 0 def  /offbits 0 def
		freq sangle landscape {90 add} if 
			{/y exch def
			 /x exch def
			 /xindex x 1 add 2 div bpside mul cvi def
			 /yindex y 1 add 2 div bpside mul cvi def
			 bstring yindex bwidth mul xindex 8 idiv add get
			 1 7 xindex 8 mod sub bitshift and 0 ne FrameNegative {not} if
			 {/onbits  onbits  1 add def 1}
			 {/offbits offbits 1 add def 0}
			 ifelse
			}
			setscreen
		offbits offbits onbits add div FrameNegative {1.0 exch sub} if
		/FrameCurGray exch def
	} { 
		pop pop
		dup patCache exch known {
			patCache exch get
		} { 
			dup
			patDict /bstring 3 -1 roll put
			patDict 
			9 PatFreq screenIndex get div dup matrix scale
			makepattern
			dup 
			patCache 4 -1 roll 3 -1 roll put
		} ifelse
		/FrameCurGray 0 def
		/FrameCurPat exch def
	} ifelse
	/graymode false def
	combineColor
} bind def
/setGrayScaleMode {
	graymode not {
		/graymode true def
		FMLevel1 {
			setCurrentScreen
		} if
	} if
	/FrameCurGray exch def
	combineColor
} bind def
/normalize {
	transform round exch round exch itransform
	} bind def
/dnormalize {
	dtransform round exch round exch idtransform
	} bind def
/lnormalize { 
	0 dtransform exch cvi 2 idiv 2 mul 1 add exch idtransform pop
	} bind def
/H { 
	lnormalize setlinewidth
	} bind def
/Z {
	setlinecap
	} bind def
	
/PFill {
	graymode FMLevel1 or not {
		gsave 1 setgray eofill grestore
	} if
} bind def
/PStroke {
	graymode FMLevel1 or not {
		gsave 1 setgray stroke grestore
	} if
	stroke
} bind def
	/fillvals FMLOCAL
/X { 
	fillvals exch get
	dup type /stringtype eq
	{8 1 setPatternMode} 
	{setGrayScaleMode}
	ifelse
	} bind def
/V { 
	PFill gsave eofill grestore
	} bind def
/Vclip {
	clip
	} bind def
/Vstrk {
	currentlinewidth exch setlinewidth PStroke setlinewidth
	} bind def
/N { 
	PStroke
	} bind def
/Nclip {
	strokepath clip newpath
	} bind def
/Nstrk {
	currentlinewidth exch setlinewidth PStroke setlinewidth
	} bind def
/M {newpath moveto} bind def
/E {lineto} bind def
/D {curveto} bind def
/O {closepath} bind def
	/n FMLOCAL
/L { 
 	/n exch def
	newpath
	normalize
	moveto 
	2 1 n {pop normalize lineto} for
	} bind def
/Y { 
	L 
	closepath
	} bind def
	/x1 FMLOCAL
	/x2 FMLOCAL
	/y1 FMLOCAL
	/y2 FMLOCAL
/R { 
	/y2 exch def
	/x2 exch def
	/y1 exch def
	/x1 exch def
	x1 y1
	x2 y1
	x2 y2
	x1 y2
	4 Y 
	} bind def
	/rad FMLOCAL
/rarc 
	{rad 
	 arcto
	} bind def
/RR { 
	/rad exch def
	normalize
	/y2 exch def
	/x2 exch def
	normalize
	/y1 exch def
	/x1 exch def
	mark
	newpath
	{
	x1 y1 rad add moveto
	x1 y2 x2 y2 rarc
	x2 y2 x2 y1 rarc
	x2 y1 x1 y1 rarc
	x1 y1 x1 y2 rarc
	closepath
	} stopped {x1 y1 x2 y2 R} if 
	cleartomark
	} bind def
/RRR { 
	/rad exch def
	normalize /y4 exch def /x4 exch def
	normalize /y3 exch def /x3 exch def
	normalize /y2 exch def /x2 exch def
	normalize /y1 exch def /x1 exch def
	newpath
	normalize moveto 
	mark
	{
	x2 y2 x3 y3 rarc
	x3 y3 x4 y4 rarc
	x4 y4 x1 y1 rarc
	x1 y1 x2 y2 rarc
	closepath
	} stopped
	 {x1 y1 x2 y2 x3 y3 x4 y4 newpath moveto lineto lineto lineto closepath} if
	cleartomark
	} bind def
/C { 
	grestore
	gsave
	R 
	clip
	setCurrentScreen
} bind def
/CP { 
	grestore
	gsave
	Y 
	clip
	setCurrentScreen
} bind def
	/FMpointsize FMLOCAL
/F { 
	FMfonts exch get
	FMpointsize scalefont
	setfont
	} bind def
/Q { 
	/FMpointsize exch def
	F 
	} bind def
/T { 
	moveto show
	} bind def
/RF { 
	rotate
	0 ne {-1 1 scale} if
	} bind def
/TF { 
	gsave
	moveto 
	RF
	show
	grestore
	} bind def
/P { 
	moveto
	0 32 3 2 roll widthshow
	} bind def
/PF { 
	gsave
	moveto 
	RF
	0 32 3 2 roll widthshow
	grestore
	} bind def
/S { 
	moveto
	0 exch ashow
	} bind def
/SF { 
	gsave
	moveto
	RF
	0 exch ashow
	grestore
	} bind def
/B { 
	moveto
	0 32 4 2 roll 0 exch awidthshow
	} bind def
/BF { 
	gsave
	moveto
	RF
	0 32 4 2 roll 0 exch awidthshow
	grestore
	} bind def
/G { 
	gsave
	newpath
	normalize translate 0.0 0.0 moveto 
	dnormalize scale 
	0.0 0.0 1.0 5 3 roll arc 
	closepath 
	PFill fill
	grestore
	} bind def
/Gstrk {
	savematrix
    newpath
    2 index 2 div add exch 3 index 2 div sub exch 
    normalize 2 index 2 div sub exch 3 index 2 div add exch 
    translate
    scale 
    0.0 0.0 1.0 5 3 roll arc 
    restorematrix
    currentlinewidth exch setlinewidth PStroke setlinewidth
    } bind def
/Gclip { 
	newpath
	savematrix
	normalize translate 0.0 0.0 moveto 
	dnormalize scale 
	0.0 0.0 1.0 5 3 roll arc 
	closepath 
	clip newpath
	restorematrix
	} bind def
/GG { 
	gsave
	newpath
	normalize translate 0.0 0.0 moveto 
	rotate 
	dnormalize scale 
	0.0 0.0 1.0 5 3 roll arc 
	closepath
	PFill
	fill
	grestore
	} bind def
/GGclip { 
	savematrix
	newpath
    normalize translate 0.0 0.0 moveto 
    rotate 
    dnormalize scale 
    0.0 0.0 1.0 5 3 roll arc 
    closepath
	clip newpath
	restorematrix
	} bind def
/GGstrk { 
	savematrix
    newpath
    normalize translate 0.0 0.0 moveto 
    rotate 
    dnormalize scale 
    0.0 0.0 1.0 5 3 roll arc 
    closepath 
	restorematrix
    currentlinewidth exch setlinewidth PStroke setlinewidth
	} bind def
/A { 
	gsave
	savematrix
	newpath
	2 index 2 div add exch 3 index 2 div sub exch 
	normalize 2 index 2 div sub exch 3 index 2 div add exch 
	translate 
	scale 
	0.0 0.0 1.0 5 3 roll arc 
	restorematrix
	PStroke
	grestore
	} bind def
/Aclip {
	newpath
	savematrix
	normalize translate 0.0 0.0 moveto 
	dnormalize scale 
	0.0 0.0 1.0 5 3 roll arc 
	closepath 
	strokepath clip newpath
	restorematrix
} bind def
/Astrk {
	Gstrk
} bind def
/AA { 
	gsave
	savematrix
	newpath
	
	3 index 2 div add exch 4 index 2 div sub exch 
	
	normalize 3 index 2 div sub exch 4 index 2 div add exch
	translate 
	rotate 
	scale 
	0.0 0.0 1.0 5 3 roll arc 
	restorematrix
	PStroke
	grestore
	} bind def
/AAclip {
	savematrix
	newpath
    normalize translate 0.0 0.0 moveto 
    rotate 
    dnormalize scale 
    0.0 0.0 1.0 5 3 roll arc 
    closepath
	strokepath clip newpath
	restorematrix
} bind def
/AAstrk {
	GGstrk
} bind def
	/x FMLOCAL
	/y FMLOCAL
	/w FMLOCAL
	/h FMLOCAL
	/xx FMLOCAL
	/yy FMLOCAL
	/ww FMLOCAL
	/hh FMLOCAL
	/FMsaveobject FMLOCAL
	/FMoptop FMLOCAL
	/FMdicttop FMLOCAL
/BEGINPRINTCODE { 
	/FMdicttop countdictstack 1 add def 
	/FMoptop count 7 sub def 
	/FMsaveobject save def
	userdict begin 
	/showpage {} def 
	FMNORMALIZEGRAPHICS 
	3 index neg 3 index neg translate
	} bind def
/ENDPRINTCODE {
	count -1 FMoptop {pop pop} for 
	countdictstack -1 FMdicttop {pop end} for 
	FMsaveobject restore 
	} bind def
/gn { 
	0 
	{	46 mul 
		cf read pop 
		32 sub 
		dup 46 lt {exit} if 
		46 sub add 
		} loop
	add 
	} bind def
	/str FMLOCAL
/cfs { 
	/str sl string def 
	0 1 sl 1 sub {str exch val put} for 
	str def 
	} bind def
/ic [ 
	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0223
	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0223
	0
	{0 hx} {1 hx} {2 hx} {3 hx} {4 hx} {5 hx} {6 hx} {7 hx} {8 hx} {9 hx}
	{10 hx} {11 hx} {12 hx} {13 hx} {14 hx} {15 hx} {16 hx} {17 hx} {18 hx}
	{19 hx} {gn hx} {0} {1} {2} {3} {4} {5} {6} {7} {8} {9} {10} {11} {12}
	{13} {14} {15} {16} {17} {18} {19} {gn} {0 wh} {1 wh} {2 wh} {3 wh}
	{4 wh} {5 wh} {6 wh} {7 wh} {8 wh} {9 wh} {10 wh} {11 wh} {12 wh}
	{13 wh} {14 wh} {gn wh} {0 bl} {1 bl} {2 bl} {3 bl} {4 bl} {5 bl} {6 bl}
	{7 bl} {8 bl} {9 bl} {10 bl} {11 bl} {12 bl} {13 bl} {14 bl} {gn bl}
	{0 fl} {1 fl} {2 fl} {3 fl} {4 fl} {5 fl} {6 fl} {7 fl} {8 fl} {9 fl}
	{10 fl} {11 fl} {12 fl} {13 fl} {14 fl} {gn fl}
	] def
	/sl FMLOCAL
	/val FMLOCAL
	/ws FMLOCAL
	/im FMLOCAL
	/bs FMLOCAL
	/cs FMLOCAL
	/len FMLOCAL
	/pos FMLOCAL
/ms { 
	/sl exch def 
	/val 255 def 
	/ws cfs 
	/im cfs 
	/val 0 def 
	/bs cfs 
	/cs cfs 
	} bind def
400 ms 
/ip { 
	is 
	0 
	cf cs readline pop 
	{	ic exch get exec 
		add 
		} forall 
	pop 
	
	} bind def
/rip { 
	   
	  
	  bis ris copy pop 
      is
      0
      cf cs readline pop 
      {       ic exch get exec 
              add 
              } forall 
	  pop pop 
	  ris gis copy pop 
	  dup is exch 
	  
      cf cs readline pop 
      {       ic exch get exec 
              add 
              } forall 
	  pop pop
	  gis bis copy pop 
	  dup add is exch 
	  
      cf cs readline pop 
      {       ic exch get exec 
              add 
              } forall 
      pop 
      
      } bind def
/wh { 
	/len exch def 
	/pos exch def 
	ws 0 len getinterval im pos len getinterval copy pop
	pos len 
	} bind def
/bl { 
	/len exch def 
	/pos exch def 
	bs 0 len getinterval im pos len getinterval copy pop
	pos len 
	} bind def
/s1 1 string def
/fl { 
	/len exch def 
	/pos exch def 
	/val cf s1 readhexstring pop 0 get def
	pos 1 pos len add 1 sub {im exch val put} for
	pos len 
	} bind def
/hx { 
	3 copy getinterval 
	cf exch readhexstring pop pop 
	} bind def
	/h FMLOCAL
	/w FMLOCAL
	/d FMLOCAL
	/lb FMLOCAL
	/bitmapsave FMLOCAL
	/is FMLOCAL
	/cf FMLOCAL
/wbytes { 
      dup dup
      24 eq { pop pop 3 mul }
      { 8 eq {pop} {1 eq {7 add 8 idiv} {3 add 4 idiv} ifelse} ifelse } ifelse
	} bind def
/BEGINBITMAPBWc { 
	1 {} COMMONBITMAPc
	} bind def
/BEGINBITMAPGRAYc { 
	8 {} COMMONBITMAPc
	} bind def
/BEGINBITMAP2BITc { 
	2 {} COMMONBITMAPc
	} bind def
/COMMONBITMAPc { 
		 
	/r exch def
	/d exch def
	gsave
	
	3 index 2 div add exch	
	4 index 2 div add exch	
	translate		
	rotate			
	1 index 2 div neg	
	1 index 2 div neg	
	translate		
	scale			
	/h exch def /w exch def
	/lb w d wbytes def 
	sl lb lt {lb ms} if 
	/bitmapsave save def 
	r                    
	/is im 0 lb getinterval def 
	ws 0 lb getinterval is copy pop 
	/cf currentfile def 
	w h d [w 0 0 h neg 0 h] 
	{ip} image 
	bitmapsave restore 
	grestore
	} bind def
/BEGINBITMAPBW { 
	1 {} COMMONBITMAP
	} bind def
/BEGINBITMAPGRAY { 
	8 {} COMMONBITMAP
	} bind def
/BEGINBITMAP2BIT { 
	2 {} COMMONBITMAP
	} bind def
/COMMONBITMAP { 
	/r exch def
	/d exch def
	gsave
	
	3 index 2 div add exch	
	4 index 2 div add exch	
	translate		
	rotate			
	1 index 2 div neg	
	1 index 2 div neg	
	translate		
	scale			
	/h exch def /w exch def
	/bitmapsave save def 
	r                    
	/is w d wbytes string def
	/cf currentfile def 
	w h d [w 0 0 h neg 0 h] 
	{cf is readhexstring pop} image
	bitmapsave restore 
	grestore
	} bind def
/ngrayt 256 array def
/nredt 256 array def
/nbluet 256 array def
/ngreent 256 array def
	/gryt FMLOCAL
	/blut FMLOCAL
	/grnt FMLOCAL
	/redt FMLOCAL
	/indx FMLOCAL
	/cynu FMLOCAL
	/magu FMLOCAL
	/yelu FMLOCAL
	/k FMLOCAL
	/u FMLOCAL
FMLevel1 {
/colorsetup {
	currentcolortransfer
	/gryt exch def
	/blut exch def
	/grnt exch def
	/redt exch def
	0 1 255 {
		/indx exch def
		/cynu 1 red indx get 255 div sub def
		/magu 1 green indx get 255 div sub def
		/yelu 1 blue indx get 255 div sub def
		/k cynu magu min yelu min def
		/u k currentundercolorremoval exec def
%		/u 0 def
		nredt indx 1 0 cynu u sub max sub redt exec put
		ngreent indx 1 0 magu u sub max sub grnt exec put
		nbluet indx 1 0 yelu u sub max sub blut exec put
		ngrayt indx 1 k currentblackgeneration exec sub gryt exec put
	} for
	{255 mul cvi nredt exch get}
	{255 mul cvi ngreent exch get}
	{255 mul cvi nbluet exch get}
	{255 mul cvi ngrayt exch get}
	setcolortransfer
	{pop 0} setundercolorremoval
	{} setblackgeneration
	} bind def
}
{
/colorSetup2 {
	[ /Indexed /DeviceRGB 255 
		{dup red exch get 255 div 
		 exch dup green exch get 255 div 
		 exch blue exch get 255 div}
	] setcolorspace
} bind def
} ifelse
	/tran FMLOCAL
/fakecolorsetup {
	/tran 256 string def
	0 1 255 {/indx exch def 
		tran indx
		red indx get 77 mul
		green indx get 151 mul
		blue indx get 28 mul
		add add 256 idiv put} for
	currenttransfer
	{255 mul cvi tran exch get 255.0 div}
	exch concatprocs settransfer
} bind def
/BITMAPCOLOR { 
	/d 8 def
	gsave
	
	3 index 2 div add exch	
	4 index 2 div add exch	
	translate		
	rotate			
	1 index 2 div neg	
	1 index 2 div neg	
	translate		
	scale			
	/h exch def /w exch def
	/bitmapsave save def
	FMLevel1 {	
		colorsetup
		/is w d wbytes string def
		/cf currentfile def 
		w h d [w 0 0 h neg 0 h] 
		{cf is readhexstring pop} {is} {is} true 3 colorimage 
	} {
		colorSetup2
		/is w d wbytes string def
		/cf currentfile def 
		7 dict dup begin
			/ImageType 1 def
			/Width w def
			/Height h def
			/ImageMatrix [w 0 0 h neg 0 h] def
			/DataSource {cf is readhexstring pop} bind def
			/BitsPerComponent d def
			/Decode [0 255] def
		end image	
	} ifelse
	bitmapsave restore 
	grestore
	} bind def
/BITMAPCOLORc { 
	/d 8 def
	gsave
	
	3 index 2 div add exch	
	4 index 2 div add exch	
	translate		
	rotate			
	1 index 2 div neg	
	1 index 2 div neg	
	translate		
	scale			
	/h exch def /w exch def
	/lb w d wbytes def 
	sl lb lt {lb ms} if 
	/bitmapsave save def 
	FMLevel1 {	
		colorsetup
		/is im 0 lb getinterval def 
		ws 0 lb getinterval is copy pop 
		/cf currentfile def 
		w h d [w 0 0 h neg 0 h] 
		{ip} {is} {is} true 3 colorimage
	} {
		colorSetup2
		/is im 0 lb getinterval def 
		ws 0 lb getinterval is copy pop 
		/cf currentfile def 
		7 dict dup begin
			/ImageType 1 def
			/Width w def
			/Height h def
			/ImageMatrix [w 0 0 h neg 0 h] def
			/DataSource {ip} bind def
			/BitsPerComponent d def
			/Decode [0 255] def
		end image	
	} ifelse
	bitmapsave restore 
	grestore
	} bind def
/BITMAPTRUECOLORc { 
	/d 24 def
        gsave
 	
	3 index 2 div add exch	
	4 index 2 div add exch	
	translate		
	rotate			
	1 index 2 div neg	
	1 index 2 div neg	
	translate		
	scale			
	/h exch def /w exch def
	/lb w d wbytes def 
	sl lb lt {lb ms} if 
        /bitmapsave save def 
        
	/is im 0 lb getinterval def	
	/ris im 0 w getinterval def	
	/gis im w w getinterval def	
	/bis im w 2 mul w getinterval def 
        
        ws 0 lb getinterval is copy pop 
        /cf currentfile def 
        w h 8 [w 0 0 h neg 0 h] 
        {w rip pop ris} {gis} {bis} true 3 colorimage
        bitmapsave restore 
        grestore
        } bind def
/BITMAPTRUECOLOR { 
        gsave
		
		3 index 2 div add exch	
		4 index 2 div add exch	
		translate		
		rotate			
		1 index 2 div neg	
		1 index 2 div neg	
		translate		
		scale			
		/h exch def /w exch def
        /bitmapsave save def 
        /is w string def
        /gis w string def
        /bis w string def
        /cf currentfile def 
        w h 8 [w 0 0 h neg 0 h] 
        { cf is readhexstring pop } 
        { cf gis readhexstring pop } 
        { cf bis readhexstring pop } 
        true 3 colorimage 
        bitmapsave restore 
        grestore
        } bind def
/BITMAPTRUEGRAYc { 
	/d 24 def
        gsave
	
	3 index 2 div add exch	
	4 index 2 div add exch	
	translate		
	rotate			
	1 index 2 div neg	
	1 index 2 div neg	
	translate		
	scale			
	/h exch def /w exch def
	/lb w d wbytes def 
	sl lb lt {lb ms} if 
        /bitmapsave save def 
        
	/is im 0 lb getinterval def	
	/ris im 0 w getinterval def	
	/gis im w w getinterval def	
	/bis im w 2 mul w getinterval def 
        ws 0 lb getinterval is copy pop 
        /cf currentfile def 
        w h 8 [w 0 0 h neg 0 h] 
        {w rip pop ris gis bis w gray} image
        bitmapsave restore 
        grestore
        } bind def
/ww FMLOCAL
/r FMLOCAL
/g FMLOCAL
/b FMLOCAL
/i FMLOCAL
/gray { 
        /ww exch def
        /b exch def
        /g exch def
        /r exch def
        0 1 ww 1 sub { /i exch def r i get .299 mul g i get .587 mul
			b i get .114 mul add add r i 3 -1 roll floor cvi put } for
        r
        } bind def
/BITMAPTRUEGRAY { 
        gsave
		
		3 index 2 div add exch	
		4 index 2 div add exch	
		translate		
		rotate			
		1 index 2 div neg	
		1 index 2 div neg	
		translate		
		scale			
		/h exch def /w exch def
        /bitmapsave save def 
        /is w string def
        /gis w string def
        /bis w string def
        /cf currentfile def 
        w h 8 [w 0 0 h neg 0 h] 
        { cf is readhexstring pop 
          cf gis readhexstring pop 
          cf bis readhexstring pop w gray}  image
        bitmapsave restore 
        grestore
        } bind def
/BITMAPGRAY { 
	8 {fakecolorsetup} COMMONBITMAP
	} bind def
/BITMAPGRAYc { 
	8 {fakecolorsetup} COMMONBITMAPc
	} bind def
/ENDBITMAP {
	} bind def
end 
	/ALDsave FMLOCAL
	/ALDmatrix matrix def ALDmatrix currentmatrix pop
/StartALD {
	/ALDsave save def
	 savematrix
	 ALDmatrix setmatrix
	} bind def
/InALD {
	 restorematrix
	} bind def
/DoneALD {
	 ALDsave restore
	} bind def
/I { setdash } bind def
/J { [] 0 setdash } bind def
%%EndProlog
%%BeginSetup
(4.0) FMVERSION
1 1 0 0 612 792 0 1 17 FMDOCUMENT
0 0 /Helvetica-Bold FMFONTDEFINE
1 0 /NewCenturySchlbk-Roman FMFONTDEFINE
2 1 /ZapfDingbats FMFONTDEFINE
3 0 /NewCenturySchlbk-Italic FMFONTDEFINE
4 0 /NewCenturySchlbk-Bold FMFONTDEFINE
5 0 /Courier FMFONTDEFINE
6 0 /Times-Italic FMFONTDEFINE
7 0 /Times-Roman FMFONTDEFINE
32 FMFILLS
0 0 FMFILL
1 0.1 FMFILL
2 0.3 FMFILL
3 0.5 FMFILL
4 0.7 FMFILL
5 0.9 FMFILL
6 0.97 FMFILL
7 1 FMFILL
8 <0f1e3c78f0e1c387> FMFILL
9 <0f87c3e1f0783c1e> FMFILL
10 <cccccccccccccccc> FMFILL
11 <ffff0000ffff0000> FMFILL
12 <8142241818244281> FMFILL
13 <03060c183060c081> FMFILL
14 <8040201008040201> FMFILL
16 1 FMFILL
17 0.9 FMFILL
18 0.7 FMFILL
19 0.5 FMFILL
20 0.3 FMFILL
21 0.1 FMFILL
22 0.03 FMFILL
23 0 FMFILL
24 <f0e1c3870f1e3c78> FMFILL
25 <f0783c1e0f87c3e1> FMFILL
26 <3333333333333333> FMFILL
27 <0000ffff0000ffff> FMFILL
28 <7ebddbe7e7dbbd7e> FMFILL
29 <fcf9f3e7cf9f3f7e> FMFILL
30 <7fbfdfeff7fbfdfe> FMFILL
%%EndSetup
%%Page: "569" 1
%%BeginPaperSize: Letter
%%EndPaperSize
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
J
0 0 0 1 0 0 0 K
162 690.34 558 702 R
7 X
0 0 0 1 0 0 0 K
V
0 14 Q
0 X
(Design Philosophy) 431.97 692.67 T
162 666.34 558 678.01 R
7 X
V
1 10 Q
0 X
(569) 541.32 671.34 T
324 684 580 684 2 L
7 X
V
3 H
2 Z
0 X
N
504 90 558 125 R
7 X
V
2 60 Q
0 X
(l) 507.27 85 T
0 24 Q
(Concepts book) 327.65 110 T
90 99 270 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
90.67 123.5 270.67 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
536.84 533.33 557.67 545 R
V
0 8 Q
0 X
(16.1) 542.1 539.67 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
1 10 Q
0 X
-0.12 (The) 180 610.3 P
1 9 Q
-0.1 (GEOS) 200.44 610.3 P
1 10 Q
-0.12 ( memory manager is well suited to dealing with blocks of memory) 226.62 610.3 P
(in the 2K-6K range. However) 180 597.3 T
(, for small amounts of memory) 314.83 597.3 T
(, the manager) 454.66 597.3 T
(\325) 519.48 597.3 T
(s) 521.15 597.3 T
-0.04 (overhead becomes signi\336cant. For this reason,) 180 584.3 P
1 9 Q
-0.03 (GEOS) 395.9 584.3 P
1 10 Q
-0.04 ( provides local memory) 422.07 584.3 P
(\050or) 180 571.3 T
3 F
(LMem) 195.55 571.3 T
1 F
(\051 routines. These routines let an application allocate a block of) 224.99 571.3 T
(memory and designate it as a) 180 558.3 T
3 F
(local memory heap) 318.92 558.3 T
1 F
(. The application can then) 405.01 558.3 T
(request small amounts of memory from this heap. The LMem library) 180 545.3 T
-0.37 (automatically reorganizes the heap when necessary to make space available.) 180 532.3 P
(The local memory routines are also used to manipulate objects. All objects) 180 512.3 T
(are special LMem chunks which are stored in a special type of LMem heap) 180 499.3 T
-0.02 (\050called an) 180 486.3 P
3 F
-0.02 (object block) 227.55 486.3 P
1 F
-0.02 (\051. Most of the routines which work on chunks can also) 280.31 486.3 P
(be used on objects.) 180 473.3 T
-0.1 (Before you read this chapter) 180 453.3 P
-0.1 (, you should be familiar with the use of handles) 310.14 453.3 P
-0.88 (in) 180 440.3 P
1 9 Q
-0.79 (GEOS) 191.16 440.3 P
1 10 Q
-0.88 ( and with the 80x86\325) 217.34 440.3 P
-0.88 (s segment:offset memory referencing. Y) 307.57 440.3 P
-0.88 (ou should) 485.35 440.3 P
(also be familiar with the global memory manager \050see \322Memory) 180 427.3 T
(Management,\323 Chapter) 180 414.3 T
(15\051.) 291.12 414.3 T
0 14 Q
(16.1) 134.76 361.97 T
0 24 Q
(Design Philosophy) 180 361.97 T
1 10 Q
-0.59 (The) 180 336.3 P
1 9 Q
-0.53 (GEOS) 199.97 336.3 P
1 10 Q
-0.59 ( memory manager is designed to deal with blocks of memory which) 226.15 336.3 P
-0.25 (are measured in kilobytes. Every memory block needs an entry in the global) 180 323.3 P
(handle table; each such entry takes up 16 bytes. This memory overhead is) 180 310.3 T
-0.2 (insigni\336cant for a 10K code block but very signi\336cant for) 180 297.3 P
-0.2 (, for example, a 100) 438.8 297.3 P
(byte database entry) 180 284.3 T
(. Furthermore,) 270.58 284.3 T
1 9 Q
(GEOS) 341.69 284.3 T
1 10 Q
( allows a limited number of global) 367.86 284.3 T
-0.79 (handles. If an application were to use global blocks for small amounts of data,) 180 271.3 P
(it could use up too many handles.) 180 258.3 T
-0.26 (On the other hand, if an application were to store lots of small pieces of data) 180 238.3 P
(in a single global block, it might have to write elaborate) 180 225.3 T
(memory-management routines. It would have to make sure that it could) 180 212.3 T
-0.28 (resize a piece of data at will and shuf\337e other data to make room. This could) 180 199.3 P
(force programmers to spend a lot of their time writing support code.) 180 186.3 T
(For these reasons,) 180 166.3 T
1 9 Q
(GEOS) 267.23 166.3 T
1 10 Q
( provides local memory routines. Applications can) 293.4 166.3 T
-0.54 (designate a block of memory as a local-memory heap and use LMem routines) 180 153.3 P
81 144 531 648 C
235.51 643.97 376.49 648 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
235.51 643.97 376.49 648 R
7 X
0 0 0 1 0 0 0 K
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
81 144 531 648 C
36 72 576 720 C
81 410.6 171 459.42 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
1 X
0 0 0 1 0 0 0 K
90 450 13.5 13.5 101.25 435.3 G
4 H
0 Z
90 450 13.5 13.5 101.25 435.3 A
0 0 0 1 0 0 0 K
81 415.18 121.5 455.68 R
1 H
0 X
N
0 0 0 1 0 0 0 K
36 72 576 720 C
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "569" 1
%%Page: "570" 2
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
54 690.34 450 702 R
7 X
0 0 0 1 0 0 0 K
V
0 14 Q
0 X
(Local Memory) 54 692.67 T
54 666.34 450 678.01 R
7 X
V
1 10 Q
0 X
(570) 54 671.34 T
32 684 288 684 2 L
7 X
V
3 H
2 Z
0 X
N
54 90 108 125 R
7 X
V
2 60 Q
0 X
(l) 57.27 85 T
0 24 Q
(Concepts book) 102 110 T
306 99 486 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
305.67 122.67 485.67 134.83 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
54.33 533.33 75.17 545 R
V
0 8 Q
0 X
(16.2) 54.33 539.67 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
7 X
V
1 10 Q
0 X
(to request small amounts \050) 180 641.33 T
3 F
(chunks) 303.54 641.33 T
1 F
(\051 of data. The local memory library) 336.31 641.33 T
(automatically shuf\337es chunks in that heap to make room for new requests.) 180 628.33 T
(Applications can change the size of a chunk at will. The cost of using the) 180 615.33 T
(LMem routines is one added layer of indirection and a small amount of) 180 602.33 T
(memory overhead for each chunk.) 180 589.33 T
-0.4 (The LMem routines have another advantage. They provide a uniform way of) 180 569.33 P
(managing small pieces of memory) 180 556.33 T
(. This lets) 335.39 556.33 T
1 9 Q
(GEOS) 383.74 556.33 T
1 10 Q
( add functionality which) 409.91 556.33 T
-0.39 (applications can use in a variety of ways. For example,) 180 543.33 P
1 9 Q
-0.35 (GEOS) 431.53 543.33 P
1 10 Q
-0.39 ( implements an) 457.71 543.33 P
(array-management scheme based on LMem chunks; this scheme comes) 180 530.33 T
(complete with a modi\336ed Quicksort routine. Similarly) 180 517.33 T
(, all) 427.81 517.33 T
1 9 Q
(GEOS) 448.01 517.33 T
1 10 Q
( objects are) 474.18 517.33 T
(stored in object blocks, which are a special kind of local-memory heap. This) 180 504.33 T
(makes it easy to add or delete objects dynamically) 180 491.33 T
(.) 409.86 491.33 T
0 14 Q
(16.2) 134.76 439 T
0 24 Q
(Structure of a Local Memory) 180 439 T
(Heap) 180 411 T
1 10 Q
-0.49 (A local memory heap looks and acts much like the global heap. However) 180 385.33 P
-0.49 (, it is) 506.54 385.33 P
(contained entirely within a single memory block. This block is initialized) 180 372.33 T
-0.69 (with a 16-byte) 180 359.33 P
4 F
-0.71 (LMemBlockHeader) 247.03 359.33 P
1 F
-0.69 ( \050described on page 577\051, a local memory) 347.22 359.33 P
(handle table, and a local memory heap. Optionally) 180 346.33 T
(, a space for data may be) 411.91 346.33 T
(allocated between the header and the handle table.) 180 333.33 T
(Each allocated section of memory within a local heap is called a) 180 313.33 T
3 F
(chunk) 476.16 313.33 T
1 F
(, and) 504.49 313.33 T
(the handles of these chunks are called) 180 300.33 T
3 F
(chunk handles) 359.09 300.33 T
1 F
(. See Figure) 426.48 300.33 T
(16-) 484.64 300.33 T
(1 on) 499.09 300.33 T
(page) 180 287.33 T
2 F
(l) 204.45 287.33 T
1 F
(571 for an illustration of a local heap.) 215.14 287.33 T
(Chunks comprise a chunk of data preceded by a word that contains the) 180 267.33 T
(length of the data \050in bytes\051. When the heap is created, a certain number of) 180 254.33 T
(chunk handles will be allocated. If a chunk is requested after all of these) 180 241.33 T
(chunks have been given out, the local memory routines will enlarge the) 180 228.33 T
(LMem handle table, relocating chunks as necessary) 180 215.33 T
(. Unused chunks are) 417.99 215.33 T
(stored in a linked list.) 180 202.33 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "570" 2
%%Page: "571" 3
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
162 690.34 558 702 R
7 X
0 0 0 1 0 0 0 K
V
0 14 Q
0 X
(Structure of a Local Memory Heap) 330.84 692.67 T
162 666.34 558 678.01 R
7 X
V
1 10 Q
0 X
(571) 541.32 671.34 T
324 684 580 684 2 L
7 X
V
3 H
2 Z
0 X
N
504 90 558 125 R
7 X
V
2 60 Q
0 X
(l) 507.27 85 T
0 24 Q
(Concepts book) 327.65 110 T
90 99 270 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
90.67 123.5 270.67 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
536.84 533.33 557.67 545 R
V
0 8 Q
0 X
(16.2) 542.1 539.67 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
7 X
V
0 14 Q
0 X
(16.2.1) 123.08 636 T
0 18 Q
(The Local Heap) 180 636 T
1 10 Q
(An application may designate any block as a local memory heap. The block) 180 612.33 T
-0.6 (may or may not be \336xed, swapable, or discardable, as the application desires.) 180 599.33 P
(A block may have other data besides the local heap. When a local heap is) 180 579.33 T
-0.5 (created, an offset into the block can be speci\336ed. The heap will put its header) 180 566.33 P
-0.01 (structure at the beginning of the block and the handle table at the speci\336ed) 180 553.33 P
(offset; everything in between will be left untouched by the LMem routines.) 180 540.33 T
(The offset must be larger than the standard header or else may be zero,) 180 527.33 T
(indicating that the default offset should be used.) 180 514.33 T
81 144 531 648 C
180 144 531 486 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 10 Q
0 X
0 0 0 1 0 0 0 K
(Figure) 180 188.81 T
(16-) 213.34 188.81 T
(1) 227.79 188.81 T
3 F
(A Local Memory Heap) 236.13 188.81 T
-0.15 (A block on the Global Heap that has been allocated as a Local Memory heap.) 180 174.81 P
(It is partitioned into a block header) 180 162.81 T
(, a chunk of \336xed data, an LMem handle) 340.9 162.81 T
(table, and a local memory heap.) 180 150.81 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
376.58 287.22 449.08 454.22 R
0.5 H
0 Z
N
377.88 289.65 447.78 327.03 R
N
377.88 441.36 447.78 453.01 R
N
377.88 378.01 447.78 407.62 R
6 X
V
0 X
N
377.88 417.81 447.78 437.72 R
N
377.88 357.13 447.78 369.27 R
N
1 F
(Handle) 395.89 312.8 T
(T) 400.17 298.8 T
(able) 406.22 298.8 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
(Block 1) 395.79 444.64 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
(Block 2) 395.79 425.23 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
392.61 388.68 433.05 396.94 R
6 X
V
0 X
(Block 3) 395.79 390.27 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
(Block 4) 395.79 360.66 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
180.83 202.97 293.33 459.97 R
6 X
V
1 H
0 X
N
182.02 203.38 290.48 236.9 R
7 X
V
0.5 H
0 X
N
182.85 440.17 291.32 458.1 R
7 X
V
0 X
N
182.85 355.68 291.32 388.25 R
7 X
V
0 X
N
182.85 397.94 291.32 434.57 R
7 X
V
0 X
N
182.02 269.22 290.48 313.9 R
7 X
V
0 X
N
186.03 213.44 286.47 226.84 R
7 X
V
0 X
(LMemBlockHeader) 191.35 220.18 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
205.71 442.79 268.46 455.49 R
7 X
V
0 X
(Chunk 1) 217.17 448.82 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
205.71 408.66 268.46 423.85 R
7 X
V
0 X
(Chunk 3) 217.17 417.18 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
205.71 367.43 268.46 376.51 R
7 X
V
0 X
(Chunk 2) 217.17 369.84 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
204.88 276.37 267.62 306.75 R
7 X
V
0 X
(LMem) 221.25 300.08 T
(Handle T) 205.26 286.08 T
(able) 247.98 286.08 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
182.02 236.35 290.48 268.92 R
7 X
V
0 X
N
204.88 248.09 267.62 257.17 R
7 X
V
0 X
(Fixed Data) 210.5 250.51 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
447.83 407.97 293.33 459.97 2 L
7 X
V
1 H
2 Z
0 X
N
447.58 378.22 293.33 203.22 2 L
7 X
V
0 X
N
377.83 377.97 293.58 302.97 2 L
7 X
V
0 X
N
377.83 407.97 293.33 430.47 2 L
7 X
V
0 X
N
3 F
(LMem Heap) 208.85 468 T
(Global Heap) 383.95 468 T
81 144 531 648 C
36 72 576 720 C
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "571" 3
%%Page: "572" 4
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
54 690.34 450 702 R
7 X
0 0 0 1 0 0 0 K
V
0 14 Q
0 X
(Local Memory) 54 692.67 T
54 666.34 450 678.01 R
7 X
V
1 10 Q
0 X
(572) 54 671.34 T
32 684 288 684 2 L
7 X
V
3 H
2 Z
0 X
N
54 90 108 125 R
7 X
V
2 60 Q
0 X
(l) 57.27 85 T
0 24 Q
(Concepts book) 102 110 T
306 99 486 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
305.67 122.67 485.67 134.83 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
54.33 533.33 75.17 545 R
V
0 8 Q
0 X
(16.2) 54.33 539.67 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
7 X
V
1 10 Q
0 X
(Before performing any operations on a local memory heap, an application) 180 641.33 T
(must lock the heap the way it would any other block. Some local memory) 180 628.33 T
-0.02 (routines may need to resize the block; this may cause the block to be moved) 180 615.33 P
(on the global heap. Therefore, you should assume that these routines may) 180 602.33 T
(invalidate all pointers to the relevant block. The descriptions of routines) 180 589.33 T
(which may behave this way will contain a warning to that effect. When you) 180 576.33 T
-0.51 (initialize an LMem heap, you can specify that it should never be resized; this) 180 563.33 P
(is advisable if the heap is in a \336xed block.) 180 550.33 T
-0.24 (A virtual-memory \336le block may contain an LMem heap. For details on this,) 180 530.33 P
(see \322V) 180 517.33 T
(irtual Memory) 208.08 517.33 T
(,\323 Chapter) 274.19 517.33 T
(18.) 324.38 517.33 T
0 14 Q
(16.2.2) 123.08 475 T
0 18 Q
(Chunks and Chunk Handles) 180 475 T
1 10 Q
(Just as blocks on the local heap are accessed with handles, chunks are) 180 451.33 T
(accessed via chunk handles. Each chunk handle is an offset into the block) 180 438.33 T
(containing the local memory heap; thus, the segment address of the locked) 180 425.33 T
(heap, combined with the chunk handle, make up a pointer to a location) 180 412.33 T
(within the local memory heap\325) 180 399.33 T
(s chunk handle table. That location contains) 319.28 399.33 T
-0.31 (another offset which, when combined with the segment address of the block,) 180 386.33 P
-0.63 (composes a far) 180 373.33 P
-0.63 (-pointer to the actual chunk. Figure) 246.33 373.33 P
-0.63 (16-) 411.32 373.33 P
-0.63 (2 on page) 425.77 373.33 P
2 F
-0.63 (l) 471.19 373.33 P
1 F
-0.63 (573 shows) 481.88 373.33 P
(the use of a chunk handle to access a chunk.) 180 360.33 T
(Chunks are movable within the local heap; whenever a chunk is created or) 180 340.33 T
-0.85 (resized, the local memory manager may move any chunks in that heap. There) 180 327.33 P
(is no locking mechanism for chunks; thus, creating or resizing a chunk can) 180 314.33 T
-0.81 (potentially invalidate pointers to all the other chunks, forcing the application) 180 301.33 P
(to again dereference the handles for these chunks. Be warned that many) 180 288.33 T
-0.18 (message handlers can cause heap compaction. As a general rule, you should) 180 275.33 P
(not save chunk addresses around message sends; instead, dereference the) 180 262.33 T
(chunk handles to get the current address.) 180 249.33 T
(Chunks are aligned along dwords. This speeds up chunk moves and similar) 180 229.33 T
(operations. This means that when you request a chunk, its size may be) 180 216.33 T
(slightly larger than you request.) 180 203.33 T
(Objects are special kinds of LMem chunks. An optr is simply the global) 180 183.33 T
-0.26 (memory handle of an LMem heap followed by the chunk handle of an object.) 180 170.33 P
(For this reason, many LMem routines come in two formats: one which is) 180 157.33 T
81 215.97 171 346.45 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 9 Q
0 X
0 0 0 1 0 0 0 K
(Chunk Addresses) 81 293.45 T
(Are V) 81 282.45 T
(olatile) 103.84 282.45 T
1 F
(Adding or resizing a) 81 266.45 T
(chunk or sending a) 81 255.45 T
(message can change) 81 244.45 T
(all chunk addresses) 81 233.45 T
(in an LMem heap.) 81 222.45 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
1 X
90 450 13.5 13.5 101.25 322.33 G
4 H
0 Z
90 450 13.5 13.5 101.25 322.33 A
0 0 0 1 0 0 0 K
81 302.21 121.5 342.71 R
1 H
0 X
N
0 0 0 1 0 0 0 K
36 72 576 720 C
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "572" 4
%%Page: "573" 5
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
162 690.34 558 702 R
7 X
0 0 0 1 0 0 0 K
V
0 14 Q
0 X
(Structure of a Local Memory Heap) 330.84 692.67 T
162 666.34 558 678.01 R
7 X
V
1 10 Q
0 X
(573) 541.32 671.34 T
324 684 580 684 2 L
7 X
V
3 H
2 Z
0 X
N
504 90 558 125 R
7 X
V
2 60 Q
0 X
(l) 507.27 85 T
0 24 Q
(Concepts book) 327.65 110 T
90 99 270 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
90.67 123.5 270.67 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
536.84 533.33 557.67 545 R
V
0 8 Q
0 X
(16.2) 542.1 539.67 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
7 X
V
1 10 Q
0 X
-0.53 (passed an optr) 180 641.33 P
-0.53 (, and one which is passed the global and chunk handles. There) 245.8 641.33 P
(is also a macro,) 180 628.33 T
4 F
(ConstructOptr\050\051) 253.91 628.33 T
1 F
(, which is passed a memory handle and a) 338 628.33 T
(chunk handle and returns an optr constructed from the two.) 180 615.33 T
0 14 Q
(16.2.3) 123.08 268.01 T
0 18 Q
(T) 180 268.01 T
(ypes of LMem Heaps) 189.67 268.01 T
5 10 Q
(LMemType, LMemFlags) 180 244.34 T
1 F
(In addition to being used for general memory needs, local memory heaps) 180 224.34 T
(perform many speci\336c functions in the) 180 211.34 T
1 9 Q
(GEOS) 359.99 211.34 T
1 10 Q
( system. When an LMem heap) 386.16 211.34 T
(is created, a member of the) 180 198.34 T
4 F
(LMemT) 307.98 198.34 T
(ype) 347.08 198.34 T
1 F
( enumerated type is passed,) 365.6 198.34 T
(indicating to what use the LMem heap will be put. Several types are) 180 185.34 T
(available:) 180 172.34 T
81 144 531 648 C
180 307.01 531 612 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 10 Q
0 X
0 0 0 1 0 0 0 K
(Figure) 180 363.65 T
(16-) 213.34 363.65 T
(2) 227.79 363.65 T
3 F
(Referencing a Chunk) 236.13 363.65 T
-0.06 (A chunk handle consists of an offset into the block containing the local heap;) 180 349.65 P
-0.61 (this offset indicates an entry in the local memory handle table, where an offset) 180 337.65 P
-0.21 (to the chunk data is stored. In this case, the block containing the LMem heap) 180 325.65 P
(begins at address 1000:00. All addresses shown are in hexadecimal.) 180 313.65 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
336.56 379.39 448.56 605.02 R
6 X
V
1 H
0 Z
0 X
N
338.08 544.37 446.54 583.55 R
7 X
V
0.5 H
0 X
N
338.08 392.93 446.54 461.56 R
7 X
V
0 X
N
360.94 555.84 423.69 572.09 R
7 X
V
1 F
0 X
(Chunk) 376.57 565.42 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
342.44 443.12 442.19 452.04 R
7 X
V
0 X
(LMem Handle T) 344.93 445.37 T
(able) 420.43 445.37 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
338.08 532.12 446.54 544.09 R
7 X
V
0 X
N
360.94 535.04 423.69 541.32 R
7 X
V
0 X
(Size W) 369.07 534.65 T
(ord) 400.37 534.65 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
338.83 404.6 445.79 416.57 R
7 X
V
0 X
N
370.44 407.45 414.19 413.73 R
7 X
V
0 X
(:0x0120) 374.34 407.06 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
199.19 400.61 242.94 406.89 R
7 X
V
0 X
(:0x0042) 203.09 400.22 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
182.06 398.27 260.06 409.24 R
N
182.19 412.24 259.94 418.52 R
7 X
V
0 X
(Chunk Handle) 186.99 411.86 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
327.03 407.72 338.56 404.41 327.03 401.1 327.03 404.41 4 Y
V
261.06 404.41 327.03 404.41 2 L
7 X
V
1 H
2 Z
0 X
N
326.03 547.31 337.56 544 326.03 540.69 326.03 544 4 Y
V
338.56 409.24 318.56 409.24 318.56 544 326.03 544 4 L
N
453.86 376.01 448.67 379.01 453.86 382.01 453.86 379.01 4 Y
V
474.5 379.01 453.86 379.01 2 L
N
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
3 9 Q
(0x1000:0x00) 478.67 375.45 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
453.86 401.83 448.67 404.83 453.86 407.83 453.86 404.83 4 Y
V
474.5 404.83 453.86 404.83 2 L
N
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
(0x1000:0x42) 478.67 401.28 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
453.86 541.75 448.67 544.75 453.86 547.75 453.86 544.75 4 Y
V
470.17 544.75 453.86 544.75 2 L
N
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
(0x1000:0x120) 474.5 541.2 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 C
36 72 576 720 C
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "573" 5
%%Page: "574" 6
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
54 690.34 450 702 R
7 X
0 0 0 1 0 0 0 K
V
0 14 Q
0 X
(Local Memory) 54 692.67 T
54 666.34 450 678.01 R
7 X
V
1 10 Q
0 X
(574) 54 671.34 T
32 684 288 684 2 L
7 X
V
3 H
2 Z
0 X
N
54 90 108 125 R
7 X
V
2 60 Q
0 X
(l) 57.27 85 T
0 24 Q
(Concepts book) 102 110 T
306 99 486 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
305.67 122.67 485.67 134.83 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
54.33 533.33 75.17 545 R
V
0 8 Q
0 X
(16.2) 54.33 539.67 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
7 X
V
1 9 Q
0 X
(LMEM_TYPE_GENERAL) 180 641.33 T
1 10 Q
-0.37 (The LMem heap will be used for general data storage, possibly) 243 629.33 P
(including a chunk, name, or element array) 243 617.33 T
(. When an) 439.13 617.33 T
-0.02 (application creates an LMem heap, it will almost always be of) 243 605.33 P
(type \322General\323 or \322Object.\323) 243 593.33 T
1 9 Q
(LMEM_TYPE_WINDOW) 180 574.33 T
1 10 Q
(W) 243 562.33 T
(indows are stored in memory as LMem heaps. The header) 252.44 562.33 T
(contains information about the window; each region in the) 243 550.33 T
(window is stored as a chunk. Applications will not directly) 243 538.33 T
(create W) 243 526.33 T
(indow heaps.) 283.55 526.33 T
1 9 Q
(LMEM_TYPE_OBJ_BLOCK) 180 507.33 T
1 10 Q
-0.35 (Objects are stored in object blocks, which are LMem heaps. An) 243 495.33 P
(object block has some extra header information and contains) 243 483.33 T
-0.76 (one chunk which contains only \337ags. All the objects in the block) 243 471.33 P
(are stored as chunks on the heap. Applications can directly) 243 459.33 T
(create object blocks; for more information, see \322GEOS) 243 447.33 T
(Programming,\323 Chapter) 243 435.33 T
(5.) 357.08 435.33 T
1 9 Q
(LMEM_TYPE_GST) 180 416.33 T
(A) 261.51 416.33 T
(TE) 267.52 416.33 T
1 10 Q
(A GState is an LMem heap. The GState information is in the) 243 404.33 T
-0.31 (header) 243 392.33 P
-0.31 (, and the application clip-rectangle is stored in a chunk.) 274.11 392.33 P
(Applications do not directly create GState blocks; rather) 243 380.33 T
(, they) 502.1 380.33 T
(call a GState creation routine, which creates the block. \050See) 243 368.33 T
(\322Graphics Environment,\323 Chapter) 243 356.33 T
(23.\051) 403 356.33 T
1 9 Q
(LMEM_TYPE_FONT_BLOCK) 180 337.33 T
1 10 Q
(Font blocks are stored as LMem heaps. Applications do not) 243 325.33 T
(create font blocks directly) 243 313.33 T
(.) 360.78 313.33 T
1 9 Q
(LMEM_TYPE_GSTRING) 180 294.33 T
1 10 Q
(Whenever a GString is created or loaded, a GString LMem) 243 282.33 T
(heap is created, and elements are added as chunks. The heap) 243 270.33 T
-0 (is created automatically by the GString routines; applications) 243 258.33 P
(should not create GString blocks. \050See section 23.8 of chapter) 243 246.33 T
(23.\051) 243 234.33 T
1 9 Q
(LMEM_TYPE_DB_ITEMS) 180 215.33 T
1 10 Q
(The V) 243 203.33 T
(irtual Memory mechanism provides routines to create) 270.34 203.33 T
(and manage) 243 191.33 T
3 F
(database items) 302.46 191.33 T
1 F
(, short pieces of data which are) 371.15 191.33 T
(dynamically allocated and are saved with the) 243 179.33 T
1 9 Q
(VM) 455.08 179.33 T
1 10 Q
( \336le. These) 470.07 179.33 T
(items are stored in special database LMem heaps, which are) 243 167.33 T
(created in special database blocks in the) 243 155.33 T
1 9 Q
(VM) 431.93 155.33 T
1 10 Q
( \336le. Applications) 446.92 155.33 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "574" 6
%%Page: "575" 7
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
162 690.34 558 702 R
7 X
0 0 0 1 0 0 0 K
V
0 14 Q
0 X
(Structure of a Local Memory Heap) 330.84 692.67 T
162 666.34 558 678.01 R
7 X
V
1 10 Q
0 X
(575) 541.32 671.34 T
324 684 580 684 2 L
7 X
V
3 H
2 Z
0 X
N
504 90 558 125 R
7 X
V
2 60 Q
0 X
(l) 507.27 85 T
0 24 Q
(Concepts book) 327.65 110 T
90 99 270 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
90.67 123.5 270.67 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
536.84 533.33 557.67 545 R
V
0 8 Q
0 X
(16.2) 542.1 539.67 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
7 X
V
1 10 Q
0 X
-0.64 (do not directly allocate) 243 641.33 P
1 9 Q
-0.57 (DB) 348.24 641.33 P
1 10 Q
-0.64 ( blocks; rather) 361.74 641.33 P
-0.64 (, they call) 426.22 641.33 P
1 9 Q
-0.57 (DB) 472.1 641.33 P
1 10 Q
-0.64 ( routines,) 485.6 641.33 P
(which see to it that the blocks are created. \050See \322Database) 243 629.33 T
(Library) 243 617.33 T
(,\323 Chapter) 277.08 617.33 T
(19.\051) 327.27 617.33 T
(When an LMem heap is allocated, certain \337ags are passed to indicate) 180 598.33 T
(properties the heap should have. Some of these \337ags are passed only for) 180 585.33 T
(system-created heaps. The \337ags are stored in a word-length record) 180 572.33 T
-0.18 (\050) 180 559.33 P
4 F
-0.18 (LocalMemoryFlags) 183.33 559.33 P
1 F
-0.18 (\051; the record also contains \337ags indicating the current) 282.4 559.33 P
(state of the heap. The) 180 546.33 T
4 F
(LocalMemoryFlags) 283.17 546.33 T
1 F
( are listed below:) 382.24 546.33 T
1 9 Q
(LMF_HAS_FLAGS) 180 526.33 T
1 10 Q
(Set if the block has a chunk containing only \337ags. This \337ag is) 243 514.33 T
(set for object blocks; it is usually cleared for general LMem) 243 502.33 T
(heaps.) 243 490.33 T
1 9 Q
(LMF_IN_RESOURCE) 180 471.33 T
1 10 Q
(Set if the block has just been loaded from a resource and has) 243 459.33 T
(not been changed since being loaded. This \337ag is set only for) 243 447.33 T
(object blocks created by the compiler) 243 435.33 T
(.) 411.53 435.33 T
1 9 Q
(LMF_DET) 180 416.33 T
(ACHABLE) 224.01 416.33 T
1 10 Q
-0.19 (Set if the block is an object block which can be saved to a state) 243 404.33 P
(\336le.) 243 392.33 T
1 9 Q
(LMF_DUPLICA) 180 373.33 T
(TED) 247.51 373.33 T
1 10 Q
(Set if block is an object block created by the) 243 361.33 T
4 F
-0.43 (ObjDuplicateResource\050\051) 243 349.33 P
1 F
-0.42 ( routine. This \337ag should not be set) 368.19 349.33 P
(by applications.) 243 337.33 T
1 9 Q
(LMF_RELOCA) 180 318.33 T
(TED) 243.5 318.33 T
1 10 Q
-0.76 (Set if all the objects in the block have been relocated. The object) 243 306.33 P
(system sets this when it has relocated all the objects in the) 243 294.33 T
(block.) 243 282.33 T
1 9 Q
(LMF_AUTO_FREE) 180 263.33 T
1 10 Q
(This \337ag is used by several object routines. It indicates that if) 243 251.33 T
(the block\325) 243 239.33 T
(s in-use count drops to zero, the block may be freed.) 286.53 239.33 T
(This \337ag should not be set by applications.) 243 227.33 T
1 9 Q
(LMF_IN_MEM_ALLOC) 180 208.33 T
1 10 Q
(This \337ag is used in error) 243 196.33 T
(-checking code to prevent the heap) 356.16 196.33 T
(from being validated while a chunk is being allocated. For) 243 184.33 T
(internal use only\321do not modify) 243 172.33 T
3 F
(.) 393.57 172.33 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "575" 7
%%Page: "576" 8
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
54 690.34 450 702 R
7 X
0 0 0 1 0 0 0 K
V
0 14 Q
0 X
(Local Memory) 54 692.67 T
54 666.34 450 678.01 R
7 X
V
1 10 Q
0 X
(576) 54 671.34 T
32 684 288 684 2 L
7 X
V
3 H
2 Z
0 X
N
54 90 108 125 R
7 X
V
2 60 Q
0 X
(l) 57.27 85 T
0 24 Q
(Concepts book) 102 110 T
306 99 486 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
305.67 122.67 485.67 134.83 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
54.33 533.33 75.17 545 R
V
0 8 Q
0 X
(16.2) 54.33 539.67 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
7 X
V
1 9 Q
0 X
(LMF_IS_VM) 180 641.33 T
1 10 Q
(Set if LMem heap is in a) 243 629.33 T
1 9 Q
(VM) 359.14 629.33 T
1 10 Q
( block and the block should be) 374.13 629.33 T
(marked dirty whenever a chunk is marked dirty) 243 617.33 T
(. This \337ag is) 464.5 617.33 T
(automatically set by the) 243 605.33 T
1 9 Q
(VM) 357.29 605.33 T
1 10 Q
( code when an LMem heap is) 372.28 605.33 T
(created in or attached to a) 243 593.33 T
1 9 Q
(VM) 367.09 593.33 T
1 10 Q
( \336le. This \337ag should not be set) 382.08 593.33 T
(by applications.) 243 581.33 T
1 9 Q
(LMF_NO_HANDLES) 180 562.33 T
1 10 Q
(Set if block does not use chunk handles. A block can be set to) 243 550.33 T
(simulate the C) 243 538.33 T
4 F
(malloc\050\051) 313.94 538.33 T
1 F
(routine; in this case, chunks are not) 359.04 538.33 T
-0.63 (relocated after being created, so chunk handles are not needed.) 243 526.33 P
(Ordinarily) 243 514.33 T
(, these blocks are created by the) 290.78 514.33 T
4 F
(malloc\050\051) 441.36 514.33 T
1 F
( routine,) 483.59 514.33 T
(not by applications. \050See the discussion of) 243 502.33 T
4 F
(malloc\050\051) 437.84 502.33 T
1 F
( in section) 480.07 502.33 T
(15.4 of chapter 15.\051) 243 490.33 T
1 9 Q
(LMF_NO_ENLARGE) 180 471.33 T
1 10 Q
(Indicates that the local-memory routines should not enlarge) 243 459.33 T
(this block to ful\336ll chunk requests. This guarantees that the) 243 447.33 T
-0.71 (block will not be moved by a chunk allocation request; however) 243 435.33 P
-0.71 (,) 526.15 435.33 P
(it makes these requests more likely to fail.) 243 423.33 T
1 9 Q
(LMF_RETURN_ERRORS) 180 404.33 T
1 10 Q
(Set if local memory routines should return errors when) 243 392.33 T
(allocation requests cannot be ful\336lled. If the \337ag is not set,) 243 380.33 T
(allocation routines will fatal-error if they cannot comply with) 243 368.33 T
(requests. This \337ag is generally clear for expandable LMem) 243 356.33 T
-0.94 (blocks, since many system routines \050such as) 243 344.33 P
4 F
-0.98 (ObjInstantiate\050\051) 442.14 344.33 P
1 F
-0.94 (\051) 525.84 344.33 P
-0.16 (are optimized in such a way that they cannot deal with LMem) 243 332.33 P
(allocation errors.) 243 320.33 T
1 9 Q
(LMF_DEA) 180 301.33 T
(TH_COUNT) 224.51 301.33 T
1 10 Q
(This \336eld occupies the least signi\336cant three bits of the \337ag) 243 289.33 T
(\336eld. It means nothing if the value is zero. If it is non-zero, it) 243 277.33 T
(indicates the number of remove-block messages left which) 243 265.33 T
(must hit) 243 253.33 T
4 F
(BlockDeathCommon) 285.23 253.33 T
1 F
( before it will free the block.) 392.27 253.33 T
(This \337ag is used by the handlers for) 243 241.33 T
1 9 Q
(MSG_FREE_DUPLICA) 411.54 241.33 T
(TE) 509.71 241.33 T
1 10 Q
(and) 243 229.33 T
1 9 Q
(MSG_REMOVE_BLOCK) 263.19 229.33 T
1 10 Q
(.) 367.85 229.33 T
1 9 Q
(STD_LMEM_OBJ_FLAGS) 180 210.33 T
1 10 Q
(This is a constant which combines the) 243 198.33 T
1 9 Q
(LMF_HAS_FLAGS) 421.36 198.33 T
1 10 Q
( and) 501.7 198.33 T
1 9 Q
-0.24 (LMF_RELOCA) 243 186.33 P
-0.24 (TED) 306.5 186.33 P
1 10 Q
-0.26 ( \337ags. These \337ags should be set for all object) 326.01 186.33 P
(blocks.) 243 174.33 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "576" 8
%%Page: "577" 9
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
162 690.34 558 702 R
7 X
0 0 0 1 0 0 0 K
V
0 14 Q
0 X
(Using Local Memory Heaps) 375.17 692.67 T
162 666.34 558 678.01 R
7 X
V
1 10 Q
0 X
(577) 541.32 671.34 T
324 684 580 684 2 L
7 X
V
3 H
2 Z
0 X
N
504 90 558 125 R
7 X
V
2 60 Q
0 X
(l) 507.27 85 T
0 24 Q
(Concepts book) 327.65 110 T
90 99 270 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
90.67 123.5 270.67 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
536.84 533.33 557.67 545 R
V
0 8 Q
0 X
(16.3) 542.1 539.67 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
7 X
V
0 14 Q
0 X
(16.3) 134.76 632 T
0 24 Q
(Using Local Memory Heaps) 180 632 T
1 10 Q
-0.5 (Local memory heaps are much like the global heap and are accessed in much) 180 606.33 P
(the same way) 180 593.33 T
(. Local heaps are simple to create and manage.) 242.24 593.33 T
-0.56 (Many applications will not need to use local heaps directly; instead, they will) 180 573.33 P
(use more advanced data-management mechanisms based on local heaps,) 180 560.33 T
(such as chunk arrays or database blocks. However) 180 547.33 T
(, even if you use these) 412.25 547.33 T
(mechanisms, you should be familiar with this section; this will help you) 180 534.33 T
(understand how the other mechanisms work.) 180 521.33 T
(Remember that every local memory heap resides in a global memory block.) 180 501.33 T
-0.82 (All the rules for using memory blocks apply) 180 488.33 P
-0.82 (. \050See \322Memory Etiquette\323 on page) 374.44 488.33 P
(552.\051) 180 475.33 T
0 14 Q
(16.3.1) 123.08 433 T
0 18 Q
(Creating a Local Heap) 180 433 T
5 10 Q
(LMemInitHeap\050\051, MemAllocLMem\050\051) 180 409.33 T
1 F
-0.43 (Before you create a local heap, you must \336rst allocate and lock a block on the) 180 389.33 P
(global heap using) 180 376.33 T
4 F
(MemAlloc\050\051) 263.91 376.33 T
1 F
( and) 323.17 376.33 T
4 F
(MemLock\050\051) 346.14 376.33 T
1 F
(. \050Alternatively) 404.66 376.33 T
(, you can) 473.74 376.33 T
(allocate a \336xed block.\051 Then, you must call) 180 363.33 T
4 F
(LMemInitHeap\050\051) 378.93 363.33 T
1 F
(.) 465.58 363.33 T
4 F
(LMemInitHeap\050\051) 180 343.33 T
1 F
( creates and initializes a local memory heap. It must be) 266.65 343.33 T
(passed several arguments:) 180 330.33 T
2 F
(u) 180 310.33 T
1 F
-0.52 (The handle of a locked or \336xed block which will contain the local memory) 198 310.33 P
(heap. It may be moveable, discardable, both, or neither; it should) 198 298.33 T
3 F
(not) 501.21 298.33 T
1 F
-0.68 (have the \337ag) 198 286.33 P
1 9 Q
-0.61 (HF_LMEM) 258.37 286.33 P
1 10 Q
-0.68 ( set. If the LMem heap will be resizable, the block) 305.87 286.33 P
-0.19 (may be of any size; the LMem routines will enlarge it if necessary) 198 274.33 P
-0.19 (. If the) 498.04 274.33 P
-0.03 (heap will not be resizable \050i.e.) 198 262.33 P
1 9 Q
-0.03 (LMF_NO_ENLARGE) 338.03 262.33 P
1 10 Q
-0.03 ( is passed\051, it must be) 428.2 262.33 P
(created large enough to accommodate the heap.) 198 250.33 T
2 F
(u) 180 231.33 T
1 F
-0.67 (The offset within the block where the local heap\325) 198 231.33 P
-0.67 (s handle table will begin.) 415.8 231.33 P
-0.63 (The local heap will \336ll the space to the end of the block; any data between) 198 219.33 P
-0.84 (the) 198 207.33 P
4 F
-0.87 (LMemBlockHeader) 214.94 207.33 P
1 F
-0.84 ( and the indicated offset will be zero-initialized.) 315.13 207.33 P
(If an application will not need a \336xed data space, it should specify an) 198 195.33 T
(offset of zero; the handle table will then be put immediately after the) 198 183.33 T
4 F
(LMemBlockHeader) 198 171.33 T
1 F
(. Often, when an application needs a \336xed data) 297.45 171.33 T
(space, it will de\336ne a special structure, the \336rst element of which is an) 198 159.33 T
4 F
(LMemBlockHeader) 198 147.33 T
1 F
(, and will pass the size of that structure as the) 297.45 147.33 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "577" 9
%%Page: "578" 10
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
54 690.34 450 702 R
7 X
0 0 0 1 0 0 0 K
V
0 14 Q
0 X
(Local Memory) 54 692.67 T
54 666.34 450 678.01 R
7 X
V
1 10 Q
0 X
(578) 54 671.34 T
32 684 288 684 2 L
7 X
V
3 H
2 Z
0 X
N
54 90 108 125 R
7 X
V
2 60 Q
0 X
(l) 57.27 85 T
0 24 Q
(Concepts book) 102 110 T
306 99 486 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
305.67 122.67 485.67 134.83 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
54.33 533.33 75.17 545 R
V
0 8 Q
0 X
(16.3) 54.33 539.67 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
7 X
V
1 10 Q
0 X
(offset. It can then access the \336xed data by using the \336elds of the) 198 641.33 T
-0.29 (structure. If the offset speci\336ed is non-zero but is less than the size of an) 198 629.33 P
4 F
(LMemBlockHeader) 198 617.33 T
1 F
(,) 297.45 617.33 T
4 F
(LMemInitHeap\050\051) 303.01 617.33 T
1 F
( will return an error) 389.66 617.33 T
(.) 482.25 617.33 T
2 F
(u) 180 598.33 T
1 F
(A member of the) 198 598.33 T
4 F
(LMemT) 277.45 598.33 T
(ype) 316.55 598.33 T
1 F
( enumerated type, specifying the type of) 335.07 598.33 T
(block to be created \050see page 573\051.) 198 586.33 T
2 F
(u) 180 567.33 T
1 F
(A word of) 198 567.33 T
4 F
(LocalMemoryFlags) 244.85 567.33 T
1 F
( for the heap. \050See page 575.\051) 343.92 567.33 T
2 F
(u) 180 548.33 T
1 F
-0.01 (A word specifying the number of chunk handles to leave room for in the) 198 548.33 P
(starter handle table. When these chunks have all been allocated, the) 198 536.33 T
(local memory manager will expand the LMem handle table to create) 198 524.33 T
(more chunk handles. No matter how big the starter handle table is, the) 198 512.33 T
(heap will initially contain just one chunk \050whose size is speci\336ed by the) 198 500.33 T
(next argument\051. Applications should generally pass the constant) 198 488.33 T
1 9 Q
(STD_LMEM_INIT_HANDLES) 198 476.33 T
1 10 Q
(.) 326.83 476.33 T
2 F
(u) 180 457.33 T
1 F
(A word specifying the amount of space to be assigned to the chunk) 198 457.33 T
(created when the heap is initialized. When more space is needed, the) 198 445.33 T
(chunks will expand to the end of the block, and \050if necessary\051 the block) 198 433.33 T
(itself will be expanded. Applications should generally pass the constant) 198 421.33 T
1 9 Q
(STD_LMEM_INIT_HEAP) 198 409.33 T
1 10 Q
(.) 305.54 409.33 T
4 F
(LMemInitHeap\050\051) 180 390.33 T
1 F
( creates the) 266.65 390.33 T
4 F
(LMemBlockHeader) 322.95 390.33 T
1 F
( and the chunk handle) 423.14 390.33 T
-0.06 (table. It also creates a single free chunk; more chunks will automatically be) 180 377.33 P
(created as needed. It may resize the block passed \050unless the \337ag) 180 364.33 T
1 9 Q
(LMF_NO_ENLARGE) 180 351.33 T
1 10 Q
( is passed\051; therefore, any pointers to the block may) 270.17 351.33 T
(become invalid. It does not return anything.) 180 338.33 T
(If you want to create a memory block and initialize it as an LMem heap in) 180 318.33 T
-0.47 (one operation, call) 180 305.33 P
4 F
-0.48 ( MemAllocLMem\050\051) 263.7 305.33 P
1 F
-0.47 (. This routine takes two arguments: a) 357.75 305.33 P
(member of the) 180 292.33 T
4 F
(LMemT) 249.45 292.33 T
(ype) 288.55 292.33 T
1 F
( enumerated type, and the amount of space to) 307.07 292.33 T
-0.3 (leave for the header \050again, a zero size indicates that the default header size) 180 279.33 P
-0.09 (should be used\051.) 180 266.33 P
4 F
-0.09 (MemAllocLMem\050\051) 256.95 266.33 P
1 F
-0.09 ( allocates a movable, swapable block in) 348.61 266.33 P
(the global heap, then initializes an LMem heap in that block. If you specify) 180 253.33 T
(an) 180 240.33 T
4 F
(LMemT) 194.45 240.33 T
(ype) 233.55 240.33 T
1 F
( of) 252.07 240.33 T
1 9 Q
(LMEM_TYPE_OBJ_BLOCK,) 265.96 240.33 T
4 10 Q
(MemAllocLMem\050\051) 390.3 240.33 T
1 F
( will pass) 481.96 240.33 T
(the) 180 227.33 T
1 9 Q
(STD_LMEM_OBJECT_FLAGS) 197.78 227.33 T
1 10 Q
( \337ags; otherwise, it will pass a clear) 328.13 227.33 T
4 F
(LocalMemoryFlags) 180 214.33 T
1 F
( record.) 279.07 214.33 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "578" 10
%%Page: "579" 11
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
162 690.34 558 702 R
7 X
0 0 0 1 0 0 0 K
V
0 14 Q
0 X
(Using Local Memory Heaps) 375.17 692.67 T
162 666.34 558 678.01 R
7 X
V
1 10 Q
0 X
(579) 541.32 671.34 T
324 684 580 684 2 L
7 X
V
3 H
2 Z
0 X
N
504 90 558 125 R
7 X
V
2 60 Q
0 X
(l) 507.27 85 T
0 24 Q
(Concepts book) 327.65 110 T
90 99 270 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
90.67 123.5 270.67 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
536.84 533.33 557.67 545 R
V
0 8 Q
0 X
(16.3) 542.1 539.67 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
7 X
V
0 14 Q
0 X
(16.3.2) 123.08 636 T
0 18 Q
(Using Chunks) 180 636 T
5 10 Q
(LMemAlloc\050\051, LMemDeref\050\051, LMemFree\050\051, LMemGetChunkSize\050\051,) 180 612.33 T
(LMemReAlloc\050\051, LMemInsertAt\050\051, LMemDeleteAt\050\051,) 180 599.33 T
(LMemDerefHandles\050\051, LMemFreeHandles\050\051,) 180 586.33 T
(LMemGetChunkSizeHandles\050\051, LMemReAllocHandles\050\051,) 180 573.33 T
(LMemInsertAtHandles\050\051, LMemDeleteAtHandles\050\051) 180 560.33 T
1 F
-0.45 (Once a local heap has been initialized, you can allocate, use, and free chunks) 180 540.33 P
(at will. Chunks can only be manipulated while the block containing the) 180 527.33 T
(LMem heap is \336xed or locked on the global heap.) 180 514.33 T
4 F
(LMemAlloc\050\051) 180 494.33 T
1 F
( allocates a new chunk on the local heap. It is passed the) 246.48 494.33 T
(handle of the block containing the heap and the size of the chunk needed.) 180 481.33 T
4 F
(LMemAlloc\050\051) 180 468.33 T
1 F
( returns the handle of the new chunk \050which must then be) 246.48 468.33 T
(dereferenced before the chunk is used\051. The size requested will be rounded) 180 455.33 T
-0.15 (up as necessary to ensure that the chunks are dword-aligned. An additional) 180 442.33 P
(two bytes will be allocated to store the size of the chunk; these bytes will be) 180 429.33 T
(before the data. This routine may compact the chunks on the local heap, so) 180 416.33 T
-0.7 (all pointers to that heap will be invalidated; they will have to be dereferenced) 180 403.33 P
(by their chunk handles. Furthermore, the block itself may be moved \050if) 180 390.33 T
1 9 Q
-0.1 (LMF_NO_ENLARGE) 180 377.33 P
1 10 Q
-0.11 ( is not set\051. Even \336xed blocks may be moved if they need) 270.17 377.33 P
(to expand to accommodate new chunks.) 180 364.33 T
(All of the following routines come in two forms. As noted, an optr is simply) 180 344.33 T
-0.18 (the handle of an object block, followed by the object\325) 180 331.33 P
-0.18 (s chunk handle. For this) 416.35 331.33 P
(reason, most LMem routines come in two slightly different formats: one) 180 318.33 T
-0.1 (where the chunk is speci\336ed with an optr) 180 305.33 P
-0.1 (, and one where it is speci\336ed with) 369.34 305.33 P
(the two handles. In all other ways, the two versions of each routine are) 180 292.33 T
(identical. Indeed, in assembly there is only a single version of each routine;) 180 279.33 T
(the only difference is in how the C routines take their parameters.) 180 266.33 T
-0.03 (Once you have allocated a chunk, you must dereference its chunk handle in) 180 246.33 P
(order to use it. Y) 180 233.33 T
(ou can do this with) 256.12 233.33 T
4 F
(LMemDeref\050\051) 346.69 233.33 T
1 F
(. This routine takes a) 415.76 233.33 T
-0.05 (singe parameter) 180 220.33 P
-0.05 (, namely the optr) 254.77 220.33 P
-0.05 (. It returns a pointer to the data portion of) 333.15 220.33 P
-0.54 (the chunk \050after the size word\051. This pointer will remain valid until the block) 180 207.33 P
-0.53 (is unlocked or until a routine is called which can cause block resizing or heap) 180 194.33 P
(compaction \050e.g.) 180 181.33 T
4 F
(LMemAlloc\050\051) 257.04 181.33 T
1 F
(\051. Since these routines can invalidate) 323.52 181.33 T
-0.53 (chunk-pointers, it is important that data-synchronization routines be used if) 180 168.33 P
-0.65 (more than one thread is accessing the heap; otherwise, one thread may cause) 180 155.33 P
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "579" 11
%%Page: "580" 12
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
54 690.34 450 702 R
7 X
0 0 0 1 0 0 0 K
V
0 14 Q
0 X
(Local Memory) 54 692.67 T
54 666.34 450 678.01 R
7 X
V
1 10 Q
0 X
(580) 54 671.34 T
32 684 288 684 2 L
7 X
V
3 H
2 Z
0 X
N
54 90 108 125 R
7 X
V
2 60 Q
0 X
(l) 57.27 85 T
0 24 Q
(Concepts book) 102 110 T
306 99 486 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
305.67 122.67 485.67 134.83 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
54.33 533.33 75.17 545 R
V
0 8 Q
0 X
(16.3) 54.33 539.67 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
7 X
V
1 10 Q
0 X
(the heap to be shuf\337ed while another thread is trying to read from it. The) 180 641.33 T
(version which takes handles is named) 180 628.33 T
4 F
(LMemDerefHandles\050\051) 358.36 628.33 T
1 F
(.) 470.02 628.33 T
(When you are done using a chunk of memory) 180 608.33 T
(, you should free it with) 387.04 608.33 T
4 F
-0.29 (LMemFree\050\051) 180 595.33 P
1 F
-0.28 (. This routine is passed an optr; it does not return anything. It) 244.07 595.33 P
(does not resize the block or shuf\337e chunks; therefore, pointers to other) 180 582.33 T
(chunks will not be invalidated by) 180 569.33 T
4 F
(LMemFree\050\051) 336.15 569.33 T
1 F
(. The version which takes) 400.22 569.33 T
(handles is named) 180 556.33 T
4 F
(LMemFreeHandles\050\051) 263.72 556.33 T
1 F
(.) 370.38 556.33 T
(Y) 180 536.33 T
(ou can \336nd out the size of any chunk by calling the routine) 185.93 536.33 T
4 F
(LMemGetChunkSize\050\051) 180 523.33 T
1 F
(. This routine is passed an optr; it returns the size) 294.99 523.33 T
-0.56 (of the chunk in bytes \050not counting the chunk\325) 180 510.33 P
-0.56 (s size word\051. The version which) 387.35 510.33 P
(takes handles is named) 180 497.33 T
4 F
(LMemGetChunkSizeHandles\050\051) 291.51 497.33 T
1 F
(.) 449.09 497.33 T
-0.38 (Chunks can be resized after creation. The Boolean routine) 180 477.33 P
4 F
-0.4 (LMemReAlloc\050\051) 448.23 477.33 P
1 F
(takes two arguments, namely an optr and the new size of the chunk. If the) 180 464.33 T
(new size is larger than the old one, bytes will be added to the end of the) 180 451.33 T
-0.14 (chunk; chunks may be shuf\337ed and the block may be resized, so all pointers) 180 438.33 P
-0.83 (to chunks will be invalidated. The new bytes will not be zero-initialized. If the) 180 425.33 P
(new chunk size is smaller than the old one, the chunk will be truncated;) 180 412.33 T
(pointers to chunks will not be invalidated. This routine will fail only if the) 180 399.33 T
(LMem heap ran out of space and could not be resized. In this case, it will) 180 386.33 T
(return non-zero without changing the chunk. If it succeeds, it returns zero.) 180 373.33 T
(The version which takes handles is called) 180 360.33 T
4 F
(LMemReAllocHandles\050\051) 374.66 360.33 T
1 F
(.) 497.62 360.33 T
(Y) 180 340.33 T
(ou can add bytes inside a chunk with the Boolean routine) 185.93 340.33 T
4 F
(LMemInsertAt\050\051) 180 327.33 T
1 F
(. This routine takes three arguments: the optr) 263.51 327.33 T
(, an offset) 475.57 327.33 T
(within the chunk, and the number of bytes to add. The new space is added) 180 314.33 T
(beginning at the speci\336ed offset; it is initialized to zeros. This may cause) 180 301.33 T
-0.58 (chunks to be shuf\337ed and/or the block to be expanded; pointers to chunks are) 180 288.33 P
(therefore invalidated. Note that it is your responsibility to make sure that) 180 275.33 T
(the offset within the chunk really is in the chunk; otherwise, results are) 180 262.33 T
(unde\336ned. If) 180 249.33 T
4 F
(LMemInsertAt\050\051) 241.66 249.33 T
1 F
( fails \050because the LMem heap ran out of) 325.17 249.33 T
-0.01 (space and could not be expanded\051, it returns non-zero without changing the) 180 236.33 P
-0.17 (chunk; otherwise it returns zero. The version which takes handles is named) 180 223.33 P
4 F
(LMemInsertAtHandles\050\051) 180 210.33 T
1 F
(.) 306.1 210.33 T
(Y) 180 190.33 T
(ou can delete bytes within a chunk with the routine) 185.93 190.33 T
4 F
(LMemDeleteAt\050\051) 427.26 190.33 T
1 F
(.) 512.62 190.33 T
-0.01 (This routine takes three arguments: the optr) 180 177.33 P
-0.01 (, the offset within the chunk of) 386.43 177.33 P
(the \336rst byte to be deleted, and the number of bytes to delete. This routine) 180 164.33 T
-0.72 (does not invalidate pointers to chunks. The routine does not return anything.) 180 151.33 P
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "580" 12
%%Page: "581" 13
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
162 690.34 558 702 R
7 X
0 0 0 1 0 0 0 K
V
0 14 Q
0 X
(Using Local Memory Heaps) 375.17 692.67 T
162 666.34 558 678.01 R
7 X
V
1 10 Q
0 X
(581) 541.32 671.34 T
324 684 580 684 2 L
7 X
V
3 H
2 Z
0 X
N
504 90 558 125 R
7 X
V
2 60 Q
0 X
(l) 507.27 85 T
0 24 Q
(Concepts book) 327.65 110 T
90 99 270 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
90.67 123.5 270.67 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
536.84 533.33 557.67 545 R
V
0 8 Q
0 X
(16.3) 542.1 539.67 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
7 X
V
1 10 Q
0 X
-0.74 (Note that it is your responsibility to make sure that all the bytes to be deleted) 180 641.33 P
(are within the chunk, i.e. that the offset and number of bytes passed do not) 180 628.33 T
(specify bytes that are beyond the end of the chunk. If you fail to do this,) 180 615.33 T
(results are unde\336ned. The version which takes handles is named) 180 602.33 T
4 F
(LMemDeleteAtHandles\050\051) 180 589.33 T
1 F
(.) 307.95 589.33 T
0 14 Q
(16.3.3) 123.08 547 T
0 18 Q
(Contracting the LMem Heap) 180 547 T
5 10 Q
(LMemContract\050\051) 180 523.33 T
1 F
-0.65 (The local memory manager routines ordinarily take care of heap compaction.) 180 503.33 P
(However) 180 490.33 T
(, you can also order compaction at will.) 220.18 490.33 T
(The routine) 180 470.33 T
4 F
(LMemContract\050\051) 237.04 470.33 T
1 F
( compacts the heap and then frees all the) 323.34 470.33 T
(unused heap space \050by truncating the block with the LMem heap\051. The) 180 457.33 T
-0.3 (routine takes one argument, namely the handle of the \050locked or \336xed\051 block) 180 444.33 P
(containing the LMem heap. It shuf\337es all the chunks, thus invalidating) 180 431.33 T
(pointers to chunks; however) 180 418.33 T
(, it is guaranteed not to move the block on the) 309.26 418.33 T
(global heap.) 180 405.33 T
0 14 Q
(16.3.4) 123.08 363 T
0 18 Q
(Example of LMem Usage) 180 363 T
1 10 Q
(At \336rst, the local memory techniques can seem tricky) 180 339.33 T
(. This section contains) 424.83 339.33 T
(an example of LMem usage in Goc. The example shows the basic principles) 180 326.33 T
(of LMem usage.) 180 313.33 T
81 280.98 531 293 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 280.98 531 293 R
7 X
0 0 0 1 0 0 0 K
V
76.5 288.23 617.5 291.73 R
4 X
V
0.5 H
0 Z
N
36 72 576 720 C
0 10 Q
0 X
0 0 0 1 0 0 0 K
(Code Display) 81 274.31 T
(16-) 147.13 274.31 T
(1 LMem Usage in GOC) 161.58 274.31 T
5 9 Q
(/*) 81 259.98 T
( * Declarations) 81 248.98 T
( */) 81 237.98 T
(/* We\325ll want to have a fixed data area at the start of the block. That area will) 81 219.98 T
( * have to start with an LMemBlockHeader, but after that, we can put whatever we) 81 208.98 T
( * want. To make it easy to access the fixed data, we define a structure.) 81 197.98 T
( */) 81 186.98 T
(typedef struct {) 81 175.98 T
(LMemBlockHeader) 125 164.98 T
(MLMBH_standardHeader;) 212.5 164.98 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "581" 13
%%Page: "582" 14
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
54 690.34 450 702 R
7 X
0 0 0 1 0 0 0 K
V
0 14 Q
0 X
(Local Memory) 54 692.67 T
54 666.34 450 678.01 R
7 X
V
1 10 Q
0 X
(582) 54 671.34 T
32 684 288 684 2 L
7 X
V
3 H
2 Z
0 X
N
54 90 108 125 R
7 X
V
2 60 Q
0 X
(l) 57.27 85 T
0 24 Q
(Concepts book) 102 110 T
306 99 486 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
305.67 122.67 485.67 134.83 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
54.33 533.33 75.17 545 R
V
0 8 Q
0 X
(16.3) 54.33 539.67 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
7 X
V
5 9 Q
0 X
(float) 125 642 T
(MLMBH_someData;) 212.5 642 T
(float) 125 631 T
(MLMBH_someMoreData;) 212.5 631 T
(char) 125 620 T
(MLMBH_someChars[10];) 212.5 620 T
(} MyLMemBlockHeader;) 81 609 T
(MyLMemBlockHeader) 81 591 T
(*thisHeapsHeader;) 212.5 591 T
(MemHandle) 81 580 T
(thisHeapsHandle;) 212.5 580 T
(ChunkHandle) 81 569 T
(firstChH, secondChH;) 212.5 569 T
(char) 81 558 T
(*firstChPtr, *secondChPtr;) 212.5 558 T
(int) 81 547 T
(i;) 212.5 547 T
(/*) 81 529 T
( * Code) 81 518 T
( */) 81 507 T
(/* We have to create the LMem heap. First, we create the block: */) 81 489 T
(thisHeapsHandle = MemAlloc\050) 81 478 T
(/* MemAlloc returns the block handle */) 301 478 T
(2048,) 212.5 467 T
(/* Allocate 2K; can grow as necessary */) 301 467 T
(HF_SWAPABLE,) 212.5 456 T
(/* Make block swapable. LMemInitHeap\050\051) 301 456 T
( * will add the flag HF_LMEM. */) 301 445 T
(HAF_ZERO_INIT | HAF_LOCK\051;) 212.5 434 T
(/* Zero & lock the block) 388 434 T
( * upon allocation */) 388 423 T
(LMemInitHeap\050thisHeapsHandle,) 81 405 T
(/* Pass handle of locked block */) 301 405 T
(LMEM_TYPE_GENERAL,) 168.98 394 T
(/* Allocate a general heap */) 301 394 T
(0,) 168.98 383 T
(/* Don\325t pass any flags */) 301 383 T
(sizeof\050MyLMemBlockHeader\051,) 168.98 372 T
(/* Offset to leave room for header */) 314.78 372 T
(STD_INIT_HANDLES,) 168.98 361 T
(/* Standard # of starter handles */) 301 361 T
(STD_INIT_HEAP\051;) 168.98 350 T
(/* Allocate standard amt. of empty heap */) 256.5 350 T
(/* The block is still locked; we can initialize the fixed data section. */) 81 332 T
(thisHeapsHeader = \050MyLMemBlockHeader *\051 MemDeref\050thisHeapsHandle\051;) 81 321 T
(thisHeapsHeader->MLMBH_someData = 3.1415926;) 81 310 T
(/* Now, we allocate some chunks. This invalidates pointers to this heap \050such as) 81 292 T
( * thisHeapsHeader\051, since chunk allocation may cause the heap to be resized \050and) 81 281 T
( * thus moved\051. The block must be locked when we do this.) 81 270 T
( */) 81 259 T
(firstChH = LMemAlloc\050) 81 248 T
(/* LMemAlloc returns a chunk handle */) 301 248 T
(thisHeapsHandle,) 168.98 237 T
(/* Pass handle of block . . . */) 301 237 T
(100\051;) 168.98 226 T
(/* . . . and number of bytes in chunk */) 301 226 T
(secondChH = LMemAlloc\050thisHeapsHandle, 50\051;) 81 208 T
(/* Now, we start writing data to a chunk: */) 81 190 T
(firstChPtr = \050char *\051 LMemDerefHandles\050thisHeapsHandle, firstChH\051;) 81 179 T
(for\050i = 0; i <= 30; i++\051) 81 168 T
(firstChPtr[i] = 'x';) 97.2 157 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "582" 14
%%Page: "583" 15
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
162 690.34 558 702 R
7 X
0 0 0 1 0 0 0 K
V
0 14 Q
0 X
(Special LMem Uses) 427.28 692.67 T
162 666.34 558 678.01 R
7 X
V
1 10 Q
0 X
(583) 541.32 671.34 T
324 684 580 684 2 L
7 X
V
3 H
2 Z
0 X
N
504 90 558 125 R
7 X
V
2 60 Q
0 X
(l) 507.27 85 T
0 24 Q
(Concepts book) 327.65 110 T
90 99 270 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
90.67 123.5 270.67 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
536.84 533.33 557.67 545 R
V
0 8 Q
0 X
(16.4) 542.1 539.67 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
7 X
V
5 9 Q
0 X
(/* We can insert 10 bytes into the middle of the second chunk. This may cause the) 81 642 T
( * chunks or blocks to be shuffled; all pointers are invalidated) 81 631 T
( */) 81 620 T
(LMemInsertAtHandles\050thisHeapsHandle, secondChH,) 81 609 T
(/* Block & chunk handles */) 344 609 T
(20,) 168.98 598 T
(/* Insert after 20th byte */) 344 598 T
(30\051;) 168.98 587 T
(/* Insert 30 null bytes */) 344 587 T
(/* If we want to access the first chunk, we need to dereference its handle again:) 81 569 T
( */) 81 558 T
(firstChPtr = \050char *\051 LMemDeref\050thisHeapsHandle, firstChH\051;) 81 547 T
(for\050i = 1; i <= 15; i++\051) 81 536 T
(firstChPtr[\050i<<1\051] = 'o';) 102.6 525 T
(/* When we\325re done with a chunk, we should free it. This does not invalidate) 81 507 T
( * any pointers to other chunks.) 81 496 T
( */) 81 485 T
(LMemFreeHandles\050thisHeapsHandle, firstChH\051;) 81 474 T
(/* If we won\325t be using an LMem heap for a while, we should unlock it the way we) 81 456 T
( * would any block: */) 81 445 T
(MemUnlock\050thisHeapsHandle\051;) 81 434 T
(/* When we\325re done with the LMem heap, we can just free it. */) 81 416 T
(MemFree\050thisHeapsHandle\051;) 81 405 T
81 380.98 531 393 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 380.98 531 393 R
7 X
0 0 0 1 0 0 0 K
V
76.5 388.23 617.5 391.73 R
4 X
V
0.5 H
0 Z
N
36 72 576 720 C
0 14 Q
0 X
0 0 0 1 0 0 0 K
(16.4) 134.76 330.98 T
0 24 Q
(Special LMem Uses) 180 330.98 T
1 10 Q
-0.56 (Local memory heaps are used for many purposes in) 180 305.31 P
1 9 Q
-0.5 (GEOS) 415.19 305.31 P
1 10 Q
-0.56 (. Objects are stored) 441.36 305.31 P
(in special LMem heaps, called) 180 292.31 T
3 F
(object blocks) 321.69 292.31 T
1 F
(; windows, GStrings, and many) 378.91 292.31 T
-0.54 (other things are implemented as LMem heaps; and LMem heaps can be used) 180 279.31 P
(to manage arrays of data. Most of these things are done by the system,) 180 266.31 T
(transparent to the user; however) 180 253.31 T
(, some of these things can be called on) 331.3 253.31 T
(directly by applications.) 180 240.31 T
(Most of these techniques are described in their own chapters. One use of) 180 220.31 T
(LMem heaps will be described in this chapter; namely) 180 207.31 T
(, the use of LMem) 428.74 207.31 T
(chunks to store special arrays of data via the Chunk Array routines. The) 180 194.31 T
(chapter will also describe special purpose variants of the Chunk Array: the) 180 181.31 T
(Element Array and the Name Array) 180 168.31 T
(.) 346.12 168.31 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "583" 15
%%Page: "584" 16
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
54 690.34 450 702 R
7 X
0 0 0 1 0 0 0 K
V
0 14 Q
0 X
(Local Memory) 54 692.67 T
54 666.34 450 678.01 R
7 X
V
1 10 Q
0 X
(584) 54 671.34 T
32 684 288 684 2 L
7 X
V
3 H
2 Z
0 X
N
54 90 108 125 R
7 X
V
2 60 Q
0 X
(l) 57.27 85 T
0 24 Q
(Concepts book) 102 110 T
306 99 486 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
305.67 122.67 485.67 134.83 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
54.33 533.33 75.17 545 R
V
0 8 Q
0 X
(16.4) 54.33 539.67 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
7 X
V
0 14 Q
0 X
(16.4.1) 123.08 636 T
0 18 Q
(Chunk Arrays) 180 636 T
1 10 Q
(V) 180 612.33 T
(ery often an application will need to keep track of many different pieces of) 186.3 612.33 T
(data and access them by an index. An application can do this in the) 180 599.33 T
(traditional way) 180 586.33 T
(, i.e., allocate a block of memory and set it up as an array) 250.02 586.33 T
(.) 512.68 586.33 T
(However) 180 573.33 T
(,) 220.18 573.33 T
1 9 Q
(GEOS) 225.74 573.33 T
1 10 Q
( provides a mechanism which is often more suitable: the) 251.91 573.33 T
3 F
(chunk array) 180 560.33 T
1 F
(. The chunk array routines let you dynamically insert or delete) 235.36 560.33 T
(elements in the middle of an array; you can get a pointer to an arbitrary) 180 547.33 T
-0.28 (element \050speci\336ed by its index number\051; you can sort the array based on any) 180 534.33 P
-0.62 (arbitrary criterion. The array can be speci\336ed as \322uniform-size\323 \050all elements) 180 521.33 P
(the same size, speci\336ed when the chunk array is created\051, or \322variable-size\323) 180 508.33 T
-0.25 (\050each element can be created at an arbitrary size and can be resized at will\051.) 180 495.33 P
(Note that either type of array can grow or shrink dynamically; while the) 180 482.33 T
(elements may be of a \336xed size, the array need not be.) 180 469.33 T
(The chunk array is implemented on top of the LMem routines. The entire) 180 449.33 T
-0.56 (array is a single chunk in a local memory heap \050hence the name\051. It therefore) 180 436.33 P
-0.53 (has a maximum total size of somewhat less than 64K, and memory ef\336ciency) 180 423.33 P
-0.14 (drops signi\336cantly if it is larger than roughly 6K. If you need a larger array) 180 410.33 P
-0.14 (,) 525.59 410.33 P
(you should use a Huge Array \050see section 18.5 of chapter 18\051. If you will be) 180 397.33 T
(using the chunk array routines, you should include) 180 384.33 T
4 F
(chunkarr) 418.71 384.33 T
(.h) 467.24 384.33 T
1 F
(.) 476.87 384.33 T
0 14 Q
(16.4.1.1) 111.4 350.67 T
(Structure of the Chunk Array) 180 350.67 T
1 10 Q
(A chunk array is contained in a single chunk in an LMem heap. It begins) 180 328.33 T
-0.23 (with a special header structure which speci\336es certain characteristics of the) 180 315.33 P
(chunk array: the number of elements in the array) 180 302.33 T
(, the size of each element) 408.72 302.33 T
-0.67 (\050or zero for variable sized arrays\051, the offset from the start of the chunk to the) 180 289.33 P
-0.73 (\336rst element, and the offset from the \336rst element to the end of the array) 180 276.33 P
-0.73 (. The) 506.33 276.33 P
(header is a structure of type) 180 263.33 T
4 F
(ChunkArrayHeader) 313.15 263.33 T
1 F
(; an application can) 416.49 263.33 T
-0.69 (examine the \336elds of this structure directly or by using chunk array routines.) 180 250.33 P
(The creating application can request that the chunk array contain some) 180 237.33 T
(blank space between the header and the \336rst element; it can use that space) 180 224.33 T
(however it likes.) 180 211.33 T
(Elements can be referenced by index number) 180 191.33 T
(. The \336rst element has index) 387.41 191.33 T
-0.54 (number zero. Y) 180 178.33 P
-0.54 (ou can translate element numbers to pointers, and vice versa,) 248.56 178.33 P
(by calling) 180 165.33 T
4 F
(ChunkArrayElementT) 227.42 165.33 T
(oPtr\050\051) 342.24 165.33 T
1 F
( and) 373.17 165.33 T
4 F
(ChunkArrayPtrT) 180 152.33 T
(oElement\050\051) 268.53 152.33 T
1 F
( \050see section 16.4.1.3 on page 587\051.) 325.75 152.33 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "584" 16
%%Page: "585" 17
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
162 690.34 558 702 R
7 X
0 0 0 1 0 0 0 K
V
0 14 Q
0 X
(Special LMem Uses) 427.28 692.67 T
162 666.34 558 678.01 R
7 X
V
1 10 Q
0 X
(585) 541.32 671.34 T
324 684 580 684 2 L
7 X
V
3 H
2 Z
0 X
N
504 90 558 125 R
7 X
V
2 60 Q
0 X
(l) 507.27 85 T
0 24 Q
(Concepts book) 327.65 110 T
90 99 270 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
90.67 123.5 270.67 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
536.84 533.33 557.67 545 R
V
0 8 Q
0 X
(16.4) 542.1 539.67 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
7 X
V
1 10 Q
0 X
-0.69 (A uniform-size chunk array has a simple structure. After the header \050and the) 180 641.33 P
-0.65 (extra space, if any\051 come the elements. They follow one after another) 180 628.33 P
-0.65 (, with no) 489.78 628.33 P
(free space between them, as shown in Figure) 180 615.33 T
(16-) 390.21 615.33 T
(3. An application can) 404.66 615.33 T
-0.47 (request a pointer to any element, speci\336ed by index; the chunk array routine) 180 602.33 P
-0.08 (multiplies the index by the size of each element and adds the product to the) 180 589.33 P
-0.81 (address of the \336rst element, producing a pointer to the requested element. An) 180 576.33 P
-0.71 (application can also proceed through the array) 180 563.33 P
-0.71 (, going from one element to the) 390.02 563.33 P
(next, without speci\336cally requesting pointers.) 180 550.33 T
-0.14 (The structure of a variable-size chunk array is a little bit more complicated.) 180 530.33 P
-0.35 (After the header \050and extra space\051 is a lookup-table of two-byte entries, each) 180 517.33 P
-0.25 (containing the offset from the start of the chunk to the appropriate element.) 180 504.33 P
(The chunk array routines maintain this table automatically) 180 491.33 T
(. When an) 455.61 491.33 T
(application wants to reference a given element, the chunk array routine) 180 478.33 T
(doubles the index number and adds it to the offset to the start of this table;) 180 465.33 T
(this produces the address of a table entry) 180 452.33 T
(, which itself contains the offset to) 369.83 452.33 T
(the actual element \050see Figure) 180 439.33 T
(16-) 323.35 439.33 T
(4\051. Effectively) 337.8 439.33 T
(, there are two arrays with) 400.39 439.33 T
(the same number of elements; the \336rst is a uniform-sized array of offsets to) 180 426.33 T
-0.37 (the entries in the second \050variable-sized\051 array) 180 413.33 P
-0.37 (. However) 392.26 413.33 P
-0.37 (, this is transparent) 437.63 413.33 P
(to the application, which merely requests a pointer to element) 180 400.33 T
3 F
(n) 469.48 400.33 T
1 F
( and is) 475.59 400.33 T
81 144 531 648 C
178.5 144 531 391.97 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
361.83 203.08 465.17 365.9 R
4 X
0 0 0 1 0 0 0 K
V
0.5 H
0 Z
0 X
N
0 10 Q
(Figure) 180 190.12 T
(16-) 213.34 190.12 T
(3) 227.79 190.12 T
3 F
(Uniform-Size Chunk Array) 236.13 190.12 T
(All elements are the same size; thus, to access an individual element, the) 180 176.12 T
(routines just multiply the element size by the element number and add the) 180 164.12 T
(product to the address of the \336rst element.) 180 152.12 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
361.83 203.08 465.17 234.47 R
7 X
V
0 X
N
3 9 Q
(LMemHandleT) 373.59 215.35 T
(able) 436.24 215.35 T
361.83 234.19 465.17 248.89 R
7 X
V
0 X
N
(Chunk) 399.5 238.11 T
361.83 259.84 465.17 287.89 R
7 X
V
0 X
N
(Chunk) 399.5 269.69 T
361.83 295.77 465.17 335.18 R
7 X
V
0 X
N
(ChunkArray) 387.5 310.67 T
361.83 343.86 465.17 365.9 R
7 X
V
0 X
N
(Chunk) 399.5 351.05 T
465.17 335.18 285.08 366.3 2 L
7 X
V
2 Z
0 X
N
361.83 335.18 180.92 366.3 2 L
7 X
V
0 X
N
361.83 295.77 180.92 252.26 2 L
7 X
V
0 X
N
465.17 295.77 285.08 252.26 2 L
7 X
V
0 X
N
180.92 252.26 285.08 285.65 R
7 X
V
0 Z
0 X
N
(ChunkArrayHeader) 191.93 265.53 T
180.92 285.65 285.08 315.04 R
7 X
V
0 X
N
(Extra Space \050if any\051) 191.84 296.92 T
180.92 315.04 285.08 332.13 R
7 X
V
0 X
N
(Element 0) 212.17 320.16 T
180.92 332.13 285.08 349.21 R
7 X
V
0 X
N
(Element 1) 212.17 337.24 T
180.92 349.21 285.08 366.3 R
7 X
V
0 X
N
(Element 2) 212.17 354.33 T
3 10 Q
(LMem Heap) 385.27 379.5 T
(Chunk Array) 202.73 379.5 T
81 144 531 648 C
36 72 576 720 C
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "585" 17
%%Page: "586" 18
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
54 690.34 450 702 R
7 X
0 0 0 1 0 0 0 K
V
0 14 Q
0 X
(Local Memory) 54 692.67 T
54 666.34 450 678.01 R
7 X
V
1 10 Q
0 X
(586) 54 671.34 T
32 684 288 684 2 L
7 X
V
3 H
2 Z
0 X
N
54 90 108 125 R
7 X
V
2 60 Q
0 X
(l) 57.27 85 T
0 24 Q
(Concepts book) 102 110 T
306 99 486 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
305.67 122.67 485.67 134.83 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
54.33 533.33 75.17 545 R
V
0 8 Q
0 X
(16.4) 54.33 539.67 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
7 X
V
1 10 Q
0 X
-0.17 (returned that pointer) 180 641.33 P
-0.17 (. It does not need to know or care about the extra table) 277.99 641.33 P
(constructed by the chunk array routines.) 180 628.33 T
0 14 Q
(16.4.1.2) 111.4 345.69 T
(Creating a Chunk Array) 180 345.69 T
5 10 Q
(ChunkArrayCreate\050\051, ChunkArrayCreateAt\050\051,) 180 323.36 T
(ChunkArrayCreateAtHandles\050\051, ChunkArrayHeader) 180 310.36 T
1 F
(Chunk arrays are created in local memory heaps. An LMem heap can have) 180 290.36 T
(several chunk arrays, and it can have other types of chunks besides chunk) 180 277.36 T
-0.64 (arrays; however) 180 264.36 P
-0.64 (, since an LMem heap is limited to 64K in total size, the more) 252.88 264.36 P
(you put in the heap, the less room there is for a chunk array to grow) 180 251.36 T
(.) 494.29 251.36 T
(The \336rst step in creating a chunk array is to create an LMem heap. Create) 180 231.36 T
-0.37 (the heap the same way you would any general LMem heap. The heap should) 180 218.36 P
(probably be left resizable, since that way it will be able to grow to) 180 205.36 T
(accommodate the chunk array) 180 192.36 T
(.) 318.71 192.36 T
(Once you have created the heap, use the routine) 180 172.36 T
4 F
(ChunkArrayCreate\050\051) 405.57 172.36 T
1 F
( to) 513.36 172.36 T
(create the chunk array) 180 159.36 T
(. This routine will allocate a chunk for the chunk) 284.63 159.36 T
81 144 531 648 C
180 376.02 531 625 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 10 Q
0 X
0 0 0 1 0 0 0 K
(Figure) 180 412 T
(16-) 213.34 412 T
(4) 227.79 412 T
3 F
(V) 236.13 412 T
(ariable-Size Chunk Array) 241.88 412 T
(A chunk array with variable-size elements is actually two successive arrays;) 180 398 T
-0.1 (the \336rst array is an array of chunk offsets to the elements of the second array) 180 386 P
-0.1 (.) 528.22 386 P
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
182.75 425.33 294.42 453.11 R
7 X
V
0.5 H
0 Z
0 X
N
3 9 Q
(ChunkArrayHeader) 197.51 435.83 T
182.75 453.39 294.42 479.71 R
7 X
V
0 X
N
(Extra Space \050if any\051) 197.43 463.15 T
182.75 479.6 294.42 490.42 R
6 X
V
0 X
N
(T) 211.67 481.61 T
(able entry 0) 217.17 481.61 T
182.75 490.33 294.42 501.15 R
6 X
V
0 X
N
(T) 211.67 492.35 T
(able entry 1) 217.17 492.35 T
182.75 501.06 294.42 511.88 R
6 X
V
0 X
N
(T) 211.67 503.08 T
(able entry 2) 217.17 503.08 T
182.75 594.83 294.42 614.92 R
7 X
V
0 X
N
(Element 2) 217.75 601.61 T
182.75 543.15 294.42 594.83 R
7 X
V
0 X
N
(Element 1) 217.75 564.68 T
182.75 511.76 294.42 543.16 R
7 X
V
0 X
N
(Element 0) 217.75 523.82 T
299.7 508.89 294.5 511.89 299.7 514.89 299.7 511.89 4 Y
V
294.5 484.76 319.5 484.76 319.5 511.89 299.7 511.89 4 L
2 Z
N
299.61 540.16 294.42 543.16 299.61 546.16 299.61 543.16 4 Y
V
294.42 495.74 332 495.74 332 543.16 299.61 543.16 4 L
N
299.61 591.83 294.42 594.83 299.61 597.83 299.61 594.83 4 Y
V
294.42 506.47 343.67 506.47 343.67 594.83 299.61 594.83 4 L
N
81 144 531 648 C
36 72 576 720 C
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "586" 18
%%Page: "587" 19
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
162 690.34 558 702 R
7 X
0 0 0 1 0 0 0 K
V
0 14 Q
0 X
(Special LMem Uses) 427.28 692.67 T
162 666.34 558 678.01 R
7 X
V
1 10 Q
0 X
(587) 541.32 671.34 T
324 684 580 684 2 L
7 X
V
3 H
2 Z
0 X
N
504 90 558 125 R
7 X
V
2 60 Q
0 X
(l) 507.27 85 T
0 24 Q
(Concepts book) 327.65 110 T
90 99 270 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
90.67 123.5 270.67 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
536.84 533.33 557.67 545 R
V
0 8 Q
0 X
(16.4) 542.1 539.67 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
7 X
V
1 10 Q
0 X
(array) 180 641.33 T
(, initialize the array) 204.26 641.33 T
(, and return the chunk handle. Since the routine) 295.76 641.33 T
(allocates a chunk, it can cause chunk shuf\337ing or heap resizing; thus, all) 180 628.33 T
(pointers to the heap are invalidated.) 180 615.33 T
4 F
(ChunkArrayCreate\050\051) 180 595.33 T
1 F
( takes three arguments:) 287.79 595.33 T
2 F
(u) 180 575.33 T
1 F
(The handle of a locked block containing the LMem heap;) 198 575.33 T
2 F
(u) 180 556.33 T
1 F
(The size of each element, or zero if the elements are variable-size; and) 198 556.33 T
2 F
(u) 180 537.33 T
1 F
(The size of the header for the chunk array) 198 537.33 T
(. If you pass zero, the routine) 391.52 537.33 T
(will automatically leave enough space for a) 198 525.33 T
4 F
(ChunkArrayHeader) 399.89 525.33 T
1 F
(structure; if you pass a non-zero argument, it must be larger than the) 198 513.33 T
-0.31 (size of a) 198 501.33 P
4 F
-0.32 (ChunkArrayHeader) 236.9 501.33 P
1 F
-0.31 (. If you will need a data space at the start) 339.5 501.33 P
(of the array) 198 489.33 T
(, it is a good idea to de\336ne a structure, the \336rst element of) 251.15 489.33 T
(which is a) 198 477.33 T
4 F
(ChunkArrayHeader) 247.27 477.33 T
1 F
(, and use that structure to access the) 349.87 477.33 T
(\336xed data area; you can then pass the size of that structure as this) 198 465.33 T
(argument.) 198 453.33 T
(There is another version of this routine which creates a chunk array in an) 180 434.33 T
(existing chunk. This routine,) 180 421.33 T
4 F
(ChunkArrayCreateAt\050\051) 316.31 421.33 T
1 F
(, takes three) 435.95 421.33 T
(arguments, namely an optr indicating the chunk, the size of each element,) 180 408.33 T
-0.18 (and the size of the header) 180 395.33 P
-0.18 (. It allocates a chunk array in that chunk, resizing) 297.43 395.33 P
(it if necessary) 180 382.33 T
(, and returns the chunk\325) 243.15 382.33 T
(s handle. Any data in the chunk may) 354.45 382.33 T
(be overwritten \050except for whatever data falls in the header area after the) 180 369.33 T
4 F
(ChunkArrayHeader) 180 356.33 T
1 F
(\051. The version which takes handles is called) 283.34 356.33 T
4 F
(ChunkArrayCreateAtHandles\050\051) 180 343.33 T
1 F
(.) 342.23 343.33 T
-0.71 (When you are done with a chunk array) 180 323.33 P
-0.71 (, you can free it with) 354.28 323.33 P
4 F
-0.74 (LMemFree\050\051) 447.8 323.33 P
1 F
-0.71 ( the) 511.86 323.33 P
(way you would any other chunk.) 180 310.33 T
0 14 Q
(16.4.1.3) 111.4 276.67 T
(Adding, Removing, and Accessing Elements) 180 276.67 T
5 10 Q
(ChunkArrayAppend\050\051, ChunkArrayAppendHandles\050\051,) 180 254.33 T
(ChunkArrayInsertAt\050\051, ChunkArrayInsertAtHandle\050\051,) 180 241.33 T
(ChunkArrayDelete\050\051, ChunkArrayDeleteHandle\050\051,) 180 228.33 T
(ChunkArrayDeleteRange\050\051, ChunkArrayDeleteRangeHandles\050\051,) 180 215.33 T
(ChunkArrayElementResize\050\051,) 180 202.33 T
(ChunkArrayElementResizeHandles\050\051,) 180 189.33 T
(ChunkArrayElementToPtr\050\051,) 180 176.33 T
(ChunkArrayElementToPtrHandles\050\051,) 180 163.33 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "587" 19
%%Page: "588" 20
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
54 690.34 450 702 R
7 X
0 0 0 1 0 0 0 K
V
0 14 Q
0 X
(Local Memory) 54 692.67 T
54 666.34 450 678.01 R
7 X
V
1 10 Q
0 X
(588) 54 671.34 T
32 684 288 684 2 L
7 X
V
3 H
2 Z
0 X
N
54 90 108 125 R
7 X
V
2 60 Q
0 X
(l) 57.27 85 T
0 24 Q
(Concepts book) 102 110 T
306 99 486 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
305.67 122.67 485.67 134.83 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
54.33 533.33 75.17 545 R
V
0 8 Q
0 X
(16.4) 54.33 539.67 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
7 X
V
5 10 Q
0 X
(ChunkArrayPtrToElement\050\051, ChunkArrayPtrToElementHandle\050\051,) 180 641.33 T
(ChunkArrayGetElement\050\051, ChunkArrayGetElementHandles\050\051) 180 628.33 T
1 F
-0.3 (The chunk array library provides a high-level interface for working with the) 180 608.33 P
(arrays. The application speci\336es a request in general terms \050e.g., \322Insert a) 180 595.33 T
(new element before element \336ve,\323 \322Give me a pointer to element 20\323\051. The) 180 582.33 T
(routines take care of the low-level memory management: inserting bytes,) 180 569.33 T
(swapping chunks to make room, etc. These routines depend on the LMem) 180 556.33 T
(routines; therefore, the block containing the LMem heap must be locked or) 180 543.33 T
(\336xed when you use these routines \050or any other chunk array routines\051.) 180 530.33 T
(When you call a chunk array routine, you must pass the handles specifying) 180 510.33 T
-0.42 (the chunk. As with other routines which act on a chunk, these routines come) 180 497.33 P
(in two formats: one in which the chunk is speci\336ed with an optr) 180 484.33 T
(, and one in) 472.99 484.33 T
(which it is speci\336ed with the global memory handle and the chunk handle.) 180 471.33 T
-0.05 (Adding elements to a chunk array is easy) 180 451.33 P
-0.05 (. T) 369.83 451.33 P
-0.05 (o add an element to the end of a) 381.09 451.33 P
(chunk array) 180 438.33 T
(, use the routine) 235.74 438.33 T
4 F
(ChunkArrayAppend\050\051) 314.08 438.33 T
1 F
(. This routine) 427.24 438.33 T
(automatically updates the) 180 425.33 T
4 F
(ChunkArrayHeader) 303.73 425.33 T
1 F
( \050and the lookup-table, if) 407.07 425.33 T
(elements are variable-sized\051. The routine takes two arguments, namely the) 180 412.33 T
-0.71 (optr and the size of the new element. If the array elements are uniform-sized,) 180 399.33 P
(the size argument is ignored. The routine will resize the chunk to) 180 386.33 T
(accommodate the new element, update its header table \050and lookup table if) 180 373.33 T
(necessary\051, and return a pointer to the element. Since the chunk is resized,) 180 360.33 T
(all other chunk pointers \050and pointers within the chunk array\051 are) 180 347.33 T
(invalidated. The version which takes handles is named) 180 334.33 T
4 F
(ChunkArrayAppendHandles\050\051) 180 321.33 T
1 F
(.) 335.75 321.33 T
(Y) 180 301.33 T
(ou can also add an element within the middle of an array) 185.93 301.33 T
(. The routine) 448.94 301.33 T
4 F
-0.19 (ChunkArrayInsertAt\050\051) 180 288.33 P
1 F
-0.18 ( takes three arguments, namely the optr) 296.3 288.33 P
-0.18 (, a pointer) 481.53 288.33 P
(to the location at which to insert the element, and the size of the element) 180 275.33 T
(\050ignored for uniform-sized arrays\051. The routine will insert the appropriate) 180 262.33 T
(number of bytes at that location in the chunk, update the header and) 180 249.33 T
-0.8 (lookup-table, and return a pointer to the new element. Pointers to chunks are) 180 236.33 P
(invalidated. The version which takes the chunk handle,) 180 223.33 T
4 F
-0.38 (ChunkArrayInsertAtHandle\050\051) 180 210.33 P
1 F
-0.37 (, is slightly unusual in that it is passed the) 333.89 210.33 P
(chunk handle but not the global memory handle; the routine gets the) 180 197.33 T
(segment address of the chunk from the passed pointers.) 180 184.33 T
(When you are done with an element, free it with) 180 164.33 T
4 F
(ChunkArrayDelete\050\051) 406.32 164.33 T
1 F
(.) 512.62 164.33 T
(This routine takes two arguments, namely the optr and a pointer to the) 180 151.33 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "588" 20
%%Page: "589" 21
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
162 690.34 558 702 R
7 X
0 0 0 1 0 0 0 K
V
0 14 Q
0 X
(Special LMem Uses) 427.28 692.67 T
162 666.34 558 678.01 R
7 X
V
1 10 Q
0 X
(589) 541.32 671.34 T
324 684 580 684 2 L
7 X
V
3 H
2 Z
0 X
N
504 90 558 125 R
7 X
V
2 60 Q
0 X
(l) 507.27 85 T
0 24 Q
(Concepts book) 327.65 110 T
90 99 270 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
90.67 123.5 270.67 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
536.84 533.33 557.67 545 R
V
0 8 Q
0 X
(16.4) 542.1 539.67 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
7 X
V
1 10 Q
0 X
(element to be deleted. It shrinks the chunk; thus, it is guaranteed not to) 180 641.33 T
-0.35 (shuf\337e chunks, so chunk pointers remain valid \050though pointers to elements) 180 628.33 P
(within the chunk array will be invalidated if the elements come after the) 180 615.33 T
-0.73 (deleted element\051. Again, the handle version,) 180 602.33 P
4 F
-0.76 (ChunkArrayDeleteHandle\050\051) 382.28 602.33 P
1 F
-0.73 (,) 526.17 602.33 P
(is passed the chunk handle but not the global handle.) 180 589.33 T
(If you need to delete several consecutive elements, call) 180 569.33 T
4 F
-0.5 (ChunkArrayDeleteRange\050\051) 180 556.33 P
1 F
-0.48 (. This routine takes three arguments: the optr) 319.26 556.33 P
(to the chunk array) 180 543.33 T
(, the index of the \336rst element to delete, and the number) 265.19 543.33 T
(of elements to delete. The speci\336ed elements will be deleted. As with) 180 530.33 T
4 F
(ChunkArrayDelete\050\051) 180 517.33 T
1 F
(, the global and local heaps will not be shuf\337ed. The) 286.3 517.33 T
-0.44 (handle version,) 180 504.33 P
4 F
-0.46 (ChunkArrayDeleteRangeHandles\050\051) 252.82 504.33 P
1 F
-0.44 (, is passed the global) 434.67 504.33 P
(handle of the LMem heap and the chunk handle of the chunk array instead) 180 491.33 T
(of the optr to the chunk array) 180 478.33 T
(.) 315.93 478.33 T
(Elements in variable-sized arrays can be resized after creation with the) 180 458.33 T
(routine) 180 445.33 T
4 F
(ChunkArrayElementResize\050\051) 216.48 445.33 T
1 F
(. This routine takes three) 366.48 445.33 T
(arguments: the optr) 180 432.33 T
(, the element number) 271.67 432.33 T
(, and the new size. The routine) 370.2 432.33 T
(resizes the element and updates the lookup table. If the new size is larger) 180 419.33 T
-0.15 (than the old, null bytes will be added to the end of the element; chunks may) 180 406.33 P
(be shuf\337ed, so all chunk pointers are invalidated. If the new size is smaller) 180 393.33 T
-0.38 (than the old, the element will be truncated. This is guaranteed not to shuf\337e) 180 380.33 P
-0.69 (chunks, so pointers to chunks remain valid, though pointers within the array) 180 367.33 P
(may be invalidated. The version which takes handles,) 180 354.33 T
4 F
-0.57 (ChunkArrayElementResizeHandles\050\051) 180 341.33 P
1 F
-0.55 (, is passed both the global memory) 372.59 341.33 P
(handle and the chunk handle.) 180 328.33 T
-0.41 (If you have the index of an element and you want to access that element, use) 180 308.33 P
(the routine) 180 295.33 T
4 F
(ChunkArrayElementT) 234.26 295.33 T
(oPtr\050\051) 349.08 295.33 T
1 F
(. It takes three arguments: the) 380.01 295.33 T
(optr) 180 282.33 T
(, the element number) 198.33 282.33 T
(, and a pointer to a word-length variable. The) 296.86 282.33 T
-0.54 (routine writes the size of the element in the variable and returns a pointer to) 180 269.33 P
(the element. \050If you are not interested in the element\325) 180 256.33 T
(s size, pass a null) 426.87 256.33 T
(pointer) 180 243.33 T
(.\051 It does not change the chunk in any way) 212.59 243.33 T
(, so no pointers are) 407.24 243.33 T
(invalidated. If you pass an index which is out-of-bounds,) 180 230.33 T
4 F
-0.31 (ChunkArrayElementT) 180 217.33 P
-0.31 (oPtr\050\051) 294.82 217.33 P
1 F
-0.3 ( will treat it as the index of the last element.) 325.75 217.33 P
(\050The constant) 180 204.33 T
1 9 Q
(CA_LAST_ELEMENT) 246.3 204.33 T
1 10 Q
( is often used for this purpose.\051 However) 339.8 204.33 T
(,) 525.35 204.33 T
(the error) 180 191.33 T
(-checking version will always fatal-error if passed the index) 220.92 191.33 T
1 9 Q
(CA_NULL_ELEMENT) 180 178.33 T
1 10 Q
( \050i.e. 0xffff\051. The version which takes handles is named) 276 178.33 T
4 F
(ChunkArrayElementT) 180 165.33 T
(oPtrHandles\050\051) 294.82 165.33 T
1 F
(.) 368.34 165.33 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "589" 21
%%Page: "590" 22
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
54 690.34 450 702 R
7 X
0 0 0 1 0 0 0 K
V
0 14 Q
0 X
(Local Memory) 54 692.67 T
54 666.34 450 678.01 R
7 X
V
1 10 Q
0 X
(590) 54 671.34 T
32 684 288 684 2 L
7 X
V
3 H
2 Z
0 X
N
54 90 108 125 R
7 X
V
2 60 Q
0 X
(l) 57.27 85 T
0 24 Q
(Concepts book) 102 110 T
306 99 486 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
305.67 122.67 485.67 134.83 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
54.33 533.33 75.17 545 R
V
0 8 Q
0 X
(16.4) 54.33 539.67 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
7 X
V
1 10 Q
0 X
-0.35 (If you know the address of an element and you need to \336nd out its index, use) 180 641.33 P
(the routine) 180 628.33 T
4 F
(ChunkArrayPtrT) 234.26 628.33 T
(oElement\050\051) 322.79 628.33 T
1 F
(. This routine takes two) 380.01 628.33 T
-0.84 (arguments, namely the optr and a pointer to the element. It returns the index) 180 615.33 P
(number of the element. The version which takes the chunk handle,) 180 602.33 T
4 F
-0.55 (ChunkArrayPtrT) 180 589.33 P
-0.55 (oElementHandle\050\051) 268.53 589.33 P
1 F
-0.53 (, is passed the chunk handle and the) 363.34 589.33 P
(pointer but not the global memory handle.) 180 576.33 T
(Y) 180 556.33 T
(ou can copy an element to a speci\336ed location with the routine) 185.93 556.33 T
4 F
-0.16 (ChunkArrayGetElement\050\051) 180 543.33 P
1 F
-0.16 (. This routine takes three arguments: the optr) 314.63 543.33 P
-0.16 (,) 525.6 543.33 P
(the element number) 180 530.33 T
(, and a pointer to a buffer big enough to hold the entire) 272.97 530.33 T
(element. The routine will copy the element to the speci\336ed buffer) 180 517.33 T
(. The) 479.65 517.33 T
-0.52 (version which takes handles is called) 180 504.33 P
4 F
-0.53 (ChunkArrayGetElementHandles\050\051) 351 504.33 P
1 F
-0.52 (.) 528.22 504.33 P
0 14 Q
(16.4.1.4) 111.4 470.67 T
(Chunk Array Utilities) 180 470.67 T
5 10 Q
(ChunkArrayGetCount\050\051, ChunkArrayGetCountHandles\050\051,) 180 448.33 T
(ChunkArrayZero\050\051, ChunkArrayZeroHandles\050\051,) 180 435.33 T
(ChunkArrayEnum\050\051, ChunkArrayEnumHandles\050\051,) 180 422.33 T
(ChunkArrayEnumRange\050\051, ChunkArrayEnumRangeHandles\050\051,) 180 409.33 T
(ChunkArraySort\050\051, ArrayQuickSort\050\051) 180 396.33 T
1 F
(T) 180 376.33 T
(o \336nd out how many elements are in a chunk array) 185.75 376.33 T
(, use the routine) 420.78 376.33 T
4 F
(ChunkArrayGetCount\050\051) 180 363.33 T
1 F
(. This routine takes one argument, namely the) 303.15 363.33 T
(optr) 180 350.33 T
(. It returns the number of elements in the array) 198.33 350.33 T
(. It does not change the) 418.34 350.33 T
-0.77 (array; no pointers are invalidated. The version which takes handles is named) 180 337.33 P
4 F
(ChunkArrayGetCountHandles\050\051) 180 324.33 T
1 F
(.) 345.74 324.33 T
-0.17 (If you want to delete all elements in the array but you don\325) 180 304.33 P
-0.17 (t want to free the) 449.08 304.33 P
(array itself, use the routine) 180 291.33 T
4 F
(ChunkArrayZero\050\051) 309.64 291.33 T
1 F
(. This routine takes one) 406.32 291.33 T
-0.43 (argument, namely the optr) 180 278.33 P
-0.43 (. It does not return anything. This routine deletes) 302.61 278.33 P
(all the elements in the array) 180 265.33 T
(, updates the header and lookup tables, and) 310.95 265.33 T
(resizes the chunk. Since the chunk is truncated, no chunks are swapped, so) 180 252.33 T
(no chunk pointers are invalidated \050though pointers to elements are,) 180 239.33 T
(naturally) 180 226.33 T
(, invalidated\051. The version which takes handles is named) 222.23 226.33 T
4 F
(ChunkArrayZeroHandles\050\051) 180 213.33 T
1 F
(.) 319.27 213.33 T
(If you want to apply a function to every element in the array) 180 193.33 T
(, use) 458.36 193.33 T
4 F
(ChunkArrayEnum\050\051) 180 180.33 T
1 F
(. This routine is passed three arguments:) 283.89 180.33 T
2 F
(u) 180 160.33 T
1 F
(The optr) 198 160.33 T
(.) 236.89 160.33 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "590" 22
%%Page: "591" 23
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
162 690.34 558 702 R
7 X
0 0 0 1 0 0 0 K
V
0 14 Q
0 X
(Special LMem Uses) 427.28 692.67 T
162 666.34 558 678.01 R
7 X
V
1 10 Q
0 X
(591) 541.32 671.34 T
324 684 580 684 2 L
7 X
V
3 H
2 Z
0 X
N
504 90 558 125 R
7 X
V
2 60 Q
0 X
(l) 507.27 85 T
0 24 Q
(Concepts book) 327.65 110 T
90 99 270 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
90.67 123.5 270.67 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
536.84 533.33 557.67 545 R
V
0 8 Q
0 X
(16.4) 542.1 539.67 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
7 X
V
2 10 Q
0 X
(u) 180 641.33 T
1 F
(A pointer to a Boolean callback routine. This routine will be called for) 198 641.33 T
-0.45 (each element in succession. This routine must be declared _pascal. If the) 198 629.33 P
(callback routine ever returns) 198 617.33 T
3 F
(true) 335.04 617.33 T
1 F
(,) 353.55 617.33 T
4 F
(ChunkArrayEnum\050\051) 359.11 617.33 T
1 F
( will) 463 617.33 T
(immediately return with value) 198 605.33 T
3 F
(true) 343.02 605.33 T
1 F
( \050without checking any more) 361.53 605.33 T
(elements\051. If the callback routine returns) 198 593.33 T
3 F
(false) 390.97 593.33 T
1 F
( for every element,) 412.25 593.33 T
4 F
(ChunkArrayEnum\050\051) 198 581.33 T
1 F
( will return with value) 301.89 581.33 T
3 F
(false.) 409.13 581.33 T
2 F
(u) 180 562.33 T
1 F
(A pointer which is passed to the callback routine.) 198 562.33 T
(The callback routine should be written to take two arguments:) 180 543.33 T
2 F
(u) 180 523.33 T
1 F
(A pointer to the start of an element) 198 523.33 T
2 F
(u) 180 504.33 T
1 F
(The pointer passed to) 198 504.33 T
4 F
(ChunkArrayEnum\050\051) 300.42 504.33 T
(ChunkArrayEnum\050\051) 180 485.33 T
1 F
( can be used for many different purposes, depending) 283.89 485.33 T
(on the nature of the callback routine. For example, it can perform some) 180 472.33 T
-0.47 (action on every element \050in which case it ought always to return) 180 459.33 P
3 F
-0.47 (false) 473.52 459.33 P
1 F
-0.47 (\051; it can) 494.8 459.33 P
(analyze the data in the various elements; it can check to see if any element) 180 446.33 T
(meets some criterion. If it needs to write its results, it might do so at the) 180 433.33 T
-0.14 (location indicated by the pointer) 180 420.33 P
-0.14 (.) 328.14 420.33 P
4 F
-0.15 (ChunkArrayEnum\050\051) 333.55 420.33 P
1 F
-0.14 ( will not cause heap) 437.45 420.33 P
(shuf\337ing unless the callback routine causes it; thus, if the callback routine) 180 407.33 T
-0.43 (avoids shuf\337ing the heap, it can \050for example\051 be passed a pointer to a chunk) 180 394.33 P
(in the same LMem heap as the chunk array) 180 381.33 T
(. The version which is passed) 381.14 381.33 T
(handles is named) 180 368.33 T
4 F
(ChunkArrayEnumHandles\050\051) 263.72 368.33 T
1 F
(.) 410.2 368.33 T
(There is another version of) 180 348.33 T
4 F
(ChunkArrayEnum\050\051) 307.04 348.33 T
1 F
( which acts on a range of) 410.93 348.33 T
(elements. This routine is called) 180 335.33 T
4 F
(ChunkArrayEnumRange\050\051) 327.43 335.33 T
1 F
(. This routine) 464.28 335.33 T
-0.08 (takes the same arguments as) 180 322.33 P
4 F
-0.09 (ChunkArrayEnum\050\051) 317.77 322.33 P
1 F
-0.08 (, plus two more: a start) 421.66 322.33 P
(index, and a number of elements to enumerate.) 180 309.33 T
4 F
-0.46 (ChunkArrayEnumRange\050\051) 180 296.33 P
1 F
-0.45 ( calls the callback routine for the element with) 316.85 296.33 P
(the speci\336ed index, and for every element thereafter until it has processed) 180 283.33 T
-0.71 (the speci\336ed number of elements. Y) 180 270.33 P
-0.71 (ou can have it enumerate to the end of the) 339.96 270.33 P
(chunk array by passing a count of 0xffff.) 180 257.33 T
(The chunk array library also provides a sorting routine,) 180 237.33 T
4 F
(ChunkArraySort\050\051) 180 224.33 T
1 F
(. This routine performs a modi\336ed Quicksort on the) 275.2 224.33 T
-0.37 (array) 180 211.33 P
-0.37 (, using insertion sorts for subarrays below a certain size. This gives the) 204.26 211.33 P
(sort a performance of) 180 198.33 T
(. The sort routine takes three arguments: the) 317.4 198.33 T
(chunk array\325) 180 185.33 T
(s optr) 238.52 185.33 T
(, a pointer to a comparison function, and a word of data) 264.26 185.33 T
(which is passed to the comparison function.) 180 172.33 T
280.92 194.34 317.4 205.48 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
6 9 Q
0 X
0 0 0 1 0 0 0 K
(O) 281.45 198.33 T
(n) 290.94 198.33 T
(n) 308.37 198.33 T
7 F
(l) 295.97 198.33 T
(o) 298.47 198.33 T
(g) 302.97 198.33 T
(\050) 287.95 198.33 T
(\051) 312.87 198.33 T
36 72 576 720 C
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "591" 23
%%Page: "592" 24
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
54 690.34 450 702 R
7 X
0 0 0 1 0 0 0 K
V
0 14 Q
0 X
(Local Memory) 54 692.67 T
54 666.34 450 678.01 R
7 X
V
1 10 Q
0 X
(592) 54 671.34 T
32 684 288 684 2 L
7 X
V
3 H
2 Z
0 X
N
54 90 108 125 R
7 X
V
2 60 Q
0 X
(l) 57.27 85 T
0 24 Q
(Concepts book) 102 110 T
306 99 486 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
305.67 122.67 485.67 134.83 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
54.33 533.33 75.17 545 R
V
0 8 Q
0 X
(16.4) 54.33 539.67 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
7 X
V
1 10 Q
0 X
-0.55 (Whenever the sort routine needs to decide which of two elements comes \336rst,) 180 641.33 P
(it calls the comparison routine. The comparison routine takes two) 180 628.33 T
(arguments, namely the optr and the word of data passed to) 180 615.33 T
4 F
(ChunkArraySort\050\051) 180 602.33 T
1 F
(. It returns a signed word with the following) 275.2 602.33 T
-0.31 (signi\336cance: If the \336rst of the elements should come \336rst in the sorted array) 180 589.33 P
-0.31 (,) 525.75 589.33 P
(it returns a negative number; if the \336rst element ought to come after the) 180 576.33 T
(second, it should return a positive number; and if it doesn\325) 180 563.33 T
(t matter which) 448.92 563.33 T
(comes \336rst, it should return zero. Y) 180 550.33 T
(ou can write a general-purpose) 342.22 550.33 T
(comparison routine which can compare based on any of several parts of the) 180 537.33 T
(element, and you can use the data word to instruct it which part to sort on;) 180 524.33 T
-0.79 (or you can use the data word to tell it to sort in ascending or descending order) 180 511.33 P
-0.79 (.) 526.23 511.33 P
4 F
-0.68 (ChunkArraySort\050\051) 180 498.33 P
1 F
-0.65 ( does not cause heap shuf\337ing as long as the comparison) 275.2 498.33 P
(routine does not. The routine which takes handles is called) 180 485.33 T
4 F
(ChunkArraySortHandles\050\051) 180 472.33 T
1 F
(.) 317.79 472.33 T
4 F
(ChunkArraySort\050\051) 180 452.33 T
1 F
( is based on a more general array sorting routine,) 275.2 452.33 T
4 F
(ArrayQuickSort\050\051) 180 439.33 T
1 F
(.) 271.31 439.33 T
4 F
(ChunkArraySort\050\051) 276.87 439.33 T
1 F
( reads data about the array from) 372.07 439.33 T
-0.47 (the array header and passes the information to) 180 426.33 P
4 F
-0.48 (ArrayQuickSort\050\051) 396.83 426.33 P
1 F
-0.47 (. Y) 488.14 426.33 P
-0.47 (ou can) 499.16 426.33 P
(call) 180 413.33 T
4 F
(ArrayQuickSort\050\051) 199.08 413.33 T
1 F
( directly for arrays which are not chunk arrays,) 290.39 413.33 T
(provided all elements are of uniform size.) 180 400.33 T
4 F
(ArrayQuickSort\050\051) 373.9 400.33 T
1 F
( takes \336ve) 465.21 400.33 T
-0.83 (arguments: a pointer to an array \050which should be locked or \336xed in memory\051,) 180 387.33 P
-0.07 (the number of elements in the array) 180 374.33 P
-0.07 (, the size of each element, a pointer to a) 345.9 374.33 P
(callback routine \050which has exactly the same format as the) 180 361.33 T
4 F
(ChunkArraySort\050\051) 180 348.33 T
1 F
( callback routine\051, and a data word to pass to that) 275.2 348.33 T
(callback routine. It does not return anything.) 180 335.33 T
(Note that) 180 315.33 T
4 F
(ChunkArraySort\050\051) 227.05 315.33 T
1 F
( is currently implemented only for chunk) 322.25 315.33 T
(arrays with \336xed-sized elements.) 180 302.33 T
0 14 Q
(16.4.1.5) 111.4 268.67 T
(Example of Chunk Array Usage) 180 268.67 T
1 10 Q
(This section contains an example of how a chunk array might be used. It) 180 246.33 T
(shows several common chunk array actions, including sorting the array) 180 233.33 T
(.) 509.46 233.33 T
81 200.98 531 213 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 200.98 531 213 R
7 X
0 0 0 1 0 0 0 K
V
76.5 208.23 617.5 211.73 R
4 X
V
0.5 H
0 Z
N
36 72 576 720 C
0 10 Q
0 X
0 0 0 1 0 0 0 K
(Code Display) 81 194.31 T
(16-) 147.13 194.31 T
(2 Example of Chunk Array Usage) 161.58 194.31 T
5 9 Q
(/*) 81 179.98 T
( *) 81 168.98 T
(Declarations \050not in any routine\051) 125 168.98 T
( */) 81 157.98 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "592" 24
%%Page: "593" 25
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
162 690.34 558 702 R
7 X
0 0 0 1 0 0 0 K
V
0 14 Q
0 X
(Special LMem Uses) 427.28 692.67 T
162 666.34 558 678.01 R
7 X
V
1 10 Q
0 X
(593) 541.32 671.34 T
324 684 580 684 2 L
7 X
V
3 H
2 Z
0 X
N
504 90 558 125 R
7 X
V
2 60 Q
0 X
(l) 507.27 85 T
0 24 Q
(Concepts book) 327.65 110 T
90 99 270 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
90.67 123.5 270.67 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
536.84 533.33 557.67 545 R
V
0 8 Q
0 X
(16.4) 542.1 539.67 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
7 X
V
5 9 Q
0 X
(/* We want to store some data right after the chunk array header, so we define our) 81 642 T
( * own header structure. Data in this structure \050except for the ChunkArrayHeader) 81 631 T
( * proper\051 will not be affected by the chunk array routines. */) 81 620 T
(typedef struct {) 81 609 T
(ChunkArrayHeader) 125 598 T
(standardChunkArrayHeader;) 256.5 598 T
(int) 125 587 T
(someData;) 256.5 587 T
(float) 125 576 T
(someMoreData;) 256.5 576 T
(} MyChunkArrayHeader;) 81 565 T
(/* For simplicity, we define a structure which will be used for each element in the) 81 547 T
( * array. \050This is entirely optional.\051 */) 81 536 T
(typedef struct {) 81 525 T
(char) 125 514 T
(someText[80];) 168.98 514 T
(int) 125 503 T
(anInteger;) 168.98 503 T
(float) 125 492 T
(aFloat;) 168.98 492 T
(} MyElementStructure;) 81 481 T
(/* We define some values to pass to the sort routine. The routine will sort by a) 81 463 T
( * different field depending on what value it\325s passed. */) 81 452 T
(#define) 81 441 T
(SORT_ARRAY_BY_STRING) 125 441 T
(0) 301 441 T
(#define) 81 430 T
(SORT_ARRAY_ASCENDING_BY_INT) 125 430 T
(1) 301 430 T
(#define) 81 419 T
(SORT_ARRAY_DESCENDING_BY_FLOAT) 125 419 T
(2) 301 419 T
(/* This is the routine we will use to sort the array. We pass the address of this) 81 401 T
( * routine to ChunkArraySort\050\051, which will call this routine to compare elements.) 81 390 T
( * It returns a negative number if the first element should come before the second) 81 379 T
( * in the sorted array, and a positive integer if the second should come before the) 81 368 T
( * first. If the elements can be in either order, it returns zero. */) 81 357 T
(sword _pascal MyElementCompareRoutine\050) 81 346 T
(MyElementStructure) 125 335 T
(*e1,) 256.5 335 T
(/* Address of first element */) 301 335 T
(MyElementStructure) 125 324 T
(*e2,) 256.5 324 T
(/* Address of second element */) 301 324 T
(word) 125 313 T
(valueForCallback\051) 212.5 313 T
-0.02 (/* Datum passed in to ChunkArraySort\050\051 */) 309.7 313 P
({) 81 302 T
(/* We sort differently depending on what the value of valueForCallback is.) 125 284 T
( * That way, we can use this one routine for all our sorting.) 125 273 T
( */) 125 262 T
(switch\050valueForCallback\051 {) 125 251 T
(case SORT_ARRAY_ASCENDING_BY_INT:) 146.6 240 T
(/* Compare the elements based on their integer fields. Smaller int) 146.6 229 T
( * comes first.*/) 146.6 218 T
(if \050e1->anInteger < e2->anInteger\051) 168.98 207 T
(return\050-1\051;) 190.58 196 T
(else if \050e1->anInteger > e2->anInteger\051) 168.98 185 T
(return\0501\051;) 190.58 174 T
(else return\0500\051;) 168.98 163 T
(break;) 168.98 152 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "593" 25
%%Page: "594" 26
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
54 690.34 450 702 R
7 X
0 0 0 1 0 0 0 K
V
0 14 Q
0 X
(Local Memory) 54 692.67 T
54 666.34 450 678.01 R
7 X
V
1 10 Q
0 X
(594) 54 671.34 T
32 684 288 684 2 L
7 X
V
3 H
2 Z
0 X
N
54 90 108 125 R
7 X
V
2 60 Q
0 X
(l) 57.27 85 T
0 24 Q
(Concepts book) 102 110 T
306 99 486 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
305.67 122.67 485.67 134.83 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
54.33 533.33 75.17 545 R
V
0 8 Q
0 X
(16.4) 54.33 539.67 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
7 X
V
5 9 Q
0 X
(case SORT_ARRAY_DESCENDING_BY_FLOAT:) 146.6 642 T
(/* Compare the elements based on their float fields. Larger float) 146.6 631 T
( * comes first.*/) 146.6 620 T
(if \050e1->aFloat > e2->aFloat\051) 168.98 609 T
(return\050-1\051;) 190.58 598 T
(else if \050e2->aFloat < e2->aFloat\051) 168.98 587 T
(return\0501\051;) 190.58 576 T
(else return\0500\051;) 168.98 565 T
(break;) 168.98 554 T
(case SORT_ARRAY_BY_STRING:) 146.6 536 T
(/* In this case, we call the localization routine to compare the) 168.98 525 T
( * two strings. The localization routine has the same return) 168.98 514 T
( * conventions as this routine, so we return its result directly.) 168.98 503 T
( */) 168.98 492 T
(return\050LocalCmpStrings\050e1->someText, e2->someText, 40\051\051;) 212.5 481 T
(break;) 212.5 470 T
(default:) 146.6 459 T
(/* If we get here, we were passed a bad callback word. The callback) 168.98 448 T
(* routine therefore does not express a preference in ordering the) 174.38 437 T
(* two elements; it shows this by returning zero.) 174.38 426 T
(*/) 174.38 415 T
(} /* end of switch */) 125 404 T
(}) 81 386 T
(/* All of the above appears in some declaration section. The code below might) 81 368 T
( * appear in any routine which creates a chunk array. First, the declarations:) 81 357 T
( */) 81 346 T
(MemHandle) 81 335 T
(blockWithHeap;) 212.5 335 T
(chunkHandle) 81 324 T
(myChunkArray;) 212.5 324 T
(MyChunkArrayHeader) 81 313 T
(*chunkArrayAddress;) 212.5 313 T
(MyElementStructure) 81 302 T
(*currentElement;) 212.5 302 T
(/* Now the code. Here, blockWithHeap has already been set to hold the block handle) 81 284 T
( * of an LMem heap.) 81 273 T
( */) 81 262 T
(MemLock\050blockWithHeap\051; /* Always lock LMem heap before acting on it */) 81 244 T
(myChunkArray = ChunkArrayCreate\050blockWithHeap,) 81 233 T
(sizeof\050MyElementStructure\051, /* Size of each element */) 212.5 222 T
(sizeof\050MyChunkArrayHeader\051\051; /* Size of header */) 212.5 211 T
(/* Let\325s write some data into our part of the header. We need the array\325s address:) 81 193 T
(*/) 81 182 T
(chunkArrayAddress = LMemDerefHandles\050blockWithHeap, myChunkArray\051;) 81 171 T
(chunkArrayAddress->someData = 42;) 81 160 T
(/* This data won\325t be affected */) 344 160 T
(chunkArrayAddress->someMoreData = 2.7182818;) 81 149 T
(/* by chunk array actions */) 344 149 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "594" 26
%%Page: "595" 27
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
162 690.34 558 702 R
7 X
0 0 0 1 0 0 0 K
V
0 14 Q
0 X
(Special LMem Uses) 427.28 692.67 T
162 666.34 558 678.01 R
7 X
V
1 10 Q
0 X
(595) 541.32 671.34 T
324 684 580 684 2 L
7 X
V
3 H
2 Z
0 X
N
504 90 558 125 R
7 X
V
2 60 Q
0 X
(l) 507.27 85 T
0 24 Q
(Concepts book) 327.65 110 T
90 99 270 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
90.67 123.5 270.67 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
536.84 533.33 557.67 545 R
V
0 8 Q
0 X
(16.4) 542.1 539.67 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
7 X
V
5 9 Q
0 X
(/* Now, let\325s create an element: */) 81 642 T
(currentElement = ChunkArrayAppendHandles\050blockWithHeap, myChunkArray, 0\051;) 81 631 T
(/* That invalidates chunkArrayAddress */) 125 620 T
(currentElement->anInteger = 1999;) 81 609 T
(currentElement->aFloat = 1.4142135;) 81 598 T
(strcpy\050currentElement->someText,) 81 587 T
("Work is the curse of the drinking class.\134n" \134) 259.2 587 T
(") 256.5 576 T
(--Oscar Wilde"\051) 272.7 576 T
(/* We\325re done with the array for the moment, so we unlock it: */) 81 558 T
(MemUnlock\050blockWithHeap\051;) 81 547 T
(/* Let\325s assume that several other elements are created now. */) 81 529 T
(/* . . . */) 81 511 T
(/* Now we need to sort the array: */) 81 493 T
(MemLock\050blockWithHeap\051;) 81 482 T
(ChunkArraySortHandles\050blockWithHeap, myChunkArray,) 81 471 T
(SORT_ARRAY_ASCENDING_BY_INT, /* this is passed to comp. routine */) 168.98 460 T
(MyElementCompareRoutine\051;) 168.98 449 T
(/* Array is now sorted! */) 81 431 T
81 406.98 531 419 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 406.98 531 419 R
7 X
0 0 0 1 0 0 0 K
V
76.5 414.23 617.5 417.73 R
4 X
V
0.5 H
0 Z
N
36 72 576 720 C
0 14 Q
0 X
0 0 0 1 0 0 0 K
(16.4.2) 123.08 366.98 T
0 18 Q
(Element Arrays) 180 366.98 T
1 10 Q
(Sometimes an application will create an array with a high duplication rate;) 180 343.31 T
(that is, the array may contain many identical elements. This can be) 180 330.31 T
-0.29 (inef\336cient if the duplication rate is very high or elements are very large. For) 180 317.31 P
-0.66 (this reason,) 180 304.31 P
1 9 Q
-0.6 (GEOS) 235.53 304.31 P
1 10 Q
-0.66 ( provides a special variant of the chunk array known as the) 261.7 304.31 P
3 F
(element array) 180 291.31 T
1 F
(. Every element in an element array has a reference count.) 242.2 291.31 T
(When you insert an element, the insertion routine checks whether an) 180 278.31 T
(identical element already exists in the array) 180 265.31 T
(. If it does, the routine does not) 383.92 265.31 T
(add another copy; instead, it increments the reference count of the element) 180 252.31 T
-0.54 (already in the array and returns its element index. If no such element exists,) 180 239.31 P
-0.01 (the routine copies the new element into the array) 180 226.31 P
-0.01 (, gives it a reference count) 407.17 226.31 P
(of 1, and returns its element number) 180 213.31 T
(. The application may specify a) 349.46 213.31 T
-0.07 (comparison routine which determines whether an element already exists in) 180 200.31 P
(the array; or it may instruct the insertion routine to do a byte-level) 180 187.31 T
(comparison.) 180 174.31 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "595" 27
%%Page: "596" 28
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
54 690.34 450 702 R
7 X
0 0 0 1 0 0 0 K
V
0 14 Q
0 X
(Local Memory) 54 692.67 T
54 666.34 450 678.01 R
7 X
V
1 10 Q
0 X
(596) 54 671.34 T
32 684 288 684 2 L
7 X
V
3 H
2 Z
0 X
N
54 90 108 125 R
7 X
V
2 60 Q
0 X
(l) 57.27 85 T
0 24 Q
(Concepts book) 102 110 T
306 99 486 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
305.67 122.67 485.67 134.83 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
54.33 533.33 75.17 545 R
V
0 8 Q
0 X
(16.4) 54.33 539.67 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
7 X
V
1 10 Q
0 X
-0.54 (Note that elements in an element array may be of \336xed, uniform size, or they) 180 641.33 P
(may be of variable size \050just as with chunk arrays\051. When you create an) 180 628.33 T
-0.23 (element array) 180 615.33 P
-0.23 (, you must specify the size of each element; specifying a size of) 243.85 615.33 P
(zero indicates that the elements are of variable size.) 180 602.33 T
-0.38 (Members of an element array keep their index numbers until they are freed.) 180 582.33 P
(If an element is deleted, the element array routines actually just resize the) 180 569.33 T
(element to zero and add it to a free list. This means that an element with) 180 556.33 T
(index 12 might not be the thirteenth element in the array) 180 543.33 T
(, as it would in a) 445.41 543.33 T
(chunk array \050remember) 180 530.33 T
(, indexes start with zero\051; there might be freed) 289.44 530.33 T
(elements before it. For this reason, we speak of an element in an element) 180 517.33 T
(array having a \322token\323 instead of an index; you should generally consider a) 180 504.33 T
-0.54 (token to be an opaque value. Nevertheless, in most situations, element array) 180 491.33 P
(tokens behave just like chunk array indexes.) 180 478.33 T
(When you delete a reference to an element, its reference count is) 180 458.33 T
(decremented. If the reference count reaches zero, the routine calls an) 180 445.33 T
(application-speci\336ed callback routine to delete the element itself.) 180 432.33 T
(Note that adding an element to an element array requires a linear search) 180 412.33 T
-0.08 (through the existing elements; thus, element arrays are inef\336cient for large) 180 399.33 P
(numbers of elements, if elements will be continually added. Accessing) 180 386.33 T
-0.75 (elements, however) 180 373.33 P
-0.75 (, takes constant time, since the element array routines can) 264.43 373.33 P
-0.14 (quickly translate an element\325) 180 360.33 P
-0.14 (s token into the offset to that element. Thus, it) 314.23 360.33 P
(takes no longer to access an element in an element array than it does to) 180 347.33 T
(access one in a chunk array) 180 334.33 T
(.) 306.49 334.33 T
0 14 Q
(16.4.2.1) 111.4 300.67 T
(Creating an Element Array) 180 300.67 T
5 10 Q
(ElementArrayCreate\050\051, ElementArrayCreateAt\050\051,) 180 278.33 T
(ElementArrayCreateAtHandles\050\051, ElementArrayHeader) 180 265.33 T
1 F
(T) 180 245.33 T
(o create an element array) 185.75 245.33 T
(, call the routine) 303.17 245.33 T
4 F
(ElementArrayCreate\050\051) 382.07 245.33 T
1 F
(. Like) 498.19 245.33 T
4 F
-0.23 (ChunkArrayCreate\050\051) 180 232.33 P
1 F
-0.22 (, it takes three arguments: the LMem heap\325) 287.79 232.33 P
-0.22 (s handle,) 486.81 232.33 P
(the size of each element \050or 0 for variable-sized elements\051, and the size to) 180 219.33 T
-0.13 (leave for the array header) 180 206.33 P
-0.13 (. The routine allocates a chunk in the LMem heap) 298.93 206.33 P
(and initializes it as an element array) 180 193.33 T
(. There is one signi\336cant difference:) 350.04 193.33 T
(Element arrays begin with an) 180 180.33 T
4 F
(ElementArrayHeader) 320.95 180.33 T
1 F
(, a structure whose) 431.88 180.33 T
(\336rst component is a) 180 167.33 T
4 F
(ChunkArrayHeader) 273.71 167.33 T
1 F
(. If you are allocating free space) 376.31 167.33 T
(between the header and the array) 180 154.33 T
(, make sure to leave enough room for an) 335.76 154.33 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "596" 28
%%Page: "597" 29
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
162 690.34 558 702 R
7 X
0 0 0 1 0 0 0 K
V
0 14 Q
0 X
(Special LMem Uses) 427.28 692.67 T
162 666.34 558 678.01 R
7 X
V
1 10 Q
0 X
(597) 541.32 671.34 T
324 684 580 684 2 L
7 X
V
3 H
2 Z
0 X
N
504 90 558 125 R
7 X
V
2 60 Q
0 X
(l) 507.27 85 T
0 24 Q
(Concepts book) 327.65 110 T
90 99 270 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
90.67 123.5 270.67 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
536.84 533.33 557.67 545 R
V
0 8 Q
0 X
(16.4) 542.1 539.67 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
7 X
V
4 10 Q
0 X
(ElementArrayHeader) 180 641.33 T
1 F
(. If you do not need to allocate free space, you can) 290.93 641.33 T
(pass a header size of zero, as with) 180 628.33 T
4 F
(ChunkArrayCreate\050\051) 339.28 628.33 T
1 F
(.) 447.07 628.33 T
(There is another version of this routine,) 180 608.33 T
4 F
(ElementArrayCreateAt\050\051) 366.86 608.33 T
1 F
(, which) 494.83 608.33 T
(creates the element array in a pre-existing chunk. This routine takes three) 180 595.33 T
(arguments: an optr indicating the chunk, the size of each element, and the) 180 582.33 T
(size of the header) 180 569.33 T
(. It creates the element array in the speci\336ed chunk,) 260.37 569.33 T
-0.52 (resizing it if necessary) 180 556.33 P
-0.52 (. Any data in the chunk may be overwritten \050except for) 281.02 556.33 P
(whatever data falls in the header area after the) 180 543.33 T
4 F
(ElementArrayHeader) 402.63 543.33 T
1 F
(\051.) 514.3 543.33 T
(There is also a version which takes handles instead of an optr; it is called) 180 530.33 T
4 F
(ElementArrayCreateAtHandles\050\051) 180 517.33 T
1 F
(.) 350.56 517.33 T
(The routine returns the handle of the newly-created element array) 180 497.33 T
(. It can) 487.23 497.33 T
(cause heap compaction or resizing; therefore, all pointers to the heap are) 180 484.33 T
(invalidated.) 180 471.33 T
0 14 Q
(16.4.2.2) 111.4 437.67 T
(Adding an Element) 180 437.67 T
5 10 Q
(ElementArrayAddElement\050\051,) 180 415.33 T
(ElementArrayAddElementHandles\050\051,) 180 402.33 T
(ElementArrayAddReference\050\051,) 180 389.33 T
(ElementArrayAddReferenceHandles\050\051) 180 376.33 T
1 F
(Adding an element to an element array is somewhat different from adding) 180 356.33 T
-0.52 (one to a chunk array) 180 343.33 P
-0.52 (. T) 272.55 343.33 P
-0.52 (o add an element to a chunk array) 283.34 343.33 P
-0.52 (, you merely call the) 437.3 343.33 P
-0.22 (append routine, then write the element into the allocated space. If you want) 180 330.33 P
(to add an element to an element array) 180 317.33 T
(, you must \336rst write out the data for) 355.96 317.33 T
(the element in a buffer) 180 304.33 T
(. Y) 285.01 304.33 T
(ou then pass the address of this data to) 296.5 304.33 T
4 F
-0.47 (ElementArrayAddElement\050\051) 180 291.33 P
1 F
-0.46 (, which compares your new element with the) 325.56 291.33 P
(elements already in the array) 180 278.33 T
(, and copies it into the array if necessary) 316.13 278.33 T
(.) 502.63 278.33 T
4 F
(ElementArrayAddElement\050\051) 180 258.33 T
1 F
( takes four arguments:) 325.56 258.33 T
2 F
(u) 180 238.33 T
1 F
(An optr indicating the element array;) 198 238.33 T
2 F
(u) 180 219.33 T
1 F
(The address of the element to copy into the array;) 198 219.33 T
2 F
(u) 180 200.33 T
1 F
(A pointer to a callback comparison routine \050see below\051, or a null pointer) 198 200.33 T
(to do a byte-wise comparison;) 198 188.33 T
2 F
(u) 180 169.33 T
1 F
(A dword of data to pass to the comparison routine.) 198 169.33 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "597" 29
%%Page: "598" 30
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
54 690.34 450 702 R
7 X
0 0 0 1 0 0 0 K
V
0 14 Q
0 X
(Local Memory) 54 692.67 T
54 666.34 450 678.01 R
7 X
V
1 10 Q
0 X
(598) 54 671.34 T
32 684 288 684 2 L
7 X
V
3 H
2 Z
0 X
N
54 90 108 125 R
7 X
V
2 60 Q
0 X
(l) 57.27 85 T
0 24 Q
(Concepts book) 102 110 T
306 99 486 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
305.67 122.67 485.67 134.83 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
54.33 533.33 75.17 545 R
V
0 8 Q
0 X
(16.4) 54.33 539.67 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
7 X
V
1 10 Q
0 X
(Y) 180 641.33 T
(ou may have your own criteria for deciding whether an element should be) 185.93 641.33 T
-0.7 (copied into an array) 180 628.33 P
-0.7 (. For example, elements in the array may have three data) 269.39 628.33 P
-0.66 (\336elds; perhaps you count two elements as matching if the \336rst two data \336elds) 180 615.33 P
-0.49 (match. For this reason,) 180 602.33 P
4 F
-0.5 (ElementArrayAddElement\050\051) 288.25 602.33 P
1 F
-0.49 ( lets you specify your) 433.81 602.33 P
(own comparison routine. The callback routine should be a Boolean routine,) 180 589.33 T
(declared _pascal, which takes three arguments:) 180 576.33 T
2 F
(u) 180 556.33 T
1 F
(The address of the element to add;) 198 556.33 T
2 F
(u) 180 537.33 T
1 F
(The address of an element in the array to compare the new element to;) 198 537.33 T
2 F
(u) 180 518.33 T
1 F
(The callback data dword passed to) 198 518.33 T
4 F
(ElementArrayAddElement\050\051) 359.89 518.33 T
1 F
(.) 505.45 518.33 T
4 F
(ElementArrayAddElement\050\051) 180 499.33 T
1 F
( calls the callback routine to compare the) 325.56 499.33 T
-0.75 (new element to each element in the array) 180 486.33 P
-0.75 (. If the callback routine ever returns) 365.7 486.33 P
3 F
(true) 180 473.33 T
1 F
(,) 198.51 473.33 T
4 F
(ElementArrayAddElement\050\051) 204.07 473.33 T
1 F
( has found a matching element in the) 349.63 473.33 T
-0.01 (array; it will increment that element\325) 180 460.33 P
-0.01 (s reference count and return its index.) 351.46 460.33 P
(If the callback routine returns) 180 447.33 T
3 F
(false) 322.41 447.33 T
1 F
( for every element,) 343.69 447.33 T
4 F
(ElementArrayAddElement\050\051) 180 434.33 T
1 F
( copies the new element into the array and) 325.56 434.33 T
-0.68 (gives it a reference count of 1. It returns the element\325) 180 421.33 P
-0.68 (s index; the element will) 418.43 421.33 P
-0.47 (keep that index until it is freed. Note that there is no way to specify where in) 180 408.33 P
-0.13 (an element array a new element should be added. If there are free spaces in) 180 395.33 P
(the array) 180 382.33 T
(, the new element will be created in the \336rst free space; otherwise,) 222.04 382.33 T
(it will be appended to the end of the array) 180 369.33 T
(.) 372.81 369.33 T
-0.76 (If you want to do a bytewise comparison, pass in a null pointer as the callback) 180 349.33 P
-0.16 (routine.) 180 336.33 P
4 F
-0.16 (ElementArrayAddElement\050\051) 219.1 336.33 P
1 F
-0.16 ( will then do a bytewise comparison) 364.66 336.33 P
(of the elements, treating two elements as equal only if every byte matches.) 180 323.33 T
(The bytewise comparison is implemented as a machine-language string) 180 310.33 T
(instruction; it is therefore very fast.) 180 297.33 T
(If you know that the element you want to add is already in the array) 180 277.33 T
(, call) 495.98 277.33 T
4 F
(ElementArrayAddReference\050\051) 180 264.33 T
1 F
(. This routine simply increments the) 334.83 264.33 T
-0.29 (reference count of a speci\336ed element; it does no comparisons. It is therefore) 180 251.33 P
(much faster than) 180 238.33 T
4 F
(ElementArrayAddElement\050\051) 262.41 238.33 T
1 F
(.) 407.97 238.33 T
(Both of these routines have counterparts which are passed handles instead) 180 218.33 T
(of an optr; these counterparts are named) 180 205.33 T
4 F
(ElementArrayAddElementHandles\050\051) 180 192.33 T
1 F
( and) 368.15 192.33 T
4 F
(ElementArrayAddReferenceHandles\050\051) 180 179.33 T
1 F
(.) 377.42 179.33 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "598" 30
%%Page: "599" 31
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
162 690.34 558 702 R
7 X
0 0 0 1 0 0 0 K
V
0 14 Q
0 X
(Special LMem Uses) 427.28 692.67 T
162 666.34 558 678.01 R
7 X
V
1 10 Q
0 X
(599) 541.32 671.34 T
324 684 580 684 2 L
7 X
V
3 H
2 Z
0 X
N
504 90 558 125 R
7 X
V
2 60 Q
0 X
(l) 507.27 85 T
0 24 Q
(Concepts book) 327.65 110 T
90 99 270 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
90.67 123.5 270.67 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
536.84 533.33 557.67 545 R
V
0 8 Q
0 X
(16.4) 542.1 539.67 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
7 X
V
0 14 Q
0 X
(16.4.2.3) 111.4 638.67 T
(Accessing Elements in an Element Array) 180 638.67 T
5 10 Q
(ElementArrayElementChanged\050\051,) 180 616.33 T
(ElementArrayElementChangedHandles\050\051) 180 603.33 T
1 F
-0.75 (Elements in element arrays are accessed in almost the same way as elements) 180 583.33 P
-0.04 (in chunk arrays. There is one major difference. Each element in an element) 180 570.33 P
(array begins with a) 180 557.33 T
4 F
(RefElementHeader) 272.8 557.33 T
1 F
( structure, which contains the) 372.06 557.33 T
-0.33 (element\325) 180 544.33 P
-0.33 (s reference count. For this reason, it is a good idea to declare special) 218.71 544.33 P
(structures for your elements and have the \336rst component of that structure) 180 531.33 T
(be the) 180 518.33 T
4 F
(RefElementHeader) 211.12 518.33 T
1 F
( structure \050as in the code sample below\051.) 310.38 518.33 T
81 485.98 531 498 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 485.98 531 498 R
7 X
0 0 0 1 0 0 0 K
V
76.5 493.23 617.5 496.73 R
4 X
V
0.5 H
0 Z
N
36 72 576 720 C
0 10 Q
0 X
0 0 0 1 0 0 0 K
(Code Display) 81 479.31 T
(16-) 147.13 479.31 T
(3 Structure for Element Array Elements) 161.58 479.31 T
5 9 Q
-0.22 (/* We need to declare two different structures. One will have all the fields in the) 81 464.98 P
-0.2 ( * element proper. We will use this when we create an element, and we will pass its) 81 453.98 P
( * address to ElementArrayAddElement\050\051. The other will contain two fields: the) 81 442.98 T
( * RefElementHeader structure, and the element body structure. When we dereference) 81 431.98 T
( * an element, we are returned the address of such a structure.) 81 420.98 T
( */) 81 409.98 T
(typedef struct {) 81 391.98 T
(word) 125 380.98 T
(amount;) 212.5 380.98 T
(/* This has the element\325s data fields */) 301 380.98 T
(float) 125 369.98 T
(interestRate;) 212.5 369.98 T
(char) 125 358.98 T
(description[20];) 212.5 358.98 T
(} MyElementBody;) 81 347.98 T
(typedef struct {) 81 329.98 T
(RefElementHeader) 125 318.98 T
(header;) 256.5 318.98 T
(/* We won\325t use this\321it holds ref count */) 301 318.98 T
(MyElementBody) 125 307.98 T
(body;) 212.5 307.98 T
(} MyElement;) 81 296.98 T
81 272.95 531 284.98 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 272.95 531 284.98 R
7 X
0 0 0 1 0 0 0 K
V
76.5 280.2 617.5 283.7 R
4 X
V
0.5 H
0 Z
N
36 72 576 720 C
1 10 Q
0 X
0 0 0 1 0 0 0 K
(Note that if you change an element, this may make it identical to another) 180 255.29 T
(element in the element array; in this case, the two could be combined into) 180 242.29 T
(one. T) 180 229.29 T
(o check for this situation, call) 207.42 229.29 T
4 F
(ElementArrayElementChanged\050\051) 346.14 229.29 T
1 F
(.) 516.88 229.29 T
(This routine takes four arguments: the optr to the element array) 180 216.29 T
(, the token) 477.99 216.29 T
-0.35 (for the element changed, a callback comparison routine, and a dword of data) 180 203.29 P
-0.85 (which is passed to the callback routine.) 180 190.29 P
4 F
-0.88 (ElementArrayElementChanged\050\051) 358.33 190.29 P
1 F
-0.04 (checks to see if the element is identical to any other element in the array) 180 177.29 P
-0.04 (. It) 514.79 177.29 P
-0.17 (calls the comparison routine to compare elements. \050Y) 180 164.29 P
-0.17 (ou can force a bytewise) 422.56 164.29 P
(comparison by passing a null function pointer) 180 151.29 T
(.\051 If it matches another) 390.57 151.29 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "599" 31
%%Page: "600" 32
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
54 690.34 450 702 R
7 X
0 0 0 1 0 0 0 K
V
0 14 Q
0 X
(Local Memory) 54 692.67 T
54 666.34 450 678.01 R
7 X
V
1 10 Q
0 X
(600) 54 671.34 T
32 684 288 684 2 L
7 X
V
3 H
2 Z
0 X
N
54 90 108 125 R
7 X
V
2 60 Q
0 X
(l) 57.27 85 T
0 24 Q
(Concepts book) 102 110 T
306 99 486 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
305.67 122.67 485.67 134.83 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
54.33 533.33 75.17 545 R
V
0 8 Q
0 X
(16.4) 54.33 539.67 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
7 X
V
1 10 Q
0 X
-0.03 (element, the two elements will be combined; i.e., the element passed will be) 180 641.33 P
(deleted, and the matching element will have its reference count increased) 180 628.33 T
-0.15 (appropriately) 180 615.33 P
-0.15 (. The matching element\325) 241.67 615.33 P
-0.15 (s token will be returned; you will have) 352.35 615.33 P
(to change any references to the old element appropriately) 180 602.33 T
(. If no match is) 444.64 602.33 T
-0.57 (found, the token which was passed will be returned. The version which takes) 180 589.33 P
(handles is called) 180 576.33 T
4 F
(ElementArrayElementChangedHandles\050\051) 259.46 576.33 T
1 F
(.) 472.79 576.33 T
0 14 Q
(16.4.2.4) 111.4 542.67 T
(Removing An Element From An Element Array) 180 542.67 T
5 10 Q
(ElementArrayRemoveReference\050\051,) 180 520.33 T
(ElementArrayRemoveReferenceHandles\050\051,) 180 507.33 T
(ElementArrayDelete\050\051, ElementArrayDeleteHandles\050\051) 180 494.33 T
1 F
(When you want to remove an element from an element array) 180 474.33 T
(, you should) 460.58 474.33 T
(ordinarily call) 180 461.33 T
4 F
(ElementArrayRemoveReference\050\051) 247.97 461.33 T
1 F
(. This routine) 423.35 461.33 T
(decrements the element\325) 180 448.33 T
(s reference count; it does not, however) 292.41 448.33 T
(, delete the) 467.96 448.33 T
-0.42 (element unless the reference count reaches zero \050i.e. the last reference to the) 180 435.33 P
(element has been deleted\051.) 180 422.33 T
(This routine takes four arguments: the optr of the array) 180 402.33 T
(, the index of the) 437.61 402.33 T
(element, a pointer to a callback routine, and a dword-sized constant to be) 180 389.33 T
(passed to it. There may be certain bookkeeping tasks you want to perform) 180 376.33 T
(when an element is actually being deleted but not when it is just having its) 180 363.33 T
(reference count decremented. In this case, you can pass the address of a) 180 350.33 T
-0.62 (callback routine, which will be called on any element to be deleted just before) 180 337.33 P
(the deletion occurs. After the callback routine returns, the element will be) 180 324.33 T
(removed. If you do not need to have a callback routine called, pass a null) 180 311.33 T
(function pointer) 180 298.33 T
(. As noted, when an element is removed, it is actually just) 253.51 298.33 T
(resized to zero; that way the index numbers of following elements are) 180 285.33 T
(preserved.) 180 272.33 T
(If you want to delete an element regardless of its reference count, call) 180 252.33 T
4 F
-0.95 (ElementArrayDelete\050\051) 180 239.33 P
1 F
-0.92 (. This routine takes two arguments, namely the optr) 294.63 239.33 P
(indicating the array and the index of the element to be deleted. It does not) 180 226.33 T
-0.69 (take a callback routine; perform any necessary bookkeeping before you call it.) 180 213.33 P
(Both of these routines have counterparts which take handles; these) 180 193.33 T
-0.77 (counterparts are named) 180 180.33 P
4 F
-0.79 (ElementArrayRemoveReferenceHandles\050\051) 291.59 180.33 P
1 F
-0.77 ( and) 509.56 180.33 P
4 F
(ElementArrayDeleteHandles\050\051) 180 167.33 T
1 F
(.) 337.22 167.33 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "600" 32
%%Page: "601" 33
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
162 690.34 558 702 R
7 X
0 0 0 1 0 0 0 K
V
0 14 Q
0 X
(Special LMem Uses) 427.28 692.67 T
162 666.34 558 678.01 R
7 X
V
1 10 Q
0 X
(601) 541.32 671.34 T
324 684 580 684 2 L
7 X
V
3 H
2 Z
0 X
N
504 90 558 125 R
7 X
V
2 60 Q
0 X
(l) 507.27 85 T
0 24 Q
(Concepts book) 327.65 110 T
90 99 270 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
90.67 123.5 270.67 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
536.84 533.33 557.67 545 R
V
0 8 Q
0 X
(16.4) 542.1 539.67 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
7 X
V
0 14 Q
0 X
(16.4.2.5) 111.4 638.67 T
(The \322Used Index\323 and Other Index Systems) 180 638.67 T
5 10 Q
(ElementArrayGetUsedCount\050\051,) 180 616.33 T
(ElementArrayGetUsedCountHandles\050\051,) 180 603.33 T
(ElementArrayUsedIndexToToken\050\051,) 180 590.33 T
(ElementArrayUsedIndexToTokenHandles\050\051,) 180 577.33 T
(ElementArrayTokenToUsedIndex\050\051,) 180 564.33 T
(ElementArrayTokenToUsedIndexHandles\050\051) 180 551.33 T
1 F
(Sometimes its useful to have a special index system for element arrays.) 180 531.33 T
-0.35 (Perhaps you would like the used elements to be numbered sequentially) 180 518.33 P
-0.35 (, that) 503.92 518.33 P
(is, the \336rst \322used\323 element would be element \322zero,\323 even if there were free) 180 505.33 T
(elements before it. This would require setting up a second index system,) 180 492.33 T
-0.14 (besides the one used by the element array routines.) 180 479.33 P
1 9 Q
-0.13 (GEOS) 419.51 479.33 P
1 10 Q
-0.14 ( provides routines) 445.68 479.33 P
(with this functionality) 180 466.33 T
(.) 282.42 466.33 T
(T) 180 446.33 T
(o \336nd out the number of elements in an element array) 185.75 446.33 T
(, call) 434.85 446.33 T
4 F
(ElementArrayGetUsedCount\050\051) 180 433.33 T
1 F
(. This routine can return either the) 337.22 433.33 T
-0.04 (number of elements in use or the number of \322in use\323 elements which satisfy) 180 420.33 P
(any arbitrary criteria. The routine takes three arguments: the optr to the) 180 407.33 T
(element array) 180 394.33 T
(, a dword of data which is passed to a callback routine, and a) 244.08 394.33 T
-0.79 (pointer to a Boolean callback routine. That callback routine should itself take) 180 381.33 P
(two arguments: a pointer to an element, and the dword passed to) 180 368.33 T
4 F
(ElementArrayGetUsedCount\050\051) 180 355.33 T
1 F
(. The callback routine is called once for) 337.22 355.33 T
-0.22 (each \322in use\323 element. The callback should return) 180 342.33 P
3 F
-0.22 (true) 410.45 342.33 P
1 F
-0.22 ( if the element should) 428.96 342.33 P
(be counted; otherwise, it should return) 180 329.33 T
3 F
(false) 361.86 329.33 T
1 F
(. For example, the callback) 383.14 329.33 T
-0.34 (routine might return) 180 316.33 P
3 F
-0.34 (true) 278.41 316.33 P
1 F
-0.34 ( if the element is longer than 10 bytes; in this case,) 296.92 316.33 P
4 F
(ElementArrayGetUsedCount\050\051) 180 303.33 T
1 F
( would return the number of elements) 337.22 303.33 T
-0.09 (which are longer than 10 bytes. T) 180 290.33 P
-0.09 (o have every used element counted, pass a) 333.56 290.33 P
(null function pointer) 180 277.33 T
(. The version of this routine which takes handles is) 274.81 277.33 T
(called) 180 264.33 T
4 F
(ElementArrayGetUsedCountHandles\050\051) 209.82 264.33 T
1 F
(.) 409.63 264.33 T
(If you use a different indexing scheme, you will need a way to translate the) 180 244.33 T
(index into the normal element array token. T) 180 231.33 T
(o do this, call the routine) 388 231.33 T
4 F
-0.05 (ElementArrayUsedIndexT) 180 218.33 P
-0.05 (oT) 315.37 218.33 P
-0.05 (oken\050\051) 327.78 218.33 P
1 F
-0.05 (. This routine takes four arguments:) 360.93 218.33 P
(the optr of the element array) 180 205.33 T
(, the index count, a dword \050which is passed to) 312.6 205.33 T
(the callback routine\051, and a callback routine. The callback routine is of the) 180 192.33 T
(same format as the callback routine passed to) 180 179.33 T
4 F
-0.71 (ElementArrayGetUsedCount\050\051) 180 166.33 P
1 F
-0.69 (; it should return) 337.22 166.33 P
3 F
-0.69 (true) 416.12 166.33 P
1 F
-0.69 ( if the element meets) 434.63 166.33 P
(some criterion.) 180 153.33 T
4 F
(ElementArrayUsedIndexT) 251.48 153.33 T
(oT) 386.85 153.33 T
(oken\050\051) 399.26 153.33 T
1 F
( translates the index) 432.41 153.33 T
81 441.13 171 537.45 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 9 Q
0 X
0 0 0 1 0 0 0 K
(Advanced T) 81 484.45 T
(opic) 131.35 484.45 T
1 F
-0.5 (V) 81 468.45 P
-0.5 (ery few applications) 86.67 468.45 P
(will ever need to use) 81 457.45 T
(these routines.) 81 446.45 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
1 X
90 450 13.5 13.5 101.25 513.33 G
4 H
0 Z
90 450 13.5 13.5 101.25 513.33 A
0 0 0 1 0 0 0 K
81 493.21 121.5 533.71 R
1 H
0 X
N
0 0 0 1 0 0 0 K
36 72 576 720 C
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "601" 33
%%Page: "602" 34
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
54 690.34 450 702 R
7 X
0 0 0 1 0 0 0 K
V
0 14 Q
0 X
(Local Memory) 54 692.67 T
54 666.34 450 678.01 R
7 X
V
1 10 Q
0 X
(602) 54 671.34 T
32 684 288 684 2 L
7 X
V
3 H
2 Z
0 X
N
54 90 108 125 R
7 X
V
2 60 Q
0 X
(l) 57.27 85 T
0 24 Q
(Concepts book) 102 110 T
306 99 486 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
305.67 122.67 485.67 134.83 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
54.33 533.33 75.17 545 R
V
0 8 Q
0 X
(16.4) 54.33 539.67 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
7 X
V
1 10 Q
0 X
(passed into the element array\325) 180 641.33 T
(s token for that element. For example, if the) 319.65 641.33 T
(callback routine returns) 180 628.33 T
3 F
(true) 294.45 628.33 T
1 F
( for elements which are longer than 10 bytes,) 312.96 628.33 T
(and you pass an index of \336ve,) 180 615.33 T
4 F
(ElementArrayUsedIndexT) 318.54 615.33 T
(oT) 453.91 615.33 T
(oken\050\051) 466.32 615.33 T
1 F
( will) 499.47 615.33 T
(return the token for the sixth element in the element array which is longer) 180 602.33 T
-0.35 (than 10 bytes. \050Remember) 180 589.33 P
-0.35 (, all indexes are zero-based.\051 Again, passing a null) 299.89 589.33 P
(function pointer makes the routine count all \322in-use\323 elements. The version) 180 576.33 T
(which takes the element array\325) 180 563.33 T
(s handles is called) 322.8 563.33 T
4 F
(ElementArrayUsedIndexT) 180 550.33 T
(oT) 315.37 550.33 T
(okenHandles\050\051) 327.78 550.33 T
1 F
(.) 403.52 550.33 T
(T) 180 530.33 T
(o translate a token back into this kind of index, call) 185.75 530.33 T
4 F
-0.05 (ElementArrayT) 180 517.33 P
-0.05 (okenT) 259.82 517.33 P
-0.05 (oUsedIndex\050\051) 291.49 517.33 P
1 F
-0.05 (. This routine takes four arguments:) 360.93 517.33 P
(the optr to the element array) 180 504.33 T
(, an element token, a callback routine \050as with) 313.16 504.33 T
-0.08 (the other routines in this section\051, and a dword which is passed along to the) 180 491.33 P
-0.32 (callback routine. The routine \336nds the element whose token was passed and) 180 478.33 P
(returns the index it would have under the indexing system de\336ned by the) 180 465.33 T
(callback routine. Again, passing a null function pointer makes the routine) 180 452.33 T
(count every \322in-use\323 element. The routine which takes handles is called) 180 439.33 T
4 F
(ElementArrayT) 180 426.33 T
(okenT) 259.82 426.33 T
(oUsedIndexHandles\050\051) 291.49 426.33 T
1 F
(.) 403.52 426.33 T
0 14 Q
(16.4.3) 123.08 384 T
0 18 Q
(Name Arrays) 180 384 T
1 10 Q
(Applications can build on chunk arrays and element arrays in many ways.) 180 360.33 T
(The chunk array library includes one example of an elaboration on these) 180 347.33 T
-0.78 (structures: the) 180 334.33 P
3 F
-0.78 (name array) 249.37 334.33 P
1 F
-0.78 (. The name array is a special kind of element array) 300.8 334.33 P
(in which elements can be accessed by a \322name\323 label as well as by a token.) 180 321.33 T
(Elements in a name array are of variable size. Each element is divided into) 180 308.33 T
(three sections: The \336rst is the) 180 295.33 T
4 F
(RefElementHeader) 320.38 295.33 T
1 F
(; every element in an) 419.64 295.33 T
-0.24 (element array must begin with one of these \050and the name array is a kind of) 180 282.33 P
-0.09 (element array\051. The second is the data section. The data section is the same) 180 269.33 P
-0.39 (size for every element in a given name array; this size may be anything from) 180 256.33 P
(zero bytes up to a maximum of) 180 243.33 T
1 9 Q
(NAME_ARRA) 324.65 243.33 T
(Y_MAX_DA) 383.14 243.33 T
(T) 432.81 243.33 T
(A_SIZE) 438.32 243.33 T
1 10 Q
(\05064 bytes\051.) 473.43 243.33 T
(The data section is followed by a \322name\323 section. This section contains a) 180 230.33 T
(sequence of bytes of any length up to a maximum of) 180 217.33 T
1 9 Q
(NAME_ARRA) 180 204.33 T
(Y_MAX_NAME_SIZE) 238.49 204.33 T
1 10 Q
( \050256 bytes\051. The name may contain nulls) 329.81 204.33 T
-0.62 (and need not be null terminated. Y) 180 191.33 P
-0.62 (ou can translate a name into the element\325) 336.67 191.33 P
-0.62 (s) 524.21 191.33 P
(token by calling) 180 178.33 T
4 F
(NameArrayFind\050\051) 256.13 178.33 T
1 F
( \050described below\051.) 348.35 178.33 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "602" 34
%%Page: "603" 35
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
162 690.34 558 702 R
7 X
0 0 0 1 0 0 0 K
V
0 14 Q
0 X
(Special LMem Uses) 427.28 692.67 T
162 666.34 558 678.01 R
7 X
V
1 10 Q
0 X
(603) 541.32 671.34 T
324 684 580 684 2 L
7 X
V
3 H
2 Z
0 X
N
504 90 558 125 R
7 X
V
2 60 Q
0 X
(l) 507.27 85 T
0 24 Q
(Concepts book) 327.65 110 T
90 99 270 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
90.67 123.5 270.67 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
536.84 533.33 557.67 545 R
V
0 8 Q
0 X
(16.4) 542.1 539.67 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
7 X
V
1 10 Q
0 X
(Note that creating elements in a name array) 180 641.33 T
(, as in any element array) 385.22 641.33 T
(,) 499.69 641.33 T
(requires a search through all elements; it thus takes linear time.) 180 628.33 T
(Furthermore, translating a name into a token also requires a linear search) 180 615.33 T
(through the elements, and thus also takes linear time. Name arrays thus) 180 602.33 T
-0.25 (become slow if they grow too large. Accessing an element by token, however) 180 589.33 P
-0.25 (,) 525.69 589.33 P
(still takes constant time.) 180 576.33 T
0 14 Q
(16.4.3.1) 111.4 542.67 T
(Creating a Name Array) 180 542.67 T
5 10 Q
(NameArrayCreate\050\051, NameArrayCreateAt\050\051,) 180 520.33 T
(NameArrayCreateAtHandles\050\051, NameArrayAdd\050\051,) 180 507.33 T
(NameArrayAddHandles\050\051, NameArrayHeader, NameArrayAddFlags) 180 494.33 T
1 F
(Creating a name array is much like creating an element array) 180 474.33 T
(. Every name) 466.52 474.33 T
(array must begin with a) 180 461.33 T
4 F
(NameArrayHeader) 294.47 461.33 T
1 F
(. This structure has the) 391.88 461.33 T
(following de\336nition:) 180 448.33 T
5 F
(typedef struct {) 216 432.33 T
(ElementArrayHeader) 252 418.33 T
(NAH_meta;) 396 418.33 T
(word) 252 404.33 T
(NAH_dataSize;) 396 404.33 T
(} NameArrayHeader;) 216 387.33 T
1 F
(This structure contains one new \336eld, namely) 180 366.33 T
3 9 Q
(NAH) 393.72 366.33 T
3 10 Q
(_datasize) 414.89 366.33 T
1 F
(. This \336eld) 457.84 366.33 T
(speci\336es the size of the data area of each element; the name area is of) 180 353.33 T
-0.09 (variable size. Y) 180 340.33 P
-0.09 (ou may examine this \336eld at will, but you may not change it.) 249.48 340.33 P
-0.03 (Y) 180 327.33 P
-0.03 (ou may set up a \336xed data area between the) 185.93 327.33 P
4 F
-0.03 (NameArrayHeader) 392.18 327.33 P
1 F
-0.03 ( and the) 490.33 327.33 P
-0.82 (elements. The usual way to do this is to de\336ne a structure whose \336rst element) 180 314.33 P
(is a) 180 301.33 T
4 F
(NameArrayHeader) 198.9 301.33 T
1 F
( structure.) 297.05 301.33 T
-0.13 (T) 180 281.33 P
-0.13 (o create a name array) 185.75 281.33 P
-0.13 (, call the routine) 285.05 281.33 P
4 F
-0.14 (NameArrayCreate\050\051) 363.42 281.33 P
1 F
-0.13 (. This routine) 466.02 281.33 P
(is passed three arguments:) 180 268.33 T
2 F
(u) 180 248.33 T
1 F
(The global handle of an LMem heap. The name array will be created in) 198 248.33 T
(this block.) 198 236.33 T
2 F
(u) 180 217.33 T
1 F
(The size of the data area in each element. The total size of the element) 198 217.33 T
-0.22 (will vary) 198 205.33 P
-0.22 (, depending on the size of the name. Remember) 237.41 205.33 P
-0.22 (, there is a three) 453.23 205.33 P
-0.14 (byte) 198 193.33 P
4 F
-0.14 (RefElementHeader) 220.46 193.33 P
1 F
-0.14 ( at the start of every element \050before the data) 319.73 193.33 P
(section\051.) 198 181.33 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "603" 35
%%Page: "604" 36
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
54 690.34 450 702 R
7 X
0 0 0 1 0 0 0 K
V
0 14 Q
0 X
(Local Memory) 54 692.67 T
54 666.34 450 678.01 R
7 X
V
1 10 Q
0 X
(604) 54 671.34 T
32 684 288 684 2 L
7 X
V
3 H
2 Z
0 X
N
54 90 108 125 R
7 X
V
2 60 Q
0 X
(l) 57.27 85 T
0 24 Q
(Concepts book) 102 110 T
306 99 486 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
305.67 122.67 485.67 134.83 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
54.33 533.33 75.17 545 R
V
0 8 Q
0 X
(16.4) 54.33 539.67 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
7 X
V
2 10 Q
0 X
(u) 180 641.33 T
1 F
-0.04 (The size of the header structure for the name array) 198 641.33 P
-0.04 (. If you will not need) 433.79 641.33 P
(a \336xed data area, you can pass a size of zero, and enough space will) 198 629.33 T
(automatically be left for a) 198 617.33 T
4 F
(NameArrayHeader) 319.88 617.33 T
1 F
(.) 417.29 617.33 T
-0.21 (The routine allocates a chunk in the speci\336ed heap, initializes a name array) 180 598.33 P
(in that chunk, and returns the chunk\325) 180 585.33 T
(s handle. If it fails for any reason, it) 354.27 585.33 T
-0.61 (returns a null chunk handle. Since the routine allocates a chunk, all pointers) 180 572.33 P
(to the LMem heap are invalidated.) 180 559.33 T
(If you want to create a name array in a speci\336c chunk, call) 180 539.33 T
4 F
(NameArrayCreateAt\050\051) 180 526.33 T
1 F
(. This routine is almost the same as) 294.45 526.33 T
4 F
(NameArrayCreate\050\051) 180 513.33 T
1 F
(. However) 282.6 513.33 T
(, instead of being passed a memory handle,) 328.34 513.33 T
4 F
(NameArrayCreateAt\050\051) 180 500.33 T
1 F
( is passed an optr to a chunk. The name array will) 294.45 500.33 T
(be created in that chunk. Any data in that chunk \050outside of the \336xed data) 180 487.33 T
-0.74 (area\051 will be destroyed. Note that if the chunk is too small for the name array) 180 474.33 P
-0.74 (,) 526.18 474.33 P
4 F
-0.54 (NameArrayCreateAt\050\051) 180 461.33 P
1 F
-0.52 ( will resize it; thus, pointers to the LMem heap may) 294.45 461.33 P
(be invalidated. There is a version of this routine which takes the chunk\325) 180 448.33 T
(s) 511.16 448.33 T
(global and chunk handles instead of its optr; this routine is called) 180 435.33 T
4 F
(NameArrayCreateAtHandles\050\051) 180 422.33 T
1 F
(.) 337.04 422.33 T
(T) 180 402.33 T
(o create an element, call) 185.75 402.33 T
4 F
(NameArrayAdd\050\051) 300.77 402.33 T
1 F
(. This routine creates an) 389.48 402.33 T
(element and copies the data and name into it. The routine takes \336ve) 180 389.33 T
(arguments:) 180 376.33 T
2 F
(u) 180 356.33 T
1 F
(The optr to the name array) 198 356.33 T
(.) 322.46 356.33 T
2 F
(u) 180 337.33 T
1 F
(A pointer to an array of characters containing the element\325) 198 337.33 T
(s name.) 468.94 337.33 T
2 F
(u) 180 318.33 T
1 F
-0.82 (The length of the name, in bytes. This many characters will be copied into) 198 318.33 P
(the name. If you pass a length of zero, bytes will be copied until a null) 198 306.33 T
(byte is reached \050the null will not be copied\051.) 198 294.33 T
2 F
(u) 180 275.33 T
1 F
(A word-length set of) 198 275.33 T
4 F
(NameArrayAddFlags) 294.11 275.33 T
1 F
(. Only one \337ag is currently) 403 275.33 T
(de\336ned, namely) 198 263.33 T
1 9 Q
(NAAF_SET_DA) 274.12 263.33 T
(T) 340.63 263.33 T
(A_ON_REPLACE) 346.14 263.33 T
1 10 Q
(. This \337ag is described) 420.47 263.33 T
(below) 198 251.33 T
(.) 223.57 251.33 T
2 F
(u) 180 232.33 T
1 F
(A pointer to the data section. The data will be copied into the new) 198 232.33 T
(element. \050The length of the data portion was speci\336ed when the name) 198 220.33 T
(array was created.\051) 198 208.33 T
4 F
(NameArrayAdd\050\051) 180 189.33 T
1 F
( allocates the element, copies in the data and name, and) 268.71 189.33 T
(returns the element\325) 180 176.33 T
(s token. If an element with the speci\336ed name already) 273.89 176.33 T
(exists,) 180 163.33 T
4 F
(NameArrayAdd\050\051) 212.23 163.33 T
1 F
( will not create a duplicate. Instead, if the \337ag) 300.94 163.33 T
1 9 Q
(NAAF_SET_DA) 180 150.33 T
(T) 246.51 150.33 T
(A_ON_REPLACE) 252.02 150.33 T
1 10 Q
( was passed,) 326.35 150.33 T
4 F
(NameArrayAdd\050\051) 386.74 150.33 T
1 F
( will copy) 475.45 150.33 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "604" 36
%%Page: "605" 37
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
162 690.34 558 702 R
7 X
0 0 0 1 0 0 0 K
V
0 14 Q
0 X
(Special LMem Uses) 427.28 692.67 T
162 666.34 558 678.01 R
7 X
V
1 10 Q
0 X
(605) 541.32 671.34 T
324 684 580 684 2 L
7 X
V
3 H
2 Z
0 X
N
504 90 558 125 R
7 X
V
2 60 Q
0 X
(l) 507.27 85 T
0 24 Q
(Concepts book) 327.65 110 T
90 99 270 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
90.67 123.5 270.67 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
536.84 533.33 557.67 545 R
V
0 8 Q
0 X
(16.4) 542.1 539.67 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
7 X
V
1 10 Q
0 X
(the new data section into the existing element; if the \337ag was not passed, it) 180 641.33 T
(will leave the existing element unchanged. In either case, it will return the) 180 628.33 T
(existing element\325) 180 615.33 T
(s token and increment its reference count. If an element is) 258.16 615.33 T
(added, the name array may have to be resized; therefore, pointers into the) 180 602.33 T
-0.14 (chunk array will be invalidated. There is a version in which the name array) 180 589.33 P
(is speci\336ed by its global and chunk handles; this version is called) 180 576.33 T
4 F
(NameArrayAddHandles\050\051) 180 563.33 T
1 F
(.) 311.3 563.33 T
81 530.98 531 543 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 530.98 531 543 R
7 X
0 0 0 1 0 0 0 K
V
76.5 538.23 617.5 541.73 R
4 X
V
0.5 H
0 Z
N
36 72 576 720 C
0 10 Q
0 X
0 0 0 1 0 0 0 K
(Code Display) 81 524.31 T
(16-) 147.13 524.31 T
(4 Allocating a Name Array) 161.58 524.31 T
5 9 Q
(/* We want a fixed data space, so we define our own header structure. */) 81 509.98 T
(typedef) 81 498.98 T
(struct {) 125 498.98 T
(NameArrayHeader) 125 487.98 T
(MNAH_meta;) 212.5 487.98 T
(/* Must begin with a NameArrayHeader!!! */) 301 487.98 T
(char *) 125 476.98 T
(MNAH_comments[32];) 212.5 476.98 T
(} MyNameArrayHeader;) 81 465.98 T
(/* The data section of the name array will be this structure: */) 81 447.98 T
(typedef struct {) 81 436.98 T
(double) 125 425.98 T
(MDSS_myDataFloat;) 212.5 425.98 T
(int) 125 414.98 T
(MDSS_myDataInts[20];) 212.5 414.98 T
(} MyDataSectionStruct;) 81 403.98 T
(/* Every element in the name array will have this structure: */) 81 385.98 T
(typedef struct {) 81 374.98 T
(RefElementHeader) 125 363.98 T
(MES_header;) 256.5 363.98 T
(/* For internal use */) 344 363.98 T
(MyDataSectionStruct) 125 352.98 T
(MES_data;) 256.5 352.98 T
(char) 125 341.98 T
(MES_name[];) 256.5 341.98 T
(/* We don\325t know how long this) 344 341.98 T
( * will actually be */) 344 330.98 T
(} MyElementStruct;) 81 319.98 T
(MemHandle) 81 301.98 T
(myLMemHeap;) 168.98 301.98 T
(/* Assume this is initialized */) 256.5 301.98 T
(ChunkHandle) 81 290.98 T
(myNameArray;) 168.98 290.98 T
(/* Sample call to NameArrayCreate\050\051 */) 81 272.98 T
(myNameArray = NameArrayCreate\050myLMemHeap, sizeof\050MyDataSectionStruct\051,) 81 261.98 T
(sizeof\050MyNameArrayHeader\051\051;) 256.5 250.98 T
81 226.95 531 238.98 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 226.95 531 238.98 R
7 X
0 0 0 1 0 0 0 K
V
76.5 234.2 617.5 237.7 R
4 X
V
0.5 H
0 Z
N
36 72 576 720 C
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "605" 37
%%Page: "606" 38
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
54 690.34 450 702 R
7 X
0 0 0 1 0 0 0 K
V
0 14 Q
0 X
(Local Memory) 54 692.67 T
54 666.34 450 678.01 R
7 X
V
1 10 Q
0 X
(606) 54 671.34 T
32 684 288 684 2 L
7 X
V
3 H
2 Z
0 X
N
54 90 108 125 R
7 X
V
2 60 Q
0 X
(l) 57.27 85 T
0 24 Q
(Concepts book) 102 110 T
306 99 486 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
305.67 122.67 485.67 134.83 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
54.33 533.33 75.17 545 R
V
0 8 Q
0 X
(16.4) 54.33 539.67 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
7 X
V
0 14 Q
0 X
(16.4.3.2) 111.4 638.67 T
(Accessing Elements in a Name Array) 180 638.67 T
5 10 Q
(NameArrayFind\050\051, NameArrayFindHandles\050\051,) 180 616.33 T
(NameArrayChangeName\050\051, NameArrayChangeNameHandles\050\051) 180 603.33 T
1 F
-0.48 (Name array routines can be accessed with all the routines used for accessing) 180 583.33 P
(element arrays. However) 180 570.33 T
(, a few special purpose routines are also provided.) 295.56 570.33 T
(If you know the name of an element and want a copy of its data, call) 180 550.33 T
4 F
(NameArrayFind\050\051) 180 537.33 T
1 F
(. This routine is passed four arguments:) 272.22 537.33 T
2 F
(u) 180 517.33 T
1 F
(The optr to the name array) 198 517.33 T
(.) 322.46 517.33 T
2 F
(u) 180 498.33 T
1 F
-0.65 (A pointer to a character buffer) 198 498.33 P
-0.65 (. The buffer should contain the name of the) 334.58 498.33 P
(element sought.) 198 486.33 T
2 F
(u) 180 467.33 T
1 F
(The length of the name. If a length of zero is passed, the name is) 198 467.33 T
(considered to be null terminated \050the trailing null is) 198 455.33 T
3 F
(not) 441.36 455.33 T
1 F
( part of the) 455.99 455.33 T
(name\051.) 198 443.33 T
2 F
(u) 180 424.33 T
1 F
(A pointer to a return buffer) 198 424.33 T
(. The data portion of the element will be) 323.92 424.33 T
(copied to this location.) 198 412.33 T
4 F
(NameArrayFind\050\051) 180 393.33 T
1 F
( will do a linear search through the elements. If it \336nds) 272.22 393.33 T
-0.29 (one with the name speci\336ed, it will return that element\325) 180 380.33 P
-0.29 (s token and copy the) 435.03 380.33 P
(data portion into the return buffer) 180 367.33 T
(. If there is no element with the speci\336ed) 338.15 367.33 T
(name,) 180 354.33 T
4 F
(NameArrayFind\050\051) 211.12 354.33 T
1 F
( will return the constant) 303.34 354.33 T
1 9 Q
(CA_NULL_ELEMENT) 419.09 354.33 T
1 10 Q
(.) 514.17 354.33 T
-0.06 (The routine) 180 341.33 P
4 F
-0.06 (NameArrayFindHandles\050\051) 236.93 341.33 P
1 F
-0.06 ( is identical, except that the name) 371.74 341.33 P
(array is speci\336ed by its global and chunk handles.) 180 328.33 T
(T) 180 308.33 T
(o change an element\325) 185.75 308.33 T
(s name, call) 282.06 308.33 T
4 F
(NameArrayChangeName\050\051) 339.67 308.33 T
1 F
(. This) 476.7 308.33 T
(routine is passed four arguments:) 180 295.33 T
2 F
(u) 180 275.33 T
1 F
(The optr to the name array) 198 275.33 T
(.) 322.46 275.33 T
2 F
(u) 180 256.33 T
1 F
(The token of the element whose name will be changed.) 198 256.33 T
2 F
(u) 180 237.33 T
1 F
-0.25 (A pointer to a character buffer containing the new name for the element.) 198 237.33 P
2 F
(u) 180 218.33 T
1 F
(The length of the new name. If a length of zero is passed, the name is) 198 218.33 T
(considered to be null terminated \050the trailing null is) 198 206.33 T
3 F
(not) 441.36 206.33 T
1 F
( part of the) 455.99 206.33 T
(name\051.) 198 194.33 T
4 F
-0.21 (NameArrayChangeName\050\051) 180 175.33 P
1 F
-0.2 ( changes the element\325) 317.03 175.33 P
-0.2 (s name. If the new name) 415.7 175.33 P
-0.59 (is longer than the old, the element will have to be resized; this will invalidate) 180 162.33 P
(pointers within that block.) 180 149.33 T
4 F
(NameArrayChangeNameHandles\050\051) 305.58 149.33 T
1 F
( is) 485.2 149.33 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "606" 38
%%Page: "607" 39
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
162 690.34 558 702 R
7 X
0 0 0 1 0 0 0 K
V
0 14 Q
0 X
(Special LMem Uses) 427.28 692.67 T
162 666.34 558 678.01 R
7 X
V
1 10 Q
0 X
(607) 541.32 671.34 T
324 684 580 684 2 L
7 X
V
3 H
2 Z
0 X
N
504 90 558 125 R
7 X
V
2 60 Q
0 X
(l) 507.27 85 T
0 24 Q
(Concepts book) 327.65 110 T
90 99 270 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
90.67 123.5 270.67 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
536.84 533.33 557.67 545 R
V
0 8 Q
0 X
(16.4) 542.1 539.67 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
7 X
V
1 10 Q
0 X
(identical, except that the name array is speci\336ed by its global and chunk) 180 641.33 T
(handles.) 180 628.33 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "607" 39
%%Page: "608" 40
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
54 690.34 450 702 R
7 X
0 0 0 1 0 0 0 K
V
0 14 Q
0 X
(Local Memory) 54 692.67 T
54 666.34 450 678.01 R
7 X
V
1 10 Q
0 X
(608) 54 671.34 T
32 684 288 684 2 L
7 X
V
3 H
2 Z
0 X
N
54 90 108 125 R
7 X
V
2 60 Q
0 X
(l) 57.27 85 T
0 24 Q
(Concepts book) 102 110 T
306 99 486 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
305.67 122.67 485.67 134.83 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
54.33 533.33 75.17 545 R
V
0 8 Q
0 X
(16.4) 54.33 539.67 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "608" 40
%%Trailer
%%BoundingBox: 0 0 612 792
%%PageOrder: Ascend
%%Pages: 40
%%DocumentFonts: Helvetica-Bold
%%+ NewCenturySchlbk-Roman
%%+ ZapfDingbats
%%+ NewCenturySchlbk-Italic
%%+ NewCenturySchlbk-Bold
%%+ Courier
%%+ Times-Italic
%%+ Times-Roman
%%EOF
