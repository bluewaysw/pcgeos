%!PS-Adobe-3.0
%%BoundingBox: (atend)
%%Pages: (atend)
%%PageOrder: (atend)
%%DocumentFonts: (atend)
%%Creator: Frame 4.0
%%DocumentData: Clean7Bit
%%EndComments
%%BeginProlog
%
% Frame ps_prolog 4.0, for use with Frame 4.0 products
% This ps_prolog file is Copyright (c) 1986-1993 Frame Technology
% Corporation.  All rights reserved.  This ps_prolog file may be
% freely copied and distributed in conjunction with documents created
% using FrameMaker, FrameBuilder and FrameViewer as long as this 
% copyright notice is preserved.
%
% Frame products normally print colors as their true color on a color printer
% or as shades of gray, based on luminance, on a black-and white printer. The
% following flag, if set to True, forces all non-white colors to print as pure
% black. This has no effect on bitmap images.
/FMPrintAllColorsAsBlack             false def
%
% Frame products can either set their own line screens or use a printer's 
% default settings. Three flags below control this separately for no 
% separations, spot separations and process separations. If a flag
% is true, then the default printer settings will not be changed. If it is
% false, Frame products will use their own settings from a table based on
% the printer's resolution.
/FMUseDefaultNoSeparationScreen      true  def
/FMUseDefaultSpotSeparationScreen    true  def
/FMUseDefaultProcessSeparationScreen false def
%
% For any given PostScript printer resolution, Frame products have two sets of 
% screen angles and frequencies for printing process separations, which are 
% recomended by Adobe. The following variable chooses the higher frequencies
% when set to true or the lower frequencies when set to false. This is only
% effective if the appropriate FMUseDefault...SeparationScreen flag is false.
/FMUseHighFrequencyScreens true def
%
% PostScript Level 2 printers contain an "Accurate Screens" feature which can
% improve process separation rendering at the expense of compute time. This 
% flag is ignored by PostScript Level 1 printers.
/FMUseAcccurateScreens true def
%
% The following PostScript procedure defines the spot function that Frame
% products will use for process separations. You may un-comment-out one of
% the alternative functions below, or use your own.
%
% Dot function
/FMSpotFunction {abs exch abs 2 copy add 1 gt 
		{1 sub dup mul exch 1 sub dup mul add 1 sub }
		{dup mul exch dup mul add 1 exch sub }ifelse } def
%
% Line function
% /FMSpotFunction { pop } def
%
% Elipse function
% /FMSpotFunction { dup 5 mul 8 div mul exch dup mul exch add 
%		sqrt 1 exch sub } def
%
%
/FMversion (4.0) def 
/FMLevel1 /languagelevel where {pop languagelevel} {1} ifelse 2 lt def
/FMPColor
	FMLevel1 {
		false
		/colorimage where {pop pop true} if
	} {
		true
	} ifelse
def
/FrameDict 400 dict def 
systemdict /errordict known not {/errordict 10 dict def
		errordict /rangecheck {stop} put} if
% The readline in PS 23.0 doesn't recognize cr's as nl's on AppleTalk
FrameDict /tmprangecheck errordict /rangecheck get put 
errordict /rangecheck {FrameDict /bug true put} put 
FrameDict /bug false put 
mark 
% Some PS machines read past the CR, so keep the following 3 lines together!
currentfile 5 string readline
00
0000000000
cleartomark 
errordict /rangecheck FrameDict /tmprangecheck get put 
FrameDict /bug get { 
	/readline {
		/gstring exch def
		/gfile exch def
		/gindex 0 def
		{
			gfile read pop 
			dup 10 eq {exit} if 
			dup 13 eq {exit} if 
			gstring exch gindex exch put 
			/gindex gindex 1 add def 
		} loop
		pop 
		gstring 0 gindex getinterval true 
		} bind def
	} if
/FMshowpage /showpage load def
/FMquit /quit load def
/FMFAILURE { 
	dup = flush 
	FMshowpage 
	/Helvetica findfont 12 scalefont setfont
	72 200 moveto
	show FMshowpage 
	FMquit 
	} def 
/FMVERSION {
	FMversion ne {
		(Frame product version does not match ps_prolog!) FMFAILURE
		} if
	} def 
/FMBADEPSF { 
	(PostScript Lang. Ref. Man., 2nd Ed., H.2.4 says EPS must not call X              )
	dup dup (X) search pop exch pop exch pop length 
	4 -1 roll 
	putinterval 
	FMFAILURE
	} def
/FMLOCAL {
	FrameDict begin
	0 def 
	end 
	} def 
/concatprocs
	{
	/proc2 exch cvlit def/proc1 exch cvlit def/newproc proc1 length proc2 length add array def
	newproc 0 proc1 putinterval newproc proc1 length proc2 putinterval newproc cvx
}def
FrameDict begin 
/FMnone 0 def
/FMcyan 1 def
/FMmagenta 2 def
/FMyellow 3 def
/FMblack 4 def
/FMcustom 5 def
/FrameNegative false def 
/FrameSepIs FMnone def 
/FrameSepBlack 0 def
/FrameSepYellow 0 def
/FrameSepMagenta 0 def
/FrameSepCyan 0 def
/FrameSepRed 1 def
/FrameSepGreen 1 def
/FrameSepBlue 1 def
/FrameCurGray 1 def
/FrameCurPat null def
/FrameCurColors [ 0 0 0 1 0 0 0 ] def 
/FrameColorEpsilon .001 def	
/eqepsilon {		
	sub dup 0 lt {neg} if
	FrameColorEpsilon le
} bind def
/FrameCmpColorsCMYK { 
	2 copy 0 get exch 0 get eqepsilon {
		2 copy 1 get exch 1 get eqepsilon {
			2 copy 2 get exch 2 get eqepsilon {
				3 get exch 3 get eqepsilon
			} {pop pop false} ifelse
		}{pop pop false} ifelse
	} {pop pop false} ifelse
} bind def
/FrameCmpColorsRGB { 
	2 copy 4 get exch 0 get eqepsilon {
		2 copy 5 get exch 1 get eqepsilon {
			6 get exch 2 get eqepsilon
		}{pop pop false} ifelse
	} {pop pop false} ifelse
} bind def
/RGBtoCMYK { 
	1 exch sub 
	3 1 roll 
	1 exch sub 
	3 1 roll 
	1 exch sub 
	3 1 roll 
	3 copy 
	2 copy 
	le { pop } { exch pop } ifelse 
	2 copy 
	le { pop } { exch pop } ifelse 
	dup dup dup 
	6 1 roll 
	4 1 roll 
	7 1 roll 
	sub 
	6 1 roll 
	sub 
	5 1 roll 
	sub 
	4 1 roll 
} bind def
/CMYKtoRGB { 
	dup dup 4 -1 roll add 						  
	5 1 roll 3 -1 roll add 						  
	4 1 roll add 								  
	1 exch sub dup 0 lt {pop 0} if 3 1 roll 	  
	1 exch sub dup 0 lt {pop 0} if exch 	      
	1 exch sub dup 0 lt {pop 0} if exch	  		  
} bind def
/FrameSepInit {
	1.0 RealSetgray
} bind def
/FrameSetSepColor { 
	/FrameSepBlue exch def
	/FrameSepGreen exch def
	/FrameSepRed exch def
	/FrameSepBlack exch def
	/FrameSepYellow exch def
	/FrameSepMagenta exch def
	/FrameSepCyan exch def
	/FrameSepIs FMcustom def
	setCurrentScreen	
} bind def
/FrameSetCyan {
	/FrameSepBlue 1.0 def
	/FrameSepGreen 1.0 def
	/FrameSepRed 0.0 def
	/FrameSepBlack 0.0 def
	/FrameSepYellow 0.0 def
	/FrameSepMagenta 0.0 def
	/FrameSepCyan 1.0 def
	/FrameSepIs FMcyan def
	setCurrentScreen	
} bind def
 
/FrameSetMagenta {
	/FrameSepBlue 1.0 def
	/FrameSepGreen 0.0 def
	/FrameSepRed 1.0 def
	/FrameSepBlack 0.0 def
	/FrameSepYellow 0.0 def
	/FrameSepMagenta 1.0 def
	/FrameSepCyan 0.0 def
	/FrameSepIs FMmagenta def
	setCurrentScreen
} bind def
 
/FrameSetYellow {
	/FrameSepBlue 0.0 def
	/FrameSepGreen 1.0 def
	/FrameSepRed 1.0 def
	/FrameSepBlack 0.0 def
	/FrameSepYellow 1.0 def
	/FrameSepMagenta 0.0 def
	/FrameSepCyan 0.0 def
	/FrameSepIs FMyellow def
	setCurrentScreen
} bind def
 
/FrameSetBlack {
	/FrameSepBlue 0.0 def
	/FrameSepGreen 0.0 def
	/FrameSepRed 0.0 def
	/FrameSepBlack 1.0 def
	/FrameSepYellow 0.0 def
	/FrameSepMagenta 0.0 def
	/FrameSepCyan 0.0 def
	/FrameSepIs FMblack def
	setCurrentScreen
} bind def
 
/FrameNoSep { 
	/FrameSepIs FMnone def
	setCurrentScreen
} bind def
/FrameSetSepColors { 
	FrameDict begin
	[ exch 1 add 1 roll ]
	/FrameSepColors  
	exch def end
	} bind def
/FrameColorInSepListCMYK { 
	FrameSepColors {  
       		exch dup 3 -1 roll 
       		FrameCmpColorsCMYK 
       		{ pop true exit } if
    	} forall 
	dup true ne {pop false} if
	} bind def
/FrameColorInSepListRGB { 
	FrameSepColors {  
       		exch dup 3 -1 roll 
       		FrameCmpColorsRGB 
       		{ pop true exit } if
    	} forall 
	dup true ne {pop false} if
	} bind def
/RealSetgray /setgray load def
/RealSetrgbcolor /setrgbcolor load def
/RealSethsbcolor /sethsbcolor load def
end 
/setgray { 
	FrameDict begin
	FrameSepIs FMnone eq
		{ RealSetgray } 
		{ 
		FrameSepIs FMblack eq 
			{ RealSetgray } 
			{ FrameSepIs FMcustom eq 
			  FrameSepRed 0 eq and
			  FrameSepGreen 0 eq and
			  FrameSepBlue 0 eq and {
			  	RealSetgray
			  } {
				1 RealSetgray pop 
			  } ifelse
			} ifelse
		} ifelse
	end
} bind def
/setrgbcolor { 
	FrameDict begin
	FrameSepIs FMnone eq
	{  RealSetrgbcolor }
	{
		3 copy [ 4 1 roll ] 
		FrameColorInSepListRGB
		{
				FrameSepBlue eq exch 
			 	FrameSepGreen eq and exch 
			 	FrameSepRed eq and
			 	{ 0 } { 1 } ifelse
		}
		{
			FMPColor {
				RealSetrgbcolor
				currentcmykcolor
			} {
				RGBtoCMYK
			} ifelse
			FrameSepIs FMblack eq
			{1.0 exch sub 4 1 roll pop pop pop} {
			FrameSepIs FMyellow eq
			{pop 1.0 exch sub 3 1 roll pop pop} {
			FrameSepIs FMmagenta eq
			{pop pop 1.0 exch sub exch pop } {
			FrameSepIs FMcyan eq
			{pop pop pop 1.0 exch sub } 
			{pop pop pop pop 1} ifelse } ifelse } ifelse } ifelse 
		} ifelse
		RealSetgray
	} 
	ifelse
	end
} bind def
/sethsbcolor {
	FrameDict begin
	FrameSepIs FMnone eq 
	{ RealSethsbcolor } 
	{
		RealSethsbcolor 
		currentrgbcolor  
		setrgbcolor 
	} 
	ifelse
	end
} bind def
FrameDict begin
/setcmykcolor where {
	pop /RealSetcmykcolor /setcmykcolor load def
} {
	/RealSetcmykcolor {
		4 1 roll
		3 { 3 index add 0 max 1 min 1 exch sub 3 1 roll} repeat 
		setrgbcolor pop
	} bind def
} ifelse
userdict /setcmykcolor { 
		FrameDict begin
		FrameSepIs FMnone eq
		{ RealSetcmykcolor } 
		{
			4 copy [ 5 1 roll ]
			FrameColorInSepListCMYK
			{
				FrameSepBlack eq exch 
				FrameSepYellow eq and exch 
				FrameSepMagenta eq and exch 
				FrameSepCyan eq and 
				{ 0 } { 1 } ifelse
			}
			{
				FrameSepIs FMblack eq
				{1.0 exch sub 4 1 roll pop pop pop} {
				FrameSepIs FMyellow eq
				{pop 1.0 exch sub 3 1 roll pop pop} {
				FrameSepIs FMmagenta eq
				{pop pop 1.0 exch sub exch pop } {
				FrameSepIs FMcyan eq
				{pop pop pop 1.0 exch sub } 
				{pop pop pop pop 1} ifelse } ifelse } ifelse } ifelse 
			} ifelse
			RealSetgray
		}
		ifelse
		end
	} bind put
FMLevel1 not { 
	
	/patProcDict 5 dict dup begin
		<0f1e3c78f0e1c387> { 3 setlinewidth -1 -1 moveto 9 9 lineto stroke 
											4 -4 moveto 12 4 lineto stroke
											-4 4 moveto 4 12 lineto stroke} bind def
		<0f87c3e1f0783c1e> { 3 setlinewidth -1 9 moveto 9 -1 lineto stroke 
											-4 4 moveto 4 -4 lineto stroke
											4 12 moveto 12 4 lineto stroke} bind def
		<8142241818244281> { 1 setlinewidth -1 9 moveto 9 -1 lineto stroke
											-1 -1 moveto 9 9 lineto stroke } bind def
		<03060c183060c081> { 1 setlinewidth -1 -1 moveto 9 9 lineto stroke 
											4 -4 moveto 12 4 lineto stroke
											-4 4 moveto 4 12 lineto stroke} bind def
		<8040201008040201> { 1 setlinewidth -1 9 moveto 9 -1 lineto stroke 
											-4 4 moveto 4 -4 lineto stroke
											4 12 moveto 12 4 lineto stroke} bind def
	end def
	/patDict 15 dict dup begin
		/PatternType 1 def		
		/PaintType 2 def		
		/TilingType 3 def		
		/BBox [ 0 0 8 8 ] def 	
		/XStep 8 def			
		/YStep 8 def			
		/PaintProc {
			begin
			patProcDict bstring known {
				patProcDict bstring get exec
			} {
				8 8 true [1 0 0 -1 0 8] bstring imagemask
			} ifelse
			end
		} bind def
	end def
} if
/combineColor {
    FrameSepIs FMnone eq
	{
		graymode FMLevel1 or not {
			
			[/Pattern [/DeviceCMYK]] setcolorspace
			FrameCurColors 0 4 getinterval aload pop FrameCurPat setcolor
		} {
			FrameCurColors 3 get 1.0 ge {
				FrameCurGray RealSetgray
			} {
				FMPColor graymode and {
					0 1 3 { 
						FrameCurColors exch get
						1 FrameCurGray sub mul
					} for
					RealSetcmykcolor
				} {
					4 1 6 {
						FrameCurColors exch get
						graymode {
							1 exch sub 1 FrameCurGray sub mul 1 exch sub
						} {
							1.0 lt {FrameCurGray} {1} ifelse
						} ifelse
					} for
					RealSetrgbcolor
				} ifelse
			} ifelse
		} ifelse
	} { 
		FrameCurColors 0 4 getinterval aload
		FrameColorInSepListCMYK {
			FrameSepBlack eq exch 
			FrameSepYellow eq and exch 
			FrameSepMagenta eq and exch 
			FrameSepCyan eq and
			FrameSepIs FMcustom eq and
			{ FrameCurGray } { 1 } ifelse
		} {
			FrameSepIs FMblack eq
			{FrameCurGray 1.0 exch sub mul 1.0 exch sub 4 1 roll pop pop pop} {
			FrameSepIs FMyellow eq
			{pop FrameCurGray 1.0 exch sub mul 1.0 exch sub 3 1 roll pop pop} {
			FrameSepIs FMmagenta eq
			{pop pop FrameCurGray 1.0 exch sub mul 1.0 exch sub exch pop } {
			FrameSepIs FMcyan eq
			{pop pop pop FrameCurGray 1.0 exch sub mul 1.0 exch sub } 
			{pop pop pop pop 1} ifelse } ifelse } ifelse } ifelse 
		} ifelse
		graymode FMLevel1 or not {
			
			[/Pattern [/DeviceGray]] setcolorspace
			FrameCurPat setcolor
		} { 
			graymode not FMLevel1 and {
				
				dup 1 lt {pop FrameCurGray} if
			} if
			RealSetgray
		} ifelse
	} ifelse
} bind def
/savematrix {
	orgmatrix currentmatrix pop
	} bind def
/restorematrix {
	orgmatrix setmatrix
	} bind def
/dmatrix matrix def
/dpi    72 0 dmatrix defaultmatrix dtransform
    dup mul exch   dup mul add   sqrt def
	
/freq dpi dup 72 div round dup 0 eq {pop 1} if 8 mul div def
/sangle 1 0 dmatrix defaultmatrix dtransform exch atan def
/dpiranges   [  2540    2400    1693     1270    1200     635      600      0      ] def
/CMLowFreqs  [ 100.402  94.8683 89.2289 100.402  94.8683  66.9349  63.2456 47.4342 ] def
/YLowFreqs   [  95.25   90.0    84.65    95.25   90.0     70.5556  66.6667 50.0    ] def
/KLowFreqs   [  89.8026 84.8528 79.8088  89.8026 84.8528  74.8355  70.7107 53.033  ] def
/CLowAngles  [  71.5651 71.5651 71.5651 71.5651  71.5651  71.5651  71.5651 71.5651 ] def
/MLowAngles  [  18.4349 18.4349 18.4349 18.4349  18.4349  18.4349  18.4349 18.4349 ] def
/YLowTDot    [  true    true    false    true    true     false    false   false   ] def
/CMHighFreqs [ 133.87  126.491 133.843  108.503 102.523  100.402   94.8683 63.2456 ] def
/YHighFreqs  [ 127.0   120.0   126.975  115.455 109.091   95.25    90.0    60.0    ] def
/KHighFreqs  [ 119.737 113.137 119.713  128.289 121.218   89.8026  84.8528 63.6395 ] def
/CHighAngles [  71.5651 71.5651 71.5651  70.0169 70.0169  71.5651  71.5651 71.5651 ] def
/MHighAngles [  18.4349 18.4349 18.4349  19.9831 19.9831  18.4349  18.4349 18.4349 ] def
/YHighTDot   [  false   false   true     false   false    true     true    false   ] def
/PatFreq     [	10.5833 10.0     9.4055  10.5833 10.0	  10.5833  10.0	   9.375   ] def
/screenIndex {
	0 1 dpiranges length 1 sub { dup dpiranges exch get 1 sub dpi le {exit} {pop} ifelse } for
} bind def
/getCyanScreen {
	FMUseHighFrequencyScreens { CHighAngles CMHighFreqs} {CLowAngles CMLowFreqs} ifelse
		screenIndex dup 3 1 roll get 3 1 roll get /FMSpotFunction load
} bind def
/getMagentaScreen {
	FMUseHighFrequencyScreens { MHighAngles CMHighFreqs } {MLowAngles CMLowFreqs} ifelse
		screenIndex dup 3 1 roll get 3 1 roll get /FMSpotFunction load
} bind def
/getYellowScreen {
	FMUseHighFrequencyScreens { YHighTDot YHighFreqs} { YLowTDot YLowFreqs } ifelse
		screenIndex dup 3 1 roll get 3 1 roll get { 3 div
			{2 { 1 add 2 div 3 mul dup floor sub 2 mul 1 sub exch} repeat
			FMSpotFunction } } {/FMSpotFunction load } ifelse
			0.0 exch
} bind def
/getBlackScreen  {
	FMUseHighFrequencyScreens { KHighFreqs } { KLowFreqs } ifelse
		screenIndex get 45.0 /FMSpotFunction load 
} bind def
/getSpotScreen {
	getBlackScreen
} bind def
/getCompositeScreen {
	getBlackScreen
} bind def
/FMSetScreen 
	FMLevel1 { /setscreen load 
	}{ {
		8 dict begin
		/HalftoneType 1 def
		/SpotFunction exch def
		/Angle exch def
		/Frequency exch def
		/AccurateScreens FMUseAcccurateScreens def
		currentdict end sethalftone
	} bind } ifelse
def
/setDefaultScreen {
	FMPColor {
		orgrxfer cvx orggxfer cvx orgbxfer cvx orgxfer cvx setcolortransfer
	}
	{
		orgxfer cvx settransfer
	} ifelse
	orgfreq organgle orgproc cvx setscreen
} bind def
/setCurrentScreen {
	FrameSepIs FMnone eq {
		FMUseDefaultNoSeparationScreen {
			setDefaultScreen
		} {
			getCompositeScreen FMSetScreen
		} ifelse
	} {
		FrameSepIs FMcustom eq {
			FMUseDefaultSpotSeparationScreen {
				setDefaultScreen
			} {
				getSpotScreen FMSetScreen
			} ifelse
		} {
			FMUseDefaultProcessSeparationScreen {
				setDefaultScreen
			} {
				FrameSepIs FMcyan eq {
					getCyanScreen FMSetScreen
				} {
					FrameSepIs FMmagenta eq {
						getMagentaScreen FMSetScreen
					} {
						FrameSepIs FMyellow eq {
							getYellowScreen FMSetScreen
						} {
							getBlackScreen FMSetScreen
						} ifelse
					} ifelse
				} ifelse
			} ifelse
		} ifelse
	} ifelse 
} bind def
end
	/gstring FMLOCAL
	/gfile FMLOCAL
	/gindex FMLOCAL
	/orgrxfer FMLOCAL
	/orggxfer FMLOCAL
	/orgbxfer FMLOCAL
	/orgxfer FMLOCAL
	/orgproc FMLOCAL
	/orgrproc FMLOCAL
	/orggproc FMLOCAL
	/orgbproc FMLOCAL
	/organgle FMLOCAL
	/orgrangle FMLOCAL
	/orggangle FMLOCAL
	/orgbangle FMLOCAL
	/orgfreq FMLOCAL
	/orgrfreq FMLOCAL
	/orggfreq FMLOCAL
	/orgbfreq FMLOCAL
	/yscale FMLOCAL
	/xscale FMLOCAL
	/edown FMLOCAL
	/manualfeed FMLOCAL
	/paperheight FMLOCAL
	/paperwidth FMLOCAL
/FMDOCUMENT { 
	array /FMfonts exch def 
	/#copies exch def
	FrameDict begin
	0 ne /manualfeed exch def
	/paperheight exch def
	/paperwidth exch def
	0 ne /FrameNegative exch def 
	0 ne /edown exch def 
	/yscale exch def
	/xscale exch def
	FMLevel1 {
		manualfeed {setmanualfeed} if
		/FMdicttop countdictstack 1 add def 
		/FMoptop count def 
		setpapername 
		manualfeed {true} {papersize} ifelse 
		{manualpapersize} {false} ifelse 
		{desperatepapersize} {false} ifelse 
		{ (Can't select requested paper size for Frame print job!) FMFAILURE } if
		count -1 FMoptop {pop pop} for
		countdictstack -1 FMdicttop {pop end} for 
		}
		{{1 dict dup /PageSize [paperwidth paperheight]put setpagedevice}stopped
		{ (Can't select requested paper size for Frame print job!) FMFAILURE } if
		 {1 dict dup /ManualFeed manualfeed put setpagedevice } stopped pop }
	ifelse 
	
	FMPColor {
		currentcolorscreen
			cvlit /orgproc exch def
				  /organgle exch def 
				  /orgfreq exch def
			cvlit /orgbproc exch def
				  /orgbangle exch def 
				  /orgbfreq exch def
			cvlit /orggproc exch def
				  /orggangle exch def 
				  /orggfreq exch def
			cvlit /orgrproc exch def
				  /orgrangle exch def 
				  /orgrfreq exch def
			currentcolortransfer 
			FrameNegative {
				1 1 4 { 
					pop { 1 exch sub } concatprocs 4 1 roll
				} for
				4 copy
				setcolortransfer
			} if
			cvlit /orgxfer exch def
			cvlit /orgbxfer exch def
			cvlit /orggxfer exch def
			cvlit /orgrxfer exch def
	} {
		currentscreen 
			cvlit /orgproc exch def
				  /organgle exch def 
				  /orgfreq exch def
				  
		currenttransfer 
		FrameNegative {
			{ 1 exch sub } concatprocs
			dup settransfer
		} if 
		cvlit /orgxfer exch def
	} ifelse
	end 
} def 
/pagesave FMLOCAL
/orgmatrix FMLOCAL
/landscape FMLOCAL
/pwid FMLOCAL
/FMBEGINPAGE { 
	FrameDict begin 
	/pagesave save def
	3.86 setmiterlimit
	/landscape exch 0 ne def
	landscape { 
		90 rotate 0 exch dup /pwid exch def neg translate pop 
	}{
		pop /pwid exch def
	} ifelse
	edown { [-1 0 0 1 pwid 0] concat } if
	0 0 moveto paperwidth 0 lineto paperwidth paperheight lineto 
	0 paperheight lineto 0 0 lineto 1 setgray fill
	xscale yscale scale
	/orgmatrix matrix def
	gsave 
} def 
/FMENDPAGE {
	grestore 
	pagesave restore
	end 
	showpage
	} def 
/FMFONTDEFINE { 
	FrameDict begin
	findfont 
	ReEncode 
	1 index exch 
	definefont 
	FMfonts 3 1 roll 
	put
	end 
	} def 
/FMFILLS {
	FrameDict begin dup
	array /fillvals exch def
	dict /patCache exch def
	end 
	} def 
/FMFILL {
	FrameDict begin
	 fillvals 3 1 roll put
	end 
	} def 
/FMNORMALIZEGRAPHICS { 
	newpath
	0.0 0.0 moveto
	1 setlinewidth
	0 setlinecap
	0 0 0 sethsbcolor
	0 setgray 
	} bind def
	/fx FMLOCAL
	/fy FMLOCAL
	/fh FMLOCAL
	/fw FMLOCAL
	/llx FMLOCAL
	/lly FMLOCAL
	/urx FMLOCAL
	/ury FMLOCAL
/FMBEGINEPSF { 
	end 
	/FMEPSF save def 
	/showpage {} def 
% See Adobe's "PostScript Language Reference Manual, 2nd Edition", page 714.
% "...the following operators MUST NOT be used in an EPS file:" (emphasis ours)
	/banddevice {(banddevice) FMBADEPSF} def
	/clear {(clear) FMBADEPSF} def
	/cleardictstack {(cleardictstack) FMBADEPSF} def 
	/copypage {(copypage) FMBADEPSF} def
	/erasepage {(erasepage) FMBADEPSF} def
	/exitserver {(exitserver) FMBADEPSF} def
	/framedevice {(framedevice) FMBADEPSF} def
	/grestoreall {(grestoreall) FMBADEPSF} def
	/initclip {(initclip) FMBADEPSF} def
	/initgraphics {(initgraphics) FMBADEPSF} def
	/initmatrix {(initmatrix) FMBADEPSF} def
	/quit {(quit) FMBADEPSF} def
	/renderbands {(renderbands) FMBADEPSF} def
	/setglobal {(setglobal) FMBADEPSF} def
	/setpagedevice {(setpagedevice) FMBADEPSF} def
	/setshared {(setshared) FMBADEPSF} def
	/startjob {(startjob) FMBADEPSF} def
	/lettertray {(lettertray) FMBADEPSF} def
	/letter {(letter) FMBADEPSF} def
	/lettersmall {(lettersmall) FMBADEPSF} def
	/11x17tray {(11x17tray) FMBADEPSF} def
	/11x17 {(11x17) FMBADEPSF} def
	/ledgertray {(ledgertray) FMBADEPSF} def
	/ledger {(ledger) FMBADEPSF} def
	/legaltray {(legaltray) FMBADEPSF} def
	/legal {(legal) FMBADEPSF} def
	/statementtray {(statementtray) FMBADEPSF} def
	/statement {(statement) FMBADEPSF} def
	/executivetray {(executivetray) FMBADEPSF} def
	/executive {(executive) FMBADEPSF} def
	/a3tray {(a3tray) FMBADEPSF} def
	/a3 {(a3) FMBADEPSF} def
	/a4tray {(a4tray) FMBADEPSF} def
	/a4 {(a4) FMBADEPSF} def
	/a4small {(a4small) FMBADEPSF} def
	/b4tray {(b4tray) FMBADEPSF} def
	/b4 {(b4) FMBADEPSF} def
	/b5tray {(b5tray) FMBADEPSF} def
	/b5 {(b5) FMBADEPSF} def
	FMNORMALIZEGRAPHICS 
	[/fy /fx /fh /fw /ury /urx /lly /llx] {exch def} forall 
	fx fw 2 div add fy fh 2 div add  translate
	rotate
	fw 2 div neg fh 2 div neg translate
	fw urx llx sub div fh ury lly sub div scale 
	llx neg lly neg translate 
	/FMdicttop countdictstack 1 add def 
	/FMoptop count def 
	} bind def
/FMENDEPSF {
	count -1 FMoptop {pop pop} for 
	countdictstack -1 FMdicttop {pop end} for 
	FMEPSF restore
	FrameDict begin 
	} bind def
FrameDict begin 
/setmanualfeed {
%%BeginFeature *ManualFeed True
	 statusdict /manualfeed true put
%%EndFeature
	} bind def
/max {2 copy lt {exch} if pop} bind def
/min {2 copy gt {exch} if pop} bind def
/inch {72 mul} def
/pagedimen { 
	paperheight sub abs 16 lt exch 
	paperwidth sub abs 16 lt and
	{/papername exch def} {pop} ifelse
	} bind def
	/papersizedict FMLOCAL
/setpapername { 
	/papersizedict 14 dict def 
	papersizedict begin
	/papername /unknown def 
		/Letter 8.5 inch 11.0 inch pagedimen
		/LetterSmall 7.68 inch 10.16 inch pagedimen
		/Tabloid 11.0 inch 17.0 inch pagedimen
		/Ledger 17.0 inch 11.0 inch pagedimen
		/Legal 8.5 inch 14.0 inch pagedimen
		/Statement 5.5 inch 8.5 inch pagedimen
		/Executive 7.5 inch 10.0 inch pagedimen
		/A3 11.69 inch 16.5 inch pagedimen
		/A4 8.26 inch 11.69 inch pagedimen
		/A4Small 7.47 inch 10.85 inch pagedimen
		/B4 10.125 inch 14.33 inch pagedimen
		/B5 7.16 inch 10.125 inch pagedimen
	end
	} bind def
/papersize {
	papersizedict begin
		/Letter {lettertray letter} def
		/LetterSmall {lettertray lettersmall} def
		/Tabloid {11x17tray 11x17} def
		/Ledger {ledgertray ledger} def
		/Legal {legaltray legal} def
		/Statement {statementtray statement} def
		/Executive {executivetray executive} def
		/A3 {a3tray a3} def
		/A4 {a4tray a4} def
		/A4Small {a4tray a4small} def
		/B4 {b4tray b4} def
		/B5 {b5tray b5} def
		/unknown {unknown} def
	papersizedict dup papername known {papername} {/unknown} ifelse get
	end
	statusdict begin stopped end 
	} bind def
/manualpapersize {
	papersizedict begin
		/Letter {letter} def
		/LetterSmall {lettersmall} def
		/Tabloid {11x17} def
		/Ledger {ledger} def
		/Legal {legal} def
		/Statement {statement} def
		/Executive {executive} def
		/A3 {a3} def
		/A4 {a4} def
		/A4Small {a4small} def
		/B4 {b4} def
		/B5 {b5} def
		/unknown {unknown} def
	papersizedict dup papername known {papername} {/unknown} ifelse get
	end
	stopped 
	} bind def
/desperatepapersize {
	statusdict /setpageparams known
		{
		paperwidth paperheight 0 1 
		statusdict begin
		{setpageparams} stopped 
		end
		} {true} ifelse 
	} bind def
/DiacriticEncoding [
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /space /exclam /quotedbl
/numbersign /dollar /percent /ampersand /quotesingle /parenleft
/parenright /asterisk /plus /comma /hyphen /period /slash /zero /one
/two /three /four /five /six /seven /eight /nine /colon /semicolon
/less /equal /greater /question /at /A /B /C /D /E /F /G /H /I /J /K
/L /M /N /O /P /Q /R /S /T /U /V /W /X /Y /Z /bracketleft /backslash
/bracketright /asciicircum /underscore /grave /a /b /c /d /e /f /g /h
/i /j /k /l /m /n /o /p /q /r /s /t /u /v /w /x /y /z /braceleft /bar
/braceright /asciitilde /.notdef /Adieresis /Aring /Ccedilla /Eacute
/Ntilde /Odieresis /Udieresis /aacute /agrave /acircumflex /adieresis
/atilde /aring /ccedilla /eacute /egrave /ecircumflex /edieresis
/iacute /igrave /icircumflex /idieresis /ntilde /oacute /ograve
/ocircumflex /odieresis /otilde /uacute /ugrave /ucircumflex
/udieresis /dagger /.notdef /cent /sterling /section /bullet
/paragraph /germandbls /registered /copyright /trademark /acute
/dieresis /.notdef /AE /Oslash /.notdef /.notdef /.notdef /.notdef
/yen /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/ordfeminine /ordmasculine /.notdef /ae /oslash /questiondown
/exclamdown /logicalnot /.notdef /florin /.notdef /.notdef
/guillemotleft /guillemotright /ellipsis /.notdef /Agrave /Atilde
/Otilde /OE /oe /endash /emdash /quotedblleft /quotedblright
/quoteleft /quoteright /.notdef /.notdef /ydieresis /Ydieresis
/fraction /currency /guilsinglleft /guilsinglright /fi /fl /daggerdbl
/periodcentered /quotesinglbase /quotedblbase /perthousand
/Acircumflex /Ecircumflex /Aacute /Edieresis /Egrave /Iacute
/Icircumflex /Idieresis /Igrave /Oacute /Ocircumflex /.notdef /Ograve
/Uacute /Ucircumflex /Ugrave /dotlessi /circumflex /tilde /macron
/breve /dotaccent /ring /cedilla /hungarumlaut /ogonek /caron
] def
/ReEncode { 
	dup 
	length 
	dict begin 
	{
	1 index /FID ne 
		{def} 
		{pop pop} ifelse 
	} forall 
	0 eq {/Encoding DiacriticEncoding def} if 
	currentdict 
	end 
	} bind def
FMPColor 
	
	{
	/BEGINBITMAPCOLOR { 
		BITMAPCOLOR} def
	/BEGINBITMAPCOLORc { 
		BITMAPCOLORc} def
	/BEGINBITMAPTRUECOLOR { 
		BITMAPTRUECOLOR } def
	/BEGINBITMAPTRUECOLORc { 
		BITMAPTRUECOLORc } def
	}
	
	{
	/BEGINBITMAPCOLOR { 
		BITMAPGRAY} def
	/BEGINBITMAPCOLORc { 
		BITMAPGRAYc} def
	/BEGINBITMAPTRUECOLOR { 
		BITMAPTRUEGRAY } def
	/BEGINBITMAPTRUECOLORc { 
		BITMAPTRUEGRAYc } def
	}
ifelse
/K { 
	FMPrintAllColorsAsBlack {
		dup 1 eq 2 index 1 eq and 3 index 1 eq and not
			{7 {pop} repeat 0 0 0 1 0 0 0} if
	} if 
	FrameCurColors astore 
	pop combineColor
} bind def
/graymode true def
	/bwidth FMLOCAL
	/bpside FMLOCAL
	/bstring FMLOCAL
	/onbits FMLOCAL
	/offbits FMLOCAL
	/xindex FMLOCAL
	/yindex FMLOCAL
	/x FMLOCAL
	/y FMLOCAL
/setPatternMode {
	FMLevel1 {
		/bwidth  exch def
		/bpside  exch def
		/bstring exch def
		/onbits 0 def  /offbits 0 def
		freq sangle landscape {90 add} if 
			{/y exch def
			 /x exch def
			 /xindex x 1 add 2 div bpside mul cvi def
			 /yindex y 1 add 2 div bpside mul cvi def
			 bstring yindex bwidth mul xindex 8 idiv add get
			 1 7 xindex 8 mod sub bitshift and 0 ne FrameNegative {not} if
			 {/onbits  onbits  1 add def 1}
			 {/offbits offbits 1 add def 0}
			 ifelse
			}
			setscreen
		offbits offbits onbits add div FrameNegative {1.0 exch sub} if
		/FrameCurGray exch def
	} { 
		pop pop
		dup patCache exch known {
			patCache exch get
		} { 
			dup
			patDict /bstring 3 -1 roll put
			patDict 
			9 PatFreq screenIndex get div dup matrix scale
			makepattern
			dup 
			patCache 4 -1 roll 3 -1 roll put
		} ifelse
		/FrameCurGray 0 def
		/FrameCurPat exch def
	} ifelse
	/graymode false def
	combineColor
} bind def
/setGrayScaleMode {
	graymode not {
		/graymode true def
		FMLevel1 {
			setCurrentScreen
		} if
	} if
	/FrameCurGray exch def
	combineColor
} bind def
/normalize {
	transform round exch round exch itransform
	} bind def
/dnormalize {
	dtransform round exch round exch idtransform
	} bind def
/lnormalize { 
	0 dtransform exch cvi 2 idiv 2 mul 1 add exch idtransform pop
	} bind def
/H { 
	lnormalize setlinewidth
	} bind def
/Z {
	setlinecap
	} bind def
	
/PFill {
	graymode FMLevel1 or not {
		gsave 1 setgray eofill grestore
	} if
} bind def
/PStroke {
	graymode FMLevel1 or not {
		gsave 1 setgray stroke grestore
	} if
	stroke
} bind def
	/fillvals FMLOCAL
/X { 
	fillvals exch get
	dup type /stringtype eq
	{8 1 setPatternMode} 
	{setGrayScaleMode}
	ifelse
	} bind def
/V { 
	PFill gsave eofill grestore
	} bind def
/Vclip {
	clip
	} bind def
/Vstrk {
	currentlinewidth exch setlinewidth PStroke setlinewidth
	} bind def
/N { 
	PStroke
	} bind def
/Nclip {
	strokepath clip newpath
	} bind def
/Nstrk {
	currentlinewidth exch setlinewidth PStroke setlinewidth
	} bind def
/M {newpath moveto} bind def
/E {lineto} bind def
/D {curveto} bind def
/O {closepath} bind def
	/n FMLOCAL
/L { 
 	/n exch def
	newpath
	normalize
	moveto 
	2 1 n {pop normalize lineto} for
	} bind def
/Y { 
	L 
	closepath
	} bind def
	/x1 FMLOCAL
	/x2 FMLOCAL
	/y1 FMLOCAL
	/y2 FMLOCAL
/R { 
	/y2 exch def
	/x2 exch def
	/y1 exch def
	/x1 exch def
	x1 y1
	x2 y1
	x2 y2
	x1 y2
	4 Y 
	} bind def
	/rad FMLOCAL
/rarc 
	{rad 
	 arcto
	} bind def
/RR { 
	/rad exch def
	normalize
	/y2 exch def
	/x2 exch def
	normalize
	/y1 exch def
	/x1 exch def
	mark
	newpath
	{
	x1 y1 rad add moveto
	x1 y2 x2 y2 rarc
	x2 y2 x2 y1 rarc
	x2 y1 x1 y1 rarc
	x1 y1 x1 y2 rarc
	closepath
	} stopped {x1 y1 x2 y2 R} if 
	cleartomark
	} bind def
/RRR { 
	/rad exch def
	normalize /y4 exch def /x4 exch def
	normalize /y3 exch def /x3 exch def
	normalize /y2 exch def /x2 exch def
	normalize /y1 exch def /x1 exch def
	newpath
	normalize moveto 
	mark
	{
	x2 y2 x3 y3 rarc
	x3 y3 x4 y4 rarc
	x4 y4 x1 y1 rarc
	x1 y1 x2 y2 rarc
	closepath
	} stopped
	 {x1 y1 x2 y2 x3 y3 x4 y4 newpath moveto lineto lineto lineto closepath} if
	cleartomark
	} bind def
/C { 
	grestore
	gsave
	R 
	clip
	setCurrentScreen
} bind def
/CP { 
	grestore
	gsave
	Y 
	clip
	setCurrentScreen
} bind def
	/FMpointsize FMLOCAL
/F { 
	FMfonts exch get
	FMpointsize scalefont
	setfont
	} bind def
/Q { 
	/FMpointsize exch def
	F 
	} bind def
/T { 
	moveto show
	} bind def
/RF { 
	rotate
	0 ne {-1 1 scale} if
	} bind def
/TF { 
	gsave
	moveto 
	RF
	show
	grestore
	} bind def
/P { 
	moveto
	0 32 3 2 roll widthshow
	} bind def
/PF { 
	gsave
	moveto 
	RF
	0 32 3 2 roll widthshow
	grestore
	} bind def
/S { 
	moveto
	0 exch ashow
	} bind def
/SF { 
	gsave
	moveto
	RF
	0 exch ashow
	grestore
	} bind def
/B { 
	moveto
	0 32 4 2 roll 0 exch awidthshow
	} bind def
/BF { 
	gsave
	moveto
	RF
	0 32 4 2 roll 0 exch awidthshow
	grestore
	} bind def
/G { 
	gsave
	newpath
	normalize translate 0.0 0.0 moveto 
	dnormalize scale 
	0.0 0.0 1.0 5 3 roll arc 
	closepath 
	PFill fill
	grestore
	} bind def
/Gstrk {
	savematrix
    newpath
    2 index 2 div add exch 3 index 2 div sub exch 
    normalize 2 index 2 div sub exch 3 index 2 div add exch 
    translate
    scale 
    0.0 0.0 1.0 5 3 roll arc 
    restorematrix
    currentlinewidth exch setlinewidth PStroke setlinewidth
    } bind def
/Gclip { 
	newpath
	savematrix
	normalize translate 0.0 0.0 moveto 
	dnormalize scale 
	0.0 0.0 1.0 5 3 roll arc 
	closepath 
	clip newpath
	restorematrix
	} bind def
/GG { 
	gsave
	newpath
	normalize translate 0.0 0.0 moveto 
	rotate 
	dnormalize scale 
	0.0 0.0 1.0 5 3 roll arc 
	closepath
	PFill
	fill
	grestore
	} bind def
/GGclip { 
	savematrix
	newpath
    normalize translate 0.0 0.0 moveto 
    rotate 
    dnormalize scale 
    0.0 0.0 1.0 5 3 roll arc 
    closepath
	clip newpath
	restorematrix
	} bind def
/GGstrk { 
	savematrix
    newpath
    normalize translate 0.0 0.0 moveto 
    rotate 
    dnormalize scale 
    0.0 0.0 1.0 5 3 roll arc 
    closepath 
	restorematrix
    currentlinewidth exch setlinewidth PStroke setlinewidth
	} bind def
/A { 
	gsave
	savematrix
	newpath
	2 index 2 div add exch 3 index 2 div sub exch 
	normalize 2 index 2 div sub exch 3 index 2 div add exch 
	translate 
	scale 
	0.0 0.0 1.0 5 3 roll arc 
	restorematrix
	PStroke
	grestore
	} bind def
/Aclip {
	newpath
	savematrix
	normalize translate 0.0 0.0 moveto 
	dnormalize scale 
	0.0 0.0 1.0 5 3 roll arc 
	closepath 
	strokepath clip newpath
	restorematrix
} bind def
/Astrk {
	Gstrk
} bind def
/AA { 
	gsave
	savematrix
	newpath
	
	3 index 2 div add exch 4 index 2 div sub exch 
	
	normalize 3 index 2 div sub exch 4 index 2 div add exch
	translate 
	rotate 
	scale 
	0.0 0.0 1.0 5 3 roll arc 
	restorematrix
	PStroke
	grestore
	} bind def
/AAclip {
	savematrix
	newpath
    normalize translate 0.0 0.0 moveto 
    rotate 
    dnormalize scale 
    0.0 0.0 1.0 5 3 roll arc 
    closepath
	strokepath clip newpath
	restorematrix
} bind def
/AAstrk {
	GGstrk
} bind def
	/x FMLOCAL
	/y FMLOCAL
	/w FMLOCAL
	/h FMLOCAL
	/xx FMLOCAL
	/yy FMLOCAL
	/ww FMLOCAL
	/hh FMLOCAL
	/FMsaveobject FMLOCAL
	/FMoptop FMLOCAL
	/FMdicttop FMLOCAL
/BEGINPRINTCODE { 
	/FMdicttop countdictstack 1 add def 
	/FMoptop count 7 sub def 
	/FMsaveobject save def
	userdict begin 
	/showpage {} def 
	FMNORMALIZEGRAPHICS 
	3 index neg 3 index neg translate
	} bind def
/ENDPRINTCODE {
	count -1 FMoptop {pop pop} for 
	countdictstack -1 FMdicttop {pop end} for 
	FMsaveobject restore 
	} bind def
/gn { 
	0 
	{	46 mul 
		cf read pop 
		32 sub 
		dup 46 lt {exit} if 
		46 sub add 
		} loop
	add 
	} bind def
	/str FMLOCAL
/cfs { 
	/str sl string def 
	0 1 sl 1 sub {str exch val put} for 
	str def 
	} bind def
/ic [ 
	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0223
	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0223
	0
	{0 hx} {1 hx} {2 hx} {3 hx} {4 hx} {5 hx} {6 hx} {7 hx} {8 hx} {9 hx}
	{10 hx} {11 hx} {12 hx} {13 hx} {14 hx} {15 hx} {16 hx} {17 hx} {18 hx}
	{19 hx} {gn hx} {0} {1} {2} {3} {4} {5} {6} {7} {8} {9} {10} {11} {12}
	{13} {14} {15} {16} {17} {18} {19} {gn} {0 wh} {1 wh} {2 wh} {3 wh}
	{4 wh} {5 wh} {6 wh} {7 wh} {8 wh} {9 wh} {10 wh} {11 wh} {12 wh}
	{13 wh} {14 wh} {gn wh} {0 bl} {1 bl} {2 bl} {3 bl} {4 bl} {5 bl} {6 bl}
	{7 bl} {8 bl} {9 bl} {10 bl} {11 bl} {12 bl} {13 bl} {14 bl} {gn bl}
	{0 fl} {1 fl} {2 fl} {3 fl} {4 fl} {5 fl} {6 fl} {7 fl} {8 fl} {9 fl}
	{10 fl} {11 fl} {12 fl} {13 fl} {14 fl} {gn fl}
	] def
	/sl FMLOCAL
	/val FMLOCAL
	/ws FMLOCAL
	/im FMLOCAL
	/bs FMLOCAL
	/cs FMLOCAL
	/len FMLOCAL
	/pos FMLOCAL
/ms { 
	/sl exch def 
	/val 255 def 
	/ws cfs 
	/im cfs 
	/val 0 def 
	/bs cfs 
	/cs cfs 
	} bind def
400 ms 
/ip { 
	is 
	0 
	cf cs readline pop 
	{	ic exch get exec 
		add 
		} forall 
	pop 
	
	} bind def
/rip { 
	   
	  
	  bis ris copy pop 
      is
      0
      cf cs readline pop 
      {       ic exch get exec 
              add 
              } forall 
	  pop pop 
	  ris gis copy pop 
	  dup is exch 
	  
      cf cs readline pop 
      {       ic exch get exec 
              add 
              } forall 
	  pop pop
	  gis bis copy pop 
	  dup add is exch 
	  
      cf cs readline pop 
      {       ic exch get exec 
              add 
              } forall 
      pop 
      
      } bind def
/wh { 
	/len exch def 
	/pos exch def 
	ws 0 len getinterval im pos len getinterval copy pop
	pos len 
	} bind def
/bl { 
	/len exch def 
	/pos exch def 
	bs 0 len getinterval im pos len getinterval copy pop
	pos len 
	} bind def
/s1 1 string def
/fl { 
	/len exch def 
	/pos exch def 
	/val cf s1 readhexstring pop 0 get def
	pos 1 pos len add 1 sub {im exch val put} for
	pos len 
	} bind def
/hx { 
	3 copy getinterval 
	cf exch readhexstring pop pop 
	} bind def
	/h FMLOCAL
	/w FMLOCAL
	/d FMLOCAL
	/lb FMLOCAL
	/bitmapsave FMLOCAL
	/is FMLOCAL
	/cf FMLOCAL
/wbytes { 
      dup dup
      24 eq { pop pop 3 mul }
      { 8 eq {pop} {1 eq {7 add 8 idiv} {3 add 4 idiv} ifelse} ifelse } ifelse
	} bind def
/BEGINBITMAPBWc { 
	1 {} COMMONBITMAPc
	} bind def
/BEGINBITMAPGRAYc { 
	8 {} COMMONBITMAPc
	} bind def
/BEGINBITMAP2BITc { 
	2 {} COMMONBITMAPc
	} bind def
/COMMONBITMAPc { 
		 
	/r exch def
	/d exch def
	gsave
	
	3 index 2 div add exch	
	4 index 2 div add exch	
	translate		
	rotate			
	1 index 2 div neg	
	1 index 2 div neg	
	translate		
	scale			
	/h exch def /w exch def
	/lb w d wbytes def 
	sl lb lt {lb ms} if 
	/bitmapsave save def 
	r                    
	/is im 0 lb getinterval def 
	ws 0 lb getinterval is copy pop 
	/cf currentfile def 
	w h d [w 0 0 h neg 0 h] 
	{ip} image 
	bitmapsave restore 
	grestore
	} bind def
/BEGINBITMAPBW { 
	1 {} COMMONBITMAP
	} bind def
/BEGINBITMAPGRAY { 
	8 {} COMMONBITMAP
	} bind def
/BEGINBITMAP2BIT { 
	2 {} COMMONBITMAP
	} bind def
/COMMONBITMAP { 
	/r exch def
	/d exch def
	gsave
	
	3 index 2 div add exch	
	4 index 2 div add exch	
	translate		
	rotate			
	1 index 2 div neg	
	1 index 2 div neg	
	translate		
	scale			
	/h exch def /w exch def
	/bitmapsave save def 
	r                    
	/is w d wbytes string def
	/cf currentfile def 
	w h d [w 0 0 h neg 0 h] 
	{cf is readhexstring pop} image
	bitmapsave restore 
	grestore
	} bind def
/ngrayt 256 array def
/nredt 256 array def
/nbluet 256 array def
/ngreent 256 array def
	/gryt FMLOCAL
	/blut FMLOCAL
	/grnt FMLOCAL
	/redt FMLOCAL
	/indx FMLOCAL
	/cynu FMLOCAL
	/magu FMLOCAL
	/yelu FMLOCAL
	/k FMLOCAL
	/u FMLOCAL
FMLevel1 {
/colorsetup {
	currentcolortransfer
	/gryt exch def
	/blut exch def
	/grnt exch def
	/redt exch def
	0 1 255 {
		/indx exch def
		/cynu 1 red indx get 255 div sub def
		/magu 1 green indx get 255 div sub def
		/yelu 1 blue indx get 255 div sub def
		/k cynu magu min yelu min def
		/u k currentundercolorremoval exec def
%		/u 0 def
		nredt indx 1 0 cynu u sub max sub redt exec put
		ngreent indx 1 0 magu u sub max sub grnt exec put
		nbluet indx 1 0 yelu u sub max sub blut exec put
		ngrayt indx 1 k currentblackgeneration exec sub gryt exec put
	} for
	{255 mul cvi nredt exch get}
	{255 mul cvi ngreent exch get}
	{255 mul cvi nbluet exch get}
	{255 mul cvi ngrayt exch get}
	setcolortransfer
	{pop 0} setundercolorremoval
	{} setblackgeneration
	} bind def
}
{
/colorSetup2 {
	[ /Indexed /DeviceRGB 255 
		{dup red exch get 255 div 
		 exch dup green exch get 255 div 
		 exch blue exch get 255 div}
	] setcolorspace
} bind def
} ifelse
	/tran FMLOCAL
/fakecolorsetup {
	/tran 256 string def
	0 1 255 {/indx exch def 
		tran indx
		red indx get 77 mul
		green indx get 151 mul
		blue indx get 28 mul
		add add 256 idiv put} for
	currenttransfer
	{255 mul cvi tran exch get 255.0 div}
	exch concatprocs settransfer
} bind def
/BITMAPCOLOR { 
	/d 8 def
	gsave
	
	3 index 2 div add exch	
	4 index 2 div add exch	
	translate		
	rotate			
	1 index 2 div neg	
	1 index 2 div neg	
	translate		
	scale			
	/h exch def /w exch def
	/bitmapsave save def
	FMLevel1 {	
		colorsetup
		/is w d wbytes string def
		/cf currentfile def 
		w h d [w 0 0 h neg 0 h] 
		{cf is readhexstring pop} {is} {is} true 3 colorimage 
	} {
		colorSetup2
		/is w d wbytes string def
		/cf currentfile def 
		7 dict dup begin
			/ImageType 1 def
			/Width w def
			/Height h def
			/ImageMatrix [w 0 0 h neg 0 h] def
			/DataSource {cf is readhexstring pop} bind def
			/BitsPerComponent d def
			/Decode [0 255] def
		end image	
	} ifelse
	bitmapsave restore 
	grestore
	} bind def
/BITMAPCOLORc { 
	/d 8 def
	gsave
	
	3 index 2 div add exch	
	4 index 2 div add exch	
	translate		
	rotate			
	1 index 2 div neg	
	1 index 2 div neg	
	translate		
	scale			
	/h exch def /w exch def
	/lb w d wbytes def 
	sl lb lt {lb ms} if 
	/bitmapsave save def 
	FMLevel1 {	
		colorsetup
		/is im 0 lb getinterval def 
		ws 0 lb getinterval is copy pop 
		/cf currentfile def 
		w h d [w 0 0 h neg 0 h] 
		{ip} {is} {is} true 3 colorimage
	} {
		colorSetup2
		/is im 0 lb getinterval def 
		ws 0 lb getinterval is copy pop 
		/cf currentfile def 
		7 dict dup begin
			/ImageType 1 def
			/Width w def
			/Height h def
			/ImageMatrix [w 0 0 h neg 0 h] def
			/DataSource {ip} bind def
			/BitsPerComponent d def
			/Decode [0 255] def
		end image	
	} ifelse
	bitmapsave restore 
	grestore
	} bind def
/BITMAPTRUECOLORc { 
	/d 24 def
        gsave
 	
	3 index 2 div add exch	
	4 index 2 div add exch	
	translate		
	rotate			
	1 index 2 div neg	
	1 index 2 div neg	
	translate		
	scale			
	/h exch def /w exch def
	/lb w d wbytes def 
	sl lb lt {lb ms} if 
        /bitmapsave save def 
        
	/is im 0 lb getinterval def	
	/ris im 0 w getinterval def	
	/gis im w w getinterval def	
	/bis im w 2 mul w getinterval def 
        
        ws 0 lb getinterval is copy pop 
        /cf currentfile def 
        w h 8 [w 0 0 h neg 0 h] 
        {w rip pop ris} {gis} {bis} true 3 colorimage
        bitmapsave restore 
        grestore
        } bind def
/BITMAPTRUECOLOR { 
        gsave
		
		3 index 2 div add exch	
		4 index 2 div add exch	
		translate		
		rotate			
		1 index 2 div neg	
		1 index 2 div neg	
		translate		
		scale			
		/h exch def /w exch def
        /bitmapsave save def 
        /is w string def
        /gis w string def
        /bis w string def
        /cf currentfile def 
        w h 8 [w 0 0 h neg 0 h] 
        { cf is readhexstring pop } 
        { cf gis readhexstring pop } 
        { cf bis readhexstring pop } 
        true 3 colorimage 
        bitmapsave restore 
        grestore
        } bind def
/BITMAPTRUEGRAYc { 
	/d 24 def
        gsave
	
	3 index 2 div add exch	
	4 index 2 div add exch	
	translate		
	rotate			
	1 index 2 div neg	
	1 index 2 div neg	
	translate		
	scale			
	/h exch def /w exch def
	/lb w d wbytes def 
	sl lb lt {lb ms} if 
        /bitmapsave save def 
        
	/is im 0 lb getinterval def	
	/ris im 0 w getinterval def	
	/gis im w w getinterval def	
	/bis im w 2 mul w getinterval def 
        ws 0 lb getinterval is copy pop 
        /cf currentfile def 
        w h 8 [w 0 0 h neg 0 h] 
        {w rip pop ris gis bis w gray} image
        bitmapsave restore 
        grestore
        } bind def
/ww FMLOCAL
/r FMLOCAL
/g FMLOCAL
/b FMLOCAL
/i FMLOCAL
/gray { 
        /ww exch def
        /b exch def
        /g exch def
        /r exch def
        0 1 ww 1 sub { /i exch def r i get .299 mul g i get .587 mul
			b i get .114 mul add add r i 3 -1 roll floor cvi put } for
        r
        } bind def
/BITMAPTRUEGRAY { 
        gsave
		
		3 index 2 div add exch	
		4 index 2 div add exch	
		translate		
		rotate			
		1 index 2 div neg	
		1 index 2 div neg	
		translate		
		scale			
		/h exch def /w exch def
        /bitmapsave save def 
        /is w string def
        /gis w string def
        /bis w string def
        /cf currentfile def 
        w h 8 [w 0 0 h neg 0 h] 
        { cf is readhexstring pop 
          cf gis readhexstring pop 
          cf bis readhexstring pop w gray}  image
        bitmapsave restore 
        grestore
        } bind def
/BITMAPGRAY { 
	8 {fakecolorsetup} COMMONBITMAP
	} bind def
/BITMAPGRAYc { 
	8 {fakecolorsetup} COMMONBITMAPc
	} bind def
/ENDBITMAP {
	} bind def
end 
	/ALDsave FMLOCAL
	/ALDmatrix matrix def ALDmatrix currentmatrix pop
/StartALD {
	/ALDsave save def
	 savematrix
	 ALDmatrix setmatrix
	} bind def
/InALD {
	 restorematrix
	} bind def
/DoneALD {
	 ALDsave restore
	} bind def
/I { setdash } bind def
/J { [] 0 setdash } bind def
%%EndProlog
%%BeginSetup
(4.0) FMVERSION
1 1 0 0 612 792 0 1 16 FMDOCUMENT
0 0 /NewCenturySchlbk-Roman FMFONTDEFINE
1 1 /ZapfDingbats FMFONTDEFINE
2 0 /Helvetica-Bold FMFONTDEFINE
3 0 /Courier FMFONTDEFINE
4 0 /NewCenturySchlbk-Bold FMFONTDEFINE
5 0 /Courier-Bold FMFONTDEFINE
6 0 /NewCenturySchlbk-Italic FMFONTDEFINE
7 0 /Courier-Oblique FMFONTDEFINE
32 FMFILLS
0 0 FMFILL
1 0.1 FMFILL
2 0.3 FMFILL
3 0.5 FMFILL
4 0.7 FMFILL
5 0.9 FMFILL
6 0.97 FMFILL
7 1 FMFILL
8 <0f1e3c78f0e1c387> FMFILL
9 <0f87c3e1f0783c1e> FMFILL
10 <cccccccccccccccc> FMFILL
11 <ffff0000ffff0000> FMFILL
12 <8142241818244281> FMFILL
13 <03060c183060c081> FMFILL
14 <8040201008040201> FMFILL
16 1 FMFILL
17 0.9 FMFILL
18 0.7 FMFILL
19 0.5 FMFILL
20 0.3 FMFILL
21 0.1 FMFILL
22 0.03 FMFILL
23 0 FMFILL
24 <f0e1c3870f1e3c78> FMFILL
25 <f0783c1e0f87c3e1> FMFILL
26 <3333333333333333> FMFILL
27 <0000ffff0000ffff> FMFILL
28 <7ebddbe7e7dbbd7e> FMFILL
29 <fcf9f3e7cf9f3f7e> FMFILL
30 <7fbfdfeff7fbfdfe> FMFILL
%%EndSetup
%%Page: "301" 1
%%BeginPaperSize: Letter
%%EndPaperSize
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
J
0 0 0 1 0 0 0 K
162 690.34 558 702 R
7 X
0 0 0 1 0 0 0 K
V
162 666.34 558 678.01 R
V
0 10 Q
0 X
(301) 541.32 671.34 T
324 684 580 684 2 L
7 X
V
3 H
2 Z
0 X
N
512 90 558 125 R
7 X
V
1 60 Q
0 X
(n) 512.17 85 T
315 104 510 126 R
7 X
V
2 24 Q
0 X
(Routines) 407.33 110 T
90 99 270 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
90.67 123.5 270.67 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
81 642.99 531 648 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 642.99 531 648 R
7 X
0 0 0 1 0 0 0 K
V
50 646.99 609.01 646.99 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 634.99 T
2 F
(MakeWWFixed\050\051) 99 634.99 T
3 10 Q
(WWFixed MakeWWFixed\050number\051;) 99 620.33 T
0 F
(This macro casts a \337oating-point or integer number to a) 180 602.33 T
4 F
(WWFixed) 440.77 602.33 T
0 F
( value.) 489.83 602.33 T
2 F
(Include:) 99 583.83 T
0 F
(geos.h) 180 583.83 T
81 567.48 531 572.49 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 567.48 531 572.49 R
7 X
0 0 0 1 0 0 0 K
V
50 571.48 609.01 571.48 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 559.48 T
2 F
(malloc\050\051) 99 559.48 T
5 10 Q
(void) 99 544.82 T
3 F
(* malloc\050) 153 544.82 T
3 9 Q
(size_t) 153 534.48 T
(blockSize\051;) 261 534.48 T
(/* # of bytes to allocate*/) 333 534.48 T
0 10 Q
(The) 180 516.82 T
4 F
(malloc\050\051) 200.56 516.82 T
0 F
( family of routines is provided for Standard C compatibility) 242.79 516.82 T
(. If) 515.04 516.82 T
-0.5 (a geode needs a small amount of \336xed memory) 180 505.32 P
-0.5 (, it can call one of the routines.) 389.95 505.32 P
-0.65 (The kernel will allocate a \336xed block to satisfy the geode\325) 180 493.82 P
-0.65 (s) 435.73 493.82 P
4 F
-0.68 (malloc\050\051) 442.48 493.82 P
0 F
-0.65 ( requests;) 484.71 493.82 P
(it will allocate memory from this block. When the block is \336lled, it will) 180 482.32 T
(allocate another \336xed malloc-block. When all the memory in the block is) 180 470.82 T
(freed, the memory manager will automatically free the block.) 180 459.32 T
-0.5 (When a geode calls) 180 440.82 P
4 F
-0.52 (malloc\050\051) 268.73 440.82 P
0 F
-0.5 (, a section of memory of the size speci\336ed will be) 310.96 440.82 P
(allocated out of its malloc-block, and the address of the start of the memory) 180 429.32 T
(will be returned. The memory will) 180 417.82 T
6 F
(not) 340.58 417.82 T
0 F
( be zero-initialized. If the request) 355.21 417.82 T
(cannot be satis\336ed,) 180 406.32 T
4 F
(malloc) 271.5 406.32 T
0 F
( will return a null pointer) 305.95 406.32 T
(. The memory is) 423.74 406.32 T
(guaranteed not to be moved until it is freed \050with) 180 394.82 T
4 F
(free\050\051) 410.03 394.82 T
0 F
(\051 or resized \050with) 438.37 394.82 T
4 F
(realloc\050\051) 180 383.32 T
0 F
(\051. When) 223.53 383.32 T
0 9 Q
(GEOS) 262.23 383.32 T
0 10 Q
( shuts down, all \336xed blocks are freed, and any) 288.4 383.32 T
(memory allocated with) 180 371.82 T
4 F
(malloc\050\051) 288.35 371.82 T
0 F
( is lost.) 330.58 371.82 T
(Using too many \336xed blocks degrades the memory manager) 180 353.32 T
(\325) 455.95 353.32 T
(s performance,) 457.62 353.32 T
(slowing the whole system. For this reason, applications should not use) 180 341.82 T
4 F
(malloc) 180 330.32 T
0 F
(-family routines if they can possibly be avoided. They are provided) 214.45 330.32 T
(only to simplify porting of existing programs; however) 180 318.82 T
(, applications should) 428.9 318.82 T
-0.62 (make every effort to use the) 180 307.32 P
0 9 Q
-0.56 (GEOS) 308.15 307.32 P
0 10 Q
-0.62 ( memory management and LMem routines) 334.32 307.32 P
-0.66 (instead. If you must use the) 180 295.82 P
4 F
-0.68 (malloc) 307.71 295.82 P
0 F
-0.66 (-family routines, use them sparingly) 342.17 295.82 P
-0.66 (, and) 506.57 295.82 P
(free the memory as quickly as possible.) 180 284.32 T
2 F
(T) 99 265.82 T
(ips and T) 104.93 265.82 T
(ricks:) 148.28 265.82 T
0 F
(Y) 180 265.82 T
(ou can allocate memory in another geode\325) 185.93 265.82 T
(s malloc-block by calling) 376.32 265.82 T
4 F
(GeoMalloc\050\051) 180 252.82 T
0 F
(. However) 242.59 252.82 T
(, that block will be freed when the other geode exits.) 288.33 252.82 T
2 F
(W) 99 232.82 T
(arnings:) 108.07 232.82 T
0 F
(All memory allocated with) 180 232.82 T
4 F
(malloc\050\051) 304.65 232.82 T
0 F
( is freed when) 346.88 232.82 T
0 9 Q
(GEOS) 414.29 232.82 T
0 10 Q
( shuts down.) 440.46 232.82 T
2 F
(Include:) 99 212.82 T
0 F
(stdlib.h) 180 212.82 T
2 F
(See Also:) 99 192.82 T
0 F
(calloc\050\051, free\050\051, GeoMalloc\050\051, realloc\050\051) 180 192.82 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "301" 1
%%Page: "302" 2
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
54 690.34 450 702 R
7 X
0 0 0 1 0 0 0 K
V
54 666.34 450 678.01 R
V
0 10 Q
0 X
(302) 54 671.34 T
32 684 288 684 2 L
7 X
V
3 H
2 Z
0 X
N
54 90 108 125 R
7 X
V
1 60 Q
0 X
(n) 58.17 85 T
104 104 299 126 R
7 X
V
2 24 Q
0 X
(Routines) 104 110 T
306 99 486 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
306 123.5 486 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
81 642.99 531 648 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 642.99 531 648 R
7 X
0 0 0 1 0 0 0 K
V
50 646.99 609.01 646.99 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 634.99 T
2 F
(ManufacturerFromFormatID) 99 634.99 T
5 10 Q
(word) 99 621.33 T
3 F
(ManufacturerFromFormatID\050) 153 621.33 T
7 F
(id) 303 621.33 T
3 F
(\051;) 315 621.33 T
3 9 Q
(ClipboardItemFormatID) 153 610.99 T
7 F
(id) 271.8 610.99 T
3 F
(;) 282.6 610.99 T
0 10 Q
(This macro extracts the word-sized manufacturer) 180 593.33 T
0 9 Q
(ID) 411.29 593.33 T
0 10 Q
( \050of type) 421.95 593.33 T
4 F
(Manufacturer) 180 581.83 T
4 9 Q
(ID) 252.41 581.83 T
4 10 Q
(s) 263.9 581.83 T
0 F
(\051 from a) 268.9 581.83 T
4 F
(ClipboardInfoFormat) 307.79 581.83 T
4 9 Q
(ID) 419.83 581.83 T
0 10 Q
( argument.) 431.33 581.83 T
81 566.98 531 571.99 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 566.98 531 571.99 R
7 X
0 0 0 1 0 0 0 K
V
50 570.98 609.01 570.98 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 558.98 T
2 F
(MemAlloc\050\051) 99 558.98 T
5 10 Q
(MemHandle) 99 544.32 T
3 F
( MemAlloc\050) 153 544.32 T
3 9 Q
(word) 153 533.98 T
(byteSize,) 261 533.98 T
(/* Size of block in bytes */) 333 533.98 T
(HeapFlags) 153 523.98 T
(hfFlags,) 261 523.98 T
(/* Type of block */) 333 523.98 T
(HeapAllocFlags) 153 513.98 T
(haFlags\051;) 261 513.98 T
(/* How to allocate block */) 333 513.98 T
0 10 Q
-0.75 (This routine allocates a global memory block and creates an entry for it in the) 180 496.32 P
(global handle table. The properties of the block are determined by the) 180 484.82 T
4 F
(HeapFlags) 180 473.32 T
0 F
( record passed; the way the block should be allocated is) 235.18 473.32 T
-0.08 (determined by the) 180 461.82 P
4 F
-0.08 (HeapAllocFlags) 266.99 461.82 P
0 F
-0.08 ( record. Both sets of \337ags are described) 348.48 461.82 P
(below) 180 450.32 T
(. The routine returns the block\325) 205.57 450.32 T
(s handle. If it could not allocate the) 349.1 450.32 T
(block, it returns a null handle. The block allocated may be larger than the) 180 438.82 T
(size requested, as the block size is rounded up to the next even paragraph) 180 427.32 T
(\050one paragraph equals sixteen bytes\051.) 180 415.82 T
4 F
(HeapFlags) 180 397.32 T
0 F
( are stored in the block\325) 235.18 397.32 T
(s handle table entry) 342.79 397.32 T
(. They can be) 434.29 397.32 T
(retrieved with the routine) 180 385.82 T
4 F
(MemGetInfo\050\051) 302.78 385.82 T
0 F
(; some of them can be changed) 375.36 385.82 T
(with the routine) 180 374.32 T
4 F
(MemModifyFlags\050\051) 257.97 374.32 T
0 F
(. The following \337ags are available:) 355.18 374.32 T
0 9 Q
(HF_FIXED) 180 355.82 T
0 10 Q
-0.05 (The block will not move from its place in the global heap until) 243 344.82 P
-0.65 (it is freed. If this \337ag is off, the memory manager may move the) 243 333.82 P
-0.51 (block while it is unlocked. If the \337ag is on, the block may not be) 243 322.82 P
-0.31 (locked, and) 243 311.82 P
0 9 Q
-0.28 (HF_DISCARDABLE) 297.39 311.82 P
0 10 Q
-0.31 ( and) 383.72 311.82 P
0 9 Q
-0.28 (HF_SW) 406.07 311.82 P
-0.28 (AP) 437.74 311.82 P
-0.28 (ABLE) 449.57 311.82 P
0 10 Q
-0.31 ( must be off.) 475.07 311.82 P
0 9 Q
(HF_SHARABLE) 180 293.82 T
0 10 Q
(The block may be locked by threads belonging to geodes other) 243 282.82 T
(than the block\325) 243 271.82 T
(s owner) 310.98 271.82 T
(.) 345.98 271.82 T
0 9 Q
(HF_DISCARDABLE) 180 253.82 T
0 10 Q
(The block may be discarded when unlocked.) 243 242.82 T
0 9 Q
(HF_SW) 180 224.82 T
(AP) 211.67 224.82 T
(ABLE) 223.51 224.82 T
0 10 Q
-0.59 (The block may be swapped to extended/expanded memory or to) 243 213.82 P
(the disk swap space when it is unlocked.) 243 202.82 T
0 9 Q
(HF_LMEM) 180 184.82 T
0 10 Q
(The block contains a local memory heap. This \337ag is set) 243 173.82 T
(automatically by) 243 162.82 T
4 F
(LMemInitHeap\050\051) 323.21 162.82 T
0 F
( and) 409.86 162.82 T
4 F
(VMAllocLMem\050\051) 432.83 162.82 T
0 F
(;) 516.71 162.82 T
(applications should not need to set this \337ag.) 243 151.82 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "302" 2
%%Page: "303" 3
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
162 690.34 558 702 R
7 X
0 0 0 1 0 0 0 K
V
162 666.34 558 678.01 R
V
0 10 Q
0 X
(303) 541.32 671.34 T
324 684 580 684 2 L
7 X
V
3 H
2 Z
0 X
N
512 90 558 125 R
7 X
V
1 60 Q
0 X
(n) 512.17 85 T
315 104 510 126 R
7 X
V
2 24 Q
0 X
(Routines) 407.33 110 T
90 99 270 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
90.67 123.5 270.67 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
0 9 Q
0 X
(HF_DISCARDED) 180 641.33 T
0 10 Q
(The memory manager turns this bit on when it discards a) 243 630.33 T
(block. The bit is turned off when the block is reallocated.) 243 619.33 T
0 9 Q
(HF_SW) 180 601.33 T
(APPED) 211.67 601.33 T
0 10 Q
(The memory manager turns this bit on when it swaps a block) 243 590.33 T
(to extended/expanded memory or to the disk swap space. It) 243 579.33 T
(turns the bit off when it swaps the block back into the global) 243 568.33 T
(heap.) 243 557.33 T
4 F
-0.32 (HeapAllocFlags) 180 539.33 P
0 F
-0.31 ( indicate how the block should be allocated and initialized.) 261.48 539.33 P
-0.46 (They are not stored and can not be retrieved. Some of the \337ags can be passed) 180 527.83 P
(with) 180 516.33 T
4 F
(MemReAlloc\050\051) 203.71 516.33 T
0 F
(. The following \337ags are available:) 276.86 516.33 T
0 9 Q
(HAF_ZERO_INIT) 180 497.83 T
0 10 Q
-0.17 (The memory manager should initialize the block to null bytes.) 243 486.83 P
(This \337ag may be passed to) 243 475.83 T
4 F
(MemReAlloc\050\051) 367.85 475.83 T
0 F
( to cause new) 441 475.83 T
(memory to be zero-initialized.) 243 464.83 T
0 9 Q
(HAF_LOCK) 180 446.83 T
0 10 Q
-0.19 (The memory manager should lock the block after allocating it.) 243 446.83 P
-0.04 (T) 243 435.83 P
-0.04 (o get the block\325) 248.75 435.83 P
-0.04 (s address, call) 316.99 435.83 P
4 F
-0.04 (MemDeref\050\051) 384.67 435.83 P
0 F
-0.04 (. This \337ag may be) 446.52 435.83 P
(passed to) 243 424.83 T
4 F
(MemReAlloc\050\051) 288.75 424.83 T
0 F
(.) 361.9 424.83 T
0 9 Q
(HAF_NO_ERR) 180 406.83 T
0 10 Q
(The memory manager should not return errors. If it cannot) 243 395.83 T
(allocate block,) 243 384.83 T
0 9 Q
(GEOS) 311.17 384.83 T
0 10 Q
( will crash. Use of this \337ag is strongly) 337.34 384.83 T
(discouraged. This \337ag may be passed to) 243 373.83 T
4 F
(MemReAlloc\050\051) 428.59 373.83 T
0 F
(.) 501.74 373.83 T
0 9 Q
(HAF_UI) 180 355.83 T
0 10 Q
(If both) 243 355.83 T
0 9 Q
(HAF_OBJECT_RESOURCE) 276.52 355.83 T
0 10 Q
( and) 395.52 355.83 T
0 9 Q
(HAF_UI) 418.49 355.83 T
0 10 Q
( are set, this) 453.98 355.83 T
(block will be run by the application\325) 243 344.83 T
(s) 407.3 344.83 T
0 9 Q
(UI) 414.71 344.83 T
0 10 Q
( thread.) 425.71 344.83 T
0 9 Q
(HAF_READ_ONL) 180 326.83 T
(Y) 255.01 326.83 T
0 10 Q
(The block\325) 243 315.83 T
(s data will not be modi\336ed. Useful for the debugger) 289.31 315.83 T
(.) 524.9 315.83 T
0 9 Q
(HAF_OBJECT_RESOURCE) 180 297.83 T
0 10 Q
(This block will be an object block.) 243 286.83 T
0 9 Q
(HAF_CODE) 180 268.83 T
0 10 Q
(This block contains executable code.) 243 268.83 T
0 9 Q
(HAF_CONFORMING) 180 250.83 T
0 10 Q
(If the block contains code, the code may be run by a less) 243 239.83 T
(privileged entity) 243 228.83 T
(. If the block contains data, the data may be) 318.19 228.83 T
(accessed or altered by a less privileged entity) 243 217.83 T
(.) 450.43 217.83 T
2 F
(Include:) 99 199.83 T
0 F
(heap.h) 180 199.83 T
2 F
(See Also:) 99 179.83 T
0 F
(MemAllocSetOwner\050\051, MemReAlloc\050\051, MemDeref\050\051) 180 179.83 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "303" 3
%%Page: "304" 4
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
54 690.34 450 702 R
7 X
0 0 0 1 0 0 0 K
V
54 666.34 450 678.01 R
V
0 10 Q
0 X
(304) 54 671.34 T
32 684 288 684 2 L
7 X
V
3 H
2 Z
0 X
N
54 90 108 125 R
7 X
V
1 60 Q
0 X
(n) 58.17 85 T
104 104 299 126 R
7 X
V
2 24 Q
0 X
(Routines) 104 110 T
306 99 486 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
306 123.5 486 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
81 642.99 531 648 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 642.99 531 648 R
7 X
0 0 0 1 0 0 0 K
V
50 646.99 609.01 646.99 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 634.99 T
2 F
(MemAllocLMem\050\051) 99 634.99 T
5 10 Q
(MemHandle) 99 621.33 T
3 F
( MemAllocLMem\050) 153 621.33 T
3 9 Q
(LMemType) 153 610.99 T
(type,) 261 610.99 T
(/* type of LMem block */) 333 610.99 T
(word) 153 600.99 T
(headerSize\051;) 261 600.99 T
(/* size of header structure */) 333 600.99 T
0 10 Q
-0.08 (This routine allocates and initializes a local memory block; it can be used to) 180 583.33 P
-0.65 (simplify this procedure from the two-step process of) 180 571.83 P
4 F
-0.67 (MemAlloc\050\051) 416.27 571.83 P
0 F
-0.65 ( followed by) 475.53 571.83 P
4 F
-0.49 (LMemInitHeap\050\051) 180 560.33 P
0 F
-0.48 (. Pass an LMem type indicating what will be stored in the) 266.65 560.33 P
-0.74 (block, along with the size of the header structure to use. If the block is to have) 180 548.83 P
(the standard header) 180 537.33 T
(, pass zero in) 273.34 537.33 T
6 F
(headerSize) 336.31 537.33 T
0 F
(.) 386.66 537.33 T
(This routine returns the handle of the unlocked, newly allocated block. The) 180 518.83 T
(block will contain two LMem handles and 64 bytes allocated for the LMem) 180 507.33 T
(heap.) 180 495.83 T
2 F
(Include:) 99 477.33 T
0 F
(lmem.h) 180 477.33 T
2 F
(See Also:) 99 457.33 T
0 F
(LMemInitHeap\050\051) 180 457.33 T
81 440.98 531 445.99 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 440.98 531 445.99 R
7 X
0 0 0 1 0 0 0 K
V
50 444.98 609.01 444.98 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 432.98 T
2 F
(MemAllocSetOwner\050\051) 99 432.98 T
5 10 Q
(MemHandle) 99 418.32 T
3 F
( MemAllocSetOwner\050) 153 418.32 T
3 9 Q
(GeodeHandle) 153 407.98 T
(owner,) 261 407.98 T
(/* Handle of block\325s owner */) 333 407.98 T
(word) 153 397.98 T
(byteSize,) 261 397.98 T
(/* Size of block in bytes */) 333 397.98 T
(HeapFlags) 153 387.98 T
(hfFlags,) 261 387.98 T
(/* Type of block */) 333 387.98 T
(HeapAllocFlags) 153 377.98 T
(haFlags\051;) 261 377.98 T
(/* How to allocate block */) 333 377.98 T
0 10 Q
(This routine is the same as) 180 360.32 T
4 F
(MemAlloc\050\051) 307.99 360.32 T
0 F
( except that you can specify the) 367.25 360.32 T
(owner of the global memory block created.) 180 348.82 T
2 F
(Include:) 99 330.32 T
0 F
(heap.h) 180 330.32 T
2 F
(See Also:) 99 310.32 T
0 F
(MemAlloc\050\051) 180 310.32 T
81 293.98 531 298.98 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 293.98 531 298.98 R
7 X
0 0 0 1 0 0 0 K
V
50 297.98 609.01 297.98 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 285.98 T
2 F
(MemDecRefCount\050\051) 99 285.98 T
5 10 Q
(void) 99 271.31 T
3 F
(MemDecRefCount\050) 153 271.31 T
3 9 Q
(MemHandle) 153 260.97 T
(mh\051;) 261 260.97 T
(/* handle of affected block */) 333 260.97 T
0 10 Q
(This routine decrements the reference count of a global memory block \050the) 180 243.31 T
(reference count is stored in) 180 231.81 T
6 9 Q
(HM) 307.95 231.81 T
6 10 Q
(_otherInfo) 323.94 231.81 T
0 F
(\051. If the reference count reaches) 370.96 231.81 T
(zero,) 180 220.31 T
4 F
(MemDecRefCount\050\051) 204.81 220.31 T
0 F
( will free the block.) 307.03 220.31 T
2 F
(W) 99 201.81 T
(arnings:) 108.07 201.81 T
0 F
(This routine assumes that a reference count is stored in) 180 201.81 T
6 9 Q
(HM) 440.57 201.81 T
6 10 Q
(_otherInfo) 456.56 201.81 T
0 F
(. Y) 503.58 201.81 T
(ou) 515.07 201.81 T
(may only use this routine if the block has had a reference count set up with) 180 188.81 T
4 F
(MemInitRefCount\050\051) 180 175.81 T
0 F
(.) 281.84 175.81 T
2 F
(Include:) 99 155.81 T
0 F
(heap.h) 180 155.81 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "304" 4
%%Page: "305" 5
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
162 690.34 558 702 R
7 X
0 0 0 1 0 0 0 K
V
162 666.34 558 678.01 R
V
0 10 Q
0 X
(305) 541.32 671.34 T
324 684 580 684 2 L
7 X
V
3 H
2 Z
0 X
N
512 90 558 125 R
7 X
V
1 60 Q
0 X
(n) 512.17 85 T
315 104 510 126 R
7 X
V
2 24 Q
0 X
(Routines) 407.33 110 T
90 99 270 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
90.67 123.5 270.67 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
81 642.99 531 648 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 642.99 531 648 R
7 X
0 0 0 1 0 0 0 K
V
50 646.99 609.01 646.99 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 634.99 T
2 F
(MemDeref\050\051) 99 634.99 T
5 10 Q
(void) 99 620.33 T
3 F
(* MemDeref\050) 153 620.33 T
3 9 Q
(MemHandle) 153 609.99 T
(mh\051;) 261 609.99 T
(/* Handle of locked block to dereference */) 297 609.99 T
0 10 Q
(This routine takes one argument, the handle of a global memory block; it) 180 592.33 T
(returns the address of the block on the global heap. If the block has been) 180 580.83 T
-0.13 (discarded, or if the handle is not a memory handle, it returns a null pointer) 180 569.33 P
-0.13 (.) 525.57 569.33 P
-0.26 (It gets this information by reading the block\325) 180 557.83 P
-0.26 (s handle table entry; it does not) 383.92 557.83 P
(need to actually access the block.) 180 546.33 T
-0.1 (Note that if the handle is of an unlocked, moveable block,) 180 527.83 P
4 F
-0.1 (MemDeref\050\051) 446.56 527.83 P
0 F
-0.1 ( will) 508.41 527.83 P
(return the block\325) 180 516.33 T
(s address with out any warning; however) 256.3 516.33 T
(, the address will) 445.58 516.33 T
(be unreliable, since the memory manager can move the block at any time.) 180 504.83 T
2 F
(Include:) 99 486.33 T
0 F
(heap.h) 180 486.33 T
2 F
(T) 99 466.33 T
(ips and T) 104.93 466.33 T
(ricks:) 148.28 466.33 T
0 F
-0.21 (This is very useful when you allocate a \336xed or locked block, and need to get) 180 466.33 P
(the block\325) 180 453.33 T
(s address without calling) 223.53 453.33 T
4 F
(MemLock\050\051) 341.88 453.33 T
0 F
(.) 400.4 453.33 T
2 F
(W) 99 433.33 T
(arnings:) 108.07 433.33 T
0 F
(This routine, if given an unlocked, moveable block, will return the pointer) 180 433.33 T
(without a warning, even though that block may move at any time.) 180 420.33 T
2 F
(See Also:) 99 400.33 T
0 F
(MemGetInfo\050\051, MemModifyFlags\050\051) 180 400.33 T
81 383.98 531 388.99 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 383.98 531 388.99 R
7 X
0 0 0 1 0 0 0 K
V
50 387.98 609.01 387.98 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 375.98 T
2 F
(MemDowngradeExclLock\050\051) 99 375.98 T
5 10 Q
(void) 99 362.32 T
3 F
(MemDowngradeExclLock\050) 153 362.32 T
3 9 Q
(MemHandle) 153 351.98 T
(mh\051;) 261 351.98 T
(/* handle of affected block */) 315 351.98 T
0 10 Q
(An application that has an exclusive lock on a block may downgrade it to a) 180 334.32 T
(shared lock with this routine. It does not otherwise affect the block.) 180 322.82 T
2 F
(Include:) 99 304.32 T
0 F
(heap.h) 180 304.32 T
81 287.98 531 292.98 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 287.98 531 292.98 R
7 X
0 0 0 1 0 0 0 K
V
50 291.98 609.01 291.98 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 279.97 T
2 F
(MemFree\050\051) 99 279.97 T
5 10 Q
(void) 99 265.31 T
3 F
(MemFree\050) 153 265.31 T
3 9 Q
(MemHandle) 153 254.97 T
(mh\051;) 261 254.97 T
(/* handle of block to be freed */) 315 254.97 T
0 10 Q
(This routine frees a global memory block. The block can be locked or) 180 237.31 T
(unlocked.) 180 225.81 T
2 F
(Include:) 99 207.31 T
0 F
(heap.h) 180 207.31 T
2 F
(W) 99 187.31 T
(arnings:) 108.07 187.31 T
0 F
-0.67 (The routine does not care whether other threads have locked the block. If you) 180 187.31 P
(try to free a bad handle, routine may fatal-error) 180 174.31 T
(.) 400.39 174.31 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "305" 5
%%Page: "306" 6
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
54 690.34 450 702 R
7 X
0 0 0 1 0 0 0 K
V
54 666.34 450 678.01 R
V
0 10 Q
0 X
(306) 54 671.34 T
32 684 288 684 2 L
7 X
V
3 H
2 Z
0 X
N
54 90 108 125 R
7 X
V
1 60 Q
0 X
(n) 58.17 85 T
104 104 299 126 R
7 X
V
2 24 Q
0 X
(Routines) 104 110 T
306 99 486 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
306 123.5 486 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
81 642.99 531 648 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 642.99 531 648 R
7 X
0 0 0 1 0 0 0 K
V
50 646.99 609.01 646.99 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 634.99 T
2 F
(MemGetInfo\050\051) 99 634.99 T
5 10 Q
(word) 99 620.33 T
3 F
(MemGetInfo\050) 153 620.33 T
(/* return value depends on flag passed */) 225 620.33 T
3 9 Q
(MemHandle) 153 609.99 T
(mh,) 261 609.99 T
(/* Handle of block to get info about */) 315 609.99 T
(MemGetInfoType) 153 599.99 T
(info\051;) 261 599.99 T
(/* Type of information to get */) 315 599.99 T
4 10 Q
-0.3 (MemGetInfo\050\051) 180 582.33 P
0 F
-0.29 ( is a general-purpose routine for getting information about a) 252.58 582.33 P
-0.37 (global memory block. It gets the information by looking in the block\325) 180 570.83 P
-0.37 (s handle) 489.88 570.83 P
(table entry; it does not need to access the actual block. It returns a single) 180 559.33 T
(word of data; the meaning of that word depends on the value of the) 180 547.83 T
4 F
(MemGetInfoT) 180 536.33 T
(ype) 251.5 536.33 T
0 F
( variable passed. The following types are available:) 270.02 536.33 T
0 9 Q
(MGIT_SIZE) 180 517.83 T
0 10 Q
(Return value is size of the block in bytes. This may be larger) 243 517.83 T
-0.72 (than the size originally requested, as blocks are allocated along) 243 506.83 P
(paragraph boundaries.) 243 495.83 T
0 9 Q
(MGIT_FLAGS_AND_LOCK_COUNT) 180 477.83 T
0 10 Q
(The upper byte of the return value is the current) 243 466.83 T
4 F
(HeapFlags) 471.15 466.83 T
0 F
(record for the block. The lower byte is the number of locks) 243 455.83 T
(currently on the block.) 243 444.83 T
0 9 Q
(MGIT_OWNER_OR_VM_FILE_HANDLE) 180 426.83 T
0 10 Q
(If the block is part of a) 243 415.83 T
0 9 Q
(VM) 350.24 415.83 T
0 10 Q
( \336le, return value is the) 365.23 415.83 T
0 9 Q
(VM) 476.91 415.83 T
0 10 Q
( \336le) 491.91 415.83 T
(handle. Otherwise, return value is the GeodeHandle of the) 243 404.83 T
(owning thread.) 243 393.83 T
0 9 Q
(MGIT_ADDRESS) 180 375.83 T
0 10 Q
-0.17 (Return value is block\325) 243 364.83 P
-0.17 (s segment address on the global heap, or) 342.32 364.83 P
(zero if block has been discarded. If block is unlocked and) 243 353.83 T
(moveable, address may change without warning. Ordinarily) 243 342.83 T
(,) 519.15 342.83 T
4 F
(MemDeref\050\051) 243 331.83 T
0 F
( is preferable.) 304.85 331.83 T
0 9 Q
(MGIT_OTHER_INFO) 180 313.83 T
0 10 Q
-0.62 (Returns the value of the) 243 302.83 P
6 F
-0.62 (HM_otherInfo) 354.72 302.83 P
0 F
-0.62 ( word. This word is used) 419.51 302.83 P
(in different ways for different types of handles.) 243 291.83 T
0 9 Q
(MGIT_EXEC_THREAD) 180 273.83 T
0 10 Q
(Returns the ThreadHandle of the thread executing this block,) 243 262.83 T
(if any) 243 251.83 T
(.) 268.19 251.83 T
2 F
(Include:) 99 233.83 T
0 F
(heap.h) 180 233.83 T
2 F
(W) 99 213.83 T
(arnings:) 108.07 213.83 T
0 F
-0.17 (If the handle is not a global memory block handle, results are unpredictable) 180 213.83 P
(\050the routine will read inappropriate data from the handle table entry\051.) 180 200.83 T
2 F
(See Also:) 99 180.83 T
0 F
(MemDeref\050\051, MemModifyFlags\050\051, MemModifyOtherInfo\050\051,) 180 180.83 T
(HandleModifyOwner\050\051) 180 167.83 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "306" 6
%%Page: "307" 7
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
162 690.34 558 702 R
7 X
0 0 0 1 0 0 0 K
V
162 666.34 558 678.01 R
V
0 10 Q
0 X
(307) 541.32 671.34 T
324 684 580 684 2 L
7 X
V
3 H
2 Z
0 X
N
512 90 558 125 R
7 X
V
1 60 Q
0 X
(n) 512.17 85 T
315 104 510 126 R
7 X
V
2 24 Q
0 X
(Routines) 407.33 110 T
90 99 270 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
90.67 123.5 270.67 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
81 642.99 531 648 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 642.99 531 648 R
7 X
0 0 0 1 0 0 0 K
V
50 646.99 609.01 646.99 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 634.99 T
2 F
(MemIncRefCount\050\051) 99 634.99 T
5 10 Q
(void) 99 620.33 T
3 F
(MemIncRefCount\050) 153 620.33 T
3 9 Q
(MemHandle) 153 609.99 T
(mh\051;) 261 609.99 T
(/* handle of affected block */) 315 609.99 T
0 10 Q
(This routine increments the reference count of a global memory block \050the) 180 592.33 T
(reference count is stored in) 180 580.83 T
6 9 Q
(HM) 307.95 580.83 T
6 10 Q
(_otherInfo) 323.94 580.83 T
0 F
(\051.) 370.96 580.83 T
2 F
(W) 99 562.33 T
(arnings:) 108.07 562.33 T
0 F
(This routine assumes that a reference count is stored in) 180 562.33 T
6 9 Q
(HM) 440.57 562.33 T
6 10 Q
(_otherInfo) 456.56 562.33 T
0 F
(. Y) 503.58 562.33 T
(ou) 515.07 562.33 T
(may only use this routine if the block has had a reference count set up with) 180 549.33 T
4 F
(MemInitRefCount\050\051) 180 536.33 T
0 F
(.) 281.84 536.33 T
2 F
(Include:) 99 516.33 T
0 F
(heap.h) 180 516.33 T
81 499.98 531 504.99 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 499.98 531 504.99 R
7 X
0 0 0 1 0 0 0 K
V
50 503.98 609.01 503.98 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 491.98 T
2 F
(MemInitRefCount\050\051) 99 491.98 T
5 10 Q
(void) 99 477.32 T
3 F
(MemInitRefCount\050) 153 477.32 T
3 9 Q
(MemHandle) 153 466.98 T
(mh,) 261 466.98 T
(/* handle of affected block */) 333 466.98 T
(word) 153 456.98 T
(count\051;) 261 456.98 T
(/* initial reference count */) 333 456.98 T
0 10 Q
-0.24 (This routine sets up a reference count for the speci\336ed global memory block.) 180 439.32 P
(The passed count is stored in the) 180 427.82 T
6 9 Q
(HM) 334.83 427.82 T
6 10 Q
(_otherInfo) 350.82 427.82 T
0 F
( \336eld of the block\325) 397.84 427.82 T
(s) 478.04 427.82 T
(handle-table entry) 180 416.32 T
(.) 264.64 416.32 T
2 F
(W) 99 397.82 T
(arnings:) 108.07 397.82 T
0 F
(This routine overwrites the) 180 397.82 T
6 9 Q
(HM) 309.08 397.82 T
6 10 Q
(_otherInfo) 325.07 397.82 T
0 F
( \336eld. Since the semaphore) 372.09 397.82 T
-0.14 (routines \050) 180 384.82 P
4 F
-0.15 (HandleP\050\051) 224.29 384.82 P
0 F
-0.14 ( and) 277.25 384.82 P
4 F
-0.15 (HandleV\050\051) 299.93 384.82 P
0 F
-0.14 ( and the routines which use them\051 use) 352.89 384.82 P
(this \336eld, you cannot use both the semaphore routines and the reference) 180 371.82 T
(count routines on the same block.) 180 358.82 T
2 F
(Include:) 99 338.82 T
0 F
(heap.h) 180 338.82 T
81 322.48 531 327.48 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 322.48 531 327.48 R
7 X
0 0 0 1 0 0 0 K
V
50 326.48 609.01 326.48 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 314.48 T
2 F
(MemLock\050\051) 99 314.48 T
5 10 Q
(void) 99 299.81 T
3 F
(* MemLock\050) 153 299.81 T
3 9 Q
(MemHandle) 153 289.48 T
(mh\051;) 261 289.48 T
(/* Handle of block to lock */) 315 289.48 T
0 10 Q
(This routine locks a global memory block on the global heap. If the block is) 180 271.81 T
(swapped, the memory manager swaps it back into the global heap; it then) 180 260.31 T
(increments the lock count \050up to a maximum of 255\051. The block will not be) 180 248.81 T
-0.41 (moved, swapped, or discarded until the lock count reaches zero. This routine) 180 237.31 P
-0.1 (returns a pointer to the start of the block, or a null pointer if block has been) 180 225.81 P
-0.21 (discarded. T) 180 214.31 P
-0.21 (o get the address of a block without locking it, use) 235.54 214.31 P
4 F
-0.22 (MemDeref\050\051) 466.37 214.31 P
0 F
-0.21 (.) 528.22 214.31 P
2 F
(Include:) 99 195.81 T
0 F
(heap.h) 180 195.81 T
2 F
(W) 99 175.81 T
(arnings:) 108.07 175.81 T
0 F
-0.39 (If you try to lock a bad handle, the routine may fatal-error) 180 175.81 P
-0.39 (. This routine does) 444.04 175.81 P
(not check for synchronization problems; if the block is used by several) 180 162.81 T
(threads, you should use the synchronization routines.) 180 149.81 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "307" 7
%%Page: "308" 8
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
54 690.34 450 702 R
7 X
0 0 0 1 0 0 0 K
V
54 666.34 450 678.01 R
V
0 10 Q
0 X
(308) 54 671.34 T
32 684 288 684 2 L
7 X
V
3 H
2 Z
0 X
N
54 90 108 125 R
7 X
V
1 60 Q
0 X
(n) 58.17 85 T
104 104 299 126 R
7 X
V
2 24 Q
0 X
(Routines) 104 110 T
306 99 486 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
306 123.5 486 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
2 10 Q
0 X
(Never Use Situations:) 99 641.33 T
0 F
(Never lock a \336xed block.) 180 628.33 T
2 F
(See Also:) 99 608.33 T
0 F
(MemDeref\050\051) 180 608.33 T
81 591.99 531 597 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 591.99 531 597 R
7 X
0 0 0 1 0 0 0 K
V
50 595.99 609.01 595.99 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 583.99 T
2 F
(MemLockExcl\050\051) 99 583.99 T
5 10 Q
(void) 99 569.33 T
3 F
(* MemLockExcl\050) 153 569.33 T
3 9 Q
(MemHandle) 153 558.99 T
(mh\051;) 261 558.99 T
(/* Handle of block to grab */) 315 558.99 T
0 10 Q
-0.06 (If several different threads will be accessing the same global memory block,) 180 541.33 P
(they should use data-access synchronization routines.) 180 529.83 T
4 F
(MemLockExcl\050\051) 431.3 529.83 T
0 F
-0.43 (belongs to one such set of routines. Often, several threads will need access to) 180 518.33 P
(the same block; however) 180 506.83 T
(, most of the time, they will not need to change the) 292.24 506.83 T
-0.15 (block. There is no synchronization problem if several threads read the same) 180 495.33 P
-0.32 (block at once, as long as none of them alters the block \050by resizing it, writing) 180 483.83 P
(to it, etc.\051 However) 180 472.33 T
(, if a thread needs to change a block, no other thread) 266.67 472.33 T
(should have access at that time.) 180 460.83 T
(The routines) 180 442.33 T
4 F
(MemLockExcl\050\051) 241.67 442.33 T
0 F
(,) 322.97 442.33 T
4 F
(MemLockShared\050\051) 328.53 442.33 T
0 F
(,) 424.28 442.33 T
4 F
(MemUnlockShared\050\051) 180 430.83 T
0 F
(, and) 287.23 430.83 T
4 F
(MemUnlockExcl\050\051) 312.98 430.83 T
0 F
( take advantage of this) 405.76 430.83 T
(situation. They maintain a queue of threads requesting access to a block.) 180 419.33 T
-0.63 (When the block is not being used, they awaken the highest priority thread on) 180 407.83 P
-0.24 (the queue. If that thread requested exclusive access, the other threads sleep) 180 396.33 P
(until it relinquishes access \050via) 180 384.83 T
4 F
(MemUnlockExcl\050\051) 326.5 384.83 T
0 F
(\051. If it requested shared) 419.28 384.83 T
(access, the routines awaken every other thread which requested shared) 180 373.33 T
(access; the other threads on the queue will sleep until every active thread) 180 361.83 T
(relinquishes access \050via) 180 350.33 T
4 F
(MemUnlockShared\050\051) 291.49 350.33 T
0 F
(\051.) 398.72 350.33 T
4 F
(MemLockExcl\050\051) 180 331.83 T
0 F
( requests exclusive access to the block. If the block is not) 261.3 331.83 T
(being accessed, the routine will grab exclusive access for the block, lock the) 180 320.33 T
(block, and return the block\325) 180 308.83 T
(s address. If the block is being accessed, the) 306.13 308.83 T
(routine will sleep on the queue until it can get access; it will then awaken,) 180 297.33 T
(lock the block, and return its address.) 180 285.83 T
2 F
(Include:) 99 267.33 T
0 F
(heap.h) 180 267.33 T
2 F
(T) 99 247.33 T
(ips and T) 104.93 247.33 T
(ricks:) 148.28 247.33 T
0 F
-0.46 (Y) 180 247.33 P
-0.46 (ou can \336nd out if the block is being accessed by looking at the) 185.93 247.33 P
6 9 Q
-0.41 (HM) 465.67 247.33 P
6 10 Q
-0.46 (_otherInfo) 481.66 247.33 P
0 F
(word \050with) 180 234.33 T
4 F
(MemGetInfo\050\051) 232.78 234.33 T
0 F
(\051. If) 305.36 234.33 T
6 9 Q
(HM) 324.43 234.33 T
6 10 Q
(_otherInfo) 340.42 234.33 T
0 F
( equals one, the block is not) 387.44 234.33 T
-0.67 (grabbed; if it equals zero, it is grabbed, but no threads are queued; otherwise,) 180 221.33 P
(it equals the handle of the \336rst thread queued.) 180 208.33 T
2 F
(Be Sure T) 99 188.33 T
(o:) 144.94 188.33 T
0 F
(Make sure that all routines accessing the block get access with) 180 188.33 T
4 F
(MemLockExcl\050\051) 180 175.33 T
0 F
( or) 261.3 175.33 T
4 F
(MemLockShared\050\051) 276.3 175.33 T
0 F
(. The routines use the block\325) 372.05 175.33 T
(s) 501.33 175.33 T
6 9 Q
(HM) 180 162.33 T
6 10 Q
(_otherInfo) 195.99 162.33 T
0 F
( word; you must not alter it. When you are done accessing the) 243.01 162.33 T
(block, make sure to relinquish access by calling) 180 149.33 T
4 F
(MemUnlockExcl\050\051) 401.52 149.33 T
0 F
(.) 494.3 149.33 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "308" 8
%%Page: "309" 9
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
162 690.34 558 702 R
7 X
0 0 0 1 0 0 0 K
V
162 666.34 558 678.01 R
V
0 10 Q
0 X
(309) 541.32 671.34 T
324 684 580 684 2 L
7 X
V
3 H
2 Z
0 X
N
512 90 558 125 R
7 X
V
1 60 Q
0 X
(n) 512.17 85 T
315 104 510 126 R
7 X
V
2 24 Q
0 X
(Routines) 407.33 110 T
90 99 270 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
90.67 123.5 270.67 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
2 10 Q
0 X
(W) 99 641.33 T
(arnings:) 108.07 641.33 T
0 F
(If a thread calls) 180 641.33 T
4 F
(MemLockExcl\050\051) 255.75 641.33 T
0 F
( when it already has shared or exclusive) 337.05 641.33 T
-0.6 (access, it will deadlock; it will sleep until access is relinquished, but it cannot) 180 628.33 P
-0.79 (relinquish access while it is sleeping. If you try to grab a block which is owned) 180 615.33 P
(by a different geode and is non-sharable, the routine will fatal-error) 180 602.33 T
(.) 492.25 602.33 T
2 F
(Never Use Situations:) 99 582.33 T
0 F
-0.06 (Never use) 180 569.33 P
4 F
-0.07 (MemLockExcl\050\051) 229.13 569.33 P
0 F
-0.06 ( or) 310.43 569.33 P
4 F
-0.07 (MemLockShared\050\051) 325.3 569.33 P
0 F
-0.06 ( on a \336xed block. It will) 421.05 569.33 P
-0.33 (attempt to lock the block, and \336xed blocks cannot be locked. Instead, use the) 180 556.33 P
4 F
(HandleP\050\051) 180 543.33 T
0 F
( and) 232.96 543.33 T
4 F
(HandleV\050\051) 255.93 543.33 T
0 F
( routines.) 308.89 543.33 T
2 F
(See Also:) 99 523.33 T
0 F
(MemLockShared\050\051, MemUnlockExcl\050\051, MemUnlockShared\050\051) 180 523.33 T
81 506.99 531 512 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 506.99 531 512 R
7 X
0 0 0 1 0 0 0 K
V
50 510.99 609.01 510.99 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 498.99 T
2 F
(MemLockFixedOrMovable\050\051) 99 498.99 T
5 10 Q
(void) 99 485.33 T
3 F
(* MemLockFixedOrMovable\050) 153 485.33 T
3 9 Q
(void) 153 474.99 T
(* ptr\051;) 189 474.99 T
(/* virtual segment */) 279 474.99 T
0 10 Q
(Given a virtual segment, this routine locks it \050if it was movable\051. A virtual) 180 457.33 T
(segment is an opaque pointer to a block that an application views as locked) 180 445.83 T
-0.14 (or \336xed\321the memory manager can actually swap locked or \336xed blocks and) 180 434.33 P
(will designate them as virtual segments.) 180 422.83 T
2 F
(Include:) 99 404.33 T
0 F
(heap.h) 180 404.33 T
81 387.98 531 392.99 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 387.98 531 392.99 R
7 X
0 0 0 1 0 0 0 K
V
50 391.98 609.01 391.98 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 379.98 T
2 F
(MemLockShared\050\051) 99 379.98 T
5 10 Q
(void) 99 365.32 T
3 F
(* MemLockShared\050) 153 365.32 T
3 9 Q
(MemHandle) 153 354.98 T
(mh\051;) 261 354.98 T
(/* Handle of block to grab */) 315 354.98 T
4 10 Q
-0.31 (MemLockShared\050\051) 180 337.32 P
0 F
-0.3 ( requests shared access to the passed block. If the block) 275.75 337.32 P
-0.51 (is not being accessed, or if it is held for shared access and the queue is empty) 180 325.82 P
-0.51 (,) 525.95 325.82 P
(the routine gets access, locks the block, and returns the block\325) 180 314.32 T
(s address.) 464.66 314.32 T
-0.13 (Otherwise it sleeps on the queue until the shared requests are awakened; it) 180 302.82 P
(then locks the block and returns the block\325) 180 291.32 T
(s address.) 375.58 291.32 T
2 F
(Include:) 99 272.82 T
0 F
(heap.h) 180 272.82 T
2 F
(Be Sure T) 99 252.82 T
(o:) 144.94 252.82 T
0 F
(Make sure that all routines accessing the block get access with) 180 252.82 T
4 F
(MemLockExcl\050\051) 180 239.82 T
0 F
( or) 261.3 239.82 T
4 F
(MemLockShared\050\051) 276.3 239.82 T
0 F
(. The routines use the block\325) 372.05 239.82 T
(s) 501.33 239.82 T
6 9 Q
(HM) 180 226.82 T
6 10 Q
(_otherInfo) 195.99 226.82 T
0 F
( word; you must not alter it. When you are done accessing the) 243.01 226.82 T
(block, make sure to relinquish access by calling) 180 213.82 T
4 F
(MemUnlockExcl\050\051) 401.52 213.82 T
0 F
(.) 494.3 213.82 T
2 F
(W) 99 193.82 T
(arnings:) 108.07 193.82 T
0 F
-0.55 (If a thread calls) 180 193.82 P
4 F
-0.57 (MemLockShared\050\051) 253.54 193.82 P
0 F
-0.55 ( when it already has exclusive access, it) 349.29 193.82 P
(will deadlock; it will sleep until access is relinquished, but it cannot) 180 180.82 T
-0.28 (relinquish access while it is sleeping. The thread must be careful not to take) 180 167.82 P
-0.33 (actions which could change the block, such as resizing it or writing to it. The) 180 154.82 P
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "309" 9
%%Page: "310" 10
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
54 690.34 450 702 R
7 X
0 0 0 1 0 0 0 K
V
54 666.34 450 678.01 R
V
0 10 Q
0 X
(310) 54 671.34 T
32 684 288 684 2 L
7 X
V
3 H
2 Z
0 X
N
54 90 108 125 R
7 X
V
1 60 Q
0 X
(n) 58.17 85 T
104 104 299 126 R
7 X
V
2 24 Q
0 X
(Routines) 104 110 T
306 99 486 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
306 123.5 486 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
0 10 Q
0 X
(routine will not enforce this. If you try to grab a block which is owned by a) 180 641.33 T
(different geode and is non-sharable, the routine will fatal-error) 180 628.33 T
(.) 470.2 628.33 T
2 F
(Never Use Situations:) 99 608.33 T
0 F
-0.06 (Never use) 180 595.33 P
4 F
-0.07 (MemLockExcl\050\051) 229.13 595.33 P
0 F
-0.06 ( or) 310.43 595.33 P
4 F
-0.07 (MemLockShared\050\051) 325.3 595.33 P
0 F
-0.06 ( on a \336xed block. It will) 421.05 595.33 P
-0.33 (attempt to lock the block, and \336xed blocks cannot be locked. Instead, use the) 180 582.33 P
4 F
(HandleP\050\051) 180 569.33 T
0 F
( and) 232.96 569.33 T
4 F
(HandleV\050\051) 255.93 569.33 T
0 F
( routines.) 308.89 569.33 T
2 F
(See Also:) 99 549.33 T
0 F
(MemLockExcl\050\051, MemUnlockExcl\050\051, MemUnlockShared\050\051) 180 549.33 T
81 532.99 531 538 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 532.99 531 538 R
7 X
0 0 0 1 0 0 0 K
V
50 536.99 609.01 536.99 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 524.99 T
2 F
(MemModifyFlags\050\051) 99 524.99 T
5 10 Q
(void) 99 510.33 T
3 F
(MemModifyFlags\050) 153 510.33 T
3 9 Q
(MemHandle) 153 499.99 T
(mh,) 261 499.99 T
(/* Handle of block to modify */) 351 499.99 T
(HeapFlags) 153 489.99 T
(bitsToSet,) 261 489.99 T
(/* HeapFlags to turn on */) 351 489.99 T
(HeapFlags) 153 479.99 T
(bitsToClear\051;) 261 479.99 T
(/* HeapFlags to turn off */) 351 479.99 T
4 10 Q
(MemModifyFlags\050\051) 180 462.33 T
0 F
(changes the) 280.08 462.33 T
4 F
( HeapFlags) 335.08 462.33 T
0 F
( record of the global memory) 393.13 462.33 T
(block speci\336ed. Not all \337ags can be changed after the block is created; only) 180 450.83 T
-0.49 (the \337ags) 180 439.33 P
0 9 Q
-0.44 (HF_SHARABLE) 221.32 439.33 P
0 10 Q
-0.49 (,) 290.98 439.33 P
0 9 Q
-0.44 (HF_DISCARDABLE) 296.05 439.33 P
0 10 Q
-0.49 (,) 382.38 439.33 P
0 9 Q
-0.44 (HF_SW) 387.45 439.33 P
-0.44 (AP) 419.12 439.33 P
-0.44 (ABLE) 430.95 439.33 P
0 10 Q
-0.49 (, and) 456.45 439.33 P
0 9 Q
-0.44 (HF_LMEM) 481.22 439.33 P
0 10 Q
(can be changed.) 180 427.83 T
-0.76 (The routine uses the handle table entry of the block speci\336ed; it does not need) 180 409.33 P
-0.59 (to look at the actual block. The routine performs normally whether or not the) 180 397.83 P
(block is locked, \336xed, or discarded.) 180 386.33 T
2 F
(Include:) 99 367.83 T
0 F
(heap.h) 180 367.83 T
2 F
(W) 99 347.83 T
(arnings:) 108.07 347.83 T
0 F
(If the handle is not a global memory handle, results are unpredictable; the) 180 347.83 T
(routine will change inappropriate bits of the handle table entry) 180 334.83 T
(.) 471.15 334.83 T
2 F
(See Also:) 99 314.83 T
0 F
(MemGetInfo\050\051, HandleModifyOwner\050\051, MemModifyOtherInfo\050\051) 180 314.83 T
81 298.48 531 303.49 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 298.48 531 303.49 R
7 X
0 0 0 1 0 0 0 K
V
50 302.48 609.01 302.48 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 290.48 T
2 F
(MemModifyOtherInfo\050\051) 99 290.48 T
5 10 Q
(void) 99 275.82 T
3 F
(MemModifyOtherInfo\050) 153 275.82 T
3 9 Q
(MemHandle) 153 265.48 T
(mh,) 261 265.48 T
(/* Handle of block to modify */) 333 265.48 T
(word) 153 255.48 T
(otherInfo\051;) 261 255.48 T
(/* New value of HM_otherInfo word */) 333 255.48 T
0 10 Q
(Use this routine to change the value of the global memory block\325) 180 237.82 T
(s) 475.97 237.82 T
6 9 Q
(HM) 180 226.32 T
6 10 Q
(_otherInfo) 195.99 226.32 T
0 F
( word. Some blocks need this word left alone; for example,) 243.01 226.32 T
(data-access synchronization routines use this word.) 180 214.82 T
2 F
(Include:) 99 196.32 T
0 F
(heap.h) 180 196.32 T
2 F
(See Also:) 99 176.32 T
0 F
(MemGetInfo\050\051, MemModifyFlags\050\051, HandleModifyOwner\050\051) 180 176.32 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "310" 10
%%Page: "311" 11
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
162 690.34 558 702 R
7 X
0 0 0 1 0 0 0 K
V
162 666.34 558 678.01 R
V
0 10 Q
0 X
(311) 541.32 671.34 T
324 684 580 684 2 L
7 X
V
3 H
2 Z
0 X
N
512 90 558 125 R
7 X
V
1 60 Q
0 X
(n) 512.17 85 T
315 104 510 126 R
7 X
V
2 24 Q
0 X
(Routines) 407.33 110 T
90 99 270 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
90.67 123.5 270.67 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
81 642.99 531 648 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 642.99 531 648 R
7 X
0 0 0 1 0 0 0 K
V
50 646.99 609.01 646.99 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 634.99 T
2 F
(MemOwner\050\051) 99 634.99 T
5 10 Q
(GeodeHandle) 99 621.33 T
3 F
( MemOwner\050) 165 621.33 T
3 9 Q
(MemHandle) 153 610.99 T
(mh\051;) 261 610.99 T
(/* handle of block queried */) 315 610.99 T
0 10 Q
(This routine returns the owning geode of the passed block. If the block) 180 593.33 T
(belongs to a) 180 581.83 T
0 9 Q
(VM) 237.61 581.83 T
0 10 Q
( \336le, the owner of the) 252.6 581.83 T
0 9 Q
(VM) 352.98 581.83 T
0 10 Q
( \336le will be returned \050unlike) 367.98 581.83 T
4 F
(MemInfo\050\051) 180 570.33 T
0 F
(, which returns the) 234.25 570.33 T
0 9 Q
(VM) 325.36 570.33 T
0 10 Q
( \336le handle\051.) 340.35 570.33 T
2 F
(Include:) 99 551.83 T
0 F
(heap.h) 180 551.83 T
81 535.48 531 540.49 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 535.48 531 540.49 R
7 X
0 0 0 1 0 0 0 K
V
50 539.48 609.01 539.48 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 527.48 T
2 F
(MemPLock\050\051) 99 527.48 T
5 10 Q
(void) 99 512.82 T
3 F
(* MemPLock\050) 153 512.82 T
3 9 Q
(MemHandle) 153 502.48 T
(mh\051;) 261 502.48 T
(/* Handle of block to lock */) 297 502.48 T
0 10 Q
-0.06 (If several different threads will be accessing the same global memory block,) 180 484.82 P
-0.49 (they need to make sure their activities will not con\337ict. The way they do that) 180 473.32 P
(is to use synchronization routines to get control of a block.) 180 461.82 T
4 F
(MemPLock\050\051) 451.13 461.82 T
0 F
( is) 517.24 461.82 T
(part of one set of synchronization routines.) 180 450.32 T
(If the threads are using the) 180 431.82 T
4 F
(MemPLock\050\051) 309.82 431.82 T
0 F
( family) 375.93 431.82 T
(, then whenever a thread) 407.05 431.82 T
-0.18 (needs access to the block in question, it can call) 180 420.32 P
4 F
-0.19 (MemPLock\050\051) 400.06 420.32 P
0 F
-0.18 (. This routine) 466.17 420.32 P
-0.82 (calls) 180 408.82 P
4 F
-0.85 (HandleP\050\051) 202.88 408.82 P
0 F
-0.82 ( to get control of the block; it then locks the block and returns) 255.85 408.82 P
-0.12 (its address. If the block has been discarded, it grabs the block and returns a) 180 397.32 P
-0.47 (null pointer; you can then reallocate the block. When the thread is done with) 180 385.82 P
(the block, it should release it with) 180 374.32 T
4 F
(MemUnlockV\050\051) 339.85 374.32 T
0 F
(.) 417.44 374.32 T
2 F
(Include:) 99 355.82 T
0 F
(heap.h) 180 355.82 T
2 F
(T) 99 335.82 T
(ips and T) 104.93 335.82 T
(ricks:) 148.28 335.82 T
0 F
-0.46 (Y) 180 335.82 P
-0.46 (ou can \336nd out if the block is being accessed by looking at the) 185.93 335.82 P
6 9 Q
-0.41 (HM) 465.67 335.82 P
6 10 Q
-0.46 (_otherInfo) 481.66 335.82 P
0 F
(word \050with) 180 322.82 T
4 F
(MemGetInfo\050\051) 232.78 322.82 T
0 F
(\051. If) 305.36 322.82 T
6 9 Q
(HM) 324.43 322.82 T
6 10 Q
(_otherInfo) 340.42 322.82 T
0 F
( equals one, the block is not) 387.44 322.82 T
-0.67 (grabbed; if it equals zero, it is grabbed, but no threads are queued; otherwise,) 180 309.82 P
(it equals the handle of the \336rst thread queued.) 180 296.82 T
2 F
(Be Sure T) 99 276.82 T
(o:) 144.94 276.82 T
0 F
(Make sure that all threads accessing the block use) 180 276.82 T
4 F
(MemPLock\050\051) 415.96 276.82 T
0 F
( and/or) 482.07 276.82 T
4 F
(HandleP\050\051) 180 263.82 T
0 F
( to grab the block. These routines use the) 232.96 263.82 T
6 9 Q
(HM) 426.14 263.82 T
6 10 Q
(_otherInfo) 442.13 263.82 T
0 F
( \336eld of) 489.15 263.82 T
(the block\325) 180 250.82 T
(s handle table entry; do not alter this \336eld. Release the block with) 223.53 250.82 T
4 F
(HandleV\050\051) 180 237.82 T
0 F
( or) 232.96 237.82 T
4 F
(MemUnlockV\050\051) 247.96 237.82 T
0 F
( when you are done with it.) 325.55 237.82 T
2 F
(W) 99 217.82 T
(arnings:) 108.07 217.82 T
0 F
-0.74 (If a thread calls) 180 217.82 P
4 F
-0.76 (MemPLock\050\051) 252.79 217.82 P
0 F
-0.74 ( when it already has control of the block, it will) 318.9 217.82 P
(deadlock.) 180 204.82 T
4 F
(MemThreadGrab\050\051) 226.12 204.82 T
0 F
( avoids this con\337ict. If you try to grab a) 322.97 204.82 T
(non-sharable block owned by another thread,) 180 191.82 T
4 F
(MemPLock\050\051) 391.51 191.82 T
0 F
( will fatal-error) 457.62 191.82 T
(.) 527.81 191.82 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "311" 11
%%Page: "312" 12
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
54 690.34 450 702 R
7 X
0 0 0 1 0 0 0 K
V
54 666.34 450 678.01 R
V
0 10 Q
0 X
(312) 54 671.34 T
32 684 288 684 2 L
7 X
V
3 H
2 Z
0 X
N
54 90 108 125 R
7 X
V
1 60 Q
0 X
(n) 58.17 85 T
104 104 299 126 R
7 X
V
2 24 Q
0 X
(Routines) 104 110 T
306 99 486 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
306 123.5 486 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
2 10 Q
0 X
(Never Use Situations:) 99 641.33 T
0 F
-0.11 (Never use) 180 628.33 P
4 F
-0.11 (MemPLock\050\051) 229.04 628.33 P
0 F
-0.11 ( with a \336xed block. It will try to lock the block, and) 295.15 628.33 P
(\336xed blocks cannot be locked. Instead, use) 180 615.33 T
4 F
(HandleP\050\051) 377.62 615.33 T
0 F
(.) 430.58 615.33 T
2 F
(See Also:) 99 595.33 T
0 F
(HandleP\050\051, MemUnlockV\050\051, HandleV\050\051) 180 595.33 T
81 578.99 531 584 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 578.99 531 584 R
7 X
0 0 0 1 0 0 0 K
V
50 582.99 609.01 582.99 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 570.99 T
2 F
(MemPtrT) 99 570.99 T
(oHandle\050\051) 149.45 570.99 T
5 10 Q
(MemHandle) 99 557.33 T
3 F
( MemPtrToHandle\050) 153 557.33 T
3 9 Q
(void) 153 546.99 T
(* ptr\051;) 189 546.99 T
(/* pointer to locked block */) 279 546.99 T
0 10 Q
(This routine returns the global handle of the locked block.) 180 529.33 T
2 F
(Include:) 99 510.83 T
0 F
(heap.h) 180 510.83 T
81 494.48 531 499.49 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 494.48 531 499.49 R
7 X
0 0 0 1 0 0 0 K
V
50 498.48 609.01 498.48 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 486.48 T
2 F
(MemReAlloc\050\051) 99 486.48 T
5 10 Q
(MemHandle) 99 471.82 T
3 F
(MemReAlloc\050) 159 471.82 T
3 9 Q
(MemHandle) 153 461.48 T
(mh,) 261 461.48 T
(/* Handle of block */) 351 461.48 T
(word) 153 451.48 T
(byteSize,) 261 451.48 T
(/* New size of the block */) 351 451.48 T
(HeapAllocFlags) 153 441.48 T
(heapAllocFlags\051;) 261 441.48 T
(/* How to reallocate block */) 351 441.48 T
0 10 Q
(This routine reallocates a global memory block. It can be used to resize a) 180 423.82 T
-0.17 (block; it can also be used to reallocate memory for a discarded block. Locked) 180 412.32 P
(and \336xed blocks can be reallocated; however) 180 400.82 T
(, they may move on the global) 383.36 400.82 T
-0.04 (heap, so all pointers within the block must be adjusted. Note, however) 180 389.32 P
-0.04 (, that) 503.29 389.32 P
(if the new size is smaller than the old size, the block is guaranteed not to) 180 377.82 T
(move. The reallocated block may be larger than the size requested, as the) 180 366.32 T
(block size is rounded up to the next even paragraph \050one paragraph equals) 180 354.82 T
(sixteen bytes\051.) 180 343.32 T
(The routine is passed a record of) 180 324.82 T
4 F
(HeapAllocFlags) 332.97 324.82 T
0 F
(. Only the \337ags) 414.45 324.82 T
0 9 Q
(HAF_ZERO_INIT) 180 313.32 T
0 10 Q
(,) 254.24 313.32 T
0 9 Q
(HAF_LOCK) 259.8 313.32 T
0 10 Q
(, and) 310.8 313.32 T
0 9 Q
(HAF_NO_ERR) 336.55 313.32 T
0 10 Q
( may be passed.) 399.38 313.32 T
2 F
(Include:) 99 294.82 T
0 F
(heap.h) 180 294.82 T
2 F
(W) 99 274.82 T
(arnings:) 108.07 274.82 T
0 F
(If) 180 274.82 T
0 9 Q
(HAF_LOCK) 190.18 274.82 T
0 10 Q
( is passed, the lock count will be incremented even if the block) 241.18 274.82 T
-0.41 (is already locked by this thread. The routine does not care whether the block) 180 261.82 P
(has been locked by another thread \050possibly belonging to another geode\051;) 180 248.82 T
-0.68 (thus, if the block is being used by more than one thread, it is important to use) 180 235.82 P
(the synchronization routines.) 180 222.82 T
2 F
(See Also:) 99 202.82 T
0 F
(MemAlloc\050\051, MemDeref\050\051) 180 202.82 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "312" 12
%%Page: "313" 13
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
162 690.34 558 702 R
7 X
0 0 0 1 0 0 0 K
V
162 666.34 558 678.01 R
V
0 10 Q
0 X
(313) 541.32 671.34 T
324 684 580 684 2 L
7 X
V
3 H
2 Z
0 X
N
512 90 558 125 R
7 X
V
1 60 Q
0 X
(n) 512.17 85 T
315 104 510 126 R
7 X
V
2 24 Q
0 X
(Routines) 407.33 110 T
90 99 270 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
90.67 123.5 270.67 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
81 642.99 531 648 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 642.99 531 648 R
7 X
0 0 0 1 0 0 0 K
V
50 646.99 609.01 646.99 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 634.99 T
2 F
(MemThreadGrab\050\051) 99 634.99 T
5 10 Q
(void) 99 620.33 T
3 F
(* MemThreadGrab\050) 153 620.33 T
3 9 Q
(MemHandle) 153 609.99 T
(mh\051;) 261 609.99 T
(/* Handle of block to grab */) 315 609.99 T
4 10 Q
(MemThreadGrab\050\051) 180 592.33 T
0 F
( is used in conjunction with) 276.85 592.33 T
4 F
(MemThreadGrabNB\050\051) 406.3 592.33 T
0 F
(and) 180 580.83 T
4 F
(MemThreadRelease\050\051) 200.19 580.83 T
0 F
( to maintain data-access synchronization. If) 310.93 580.83 T
(several threads will all have access to the same global memory block, they) 180 569.33 T
(should use data-acess synchronization routines to make sure that their) 180 557.83 T
-0.01 (activities do not con\337ict. If a thread uses) 180 546.33 P
4 F
-0.01 (MemThreadGrab\050\051) 370.11 546.33 P
0 F
-0.01 ( and no other) 466.96 546.33 P
(thread has grabbed the block in question, the routine will increment the) 180 534.83 T
-0.25 (\322grab count,\323 lock the block, and return its address. It can do this even if the) 180 523.33 P
-0.17 (calling thread has already grabbed the block. If another thread has grabbed) 180 511.83 P
(the block,) 180 500.33 T
4 F
(MemThreadGrab\050\051) 227.42 500.33 T
0 F
( will put the calling thread in a queue to get) 324.27 500.33 T
(the block; the thread will sleep until it gets the block, then) 180 488.83 T
4 F
(MemThreadGrab\050\051) 180 477.33 T
0 F
( will grab the block, lock it, and return its address.) 276.85 477.33 T
(If the block has been discarded,) 180 458.83 T
4 F
(MemThreadGrab\050\051) 328.35 458.83 T
0 F
( grabs the block and) 425.2 458.83 T
(returns a null pointer; you can then reallocate memory for the block.) 180 447.33 T
2 F
(Include:) 99 428.83 T
0 F
(heap.h) 180 428.83 T
2 F
(Be Sure T) 99 408.83 T
(o:) 144.94 408.83 T
0 F
-0.78 (Make sure that all threads using the block use the) 180 408.83 P
4 F
-0.81 (MemThread\311\050\051) 407.94 408.83 P
0 F
-0.78 ( routines) 488.68 408.83 P
(to access it \050not other data-acess synchronization routines\051. Do not change) 180 395.83 T
(the) 180 382.83 T
6 9 Q
(HM) 197.78 382.83 T
6 10 Q
(_otherInfo) 213.77 382.83 T
0 F
( word of the block\325) 260.79 382.83 T
(s handle table entry \050the routines use) 343.95 382.83 T
(that word as a semaphore\051.) 180 369.83 T
2 F
(W) 99 349.83 T
(arnings:) 108.07 349.83 T
0 F
(If you try to grab a block which is owned by a different geode and is) 180 349.83 T
(non-sharable, the routine will fatal-error) 180 336.83 T
(.) 367.79 336.83 T
2 F
(Never Use Situations:) 99 316.83 T
0 F
(Never use) 180 303.83 T
4 F
(MemThreadGrab\050\051) 229.26 303.83 T
0 F
( with a \336xed block. It will try to lock the) 326.11 303.83 T
(block, and \336xed blocks cannot be locked. If you need data-access) 180 290.83 T
(synchronization for a \336xed block, use the) 180 277.83 T
4 F
(HandleP\050\051) 371.49 277.83 T
0 F
( and) 424.45 277.83 T
4 F
(HandleV\050\051) 447.42 277.83 T
0 F
(routines.) 180 264.83 T
2 F
(See Also:) 99 244.83 T
0 F
(MemThreadGrabNB\050\051, MemThreadRelease\050\051) 180 244.83 T
81 228.48 531 233.49 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 228.48 531 233.49 R
7 X
0 0 0 1 0 0 0 K
V
50 232.48 609.01 232.48 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 220.48 T
2 F
(MemThreadGrabNB\050\051) 99 220.48 T
5 10 Q
(void) 99 205.82 T
3 F
(* MemThreadGrabNB\050) 153 205.82 T
3 9 Q
(MemHandle) 153 195.48 T
(mh\051; /* handle of block to grab */) 261 195.48 T
0 10 Q
(This is a data-synchronization routine to be used in conjunction with) 180 177.82 T
4 F
(MemThreadGrab\050\051) 180 166.32 T
0 F
( and) 276.85 166.32 T
4 F
(MemThreadRelease\050\051) 299.82 166.32 T
0 F
(. It is exactly the same as) 410.56 166.32 T
4 F
(MemThreadGrab\050\051) 180 154.82 T
0 F
(, except that if it cannot grab the global memory block) 276.85 154.82 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "313" 13
%%Page: "314" 14
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
54 690.34 450 702 R
7 X
0 0 0 1 0 0 0 K
V
54 666.34 450 678.01 R
V
0 10 Q
0 X
(314) 54 671.34 T
32 684 288 684 2 L
7 X
V
3 H
2 Z
0 X
N
54 90 108 125 R
7 X
V
1 60 Q
0 X
(n) 58.17 85 T
104 104 299 126 R
7 X
V
2 24 Q
0 X
(Routines) 104 110 T
306 99 486 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
306 123.5 486 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
0 10 Q
0 X
(because another thread has it, the routine returns an error instead of) 180 641.33 T
(blocking.) 180 629.83 T
(If successful,) 180 611.33 T
4 F
(MemThreadGrabNB\050\051) 242.21 611.33 T
0 F
( returns a pointer to the block. If the) 355.17 611.33 T
(block has been discarded, it grabs the block and returns a null pointer; you) 180 599.83 T
(can then reallocate memory for the block. If the block has been grabbed by) 180 588.33 T
(another thread,) 180 576.83 T
4 F
(MemThreadGrab\050\051) 255.19 576.83 T
0 F
( returns the constant) 352.04 576.83 T
0 9 Q
(BLOCK_GRABBED) 180 565.33 T
0 10 Q
(.) 264 565.33 T
2 F
(Include:) 99 546.83 T
0 F
(heap.h) 180 546.83 T
2 F
(T) 99 526.83 T
(ips and T) 104.93 526.83 T
(ricks:) 148.28 526.83 T
0 F
-0.46 (Y) 180 526.83 P
-0.46 (ou can \336nd out if the block is being accessed by looking at the) 185.93 526.83 P
6 9 Q
-0.41 (HM) 465.67 526.83 P
6 10 Q
-0.46 (_otherInfo) 481.66 526.83 P
0 F
(word \050with) 180 513.83 T
4 F
(MemGetInfo\050\051) 232.78 513.83 T
0 F
(\051. If) 305.36 513.83 T
6 9 Q
(HM) 324.43 513.83 T
6 10 Q
(_otherInfo) 340.42 513.83 T
0 F
( equals one, the block is not) 387.44 513.83 T
-0.67 (grabbed; if it equals zero, it is grabbed, but no threads are queued; otherwise,) 180 500.83 P
(it equals the handle of the \336rst thread queued.) 180 487.83 T
2 F
(Be Sure T) 99 467.83 T
(o:) 144.94 467.83 T
0 F
-0.78 (Make sure that all threads using the block use the) 180 467.83 P
4 F
-0.81 (MemThread\311\050\051) 407.94 467.83 P
0 F
-0.78 ( routines) 488.68 467.83 P
(to access the block \050not other data-access synchronization routines\051. Do not) 180 454.83 T
-0.49 (change the) 180 441.83 P
6 9 Q
-0.44 (HM) 232.16 441.83 P
6 10 Q
-0.49 (_otherInfo) 248.15 441.83 P
0 F
-0.49 ( word of the block\325) 295.17 441.83 P
-0.49 (s handle table entry \050the routines) 376.36 441.83 P
(use that word as a semaphore\051.) 180 428.83 T
2 F
(W) 99 408.83 T
(arnings:) 108.07 408.83 T
0 F
(If you try to grab a block that is owned by a different geode and is) 180 408.83 T
(non-sharable, the routine will fatal-error) 180 395.83 T
(.) 367.79 395.83 T
2 F
(Never Use Situations:) 99 375.83 T
0 F
(Never use) 180 362.83 T
4 F
(MemThreadGrabNB\050\051) 229.26 362.83 T
0 F
( with a \336xed block. It will try to lock the) 342.22 362.83 T
(block, and \336xed blocks cannot be locked. If you need synchronization for a) 180 349.83 T
(\336xed block, use the) 180 336.83 T
4 F
(HandleP\050\051) 270.94 336.83 T
0 F
( and) 323.9 336.83 T
4 F
(HandleV\050\051) 346.87 336.83 T
0 F
( routines.) 399.83 336.83 T
2 F
(See Also:) 99 316.83 T
0 F
(MemThreadGrab\050\051, MemThreadRelease\050\051) 180 316.83 T
81 300.49 531 305.5 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 300.49 531 305.5 R
7 X
0 0 0 1 0 0 0 K
V
50 304.49 609.01 304.49 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 292.49 T
2 F
(MemThreadRelease\050\051) 99 292.49 T
5 10 Q
(void) 99 277.83 T
3 F
(MemThreadRelease\050) 153 277.83 T
3 9 Q
(MemHandle) 153 267.49 T
(mh\051; /* handle of locked block to release */) 261 267.49 T
0 10 Q
(Use this routine to release a global memory block which you have grabbed) 180 249.83 T
(with) 180 238.33 T
4 F
(MemThreadGrab\050\051) 203.71 238.33 T
0 F
( or) 300.56 238.33 T
4 F
(MemThreadGrabNB\050\051) 315.56 238.33 T
0 F
(. The routine) 428.52 238.33 T
(decrements the grab count; if the grab count reaches zero, the routine) 180 226.83 T
(unlocks the block.) 180 215.33 T
2 F
(Include:) 99 196.83 T
0 F
(heap.h) 180 196.83 T
2 F
(T) 99 176.83 T
(ips and T) 104.93 176.83 T
(ricks:) 148.28 176.83 T
0 F
-0.46 (Y) 180 176.83 P
-0.46 (ou can \336nd out if the block is being accessed by looking at the) 185.93 176.83 P
6 9 Q
-0.41 (HM) 465.67 176.83 P
6 10 Q
-0.46 (_otherInfo) 481.66 176.83 P
0 F
(word \050with) 180 163.83 T
4 F
(MemGetInfo\050\051) 232.78 163.83 T
0 F
(\051. If) 305.36 163.83 T
6 9 Q
(HM) 324.43 163.83 T
6 10 Q
(_otherInfo) 340.42 163.83 T
0 F
( equals one, the block is not) 387.44 163.83 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "314" 14
%%Page: "315" 15
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
162 690.34 558 702 R
7 X
0 0 0 1 0 0 0 K
V
162 666.34 558 678.01 R
V
0 10 Q
0 X
(315) 541.32 671.34 T
324 684 580 684 2 L
7 X
V
3 H
2 Z
0 X
N
512 90 558 125 R
7 X
V
1 60 Q
0 X
(n) 512.17 85 T
315 104 510 126 R
7 X
V
2 24 Q
0 X
(Routines) 407.33 110 T
90 99 270 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
90.67 123.5 270.67 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
0 10 Q
0 X
-0.67 (grabbed; if it equals zero, it is grabbed, but no threads are queued; otherwise,) 180 641.33 P
(it equals the handle of the \336rst thread queued.) 180 628.33 T
2 F
(Be Sure T) 99 608.33 T
(o:) 144.94 608.33 T
0 F
-0.78 (Make sure that all threads using the block use the) 180 608.33 P
4 F
-0.81 (MemThread\311\050\051) 407.94 608.33 P
0 F
-0.78 ( routines) 488.68 608.33 P
(to access the block \050not other data-access synchronization routines\051. Do not) 180 595.33 T
-0.49 (change the) 180 582.33 P
6 9 Q
-0.44 (HM) 232.16 582.33 P
6 10 Q
-0.49 (_otherInfo) 248.15 582.33 P
0 F
-0.49 ( word of the block\325) 295.17 582.33 P
-0.49 (s handle table entry \050the routines) 376.36 582.33 P
-0.43 (use that word as a semaphore\051. Make sure to release the block once for every) 180 569.33 P
-0.64 (time you grab it; the block is not unlocked until each of your grabs is released.) 180 556.33 P
2 F
(W) 99 536.33 T
(arnings:) 108.07 536.33 T
0 F
(If you try to release a block that you have not successfully grabbed, the) 180 536.33 T
(routine will fatal-error) 180 523.33 T
(.) 283.89 523.33 T
2 F
(See Also:) 99 503.33 T
0 F
(MemThreadGrab\050\051, MemThreadGrabNB\050\051) 180 503.33 T
81 486.99 531 492 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 486.99 531 492 R
7 X
0 0 0 1 0 0 0 K
V
50 490.99 609.01 490.99 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 478.99 T
2 F
(MemUnlock\050\051) 99 478.99 T
5 10 Q
(void) 99 464.33 T
3 F
(MemUnlock\050) 153 464.33 T
3 9 Q
(MemHandle) 153 453.99 T
(mh\051;) 261 453.99 T
(/* Handle of block to unlock */) 297 453.99 T
0 10 Q
(This routine decrements the lock count of the indicated block. If the lock) 180 436.33 T
(count reaches zero, the block becomes unlocked \050it can be moved, swapped,) 180 424.83 T
(or discarded\051. Do not try to unlock a block that has not been locked.) 180 413.33 T
2 F
(Include:) 99 394.83 T
0 F
(heap.h) 180 394.83 T
81 378.48 531 383.49 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 378.48 531 383.49 R
7 X
0 0 0 1 0 0 0 K
V
50 382.48 609.01 382.48 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 370.48 T
2 F
(MemUnlockExcl\050\051) 99 370.48 T
5 10 Q
(void) 99 355.82 T
3 F
(MemUnlockExcl\050) 153 355.82 T
3 9 Q
(memHandle) 153 345.48 T
(mh\051;) 261 345.48 T
(/* Handle of block to release */) 315 345.48 T
0 10 Q
(If a thread has gained access to a block with) 180 327.82 T
4 F
(MemLockExcl\050\051) 386.89 327.82 T
0 F
(, it should) 468.19 327.82 T
(release the block as soon as it can. Until it does, no other thread can access) 180 316.32 T
(the block for either shared or exclusive access. It can release the block by) 180 304.82 T
-0.18 (calling) 180 293.32 P
4 F
-0.19 (MemUnlockExcl\050\051) 213.53 293.32 P
0 F
-0.18 (. This routine unlocks the block and releases the) 306.31 293.32 P
(thread\325) 180 281.82 T
(s access to it. If there is a queue for this block, the highest-priority) 212.41 281.82 T
(thread waiting will be awakened, as described in) 180 270.32 T
4 F
(MemLockExcl\050\051) 408.39 270.32 T
0 F
(.) 489.69 270.32 T
2 F
(Include:) 99 251.82 T
0 F
(heap.h) 180 251.82 T
2 F
(T) 99 231.82 T
(ips and T) 104.93 231.82 T
(ricks:) 148.28 231.82 T
0 F
-0.46 (Y) 180 231.82 P
-0.46 (ou can \336nd out if the block is being accessed by looking at the) 185.93 231.82 P
6 9 Q
-0.41 (HM) 465.67 231.82 P
6 10 Q
-0.46 (_otherInfo) 481.66 231.82 P
0 F
(word \050with) 180 218.82 T
4 F
(MemGetInfo\050\051) 232.78 218.82 T
0 F
(\051. If) 305.36 218.82 T
6 9 Q
(HM) 324.43 218.82 T
6 10 Q
(_otherInfo) 340.42 218.82 T
0 F
( equals one, the block is not) 387.44 218.82 T
-0.67 (grabbed; if it equals zero, it is grabbed, but no threads are queued; otherwise,) 180 205.82 P
(it equals the handle of the \336rst thread queued.) 180 192.82 T
2 F
(Be Sure T) 99 172.82 T
(o:) 144.94 172.82 T
0 F
(Make sure that all routines accessing the block get access with) 180 172.82 T
4 F
(MemLockExcl\050\051) 180 159.82 T
0 F
( or) 261.3 159.82 T
4 F
(MemLockShared\050\051) 276.3 159.82 T
0 F
(. The routines use the block\325) 372.05 159.82 T
(s) 501.33 159.82 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "315" 15
%%Page: "316" 16
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
54 690.34 450 702 R
7 X
0 0 0 1 0 0 0 K
V
54 666.34 450 678.01 R
V
0 10 Q
0 X
(316) 54 671.34 T
32 684 288 684 2 L
7 X
V
3 H
2 Z
0 X
N
54 90 108 125 R
7 X
V
1 60 Q
0 X
(n) 58.17 85 T
104 104 299 126 R
7 X
V
2 24 Q
0 X
(Routines) 104 110 T
306 99 486 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
306 123.5 486 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
6 9 Q
0 X
-0.4 (HM) 180 641.33 P
6 10 Q
-0.44 (_otherInfo) 195.99 641.33 P
0 F
-0.44 ( word; you must not alter it. Call this routine while the block is) 243.01 641.33 P
(still locked; it will call) 180 628.33 T
4 F
(MemUnlock\050\051) 284.48 628.33 T
0 F
( to unlock the block.) 354.48 628.33 T
2 F
(W) 99 608.33 T
(arnings:) 108.07 608.33 T
0 F
-0.47 (If you call this routine on a block which you have not gained access to, it may) 180 608.33 P
(fatal-error) 180 595.33 T
(.) 227.4 595.33 T
2 F
(See Also:) 99 575.33 T
0 F
(MemLockExcl\050\051, MemLockShared\050\051, MemUnlockShared\050\051) 180 575.33 T
81 558.99 531 564 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 558.99 531 564 R
7 X
0 0 0 1 0 0 0 K
V
50 562.99 609.01 562.99 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 550.99 T
2 F
(MemUnlockFixedOrMovable\050\051) 99 550.99 T
5 10 Q
(void) 99 537.33 T
3 F
(MemUnlockFixedOrMovable\050) 153 537.33 T
3 9 Q
(void) 153 526.99 T
(* ptr\051;) 189 526.99 T
(/* virtual segment */) 279 526.99 T
0 10 Q
(This routine unlocks a previously locked, movable virtual segment. Do not) 180 509.33 T
(call this routine with normal locked or \336xed blocks; only call it for those) 180 497.83 T
(blocks locked with) 180 486.33 T
4 F
(MemLockFixedOrMovable\050\051) 267.24 486.33 T
0 F
(.) 412.6 486.33 T
2 F
(Include:) 99 467.83 T
0 F
(heap.h) 180 467.83 T
81 451.48 531 456.49 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 451.48 531 456.49 R
7 X
0 0 0 1 0 0 0 K
V
50 455.48 609.01 455.48 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 443.48 T
2 F
(MemUnlockShared\050\051) 99 443.48 T
5 10 Q
(void) 99 428.82 T
3 F
(MemUnlockShared\050) 153 428.82 T
3 9 Q
(MemHandle) 153 418.48 T
(mh\051;) 261 418.48 T
(/* Handle of block to release */) 297 418.48 T
0 10 Q
-0.04 (If a thread has gained access to a block with) 180 400.82 P
4 F
-0.04 (MemLockShared\050\051) 386.47 400.82 P
0 F
-0.04 (, it should) 482.22 400.82 P
-0.14 (release the block as soon as it can. Until it does, no thread can be awakened) 180 389.32 P
(from the queue. It can release the block by calling) 180 377.82 T
4 F
(MemUnlockShared\050\051) 412.81 377.82 T
0 F
(.) 520.04 377.82 T
(This routine calls) 180 366.32 T
4 F
(MemUnlock\050\051) 263.53 366.32 T
0 F
(, decrementing the block\325) 333.53 366.32 T
(s lock count; it) 448.54 366.32 T
(then releases the thread\325) 180 354.82 T
(s access to it. If no other thread is accessing the) 294.27 354.82 T
-0.24 (block and there is a queue for this block, the highest-priority thread waiting) 180 343.32 P
(will be awakened, as described in) 180 331.82 T
4 F
(MemLockExcl\050\051) 337.08 331.82 T
0 F
(.) 418.38 331.82 T
2 F
(Include:) 99 313.32 T
0 F
(heap.h) 180 313.32 T
2 F
(T) 99 293.32 T
(ips and T) 104.93 293.32 T
(ricks:) 148.28 293.32 T
0 F
-0.46 (Y) 180 293.32 P
-0.46 (ou can \336nd out if the block is being accessed by looking at the) 185.93 293.32 P
6 9 Q
-0.41 (HM) 465.67 293.32 P
6 10 Q
-0.46 (_otherInfo) 481.66 293.32 P
0 F
(word \050with) 180 280.32 T
4 F
(MemGetInfo\050\051) 232.78 280.32 T
0 F
(\051. If) 305.36 280.32 T
6 9 Q
(HM) 324.43 280.32 T
6 10 Q
(_otherInfo) 340.42 280.32 T
0 F
( equals one, the block is not) 387.44 280.32 T
-0.67 (grabbed; if it equals zero, it is grabbed, but no threads are queued; otherwise,) 180 267.32 P
(it equals the handle of the \336rst thread queued.) 180 254.32 T
2 F
(Be Sure T) 99 234.32 T
(o:) 144.94 234.32 T
0 F
(Make sure that all routines accessing the block get access with) 180 234.32 T
4 F
(MemLockExcl\050\051) 180 221.32 T
0 F
( or) 261.3 221.32 T
4 F
(MemLockShared\050\051) 276.3 221.32 T
0 F
(. These routines use the block\325) 372.05 221.32 T
(s) 510.96 221.32 T
6 9 Q
-0.4 (HM) 180 208.32 P
6 10 Q
-0.44 (_otherInfo) 195.99 208.32 P
0 F
-0.44 ( word; you must not alter it. Call this routine while the block is) 243.01 208.32 P
(still locked; it will call) 180 195.32 T
4 F
(MemUnlock\050\051) 284.48 195.32 T
0 F
( to unlock the block.) 354.48 195.32 T
2 F
(W) 99 175.32 T
(arnings:) 108.07 175.32 T
0 F
-0.47 (If you call this routine on a block which you have not gained access to, it may) 180 175.32 P
(fatal-error) 180 162.32 T
(.) 227.4 162.32 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "316" 16
%%Page: "317" 17
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
162 690.34 558 702 R
7 X
0 0 0 1 0 0 0 K
V
162 666.34 558 678.01 R
V
0 10 Q
0 X
(317) 541.32 671.34 T
324 684 580 684 2 L
7 X
V
3 H
2 Z
0 X
N
512 90 558 125 R
7 X
V
1 60 Q
0 X
(n) 512.17 85 T
315 104 510 126 R
7 X
V
2 24 Q
0 X
(Routines) 407.33 110 T
90 99 270 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
90.67 123.5 270.67 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
2 10 Q
0 X
(See Also:) 99 641.33 T
0 F
(MemLockExcl\050\051, MemLockShared\050\051, MemUnlockExcl\050\051) 180 641.33 T
81 624.99 531 630 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 624.99 531 630 R
7 X
0 0 0 1 0 0 0 K
V
50 628.99 609.01 628.99 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 616.99 T
2 F
(MemUnlockV\050\051) 99 616.99 T
5 10 Q
(void) 99 602.33 T
3 F
(MemUnlockV\050) 153 602.33 T
3 9 Q
(MemHandle) 153 591.99 T
(mh\051;) 261 591.99 T
(/* Handle of block to release */) 315 591.99 T
0 10 Q
(This routine unlocks a block with) 180 574.33 T
4 F
(MemUnlock\050\051) 336.88 574.33 T
0 F
(, then releases its) 406.88 574.33 T
(semaphore with) 180 562.83 T
4 F
(HandleV\050\051) 256.86 562.83 T
0 F
(. Do not use this routine unless the block\325) 309.82 562.83 T
(s) 500.22 562.83 T
(semaphore was grabbed and the block locked \050typically with the) 180 551.33 T
4 F
(MemPLock\050\051) 180 539.83 T
0 F
( routine\051.) 246.11 539.83 T
2 F
(Include:) 99 521.33 T
0 F
(heap.h) 180 521.33 T
2 F
(T) 99 501.33 T
(ips and T) 104.93 501.33 T
(ricks:) 148.28 501.33 T
0 F
-0.46 (Y) 180 501.33 P
-0.46 (ou can \336nd out if the block is being accessed by looking at the) 185.93 501.33 P
6 9 Q
-0.41 (HM) 465.67 501.33 P
6 10 Q
-0.46 (_otherInfo) 481.66 501.33 P
0 F
(word \050with) 180 488.33 T
4 F
(MemGetInfo\050\051) 232.78 488.33 T
0 F
(\051. If) 305.36 488.33 T
6 9 Q
(HM) 324.43 488.33 T
6 10 Q
(_otherInfo) 340.42 488.33 T
0 F
( equals one, the block is not) 387.44 488.33 T
-0.67 (grabbed; if it equals zero, it is grabbed, but no threads are queued; otherwise,) 180 475.33 P
(it equals the handle of the \336rst thread queued.) 180 462.33 T
2 F
(Be Sure T) 99 442.33 T
(o:) 144.94 442.33 T
0 F
(Make sure that all threads accessing the block use) 180 442.33 T
4 F
(HandleP\050\051) 415.96 442.33 T
0 F
( or) 468.92 442.33 T
4 F
(MemPLock\050\051) 180 429.33 T
0 F
( to access the thread. These routines use the) 246.11 429.33 T
6 9 Q
(HM) 453.72 429.33 T
6 10 Q
(_otherInfo) 469.71 429.33 T
0 F
(\336eld of the handle table entry; do not alter this \336eld.) 180 416.33 T
2 F
(W) 99 396.33 T
(arnings:) 108.07 396.33 T
0 F
(Do not use this on a block unless you have grabbed it. The routine does not) 180 396.33 T
(check to see that you have grabbed the thread; it just clears the semaphore) 180 383.33 T
(and returns.) 180 370.33 T
2 F
(Never Use Situations:) 99 350.33 T
0 F
-0.33 (Never use this routine to release a \336xed block. It will try to unlock the block;) 180 337.33 P
(\336xed blocks cannot be locked or unlocked. Instead, call) 180 324.33 T
4 F
(HandleV\050\051) 434.66 324.33 T
0 F
( directly) 487.62 324.33 T
(.) 524.47 324.33 T
2 F
(See Also:) 99 304.33 T
0 F
(MemPLock\050\051, HandleP\050\051, HandleV\050\051) 180 304.33 T
81 287.98 531 292.99 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 287.98 531 292.99 R
7 X
0 0 0 1 0 0 0 K
V
50 291.98 609.01 291.98 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 279.98 T
2 F
(MemUpgradeSharedLock\050\051) 99 279.98 T
5 10 Q
(void) 99 266.32 T
3 F
(* MemUpgradeSharedLock\050) 153 266.32 T
3 9 Q
(MemHandle) 153 255.98 T
(mh\051;) 261 255.98 T
(/* handle of locked block */) 315 255.98 T
0 10 Q
(This routine upgrades a shared lock on the block to an exclusive lock, as if) 180 238.32 T
-0.65 (the caller had used MemLockExcl\050\051. If other threads have access to the block,) 180 226.82 P
(the caller will sleep in the access queue until it can gain exclusive access.) 180 215.32 T
(This routine returns the pointer of the locked block because, if the caller) 180 196.82 T
(sleeps in the queue, the memory block could move between the call and the) 180 185.32 T
(granting of access.) 180 173.82 T
2 F
(Include:) 99 155.32 T
0 F
(heap.h) 180 155.32 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "317" 17
%%Page: "318" 18
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
54 690.34 450 702 R
7 X
0 0 0 1 0 0 0 K
V
54 666.34 450 678.01 R
V
0 10 Q
0 X
(318) 54 671.34 T
32 684 288 684 2 L
7 X
V
3 H
2 Z
0 X
N
54 90 108 125 R
7 X
V
1 60 Q
0 X
(n) 58.17 85 T
104 104 299 126 R
7 X
V
2 24 Q
0 X
(Routines) 104 110 T
306 99 486 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
306 123.5 486 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
2 10 Q
0 X
(See Also:) 99 641.33 T
0 F
(MemLockExcl\050\051, MemLockShared\050\051, MemDowngradeExclLock\050\051) 180 641.33 T
81 624.99 531 630 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 624.99 531 630 R
7 X
0 0 0 1 0 0 0 K
V
50 628.99 609.01 628.99 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 616.99 T
2 F
(MessageSetDestination\050\051) 99 616.99 T
5 10 Q
(void) 99 603.33 T
3 F
(MessageSetDestination\050) 153 603.33 T
3 9 Q
(EventHandle) 153 592.99 T
(event,) 261 592.99 T
(/* handle of the event to be modified */) 315 592.99 T
(optr) 153 582.99 T
(dest\051;) 261 582.99 T
(/* new destination for the event */) 315 582.99 T
0 10 Q
(This routine sets the destination of an event to the optr passed.) 180 565.33 T
2 F
(Include:) 99 546.83 T
0 F
(object.h) 180 546.83 T
81 530.48 531 535.49 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 530.48 531 535.49 R
7 X
0 0 0 1 0 0 0 K
V
50 534.48 609.01 534.48 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 522.48 T
2 F
(NameArrayAdd\050\051) 99 522.48 T
5 10 Q
(word) 99 507.82 T
3 F
(NameArrayAdd\050) 153 507.82 T
3 9 Q
(optr) 153 497.48 T
(arr,) 261 497.48 T
(/* optr of name array */) 333 497.48 T
(const char) 153 487.48 T
(* nameToAdd,) 261 487.48 T
(/* Name of new element */) 333 487.48 T
(word) 153 477.48 T
(nameLength,) 261 477.48 T
(/* Length of name; pass zero if) 333 477.48 T
( * name string is null-terminated */) 315 467.48 T
(NameArrayAddFlags) 153 457.48 T
(flags,) 261 457.48 T
(/* Described below */) 333 457.48 T
(const) 153 447.48 T
(void) 189 447.48 T
(* data\051;) 261 447.48 T
(/* Copy this data to new element */) 333 447.48 T
0 10 Q
-0.79 (This routine creates a new element in a name array) 180 429.82 P
-0.79 (, copying the passed name) 411.24 429.82 P
(and data into the new element. If no element with the passed name exists,) 180 418.32 T
4 F
(NameArrayAdd\050\051) 180 406.82 T
0 F
( will create the element and return its token. If an) 268.71 406.82 T
-0.38 (element with the same name already exists, the existing element\325) 180 395.32 P
-0.38 (s reference) 478.82 395.32 P
(count will be incremented and its token will be returned. The routine takes) 180 383.82 T
(the following arguments:) 180 372.32 T
6 F
(array) 180 353.82 T
0 F
(The optr of the name array) 243 353.82 T
(.) 366.9 353.82 T
6 F
(nameT) 180 335.82 T
(oAdd) 211.14 335.82 T
0 F
(The name of the new element. This string may contain nulls.) 243 324.82 T
6 F
(nameLength) 180 306.82 T
0 F
(The length of the name string, in bytes. If you pass zero,) 243 295.82 T
4 F
(NameArrayAdd\050\051) 243 284.82 T
0 F
( will assume the string is null-terminated.) 331.71 284.82 T
6 F
(\337ags) 180 266.82 T
0 F
(A record of) 243 266.82 T
4 F
(NameArrayAddFlags) 295.95 266.82 T
0 F
(, described below) 404.84 266.82 T
(.) 482.45 266.82 T
6 F
(data) 180 248.82 T
0 F
(The data to copy into the new element.) 243 248.82 T
2 F
(Structures:) 99 230.82 T
0 F
(The argument is passed a set of) 180 230.82 T
4 F
(NameArrayAddFlags) 329.1 230.82 T
0 F
(. Only one \337ag is) 437.99 230.82 T
(currently de\336ned:) 180 219.82 T
0 9 Q
(NAAF_SET_DA) 180 201.82 T
(T) 246.51 201.82 T
(A_ON_REPLACE) 252.02 201.82 T
0 10 Q
-0.66 (If an element with the speci\336ed name exists and this \337ag is set,) 243 190.82 P
-0.5 (the data passed will be copied into the data area of the existing) 243 179.82 P
-0.06 (element. If this \337ag is not set, the existing element will not be) 243 168.82 P
(changed.) 243 157.82 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "318" 18
%%Page: "319" 19
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
162 690.34 558 702 R
7 X
0 0 0 1 0 0 0 K
V
162 666.34 558 678.01 R
V
0 10 Q
0 X
(319) 541.32 671.34 T
324 684 580 684 2 L
7 X
V
3 H
2 Z
0 X
N
512 90 558 125 R
7 X
V
1 60 Q
0 X
(n) 512.17 85 T
315 104 510 126 R
7 X
V
2 24 Q
0 X
(Routines) 407.33 110 T
90 99 270 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
90.67 123.5 270.67 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
2 10 Q
0 X
(W) 99 641.33 T
(arnings:) 108.07 641.33 T
0 F
-0.28 (This routine may resize the name array; therefore, all pointers to the LMem) 180 641.33 P
(heap are invalidated.) 180 628.33 T
2 F
(Include:) 99 608.33 T
0 F
(chunkarr) 180 608.33 T
(.h) 222.4 608.33 T
81 591.99 531 597 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 591.99 531 597 R
7 X
0 0 0 1 0 0 0 K
V
50 595.99 609.01 595.99 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 583.99 T
2 F
(NameArrayAddHandles\050\051) 99 583.99 T
5 10 Q
(dword) 99 569.33 T
3 F
(NameArrayAddHandles\050) 153 569.33 T
3 9 Q
(MemHandle) 153 558.99 T
(mh,) 261 558.99 T
(/* Handle of LMem heap */) 333 558.99 T
(ChunkHandle) 153 548.99 T
(arr,) 261 548.99 T
(/* Chunk handle of name array */) 333 548.99 T
(const char *) 153 538.99 T
(nameToAdd,) 261 538.99 T
(/* Name of new element */) 333 538.99 T
(word) 153 528.99 T
(nameLength,) 261 528.99 T
(/* Length of name; pass zero if) 333 528.99 T
( * name string is null-terminated */) 315 518.99 T
(NameArrayAddFlags) 153 508.99 T
(flags,) 261 508.99 T
(/* Described below */) 333 508.99 T
(const) 153 498.99 T
(void *) 189 498.99 T
(data\051;) 261 498.99 T
(/* Copy this data to new element */) 333 498.99 T
0 10 Q
(This routine is exactly like) 180 481.33 T
4 F
(NameArrayAdd\050\051) 305.95 481.33 T
0 F
( above, except that the name) 394.66 481.33 T
(array is speci\336ed by its global and chunk handles \050instead of with an optr\051.) 180 469.83 T
2 F
(W) 99 451.33 T
(arnings:) 108.07 451.33 T
0 F
-0.3 (This routine may resize the name array; therefore, all pointers to within the) 180 451.33 P
(LMem heap are invalidated.) 180 438.33 T
2 F
(Include:) 99 418.33 T
0 F
(chunkarr) 180 418.33 T
(.h) 222.4 418.33 T
81 401.98 531 406.99 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 401.98 531 406.99 R
7 X
0 0 0 1 0 0 0 K
V
50 405.98 609.01 405.98 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 393.98 T
2 F
(NameArrayChangeName\050\051) 99 393.98 T
5 10 Q
(void) 99 379.32 T
3 F
(NameArrayChangeName\050) 153 379.32 T
3 9 Q
(optr) 153 368.98 T
(array,) 261 368.98 T
(/* optr of name array */) 315 368.98 T
(word) 153 358.98 T
(token,) 261 358.98 T
(/* Token of element to be changed */) 315 358.98 T
(const char *) 153 348.98 T
(newName,) 261 348.98 T
(/* New name for element */) 315 348.98 T
(word) 153 338.98 T
(nameLength\051;) 261 338.98 T
(/* Length of name in bytes; pass) 333 338.98 T
( * zero if name string is) 315 328.98 T
( * null-terminated */) 315 318.98 T
0 10 Q
(This routine changes the name of an element in a name array) 180 301.32 T
(.) 464.3 301.32 T
2 F
(W) 99 282.82 T
(arnings:) 108.07 282.82 T
0 F
-0.74 (If the new name is longer than the old, the chunk will be resized, invalidating) 180 282.82 P
(all pointers to within the LMem heap.) 180 269.82 T
2 F
(Include:) 99 249.82 T
0 F
(chunkarr) 180 249.82 T
(.h) 222.4 249.82 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "319" 19
%%Page: "320" 20
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
54 690.34 450 702 R
7 X
0 0 0 1 0 0 0 K
V
54 666.34 450 678.01 R
V
0 10 Q
0 X
(320) 54 671.34 T
32 684 288 684 2 L
7 X
V
3 H
2 Z
0 X
N
54 90 108 125 R
7 X
V
1 60 Q
0 X
(n) 58.17 85 T
104 104 299 126 R
7 X
V
2 24 Q
0 X
(Routines) 104 110 T
306 99 486 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
306 123.5 486 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
81 642.99 531 648 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 642.99 531 648 R
7 X
0 0 0 1 0 0 0 K
V
50 646.99 609.01 646.99 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 634.99 T
2 F
(NameArrayChangeNameHandles\050\051) 99 634.99 T
5 10 Q
(dword) 99 620.33 T
3 F
(NameArrayChangeNameHandles\050) 153 620.33 T
3 9 Q
(MemHandle) 153 609.99 T
(mh,) 261 609.99 T
(/* Handle of LMem heap */) 333 609.99 T
(ChunkHandle) 153 599.99 T
(array,) 261 599.99 T
(/* Chunk handle of name array */) 333 599.99 T
(word) 153 589.99 T
(token,) 261 589.99 T
(/* Token of element to be changed */) 333 589.99 T
(const char *) 153 579.99 T
(newName,) 261 579.99 T
(/* New name for element */) 333 579.99 T
(word) 153 569.99 T
(nameLength\051;) 261 569.99 T
(/* Length of name in bytes; pass) 333 569.99 T
( * zero if name string is) 315 559.99 T
( * null-terminated */) 315 549.99 T
0 10 Q
-0.14 (This routine is exactly like) 180 532.33 P
4 F
-0.14 (NameArrayChangeName\050\051) 305.25 532.33 P
0 F
-0.14 ( above, except that) 442.28 532.33 P
-0.06 (the name array is speci\336ed by its global and chunk handles \050instead of with) 180 520.83 P
(an optr\051.) 180 509.33 T
2 F
(W) 99 490.83 T
(arnings:) 108.07 490.83 T
0 F
-0.74 (If the new name is longer than the old, the chunk will be resized, invalidating) 180 490.83 P
(all pointers to within the LMem heap.) 180 477.83 T
2 F
(Include:) 99 457.83 T
0 F
(chunkarr) 180 457.83 T
(.h) 222.4 457.83 T
81 441.48 531 446.49 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 441.48 531 446.49 R
7 X
0 0 0 1 0 0 0 K
V
50 445.48 609.01 445.48 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 433.48 T
2 F
(NameArrayCreate\050\051) 99 433.48 T
5 10 Q
(ChunkHandle) 99 418.82 T
3 F
(NameArrayCreate\050) 171 418.82 T
3 9 Q
(MemHandle) 153 408.48 T
(mh,) 261 408.48 T
(/* Global handle of LMem heap */) 333 408.48 T
(word) 153 398.48 T
(dataSize,) 261 398.48 T
(/* Size of data section for) 333 398.48 T
( * each element */) 315 388.48 T
(word) 153 378.48 T
(headerSize\051;) 261 378.48 T
(/* Size of header; pass) 333 378.48 T
( * zero for default header */) 315 368.48 T
0 10 Q
-0.02 (This routine creates a name array in the indicated LMem heap. It creates a) 180 350.82 P
4 F
(NameArrayHeader) 180 339.32 T
0 F
( structure at the head of a new chunk. If you want to) 278.15 339.32 T
(leave extra space before the start of the array) 180 327.82 T
(, you can pass a larger header) 389.28 327.82 T
(size; if you want to use the standard header) 180 316.32 T
(, pass a header size of zero.) 381.32 316.32 T
-0.61 (Y) 180 297.82 P
-0.61 (ou must specify the size of the data portion of each element when you create) 185.93 297.82 P
(the array) 180 286.32 T
(. The name portion will be variable sized.) 222.04 286.32 T
2 F
(Include:) 99 267.82 T
0 F
(chunkarr) 180 267.82 T
(.h) 222.4 267.82 T
2 F
(T) 99 247.82 T
(ips and T) 104.93 247.82 T
(ricks:) 148.28 247.82 T
0 F
(If you want extra space after the) 180 247.82 T
4 F
(NameArrayHeader) 333.53 247.82 T
0 F
(, you may want to) 430.94 247.82 T
(create your own header structure, the \336rst element of which is a) 180 234.82 T
4 F
(NameArrayHeader) 180 221.82 T
0 F
(. Y) 277.41 221.82 T
(ou can pass the size of this header to) 288.9 221.82 T
4 F
(NameArrayCreate\050\051) 180 208.82 T
0 F
( and access the data in your header via the structure) 282.6 208.82 T
(\336elds.) 180 195.82 T
2 F
(Be Sure T) 99 175.82 T
(o:) 144.94 175.82 T
0 F
(Lock the block on the global heap before calling this routine \050unless it is) 180 175.82 T
(\336xed\051. If you pass a header size, make sure it is larger than) 180 162.82 T
4 F
(sizeof\050NameArrayHeader\051) 180 149.82 T
0 F
(.) 315.74 149.82 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "320" 20
%%Page: "321" 21
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
162 690.34 558 702 R
7 X
0 0 0 1 0 0 0 K
V
162 666.34 558 678.01 R
V
0 10 Q
0 X
(321) 541.32 671.34 T
324 684 580 684 2 L
7 X
V
3 H
2 Z
0 X
N
512 90 558 125 R
7 X
V
1 60 Q
0 X
(n) 512.17 85 T
315 104 510 126 R
7 X
V
2 24 Q
0 X
(Routines) 407.33 110 T
90 99 270 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
90.67 123.5 270.67 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
2 10 Q
0 X
(Include:) 99 641.33 T
0 F
(chunkarr) 180 641.33 T
(.h) 222.4 641.33 T
81 624.99 531 630 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 624.99 531 630 R
7 X
0 0 0 1 0 0 0 K
V
50 628.99 609.01 628.99 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 616.99 T
2 F
(NameArrayCreateAt\050\051) 99 616.99 T
5 10 Q
(ChunkHandle) 99 602.33 T
3 F
(NameArrayCreateAt\050) 171 602.33 T
3 9 Q
(optr) 153 591.99 T
(array,) 189 591.99 T
(/* Turn this chunk into a name array */) 261 591.99 T
(word) 153 581.99 T
(dataSize,) 189 581.99 T
(/* Size of data section of each element */) 261 581.99 T
(word) 153 571.99 T
(headerSize\051;) 189 571.99 T
(/* Size of header; pass zero for default header */) 261 571.99 T
0 10 Q
-0.84 (This routine is just like) 180 554.33 P
4 F
-0.87 (NameArrayCreate\050\051) 286.56 554.33 P
0 F
-0.84 ( above, except that the element) 389.16 554.33 P
(array is created in a pre-existing chunk. The contents of that chunk will be) 180 542.83 T
(destroyed.) 180 531.33 T
2 F
(Include:) 99 512.83 T
0 F
(chunkarr) 180 512.83 T
(.h) 222.4 512.83 T
2 F
(W) 99 492.83 T
(arnings:) 108.07 492.83 T
0 F
(If the chunk isn\325) 180 492.83 T
(t large enough, it will be resized. This will invalidate all) 255.19 492.83 T
(pointers to chunks in that block.) 180 479.83 T
2 F
(Include:) 99 459.83 T
0 F
(chunkarr) 180 459.83 T
(.h) 222.4 459.83 T
81 443.48 531 448.49 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 443.48 531 448.49 R
7 X
0 0 0 1 0 0 0 K
V
50 447.48 609.01 447.48 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 435.48 T
2 F
(NameArrayCreateAtHandles\050\051) 99 435.48 T
5 10 Q
(ChunkHandle) 99 420.82 T
3 F
(NameArrayCreateAtHandles\050) 171 420.82 T
3 9 Q
(MemHandle) 153 410.48 T
(mh,) 261 410.48 T
(/* Global handle of LMem heap */) 333 410.48 T
(ChunkHandle) 153 400.48 T
(chunk,) 261 400.48 T
(/* the chunk for the array */) 333 400.48 T
(word) 153 390.48 T
(dataSize,) 261 390.48 T
(/* Size of data for each element */) 333 390.48 T
(word) 153 380.48 T
(headerSize\051;) 261 380.48 T
(/* Size of header; pass) 333 380.48 T
( * zero for default header */) 315 370.48 T
0 10 Q
(This routine is exactly like) 180 352.82 T
4 F
(NameArrayCreateAt\050\051) 305.95 352.82 T
0 F
( above, except that the) 420.4 352.82 T
(name array is speci\336ed by its global and chunk handles \050instead of with an) 180 341.32 T
(optr\051.) 180 329.82 T
2 F
(Include:) 99 311.32 T
0 F
(chunkarr) 180 311.32 T
(.h) 222.4 311.32 T
2 F
(W) 99 291.32 T
(arnings:) 108.07 291.32 T
0 F
(If the chunk isn\325) 180 291.32 T
(t large enough, it will be resized. This will invalidate all) 255.19 291.32 T
(pointers to chunks in that block.) 180 278.32 T
2 F
(Include:) 99 258.32 T
0 F
(chunkarr) 180 258.32 T
(.h) 222.4 258.32 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "321" 21
%%Page: "322" 22
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
54 690.34 450 702 R
7 X
0 0 0 1 0 0 0 K
V
54 666.34 450 678.01 R
V
0 10 Q
0 X
(322) 54 671.34 T
32 684 288 684 2 L
7 X
V
3 H
2 Z
0 X
N
54 90 108 125 R
7 X
V
1 60 Q
0 X
(n) 58.17 85 T
104 104 299 126 R
7 X
V
2 24 Q
0 X
(Routines) 104 110 T
306 99 486 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
306 123.5 486 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
81 642.99 531 648 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 642.99 531 648 R
7 X
0 0 0 1 0 0 0 K
V
50 646.99 609.01 646.99 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 634.99 T
2 F
(NameArrayFind\050\051) 99 634.99 T
5 10 Q
(word) 99 620.33 T
3 F
(NameArrayFind\050) 153 620.33 T
3 9 Q
(optr) 153 609.99 T
(array,) 261 609.99 T
(/* optr to name array */) 333 609.99 T
(const char) 153 599.99 T
(* nameToFind,) 261 599.99 T
(/* Find element with this name */) 333 599.99 T
(word) 153 589.99 T
(nameLength,) 261 589.99 T
(/* Pass zero if name string is) 333 589.99 T
( * null-terminated */) 315 579.99 T
(void *) 153 569.99 T
(returnData\051;) 261 569.99 T
(/* Copy data section into this) 333 569.99 T
( * buffer */) 315 559.99 T
0 10 Q
-0.82 (This routine locates the element with the speci\336ed name. It returns the token) 180 542.33 P
-0.55 (of the element and copies its data section into the passed buffer) 180 530.83 P
-0.55 (. If there is no) 466.36 530.83 P
(element with the speci\336ed name, the routine will return) 180 519.33 T
0 9 Q
(CA_NULL_ELEMENT) 180 507.83 T
0 10 Q
(. The routine takes the following arguments:) 275.08 507.83 T
6 F
(array) 180 489.33 T
0 F
(The optr of the name array) 243 489.33 T
(.) 366.9 489.33 T
6 F
(nameT) 180 471.33 T
(oAdd) 211.14 471.33 T
0 F
-0.37 (The name of the element to \336nd. This string may contain nulls.) 243 460.33 P
6 F
(nameLength) 180 442.33 T
0 F
(The length of the name string, in bytes. If you pass zero,) 243 431.33 T
4 F
(NameArrayFind\050\051) 243 420.33 T
0 F
( will assume the string is null-terminated.) 335.22 420.33 T
6 F
(returnData) 180 402.33 T
0 F
(The data section of the element is written to this buffer) 243 402.33 T
(.) 497.66 402.33 T
2 F
(Include:) 99 384.33 T
0 F
(chunkarr) 180 384.33 T
(.h) 222.4 384.33 T
2 F
(W) 99 364.33 T
(arnings:) 108.07 364.33 T
0 F
(Y) 180 364.33 T
(ou must make sure the) 185.93 364.33 T
6 F
(returnData) 295.02 364.33 T
0 F
( buffer is large enough to hold an) 346.86 364.33 T
(element\325) 180 351.33 T
(s data portion; otherwise, data after the buffer will be overwritten.) 218.71 351.33 T
81 334.98 531 339.99 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 334.98 531 339.99 R
7 X
0 0 0 1 0 0 0 K
V
50 338.98 609.01 338.98 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 326.98 T
2 F
(NameArrayFindHandles\050\051) 99 326.98 T
5 10 Q
(word) 99 312.32 T
3 F
(NameArrayFindHandles\050) 153 312.32 T
3 9 Q
(MemHandle) 153 301.98 T
(mh,) 261 301.98 T
(/* Handle of LMem heap */) 333 301.98 T
(ChunkHandle) 153 291.98 T
(array,) 261 291.98 T
(/* Handle of name array */) 333 291.98 T
(const char *) 153 281.98 T
(nameToFind,) 261 281.98 T
(/* Find element with this name */) 333 281.98 T
(word) 153 271.98 T
(nameLength,) 261 271.98 T
(/* Pass zero if name string is) 333 271.98 T
( * null-terminated */) 315 261.98 T
(void *) 153 251.98 T
(returnData\051;) 261 251.98 T
(/* Copy data section into this) 333 251.98 T
( * buffer */) 315 241.98 T
0 10 Q
-0.23 (This routine is exactly like) 180 224.32 P
4 F
-0.24 (NameArrayFind\050\051) 304.78 224.32 P
0 F
-0.23 ( above, except that the name) 397 224.32 P
(array is speci\336ed by its global and chunk handles \050instead of with an optr\051.) 180 212.82 T
2 F
(Include:) 99 194.32 T
0 F
(chunkarr) 180 194.32 T
(.h) 222.4 194.32 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "322" 22
%%Page: "323" 23
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
162 690.34 558 702 R
7 X
0 0 0 1 0 0 0 K
V
162 666.34 558 678.01 R
V
0 10 Q
0 X
(323) 541.32 671.34 T
324 684 580 684 2 L
7 X
V
3 H
2 Z
0 X
N
512 90 558 125 R
7 X
V
1 60 Q
0 X
(n) 512.17 85 T
315 104 510 126 R
7 X
V
2 24 Q
0 X
(Routines) 407.33 110 T
90 99 270 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
90.67 123.5 270.67 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
81 642.99 531 648 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 642.99 531 648 R
7 X
0 0 0 1 0 0 0 K
V
50 646.99 609.01 646.99 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 634.99 T
2 F
(NEC\050\051) 99 634.99 T
3 10 Q
(NEC\050) 99 621.33 T
7 F
(line) 123 621.33 T
3 F
(\051) 147 621.33 T
0 F
(This macro de\336nes a line of code that will only be compiled into the) 180 603.33 T
6 F
(non) 180 591.83 T
0 F
(-error) 197.22 591.83 T
(-checking version of the geode. The) 223.69 591.83 T
6 F
(line) 387.95 591.83 T
0 F
( parameter of the macro is) 405.16 591.83 T
-0.29 (the actual line of code. When the non-) 180 580.33 P
0 9 Q
-0.26 (EC) 352.43 580.33 P
0 10 Q
-0.29 ( version of the program is compiled,) 365.42 580.33 P
(the line will be treated as a normal line of code; when the) 180 568.83 T
0 9 Q
(EC) 447.46 568.83 T
0 10 Q
( version is) 460.46 568.83 T
(compiled, the line will be ignored.) 180 557.33 T
2 F
(Include:) 99 538.83 T
0 F
(ec.h) 180 538.83 T
81 522.48 531 527.49 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 522.48 531 527.49 R
7 X
0 0 0 1 0 0 0 K
V
50 526.48 609.01 526.48 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 514.48 T
2 F
(ObjBlockGetOutput\050\051) 99 514.48 T
5 10 Q
(optr) 99 500.82 T
3 F
(ObjBlockGetOutput\050) 153 500.82 T
3 9 Q
(MemHandle mh\051;) 153 490.48 T
(/* handle of the subject object block */) 279 490.48 T
0 10 Q
(This routine returns the optr of the output destination object set for the) 180 472.82 T
-0.3 (speci\336ed object block. The output object is stored in the object block\325) 180 461.32 P
-0.3 (s header) 489.55 461.32 P
(in the) 180 449.82 T
6 9 Q
(OLMBH) 209.82 449.82 T
6 10 Q
(_output) 245.32 449.82 T
0 F
( \336eld. If the block has no output set, NullOptr will be) 280.32 449.82 T
(returned.) 180 438.32 T
2 F
(Include:) 99 419.82 T
0 F
(object.h) 180 419.82 T
2 F
(See Also:) 99 399.82 T
0 F
(ObjLMemBlockHeader) 180 399.82 T
81 383.48 531 388.48 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 383.48 531 388.48 R
7 X
0 0 0 1 0 0 0 K
V
50 387.48 609.01 387.48 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 375.48 T
2 F
(ObjBlockSetOutput\050\051) 99 375.48 T
5 10 Q
(void) 99 361.81 T
3 F
(ObjBlockSetOutput\050) 153 361.81 T
3 9 Q
(MemHandle) 153 351.48 T
(mh,) 261 351.48 T
(/* handle of the subject object block */) 315 351.48 T
(optr) 153 341.48 T
(o\051;) 261 341.48 T
(/* optr of the new output object */) 315 341.48 T
0 10 Q
(This routine sets the) 180 323.81 T
6 9 Q
(OLMBH) 278.53 323.81 T
6 10 Q
(_output) 314.03 323.81 T
0 F
( \336eld in the speci\336ed object block\325) 349.03 323.81 T
(s) 502.38 323.81 T
(header) 180 312.31 T
(. The optr passed in) 211.11 312.31 T
6 F
(o) 305.2 312.31 T
0 F
( will be set as the block\325) 310.2 312.31 T
(s output.) 419.13 312.31 T
2 F
(Include:) 99 293.81 T
0 F
(object.h) 180 293.81 T
2 F
(See Also:) 99 273.81 T
0 F
(ObjLMemBlockHeader) 180 273.81 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "323" 23
%%Page: "324" 24
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
54 690.34 450 702 R
7 X
0 0 0 1 0 0 0 K
V
54 666.34 450 678.01 R
V
0 10 Q
0 X
(324) 54 671.34 T
32 684 288 684 2 L
7 X
V
3 H
2 Z
0 X
N
54 90 108 125 R
7 X
V
1 60 Q
0 X
(n) 58.17 85 T
104 104 299 126 R
7 X
V
2 24 Q
0 X
(Routines) 104 110 T
306 99 486 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
306 123.5 486 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
81 642.99 531 648 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 642.99 531 648 R
7 X
0 0 0 1 0 0 0 K
V
50 646.99 609.01 646.99 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 634.99 T
2 F
(ObjCompAddChild\050\051) 99 634.99 T
5 10 Q
(void) 99 620.33 T
3 F
(ObjCompAddChild\050) 153 620.33 T
3 9 Q
(optr) 153 609.99 T
(obj,) 189 609.99 T
(/* optr of parent composite */) 279 609.99 T
(optr) 153 599.99 T
(objToAdd,) 189 599.99 T
(/* optr of new child */) 279 599.99 T
(word) 153 589.99 T
(flags,) 189 589.99 T
(/* CompChildFlags */) 279 589.99 T
(word) 153 579.99 T
(masterOffset,) 189 579.99 T
(/* offset to master part */) 279 579.99 T
(word) 153 569.99 T
(compOffset,) 189 569.99 T
(/* offset to comp field in master part */) 279 569.99 T
(word) 153 559.99 T
(linkOffset\051;) 189 559.99 T
(/* offset to link field in master part */) 279 559.99 T
0 10 Q
(This routine adds the given object to an object tree as the child of another) 180 542.33 T
(speci\336ed object. It returns nothing. Y) 180 530.83 T
(ou will not likely want to use this) 350.37 530.83 T
-0.32 (routine; instead, you will probably use the messages listed below under \322See) 180 519.33 P
(Also.\323 The parameters of this routine are) 180 507.83 T
6 F
(obj) 180 489.33 T
0 F
(The optr of the parent composite object. The parent must be a) 243 489.33 T
(composite; if it is not, an error will result.) 243 478.33 T
6 F
(objT) 180 460.33 T
(oAdd) 199.67 460.33 T
0 F
-0.71 (The optr of the child object. The child must have a link instance) 243 460.33 P
(\336eld \050de\336ned with) 243 449.33 T
4 F
(@link) 329.3 449.33 T
0 F
(\051.) 357.51 449.33 T
6 F
(\337ags) 180 431.33 T
0 F
(A record of) 243 431.33 T
4 F
(CompChildFlags) 295.95 431.33 T
0 F
(. These \337ags indicate whether) 382.62 431.33 T
-0.03 (the object should initially be marked dirty as well as where in) 243 420.33 P
(the parent\325) 243 409.33 T
(s child list the new child should be placed \050\336rst,) 293.19 409.33 T
(second, last, etc.\051.) 243 398.33 T
6 F
(masterOffset) 180 380.33 T
0 F
(The offset within the parent\325) 243 369.33 T
(s instance chunk to the master) 374.68 369.33 T
-0.77 (group\325) 243 358.33 P
-0.77 (s offset. \050The value that would appear in the parent class\325) 271.33 358.33 P
6 F
(Class_masterOffset) 243 347.33 T
0 F
( \336eld in its) 331.48 347.33 T
4 F
(ClassStruct) 383.53 347.33 T
0 F
( structure.\051) 443.73 347.33 T
6 F
(compOffset) 180 329.33 T
0 F
-0.22 (The offset within the parent\325) 243 329.33 P
-0.22 (s instance chunk to the composite) 373.8 329.33 P
(\336eld.) 243 318.33 T
6 F
(linkOffset) 180 300.33 T
0 F
(The offset within the parent\325) 243 300.33 T
(s instance chunk to the link \336eld.) 374.68 300.33 T
2 F
(W) 99 282.33 T
(arnings:) 108.07 282.33 T
0 F
(This routine may resize and move LMem and Object blocks on the heap,) 180 282.33 T
(thereby invalidating all segment addresses and pointers.) 180 269.33 T
2 F
(Include:) 99 249.33 T
0 F
(metaC.goh) 180 249.33 T
2 F
(See Also:) 99 229.33 T
0 9 Q
(MSG_VIS_ADD_CHILD) 180 229.33 T
0 10 Q
(,) 281.66 229.33 T
0 9 Q
(MSG_GEN_ADD_CHILD) 287.22 229.33 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "324" 24
%%Page: "325" 25
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
162 690.34 558 702 R
7 X
0 0 0 1 0 0 0 K
V
162 666.34 558 678.01 R
V
0 10 Q
0 X
(325) 541.32 671.34 T
324 684 580 684 2 L
7 X
V
3 H
2 Z
0 X
N
512 90 558 125 R
7 X
V
1 60 Q
0 X
(n) 512.17 85 T
315 104 510 126 R
7 X
V
2 24 Q
0 X
(Routines) 407.33 110 T
90 99 270 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
90.67 123.5 270.67 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
81 642.99 531 648 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 642.99 531 648 R
7 X
0 0 0 1 0 0 0 K
V
50 646.99 609.01 646.99 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 634.99 T
2 F
(ObjCompFindChildByNumber\050\051) 99 634.99 T
5 10 Q
(optr) 99 620.33 T
3 F
(ObjCompFindChildByNumber\050) 153 620.33 T
3 9 Q
(optr) 153 609.99 T
(obj,) 189 609.99 T
(/* parent\325s optr */) 279 609.99 T
(word) 153 599.99 T
(childToFind,) 189 599.99 T
(/* zero-based child number */) 279 599.99 T
(word) 153 589.99 T
(masterOffset,) 189 589.99 T
(/* offset to master part */) 279 589.99 T
(word) 153 579.99 T
(compOffset,) 189 579.99 T
(/* offset to comp field in master part */) 279 579.99 T
(word) 153 569.99 T
(linkOffset\051;) 189 569.99 T
(/* offset to link field in master part */) 279 569.99 T
0 10 Q
-0.66 (This routine returns the optr of the passed object\325) 180 552.33 P
-0.66 (s child; the child is speci\336ed) 403.08 552.33 P
(based on its position in the object\325) 180 540.83 T
(s child list. Y) 335.4 540.83 T
(ou will not often use this) 394.49 540.83 T
(routine, but you will probably use the messages listed under \322See Also\323) 180 529.33 T
(instead. The routine\325) 180 517.83 T
(s parameters are listed below:) 275.57 517.83 T
6 F
(obj) 180 499.33 T
0 F
(The optr of the parent object.) 243 499.33 T
6 F
(childT) 180 481.33 T
(oFind) 209.28 481.33 T
0 F
(The zero-based number of the child to be found. For example,) 243 470.33 T
(to return the \336rst child\325) 243 459.33 T
(s optr) 351.33 459.33 T
(, pass zero or) 377.07 459.33 T
0 9 Q
(CCO_FIRST) 440.22 459.33 T
0 10 Q
(; to) 492.01 459.33 T
(return the last child\325) 243 448.33 T
(s optr) 337.82 448.33 T
(, pass) 363.56 448.33 T
0 9 Q
(CCO_LAST) 392.46 448.33 T
0 10 Q
(.) 440.21 448.33 T
6 F
(masterOffset) 180 430.33 T
0 F
(The offset within the parent\325) 243 419.33 T
(s instance chunk to the master) 374.68 419.33 T
-0.77 (group\325) 243 408.33 P
-0.77 (s offset. \050The value that would appear in the parent class\325) 271.33 408.33 P
6 F
(Class_masterOffset) 243 397.33 T
0 F
( \336eld in its) 331.48 397.33 T
4 F
(ClassStruct) 383.53 397.33 T
0 F
( structure.\051) 443.73 397.33 T
6 F
(compOffset) 180 379.33 T
0 F
-0.22 (The offset within the parent\325) 243 379.33 P
-0.22 (s instance chunk to the composite) 373.8 379.33 P
(\336eld.) 243 368.33 T
6 F
(linkOffset) 180 350.33 T
0 F
(The offset within the parent\325) 243 350.33 T
(s instance chunk to the link \336eld.) 374.68 350.33 T
2 F
(Include:) 99 332.33 T
0 F
(metaC.goh) 180 332.33 T
2 F
(See Also:) 99 312.33 T
0 9 Q
(MSG_GEN_FIND_CHILD) 180 312.33 T
0 10 Q
(,) 290.17 312.33 T
0 9 Q
(MSG_VIS_FIND_CHILD) 295.73 312.33 T
81 295.98 531 300.99 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 295.98 531 300.99 R
7 X
0 0 0 1 0 0 0 K
V
50 299.98 609.01 299.98 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 287.98 T
2 F
(ObjCompFindChildByOptr\050\051) 99 287.98 T
5 10 Q
(word) 99 273.32 T
3 F
(ObjCompFindChildByOptr\050) 153 273.32 T
3 9 Q
(optr) 153 262.98 T
(obj,) 189 262.98 T
(/* parent\325s optr */) 279 262.98 T
(optr) 153 252.98 T
(childToFind,) 189 252.98 T
(/* optr of child to find */) 279 252.98 T
(word) 153 242.98 T
(masterOffset,) 189 242.98 T
(/* offset to master part */) 279 242.98 T
(word) 153 232.98 T
(compOffset,) 189 232.98 T
(/* offset to comp field in master part */) 279 232.98 T
(word) 153 222.98 T
(linkOffset\051;) 189 222.98 T
(/* offset to link field in master part */) 279 222.98 T
0 10 Q
(This routine returns the zero-based child number of an object given its optr) 180 205.32 T
-0.24 (and its parent\325) 180 193.82 P
-0.24 (s optr) 246.57 193.82 P
-0.24 (. The returned number represents the child\325) 272.06 193.82 P
-0.24 (s position in) 472.83 193.82 P
-0.45 (its parent\325) 180 182.32 P
-0.45 (s child list. For example, a return value of zero indicates the object) 226.41 182.32 P
-0.7 (is the parent\325) 180 170.82 P
-0.7 (s \336rst child. Y) 239.34 170.82 P
-0.7 (ou will not likely use this routine; instead, you will) 300.57 170.82 P
(probably use the messages shown below under \322See Also.\323) 180 159.32 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "325" 25
%%Page: "326" 26
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
54 690.34 450 702 R
7 X
0 0 0 1 0 0 0 K
V
54 666.34 450 678.01 R
V
0 10 Q
0 X
(326) 54 671.34 T
32 684 288 684 2 L
7 X
V
3 H
2 Z
0 X
N
54 90 108 125 R
7 X
V
1 60 Q
0 X
(n) 58.17 85 T
104 104 299 126 R
7 X
V
2 24 Q
0 X
(Routines) 104 110 T
306 99 486 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
306 123.5 486 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
0 10 Q
0 X
(The parameters for this routine are listed below:) 180 641.33 T
6 F
(obj) 180 622.83 T
0 F
(The optr of the parent object.) 243 622.83 T
6 F
(childT) 180 604.83 T
(oFind) 209.28 604.83 T
0 F
(The optr of the child whose number is to be returned. If the) 243 593.83 T
(child is not found, the routine will return -1.) 243 582.83 T
6 F
(masterOffset) 180 564.83 T
0 F
(The offset within the parent\325) 243 553.83 T
(s instance chunk to the master) 374.68 553.83 T
-0.77 (group\325) 243 542.83 P
-0.77 (s offset. \050The value that would appear in the parent class\325) 271.33 542.83 P
6 F
(Class_masterOffset) 243 531.83 T
0 F
( \336eld in its) 331.48 531.83 T
4 F
(ClassStruct) 383.53 531.83 T
0 F
( structure.\051) 443.73 531.83 T
6 F
(compOffset) 180 513.83 T
0 F
-0.22 (The offset within the parent\325) 243 513.83 P
-0.22 (s instance chunk to the composite) 373.8 513.83 P
(\336eld.) 243 502.83 T
6 F
(linkOffset) 180 484.83 T
0 F
(The offset within the parent\325) 243 484.83 T
(s instance chunk to the link \336eld.) 374.68 484.83 T
2 F
(Include:) 99 466.83 T
0 F
(metaC.goh) 180 466.83 T
2 F
(See Also:) 99 446.83 T
0 9 Q
(MSG_GEN_FIND_CHILD) 180 446.83 T
0 10 Q
(,) 290.17 446.83 T
0 9 Q
(MSG_VIS_FIND_CHILD) 295.73 446.83 T
81 430.49 531 435.5 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 430.49 531 435.5 R
7 X
0 0 0 1 0 0 0 K
V
50 434.49 609.01 434.49 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 422.49 T
2 F
(ObjCompMoveChild\050\051) 99 422.49 T
5 10 Q
(void) 99 407.83 T
3 F
(ObjCompMoveChild\050) 153 407.83 T
3 9 Q
(optr) 153 397.49 T
(obj,) 189 397.49 T
(/* parent\325s optr */) 279 397.49 T
(optr) 153 387.49 T
(objToMove,) 189 387.49 T
(/* optr of child to move */) 279 387.49 T
(word) 153 377.49 T
(flags,) 189 377.49 T
(/* CompChildFlags */) 279 377.49 T
(word) 153 367.49 T
(masterOffset,) 189 367.49 T
(/* offset to master part */) 279 367.49 T
(word) 153 357.49 T
(compOffset,) 189 357.49 T
(/* offset to comp field in master part */) 279 357.49 T
(word) 153 347.49 T
(linkOffset\051;) 189 347.49 T
(/* offset to link field in master part */) 279 347.49 T
0 10 Q
(This routine moves the speci\336ed child within its parent\325) 180 329.83 T
(s child list. This) 437.06 329.83 T
-0.81 (routine will not move a child from one parent to another) 180 318.33 P
-0.81 (, but it can reorganize) 430.79 318.33 P
-0.68 (a parent\325) 180 306.83 P
-0.68 (s children. Y) 220.07 306.83 P
-0.68 (ou will not likely use this routine, but you may often use) 275.76 306.83 P
(the messages listed under \322See Also\323 below) 180 295.33 T
(.) 378 295.33 T
(The parameters of this routine are shown below:) 180 276.83 T
6 F
(obj) 180 258.33 T
0 F
(The optr of the parent object.) 243 258.33 T
6 F
(objT) 180 240.33 T
(oMove) 199.67 240.33 T
0 F
-0.42 (The optr of the child to be moved. If the optr does not point to a) 243 240.33 P
(valid child, behavior is unde\336ned and an error is likely) 243 229.33 T
(.) 495.07 229.33 T
6 F
(\337ags) 180 211.33 T
0 F
(A record of) 243 211.33 T
4 F
(CompChildFlags) 295.95 211.33 T
0 F
( indicating the new position of) 382.62 211.33 T
(the child and whether the link should be marked dirty) 243 200.33 T
(.) 493.03 200.33 T
6 F
(masterOffset) 180 182.33 T
0 F
(The offset within the parent\325) 243 171.33 T
(s instance chunk to the master) 374.68 171.33 T
-0.77 (group\325) 243 160.33 P
-0.77 (s offset. \050The value that would appear in the parent class\325) 271.33 160.33 P
6 F
(Class_masterOffset) 243 149.33 T
0 F
( \336eld in its) 331.48 149.33 T
4 F
(ClassStruct) 383.53 149.33 T
0 F
( structure.\051) 443.73 149.33 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "326" 26
%%Page: "327" 27
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
162 690.34 558 702 R
7 X
0 0 0 1 0 0 0 K
V
162 666.34 558 678.01 R
V
0 10 Q
0 X
(327) 541.32 671.34 T
324 684 580 684 2 L
7 X
V
3 H
2 Z
0 X
N
512 90 558 125 R
7 X
V
1 60 Q
0 X
(n) 512.17 85 T
315 104 510 126 R
7 X
V
2 24 Q
0 X
(Routines) 407.33 110 T
90 99 270 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
90.67 123.5 270.67 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
6 10 Q
0 X
(compOffset) 180 641.33 T
0 F
-0.22 (The offset within the parent\325) 243 641.33 P
-0.22 (s instance chunk to the composite) 373.8 641.33 P
(\336eld.) 243 630.33 T
6 F
(linkOffset) 180 612.33 T
0 F
(The offset within the parent\325) 243 612.33 T
(s instance chunk to the link \336eld.) 374.68 612.33 T
2 F
(W) 99 594.33 T
(arnings:) 108.07 594.33 T
0 F
(This routine may cause LMem and/or Object Blocks to move or to shuf\337e) 180 594.33 T
(their chunks, thereby invalidating any segment addresses or pointers.) 180 581.33 T
2 F
(Include:) 99 561.33 T
0 F
(metaC.goh) 180 561.33 T
2 F
(See Also:) 99 541.33 T
0 9 Q
(MSG_GEN_MOVE_CHILD) 180 541.33 T
0 10 Q
(,) 294.66 541.33 T
0 9 Q
(MSG_VIS_MOVE_CHILD) 300.22 541.33 T
81 524.99 531 530 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 524.99 531 530 R
7 X
0 0 0 1 0 0 0 K
V
50 528.99 609.01 528.99 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 516.99 T
2 F
(ObjCompProcessChildren\050\051) 99 516.99 T
5 10 Q
(Boolean) 99 502.33 T
3 F
(ObjCompProcessChildren\050) 153 502.33 T
3 9 Q
(optr) 153 491.99 T
(obj,) 261 491.99 T
(/* parent\325s optr */) 333 491.99 T
(optr) 153 481.99 T
(firstChild,) 261 481.99 T
(/* optr of first child to process */) 333 481.99 T
(ObjCompCallType) 153 471.99 T
(stdCallback,) 261 471.99 T
(/* standard callback type */) 333 471.99 T
(void) 153 461.99 T
(* cbData,) 261 461.99 T
(/* data passed to callback */) 333 461.99 T
(word) 153 451.99 T
(masterOffset,) 261 451.99 T
(/* offset to master part */) 333 451.99 T
(word) 153 441.99 T
(compOffset,) 261 441.99 T
(/* offset to comp field */) 333 441.99 T
(word) 153 431.99 T
(linkOffset\051;) 261 431.99 T
(/* offset to link field */) 333 431.99 T
(Boolean _pascal \050*callback\051 \050optr parent, optr child, void *cbData\051\051;) 153 421.99 T
0 10 Q
(This routine performs a speci\336c set of actions on all or some of an object\325) 180 404.33 T
(s) 512.8 404.33 T
(children. It is very rare that you will use this routine; typically) 180 392.83 T
(, you should) 468.73 392.83 T
(send a message to all of the parent\325) 180 381.33 T
(s children. If, however) 342.07 381.33 T
(, you use this) 444.1 381.33 T
-0.37 (routine, you must also write a callback routine that will be executed once for) 180 369.83 P
(each affected child.) 180 358.33 T
4 F
(ObjCompProcessChildren\050\051) 180 339.83 T
0 F
( returns) 322.79 339.83 T
6 F
(true) 362.97 339.83 T
0 F
( \050nonzero\051 only if it was stopped) 381.48 339.83 T
(before all children had been processed. The only two ways this could be) 180 328.33 T
(returned is if an error occurs or if your callback returns) 180 316.83 T
6 F
(true) 438.87 316.83 T
0 F
( when called.) 457.38 316.83 T
(The parameters for this routine are) 180 298.33 T
6 F
(obj) 180 279.83 T
0 F
(The optr of the composite whose children are to be processed.) 243 279.83 T
6 F
(\336rstChild) 180 261.83 T
0 F
(The optr of the \336rst child to be processed. This routine will) 243 261.83 T
(begin with the passed child and continue with all subsequent) 243 250.83 T
-0.28 (children. Pass the optr of the composite\325) 243 239.83 P
-0.28 (s \336rst child\321retrieved) 425.19 239.83 P
(with the routine) 243 228.83 T
4 F
(ObjCompFindChildByNumber\050\051) 320.97 228.83 T
0 F
(\321to) 486.34 228.83 T
(process all children.) 243 217.83 T
6 F
(stdCallback) 180 199.83 T
0 F
-0.08 (A value of) 243 188.83 P
4 F
-0.08 (ObjCompCallT) 291.85 188.83 P
-0.08 (ype) 368 188.83 P
0 F
-0.08 ( indicating how the data in the) 386.52 188.83 P
(buffer pointed to by) 243 177.83 T
6 F
(cbData) 336.34 177.83 T
0 F
( will be passed to your callback) 369.12 177.83 T
(routine. These values are detailed below) 243 166.83 T
(.) 428.41 166.83 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "327" 27
%%Page: "328" 28
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
54 690.34 450 702 R
7 X
0 0 0 1 0 0 0 K
V
54 666.34 450 678.01 R
V
0 10 Q
0 X
(328) 54 671.34 T
32 684 288 684 2 L
7 X
V
3 H
2 Z
0 X
N
54 90 108 125 R
7 X
V
1 60 Q
0 X
(n) 58.17 85 T
104 104 299 126 R
7 X
V
2 24 Q
0 X
(Routines) 104 110 T
306 99 486 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
306 123.5 486 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
6 10 Q
0 X
(cbData) 180 641.33 T
0 F
(A pointer to a buffer in which data can be passed to your) 243 641.33 T
(callback routine. This buffer can be altered by your callback.) 243 630.33 T
6 F
(masterOffset) 180 612.33 T
0 F
(The offset within the parent\325) 243 601.33 T
(s instance chunk to the master) 374.68 601.33 T
-0.77 (group\325) 243 590.33 P
-0.77 (s offset. \050The value that would appear in the parent class\325) 271.33 590.33 P
6 F
(Class_masterOffset) 243 579.33 T
0 F
( \336eld in its) 331.48 579.33 T
4 F
(ClassStruct) 383.53 579.33 T
0 F
( structure.\051) 443.73 579.33 T
6 F
(compOffset) 180 561.33 T
0 F
-0.22 (The offset within the parent\325) 243 561.33 P
-0.22 (s instance chunk to the composite) 373.8 561.33 P
(\336eld.) 243 550.33 T
6 F
(linkOffset) 180 532.33 T
0 F
(The offset within the parent\325) 243 532.33 T
(s instance chunk to the link \336eld.) 374.68 532.33 T
6 F
(callback) 180 514.33 T
0 F
(A pointer to the actual callback routine that will be executed) 243 503.33 T
-0.57 (once for each child. The callback should be in your geode\325) 243 492.33 P
-0.57 (s \336xed) 499.73 492.33 P
(memory) 243 481.33 T
(. The parameters and return values for the callback) 279.48 481.33 T
(routine are given below) 243 470.33 T
(.) 350.61 470.33 T
-0.26 (The callback routine takes three parameters and returns a boolean value. It) 180 452.33 P
(must be declared _pascal. The three parameters to the callback are listed) 180 440.83 T
(below:) 180 429.33 T
6 F
(parent) 180 410.83 T
0 F
(The optr of the parent composite.) 243 410.83 T
6 F
(child) 180 392.83 T
0 F
(The optr of the current child being processed.) 243 392.83 T
6 F
(cbData) 180 374.83 T
0 F
(A pointer to the buffer passed by the original caller of) 243 374.83 T
4 F
-0.33 (ObjCompProcessChildren\050\051) 243 363.83 P
0 F
-0.32 (. What is actually in this buffer) 385.79 363.83 P
(may depend on the value in the original) 243 352.83 T
6 F
(sdtCallback) 429.88 352.83 T
0 F
(parameter; if the buffer is not saved and restored by) 243 341.83 T
4 F
(ObjCompProcessChildren\050\051) 243 330.83 T
0 F
( between children, each child) 385.79 330.83 T
(may receive data altered by the previous child.) 243 319.83 T
-0.26 (The callback routine can access and alter the buffer pointed to by) 180 301.83 P
6 F
-0.26 (cbData) 480.96 301.83 P
0 F
-0.26 (, or) 513.74 301.83 P
-0.61 (it can query the child or do anything else with the exception of destroying the) 180 290.33 P
(child. It should return a Boolean value:) 180 278.83 T
6 F
(true) 364.09 278.83 T
0 F
( if) 382.6 278.83 T
4 F
(ObjCompProcessChildren\050\051) 180 267.33 T
0 F
( should be aborted,) 322.79 267.33 T
6 F
(false) 413.18 267.33 T
0 F
( if it should not.) 434.46 267.33 T
-0.85 (The values you can pass to) 180 248.83 P
4 F
-0.88 (ObjCompProcessChildren\050\051) 301.23 248.83 P
0 F
-0.85 ( in) 444.02 248.83 P
6 F
-0.85 (stdCallback) 457.15 248.83 P
0 F
-0.85 ( are) 512.14 248.83 P
(of type) 180 237.33 T
4 F
(ObjCompCallT) 213.89 237.33 T
(ype) 290.04 237.33 T
0 F
(. Y) 308.56 237.33 T
(ou can use one of the following values to) 320.05 237.33 T
-0.48 (specify how the buffer in) 180 225.83 P
6 F
-0.48 (cbData) 294.08 225.83 P
0 F
-0.48 ( will be passed on to the next child\325) 326.86 225.83 P
-0.48 (s callback) 483.98 225.83 P
(routine:) 180 214.33 T
0 9 Q
(OCCT_SA) 180 195.83 T
(VE_P) 221.67 195.83 T
(ARAMS_TEST_ABORT) 244.5 195.83 T
0 10 Q
(Save the buffer passed in) 243 184.83 T
6 F
(cbData) 362.46 184.83 T
0 F
( before calling each child;) 395.24 184.83 T
(abort the routine if the callback returns) 243 173.83 T
6 F
(true) 429.5 173.83 T
0 F
(.) 448.01 173.83 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "328" 28
%%Page: "329" 29
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
162 690.34 558 702 R
7 X
0 0 0 1 0 0 0 K
V
162 666.34 558 678.01 R
V
0 10 Q
0 X
(329) 541.32 671.34 T
324 684 580 684 2 L
7 X
V
3 H
2 Z
0 X
N
512 90 558 125 R
7 X
V
1 60 Q
0 X
(n) 512.17 85 T
315 104 510 126 R
7 X
V
2 24 Q
0 X
(Routines) 407.33 110 T
90 99 270 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
90.67 123.5 270.67 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
0 9 Q
0 X
(OCCT_SA) 180 641.33 T
(VE_P) 221.67 641.33 T
(ARAMS_DONT_TEST_ABORT) 244.5 641.33 T
0 10 Q
(Save the buffer passed in) 243 630.33 T
6 F
(cbData) 362.46 630.33 T
0 F
( before calling each child; do) 395.24 630.33 T
-0.18 (not check the return value of the callback before proceeding to) 243 619.33 P
(the next child.) 243 608.33 T
0 9 Q
(OCCT_DONT_SA) 180 590.33 T
(VE_P) 253.51 590.33 T
(ARAMS_TEST_ABORT) 276.35 590.33 T
0 10 Q
(Do not save the buffer in) 243 579.33 T
6 F
(cbData) 360.05 579.33 T
0 F
(, and abort if the callback) 392.83 579.33 T
(routine returns) 243 568.33 T
6 F
(true) 316.88 568.33 T
0 F
(.) 335.39 568.33 T
0 9 Q
(OCCT_DONT_SA) 180 550.33 T
(VE_P) 253.51 550.33 T
(ARAMS_DONT_TEST_ABORT) 276.35 550.33 T
0 10 Q
-0.46 (Do not save the buffer in) 243 539.33 P
6 F
-0.46 (cbData) 357.31 539.33 P
0 F
-0.46 (, and do not check the callback) 390.09 539.33 P
(routine\325) 243 528.33 T
(s return value.) 278.37 528.33 T
0 9 Q
(OCCT_ABORT_AFTER_FIRST) 180 510.33 T
0 10 Q
-0.23 (Abort the processing after only one child \050typically used to call) 243 499.33 P
(the) 243 488.33 T
6 F
(nth) 260.78 488.33 T
0 F
( child\051.) 276.52 488.33 T
0 9 Q
(OCCT_COUNT_CHILDREN) 180 470.33 T
0 10 Q
(Counts the number of children rather than calling each.) 243 459.33 T
2 F
(Include:) 99 441.33 T
0 F
(metaC.goh) 180 441.33 T
2 F
(See Also:) 99 421.33 T
0 F
(@send, @call,) 180 421.33 T
0 9 Q
(MSG_MET) 243.64 421.33 T
(A_SEND_CLASSED_EVENT) 289.81 421.33 T
81 404.99 531 410 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 404.99 531 410 R
7 X
0 0 0 1 0 0 0 K
V
50 408.99 609.01 408.99 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 396.99 T
2 F
(ObjCompRemoveChild\050\051) 99 396.99 T
5 10 Q
(void) 99 382.33 T
3 F
(ObjCompRemoveChild\050) 153 382.33 T
3 9 Q
(optr) 153 371.99 T
(obj,) 189 371.99 T
(/* parent\325s optr */) 279 371.99 T
(optr) 153 361.99 T
(objToRemove) 189 361.99 T
(/* optr of child to be removed */) 279 361.99 T
(word) 153 351.99 T
(flags,) 189 351.99 T
(/* CompChildFlags */) 279 351.99 T
(word) 153 341.99 T
(masterOffset,) 189 341.99 T
(/* offset to master part */) 279 341.99 T
(word) 153 331.99 T
(compOffset,) 189 331.99 T
(/* offset to comp field in master part */) 279 331.99 T
(word) 153 321.99 T
(linkOffset\051;) 189 321.99 T
(/* offset to link field in master part */) 279 321.99 T
0 10 Q
(This routine removes the given child from the speci\336ed parent composite.) 180 304.33 T
(The child will be removed entirely from the object tree, but it will not be) 180 292.83 T
(detached or freed. The parameters of this routine are listed below:) 180 281.33 T
6 F
(obj) 180 262.83 T
0 F
(The optr of the parent composite.) 243 262.83 T
6 F
(objT) 180 244.83 T
(oRemove) 199.67 244.83 T
0 F
(The optr of the child to be removed.) 243 233.83 T
6 F
(\337ags) 180 215.83 T
0 F
(A record of) 243 215.83 T
4 F
(CompChildFlags) 295.95 215.83 T
0 F
( indicating whether the parent) 382.62 215.83 T
(and child should be marked dirty after the operation.) 243 204.83 T
6 F
(masterOffset) 180 186.83 T
0 F
(The offset within the parent\325) 243 175.83 T
(s instance chunk to the master) 374.68 175.83 T
-0.77 (group\325) 243 164.83 P
-0.77 (s offset. \050The value that would appear in the parent class\325) 271.33 164.83 P
6 F
(Class_masterOffset) 243 153.83 T
0 F
( \336eld in its) 331.48 153.83 T
4 F
(ClassStruct) 383.53 153.83 T
0 F
( structure.\051) 443.73 153.83 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "329" 29
%%Page: "330" 30
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
54 690.34 450 702 R
7 X
0 0 0 1 0 0 0 K
V
54 666.34 450 678.01 R
V
0 10 Q
0 X
(330) 54 671.34 T
32 684 288 684 2 L
7 X
V
3 H
2 Z
0 X
N
54 90 108 125 R
7 X
V
1 60 Q
0 X
(n) 58.17 85 T
104 104 299 126 R
7 X
V
2 24 Q
0 X
(Routines) 104 110 T
306 99 486 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
306 123.5 486 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
6 10 Q
0 X
(compOffset) 180 641.33 T
0 F
-0.22 (The offset within the parent\325) 243 641.33 P
-0.22 (s instance chunk to the composite) 373.8 641.33 P
(\336eld.) 243 630.33 T
6 F
(linkOffset) 180 612.33 T
0 F
(The offset within the parent\325) 243 612.33 T
(s instance chunk to the link \336eld.) 374.68 612.33 T
2 F
(Include:) 99 594.33 T
0 F
(metaC.goh) 180 594.33 T
81 577.99 531 583 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 577.99 531 583 R
7 X
0 0 0 1 0 0 0 K
V
50 581.99 609.01 581.99 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 569.99 T
2 F
(ObjDecInteractibleCount\050\051) 99 569.99 T
5 10 Q
(void) 99 556.33 T
3 F
(ObjDecInteractibleCount\050) 153 556.33 T
3 9 Q
(MemHandle mh\051;) 153 545.99 T
(/* subject object block */) 279 545.99 T
0 10 Q
(This routine decrements the given object block\325) 180 528.33 T
(s interactable count. Do not) 396.68 528.33 T
(decrement the interactable count without \336rst incrementing it with) 180 516.83 T
4 F
(ObjIncInteractibleCount\050\051) 180 505.33 T
0 F
(. V) 316.66 505.33 T
(isible objects automatically decrement the) 329 505.33 T
(interactable count in their) 180 493.83 T
0 9 Q
(MSG_VIS_CLOSE) 304.27 493.83 T
0 10 Q
( handlers.) 381.94 493.83 T
2 F
(Include:) 99 475.33 T
0 F
(object.h) 180 475.33 T
2 F
(See Also:) 99 455.33 T
0 F
(ObjIncInteractibleCount\050\051,) 180 455.33 T
0 9 Q
(MSG_VIS_CLOSE) 305.73 455.33 T
0 10 Q
(, ObjLMemBlockHeader) 383.4 455.33 T
81 438.98 531 443.99 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 438.98 531 443.99 R
7 X
0 0 0 1 0 0 0 K
V
50 442.98 609.01 442.98 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 430.98 T
2 F
(ObjDecInUseCount\050\051) 99 430.98 T
5 10 Q
(void) 99 417.32 T
3 F
(ObjDecInUseCount\050) 153 417.32 T
3 9 Q
(MemHandle mh\051;) 153 406.98 T
(/* subject object block */) 261 406.98 T
0 10 Q
(This routine decrements the given object block\325) 180 389.32 T
(s in-use count. When the) 396.68 389.32 T
(in-use count reaches zero, the block may safely be freed. Y) 180 377.82 T
(ou should not) 447.61 377.82 T
(decrement the in-use count of a block without \336rst incrementing it at some) 180 366.32 T
(point with) 180 354.82 T
4 F
(ObjIncInUseCount\050\051) 230.38 354.82 T
0 F
(.) 335.55 354.82 T
2 F
(W) 99 336.32 T
(arnings:) 108.07 336.32 T
0 F
-0.82 (Do not decrement the in-use count without incrementing it \336rst. An error will) 180 336.32 P
(result.) 180 323.32 T
2 F
(Include:) 99 303.32 T
0 F
(object.h) 180 303.32 T
2 F
(See Also:) 99 283.32 T
0 F
(ObjIncInUseCount\050\051, ObjDecInteractibleCount\050\051, ObjLMemBlockHeader) 180 283.32 T
81 266.98 531 271.98 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 266.98 531 271.98 R
7 X
0 0 0 1 0 0 0 K
V
50 270.98 609.01 270.98 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 258.97 T
2 F
(ObjDeref\050\051) 99 258.97 T
5 10 Q
(void) 99 245.31 T
3 F
(* ObjDeref\050) 153 245.31 T
3 9 Q
(optr) 153 234.97 T
(obj) 189 234.97 T
(/* optr to dereference */) 297 234.97 T
(word) 153 224.97 T
(masterLevel\051;) 189 224.97 T
(/* specific master level to dereference */) 297 224.97 T
0 10 Q
(This routine dereferences the given optr and master level to reset the) 180 207.31 T
(message parameter) 180 195.81 T
6 F
(pself) 273.16 195.81 T
0 F
(. Because many routines and messages may cause) 294.44 195.81 T
-0.29 (the calling object\325) 180 184.31 P
-0.29 (s instance chunk to move, the) 259.43 184.31 P
6 F
-0.29 (pself) 397.53 184.31 P
0 F
-0.29 ( parameter may become) 418.81 184.31 P
(invalid. The two parameters to) 180 172.81 T
4 F
(ObjDeref\050\051) 325.4 172.81 T
0 F
( are) 380.4 172.81 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "330" 30
%%Page: "331" 31
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
162 690.34 558 702 R
7 X
0 0 0 1 0 0 0 K
V
162 666.34 558 678.01 R
V
0 10 Q
0 X
(331) 541.32 671.34 T
324 684 580 684 2 L
7 X
V
3 H
2 Z
0 X
N
512 90 558 125 R
7 X
V
1 60 Q
0 X
(n) 512.17 85 T
315 104 510 126 R
7 X
V
2 24 Q
0 X
(Routines) 407.33 110 T
90 99 270 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
90.67 123.5 270.67 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
6 10 Q
0 X
(obj) 180 641.33 T
0 F
-0.77 (The optr of the object to be dereferenced; nearly always you will) 243 641.33 P
(want to pass) 243 630.33 T
4 F
(oself) 304.13 630.33 T
0 F
(.) 328.39 630.33 T
6 F
(masterLevel) 180 612.33 T
0 F
(The master level of the part to be dereferenced. This is the) 243 601.33 T
(offset into the instance chunk where the offset to the master) 243 590.33 T
(part is stored. Since) 243 579.33 T
6 F
(pself) 338.01 579.33 T
0 F
( points to the \336rst byte of a master) 359.29 579.33 T
(part, you must specify which master part you are) 243 568.33 T
(dereferencing.) 243 557.33 T
-0.46 (For example, a visible object dereferencing its) 180 539.33 P
4 F
-0.48 (V) 391.05 539.33 P
-0.48 (isClass) 398.2 539.33 P
0 F
-0.46 ( instance data would) 434.31 539.33 P
(call this routine as follows:) 180 527.83 T
3 9 Q
(pself = ObjDeref\050oself, 4\051;) 216 513 T
0 10 Q
-0.58 (Note, however) 180 495.33 P
-0.58 (, the) 244.98 495.33 P
4 F
-0.6 (ObjDeref1\050\051) 267.16 495.33 P
0 F
-0.58 ( and) 327.9 495.33 P
4 F
-0.6 (ObjDerefV) 349.71 495.33 P
-0.6 (is\050\051) 404.08 495.33 P
0 F
-0.58 ( exist to dereference the) 420.57 495.33 P
-0.21 (V) 180 483.83 P
-0.21 (is master part, and) 186.78 483.83 P
4 F
-0.22 (ObjDeref2\050\051) 277.07 483.83 P
0 F
-0.21 ( and) 337.81 483.83 P
4 F
-0.22 (ObjDerefGen\050\051) 360.37 483.83 P
0 F
-0.21 ( exist to dereference) 436.29 483.83 P
(the Gen master part.) 180 472.33 T
2 F
(Include:) 99 453.83 T
0 F
(object.h) 180 453.83 T
2 F
(See Also:) 99 433.83 T
0 F
(ObjDeref1\050\051, ObjDeref2\050\051) 180 433.83 T
81 417.49 531 422.5 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 417.49 531 422.5 R
7 X
0 0 0 1 0 0 0 K
V
50 421.49 609.01 421.49 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 409.49 T
2 F
(ObjDerefHandles\050\051) 99 409.49 T
5 10 Q
(void) 99 395.83 T
3 F
(* ObjDerefHandles\050) 153 395.83 T
3 9 Q
(MemHandle) 153 385.49 T
(mh,) 261 385.49 T
(/* handle portion of optr */) 351 385.49 T
(ChunkHandle) 153 375.49 T
(ch,) 261 375.49 T
(/* chunk portion of optr */) 351 375.49 T
(word) 153 365.49 T
(masterLevel\051;) 261 365.49 T
(/* master level to dereference */) 351 365.49 T
0 10 Q
(This routine is exactly the same as) 180 347.83 T
4 F
(ObjDeref\050\051) 343.55 347.83 T
0 F
(, above, except that the optr) 398.55 347.83 T
(is speci\336ed as its separate handles.) 180 336.33 T
2 F
(Include:) 99 317.83 T
0 F
(object.h) 180 317.83 T
81 301.48 531 306.49 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 301.48 531 306.49 R
7 X
0 0 0 1 0 0 0 K
V
50 305.48 609.01 305.48 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 293.48 T
2 F
(ObjDeref1\050\051) 99 293.48 T
5 10 Q
(void) 99 279.82 T
3 F
(* ObjDeref1\050) 153 279.82 T
3 9 Q
(optr obj\051;) 153 269.48 T
(/* optr of object to be dereferenced */) 279 269.48 T
0 10 Q
(This routine is a special version of) 180 251.82 T
4 F
(ObjDeref\050\051) 340.76 251.82 T
0 F
( which dereferences the \336rst) 395.76 251.82 T
(master part of an object. V) 180 240.32 T
(isible objects should use this routine or) 302.35 240.32 T
4 F
(ObjDerefV) 180 228.82 T
(is\050\051) 234.37 228.82 T
0 F
( instead of) 250.85 228.82 T
4 F
(ObjDeref\050\051) 301.6 228.82 T
0 F
(.) 356.6 228.82 T
2 F
(Include:) 99 210.32 T
0 F
(object.h) 180 210.32 T
2 F
(See Also:) 99 190.32 T
0 F
(ObjDeref\050\051, ObjDeref2\050\051) 180 190.32 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "331" 31
%%Page: "332" 32
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
54 690.34 450 702 R
7 X
0 0 0 1 0 0 0 K
V
54 666.34 450 678.01 R
V
0 10 Q
0 X
(332) 54 671.34 T
32 684 288 684 2 L
7 X
V
3 H
2 Z
0 X
N
54 90 108 125 R
7 X
V
1 60 Q
0 X
(n) 58.17 85 T
104 104 299 126 R
7 X
V
2 24 Q
0 X
(Routines) 104 110 T
306 99 486 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
306 123.5 486 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
81 642.99 531 648 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 642.99 531 648 R
7 X
0 0 0 1 0 0 0 K
V
50 646.99 609.01 646.99 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 634.99 T
2 F
(ObjDeref1Handles\050\051) 99 634.99 T
5 10 Q
(void) 99 621.33 T
3 F
(*ObjDeref1Handles\050) 153 621.33 T
3 9 Q
(MemHandle) 153 610.99 T
(mh,) 261 610.99 T
(/* handle portion of optr */) 315 610.99 T
(ChunkHandle) 153 600.99 T
(ch,\051;) 261 600.99 T
(/* chunk handle portion of optr */) 315 600.99 T
0 10 Q
(This routine is exactly like) 180 583.33 T
4 F
(ObjDeref1\050\051) 305.95 583.33 T
0 F
(, above, except that the optr is) 366.69 583.33 T
(speci\336ed as its separate handles.) 180 571.83 T
2 F
(Include:) 99 553.33 T
0 F
(object.h) 180 553.33 T
81 536.98 531 541.99 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 536.98 531 541.99 R
7 X
0 0 0 1 0 0 0 K
V
50 540.98 609.01 540.98 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 528.98 T
2 F
(ObjDeref2\050\051) 99 528.98 T
5 10 Q
(void) 99 515.32 T
3 F
(* ObjDeref2\050) 153 515.32 T
3 9 Q
(optr) 153 504.98 T
(obj\051;) 189 504.98 T
(/* optr of object to be dereferenced */) 279 504.98 T
0 10 Q
(This routine is a specialized version of) 180 487.32 T
4 F
(ObjDeref\050\051) 359.46 487.32 T
0 F
( which dereferences the) 414.46 487.32 T
(second master part of an object. Generic objects should use this routine or) 180 475.82 T
4 F
(ObjDerefGen\050\051) 180 464.32 T
0 F
( instead of) 255.92 464.32 T
4 F
(ObjDeref\050\051) 306.67 464.32 T
0 F
(.) 361.67 464.32 T
2 F
(Include:) 99 445.82 T
0 F
(object.h) 180 445.82 T
2 F
(See Also:) 99 425.82 T
0 F
(ObjDeref\050\051, ObjDeref1\050\051) 180 425.82 T
81 409.48 531 414.48 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 409.48 531 414.48 R
7 X
0 0 0 1 0 0 0 K
V
50 413.48 609.01 413.48 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 401.48 T
2 F
(ObjDeref2Handles\050\051) 99 401.48 T
5 10 Q
(void) 99 387.81 T
3 F
(* ObjDeref2Handles\050) 153 387.81 T
3 9 Q
(MemHandle) 153 377.48 T
(mh,/) 261 377.48 T
(/* handle portion of optr */) 315 377.48 T
(ChunkHandle) 153 367.48 T
(ch\051;) 261 367.48 T
(/* chunk portion of optr */) 315 367.48 T
0 10 Q
(This routine is exactly like) 180 349.81 T
4 F
(ObjDeref2\050\051) 305.95 349.81 T
0 F
(, above, except that the optr is) 366.69 349.81 T
(speci\336ed as its separate handles.) 180 338.31 T
2 F
(Include:) 99 319.81 T
0 F
(object.h) 180 319.81 T
81 303.47 531 308.48 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 303.47 531 308.48 R
7 X
0 0 0 1 0 0 0 K
V
50 307.47 609.01 307.47 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 295.47 T
2 F
(ObjDerefGen\050\051) 99 295.47 T
5 10 Q
(void) 99 281.8 T
3 F
(* ObjDerefGen\050) 153 281.8 T
3 9 Q
(optr) 153 271.47 T
(obj\051;) 189 271.47 T
(/* generic object to be dereferenced */) 297 271.47 T
0 10 Q
(This routine is exactly the same as) 180 253.8 T
4 F
(ObjDeref2\050\051) 343.55 253.8 T
0 F
( and dereferences the Gen) 404.29 253.8 T
(master part of a generic object.) 180 242.3 T
2 F
(Include:) 99 223.8 T
0 F
(object.h) 180 223.8 T
2 F
(See Also:) 99 203.8 T
0 F
(ObjDeref\050\051, ObjDeref2\050\051) 180 203.8 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "332" 32
%%Page: "333" 33
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
162 690.34 558 702 R
7 X
0 0 0 1 0 0 0 K
V
162 666.34 558 678.01 R
V
0 10 Q
0 X
(333) 541.32 671.34 T
324 684 580 684 2 L
7 X
V
3 H
2 Z
0 X
N
512 90 558 125 R
7 X
V
1 60 Q
0 X
(n) 512.17 85 T
315 104 510 126 R
7 X
V
2 24 Q
0 X
(Routines) 407.33 110 T
90 99 270 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
90.67 123.5 270.67 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
81 642.99 531 648 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 642.99 531 648 R
7 X
0 0 0 1 0 0 0 K
V
50 646.99 609.01 646.99 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 634.99 T
2 F
(ObjDerefV) 99 634.99 T
(is\050\051) 157.46 634.99 T
5 10 Q
(void) 99 621.33 T
3 F
(* ObjDerefVis\050) 153 621.33 T
3 9 Q
(optr) 153 610.99 T
(obj\051;) 189 610.99 T
(/* visible object to be dereferenced */) 297 610.99 T
0 10 Q
(This routine is exactly the same as) 180 593.33 T
4 F
(ObjDeref1\050\051) 343.55 593.33 T
0 F
( and dereferences the V) 404.29 593.33 T
(is) 512.73 593.33 T
(master part of a visible object or a visibly-realized generic object.) 180 581.83 T
2 F
(Include:) 99 563.33 T
0 F
(object.h) 180 563.33 T
2 F
(See Also:) 99 543.33 T
0 F
(ObjDeref\050\051, ObjDeref1\050\051) 180 543.33 T
81 526.98 531 531.99 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 526.98 531 531.99 R
7 X
0 0 0 1 0 0 0 K
V
50 530.98 609.01 530.98 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 518.98 T
2 F
(ObjDoRelocation\050\051) 99 518.98 T
5 10 Q
(Boolean) 99 504.32 T
3 F
(ObjDoRelocation\050 /* returns) 153 504.32 T
7 F
(true) 321 504.32 T
3 F
( if error */) 345 504.32 T
3 9 Q
(ObjRelocationType) 153 493.98 T
(type,) 261 493.98 T
(/* type of relocation */) 333 493.98 T
(MemHandle) 153 483.98 T
(block,) 261 483.98 T
(/* handle of info block */) 333 483.98 T
(void) 153 473.98 T
(* sourceData,) 261 473.98 T
(/* source of relocation */) 333 473.98 T
(void) 153 463.98 T
(* destData\051;) 261 463.98 T
(/* relocated value */) 333 463.98 T
0 10 Q
(This routine relocates a given word or dword argument and is used for) 180 446.32 T
-0.67 (resolving handles and pointers to movable objects. Most often, relocation and) 180 434.82 P
-0.49 (unrelocation occur when resources are loaded, swapped, or saved, and this is) 180 423.32 P
(in most cases taken care of by the kernel.) 180 411.82 T
4 F
(ObjDoRelocation\050\051) 180 393.32 T
0 F
( takes four parameters:) 276.66 393.32 T
6 F
(type) 180 374.82 T
0 F
-0.8 (The type of relocation to be performed \050) 243 374.82 P
4 F
-0.83 (RelocationT) 419.05 374.82 P
-0.83 (ype) 481.86 374.82 P
0 F
-0.8 (\051. This) 500.38 374.82 P
(can be one of the three values shown below) 243 363.82 T
(.) 440.81 363.82 T
6 F
(block) 180 345.82 T
0 F
(The handle of the block containing the relocation.) 243 345.82 T
6 F
(sourceData) 180 327.82 T
0 F
-0.31 (A pointer to the source of the relocation; this pointer should be) 243 327.82 P
(cast to the proper type \050word or dword\051 when calling the) 243 316.82 T
(routine.) 243 305.82 T
6 F
(destData) 180 287.82 T
0 F
(A pointer to the value to be returned; this pointer should be) 243 287.82 T
-0.5 (cast appropriately when the routine is called. The exact type of) 243 276.82 P
(return value depends on) 243 265.82 T
6 F
(sourceData) 358.37 265.82 T
0 F
( and) 410.02 265.82 T
6 F
(type) 432.99 265.82 T
0 F
(, above.) 451.69 265.82 T
-0.69 (The type of relocation to be done affects the type of data passed in) 180 247.82 P
6 F
-0.69 (sourceData) 477.26 247.82 P
0 F
-0.22 (and) 180 236.32 P
6 F
-0.22 (destData) 199.96 236.32 P
0 F
-0.22 (. The relocation type is passed in the type parameter and must) 241.26 236.32 P
(be one of the following enumerations of) 180 224.82 T
4 F
(RelocationT) 363.72 224.82 T
(ype) 426.53 224.82 T
0 F
(:) 445.05 224.82 T
0 9 Q
(RELOC_RELOC_HANDLE) 180 206.32 T
0 10 Q
(The relocation will be from a resource) 243 195.32 T
0 9 Q
(ID) 420.05 195.32 T
0 10 Q
( to a handle. The) 430.71 195.32 T
6 F
(sourceData) 243 184.32 T
0 F
( pointer should be cast to type word, and the) 294.65 184.32 T
6 F
(destData) 243 173.32 T
0 F
( pointer should be cast to type Handle.) 284.29 173.32 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "333" 33
%%Page: "334" 34
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
54 690.34 450 702 R
7 X
0 0 0 1 0 0 0 K
V
54 666.34 450 678.01 R
V
0 10 Q
0 X
(334) 54 671.34 T
32 684 288 684 2 L
7 X
V
3 H
2 Z
0 X
N
54 90 108 125 R
7 X
V
1 60 Q
0 X
(n) 58.17 85 T
104 104 299 126 R
7 X
V
2 24 Q
0 X
(Routines) 104 110 T
306 99 486 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
306 123.5 486 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
0 9 Q
0 X
(RELOC_RELOC_SEGMENT) 180 641.33 T
0 10 Q
-0.46 (The relocation will be from a resource) 243 630.33 P
0 9 Q
-0.41 (ID) 416.86 630.33 P
0 10 Q
-0.46 ( to a segment address.) 427.52 630.33 P
(The) 243 619.33 T
6 F
(sourceData) 263.56 619.33 T
0 F
( pointer should be cast to type word, and the) 315.21 619.33 T
6 F
(destData) 243 608.33 T
0 F
( pointer should be cast to type Segment.) 284.29 608.33 T
0 9 Q
(RELOC_RELOC_ENTR) 180 590.33 T
(Y_POINT) 280 590.33 T
0 10 Q
(The relocation will be from either a resource) 243 579.33 T
0 9 Q
(ID) 450.42 579.33 T
0 10 Q
( or an entry) 461.08 579.33 T
-0.49 (number to an entry point. Both the) 243 568.33 P
6 F
-0.49 (sourceData) 404.43 568.33 P
0 F
-0.49 ( pointer and the) 456.08 568.33 P
6 F
(destData) 243 557.33 T
0 F
( pointer should be cast to type dword.) 284.29 557.33 T
4 F
-0.6 (ObjDoRelocation\050\051) 180 539.33 P
0 F
-0.58 ( returns an error \337ag that will be) 276.66 539.33 P
6 F
-0.58 (true) 428.17 539.33 P
0 F
-0.58 ( if an error occurs,) 446.68 539.33 P
6 F
(false) 180 527.83 T
0 F
( otherwise.) 201.28 527.83 T
(The relocation done by this routine can be undone with) 180 509.33 T
4 F
(ObjDoUnRelocation\050\051) 180 497.83 T
0 F
(.) 291.84 497.83 T
2 F
(Include:) 99 479.33 T
0 F
(object.h) 180 479.33 T
81 462.99 531 468 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 462.99 531 468 R
7 X
0 0 0 1 0 0 0 K
V
50 466.99 609.01 466.99 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 454.99 T
2 F
(ObjDoUnRelocation\050\051) 99 454.99 T
5 10 Q
(Boolean) 99 440.33 T
3 F
(ObjDoUnRelocation\050 /* returns) 153 440.33 T
7 F
(true) 333 440.33 T
3 F
( if error */) 357 440.33 T
3 9 Q
(ObjRelocationType) 153 429.99 T
(type,) 261 429.99 T
(/* type of relocation */) 333 429.99 T
(MemHandle) 153 419.99 T
(block,) 261 419.99 T
(/* handle of info block */) 333 419.99 T
(void) 153 409.99 T
(* sourceData,) 261 409.99 T
(/* source of relocation */) 333 409.99 T
(void) 153 399.99 T
(* destData\051;) 261 399.99 T
(/* relocated value */) 333 399.99 T
0 10 Q
(This routine unrelocates a given word or dword. It translates a handle, a) 180 382.33 T
(segment address, or an entry point back into a resource) 180 370.83 T
0 9 Q
(ID) 439.28 370.83 T
0 10 Q
(. The translation) 449.95 370.83 T
(done is the exact reverse of that done by) 180 359.33 T
4 F
(ObjDoRelocation\050\051) 368.35 359.33 T
0 F
(. See that) 465.01 359.33 T
(routine \050above\051 for more information.) 180 347.83 T
4 F
(ObjDoUnRelocation\050\051) 180 329.33 T
0 F
( returns an error \337ag that will be) 291.84 329.33 T
6 F
(true) 447.97 329.33 T
0 F
( if an error) 466.48 329.33 T
-0.71 (occurs and) 180 317.83 P
6 F
-0.71 (false) 230.61 317.83 P
0 F
-0.71 ( if the unrelocation is successful. The unrelocated resource) 251.89 317.83 P
0 9 Q
-0.64 (ID) 518.27 317.83 P
0 10 Q
(will be returned pointed to by the) 180 306.33 T
6 F
(destData) 337.43 306.33 T
0 F
( pointer) 378.72 306.33 T
(.) 414.09 306.33 T
2 F
(Include:) 99 287.83 T
0 F
(object.h) 180 287.83 T
2 F
(See Also:) 99 267.83 T
0 F
(ObjDoRelocation\050\051) 180 267.83 T
81 251.48 531 256.49 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 251.48 531 256.49 R
7 X
0 0 0 1 0 0 0 K
V
50 255.48 609.01 255.48 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 243.48 T
2 F
(ObjDuplicateMessage\050\051) 99 243.48 T
5 10 Q
(EventHandle) 99 229.82 T
3 F
( ObjDuplicateMessage\050) 165 229.82 T
3 9 Q
(EventHandle msg\051;) 153 219.48 T
(/* event to duplicate */) 297 219.48 T
0 10 Q
(This routine duplicates a prerecorded event, returning the event handle of) 180 201.82 T
(the new event. Pass the handle of the event to be duplicated. Y) 180 190.32 T
(ou can then) 468.94 190.32 T
(change information about the event with) 180 178.82 T
4 F
(ObjSetMessageDestination\050\051) 371.32 178.82 T
0 F
(.) 518.52 178.82 T
2 F
(Include:) 99 160.32 T
0 F
(object.h) 180 160.32 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "334" 34
%%Page: "335" 35
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
162 690.34 558 702 R
7 X
0 0 0 1 0 0 0 K
V
162 666.34 558 678.01 R
V
0 10 Q
0 X
(335) 541.32 671.34 T
324 684 580 684 2 L
7 X
V
3 H
2 Z
0 X
N
512 90 558 125 R
7 X
V
1 60 Q
0 X
(n) 512.17 85 T
315 104 510 126 R
7 X
V
2 24 Q
0 X
(Routines) 407.33 110 T
90 99 270 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
90.67 123.5 270.67 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
2 10 Q
0 X
(See Also:) 99 641.33 T
0 F
(ObjSetEventInfo\050\051) 180 641.33 T
81 624.99 531 630 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 624.99 531 630 R
7 X
0 0 0 1 0 0 0 K
V
50 628.99 609.01 628.99 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 616.99 T
2 F
(ObjDuplicateResource\050\051) 99 616.99 T
5 10 Q
(MemHandle) 99 602.33 T
3 F
( ObjDuplicateResource\050) 153 602.33 T
3 9 Q
(MemHandle) 153 591.99 T
(blockToDup,) 261 591.99 T
(/* handle of resource; must) 351 591.99 T
( *) 351 581.99 T
7 F
(not) 367.2 581.99 T
3 F
( be loaded */) 383.4 581.99 T
(GeodeHandle) 153 571.99 T
(owner,) 261 571.99 T
(/* owner of duplicate */) 351 571.99 T
(ThreadHandle) 153 561.99 T
(burdenThread\051;) 261 561.99 T
(/* burden thread of duplicate */) 351 561.99 T
0 10 Q
-0.57 (This routine duplicates an entire object resource block. The new block will be) 180 544.33 P
-0.45 (put on the \322saved blocks\323 list so it gets saved to the geode\325) 180 532.83 P
-0.45 (s state \336le. Usually) 440.93 532.83 P
-0.43 (this is used by the) 180 521.33 P
0 9 Q
-0.39 (UI) 264.73 521.33 P
0 10 Q
-0.43 ( to make editable copies of an application\325) 275.73 521.33 P
-0.43 (s) 464.63 521.33 P
0 9 Q
-0.39 (UI) 471.61 521.33 P
0 10 Q
-0.43 ( resources) 482.61 521.33 P
(to ensure the proper state information gets saved. This routine takes three) 180 509.83 T
(parameters:) 180 498.33 T
6 F
(blockT) 180 479.83 T
(oDup) 209.85 479.83 T
0 F
-0.51 (The handle of the block to be duplicated. The block must not be) 243 479.83 P
-0.58 (resident in memory when) 243 468.83 P
4 F
-0.6 (ObjDuplicateResource\050\051) 361.61 468.83 P
0 F
-0.58 ( is called.) 486.8 468.83 P
-0.61 (Also, it can only be a \322template\323 resource\321a resource that does) 243 457.83 P
-0.2 (not get used by the) 243 446.83 P
0 9 Q
-0.19 (UI) 332.54 446.83 P
0 10 Q
-0.2 ( or the application directly) 343.54 446.83 P
-0.2 (, but only gets) 463.84 446.83 P
(copied via this routine.) 243 435.83 T
6 F
(owner) 180 417.83 T
0 F
(The owner geode of the new block. This should be the geode) 243 417.83 T
(handle of the owning geode or zero to have the calling geode) 243 406.83 T
-0.11 (own it. If you pass an) 243 395.83 P
6 F
-0.11 (owner) 343.83 395.83 P
0 F
-0.11 ( of -1, the new block will be owned) 371.6 395.83 P
(by the same geode that owns the original.) 243 384.83 T
6 F
(burdenThread) 180 366.83 T
0 F
(The thread that will run the block and handle its messages.) 243 355.83 T
(This should be a thread handle or zero to have the calling) 243 344.83 T
-0.2 (thread run the block. Passing a) 243 333.83 P
6 F
-0.2 (burdenThread) 389.41 333.83 P
0 F
-0.2 ( of -1 makes the) 455.87 333.83 P
(new resource have the same burden thread as the original.) 243 322.83 T
4 F
(ObjDuplicateResource\050\051) 180 304.83 T
0 F
( returns the handle of the newly created block,) 305.19 304.83 T
(which will be unlocked and may or may not be resident in memory) 180 293.33 T
(.) 485.97 293.33 T
2 F
(Include:) 99 274.83 T
0 F
(object.h) 180 274.83 T
2 F
(See Also:) 99 254.83 T
0 F
(ObjFreeDuplicate\050\051,) 180 254.83 T
0 9 Q
(MSG_MET) 274.45 254.83 T
(A_BLOCK_FREE) 320.62 254.83 T
0 10 Q
(, ObjLockObjBlock\050\051) 394.62 254.83 T
81 238.48 531 243.49 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 238.48 531 243.49 R
7 X
0 0 0 1 0 0 0 K
V
50 242.48 609.01 242.48 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 230.48 T
2 F
(ObjEnableDetach\050\051) 99 230.48 T
5 10 Q
(void) 99 215.82 T
3 F
(ObjEnableDetach\050) 153 215.82 T
3 9 Q
(optr) 153 205.48 T
(obj\051;) 189 205.48 T
(/* object calling this routine */) 279 205.48 T
0 10 Q
(This routine acts as an object\325) 180 187.82 T
(s handler for) 317.06 187.82 T
0 9 Q
(MSG_MET) 378.91 187.82 T
(A_ACK) 425.08 187.82 T
0 10 Q
(. This handler) 456.08 187.82 T
-0.76 (decrements the acknowledgment count \050incremented with) 180 176.32 P
4 F
-0.78 (ObjIncDetach\050\051) 445.84 176.32 P
0 F
-0.76 (\051) 525.65 176.32 P
(and, if the count is zero, enables the detach mechanism so the object can be) 180 164.82 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "335" 35
%%Page: "336" 36
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
54 690.34 450 702 R
7 X
0 0 0 1 0 0 0 K
V
54 666.34 450 678.01 R
V
0 10 Q
0 X
(336) 54 671.34 T
32 684 288 684 2 L
7 X
V
3 H
2 Z
0 X
N
54 90 108 125 R
7 X
V
1 60 Q
0 X
(n) 58.17 85 T
104 104 299 126 R
7 X
V
2 24 Q
0 X
(Routines) 104 110 T
306 99 486 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
306 123.5 486 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
0 10 Q
0 X
(fully detached. Because the detach mechanism is implemented in) 180 641.33 T
4 F
(MetaClass) 180 629.83 T
0 F
(, it is highly unlikely you will ever call this routine.) 233.33 629.83 T
-0.05 (The lone parameter of this routine is the optr of the calling object \050or) 180 611.33 P
-0.05 (, in the) 495.79 611.33 P
(case of) 180 599.83 T
0 9 Q
(MSG_MET) 213.52 599.83 T
(A_ACK) 259.69 599.83 T
0 10 Q
(, the object sending acknowledgment\051.) 290.69 599.83 T
2 F
(W) 99 581.33 T
(arnings:) 108.07 581.33 T
0 F
(This routine may resize and/or move chunks and object blocks, thereby) 180 581.33 T
(invalidating all pointers and segment addresses.) 180 568.33 T
2 F
(Include:) 99 548.33 T
0 F
(metaC.goh) 180 548.33 T
2 F
(See Also:) 99 528.33 T
0 9 Q
(MSG_MET) 180 528.33 T
(A_DET) 226.17 528.33 T
(ACH) 256.18 528.33 T
0 10 Q
(, ObjInitDetach\050\051, ObjIncDetach\050\051,) 276.67 528.33 T
0 9 Q
(MSG_MET) 436.67 528.33 T
(A_ACK) 482.84 528.33 T
81 511.99 531 517 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 511.99 531 517 R
7 X
0 0 0 1 0 0 0 K
V
50 515.99 609.01 515.99 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 503.99 T
2 F
(ObjFreeChunk\050\051) 99 503.99 T
5 10 Q
(void) 99 489.33 T
3 F
(ObjFreeChunk\050) 153 489.33 T
3 9 Q
(optr) 153 478.99 T
(o\051;) 189 478.99 T
(/* optr of chunk to be freed */) 279 478.99 T
0 10 Q
-0.49 (This routine frees the passed object\325) 180 461.33 P
-0.49 (s instance chunk. If the object came from) 342.91 461.33 P
(a loaded resource, however) 180 449.83 T
(, the object is resized to zero and marked dirty) 303.89 449.83 T
(rather than actually freed.) 180 438.33 T
2 F
(W) 99 419.83 T
(arnings:) 108.07 419.83 T
0 F
(The object must be fully detached, and its message queues must be empty) 180 419.83 T
-0.16 (before it can safely be freed. All this is handled by) 180 406.83 P
0 9 Q
-0.14 (MSG_MET) 411.67 406.83 P
-0.14 (A_DET) 457.84 406.83 P
-0.14 (ACH) 487.85 406.83 P
0 10 Q
-0.16 ( and) 508.34 406.83 P
0 9 Q
(MSG_MET) 180 393.83 T
(A_OBJ_FREE) 226.17 393.83 T
0 10 Q
(.) 285.67 393.83 T
2 F
(Include:) 99 373.83 T
0 F
(object.h) 180 373.83 T
2 F
(See Also:) 99 353.83 T
0 9 Q
(MSG_MET) 180 353.83 T
(A_DET) 226.17 353.83 T
(ACH) 256.18 353.83 T
0 10 Q
(,) 276.67 353.83 T
0 9 Q
(MSG_MET) 282.23 353.83 T
(A_OBJ_FREE) 328.4 353.83 T
0 10 Q
(, ObjInstantiate\050\051) 387.9 353.83 T
81 337.48 531 342.49 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 337.48 531 342.49 R
7 X
0 0 0 1 0 0 0 K
V
50 341.48 609.01 341.48 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 329.48 T
2 F
(ObjFreeChunkHandles\050\051) 99 329.48 T
5 10 Q
(void) 99 315.82 T
3 F
(ObjFreeChunkHandles\050) 153 315.82 T
3 9 Q
(MemHandle) 153 305.48 T
(mh,) 261 305.48 T
(/* handle portion of optr */) 315 305.48 T
(ChunkHandle) 153 295.48 T
(ch\051;) 261 295.48 T
(/* chunk portion of optr */) 315 295.48 T
0 10 Q
(This routine is the same as ObjFreeChunk\050\051; the chunk is speci\336ed by its) 180 277.82 T
(handles rather than by an optr) 180 266.32 T
(.) 322.24 266.32 T
2 F
(Include:) 99 247.82 T
0 F
(object.h) 180 247.82 T
81 231.48 531 236.48 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 231.48 531 236.48 R
7 X
0 0 0 1 0 0 0 K
V
50 235.48 609.01 235.48 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 223.47 T
2 F
(ObjFreeDuplicate\050\051) 99 223.47 T
5 10 Q
(void) 99 208.81 T
3 F
(ObjFreeDuplicate\050) 153 208.81 T
3 9 Q
(MemHandle mh\051;) 153 198.47 T
(/* handle of duplicate block to be freed */) 279 198.47 T
0 10 Q
(This routine frees a block that had been saved with) 180 180.81 T
4 F
(ObjSaveBlock\050\051) 419.86 180.81 T
0 F
( or) 500.24 180.81 T
(created with) 180 169.31 T
4 F
(ObjDuplicateResource\050\051) 240.56 169.31 T
0 F
(. It must be passed the memory) 365.75 169.31 T
(handle of the duplicated resource.) 180 157.81 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "336" 36
%%Page: "337" 37
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
162 690.34 558 702 R
7 X
0 0 0 1 0 0 0 K
V
162 666.34 558 678.01 R
V
0 10 Q
0 X
(337) 541.32 671.34 T
324 684 580 684 2 L
7 X
V
3 H
2 Z
0 X
N
512 90 558 125 R
7 X
V
1 60 Q
0 X
(n) 512.17 85 T
315 104 510 126 R
7 X
V
2 24 Q
0 X
(Routines) 407.33 110 T
90 99 270 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
90.67 123.5 270.67 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
2 10 Q
0 X
(W) 99 641.33 T
(arnings:) 108.07 641.33 T
0 F
(All objects in the duplicated resource must be properly detached to ensure) 180 641.33 T
-0.07 (that nothing tries to send messages to the objects in the block. Additionally) 180 628.33 P
-0.07 (,) 525.51 628.33 P
(the block\325) 180 615.33 T
(s in-use count and interactable count should be zero.) 223.53 615.33 T
2 F
(Include:) 99 595.33 T
0 F
(object.h) 180 595.33 T
2 F
(See Also:) 99 575.33 T
0 F
(ObjDuplicateResource\050\051, ObjSaveBlock\050\051, ObjLMemBlockHeader) 180 575.33 T
81 558.99 531 564 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 558.99 531 564 R
7 X
0 0 0 1 0 0 0 K
V
50 562.99 609.01 562.99 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 550.99 T
2 F
(ObjFreeMessage\050\051) 99 550.99 T
5 10 Q
(void) 99 536.33 T
3 F
(ObjFreeMessage\050) 153 536.33 T
3 9 Q
(EventHandle event\051;) 153 525.99 T
(/* event to be freed */) 297 525.99 T
0 10 Q
-0.18 (This routine frees an event handle and its associated event. This is rarely) 180 508.33 P
-0.18 (, if) 516.55 508.33 P
-0.39 (ever) 180 496.83 P
-0.39 (, used by anything other than the kernel. The kernel uses this routine to) 199.07 496.83 P
(free events after they have been handled.) 180 485.33 T
2 F
(Include:) 99 466.83 T
0 F
(object.h) 180 466.83 T
81 450.48 531 455.49 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 450.48 531 455.49 R
7 X
0 0 0 1 0 0 0 K
V
50 454.48 609.01 454.48 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 442.48 T
2 F
(ObjFreeObjBlock\050\051) 99 442.48 T
5 10 Q
(void) 99 428.82 T
3 F
(ObjFreeObjBlock\050) 153 428.82 T
3 9 Q
(MemHandle block\051;) 153 418.48 T
(/* handle of the object block to be freed */) 279 418.48 T
0 10 Q
-0.12 (This routine frees the speci\336ed object block. It \336rst checks the block\325) 180 400.82 P
-0.12 (s in-use) 492.73 400.82 P
(count to see if any external references to the block are being kept. If the) 180 389.32 T
(in-use count is nonzero,) 180 377.82 T
4 F
(ObjFreeObjBlock\050\051) 292.03 377.82 T
0 F
( simply sets the block\325) 390 377.82 T
(s) 490.95 377.82 T
(auto-free bit and returns; the block will be freed the \336rst time the in-use) 180 366.32 T
(count reaches zero. If the in-use count is zero \050no external references\051, the) 180 354.82 T
(block will be freed immediately) 180 343.32 T
(.) 323.18 343.32 T
-0.09 (If the object block passed is not run by the calling thread, the operation will) 180 324.82 P
(be handled by a remote call in the object block\325) 180 313.32 T
(s thread.) 394.86 313.32 T
2 F
(Include:) 99 294.82 T
0 F
(object.h) 180 294.82 T
2 F
(See Also:) 99 274.82 T
0 F
(ObjFreeDuplicate\050\051,) 180 274.82 T
0 9 Q
(MSG_MET) 274.45 274.82 T
(A_BLOCK_FREE) 320.62 274.82 T
81 258.48 531 263.48 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 258.48 531 263.48 R
7 X
0 0 0 1 0 0 0 K
V
50 262.48 609.01 262.48 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 250.47 T
2 F
(ObjGetFlags\050\051) 99 250.47 T
5 10 Q
(ObjChunkFlags) 99 235.81 T
3 F
( ObjGetFlags\050) 177 235.81 T
3 9 Q
(optr) 153 225.47 T
(o\051;) 189 225.47 T
(/* optr of subject object */) 279 225.47 T
0 10 Q
-0.84 (This routine returns the object \337ags associated with a given object. The object) 180 207.81 P
(is speci\336ed by the passed optr) 180 196.31 T
(, and the \337ags are stored in the object\325) 317.05 196.31 T
(s) 492.63 196.31 T
4 F
(ObjChunkFlags) 180 184.81 T
0 F
( record.) 261.29 184.81 T
2 F
(Include:) 99 166.31 T
0 F
(object.h) 180 166.31 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "337" 37
%%Page: "338" 38
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
54 690.34 450 702 R
7 X
0 0 0 1 0 0 0 K
V
54 666.34 450 678.01 R
V
0 10 Q
0 X
(338) 54 671.34 T
32 684 288 684 2 L
7 X
V
3 H
2 Z
0 X
N
54 90 108 125 R
7 X
V
1 60 Q
0 X
(n) 58.17 85 T
104 104 299 126 R
7 X
V
2 24 Q
0 X
(Routines) 104 110 T
306 99 486 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
306 123.5 486 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
2 10 Q
0 X
(See Also:) 99 641.33 T
0 F
(ObjSetFlags\050\051, ObjChunkFlags) 180 641.33 T
81 624.99 531 630 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 624.99 531 630 R
7 X
0 0 0 1 0 0 0 K
V
50 628.99 609.01 628.99 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 616.99 T
2 F
(ObjGetFlagsHandles\050\051) 99 616.99 T
5 10 Q
(ObjChunkFlags) 99 603.33 T
3 F
( ObjGetFlagsHandles\050) 177 603.33 T
3 9 Q
(Memhandle) 153 592.99 T
(mh,) 261 592.99 T
(/* handle portion of optr */) 315 592.99 T
(ChunkHandle) 153 582.99 T
(ch\051;) 261 582.99 T
(/* chunk portion of optr */) 315 582.99 T
0 10 Q
(This routine is the same as) 180 565.33 T
4 F
(ObjGetFlags\050\051) 307.99 565.33 T
0 F
(, but the object is speci\336ed with) 380.39 565.33 T
(its handles rather than with its optr) 180 553.83 T
(.) 346.69 553.83 T
2 F
(Include:) 99 535.33 T
0 F
(object.h) 180 535.33 T
81 518.98 531 523.99 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 518.98 531 523.99 R
7 X
0 0 0 1 0 0 0 K
V
50 522.98 609.01 522.98 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 510.98 T
2 F
(ObjGetMessageInfo\050\051) 99 510.98 T
5 10 Q
(Message) 99 496.32 T
3 F
(ObjGetMessageInfo\050) 153 496.32 T
3 9 Q
(EventHandle) 153 485.98 T
(event,) 261 485.98 T
(/* event to be queried */) 333 485.98 T
(optr) 153 475.98 T
(* dest\051;) 261 475.98 T
(/* buffer for destination optr */) 333 475.98 T
0 10 Q
(This routine gets information about the speci\336ed) 180 458.32 T
6 F
(event) 408.17 458.32 T
0 F
(. The return value is) 431.87 458.32 T
-0.37 (the message number of the event. The) 180 446.82 P
6 F
-0.37 (dest) 356.33 446.82 P
0 F
-0.37 ( parameter is a pointer to an optr) 374.84 446.82 P
-0.37 (.) 525.81 446.82 P
(This routine will return with the optr represinting the event\325) 180 435.32 T
(s destination) 460.57 435.32 T
(object.) 180 423.82 T
2 F
(Include:) 99 405.32 T
0 F
(object.h) 180 405.32 T
81 388.98 531 393.98 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 388.98 531 393.98 R
7 X
0 0 0 1 0 0 0 K
V
50 392.98 609.01 392.98 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 380.98 T
2 F
(ObjIncDetach\050\051) 99 380.98 T
5 10 Q
(void) 99 366.31 T
3 F
(ObjIncDetach\050) 153 366.31 T
3 9 Q
(optr) 153 355.98 T
(obj\051;) 189 355.98 T
(/* optr of calling object */) 279 355.98 T
0 10 Q
(This routine increments the number of detach acknowledgments an object) 180 338.31 T
-0.45 (must receive before it can safely be detached. Each time the detaching object) 180 326.81 P
-0.74 (sends noti\336cation of its detachment, it must call) 180 315.31 P
4 F
-0.76 (ObjIncDetach\050\051) 399.13 315.31 P
0 F
-0.74 ( to indicate) 478.94 315.31 P
(that it must receive a corresponding detach acknowledgment) 180 303.81 T
(\050) 180 292.31 T
0 9 Q
(MSG_MET) 183.33 292.31 T
(A_ACK) 229.5 292.31 T
0 10 Q
(\051.) 260.5 292.31 T
(The calling object must have previously called) 180 273.81 T
4 F
(ObjInitDetach\050\051) 395.58 273.81 T
0 F
(. Since the) 477.79 273.81 T
(detach mechanism is implemented in) 180 262.31 T
4 F
(MetaClass) 355.02 262.31 T
0 F
(, it is highly unlikely you) 408.35 262.31 T
-0.82 (will ever need to call this routine.) 180 250.81 P
4 F
-0.85 ( ObjIncDetach\050\051) 330.09 250.81 P
0 F
-0.82 ( takes a single parameter:) 411.92 250.81 P
(the optr of the calling object.) 180 239.31 T
2 F
(Include:) 99 220.81 T
0 F
(metaC.goh) 180 220.81 T
2 F
(See Also:) 99 200.81 T
0 9 Q
-0.24 (MSG_MET) 180 200.81 P
-0.24 (A_DET) 226.17 200.81 P
-0.24 (ACH) 256.18 200.81 P
0 10 Q
-0.27 (, ObjInitDetach\050\051, ObjEnableDetach\050\051,) 276.67 200.81 P
0 9 Q
-0.24 (MSG_MET) 453.83 200.81 P
-0.24 (A_ACK) 500 200.81 P
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "338" 38
%%Page: "339" 39
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
162 690.34 558 702 R
7 X
0 0 0 1 0 0 0 K
V
162 666.34 558 678.01 R
V
0 10 Q
0 X
(339) 541.32 671.34 T
324 684 580 684 2 L
7 X
V
3 H
2 Z
0 X
N
512 90 558 125 R
7 X
V
1 60 Q
0 X
(n) 512.17 85 T
315 104 510 126 R
7 X
V
2 24 Q
0 X
(Routines) 407.33 110 T
90 99 270 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
90.67 123.5 270.67 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
81 642.99 531 648 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 642.99 531 648 R
7 X
0 0 0 1 0 0 0 K
V
50 646.99 609.01 646.99 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 634.99 T
2 F
(ObjIncInteractibleCount\050\051) 99 634.99 T
5 10 Q
(void) 99 621.33 T
3 F
(ObjIncInteractibleCount\050) 153 621.33 T
3 9 Q
(MemHandle mh\051;) 153 610.99 T
(/* handle of object block */) 279 610.99 T
0 10 Q
-0.37 (This routine increments the interactable count of the given object block. The) 180 593.33 P
(interactable count maintains the number of objects currently visible to the) 180 581.83 T
(user or about to be acted on by the user \050e.g. via keyboard accelerator\051. The) 180 570.33 T
(interactable count is maintained by the) 180 558.83 T
0 9 Q
(UI) 364.85 558.83 T
0 10 Q
(; only in extremely special cases) 375.85 558.83 T
-0.24 (may you need to increment or decrement the count. T) 180 547.33 P
-0.24 (o decrement the count,) 423.99 547.33 P
(use) 180 535.83 T
4 F
(ObjDecInteractibleCount\050\051) 198.52 535.83 T
0 F
(.) 337.96 535.83 T
(V) 180 517.33 T
(isible objects increment the interactable count in their) 186.78 517.33 T
0 9 Q
(MSG_VIS_OPEN) 440.32 517.33 T
0 10 Q
(handlers and decrement it in their) 180 505.83 T
0 9 Q
(MSG_VIS_CLOSE) 342.23 505.83 T
0 10 Q
( handlers. This is built) 419.9 505.83 T
(into) 180 494.33 T
4 F
(V) 200.93 494.33 T
(isClass) 208.08 494.33 T
0 F
(.) 244.19 494.33 T
2 F
(Include:) 99 475.83 T
0 F
(object.h) 180 475.83 T
2 F
(See Also:) 99 455.83 T
0 F
(ObjDecInteractibleCount\050\051,) 180 455.83 T
0 9 Q
(MSG_VIS_OPEN) 308.33 455.83 T
0 10 Q
(,) 381.17 455.83 T
0 9 Q
(MSG_VIS_CLOSE) 386.73 455.83 T
0 10 Q
(,) 464.4 455.83 T
(ObjLMemBlockHeader) 180 442.83 T
81 426.48 531 431.49 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 426.48 531 431.49 R
7 X
0 0 0 1 0 0 0 K
V
50 430.48 609.01 430.48 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 418.48 T
2 F
(ObjIncInUseCount\050\051) 99 418.48 T
5 10 Q
(void) 99 403.82 T
3 F
(ObjIncInUseCount\050) 153 403.82 T
3 9 Q
(MemHandle mh\051;) 153 393.48 T
(/* handle of object block */) 279 393.48 T
0 10 Q
(This routine increments the given object block\325) 180 375.82 T
(s in-use count. The in-use) 395.2 375.82 T
-0.04 (count maintains the number of outside references to this object block which) 180 364.32 P
(are stored elsewhere and which need to be removed before the block can) 180 352.82 T
-0.05 (safely be freed. If you store an optr to an object block, you should increment) 180 341.32 P
(the in-use count of the block.) 180 329.82 T
(When the reference to the block is removed, the in-use count should be) 180 311.32 T
(decremented with) 180 299.82 T
4 F
(ObjDecInUseCount\050\051) 265.74 299.82 T
0 F
(.) 373.69 299.82 T
2 F
(Include:) 99 281.32 T
0 F
(object.h) 180 281.32 T
2 F
(See Also:) 99 261.32 T
0 F
(ObjDecInUseCount\050\051, ObjIncInteractibleCount\050\051, ObjLMemBlockHeader) 180 261.32 T
81 244.98 531 249.98 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 244.98 531 249.98 R
7 X
0 0 0 1 0 0 0 K
V
50 248.98 609.01 248.98 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 236.97 T
2 F
(ObjInitDetach\050\051) 99 236.97 T
5 10 Q
(void) 99 222.31 T
3 F
(ObjInitDetach\050) 153 222.31 T
3 9 Q
(MetaMessages) 153 211.97 T
(msg,) 261 211.97 T
(optr) 153 201.97 T
(obj) 261 201.97 T
(/* object being detached */) 315 201.97 T
(word) 153 191.97 T
(callerID,) 261 191.97 T
(/* an identifier token for the caller */) 315 191.97 T
(optr) 153 181.97 T
(ackOD\051;) 261 181.97 T
(/* object to which ack is sent */) 315 181.97 T
0 10 Q
(Initialize the detach sequence for the speci\336ed object. The detach sequence) 180 164.31 T
-0.28 (severs all ties between the system and the object, allowing it to be destroyed) 180 152.81 P
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "339" 39
%%Page: "340" 40
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
54 690.34 450 702 R
7 X
0 0 0 1 0 0 0 K
V
54 666.34 450 678.01 R
V
0 10 Q
0 X
(340) 54 671.34 T
32 684 288 684 2 L
7 X
V
3 H
2 Z
0 X
N
54 90 108 125 R
7 X
V
1 60 Q
0 X
(n) 58.17 85 T
104 104 299 126 R
7 X
V
2 24 Q
0 X
(Routines) 104 110 T
306 99 486 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
306 123.5 486 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
0 10 Q
0 X
(without other objects or geodes trying to contact it. It is highly unlikely you) 180 641.33 T
-0.81 (will ever call this routine; typically) 180 629.83 P
-0.81 (, you will instead use) 336.18 629.83 P
0 9 Q
-0.73 (MSG_MET) 432.36 629.83 P
-0.73 (A_DET) 478.53 629.83 P
-0.73 (ACH) 508.53 629.83 P
0 10 Q
(or one of the generic or visible object messages, which will call this routine.) 180 618.33 T
(The parameters for this routine are) 180 606.83 T
(msg) 180 588.33 T
(The detach message.) 243 588.33 T
6 F
(obj) 180 570.33 T
0 F
(The optr of the object to be detached.) 243 570.33 T
6 F
(callerID) 180 552.33 T
0 F
(The caller object\325) 243 552.33 T
(s) 320.6 552.33 T
0 9 Q
(ID) 328.01 552.33 T
0 10 Q
(.) 338.67 552.33 T
6 F
(ackOD) 180 534.33 T
0 F
-0.77 (The optr of the caller object or another object which is to receive) 243 534.33 P
(acknowledgment noti\336cation of the detach.) 243 523.33 T
2 F
(Include:) 99 505.33 T
0 F
(metaC.goh) 180 505.33 T
2 F
(See Also:) 99 485.33 T
0 9 Q
(MSG_MET) 180 485.33 T
(A_DET) 226.17 485.33 T
(ACH) 256.18 485.33 T
0 10 Q
(,) 276.67 485.33 T
0 9 Q
(MSG_GEN_DESTROY) 282.23 485.33 T
0 10 Q
(,) 377.13 485.33 T
0 9 Q
(MSG_VIS_REMOVE) 382.69 485.33 T
0 10 Q
(,) 470.18 485.33 T
(ObjIncDetach\050\051, ObjEnableDetach\050\051,) 180 472.33 T
0 9 Q
(MSG_MET) 349.82 472.33 T
(A_ACK) 395.99 472.33 T
81 455.99 531 461 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 455.99 531 461 R
7 X
0 0 0 1 0 0 0 K
V
50 459.99 609.01 459.99 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 447.99 T
2 F
(ObjInitializeMaster\050\051) 99 447.99 T
5 10 Q
(void) 99 433.33 T
3 F
(ObjInitializeMaster\050) 153 433.33 T
3 9 Q
(optr) 153 422.99 T
(obj,) 261 422.99 T
(/* object to be initialized */) 333 422.99 T
(ClassStruct) 153 412.99 T
(* class\051;) 261 412.99 T
(/* class in master group */) 333 412.99 T
0 10 Q
(This routine initializes the appropriate master part of the passed object,) 180 395.33 T
(resizing the instance chunk if necessary) 180 383.83 T
(. It takes two parameters:) 363.7 383.83 T
6 F
(obj) 180 365.33 T
0 F
(The optr of the object whose master part is to be initialized.) 243 365.33 T
6 F
(class) 180 347.33 T
0 F
(A pointer to the class de\336nition of a class in the appropriate) 243 347.33 T
-0.81 (master group. This does not have to be the master class; it must) 243 336.33 P
(only be a class in the master goup.) 243 325.33 T
2 F
(W) 99 307.33 T
(arnings:) 108.07 307.33 T
0 F
(This routine may resize and/or move chunks or object blocks, thereby) 180 307.33 T
(invalidating pointers and segment addresses.) 180 294.33 T
2 F
(Include:) 99 274.33 T
0 F
(object.h) 180 274.33 T
2 F
(See Also:) 99 254.33 T
0 F
(ObjResizeMaster\050\051, ObjInitializePart\050\051, ClassStruct) 180 254.33 T
81 237.98 531 242.99 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 237.98 531 242.99 R
7 X
0 0 0 1 0 0 0 K
V
50 241.98 609.01 241.98 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 229.98 T
2 F
(ObjInitializeMasterHandles\050\051) 99 229.98 T
5 10 Q
(void) 99 216.32 T
3 F
(ObjInitializeMasterHandles\050) 153 216.32 T
3 9 Q
(MemHandle) 153 205.98 T
(mh,) 261 205.98 T
(/* handle portion of optr */) 333 205.98 T
(ChunkHandle) 153 195.98 T
(ch,) 261 195.98 T
(/* chunk portion of optr */) 333 195.98 T
(ClassStruct) 153 185.98 T
(* class\051;) 261 185.98 T
(/* class in master group */) 333 185.98 T
0 10 Q
(This routine is the same as) 180 168.32 T
4 F
(ObjInitializeMaster\050\051) 307.99 168.32 T
0 F
( except it speci\336es the) 417.6 168.32 T
(object via its handles rather than its optr) 180 156.82 T
(.) 369.47 156.82 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "340" 40
%%Page: "341" 41
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
162 690.34 558 702 R
7 X
0 0 0 1 0 0 0 K
V
162 666.34 558 678.01 R
V
0 10 Q
0 X
(341) 541.32 671.34 T
324 684 580 684 2 L
7 X
V
3 H
2 Z
0 X
N
512 90 558 125 R
7 X
V
1 60 Q
0 X
(n) 512.17 85 T
315 104 510 126 R
7 X
V
2 24 Q
0 X
(Routines) 407.33 110 T
90 99 270 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
90.67 123.5 270.67 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
2 10 Q
0 X
(Include:) 99 641.33 T
0 F
(object.h) 180 641.33 T
81 624.99 531 630 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 624.99 531 630 R
7 X
0 0 0 1 0 0 0 K
V
50 628.99 609.01 628.99 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 616.99 T
2 F
(ObjInitializePart\050\051) 99 616.99 T
5 10 Q
(void) 99 602.33 T
3 F
(ObjInitializePart\050) 153 602.33 T
3 9 Q
(optr) 153 591.99 T
(obj,) 189 591.99 T
(/* object to have a part initialized */) 297 591.99 T
(word) 153 581.99 T
(masterOffset\051;) 189 581.99 T
(/* offset to master offset in chunk */) 297 581.99 T
0 10 Q
(This routine initializes all master parts of the given object down to and) 180 564.33 T
(including the master part speci\336ed in) 180 552.83 T
6 F
(masterOffset) 356.12 552.83 T
0 F
(. It will resize the chunk) 414.43 552.83 T
(if necessary and even resolve variant classes above the master group) 180 541.33 T
(speci\336ed, if necessary) 180 529.83 T
(. This routine takes two parameters:) 278.7 529.83 T
6 F
(obj) 180 511.33 T
0 F
(The optr of the object to be initialized.) 243 511.33 T
6 F
(masterOffset) 180 493.33 T
0 F
(The offset within the parent\325) 243 482.33 T
(s instance chunk to the master) 374.68 482.33 T
-0.27 (group\325) 243 471.33 P
-0.27 (s offset \050the value that would appear in the parent class\325) 271.33 471.33 P
6 F
(Class_masterOffset) 243 460.33 T
0 F
( \336eld in its) 331.48 460.33 T
4 F
(ClassStruct) 383.53 460.33 T
0 F
( structure\051.) 443.73 460.33 T
2 F
(W) 99 442.33 T
(arnings:) 108.07 442.33 T
0 F
(This routine may move and/or resize chunks or object blocks, thereby) 180 442.33 T
(invalidating pointers and segment addresses.) 180 429.33 T
2 F
(Include:) 99 409.33 T
0 F
(object.h) 180 409.33 T
2 F
(See Also:) 99 389.33 T
0 F
(ObjResizeMaster\050\051, ObjInitializeMaster\050\051,) 180 389.33 T
0 9 Q
(MSG_MET) 180 376.33 T
(A_RESOL) 226.17 376.33 T
(VE_V) 268.01 376.33 T
(ARIANT_SUPERCLASS) 291.01 376.33 T
81 359.98 531 364.99 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 359.98 531 364.99 R
7 X
0 0 0 1 0 0 0 K
V
50 363.98 609.01 363.98 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 351.98 T
2 F
(ObjInitializePartHandles\050\051) 99 351.98 T
3 10 Q
(void) 99 338.32 T
(ObjInitializePartHandles\050) 153 338.32 T
3 9 Q
(Memhandle) 153 327.98 T
(mh,) 261 327.98 T
(/* handle portion of optr */) 351 327.98 T
(ChunkHandle) 153 317.98 T
(ch,) 261 317.98 T
(/* chunk portion of optr */) 351 317.98 T
(word) 153 307.98 T
(masterOffset\051;) 261 307.98 T
(/* master group offset */) 351 307.98 T
0 10 Q
(This routine is the same as) 180 290.32 T
4 F
(ObjInitializePart\050\051) 307.99 290.32 T
0 F
( except that it speci\336es the) 404.64 290.32 T
(object via its handles rather than an optr) 180 278.82 T
(.) 369.47 278.82 T
2 F
(Include:) 99 260.32 T
0 F
(object.h) 180 260.32 T
81 243.98 531 248.98 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 243.98 531 248.98 R
7 X
0 0 0 1 0 0 0 K
V
50 247.98 609.01 247.98 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 235.97 T
2 F
(ObjInstantiate\050\051) 99 235.97 T
5 10 Q
(optr) 99 221.31 T
3 F
(ObjInstantiate\050) 153 221.31 T
3 9 Q
(MemHandle) 153 210.97 T
(block,) 261 210.97 T
(/* block in which new object) 333 210.97 T
( * will be instantiated */) 315 200.97 T
(ClassStruct) 153 190.97 T
(* class\051;) 261 190.97 T
(/* class of new object */) 333 190.97 T
0 10 Q
(This routine instantiates a new object, allocating the proper size instance) 180 173.31 T
-0.75 (chunk. It returns the optr of the new object; this optr can then be used to send) 180 161.81 P
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "341" 41
%%Page: "342" 42
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
54 690.34 450 702 R
7 X
0 0 0 1 0 0 0 K
V
54 666.34 450 678.01 R
V
0 10 Q
0 X
(342) 54 671.34 T
32 684 288 684 2 L
7 X
V
3 H
2 Z
0 X
N
54 90 108 125 R
7 X
V
1 60 Q
0 X
(n) 58.17 85 T
104 104 299 126 R
7 X
V
2 24 Q
0 X
(Routines) 104 110 T
306 99 486 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
306 123.5 486 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
0 10 Q
0 X
-0.82 (setup messages or other messages \050such as adding the object to an object tree,) 180 641.33 P
(setting it usable, etc.\051.) 180 629.83 T
(The new object\325) 180 611.33 T
(s instance data will be initialized to all zeroes if it has no) 250.75 611.33 T
-0.54 (master parts \050is a direct descendant of) 180 599.83 P
4 F
-0.56 (MetaClass) 356.23 599.83 P
0 F
-0.54 (\051. If it is a member of some) 409.56 599.83 P
(master group, only enough space for the base structure \050the master offsets) 180 588.33 T
(and the class pointer\051 will be allocated. In either case, initialization of the) 180 576.83 T
(instance data will occur at a later time.) 180 565.33 T
4 F
(ObjInstantiate\050\051) 180 546.83 T
0 F
( takes two parameters:) 263.69 546.83 T
6 F
(block) 180 528.33 T
0 F
(The memory handle of an object block in which the object\325) 243 528.33 T
(s) 509.14 528.33 T
(instance chunk will be allocated. This block) 243 517.33 T
6 F
(must) 446.75 517.33 T
0 F
( be an object) 469.71 517.33 T
(block, though it need not be run by the caller) 243 506.33 T
(\325) 450.8 506.33 T
(s thread. If the) 452.47 506.33 T
-0.14 (block is run by another thread, the routine will be executed as) 243 495.33 P
(a remote call.) 243 484.33 T
6 F
(class) 180 466.33 T
0 F
-0.08 (A pointer to the) 243 466.33 P
4 F
-0.08 (ClassStruct) 318.26 466.33 P
0 F
-0.08 ( structure of the class of the new) 378.46 466.33 P
-0.14 (object. This pointer will be set in the object\325) 243 455.33 P
-0.14 (s class pointer \050the) 441.74 455.33 P
(\336rst four bytes of the instance chunk\051.) 243 444.33 T
2 F
(W) 99 426.33 T
(arnings:) 108.07 426.33 T
0 F
-0.34 (This routine, because it allocates a new chunk, may cause LMem and Object) 180 426.33 P
(blocks to move or resize, thereby invalidating any pointers and segment) 180 413.33 T
(addresses. Be sure to dereference pointers after calls to this routine.) 180 400.33 T
2 F
(Include:) 99 380.33 T
0 F
(metaC.goh) 180 380.33 T
81 363.99 531 369 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 363.99 531 369 R
7 X
0 0 0 1 0 0 0 K
V
50 367.99 609.01 367.99 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 355.99 T
2 F
(ObjIsClassADescendant\050\051) 99 355.99 T
5 10 Q
(Boolean) 99 342.33 T
3 F
(ObjIsClassADescendant\050) 153 342.33 T
3 9 Q
(ClassStruct) 153 331.99 T
(* class1,) 261 331.99 T
(/* proposed ancestor */) 333 331.99 T
(ClassStruct) 153 321.99 T
(* class2\051;) 261 321.99 T
(/* proposed descendant */) 333 321.99 T
0 10 Q
-0.55 (This routine checks if) 180 304.33 P
6 F
-0.55 (class2) 280.21 304.33 P
0 F
-0.55 ( is a descendand of) 308.16 304.33 P
6 F
-0.55 (class1) 395.05 304.33 P
0 F
-0.55 ( and returns) 423 304.33 P
6 F
-0.55 (true) 481.72 304.33 P
0 F
-0.55 ( if it is.) 500.23 304.33 P
2 F
(Include:) 99 285.83 T
0 F
(object.h) 180 285.83 T
81 269.48 531 274.49 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 269.48 531 274.49 R
7 X
0 0 0 1 0 0 0 K
V
50 273.48 609.01 273.48 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 261.48 T
2 F
(ObjIsObjectInClass\050\051) 99 261.48 T
5 10 Q
(Boolean) 99 246.82 T
3 F
(ObjIsObjectInClass\050) 153 246.82 T
3 9 Q
(optr) 153 236.48 T
(obj,) 261 236.48 T
(/* object to check */) 333 236.48 T
(ClassStruct) 153 226.48 T
(* class\051;) 261 226.48 T
(/* proposed class */) 333 226.48 T
0 10 Q
(This routine checks to see if the passed object is a member of the speci\336ed) 180 208.82 T
(class. It checks superclasses as well, but if an unresolved variant class is) 180 197.32 T
(encountered, the variant will) 180 185.82 T
6 F
(not) 317.05 185.82 T
0 F
( be resolved. If you want to search past) 331.68 185.82 T
(variant class links, you should sent) 180 174.32 T
0 9 Q
(MSG_MET) 345.77 174.32 T
(A_DUMMY) 391.94 174.32 T
0 10 Q
( to the object \336rst.) 440.6 174.32 T
(The two parameters for this routine are) 180 162.82 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "342" 42
%%Page: "343" 43
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
162 690.34 558 702 R
7 X
0 0 0 1 0 0 0 K
V
162 666.34 558 678.01 R
V
0 10 Q
0 X
(343) 541.32 671.34 T
324 684 580 684 2 L
7 X
V
3 H
2 Z
0 X
N
512 90 558 125 R
7 X
V
1 60 Q
0 X
(n) 512.17 85 T
315 104 510 126 R
7 X
V
2 24 Q
0 X
(Routines) 407.33 110 T
90 99 270 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
90.67 123.5 270.67 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
6 10 Q
0 X
(obj) 180 641.33 T
0 F
(The optr of the object to be checked.) 243 641.33 T
6 F
(class) 180 623.33 T
0 F
(A pointer to the subject class\325) 243 623.33 T
4 F
(ClassStruct) 381.16 623.33 T
0 F
( de\336nition.) 441.36 623.33 T
4 F
-0.45 (ObjIsObjectInClass\050\051) 180 605.33 P
0 F
-0.43 ( returns) 288.14 605.33 P
6 F
-0.43 (true) 327.45 605.33 P
0 F
-0.43 ( if the object is in the class,) 345.96 605.33 P
6 F
-0.43 (false) 470.29 605.33 P
0 F
-0.43 ( \050zero\051 if) 491.57 605.33 P
(it is not.) 180 593.83 T
2 F
(Include:) 99 575.33 T
0 F
(object.h) 180 575.33 T
81 558.99 531 564 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 558.99 531 564 R
7 X
0 0 0 1 0 0 0 K
V
50 562.99 609.01 562.99 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 550.99 T
2 F
(ObjIsObjectInClassHandles\050\051) 99 550.99 T
5 10 Q
(Boolean) 99 537.33 T
3 F
(ObjIsObjectInClassHandles\050) 153 537.33 T
3 9 Q
(MemHandle) 153 526.99 T
(mh,) 261 526.99 T
(/* handle portion of optr */) 333 526.99 T
(ChunkHandle) 153 516.99 T
(ch,) 261 516.99 T
(/* chunk portion of optr */) 333 516.99 T
(ClassStruct) 153 506.99 T
(* class\051;) 261 506.99 T
(/* proposed class */) 333 506.99 T
0 10 Q
-0.31 (This routine is just like) 180 489.33 P
4 F
-0.32 (ObjIsObjectInClass\050\051) 289.19 489.33 P
0 F
-0.31 ( except the object is speci\336ed) 397.33 489.33 P
(via its handles rather than its optr) 180 477.83 T
(.) 339.84 477.83 T
2 F
(Include:) 99 459.33 T
0 F
(object.h) 180 459.33 T
81 442.98 531 447.99 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 442.98 531 447.99 R
7 X
0 0 0 1 0 0 0 K
V
50 446.98 609.01 446.98 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 434.98 T
2 F
(ObjLinkFindParent\050\051) 99 434.98 T
5 10 Q
(optr) 99 420.32 T
3 F
(ObjLinkFindParent\050) 153 420.32 T
3 9 Q
(optr) 153 409.98 T
(obj,) 189 409.98 T
(/* child\325s optr */) 279 409.98 T
(word) 153 399.98 T
(masterOffset,) 189 399.98 T
(/* offset to master part with link field */) 279 399.98 T
(word) 153 389.98 T
(linkOffset\051;) 189 389.98 T
(/* offset in master part to link field */) 279 389.98 T
0 10 Q
(This routine returns the optr of the speci\336ed object\325) 180 372.32 T
(s parent. It must be) 416.85 372.32 T
(passed the following:) 180 360.82 T
6 F
(obj) 180 342.32 T
0 F
(The optr of the object whose parent is to be found.) 243 342.32 T
6 F
(masterOffset) 180 324.32 T
0 F
(The offset within the object\325) 243 313.32 T
(s instance chunk to its master) 370.79 313.32 T
(group\325) 243 302.32 T
(s offset \050the value that would appear in the) 271.33 302.32 T
6 F
(Class_masterOffset) 243 291.32 T
0 F
( \336eld in its) 331.48 291.32 T
4 F
(ClassStruct) 383.53 291.32 T
0 F
( structure\051.) 443.73 291.32 T
6 F
(linkOffset) 180 273.32 T
0 F
(The offset within the object\325) 243 273.32 T
(s instance chunk to the link \336eld.) 370.79 273.32 T
2 F
(Include:) 99 255.32 T
0 F
(metaC.goh) 180 255.32 T
2 F
(See Also:) 99 235.32 T
0 9 Q
(MSG_VIS_FIND_P) 180 235.32 T
(ARENT) 259.84 235.32 T
0 10 Q
(,) 291.75 235.32 T
0 9 Q
(MSG_GEN_FIND_P) 297.31 235.32 T
(ARENT) 382.15 235.32 T
81 218.98 531 223.98 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 218.98 531 223.98 R
7 X
0 0 0 1 0 0 0 K
V
50 222.98 609.01 222.98 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 210.97 T
2 F
(ObjLockObjBlock\050\051) 99 210.97 T
5 10 Q
(void) 99 196.31 T
3 F
(* ObjLockObjBlock\050) 153 196.31 T
3 9 Q
(MemHandle mh\051;) 153 185.97 T
(/* handle of object block */) 279 185.97 T
0 10 Q
(This routine locks an object block, loading in the block if necessary) 180 168.31 T
(. It must) 486.34 168.31 T
(be passed the handle of the block, and it returns the locked block\325) 180 156.81 T
(s segment) 481.16 156.81 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "343" 43
%%Page: "344" 44
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
54 690.34 450 702 R
7 X
0 0 0 1 0 0 0 K
V
54 666.34 450 678.01 R
V
0 10 Q
0 X
(344) 54 671.34 T
32 684 288 684 2 L
7 X
V
3 H
2 Z
0 X
N
54 90 108 125 R
7 X
V
1 60 Q
0 X
(n) 58.17 85 T
104 104 299 126 R
7 X
V
2 24 Q
0 X
(Routines) 104 110 T
306 99 486 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
306 123.5 486 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
0 10 Q
0 X
(address. When the caller is done using the block, it should unlock it with) 180 641.33 T
4 F
(MemUnlock\050\051) 180 629.83 T
0 F
(.) 250 629.83 T
2 F
(Be Sure T) 99 611.33 T
(o:) 144.94 611.33 T
0 F
(Always unlock the block when you are done with it, with) 180 611.33 T
4 F
(MemUnlock\050\051) 444.12 611.33 T
0 F
(.) 514.12 611.33 T
2 F
(Include:) 99 591.33 T
0 F
(object.h) 180 591.33 T
2 F
(See Also:) 99 571.33 T
0 F
(MemLock\050\051, MemUnlock\050\051) 180 571.33 T
81 554.99 531 560 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 554.99 531 560 R
7 X
0 0 0 1 0 0 0 K
V
50 558.99 609.01 558.99 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 546.99 T
2 F
(ObjMapSavedT) 99 546.99 T
(oState\050\051) 184.8 546.99 T
5 10 Q
(VMBlockHandle) 99 532.33 T
3 F
( ObjMapSavedToState\050) 177 532.33 T
3 9 Q
(MemHandle mh\051;) 153 521.99 T
(/* handle of object block */) 279 521.99 T
0 10 Q
-0.74 (This routine returns the) 180 504.33 P
0 9 Q
-0.66 (VM) 292.05 504.33 P
0 10 Q
-0.74 ( block handle of the state \336le block corresponding) 307.05 504.33 P
(to the passed object block. If the speci\336ed object block has no state \336le) 180 492.83 T
(equivalent, a null handle is returned.) 180 481.33 T
2 F
(Include:) 99 462.83 T
0 F
(object.h) 180 462.83 T
81 446.48 531 451.49 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 446.48 531 451.49 R
7 X
0 0 0 1 0 0 0 K
V
50 450.48 609.01 450.48 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 438.48 T
2 F
(ObjMapStateT) 99 438.48 T
(oSaved\050\051) 178.79 438.48 T
5 10 Q
(MemHandle) 99 423.82 T
3 F
( ObjMapStateToSaved\050) 153 423.82 T
3 9 Q
(VMBlockHandle) 153 413.48 T
(vmbh,) 261 413.48 T
(/* VM block handle of state block */) 315 413.48 T
(GeodeHandle) 153 403.48 T
(gh\051;) 261 403.48 T
(/* handle of geode owning block */) 315 403.48 T
0 10 Q
(This routine takes a) 180 385.82 T
0 9 Q
(VM) 275.95 385.82 T
0 10 Q
( block handle and a geode handle and returns the) 290.94 385.82 T
-0.23 (memory block corresponding to the) 180 374.32 P
0 9 Q
-0.2 (VM) 343.49 374.32 P
0 10 Q
-0.23 ( block, if any) 358.48 374.32 P
-0.23 (. The two parameters are) 415.41 374.32 P
6 F
(vmbh) 180 355.82 T
0 F
(The) 243 355.82 T
0 9 Q
(VM) 263.56 355.82 T
0 10 Q
( block handle of the) 278.55 355.82 T
0 9 Q
(VM) 371.53 355.82 T
0 10 Q
( block to be mapped.) 386.53 355.82 T
6 F
(gh) 180 337.82 T
0 F
(The geode handle of the owner of the block, or zero to use the) 243 337.82 T
(calling geode\325) 243 326.82 T
(s handle.) 304.49 326.82 T
(If the block is found,) 180 308.82 T
4 F
(ObjMapStateT) 277.23 308.82 T
(oSaved\050\051) 351.49 308.82 T
0 F
( returns its handle. If the) 396.68 308.82 T
(block is not found, it returns a null handle.) 180 297.32 T
2 F
(Include:) 99 278.82 T
0 F
(object.h) 180 278.82 T
81 262.48 531 267.48 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 262.48 531 267.48 R
7 X
0 0 0 1 0 0 0 K
V
50 266.48 609.01 266.48 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 254.47 T
2 F
(ObjMarkDirty\050\051) 99 254.47 T
5 10 Q
(void) 99 239.81 T
3 F
(ObjMarkDirty\050) 153 239.81 T
3 9 Q
(optr) 153 229.47 T
(o\051;) 189 229.47 T
(/* object to be marked dirty */) 261 229.47 T
0 10 Q
(This routine marks an object dirty) 180 211.81 T
(, indicating that changes to it should be) 337.61 211.81 T
-0.79 (saved when its object block is saved. If you want changes to objects saved, you) 180 200.31 P
(should mark the object dirty) 180 188.81 T
(.) 310.01 188.81 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "344" 44
%%Page: "345" 45
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
162 690.34 558 702 R
7 X
0 0 0 1 0 0 0 K
V
162 666.34 558 678.01 R
V
0 10 Q
0 X
(345) 541.32 671.34 T
324 684 580 684 2 L
7 X
V
3 H
2 Z
0 X
N
512 90 558 125 R
7 X
V
1 60 Q
0 X
(n) 512.17 85 T
315 104 510 126 R
7 X
V
2 24 Q
0 X
(Routines) 407.33 110 T
90 99 270 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
90.67 123.5 270.67 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
2 10 Q
0 X
(T) 99 641.33 T
(ips and T) 104.93 641.33 T
(ricks:) 148.28 641.33 T
0 F
(Often you do not need this routine because parameters or \337ags to other) 180 641.33 T
-0.81 (routines will set the object dirty automatically) 180 628.33 P
-0.81 (. If there is any doubt, however) 387.95 628.33 P
-0.81 (,) 526.25 628.33 P
(you should use this routine.) 180 615.33 T
2 F
(Include:) 99 595.33 T
0 F
(object.h) 180 595.33 T
2 F
(See Also:) 99 575.33 T
0 F
(ObjChunkFlags, ObjSetFlags\050\051) 180 575.33 T
81 558.99 531 564 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 558.99 531 564 R
7 X
0 0 0 1 0 0 0 K
V
50 562.99 609.01 562.99 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 550.99 T
2 F
(ObjMarkDirtyHandles\050\051) 99 550.99 T
5 10 Q
(void) 99 537.33 T
3 F
(ObjMarkDirtyHandles\050) 153 537.33 T
3 9 Q
(MemHandle) 153 526.99 T
(mh,) 261 526.99 T
(/* handle portion of optr */) 315 526.99 T
(ChunkHandle) 153 516.99 T
(ch\051;) 261 516.99 T
(/* chunk portion of optr */) 315 516.99 T
0 10 Q
(This routine is the same as) 180 499.33 T
4 F
(ObjMarkDirty\050\051) 307.99 499.33 T
0 F
( except that it speci\336es the) 389.47 499.33 T
(object via handles rather than an optr) 180 487.83 T
(.) 355.02 487.83 T
81 472.98 531 477.99 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 472.98 531 477.99 R
7 X
0 0 0 1 0 0 0 K
V
50 476.98 609.01 476.98 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 464.98 T
2 F
(ObjProcBroadcastMessage\050\051) 99 464.98 T
5 10 Q
(void) 99 450.32 T
3 F
(ObjProcBroadcastMessage\050) 153 450.32 T
3 9 Q
(EventHandle event\051;) 153 439.98 T
(/* the event to be broadcast */) 279 439.98 T
0 10 Q
(This routine broadcasts the given event to all threads which have message) 180 422.32 T
(queues. It must be passed an encapsulated event \050usually recorded with) 180 410.82 T
4 F
(@record) 180 399.32 T
0 F
(\051 and returns nothing. This is typically used for noti\336cation) 221.93 399.32 T
(purposes.) 180 387.82 T
2 F
(Include:) 99 369.32 T
0 F
(metaC.goh) 180 369.32 T
81 352.98 531 357.98 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 352.98 531 357.98 R
7 X
0 0 0 1 0 0 0 K
V
50 356.98 609.01 356.98 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 344.98 T
2 F
(ObjRelocateEntryPoint\050\051) 99 344.98 T
5 10 Q
(void *) 99 330.31 T
3 F
(ObjRelocateEntryPoint\050) 153 330.31 T
3 9 Q
(EntryPointRelocation *) 153 319.98 T
(relocData\051;) 279 319.98 T
81 305.97 531 310.98 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 305.97 531 310.98 R
7 X
0 0 0 1 0 0 0 K
V
50 309.97 609.01 309.97 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 297.97 T
2 F
(ObjRelocOrUnRelocSuper\050\051) 99 297.97 T
5 10 Q
(void) 99 283.3 T
3 F
(ObjRelocOrUnRelocSuper\050) 153 283.3 T
3 9 Q
(optr) 153 272.97 T
(oself,) 261 272.97 T
(ClassStruct) 153 262.97 T
(*class,) 261 262.97 T
(word) 153 252.97 T
(frame\051;) 261 252.97 T
0 10 Q
(Call this routine to relocate an object\325) 180 235.3 T
(s superclass.) 352.8 235.3 T
2 F
(Include:) 99 216.8 T
0 F
(object.h) 180 216.8 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "345" 45
%%Page: "346" 46
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
54 690.34 450 702 R
7 X
0 0 0 1 0 0 0 K
V
54 666.34 450 678.01 R
V
0 10 Q
0 X
(346) 54 671.34 T
32 684 288 684 2 L
7 X
V
3 H
2 Z
0 X
N
54 90 108 125 R
7 X
V
1 60 Q
0 X
(n) 58.17 85 T
104 104 299 126 R
7 X
V
2 24 Q
0 X
(Routines) 104 110 T
306 99 486 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
306 123.5 486 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
81 642.99 531 648 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 642.99 531 648 R
7 X
0 0 0 1 0 0 0 K
V
50 646.99 609.01 646.99 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 634.99 T
2 F
(ObjResizeMaster\050\051) 99 634.99 T
5 10 Q
(void) 99 620.33 T
3 F
(ObjResizeMaster\050) 153 620.33 T
3 9 Q
(optr) 153 609.99 T
(obj,) 189 609.99 T
(/* object to have its master part resized */) 279 609.99 T
(word) 153 599.99 T
(masterOffset,) 189 599.99 T
(/* master offset of proper master part */) 279 599.99 T
(word) 153 589.99 T
(newSize\051;) 189 589.99 T
(/* new size for the master part */) 279 589.99 T
0 10 Q
-0.75 (This routine resizes a master part of an object\325) 180 572.33 P
-0.75 (s instance chunk. It is typically) 388.27 572.33 P
(used to allocate space for a master part or to resize the master part to zero) 180 560.83 T
-0.51 (\050as when the V) 180 549.33 P
-0.51 (is part of a visible object is removed in) 247.1 549.33 P
0 9 Q
-0.46 (MSG_VIS_CLOSE) 422.13 549.33 P
0 10 Q
-0.51 (\051. This) 499.8 549.33 P
(routine must be passed the following three parameters:) 180 537.83 T
6 F
(obj) 180 519.33 T
0 F
(The optr of the object whose master part is to be resized.) 243 519.33 T
6 F
(masterOffset) 180 501.33 T
0 F
(The offset into the object\325) 243 490.33 T
(s instance chunk where the offset to) 358.75 490.33 T
(the master part is kept \050this is the same offset held in the) 243 479.33 T
(master class\325) 243 468.33 T
6 F
(Class_masterOffset) 305.42 468.33 T
0 F
( \336eld\051.) 393.9 468.33 T
6 F
(newSize) 180 450.33 T
0 F
(The new size of the master part. This can be found in the) 243 450.33 T
(master class\325) 243 439.33 T
6 F
(Class_instanceSize) 305.42 439.33 T
0 F
( \336eld.) 392.79 439.33 T
2 F
(W) 99 421.33 T
(arnings:) 108.07 421.33 T
0 F
(This routine may resize and/or move chunks or object blocks, thereby) 180 421.33 T
(invalidating stored segment addresses and pointers.) 180 408.33 T
2 F
(Include:) 99 388.33 T
0 F
(object.h) 180 388.33 T
2 F
(See Also:) 99 368.33 T
0 F
(ClassStruct, ObjInitializeMaster\050\051, ObjInitializePart\050\051) 180 368.33 T
81 351.98 531 356.99 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 351.98 531 356.99 R
7 X
0 0 0 1 0 0 0 K
V
50 355.98 609.01 355.98 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 343.98 T
2 F
(ObjResizeMasterHandles\050\051) 99 343.98 T
5 10 Q
(void) 99 330.32 T
3 F
(ObjResizeMasterHandles\050) 153 330.32 T
3 9 Q
(MemHandle) 153 319.98 T
(mh,) 261 319.98 T
(/* handle portion of optr */) 333 319.98 T
(ChunkHandle) 153 309.98 T
(ch,) 261 309.98 T
(/* chunk portion of optr */) 333 309.98 T
(word) 153 299.98 T
(masterOffset,) 261 299.98 T
(/* offset to master part */) 333 299.98 T
(word) 153 289.98 T
(newSize\051;) 261 289.98 T
(/* new size of master part */) 333 289.98 T
0 10 Q
(This routine is the same as) 180 272.32 T
4 F
(ObjResizeMaster\050\051) 307.99 272.32 T
0 F
( except that the object is) 403.91 272.32 T
(speci\336ed with its handles rather than its optr) 180 260.82 T
(.) 389.28 260.82 T
2 F
(Include:) 99 242.32 T
0 F
(object.h) 180 242.32 T
81 225.98 531 230.98 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 225.98 531 230.98 R
7 X
0 0 0 1 0 0 0 K
V
50 229.98 609.01 229.98 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 217.97 T
2 F
(ObjSaveBlock\050\051) 99 217.97 T
5 10 Q
(void) 99 203.31 T
3 F
(ObjSaveBlock\050) 153 203.31 T
3 9 Q
(MemHandle mh\051;) 153 192.97 T
(/*handle of block to be marked for saving */) 279 192.97 T
0 10 Q
-0.26 (This routine sets up an object or LMem block to be saved to its owner) 180 175.31 P
-0.26 (\325) 496.7 175.31 P
-0.26 (s state) 498.37 175.31 P
(\336le. The block\325) 180 163.81 T
(s handle must be passed in) 246.13 163.81 T
6 F
(mh) 373.75 163.81 T
0 F
(. The block must be an object) 388.75 163.81 T
(block.) 180 152.31 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "346" 46
%%Page: "347" 47
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
162 690.34 558 702 R
7 X
0 0 0 1 0 0 0 K
V
162 666.34 558 678.01 R
V
0 10 Q
0 X
(347) 541.32 671.34 T
324 684 580 684 2 L
7 X
V
3 H
2 Z
0 X
N
512 90 558 125 R
7 X
V
1 60 Q
0 X
(n) 512.17 85 T
315 104 510 126 R
7 X
V
2 24 Q
0 X
(Routines) 407.33 110 T
90 99 270 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
90.67 123.5 270.67 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
2 10 Q
0 X
(Include:) 99 641.33 T
0 F
(object.h) 180 641.33 T
2 F
(See Also:) 99 621.33 T
0 F
(ObjMapSavedT) 180 621.33 T
(oState\050\051, ObjMapStateT) 250.76 621.33 T
(oSaved\050\051) 360.05 621.33 T
81 604.99 531 610 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 604.99 531 610 R
7 X
0 0 0 1 0 0 0 K
V
50 608.99 609.01 608.99 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 596.99 T
2 F
(ObjSetEventInfo\050\051) 99 596.99 T
5 10 Q
(void) 99 582.33 T
3 F
(ObjSetEventInfo\050) 153 582.33 T
3 9 Q
(EventHandle) 153 571.99 T
(event,) 261 571.99 T
(/* handle of the event to be modified */) 315 571.99 T
(Message) 153 561.99 T
(msg,) 261 561.99 T
(/* the new message for the event */) 315 561.99 T
(optr) 153 551.99 T
(dest\051;) 261 551.99 T
(/* the new destination of the event */) 315 551.99 T
0 10 Q
-0.09 (This routine modi\336es an event, setting its information to the passed values.) 180 534.33 P
(The three parameters are) 180 522.83 T
6 F
(event) 180 504.33 T
0 F
(The event handle of the event to be modi\336ed.) 243 504.33 T
6 F
(msg) 180 486.33 T
0 F
-0.26 (The message to be sent in place of the current message. T) 243 486.33 P
-0.26 (o use) 505.21 486.33 P
(the same message, you must \336rst retrieve it with) 243 475.33 T
4 F
(ObjGetMessageInfo\050\051) 243 464.33 T
0 F
(.) 352.24 464.33 T
6 F
(dest) 180 446.33 T
0 F
-0.28 (The optr of the new destination object for the event. T) 243 446.33 P
-0.28 (o use the) 487.77 446.33 P
(same destination object, you must \336rst retrieve it with) 243 435.33 T
4 F
(ObjGetMessageInfo\050\051) 243 424.33 T
0 F
(.) 352.24 424.33 T
2 F
(Include:) 99 406.33 T
0 F
(object.h) 180 406.33 T
2 F
(See Also:) 99 386.33 T
0 F
(ObjGetEventInfo\050\051) 180 386.33 T
81 369.98 531 374.99 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 369.98 531 374.99 R
7 X
0 0 0 1 0 0 0 K
V
50 373.98 609.01 373.98 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 361.98 T
2 F
(ObjSetFlags\050\051) 99 361.98 T
5 10 Q
(void) 99 347.32 T
3 F
(ObjSetFlags\050) 153 347.32 T
3 9 Q
(optr) 153 336.98 T
(o,) 261 336.98 T
(/* object whose flags will be set */) 333 336.98 T
(ObjChunkFlags) 153 326.98 T
(bitsToSet,) 261 326.98 T
(/* flags to set */) 333 326.98 T
(ObjChunkFlags) 153 316.98 T
(bitsToClear\051;) 261 316.98 T
(/* flags to clear */) 333 316.98 T
0 10 Q
-0.65 (This routine sets the chunk \337ags for the speci\336ed object. Flags that should be) 180 299.32 P
(set are passed in) 180 287.82 T
6 F
(bitsT) 260.2 287.82 T
(oSet) 283.01 287.82 T
0 F
(, and \337ags that should be cleared are passed in) 302.64 287.82 T
6 F
(bitsT) 180 276.32 T
(oClear) 202.81 276.32 T
0 F
(. T) 232.24 276.32 T
(ypically) 243.95 276.32 T
(, applications will not use this routine but will rather) 278.77 276.32 T
(let the kernel maintain the object\325) 180 264.82 T
(s \337ags.) 336.51 264.82 T
2 F
(Include:) 99 246.32 T
0 F
(object.h) 180 246.32 T
2 F
(See Also:) 99 226.32 T
0 F
(ObjGetFlags\050\051, ObjChunkFlags) 180 226.32 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "347" 47
%%Page: "348" 48
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
54 690.34 450 702 R
7 X
0 0 0 1 0 0 0 K
V
54 666.34 450 678.01 R
V
0 10 Q
0 X
(348) 54 671.34 T
32 684 288 684 2 L
7 X
V
3 H
2 Z
0 X
N
54 90 108 125 R
7 X
V
1 60 Q
0 X
(n) 58.17 85 T
104 104 299 126 R
7 X
V
2 24 Q
0 X
(Routines) 104 110 T
306 99 486 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
306 123.5 486 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
81 642.99 531 648 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 642.99 531 648 R
7 X
0 0 0 1 0 0 0 K
V
50 646.99 609.01 646.99 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 634.99 T
2 F
(ObjSetFlagsHandles\050\051) 99 634.99 T
5 10 Q
(void) 99 621.33 T
3 F
(ObjSetFlagsHandles\050) 153 621.33 T
3 9 Q
(MemHandle) 153 610.99 T
(mh,) 261 610.99 T
(/* handle portion of optr */) 333 610.99 T
(ChunkHandle) 153 600.99 T
(ch,) 261 600.99 T
(/* chunk portion of optr */) 333 600.99 T
(ObjChunkFlags) 153 590.99 T
(bitsToSet,) 261 590.99 T
(/* flags to set */) 333 590.99 T
(ObjChunkFlags) 153 580.99 T
(bitsToClear\051;) 261 580.99 T
(/* flags to clear */) 333 580.99 T
0 10 Q
-0.43 (This routine is the same as) 180 563.33 P
4 F
-0.44 (ObjSetFlags\050\051) 305.44 563.33 P
0 F
-0.43 ( except that the object is speci\336ed) 376.18 563.33 P
(via its handles rather than its optr) 180 551.83 T
(.) 339.84 551.83 T
2 F
(Include:) 99 533.33 T
0 F
(object.h) 180 533.33 T
81 516.98 531 521.99 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 516.98 531 521.99 R
7 X
0 0 0 1 0 0 0 K
V
50 520.98 609.01 520.98 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 508.98 T
2 F
(ObjT) 99 508.98 T
(estIfObjBlockRunByCurThread\050\051) 125.45 508.98 T
5 10 Q
(Boolean) 99 494.32 T
3 F
(ObjTestIfObjBlockRunByCurThread\050) 153 494.32 T
3 9 Q
(MemHandle mh\051;) 153 483.98 T
(/* handle of object block */) 279 483.98 T
0 10 Q
-0.52 (This routine checks if the calling thread is running the speci\336ed object block.) 180 466.32 P
-0.74 (This routine can be used to determine if calls to objects in the block are across) 180 454.82 P
-0.1 (threads or internal to the calling thread. Pass this routine the handle of the) 180 443.32 P
-0.73 (object block to be checked\321if the object block is a) 180 431.82 P
0 9 Q
-0.65 (VM) 403.32 431.82 P
0 10 Q
-0.73 ( block, the thread for the) 418.31 431.82 P
0 9 Q
(VM) 180 420.32 T
0 10 Q
( \336le is checked rather than that for the block.) 194.99 420.32 T
-0.57 (If the block is run by the calling thread, the return value is) 180 401.82 P
6 F
-0.57 (true) 447.94 401.82 P
0 F
-0.57 (. If a different) 466.45 401.82 P
(thread runs the block, the return is) 180 390.32 T
6 F
(false) 346.12 390.32 T
0 F
( \050zero\051.) 367.4 390.32 T
2 F
(Include:) 99 371.82 T
0 F
(object.h) 180 371.82 T
81 355.48 531 360.48 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 355.48 531 360.48 R
7 X
0 0 0 1 0 0 0 K
V
50 359.48 609.01 359.48 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 347.48 T
2 F
(ObjUnrelocateEntryPoint\050\051) 99 347.48 T
5 10 Q
(void) 99 332.81 T
3 F
(ObjUnrelocateEntryPoint\050) 153 332.81 T
3 9 Q
(EntryPointRelocation *) 153 322.48 T
(relocData,) 279 322.48 T
(void *) 153 312.48 T
(entryPoint\051;) 279 312.48 T
81 298.47 531 303.48 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 298.47 531 303.48 R
7 X
0 0 0 1 0 0 0 K
V
50 302.47 609.01 302.47 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 290.47 T
2 F
(ObjV) 99 290.47 T
(arAddData\050\051) 126.35 290.47 T
5 10 Q
(void) 99 275.8 T
3 F
(* ObjVarAddData\050) 153 275.8 T
3 9 Q
(optr) 153 265.47 T
(obj,) 261 265.47 T
(/* object to add vardata to */) 333 265.47 T
(VardataKey) 153 255.47 T
(dataType,) 261 255.47 T
(/* vardata type */) 333 255.47 T
(word) 153 245.47 T
(dataSize\051;) 261 245.47 T
(/* vardata data size, if any */) 333 245.47 T
0 10 Q
-0.75 (This routine adds or alters a variable data entry for the speci\336ed object. If the) 180 227.8 P
(data type does not currently exist in the instance chunk, it will be allocated) 180 216.3 T
(and added to the chunk. If it does exist, the extra data of the entry will be) 180 204.8 T
(re-initialized to all zeroes.) 180 193.3 T
-0.42 (This routine returns a pointer to the extra data of the new or modi\336ed entry;) 180 174.8 P
-0.06 (if the entry has no extra data, an opaque pointer to the entry is passed, and) 180 163.3 P
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "348" 48
%%Page: "349" 49
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
162 690.34 558 702 R
7 X
0 0 0 1 0 0 0 K
V
162 666.34 558 678.01 R
V
0 10 Q
0 X
(349) 541.32 671.34 T
324 684 580 684 2 L
7 X
V
3 H
2 Z
0 X
N
512 90 558 125 R
7 X
V
1 60 Q
0 X
(n) 512.17 85 T
315 104 510 126 R
7 X
V
2 24 Q
0 X
(Routines) 407.33 110 T
90 99 270 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
90.67 123.5 270.67 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
0 10 Q
0 X
(you can use this pointer with) 180 641.33 T
4 F
(ObjV) 317.05 641.33 T
(arDeleteDataAt\050\051) 342.05 641.33 T
0 F
(. In either case, the) 431.12 641.33 T
(object will be marked dirty) 180 629.83 T
(.) 302.8 629.83 T
(The parameters of this routine are) 180 611.33 T
6 F
(obj) 180 592.83 T
0 F
(The optr of the object affected. This should be the caller) 243 592.83 T
(\325) 500.05 592.83 T
(s optr) 501.72 592.83 T
(.) 527.46 592.83 T
6 F
(dataT) 180 574.83 T
(ype) 207.07 574.83 T
0 F
(The) 243 574.83 T
4 F
(V) 263.56 574.83 T
(ardataKey) 270.23 574.83 T
0 F
( word declaring the data type and its \337ags.) 324.68 574.83 T
(The) 243 563.83 T
0 9 Q
(VDF_SA) 263.56 563.83 T
(VE_TO_ST) 298.73 563.83 T
(A) 344.91 563.83 T
(TE) 350.91 563.83 T
0 10 Q
( \337ag must be properly set; the) 363.42 563.83 T
0 9 Q
-0.16 (VDF_EXTRA_DA) 243 552.83 P
-0.16 (T) 316.34 552.83 P
-0.16 (A) 321.85 552.83 P
0 10 Q
-0.18 ( \337ag is ignored, however) 328.35 552.83 P
-0.18 (, as the routine will) 439.11 552.83 P
(set it properly) 243 541.83 T
(.) 306.89 541.83 T
6 F
(dataSize) 180 523.83 T
0 F
-0.32 (The size of the extra data for this type. If the type has no extra) 243 523.83 P
(data, pass zero.) 243 512.83 T
2 F
(Include:) 99 494.83 T
0 F
(object.h) 180 494.83 T
2 F
(W) 99 474.83 T
(arnings:) 108.07 474.83 T
0 F
-0.37 (This routine should be called only by the object whose vardata is affected. T) 180 474.83 P
-0.37 (o) 523.59 474.83 P
(operate on other objects\325 vardata remotely) 180 461.83 T
(, use messages provided by) 373.35 461.83 T
4 F
(MetaClass) 180 448.83 T
0 F
( \050see below under \322See Also\323\051.) 233.33 448.83 T
2 F
(See Also:) 99 428.83 T
0 9 Q
(MSG_MET) 180 428.83 T
(A_ADD_V) 226.17 428.83 T
(AR_DA) 267.67 428.83 T
(T) 298.17 428.83 T
(A) 303.68 428.83 T
0 10 Q
(, ObjV) 310.18 428.83 T
(arDeleteDataAt\050\051) 338.34 428.83 T
81 412.49 531 417.5 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 412.49 531 417.5 R
7 X
0 0 0 1 0 0 0 K
V
50 416.49 609.01 416.49 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 404.49 T
2 F
(ObjV) 99 404.49 T
(arAddDataHandles\050\051) 126.35 404.49 T
5 10 Q
(void) 99 390.83 T
3 F
(* ObjVarAddDataHandles\050) 153 390.83 T
3 9 Q
(MemHandle) 153 380.49 T
(mh,) 261 380.49 T
(/* handle portion of optr */) 333 380.49 T
(ChunkHandle) 153 370.49 T
(ch,) 261 370.49 T
(/* chunk portion of optr */) 333 370.49 T
(VardataKey) 153 360.49 T
(dataType,) 261 360.49 T
(/* vardata type */) 333 360.49 T
(word) 153 350.49 T
(dataSize\051;) 261 350.49 T
(/* vardata data size, if any */) 333 350.49 T
0 10 Q
(This routine is the same as) 180 332.83 T
4 F
(ObjV) 307.99 332.83 T
(arAddData\050\051) 332.99 332.83 T
0 F
( except that the object is) 397.81 332.83 T
(speci\336ed via its handles rather than its optr) 180 321.33 T
(.) 382.43 321.33 T
2 F
(Include:) 99 302.83 T
0 F
(object.h) 180 302.83 T
81 286.48 531 291.49 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 286.48 531 291.49 R
7 X
0 0 0 1 0 0 0 K
V
50 290.48 609.01 290.48 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 278.48 T
2 F
(ObjV) 99 278.48 T
(arCopyDataRange\050\051) 126.35 278.48 T
5 10 Q
(void) 99 263.82 T
3 F
(ObjVarCopyDataRange\050) 153 263.82 T
3 9 Q
(optr) 153 253.48 T
(source,) 189 253.48 T
(/* the optr of the source object */) 261 253.48 T
(optr) 153 243.48 T
(dest,) 189 243.48 T
(/* the optr of the destination \050calling\051 object */) 261 243.48 T
(word) 153 233.48 T
(rangeStart,) 189 233.48 T
(/* the smallest data type value to be copied */) 261 233.48 T
(word) 153 223.48 T
(rangeEnd\051;) 189 223.48 T
(/* the largest data type value to be copied */) 261 223.48 T
0 10 Q
-0.82 (This routine copies all the vardata entries within the speci\336ed range from the) 180 205.82 P
6 F
(source) 180 194.32 T
0 F
( object to the) 208.87 194.32 T
6 F
(dest) 270.73 194.32 T
0 F
( object. The range to be copied is speci\336ed by data) 289.24 194.32 T
-0.63 (types and is between) 180 182.82 P
6 F
-0.63 (rangeStart) 276.77 182.82 P
0 F
-0.63 ( and) 326.76 182.82 P
6 F
-0.63 (rangeEnd) 348.47 182.82 P
0 F
-0.63 (, inclusive. If any data entries) 394.01 182.82 P
(are copied, the destination object will be marked dirty) 180 171.32 T
(.) 428 171.32 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "349" 49
%%Page: "350" 50
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
54 690.34 450 702 R
7 X
0 0 0 1 0 0 0 K
V
54 666.34 450 678.01 R
V
0 10 Q
0 X
(350) 54 671.34 T
32 684 288 684 2 L
7 X
V
3 H
2 Z
0 X
N
54 90 108 125 R
7 X
V
1 60 Q
0 X
(n) 58.17 85 T
104 104 299 126 R
7 X
V
2 24 Q
0 X
(Routines) 104 110 T
306 99 486 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
306 123.5 486 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
2 10 Q
0 X
(W) 99 641.33 T
(arnings:) 108.07 641.33 T
0 F
-0.5 (This routine should be called only by the destination object; it is against) 180 641.33 P
0 9 Q
-0.45 (OOP) 508.71 641.33 P
0 10 Q
(doctrine for one object to alter another) 180 628.33 T
(\325) 357.77 628.33 T
(s instance data.) 359.44 628.33 T
2 F
(Include:) 99 608.33 T
0 F
(object.h) 180 608.33 T
81 591.99 531 597 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 591.99 531 597 R
7 X
0 0 0 1 0 0 0 K
V
50 595.99 609.01 595.99 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 583.99 T
2 F
(ObjV) 99 583.99 T
(arDeleteData\050\051) 126.35 583.99 T
5 10 Q
(Boolean) 99 569.33 T
3 F
(ObjVarDeleteData\050) 153 569.33 T
3 9 Q
(optr) 153 558.99 T
(obj,) 261 558.99 T
(/* object to delete from */) 333 558.99 T
(VardataKey) 153 548.99 T
(dataType\051;) 261 548.99 T
(/* data type to delete */) 333 548.99 T
0 10 Q
(This routine deletes a vardata entry from the speci\336ed object\325) 180 531.33 T
(s instance) 463.17 531.33 T
-0.33 (chunk, if the entry exists. The entry is speci\336ed by its data type; to delete an) 180 519.83 P
(entry speci\336ed by a pointer to it, use) 180 508.33 T
4 F
(ObjV) 351.13 508.33 T
(arDeleteDataAt\050\051) 376.13 508.33 T
0 F
(, below) 465.2 508.33 T
(. It) 496.33 508.33 T
(returns an error \337ag:) 180 496.83 T
6 F
(true) 280.55 496.83 T
0 F
( if the entry was not found,) 299.06 496.83 T
6 F
(false) 426.85 496.83 T
0 F
( if the entry was) 448.13 496.83 T
(successfully deleted. The object will also be marked dirty by the routine.) 180 485.33 T
(The parameters for this routine are) 180 466.83 T
6 F
(obj) 180 448.33 T
0 F
(The optr of the object affected. This should be the caller) 243 448.33 T
(\325) 500.05 448.33 T
(s optr) 501.72 448.33 T
(.) 527.46 448.33 T
6 F
(dataT) 180 430.33 T
(ype) 207.07 430.33 T
0 F
(The) 243 430.33 T
4 F
(V) 263.56 430.33 T
(ardataKey) 270.23 430.33 T
0 F
( word declaring the data type and its \337ags.) 324.68 430.33 T
-0.48 (Both the) 243 419.33 P
0 9 Q
-0.43 (VDF_SA) 284.83 419.33 P
-0.43 (VE_TO_ST) 320 419.33 P
-0.43 (A) 366.18 419.33 P
-0.43 (TE) 372.18 419.33 P
0 10 Q
-0.48 ( \337ag and the) 384.68 419.33 P
0 9 Q
-0.43 (VDF_EXTRA_DA) 443.35 419.33 P
-0.43 (T) 516.69 419.33 P
-0.43 (A) 522.2 419.33 P
0 10 Q
(\337ag are ignored.) 243 408.33 T
2 F
(W) 99 390.33 T
(arnings:) 108.07 390.33 T
0 F
-0.37 (This routine should be called only by the object whose vardata is affected. T) 180 390.33 P
-0.37 (o) 523.59 390.33 P
(operate on other objects\325 vardata remotely) 180 377.33 T
(, use messages provided by) 373.35 377.33 T
4 F
(MetaClass) 180 364.33 T
0 F
( \050see below under \322See Also\323\051.) 233.33 364.33 T
2 F
(Include:) 99 344.33 T
0 F
(object.h) 180 344.33 T
2 F
(See Also:) 99 324.33 T
0 9 Q
(MSG_MET) 180 324.33 T
(A_DELETE_V) 226.17 324.33 T
(AR_DA) 285.67 324.33 T
(T) 316.17 324.33 T
(A) 321.68 324.33 T
0 10 Q
(, ObjV) 328.18 324.33 T
(arDeleteDataAt\050\051) 356.34 324.33 T
81 307.98 531 312.99 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 307.98 531 312.99 R
7 X
0 0 0 1 0 0 0 K
V
50 311.98 609.01 311.98 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 299.98 T
2 F
(ObjV) 99 299.98 T
(arDeleteDataHandles\050\051) 126.35 299.98 T
5 10 Q
(Boolean) 99 286.32 T
3 F
(ObjVarDeleteDataHandles\050) 153 286.32 T
3 9 Q
(MemHandle) 153 275.98 T
(mh,) 261 275.98 T
(/* handle portion of optr */) 333 275.98 T
(ChunkHandle) 153 265.98 T
(ch,) 261 265.98 T
(/* chunk portion of optr */) 333 265.98 T
(VardataKey) 153 255.98 T
(dataType\051;) 261 255.98 T
(/* data type to delete */) 333 255.98 T
0 10 Q
(This routine is the same as) 180 238.32 T
4 F
(ObjV) 307.99 238.32 T
(arDeleteData\050\051) 332.99 238.32 T
0 F
( except that the object is) 410.21 238.32 T
(speci\336ed via its handles rather than its optr) 180 226.82 T
(.) 382.43 226.82 T
2 F
(Include:) 99 208.32 T
0 F
(object.h) 180 208.32 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "350" 50
%%Page: "351" 51
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
162 690.34 558 702 R
7 X
0 0 0 1 0 0 0 K
V
162 666.34 558 678.01 R
V
0 10 Q
0 X
(351) 541.32 671.34 T
324 684 580 684 2 L
7 X
V
3 H
2 Z
0 X
N
512 90 558 125 R
7 X
V
1 60 Q
0 X
(n) 512.17 85 T
315 104 510 126 R
7 X
V
2 24 Q
0 X
(Routines) 407.33 110 T
90 99 270 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
90.67 123.5 270.67 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
81 642.99 531 648 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 642.99 531 648 R
7 X
0 0 0 1 0 0 0 K
V
50 646.99 609.01 646.99 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 634.99 T
2 F
(ObjV) 99 634.99 T
(arDeleteDataAt\050\051) 126.35 634.99 T
5 10 Q
(void) 99 620.33 T
3 F
(ObjVarDeleteDataAt\050) 153 620.33 T
3 9 Q
(optr) 153 609.99 T
(obj,) 189 609.99 T
(/* object to delete from */) 297 609.99 T
(word) 153 599.99 T
(extraDataOffset\051;) 189 599.99 T
(/* offset to extra data to delete */) 297 599.99 T
0 10 Q
(This routine deletes the speci\336ed vardata entry from the given object\325) 180 582.33 T
(s) 500.39 582.33 T
(instance chunk. The vardata entry is speci\336ed by its pointer as returned by) 180 570.83 T
4 F
(ObjV) 180 559.33 T
(arAddData\050\051) 205 559.33 T
0 F
(,) 269.82 559.33 T
4 F
(ObjV) 275.38 559.33 T
(arFindData\050\051) 300.38 559.33 T
0 F
(, and) 368.71 559.33 T
4 F
(ObjV) 394.46 559.33 T
(arDerefData\050\051) 419.46 559.33 T
0 F
(. T) 492.24 559.33 T
(o) 503.55 559.33 T
(delete an entry speci\336ed by its data type, use) 180 547.83 T
4 F
(ObjV) 390.96 547.83 T
(arDeleteData\050\051) 415.96 547.83 T
0 F
(, above.) 493.18 547.83 T
2 F
(W) 99 529.33 T
(arnings:) 108.07 529.33 T
0 F
-0.37 (This routine should be called only by the object whose vardata is affected. T) 180 529.33 P
-0.37 (o) 523.59 529.33 P
(operate on other objects\325 vardata remotely) 180 516.33 T
(, use messages provided by) 373.35 516.33 T
4 F
(MetaClass) 180 503.33 T
0 F
( \050see below under \322See Also\323\051.) 233.33 503.33 T
2 F
(Include:) 99 483.33 T
0 F
(object.h) 180 483.33 T
2 F
(See Also:) 99 463.33 T
0 9 Q
(MSG_MET) 180 463.33 T
(A_DELETE_V) 226.17 463.33 T
(AR_DA) 285.67 463.33 T
(T) 316.17 463.33 T
(A) 321.68 463.33 T
0 10 Q
(, ObjV) 328.18 463.33 T
(arDeleteData\050\051) 356.34 463.33 T
81 446.98 531 451.99 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 446.98 531 451.99 R
7 X
0 0 0 1 0 0 0 K
V
50 450.98 609.01 450.98 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 438.98 T
2 F
(ObjV) 99 438.98 T
(arDeleteDataAtHandles\050\051) 126.35 438.98 T
5 10 Q
(void) 99 425.32 T
3 F
(ObjVarDeleteDataAtHandles\050) 153 425.32 T
3 9 Q
(MemHandle) 153 414.98 T
(mh,) 261 414.98 T
(/* handle portion of optr */) 315 414.98 T
(ChunkHandle) 153 404.98 T
(ch,) 261 404.98 T
(/* chunk portion of optr */) 315 404.98 T
(word) 153 394.98 T
(extraDataOffset\051;) 189 394.98 T
(/* offset to extra data to delete */) 315 394.98 T
0 10 Q
-0.52 (This routine is the same as) 180 377.32 P
4 F
-0.54 (ObjV) 304.86 377.32 P
-0.54 (arDeleteDataAt\050\051) 329.86 377.32 P
0 F
-0.52 ( except that the object is) 418.93 377.32 P
(speci\336ed via its handles rather than its optr) 180 365.82 T
(.) 382.43 365.82 T
2 F
(Include:) 99 347.32 T
0 F
(object.h) 180 347.32 T
81 330.98 531 335.98 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 330.98 531 335.98 R
7 X
0 0 0 1 0 0 0 K
V
50 334.98 609.01 334.98 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 322.98 T
2 F
(ObjV) 99 322.98 T
(arDeleteDataRange\050\051) 126.35 322.98 T
5 10 Q
(void) 99 308.31 T
3 F
(ObjVarDeleteDataRange\050) 153 308.31 T
3 9 Q
(optr) 153 297.98 T
(obj,) 261 297.98 T
(/* object to delete from */) 351 297.98 T
(word) 153 287.98 T
(rangeStart,) 261 287.98 T
(/* start of range */) 351 287.98 T
(word) 153 277.97 T
(rangeEnd,) 261 277.97 T
(/* end of range */) 351 277.97 T
(Boolean) 153 267.97 T
(useStateFlag\051;) 261 267.97 T
(/* save to state flag */) 351 267.97 T
0 10 Q
(This routine deletes all data entries within a given range for the passed) 180 250.31 T
(object. The range is speci\336ed by beginning and ending data types and is) 180 238.81 T
(inclusive. The four parameters to this routine are) 180 227.31 T
6 F
(obj) 180 208.81 T
0 F
(The optr of the object whose data entries are to be deleted.) 243 208.81 T
6 F
(rangeStart) 180 190.81 T
0 F
(The lowest number data type to be deleted. Both the) 243 190.81 T
0 9 Q
(VDF_SA) 243 179.81 T
(VE_TO_ST) 278.17 179.81 T
(A) 324.35 179.81 T
(TE) 330.35 179.81 T
0 10 Q
( \337ag and the) 342.86 179.81 T
0 9 Q
(VDF_EXTRA_DA) 403.42 179.81 T
(T) 476.77 179.81 T
(A) 482.27 179.81 T
0 10 Q
( \337ag are) 488.77 179.81 T
(ignored.) 243 168.81 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "351" 51
%%Page: "352" 52
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
54 690.34 450 702 R
7 X
0 0 0 1 0 0 0 K
V
54 666.34 450 678.01 R
V
0 10 Q
0 X
(352) 54 671.34 T
32 684 288 684 2 L
7 X
V
3 H
2 Z
0 X
N
54 90 108 125 R
7 X
V
1 60 Q
0 X
(n) 58.17 85 T
104 104 299 126 R
7 X
V
2 24 Q
0 X
(Routines) 104 110 T
306 99 486 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
306 123.5 486 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
6 10 Q
0 X
(rangeEnd) 180 641.33 T
0 F
(The highest number data type to be deleted. Both the) 243 641.33 T
0 9 Q
(VDF_SA) 243 630.33 T
(VE_TO_ST) 278.17 630.33 T
(A) 324.35 630.33 T
(TE) 330.35 630.33 T
0 10 Q
( \337ag and the) 342.86 630.33 T
0 9 Q
(VDF_EXTRA_DA) 403.42 630.33 T
(T) 476.77 630.33 T
(A) 482.27 630.33 T
0 10 Q
( \337ag are) 488.77 630.33 T
(ignored.) 243 619.33 T
6 F
(useStateFlag) 180 601.33 T
0 F
(A \337ag indicating whether entries with their) 243 590.33 T
0 9 Q
(VDF_SA) 243 579.33 T
(VE_TO_ST) 278.17 579.33 T
(A) 324.35 579.33 T
(TE) 330.35 579.33 T
0 10 Q
( \337ags should be deleted. Pass) 342.86 579.33 T
6 F
(true) 480.3 579.33 T
0 F
-0.49 (\050nonzero\051 to take the state \337ag into account; pass) 243 568.33 P
6 F
-0.49 (false) 468.05 568.33 P
0 F
-0.49 ( \050zero\051 to) 489.33 568.33 P
(delete all entries in the range.) 243 557.33 T
2 F
(W) 99 539.33 T
(arnings:) 108.07 539.33 T
0 F
-0.37 (This routine should be called only by the object whose vardata is affected. T) 180 539.33 P
-0.37 (o) 523.59 539.33 P
(operate on other objects\325 vardata remotely) 180 526.33 T
(, use messages provided by) 373.35 526.33 T
4 F
(MetaClass) 180 513.33 T
0 F
( \050see below under \322See Also\323\051.) 233.33 513.33 T
2 F
(Include:) 99 493.33 T
0 F
(object.h) 180 493.33 T
2 F
(See Also:) 99 473.33 T
0 F
(MSG_MET) 180 473.33 T
(A_DELETE_V) 231.3 473.33 T
(AR_DA) 297.41 473.33 T
(T) 331.3 473.33 T
(A) 337.42 473.33 T
81 456.99 531 462 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 456.99 531 462 R
7 X
0 0 0 1 0 0 0 K
V
50 460.99 609.01 460.99 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 448.99 T
2 F
(ObjV) 99 448.99 T
(arDeleteDataRangeHandles\050\051) 126.35 448.99 T
5 10 Q
(void) 99 435.33 T
3 F
(ObjVarDeleteDataRangeHandles\050) 153 435.33 T
3 9 Q
(MemHandle) 153 424.99 T
(mh,) 261 424.99 T
(/* handle portion of optr */) 351 424.99 T
(ChunkHandle) 153 414.99 T
(ch,) 261 414.99 T
(/* chunk portion of optr */) 351 414.99 T
(word) 153 404.99 T
(rangeStart,) 261 404.99 T
(/* start of range */) 351 404.99 T
(word) 153 394.99 T
(rangeEnd,) 261 394.99 T
(/* end of range */) 351 394.99 T
(Boolean) 153 384.99 T
(useStateFlag\051;) 261 384.99 T
(/* save to state flag */) 351 384.99 T
0 10 Q
(This routine is the same as) 180 367.33 T
4 F
(ObjV) 307.99 367.33 T
(arDeleteDataRange\050\051) 332.99 367.33 T
0 F
( except that the) 443.17 367.33 T
(object is speci\336ed via its handles rather than its optr) 180 355.83 T
(.) 422.62 355.83 T
2 F
(Include:) 99 337.33 T
0 F
(object.h) 180 337.33 T
81 320.98 531 325.99 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 320.98 531 325.99 R
7 X
0 0 0 1 0 0 0 K
V
50 324.98 609.01 324.98 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 312.98 T
2 F
(ObjV) 99 312.98 T
(arDerefData\050\051) 126.35 312.98 T
5 10 Q
(void) 99 299.32 T
3 F
(* ObjVarDerefData\050) 153 299.32 T
3 9 Q
(optr) 153 288.98 T
(obj,) 261 288.98 T
(/* object having data type */) 333 288.98 T
(VardataKey) 153 278.98 T
(dataType\051;) 261 278.98 T
(/* data type to dereference */) 333 278.98 T
0 10 Q
-0.85 (This routine is exactly like) 180 261.32 P
4 F
-0.88 (ObjV) 301.71 261.32 P
-0.88 (arFindData\050\051) 326.71 261.32 P
0 F
-0.85 (, below) 395.04 261.32 P
-0.85 (, except that it does not) 425.33 261.32 P
(return a null pointer if the data type is not found. Do not use this routine) 180 249.82 T
(unless you are absolutely sure the data type is in the object; otherwise,) 180 238.32 T
(results are unpredictable.) 180 226.82 T
2 F
(Include:) 99 208.32 T
4 F
(object.h) 180 208.32 T
2 F
(See Also:) 99 188.32 T
0 F
(ObjV) 180 188.32 T
(arFindData\050\051) 202.6 188.32 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "352" 52
%%Page: "353" 53
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
162 690.34 558 702 R
7 X
0 0 0 1 0 0 0 K
V
162 666.34 558 678.01 R
V
0 10 Q
0 X
(353) 541.32 671.34 T
324 684 580 684 2 L
7 X
V
3 H
2 Z
0 X
N
512 90 558 125 R
7 X
V
1 60 Q
0 X
(n) 512.17 85 T
315 104 510 126 R
7 X
V
2 24 Q
0 X
(Routines) 407.33 110 T
90 99 270 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
90.67 123.5 270.67 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
81 642.99 531 648 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 642.99 531 648 R
7 X
0 0 0 1 0 0 0 K
V
50 646.99 609.01 646.99 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 634.99 T
2 F
(ObjV) 99 634.99 T
(arDerefDataHandles\050\051) 126.35 634.99 T
5 10 Q
(void) 99 621.33 T
3 F
(* ObjVarDerefDataHandles\050) 153 621.33 T
3 9 Q
(MemHandle) 153 610.99 T
(mh,) 261 610.99 T
(/* handle portion of optr */) 333 610.99 T
(ChunkHandle) 153 600.99 T
(ch,) 261 600.99 T
(/* chunk portion of optr */) 333 600.99 T
(VardataKey) 153 590.99 T
(dataType\051;) 261 590.99 T
(/* data type to dereference */) 333 590.99 T
0 10 Q
(This routine is the same as) 180 573.33 T
4 F
(ObjV) 307.99 573.33 T
(arDerefData\050\051) 332.99 573.33 T
0 F
( except that the object is) 405.77 573.33 T
(speci\336ed via its handles rather than its optr) 180 561.83 T
(.) 382.43 561.83 T
2 F
(Include:) 99 543.33 T
4 F
(object.h) 180 543.33 T
81 526.98 531 531.99 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 526.98 531 531.99 R
7 X
0 0 0 1 0 0 0 K
V
50 530.98 609.01 530.98 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 518.98 T
2 F
(ObjV) 99 518.98 T
(arFindData\050\051) 126.35 518.98 T
5 10 Q
(void) 99 504.32 T
3 F
(* ObjVarFindData\050) 153 504.32 T
3 9 Q
(optr) 153 493.98 T
(obj,) 261 493.98 T
(/* object to be checked */) 333 493.98 T
(VardataKey) 153 483.98 T
(dataType\051;) 261 483.98 T
(/* data type to find */) 333 483.98 T
0 10 Q
(This routine searches an object\325) 180 466.32 T
(s variable data for a given data type. If the) 325.38 466.32 T
-0.74 (type is found,) 180 454.82 P
4 F
-0.76 (ObjV) 242.98 454.82 P
-0.76 (arFindData\050\051) 267.98 454.82 P
0 F
-0.74 ( returns a pointer to the entry\325) 336.31 454.82 P
-0.74 (s extra data;) 472.45 454.82 P
(if the entry has no extra data, an opaque pointer is returned which may be) 180 443.32 T
(used with) 180 431.82 T
4 F
(ObjV) 227.97 431.82 T
(arDeleteDataAt\050\051) 252.97 431.82 T
0 F
(. If the entry is not found, a null pointer) 342.04 431.82 T
(is returned. The pointer returned by this routine must be used before any) 180 420.32 T
(subsequent operations on the object\325) 180 408.82 T
(s block; the pointer may be invalidated) 346.87 408.82 T
(by other LMem or object operations.) 180 397.32 T
(The two parameters of this routine are) 180 378.82 T
6 F
(obj) 180 360.32 T
0 F
(The optr of the object affected. This should be the caller) 243 360.32 T
(\325) 500.05 360.32 T
(s optr) 501.72 360.32 T
(.) 527.46 360.32 T
6 F
(dataT) 180 342.32 T
(ype) 207.07 342.32 T
0 F
(The) 243 342.32 T
4 F
(V) 263.56 342.32 T
(ardataKey) 270.23 342.32 T
0 F
( word declaring the data type and its \337ags.) 324.68 342.32 T
-0.48 (Both the) 243 331.32 P
0 9 Q
-0.43 (VDF_SA) 284.83 331.32 P
-0.43 (VE_TO_ST) 320 331.32 P
-0.43 (A) 366.18 331.32 P
-0.43 (TE) 372.18 331.32 P
0 10 Q
-0.48 ( \337ag and the) 384.68 331.32 P
0 9 Q
-0.43 (VDF_EXTRA_DA) 443.35 331.32 P
-0.43 (T) 516.69 331.32 P
-0.43 (A) 522.2 331.32 P
0 10 Q
(\337ag are ignored.) 243 320.32 T
2 F
(W) 99 302.32 T
(arnings:) 108.07 302.32 T
0 F
-0.37 (This routine should be called only by the object whose vardata is affected. T) 180 302.32 P
-0.37 (o) 523.59 302.32 P
(operate on other objects\325 vardata remotely) 180 289.32 T
(, use messages provided by) 373.35 289.32 T
4 F
(MetaClass) 180 276.32 T
0 F
( \050see below under \322See Also\323\051.) 233.33 276.32 T
2 F
(Include:) 99 256.32 T
4 F
(object.h) 180 256.32 T
2 F
(See Also:) 99 236.98 T
0 9 Q
(MSG_MET) 180 236.98 T
(A_FIND_V) 226.17 236.98 T
(AR_DA) 271.17 236.98 T
(T) 301.67 236.98 T
(A) 307.18 236.98 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "353" 53
%%Page: "354" 54
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
54 690.34 450 702 R
7 X
0 0 0 1 0 0 0 K
V
54 666.34 450 678.01 R
V
0 10 Q
0 X
(354) 54 671.34 T
32 684 288 684 2 L
7 X
V
3 H
2 Z
0 X
N
54 90 108 125 R
7 X
V
1 60 Q
0 X
(n) 58.17 85 T
104 104 299 126 R
7 X
V
2 24 Q
0 X
(Routines) 104 110 T
306 99 486 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
306 123.5 486 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
81 642.99 531 648 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 642.99 531 648 R
7 X
0 0 0 1 0 0 0 K
V
50 646.99 609.01 646.99 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 634.99 T
2 F
(ObjV) 99 634.99 T
(arFindDataHandles\050\051) 126.35 634.99 T
5 10 Q
(void) 99 621.33 T
3 F
(* ObjVarFindDataHandles\050) 153 621.33 T
3 9 Q
(MemHandle) 153 610.99 T
(mh,) 261 610.99 T
(/* handle portion of optr */) 333 610.99 T
(ChunkHandle) 153 600.99 T
(ch,) 261 600.99 T
(/* chunk portion of optr */) 333 600.99 T
(VardataKey) 153 590.99 T
(dataType\051;) 261 590.99 T
(/* data type to find */) 333 590.99 T
0 10 Q
(This routine is the same as) 180 573.33 T
4 F
(ObjV) 307.99 573.33 T
(arFindData\050\051) 332.99 573.33 T
0 F
( except that the object is) 401.32 573.33 T
(speci\336ed via its handles rather than its optr) 180 561.83 T
(.) 382.43 561.83 T
2 F
(Include:) 99 543.33 T
4 F
(object.h) 180 543.33 T
81 526.98 531 531.99 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 526.98 531 531.99 R
7 X
0 0 0 1 0 0 0 K
V
50 530.98 609.01 530.98 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 518.98 T
2 F
(ObjV) 99 518.98 T
(arScanData\050\051) 126.35 518.98 T
5 10 Q
(void) 99 504.32 T
3 F
(ObjVarScanData\050) 153 504.32 T
3 9 Q
(optr) 153 493.98 T
(obj,) 261 493.98 T
(/* object to be scanned */) 351 493.98 T
(word) 153 483.98 T
(numHandlers,) 261 483.98 T
(/* number of handlers in table */) 351 483.98 T
(VarDataCHandler) 153 473.98 T
(* handlerTable,) 261 473.98 T
(/* pointer to handler table */) 351 473.98 T
(void) 153 463.98 T
(* handlerData\051;) 261 463.98 T
(/* pointer to handler data */) 351 463.98 T
0 10 Q
(This routine scans an object\325) 180 446.32 T
(s vardata and calls all the vardata handlers) 310.94 446.32 T
(speci\336ed in the passed handler table. Pass it the following parameters:) 180 434.82 T
6 F
(obj) 180 416.32 T
0 F
(The optr of the object whose variable data table is to be) 243 416.32 T
(scanned.) 243 405.32 T
6 F
(numHandlers) 180 387.32 T
0 F
(The number of handlers speci\336ed in the passed handler table.) 243 376.32 T
6 F
(handlerT) 180 358.32 T
(able) 222.39 358.32 T
0 F
(A pointer to a list of) 243 347.32 T
4 F
(V) 337.83 347.32 T
(arDataCHandler) 344.5 347.32 T
0 F
( structures. Each of) 431.17 347.32 T
-0.12 (these structures contains a vardata data type and a pointer to) 243 336.32 P
(the routine that is to handle it. All the handler routines must) 243 325.32 T
(be in the same segment as the handler table.) 243 314.32 T
6 F
(handlerData) 180 296.32 T
0 F
-0.53 (A pointer to a buffer that is passed on to the handlers. This can) 243 285.32 P
-0.85 (contain any information of speci\336c interest to the application or) 243 274.32 P
(handlers.) 243 263.32 T
2 F
(V) 99 245.32 T
(ardata Handler Format:) 105.12 245.32 T
0 F
(A vardata handler routine must have the following format:) 180 234.32 T
3 9 Q
(void _pascal \050MemHandle mh, ChunkHandle chnk,) 216 219.98 T
(VarDataEntry *extraData, word dataType,) 252 209.98 T
(void *handlerData\051) 252 199.98 T
0 10 Q
-0.05 (The handler should not free the object chunk or destroy the object; it can do) 180 182.32 P
-0.75 (anything else it pleases. The handler returns nothing and takes the following) 180 170.82 P
(parameters:) 180 159.32 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "354" 54
%%Page: "355" 55
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
162 690.34 558 702 R
7 X
0 0 0 1 0 0 0 K
V
162 666.34 558 678.01 R
V
0 10 Q
0 X
(355) 541.32 671.34 T
324 684 580 684 2 L
7 X
V
3 H
2 Z
0 X
N
512 90 558 125 R
7 X
V
1 60 Q
0 X
(n) 512.17 85 T
315 104 510 126 R
7 X
V
2 24 Q
0 X
(Routines) 407.33 110 T
90 99 270 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
90.67 123.5 270.67 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
6 10 Q
0 X
(mh:chnk) 180 641.33 T
0 F
(The memory handle and chunk handle of the object being) 243 641.33 T
(referenced. T) 243 630.33 T
(ogether) 302.81 630.33 T
(, these comprise the optr of the object.) 336.88 630.33 T
6 F
(extraData) 180 612.33 T
0 F
(A pointer to the data type\325) 243 612.33 T
(s extra data, if it has any) 363.76 612.33 T
(. This) 478.61 612.33 T
(pointer may be parsed with the macros) 243 601.33 T
4 F
(V) 426.17 601.33 T
(arDataT) 432.84 601.33 T
(ypePtr\050\051) 475.65 601.33 T
0 F
(,) 518.99 601.33 T
4 F
(V) 243 590.33 T
(arDataFlagsPtr\050\051) 249.67 590.33 T
0 F
(, and) 338.56 590.33 T
4 F
(V) 364.31 590.33 T
(arDataSizePtr\050\051) 370.98 590.33 T
0 F
(.) 453.39 590.33 T
6 F
(dataT) 180 572.33 T
(ype) 207.07 572.33 T
0 F
-0.3 (The data type of the data entry being handled. This is a record) 243 572.33 P
(of type) 243 561.33 T
4 F
(V) 276.89 561.33 T
(ardataKey) 283.56 561.33 T
0 F
(.) 336.9 561.33 T
6 F
(handlerData) 180 543.33 T
0 F
(A pointer to a buffer passed through by) 243 532.33 T
4 F
(ObjV) 427.27 532.33 T
(arScanData\050\051) 452.27 532.33 T
0 F
(.) 521.35 532.33 T
(This buffer may be used for passing additional data to the) 243 521.33 T
(handlers.) 243 510.33 T
2 F
(Structures:) 99 492.33 T
0 F
(The) 180 492.33 T
4 F
(V) 200.56 492.33 T
(arDataCHandler) 207.23 492.33 T
0 F
( structure contains two elements:) 293.9 492.33 T
3 9 Q
(typedef struct {) 216 478 T
(word) 237.6 468 T
(VDCH_dataType;) 288 468 T
(void) 237.6 458 T
(_pascal) 259.2 458 T
(\050*VDCH_handler\051 \050) 302.4 458 T
(MemHandle) 324 448 T
(mh,) 396 448 T
(ChunkHandle) 324 438 T
(chnk,) 396 438 T
(VarDataEntry) 324 428 T
(* extraData,) 396 428 T
(word) 324 418 T
(dataType) 396 418 T
(void) 324 408 T
(* handlerData\051;) 396 408 T
(} VarDataCHandler;) 216 398 T
0 10 Q
-0.17 (The \336rst element is the data type, a record containing the data type and the) 180 380.33 P
-0.05 (vardata \337ags. The second element is a far pointer to the handler routine for) 180 368.83 P
(the type.) 180 357.33 T
2 F
(Include:) 99 338.83 T
4 F
(object.h) 180 338.83 T
81 322.49 531 327.5 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 322.49 531 327.5 R
7 X
0 0 0 1 0 0 0 K
V
50 326.49 609.01 326.49 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 314.49 T
2 F
(ObjV) 99 314.49 T
(arScanDataHandles\050\051) 126.35 314.49 T
5 10 Q
(void) 99 300.83 T
3 F
(ObjVarScanDataHandles\050) 153 300.83 T
3 9 Q
(MemHandle) 153 290.49 T
(mh,) 261 290.49 T
(/* handle portion of optr */) 333 290.49 T
(ChunkHandle) 153 280.49 T
(ch,) 261 280.49 T
(/* chunk portion of optr */) 333 280.49 T
(word) 153 270.49 T
(numHandlers,) 261 270.49 T
(/* number of handlers in table */) 351 270.49 T
(VarDataCHandler) 153 260.49 T
(* handlerTable,) 261 260.49 T
(/* pointer to handler table */) 351 260.49 T
(void) 153 250.49 T
(* handlerData\051;) 261 250.49 T
(/* pointer to handler data */) 351 250.49 T
0 10 Q
(This routine is the same as) 180 232.83 T
4 F
(ObjV) 307.99 232.83 T
(arScanData\050\051) 332.99 232.83 T
0 F
( except that the object is) 402.07 232.83 T
(speci\336ed via its handles rather than its optr) 180 221.33 T
(.) 382.43 221.33 T
2 F
(Include:) 99 202.83 T
4 F
(object.h) 180 202.83 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "355" 55
%%Page: "356" 56
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
54 690.34 450 702 R
7 X
0 0 0 1 0 0 0 K
V
54 666.34 450 678.01 R
V
0 10 Q
0 X
(356) 54 671.34 T
32 684 288 684 2 L
7 X
V
3 H
2 Z
0 X
N
54 90 108 125 R
7 X
V
1 60 Q
0 X
(n) 58.17 85 T
104 104 299 126 R
7 X
V
2 24 Q
0 X
(Routines) 104 110 T
306 99 486 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
306 123.5 486 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
81 642.99 531 648 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 642.99 531 648 R
7 X
0 0 0 1 0 0 0 K
V
50 646.99 609.01 646.99 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 634.99 T
2 F
(offsetof\050\051) 99 634.99 T
5 10 Q
(word) 99 621.33 T
3 F
(offsetof\050) 153 621.33 T
7 F
(struc) 207 621.33 T
3 F
(,) 237 621.33 T
7 F
(field) 249 621.33 T
3 F
(\051;) 279 621.33 T
0 F
(This macro returns the offset of the speci\336ed \336eld within the speci\336ed) 180 603.33 T
(structure.) 180 591.83 T
81 576.98 531 581.99 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 576.98 531 581.99 R
7 X
0 0 0 1 0 0 0 K
V
50 580.98 609.01 580.98 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 568.98 T
2 F
(OptrT) 99 568.98 T
(oChunk\050\051) 130.78 568.98 T
5 10 Q
(ChunkHandle) 99 554.32 T
3 F
( OptrToChunk\050) 165 554.32 T
7 F
(op) 243 554.32 T
3 F
(\051;) 255 554.32 T
3 9 Q
(optr) 153 543.98 T
7 F
(op) 189 543.98 T
3 F
(;) 199.8 543.98 T
0 10 Q
(This macro extracts the chunk handle portion of the given optr) 180 526.32 T
(.) 469.27 526.32 T
2 F
(See Also:) 99 507.82 T
0 F
(ConstructOptr\050\051, OptrT) 180 507.82 T
(oHandle\050\051) 287.4 507.82 T
81 491.48 531 496.48 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 491.48 531 496.48 R
7 X
0 0 0 1 0 0 0 K
V
50 495.48 609.01 495.48 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 483.48 T
2 F
(OptrT) 99 483.48 T
(oHandle\050\051) 130.78 483.48 T
5 10 Q
(MemHandle) 99 468.81 T
3 F
( OptrToHandle\050) 153 468.81 T
7 F
(op) 237 468.81 T
3 F
(\051;) 249 468.81 T
3 9 Q
(optr) 153 458.48 T
7 F
(op) 189 458.48 T
3 F
(;) 199.8 458.48 T
0 10 Q
(This macro extracts the MemHandle portion of the given optr) 180 440.81 T
(.) 463.34 440.81 T
2 F
(See Also:) 99 422.31 T
0 F
(ConstructOptr\050\051, OptrT) 180 422.31 T
(oChunk\050\051) 287.4 422.31 T
81 405.97 531 410.98 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 405.97 531 410.98 R
7 X
0 0 0 1 0 0 0 K
V
50 409.97 609.01 409.97 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 397.97 T
2 F
(ParallelClose\050\051) 99 397.97 T
5 10 Q
(StreamError) 99 383.3 T
3 F
( ParallelClose\050) 165 383.3 T
3 9 Q
(GeodeHandle) 153 372.97 T
(driver,) 261 372.97 T
(ParallelUnit) 153 362.97 T
(unit,) 261 362.97 T
(Boolean) 153 352.97 T
(linger\051;) 261 352.97 T
0 10 Q
(Close the stream to a parallel port.) 180 335.3 T
2 F
(Include:) 99 316.8 T
4 F
(streamC.h) 180 316.8 T
81 300.46 531 305.47 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 300.46 531 305.47 R
7 X
0 0 0 1 0 0 0 K
V
50 304.46 609.01 304.46 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 292.46 T
2 F
(ParallelOpen\050\051) 99 292.46 T
5 10 Q
(StreamError) 99 277.79 T
3 F
( ParallelOpen\050) 165 277.79 T
3 9 Q
(GeodeHandle) 153 267.46 T
(driver,) 261 267.46 T
(ParallelUnit) 153 257.46 T
(unit,) 261 257.46 T
(StreamOpenFlags) 153 247.46 T
(flags,) 261 247.46 T
(word) 153 237.46 T
(outBuffSize,) 261 237.46 T
(word) 153 227.46 T
(timeout\051;) 261 227.46 T
0 10 Q
(This routine opens a stream to the speci\336ed parallel port. It is passed the) 180 209.79 T
(following arguments:) 180 198.29 T
6 F
(driver) 180 179.79 T
0 F
(The) 243 179.79 T
4 F
(GeodeT) 263.56 179.79 T
(oken) 302.45 179.79 T
0 F
( of the parallel driver) 327.82 179.79 T
(.) 425.42 179.79 T
6 F
(unit) 180 161.79 T
0 F
(The parallel port to open.) 243 161.79 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "356" 56
%%Page: "357" 57
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
162 690.34 558 702 R
7 X
0 0 0 1 0 0 0 K
V
162 666.34 558 678.01 R
V
0 10 Q
0 X
(357) 541.32 671.34 T
324 684 580 684 2 L
7 X
V
3 H
2 Z
0 X
N
512 90 558 125 R
7 X
V
1 60 Q
0 X
(n) 512.17 85 T
315 104 510 126 R
7 X
V
2 24 Q
0 X
(Routines) 407.33 110 T
90 99 270 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
90.67 123.5 270.67 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
6 10 Q
0 X
(\337ags) 180 641.33 T
0 F
-0.31 (This speci\336es whether the call should fail if the port is busy) 243 641.33 P
-0.31 (, or) 513.85 641.33 P
(wait for a time to see if it will become free.) 243 630.33 T
6 F
(outBuffSize) 180 612.33 T
0 F
(The size of the stream buffer used for output to the parallel) 243 612.33 T
(port.) 243 601.33 T
6 F
(timeout) 180 583.33 T
0 F
(The number of clock ticks to wait for the port to become free.) 243 583.33 T
(\050This argument is ignored if) 243 572.33 T
6 F
(\337ags) 375.23 572.33 T
0 F
( is not) 396.89 572.33 T
0 9 Q
(STREAM_OPEN_TIMEOUT) 243 561.33 T
0 10 Q
(.\051) 362.58 561.33 T
(If the routine is successful, it returns zero. If it is unsuccessful, it returns a) 180 543.33 T
(member of the) 180 531.83 T
4 F
(StreamError) 249.45 531.83 T
0 F
( enumerated type.) 316.32 531.83 T
2 F
(Include:) 99 513.33 T
4 F
(streamC.h) 180 513.33 T
81 496.99 531 502 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 496.99 531 502 R
7 X
0 0 0 1 0 0 0 K
V
50 500.99 609.01 500.99 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 488.99 T
2 F
(ParallelW) 99 488.99 T
(rite\050\051) 152.81 488.99 T
5 10 Q
(StreamError) 99 474.33 T
3 F
( ParallelWrite\050) 165 474.33 T
3 9 Q
(GeodeHandle) 153 463.99 T
(driver,) 261 463.99 T
(ParallelUnit) 153 453.99 T
(unit,) 261 453.99 T
(StreamBlocker) 153 443.99 T
(blocker,) 261 443.99 T
(word) 153 433.99 T
(buffSize,) 261 433.99 T
(const byte *) 153 423.99 T
(buffer,) 261 423.99 T
(word *) 153 413.99 T
(numBytesWritten\051;) 261 413.99 T
0 10 Q
(W) 180 396.33 T
(rite data to a parallel port.) 189.26 396.33 T
2 F
(Include:) 99 377.83 T
4 F
(streamC.h) 180 377.83 T
81 361.48 531 366.49 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 361.48 531 366.49 R
7 X
0 0 0 1 0 0 0 K
V
50 365.48 609.01 365.48 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 353.48 T
2 F
(ParallelW) 99 353.48 T
(riteByte\050\051) 152.81 353.48 T
5 10 Q
(StreamError) 99 338.82 T
3 F
( ParallelWrite\050) 165 338.82 T
3 9 Q
(GeodeHandle) 153 328.48 T
(driver,) 261 328.48 T
(ParallelUnit) 153 318.48 T
(unit,) 261 318.48 T
(StreamBlocker) 153 308.48 T
(blocker,) 261 308.48 T
(word) 153 298.48 T
(buffSize,) 261 298.48 T
(byte) 153 288.48 T
(dataByte\051;) 261 288.48 T
0 10 Q
(W) 180 270.82 T
(rite one byte of data to a parallel port.) 189.26 270.82 T
2 F
(Include:) 99 252.32 T
4 F
(streamC.h) 180 252.32 T
81 235.98 531 240.98 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 235.98 531 240.98 R
7 X
0 0 0 1 0 0 0 K
V
50 239.98 609.01 239.98 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 227.97 T
2 F
(PCB\050\051) 99 227.97 T
3 10 Q
(#define PCB\050return_type, pointer_name, args\051 \134) 99 213.31 T
3 9 Q
(return_type _pascal \050*pointer_name\051 args) 153 202.97 T
0 10 Q
(This macro is useful for declaring pointers to functions that use the pascal) 180 185.31 T
-0.03 (calling conventions. For example, to declare a pointer to a function which is) 180 173.81 P
(passed two strings and returns an integer) 180 162.31 T
(, one could write) 372.79 162.31 T
3 9 Q
(PCB\050int, func_ptr, \050const char *, const char *\051\051;) 216 147.47 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "357" 57
%%Page: "358" 58
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
54 690.34 450 702 R
7 X
0 0 0 1 0 0 0 K
V
54 666.34 450 678.01 R
V
0 10 Q
0 X
(358) 54 671.34 T
32 684 288 684 2 L
7 X
V
3 H
2 Z
0 X
N
54 90 108 125 R
7 X
V
1 60 Q
0 X
(n) 58.17 85 T
104 104 299 126 R
7 X
V
2 24 Q
0 X
(Routines) 104 110 T
306 99 486 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
306 123.5 486 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
0 10 Q
0 X
(which would be expanded to) 180 641.33 T
3 9 Q
(int _pascal \050*func_ptr\051 \050const char *, const char *\051;) 216 626.5 T
2 10 Q
(See Also:) 99 608.83 T
0 F
(CCB\050\051) 180 608.83 T
81 592.49 531 597.5 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 592.49 531 597.5 R
7 X
0 0 0 1 0 0 0 K
V
50 596.49 609.01 596.49 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 584.49 T
2 F
(PCCOMABORT\050\051) 99 584.49 T
5 10 Q
(void) 99 569.83 T
3 F
( PCCOMABORT\050void\051;) 123 569.83 T
0 F
(This routine aborts the current \336le transfer operation being carried out by) 180 551.83 T
(the PCCom library) 180 540.33 T
(. It is the third entry point in the PCCom library) 266.12 540.33 T
(.) 489.29 540.33 T
2 F
(Include:) 99 521.83 T
4 F
(pccom.goh) 180 521.83 T
81 505.48 531 510.49 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 505.48 531 510.49 R
7 X
0 0 0 1 0 0 0 K
V
50 509.48 609.01 509.48 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 497.48 T
2 F
(PCCOMEXIT\050\051) 99 497.48 T
5 10 Q
(PCComReturnType) 99 482.82 T
3 F
( PCCOMEXIT\050\051;) 189 482.82 T
0 F
-0.54 (This routine kills a pccom thread such as those started by) 180 464.82 P
0 9 Q
-0.48 (PCCOMINIT) 443.93 464.82 P
0 10 Q
-0.54 (\050\051. It is) 499.09 464.82 P
(the second entry point in the PCCom library) 180 453.32 T
(.) 383.9 453.32 T
2 F
(Structures:) 99 434.82 T
3 9 Q
(typedef ByteEnum PCComReturnType;) 153 424.48 T
(#define PCCRT_NO_ERROR 0) 153 414.48 T
(#define PCCRT_CANNOT_LOAD_SERIAL_DRIVER 1) 153 404.48 T
(#define PCCRT_CANNOT_CREATE_THREAD 2) 153 394.48 T
(#define PCCRT_CANNOT_ALLOC_STREAM 3) 153 384.48 T
(#define PCCRT_ALREADY_INITIALIZED 4) 153 374.48 T
2 10 Q
(Include:) 99 356.82 T
4 F
(pccom.goh) 180 356.82 T
81 340.48 531 345.48 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 340.48 531 345.48 R
7 X
0 0 0 1 0 0 0 K
V
50 344.48 609.01 344.48 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 332.48 T
2 F
(PCCOMINIT\050\051) 99 332.48 T
5 10 Q
(PCComReturnType) 99 317.81 T
3 F
( PCCOMINIT\050) 189 317.81 T
3 9 Q
(SerialPortNum) 153 307.48 T
(port,) 261 307.48 T
(SerialBaud) 153 297.48 T
(baud,) 261 297.48 T
(word) 153 287.48 T
(timeout,) 261 287.48 T
(optr) 153 277.47 T
(callbackOptr,) 261 277.47 T
(PCComInitFlags) 153 267.47 T
(flags\051;) 261 267.47 T
0 10 Q
-0.21 (This entry point of the PCCom library spawns a new thread which monitors) 180 249.81 P
(a serial port and acts as a passive pccom terminal. This routine is the \336rst) 180 238.31 T
(entry point in the PCCom library) 180 226.81 T
(.) 332.42 226.81 T
(This routine takes the following arguments:) 180 208.31 T
6 F
(port) 180 190.31 T
0 F
-0.74 (A) 243 190.31 P
4 F
-0.76 (SerialPortNum) 252.26 190.31 P
0 F
-0.74 ( value specifying which serial port to use for) 331.15 190.31 P
(the pccom connection. Pass -1 for the system default value:) 243 179.31 T
4 F
(com1) 243 168.31 T
0 F
( for the Zoomer) 270.04 168.31 T
(,) 339.85 168.31 T
4 F
(com2) 345.41 168.31 T
0 F
( for the desktop product.) 372.45 168.31 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "358" 58
%%Page: "359" 59
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
162 690.34 558 702 R
7 X
0 0 0 1 0 0 0 K
V
162 666.34 558 678.01 R
V
0 10 Q
0 X
(359) 541.32 671.34 T
324 684 580 684 2 L
7 X
V
3 H
2 Z
0 X
N
512 90 558 125 R
7 X
V
1 60 Q
0 X
(n) 512.17 85 T
315 104 510 126 R
7 X
V
2 24 Q
0 X
(Routines) 407.33 110 T
90 99 270 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
90.67 123.5 270.67 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
6 10 Q
0 X
(baud) 180 641.33 T
0 F
(A) 243 641.33 T
4 F
(SerialBaud) 253 641.33 T
0 F
( value specifying what speed to use. Pass -1 for) 311.34 641.33 T
(the system default value: 19200 baud for the Zoomer) 243 630.33 T
(, 38400) 485.64 630.33 T
(baud for the desktop product.) 243 619.33 T
6 F
(timeout) 180 601.33 T
0 F
(Number of clock ticks \050one tick is 1/60 second\051 to allow for) 243 601.33 T
(connection.) 243 590.33 T
6 F
(callbackOptr) 180 572.33 T
0 F
(An object which will receive noti\336cation messages of certain) 243 561.33 T
(events. A value of zero means no noti\336cation will be sent.) 243 550.33 T
6 F
(\337ags) 180 532.33 T
0 F
-0.07 (If an object will be receiving noti\336cation messages, these \337ags) 243 532.33 P
(determine what sort of noti\336cations will be sent.) 243 521.33 T
2 F
(Structures:) 99 503.33 T
3 9 Q
(typedef ByteEnum PCComReturnType;) 153 493 T
(#define PCCRT_NO_ERROR 0) 153 483 T
(#define PCCRT_CANNOT_LOAD_SERIAL_DRIVER 1) 153 473 T
(#define PCCRT_CANNOT_CREATE_THREAD 2) 153 463 T
(#define PCCRT_CANNOT_ALLOC_STREAM 3) 153 453 T
(#define PCCRT_ALREADY_INITIALIZED 4) 153 443 T
(typedef WordFlags PCComInitFlags;) 153 423 T
(/* send notifications when text is available for display */) 189 413 T
(#define PCCIF_NOTIFY_OUTPUT 0x8000) 153 403 T
(/* send notification when the remote machine shuts down the) 189 393 T
( * serial line */) 189 383 T
(#define PCCIF_NOTIFY_EXIT 0x4000) 153 373 T
2 10 Q
(Include:) 99 345.33 T
4 F
(pccom.goh) 180 345.33 T
81 328.99 531 334 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 328.99 531 334 R
7 X
0 0 0 1 0 0 0 K
V
50 332.99 609.01 332.99 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 320.99 T
2 F
(ProcCallFixedOrMovable_cdecl\050\051) 99 320.99 T
5 10 Q
(dword) 99 306.33 T
3 F
(ProcCallFixedOrMovable_cdecl\050) 153 306.33 T
3 9 Q
(void) 153 295.99 T
(\050*routine\051,) 189 295.99 T
(...\051) 153 285.99 T
0 10 Q
(This routine calls the routine pointed to, passing the other arguments) 180 268.33 T
(through to the called routine. The called routine must use C calling) 180 256.83 T
(conventions.) 180 245.33 T
2 F
(Include:) 99 226.83 T
4 F
(resource.h) 180 226.83 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "359" 59
%%Page: "360" 60
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
54 690.34 450 702 R
7 X
0 0 0 1 0 0 0 K
V
54 666.34 450 678.01 R
V
0 10 Q
0 X
(360) 54 671.34 T
32 684 288 684 2 L
7 X
V
3 H
2 Z
0 X
N
54 90 108 125 R
7 X
V
1 60 Q
0 X
(n) 58.17 85 T
104 104 299 126 R
7 X
V
2 24 Q
0 X
(Routines) 104 110 T
306 99 486 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
306 123.5 486 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
81 642.99 531 648 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 642.99 531 648 R
7 X
0 0 0 1 0 0 0 K
V
50 646.99 609.01 646.99 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 634.99 T
2 F
(ProcCallFixedOrMovable_pascal\050\051) 99 634.99 T
5 10 Q
(dword) 99 620.33 T
3 F
(ProcCallFixedOrMovable_pascal\050) 153 620.33 T
3 9 Q
(\311,) 153 609.99 T
(void) 153 599.99 T
(\050*routine\051\051) 189 599.99 T
0 10 Q
(This routine calls the routine pointed to, passing the other arguments) 180 582.33 T
(through to the called routine. The called routine must use Pascal calling) 180 570.83 T
(conventions.) 180 559.33 T
2 F
(Include:) 99 540.83 T
4 F
(resource.h) 180 540.83 T
81 524.48 531 529.49 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 524.48 531 529.49 R
7 X
0 0 0 1 0 0 0 K
V
50 528.48 609.01 528.48 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 516.48 T
2 F
(ProcGetLibraryEntry\050\051) 99 516.48 T
5 10 Q
(void *) 99 501.82 T
3 F
(ProcGetLibraryEntry\050) 153 501.82 T
3 9 Q
(GeodeHandle) 153 491.48 T
(library,) 261 491.48 T
(word) 153 481.48 T
(entryNumber\051) 261 481.48 T
0 10 Q
(This routine returns the pointer to a library\325) 180 463.82 T
(s entry-point.) 384.46 463.82 T
2 F
(Include:) 99 445.32 T
4 F
(resource.h) 180 445.32 T
81 428.98 531 433.98 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 428.98 531 433.98 R
7 X
0 0 0 1 0 0 0 K
V
50 432.98 609.01 432.98 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 420.98 T
2 F
(ProcInfo\050\051) 99 420.98 T
5 10 Q
(ThreadHandle) 99 407.31 T
3 F
( ProcInfo\050) 171 407.31 T
3 9 Q
(GeodeHandle gh\051;) 153 396.98 T
(/* handle of geode to check */) 261 396.98 T
0 10 Q
(This routine returns the \336rst thread of the process geode speci\336ed. If the) 180 379.31 T
(geode is not a process, the routine will return a null handle.) 180 367.81 T
2 F
(Include:) 99 349.31 T
4 F
(geode.h) 180 349.31 T
81 332.97 531 337.98 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 332.97 531 337.98 R
7 X
0 0 0 1 0 0 0 K
V
50 336.97 609.01 336.97 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 324.97 T
2 F
(PtrT) 99 324.97 T
(oOffset\050\051) 122.11 324.97 T
5 10 Q
(word) 99 311.3 T
3 F
(PtrToOffset\050) 153 311.3 T
7 F
(ptr) 225 311.3 T
3 F
(\051;) 243 311.3 T
3 9 Q
(dword) 153 300.97 T
7 F
(ptr) 189 300.97 T
3 F
(;) 205.2 300.97 T
0 10 Q
-0.6 (This macro returns just the lower 16 bits of the given dword. It is most useful) 180 283.3 P
(for extracting the offset portion of a far pointer) 180 271.8 T
(.) 395.55 271.8 T
81 256.96 531 261.97 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 256.96 531 261.97 R
7 X
0 0 0 1 0 0 0 K
V
50 260.96 609.01 260.96 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 248.96 T
2 F
(PtrT) 99 248.96 T
(oSegment\050\051) 122.11 248.96 T
5 10 Q
(word) 99 235.29 T
3 F
(PtrToSegment\050) 153 235.29 T
7 F
(ptr) 231 235.29 T
3 F
(\051;) 249 235.29 T
3 9 Q
(dword) 153 224.96 T
7 F
(ptr) 189 224.96 T
3 F
(;) 205.2 224.96 T
0 10 Q
-0.7 (This macro returns just the upper 16 bits of the given dword. It is most useful) 180 207.29 P
(for extracting the segment address of a far pointer) 180 195.79 T
(.) 411.67 195.79 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "360" 60
%%Trailer
%%BoundingBox: 0 0 612 792
%%PageOrder: Ascend
%%Pages: 60
%%DocumentFonts: NewCenturySchlbk-Roman
%%+ ZapfDingbats
%%+ Helvetica-Bold
%%+ Courier
%%+ NewCenturySchlbk-Bold
%%+ Courier-Bold
%%+ NewCenturySchlbk-Italic
%%+ Courier-Oblique
%%EOF
