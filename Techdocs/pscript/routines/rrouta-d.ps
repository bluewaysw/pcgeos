%!PS-Adobe-3.0
%%BoundingBox: (atend)
%%Pages: (atend)
%%PageOrder: (atend)
%%DocumentFonts: (atend)
%%Creator: Frame 4.0
%%DocumentData: Clean7Bit
%%EndComments
%%BeginProlog
%
% Frame ps_prolog 4.0, for use with Frame 4.0 products
% This ps_prolog file is Copyright (c) 1986-1993 Frame Technology
% Corporation.  All rights reserved.  This ps_prolog file may be
% freely copied and distributed in conjunction with documents created
% using FrameMaker, FrameBuilder and FrameViewer as long as this 
% copyright notice is preserved.
%
% Frame products normally print colors as their true color on a color printer
% or as shades of gray, based on luminance, on a black-and white printer. The
% following flag, if set to True, forces all non-white colors to print as pure
% black. This has no effect on bitmap images.
/FMPrintAllColorsAsBlack             false def
%
% Frame products can either set their own line screens or use a printer's 
% default settings. Three flags below control this separately for no 
% separations, spot separations and process separations. If a flag
% is true, then the default printer settings will not be changed. If it is
% false, Frame products will use their own settings from a table based on
% the printer's resolution.
/FMUseDefaultNoSeparationScreen      true  def
/FMUseDefaultSpotSeparationScreen    true  def
/FMUseDefaultProcessSeparationScreen false def
%
% For any given PostScript printer resolution, Frame products have two sets of 
% screen angles and frequencies for printing process separations, which are 
% recomended by Adobe. The following variable chooses the higher frequencies
% when set to true or the lower frequencies when set to false. This is only
% effective if the appropriate FMUseDefault...SeparationScreen flag is false.
/FMUseHighFrequencyScreens true def
%
% PostScript Level 2 printers contain an "Accurate Screens" feature which can
% improve process separation rendering at the expense of compute time. This 
% flag is ignored by PostScript Level 1 printers.
/FMUseAcccurateScreens true def
%
% The following PostScript procedure defines the spot function that Frame
% products will use for process separations. You may un-comment-out one of
% the alternative functions below, or use your own.
%
% Dot function
/FMSpotFunction {abs exch abs 2 copy add 1 gt 
		{1 sub dup mul exch 1 sub dup mul add 1 sub }
		{dup mul exch dup mul add 1 exch sub }ifelse } def
%
% Line function
% /FMSpotFunction { pop } def
%
% Elipse function
% /FMSpotFunction { dup 5 mul 8 div mul exch dup mul exch add 
%		sqrt 1 exch sub } def
%
%
/FMversion (4.0) def 
/FMLevel1 /languagelevel where {pop languagelevel} {1} ifelse 2 lt def
/FMPColor
	FMLevel1 {
		false
		/colorimage where {pop pop true} if
	} {
		true
	} ifelse
def
/FrameDict 400 dict def 
systemdict /errordict known not {/errordict 10 dict def
		errordict /rangecheck {stop} put} if
% The readline in PS 23.0 doesn't recognize cr's as nl's on AppleTalk
FrameDict /tmprangecheck errordict /rangecheck get put 
errordict /rangecheck {FrameDict /bug true put} put 
FrameDict /bug false put 
mark 
% Some PS machines read past the CR, so keep the following 3 lines together!
currentfile 5 string readline
00
0000000000
cleartomark 
errordict /rangecheck FrameDict /tmprangecheck get put 
FrameDict /bug get { 
	/readline {
		/gstring exch def
		/gfile exch def
		/gindex 0 def
		{
			gfile read pop 
			dup 10 eq {exit} if 
			dup 13 eq {exit} if 
			gstring exch gindex exch put 
			/gindex gindex 1 add def 
		} loop
		pop 
		gstring 0 gindex getinterval true 
		} bind def
	} if
/FMshowpage /showpage load def
/FMquit /quit load def
/FMFAILURE { 
	dup = flush 
	FMshowpage 
	/Helvetica findfont 12 scalefont setfont
	72 200 moveto
	show FMshowpage 
	FMquit 
	} def 
/FMVERSION {
	FMversion ne {
		(Frame product version does not match ps_prolog!) FMFAILURE
		} if
	} def 
/FMBADEPSF { 
	(PostScript Lang. Ref. Man., 2nd Ed., H.2.4 says EPS must not call X              )
	dup dup (X) search pop exch pop exch pop length 
	4 -1 roll 
	putinterval 
	FMFAILURE
	} def
/FMLOCAL {
	FrameDict begin
	0 def 
	end 
	} def 
/concatprocs
	{
	/proc2 exch cvlit def/proc1 exch cvlit def/newproc proc1 length proc2 length add array def
	newproc 0 proc1 putinterval newproc proc1 length proc2 putinterval newproc cvx
}def
FrameDict begin 
/FMnone 0 def
/FMcyan 1 def
/FMmagenta 2 def
/FMyellow 3 def
/FMblack 4 def
/FMcustom 5 def
/FrameNegative false def 
/FrameSepIs FMnone def 
/FrameSepBlack 0 def
/FrameSepYellow 0 def
/FrameSepMagenta 0 def
/FrameSepCyan 0 def
/FrameSepRed 1 def
/FrameSepGreen 1 def
/FrameSepBlue 1 def
/FrameCurGray 1 def
/FrameCurPat null def
/FrameCurColors [ 0 0 0 1 0 0 0 ] def 
/FrameColorEpsilon .001 def	
/eqepsilon {		
	sub dup 0 lt {neg} if
	FrameColorEpsilon le
} bind def
/FrameCmpColorsCMYK { 
	2 copy 0 get exch 0 get eqepsilon {
		2 copy 1 get exch 1 get eqepsilon {
			2 copy 2 get exch 2 get eqepsilon {
				3 get exch 3 get eqepsilon
			} {pop pop false} ifelse
		}{pop pop false} ifelse
	} {pop pop false} ifelse
} bind def
/FrameCmpColorsRGB { 
	2 copy 4 get exch 0 get eqepsilon {
		2 copy 5 get exch 1 get eqepsilon {
			6 get exch 2 get eqepsilon
		}{pop pop false} ifelse
	} {pop pop false} ifelse
} bind def
/RGBtoCMYK { 
	1 exch sub 
	3 1 roll 
	1 exch sub 
	3 1 roll 
	1 exch sub 
	3 1 roll 
	3 copy 
	2 copy 
	le { pop } { exch pop } ifelse 
	2 copy 
	le { pop } { exch pop } ifelse 
	dup dup dup 
	6 1 roll 
	4 1 roll 
	7 1 roll 
	sub 
	6 1 roll 
	sub 
	5 1 roll 
	sub 
	4 1 roll 
} bind def
/CMYKtoRGB { 
	dup dup 4 -1 roll add 						  
	5 1 roll 3 -1 roll add 						  
	4 1 roll add 								  
	1 exch sub dup 0 lt {pop 0} if 3 1 roll 	  
	1 exch sub dup 0 lt {pop 0} if exch 	      
	1 exch sub dup 0 lt {pop 0} if exch	  		  
} bind def
/FrameSepInit {
	1.0 RealSetgray
} bind def
/FrameSetSepColor { 
	/FrameSepBlue exch def
	/FrameSepGreen exch def
	/FrameSepRed exch def
	/FrameSepBlack exch def
	/FrameSepYellow exch def
	/FrameSepMagenta exch def
	/FrameSepCyan exch def
	/FrameSepIs FMcustom def
	setCurrentScreen	
} bind def
/FrameSetCyan {
	/FrameSepBlue 1.0 def
	/FrameSepGreen 1.0 def
	/FrameSepRed 0.0 def
	/FrameSepBlack 0.0 def
	/FrameSepYellow 0.0 def
	/FrameSepMagenta 0.0 def
	/FrameSepCyan 1.0 def
	/FrameSepIs FMcyan def
	setCurrentScreen	
} bind def
 
/FrameSetMagenta {
	/FrameSepBlue 1.0 def
	/FrameSepGreen 0.0 def
	/FrameSepRed 1.0 def
	/FrameSepBlack 0.0 def
	/FrameSepYellow 0.0 def
	/FrameSepMagenta 1.0 def
	/FrameSepCyan 0.0 def
	/FrameSepIs FMmagenta def
	setCurrentScreen
} bind def
 
/FrameSetYellow {
	/FrameSepBlue 0.0 def
	/FrameSepGreen 1.0 def
	/FrameSepRed 1.0 def
	/FrameSepBlack 0.0 def
	/FrameSepYellow 1.0 def
	/FrameSepMagenta 0.0 def
	/FrameSepCyan 0.0 def
	/FrameSepIs FMyellow def
	setCurrentScreen
} bind def
 
/FrameSetBlack {
	/FrameSepBlue 0.0 def
	/FrameSepGreen 0.0 def
	/FrameSepRed 0.0 def
	/FrameSepBlack 1.0 def
	/FrameSepYellow 0.0 def
	/FrameSepMagenta 0.0 def
	/FrameSepCyan 0.0 def
	/FrameSepIs FMblack def
	setCurrentScreen
} bind def
 
/FrameNoSep { 
	/FrameSepIs FMnone def
	setCurrentScreen
} bind def
/FrameSetSepColors { 
	FrameDict begin
	[ exch 1 add 1 roll ]
	/FrameSepColors  
	exch def end
	} bind def
/FrameColorInSepListCMYK { 
	FrameSepColors {  
       		exch dup 3 -1 roll 
       		FrameCmpColorsCMYK 
       		{ pop true exit } if
    	} forall 
	dup true ne {pop false} if
	} bind def
/FrameColorInSepListRGB { 
	FrameSepColors {  
       		exch dup 3 -1 roll 
       		FrameCmpColorsRGB 
       		{ pop true exit } if
    	} forall 
	dup true ne {pop false} if
	} bind def
/RealSetgray /setgray load def
/RealSetrgbcolor /setrgbcolor load def
/RealSethsbcolor /sethsbcolor load def
end 
/setgray { 
	FrameDict begin
	FrameSepIs FMnone eq
		{ RealSetgray } 
		{ 
		FrameSepIs FMblack eq 
			{ RealSetgray } 
			{ FrameSepIs FMcustom eq 
			  FrameSepRed 0 eq and
			  FrameSepGreen 0 eq and
			  FrameSepBlue 0 eq and {
			  	RealSetgray
			  } {
				1 RealSetgray pop 
			  } ifelse
			} ifelse
		} ifelse
	end
} bind def
/setrgbcolor { 
	FrameDict begin
	FrameSepIs FMnone eq
	{  RealSetrgbcolor }
	{
		3 copy [ 4 1 roll ] 
		FrameColorInSepListRGB
		{
				FrameSepBlue eq exch 
			 	FrameSepGreen eq and exch 
			 	FrameSepRed eq and
			 	{ 0 } { 1 } ifelse
		}
		{
			FMPColor {
				RealSetrgbcolor
				currentcmykcolor
			} {
				RGBtoCMYK
			} ifelse
			FrameSepIs FMblack eq
			{1.0 exch sub 4 1 roll pop pop pop} {
			FrameSepIs FMyellow eq
			{pop 1.0 exch sub 3 1 roll pop pop} {
			FrameSepIs FMmagenta eq
			{pop pop 1.0 exch sub exch pop } {
			FrameSepIs FMcyan eq
			{pop pop pop 1.0 exch sub } 
			{pop pop pop pop 1} ifelse } ifelse } ifelse } ifelse 
		} ifelse
		RealSetgray
	} 
	ifelse
	end
} bind def
/sethsbcolor {
	FrameDict begin
	FrameSepIs FMnone eq 
	{ RealSethsbcolor } 
	{
		RealSethsbcolor 
		currentrgbcolor  
		setrgbcolor 
	} 
	ifelse
	end
} bind def
FrameDict begin
/setcmykcolor where {
	pop /RealSetcmykcolor /setcmykcolor load def
} {
	/RealSetcmykcolor {
		4 1 roll
		3 { 3 index add 0 max 1 min 1 exch sub 3 1 roll} repeat 
		setrgbcolor pop
	} bind def
} ifelse
userdict /setcmykcolor { 
		FrameDict begin
		FrameSepIs FMnone eq
		{ RealSetcmykcolor } 
		{
			4 copy [ 5 1 roll ]
			FrameColorInSepListCMYK
			{
				FrameSepBlack eq exch 
				FrameSepYellow eq and exch 
				FrameSepMagenta eq and exch 
				FrameSepCyan eq and 
				{ 0 } { 1 } ifelse
			}
			{
				FrameSepIs FMblack eq
				{1.0 exch sub 4 1 roll pop pop pop} {
				FrameSepIs FMyellow eq
				{pop 1.0 exch sub 3 1 roll pop pop} {
				FrameSepIs FMmagenta eq
				{pop pop 1.0 exch sub exch pop } {
				FrameSepIs FMcyan eq
				{pop pop pop 1.0 exch sub } 
				{pop pop pop pop 1} ifelse } ifelse } ifelse } ifelse 
			} ifelse
			RealSetgray
		}
		ifelse
		end
	} bind put
FMLevel1 not { 
	
	/patProcDict 5 dict dup begin
		<0f1e3c78f0e1c387> { 3 setlinewidth -1 -1 moveto 9 9 lineto stroke 
											4 -4 moveto 12 4 lineto stroke
											-4 4 moveto 4 12 lineto stroke} bind def
		<0f87c3e1f0783c1e> { 3 setlinewidth -1 9 moveto 9 -1 lineto stroke 
											-4 4 moveto 4 -4 lineto stroke
											4 12 moveto 12 4 lineto stroke} bind def
		<8142241818244281> { 1 setlinewidth -1 9 moveto 9 -1 lineto stroke
											-1 -1 moveto 9 9 lineto stroke } bind def
		<03060c183060c081> { 1 setlinewidth -1 -1 moveto 9 9 lineto stroke 
											4 -4 moveto 12 4 lineto stroke
											-4 4 moveto 4 12 lineto stroke} bind def
		<8040201008040201> { 1 setlinewidth -1 9 moveto 9 -1 lineto stroke 
											-4 4 moveto 4 -4 lineto stroke
											4 12 moveto 12 4 lineto stroke} bind def
	end def
	/patDict 15 dict dup begin
		/PatternType 1 def		
		/PaintType 2 def		
		/TilingType 3 def		
		/BBox [ 0 0 8 8 ] def 	
		/XStep 8 def			
		/YStep 8 def			
		/PaintProc {
			begin
			patProcDict bstring known {
				patProcDict bstring get exec
			} {
				8 8 true [1 0 0 -1 0 8] bstring imagemask
			} ifelse
			end
		} bind def
	end def
} if
/combineColor {
    FrameSepIs FMnone eq
	{
		graymode FMLevel1 or not {
			
			[/Pattern [/DeviceCMYK]] setcolorspace
			FrameCurColors 0 4 getinterval aload pop FrameCurPat setcolor
		} {
			FrameCurColors 3 get 1.0 ge {
				FrameCurGray RealSetgray
			} {
				FMPColor graymode and {
					0 1 3 { 
						FrameCurColors exch get
						1 FrameCurGray sub mul
					} for
					RealSetcmykcolor
				} {
					4 1 6 {
						FrameCurColors exch get
						graymode {
							1 exch sub 1 FrameCurGray sub mul 1 exch sub
						} {
							1.0 lt {FrameCurGray} {1} ifelse
						} ifelse
					} for
					RealSetrgbcolor
				} ifelse
			} ifelse
		} ifelse
	} { 
		FrameCurColors 0 4 getinterval aload
		FrameColorInSepListCMYK {
			FrameSepBlack eq exch 
			FrameSepYellow eq and exch 
			FrameSepMagenta eq and exch 
			FrameSepCyan eq and
			FrameSepIs FMcustom eq and
			{ FrameCurGray } { 1 } ifelse
		} {
			FrameSepIs FMblack eq
			{FrameCurGray 1.0 exch sub mul 1.0 exch sub 4 1 roll pop pop pop} {
			FrameSepIs FMyellow eq
			{pop FrameCurGray 1.0 exch sub mul 1.0 exch sub 3 1 roll pop pop} {
			FrameSepIs FMmagenta eq
			{pop pop FrameCurGray 1.0 exch sub mul 1.0 exch sub exch pop } {
			FrameSepIs FMcyan eq
			{pop pop pop FrameCurGray 1.0 exch sub mul 1.0 exch sub } 
			{pop pop pop pop 1} ifelse } ifelse } ifelse } ifelse 
		} ifelse
		graymode FMLevel1 or not {
			
			[/Pattern [/DeviceGray]] setcolorspace
			FrameCurPat setcolor
		} { 
			graymode not FMLevel1 and {
				
				dup 1 lt {pop FrameCurGray} if
			} if
			RealSetgray
		} ifelse
	} ifelse
} bind def
/savematrix {
	orgmatrix currentmatrix pop
	} bind def
/restorematrix {
	orgmatrix setmatrix
	} bind def
/dmatrix matrix def
/dpi    72 0 dmatrix defaultmatrix dtransform
    dup mul exch   dup mul add   sqrt def
	
/freq dpi dup 72 div round dup 0 eq {pop 1} if 8 mul div def
/sangle 1 0 dmatrix defaultmatrix dtransform exch atan def
/dpiranges   [  2540    2400    1693     1270    1200     635      600      0      ] def
/CMLowFreqs  [ 100.402  94.8683 89.2289 100.402  94.8683  66.9349  63.2456 47.4342 ] def
/YLowFreqs   [  95.25   90.0    84.65    95.25   90.0     70.5556  66.6667 50.0    ] def
/KLowFreqs   [  89.8026 84.8528 79.8088  89.8026 84.8528  74.8355  70.7107 53.033  ] def
/CLowAngles  [  71.5651 71.5651 71.5651 71.5651  71.5651  71.5651  71.5651 71.5651 ] def
/MLowAngles  [  18.4349 18.4349 18.4349 18.4349  18.4349  18.4349  18.4349 18.4349 ] def
/YLowTDot    [  true    true    false    true    true     false    false   false   ] def
/CMHighFreqs [ 133.87  126.491 133.843  108.503 102.523  100.402   94.8683 63.2456 ] def
/YHighFreqs  [ 127.0   120.0   126.975  115.455 109.091   95.25    90.0    60.0    ] def
/KHighFreqs  [ 119.737 113.137 119.713  128.289 121.218   89.8026  84.8528 63.6395 ] def
/CHighAngles [  71.5651 71.5651 71.5651  70.0169 70.0169  71.5651  71.5651 71.5651 ] def
/MHighAngles [  18.4349 18.4349 18.4349  19.9831 19.9831  18.4349  18.4349 18.4349 ] def
/YHighTDot   [  false   false   true     false   false    true     true    false   ] def
/PatFreq     [	10.5833 10.0     9.4055  10.5833 10.0	  10.5833  10.0	   9.375   ] def
/screenIndex {
	0 1 dpiranges length 1 sub { dup dpiranges exch get 1 sub dpi le {exit} {pop} ifelse } for
} bind def
/getCyanScreen {
	FMUseHighFrequencyScreens { CHighAngles CMHighFreqs} {CLowAngles CMLowFreqs} ifelse
		screenIndex dup 3 1 roll get 3 1 roll get /FMSpotFunction load
} bind def
/getMagentaScreen {
	FMUseHighFrequencyScreens { MHighAngles CMHighFreqs } {MLowAngles CMLowFreqs} ifelse
		screenIndex dup 3 1 roll get 3 1 roll get /FMSpotFunction load
} bind def
/getYellowScreen {
	FMUseHighFrequencyScreens { YHighTDot YHighFreqs} { YLowTDot YLowFreqs } ifelse
		screenIndex dup 3 1 roll get 3 1 roll get { 3 div
			{2 { 1 add 2 div 3 mul dup floor sub 2 mul 1 sub exch} repeat
			FMSpotFunction } } {/FMSpotFunction load } ifelse
			0.0 exch
} bind def
/getBlackScreen  {
	FMUseHighFrequencyScreens { KHighFreqs } { KLowFreqs } ifelse
		screenIndex get 45.0 /FMSpotFunction load 
} bind def
/getSpotScreen {
	getBlackScreen
} bind def
/getCompositeScreen {
	getBlackScreen
} bind def
/FMSetScreen 
	FMLevel1 { /setscreen load 
	}{ {
		8 dict begin
		/HalftoneType 1 def
		/SpotFunction exch def
		/Angle exch def
		/Frequency exch def
		/AccurateScreens FMUseAcccurateScreens def
		currentdict end sethalftone
	} bind } ifelse
def
/setDefaultScreen {
	FMPColor {
		orgrxfer cvx orggxfer cvx orgbxfer cvx orgxfer cvx setcolortransfer
	}
	{
		orgxfer cvx settransfer
	} ifelse
	orgfreq organgle orgproc cvx setscreen
} bind def
/setCurrentScreen {
	FrameSepIs FMnone eq {
		FMUseDefaultNoSeparationScreen {
			setDefaultScreen
		} {
			getCompositeScreen FMSetScreen
		} ifelse
	} {
		FrameSepIs FMcustom eq {
			FMUseDefaultSpotSeparationScreen {
				setDefaultScreen
			} {
				getSpotScreen FMSetScreen
			} ifelse
		} {
			FMUseDefaultProcessSeparationScreen {
				setDefaultScreen
			} {
				FrameSepIs FMcyan eq {
					getCyanScreen FMSetScreen
				} {
					FrameSepIs FMmagenta eq {
						getMagentaScreen FMSetScreen
					} {
						FrameSepIs FMyellow eq {
							getYellowScreen FMSetScreen
						} {
							getBlackScreen FMSetScreen
						} ifelse
					} ifelse
				} ifelse
			} ifelse
		} ifelse
	} ifelse 
} bind def
end
	/gstring FMLOCAL
	/gfile FMLOCAL
	/gindex FMLOCAL
	/orgrxfer FMLOCAL
	/orggxfer FMLOCAL
	/orgbxfer FMLOCAL
	/orgxfer FMLOCAL
	/orgproc FMLOCAL
	/orgrproc FMLOCAL
	/orggproc FMLOCAL
	/orgbproc FMLOCAL
	/organgle FMLOCAL
	/orgrangle FMLOCAL
	/orggangle FMLOCAL
	/orgbangle FMLOCAL
	/orgfreq FMLOCAL
	/orgrfreq FMLOCAL
	/orggfreq FMLOCAL
	/orgbfreq FMLOCAL
	/yscale FMLOCAL
	/xscale FMLOCAL
	/edown FMLOCAL
	/manualfeed FMLOCAL
	/paperheight FMLOCAL
	/paperwidth FMLOCAL
/FMDOCUMENT { 
	array /FMfonts exch def 
	/#copies exch def
	FrameDict begin
	0 ne /manualfeed exch def
	/paperheight exch def
	/paperwidth exch def
	0 ne /FrameNegative exch def 
	0 ne /edown exch def 
	/yscale exch def
	/xscale exch def
	FMLevel1 {
		manualfeed {setmanualfeed} if
		/FMdicttop countdictstack 1 add def 
		/FMoptop count def 
		setpapername 
		manualfeed {true} {papersize} ifelse 
		{manualpapersize} {false} ifelse 
		{desperatepapersize} {false} ifelse 
		{ (Can't select requested paper size for Frame print job!) FMFAILURE } if
		count -1 FMoptop {pop pop} for
		countdictstack -1 FMdicttop {pop end} for 
		}
		{{1 dict dup /PageSize [paperwidth paperheight]put setpagedevice}stopped
		{ (Can't select requested paper size for Frame print job!) FMFAILURE } if
		 {1 dict dup /ManualFeed manualfeed put setpagedevice } stopped pop }
	ifelse 
	
	FMPColor {
		currentcolorscreen
			cvlit /orgproc exch def
				  /organgle exch def 
				  /orgfreq exch def
			cvlit /orgbproc exch def
				  /orgbangle exch def 
				  /orgbfreq exch def
			cvlit /orggproc exch def
				  /orggangle exch def 
				  /orggfreq exch def
			cvlit /orgrproc exch def
				  /orgrangle exch def 
				  /orgrfreq exch def
			currentcolortransfer 
			FrameNegative {
				1 1 4 { 
					pop { 1 exch sub } concatprocs 4 1 roll
				} for
				4 copy
				setcolortransfer
			} if
			cvlit /orgxfer exch def
			cvlit /orgbxfer exch def
			cvlit /orggxfer exch def
			cvlit /orgrxfer exch def
	} {
		currentscreen 
			cvlit /orgproc exch def
				  /organgle exch def 
				  /orgfreq exch def
				  
		currenttransfer 
		FrameNegative {
			{ 1 exch sub } concatprocs
			dup settransfer
		} if 
		cvlit /orgxfer exch def
	} ifelse
	end 
} def 
/pagesave FMLOCAL
/orgmatrix FMLOCAL
/landscape FMLOCAL
/pwid FMLOCAL
/FMBEGINPAGE { 
	FrameDict begin 
	/pagesave save def
	3.86 setmiterlimit
	/landscape exch 0 ne def
	landscape { 
		90 rotate 0 exch dup /pwid exch def neg translate pop 
	}{
		pop /pwid exch def
	} ifelse
	edown { [-1 0 0 1 pwid 0] concat } if
	0 0 moveto paperwidth 0 lineto paperwidth paperheight lineto 
	0 paperheight lineto 0 0 lineto 1 setgray fill
	xscale yscale scale
	/orgmatrix matrix def
	gsave 
} def 
/FMENDPAGE {
	grestore 
	pagesave restore
	end 
	showpage
	} def 
/FMFONTDEFINE { 
	FrameDict begin
	findfont 
	ReEncode 
	1 index exch 
	definefont 
	FMfonts 3 1 roll 
	put
	end 
	} def 
/FMFILLS {
	FrameDict begin dup
	array /fillvals exch def
	dict /patCache exch def
	end 
	} def 
/FMFILL {
	FrameDict begin
	 fillvals 3 1 roll put
	end 
	} def 
/FMNORMALIZEGRAPHICS { 
	newpath
	0.0 0.0 moveto
	1 setlinewidth
	0 setlinecap
	0 0 0 sethsbcolor
	0 setgray 
	} bind def
	/fx FMLOCAL
	/fy FMLOCAL
	/fh FMLOCAL
	/fw FMLOCAL
	/llx FMLOCAL
	/lly FMLOCAL
	/urx FMLOCAL
	/ury FMLOCAL
/FMBEGINEPSF { 
	end 
	/FMEPSF save def 
	/showpage {} def 
% See Adobe's "PostScript Language Reference Manual, 2nd Edition", page 714.
% "...the following operators MUST NOT be used in an EPS file:" (emphasis ours)
	/banddevice {(banddevice) FMBADEPSF} def
	/clear {(clear) FMBADEPSF} def
	/cleardictstack {(cleardictstack) FMBADEPSF} def 
	/copypage {(copypage) FMBADEPSF} def
	/erasepage {(erasepage) FMBADEPSF} def
	/exitserver {(exitserver) FMBADEPSF} def
	/framedevice {(framedevice) FMBADEPSF} def
	/grestoreall {(grestoreall) FMBADEPSF} def
	/initclip {(initclip) FMBADEPSF} def
	/initgraphics {(initgraphics) FMBADEPSF} def
	/initmatrix {(initmatrix) FMBADEPSF} def
	/quit {(quit) FMBADEPSF} def
	/renderbands {(renderbands) FMBADEPSF} def
	/setglobal {(setglobal) FMBADEPSF} def
	/setpagedevice {(setpagedevice) FMBADEPSF} def
	/setshared {(setshared) FMBADEPSF} def
	/startjob {(startjob) FMBADEPSF} def
	/lettertray {(lettertray) FMBADEPSF} def
	/letter {(letter) FMBADEPSF} def
	/lettersmall {(lettersmall) FMBADEPSF} def
	/11x17tray {(11x17tray) FMBADEPSF} def
	/11x17 {(11x17) FMBADEPSF} def
	/ledgertray {(ledgertray) FMBADEPSF} def
	/ledger {(ledger) FMBADEPSF} def
	/legaltray {(legaltray) FMBADEPSF} def
	/legal {(legal) FMBADEPSF} def
	/statementtray {(statementtray) FMBADEPSF} def
	/statement {(statement) FMBADEPSF} def
	/executivetray {(executivetray) FMBADEPSF} def
	/executive {(executive) FMBADEPSF} def
	/a3tray {(a3tray) FMBADEPSF} def
	/a3 {(a3) FMBADEPSF} def
	/a4tray {(a4tray) FMBADEPSF} def
	/a4 {(a4) FMBADEPSF} def
	/a4small {(a4small) FMBADEPSF} def
	/b4tray {(b4tray) FMBADEPSF} def
	/b4 {(b4) FMBADEPSF} def
	/b5tray {(b5tray) FMBADEPSF} def
	/b5 {(b5) FMBADEPSF} def
	FMNORMALIZEGRAPHICS 
	[/fy /fx /fh /fw /ury /urx /lly /llx] {exch def} forall 
	fx fw 2 div add fy fh 2 div add  translate
	rotate
	fw 2 div neg fh 2 div neg translate
	fw urx llx sub div fh ury lly sub div scale 
	llx neg lly neg translate 
	/FMdicttop countdictstack 1 add def 
	/FMoptop count def 
	} bind def
/FMENDEPSF {
	count -1 FMoptop {pop pop} for 
	countdictstack -1 FMdicttop {pop end} for 
	FMEPSF restore
	FrameDict begin 
	} bind def
FrameDict begin 
/setmanualfeed {
%%BeginFeature *ManualFeed True
	 statusdict /manualfeed true put
%%EndFeature
	} bind def
/max {2 copy lt {exch} if pop} bind def
/min {2 copy gt {exch} if pop} bind def
/inch {72 mul} def
/pagedimen { 
	paperheight sub abs 16 lt exch 
	paperwidth sub abs 16 lt and
	{/papername exch def} {pop} ifelse
	} bind def
	/papersizedict FMLOCAL
/setpapername { 
	/papersizedict 14 dict def 
	papersizedict begin
	/papername /unknown def 
		/Letter 8.5 inch 11.0 inch pagedimen
		/LetterSmall 7.68 inch 10.16 inch pagedimen
		/Tabloid 11.0 inch 17.0 inch pagedimen
		/Ledger 17.0 inch 11.0 inch pagedimen
		/Legal 8.5 inch 14.0 inch pagedimen
		/Statement 5.5 inch 8.5 inch pagedimen
		/Executive 7.5 inch 10.0 inch pagedimen
		/A3 11.69 inch 16.5 inch pagedimen
		/A4 8.26 inch 11.69 inch pagedimen
		/A4Small 7.47 inch 10.85 inch pagedimen
		/B4 10.125 inch 14.33 inch pagedimen
		/B5 7.16 inch 10.125 inch pagedimen
	end
	} bind def
/papersize {
	papersizedict begin
		/Letter {lettertray letter} def
		/LetterSmall {lettertray lettersmall} def
		/Tabloid {11x17tray 11x17} def
		/Ledger {ledgertray ledger} def
		/Legal {legaltray legal} def
		/Statement {statementtray statement} def
		/Executive {executivetray executive} def
		/A3 {a3tray a3} def
		/A4 {a4tray a4} def
		/A4Small {a4tray a4small} def
		/B4 {b4tray b4} def
		/B5 {b5tray b5} def
		/unknown {unknown} def
	papersizedict dup papername known {papername} {/unknown} ifelse get
	end
	statusdict begin stopped end 
	} bind def
/manualpapersize {
	papersizedict begin
		/Letter {letter} def
		/LetterSmall {lettersmall} def
		/Tabloid {11x17} def
		/Ledger {ledger} def
		/Legal {legal} def
		/Statement {statement} def
		/Executive {executive} def
		/A3 {a3} def
		/A4 {a4} def
		/A4Small {a4small} def
		/B4 {b4} def
		/B5 {b5} def
		/unknown {unknown} def
	papersizedict dup papername known {papername} {/unknown} ifelse get
	end
	stopped 
	} bind def
/desperatepapersize {
	statusdict /setpageparams known
		{
		paperwidth paperheight 0 1 
		statusdict begin
		{setpageparams} stopped 
		end
		} {true} ifelse 
	} bind def
/DiacriticEncoding [
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /space /exclam /quotedbl
/numbersign /dollar /percent /ampersand /quotesingle /parenleft
/parenright /asterisk /plus /comma /hyphen /period /slash /zero /one
/two /three /four /five /six /seven /eight /nine /colon /semicolon
/less /equal /greater /question /at /A /B /C /D /E /F /G /H /I /J /K
/L /M /N /O /P /Q /R /S /T /U /V /W /X /Y /Z /bracketleft /backslash
/bracketright /asciicircum /underscore /grave /a /b /c /d /e /f /g /h
/i /j /k /l /m /n /o /p /q /r /s /t /u /v /w /x /y /z /braceleft /bar
/braceright /asciitilde /.notdef /Adieresis /Aring /Ccedilla /Eacute
/Ntilde /Odieresis /Udieresis /aacute /agrave /acircumflex /adieresis
/atilde /aring /ccedilla /eacute /egrave /ecircumflex /edieresis
/iacute /igrave /icircumflex /idieresis /ntilde /oacute /ograve
/ocircumflex /odieresis /otilde /uacute /ugrave /ucircumflex
/udieresis /dagger /.notdef /cent /sterling /section /bullet
/paragraph /germandbls /registered /copyright /trademark /acute
/dieresis /.notdef /AE /Oslash /.notdef /.notdef /.notdef /.notdef
/yen /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/ordfeminine /ordmasculine /.notdef /ae /oslash /questiondown
/exclamdown /logicalnot /.notdef /florin /.notdef /.notdef
/guillemotleft /guillemotright /ellipsis /.notdef /Agrave /Atilde
/Otilde /OE /oe /endash /emdash /quotedblleft /quotedblright
/quoteleft /quoteright /.notdef /.notdef /ydieresis /Ydieresis
/fraction /currency /guilsinglleft /guilsinglright /fi /fl /daggerdbl
/periodcentered /quotesinglbase /quotedblbase /perthousand
/Acircumflex /Ecircumflex /Aacute /Edieresis /Egrave /Iacute
/Icircumflex /Idieresis /Igrave /Oacute /Ocircumflex /.notdef /Ograve
/Uacute /Ucircumflex /Ugrave /dotlessi /circumflex /tilde /macron
/breve /dotaccent /ring /cedilla /hungarumlaut /ogonek /caron
] def
/ReEncode { 
	dup 
	length 
	dict begin 
	{
	1 index /FID ne 
		{def} 
		{pop pop} ifelse 
	} forall 
	0 eq {/Encoding DiacriticEncoding def} if 
	currentdict 
	end 
	} bind def
FMPColor 
	
	{
	/BEGINBITMAPCOLOR { 
		BITMAPCOLOR} def
	/BEGINBITMAPCOLORc { 
		BITMAPCOLORc} def
	/BEGINBITMAPTRUECOLOR { 
		BITMAPTRUECOLOR } def
	/BEGINBITMAPTRUECOLORc { 
		BITMAPTRUECOLORc } def
	}
	
	{
	/BEGINBITMAPCOLOR { 
		BITMAPGRAY} def
	/BEGINBITMAPCOLORc { 
		BITMAPGRAYc} def
	/BEGINBITMAPTRUECOLOR { 
		BITMAPTRUEGRAY } def
	/BEGINBITMAPTRUECOLORc { 
		BITMAPTRUEGRAYc } def
	}
ifelse
/K { 
	FMPrintAllColorsAsBlack {
		dup 1 eq 2 index 1 eq and 3 index 1 eq and not
			{7 {pop} repeat 0 0 0 1 0 0 0} if
	} if 
	FrameCurColors astore 
	pop combineColor
} bind def
/graymode true def
	/bwidth FMLOCAL
	/bpside FMLOCAL
	/bstring FMLOCAL
	/onbits FMLOCAL
	/offbits FMLOCAL
	/xindex FMLOCAL
	/yindex FMLOCAL
	/x FMLOCAL
	/y FMLOCAL
/setPatternMode {
	FMLevel1 {
		/bwidth  exch def
		/bpside  exch def
		/bstring exch def
		/onbits 0 def  /offbits 0 def
		freq sangle landscape {90 add} if 
			{/y exch def
			 /x exch def
			 /xindex x 1 add 2 div bpside mul cvi def
			 /yindex y 1 add 2 div bpside mul cvi def
			 bstring yindex bwidth mul xindex 8 idiv add get
			 1 7 xindex 8 mod sub bitshift and 0 ne FrameNegative {not} if
			 {/onbits  onbits  1 add def 1}
			 {/offbits offbits 1 add def 0}
			 ifelse
			}
			setscreen
		offbits offbits onbits add div FrameNegative {1.0 exch sub} if
		/FrameCurGray exch def
	} { 
		pop pop
		dup patCache exch known {
			patCache exch get
		} { 
			dup
			patDict /bstring 3 -1 roll put
			patDict 
			9 PatFreq screenIndex get div dup matrix scale
			makepattern
			dup 
			patCache 4 -1 roll 3 -1 roll put
		} ifelse
		/FrameCurGray 0 def
		/FrameCurPat exch def
	} ifelse
	/graymode false def
	combineColor
} bind def
/setGrayScaleMode {
	graymode not {
		/graymode true def
		FMLevel1 {
			setCurrentScreen
		} if
	} if
	/FrameCurGray exch def
	combineColor
} bind def
/normalize {
	transform round exch round exch itransform
	} bind def
/dnormalize {
	dtransform round exch round exch idtransform
	} bind def
/lnormalize { 
	0 dtransform exch cvi 2 idiv 2 mul 1 add exch idtransform pop
	} bind def
/H { 
	lnormalize setlinewidth
	} bind def
/Z {
	setlinecap
	} bind def
	
/PFill {
	graymode FMLevel1 or not {
		gsave 1 setgray eofill grestore
	} if
} bind def
/PStroke {
	graymode FMLevel1 or not {
		gsave 1 setgray stroke grestore
	} if
	stroke
} bind def
	/fillvals FMLOCAL
/X { 
	fillvals exch get
	dup type /stringtype eq
	{8 1 setPatternMode} 
	{setGrayScaleMode}
	ifelse
	} bind def
/V { 
	PFill gsave eofill grestore
	} bind def
/Vclip {
	clip
	} bind def
/Vstrk {
	currentlinewidth exch setlinewidth PStroke setlinewidth
	} bind def
/N { 
	PStroke
	} bind def
/Nclip {
	strokepath clip newpath
	} bind def
/Nstrk {
	currentlinewidth exch setlinewidth PStroke setlinewidth
	} bind def
/M {newpath moveto} bind def
/E {lineto} bind def
/D {curveto} bind def
/O {closepath} bind def
	/n FMLOCAL
/L { 
 	/n exch def
	newpath
	normalize
	moveto 
	2 1 n {pop normalize lineto} for
	} bind def
/Y { 
	L 
	closepath
	} bind def
	/x1 FMLOCAL
	/x2 FMLOCAL
	/y1 FMLOCAL
	/y2 FMLOCAL
/R { 
	/y2 exch def
	/x2 exch def
	/y1 exch def
	/x1 exch def
	x1 y1
	x2 y1
	x2 y2
	x1 y2
	4 Y 
	} bind def
	/rad FMLOCAL
/rarc 
	{rad 
	 arcto
	} bind def
/RR { 
	/rad exch def
	normalize
	/y2 exch def
	/x2 exch def
	normalize
	/y1 exch def
	/x1 exch def
	mark
	newpath
	{
	x1 y1 rad add moveto
	x1 y2 x2 y2 rarc
	x2 y2 x2 y1 rarc
	x2 y1 x1 y1 rarc
	x1 y1 x1 y2 rarc
	closepath
	} stopped {x1 y1 x2 y2 R} if 
	cleartomark
	} bind def
/RRR { 
	/rad exch def
	normalize /y4 exch def /x4 exch def
	normalize /y3 exch def /x3 exch def
	normalize /y2 exch def /x2 exch def
	normalize /y1 exch def /x1 exch def
	newpath
	normalize moveto 
	mark
	{
	x2 y2 x3 y3 rarc
	x3 y3 x4 y4 rarc
	x4 y4 x1 y1 rarc
	x1 y1 x2 y2 rarc
	closepath
	} stopped
	 {x1 y1 x2 y2 x3 y3 x4 y4 newpath moveto lineto lineto lineto closepath} if
	cleartomark
	} bind def
/C { 
	grestore
	gsave
	R 
	clip
	setCurrentScreen
} bind def
/CP { 
	grestore
	gsave
	Y 
	clip
	setCurrentScreen
} bind def
	/FMpointsize FMLOCAL
/F { 
	FMfonts exch get
	FMpointsize scalefont
	setfont
	} bind def
/Q { 
	/FMpointsize exch def
	F 
	} bind def
/T { 
	moveto show
	} bind def
/RF { 
	rotate
	0 ne {-1 1 scale} if
	} bind def
/TF { 
	gsave
	moveto 
	RF
	show
	grestore
	} bind def
/P { 
	moveto
	0 32 3 2 roll widthshow
	} bind def
/PF { 
	gsave
	moveto 
	RF
	0 32 3 2 roll widthshow
	grestore
	} bind def
/S { 
	moveto
	0 exch ashow
	} bind def
/SF { 
	gsave
	moveto
	RF
	0 exch ashow
	grestore
	} bind def
/B { 
	moveto
	0 32 4 2 roll 0 exch awidthshow
	} bind def
/BF { 
	gsave
	moveto
	RF
	0 32 4 2 roll 0 exch awidthshow
	grestore
	} bind def
/G { 
	gsave
	newpath
	normalize translate 0.0 0.0 moveto 
	dnormalize scale 
	0.0 0.0 1.0 5 3 roll arc 
	closepath 
	PFill fill
	grestore
	} bind def
/Gstrk {
	savematrix
    newpath
    2 index 2 div add exch 3 index 2 div sub exch 
    normalize 2 index 2 div sub exch 3 index 2 div add exch 
    translate
    scale 
    0.0 0.0 1.0 5 3 roll arc 
    restorematrix
    currentlinewidth exch setlinewidth PStroke setlinewidth
    } bind def
/Gclip { 
	newpath
	savematrix
	normalize translate 0.0 0.0 moveto 
	dnormalize scale 
	0.0 0.0 1.0 5 3 roll arc 
	closepath 
	clip newpath
	restorematrix
	} bind def
/GG { 
	gsave
	newpath
	normalize translate 0.0 0.0 moveto 
	rotate 
	dnormalize scale 
	0.0 0.0 1.0 5 3 roll arc 
	closepath
	PFill
	fill
	grestore
	} bind def
/GGclip { 
	savematrix
	newpath
    normalize translate 0.0 0.0 moveto 
    rotate 
    dnormalize scale 
    0.0 0.0 1.0 5 3 roll arc 
    closepath
	clip newpath
	restorematrix
	} bind def
/GGstrk { 
	savematrix
    newpath
    normalize translate 0.0 0.0 moveto 
    rotate 
    dnormalize scale 
    0.0 0.0 1.0 5 3 roll arc 
    closepath 
	restorematrix
    currentlinewidth exch setlinewidth PStroke setlinewidth
	} bind def
/A { 
	gsave
	savematrix
	newpath
	2 index 2 div add exch 3 index 2 div sub exch 
	normalize 2 index 2 div sub exch 3 index 2 div add exch 
	translate 
	scale 
	0.0 0.0 1.0 5 3 roll arc 
	restorematrix
	PStroke
	grestore
	} bind def
/Aclip {
	newpath
	savematrix
	normalize translate 0.0 0.0 moveto 
	dnormalize scale 
	0.0 0.0 1.0 5 3 roll arc 
	closepath 
	strokepath clip newpath
	restorematrix
} bind def
/Astrk {
	Gstrk
} bind def
/AA { 
	gsave
	savematrix
	newpath
	
	3 index 2 div add exch 4 index 2 div sub exch 
	
	normalize 3 index 2 div sub exch 4 index 2 div add exch
	translate 
	rotate 
	scale 
	0.0 0.0 1.0 5 3 roll arc 
	restorematrix
	PStroke
	grestore
	} bind def
/AAclip {
	savematrix
	newpath
    normalize translate 0.0 0.0 moveto 
    rotate 
    dnormalize scale 
    0.0 0.0 1.0 5 3 roll arc 
    closepath
	strokepath clip newpath
	restorematrix
} bind def
/AAstrk {
	GGstrk
} bind def
	/x FMLOCAL
	/y FMLOCAL
	/w FMLOCAL
	/h FMLOCAL
	/xx FMLOCAL
	/yy FMLOCAL
	/ww FMLOCAL
	/hh FMLOCAL
	/FMsaveobject FMLOCAL
	/FMoptop FMLOCAL
	/FMdicttop FMLOCAL
/BEGINPRINTCODE { 
	/FMdicttop countdictstack 1 add def 
	/FMoptop count 7 sub def 
	/FMsaveobject save def
	userdict begin 
	/showpage {} def 
	FMNORMALIZEGRAPHICS 
	3 index neg 3 index neg translate
	} bind def
/ENDPRINTCODE {
	count -1 FMoptop {pop pop} for 
	countdictstack -1 FMdicttop {pop end} for 
	FMsaveobject restore 
	} bind def
/gn { 
	0 
	{	46 mul 
		cf read pop 
		32 sub 
		dup 46 lt {exit} if 
		46 sub add 
		} loop
	add 
	} bind def
	/str FMLOCAL
/cfs { 
	/str sl string def 
	0 1 sl 1 sub {str exch val put} for 
	str def 
	} bind def
/ic [ 
	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0223
	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0223
	0
	{0 hx} {1 hx} {2 hx} {3 hx} {4 hx} {5 hx} {6 hx} {7 hx} {8 hx} {9 hx}
	{10 hx} {11 hx} {12 hx} {13 hx} {14 hx} {15 hx} {16 hx} {17 hx} {18 hx}
	{19 hx} {gn hx} {0} {1} {2} {3} {4} {5} {6} {7} {8} {9} {10} {11} {12}
	{13} {14} {15} {16} {17} {18} {19} {gn} {0 wh} {1 wh} {2 wh} {3 wh}
	{4 wh} {5 wh} {6 wh} {7 wh} {8 wh} {9 wh} {10 wh} {11 wh} {12 wh}
	{13 wh} {14 wh} {gn wh} {0 bl} {1 bl} {2 bl} {3 bl} {4 bl} {5 bl} {6 bl}
	{7 bl} {8 bl} {9 bl} {10 bl} {11 bl} {12 bl} {13 bl} {14 bl} {gn bl}
	{0 fl} {1 fl} {2 fl} {3 fl} {4 fl} {5 fl} {6 fl} {7 fl} {8 fl} {9 fl}
	{10 fl} {11 fl} {12 fl} {13 fl} {14 fl} {gn fl}
	] def
	/sl FMLOCAL
	/val FMLOCAL
	/ws FMLOCAL
	/im FMLOCAL
	/bs FMLOCAL
	/cs FMLOCAL
	/len FMLOCAL
	/pos FMLOCAL
/ms { 
	/sl exch def 
	/val 255 def 
	/ws cfs 
	/im cfs 
	/val 0 def 
	/bs cfs 
	/cs cfs 
	} bind def
400 ms 
/ip { 
	is 
	0 
	cf cs readline pop 
	{	ic exch get exec 
		add 
		} forall 
	pop 
	
	} bind def
/rip { 
	   
	  
	  bis ris copy pop 
      is
      0
      cf cs readline pop 
      {       ic exch get exec 
              add 
              } forall 
	  pop pop 
	  ris gis copy pop 
	  dup is exch 
	  
      cf cs readline pop 
      {       ic exch get exec 
              add 
              } forall 
	  pop pop
	  gis bis copy pop 
	  dup add is exch 
	  
      cf cs readline pop 
      {       ic exch get exec 
              add 
              } forall 
      pop 
      
      } bind def
/wh { 
	/len exch def 
	/pos exch def 
	ws 0 len getinterval im pos len getinterval copy pop
	pos len 
	} bind def
/bl { 
	/len exch def 
	/pos exch def 
	bs 0 len getinterval im pos len getinterval copy pop
	pos len 
	} bind def
/s1 1 string def
/fl { 
	/len exch def 
	/pos exch def 
	/val cf s1 readhexstring pop 0 get def
	pos 1 pos len add 1 sub {im exch val put} for
	pos len 
	} bind def
/hx { 
	3 copy getinterval 
	cf exch readhexstring pop pop 
	} bind def
	/h FMLOCAL
	/w FMLOCAL
	/d FMLOCAL
	/lb FMLOCAL
	/bitmapsave FMLOCAL
	/is FMLOCAL
	/cf FMLOCAL
/wbytes { 
      dup dup
      24 eq { pop pop 3 mul }
      { 8 eq {pop} {1 eq {7 add 8 idiv} {3 add 4 idiv} ifelse} ifelse } ifelse
	} bind def
/BEGINBITMAPBWc { 
	1 {} COMMONBITMAPc
	} bind def
/BEGINBITMAPGRAYc { 
	8 {} COMMONBITMAPc
	} bind def
/BEGINBITMAP2BITc { 
	2 {} COMMONBITMAPc
	} bind def
/COMMONBITMAPc { 
		 
	/r exch def
	/d exch def
	gsave
	
	3 index 2 div add exch	
	4 index 2 div add exch	
	translate		
	rotate			
	1 index 2 div neg	
	1 index 2 div neg	
	translate		
	scale			
	/h exch def /w exch def
	/lb w d wbytes def 
	sl lb lt {lb ms} if 
	/bitmapsave save def 
	r                    
	/is im 0 lb getinterval def 
	ws 0 lb getinterval is copy pop 
	/cf currentfile def 
	w h d [w 0 0 h neg 0 h] 
	{ip} image 
	bitmapsave restore 
	grestore
	} bind def
/BEGINBITMAPBW { 
	1 {} COMMONBITMAP
	} bind def
/BEGINBITMAPGRAY { 
	8 {} COMMONBITMAP
	} bind def
/BEGINBITMAP2BIT { 
	2 {} COMMONBITMAP
	} bind def
/COMMONBITMAP { 
	/r exch def
	/d exch def
	gsave
	
	3 index 2 div add exch	
	4 index 2 div add exch	
	translate		
	rotate			
	1 index 2 div neg	
	1 index 2 div neg	
	translate		
	scale			
	/h exch def /w exch def
	/bitmapsave save def 
	r                    
	/is w d wbytes string def
	/cf currentfile def 
	w h d [w 0 0 h neg 0 h] 
	{cf is readhexstring pop} image
	bitmapsave restore 
	grestore
	} bind def
/ngrayt 256 array def
/nredt 256 array def
/nbluet 256 array def
/ngreent 256 array def
	/gryt FMLOCAL
	/blut FMLOCAL
	/grnt FMLOCAL
	/redt FMLOCAL
	/indx FMLOCAL
	/cynu FMLOCAL
	/magu FMLOCAL
	/yelu FMLOCAL
	/k FMLOCAL
	/u FMLOCAL
FMLevel1 {
/colorsetup {
	currentcolortransfer
	/gryt exch def
	/blut exch def
	/grnt exch def
	/redt exch def
	0 1 255 {
		/indx exch def
		/cynu 1 red indx get 255 div sub def
		/magu 1 green indx get 255 div sub def
		/yelu 1 blue indx get 255 div sub def
		/k cynu magu min yelu min def
		/u k currentundercolorremoval exec def
%		/u 0 def
		nredt indx 1 0 cynu u sub max sub redt exec put
		ngreent indx 1 0 magu u sub max sub grnt exec put
		nbluet indx 1 0 yelu u sub max sub blut exec put
		ngrayt indx 1 k currentblackgeneration exec sub gryt exec put
	} for
	{255 mul cvi nredt exch get}
	{255 mul cvi ngreent exch get}
	{255 mul cvi nbluet exch get}
	{255 mul cvi ngrayt exch get}
	setcolortransfer
	{pop 0} setundercolorremoval
	{} setblackgeneration
	} bind def
}
{
/colorSetup2 {
	[ /Indexed /DeviceRGB 255 
		{dup red exch get 255 div 
		 exch dup green exch get 255 div 
		 exch blue exch get 255 div}
	] setcolorspace
} bind def
} ifelse
	/tran FMLOCAL
/fakecolorsetup {
	/tran 256 string def
	0 1 255 {/indx exch def 
		tran indx
		red indx get 77 mul
		green indx get 151 mul
		blue indx get 28 mul
		add add 256 idiv put} for
	currenttransfer
	{255 mul cvi tran exch get 255.0 div}
	exch concatprocs settransfer
} bind def
/BITMAPCOLOR { 
	/d 8 def
	gsave
	
	3 index 2 div add exch	
	4 index 2 div add exch	
	translate		
	rotate			
	1 index 2 div neg	
	1 index 2 div neg	
	translate		
	scale			
	/h exch def /w exch def
	/bitmapsave save def
	FMLevel1 {	
		colorsetup
		/is w d wbytes string def
		/cf currentfile def 
		w h d [w 0 0 h neg 0 h] 
		{cf is readhexstring pop} {is} {is} true 3 colorimage 
	} {
		colorSetup2
		/is w d wbytes string def
		/cf currentfile def 
		7 dict dup begin
			/ImageType 1 def
			/Width w def
			/Height h def
			/ImageMatrix [w 0 0 h neg 0 h] def
			/DataSource {cf is readhexstring pop} bind def
			/BitsPerComponent d def
			/Decode [0 255] def
		end image	
	} ifelse
	bitmapsave restore 
	grestore
	} bind def
/BITMAPCOLORc { 
	/d 8 def
	gsave
	
	3 index 2 div add exch	
	4 index 2 div add exch	
	translate		
	rotate			
	1 index 2 div neg	
	1 index 2 div neg	
	translate		
	scale			
	/h exch def /w exch def
	/lb w d wbytes def 
	sl lb lt {lb ms} if 
	/bitmapsave save def 
	FMLevel1 {	
		colorsetup
		/is im 0 lb getinterval def 
		ws 0 lb getinterval is copy pop 
		/cf currentfile def 
		w h d [w 0 0 h neg 0 h] 
		{ip} {is} {is} true 3 colorimage
	} {
		colorSetup2
		/is im 0 lb getinterval def 
		ws 0 lb getinterval is copy pop 
		/cf currentfile def 
		7 dict dup begin
			/ImageType 1 def
			/Width w def
			/Height h def
			/ImageMatrix [w 0 0 h neg 0 h] def
			/DataSource {ip} bind def
			/BitsPerComponent d def
			/Decode [0 255] def
		end image	
	} ifelse
	bitmapsave restore 
	grestore
	} bind def
/BITMAPTRUECOLORc { 
	/d 24 def
        gsave
 	
	3 index 2 div add exch	
	4 index 2 div add exch	
	translate		
	rotate			
	1 index 2 div neg	
	1 index 2 div neg	
	translate		
	scale			
	/h exch def /w exch def
	/lb w d wbytes def 
	sl lb lt {lb ms} if 
        /bitmapsave save def 
        
	/is im 0 lb getinterval def	
	/ris im 0 w getinterval def	
	/gis im w w getinterval def	
	/bis im w 2 mul w getinterval def 
        
        ws 0 lb getinterval is copy pop 
        /cf currentfile def 
        w h 8 [w 0 0 h neg 0 h] 
        {w rip pop ris} {gis} {bis} true 3 colorimage
        bitmapsave restore 
        grestore
        } bind def
/BITMAPTRUECOLOR { 
        gsave
		
		3 index 2 div add exch	
		4 index 2 div add exch	
		translate		
		rotate			
		1 index 2 div neg	
		1 index 2 div neg	
		translate		
		scale			
		/h exch def /w exch def
        /bitmapsave save def 
        /is w string def
        /gis w string def
        /bis w string def
        /cf currentfile def 
        w h 8 [w 0 0 h neg 0 h] 
        { cf is readhexstring pop } 
        { cf gis readhexstring pop } 
        { cf bis readhexstring pop } 
        true 3 colorimage 
        bitmapsave restore 
        grestore
        } bind def
/BITMAPTRUEGRAYc { 
	/d 24 def
        gsave
	
	3 index 2 div add exch	
	4 index 2 div add exch	
	translate		
	rotate			
	1 index 2 div neg	
	1 index 2 div neg	
	translate		
	scale			
	/h exch def /w exch def
	/lb w d wbytes def 
	sl lb lt {lb ms} if 
        /bitmapsave save def 
        
	/is im 0 lb getinterval def	
	/ris im 0 w getinterval def	
	/gis im w w getinterval def	
	/bis im w 2 mul w getinterval def 
        ws 0 lb getinterval is copy pop 
        /cf currentfile def 
        w h 8 [w 0 0 h neg 0 h] 
        {w rip pop ris gis bis w gray} image
        bitmapsave restore 
        grestore
        } bind def
/ww FMLOCAL
/r FMLOCAL
/g FMLOCAL
/b FMLOCAL
/i FMLOCAL
/gray { 
        /ww exch def
        /b exch def
        /g exch def
        /r exch def
        0 1 ww 1 sub { /i exch def r i get .299 mul g i get .587 mul
			b i get .114 mul add add r i 3 -1 roll floor cvi put } for
        r
        } bind def
/BITMAPTRUEGRAY { 
        gsave
		
		3 index 2 div add exch	
		4 index 2 div add exch	
		translate		
		rotate			
		1 index 2 div neg	
		1 index 2 div neg	
		translate		
		scale			
		/h exch def /w exch def
        /bitmapsave save def 
        /is w string def
        /gis w string def
        /bis w string def
        /cf currentfile def 
        w h 8 [w 0 0 h neg 0 h] 
        { cf is readhexstring pop 
          cf gis readhexstring pop 
          cf bis readhexstring pop w gray}  image
        bitmapsave restore 
        grestore
        } bind def
/BITMAPGRAY { 
	8 {fakecolorsetup} COMMONBITMAP
	} bind def
/BITMAPGRAYc { 
	8 {fakecolorsetup} COMMONBITMAPc
	} bind def
/ENDBITMAP {
	} bind def
end 
	/ALDsave FMLOCAL
	/ALDmatrix matrix def ALDmatrix currentmatrix pop
/StartALD {
	/ALDsave save def
	 savematrix
	 ALDmatrix setmatrix
	} bind def
/InALD {
	 restorematrix
	} bind def
/DoneALD {
	 ALDsave restore
	} bind def
/I { setdash } bind def
/J { [] 0 setdash } bind def
%%EndProlog
%%BeginSetup
(4.0) FMVERSION
1 1 0 0 612 792 0 1 21 FMDOCUMENT
0 0 /NewCenturySchlbk-Roman FMFONTDEFINE
1 1 /ZapfDingbats FMFONTDEFINE
2 0 /Helvetica-Bold FMFONTDEFINE
3 0 /Courier-Bold FMFONTDEFINE
4 0 /Courier FMFONTDEFINE
5 0 /NewCenturySchlbk-Bold FMFONTDEFINE
6 0 /NewCenturySchlbk-Italic FMFONTDEFINE
7 0 /Times-Roman FMFONTDEFINE
8 0 /Times-Italic FMFONTDEFINE
9 0 /Courier-Oblique FMFONTDEFINE
32 FMFILLS
0 0 FMFILL
1 0.1 FMFILL
2 0.3 FMFILL
3 0.5 FMFILL
4 0.7 FMFILL
5 0.9 FMFILL
6 0.97 FMFILL
7 1 FMFILL
8 <0f1e3c78f0e1c387> FMFILL
9 <0f87c3e1f0783c1e> FMFILL
10 <cccccccccccccccc> FMFILL
11 <ffff0000ffff0000> FMFILL
12 <8142241818244281> FMFILL
13 <03060c183060c081> FMFILL
14 <8040201008040201> FMFILL
16 1 FMFILL
17 0.9 FMFILL
18 0.7 FMFILL
19 0.5 FMFILL
20 0.3 FMFILL
21 0.1 FMFILL
22 0.03 FMFILL
23 0 FMFILL
24 <f0e1c3870f1e3c78> FMFILL
25 <f0783c1e0f87c3e1> FMFILL
26 <3333333333333333> FMFILL
27 <0000ffff0000ffff> FMFILL
28 <7ebddbe7e7dbbd7e> FMFILL
29 <fcf9f3e7cf9f3f7e> FMFILL
30 <7fbfdfeff7fbfdfe> FMFILL
%%EndSetup
%%Page: "51" 1
%%BeginPaperSize: Letter
%%EndPaperSize
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
J
0 0 0 1 0 0 0 K
162 690.34 558 702 R
7 X
0 0 0 1 0 0 0 K
V
162 666.34 558 678.01 R
V
0 10 Q
0 X
(51) 546.88 671.34 T
324 684 580 684 2 L
7 X
V
3 H
2 Z
0 X
N
512 90 558 125 R
7 X
V
1 60 Q
0 X
(n) 512.17 85 T
315 104 510 126 R
7 X
V
2 24 Q
0 X
(Routines) 407.33 110 T
90 99 270 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
90.67 123.5 270.67 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
81 642.99 531 648 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 642.99 531 648 R
7 X
0 0 0 1 0 0 0 K
V
50 646.99 609.01 646.99 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 634.99 T
2 F
(ArrayQuickSort\050\051) 99 634.99 T
3 10 Q
(void) 99 620.33 T
4 F
(ArrayQuickSort\050) 153 620.33 T
4 9 Q
(void) 153 609.99 T
(*array,) 189 609.99 T
(/* Pointer to start of array */) 261 609.99 T
(word) 153 599.99 T
(count,) 189 599.99 T
(/* Number of elements in array */) 261 599.99 T
(word) 153 589.99 T
(elementSize,) 189 589.99 T
(/* Size of each element \050in bytes\051 */) 261 589.99 T
(word) 153 579.99 T
(valueForCallback,) 189 579.99 T
(/* Passed to callback routine */) 286.2 579.99 T
(QuickSortParameters *parameters\051;) 153 569.99 T
0 10 Q
(This routine sorts an array of uniform-sized elements. It uses a modi\336ed) 180 552.33 T
(QuickSort algorithm, using an insertion sort for subarrays below a certain) 180 540.83 T
-0.17 (size; this gives performance of) 180 529.33 P
-0.17 (. The routine calls a callback routine) 360.48 529.33 P
(to actually compare elements.) 180 517.83 T
5 F
(ArrayQuickSort\050\051) 180 499.33 T
0 F
( is passed \336ve arguments: A pointer to the \336rst element) 271.31 499.33 T
-0.29 (of the array) 180 487.83 P
-0.29 (, the number of elements in the array) 232.58 487.83 P
-0.29 (, the size of each element in) 402.44 487.83 P
-0.32 (bytes, a word of data \050which is passed to all callback routines\051, and a pointer) 180 476.33 P
(to a) 180 464.83 T
5 F
(QuickSortParameters) 200.01 464.83 T
0 F
( structure.) 313.91 464.83 T
(Before) 180 446.33 T
5 F
(ArrayQuickSort\050\051) 212.77 446.33 T
0 F
( examines or changes any element, it calls a) 304.08 446.33 T
(locking routine speci\336ed by the) 180 434.83 T
5 F
(QuickSortParameters) 326.49 434.83 T
0 F
( structure. This) 440.39 434.83 T
(routine locks the element, if necessary) 180 423.33 T
(, and takes any necessary prepatory) 356.12 423.33 T
-0.02 (steps. Similarly) 180 411.83 P
-0.02 (, after) 251.48 411.83 P
5 F
-0.02 (ArrayQuickSort\050\051) 282.01 411.83 P
0 F
-0.02 ( is \336nished with a routine, it calls) 373.32 411.83 P
-0.31 (an unlocking routine in the) 180 400.33 P
5 F
-0.32 (QuickSortParameters) 307.35 400.33 P
0 F
-0.31 (. Each of these routines) 421.25 400.33 P
(is passed a pointer to the element and the word of callback data which was) 180 388.83 T
(passed to) 180 377.33 T
5 F
(ArrayQuickSort\050\051) 225.75 377.33 T
0 F
(.) 317.06 377.33 T
(The sort routine does not compare elements. Rather) 180 358.83 T
(, it calls a comparison) 419.27 358.83 T
(callback routine speci\336ed by the) 180 347.33 T
5 F
(QuickSortParameters) 331.13 347.33 T
0 F
(. This callback) 445.03 347.33 T
(routine should be declared _pascal. Whenever) 180 335.83 T
5 F
(ArrayQuickSort\050\051) 394.45 335.83 T
0 F
( needs to) 485.76 335.83 T
-0.31 (compare two elements, it calls the callback routine, passing the addresses of) 180 324.33 P
(the elements and the) 180 312.83 T
6 F
(valueForCallback) 280.2 312.83 T
0 F
( word which was passed to) 362.04 312.83 T
5 F
(ChunkArraySort\050\051) 180 301.33 T
0 F
(. The callback routine\325) 275.2 301.33 T
(s return value determines which) 377.26 301.33 T
(element will come \336rst in the sorted array:) 180 289.83 T
1 F
(u) 180 271.33 T
0 F
(If element) 198 271.33 T
6 F
(el1) 248 271.33 T
0 F
( ought to come before) 261.33 271.33 T
6 F
(el2) 362.26 271.33 T
0 F
( in the sorted array) 375.59 271.33 T
(, the callback) 463.93 271.33 T
(routine should return a negative integer) 198 260.33 T
(.) 383.56 260.33 T
1 F
(u) 180 242.33 T
0 F
(If element) 198 242.33 T
6 F
(el1) 248 242.33 T
0 F
( ought to come after) 261.33 242.33 T
6 F
(el2) 356.15 242.33 T
0 F
( in the sorted array) 369.48 242.33 T
(, the callback) 457.82 242.33 T
(routine should return a positive integer) 198 231.33 T
(.) 380.04 231.33 T
1 F
(u) 180 213.33 T
0 F
-0.42 (If it doesn\325) 198 213.33 P
-0.42 (t matter whether) 245.5 213.33 P
6 F
-0.42 (el1) 326.48 213.33 P
0 F
-0.42 ( comes before or after) 339.81 213.33 P
6 F
-0.42 (el2) 439.56 213.33 P
0 F
-0.42 ( in the array) 452.89 213.33 P
-0.42 (, the) 508.5 213.33 P
(callback routine should return zero.) 198 202.33 T
2 F
(Include:) 99 184.33 T
0 F
(chunkarr) 180 184.33 T
(.h) 222.4 184.33 T
2 F
(T) 99 164.33 T
(ips and T) 104.93 164.33 T
(ricks:) 148.28 164.33 T
0 F
(Y) 180 164.33 T
(ou may need to sort an array based on different criteria at different times.) 185.93 164.33 T
-0.1 (The simplest way to do this is to write one general-purpose callback routine) 180 151.33 P
321.01 521 360.48 536 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
7 9 Q
0 X
0 0 0 1 0 0 0 K
(') 320.3 528.85 T
(O) 321.92 528.85 T
8 F
(') 331.41 528.85 T
(n) 333.34 528.85 T
(') 350.77 528.85 T
(n) 352.69 528.85 T
7 F
(l) 338.37 528.85 T
(o) 340.87 528.85 T
(g) 345.37 528.85 T
(\050) 328.41 528.85 T
(\051) 357.19 528.85 T
36 72 576 720 C
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "51" 1
%%Page: "52" 2
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
54 690.34 450 702 R
7 X
0 0 0 1 0 0 0 K
V
54 666.34 450 678.01 R
V
0 10 Q
0 X
(52) 54 671.34 T
32 684 288 684 2 L
7 X
V
3 H
2 Z
0 X
N
54 90 108 125 R
7 X
V
1 60 Q
0 X
(n) 58.17 85 T
104 104 299 126 R
7 X
V
2 24 Q
0 X
(Routines) 104 110 T
306 99 486 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
306 123.5 486 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
0 10 Q
0 X
(and have the) 180 641.33 T
6 F
(valueForCallback) 242.79 641.33 T
0 F
( word determine how the sort is done. For) 324.63 641.33 T
(example, the same callback routine could sort the array in ascending or) 180 628.33 T
(descending order) 180 615.33 T
(, depending on the) 257.95 615.33 T
6 F
(valueForCallback) 345.92 615.33 T
0 F
(.) 427.76 615.33 T
2 F
(Be Sure T) 99 595.33 T
(o:) 144.94 595.33 T
0 F
(Lock the array on the global heap \050unless it is in \336xed memory\051.) 180 595.33 T
2 F
(W) 99 575.33 T
(arnings:) 108.07 575.33 T
0 F
(Do not have the callback routine do anything which might invalidate) 180 575.33 T
-0.67 (pointers to the array) 180 562.33 P
-0.67 (. For example, if the array is in a chunk, do not resize the) 272.43 562.33 P
(chunks or allocate other chunks in the same LMem heap.) 180 549.33 T
2 F
(See Also:) 99 529.33 T
0 F
(QuickSortParameters, ChunkArraySort\050\051) 180 529.33 T
81 512.99 531 518 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 512.99 531 518 R
7 X
0 0 0 1 0 0 0 K
V
50 516.99 609.01 516.99 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 504.99 T
2 F
(BlockFromT) 99 504.99 T
(ransferBlockID) 168.35 504.99 T
3 10 Q
(VMBlockHandle) 99 491.33 T
4 F
( BlockFromTransferBlockID\050id\051;) 177 491.33 T
4 9 Q
(TransferBlockID) 153 480.99 T
(id;) 239.4 480.99 T
0 10 Q
(This macro extracts the) 180 463.33 T
0 9 Q
(VMB) 292.23 463.33 T
0 10 Q
(lockHandle from a) 313.72 463.33 T
5 F
(T) 401.69 463.33 T
(ransferBlockID) 408.29 463.33 T
0 F
(.) 488.67 463.33 T
81 448.48 531 453.49 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 448.48 531 453.49 R
7 X
0 0 0 1 0 0 0 K
V
50 452.48 609.01 452.48 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 440.48 T
2 F
(BlockIDFromFileAndBlock) 99 440.48 T
3 10 Q
(TransferBlockID) 99 426.82 T
4 F
( BlockIDFromFileAndBlock\050file, block\051;) 189 426.82 T
4 9 Q
(VMFileHandle) 153 416.48 T
(file;) 223.2 416.48 T
(VMBlockHandle) 153 406.48 T
(block;) 228.6 406.48 T
0 10 Q
-0.15 (This macro creates the dword type) 180 388.82 P
5 F
-0.15 (T) 341.35 388.82 P
-0.15 (ransferBlock) 347.95 388.82 P
5 9 Q
-0.14 (ID) 415.56 388.82 P
0 10 Q
-0.15 ( from a) 427.06 388.82 P
0 9 Q
-0.13 (VMF) 462.18 388.82 P
0 10 Q
-0.15 (ileHandle) 483.18 388.82 P
(and a) 180 377.32 T
0 9 Q
(VMB) 208.53 377.32 T
0 10 Q
(lockHandle.) 230.02 377.32 T
81 362.48 531 367.48 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 362.48 531 367.48 R
7 X
0 0 0 1 0 0 0 K
V
50 366.48 609.01 366.48 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 354.48 T
2 F
(bsearch\050\051) 99 354.48 T
4 10 Q
(extern void *_pascal bsearch\050) 99 339.81 T
4 9 Q
(const void) 153 329.48 T
(*key,) 261 329.48 T
(const void) 153 319.48 T
(*array,) 261 319.48 T
(word) 153 309.48 T
(count,) 261 309.48 T
(word) 153 299.48 T
(elementSize,) 261 299.48 T
(PCB\050int, compare, \050const void *, const void *\051\051\051;) 153 289.48 T
0 10 Q
(This is a standard binary search routine. The callback routine must be) 180 271.81 T
(declared _pascal.) 180 260.31 T
81 245.47 531 250.47 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 245.47 531 250.47 R
7 X
0 0 0 1 0 0 0 K
V
50 249.47 609.01 249.47 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 237.47 T
2 F
(calloc\050\051) 99 237.47 T
3 10 Q
(void *) 99 222.8 T
4 F
(calloc\050) 153 222.8 T
4 9 Q
(word) 153 212.47 T
(n,) 261 212.47 T
(/* number of structures to allocate */) 315 212.47 T
(size_t) 153 202.47 T
(size\051;) 261 202.47 T
(/* size of each structure in bytes */) 315 202.47 T
0 10 Q
(The) 180 184.8 T
5 F
(malloc\050\051) 200.56 184.8 T
0 F
( family of routines is provided for Standard C compatibility) 242.79 184.8 T
(. If) 515.04 184.8 T
-0.5 (a geode needs a small amount of \336xed memory) 180 173.3 P
-0.5 (, it can call one of the routines.) 389.95 173.3 P
-0.65 (The kernel will allocate a \336xed block to satisfy the geode\325) 180 161.8 P
-0.65 (s) 435.73 161.8 P
5 F
-0.68 (malloc\050\051) 442.48 161.8 P
0 F
-0.65 ( requests;) 484.71 161.8 P
(it will allocate memory from this block. When the block is \336lled, it will) 180 150.3 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "52" 2
%%Page: "53" 3
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
162 690.34 558 702 R
7 X
0 0 0 1 0 0 0 K
V
162 666.34 558 678.01 R
V
0 10 Q
0 X
(53) 546.88 671.34 T
324 684 580 684 2 L
7 X
V
3 H
2 Z
0 X
N
512 90 558 125 R
7 X
V
1 60 Q
0 X
(n) 512.17 85 T
315 104 510 126 R
7 X
V
2 24 Q
0 X
(Routines) 407.33 110 T
90 99 270 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
90.67 123.5 270.67 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
0 10 Q
0 X
(allocate another \336xed malloc-block. When all the memory in the block is) 180 641.33 T
(freed, the memory manager will automatically free the block.) 180 629.83 T
(When a geode calls) 180 611.33 T
5 F
(calloc\050\051) 270.75 611.33 T
0 F
(, it will be allocated a contiguous section of) 308.91 611.33 T
(memory large enough for the speci\336ed number of structures of the speci\336ed) 180 599.83 T
-0.34 (size. The memory will be allocated out of its malloc-block, and the address of) 180 588.33 P
-0.78 (the start of the memory will be returned. The memory will be zero-initialized.) 180 576.83 P
(If the request cannot be satis\336ed,) 180 565.33 T
5 F
(calloc\050\051) 336.87 565.33 T
0 F
( will return a null pointer) 375.03 565.33 T
(. The) 492.82 565.33 T
-0.81 (memory is guaranteed not to be moved until it is freed \050with) 180 553.83 P
5 F
-0.84 (free\050\051) 451.22 553.83 P
0 F
-0.81 (\051 or resized) 479.56 553.83 P
-0.27 (\050with) 180 542.33 P
5 F
-0.28 (realloc\050\051) 206.77 542.33 P
0 F
-0.27 (\051. When) 250.3 542.33 P
0 9 Q
-0.25 (GEOS) 288.45 542.33 P
0 10 Q
-0.27 ( shuts down, all \336xed blocks are freed, and any) 314.62 542.33 P
(memory allocated with) 180 530.83 T
5 F
(calloc\050\051) 288.35 530.83 T
0 F
( is lost.) 326.51 530.83 T
2 F
(T) 99 512.33 T
(ips and T) 104.93 512.33 T
(ricks:) 148.28 512.33 T
0 F
(Y) 180 512.33 T
(ou can allocate memory in another geode\325) 185.93 512.33 T
(s malloc-block by calling) 376.32 512.33 T
5 F
(GeoMalloc\050\051) 180 499.33 T
0 F
(. However) 242.59 499.33 T
(, that block will be freed when the other geode exits.) 288.33 499.33 T
2 F
(Be Sure T) 99 479.33 T
(o:) 144.94 479.33 T
0 F
(Request a size small enough to \336t in a malloc-block; that is, the size of the) 180 479.33 T
(structure times the number of structures requested must be somewhat) 180 466.33 T
(smaller than 64K.) 180 453.33 T
2 F
(W) 99 433.33 T
(arnings:) 108.07 433.33 T
0 F
(All memory allocated with) 180 433.33 T
5 F
(calloc\050\051) 304.65 433.33 T
0 F
( is freed when) 342.81 433.33 T
0 9 Q
(GEOS) 410.22 433.33 T
0 10 Q
( shuts down.) 436.39 433.33 T
2 F
(See Also:) 99 413.33 T
0 F
(malloc\050\051, free\050\051, GeoMalloc\050\051, realloc\050\051) 180 413.33 T
81 396.99 531 402 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 396.99 531 402 R
7 X
0 0 0 1 0 0 0 K
V
50 400.99 609.01 400.99 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 388.99 T
2 F
(CCB\050\051) 99 388.99 T
4 10 Q
(#define CCB\050return_type, pointer_name, args\051 \134) 99 374.33 T
4 9 Q
(return_type _cdecl \050*pointer_name\051 args) 153 363.99 T
0 10 Q
-0.47 (This macro is useful for declaring pointers to functions that use the C calling) 180 346.33 P
-0.05 (conventions. For example, to declare a pointer to a function which is passed) 180 334.83 P
(two strings and returns an integer) 180 323.33 T
(, one could write) 338.71 323.33 T
4 9 Q
(CCB\050int, func_ptr, \050const char *, const char *\051\051;) 216 308.49 T
0 10 Q
(which would be expanded to) 180 290.83 T
4 9 Q
(int _cdecl \050*func_ptr\051 \050const char *, const char *\051;) 216 275.99 T
2 10 Q
(See Also:) 99 258.33 T
0 F
(PCB\050\051) 180 258.33 T
81 241.98 531 246.99 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 241.98 531 246.99 R
7 X
0 0 0 1 0 0 0 K
V
50 245.98 609.01 245.98 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 233.98 T
2 F
(CellDeref\050\051) 99 233.98 T
3 10 Q
(void *) 99 219.32 T
4 F
(CellDeref\050) 153 219.32 T
4 9 Q
(optr) 153 208.98 T
(CellRef\051;) 189 208.98 T
0 10 Q
-0.38 (This routine translates an optr to a cell into the cell\325) 180 191.32 P
-0.38 (s address. The routine is) 416.6 191.32 P
(simply a synonym for) 180 179.82 T
5 F
(LMemDeref\050\051) 281.86 179.82 T
0 F
(.) 350.93 179.82 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "53" 3
%%Page: "54" 4
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
54 690.34 450 702 R
7 X
0 0 0 1 0 0 0 K
V
54 666.34 450 678.01 R
V
0 10 Q
0 X
(54) 54 671.34 T
32 684 288 684 2 L
7 X
V
3 H
2 Z
0 X
N
54 90 108 125 R
7 X
V
1 60 Q
0 X
(n) 58.17 85 T
104 104 299 126 R
7 X
V
2 24 Q
0 X
(Routines) 104 110 T
306 99 486 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
306 123.5 486 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
81 642.99 531 648 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 642.99 531 648 R
7 X
0 0 0 1 0 0 0 K
V
50 646.99 609.01 646.99 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 634.99 T
2 F
(CellDirty\050\051) 99 634.99 T
0 F
(Section) 326.06 634.99 T
(19.4.2.2 of the Concepts book) 370.07 634.99 T
3 10 Q
(void) 99 620.33 T
4 F
(CellDirty\050) 153 620.33 T
4 9 Q
(void *) 153 609.99 T
(ptr\051;) 261 609.99 T
(/* pointer to anywhere in locked cell */) 297 609.99 T
0 10 Q
(This routine marks a cell as \322dirty\323; i.e., the cell will have to be copied from) 180 592.33 T
(memory back to the disk.) 180 580.83 T
2 F
(Include:) 99 562.33 T
0 F
(cell.h) 180 562.33 T
2 F
(T) 99 542.33 T
(ips and T) 104.93 542.33 T
(ricks:) 148.28 542.33 T
0 F
-0.42 (All the cells in an item block are marked dirty at once; thus, you can call this) 180 542.33 P
(routine just once for several cells in the same item block. Only the segment) 180 529.33 T
-0.49 (portion of the pointer is signi\336cant; thus, you can pass a pointer to anywhere) 180 516.33 P
(in the cell. This is useful if you have incremented the pointer to the cell.) 180 503.33 T
81 486.98 531 491.99 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 486.98 531 491.99 R
7 X
0 0 0 1 0 0 0 K
V
50 490.98 609.01 490.98 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 478.98 T
2 F
(CellGetDBItem\050\051) 99 478.98 T
0 F
(Section) 326.06 478.98 T
(19.4.2.2 of the Concepts book) 370.07 478.98 T
3 10 Q
(DBGroupAndItem) 99 464.32 T
4 F
(CellGetDBItem\050) 189 464.32 T
4 9 Q
(CellFunctionParameters *) 153 453.98 T
(cfp,) 282.6 453.98 T
(word) 153 443.98 T
(row,) 261 443.98 T
(/* Get handles of cell in this row */) 315 443.98 T
(byte) 153 433.98 T
(column\051;) 261 433.98 T
(/*...and this column */) 315 433.98 T
0 10 Q
(All cells are stored as ungrouped) 180 416.32 T
0 9 Q
(DB) 334.08 416.32 T
0 10 Q
( items. If you wish to manipulate the) 347.58 416.32 T
(cells with standard) 180 404.82 T
0 9 Q
(DB) 271.31 404.82 T
0 10 Q
( routines, you will need to know their handles. The) 284.81 404.82 T
-0.42 (routine is passed the address of the) 180 393.32 P
5 F
-0.43 (CellFunctionParameters) 343.39 393.32 P
0 F
-0.42 ( and the row) 471.92 393.32 P
(and column indices of the desired cell. It returns the) 180 381.82 T
5 F
(DBGroupAndItem) 424.26 381.82 T
0 F
(value for the speci\336ed cell. If there is no cell at the speci\336ed coordinates, it) 180 370.32 T
(returns a null) 180 358.82 T
5 F
(DBGroupAndItem) 247.04 358.82 T
0 F
(. The routine does not lock the cell or) 341.48 358.82 T
(change it in any way) 180 347.32 T
(.) 274.65 347.32 T
2 F
(Include:) 99 328.82 T
0 F
(cell.h) 180 328.82 T
2 F
(See Also:) 99 308.82 T
0 F
(DBGroupAndItem) 180 308.82 T
81 292.48 531 297.48 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 292.48 531 297.48 R
7 X
0 0 0 1 0 0 0 K
V
50 296.48 609.01 296.48 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 284.48 T
2 F
(CellGetExtent\050\051) 99 284.48 T
0 F
(Section) 326.06 284.48 T
(19.4.2.2 of the Concepts book) 370.07 284.48 T
3 10 Q
(void) 99 269.81 T
4 F
(CellGetExtent\050) 153 269.81 T
4 9 Q
(CellFunctionParameters *) 153 259.47 T
(cfp,) 282.6 259.47 T
(RangeEnumParams *) 153 249.47 T
(rep\051; /* write boundaries in REP_bounds field */) 261 249.47 T
0 10 Q
-0.62 (This routine returns the boundaries of the utilized portion of the cell \336le. The) 180 231.81 P
(routine is passed the address of the cell \336le\325) 180 220.31 T
(s) 380.76 220.31 T
5 F
(CellFunctionParameters) 388.17 220.31 T
0 F
(structure.\051 It writes the results into the) 180 208.81 T
6 9 Q
(REP) 365.37 208.81 T
6 10 Q
(_bounds) 384.54 208.81 T
0 F
( \336eld of the passed) 422.87 208.81 T
5 F
-0.49 (RangeEnumParams) 180 197.31 P
0 F
-0.47 ( structure. The index of the \336rst row to contain cells is) 283.51 197.31 P
-0.3 (written into) 180 185.81 P
6 9 Q
-0.27 (REP) 237.38 185.81 P
6 10 Q
-0.3 (_bounds.) 256.55 185.81 P
6 9 Q
-0.27 (R) 297.65 185.81 P
6 10 Q
-0.3 (_top) 304.32 185.81 P
0 F
-0.3 (; the index of the last occupied row is written) 323.58 185.81 P
-0.37 (to) 180 174.31 P
6 9 Q
-0.34 (REP) 191.3 174.31 P
6 10 Q
-0.37 (_bounds.) 210.47 174.31 P
6 9 Q
-0.34 (R) 251.58 174.31 P
6 10 Q
-0.37 (_bottom) 258.24 174.31 P
0 F
-0.37 (; the index of the \336rst occupied column is written to) 294.73 174.31 P
6 9 Q
(REP) 180 162.81 T
6 10 Q
(_bounds.) 199.17 162.81 T
6 9 Q
(R) 240.28 162.81 T
6 10 Q
(_left) 246.95 162.81 T
0 F
(; and the index of the last occupied row is written to) 266.57 162.81 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "54" 4
%%Page: "55" 5
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
162 690.34 558 702 R
7 X
0 0 0 1 0 0 0 K
V
162 666.34 558 678.01 R
V
0 10 Q
0 X
(55) 546.88 671.34 T
324 684 580 684 2 L
7 X
V
3 H
2 Z
0 X
N
512 90 558 125 R
7 X
V
1 60 Q
0 X
(n) 512.17 85 T
315 104 510 126 R
7 X
V
2 24 Q
0 X
(Routines) 407.33 110 T
90 99 270 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
90.67 123.5 270.67 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
6 9 Q
0 X
-0.49 (REP) 180 641.33 P
6 10 Q
-0.55 (_bounds.) 199.17 641.33 P
6 9 Q
-0.49 (R) 240.28 641.33 P
6 10 Q
-0.55 (_right) 246.95 641.33 P
0 F
-0.55 (. If the cell \336le contains no cells, all four \336elds will be set) 274.72 641.33 P
(to) 180 629.83 T
(.) 203.44 629.83 T
2 F
(Include:) 99 611.33 T
0 F
(cell.h) 180 611.33 T
81 594.99 531 600 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 594.99 531 600 R
7 X
0 0 0 1 0 0 0 K
V
50 598.99 609.01 598.99 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 586.99 T
2 F
(CellLock\050\051) 99 586.99 T
0 F
(Section) 326.06 586.99 T
(19.4.2.2 of the Concepts book) 370.07 586.99 T
3 10 Q
(void *) 99 572.33 T
4 F
(CellLock\050) 153 572.33 T
4 9 Q
(CellFunctionParameters*) 153 561.99 T
(cfp,) 279 561.99 T
(word) 153 551.99 T
(row,) 279 551.99 T
(/* Lock cell in this row... */) 333 551.99 T
(word) 153 541.99 T
(column\051;) 279 541.99 T
(/* ... and this column */) 333 541.99 T
0 10 Q
-0.66 (This routine is passed the address of the) 180 524.33 P
5 F
-0.68 (CellFunctionParameters) 364.37 524.33 P
0 F
-0.66 ( of a cell) 492.89 524.33 P
(\336le, and the row and column indices of a cell. It locks the cell and returns a) 180 512.83 T
(pointer to it.) 180 501.33 T
2 F
(Include:) 99 482.83 T
0 F
(cell.h) 180 482.83 T
2 F
(See Also:) 99 462.83 T
0 F
(CellLockGetRef\050\051) 180 462.83 T
81 446.48 531 451.49 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 446.48 531 451.49 R
7 X
0 0 0 1 0 0 0 K
V
50 450.48 609.01 450.48 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 438.48 T
2 F
(CellLockGetRef\050\051) 99 438.48 T
0 F
(Section) 326.06 438.48 T
(19.4.2.2 of the Concepts book) 370.07 438.48 T
3 10 Q
(void *) 99 423.82 T
4 F
(CellLockGetRef\050) 153 423.82 T
4 9 Q
(CellFunctionParameters*) 153 413.48 T
(cfp,) 279 413.48 T
(word) 153 403.48 T
(row,) 279 403.48 T
(/* Lock cell in this row... */) 333 403.48 T
(word) 153 393.48 T
(column,) 279 393.48 T
(/* ... and this column */) 333 393.48 T
(optr *) 153 383.48 T
(ref\051;) 279 383.48 T
(/* Write handles here */) 333 383.48 T
0 10 Q
-0.66 (This routine is passed the address of the) 180 365.82 P
5 F
-0.68 (CellFunctionParameters) 364.37 365.82 P
0 F
-0.66 ( of a cell) 492.89 365.82 P
(\336le, and the row and column indices of a cell. It locks the cell and returns a) 180 354.32 T
-0.08 (pointer to it. It also writes the locked cell\325) 180 342.82 P
-0.08 (s item-block and chunk handles to) 370.52 342.82 P
(the optr) 180 331.32 T
(. If the cell moves \050e.g. because another cell is allocated\051, you can) 216.11 331.32 T
(translate the optr structure into a pointer by passing it to) 180 319.82 T
5 F
(CellDeref\050\051) 448.92 319.82 T
0 F
(.) 506.15 319.82 T
2 F
(Include:) 99 301.32 T
0 F
(cell.h) 180 301.32 T
2 F
(W) 99 281.32 T
(arnings:) 108.07 281.32 T
0 F
(The optr becomes invalid when the cell is unlocked.) 180 281.32 T
2 F
(See Also:) 99 261.32 T
0 F
(CellGetDBItem\050\051. CellLock\050\051) 180 261.32 T
191.67 626.88 203.44 636.96 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
7 9 Q
0 X
0 0 0 1 0 0 0 K
(1) 197.23 629.83 T
(\320) 192.39 629.83 T
36 72 576 720 C
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "55" 5
%%Page: "56" 6
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
54 690.34 450 702 R
7 X
0 0 0 1 0 0 0 K
V
54 666.34 450 678.01 R
V
0 10 Q
0 X
(56) 54 671.34 T
32 684 288 684 2 L
7 X
V
3 H
2 Z
0 X
N
54 90 108 125 R
7 X
V
1 60 Q
0 X
(n) 58.17 85 T
104 104 299 126 R
7 X
V
2 24 Q
0 X
(Routines) 104 110 T
306 99 486 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
306 123.5 486 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
81 642.99 531 648 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 642.99 531 648 R
7 X
0 0 0 1 0 0 0 K
V
50 646.99 609.01 646.99 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 634.99 T
2 F
(CellReplace\050\051) 99 634.99 T
3 10 Q
(void) 99 620.33 T
4 F
(CellReplace{) 153 620.33 T
4 9 Q
(CellFunctionParameters *) 153 609.99 T
(cfp,) 282.6 609.99 T
(word) 153 599.99 T
(row,) 261 599.99 T
(/* Insert/replace cell at this row... */) 297 599.99 T
(word) 153 589.99 T
(column,) 261 589.99 T
(/* ... and this column */) 315 589.99 T
(const void *) 153 579.99 T
(cellData,) 261 579.99 T
(/* Copy this data into the new cell */) 315 579.99 T
(word) 153 569.99 T
(size\051;) 261 569.99 T
(/* Size of new cell \050in bytes\051 */) 315 569.99 T
0 10 Q
-0.47 (This routine is used for creating, deleting, and replacing cells in a cell \336le. T) 180 552.33 P
-0.47 (o) 523.69 552.33 P
-0.13 (create or replace a cell, set) 180 540.83 P
6 F
-0.13 (cellData) 304.61 540.83 P
0 F
-0.13 ( to point to the data to copy into the new) 342.93 540.83 P
(cell, and set) 180 529.33 T
6 F
(size) 237.79 529.33 T
0 F
( to the length of the cell in bytes, and) 254.63 529.33 T
6 F
(row) 428.92 529.33 T
0 F
( and) 446.14 529.33 T
6 F
(column) 469.11 529.33 T
0 F
( the) 502.99 529.33 T
(cell\325) 180 517.83 T
(s coordinates. \050As usual,) 197.41 517.83 T
6 F
(cfp) 312.42 517.83 T
0 F
( is a pointer to the cell \336le\325) 325.93 517.83 T
(s) 447.62 517.83 T
5 F
-0.35 (CellFunctionParameters) 180 506.33 P
0 F
-0.34 ( structure.\051 Any pre-existing cell at the speci\336ed) 308.52 506.33 P
(coordinates will automatically be freed, and a new cell will be created.) 180 494.83 T
(T) 180 476.33 T
(o delete a cell, pass a) 185.75 476.33 T
6 F
(size) 285.41 476.33 T
0 F
( of zero. If there is a cell at the speci\336ed) 302.25 476.33 T
(coordinates, it will be freed. \050The) 180 464.83 T
6 F
(cellData) 334.65 464.83 T
0 F
( argument is ignored.\051) 372.97 464.83 T
2 F
(Include:) 99 446.33 T
0 F
(cell.h) 180 446.33 T
2 F
(W) 99 426.33 T
(arnings:) 108.07 426.33 T
0 F
(If a cell is allocated or replaced, pointers to all ungrouped items \050including) 180 426.33 T
(cells\051 in that) 180 413.33 T
0 9 Q
(VM) 240.75 413.33 T
0 10 Q
( \336le may be invalidated. The) 255.74 413.33 T
5 F
(CellFunctionParameters) 390.04 413.33 T
0 F
-0.1 (structure must not move during the call; for this reason, it may not be in an) 180 400.33 P
(ungrouped) 180 387.33 T
0 9 Q
(DB) 232.4 387.33 T
0 10 Q
( item. Never replace or free a locked cell; if you do, the cell\325) 245.9 387.33 T
(s) 516.48 387.33 T
(item block will not have its lock count decremented, which will prevent the) 180 374.33 T
(block from being unlocked.) 180 361.33 T
81 344.98 531 349.99 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 344.98 531 349.99 R
7 X
0 0 0 1 0 0 0 K
V
50 348.98 609.01 348.98 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 336.98 T
2 F
(CellUnlock\050\051) 99 336.98 T
3 10 Q
(void) 99 322.32 T
4 F
(CellUnlock\050) 153 322.32 T
4 9 Q
(void *) 153 311.98 T
(ptr\051; /* pointer to anywhere in locked cell */) 189 311.98 T
0 10 Q
-0.4 (This routine unlocks the cell pointed to by) 180 294.32 P
6 F
-0.4 (ptr) 373.83 294.32 P
0 F
-0.4 (. Note that a cell may be locked) 386.79 294.32 P
-0.65 (several times. When all locks on all cells in an item-block have been released,) 180 282.82 P
(the block can be swapped back to the disk.) 180 271.32 T
2 F
(Include:) 99 252.82 T
0 F
(cell.h) 180 252.82 T
2 F
(T) 99 232.82 T
(ips and T) 104.93 232.82 T
(ricks:) 148.28 232.82 T
0 F
-0.36 (The DB manager does not keep track of locks on individual items; instead, it) 180 232.82 P
(keeps a count of the total number of locks on all the items in an item-block.) 180 219.82 T
-0.2 (For this reason, only the segment address of the cell is signi\336cant; thus, you) 180 206.82 P
-0.82 (can pass a pointer to somewhere within \050or immediately after\051 a cell to unlock) 180 193.82 P
(it. This is useful if you have incremented the pointer to the cell.) 180 180.82 T
2 F
(Be Sure T) 99 160.82 T
(o:) 144.94 160.82 T
0 F
(If you change the cell, dirty it \050with) 180 160.82 T
5 F
(CellDirty\050\051) 346.12 160.82 T
0 F
(\051) 402.05 160.82 T
6 F
(before) 408.16 160.82 T
0 F
( you unlock it.) 435.37 160.82 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "56" 6
%%Page: "57" 7
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
162 690.34 558 702 R
7 X
0 0 0 1 0 0 0 K
V
162 666.34 558 678.01 R
V
0 10 Q
0 X
(57) 546.88 671.34 T
324 684 580 684 2 L
7 X
V
3 H
2 Z
0 X
N
512 90 558 125 R
7 X
V
1 60 Q
0 X
(n) 512.17 85 T
315 104 510 126 R
7 X
V
2 24 Q
0 X
(Routines) 407.33 110 T
90 99 270 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
90.67 123.5 270.67 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
81 642.99 531 648 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 642.99 531 648 R
7 X
0 0 0 1 0 0 0 K
V
50 646.99 609.01 646.99 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 634.99 T
2 F
(CFatalError\050\051) 99 634.99 T
3 10 Q
(void) 99 620.33 T
4 F
(CFatalError\050) 153 620.33 T
4 9 Q
(word) 153 609.99 T
(code\051) 189 609.99 T
0 10 Q
-0.25 (This routine generates a fatal error) 180 592.33 P
-0.25 (. It stores an error code passed for use by) 341.51 592.33 P
(the debugger) 180 580.83 T
(.) 239.63 580.83 T
81 565.98 531 570.99 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 565.98 531 570.99 R
7 X
0 0 0 1 0 0 0 K
V
50 569.98 609.01 569.98 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 557.98 T
2 F
(ChunkArrayAppend\050\051) 99 557.98 T
3 10 Q
(void *) 99 543.32 T
4 F
(ChunkArrayAppend\050) 153 543.32 T
4 9 Q
(optr) 153 532.98 T
(array,) 189 532.98 T
(/* optr to chunk array */) 315 532.98 T
(word) 153 522.98 T
(elementSize\051) 189 522.98 T
(/* Size of new element \050ignored if) 315 522.98 T
( * elements are uniform-sized\051 */) 315 512.98 T
0 10 Q
-0.68 (This routine adds a new element to the end of a chunk array) 180 495.32 P
-0.68 (. It automatically) 450.23 495.32 P
(expands the chunk to make room for the element and updates the) 180 483.82 T
5 F
(ChunkArrayHeader) 180 472.32 T
0 F
(. It returns a pointer to the new element.) 282.6 472.32 T
(One of the arguments is the size of the new element. This argument is) 180 453.82 T
-0.17 (signi\336cant if the array contains variable-sized elements. If the elements are) 180 442.32 P
(uniform-sized, this argument is ignored. The array is speci\336ed with an optr) 180 430.82 T
(.) 527.24 430.82 T
2 F
(Include:) 99 412.32 T
0 F
(chunkarr) 180 412.32 T
(.h) 222.4 412.32 T
2 F
(Be Sure T) 99 392.32 T
(o:) 144.94 392.32 T
0 F
(Lock the block on the global heap \050if it is not \336xed\051.) 180 392.32 T
2 F
(W) 99 372.32 T
(arnings:) 108.07 372.32 T
0 F
-0.64 (This routine resizes the chunk, which means it can cause heap compaction or) 180 372.32 P
(resizing. Therefore, all existing pointers to within the LMem heap are) 180 359.32 T
(invalidated.) 180 346.32 T
2 F
(See Also:) 99 326.32 T
0 F
(ChunkArrayInsertAt\050\051, ChunkArrayDelete\050\051, ChunkArrayResize\050\051) 180 326.32 T
81 309.98 531 314.98 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 309.98 531 314.98 R
7 X
0 0 0 1 0 0 0 K
V
50 313.98 609.01 313.98 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 301.98 T
2 F
(ChunkArrayAppendHandles\050\051) 99 301.98 T
3 10 Q
(void *) 99 287.31 T
4 F
(ChunkArrayAppendHandles\050) 153 287.31 T
4 9 Q
(MemHandle) 153 276.97 T
(mh,) 261 276.97 T
(/* Handle of LMem heap\325s block */) 333 276.97 T
(ChunkHandle) 153 266.97 T
(ch,) 261 266.97 T
(/* Handle of chunk array */) 333 266.97 T
(word) 153 256.97 T
(size\051) 261 256.97 T
(/* Size of new element \050ignored if) 333 256.97 T
( * elements are uniform-sized\051 */) 333 246.97 T
0 10 Q
(This routine is exactly like) 180 229.31 T
5 F
(ChunkArrayAppend\050\051) 305.95 229.31 T
0 F
(, except that the chunk) 419.11 229.31 T
(array is speci\336ed by its global and local handles instead of by an optr) 180 217.81 T
(.) 497.84 217.81 T
2 F
(Include:) 99 199.31 T
0 F
(chunkarr) 180 199.31 T
(.h) 222.4 199.31 T
2 F
(Be Sure T) 99 179.31 T
(o:) 144.94 179.31 T
0 F
(Lock the block on the global heap \050if it is not \336xed\051.) 180 179.31 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "57" 7
%%Page: "58" 8
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
54 690.34 450 702 R
7 X
0 0 0 1 0 0 0 K
V
54 666.34 450 678.01 R
V
0 10 Q
0 X
(58) 54 671.34 T
32 684 288 684 2 L
7 X
V
3 H
2 Z
0 X
N
54 90 108 125 R
7 X
V
1 60 Q
0 X
(n) 58.17 85 T
104 104 299 126 R
7 X
V
2 24 Q
0 X
(Routines) 104 110 T
306 99 486 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
306 123.5 486 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
2 10 Q
0 X
(W) 99 641.33 T
(arnings:) 108.07 641.33 T
0 F
-0.64 (This routine resizes the chunk, which means it can cause heap compaction or) 180 641.33 P
(resizing. Therefore, all existing pointers to within the LMem heap are) 180 628.33 T
(invalidated.) 180 615.33 T
2 F
(See Also:) 99 595.33 T
0 F
(ChunkArrayInsertAt\050\051, ChunkArrayDelete\050\051, ChunkArrayResize\050\051) 180 595.33 T
81 578.99 531 584 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 578.99 531 584 R
7 X
0 0 0 1 0 0 0 K
V
50 582.99 609.01 582.99 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 570.99 T
2 F
(ChunkArrayCreate\050\051) 99 570.99 T
3 10 Q
(ChunkHandle) 99 556.33 T
4 F
( ChunkArrayCreate\050) 165 556.33 T
4 9 Q
(MemHandle) 153 545.99 T
(mh,) 207 545.99 T
(/* Handle of LMem heap\325s block */) 261 545.99 T
(word) 153 535.99 T
(elementSize,) 189 535.99 T
(/* Size of each element \050or zero if elements are) 261 535.99 T
( * variable-sized\051 */) 261 525.99 T
(word) 153 515.99 T
(headerSize,) 189 515.99 T
(/* Amount of chunk to use for header \050or zero for) 261 515.99 T
( * default size\051 */) 261 505.99 T
(ObjChunkFlags ocf\051;) 153 495.99 T
0 10 Q
(This routine sets up a chunk array in the speci\336ed LMem heap. The heap) 180 478.33 T
(must have already been initialized normally) 180 466.83 T
(. The routine allocates a chunk) 383.37 466.83 T
(and sets up a chunk array in it. It returns the chunk\325) 180 455.33 T
(s handle. If it cannot) 424.65 455.33 T
(create the chunk array) 180 443.83 T
(, it returns a null handle.) 284.63 443.83 T
(If the chunk array will have uniform-size elements, you must specify the) 180 425.33 T
-0.43 (element size when you create the chunk array) 180 413.83 P
-0.43 (. Y) 388.85 413.83 P
-0.43 (ou will not be able to change) 399.9 413.83 P
(this. If the array will have variable-sized elements, pass an element size of) 180 402.33 T
(zero.) 180 390.83 T
(The chunk array always begins with a) 180 372.33 T
5 F
(ChunkArrayHeader) 359.67 372.33 T
0 F
(. Y) 462.27 372.33 T
(ou can) 473.76 372.33 T
(specify the total header size; this is useful if you want to begin the chunk) 180 360.83 T
-0.65 (array with a special header containing some extra data. However) 180 349.33 P
-0.65 (, the header) 474.97 349.33 P
(must be large enough to accommodate a) 180 337.83 T
5 F
(ChunkArrayHeader) 367.62 337.83 T
0 F
(, which will) 470.22 337.83 T
(begin the chunk. If you de\336ne a header structure, make sure that its \336rst) 180 326.33 T
-0.58 (element is a) 180 314.83 P
5 F
-0.6 (ChunkArrayHeader) 236.96 314.83 P
0 F
-0.58 (. Only the chunk array code should access) 339.56 314.83 P
-0.83 (the actual) 180 303.33 P
5 F
-0.86 (ChunkArrayHeader) 227.61 303.33 P
0 F
-0.83 (. If you pass a) 330.21 303.33 P
6 F
-0.83 (headerSize) 392.75 303.33 P
0 F
-0.83 ( of zero, the default) 443.1 303.33 P
-0.61 (header size will be used \050namely) 180 291.83 P
-0.61 (,) 325.88 291.83 P
5 F
-0.63 (sizeof\050ChunkArrayHeader\051) 330.83 291.83 P
0 F
-0.61 (\051. If you pass) 471.76 291.83 P
-0.68 (a non-zero) 180 280.33 P
6 F
-0.68 (headerSize) 229.56 280.33 P
0 F
-0.68 (, any space between the) 279.91 280.33 P
5 F
-0.7 (ChunkArrayHeader) 388.95 280.33 P
0 F
-0.68 ( and the) 492.29 280.33 P
(heap will be zero-initialized.) 180 268.83 T
(T) 180 250.33 T
(o free a chunk array) 185.75 250.33 T
(, call) 278.16 250.33 T
5 F
(LMemFree\050\051) 302.8 250.33 T
0 F
( as you would for any chunk.) 366.87 250.33 T
2 F
(Include:) 99 231.83 T
0 F
(chunkarr) 180 231.83 T
(.h) 222.4 231.83 T
2 F
(Be Sure T) 99 211.83 T
(o:) 144.94 211.83 T
0 F
(Lock the LMem heap\325) 180 211.83 T
(s block on the global heap \050unless it is \336xed\051.) 279.46 211.83 T
2 F
(W) 99 191.83 T
(arnings:) 108.07 191.83 T
0 F
-0.48 (Results are unpredictable if you pass a non-zero) 180 191.83 P
6 F
-0.48 (headerSize) 400.79 191.83 P
0 F
-0.48 ( argument which) 451.14 191.83 P
-0.18 (is smaller than) 180 178.83 P
5 F
-0.19 (sizeof\050ChunkArrayHeader\051) 252.06 178.83 P
0 F
-0.18 (. Since the routine allocates a) 392.99 178.83 P
(chunk, it can cause heap compaction or resizing; all pointers to within the) 180 165.83 T
(block are invalidated.) 180 152.83 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "58" 8
%%Page: "59" 9
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
162 690.34 558 702 R
7 X
0 0 0 1 0 0 0 K
V
162 666.34 558 678.01 R
V
0 10 Q
0 X
(59) 546.88 671.34 T
324 684 580 684 2 L
7 X
V
3 H
2 Z
0 X
N
512 90 558 125 R
7 X
V
1 60 Q
0 X
(n) 512.17 85 T
315 104 510 126 R
7 X
V
2 24 Q
0 X
(Routines) 407.33 110 T
90 99 270 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
90.67 123.5 270.67 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
81 642.99 531 648 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 642.99 531 648 R
7 X
0 0 0 1 0 0 0 K
V
50 646.99 609.01 646.99 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 634.99 T
2 F
(ChunkArrayCreateAt\050\051) 99 634.99 T
3 10 Q
(ChunkHandle) 99 620.33 T
4 F
(ChunkArrayCreateAt\050) 171 620.33 T
4 9 Q
(optr) 153 609.99 T
(array,) 189 609.99 T
(/* Create chunk array in this chunk */) 261 609.99 T
(word) 153 599.99 T
(elementSize,) 189 599.99 T
(/* Size of each element \050or zero if elements are) 261 599.99 T
( * variable-sized\051 */) 261 589.99 T
(word) 153 579.99 T
(headerSize,) 189 579.99 T
(/* Amount of chunk to use for header \050or zero for) 261 579.99 T
( * default size\051 */) 261 569.99 T
(ObjChunkFlags ocf\051;) 153 559.99 T
0 10 Q
(This routine is exactly like) 180 542.33 T
5 F
(ChunkArrayCreate\050\051) 305.95 542.33 T
0 F
(, except that you specify) 413.74 542.33 T
-0.63 (the chunk which will be made into a chunk array) 180 530.83 P
-0.63 (. The chunk is speci\336ed with) 400.31 530.83 P
-0.48 (an optr) 180 519.33 P
-0.48 (. Note that any data already existing in the chunk will be overwritten.) 212.3 519.33 P
2 F
(W) 99 500.83 T
(arnings:) 108.07 500.83 T
0 F
-0.8 (The chunk may be resized, which invalidates all pointers to within the LMem) 180 500.83 P
(heap.) 180 487.83 T
2 F
(Include:) 99 467.83 T
0 F
(chunkarr) 180 467.83 T
(.h) 222.4 467.83 T
81 451.48 531 456.49 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 451.48 531 456.49 R
7 X
0 0 0 1 0 0 0 K
V
50 455.48 609.01 455.48 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 443.48 T
2 F
(ChunkArrayCreateAtHandles\050\051) 99 443.48 T
4 10 Q
(ChunkHandle) 99 428.82 T
(ChunkArrayCreateAtHandles\050) 171 428.82 T
4 9 Q
(MemHandle) 153 418.48 T
(mh,) 261 418.48 T
(ChunkHandle) 153 408.48 T
(ch,) 261 408.48 T
(word) 153 398.48 T
(elementSize,) 261 398.48 T
(word) 153 388.48 T
(headerSize,) 261 388.48 T
(ObjChunkFlags) 153 378.48 T
(ocf\051;) 261 378.48 T
0 10 Q
-0.23 (This routine is exactly like) 180 360.82 P
5 F
-0.24 (ChunkArrayCreate\050\051) 304.78 360.82 P
0 F
-0.23 (, except that the chunk is) 412.57 360.82 P
(speci\336ed with its global and chunk handles instead of with an optr) 180 349.32 T
(.) 486.53 349.32 T
2 F
(T) 99 330.82 T
(ips and T) 104.93 330.82 T
(ricks:) 148.28 330.82 T
0 F
(If you pass a null chunk handle, a new chunk will be allocated.) 180 330.82 T
2 F
(W) 99 310.82 T
(arnings:) 108.07 310.82 T
0 F
-0.27 (The chunk may be resized, which would invalidate all pointers to within the) 180 310.82 P
(LMem heap.) 180 297.82 T
2 F
(Include:) 99 277.82 T
0 F
(chunkarr) 180 277.82 T
(.h) 222.4 277.82 T
81 261.48 531 266.48 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 261.48 531 266.48 R
7 X
0 0 0 1 0 0 0 K
V
50 265.48 609.01 265.48 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 253.47 T
2 F
(ChunkArrayDelete\050\051) 99 253.47 T
3 10 Q
(void) 99 238.81 T
4 F
(ChunkArrayDelete\050) 153 238.81 T
4 9 Q
(optr) 153 228.47 T
(array,) 189 228.47 T
(/* optr to chunk array */) 315 228.47 T
(void) 153 218.47 T
3 F
( *) 174.6 218.47 T
4 F
(element\051;) 189 218.47 T
(/* Address of element to delete */) 315 218.47 T
0 10 Q
-0.29 (This routine deletes an element from a chunk array) 180 200.81 P
-0.29 (. It is passed the address) 415.49 200.81 P
(of that element, as well as the optr of the array) 180 189.31 T
(.) 396.52 189.31 T
(Since the chunk is being decreased in size, the routine is guaranteed not to) 180 170.81 T
(cause heap compaction or resizing.) 180 159.31 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "59" 9
%%Page: "60" 10
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
54 690.34 450 702 R
7 X
0 0 0 1 0 0 0 K
V
54 666.34 450 678.01 R
V
0 10 Q
0 X
(60) 54 671.34 T
32 684 288 684 2 L
7 X
V
3 H
2 Z
0 X
N
54 90 108 125 R
7 X
V
1 60 Q
0 X
(n) 58.17 85 T
104 104 299 126 R
7 X
V
2 24 Q
0 X
(Routines) 104 110 T
306 99 486 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
306 123.5 486 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
2 10 Q
0 X
(Include:) 99 641.33 T
0 F
(chunkarr) 180 641.33 T
(.h) 222.4 641.33 T
2 F
(Be Sure T) 99 621.33 T
(o:) 144.94 621.33 T
0 F
(Lock the LMem heap\325) 180 621.33 T
(s block on the global heap \050unless it is \336xed\051.) 279.46 621.33 T
2 F
(T) 99 601.33 T
(ips and T) 104.93 601.33 T
(ricks:) 148.28 601.33 T
0 F
-0.35 (Only the chunk handle portion of the optr is signi\336cant; the memory block is) 180 601.33 P
(determined from the pointer to the element.) 180 588.33 T
2 F
(W) 99 568.33 T
(arnings:) 108.07 568.33 T
0 F
(The addresses of all elements after the deleted one will change. No other) 180 568.33 T
(addresses in the block will be affected. If the address passed is not the) 180 555.33 T
(address of an element in the array) 180 542.33 T
(, results are unde\336ned.) 337.98 542.33 T
2 F
(See Also:) 99 522.33 T
0 F
(ChunkArrayAppend\050\051, ChunkArrayInsertAt\050\051, ChunkArrayResize\050\051,) 180 522.33 T
(ChunkArrayZero\050\051) 180 509.33 T
81 492.99 531 498 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 492.99 531 498 R
7 X
0 0 0 1 0 0 0 K
V
50 496.99 609.01 496.99 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 484.99 T
2 F
(ChunkArrayDeleteHandle\050\051) 99 484.99 T
3 10 Q
(void) 99 470.33 T
4 F
(ChunkArrayDeleteHandle\050) 153 470.33 T
4 9 Q
(ChunkHandle) 153 459.99 T
(ch,) 261 459.99 T
(/* Handle of chunk array */) 333 459.99 T
(void *) 153 449.99 T
(el\051;) 261 449.99 T
(/* Address of element to delete */) 333 449.99 T
0 10 Q
(This routine is exactly like) 180 432.33 T
5 F
(ChunkArrayDelete\050\051) 305.95 432.33 T
0 F
(, except that the chunk) 412.25 432.33 T
(array is speci\336ed with its chunk handle instead of with an optr) 180 420.83 T
(. The global) 469.85 420.83 T
-0.22 (memory handle is not needed, as the memory block is implicit in the pointer) 180 409.33 P
(to the element.) 180 397.83 T
2 F
(Be Sure T) 99 379.33 T
(o:) 144.94 379.33 T
0 F
(Lock the LMem heap\325) 180 379.33 T
(s block on the global heap \050unless it is \336xed\051.) 279.46 379.33 T
2 F
(Include:) 99 359.33 T
0 F
(chunkarr) 180 359.33 T
(.h) 222.4 359.33 T
81 342.98 531 347.99 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 342.98 531 347.99 R
7 X
0 0 0 1 0 0 0 K
V
50 346.98 609.01 346.98 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 334.98 T
2 F
(ChunkArrayDeleteRange\050\051) 99 334.98 T
3 10 Q
(void) 99 320.32 T
4 F
(ChunkArrayDeleteRange\050) 153 320.32 T
4 9 Q
(optr) 153 309.98 T
(array,) 189 309.98 T
(/* optr to chunk array */) 279 309.98 T
(word) 153 299.98 T
(firstElement,) 189 299.98 T
(/* index of first element to delete */) 279 299.98 T
(word) 153 289.98 T
(count\051;) 189 289.98 T
(/* # of elements to delete \050-1 to delete to) 279 289.98 T
( * end of array\051 */) 279 279.98 T
0 10 Q
(This routine deletes several consecutive elements from a chunk array) 180 262.32 T
(. The) 499.83 262.32 T
-0.51 (routine is passed the optr of the chunk array) 180 250.82 P
-0.51 (, the index of the \336rst element to) 381.33 250.82 P
-0.05 (delete, and the number of elements to delete. The routine is guaranteed not) 180 239.32 P
-0.31 (to cause heap compaction or resizing; thus, pointers to other elements in the) 180 227.82 P
(array will remain valid.) 180 216.32 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "60" 10
%%Page: "61" 11
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
162 690.34 558 702 R
7 X
0 0 0 1 0 0 0 K
V
162 666.34 558 678.01 R
V
0 10 Q
0 X
(61) 546.88 671.34 T
324 684 580 684 2 L
7 X
V
3 H
2 Z
0 X
N
512 90 558 125 R
7 X
V
1 60 Q
0 X
(n) 512.17 85 T
315 104 510 126 R
7 X
V
2 24 Q
0 X
(Routines) 407.33 110 T
90 99 270 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
90.67 123.5 270.67 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
81 642.99 531 648 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 642.99 531 648 R
7 X
0 0 0 1 0 0 0 K
V
50 646.99 609.01 646.99 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 634.99 T
2 F
(ChunkArrayElementResize\050\051) 99 634.99 T
3 10 Q
(void) 99 620.33 T
4 F
(ChunkArrayElementResize\050) 153 620.33 T
4 9 Q
(optr) 153 609.99 T
(array,) 189 609.99 T
(/* optr to chunk array */) 315 609.99 T
(word) 153 599.99 T
(element,) 189 599.99 T
(/* Index of element to resize */) 315 599.99 T
(word) 153 589.99 T
(newSize\051;) 189 589.99 T
(/* New size of element, in bytes */) 315 589.99 T
0 10 Q
-0.75 (This routine resizes an element in a chunk array) 180 572.33 P
-0.75 (. The chunk array must have) 398.64 572.33 P
(variable-sized elements. The routine is passed an optr to the chunk array) 180 560.83 T
-0.65 (\050which must be locked on the global heap\051, as well as the index of the element) 180 549.33 P
(to resize and the new size \050in bytes\051. It does not return anything.) 180 537.83 T
(If the new size is larger than the old, null bytes will be added to the end of) 180 519.33 T
(the element. If the new size is smaller than the old, bytes will be removed) 180 507.83 T
(from the end to truncate the element to the new size.) 180 496.33 T
2 F
(W) 99 477.83 T
(arnings:) 108.07 477.83 T
0 F
-0.45 (If the element is resized larger) 180 477.83 P
-0.45 (, the chunk array may move within the LMem) 318.88 477.83 P
(heap, and the heap itself may move on the global heap; thus, all pointers to) 180 464.83 T
(within the LMem heap will be invalidated.) 180 451.83 T
2 F
(Be Sure T) 99 431.83 T
(o:) 144.94 431.83 T
0 F
(Lock the LMem heap\325) 180 431.83 T
(s block on the global heap \050unless it is \336xed\051.) 279.46 431.83 T
2 F
(Include:) 99 411.83 T
0 F
(chunkarr) 180 411.83 T
(.h) 222.4 411.83 T
81 395.48 531 400.49 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 395.48 531 400.49 R
7 X
0 0 0 1 0 0 0 K
V
50 399.48 609.01 399.48 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 387.48 T
2 F
(ChunkArrayElementResizeHandles\050\051) 99 387.48 T
3 10 Q
(void) 99 372.82 T
4 F
(ChunkArrayElementResizeHandles\050) 153 372.82 T
4 9 Q
(Memhandle) 153 362.48 T
(mh,) 261 362.48 T
(/* Global handle of LMem heap */) 333 362.48 T
(ChunkHandle) 153 352.48 T
(ch,) 261 352.48 T
(/* Chunk handle of chunk array */) 333 352.48 T
(word) 153 342.48 T
(el,) 261 342.48 T
(/* Index of element to resize */) 333 342.48 T
(word) 153 332.48 T
(ns\051;) 261 332.48 T
(/* New size of element, in bytes */) 333 332.48 T
0 10 Q
(This routine is exactly like) 180 314.82 T
5 F
(ChunkArrayElementResize\050\051) 305.95 314.82 T
0 F
( except that the) 455.95 314.82 T
(chunk array is speci\336ed with its global and chunk handles, instead of with) 180 303.32 T
(its optr) 180 291.82 T
(.) 212.78 291.82 T
2 F
(W) 99 273.32 T
(arnings:) 108.07 273.32 T
0 F
(If the element is resized to larger than the old, the chunk array may move) 180 273.32 T
(within the LMem heap, and the heap itself may move on the global heap;) 180 260.32 T
(thus, all pointers to within the LMem heap will be invalidated.) 180 247.32 T
2 F
(Be Sure T) 99 227.32 T
(o:) 144.94 227.32 T
0 F
(Lock the LMem heap\325) 180 227.32 T
(s block on the global heap \050unless it is \336xed\051.) 279.46 227.32 T
2 F
(Include:) 99 207.32 T
0 F
(chunkarr) 180 207.32 T
(.h) 222.4 207.32 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "61" 11
%%Page: "62" 12
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
54 690.34 450 702 R
7 X
0 0 0 1 0 0 0 K
V
54 666.34 450 678.01 R
V
0 10 Q
0 X
(62) 54 671.34 T
32 684 288 684 2 L
7 X
V
3 H
2 Z
0 X
N
54 90 108 125 R
7 X
V
1 60 Q
0 X
(n) 58.17 85 T
104 104 299 126 R
7 X
V
2 24 Q
0 X
(Routines) 104 110 T
306 99 486 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
306 123.5 486 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
81 642.99 531 648 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 642.99 531 648 R
7 X
0 0 0 1 0 0 0 K
V
50 646.99 609.01 646.99 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 634.99 T
2 F
(ChunkArrayElementT) 99 634.99 T
(oPtr\050\051) 220.8 634.99 T
3 10 Q
(void *) 99 620.33 T
4 F
(ChunkArrayElementToPtr\050) 153 620.33 T
4 9 Q
(optr) 153 609.99 T
(array,) 261 609.99 T
(/* optr to chunk array */) 351 609.99 T
(word) 153 599.99 T
(elementNumber,) 261 599.99 T
(/* Element to get address of */) 351 599.99 T
(void *) 153 589.99 T
(elementSize\051;) 261 589.99 T
(/* Write element\325s size here */) 351 589.99 T
0 10 Q
(This routine translates the index of an element into the element\325) 180 572.33 T
(s address.) 478.19 572.33 T
-0.28 (The routine is passed an optr to the chunk array) 180 560.83 P
-0.28 (, the index of the element in) 400.69 560.83 P
(question, and a pointer to a word-sized variable. It returns a pointer to the) 180 549.33 T
-0.33 (element. If the elements in the array are of variable size, it writes the size of) 180 537.83 P
(the element to the variable pointed to by the) 180 526.33 T
6 F
(elementSize) 388.19 526.33 T
0 F
( pointer) 442.43 526.33 T
(. If the) 477.8 526.33 T
(elements are of uniform size, it does not do this.) 180 514.83 T
(If the array index is out of bounds, the routine returns a pointer to the last) 180 496.33 T
(element in the array) 180 484.83 T
(. The routine will also do this if you pass the constant) 273.9 484.83 T
0 9 Q
(CA_LAST_ELEMENT) 180 473.33 T
0 10 Q
(.) 272.58 473.33 T
2 F
(Include:) 99 454.83 T
0 F
(chunkarr) 180 454.83 T
(.h) 222.4 454.83 T
2 F
(T) 99 434.83 T
(ips and T) 104.93 434.83 T
(ricks:) 148.28 434.83 T
0 F
-0.54 (If you are not interested in the element\325) 180 434.83 P
-0.54 (s size, pass a null pointer as the third) 359.37 434.83 P
(argument.) 180 421.83 T
2 F
(Be Sure T) 99 401.83 T
(o:) 144.94 401.83 T
0 F
(Lock the LMem heap\325) 180 401.83 T
(s block on the global heap \050unless it is \336xed\051.) 279.46 401.83 T
2 F
(W) 99 381.83 T
(arnings:) 108.07 381.83 T
0 F
(The error) 180 381.83 T
(-checking version fatal-errors if passed the index) 223.7 381.83 T
0 9 Q
(CA_NULL_ELEMENT) 180 368.83 T
0 10 Q
( \050i.e. 0xffff, or -1\051.) 276 368.83 T
81 352.48 531 357.49 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 352.48 531 357.49 R
7 X
0 0 0 1 0 0 0 K
V
50 356.48 609.01 356.48 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 344.48 T
2 F
(ChunkArrayElementT) 99 344.48 T
(oPtrHandles\050\051) 220.8 344.48 T
3 10 Q
(void *) 99 329.82 T
4 F
(ChunkArrayElementToPtrHandles\050) 153 329.82 T
4 9 Q
(Memhandle) 153 319.48 T
(mh,) 261 319.48 T
(/* Handle of LMem heap\325s block */) 351 319.48 T
(ChunkHandle) 153 309.48 T
(chunk,) 261 309.48 T
(/* Handle of chunk array */) 351 309.48 T
(word) 153 299.48 T
(elementNumber,) 261 299.48 T
(/* Element to get address of */) 351 299.48 T
(void *) 153 289.48 T
(elementSize\051;) 261 289.48 T
(/* Write element\325s size here */) 351 289.48 T
0 10 Q
(This routine is just like) 180 271.82 T
5 F
(ChunkArrayElementT) 290.76 271.82 T
(oPtr\050\051) 405.58 271.82 T
0 F
(, except that the) 436.51 271.82 T
(chunk array is speci\336ed with its global and chunk handles, instead of with) 180 260.32 T
(an optr) 180 248.82 T
(.) 212.78 248.82 T
2 F
(Include:) 99 230.32 T
0 F
(chunkarr) 180 230.32 T
(.h) 222.4 230.32 T
2 F
(T) 99 210.32 T
(ips and T) 104.93 210.32 T
(ricks:) 148.28 210.32 T
0 F
(If you are not interested in the element\325) 180 210.32 T
(s size, pass a null pointer as the) 363.16 210.32 T
(fourth argument.) 180 197.32 T
2 F
(Be Sure T) 99 177.32 T
(o:) 144.94 177.32 T
0 F
(Lock the LMem heap\325) 180 177.32 T
(s block on the global heap \050unless it is \336xed\051.) 279.46 177.32 T
2 F
(See Also:) 99 157.32 T
0 F
(ChunkArrayPtrT) 180 157.32 T
(oElement\050\051) 259.26 157.32 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "62" 12
%%Page: "63" 13
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
162 690.34 558 702 R
7 X
0 0 0 1 0 0 0 K
V
162 666.34 558 678.01 R
V
0 10 Q
0 X
(63) 546.88 671.34 T
324 684 580 684 2 L
7 X
V
3 H
2 Z
0 X
N
512 90 558 125 R
7 X
V
1 60 Q
0 X
(n) 512.17 85 T
315 104 510 126 R
7 X
V
2 24 Q
0 X
(Routines) 407.33 110 T
90 99 270 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
90.67 123.5 270.67 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
2 10 Q
0 X
(W) 99 641.33 T
(arnings:) 108.07 641.33 T
0 F
(The error) 180 641.33 T
(-checking version fatal-errors if passed the index) 223.7 641.33 T
0 9 Q
(CA_NULL_ELEMENT) 180 628.33 T
0 10 Q
( \050i.e. 0xffff, or -1\051.) 276 628.33 T
81 611.99 531 617 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 611.99 531 617 R
7 X
0 0 0 1 0 0 0 K
V
50 615.99 609.01 615.99 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 603.99 T
2 F
(ChunkArrayEnum\050\051) 99 603.99 T
3 10 Q
(Boolean) 99 589.33 T
4 F
(ChunkArrayEnum\050) 153 589.33 T
4 9 Q
(optr) 153 578.99 T
(array,) 261 578.99 T
(/* optr to chunk array */) 315 578.99 T
(void *) 153 568.99 T
(enumData,) 261 568.99 T
(/* This is passed to callback routine */) 315 568.99 T
(Boolean _pascal \050*callback\051 \050void *element, void *enumData\051\051;) 153 558.99 T
(/* callback called for each element; returns TRUE to stop */) 189 548.99 T
0 10 Q
(This routine lets you apply a procedure to every element in a chunk array) 180 531.33 T
(.) 519.47 531.33 T
(The routine is passed an optr to the callback routine, a pointer \050which is) 180 519.83 T
(passed to the callback routine\051, and a pointer to a Boolean callback routine.) 180 508.33 T
-0.69 (The callback routine, in turn, is called once for each element in the array) 180 496.83 P
-0.69 (, and) 506.63 496.83 P
-0.3 (is passed two arguments: a pointer to an element and the pointer which was) 180 485.33 P
-0.55 (passed to) 180 473.83 P
5 F
-0.57 (ChunkArrayEnum\050\051) 224.65 473.83 P
0 F
-0.55 (. If the callback routine ever returns) 328.54 473.83 P
6 F
-0.55 (true) 495.26 473.83 P
0 F
-0.55 ( for) 513.77 473.83 P
(an element,) 180 462.33 T
5 F
(ChunkArrayEnum) 237.05 462.33 T
0 F
( will stop with that element and return) 333.16 462.33 T
6 F
(true) 180 450.83 T
0 F
(. If it enumerates every element without being aborted, it returns) 198.51 450.83 T
6 F
(false) 503.91 450.83 T
0 F
(.) 525.19 450.83 T
(The callback routine can call such routines as) 180 432.33 T
5 F
(ChunkArrayAppend\050\051,) 393.73 432.33 T
(ChunkArrayInsertAt\050\051,) 180 420.83 T
0 F
( and) 299.08 420.83 T
5 F
(ChunkArrayDelete\050\051) 322.05 420.83 T
0 F
(.) 428.35 420.83 T
5 F
-0.87 (ChunkArrayEnum\050\051) 180 409.33 P
0 F
-0.84 ( will see to it that every element is enumerated exactly) 283.89 409.33 P
(once. The callback routine can even make a nested call to) 180 397.83 T
5 F
(ChunkArrayEnum\050\051) 180 386.33 T
0 F
(; the nested call will be completed for every element) 283.89 386.33 T
-0.47 (before the outer call goes to the next element. The callback routine should be) 180 374.83 P
(declared _pascal.) 180 363.33 T
2 F
(Include:) 99 344.83 T
0 F
(chunkarr) 180 344.83 T
(.h) 222.4 344.83 T
2 F
(Be Sure T) 99 324.83 T
(o:) 144.94 324.83 T
0 F
(Lock the LMem heap\325) 180 324.83 T
(s block on the global heap \050unless it is \336xed\051.) 279.46 324.83 T
81 308.48 531 313.49 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 308.48 531 313.49 R
7 X
0 0 0 1 0 0 0 K
V
50 312.48 609.01 312.48 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 300.48 T
2 F
(ChunkArrayEnumHandles\050\051) 99 300.48 T
3 10 Q
(Boolean) 99 285.82 T
4 F
(ChunkArrayEnumHandles\050) 153 285.82 T
4 9 Q
(MemHandle) 153 275.48 T
(mh,) 261 275.48 T
(/* Handle of LMem heap\325s block */) 315 275.48 T
(ChunkHandle) 153 265.48 T
(ch,) 261 265.48 T
(/* Handle of chunk array */) 315 265.48 T
(void *) 153 255.48 T
(enumData,) 261 255.48 T
(/* Buffer used by callback routine */) 315 255.48 T
(Boolean _pascal \050*callback\051 \050void *element, void *enumData\051\051;) 153 245.48 T
(/* callback called for each element; returns TRUE to stop */) 189 235.48 T
0 10 Q
(This routine is exactly like) 180 217.82 T
5 F
(ChunkArrayEnum\050\051) 305.95 217.82 T
0 F
(, except that the chunk) 409.84 217.82 T
(array is speci\336ed by its global and chunk handles \050instead of with an optr\051.) 180 206.32 T
2 F
(Include:) 99 187.82 T
0 F
(chunkarr) 180 187.82 T
(.h) 222.4 187.82 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "63" 13
%%Page: "64" 14
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
54 690.34 450 702 R
7 X
0 0 0 1 0 0 0 K
V
54 666.34 450 678.01 R
V
0 10 Q
0 X
(64) 54 671.34 T
32 684 288 684 2 L
7 X
V
3 H
2 Z
0 X
N
54 90 108 125 R
7 X
V
1 60 Q
0 X
(n) 58.17 85 T
104 104 299 126 R
7 X
V
2 24 Q
0 X
(Routines) 104 110 T
306 99 486 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
306 123.5 486 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
81 642.99 531 648 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 642.99 531 648 R
7 X
0 0 0 1 0 0 0 K
V
50 646.99 609.01 646.99 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 634.99 T
2 F
(ChunkArrayEnumRange\050\051) 99 634.99 T
3 10 Q
(Boolean) 99 620.33 T
4 F
(ChunkArrayEnumRange\050) 153 620.33 T
4 9 Q
(optr) 153 609.99 T
(array,) 189 609.99 T
(/* optr to chunk array */) 261 609.99 T
(word) 153 599.99 T
(startElement,) 189 599.99 T
(/* Start enumeration with this element */) 261 599.99 T
(word) 153 589.99 T
(count,) 189 589.99 T
(/* Process this many elements */) 261 589.99 T
(void *) 153 579.99 T
(enumData,) 189 579.99 T
(/* This is passed to the callback routine */) 261 579.99 T
(Boolean _pascal \050*callback\051) 153 569.99 T
(/* Return TRUE to halt enumeration */) 298.8 569.99 T
(\050void *element, void *enumData\051\051;) 189 559.99 T
0 10 Q
(This routine is exactly like) 180 542.33 T
5 F
(ChunkArrayEnum\050\051) 305.95 542.33 T
0 F
( \050described above\051, except) 409.84 542.33 T
(that it acts on a limited portion of the array) 180 530.83 T
(. It is passed two additional) 380.59 530.83 T
-0.45 (arguments: the index of the starting element, and the number of elements to) 180 519.33 P
-0.57 (process. It will begin the enumeration with the element speci\336ed \050remember) 180 507.83 P
-0.57 (,) 526.01 507.83 P
(the \336rst element in a chunk array has an index of zero\051. If the count passed) 180 496.33 T
(would take the enumeration past the end of the array) 180 484.83 T
(,) 426.7 484.83 T
5 F
-0.17 (ChunkArrayEnumRange\050\051) 180 473.33 P
0 F
-0.16 ( will automatically stop with the last element.) 316.85 473.33 P
(Y) 180 461.83 T
(ou can instruct) 185.93 461.83 T
5 F
(ChunkArrayEnumRange\050\051) 258.15 461.83 T
0 F
( to process all elements by) 395 461.83 T
(passing a) 180 450.33 T
6 F
(count) 226.31 450.33 T
0 F
( of) 251.49 450.33 T
0 9 Q
(CA_LAST_ELEMENT) 265.38 450.33 T
0 10 Q
(.) 357.96 450.33 T
2 F
(Include:) 99 431.83 T
0 F
(chunkarr) 180 431.83 T
(.h) 222.4 431.83 T
2 F
(W) 99 411.83 T
(arnings:) 108.07 411.83 T
0 F
(The start element must be within the bounds of the array) 180 411.83 T
(.) 445.04 411.83 T
2 F
(See Also:) 99 391.83 T
0 F
(ChunkArrayEnum\050\051) 180 391.83 T
81 375.48 531 380.49 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 375.48 531 380.49 R
7 X
0 0 0 1 0 0 0 K
V
50 379.48 609.01 379.48 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 367.48 T
2 F
(ChunkArrayEnumRangeHandles\050\051) 99 367.48 T
3 10 Q
(Boolean) 99 352.82 T
4 F
(ChunkArrayEnumRangeHandles\050) 153 352.82 T
4 9 Q
(MemHandle) 153 342.48 T
(mh,) 207 342.48 T
(/* Handle of LMem heap\325s block */) 261 342.48 T
(ChunkHandle) 153 332.48 T
(ch,) 217.8 332.48 T
(/* Handle of chunk array */) 261 332.48 T
(word) 153 322.48 T
(startElement,) 189 322.48 T
(/* Start enumeration with this element */) 261 322.48 T
(word) 153 312.48 T
(count,) 189 312.48 T
(/* Process this many elements */) 261 312.48 T
(void *) 153 302.48 T
(enumData,) 189 302.48 T
(/* This is passed to the callback routine */) 261 302.48 T
(Boolean _pascal \050*callback\051) 153 292.48 T
(/* Return TRUE to halt enumeration */) 298.8 292.48 T
(\050void *element, void *enumData\051\051;) 189 282.48 T
0 10 Q
(This routine is exactly like) 180 264.82 T
5 F
(ChunkArrayEnumRange\050\051) 305.95 264.82 T
0 F
(, except that the) 442.8 264.82 T
-0.05 (chunk array is speci\336ed by its global and chunk handles \050instead of with an) 180 253.32 P
(optr\051.) 180 241.82 T
81 226.98 531 231.98 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 226.98 531 231.98 R
7 X
0 0 0 1 0 0 0 K
V
50 230.98 609.01 230.98 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 218.97 T
2 F
(ChunkArrayGetCount\050\051) 99 218.97 T
3 10 Q
(word) 99 204.31 T
4 F
(ChunkArrayGetCount\050) 153 204.31 T
4 9 Q
(optr) 153 193.97 T
(array\051;) 189 193.97 T
(/* optr of chunk array */) 315 193.97 T
0 10 Q
(This routine returns the number of elements in the speci\336ed chunk array) 180 176.31 T
(.) 517.6 176.31 T
2 F
(Include:) 99 157.81 T
0 F
(chunkarr) 180 157.81 T
(.h) 222.4 157.81 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "64" 14
%%Page: "65" 15
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
162 690.34 558 702 R
7 X
0 0 0 1 0 0 0 K
V
162 666.34 558 678.01 R
V
0 10 Q
0 X
(65) 546.88 671.34 T
324 684 580 684 2 L
7 X
V
3 H
2 Z
0 X
N
512 90 558 125 R
7 X
V
1 60 Q
0 X
(n) 512.17 85 T
315 104 510 126 R
7 X
V
2 24 Q
0 X
(Routines) 407.33 110 T
90 99 270 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
90.67 123.5 270.67 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
2 10 Q
0 X
(T) 99 641.33 T
(ips and T) 104.93 641.33 T
(ricks:) 148.28 641.33 T
0 F
(It is usually faster to examine the) 180 641.33 T
6 9 Q
(CAH) 339.1 641.33 T
6 10 Q
(_count) 359.43 641.33 T
0 F
( \336eld of the) 389.61 641.33 T
5 F
(ChunkArrayHeader) 180 628.33 T
0 F
(. This \336eld is the \336rst word of the) 282.6 628.33 T
5 F
(ChunkArrayHeader) 180 615.33 T
0 F
( \050and therefore of the chunk\051. It contains the number) 283.34 615.33 T
(of elements in the chunk array) 180 602.33 T
(.) 321.12 602.33 T
2 F
(Be Sure T) 99 582.33 T
(o:) 144.94 582.33 T
0 F
(Lock the LMem heap\325) 180 582.33 T
(s block on the global heap \050unless it is \336xed\051.) 279.46 582.33 T
2 F
(See Also:) 99 562.33 T
0 F
(ChunkArrayHeader) 180 562.33 T
81 545.99 531 551 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 545.99 531 551 R
7 X
0 0 0 1 0 0 0 K
V
50 549.99 609.01 549.99 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 537.99 T
2 F
(ChunkArrayGetCountHandles\050\051) 99 537.99 T
3 10 Q
(word) 99 523.33 T
4 F
(ChunkArrayGetCountHandles\050) 153 523.33 T
4 9 Q
(MemHandle) 153 512.99 T
(mh,) 261 512.99 T
(/* Handle of LMem heap\325s block */) 333 512.99 T
(ChunkHandle) 153 502.99 T
(ch\051;) 261 502.99 T
(/* Handle of chunk array */) 333 502.99 T
0 10 Q
(This routine is just like) 180 485.33 T
5 F
(ChunkArrayGetCount\050\051) 290.76 485.33 T
0 F
(, except that the chunk) 413.91 485.33 T
(array is speci\336ed by its global and local handles \050instead of with an optr\051.) 180 473.83 T
2 F
(Include:) 99 455.33 T
0 F
(chunkarr) 180 455.33 T
(.h) 222.4 455.33 T
81 438.98 531 443.99 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 438.98 531 443.99 R
7 X
0 0 0 1 0 0 0 K
V
50 442.98 609.01 442.98 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 430.98 T
2 F
(ChunkArrayGetElement\050\051) 99 430.98 T
3 10 Q
(void) 99 416.32 T
4 F
(ChunkArrayGetElement\050) 153 416.32 T
4 9 Q
(optr) 153 405.98 T
(array,) 189 405.98 T
(/* optr to chunk array */) 333 405.98 T
(word) 153 395.98 T
(elementNumber,) 189 395.98 T
(/* Index of element to copy */) 333 395.98 T
(void *) 153 385.98 T
(buffer\051;) 189 385.98 T
(/* Address to copy element to */) 333 385.98 T
0 10 Q
-0.04 (This routine copies an element in a chunk array into the passed buffer) 180 368.32 P
-0.04 (. It is) 504.24 368.32 P
(your responsibility to make sure the buffer is large enough to hold the) 180 356.82 T
(element.) 180 345.32 T
2 F
(Include:) 99 326.82 T
0 F
(chunkarr) 180 326.82 T
(.h) 222.4 326.82 T
2 F
(Be Sure T) 99 306.82 T
(o:) 144.94 306.82 T
0 F
-0.6 (Lock the LMem heap\325) 180 306.82 P
-0.6 (s block on the global heap \050unless it is \336xed\051. Make sure) 277.65 306.82 P
(the buffer is large enough to hold the element.) 180 293.82 T
2 F
(See Also:) 99 273.82 T
0 F
(ChunkArrayPtrT) 180 273.82 T
(oElement\050\051, ChunkArrayElementT) 259.26 273.82 T
(oPtr\050\051) 419.26 273.82 T
81 257.48 531 262.48 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 257.48 531 262.48 R
7 X
0 0 0 1 0 0 0 K
V
50 261.48 609.01 261.48 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 249.47 T
2 F
(ChunkArrayGetElementHandles\050\051) 99 249.47 T
3 10 Q
(void) 99 234.81 T
4 F
(ChunkArrayGetElementHandles\050) 153 234.81 T
4 9 Q
(Memhandle) 153 224.47 T
(mh,) 261 224.47 T
(/* Handle of LMem heap\325s block */) 351 224.47 T
(ChunkHandle) 153 214.47 T
(array,) 261 214.47 T
(/* Handle of chunk array */) 351 214.47 T
(word) 153 204.47 T
(elementNumber,) 261 204.47 T
(/* Index of element to copy */) 351 204.47 T
(void *) 153 194.47 T
(buffer\051;) 261 194.47 T
(/* Address to copy element to */) 351 194.47 T
0 10 Q
-0.37 (This routine is just like) 180 176.81 P
5 F
-0.38 (ChunkArrayGetElement\050\051) 288.93 176.81 P
0 F
-0.37 (, except that the chunk) 423.56 176.81 P
(array is speci\336ed by its global and chunk handles \050instead of with an optr\051.) 180 165.31 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "65" 15
%%Page: "66" 16
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
54 690.34 450 702 R
7 X
0 0 0 1 0 0 0 K
V
54 666.34 450 678.01 R
V
0 10 Q
0 X
(66) 54 671.34 T
32 684 288 684 2 L
7 X
V
3 H
2 Z
0 X
N
54 90 108 125 R
7 X
V
1 60 Q
0 X
(n) 58.17 85 T
104 104 299 126 R
7 X
V
2 24 Q
0 X
(Routines) 104 110 T
306 99 486 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
306 123.5 486 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
2 10 Q
0 X
(Include:) 99 641.33 T
0 F
(chunkarr) 180 641.33 T
(.h) 222.4 641.33 T
2 F
(Be Sure T) 99 621.33 T
(o:) 144.94 621.33 T
0 F
-0.6 (Lock the LMem heap\325) 180 621.33 P
-0.6 (s block on the global heap \050unless it is \336xed\051. Make sure) 277.65 621.33 P
(the buffer is large enough to hold the element.) 180 608.33 T
2 F
(See Also:) 99 588.33 T
0 F
(ChunkArrayPtrT) 180 588.33 T
(oElement\050\051, ChunkArrayElementT) 259.26 588.33 T
(oPtr\050\051) 419.26 588.33 T
81 571.99 531 577 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 571.99 531 577 R
7 X
0 0 0 1 0 0 0 K
V
50 575.99 609.01 575.99 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 563.99 T
2 F
(ChunkArrayInsertAt\050\051) 99 563.99 T
3 10 Q
(void *) 99 549.33 T
4 F
(ChunkArrayInsertAt\050) 153 549.33 T
4 9 Q
(optr) 153 538.99 T
(array,) 261 538.99 T
(/* Handle of chunk array */) 333 538.99 T
(void *) 153 528.99 T
(insertPointer,) 261 528.99 T
(/* Address at which to insert) 336.6 528.99 T
( * element */) 333 518.99 T
(word) 153 508.99 T
(elementSize\051;) 261 508.99 T
(/* Size of new element \050ignored) 333 508.99 T
( * if elements are uniform-sized\051 */) 333 498.99 T
0 10 Q
-0.43 (This routine inserts a new element in a chunk array) 180 481.33 P
-0.43 (. Y) 416.49 481.33 P
-0.43 (ou specify the location) 427.55 481.33 P
(by passing a pointer to an element. A new element will be allocated at that) 180 469.83 T
-0.46 (location; thus, the element which was pointed to will be shifted, so it ends up) 180 458.33 P
-0.42 (immediately after the new element. The new element will be zero-initialized.) 180 446.83 P
(The routine is passed three arguments: the optr of the array) 180 428.33 T
(, the address) 457.24 428.33 T
-0.09 (where the new element should be inserted, and the size of the new element.) 180 416.83 P
-0.11 (\050If the array is of uniform-size elements, the size argument will be ignored.\051) 180 405.33 P
2 F
(Include:) 99 386.83 T
0 F
(chunkarr) 180 386.83 T
(.h) 222.4 386.83 T
2 F
(T) 99 366.83 T
(ips and T) 104.93 366.83 T
(ricks:) 148.28 366.83 T
0 F
-0.42 (Only the chunk-handle portion of the optr is signi\336cant; the memory block is) 180 366.83 P
(implicit in the pointer to the element.) 180 353.83 T
2 F
(Be Sure T) 99 333.83 T
(o:) 144.94 333.83 T
0 F
(Lock the block on the global heap \050if it is not \336xed\051.) 180 333.83 T
2 F
(W) 99 313.83 T
(arnings:) 108.07 313.83 T
0 F
(If the address passed is not the address of an element already in the chunk) 180 313.83 T
(array) 180 300.83 T
(, results are unde\336ned. The routine may cause heap compaction or) 204.26 300.83 T
(resizing; all pointers within the block are invalidated.) 180 287.83 T
2 F
(See Also:) 99 267.83 T
0 F
(ChunkArrayAppend\050\051, ChunkArrayDelete\050\051, ChunkArrayResize\050\051) 180 267.83 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "66" 16
%%Page: "67" 17
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
162 690.34 558 702 R
7 X
0 0 0 1 0 0 0 K
V
162 666.34 558 678.01 R
V
0 10 Q
0 X
(67) 546.88 671.34 T
324 684 580 684 2 L
7 X
V
3 H
2 Z
0 X
N
512 90 558 125 R
7 X
V
1 60 Q
0 X
(n) 512.17 85 T
315 104 510 126 R
7 X
V
2 24 Q
0 X
(Routines) 407.33 110 T
90 99 270 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
90.67 123.5 270.67 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
81 642.99 531 648 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 642.99 531 648 R
7 X
0 0 0 1 0 0 0 K
V
50 646.99 609.01 646.99 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 634.99 T
2 F
(ChunkArrayInsertAtHandle\050\051) 99 634.99 T
3 10 Q
(void *) 99 620.33 T
4 F
(ChunkArrayInsertAtHandle\050) 153 620.33 T
4 9 Q
(ChunkHandle) 153 609.99 T
(chunk,) 261 609.99 T
(/* Handle of chunk array */) 333 609.99 T
(void *) 153 599.99 T
(insertPointer,) 261 599.99 T
(/* Address at which to insert) 336.6 599.99 T
( * element */) 333 589.99 T
(word) 153 579.99 T
(elementSize\051;) 261 579.99 T
(/* Size of new element \050ignored) 333 579.99 T
( * if elements are uniform-sized\051 */) 333 569.99 T
0 10 Q
(This routine is just like) 180 552.33 T
5 F
(ChunkArrayInsertAt\050\051) 290.76 552.33 T
0 F
(, except that the chunk) 407.06 552.33 T
(array is speci\336ed by its chunk handle. \050The global block is implicit in the) 180 540.83 T
(pointer passed.\051) 180 529.33 T
2 F
(Include:) 99 510.83 T
0 F
(chunkarr) 180 510.83 T
(.h) 222.4 510.83 T
81 494.48 531 499.49 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 494.48 531 499.49 R
7 X
0 0 0 1 0 0 0 K
V
50 498.48 609.01 498.48 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 486.48 T
2 F
(ChunkArrayPtrT) 99 486.48 T
(oElement\050\051) 190.79 486.48 T
3 10 Q
(word) 99 471.82 T
4 F
(ChunkArrayPtrToElement\050) 153 471.82 T
4 9 Q
(optr) 153 461.48 T
(array,) 189 461.48 T
(/* Handle of chunk array */) 351 461.48 T
(void *) 153 451.48 T
(element\051;) 189 451.48 T
(/* Address of element */) 351 451.48 T
0 10 Q
-0.14 (This routine takes the address of an element in a chunk array) 180 433.82 P
-0.14 (, as well as an) 463.88 433.82 P
(optr to the array) 180 422.32 T
(. It returns the element\325) 255.56 422.32 T
(s zero-based index.) 365.75 422.32 T
2 F
(Include:) 99 403.82 T
0 F
(chunkarr) 180 403.82 T
(.h) 222.4 403.82 T
2 F
(T) 99 383.82 T
(ips and T) 104.93 383.82 T
(ricks:) 148.28 383.82 T
0 F
-0.42 (Only the chunk-handle portion of the optr is signi\336cant; the memory block is) 180 383.82 P
(implicit in the pointer to the element.) 180 370.82 T
2 F
(Be Sure T) 99 350.82 T
(o:) 144.94 350.82 T
0 F
(Lock the block on the global heap \050unless it is \336xed\051.) 180 350.82 T
2 F
(W) 99 330.82 T
(arnings:) 108.07 330.82 T
0 F
(If the address passed is not the address of the beginning of an element,) 180 330.82 T
(results are unpredictable.) 180 317.82 T
2 F
(See Also:) 99 297.82 T
0 F
(ChunkArrayElementT) 180 297.82 T
(oPtr\050\051) 283.52 297.82 T
81 281.48 531 286.48 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 281.48 531 286.48 R
7 X
0 0 0 1 0 0 0 K
V
50 285.48 609.01 285.48 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 273.47 T
2 F
(ChunkArrayPtrT) 99 273.47 T
(oElementHandle\050\051) 190.79 273.47 T
3 10 Q
(word) 99 258.81 T
4 F
(ChunkArrayPtrToElementHandle\050) 153 258.81 T
4 9 Q
(ChunkHandle) 153 248.47 T
(array,) 261 248.47 T
(/* chunk handle of chunk array */) 315 248.47 T
(void *) 153 238.47 T
(element\051;) 261 238.47 T
(/* Pointer to element to delete */) 315 238.47 T
0 10 Q
(This routine is exactly like) 180 220.81 T
5 F
(ChunkArrayPtrT) 305.95 220.81 T
(oElement\050\051) 394.48 220.81 T
0 F
(, except that the) 451.7 220.81 T
-0.28 (chunk array is indicated by its chunk handle. \050The global block is implicit in) 180 209.31 P
(the pointer passed.\051) 180 197.81 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "67" 17
%%Page: "68" 18
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
54 690.34 450 702 R
7 X
0 0 0 1 0 0 0 K
V
54 666.34 450 678.01 R
V
0 10 Q
0 X
(68) 54 671.34 T
32 684 288 684 2 L
7 X
V
3 H
2 Z
0 X
N
54 90 108 125 R
7 X
V
1 60 Q
0 X
(n) 58.17 85 T
104 104 299 126 R
7 X
V
2 24 Q
0 X
(Routines) 104 110 T
306 99 486 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
306 123.5 486 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
81 642.99 531 648 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 642.99 531 648 R
7 X
0 0 0 1 0 0 0 K
V
50 646.99 609.01 646.99 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 634.99 T
2 F
(ChunkArraySort\050\051) 99 634.99 T
3 10 Q
(void) 99 620.33 T
4 F
(ChunkArraySort\050) 153 620.33 T
4 9 Q
(optr) 153 609.99 T
(array,) 261 609.99 T
(/* optr to chunk array */) 351 609.99 T
(word) 153 599.99 T
(valueForCallback,) 261 599.99 T
(/* Passed to callback routine */) 352.8 599.99 T
(sword _pascal \050*callback\051) 153 589.99 T
(\050void *el1,) 297 589.99 T
( void * el2,) 279 579.99 T
( word valueForCallback\051\051) 279 569.99 T
(/* Sign of return value decides order of elements */) 189 559.99 T
0 10 Q
(This is a general-purpose sort routine for chunk arrays. It does a modi\336ed) 180 542.33 T
-0.3 (Quicksort on the array) 180 530.83 P
-0.3 (, using an insertion sort for subarrays below a certain) 283.19 530.83 P
(size; this gives performance of) 180 519.33 T
(.) 361.33 519.33 T
(The sort routine does not compare elements. Rather) 180 500.83 T
(, it calls a comparison) 419.27 500.83 T
(callback routine passed in the) 180 489.33 T
6 F
(callback) 320.95 489.33 T
0 F
( parameter) 359.09 489.33 T
(. Whenever it needs to) 409.65 489.33 T
-0.31 (compare two elements, it calls the callback routine, passing the addresses of) 180 477.83 P
(the elements and the) 180 466.33 T
6 F
(valueForCallback) 280.2 466.33 T
0 F
( word which was passed to) 362.04 466.33 T
5 F
(ChunkArraySort\050\051) 180 454.83 T
0 F
(. The callback routine should be declared _pascal. The) 275.2 454.83 T
(callback routine\325) 180 443.33 T
(s return value determines which element will come \336rst in) 255.94 443.33 T
(the sorted array:) 180 431.83 T
1 F
(u) 180 413.33 T
0 F
(If element) 198 413.33 T
6 F
(el1) 248 413.33 T
0 F
( ought to come before) 261.33 413.33 T
6 F
(el2) 362.26 413.33 T
0 F
( in the sorted array) 375.59 413.33 T
(, the callback) 463.93 413.33 T
(routine should return a negative integer) 198 402.33 T
(.) 383.56 402.33 T
1 F
(u) 180 384.33 T
0 F
(If element) 198 384.33 T
6 F
(el1) 248 384.33 T
0 F
( ought to come after) 261.33 384.33 T
6 F
(el2) 356.15 384.33 T
0 F
( in the sorted array) 369.48 384.33 T
(, the callback) 457.82 384.33 T
(routine should return a positive integer) 198 373.33 T
(.) 380.04 373.33 T
1 F
(u) 180 355.33 T
0 F
(If it doesn\325) 198 355.33 T
(t matter whether) 246.34 355.33 T
6 F
(el1) 328.57 355.33 T
0 F
( comes before or after) 341.9 355.33 T
6 F
(el2) 443.75 355.33 T
0 F
( in the sorted) 457.08 355.33 T
(array) 198 344.33 T
(, the callback routine should return zero.) 222.26 344.33 T
2 F
(Include:) 99 326.33 T
0 F
(chunkarr) 180 326.33 T
(.h) 222.4 326.33 T
2 F
(T) 99 306.33 T
(ips and T) 104.93 306.33 T
(ricks:) 148.28 306.33 T
0 F
(Y) 180 306.33 T
(ou may need to sort an array based on different criteria at different times.) 185.93 306.33 T
-0.1 (The simplest way to do this is to write one general-purpose callback routine) 180 293.33 P
(and have the) 180 280.33 T
6 F
(valueForCallback) 242.79 280.33 T
0 F
( word determine how the sort is done. For) 324.63 280.33 T
(example, the same callback routine could sort the array in ascending or) 180 267.33 T
(descending order) 180 254.33 T
(, depending on the) 257.95 254.33 T
6 F
(valueForCallback) 345.92 254.33 T
0 F
(.) 427.76 254.33 T
2 F
(Be Sure T) 99 234.33 T
(o:) 144.94 234.33 T
0 F
(Lock the block on the global heap \050unless it is \336xed\051.) 180 234.33 T
2 F
(W) 99 214.33 T
(arnings:) 108.07 214.33 T
0 F
(Do not have the callback routine do anything which might invalidate) 180 214.33 T
(pointers to the array \050such as allocate a new chunk or element\051.) 180 201.33 T
2 F
(See Also:) 99 181.33 T
0 F
(ArrayQuickSort\050\051) 180 181.33 T
321.85 515.33 361.33 526.47 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
7 9 Q
0 X
0 0 0 1 0 0 0 K
(') 321.14 519.33 T
(O) 322.76 519.33 T
8 F
(') 332.26 519.33 T
(n) 334.18 519.33 T
(') 351.61 519.33 T
(n) 353.54 519.33 T
7 F
(l) 339.21 519.33 T
(o) 341.71 519.33 T
(g) 346.21 519.33 T
(\050) 329.26 519.33 T
(\051) 358.04 519.33 T
36 72 576 720 C
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "68" 18
%%Page: "69" 19
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
162 690.34 558 702 R
7 X
0 0 0 1 0 0 0 K
V
162 666.34 558 678.01 R
V
0 10 Q
0 X
(69) 546.88 671.34 T
324 684 580 684 2 L
7 X
V
3 H
2 Z
0 X
N
512 90 558 125 R
7 X
V
1 60 Q
0 X
(n) 512.17 85 T
315 104 510 126 R
7 X
V
2 24 Q
0 X
(Routines) 407.33 110 T
90 99 270 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
90.67 123.5 270.67 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
81 642.99 531 648 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 642.99 531 648 R
7 X
0 0 0 1 0 0 0 K
V
50 646.99 609.01 646.99 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 634.99 T
2 F
(ChunkArraySortHandles\050\051) 99 634.99 T
3 10 Q
(void) 99 620.33 T
4 F
(ChunkArraySortHandles\050) 153 620.33 T
4 9 Q
(MemHandle) 153 609.99 T
(memHandle,) 261 609.99 T
(/* Handle of LMem heap\325s block */) 351 609.99 T
(ChunkHandle) 153 599.99 T
(chunkHandle,) 261 599.99 T
(/* Handle chunk array */) 351 599.99 T
(word) 153 589.99 T
(valueForCallback,) 261 589.99 T
(/* Passed to callback routine */) 352.8 589.99 T
(sword _pascal\050*callback\051\050void *el1, void * el2, word valueForCallback\051) 153 579.99 T
(/* Sign of return value decides order of elements */) 189 569.99 T
0 10 Q
-0.79 (This routine is exactly like) 180 552.33 P
5 F
-0.82 (ChunkArraySort\050\051) 302 552.33 P
0 F
-0.79 ( above, except that the chunk) 397.2 552.33 P
(array is speci\336ed by its global and chunk handles \050instead of by an optr\051.) 180 540.83 T
2 F
(Include:) 99 522.33 T
0 F
(chunkarr) 180 522.33 T
(.h) 222.4 522.33 T
81 505.98 531 510.99 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 505.98 531 510.99 R
7 X
0 0 0 1 0 0 0 K
V
50 509.98 609.01 509.98 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 497.98 T
2 F
(ChunkArrayZero\050\051) 99 497.98 T
3 10 Q
(void) 99 483.32 T
4 F
(ChunkArrayZero\050) 153 483.32 T
4 9 Q
(optr) 153 472.98 T
(array\051;) 189 472.98 T
(/* optr to chunk array */) 279 472.98 T
0 10 Q
(This routine destroys all the elements in an array) 180 455.32 T
(. It does not affect the) 408.92 455.32 T
(extra-space area between the) 180 443.82 T
5 F
(ChunkArrayHeader) 317.98 443.82 T
0 F
( and the elements. It is) 421.32 443.82 T
-0.26 (guaranteed not to cause heap compaction or resizing; thus, pointers to other) 180 432.32 P
(chunks remain valid.) 180 420.82 T
2 F
(Include:) 99 402.32 T
0 F
(chunkarr) 180 402.32 T
(.h) 222.4 402.32 T
2 F
(Be Sure T) 99 382.32 T
(o:) 144.94 382.32 T
0 F
(Lock the block on the global heap \050unless it is \336xed\051.) 180 382.32 T
2 F
(See Also:) 99 362.32 T
0 F
(ChunkArrayDelete\050\051) 180 362.32 T
81 345.98 531 350.98 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 345.98 531 350.98 R
7 X
0 0 0 1 0 0 0 K
V
50 349.98 609.01 349.98 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 337.98 T
2 F
(ChunkArrayZeroHandles\050\051) 99 337.98 T
3 10 Q
(void) 99 323.31 T
4 F
(ChunkArrayZeroHandles\050) 153 323.31 T
4 9 Q
(MemHandle) 153 312.98 T
(mh) 261 312.98 T
(/* Global handle of LMem heap */) 297 312.98 T
(ChunkHandle) 153 302.98 T
(ch\051;) 261 302.98 T
(/* Chunk handle of chunk array */) 297 302.98 T
0 10 Q
(This routine is exactly like) 180 285.31 T
5 F
(ChunkArrayZero\050\051) 305.95 285.31 T
0 F
( above, except that the) 402.63 285.31 T
(chunk array is speci\336ed by its global and chunk handles \050instead of by an) 180 273.81 T
(optr\051.) 180 262.31 T
2 F
(Include:) 99 243.81 T
0 F
(chunkarr) 180 243.81 T
(.h) 222.4 243.81 T
81 227.47 531 232.47 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 227.47 531 232.47 R
7 X
0 0 0 1 0 0 0 K
V
50 231.47 609.01 231.47 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 219.47 T
2 F
(ClipboardAbortQuickT) 99 219.47 T
(ransfer\050\051) 227.02 219.47 T
3 10 Q
(void) 99 204.8 T
4 F
(ClipboardAbortQuickTransfer\050void\051;) 153 204.8 T
0 F
(This routine cancels a quick-transfer operation in progress. It is typically) 180 186.8 T
(used when an object involved in a quick-transfer is shutting down or when) 180 175.3 T
(an error occurs in a quick-transfer) 180 163.8 T
(. This routine is usually used only by the) 337.95 163.8 T
(object or Process which initiated the quick-transfer) 180 152.3 T
(.) 415.19 152.3 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "69" 19
%%Page: "70" 20
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
54 690.34 450 702 R
7 X
0 0 0 1 0 0 0 K
V
54 666.34 450 678.01 R
V
0 10 Q
0 X
(70) 54 671.34 T
32 684 288 684 2 L
7 X
V
3 H
2 Z
0 X
N
54 90 108 125 R
7 X
V
1 60 Q
0 X
(n) 58.17 85 T
104 104 299 126 R
7 X
V
2 24 Q
0 X
(Routines) 104 110 T
306 99 486 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
306 123.5 486 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
2 10 Q
0 X
(Include:) 99 641.33 T
0 F
(clipbrd.goh) 180 641.33 T
81 624.99 531 630 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 624.99 531 630 R
7 X
0 0 0 1 0 0 0 K
V
50 628.99 609.01 628.99 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 616.99 T
2 F
(ClipboardAddT) 99 616.99 T
(oNoti\336cationList\050\051) 184.78 616.99 T
3 10 Q
(void) 99 602.33 T
4 F
(ClipboardAddToNotificationList\050) 153 602.33 T
4 9 Q
(optr) 153 591.99 T
(notificationOD\051;) 189 591.99 T
0 10 Q
(This routine registers the passed object or process for quick-transfer) 180 574.33 T
(noti\336cation. This routine is typically called from within an object\325) 180 562.83 T
(s) 481.15 562.83 T
0 9 Q
(MSG_MET) 180 551.33 T
(A_INITIALIZE) 226.17 551.33 T
0 10 Q
( handler or within a Process object\325) 289.66 551.33 T
(s) 450.97 551.33 T
0 9 Q
(MSG_GEN_PROCESS_OPEN_APPLICA) 180 539.83 T
(TION) 351.35 539.83 T
0 10 Q
( handler) 375.35 539.83 T
(. Pass the optr of the) 413.5 539.83 T
(object or the geode handle if the Process object should be registered.) 180 528.33 T
2 F
(Include:) 99 509.83 T
0 F
(clipbrd.goh) 180 509.83 T
2 F
(See Also:) 99 489.83 T
0 F
(ClipboardRemoveFromNoti\336cationList\050\051) 180 489.83 T
81 473.48 531 478.49 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 473.48 531 478.49 R
7 X
0 0 0 1 0 0 0 K
V
50 477.48 609.01 477.48 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 465.48 T
2 F
(ClipboardClearQuickT) 99 465.48 T
(ransferNoti\336cation\050\051) 225.04 465.48 T
3 10 Q
(void) 99 450.82 T
4 F
(ClipboardClearQuickTransferNotification\050) 153 450.82 T
4 9 Q
(optr) 153 440.48 T
(notificationOD\051;) 189 440.48 T
0 10 Q
-0.43 (This routine removes an object or process from quick-transfer noti\336cation. It) 180 422.82 P
-0.85 (is typically used in the object\325) 180 411.32 P
-0.85 (s) 311.54 411.32 P
0 9 Q
-0.76 (MSG_MET) 318.1 411.32 P
-0.76 (A_DET) 364.27 411.32 P
-0.76 (ACH) 394.28 411.32 P
0 10 Q
-0.85 ( handler or in the Process) 414.77 411.32 P
(object\325) 180 399.82 T
(s) 208.52 399.82 T
0 9 Q
(MSG_GEN_PROCESS_CLOSE_APPLICA) 215.93 399.82 T
(TION) 392.11 399.82 T
0 10 Q
( to ensure that it is not) 416.12 399.82 T
(noti\336ed after it has already detached.) 180 388.32 T
(Pass the optr of the object speci\336ed to receive noti\336cation in) 180 369.82 T
5 F
(ClipboardStartQuickT) 180 358.32 T
(ransfer\050\051) 296.43 358.32 T
0 F
( \050or the geode handle if a process\051.) 342.18 358.32 T
-0.09 (Note that an object may also want to check if a quick-transfer is in progress) 180 339.82 P
(when detaching and possibly abort it if there is one.) 180 328.32 T
2 F
(See Also:) 99 309.82 T
5 F
(clipbrd.goh) 180 309.82 T
81 293.48 531 298.48 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 293.48 531 298.48 R
7 X
0 0 0 1 0 0 0 K
V
50 297.48 609.01 297.48 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 285.48 T
2 F
(ClipboardDoneW) 99 285.48 T
(ithItem\050\051) 196.22 285.48 T
3 10 Q
(void) 99 270.81 T
4 F
(ClipboardDoneWithItem\050) 153 270.81 T
4 9 Q
(TransferBlockID header\051;) 153 260.47 T
0 10 Q
-0.62 (This routine is called when an object or Process is done using a transfer item.) 180 242.81 P
-0.14 (It relinquishes exclusive access to the item\325) 180 231.31 P
-0.14 (s transfer) 378.26 231.31 P
0 9 Q
-0.12 (VM) 425.58 231.31 P
0 10 Q
-0.14 ( \336le after the caller) 440.57 231.31 P
(had previously called) 180 219.81 T
5 F
(ClipboardQueryItem\050\051) 280.75 219.81 T
0 F
(.) 397.05 219.81 T
2 F
(Include:) 99 201.31 T
0 F
(clipbrd.goh) 180 201.31 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "70" 20
%%Page: "71" 21
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
162 690.34 558 702 R
7 X
0 0 0 1 0 0 0 K
V
162 666.34 558 678.01 R
V
0 10 Q
0 X
(71) 546.88 671.34 T
324 684 580 684 2 L
7 X
V
3 H
2 Z
0 X
N
512 90 558 125 R
7 X
V
1 60 Q
0 X
(n) 512.17 85 T
315 104 510 126 R
7 X
V
2 24 Q
0 X
(Routines) 407.33 110 T
90 99 270 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
90.67 123.5 270.67 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
81 642.99 531 648 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 642.99 531 648 R
7 X
0 0 0 1 0 0 0 K
V
50 646.99 609.01 646.99 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 634.99 T
2 F
(ClipboardEndQuickT) 99 634.99 T
(ransfer\050\051) 217.69 634.99 T
3 10 Q
(void) 99 620.33 T
4 F
(ClipboardEndQuickTransfer\050) 153 620.33 T
4 9 Q
(ClipboardQuickNotifyFlags) 153 609.99 T
(flags\051;) 297 609.99 T
0 10 Q
-0.2 (This routine ends a quick-transfer operation by resetting the pointer image,) 180 592.33 P
(clearing any quick-transfer region, clearing the quick-transfer item, and) 180 580.83 T
(sending out any needed noti\336cation of the completed transfer) 180 569.33 T
(.) 462.23 569.33 T
-0.09 (Pass this routine a record of) 180 550.83 P
5 F
-0.09 (ClipboardQuickNotifyFlags) 312.07 550.83 P
0 F
-0.09 (. Pass the value) 455.77 550.83 P
0 9 Q
(CQNF_MOVE) 180 539.33 T
0 10 Q
( if the operation was completed and was a move; pass) 239.83 539.33 T
0 9 Q
-0.14 (CQNF_COPY) 180 527.83 P
0 10 Q
-0.15 ( if the operation was completed and was a copy) 237.18 527.83 P
-0.15 (. If the operation) 451.41 527.83 P
(could not be completed \050e.g. incompatible data types\051, pass) 180 516.33 T
0 9 Q
(CQNF_NO_OPERA) 180 504.83 T
(TION) 262.18 504.83 T
0 10 Q
( or) 286.18 504.83 T
0 9 Q
(CQNF_ERROR) 301.18 504.83 T
0 10 Q
(.) 365.51 504.83 T
(The noti\336cation sent out by the) 180 486.33 T
0 9 Q
(UI) 327.43 486.33 T
0 10 Q
( will be in the form of the message) 338.43 486.33 T
0 9 Q
(MSG_MET) 180 474.83 T
(A_CLIPBOARD_NOTIFY_QUICK_TRANSFER_CONCLUDED) 226.17 474.83 T
0 10 Q
(. This) 490.85 474.83 T
(message noti\336es the originator of the transfer item of the type of operation;) 180 463.33 T
(the originator can then respond if necessary) 180 451.83 T
(.) 382.22 451.83 T
2 F
(Include:) 99 433.33 T
0 F
(clipbrd.goh) 180 433.33 T
81 416.98 531 421.99 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 416.98 531 421.99 R
7 X
0 0 0 1 0 0 0 K
V
50 420.98 609.01 420.98 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 408.98 T
2 F
(ClipboardEnumItemFormats\050\051) 99 408.98 T
3 10 Q
(word) 99 394.32 T
4 F
(ClipboardEnumItemFormats\050) 153 394.32 T
4 9 Q
(TransferBlockID) 153 383.98 T
(header,) 261 383.98 T
(word) 153 373.98 T
(maxNumFormats,) 261 373.98 T
(ClipboardFormatID *) 153 363.98 T
(buffer\051;) 261 363.98 T
0 10 Q
(This routine returns a list of all the formats supported by the current) 180 346.32 T
(transfer item. T) 180 334.82 T
(o see whether a particular format is supported, you can use) 252.42 334.82 T
5 F
(ClipboardT) 180 323.32 T
(estItemFormat\050\051) 238.53 323.32 T
0 F
( instead.) 323.9 323.32 T
(Pass this routine the following:) 180 304.82 T
6 F
(header) 180 286.32 T
0 F
(The transfer item header as returned by) 243 286.32 T
5 F
(ClipboardQueryItem\050\051) 243 275.32 T
0 F
(.) 359.3 275.32 T
6 F
(maxNumFormats) 180 257.32 T
0 F
-0.59 (The maximum number of formats that should be returned. Y) 243 246.32 P
-0.59 (ou) 517.7 246.32 P
(should set your return buffer \050see below\051 large enough to) 243 235.32 T
(support this size.) 243 224.32 T
6 F
(buffer) 180 206.32 T
0 F
-0.43 (A pointer to a locked or \336xed buffer into which the formats will) 243 206.32 P
(be copied. Upon return, the buffer will contain the proper) 243 195.32 T
(number of) 243 184.32 T
5 F
(ClipboardFormatID) 293 184.32 T
0 F
( structures, one for each) 396.52 184.32 T
-0.54 (format available. This buffer should be at least large enough to) 243 173.32 P
-0.15 (support the number of formats requested in) 243 162.32 P
6 F
-0.15 (maxNumFormats) 446.74 162.32 P
0 F
-0.15 (.) 528.22 162.32 P
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "71" 21
%%Page: "72" 22
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
54 690.34 450 702 R
7 X
0 0 0 1 0 0 0 K
V
54 666.34 450 678.01 R
V
0 10 Q
0 X
(72) 54 671.34 T
32 684 288 684 2 L
7 X
V
3 H
2 Z
0 X
N
54 90 108 125 R
7 X
V
1 60 Q
0 X
(n) 58.17 85 T
104 104 299 126 R
7 X
V
2 24 Q
0 X
(Routines) 104 110 T
306 99 486 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
306 123.5 486 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
0 10 Q
0 X
-0.44 (The word return value is the total number of formats returned. This number) 180 641.33 P
(will be equal to or less than the number passed in) 180 629.83 T
6 F
(maxNumFormats) 412.83 629.83 T
0 F
(. The) 494.31 629.83 T
(routine will also return the passed buffer \336lled with that number of) 180 618.33 T
5 F
(ClipboardFormatID) 180 606.83 T
0 F
( structures.) 283.52 606.83 T
2 F
(Include:) 99 588.33 T
0 F
(clipbrd.goh) 180 588.33 T
2 F
(See Also:) 99 568.33 T
0 F
(ClipboardT) 180 568.33 T
(estItemFormat\050\051) 231.31 568.33 T
81 551.99 531 557 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 551.99 531 557 R
7 X
0 0 0 1 0 0 0 K
V
50 555.99 609.01 555.99 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 543.99 T
2 F
(ClipboardGetClipboardFile\050\051) 99 543.99 T
3 10 Q
(VMFileHandle) 99 529.33 T
4 F
( ClipboardGetClipboardFile\050void\051;) 171 529.33 T
0 F
(This routine returns the) 180 511.33 T
0 9 Q
(VM) 295 511.33 T
0 10 Q
( \336le handle of the current default transfer) 309.99 511.33 T
0 9 Q
(VM) 506.1 511.33 T
0 10 Q
(\336le.) 180 499.83 T
2 F
(Include:) 99 481.33 T
0 F
(clipbrd.goh) 180 481.33 T
81 464.98 531 469.99 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 464.98 531 469.99 R
7 X
0 0 0 1 0 0 0 K
V
50 468.98 609.01 468.98 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 456.98 T
2 F
(ClipboardGetItemInfo\050\051) 99 456.98 T
3 10 Q
(optr) 99 442.32 T
4 F
(ClipboardGetItemInfo\050) 153 442.32 T
4 9 Q
(TransferBlockID header\051;) 153 431.98 T
0 10 Q
(This routine returns the source identi\336er \050) 180 414.32 T
6 9 Q
(CIH) 376.1 414.32 T
6 10 Q
(_sourceID) 393.76 414.32 T
0 F
(\051 of the current) 439.48 414.32 T
(transfer item. Pass the transfer item\325) 180 402.82 T
(s header returned by) 351.5 402.82 T
5 F
(ClipboardQueryItem\050\051) 180 391.32 T
0 F
(.) 296.3 391.32 T
2 F
(Include:) 99 372.82 T
0 F
(clipbrd.goh) 180 372.82 T
81 356.48 531 361.48 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 356.48 531 361.48 R
7 X
0 0 0 1 0 0 0 K
V
50 360.48 609.01 360.48 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 348.48 T
2 F
(ClipboardGetNormalItemInfo\050\051) 99 348.48 T
3 10 Q
(TransferBlockID) 99 333.81 T
4 F
( ClipboardGetNormalItemInfo\050void\051;) 189 333.81 T
0 F
-0.09 (This routine returns information about the normal transfer item. It returns) 180 315.81 P
-0.56 (a) 180 304.31 P
5 F
-0.58 (T) 187.78 304.31 P
-0.58 (ransferBlockID) 194.38 304.31 P
0 F
-0.56 ( dword which contains the) 274.76 304.31 P
0 9 Q
-0.5 (VM) 396.03 304.31 P
0 10 Q
-0.56 ( \336le handle of the transfer) 411.03 304.31 P
(\336le and the) 180 292.81 T
0 9 Q
(VM) 235.01 292.81 T
0 10 Q
( block handle of the transfer item\325) 250 292.81 T
(s header block.) 405.76 292.81 T
(T) 180 274.31 T
(o extract the \336le handle from the return value, use the macro) 185.75 274.31 T
5 F
(FileFromT) 180 262.81 T
(ransferBlockID\050\051) 234.93 262.81 T
0 F
(. T) 323.09 262.81 T
(o extract the block handle, use the macro) 334.4 262.81 T
5 F
(BlockFromT) 180 251.31 T
(ransferBlockID\050\051) 244.39 251.31 T
0 F
(.) 332.55 251.31 T
2 F
(Include:) 99 232.81 T
0 F
(clipbrd.goh) 180 232.81 T
81 216.47 531 221.47 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 216.47 531 221.47 R
7 X
0 0 0 1 0 0 0 K
V
50 220.47 609.01 220.47 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 208.47 T
2 F
(ClipboardGetQuickItemInfo\050\051) 99 208.47 T
3 10 Q
(TransferBlockID) 99 193.8 T
4 F
( ClipboardGetQuickItemInfo\050void\051;) 189 193.8 T
0 F
(This routine returns information about the quick-transfer transfer item. It) 180 175.8 T
-0.33 (returns a) 180 164.3 P
5 F
-0.34 (T) 225.08 164.3 P
-0.34 (ransferBlockID) 231.68 164.3 P
0 F
-0.33 ( dword which contains the) 312.06 164.3 P
0 9 Q
-0.3 (VM) 434.49 164.3 P
0 10 Q
-0.33 ( \336le handle of the) 449.49 164.3 P
(transfer \336le and the) 180 152.8 T
0 9 Q
(VM) 275.19 152.8 T
0 10 Q
( block handle of the transfer item\325) 290.18 152.8 T
(s header block.) 445.94 152.8 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "72" 22
%%Page: "73" 23
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
162 690.34 558 702 R
7 X
0 0 0 1 0 0 0 K
V
162 666.34 558 678.01 R
V
0 10 Q
0 X
(73) 546.88 671.34 T
324 684 580 684 2 L
7 X
V
3 H
2 Z
0 X
N
512 90 558 125 R
7 X
V
1 60 Q
0 X
(n) 512.17 85 T
315 104 510 126 R
7 X
V
2 24 Q
0 X
(Routines) 407.33 110 T
90 99 270 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
90.67 123.5 270.67 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
0 10 Q
0 X
(T) 180 641.33 T
(o extract the \336le handle from the return value, use the macro) 185.75 641.33 T
5 F
(FileFromT) 180 629.83 T
(ransferBlockID\050\051) 234.93 629.83 T
0 F
(. T) 323.09 629.83 T
(o extract the block handle, use the macro) 334.4 629.83 T
5 F
(BlockFromT) 180 618.33 T
(ransferBlockID\050\051) 244.39 618.33 T
0 F
(.) 332.55 618.33 T
2 F
(Include:) 99 599.83 T
0 F
(clipbrd.goh) 180 599.83 T
81 583.49 531 588.5 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 583.49 531 588.5 R
7 X
0 0 0 1 0 0 0 K
V
50 587.49 609.01 587.49 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 575.49 T
2 F
(ClipboardGetQuickT) 99 575.49 T
(ransferStatus\050\051) 215.03 575.49 T
3 10 Q
(Boolean) 99 560.83 T
4 F
(ClipboardGetQuickTransferStatus\050void\051;) 153 560.83 T
0 F
(This routine returns) 180 542.83 T
6 F
(true) 277.22 542.83 T
0 F
( if a quick-transfer operation is in progress,) 295.73 542.83 T
6 F
(false) 498.89 542.83 T
0 F
(otherwise. It is often called when objects or Processes are shutting down in) 180 531.33 T
(order to abort any quick-transfers originated by the caller) 180 519.83 T
(.) 446.13 519.83 T
2 F
(Include:) 99 501.33 T
0 F
(clipbrd.goh) 180 501.33 T
81 484.98 531 489.99 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 484.98 531 489.99 R
7 X
0 0 0 1 0 0 0 K
V
50 488.98 609.01 488.98 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 476.98 T
2 F
(ClipboardGetUndoItemInfo\050\051) 99 476.98 T
3 10 Q
(TransferBlockID) 99 462.32 T
4 F
( ClipboardGetUndoItemInfo\050void\051;) 189 462.32 T
0 F
(This routine returns information about the undo transfer item. It returns a) 180 444.32 T
5 F
(T) 180 432.82 T
(ransferBlockID) 186.6 432.82 T
0 F
( dword which contains the) 266.98 432.82 T
0 9 Q
(VM) 391.06 432.82 T
0 10 Q
( \336le handle of the transfer) 406.05 432.82 T
(\336le and the) 180 421.32 T
0 9 Q
(VM) 235.01 421.32 T
0 10 Q
( block handle of the transfer item\325) 250 421.32 T
(s header block.) 405.76 421.32 T
(T) 180 402.82 T
(o extract the \336le handle from the return value, use the macro) 185.75 402.82 T
5 F
(FileFromT) 180 391.32 T
(ransferBlockID\050\051) 234.93 391.32 T
0 F
(. T) 323.09 391.32 T
(o extract the block handle, use the macro) 334.4 391.32 T
5 F
(BlockFromT) 180 379.82 T
(ransferBlockID\050\051) 244.39 379.82 T
0 F
(.) 332.55 379.82 T
2 F
(Include:) 99 361.32 T
0 F
(clipbrd.goh) 180 361.32 T
81 344.98 531 349.98 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 344.98 531 349.98 R
7 X
0 0 0 1 0 0 0 K
V
50 348.98 609.01 348.98 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 336.98 T
2 F
(ClipboardQueryItem\050\051) 99 336.98 T
3 10 Q
(void) 99 322.31 T
4 F
(ClipboardQueryItem\050) 153 322.31 T
4 9 Q
(ClipboardItemFlags) 153 311.98 T
(flags,) 279 311.98 T
(ClipboardQueryArgs *) 153 301.98 T
(retValues\051;) 279 301.98 T
0 10 Q
(This routine locks the transfer item for the caller) 180 284.31 T
(\325) 407.04 284.31 T
(s exclusive access and) 408.71 284.31 T
(returns information about the current transfer item. Y) 180 272.81 T
(ou should call this) 431.3 272.81 T
(routine when beginning any paste or clipboard query operation. For) 180 261.31 T
(operations in which you will change the clipboard\325) 180 249.81 T
(s contents, you should) 410.58 249.81 T
(instead use the routine) 180 238.31 T
5 F
(ClipboardRegisterItem\050\051) 289.64 238.31 T
0 F
(.) 417.61 238.31 T
(Pass the following values:) 180 219.81 T
6 F
(\337ags) 180 201.31 T
0 F
-0.39 (A record of) 243 201.31 P
5 F
-0.4 (ClipboardItemFlags) 294.78 201.31 P
0 F
-0.39 ( indicating the transfer item) 399.04 201.31 P
(you want to query) 243 190.31 T
(. Use) 325.42 190.31 T
0 9 Q
(CIF_QUICK) 351.54 190.31 T
0 10 Q
( to get information on the) 403.7 190.31 T
(quick transfer item, and pass zero \050or) 243 179.31 T
0 9 Q
(TIF_NORMAL) 418.75 179.31 T
0 10 Q
(\051 to get) 480.75 179.31 T
(information on the normal transfer item.) 243 168.31 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "73" 23
%%Page: "74" 24
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
54 690.34 450 702 R
7 X
0 0 0 1 0 0 0 K
V
54 666.34 450 678.01 R
V
0 10 Q
0 X
(74) 54 671.34 T
32 684 288 684 2 L
7 X
V
3 H
2 Z
0 X
N
54 90 108 125 R
7 X
V
1 60 Q
0 X
(n) 58.17 85 T
104 104 299 126 R
7 X
V
2 24 Q
0 X
(Routines) 104 110 T
306 99 486 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
306 123.5 486 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
6 10 Q
0 X
(retV) 180 641.33 T
(alues) 198.15 641.33 T
0 F
(A pointer to an empty) 243 641.33 T
5 F
(ClipboardQueryArgs) 346.9 641.33 T
0 F
( structure into) 455.24 641.33 T
(which return information about the transfer item will be) 243 630.33 T
(passed. This structure is de\336ned as follows:) 243 619.33 T
4 9 Q
(typedef struct {) 216 605 T
(word) 252 595 T
(CQA_numFormats;) 360 595 T
(optr) 252 585 T
(CQA_owner;) 360 585 T
(TransferBlockID) 252 575 T
(CQA_header;) 360 575 T
(} ClipboardQueryArgs;) 216 565 T
0 10 Q
(The) 180 547.33 T
6 9 Q
(CQA_) 200.56 547.33 T
6 10 Q
(header) 224.9 547.33 T
0 F
( \336eld of) 256.18 547.33 T
5 F
(ClipboardQueryArgs) 292.85 547.33 T
0 F
( is used as a pass value to) 401.19 547.33 T
-0.78 (several other clipboard routines. It contains the) 180 535.83 P
0 9 Q
-0.7 (VM) 397.34 535.83 P
0 10 Q
-0.78 ( \336le handle of the transfer) 412.33 535.83 P
0 9 Q
(VM) 180 524.33 T
0 10 Q
( \336le and the) 194.99 524.33 T
0 9 Q
(VM) 252.78 524.33 T
0 10 Q
( block handle of the transfer item\325) 267.78 524.33 T
(s header block. The) 423.54 524.33 T
6 9 Q
(CQA_) 180 512.83 T
6 10 Q
(owner) 204.34 512.83 T
0 F
( \336eld is the optr of the object that originated the transfer item.) 232.11 512.83 T
(The) 180 501.33 T
6 9 Q
(CQA_) 200.56 501.33 T
6 10 Q
(numFormats) 224.9 501.33 T
0 F
( \336eld speci\336es the total number of formats available) 284.71 501.33 T
(for this transfer item. T) 180 489.83 T
(o see if a particular format is supported by the) 288.53 489.83 T
(transfer item, call the routine) 180 478.33 T
5 F
(ClipboardT) 320.01 478.33 T
(estItemFormat\050\051) 378.54 478.33 T
0 F
(.) 463.91 478.33 T
2 F
(Be Sure T) 99 459.83 T
(o:) 144.94 459.83 T
0 F
-0.57 (Y) 180 459.83 P
-0.57 (ou must call) 185.93 459.83 P
5 F
-0.59 (ClipboardDoneW) 243.5 459.83 P
-0.59 (ithItem\050\051) 332.2 459.83 P
0 F
-0.57 ( when you are done accessing the) 378.86 459.83 P
-0.47 (transfer item. This routine relinquishes your exclusive access to the transfer) 180 446.83 P
0 9 Q
(VM) 180 433.83 T
0 10 Q
( \336le.) 194.99 433.83 T
2 F
(Include:) 99 413.83 T
0 F
(clipbrd.goh) 180 413.83 T
2 F
(See Also:) 99 393.83 T
0 F
(ClipboardRequestItemFormat\050\051, ClipboardDoneW) 180 393.83 T
(ithItem) 410.38 393.83 T
5 F
(\050\051) 445.38 393.83 T
81 377.49 531 382.5 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 377.49 531 382.5 R
7 X
0 0 0 1 0 0 0 K
V
50 381.49 609.01 381.49 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 369.49 T
2 F
(ClipboardRegisterItem\050\051) 99 369.49 T
3 10 Q
(Boolean) 99 354.83 T
4 F
(ClipboardRegisterItem\050) 153 354.83 T
4 9 Q
(TransferBlockID header,) 153 344.49 T
(ClipboardItemFlags flags\051;) 153 334.49 T
0 10 Q
(This routine completes a change to the transfer item. Y) 180 316.83 T
(ou should use this) 434.1 316.83 T
(routine whenever copying or cutting something into the clipboard or) 180 305.33 T
(whenever attaching something as the quick-transfer item.) 180 293.83 T
(This routine puts the item speci\336ed by) 180 275.33 T
6 F
(header) 360.76 275.33 T
0 F
( into the transfer) 392.04 275.33 T
0 9 Q
(VM) 473.71 275.33 T
0 10 Q
( \336le. It) 488.7 275.33 T
-0.16 (frees any transfer item that may already be in the \336le. Pass this routine the) 180 263.83 P
(following:) 180 252.33 T
6 F
(header) 180 233.83 T
0 F
-0.22 (Header information for the item, consisting of the transfer) 243 233.83 P
0 9 Q
-0.2 (VM) 513.44 233.83 P
0 10 Q
-0.48 (\336le handle and the) 243 222.83 P
0 9 Q
-0.43 (VM) 330.55 222.83 P
0 10 Q
-0.48 ( block handle of the block containing the) 345.54 222.83 P
(new transfer item. Create the) 243 211.83 T
5 F
(T) 383.01 211.83 T
(ransferBlockID) 389.61 211.83 T
0 F
( structure) 469.99 211.83 T
(using the macro) 243 200.83 T
5 F
(BlockIDFromFileAndBlock\050\051) 320.04 200.83 T
0 F
(.) 469.31 200.83 T
6 F
(\337ags) 180 182.83 T
0 F
(A record of) 243 182.83 T
5 F
(ClipboardItemFlags) 295.95 182.83 T
0 F
( indicating whether you\325re) 400.21 182.83 T
(registering a clipboard item or a quick-transfer item. The \337ag) 243 171.83 T
0 9 Q
-0.41 (CIF_QUICK) 243 160.83 P
0 10 Q
-0.46 ( indicates the item is a quick-transfer item; zero \050or) 295.16 160.83 P
0 9 Q
(TIF_NORMAL) 243 149.83 T
0 10 Q
(\051 indicates the item is a normal clipboard item.) 305 149.83 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "74" 24
%%Page: "75" 25
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
162 690.34 558 702 R
7 X
0 0 0 1 0 0 0 K
V
162 666.34 558 678.01 R
V
0 10 Q
0 X
(75) 546.88 671.34 T
324 684 580 684 2 L
7 X
V
3 H
2 Z
0 X
N
512 90 558 125 R
7 X
V
1 60 Q
0 X
(n) 512.17 85 T
315 104 510 126 R
7 X
V
2 24 Q
0 X
(Routines) 407.33 110 T
90 99 270 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
90.67 123.5 270.67 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
2 10 Q
0 X
(Include:) 99 641.33 T
0 F
(clipbrd.goh) 180 641.33 T
2 F
(See Also:) 99 621.33 T
0 F
(ClipboardRequestItemFormat\050\051) 180 621.33 T
81 604.99 531 610 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 604.99 531 610 R
7 X
0 0 0 1 0 0 0 K
V
50 608.99 609.01 608.99 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 596.99 T
2 F
(ClipboardRemoveFromNoti\336cationList\050\051) 99 596.99 T
3 10 Q
(Boolean) 99 582.33 T
4 F
(ClipboardRemoveFromNotificationList\050) 153 582.33 T
4 9 Q
(optr) 153 571.99 T
(notificationOD\051;) 189 571.99 T
0 10 Q
(This routine removes an object or Process from the clipboard\325) 180 554.33 T
(s change) 461.49 554.33 T
(noti\336cation list. It is typically called when the object or Process is being) 180 542.83 T
(detached or destroyed. Pass it the same optr that was added to the) 180 531.33 T
(noti\336cation list with) 180 519.83 T
5 F
(ClipboardAddT) 276.5 519.83 T
(oNoti\336cationList) 355.96 519.83 T
0 F
(\050\051.) 444.09 519.83 T
-0.38 (This routine returns an error \337ag: The \337ag will be) 180 501.33 P
6 F
-0.38 (true) 410.31 501.33 P
0 F
-0.38 ( if the object could not) 428.82 501.33 P
(be found in the noti\336cation list,) 180 489.83 T
6 F
(false) 327.8 489.83 T
0 F
( if the object was successfully removed) 349.08 489.83 T
(from the list.) 180 478.33 T
2 F
(Include:) 99 459.83 T
0 F
(clipbrd.goh) 180 459.83 T
2 F
(See Also:) 99 439.83 T
0 F
(ClipboardAddT) 180 439.83 T
(oNoti\336cationList\050\051) 250.01 439.83 T
81 423.48 531 428.49 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 423.48 531 428.49 R
7 X
0 0 0 1 0 0 0 K
V
50 427.48 609.01 427.48 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 415.48 T
2 F
(ClipboardRequestItemFormat\050\051) 99 415.48 T
3 10 Q
(void) 99 400.82 T
4 F
(ClipboardRequestItemFormat\050) 153 400.82 T
4 9 Q
(ClipboardItemFormatID) 153 390.48 T
(format,) 279 390.48 T
(TransferBlockID) 153 380.48 T
(header,) 279 380.48 T
(ClipboardRequestArgs *) 153 370.48 T
(retValue\051;) 279 370.48 T
0 10 Q
(This routine returns speci\336c information about a particular transfer item.) 180 352.82 T
(Because some of the passed information must be retrieved with) 180 341.32 T
5 F
(ClipboardQueryItem\050\051) 180 329.82 T
0 F
(, you must call) 296.3 329.82 T
5 F
(ClipboardQueryItem\050\051) 366.5 329.82 T
0 F
( before) 482.8 329.82 T
(calling this routine.) 180 318.32 T
(Pass this routine the following:) 180 299.82 T
6 F
(format) 180 281.32 T
0 F
-0.36 (The manufacturer) 243 281.32 P
0 9 Q
-0.32 (ID) 329.5 281.32 P
0 10 Q
-0.36 ( and format type of the new transfer item) 340.16 281.32 P
(being put into the transfer) 243 270.32 T
0 9 Q
(VM) 368.38 270.32 T
0 10 Q
( \336le. Create the) 383.37 270.32 T
5 F
(ClipboardItemFormatID) 243 259.32 T
0 F
( value with the macro) 370.59 259.32 T
5 F
(FormatIDFromManufacturerAndT) 243 248.32 T
(ype\050\051) 422.66 248.32 T
0 F
(.) 448.96 248.32 T
6 F
(header) 180 230.32 T
0 F
-0.22 (Header information for the item, consisting of the transfer) 243 230.32 P
0 9 Q
-0.2 (VM) 513.44 230.32 P
0 10 Q
-0.48 (\336le handle and the) 243 219.32 P
0 9 Q
-0.43 (VM) 330.55 219.32 P
0 10 Q
-0.48 ( block handle of the block containing the) 345.54 219.32 P
(new transfer item. Create the) 243 208.32 T
5 F
(T) 383.01 208.32 T
(ransferBlockID) 389.61 208.32 T
0 F
( structure) 469.99 208.32 T
(using the macro) 243 197.32 T
5 F
(BlockIDFromFileAndBlock\050\051) 320.04 197.32 T
0 F
( using) 469.31 197.32 T
(returned information from) 243 186.32 T
5 F
(ClipboardQueryItem\050\051) 368.36 186.32 T
0 F
(.) 484.66 186.32 T
6 F
(retV) 180 168.32 T
(alue) 198.15 168.32 T
0 F
-0.62 (A pointer to an empty) 243 168.32 P
5 F
-0.64 (ClipboardRequestArgs) 343.79 168.32 P
0 F
-0.62 ( structure that) 462.13 168.32 P
-0.54 (will be \336lled by the routine. This structure is de\336ned as follows:) 243 157.32 P
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "75" 25
%%Page: "76" 26
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
54 690.34 450 702 R
7 X
0 0 0 1 0 0 0 K
V
54 666.34 450 678.01 R
V
0 10 Q
0 X
(76) 54 671.34 T
32 684 288 684 2 L
7 X
V
3 H
2 Z
0 X
N
54 90 108 125 R
7 X
V
1 60 Q
0 X
(n) 58.17 85 T
104 104 299 126 R
7 X
V
2 24 Q
0 X
(Routines) 104 110 T
306 99 486 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
306 123.5 486 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
4 9 Q
0 X
(typedef struct {) 216 642 T
(VMFileHandle) 252 632 T
(CRA_file;) 324 632 T
(VMChain) 252 622 T
(CRA_data;) 324 622 T
(word) 252 612 T
(CRA_extra1;) 324 612 T
(word) 252 602 T
(CRA_extra2;) 324 602 T
(} ClipboardRequestArgs;) 216 592 T
0 10 Q
(Upon return, the) 180 574.33 T
6 9 Q
(CRA_) 261.11 574.33 T
6 10 Q
(\336le) 285.11 574.33 T
0 F
( \336eld will contain the transfer) 298.99 574.33 T
0 9 Q
(VM) 439.56 574.33 T
0 10 Q
( \336le\325) 454.56 574.33 T
(s) 473.27 574.33 T
0 9 Q
(VM) 480.68 574.33 T
0 10 Q
( \336le) 495.67 574.33 T
(handle and the) 180 562.83 T
6 9 Q
(CRA_) 252.42 562.83 T
6 10 Q
(data) 276.42 562.83 T
0 F
( \336eld will contain the) 297.53 562.83 T
0 9 Q
(VM) 397.92 562.83 T
0 10 Q
( block handle of the) 412.92 562.83 T
(transfer item\325) 180 551.33 T
(s header block. If there is no transfer item,) 242.78 551.33 T
6 9 Q
(CRA_) 442.98 551.33 T
6 10 Q
(data) 466.98 551.33 T
0 F
( will be) 488.09 551.33 T
(zero.) 180 539.83 T
2 F
(Include:) 99 521.33 T
0 F
(clipbrd.goh) 180 521.33 T
2 F
(See Also:) 99 501.33 T
0 F
(ClipboardRegisterItem\050\051, ClipboardQueryItem\050\051) 180 501.33 T
81 484.99 531 490 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 484.99 531 490 R
7 X
0 0 0 1 0 0 0 K
V
50 488.99 609.01 488.99 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 476.99 T
2 F
(ClipboardSetQuickT) 99 476.99 T
(ransferFeedback\050\051) 213.7 476.99 T
3 10 Q
(void) 99 462.33 T
4 F
(ClipboardSetQuickTransferFeedback\050) 153 462.33 T
4 9 Q
(ClipboardQuickTransferFeedback) 153 451.99 T
(cursor,) 333 451.99 T
(UIFunctionsActive) 153 441.99 T
(buttonFlags\051;) 333 441.99 T
0 10 Q
(This routine sets the image of the mouse pointer during a quick-transfer) 180 424.33 T
-0.22 (operation. Use this routine to provide visual feedback to the user during the) 180 412.83 P
(quick-transfer) 180 401.33 T
(. For example, an object that could not accept the) 245.18 401.33 T
(quick-transfer item would set the \322no operation\323 cursor while the mouse) 180 389.83 T
(pointer was over its bounds.) 180 378.33 T
(Pass the two following values:) 180 359.83 T
6 F
(cursor) 180 341.33 T
0 F
(A value of) 243 341.33 T
5 F
(ClipboardQuickT) 292.08 341.33 T
(ransferFeedback) 382.02 341.33 T
0 F
( type) 470.18 341.33 T
(indicating the type of cursor to set. The possible values are) 243 330.33 T
(listed below) 243 319.33 T
(.) 296.91 319.33 T
6 F
(buttonFlags) 180 301.33 T
0 F
-0.22 (A record of) 243 301.33 P
5 F
-0.23 (UIFunctionsActive) 295.29 301.33 P
0 F
-0.22 ( \337ags. These \337ags are de\336ned) 393.42 301.33 P
-0.72 (in the Input Manager section and deal with user override of the) 243 290.33 P
(move/copy behavior) 243 279.33 T
(.) 332.82 279.33 T
(The cursor parameter contains a value of) 180 261.33 T
5 F
(ClipboardQuickT) 180 249.83 T
(ransferFeedback) 269.94 249.83 T
0 F
(. This is an enumerated type that) 358.1 249.83 T
(de\336nes the cursor to be set, and it has the following values:) 180 238.33 T
0 9 Q
(CQTF_MOVE) 180 219.83 T
0 10 Q
(This sets the cursor to the speci\336c) 243 219.83 T
0 9 Q
(UI) 402.63 219.83 T
0 10 Q
(\325) 413.63 219.83 T
(s move cursor) 415.3 219.83 T
(.) 478.07 219.83 T
0 9 Q
(CQTF_COPY) 180 201.83 T
0 10 Q
(This sets the cursor to the speci\336c) 243 201.83 T
0 9 Q
(UI) 402.63 201.83 T
0 10 Q
(\325) 413.63 201.83 T
(s copy cursor) 415.3 201.83 T
(.) 474.36 201.83 T
0 9 Q
(CQTF_CLEAR) 180 183.83 T
0 10 Q
-0.16 (This clears the cursor and sets it to the speci\336c) 244.5 183.83 P
0 9 Q
-0.15 (UI) 462.51 183.83 P
0 10 Q
-0.16 (\325) 473.51 183.83 P
-0.16 (s modal \322no) 475.18 183.83 P
(operation\323 cursor) 243 172.83 T
(.) 321.88 172.83 T
2 F
(Include:) 99 154.83 T
0 F
(clipbrd.goh) 180 154.83 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "76" 26
%%Page: "77" 27
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
162 690.34 558 702 R
7 X
0 0 0 1 0 0 0 K
V
162 666.34 558 678.01 R
V
0 10 Q
0 X
(77) 546.88 671.34 T
324 684 580 684 2 L
7 X
V
3 H
2 Z
0 X
N
512 90 558 125 R
7 X
V
1 60 Q
0 X
(n) 512.17 85 T
315 104 510 126 R
7 X
V
2 24 Q
0 X
(Routines) 407.33 110 T
90 99 270 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
90.67 123.5 270.67 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
81 642.99 531 648 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 642.99 531 648 R
7 X
0 0 0 1 0 0 0 K
V
50 646.99 609.01 646.99 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 634.99 T
2 F
(ClipboardStartQuickT) 99 634.99 T
(ransfer\050\051) 222.36 634.99 T
3 10 Q
(Boolean) 99 620.33 T
4 F
(ClipboardStartQuickTransfer\050) 153 620.33 T
4 9 Q
(ClipboardQuickTransferFlags) 153 609.99 T
(flags,) 351 609.99 T
(ClipboardQuickTransferFeedback) 153 599.99 T
(initialCursor,) 351 599.99 T
(word) 153 589.99 T
(mouseXPos,) 351 589.99 T
(word) 153 579.99 T
(mouseYPos,) 351 579.99 T
(ClipboardQuickTransferRegionInfo *) 153 569.99 T
(regionParams,) 351 569.99 T
(optr) 153 559.99 T
(notificationOD\051;) 351 559.99 T
0 10 Q
-0.84 (This routine signals the beginning of a quick-transfer operation. T) 180 542.33 P
-0.84 (ypically) 477.86 542.33 P
-0.84 (, an) 512.67 542.33 P
-0.36 (object or process will call this routine in its) 180 530.83 P
0 9 Q
-0.32 (MSG_MET) 377.9 530.83 P
-0.32 (A_ST) 424.07 530.83 P
-0.32 (ART_MOVE_COPY) 446.25 530.83 P
0 10 Q
(handler) 180 519.33 T
(.) 215.37 519.33 T
(Pass it the following parameters:) 180 500.83 T
6 F
(\337ags) 180 482.33 T
0 F
(A record of) 243 482.33 T
5 F
(ClipboardQuickT) 295.95 482.33 T
(ransferFlags) 385.89 482.33 T
0 F
( indicating) 451.82 482.33 T
(whether an addition graphic region will be attached to the) 243 471.33 T
(cursor and whether the caller wants noti\336cation of transfer) 243 460.33 T
(completion. The \337ags allowed are listed below) 243 449.33 T
(, after the) 453.79 449.33 T
(parameter list.) 243 438.33 T
6 F
(initialCursor) 180 420.33 T
0 F
(The initial cursor to use for visual feedback to the user) 243 409.33 T
(. It is a) 495.06 409.33 T
(value of) 243 398.33 T
5 F
(ClipboardQuickT) 282.08 398.33 T
(ransferFeedback) 372.02 398.33 T
0 F
(, either) 460.18 398.33 T
0 9 Q
(CQTF_MOVE) 243 387.33 T
0 10 Q
( or) 301.5 387.33 T
0 9 Q
(CQTF_COPY) 316.5 387.33 T
0 10 Q
(. If -1 is passed in this parameter) 371.23 387.33 T
(,) 523.66 387.33 T
(the initial cursor will be the default no-operation cursor \050i.e.) 243 376.33 T
(the transfer source may not also act as the transfer) 243 365.33 T
(destination\051.) 243 354.33 T
6 F
(mouseXPos) 180 336.33 T
0 F
-0.3 (This \336eld is used only if) 243 336.33 P
0 9 Q
-0.27 (CQTF_USE_REGION) 353.81 336.33 P
0 10 Q
-0.3 ( is passed in) 445.82 336.33 P
6 F
-0.3 (\337ags) 504.08 336.33 P
0 F
-0.3 (.) 525.74 336.33 P
-0.2 (It is the horizontal position of the mouse in screen coordinates.) 243 325.33 P
6 F
(mouseYPos) 180 307.33 T
0 F
-0.3 (This \336eld is used only if) 243 307.33 P
0 9 Q
-0.27 (CQTF_USE_REGION) 353.81 307.33 P
0 10 Q
-0.3 ( is passed in) 445.82 307.33 P
6 F
-0.3 (\337ags) 504.08 307.33 P
0 F
-0.3 (.) 525.74 307.33 P
(It is the vertical position of the mouse in screen coordinates.) 243 296.33 T
6 F
(regionParams) 180 278.33 T
0 F
(A pointer to a) 243 267.33 T
5 F
(ClipboardQuickT) 309.12 267.33 T
(ransferRegionInfo) 399.06 267.33 T
0 F
(structure de\336ning the graphical region to be attached to the) 243 256.33 T
(cursor during the transfer operation. This structure is only) 243 245.33 T
(required if) 243 234.33 T
0 9 Q
(CQTF_USE_REGION) 294.48 234.33 T
0 10 Q
( is passed in) 386.49 234.33 T
6 F
(\337ags) 445.95 234.33 T
0 F
(. It is de\336ned) 467.61 234.33 T
(below) 243 223.33 T
(.) 268.57 223.33 T
6 F
(noti\336cationOD) 180 205.33 T
0 F
(The optr of the object to be noti\336ed upon transfer completion.) 243 194.33 T
(The object speci\336ed will receive the noti\336cation messages) 243 183.33 T
0 9 Q
(MSG_MET) 243 172.33 T
(A_CLIPBOARD_NOTIFY_QUICK_TRANSFER_CONCL) 289.17 172.33 T
(UDED) 243 161.33 T
0 10 Q
( and) 270.84 161.33 T
0 9 Q
(MSG_\311_FEEDBACK) 293.81 161.33 T
0 10 Q
(.) 385.47 161.33 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "77" 27
%%Page: "78" 28
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
54 690.34 450 702 R
7 X
0 0 0 1 0 0 0 K
V
54 666.34 450 678.01 R
V
0 10 Q
0 X
(78) 54 671.34 T
32 684 288 684 2 L
7 X
V
3 H
2 Z
0 X
N
54 90 108 125 R
7 X
V
1 60 Q
0 X
(n) 58.17 85 T
104 104 299 126 R
7 X
V
2 24 Q
0 X
(Routines) 104 110 T
306 99 486 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
306 123.5 486 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
0 10 Q
0 X
(The allowed) 180 641.33 T
5 F
(ClipboardQuickT) 238.72 641.33 T
(ransferFlags) 328.66 641.33 T
0 F
( are listed below:) 394.59 641.33 T
0 9 Q
(CQTF_COPY_ONL) 180 622.83 T
(Y) 259.86 622.83 T
0 10 Q
(Source supports copying only \050not cutting\051.) 243 611.83 T
0 9 Q
(CQTF_USE_REGION) 180 593.83 T
0 10 Q
(Source has passed the de\336nition of a graphical region which) 243 582.83 T
(will be attached to the tail of the quick-transfer cursor) 243 571.83 T
(.) 493.21 571.83 T
0 9 Q
(CQTF_NOTIFICA) 180 553.83 T
(TION) 256.18 553.83 T
0 10 Q
(Source requires noti\336cation of completion of the transfer in) 243 542.83 T
(order to cut original data or provide other feedback.) 243 531.83 T
-0.13 (If a graphical region is to be attached to the quick-transfer cursor) 180 513.83 P
-0.13 (, you must) 480.27 513.83 P
(pass a pointer to a) 180 502.33 T
5 F
(ClipboardQuickT) 267.8 502.33 T
(ransferRegionInfo) 357.74 502.33 T
0 F
( in the) 453.66 502.33 T
6 F
(regionParams) 180 490.83 T
0 F
( parameter) 244.61 490.83 T
(. This structure is de\336ned below) 295.17 490.83 T
(.) 442.41 490.83 T
4 9 Q
(typedef struct {) 216 476 T
(word) 252 466 T
(CQTRI_paramAX;) 288 466 T
(word) 252 456 T
(CQTRI_paramBX;) 288 456 T
(word) 252 446 T
(CQTRI_paramCX;) 288 446 T
(word) 252 436 T
(CQTRI_paramDX;) 288 436 T
(Point) 252 426 T
(CQTRI_regionPos;) 288 426 T
(dword) 252 416 T
(CQTRI_strategy;) 288 416 T
(dword) 252 406 T
(CQTRI_region;) 288 406 T
(} ClipboardQuickTransferRegionInfo;) 216 396 T
0 10 Q
(This structure is passed on the stack to the routine. The \336rst four \336elds) 180 378.33 T
(represent the region\325) 180 366.83 T
(s de\336nition parameters.) 275.55 366.83 T
6 9 Q
(CQTRI_) 388.71 366.83 T
6 10 Q
(regionPos) 423.21 366.83 T
0 F
( is a) 468.01 366.83 T
5 F
(Point) 489.69 366.83 T
0 F
-0.47 (structure indicating where \050in screen coordinates\051 the region is to be located.) 180 355.33 P
6 9 Q
(CQTRI_) 180 343.83 T
6 10 Q
(strategy) 214.5 343.83 T
0 F
( is a pointer to the region strategy routine.) 250.97 343.83 T
6 9 Q
(CQTRI) 450.25 343.83 T
6 10 Q
(_strategy) 480.24 343.83 T
0 F
-0.16 (should be a video driver strategy) 180 332.33 P
-0.16 (. T) 329.41 332.33 P
-0.16 (o \336nd out the strategy of the video driver) 340.56 332.33 P
-0.31 (associated with your window) 180 320.83 P
-0.31 (, send your object a) 311.51 320.83 P
0 9 Q
-0.28 (MSG_VIS_VUP_QUER) 401.45 320.83 P
-0.28 (Y) 498.79 320.83 P
0 10 Q
-0.31 ( with) 505.13 320.83 P
0 9 Q
(VUQ_VIDEO_DRIVER) 180 309.33 T
0 10 Q
(. Pass the handle thus gained to) 277.15 309.33 T
5 F
(GeodeInfoDriver\050\051) 428.11 309.33 T
0 F
(,) 524.03 309.33 T
(which will return the strategy) 180 297.83 T
(.) 317.97 297.83 T
-0.12 (This routine returns an error \337ag: If a quick-transfer is already in progress,) 180 279.33 P
(the return will be) 180 267.83 T
6 F
(true) 263.9 267.83 T
0 F
(. If the quick-transfer is successfully begun, the error) 282.41 267.83 T
(\337ag will be) 180 256.33 T
6 F
(false) 233.17 256.33 T
0 F
(.) 254.45 256.33 T
2 F
(Include:) 99 237.83 T
0 F
(clipbrd.goh) 180 237.83 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "78" 28
%%Page: "79" 29
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
162 690.34 558 702 R
7 X
0 0 0 1 0 0 0 K
V
162 666.34 558 678.01 R
V
0 10 Q
0 X
(79) 546.88 671.34 T
324 684 580 684 2 L
7 X
V
3 H
2 Z
0 X
N
512 90 558 125 R
7 X
V
1 60 Q
0 X
(n) 512.17 85 T
315 104 510 126 R
7 X
V
2 24 Q
0 X
(Routines) 407.33 110 T
90 99 270 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
90.67 123.5 270.67 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
81 642.99 531 648 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 642.99 531 648 R
7 X
0 0 0 1 0 0 0 K
V
50 646.99 609.01 646.99 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 634.99 T
2 F
(ClipboardT) 99 634.99 T
(estItemFormat\050\051) 161.45 634.99 T
3 10 Q
(Boolean) 99 620.33 T
4 F
(ClipboardTestItemFormat\050) 153 620.33 T
4 9 Q
(TransferBlockID) 153 609.99 T
(header,) 261 609.99 T
(ClipboardFormatID) 153 599.99 T
(format\051;) 261 599.99 T
0 10 Q
(This routine tests whether the given format is supported by the speci\336ed) 180 582.33 T
-0.27 (transfer item. It returns) 180 570.83 P
6 F
-0.27 (true) 293.75 570.83 P
0 F
-0.27 ( if the format is supported,) 312.26 570.83 P
6 F
-0.27 (false) 436.78 570.83 P
0 F
-0.27 ( if the format is) 458.06 570.83 P
(not supported. Pass the following values:) 180 559.33 T
6 F
(header) 180 540.83 T
0 F
(A) 243 540.83 T
5 F
(T) 253 540.83 T
(ransferBlockID) 259.6 540.83 T
0 F
( specifying the) 339.98 540.83 T
0 9 Q
(VM) 409.61 540.83 T
0 10 Q
( \336le handle and) 424.6 540.83 T
0 9 Q
(VM) 499.06 540.83 T
0 10 Q
(block handle of the transfer item to be checked. This is) 243 529.83 T
(returned by the routines) 243 518.83 T
5 F
(ClipboardGetNormalItemInfo\050\051) 359.11 518.83 T
0 F
(,) 521.7 518.83 T
5 F
(ClipboardGetQuickItemInfo\050\051) 243 507.83 T
0 F
(,) 397.81 507.83 T
5 F
(ClipboardGetUndoItemInfo\050\051) 243 496.83 T
0 F
(, and) 394.66 496.83 T
5 F
-0.43 (ClipboardQueryItem\050\051) 243 485.83 P
0 F
-0.41 (. Most often the proper routine to use) 359.3 485.83 P
(is) 243 474.83 T
5 F
(ClipboardQueryItem\050\051) 253.56 474.83 T
0 F
(.) 369.86 474.83 T
6 F
(format) 180 456.83 T
0 F
-0.68 (A) 243 456.83 P
5 F
-0.7 (ClipboardFormatID) 252.32 456.83 P
0 F
-0.68 ( specifying the type and manufacturer) 355.84 456.83 P
0 9 Q
-0.12 (ID) 243 445.83 P
0 10 Q
-0.14 ( of the format to be checked. It is most appropriate to create) 253.66 445.83 P
(this parameter from its individual parts using the macro) 243 434.83 T
5 F
(FormatIDFromManufacturerAndT) 243 423.83 T
(ype\050\051) 422.66 423.83 T
0 F
(.) 448.96 423.83 T
2 F
(Include:) 99 405.83 T
0 F
(clipbrd.goh) 180 405.83 T
81 389.48 531 394.49 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 389.48 531 394.49 R
7 X
0 0 0 1 0 0 0 K
V
50 393.48 609.01 393.48 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 381.48 T
2 F
(ClipboardUnregisterItem\050\051) 99 381.48 T
3 10 Q
(void) 99 366.82 T
4 F
(ClipboardUnregisterItem\050) 153 366.82 T
4 9 Q
(optr) 153 356.48 T
(owner\051;) 189 356.48 T
0 10 Q
(This routine restores the transfer item to what it was before the last) 180 338.82 T
5 F
(ClipboardRegisterItem\050\051) 180 327.32 T
0 F
(. Pass it the optr of the caller) 307.97 327.32 T
(.) 441.14 327.32 T
(Only the object that last registered a transfer item is allowed to unregister) 180 308.82 T
-0.41 (it. If the transfer item is owned by a different object, or if there is no transfer) 180 297.32 P
(item, nothing will be done. If the transfer item is owned by the caller) 180 285.82 T
(, the) 497.08 285.82 T
(transfer item will be unregistered and the clipboard will be restored to its) 180 274.32 T
(previous state.) 180 262.82 T
2 F
(Include:) 99 244.32 T
0 F
(clipbrd.goh) 180 244.32 T
81 227.98 531 232.98 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 227.98 531 232.98 R
7 X
0 0 0 1 0 0 0 K
V
50 231.98 609.01 231.98 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 219.97 T
2 F
(ConstructOptr\050\051) 99 219.97 T
3 10 Q
(optr) 99 205.31 T
4 F
(ConstructOptr\050) 153 205.31 T
4 9 Q
(Handle) 153 194.97 T
(han,) 261 194.97 T
(ChunkHandle) 153 184.97 T
(ch\051;) 261 184.97 T
0 10 Q
(This macro constructs an optr type from the given handle \050typically a) 180 167.31 T
(MemHandle\051 and chunk handle.) 180 155.81 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "79" 29
%%Page: "80" 30
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
54 690.34 450 702 R
7 X
0 0 0 1 0 0 0 K
V
54 666.34 450 678.01 R
V
0 10 Q
0 X
(80) 54 671.34 T
32 684 288 684 2 L
7 X
V
3 H
2 Z
0 X
N
54 90 108 125 R
7 X
V
1 60 Q
0 X
(n) 58.17 85 T
104 104 299 126 R
7 X
V
2 24 Q
0 X
(Routines) 104 110 T
306 99 486 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
306 123.5 486 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
2 10 Q
0 X
(See Also:) 99 641.33 T
0 F
(HandleT) 180 641.33 T
(oOptr\050\051, OptrT) 219.64 641.33 T
(oHandle\050\051, OptrT) 286.31 641.33 T
(oChunk\050\051) 365.02 641.33 T
81 624.99 531 630 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 624.99 531 630 R
7 X
0 0 0 1 0 0 0 K
V
50 628.99 609.01 628.99 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 616.99 T
2 F
(DBAlloc\050\051) 99 616.99 T
3 10 Q
(DBItem) 99 602.33 T
4 F
(DBAlloc\050) 153 602.33 T
4 9 Q
(VMFileHandle) 153 591.99 T
(file,) 261 591.99 T
(DBGroup) 153 581.99 T
(group,) 261 581.99 T
(word) 153 571.99 T
(size\051;) 261 571.99 T
0 10 Q
-0.34 (This routine allocates an item in the speci\336ed \336le and group. It is passed the) 180 554.33 P
-0.49 (handles for the \336le and group which will contain the new item. It returns the) 180 542.83 P
(new item\325) 180 531.33 T
(s item-handle.) 224.27 531.33 T
2 F
(W) 99 512.83 T
(arnings:) 108.07 512.83 T
0 F
(All pointers to items in the group may be invalidated.) 180 512.83 T
2 F
(Include:) 99 492.83 T
0 F
(dbase.h) 180 492.83 T
2 F
(See Also:) 99 472.83 T
0 F
(DBAllocUngrouped\050\051) 180 472.83 T
81 456.48 531 461.49 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 456.48 531 461.49 R
7 X
0 0 0 1 0 0 0 K
V
50 460.48 609.01 460.48 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 448.48 T
2 F
(DBAllocUngrouped\050\051) 99 448.48 T
3 10 Q
(DBGroupAndItem) 99 433.82 T
4 F
(DBAllocUngrouped\050) 189 433.82 T
4 9 Q
(VMFileHandle) 153 423.48 T
(file,) 261 423.48 T
(word) 153 413.48 T
(size\051;) 261 413.48 T
0 10 Q
-0.57 (This routine allocates an ungrouped item in the speci\336ed \336le. It is passed the) 180 395.82 P
(handle of the \336le which will contain the new item. It returns the item\325) 180 384.32 T
(s) 502.26 384.32 T
5 F
(DBGroupAndItem) 180 372.82 T
0 F
( value.) 274.44 372.82 T
2 F
(W) 99 354.32 T
(arnings:) 108.07 354.32 T
0 F
(All pointers to ungrouped items may be invalidated.) 180 354.32 T
2 F
(Include:) 99 334.32 T
0 F
(dbase.h) 180 334.32 T
2 F
(See Also:) 99 314.32 T
0 F
(DBAlloc\050\051) 180 314.32 T
81 297.98 531 302.98 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 297.98 531 302.98 R
7 X
0 0 0 1 0 0 0 K
V
50 301.98 609.01 301.98 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 289.98 T
2 F
(DBCombineGroupAndItem\050\051) 99 289.98 T
3 10 Q
(DBGroupAndItem) 99 275.31 T
4 F
(DBCombineGroupAndItem\050) 189 275.31 T
4 9 Q
(DBGroup) 153 264.97 T
(group,) 261 264.97 T
(DBItem) 153 254.97 T
(item\051;) 261 254.97 T
0 10 Q
(This macro combines group and item handles into a dword-sized) 180 237.31 T
5 F
(DBGroupAndItem) 180 225.81 T
0 F
( value.) 274.44 225.81 T
2 F
(Include:) 99 207.31 T
0 F
(dbase.h) 180 207.31 T
2 F
(See Also:) 99 187.31 T
0 F
(DBGroupFromGroupAndItem\050\051, DBItemFromGroupAndItem\050\051) 180 187.31 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "80" 30
%%Page: "81" 31
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
162 690.34 558 702 R
7 X
0 0 0 1 0 0 0 K
V
162 666.34 558 678.01 R
V
0 10 Q
0 X
(81) 546.88 671.34 T
324 684 580 684 2 L
7 X
V
3 H
2 Z
0 X
N
512 90 558 125 R
7 X
V
1 60 Q
0 X
(n) 512.17 85 T
315 104 510 126 R
7 X
V
2 24 Q
0 X
(Routines) 407.33 110 T
90 99 270 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
90.67 123.5 270.67 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
81 642.99 531 648 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 642.99 531 648 R
7 X
0 0 0 1 0 0 0 K
V
50 646.99 609.01 646.99 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 634.99 T
2 F
(DBCopyDBItem\050\051) 99 634.99 T
3 10 Q
(DBItem) 99 620.33 T
4 F
(DBCopyDBItem\050) 153 620.33 T
4 9 Q
(VMFileHandle) 153 609.99 T
(srcFile,) 261 609.99 T
(DBGroup) 153 599.99 T
(srcGroup,) 261 599.99 T
(DBItem) 153 589.99 T
(srcItem,) 261 589.99 T
(VMFileHandle) 153 579.99 T
(destFile,) 261 579.99 T
(DBGroup) 153 569.99 T
(destGroup\051;) 261 569.99 T
0 10 Q
-0.82 (This routine makes a duplicate of a) 180 552.33 P
0 9 Q
-0.74 (DB) 340.23 552.33 P
0 10 Q
-0.82 ( item in the speci\336ed) 353.73 552.33 P
0 9 Q
-0.74 (DB) 448.54 552.33 P
0 10 Q
-0.82 ( \336le and group.) 462.04 552.33 P
-0.62 (It is passed the \336le handle, group handle, and item handle of the source item,) 180 540.83 P
-0.65 (as well as the \336le handle and group handle of the destination group. It makes) 180 529.33 P
(a copy of the) 180 517.83 T
0 9 Q
(DB) 240.56 517.83 T
0 10 Q
( item and returns its) 254.06 517.83 T
5 F
(DBItem) 352.59 517.83 T
0 F
( handle.) 392.77 517.83 T
2 F
(W) 99 499.33 T
(arnings:) 108.07 499.33 T
0 F
(All pointers to items in the destination group may be invalidated.) 180 499.33 T
2 F
(Include:) 99 479.33 T
0 F
(dbase.h) 180 479.33 T
2 F
(See Also:) 99 459.33 T
0 F
(VMCopyVMChain\050\051) 180 459.33 T
81 442.98 531 447.99 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 442.98 531 447.99 R
7 X
0 0 0 1 0 0 0 K
V
50 446.98 609.01 446.98 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 434.98 T
2 F
(DBCopyDBItemUngrouped\050\051) 99 434.98 T
3 10 Q
(DBGroupAndItem) 99 420.32 T
4 F
(DBCopyDBItemUngrouped\050) 189 420.32 T
4 9 Q
(VMFileHandle) 153 409.98 T
(srcFile,) 261 409.98 T
(DBGroupAndItem) 153 399.98 T
(srcID,) 261 399.98 T
(/* source item */) 333 399.98 T
(VMFileHandle) 153 389.98 T
(destFile\051;) 261 389.98 T
0 10 Q
(This routine makes a duplicate of a speci\336ed DB item. It is passed the \336le) 180 372.32 T
-0.87 (handle and) 180 360.82 P
5 F
-0.9 (DBGroupAndItem) 232.9 360.82 P
0 F
-0.87 ( value specifying the source item, and the \336le) 327.34 360.82 P
(handle of the destination \336le. It allocates the item as an ungrouped item in) 180 349.32 T
(the speci\336ed \336le and returns its) 180 337.82 T
5 F
(DBGroupAndItem) 329.45 337.82 T
0 F
( value.) 423.89 337.82 T
2 F
(T) 99 319.32 T
(ips and T) 104.93 319.32 T
(ricks:) 148.28 319.32 T
0 F
(If the source item is not ungrouped, you can combine the group and item) 180 319.32 T
(handles into a) 180 306.32 T
5 F
(DBGroupAndItem) 248.35 306.32 T
0 F
( value by calling the macro) 342.79 306.32 T
5 F
(DBCombineGroupAndItem\050\051) 180 293.32 T
0 F
(.) 328.51 293.32 T
2 F
(W) 99 273.32 T
(arnings:) 108.07 273.32 T
0 F
(All pointers to ungrouped items in the destination \336le may be invalidated.) 180 273.32 T
2 F
(Include:) 99 253.32 T
0 F
(dbase.h) 180 253.32 T
2 F
(See Also:) 99 233.32 T
0 F
(VMCopyVMChain\050\051) 180 233.32 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "81" 31
%%Page: "82" 32
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
54 690.34 450 702 R
7 X
0 0 0 1 0 0 0 K
V
54 666.34 450 678.01 R
V
0 10 Q
0 X
(82) 54 671.34 T
32 684 288 684 2 L
7 X
V
3 H
2 Z
0 X
N
54 90 108 125 R
7 X
V
1 60 Q
0 X
(n) 58.17 85 T
104 104 299 126 R
7 X
V
2 24 Q
0 X
(Routines) 104 110 T
306 99 486 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
306 123.5 486 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
81 642.99 531 648 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 642.99 531 648 R
7 X
0 0 0 1 0 0 0 K
V
50 646.99 609.01 646.99 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 634.99 T
2 F
(DBDeleteAt\050\051) 99 634.99 T
3 10 Q
(void) 99 620.33 T
4 F
(DBDeleteAt\050) 153 620.33 T
4 9 Q
(VMFileHandle) 153 609.99 T
(file,) 261 609.99 T
(DBGroup) 153 599.99 T
(group,) 261 599.99 T
(DBItem) 153 589.99 T
(item,) 261 589.99 T
(word) 153 579.99 T
(deleteOffset,) 261 579.99 T
(word) 153 569.99 T
(deleteCount\051;) 261 569.99 T
0 10 Q
(This routine deletes a sequence of bytes from within an item. It does not) 180 552.33 T
-0.07 (invalidate pointers to other items. The routine is passed the \336le, group, and) 180 540.83 P
(item handles specifying the item, as well as an offset within the item and a) 180 529.33 T
(number of bytes to delete. It will delete the speci\336ed number of bytes from) 180 517.83 T
(within the item, starting with the byte at the speci\336ed offset.) 180 506.33 T
2 F
(Include:) 99 487.83 T
0 F
(dbase.h) 180 487.83 T
81 471.48 531 476.49 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 471.48 531 476.49 R
7 X
0 0 0 1 0 0 0 K
V
50 475.48 609.01 475.48 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 463.48 T
2 F
(DBDeleteAtUngrouped\050\051) 99 463.48 T
3 10 Q
(void) 99 448.82 T
4 F
(DBDeleteAtUngrouped\050) 153 448.82 T
4 9 Q
(VMFileHandle) 153 438.48 T
(file,) 261 438.48 T
(DBGroupAndItem) 153 428.48 T
(id,) 261 428.48 T
(word) 153 418.48 T
(deleteOffset,) 261 418.48 T
(word) 153 408.48 T
(deleteCount\051;) 261 408.48 T
0 10 Q
(This routine is just like) 180 390.82 T
5 F
(DBDeleteAt\050\051) 290.76 390.82 T
0 F
(, except it is passed a) 359.83 390.82 T
5 F
(DBGroupAndItem) 180 379.32 T
0 F
( value instead of separate group and item handles. It) 274.44 379.32 T
(does not invalidate pointers to other items.) 180 367.82 T
2 F
(Include:) 99 349.32 T
0 F
(dbase.h) 180 349.32 T
81 332.98 531 337.98 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 332.98 531 337.98 R
7 X
0 0 0 1 0 0 0 K
V
50 336.98 609.01 336.98 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 324.98 T
2 F
(DBDeref\050\051) 99 324.98 T
3 10 Q
(void *) 99 310.31 T
4 F
(DBDeref\050) 153 310.31 T
4 9 Q
(optr) 153 299.98 T
3 F
(*) 261 299.98 T
4 F
(ref\051;) 266.4 299.98 T
0 10 Q
(This routine is passed an optr to a locked) 180 282.31 T
0 9 Q
(DB) 372.81 282.31 T
0 10 Q
( item. The routine returns the) 386.31 282.31 T
(address of the item.) 180 270.81 T
2 F
(W) 99 252.31 T
(arnings:) 108.07 252.31 T
0 F
(The optr becomes invalid when the) 180 252.31 T
0 9 Q
(DB) 344.28 252.31 T
0 10 Q
( item is unlocked.) 357.78 252.31 T
2 F
(Include:) 99 232.31 T
0 F
(dbase.h) 180 232.31 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "82" 32
%%Page: "83" 33
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
162 690.34 558 702 R
7 X
0 0 0 1 0 0 0 K
V
162 666.34 558 678.01 R
V
0 10 Q
0 X
(83) 546.88 671.34 T
324 684 580 684 2 L
7 X
V
3 H
2 Z
0 X
N
512 90 558 125 R
7 X
V
1 60 Q
0 X
(n) 512.17 85 T
315 104 510 126 R
7 X
V
2 24 Q
0 X
(Routines) 407.33 110 T
90 99 270 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
90.67 123.5 270.67 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
81 642.99 531 648 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 642.99 531 648 R
7 X
0 0 0 1 0 0 0 K
V
50 646.99 609.01 646.99 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 634.99 T
2 F
(DBDirty\050\051) 99 634.99 T
3 10 Q
(void) 99 620.33 T
4 F
(DBUnlock\050) 153 620.33 T
4 9 Q
(const void *) 153 609.99 T
(ptr\051;) 261 609.99 T
0 10 Q
-0.63 (This routine marks a) 180 592.33 P
0 9 Q
-0.56 (DB) 277.88 592.33 P
0 10 Q
-0.63 ( item as dirty; this insures that the) 291.38 592.33 P
0 9 Q
-0.56 (VM) 451.39 592.33 P
0 10 Q
-0.63 ( manager will) 466.38 592.33 P
-0.3 (copy its item-block back to the disk before freeing its memory) 180 580.83 P
-0.3 (. The routine is) 459.05 580.83 P
(passed a pointer to anywhere within the item.) 180 569.33 T
2 F
(T) 99 550.83 T
(ips and T) 104.93 550.83 T
(ricks:) 148.28 550.83 T
0 F
-0.73 (All the items in an item block are marked dirty at once; thus, you can call this) 180 550.83 P
-0.26 (routine just once for several items in the same item block. Only the segment) 180 537.83 P
-0.49 (portion of the pointer is signi\336cant; thus, you can pass a pointer to anywhere) 180 524.83 P
(in the item. This is useful if you have incremented the pointer to the item.) 180 511.83 T
2 F
(Include:) 99 491.83 T
0 F
(dbase.h) 180 491.83 T
81 475.48 531 480.49 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 475.48 531 480.49 R
7 X
0 0 0 1 0 0 0 K
V
50 479.48 609.01 479.48 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 467.48 T
2 F
(DBFree\050\051) 99 467.48 T
3 10 Q
(void) 99 452.82 T
4 F
(DBFree\050) 153 452.82 T
4 9 Q
(VMFileHandle) 153 442.48 T
(file,) 261 442.48 T
(DBGroup) 153 432.48 T
(group,) 261 432.48 T
(DBItem) 153 422.48 T
(item\051;) 261 422.48 T
0 10 Q
-0.12 (This routine frees the speci\336ed item. It does not invalidate pointers to other) 180 404.82 P
(items in the group. It is passed the \336le, group, and item handles specifying) 180 393.32 T
(the item; it does not return anything.) 180 381.82 T
2 F
(Never Use Situations:) 99 363.32 T
0 F
-0.05 (Never call) 180 350.32 P
5 F
-0.05 (DBFree\050\051) 229.72 350.32 P
0 F
-0.05 ( on a locked item. If you do, the item-block\325) 277.5 350.32 P
-0.05 (s lock count) 474.11 350.32 P
(will not be decremented, which will prevent the item block from ever being) 180 337.32 T
(properly unlocked.) 180 324.32 T
2 F
(Include:) 99 304.32 T
0 F
(dbase.h) 180 304.32 T
2 F
(See Also:) 99 284.32 T
0 F
(DBFreeUngrouped\050\051) 180 284.32 T
81 267.98 531 272.98 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 267.98 531 272.98 R
7 X
0 0 0 1 0 0 0 K
V
50 271.98 609.01 271.98 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 259.97 T
2 F
(DBFreeUngrouped\050\051) 99 259.97 T
3 10 Q
(void) 99 245.31 T
4 F
(DBFreeUngrouped\050) 153 245.31 T
4 9 Q
(VMFileHandle) 153 234.97 T
(file,) 261 234.97 T
(DBGroupAndItem) 153 224.97 T
(id\051;) 261 224.97 T
0 10 Q
-0.12 (This routine frees the speci\336ed item. It does not invalidate pointers to other) 180 207.31 P
-0.23 (ungrouped items. It is passed the \336le handle and) 180 195.81 P
5 F
-0.24 (DBGroupAndItem) 406.27 195.81 P
0 F
-0.23 ( value) 500.71 195.81 P
(specifying the item; it does not return anything.) 180 184.31 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "83" 33
%%Page: "84" 34
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
54 690.34 450 702 R
7 X
0 0 0 1 0 0 0 K
V
54 666.34 450 678.01 R
V
0 10 Q
0 X
(84) 54 671.34 T
32 684 288 684 2 L
7 X
V
3 H
2 Z
0 X
N
54 90 108 125 R
7 X
V
1 60 Q
0 X
(n) 58.17 85 T
104 104 299 126 R
7 X
V
2 24 Q
0 X
(Routines) 104 110 T
306 99 486 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
306 123.5 486 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
2 10 Q
0 X
(Never Use Situations:) 99 641.33 T
0 F
(Never call) 205.14 641.33 T
5 F
(DBFreeUngrouped\050\051) 254.96 641.33 T
0 F
( on a locked item. If you do, the) 361.26 641.33 T
-0.18 (item-block\325) 180 628.33 P
-0.18 (s lock count will not be decremented, which will prevent the item) 230.01 628.33 P
(block from ever being properly unlocked.) 180 615.33 T
2 F
(Include:) 99 595.33 T
0 F
(dbase.h) 180 595.33 T
2 F
(See Also:) 99 575.33 T
0 F
(DBFree\050\051) 180 575.33 T
81 558.99 531 564 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 558.99 531 564 R
7 X
0 0 0 1 0 0 0 K
V
50 562.99 609.01 562.99 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 550.99 T
2 F
(DBGetMap\050\051) 99 550.99 T
3 10 Q
(DBGroupAndItem) 99 536.33 T
4 F
(DBGetmap\050) 189 536.33 T
4 9 Q
(VMFileHandle) 153 525.99 T
(file\051;) 261 525.99 T
0 10 Q
(This routine returns the) 180 508.33 T
5 F
(DBGroupAndItem) 295 508.33 T
0 F
( structure for the passed \336le\325) 389.44 508.33 T
(s) 521.29 508.33 T
(map item. If there is no map item, it returns a null handle.) 180 496.83 T
2 F
(Include:) 99 478.33 T
0 F
(dbase.h) 180 478.33 T
2 F
(See Also:) 99 458.33 T
0 F
(DBSetMap\050\051, DBLockMap\050\051) 180 458.33 T
81 441.98 531 446.99 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 441.98 531 446.99 R
7 X
0 0 0 1 0 0 0 K
V
50 445.98 609.01 445.98 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 433.98 T
2 F
(DBGroupAlloc\050\051) 99 433.98 T
3 10 Q
(DBGroup) 99 419.32 T
4 F
(DBGroupAlloc\050) 153 419.32 T
4 9 Q
(VMFileHandle) 153 408.98 T
(file\051;) 261 408.98 T
0 10 Q
(This routine allocates a new DB group in the speci\336ed \336le and returns its) 180 391.32 T
(handle. If the group cannot be allocated,) 180 379.82 T
5 F
(DBGroupAlloc\050\051) 368.91 379.82 T
0 F
( returns a null) 452.25 379.82 T
(handle.) 180 368.32 T
2 F
(Include:) 99 349.82 T
0 F
(dbase.h) 180 349.82 T
81 333.48 531 338.48 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 333.48 531 338.48 R
7 X
0 0 0 1 0 0 0 K
V
50 337.48 609.01 337.48 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 325.48 T
2 F
(DBGroupFree\050\051) 99 325.48 T
3 10 Q
(void) 99 310.81 T
4 F
(DBGroupFree\050) 153 310.81 T
4 9 Q
(VMFileHandle) 153 300.48 T
(file,) 261 300.48 T
(DBGroup) 153 290.48 T
(group\051;) 261 290.48 T
0 10 Q
-0.34 (This routine frees the speci\336ed group. This deletes all items and item-blocks) 180 272.81 P
(associated with the group. It is passed the \336le and group handle specifying) 180 261.31 T
-0.52 (the group. Note that you can free a group even if some of its items are locked;) 180 249.81 P
(those locked items will also be freed.) 180 238.31 T
2 F
(Include:) 99 219.81 T
0 F
(dbase.h) 180 219.81 T
81 203.47 531 208.47 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 203.47 531 208.47 R
7 X
0 0 0 1 0 0 0 K
V
50 207.47 609.01 207.47 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 195.47 T
2 F
(DBGroupFromGroupAndItem\050\051) 99 195.47 T
3 10 Q
(DBGroup) 99 180.8 T
4 F
(DBGroupFromGroupAndItem\050) 153 180.8 T
4 9 Q
(DBGroupAndItem) 153 170.47 T
(id\051;) 261 170.47 T
0 10 Q
(This macro returns the) 180 152.8 T
5 F
(DBGroup) 289.63 152.8 T
0 F
( portion of a) 338.89 152.8 T
5 F
(DBGroupAndItem) 397.23 152.8 T
0 F
( value.) 491.67 152.8 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "84" 34
%%Page: "85" 35
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
162 690.34 558 702 R
7 X
0 0 0 1 0 0 0 K
V
162 666.34 558 678.01 R
V
0 10 Q
0 X
(85) 546.88 671.34 T
324 684 580 684 2 L
7 X
V
3 H
2 Z
0 X
N
512 90 558 125 R
7 X
V
1 60 Q
0 X
(n) 512.17 85 T
315 104 510 126 R
7 X
V
2 24 Q
0 X
(Routines) 407.33 110 T
90 99 270 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
90.67 123.5 270.67 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
2 10 Q
0 X
(Include:) 99 641.33 T
0 F
(dbase.h) 180 641.33 T
81 624.99 531 630 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 624.99 531 630 R
7 X
0 0 0 1 0 0 0 K
V
50 628.99 609.01 628.99 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 616.99 T
2 F
(DBInsertAt\050\051) 99 616.99 T
3 10 Q
(void) 99 602.33 T
4 F
(DBInsertAt\050) 153 602.33 T
4 9 Q
(VMFileHandle) 153 591.99 T
(file,) 261 591.99 T
(DBGroup) 153 581.99 T
(group,) 261 581.99 T
(DBItem) 153 571.99 T
(item,) 261 571.99 T
(word) 153 561.99 T
(insertOffset,) 261 561.99 T
(word) 153 551.99 T
(insertCount\051;) 261 551.99 T
0 10 Q
-0.76 (This routine inserts bytes at a speci\336ed offset within a) 180 534.33 P
0 9 Q
-0.69 (DB) 426.48 534.33 P
0 10 Q
-0.76 ( item. The bytes are) 439.98 534.33 P
-0.45 (zero-initialized. It is passed the \336le, group, and item handles specifying a) 180 522.83 P
0 9 Q
-0.41 (DB) 515.17 522.83 P
0 10 Q
(item, as well as an offset within the cell and a number of bytes to insert. It) 180 511.33 T
(inserts the speci\336ed number of bytes beginning at the speci\336ed offset; the) 180 499.83 T
(data which was at the passed offset will end up immediately after the) 180 488.33 T
(inserted bytes.) 180 476.83 T
2 F
(W) 99 458.33 T
(arnings:) 108.07 458.33 T
0 F
(This routine invalidates pointers to other items in the same group.) 180 458.33 T
2 F
(Include:) 99 438.33 T
0 F
(dbase.h) 180 438.33 T
81 421.98 531 426.99 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 421.98 531 426.99 R
7 X
0 0 0 1 0 0 0 K
V
50 425.98 609.01 425.98 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 413.98 T
2 F
(DBInsertAtUngrouped\050\051) 99 413.98 T
3 10 Q
(void) 99 399.32 T
4 F
(DBInsertAtUngrouped\050) 153 399.32 T
4 9 Q
(VMFileHandle) 153 388.98 T
(file,) 261 388.98 T
(DBGroupAndItem) 153 378.98 T
(id,) 261 378.98 T
(word) 153 368.98 T
(insertOffset,) 261 368.98 T
(word) 153 358.98 T
(insertCount\051;) 261 358.98 T
0 10 Q
(This routine is just like) 180 341.32 T
5 F
(DBInsertAt\050\051) 290.76 341.32 T
0 F
(, except it is passed a) 357.98 341.32 T
5 F
(DBGroupAndItem) 180 329.82 T
0 F
( value instead of separate group and item handles.) 274.44 329.82 T
2 F
(W) 99 311.32 T
(arnings:) 108.07 311.32 T
0 F
(This routine invalidates pointers to other ungrouped items.) 180 311.32 T
2 F
(Include:) 99 291.32 T
0 F
(dbase.h) 180 291.32 T
81 274.98 531 279.98 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 274.98 531 279.98 R
7 X
0 0 0 1 0 0 0 K
V
50 278.98 609.01 278.98 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 266.97 T
2 F
(DBItemFromGroupAndItem\050\051) 99 266.97 T
3 10 Q
(DBItem) 99 252.31 T
4 F
(DBItemFromGroupAndItem\050) 153 252.31 T
4 9 Q
(DBGroupAndItem) 153 241.97 T
(id\051;) 261 241.97 T
0 10 Q
(This macro returns the) 180 224.31 T
5 F
(DBItem) 289.63 224.31 T
0 F
( portion of a) 329.81 224.31 T
5 F
(DBGroupAndItem) 388.15 224.31 T
0 F
( value.) 482.59 224.31 T
2 F
(Include:) 99 205.81 T
0 F
(dbase.h) 180 205.81 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "85" 35
%%Page: "86" 36
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
54 690.34 450 702 R
7 X
0 0 0 1 0 0 0 K
V
54 666.34 450 678.01 R
V
0 10 Q
0 X
(86) 54 671.34 T
32 684 288 684 2 L
7 X
V
3 H
2 Z
0 X
N
54 90 108 125 R
7 X
V
1 60 Q
0 X
(n) 58.17 85 T
104 104 299 126 R
7 X
V
2 24 Q
0 X
(Routines) 104 110 T
306 99 486 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
306 123.5 486 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
81 642.99 531 648 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 642.99 531 648 R
7 X
0 0 0 1 0 0 0 K
V
50 646.99 609.01 646.99 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 634.99 T
2 F
(DBLock\050\051) 99 634.99 T
3 10 Q
(void *) 99 620.33 T
4 F
(DBLock\050) 153 620.33 T
4 9 Q
(VMFileHandle) 153 609.99 T
(file,) 261 609.99 T
(DBGroup) 153 599.99 T
(group,) 261 599.99 T
(DBItem) 153 589.99 T
(item\051;) 261 589.99 T
0 10 Q
-0.04 (This routine locks the speci\336ed item and returns a pointer to it. It is passed) 180 572.33 P
-0.28 (the \336le, group, and item handles specifying a DB item. If it fails, it returns a) 180 560.83 P
(null pointer) 180 549.33 T
(.) 233.89 549.33 T
2 F
(Include:) 99 530.83 T
0 F
(dbase.h) 180 530.83 T
2 F
(See Also:) 99 510.83 T
0 F
(DBLockGetRef\050\051, DBLockUngrouped\050\051) 180 510.83 T
81 494.48 531 499.49 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 494.48 531 499.49 R
7 X
0 0 0 1 0 0 0 K
V
50 498.48 609.01 498.48 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 486.48 T
2 F
(DBLockGetRef\050\051) 99 486.48 T
3 10 Q
(void *) 99 471.82 T
4 F
(DBLockGetRef\050) 153 471.82 T
4 9 Q
(VMFileHandle) 153 461.48 T
(file,) 261 461.48 T
(DBGroup) 153 451.48 T
(group,) 261 451.48 T
(DBItem) 153 441.48 T
(item,) 261 441.48 T
(optr *) 153 431.48 T
(ref\051;) 261 431.48 T
0 10 Q
-0.65 (This routine is just like) 180 413.82 P
5 F
-0.67 (DBLock\050\051) 287.49 413.82 P
0 F
-0.65 (, except that it writes the item\325) 336.94 413.82 P
-0.65 (s optr to the) 474.9 413.82 P
(passed address.) 180 402.32 T
2 F
(Include:) 99 383.82 T
0 F
(dbase.h) 180 383.82 T
2 F
(W) 99 363.82 T
(arnings:) 108.07 363.82 T
0 F
(The optr is only valid until the) 180 363.82 T
0 9 Q
(DB) 324.1 363.82 T
0 10 Q
( item is unlocked.) 337.6 363.82 T
81 347.48 531 352.48 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 347.48 531 352.48 R
7 X
0 0 0 1 0 0 0 K
V
50 351.48 609.01 351.48 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 339.48 T
2 F
(DBLockGetRefUngrouped\050\051) 99 339.48 T
3 10 Q
(void *) 99 324.81 T
4 F
(DBLockGetRefUngrouped\050) 153 324.81 T
4 9 Q
(VMFileHandle) 153 314.48 T
(file,) 261 314.48 T
(DBGroupAndItem) 153 304.48 T
(id,) 261 304.48 T
(optr *) 153 294.48 T
(ref\051;) 261 294.48 T
0 10 Q
(This routine is the same as) 180 276.81 T
5 F
(DBLockGetRef\050\051) 307.99 276.81 T
0 F
(, except that it is passed a) 393.55 276.81 T
5 F
(DBGroupAndItem) 180 265.31 T
0 F
( value.) 274.44 265.31 T
2 F
(Include:) 99 246.81 T
0 F
(dbase.h) 180 246.81 T
81 230.47 531 235.47 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 230.47 531 235.47 R
7 X
0 0 0 1 0 0 0 K
V
50 234.47 609.01 234.47 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 222.47 T
2 F
(DBLockMap\050\051) 99 222.47 T
3 10 Q
(void *) 99 207.8 T
4 F
(DBLockMap\050) 153 207.8 T
4 9 Q
(VMFileHandle) 153 197.47 T
(file\051;) 261 197.47 T
0 10 Q
(This routine locks the speci\336ed \336le\325) 180 179.8 T
(s map item and returns its address. T) 342.05 179.8 T
(o) 515.23 179.8 T
(unlock the map item, call) 180 168.3 T
5 F
(DBUnlock\050\051) 299.84 168.3 T
0 F
( normally) 360.77 168.3 T
(.) 404.11 168.3 T
2 F
(Include:) 99 149.8 T
0 F
(dbase.h) 180 149.8 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "86" 36
%%Page: "87" 37
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
162 690.34 558 702 R
7 X
0 0 0 1 0 0 0 K
V
162 666.34 558 678.01 R
V
0 10 Q
0 X
(87) 546.88 671.34 T
324 684 580 684 2 L
7 X
V
3 H
2 Z
0 X
N
512 90 558 125 R
7 X
V
1 60 Q
0 X
(n) 512.17 85 T
315 104 510 126 R
7 X
V
2 24 Q
0 X
(Routines) 407.33 110 T
90 99 270 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
90.67 123.5 270.67 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
2 10 Q
0 X
(See Also:) 99 641.33 T
0 F
(DBLockMap\050\051) 180 641.33 T
81 624.99 531 630 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 624.99 531 630 R
7 X
0 0 0 1 0 0 0 K
V
50 628.99 609.01 628.99 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 616.99 T
2 F
(DBLockUngrouped\050\051) 99 616.99 T
3 10 Q
(void *) 99 602.33 T
4 F
(DBLockUngrouped\050) 153 602.33 T
4 9 Q
(VMFileHandle) 153 591.99 T
(file,) 261 591.99 T
(DBGroupAndItem) 153 581.99 T
(id\051;) 261 581.99 T
0 10 Q
(This routine is the same as) 180 564.33 T
5 F
(DBLock\050\051) 307.99 564.33 T
0 F
(, except that it is passed a) 357.44 564.33 T
5 F
(DBGroupAndItem) 180 552.83 T
0 F
( value.) 274.44 552.83 T
2 F
(Include:) 99 534.33 T
0 F
(dbase.h) 180 534.33 T
81 517.98 531 522.99 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 517.98 531 522.99 R
7 X
0 0 0 1 0 0 0 K
V
50 521.98 609.01 521.98 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 509.98 T
2 F
(DBReAlloc\050\051) 99 509.98 T
3 10 Q
(void) 99 495.32 T
4 F
(DBReAlloc\050) 153 495.32 T
4 9 Q
(VMFileHandle) 153 484.98 T
(file,) 261 484.98 T
(DBGroup) 153 474.98 T
(group,) 261 474.98 T
(DBItem) 153 464.98 T
(item,) 261 464.98 T
(word) 153 454.98 T
(size\051;) 261 454.98 T
0 10 Q
(This routine changes the size of a DB item. It is passed the \336le, group, and) 180 437.32 T
(item handles specifying the DB item, and a new size for the item \050in bytes\051.) 180 425.82 T
(If the new size is larger than the old, space will be added to the end of the) 180 414.32 T
-0.1 (item; if the new size is smaller than the old, the item will be truncated to \336t.) 180 402.82 P
2 F
(W) 99 384.32 T
(arnings:) 108.07 384.32 T
0 F
(If the new size is larger than the old, all pointers to items in the group are) 180 384.32 T
(invalidated. Space added is not zero-initialized.) 180 371.32 T
2 F
(Include:) 99 351.32 T
0 F
(dbase.h) 180 351.32 T
81 334.98 531 339.98 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 334.98 531 339.98 R
7 X
0 0 0 1 0 0 0 K
V
50 338.98 609.01 338.98 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 326.98 T
2 F
(DBReAllocUngrouped\050\051) 99 326.98 T
3 10 Q
(void) 99 312.31 T
4 F
(DBReAllocUngrouped\050) 153 312.31 T
4 9 Q
(VMFileHandle) 153 301.98 T
(file,) 261 301.98 T
(DBGroupAndItem) 153 291.98 T
(id,) 261 291.98 T
4 10 Q
(word) 153 281.98 T
4 9 Q
(size\051;) 261 281.98 T
0 10 Q
(This routine is just like) 180 264.31 T
5 F
(DBReAlloc\050\051) 290.76 264.31 T
0 F
(, except it is passed a) 354.84 264.31 T
5 F
(DBGroupAndItem) 180 252.81 T
0 F
( value instead of separate group and item handles.) 274.44 252.81 T
2 F
(W) 99 234.31 T
(arnings:) 108.07 234.31 T
0 F
(If the new size is larger than the old, all pointers to ungrouped items are) 180 234.31 T
(invalidated. Space added is not zero-initialized.) 180 221.31 T
2 F
(Include:) 99 201.31 T
0 F
(dbase.h) 180 201.31 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "87" 37
%%Page: "88" 38
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
54 690.34 450 702 R
7 X
0 0 0 1 0 0 0 K
V
54 666.34 450 678.01 R
V
0 10 Q
0 X
(88) 54 671.34 T
32 684 288 684 2 L
7 X
V
3 H
2 Z
0 X
N
54 90 108 125 R
7 X
V
1 60 Q
0 X
(n) 58.17 85 T
104 104 299 126 R
7 X
V
2 24 Q
0 X
(Routines) 104 110 T
306 99 486 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
306 123.5 486 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
81 642.99 531 648 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 642.99 531 648 R
7 X
0 0 0 1 0 0 0 K
V
50 646.99 609.01 646.99 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 634.99 T
2 F
(DBSetMap\050\051) 99 634.99 T
3 10 Q
(void) 99 620.33 T
4 F
(DBSetMap\050) 153 620.33 T
4 9 Q
(VMFileHandle) 153 609.99 T
(file,) 261 609.99 T
(DBGroup) 153 599.99 T
(group,) 261 599.99 T
(DBItem) 153 589.99 T
(item\051;) 261 589.99 T
0 10 Q
(This routine sets the) 180 572.33 T
0 9 Q
(DB) 278.53 572.33 T
0 10 Q
( map item. Y) 292.03 572.33 T
(ou can later retrieve a) 350.2 572.33 T
5 F
-0.92 (DBGroupAndItem) 180 560.83 P
0 F
-0.89 ( structure identifying this item by calling) 274.44 560.83 P
5 F
-0.92 (DBGetMap\050\051) 461.52 560.83 P
0 F
-0.89 (.) 526.34 560.83 P
(The routine is passed the \336le, group, and item handles specifying the new) 180 549.33 T
(map item; it does not return anything.) 180 537.83 T
2 F
(Include:) 99 519.33 T
0 F
(dbase.h) 180 519.33 T
81 502.98 531 507.99 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 502.98 531 507.99 R
7 X
0 0 0 1 0 0 0 K
V
50 506.98 609.01 506.98 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 494.98 T
2 F
(DBSetMapUngrouped\050\051) 99 494.98 T
3 10 Q
(void) 99 480.32 T
4 F
(DBSetMapUngrouped\050) 153 480.32 T
4 9 Q
(VMFileHandle) 153 469.98 T
(file,) 261 469.98 T
(DBGroupAndItem) 153 459.98 T
(id\051;) 261 459.98 T
0 10 Q
(This routine is just like) 180 442.32 T
5 F
(DBSetMap\050\051) 290.76 442.32 T
0 F
(, except it is passed a) 353.91 442.32 T
5 F
(DBGroupAndItem) 180 430.82 T
0 F
( value instead of separate group and item handles.) 274.44 430.82 T
2 F
(Include:) 99 412.32 T
0 F
(dbase.h) 180 412.32 T
81 395.98 531 400.98 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 395.98 531 400.98 R
7 X
0 0 0 1 0 0 0 K
V
50 399.98 609.01 399.98 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 387.98 T
2 F
(DBUnlock\050\051) 99 387.98 T
3 10 Q
(void) 99 373.31 T
4 F
(DBUnlock\050) 153 373.31 T
4 9 Q
(void *) 153 362.98 T
(ptr\051; /* address of item to unlock */) 189 362.98 T
0 10 Q
(This routine unlocks the) 180 345.31 T
0 9 Q
(DB) 295.75 345.31 T
0 10 Q
( item whose address is passed.) 309.25 345.31 T
2 F
(T) 99 326.81 T
(ips and T) 104.93 326.81 T
(ricks:) 148.28 326.81 T
0 F
-0.05 (Only the segment address of the pointer is signi\336cant. Thus, you can pass a) 180 326.81 P
(pointer to somewhere within an item \050or immediately after it\051 to unlock it.) 180 313.81 T
2 F
(Be Sure T) 99 293.81 T
(o:) 144.94 293.81 T
0 F
(If the item has been changed, make sure you call) 180 293.81 T
5 F
(DBDirty\050\051) 408.55 293.81 T
6 F
(before) 462.81 293.81 T
0 F
( you) 490.02 293.81 T
(unlock it.) 180 280.81 T
2 F
(Include:) 99 260.81 T
0 F
(dbase.h) 180 260.81 T
81 244.47 531 249.47 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 244.47 531 249.47 R
7 X
0 0 0 1 0 0 0 K
V
50 248.47 609.01 248.47 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 236.47 T
2 F
(DiskCheckInUse\050\051) 99 236.47 T
3 10 Q
(Boolean) 99 221.8 T
4 F
(DiskCheckInUse\050) 153 221.8 T
4 9 Q
(DiskHandle) 153 211.47 T
(disk\051;) 261 211.47 T
0 10 Q
-0.09 (This routine checks if a registered disk is being used. If a \336le on that disk is) 180 193.8 P
-0.48 (open, or if a path on that disk is on some thread\325) 180 182.3 P
-0.48 (s directory stack, the routine) 397.49 182.3 P
(will return) 180 170.8 T
6 F
(true) 232.78 170.8 T
0 F
( \050i.e. non-zero\051; otherwise it will return) 251.29 170.8 T
6 F
(false) 432.96 170.8 T
0 F
( \050i.e. zero\051. Note) 454.24 170.8 T
(that a disk may be \322in use\323 even if it is not currently in any drive.) 180 159.3 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "88" 38
%%Page: "89" 39
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
162 690.34 558 702 R
7 X
0 0 0 1 0 0 0 K
V
162 666.34 558 678.01 R
V
0 10 Q
0 X
(89) 546.88 671.34 T
324 684 580 684 2 L
7 X
V
3 H
2 Z
0 X
N
512 90 558 125 R
7 X
V
1 60 Q
0 X
(n) 512.17 85 T
315 104 510 126 R
7 X
V
2 24 Q
0 X
(Routines) 407.33 110 T
90 99 270 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
90.67 123.5 270.67 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
2 10 Q
0 X
(T) 99 641.33 T
(ips and T) 104.93 641.33 T
(ricks:) 148.28 641.33 T
0 F
(If you pass a standard path constant, this routine will return information) 180 641.33 T
(about the disk containing the main) 180 628.33 T
5 F
(geos.ini) 344.85 628.33 T
0 F
( \336le \050which is guaranteed to be) 384.84 628.33 T
(in use\051.) 180 615.33 T
2 F
(Include:) 99 595.33 T
0 F
(disk.h) 180 595.33 T
81 578.99 531 584 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 578.99 531 584 R
7 X
0 0 0 1 0 0 0 K
V
50 582.99 609.01 582.99 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 570.99 T
2 F
(DiskCheckUnnamed\050\051) 99 570.99 T
3 10 Q
(Boolean) 99 556.33 T
4 F
(DiskCheckUnnamed\050 /* returns) 153 556.33 T
9 F
(true) 327 556.33 T
4 F
( if disk is unnamed */) 351 556.33 T
4 9 Q
(DiskHandle) 153 545.99 T
(disk\051;) 261 545.99 T
0 10 Q
(This routine checks if a registered disk has a permanent name. If the disk) 180 528.33 T
(does not have a name, the routine returns) 180 516.83 T
6 F
(true) 376.87 516.83 T
0 F
( \050i.e. non-zero\051; otherwise it) 395.38 516.83 T
(returns) 180 505.33 T
6 F
(false) 217.4 505.33 T
0 F
(. Note that) 238.68 505.33 T
0 9 Q
(GEOS) 291.29 505.33 T
0 10 Q
( assigns a temporary name to unnamed disks) 317.46 505.33 T
-0.52 (when they are registered. T) 180 493.83 P
-0.52 (o \336nd out a disk\325) 304.58 493.83 P
-0.52 (s temporary or permanent name,) 378.24 493.83 P
(call) 180 482.33 T
5 F
(DiskGetV) 199.08 482.33 T
(olumeName\050\051) 247.78 482.33 T
0 F
(.) 317.22 482.33 T
2 F
(T) 99 463.83 T
(ips and T) 104.93 463.83 T
(ricks:) 148.28 463.83 T
0 F
(If you pass a standard path constant, this routine will return information) 180 463.83 T
(about the disk containing the main) 180 450.83 T
5 F
(geos.ini) 344.85 450.83 T
0 F
( \336le.) 384.84 450.83 T
2 F
(See Also:) 99 430.83 T
0 F
(DiskGetV) 180 430.83 T
(olumeName\050\051) 224.46 430.83 T
2 F
(Include:) 99 410.83 T
0 F
(disk.h) 180 410.83 T
81 394.48 531 399.49 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 394.48 531 399.49 R
7 X
0 0 0 1 0 0 0 K
V
50 398.48 609.01 398.48 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 386.48 T
2 F
(DiskCheckW) 99 386.48 T
(ritable\050\051) 171.47 386.48 T
3 10 Q
(Boolean) 99 371.82 T
4 F
(DiskCheckWritable\050) 153 371.82 T
4 9 Q
(DiskHandle) 153 361.48 T
(disk\051;) 261 361.48 T
5 10 Q
-0.55 (DiskCheckW) 180 343.82 P
-0.55 (ritable\050\051) 245.56 343.82 P
0 F
-0.53 ( checks if a disk is currently writable. It returns) 288.34 343.82 P
6 F
-0.53 (false) 507.47 343.82 P
0 F
-0.12 (\050i.e. zero\051 if the disk is not writable, whether by nature \050e.g. a) 180 332.32 P
0 9 Q
-0.11 (CD-ROM) 464.41 332.32 P
0 10 Q
-0.12 ( disk\051) 502.9 332.32 P
-0.82 (or because the write-protect tab is on; otherwise it returns) 180 320.82 P
6 F
-0.82 (true) 443.66 320.82 P
0 F
-0.82 ( \050i.e. non-zero\051.) 462.17 320.82 P
2 F
(T) 99 302.32 T
(ips and T) 104.93 302.32 T
(ricks:) 148.28 302.32 T
0 F
(If you pass a standard path constant, this routine will return information) 180 302.32 T
(about the disk containing the main) 180 289.32 T
5 F
(geos.ini) 344.85 289.32 T
0 F
( \336le.) 384.84 289.32 T
2 F
(Include:) 99 269.32 T
0 F
(disk.h) 180 269.32 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "89" 39
%%Page: "90" 40
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
54 690.34 450 702 R
7 X
0 0 0 1 0 0 0 K
V
54 666.34 450 678.01 R
V
0 10 Q
0 X
(90) 54 671.34 T
32 684 288 684 2 L
7 X
V
3 H
2 Z
0 X
N
54 90 108 125 R
7 X
V
1 60 Q
0 X
(n) 58.17 85 T
104 104 299 126 R
7 X
V
2 24 Q
0 X
(Routines) 104 110 T
306 99 486 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
306 123.5 486 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
81 642.99 531 648 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 642.99 531 648 R
7 X
0 0 0 1 0 0 0 K
V
50 646.99 609.01 646.99 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 634.99 T
2 F
(DiskCopy\050\051) 101.78 634.99 T
3 10 Q
(DiskCopyError) 99 620.33 T
4 F
(DiskCopy\050) 183 620.33 T
4 9 Q
(word) 153 609.99 T
(source,) 261 609.99 T
(word) 153 599.99 T
(dest,) 261 599.99 T
(Boolean _pascal \050*callback\051) 153 589.99 T
(\050DiskCopyCallback) 189 579.99 T
(code,) 333 579.99 T
( DiskHandle) 189 569.99 T
(disk,) 333 569.99 T
( word) 189 559.99 T
(param\051\051;) 333 559.99 T
0 10 Q
(This routine copies one disk onto another) 180 542.33 T
(. The destination disk must be) 369.83 542.33 T
-0.09 (formattable to be the same type as the source disk. The \336rst two arguments) 180 530.83 P
-0.41 (specify the source and destination drive. These drives may or may not be the) 180 519.33 P
(same. If they are different, they must take compatible disks.) 180 507.83 T
(A disk copy requires frequent interaction with the user) 180 489.33 T
(. For example, the) 433.34 489.33 T
(copy routine must prompt the user to swap disks when necessary) 180 477.83 T
(. For this) 480.2 477.83 T
(reason,) 180 466.33 T
5 F
(DiskCopy\050\051) 216.3 466.33 T
0 F
( is passed a pointer to a callback routine. This routine) 274.45 466.33 T
-0.34 (handles all interaction with the user) 180 454.83 P
-0.34 (. It must be declared _pascal. Each time) 346.47 454.83 P
(it is called, it is passed three arguments. The \336rst is a member of the) 180 443.33 T
5 F
(DiskCopyCallback) 180 431.83 T
0 F
( enumerated type; this argument speci\336es what the) 276.12 431.83 T
(callback routine should do. The second argument is a disk handle; its) 180 420.33 T
-0.55 (signi\336cance depends on the value of the) 180 408.83 P
5 F
-0.57 (DiskCopyCallback) 362.26 408.83 P
0 F
-0.55 ( argument. The) 458.38 408.83 P
(third argument is a word-sized piece of data whose signi\336cance depends on) 180 397.33 T
(the value of the) 180 385.83 T
5 F
(DiskCopyCallback) 254.64 385.83 T
0 F
( argument. Note that either of these) 350.76 385.83 T
(arguments may be null values, depending on the value of the) 180 374.33 T
5 F
(DiskCopyCallback) 180 362.83 T
0 F
( argument.) 276.12 362.83 T
(The callback routine can abort the copy by returning) 180 344.33 T
6 F
(true) 425.95 344.33 T
0 F
( \050i.e. non-zero\051;) 444.46 344.33 T
-0.09 (otherwise, it should return) 180 332.83 P
6 F
-0.09 (false) 306.29 332.83 P
0 F
-0.09 ( \050i.e. zero\051. The callback routine is called for) 327.57 332.83 P
-0.35 (several situations, identi\336ed by the value of) 180 321.33 P
5 F
-0.36 (DiskCopyCallback) 382.42 321.33 P
0 F
-0.35 ( associated) 478.54 321.33 P
(with them:) 180 309.83 T
0 9 Q
(CALLBACK_GET_SOURCE_DISK) 180 291.33 T
0 10 Q
(The callback routine should prompt the user to insert the) 243 280.33 T
-0.46 (source disk into the appropriate drive. The second argument is) 243 269.33 P
(meaningless for this call. The third argument is the number) 243 258.33 T
(identifying the drive; use) 243 247.33 T
5 F
(DriveGetName\050\051) 361.71 247.33 T
0 F
( to \336nd the name) 446.7 247.33 T
(for this drive.) 243 236.33 T
0 9 Q
(CALLBACK_GET_DEST_DISK) 180 218.33 T
0 10 Q
(The callback routine should prompt the user to insert the) 243 207.33 T
(destination disk into the appropriate drive. The second) 243 196.33 T
(argument is meaningless for this call. The third argument is) 243 185.33 T
(the number identifying the drive.) 243 174.33 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "90" 40
%%Page: "91" 41
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
162 690.34 558 702 R
7 X
0 0 0 1 0 0 0 K
V
162 666.34 558 678.01 R
V
0 10 Q
0 X
(91) 546.88 671.34 T
324 684 580 684 2 L
7 X
V
3 H
2 Z
0 X
N
512 90 558 125 R
7 X
V
1 60 Q
0 X
(n) 512.17 85 T
315 104 510 126 R
7 X
V
2 24 Q
0 X
(Routines) 407.33 110 T
90 99 270 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
90.67 123.5 270.67 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
0 9 Q
0 X
(CALLBACK_REPORT_NUM_SW) 180 641.33 T
(APS) 320.34 641.33 T
0 10 Q
(The second argument is meaningless for this call. The third) 243 630.33 T
(argument is the number of disk swaps that will be necessary) 243 619.33 T
(.) 522.49 619.33 T
(The callback routine may wish to report this number to the) 243 608.33 T
(user and ask for con\336rmation.) 243 597.33 T
0 9 Q
(CALLBACK_VERIFY_DEST_DESTRUCTION) 180 579.33 T
0 10 Q
-0.8 (If the destination disk has already been formatted, the callback) 243 568.33 P
-0.69 (routine will be called with this parameter) 243 557.33 P
-0.69 (. The callback routine) 430.58 557.33 P
(may wish to remind the user that the destination disk will be) 243 546.33 T
(erased. The second argument is the handle of the destination) 243 535.33 T
-0.44 (disk; this is useful if, for example, you want to report the disk\325) 243 524.33 P
-0.44 (s) 524.03 524.33 P
-0.52 (name. The third argument is the destination drive\325) 243 513.33 P
-0.52 (s number) 474.03 513.33 P
-0.52 (. If) 516.3 513.33 P
(the callback routine aborts the copy at this time by returning) 243 502.33 T
(non-zero, the destination disk will not be harmed.) 243 491.33 T
0 9 Q
(CALLBACK_REPORT_FORMA) 180 473.33 T
(T_PERCT) 313 473.33 T
0 10 Q
-0.37 (If the destination disk needs to be formatted,) 243 462.33 P
5 F
-0.38 (DiskCopy\050\051) 450.8 462.33 P
0 F
-0.37 ( will) 508.95 462.33 P
-0.08 (periodically call the callback routine with this parameter) 243 451.33 P
-0.08 (. The) 505.05 451.33 P
-0.17 (callback routine may wish to notify the user how the format is) 243 440.33 P
(progressing. In this case, the second argument will be) 243 429.33 T
-0.37 (meaningless; the third parameter will be the percentage of the) 243 418.33 P
(destination disk which has been formatted. The callback) 243 407.33 T
(routine may wish to notify the user how the format is) 243 396.33 T
(progressing.) 243 385.33 T
0 9 Q
(CALLBACK_REPORT_COPY_PERCT) 180 367.33 T
0 10 Q
(While the copy is taking place,) 243 356.33 T
5 F
(DiskCopy\050\051) 386.91 356.33 T
0 F
( will periodically) 445.06 356.33 T
(call the callback routine with this parameter) 243 345.33 T
(. The callback) 448.96 345.33 T
-0.86 (routine may wish to notify the user how the copy is progressing.) 243 334.33 P
(In this case, the second parameter will be meaningless; the) 243 323.33 T
(third parameter will be the percentage of the copy which has) 243 312.33 T
(been completed.) 243 301.33 T
-0.43 (If the copy was successful,) 180 283.33 P
5 F
-0.44 (DiskCopy\050\051) 301.94 283.33 P
0 F
-0.43 ( returns zero. Otherwise, it returns a) 360.09 283.33 P
(member of the) 180 271.83 T
5 F
(DiskCopyErrors) 249.45 271.83 T
0 F
( enumerated type. That type has the) 334.09 271.83 T
(following members:) 180 260.33 T
0 9 Q
(ERR_DISKCOPY_INSUFFICIENT_MEM) 180 241.83 T
0 10 Q
(This is returned if the routine was unable to get adequate) 243 230.83 T
(memory) 243 219.83 T
(.) 279.48 219.83 T
(ERR_CANT_COPY_FIXED_DISKS) 180 201.83 T
(ERR_CANT_READ_FROM_SOURCE) 180 183.83 T
(ERR_CANT_WRITE_TO_DEST) 180 165.83 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "91" 41
%%Page: "92" 42
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
54 690.34 450 702 R
7 X
0 0 0 1 0 0 0 K
V
54 666.34 450 678.01 R
V
0 10 Q
0 X
(92) 54 671.34 T
32 684 288 684 2 L
7 X
V
3 H
2 Z
0 X
N
54 90 108 125 R
7 X
V
1 60 Q
0 X
(n) 58.17 85 T
104 104 299 126 R
7 X
V
2 24 Q
0 X
(Routines) 104 110 T
306 99 486 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
306 123.5 486 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
0 9 Q
0 X
(ERR_INCOMP) 180 641.33 T
(A) 242.32 641.33 T
(TIBLE_FORMA) 248.33 641.33 T
(TS) 315.49 641.33 T
0 10 Q
-0.56 (The destination drive must be able to write disks in exactly the) 243 630.33 P
(same format as the source disk. Note that the source and) 243 619.33 T
(destination drives may be the same.) 243 608.33 T
0 9 Q
(ERR_OPERA) 180 590.33 T
(TION_CANCELLED) 236 590.33 T
0 10 Q
(This is returned if the callback routine ever returned a) 243 579.33 T
(non-zero value, thus aborting the copy) 243 568.33 T
(.) 418.93 568.33 T
(ERR_CANT_FORMA) 180 550.33 T
(T_DEST) 278.7 550.33 T
2 F
(Include:) 99 532.33 T
0 F
(disk.h) 180 532.33 T
81 515.99 531 521 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 515.99 531 521 R
7 X
0 0 0 1 0 0 0 K
V
50 519.99 609.01 519.99 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 507.99 T
2 F
(DiskFind\050\051) 99 507.99 T
3 10 Q
(DiskHandle) 99 493.33 T
4 F
(DiskFind\050) 165 493.33 T
4 9 Q
(const char *) 153 482.99 T
(fname,) 261 482.99 T
(/* Null-terminated volume name */) 315 482.99 T
(DiskFindResult *) 153 472.99 T
(code\051;) 261 472.99 T
(/* DiskFindResult written here */) 315 472.99 T
0 10 Q
-0.16 (This routine returns the handle of the disk with the speci\336ed name. If there) 180 455.33 P
(is no registered disk with the speci\336ed name,) 180 443.83 T
5 F
(DiskFind\050\051) 391.32 443.83 T
0 F
( returns a null) 447.24 443.83 T
(handle. Note that while disk handles are unique, volume names are not;) 180 432.33 T
(therefore, there may be several registered disks with identical volume) 180 420.83 T
(names. For this reason,) 180 409.33 T
5 F
(DiskFind\050\051) 291.5 409.33 T
0 F
( writes a member of the) 347.42 409.33 T
5 F
-0.74 (DiskFindResults) 180 397.83 P
0 F
-0.71 ( enumerated type \050described below\051 into the space pointed) 266.66 397.83 P
(to by the) 180 386.33 T
6 F
(code) 223.16 386.33 T
0 F
( pointer) 243.15 386.33 T
(.) 278.52 386.33 T
2 F
(Structures:) 99 367.83 T
5 F
(DiskFind\050\051) 180 367.83 T
0 F
( uses the) 235.92 367.83 T
5 F
(DiskFindResults) 279.63 367.83 T
0 F
( enumerated type, which has the) 366.29 367.83 T
(following values:) 180 356.83 T
0 9 Q
(DFR_UNIQUE) 180 338.83 T
0 10 Q
-0.76 (There is exactly one registered disk with the speci\336ed name; its) 243 327.83 P
(handle was returned.) 243 316.83 T
0 9 Q
(DFR_NOT_UNIQUE) 180 298.83 T
0 10 Q
-0.82 (There are two or more registered disks with the speci\336ed name;) 243 287.83 P
(the handle of an arbitrary one of these disks was returned.) 243 276.83 T
0 9 Q
(DFR_NOT_FOUND) 180 258.83 T
0 10 Q
(There are no registered disks with the speci\336ed name; a null) 243 247.83 T
(disk handle was returned.) 243 236.83 T
2 F
(T) 99 218.83 T
(ips and T) 104.93 218.83 T
(ricks:) 148.28 218.83 T
0 F
(If you want to \336nd all the disks with a given volume name, call) 180 218.83 T
5 F
-0.08 (DiskForEach\050\051) 180 205.83 P
0 F
-0.08 ( and have the callback routine check each disk\325) 256.11 205.83 P
-0.08 (s name with) 471.79 205.83 P
5 F
(DiskGetV) 180 192.83 T
(olumeName\050\051) 228.7 192.83 T
0 F
(.) 298.14 192.83 T
2 F
(See Also:) 99 172.83 T
0 F
(DiskRegisterDisk\050\051) 180 172.83 T
2 F
(Include:) 99 152.83 T
0 F
(disk.h) 180 152.83 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "92" 42
%%Page: "93" 43
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
162 690.34 558 702 R
7 X
0 0 0 1 0 0 0 K
V
162 666.34 558 678.01 R
V
0 10 Q
0 X
(93) 546.88 671.34 T
324 684 580 684 2 L
7 X
V
3 H
2 Z
0 X
N
512 90 558 125 R
7 X
V
1 60 Q
0 X
(n) 512.17 85 T
315 104 510 126 R
7 X
V
2 24 Q
0 X
(Routines) 407.33 110 T
90 99 270 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
90.67 123.5 270.67 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
81 642.99 531 648 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 642.99 531 648 R
7 X
0 0 0 1 0 0 0 K
V
50 646.99 609.01 646.99 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 634.99 T
2 F
(DiskForEach\050\051) 99 634.99 T
0 F
(\050See Section) 295.18 634.99 T
(17.3.2.2 of the Concepts book\051) 366.07 634.99 T
3 10 Q
(DiskHandle) 99 620.33 T
4 F
(DiskForEach\050) 165 620.33 T
4 9 Q
(Boolean _pascal \050* callback\051) 153 609.99 T
(\050DiskHandle) 304.2 609.99 T
(disk\051\051) 363.6 609.99 T
(/* callback returns) 401.4 609.99 T
9 F
(true) 509.4 609.99 T
4 F
( * to cancel */) 369 599.99 T
0 10 Q
-0.08 (This routine lets you perform an action on every registered disk. It calls the) 180 582.33 P
(callback routine once for each disk, passing the disk\325) 180 570.83 T
(s handle. The callback) 421.7 570.83 T
(routine must be declared _pascal. The callback routine can force an early) 180 559.33 T
(termination by returning) 180 547.83 T
6 F
(true) 299.08 547.83 T
0 F
( \050i.e. non-zero\051. If the callback routine ever) 317.59 547.83 T
-0.13 (returns) 180 536.33 P
6 F
-0.13 (true) 217.27 536.33 P
0 F
-0.13 (,) 235.78 536.33 P
5 F
-0.13 (DiskForEach\050\051) 241.21 536.33 P
0 F
-0.13 ( terminates and returns the handle of the last) 317.32 536.33 P
(disk passed to the callback routine. If the callback routine examines every) 180 524.83 T
(disk without returning) 180 513.33 T
6 F
(true) 288.34 513.33 T
0 F
(,) 306.85 513.33 T
5 F
(DiskForEach\050\051) 312.41 513.33 T
0 F
( returns a null handle.) 388.52 513.33 T
2 F
(T) 99 494.83 T
(ips and T) 104.93 494.83 T
(ricks:) 148.28 494.83 T
5 F
(DiskForEach\050\051) 180 494.83 T
0 F
( is commonly used to look for a speci\336c disk. The callback) 256.11 494.83 T
-0.26 (routine checks each disk to see if it\325) 180 481.83 P
-0.26 (s the one; if it \336nds a match, the callback) 341.16 481.83 P
(routine simply returns) 180 468.83 T
6 F
(true) 287.59 468.83 T
0 F
(, and) 306.1 468.83 T
5 F
(DiskForEach\050\051) 331.85 468.83 T
0 F
( returns the disk\325) 407.96 468.83 T
(s handle.) 487.04 468.83 T
2 F
(Include:) 99 448.83 T
0 F
(disk.h) 180 448.83 T
81 432.48 531 437.49 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 432.48 531 437.49 R
7 X
0 0 0 1 0 0 0 K
V
50 436.48 609.01 436.48 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 424.48 T
2 F
(DiskFormat\050\051) 99 424.48 T
3 10 Q
(FormatError) 99 409.82 T
4 F
(DiskFormat\050) 171 409.82 T
4 9 Q
(word) 153 399.48 T
(driveNumber,) 261 399.48 T
(MediaType) 153 389.48 T
(media,) 261 389.48 T
(/* Format to this size */) 333 389.48 T
(word) 153 379.48 T
(flags,) 261 379.48 T
(/* See flags below */) 333 379.48 T
(dword) 153 369.48 T
(*goodClusters,) 261 369.48 T
(/* These are filled in at the */) 351 369.48 T
(dword) 153 359.48 T
(*badClusters,) 261 359.48 T
(/* of the format */) 351 359.48 T
(Boolean _pascal \050*callback\051) 153 349.48 T
(\050word percentDone\051\051;) 261 339.48 T
(/* Return true to cancel */) 369 339.48 T
0 10 Q
-0.46 (This routine formats a disk to the speci\336ed size. When it is \336nished, it \336lls in) 180 321.82 P
(the passed pointers to contain the number of good and bad clusters on the) 180 310.32 T
(disk. \050T) 180 298.82 T
(o \336nd out the size of each cluster) 214.09 298.82 T
(, call) 364.46 298.82 T
5 F
(DiskGetV) 389.1 298.82 T
(olumeInfo\050\051) 437.8 298.82 T
0 F
(.\051 The) 498.72 298.82 T
(routine returns a member of the) 180 287.32 T
5 F
(FormatError) 331.67 287.32 T
0 F
( enumerated type \050whose) 399.46 287.32 T
(members are described below\051.) 180 275.82 T
5 F
-0.19 (DiskFormat\050\051) 180 257.32 P
0 F
-0.18 ( can be instructed to call a callback routine periodically) 250 257.32 P
-0.18 (. This) 502.46 257.32 P
(allows the application to keep the user informed about how the format is) 180 245.82 T
(progressing. The callback routine is passed either the percent of the disk) 180 234.32 T
(which has been formatted, or the cylinder and head currently being) 180 222.82 T
(formatted. The callback routine must be declared _pascal. The callback) 180 211.32 T
(routine can cancel the format by returning) 180 199.82 T
6 F
(true) 379.63 199.82 T
0 F
( \050i.e. non-zero\051; otherwise, it) 398.14 199.82 T
(should return) 180 188.32 T
6 F
(false) 246.29 188.32 T
0 F
( \050i.e. zero\051.) 267.57 188.32 T
-0.06 (The third argument passed is a word-length \337ag \336eld. Currently) 180 169.82 P
-0.06 (, only three) 475.98 169.82 P
(\337ags are de\336ned:) 180 158.32 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "93" 43
%%Page: "94" 44
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
54 690.34 450 702 R
7 X
0 0 0 1 0 0 0 K
V
54 666.34 450 678.01 R
V
0 10 Q
0 X
(94) 54 671.34 T
32 684 288 684 2 L
7 X
V
3 H
2 Z
0 X
N
54 90 108 125 R
7 X
V
1 60 Q
0 X
(n) 58.17 85 T
104 104 299 126 R
7 X
V
2 24 Q
0 X
(Routines) 104 110 T
306 99 486 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
306 123.5 486 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
0 9 Q
0 X
(DFF_CALLBACK_PERCENT_DONE) 180 641.33 T
0 10 Q
(A callback routine should be called periodically) 243 630.33 T
(. The callback) 459.51 630.33 T
(routine should be passed a single argument, namely the) 243 619.33 T
(percentage of the format which has been done.) 243 608.33 T
0 9 Q
(DFF_CALLBACK_CYL_HEAD) 180 590.33 T
0 10 Q
(A callback routine should be called periodically) 243 579.33 T
(. The callback) 459.51 579.33 T
(routine should be passed a single argument, namely the) 243 568.33 T
(cylinder head being formatted. If both) 243 557.33 T
0 9 Q
(DFF_CALLBACK_PERCENT_DONE) 243 546.33 T
0 10 Q
( and) 400.18 546.33 T
0 9 Q
-0.55 (DFF_CALLBACK_CYL_HEAD) 243 535.33 P
0 10 Q
-0.61 ( are passed, results are unde\336ned.) 373.34 535.33 P
-0.46 (If neither \337ag is set, the callback routine will never be called; a) 243 524.33 P
(null function pointer may be passed.) 243 513.33 T
0 9 Q
(DFF_FORCE_ERASE) 180 495.33 T
0 10 Q
(A \322hard format\323 should be done, i.e. the sectors should be) 243 484.33 T
(rewritten and initialized to zeros. If this \337ag is not set,) 243 473.33 T
5 F
(DiskFormat\050\051) 243 462.33 T
0 F
( will do a \322soft format\323 if possible; it will check) 313 462.33 T
-0.67 (the sectors and write a blank \336le allocation table, but it will not) 243 451.33 P
(necessarily erase the data from the disk.) 243 440.33 T
5 F
-0.7 (DiskFormat\050\051) 180 422.33 P
0 F
-0.68 ( returns a member of the) 250 422.33 P
5 F
-0.7 (FormatErrors) 363.89 422.33 P
0 F
-0.68 ( enumerated type. If) 436.68 422.33 P
(the format was successful, it will return the constant) 180 410.83 T
0 9 Q
(FMT_DONE) 427.24 410.83 T
0 10 Q
( \050which is) 480.08 410.83 T
(guaranteed to equal zero\051. Otherwise, it will return one of the following) 180 399.33 T
(constants:) 180 387.83 T
4 9 Q
(FMT_DRIVE_NOT_READY) 216 373 T
(FMT_ERROR_WRITING_BOOT) 216 363 T
(FMT_ERROR_WRITING_ROOT_DIR) 216 353 T
(FMT_ERROR_WRITING_FAT) 216 343 T
(FMT_ABORTED) 216 333 T
(FMT_SET_VOLUME_NAME_ERROR) 216 323 T
(FMT_CANNOT_FORMAT_FIXED_DISKS_IN_CUR_RELEASE) 216 313 T
(FMT_BAD_PARTITION_TABLE) 216 303 T
(FMT_ERR_NO_PARTITION_FOUND) 216 293 T
(FMT_ERR_CANNOT_ALLOC_SECTOR_BUFFER) 216 283 T
(FMT_ERR_DISK_IS_IN_USE) 216 273 T
(FMT_ERR_WRITE_PROTECTED) 216 263 T
(FMT_ERR_DRIVE_CANNOT_SUPPORT_GIVEN_FORMAT) 216 253 T
(FMT_ERR_INVALID_DRIVE_SPECIFIED) 216 243 T
(FMT_ERR_DRIVE_CANNOT_BE_FORMATTED) 216 233 T
(FMT_ERR_DISK_UNAVAILABLE) 216 223 T
2 10 Q
(Include:) 99 205.33 T
0 F
(disk.h) 180 205.33 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "94" 44
%%Page: "95" 45
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
162 690.34 558 702 R
7 X
0 0 0 1 0 0 0 K
V
162 666.34 558 678.01 R
V
0 10 Q
0 X
(95) 546.88 671.34 T
324 684 580 684 2 L
7 X
V
3 H
2 Z
0 X
N
512 90 558 125 R
7 X
V
1 60 Q
0 X
(n) 512.17 85 T
315 104 510 126 R
7 X
V
2 24 Q
0 X
(Routines) 407.33 110 T
90 99 270 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
90.67 123.5 270.67 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
81 642.99 531 648 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 642.99 531 648 R
7 X
0 0 0 1 0 0 0 K
V
50 646.99 609.01 646.99 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 634.99 T
2 F
(DiskGetDrive\050\051) 99 634.99 T
3 10 Q
(word) 99 620.33 T
4 F
(DiskGetDrive\050) 153 620.33 T
4 9 Q
(DiskHandle) 153 609.99 T
(dh\051;) 261 609.99 T
0 10 Q
(This routine returns the drive number associated with a registered disk.) 180 592.33 T
-0.41 (Note that it will do this even if the drive is no longer usable \050e.g. if a network) 180 580.83 P
(drive has been unmapped\051.) 180 569.33 T
2 F
(T) 99 550.83 T
(ips and T) 104.93 550.83 T
(ricks:) 148.28 550.83 T
0 F
(If you pass a standard path constant, this routine will return information) 180 550.83 T
(about the disk containing the main) 180 537.83 T
5 F
(geos.ini) 344.85 537.83 T
0 F
( \336le.) 384.84 537.83 T
2 F
(See Also:) 99 517.83 T
0 F
(DiskFind\050\051, DiskRegisterDisk\050\051) 180 517.83 T
2 F
(Include:) 99 497.83 T
0 F
(disk.h) 180 497.83 T
81 481.48 531 486.49 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 481.48 531 486.49 R
7 X
0 0 0 1 0 0 0 K
V
50 485.48 609.01 485.48 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 473.48 T
2 F
(DiskGetV) 99 473.48 T
(olumeFreeSpace\050\051) 151.46 473.48 T
3 10 Q
(dword) 99 458.82 T
4 F
(DiskGetVolumeFreeSpace\050) 153 458.82 T
4 9 Q
(DiskHandle) 153 448.48 T
(dh\051;) 261 448.48 T
0 10 Q
(This routine returns the amount of free space \050measured in bytes\051 on the) 180 430.82 T
(speci\336ed disk. If the disk is, by nature, not writable \050e.g. a) 180 419.32 T
0 9 Q
(CD-ROM) 450.98 419.32 T
0 10 Q
( disk\051,) 489.47 419.32 T
5 F
(DiskGetV) 180 407.82 T
(olumeFreeSpace\050\051) 228.7 407.82 T
0 F
( returns zero and clears the thread\325) 322.97 407.82 T
(s error) 485.56 407.82 T
(value. If an error condition exists,) 180 396.32 T
5 F
(DiskGetV) 339.08 396.32 T
(olumeFreeSpace\050\051) 387.78 396.32 T
0 F
( returns) 482.05 396.32 T
(zero and sets the thread\325) 180 384.82 T
(s error value.) 293.34 384.82 T
2 F
(T) 99 366.32 T
(ips and T) 104.93 366.32 T
(ricks:) 148.28 366.32 T
0 F
(If you pass a standard path constant, this routine will return information) 180 366.32 T
(about the disk containing the main) 180 353.32 T
5 F
(geos.ini) 344.85 353.32 T
0 F
( \336le.) 384.84 353.32 T
2 F
(See Also:) 99 333.32 T
0 F
(DiskGetV) 180 333.32 T
(olumeInfo\050\051) 224.46 333.32 T
2 F
(Include:) 99 313.32 T
0 F
(disk.h) 180 313.32 T
81 296.98 531 301.98 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 296.98 531 301.98 R
7 X
0 0 0 1 0 0 0 K
V
50 300.98 609.01 300.98 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 288.98 T
2 F
(DiskGetV) 99 288.98 T
(olumeInfo\050\051) 151.46 288.98 T
3 10 Q
(word) 99 274.31 T
4 F
(DiskGetVolumeInfo\050) 153 274.31 T
(/* Returns 0 if successful */) 273 274.31 T
4 9 Q
(DiskHandle) 153 263.97 T
(dh,) 261 263.97 T
(DiskInfoStruct) 153 253.97 T
(*info\051;) 261 253.97 T
(/* Routine fills this structure */) 315 253.97 T
0 10 Q
(This routine returns general information about a disk. It returns the) 180 236.31 T
(following four pieces of information:) 180 224.81 T
1 F
(u) 180 206.31 T
0 F
-0.73 (The size of each disk block in bytes. When space is allocated, it is rounded) 198 206.31 P
(up to the nearest whole block.) 198 195.31 T
1 F
(u) 180 177.31 T
0 F
(The number of free bytes on the disk.) 198 177.31 T
1 F
(u) 180 159.31 T
0 F
(The total number of bytes on the disk; this is the total of free and used) 198 159.31 T
(space.) 198 148.31 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "95" 45
%%Page: "96" 46
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
54 690.34 450 702 R
7 X
0 0 0 1 0 0 0 K
V
54 666.34 450 678.01 R
V
0 10 Q
0 X
(96) 54 671.34 T
32 684 288 684 2 L
7 X
V
3 H
2 Z
0 X
N
54 90 108 125 R
7 X
V
1 60 Q
0 X
(n) 58.17 85 T
104 104 299 126 R
7 X
V
2 24 Q
0 X
(Routines) 104 110 T
306 99 486 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
306 123.5 486 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
1 10 Q
0 X
(u) 180 641.33 T
0 F
(The disk\325) 198 641.33 T
(s volume name. If the volume is unnamed, the current) 239.68 641.33 T
(temporary name will be returned.) 198 630.33 T
(The information is written to the passed) 180 612.33 T
5 F
(DiskInfoStruct) 369.1 612.33 T
0 F
(. If an error) 446.88 612.33 T
(condition occurs,) 180 600.83 T
5 F
(DiskGetV) 259.99 600.83 T
(olumeInfo\050\051) 308.69 600.83 T
0 F
( will return the error code and set) 369.61 600.83 T
(the thread\325) 180 589.33 T
(s error value; otherwise, it will return zero.) 230.19 589.33 T
2 F
(Structures:) 99 570.83 T
0 F
(The routine writes the information to a) 180 570.83 T
5 F
(DiskInfoStruct) 363.91 570.83 T
0 F
(:) 441.69 570.83 T
4 9 Q
(typedef struct {) 216 556.5 T
(word) 252 546.5 T
(DIS_blockSize;) 324 546.5 T
(sdword) 252 536.5 T
(DIS_freeSpace;) 324 536.5 T
(sdword) 252 526.5 T
(DIS_totalSpace;) 324 526.5 T
(VolumeName) 252 516.5 T
(DIS_name;) 324 516.5 T
(} DiskInfoStruct;) 216 506.5 T
2 10 Q
(T) 99 488.83 T
(ips and T) 104.93 488.83 T
(ricks:) 148.28 488.83 T
0 F
(If you pass a standard path constant, this routine will return information) 180 488.83 T
(about the disk containing the main) 180 475.83 T
5 F
(geos.ini) 344.85 475.83 T
0 F
( \336le.) 384.84 475.83 T
2 F
(Include:) 99 455.83 T
0 F
(disk.h) 180 455.83 T
81 439.49 531 444.5 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 439.49 531 444.5 R
7 X
0 0 0 1 0 0 0 K
V
50 443.49 609.01 443.49 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 431.49 T
2 F
(DiskGetV) 99 431.49 T
(olumeName\050\051) 151.46 431.49 T
3 10 Q
(void) 99 416.83 T
4 F
(DiskGetVolumeName\050) 153 416.83 T
4 9 Q
(DiskHandle) 153 406.49 T
(dh,) 261 406.49 T
(char *) 153 396.49 T
(buffer\051;) 261 396.49 T
(/* Must be VOLUME_NAME_LENGTH_ZT bytes) 315 396.49 T
( * long */) 315 386.49 T
0 10 Q
(This routine copies the disk\325) 180 368.83 T
(s volume name \050as a null-terminated string\051 to) 309.46 368.83 T
(the passed buffer) 180 357.33 T
(. If an error occurs, it sets the thread\325) 258.89 357.33 T
(s error value. If the) 430.74 357.33 T
(volume has no name, the routine returns the current temporary name.) 180 345.83 T
2 F
(W) 99 327.33 T
(arnings:) 108.07 327.33 T
5 F
-0.17 (DiskGetV) 180 327.33 P
-0.17 (olumeName\050\051) 228.7 327.33 P
0 F
-0.16 ( does not check the size of the buffer passed. If the) 298.14 327.33 P
(buffer is not at least) 180 314.33 T
0 9 Q
(VOLUME_NAME_LENGTH_ZT) 276.13 314.33 T
0 10 Q
( bytes long, the routine) 412.13 314.33 T
(may write beyond its boundaries.) 180 301.33 T
2 F
(T) 99 281.33 T
(ips and T) 104.93 281.33 T
(ricks:) 148.28 281.33 T
0 F
(If you pass a standard path constant, this routine will return information) 180 281.33 T
(about the disk containing the main) 180 268.33 T
5 F
(geos.ini) 344.85 268.33 T
0 F
( \336le.) 384.84 268.33 T
2 F
(See Also:) 99 248.33 T
0 F
(DiskGetV) 180 248.33 T
(olumeInfo\050\051, DiskSetV) 224.46 248.33 T
(olumeName\050\051) 326.32 248.33 T
81 231.98 531 236.99 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 231.98 531 236.99 R
7 X
0 0 0 1 0 0 0 K
V
50 235.98 609.01 235.98 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 223.98 T
2 F
(DiskRegisterDisk\050\051) 99 223.98 T
3 10 Q
(DiskHandle) 99 209.32 T
4 F
(DiskRegisterDisk\050) 165 209.32 T
4 9 Q
(word) 153 198.98 T
(driveNumber\051;) 189 198.98 T
0 10 Q
(This routine registers a disk in the speci\336ed drive and assigns it a disk) 180 181.32 T
(handle. \050The disk handle persists only to the end of the current session of) 180 169.82 T
0 9 Q
-0.28 (GEOS) 180 158.32 P
0 10 Q
-0.31 (.\051 If the disk already has a handle,) 206.17 158.32 P
5 F
-0.32 (DiskRegisterDisk\050\051) 365.01 158.32 P
0 F
-0.31 ( will return it.) 464.08 158.32 P
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "96" 46
%%Page: "97" 47
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
162 690.34 558 702 R
7 X
0 0 0 1 0 0 0 K
V
162 666.34 558 678.01 R
V
0 10 Q
0 X
(97) 546.88 671.34 T
324 684 580 684 2 L
7 X
V
3 H
2 Z
0 X
N
512 90 558 125 R
7 X
V
1 60 Q
0 X
(n) 512.17 85 T
315 104 510 126 R
7 X
V
2 24 Q
0 X
(Routines) 407.33 110 T
90 99 270 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
90.67 123.5 270.67 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
0 10 Q
0 X
-0.66 (If the disk does not have a name,) 180 641.33 P
0 9 Q
-0.6 (GEOS) 330.1 641.33 P
0 10 Q
-0.66 ( will assign it a temporary name \050such) 356.27 641.33 P
(as \322) 180 629.83 T
0 9 Q
(UNNAMED1) 196.86 629.83 T
0 10 Q
(\323\051 and display an alert box telling the user what the) 252.36 629.83 T
-0.1 (temporary name is. \050This is done only the \336rst time the disk is registered in) 180 618.33 P
-0.38 (each session.\051 Note that the temporary name is not written to the disk; thus,) 180 606.83 P
(it persists only until the end of the current session of) 180 595.33 T
0 9 Q
(GEOS) 426.86 595.33 T
0 10 Q
(.) 453.03 595.33 T
-0.09 (If this routine returns a disk handle, there\325) 180 576.83 P
-0.09 (s a disk in the drive; if it doesn\325) 377.89 576.83 P
-0.09 (t,) 521.64 576.83 P
(there may still be a disk in the drive, but the disk is unformatted.) 180 565.33 T
2 F
(T) 99 546.83 T
(ips and T) 104.93 546.83 T
(ricks:) 148.28 546.83 T
0 F
(There is no harm in registering the same disk several times. Thus, if you) 180 546.83 T
-0.63 (want to get the disk handle for the disk in a speci\336c drive, you can simply call) 180 533.83 P
5 F
(DiskRegisterDisk\050\051) 180 520.83 T
0 F
(.) 279.07 520.83 T
2 F
(See Also:) 99 500.83 T
0 F
(DiskRegisterDiskSilently\050\051) 180 500.83 T
2 F
(Include:) 99 480.83 T
0 F
(disk.h) 180 480.83 T
81 464.49 531 469.5 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 464.49 531 469.5 R
7 X
0 0 0 1 0 0 0 K
V
50 468.49 609.01 468.49 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 456.49 T
2 F
(DiskRegisterDiskSilently\050\051) 99 456.49 T
3 10 Q
(DiskHandle) 99 441.83 T
4 F
(DiskRegisterDiskSilently\050) 165 441.83 T
4 9 Q
(word) 153 431.49 T
(driveNumber\051;) 261 431.49 T
0 10 Q
(This routine is almost identical to) 180 413.83 T
5 F
(DiskRegisterDisk\050\051) 338.92 413.83 T
0 F
( \050described) 437.99 413.83 T
(immediately above\051. There is only one difference: If) 180 402.33 T
0 9 Q
(GEOS) 419.09 402.33 T
0 10 Q
( assigns a) 445.26 402.33 T
(temporary name to the disk, it will not present an alert box to the user) 180 390.83 T
(.) 505.98 390.83 T
2 F
(See Also:) 99 372.33 T
0 F
(DiskRegisterDisk\050\051) 180 372.33 T
2 F
(Include:) 99 352.33 T
0 F
(disk.h) 180 352.33 T
81 335.98 531 340.99 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 335.98 531 340.99 R
7 X
0 0 0 1 0 0 0 K
V
50 339.98 609.01 339.98 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 327.98 T
2 F
(DiskRestore\050\051) 99 327.98 T
3 10 Q
(DiskHandle) 99 313.32 T
4 F
(DiskRestore\050) 165 313.32 T
4 9 Q
(void *) 153 302.98 T
(buffer,) 261 302.98 T
(/* buffer written by DiskSave\050\051 */) 315 302.98 T
(DiskRestoreError _pascal \050*callback\051) 153 292.98 T
(\050const char) 261 282.98 T
(*driveName,) 369 282.98 T
( const char) 261 272.98 T
(*diskName,) 369 272.98 T
( void) 261 262.98 T
(**bufferPtr,) 369 262.98 T
( DiskRestoreError) 261 252.98 T
(error\051;) 369 252.98 T
5 10 Q
(DiskRestore\050\051) 180 235.32 T
0 F
( examines a buffer written by) 251.67 235.32 T
5 F
(DiskSave\050\051) 390.58 235.32 T
0 F
( and returns the) 446.69 235.32 T
-0.33 (handle of the disk described by that buffer) 180 223.82 P
-0.33 (. If that disk is already registered,) 372.72 223.82 P
5 F
-0.78 (DiskRestore\050\051) 180 212.32 P
0 F
-0.75 ( will simply return its handle. If the disk is not registered and) 251.67 212.32 P
-0.82 (is not in the drive,) 180 200.82 P
5 F
-0.85 (DiskRestore\050\051) 263.3 200.82 P
0 F
-0.82 ( will call the speci\336ed callback routine. The) 334.97 200.82 P
(callback routine should be declared _pascal. The callback routine is passed) 180 189.32 T
(four arguments:) 180 177.82 T
1 F
(u) 180 159.32 T
0 F
(A null-terminated string containing the name of the drive for the disk.) 198 159.32 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "97" 47
%%Page: "98" 48
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
54 690.34 450 702 R
7 X
0 0 0 1 0 0 0 K
V
54 666.34 450 678.01 R
V
0 10 Q
0 X
(98) 54 671.34 T
32 684 288 684 2 L
7 X
V
3 H
2 Z
0 X
N
54 90 108 125 R
7 X
V
1 60 Q
0 X
(n) 58.17 85 T
104 104 299 126 R
7 X
V
2 24 Q
0 X
(Routines) 104 110 T
306 99 486 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
306 123.5 486 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
1 10 Q
0 X
(u) 180 641.33 T
0 F
(A null-terminated string containing the disk\325) 198 641.33 T
(s volume label.) 405.24 641.33 T
1 F
(u) 180 623.33 T
0 F
(A pointer to a variable in the) 198 623.33 T
5 F
(DiskRestore\050\051) 334.51 623.33 T
0 F
( routine. This variable is) 406.18 623.33 T
-0.03 (itself a pointer to the opaque data structure provided by) 198 612.33 P
5 F
-0.03 (DiskSave\050\051) 459.21 612.33 P
0 F
-0.03 (. If) 515.32 612.33 P
(the callback routine takes any action which causes that structure to) 198 601.33 T
-0.21 (move \050e.g. if it causes the global or local heap containing the buffer to be) 198 590.33 P
(shuf\337ed\051, it should update the pointer in) 198 579.33 T
5 F
(DiskRestore\050\051) 388.01 579.33 T
0 F
(.) 459.68 579.33 T
1 F
(u) 180 561.33 T
0 F
-0.39 (A member of the) 198 561.33 P
5 F
-0.4 (DiskRestoreError) 275.9 561.33 P
0 F
-0.39 ( enumerated type. This is the error) 369.06 561.33 P
(which) 198 550.33 T
5 F
(DiskRestore\050\051) 228.37 550.33 T
0 F
( would have returned if there had not been a) 300.04 550.33 T
(callback routine. This is usually) 198 539.33 T
0 9 Q
(DRE_REMOV) 198 528.33 T
(ABLE_DRIVE_DOESNT_HOLD_DISK) 256.49 528.33 T
0 10 Q
(.) 420.5 528.33 T
-0.06 (The callback routine should prompt the user to insert a disk. If the callback) 180 510.33 P
(routine was successful, it should return) 180 498.83 T
0 9 Q
(DRE_DISK_IN_DRIVE) 365.37 498.83 T
0 10 Q
( \050which is) 463.36 498.83 T
-0.34 (guaranteed to be equal to zero\051. Otherwise, it should return a member of the) 180 487.33 P
5 F
(DiskRestoreError) 180 475.83 T
0 F
( enumerated type; usually it will return) 273.16 475.83 T
0 9 Q
(DRE_USER_CANCELLED_RESTORE) 180 464.33 T
0 10 Q
(. Note that the callback routine will not) 343 464.33 T
(generally know if the user has inserted a disk; it generally just displays an) 180 452.83 T
(alert box and returns when the user clicks \322OK.\323 After the callback routine) 180 441.33 T
(returns,) 180 429.83 T
5 F
(DiskRestore\050\051) 220.18 429.83 T
0 F
( registers the disk and makes sure that it\325) 291.85 429.83 T
(s the) 484.85 429.83 T
(correct one; if it is not, it calls the callback routine again.) 180 418.33 T
(Y) 180 399.83 T
(ou can pass a null function pointer to) 185.93 399.83 T
5 F
(DiskRestore\050\051) 360.39 399.83 T
0 F
( instead of providing) 432.06 399.83 T
(a callback routine. In this case,) 180 388.33 T
5 F
(DiskRestore\050\051) 326.88 388.33 T
0 F
( will fail if the disk has not) 398.55 388.33 T
(been registered and is not currently in the drive.) 180 376.83 T
5 F
(DiskRestore\050\051) 180 358.33 T
0 F
( returns the handle of the disk. If it fails for any reason, it) 251.67 358.33 T
(returns a null handle and sets the thread\325) 180 346.83 T
(s error value to a member of the) 372.8 346.83 T
5 F
(DiskReturnError) 180 335.33 T
0 F
( enumerated type. This type has the following members:) 270.01 335.33 T
0 9 Q
(DRE_DISK_IN_DRIVE) 180 316.83 T
0 10 Q
-0.17 (This is returned by the callback routine. This is guaranteed to) 243 305.83 P
(equal zero.) 243 294.83 T
0 9 Q
(DRE_DRIVE_NO_LONGER_EXISTS) 180 276.83 T
0 10 Q
-0.32 (The disk is associated with a drive which is no longer attached) 243 265.83 P
(to the system.) 243 254.83 T
0 9 Q
(DRE_REMOV) 180 236.83 T
(ABLE_DRIVE_DOESNT_CONT) 238.49 236.83 T
(AIN_DISK) 373.5 236.83 T
0 10 Q
(The disk is unregistered, and it is not currently in the drive) 243 225.83 T
(associated with it. If a callback routine was provided,) 243 214.83 T
5 F
(DiskRestore\050\051) 243 203.83 T
0 F
( will call it under these circumstances.) 314.67 203.83 T
0 9 Q
(DRE_USER_CANCELLED_RESTORE) 180 185.83 T
0 10 Q
-0.15 (This is returned by the callback routine if the user cancels the) 243 174.83 P
(restore.) 243 163.83 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "98" 48
%%Page: "99" 49
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
162 690.34 558 702 R
7 X
0 0 0 1 0 0 0 K
V
162 666.34 558 678.01 R
V
0 10 Q
0 X
(99) 546.88 671.34 T
324 684 580 684 2 L
7 X
V
3 H
2 Z
0 X
N
512 90 558 125 R
7 X
V
1 60 Q
0 X
(n) 512.17 85 T
315 104 510 126 R
7 X
V
2 24 Q
0 X
(Routines) 407.33 110 T
90 99 270 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
90.67 123.5 270.67 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
0 9 Q
0 X
(DRE_COULDNT_CREA) 180 641.33 T
(TE_NEW_HANDLE) 281.67 641.33 T
5 10 Q
(DiskRestore\050\051) 243 630.33 T
0 F
( was unable to register the disk in the) 314.67 630.33 T
-0.14 (appropriate drive because it couldn\325) 243 619.33 P
-0.14 (t create a new disk handle.) 407.25 619.33 P
0 9 Q
(DRE_REMOV) 180 601.33 T
(ABLE_DRIVE_IS_BUSY) 238.49 601.33 T
0 10 Q
-0.74 (The appropriate drive is busy with a time-consuming operation) 243 590.33 P
(\050e.g. a disk format\051.) 243 579.33 T
2 F
(See Also:) 99 561.33 T
0 F
(DiskSave\050\051) 180 561.33 T
2 F
(Include:) 99 541.33 T
0 F
(disk.h) 180 541.33 T
81 524.99 531 530 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 524.99 531 530 R
7 X
0 0 0 1 0 0 0 K
V
50 528.99 609.01 528.99 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 516.99 T
2 F
(DiskSave\050\051) 99 516.99 T
3 10 Q
(Boolean) 99 502.33 T
4 F
(DiskSave\050) 153 502.33 T
4 9 Q
(DiskHandle) 153 491.99 T
(disk,) 261 491.99 T
(void *) 153 481.99 T
(buffer,) 261 481.99 T
(/* data will be written here */) 333 481.99 T
(word *) 153 471.99 T
(bufferSize\051;) 261 471.99 T
(/* Size of buffer \050in bytes\051 */) 333 471.99 T
0 10 Q
(This routine writes information about a disk in the speci\336ed buffer) 180 454.33 T
(.) 487.81 454.33 T
5 F
(DiskRestore\050\051) 180 442.83 T
0 F
( can use this information to return the disk handle, even in) 251.67 442.83 T
(another session of) 180 431.33 T
0 9 Q
(GEOS) 265.93 431.33 T
0 10 Q
(. The) 292.1 431.33 T
6 F
(bufferSize) 318.22 431.33 T
0 F
( argument should point to a word) 364.5 431.33 T
(containing the size of the buffer \050in bytes\051. If the buffer is large enough,) 180 419.83 T
5 F
-0.11 (DiskSave\050\051) 180 408.33 P
0 F
-0.1 ( will write an opaque data structure into the buffer) 236.11 408.33 P
-0.1 (, and change) 470.2 408.33 P
(the value of) 180 396.83 T
6 F
(*bufferSize) 236.86 396.83 T
0 F
( to the actual size of the data structure; any extra) 288.14 396.83 T
(buffer space can be freed or otherwise used. In this case,) 180 385.33 T
5 F
(DiskSave\050\051) 442.97 385.33 T
0 F
( will) 499.08 385.33 T
-0.78 (return) 180 373.83 P
6 F
-0.78 (true) 211.99 373.83 P
0 F
-0.78 ( \050i.e. non-zero\051. If the buffer was too small,) 230.5 373.83 P
5 F
-0.8 (DiskSave\050\051) 421.66 373.83 P
0 F
-0.78 ( will return) 477.77 373.83 P
6 F
(false) 180 362.33 T
0 F
( \050i.e. zero\051 and write the size needed into) 201.28 362.33 T
6 F
(*bufferSize) 390.92 362.33 T
0 F
(. Simply call) 442.2 362.33 T
5 F
-0.3 (DiskSave\050\051) 180 350.83 P
0 F
-0.29 ( again with a large enough buffer) 236.11 350.83 P
-0.29 (. If) 387.55 350.83 P
5 F
-0.3 (DiskSave\050\051) 402.71 350.83 P
0 F
-0.29 ( failed for some) 458.82 350.83 P
(other reason, it will return) 180 339.33 T
6 F
(false) 306.12 339.33 T
0 F
( and set) 327.4 339.33 T
6 F
(*bufferSize) 366.67 339.33 T
0 F
( to zero.) 417.95 339.33 T
2 F
(See Also:) 99 320.83 T
0 F
(DiskRestore\050\051) 180 320.83 T
2 F
(Include:) 99 300.83 T
0 F
( disk.h) 180 300.83 T
81 284.48 531 289.49 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 284.48 531 289.49 R
7 X
0 0 0 1 0 0 0 K
V
50 288.48 609.01 288.48 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 276.48 T
2 F
(DiskSetV) 99 276.48 T
(olumeName\050\051) 150.13 276.48 T
3 10 Q
(word) 99 261.82 T
4 F
(DiskSetVolumeName\050) 153 261.82 T
4 9 Q
(DiskHandle) 153 251.48 T
(dh,) 261 251.48 T
(const char *) 153 241.48 T
(name\051;) 261 241.48 T
(/* Change the name to this */) 315 241.48 T
0 10 Q
(This routine changes the disk\325) 180 223.82 T
(s volume label. If it is successful, it returns) 318.72 223.82 T
(zero; otherwise it returns an error code. It also sets or clears the thread\325) 180 212.32 T
(s) 511.3 212.32 T
(error value appropriately) 180 200.82 T
(. The following error codes may be returned:) 295.74 200.82 T
0 9 Q
(ERROR_INV) 180 182.32 T
(ALID_VOLUME) 233.99 182.32 T
0 10 Q
(An invalid disk handle was passed to the routine.) 243 171.32 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "99" 49
%%Page: "100" 50
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
54 690.34 450 702 R
7 X
0 0 0 1 0 0 0 K
V
54 666.34 450 678.01 R
V
0 10 Q
0 X
(100) 54 671.34 T
32 684 288 684 2 L
7 X
V
3 H
2 Z
0 X
N
54 90 108 125 R
7 X
V
1 60 Q
0 X
(n) 58.17 85 T
104 104 299 126 R
7 X
V
2 24 Q
0 X
(Routines) 104 110 T
306 99 486 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
306 123.5 486 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
0 9 Q
0 X
(ERROR_ACCESS_DENIED) 180 641.33 T
0 10 Q
-0.3 (For some reason, the volume\325) 243 630.33 P
-0.3 (s name could not be changed. For) 376.25 630.33 P
(example, the volume might not be writable.) 243 619.33 T
0 9 Q
(ERROR_DISK_ST) 180 601.33 T
(ALE) 256.51 601.33 T
0 10 Q
(The drive containing that disk has been deleted. This usually) 243 590.33 T
(only happens with network drives.) 243 579.33 T
2 F
(Include:) 99 561.33 T
0 F
(disk.h) 180 561.33 T
81 544.99 531 550 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 544.99 531 550 R
7 X
0 0 0 1 0 0 0 K
V
50 548.99 609.01 548.99 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 536.99 T
2 F
(DosExec\050\051) 99 536.99 T
3 10 Q
(word) 99 523.33 T
4 F
(DosExec\050) 153 523.33 T
4 9 Q
(const char *) 153 512.99 T
(prog,) 261 512.99 T
(DiskHandle) 153 502.99 T
(progDisk,) 261 502.99 T
(const char *) 153 492.99 T
(arguments,) 261 492.99 T
(const char *) 153 482.99 T
(execDir,) 261 482.99 T
(DiskHandle) 153 472.99 T
(execDisk,) 261 472.99 T
(DosExecFlags) 153 462.99 T
(flags\051;) 261 462.99 T
0 10 Q
-0.79 (This routine shuts down) 180 445.33 P
0 9 Q
-0.71 (GEOS) 292.21 445.33 P
0 10 Q
-0.79 ( to run a) 318.38 445.33 P
0 9 Q
-0.71 (DOS) 357.44 445.33 P
0 10 Q
-0.79 ( program. It returns an error code) 377.12 445.33 P
(if an error occurs or zero if successful. Its parameters are listed below:) 180 433.83 T
6 F
(prog) 180 415.33 T
0 F
(A pointer to a null-terminated character string representing) 243 415.33 T
(the path of the program to be run. If a null string \050not a null) 243 404.33 T
(pointer\051, the system\325) 243 393.33 T
(s) 337.08 393.33 T
0 9 Q
(DOS) 344.49 393.33 T
0 10 Q
( command interpreter will be run.) 364.16 393.33 T
(The path string should not contain the drive name.) 243 382.33 T
6 F
(progDisk) 180 364.33 T
0 F
(A disk handle indicating the disk on which the program to be) 243 364.33 T
-0.45 (executed sits. If zero is passed, the disk on which) 243 353.33 P
0 9 Q
-0.41 (GEOS) 467.58 353.33 P
0 10 Q
-0.45 ( resides) 493.75 353.33 P
(will be used.) 243 342.33 T
6 F
(arguments) 180 324.33 T
0 F
-0.62 (A pointer to a locked or \336xed buffer containing arguments to be) 243 324.33 P
(passed to the program being run.) 243 313.33 T
6 F
(execDir) 180 295.33 T
0 F
(A pointer to a null-terminated character string representing) 243 295.33 T
(the path in which the program is to be run. The string should) 243 284.33 T
(not contain the drive name. If a null pointer is passed and) 243 273.33 T
6 F
(execDisk) 243 262.33 T
0 F
( is zero, the program will be run in the directory in) 282.43 262.33 T
(which) 243 251.33 T
0 9 Q
(GEOS) 273.37 251.33 T
0 10 Q
( was \336rst started.) 299.54 251.33 T
6 F
(execDisk) 180 233.33 T
0 F
-0.2 (The disk handle of the disk containing the directory in) 243 233.33 P
6 F
-0.2 (execDir) 495.09 233.33 P
0 F
-0.2 (.) 528.22 233.33 P
6 F
(\337ags) 180 215.33 T
0 F
(A record of) 243 215.33 T
5 F
(DosExecFlags) 295.95 215.33 T
0 F
( indicating whether the) 368.35 215.33 T
0 9 Q
(DOS) 479.47 215.33 T
0 10 Q
-0.12 (program will give a prompt to the user to return to) 243 204.33 P
0 9 Q
-0.11 (GEOS) 478.94 204.33 P
0 10 Q
-0.12 (. The) 505.11 204.33 P
(possible \337ags are) 243 193.33 T
0 9 Q
(DEF_PROMPT) 324.87 193.33 T
0 10 Q
(,) 387.96 193.33 T
0 9 Q
(DEF_FORCED_SHUTDOWN) 393.52 193.33 T
0 10 Q
(,) 518.2 193.33 T
(and) 243 182.33 T
0 9 Q
(DEF_INTERACTIVE) 263.19 182.33 T
0 10 Q
(. For more information, see the entry) 352.85 182.33 T
(for) 243 171.33 T
5 F
(DosExecFlags) 258.55 171.33 T
0 F
(.) 330.95 171.33 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "100" 50
%%Page: "101" 51
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
162 690.34 558 702 R
7 X
0 0 0 1 0 0 0 K
V
162 666.34 558 678.01 R
V
0 10 Q
0 X
(101) 541.32 671.34 T
324 684 580 684 2 L
7 X
V
3 H
2 Z
0 X
N
512 90 558 125 R
7 X
V
1 60 Q
0 X
(n) 512.17 85 T
315 104 510 126 R
7 X
V
2 24 Q
0 X
(Routines) 407.33 110 T
90 99 270 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
90.67 123.5 270.67 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
0 10 Q
0 X
-0.55 (If there was no error) 180 641.33 P
-0.55 (, DosExec\050\051 will return zero. Otherwise it will return one) 272.42 641.33 P
(of the following error values:) 180 629.83 T
0 9 Q
(ERROR_FILE_NOT_FOUND) 315.19 629.83 T
0 10 Q
(,) 438.87 629.83 T
0 9 Q
(ERROR_DOS_EXEC_IN_PROGRESS) 180 618.33 T
0 10 Q
(,) 338.34 618.33 T
0 9 Q
(ERROR_INSUFFICIENT_MEMOR) 343.9 618.33 T
(Y) 492.22 618.33 T
0 10 Q
(, or) 497.44 618.33 T
0 9 Q
(ERROR_ARGS_TOO_LONG) 180 606.83 T
0 10 Q
(.) 299.51 606.83 T
2 F
(Include:) 99 588.33 T
0 F
(system.h) 180 588.33 T
81 571.99 531 577 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 571.99 531 577 R
7 X
0 0 0 1 0 0 0 K
V
50 575.99 609.01 575.99 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 563.99 T
2 F
(DriveGetDefaultMedia\050\051) 99 563.99 T
3 10 Q
(MediaType) 99 549.33 T
4 F
(DriveGetDefaultMedia\050) 159 549.33 T
4 9 Q
(word) 153 538.99 T
(driveNumber\051;) 261 538.99 T
0 10 Q
-0.52 (This routine returns the default media type for the speci\336ed drive. It returns) 180 521.33 P
(a member of the) 180 509.83 T
5 F
(MediaT) 257.79 509.83 T
(ype) 296.52 509.83 T
0 F
( enumerated type \050described in the Data) 315.04 509.83 T
(Structures reference\051. Note that a drive can be used for media types other) 180 498.33 T
(than the default. For example, a high-density 3.5-inch drive will have a) 180 486.83 T
-0.62 (default media type of) 180 475.33 P
0 9 Q
-0.56 (MEDIA_1M44) 278.1 475.33 P
0 10 Q
-0.62 (, but it can read from, write to, and format) 338.26 475.33 P
(3.5-inch disks with size) 180 463.83 T
0 9 Q
(MEDIA_720K) 290.76 463.83 T
0 10 Q
(.) 349.43 463.83 T
2 F
(See Also:) 99 445.33 T
0 F
(DriveT) 180 445.33 T
(estMediaSupport\050\051) 211.49 445.33 T
2 F
(Include:) 99 425.33 T
0 F
(drive.h) 180 425.33 T
81 408.98 531 413.99 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 408.98 531 413.99 R
7 X
0 0 0 1 0 0 0 K
V
50 412.98 609.01 412.98 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 400.98 T
2 F
(DriveGetExtStatus\050\051) 99 400.98 T
3 10 Q
(word) 99 386.32 T
4 F
(DriveGetExtStatus\050) 153 386.32 T
4 9 Q
(word) 153 375.98 T
(driveNumber\051;) 261 375.98 T
0 10 Q
-0.51 (This routine is much like) 180 358.32 P
5 F
-0.53 (DriveGetStatus\050\051) 296.17 358.32 P
0 F
-0.51 ( \050described immediately below\051.) 384.5 358.32 P
(However) 180 346.82 T
(, in addition to returning all of the \337ags set by) 220.18 346.82 T
5 F
(DriveGetStatus\050\051) 435.96 346.82 T
0 F
(,) 524.29 346.82 T
(it also sets additional \337ags in the upper byte of the return value. It returns) 180 335.32 T
(the following additional \337ags:) 180 323.82 T
0 9 Q
(DES_LOCAL_ONL) 180 305.32 T
(Y) 259.69 305.32 T
0 10 Q
(This \337ag is set if the device cannot be viewed over a network.) 243 294.32 T
0 9 Q
(DES_READ_ONL) 180 276.32 T
(Y) 254.18 276.32 T
0 10 Q
-0.46 (This \337ag is set if the device is read only) 243 265.32 P
-0.46 (, i.e. no data can ever be) 419.96 265.32 P
(written to a volume mounted on it \050e.g., a) 243 254.32 T
0 9 Q
(CD-ROM) 436.74 254.32 T
0 10 Q
( drive\051.) 475.23 254.32 T
0 9 Q
(DES_FORMA) 180 236.32 T
(TT) 237.67 236.32 T
(ABLE) 249.18 236.32 T
0 10 Q
(This \337ag is set if disks can be formatted in the drive.) 243 225.32 T
0 9 Q
(DES_ALIAS) 180 207.32 T
0 10 Q
(This \337ag is set if the drive is actually an alias for a path on) 243 207.32 T
(another drive.) 243 196.32 T
0 9 Q
(DES_BUSY) 180 178.32 T
0 10 Q
(This \337ag is set if the drive will be busy for an extended period) 243 178.32 T
(of time \050e.g., if a disk is being formatted\051.) 243 167.32 T
(If an error condition exists,) 180 149.32 T
5 F
(DriveGetExtStatus\050\051) 308.33 149.32 T
0 F
( returns zero.) 414.62 149.32 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "101" 51
%%Page: "102" 52
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
54 690.34 450 702 R
7 X
0 0 0 1 0 0 0 K
V
54 666.34 450 678.01 R
V
0 10 Q
0 X
(102) 54 671.34 T
32 684 288 684 2 L
7 X
V
3 H
2 Z
0 X
N
54 90 108 125 R
7 X
V
1 60 Q
0 X
(n) 58.17 85 T
104 104 299 126 R
7 X
V
2 24 Q
0 X
(Routines) 104 110 T
306 99 486 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
306 123.5 486 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
2 10 Q
0 X
(See Also:) 99 641.33 T
0 F
(DriveGetStatus\050\051) 180 641.33 T
2 F
(Include:) 99 621.33 T
0 F
(drive.h) 180 621.33 T
81 604.99 531 610 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 604.99 531 610 R
7 X
0 0 0 1 0 0 0 K
V
50 608.99 609.01 608.99 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 596.99 T
2 F
(DriveGetName\050\051) 99 596.99 T
3 10 Q
(char *) 99 582.33 T
4 F
(DriveGetName\050) 153 582.33 T
4 9 Q
(word) 153 571.99 T
(driveNumber,) 189 571.99 T
(/* Get name of this drive */) 261 571.99 T
(char *) 153 561.99 T
(buffer,) 189 561.99 T
(/* Write name to this buffer */) 261 561.99 T
(word) 153 551.99 T
(bufferSize\051;) 189 551.99 T
(/* Size of buffer \050in bytes\051 */) 261 551.99 T
0 10 Q
(This routine \336nds the name of a speci\336ed drive. Y) 180 534.33 T
(ou should use this name) 408.54 534.33 T
(when prompting the user to take any action regarding this drive \050e.g. to) 180 522.83 T
(insert a disk\051. The routine writes the name, as a null terminated string, to) 180 511.33 T
(the buffer passed. It returns a pointer to the trailing null. If the drive does) 180 499.83 T
-0.27 (not exist, or the buffer is too small,) 180 488.33 P
5 F
-0.28 (DriveGetName\050\051) 341.91 488.33 P
0 F
-0.27 ( returns a null pointer) 426.9 488.33 P
-0.27 (.) 528.22 488.33 P
2 F
(Include:) 99 469.83 T
0 F
(drive.h) 180 469.83 T
81 453.48 531 458.49 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 453.48 531 458.49 R
7 X
0 0 0 1 0 0 0 K
V
50 457.48 609.01 457.48 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 445.48 T
2 F
(DriveGetStatus\050\051) 99 445.48 T
3 10 Q
(word) 99 430.82 T
4 F
(DriveGetStatus\050) 153 430.82 T
4 9 Q
(word) 153 420.48 T
(driveNumber\051;) 189 420.48 T
0 10 Q
-0.65 (This routine returns the current status of a drive. The drive is speci\336ed by its) 180 402.82 P
-0.24 (drive number) 180 391.32 P
-0.24 (. The routine returns a word of) 241.61 391.32 P
5 F
-0.25 (DriveStatus) 385.1 391.32 P
0 F
-0.24 ( \337ags. These \337ags) 447.32 391.32 P
(are listed below:) 180 379.82 T
0 9 Q
(DS_PRESENT) 180 361.32 T
0 10 Q
(This \337ag is set if the physical drive exists, regardless of) 243 350.32 T
(whether the drive contains a disk.) 243 339.32 T
0 9 Q
(DS_MEDIA_REMOV) 180 321.32 T
(ABLE) 267.82 321.32 T
0 10 Q
(This \337ag is set if the disk can be removed from the drive.) 243 310.32 T
0 9 Q
(DS_NETWORK) 180 292.32 T
0 10 Q
(This \337ag is set if the drive is accessed over a network \050or via) 243 281.32 T
-0.72 (network protocols\051, which means the drive cannot be formatted) 243 270.32 P
(or copied.) 243 259.32 T
0 9 Q
(DS_TYPE) 180 241.32 T
0 10 Q
(This is a mask for the lowest four bits of the \336eld. These bits) 243 241.32 T
(contain a member of the) 243 230.32 T
5 F
(DriveT) 357.83 230.32 T
(ype) 393.6 230.32 T
0 F
( enumerated type.) 412.12 230.32 T
(If an error condition exists,) 180 212.32 T
5 F
(DriveGetStatus\050\051) 308.33 212.32 T
0 F
( returns zero.) 396.66 212.32 T
2 F
(See Also:) 99 193.82 T
0 F
(DriveGetExtStatus\050\051) 180 193.82 T
2 F
(Include:) 99 173.82 T
0 F
(drive.h) 180 173.82 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "102" 52
%%Page: "103" 53
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
162 690.34 558 702 R
7 X
0 0 0 1 0 0 0 K
V
162 666.34 558 678.01 R
V
0 10 Q
0 X
(103) 541.32 671.34 T
324 684 580 684 2 L
7 X
V
3 H
2 Z
0 X
N
512 90 558 125 R
7 X
V
1 60 Q
0 X
(n) 512.17 85 T
315 104 510 126 R
7 X
V
2 24 Q
0 X
(Routines) 407.33 110 T
90 99 270 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
90.67 123.5 270.67 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
81 642.99 531 648 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 642.99 531 648 R
7 X
0 0 0 1 0 0 0 K
V
50 646.99 609.01 646.99 2 L
V
1 H
2 Z
0 X
N
36 72 576 720 C
1 12 Q
0 X
0 0 0 1 0 0 0 K
(n) 81 634.99 T
2 F
(DriveT) 99 634.99 T
(estMediaSupport\050\051) 135.46 634.99 T
3 10 Q
(Boolean) 99 620.33 T
4 F
(DriveTestMediaSupport\050) 153 620.33 T
4 9 Q
(word) 153 609.99 T
(DriveNumber,) 261 609.99 T
(MediaType) 153 599.99 T
(media\051;) 261 599.99 T
(/* Desired disk size */) 333 599.99 T
0 10 Q
(This routine checks whether the speci\336ed drive can support disks in the) 180 582.33 T
(speci\336ed size. It returns) 180 570.83 T
6 F
(true) 293.88 570.83 T
0 F
( \050i.e. non-zero\051 if the drive supports the size.) 312.39 570.83 T
2 F
(See Also:) 99 552.33 T
0 F
(DriveGetDefaultMedia\050\051) 180 552.33 T
2 F
(Include:) 99 532.33 T
0 F
(drive.h) 180 532.33 T
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "103" 53
%%Page: "104" 54
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
54 690.34 450 702 R
7 X
0 0 0 1 0 0 0 K
V
54 666.34 450 678.01 R
V
0 10 Q
0 X
(104) 54 671.34 T
32 684 288 684 2 L
7 X
V
3 H
2 Z
0 X
N
54 90 108 125 R
7 X
V
1 60 Q
0 X
(n) 58.17 85 T
104 104 299 126 R
7 X
V
2 24 Q
0 X
(Routines) 104 110 T
306 99 486 117 R
7 X
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
306 123.5 486 135.67 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
81 144 531 648 R
V
0 0 1 0 1 1 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "104" 54
%%Trailer
%%BoundingBox: 0 0 612 792
%%PageOrder: Ascend
%%Pages: 54
%%DocumentFonts: NewCenturySchlbk-Roman
%%+ ZapfDingbats
%%+ Helvetica-Bold
%%+ Courier-Bold
%%+ Courier
%%+ NewCenturySchlbk-Bold
%%+ NewCenturySchlbk-Italic
%%+ Times-Roman
%%+ Times-Italic
%%+ Courier-Oblique
%%EOF
