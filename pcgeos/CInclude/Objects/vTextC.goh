/***********************************************************************
 *
 *	Copyright (c) GeoWorks 1991 -- All Rights Reserved
 *
 * PROJECT:	PC GEOS
 * FILE:	vTextC.goh
 * AUTHOR:	Tony Requist: February 12, 1991
 *
 * DECLARER:	Text
 *
 * DESCRIPTION:
 *	This file defines VisTextClass
 *
 *	$Id: vTextC.goh,v 1.1 97/04/04 15:51:24 newdeal Exp $
 *
 ***********************************************************************/

@ifndef	__VTEXTC_GOH
@define __VTEXTC_GOH

@optimize
@deflib text

@include <ui.goh> 
#include <Objects/Text/tCommon.h>

@include <Objects/visC.goh>
@include <Objects/gCtrlC.goh>
@include <Objects/gViewC.goh>	    	/* for MakeRectVisibleParams */
@include <spool.goh>
#include <hugearr.h>
#include <dbase.h>


/*------------------------------------------------------------------------
 *	    Class Definition
 *------------------------------------------------------------------------*/

@class VisTextClass, VisClass;

typedef	dword	TokenAsDWord;
typedef	dword	SizeAsDWord;

#define DWORD_TOKEN(val) ((word)( (val) & 0xffff ))
#define DWORD_DATA(val) ((word)( ((val) >> 16) & 0xffff ))

/*
 * Flags sent as data with GWNT_EDITABLE_TEXT_OBJECT_HAS_FOCUS .
 */
typedef WordFlags TextFocusFlags;
#define TFF_EDITABLE_TEXT_OBJECT_HAS_FOCUS  0x8000
#define TFF_OBJECT_RUN_BY_UI_THREAD 	    0x4000


/*------------------------------------------------------------------------
 *		Exported Search Replace routines
 *------------------------------------------------------------------------*/

#define SEARCH_REPLACE_TEXT_MAXIMUM 	    65	    /* 64 chars + 1 null */

typedef ByteFlags SearchOptions;

#define SO_START_FROM_TOP		    0x40
/*	Set if the search is starting from the top of document or object. */

#define SO_NO_WILDCARDS	    	    	    0x20
/* 	Set if you want to treat wildcard chars as literal chars */

#define SO_IGNORE_SOFT_HYPHENS	    	    0x10
/* 	Set if you want to treat soft hyphens in the "searched-in" text
 *	as if they do not exist. If the string we are trying to match 
 *	contains soft hyphens, do not set this flag or the strings will
 *	never match.
 */

#define SO_BACKWARD_SEARCH	    	    0x08
/* 	Set if the user wants to search backward */

#define SO_IGNORE_CASE	    	    	    0x04
/*	Set if you want to ignore case when searching for strings */

#define SO_PARTIAL_WORD	    	    	    0x02
/* 	Set if you want to match partial words when searching for strings */

#define SO_PRESERVE_CASE_OF_DOCUMENT_STRING 0x01
/* 	If set, will preserve the case of the occurrence of the search
 *	string when replacing (will modify the replace string before
 * 	replacing it).
 */

typedef ByteEnum SearchNoteOptionType;
#define SNOT_INCLUDE_NOTE		0x0
#define SNOT_EXCLUDE_NOTE		0x1
#define SNOT_NOTE_ONLY			0x2


typedef ByteEnum WildCard;
#define WC_MATCH_SINGLE_CHAR   	    0x10
#define WC_MATCH_MULTIPLE_CHARS     0x11
#define WC_MATCH_WHITESPACE_CHAR    0x12


/**************************************************************************/
extern char *
    _pascal TextSearchInString(const char *str1, const char *startPtr,
				const char *endPtr, word str1Size,
				const char *str2, word str2Size,
				word searchOptions, word *matchLen);
/*
 * 	Finds an occurrence of a string (str2) in another string (str1).
 *	TextSearchInString can take search strings with wildcards, and returns
 *	a pointer to a match (or NULL if none), and the length of the match.
 *
 *	NOTE: startPtr and endPtr *must* be in the same segment.
 * 	
 *  	Pass: str1 - ptr to first char in string we are searching in 
 * 	      startPtr - ptr to character to start search at in string (str1)
 * 	      endPtr - ptr to last char to include in search in string (str1)
 * 		       (will not match any word that begins after this
 * 			offset, but will match words that start before this
 * 			char and extend beyond it)
 * 
 * 	      strSize - # chars of str1 pointed to by ES:DI
 * 		   (if strSize=0, str1 is assumed to be null terminated, and
 * 			strSize is calculated to be the number of non-null
 *	    	    	chars in the string)
 * 	      str2 - ptr to string to match
 * 		      May contain WildCard chars
 * 	      str2Size - # chars in str2 (or 0 if null-terminated)
 * 	      searchOptions - SearchOptions cast to a word
 *
 * 	Returns: 0 if no match found,
 * 	    	    -else-
 *		 pointer to start of string found
 * 		 matchLen filled in with # chars matched
 *
 * Example:
 * 	Want to search for the string "foo" in "I want some food", starting
 * 	with the "w" in "want":
 * 
 * 	startPtr     endPtr
 * 	  V	       V
 * 	I want some food
 * 	^
 *      str1
 * 	
 */


/**************************************************************************/
extern dword
    _pascal TextSearchInHugeArray(char *str2, word str2Size,
				       dword str1Size, dword curOffset,
				       dword endOffset, 
				       FileHandle hugeArrayFile,
				       VMBlockHandle hugeArrayBlock,
				       word searchOptions, 
				       dword *matchLen);
/*
 * 	Finds an occurrence of a string (str2) in another string (str1).
 *	TextSearchInHugeArray can take search strings with wildcards, and 
 *	returns a dword offset to a match and the length of the match
 * 	
 *  	Pass: str2 - ptr to string to match
 * 	      str2Size - # chars in str2 (or 0 if null-terminated)
 * 
 * 	Returns: offset to match found,
 * 		 matchLen - number of chars in matching string, or
 * 	    	    	    0 if string not found
 */


/*--------------------------------------------------------------------------
 *	 Text Ranges
 *--------------------------------------------------------------------------*/
 

typedef WordFlags VisTextRangeContext;

#define VTRC_PARAGRAPH_CHANGE		0x8000
/* 	Change done on paragraph level  */

#define VTRC_CHAR_ATTR_CHANGE		0x4000
/* 	Used for a charAttr change (include last CR, don't include next CR) */

#define VTRC_PARA_ATTR_BORDER_CHANGE	0x2000
/*	Used for a paraAttr change including a border */


/***************************************************************************/
@message void MSG_VIS_TEXT_GET_RANGE(VisTextRange *range = dx:bp,
				     VisTextRangeContext context = cx);
/*
 * Given a VisTextRange, return the text positions.
 *
 *  	Pass:  	range - pointer to VisTextRange
 *	    	context - VisTextRangeContext
 *
 *  	Return: The text positions in "range"
 *	Compat: Can be used with all text objects.
 */


/*------------------------------------------------------------------------
 * 	Structures for generic runs and elements
 *------------------------------------------------------------------------*/

/* 
 * 	A generic array of runs in the small format.
 */
typedef struct {
    ChunkArrayHeader	TRAH_meta;
    VMBlockHandle	TRAH_elementVMBlock;	/* Element block or 0 */
    ChunkHandle		TRAH_elementArray;  	/* ChunkHandle of the array */
} TextRunArrayHeader;

/* 
 * 	A generic array of runs in the large format.
 */
typedef struct {
    ChunkArrayHeader	TLRAH_meta;		/* Element block or 0 */
    VMBlockHandle	TLRAH_elementVMBlock;	
} TextLargeRunArrayHeader;

/*
 * 	An element in a array of runs
 */
typedef struct {
    WordAndAHalf 	TRAE_position;		/* Position for start of run */
    word	    	TRAE_token;		/*  Token for run */
} TextRunArrayElement;


typedef ByteEnum TextArrayType;
#define TAT_CHAR_ATTRS 	0
#define TAT_PARA_ATTRS 	1
#define TAT_GRAPHICS 	2
#define TAT_TYPES   	3

/*
 * 	A generic array of elements
 */
typedef struct {
    ElementArrayHeader	TEAH_meta;
    TextArrayType	TEAH_arrayType;
    byte		TEAH_unused;
} TextElementArrayHeader;


/*---------------------------------------------------------------------------
 * Macros for easily creating run and element arrays
 *--------------------------------------------------------------------------*/

#define TRAE(pos, base, type) {{pos-base, 0}, type}
#define TRAE_ABS(pos, type) {{pos, 0}, type}
#define TRAE_ALL(type) {{0, 0}, type}
#define TRAE_END {{TEXT_ADDRESS_PAST_END&0xffff, TEXT_ADDRESS_PAST_END>>16}, \
                                                        CA_NULL_ELEMENT}

@define CHAR_ATTR_ELEMENT_ARRAY_HEADER @elementArray VisTextCharAttr \
                            (TextElementArrayHeader (TAT_CHAR_ATTRS))

@define RUN_ARRAY_HEADER(elements) @chunkArray TextRunArrayElement \
    	    	    	    (TextRunArrayHeader (0, (ChunkHandle)@elements))


/*--------------------------------------------------------------------------
 * 	    Style sheet structures
 *--------------------------------------------------------------------------*/

typedef WordFlags TextStyleFlags;
#define TSF_APPLY_TO_SELECTION_ONLY 0x8000
#define TSF_POINT_SIZE_RELATIVE	    0x4000
#define TSF_MARGINS_RELATIVE	    0x2000
#define TSF_SPACING_RELATIVE	    0x1000

typedef struct {
    TextStyleFlags    	TSPD_flags;
    byte    	    	TSPD_unused[2];
} TextStylePrivateData;

typedef struct {
    NameArrayElement	    	TSEH_meta;
    word	    	    	TSEH_baseStyle;
    StyleElementFlags	    	TSEH_flags;
    byte	    	    	TSEH_reserved[6];
    TextStylePrivateData	TSEH_privateData;
    word	    	    	TSEH_charAttrToken;
    word	    	    	TSEH_paraAttrToken;
} TextStyleElementHeader;


/*--------------------------------------------------------------------------
 * 		Global routines for attributes
 *--------------------------------------------------------------------------*/

extern void
    _pascal TextMapDefaultCharAttr(VisTextDefaultCharAttr defaulAttr,
				   VisTextCharAttr *attr);
/*
 *  Load a default VisTextCharAttr.
 *	PASS:	defaultAttr - VisTextDefaultCharAttr to get attrs for 
 *	        attr - pointer to VisTextCharAttr structure to fill in
 *	RETURN: attr - filled in 
 */

extern Boolean
    _pascal TextFindDefaultCharAttr(VisTextDefaultCharAttr  *defaultAttr,
				    VisTextCharAttr *attr);
/*
 *  Look up a default VisTextCharAttr.
 *	PASS:	defaultAttr - pointer to VisTextDefaultCharAttr
 *	        attr - VisTextCharAttrs to look for
 *	RETURN: if TRUE, attr is one of the default VisTextCharAttrs
 * 		    	defaultAttr - filled in 
 *	    	if FALSE, attr is not one of the default VisTextCharAttrs
 */


extern void
    _pascal TextMapDefaultParaAttr(VisTextDefaultParaAttr defaulAttr,
				   VisTextParaAttr *attr);
/*
 *  Load a default VisTextParaAttr.
 *	PASS:	defaultAttr - VisTextDefaultParaAttr to get attrs for 
 *	        attr - pointer to VisTextParaAttr structure to fill in
 */


extern Boolean
    _pascal TextFindDefaultParaAttr(VisTextDefaultParaAttr  *defaultAttr,
				    VisTextParaAttr *attr);
/*
 *  Look up a default VisTextParaAttr.
 *	PASS:	defaultAttr - VisTextDefaultParaAttr
 *	        attr - VisTextParaAttr to look for
 *	RETURN: if TRUE, attr is one of the default VisTextParaAttrs
 * 		    	defaultAttr -  which matches attr
 *	    	if FALSE, attr is not one of the default VisTextParaAttrs
 */

extern Boolean	
    _pascal TextGetSystemCharAttrRun(word *chunkOrConstant, optr object, 
				     ObjChunkFlags flags);
/*
 *  Return the system charAttr run for an object's specific UI.
 *
 *	PASS:	object to get charAttr run for
 *	    	flags - ObjChunkFlags to allocate lmem chunk with (if any)
 *
 *	RETURN:	FALSE if chunk allocated:
 *	    	    chunkOrConstant = ChunkHandle of chunk containing
 *	    	        VisTextCharAttr, allocated in same block as object
 *	    	TRUE if default attr returned:
 *		    chunkOrConstant = VisTextDefaultCharAttr 
 *
 *	NOTE: This function must be called from the thread which is
 *	      running the object.  
 *
 */


extern word
    _pascal GetTokenForPosition(optr object, word runOffset,
				dword *position);
/*
 *  Return the token of a run at the passed position
 *
 *	PASS:	object - the text object
 *	    	runOffset - offset of RunArray to use
 *	    	position - ptr to dword containing the position 
 *
 *	RETURN:	token of the run
 *	    	position is updated to the actual position of the run
 *
 */


/*----------------------------------------------------------------------------
 *	Routines for informing the text library what libs to use
 *---------------------------------------------------------------------------*/

/*
 *	By default, the text library does not load any spell or hyphenation
 *	libraries. Apps that will be using hyphenation or spell checking need
 *	to load these libraries themselves, and these libraries will, in turn,
 *	notify the text library of their existence
 */

extern void 	/* XXX */ 
     _pascal TextSetSpellLibrary(MemHandle libHandle);
/*
 *	Pass: bx - library handle (or 0 if library is exiting)
 *	Return: nothing
 *	Destroyed: nothing
 */


extern void 	/* XXX */
     _pascal TextSetHyphenationCall(void *hyphenationWordEntryPoint);
/*
 * Pass (on-stack):
 *	(void *) to pass to ProcCallFixedOrMovable to call to get
 *	      	 hyphenation position
 *
 *	Routine is passed args on stack (pushed in this order):
 *			fptr	ptrToWordToHyphenate
 *			word	lengthOfShortestWordToHyphenate
 *
 *	Routine returns:
 *		 0 if error or no hyphenation
 *				- else -
 *		 handle of block containing HyphenationPoints structure
 */

/*---------------------------------------------------------------------------
 * 	Messages to set character attributes (charAttrs)
 *--------------------------------------------------------------------------*/
/*
 * Each of these messages takes some values to be changed
 * and the range of text to change.
 */

/***************************************************************************/

@message void MSG_VIS_TEXT_SET_CHAR_ATTR_BY_DEFAULT(@stack
					 VisTextDefaultCharAttr defCharAttrs,
            	    	    	    	 dword rangeEnd, dword rangeStart);
/*
 * 	Set: the entire charAttr structure via a default charAttr
 */

/***************************************************************************/

@message void MSG_VIS_TEXT_SET_CHAR_ATTR(@stack 
					 VisTextCharAttr *attrs,
            	    	    	    	 dword rangeEnd, dword rangeStart);
/*
 * 	Set: the entire charAttr structure via a VisTextCharAttr structure
 */

/***************************************************************************/

@message void MSG_VIS_TEXT_SET_CHAR_ATTR_BY_TOKEN(@stack word token,
            	    	    	    	 dword rangeEnd, dword rangeStart);
/*
 * 	Set: the entire charAttr structure via a VisTextCharAttr token
 * 
 * 	Passing CA_NULL_ELEMENT as the token causes "revert to base style"
 */
				
/***************************************************************************/

@importMessage MetaTextMessages, void MSG_VIS_TEXT_SET_FONT_ID(@stack
					FontID fid,
            	    	    	    	dword rangeEnd, dword rangeStart);
/*
 *	Set: the font ID
 */

/***************************************************************************/

@importMessage MetaTextMessages, void MSG_VIS_TEXT_SET_FONT_WEIGHT(@stack
					byte fontWeight,
            	    	    	    	dword rangeEnd, dword rangeStart);
/*
 *	Set: the font weight
 */
								
/***************************************************************************/

@importMessage MetaTextMessages, void MSG_VIS_TEXT_SET_FONT_WIDTH(@stack
					byte fontWidth, 
            	    	    	    	dword rangeEnd, dword rangeStart);
/*
 *	Set: the font width
 */

/***************************************************************************/

@importMessage MetaTextMessages, void MSG_VIS_TEXT_SET_POINT_SIZE(@stack
					WWFixed pointSize, 
            	    	    	    	dword rangeEnd, dword rangeStart);
/*
 *	Set: the point size
 */

/***************************************************************************/

@importMessage MetaTextMessages, void MSG_VIS_TEXT_SET_SMALLER_POINT_SIZE(
					@stack word minimumSize,
            	    	    	    	dword rangeEnd, dword rangeStart);
/*
 *	Set: the point size to a smaller point size
 */

/***************************************************************************/

@importMessage MetaTextMessages, void MSG_VIS_TEXT_SET_LARGER_POINT_SIZE(
					@stack word maximumSize,
            	    	    	    	dword rangeEnd, dword rangeStart);
/*
 *	Set: the point size to a larger point size
 */


/***************************************************************************/

@importMessage MetaTextMessages, void MSG_VIS_TEXT_SET_TEXT_STYLE(@stack
				  VisTextExtendedStyles extBitsToClear, 
				  VisTextExtendedStyles extBitsToSet,
				  TextStyle styleBitsToClear, 
				  TextStyle styleBitsToSet,
       	    	    	    	  dword rangeEnd, dword rangeStart);
/*
 *	Set: the text style and extended style bits
 *
 * If both the set bit and the clear bit is set then the bit is toggled
 */


/***************************************************************************/

@importMessage MetaTextMessages, void MSG_VIS_TEXT_SET_COLOR(@stack
				    ColorQuad color, 
       	    	    	    	    dword rangeEnd, dword rangeStart);
/* 
 *	Set: the text color
 */

/***************************************************************************/

@importMessage MetaTextMessages, void MSG_VIS_TEXT_SET_GRAY_SCREEN(@stack
				    SystemDrawMask grayScreen,
       	    	    	    	    dword rangeEnd, dword rangeStart);
/* 
 *	Set: the gray screen
 */
								   
/***************************************************************************/

@importMessage MetaTextMessages, void MSG_VIS_TEXT_SET_PATTERN(@stack
				    GraphicPattern hatch,
       	    	    	    	    dword rangeEnd, dword rangeStart);
/* 
 *	Set: the text pattern
 */

/***************************************************************************/

@importMessage MetaTextMessages, void MSG_VIS_TEXT_SET_CHAR_BG_COLOR(@stack
				    ColorQuad color,
       	    	    	    	    dword rangeEnd, dword rangeStart);
/* 
 *	Set: the character background color
 */

/***************************************************************************/

@importMessage MetaTextMessages, void MSG_VIS_TEXT_SET_CHAR_BG_GRAY_SCREEN(
				    @stack SystemDrawMask grayScreen,
       	    	    	    	    dword rangeEnd, dword rangeStart);
/* 
 *	Set: the character background gray screen
 */

/***************************************************************************/

@importMessage MetaTextMessages, void MSG_VIS_TEXT_SET_CHAR_BG_PATTERN(@stack
				    GraphicPattern hatch,
       	    	    	    	    dword rangeEnd, dword rangeStart);
/* 
 *	Set: the character background pattern
 */

/***************************************************************************/

@importMessage MetaTextMessages, void MSG_VIS_TEXT_SET_TRACK_KERNING(@stack
				    BBFixed trackKerning,
       	    	    	    	    dword rangeEnd, dword rangeStart);
/* 
 *	Set: the track kerning value
 */


/*--------------------------------------------------------------------------
 *		Other character attributes (charAttrs) messages
 *--------------------------------------------------------------------------*/

typedef WordFlags VisTextCharAttrFlags;
#define VTCAF_MULTIPLE_FONT_IDS		0x8000	
#define VTCAF_MULTIPLE_POINT_SIZES	0x4000
#define VTCAF_MULTIPLE_COLORS		0x2000
#define VTCAF_MULTIPLE_GRAY_SCREENS	0x1000
#define VTCAF_MULTIPLE_PATTERNS		0x0800
#define VTCAF_MULTIPLE_TRACK_KERNINGS	0x0400
#define VTCAF_MULTIPLE_FONT_WEIGHTS	0x0200
#define VTCAF_MULTIPLE_FONT_WIDTHS	0x0100
#define VTCAF_MULTIPLE_BG_COLORS	0x0080
#define VTCAF_MULTIPLE_BG_GRAY_SCREENS	0x0040
#define VTCAF_MULTIPLE_BG_PATTERNS	0x0020
#define VTCAF_MULTIPLE_STYLES		0x0010

typedef struct {
    VisTextCharAttrFlags	VTCAD_diffs;
    VisTextExtendedStyles	VTCAD_extendedStyles;
    TextStyle			VTCAD_textStyles;
    byte			VTCAD_unused;
} VisTextCharAttrDiffs;

typedef WordFlags VisTextGetAttrFlags;
#define VTGAF_MERGE_WITH_PASSED	    0x8000
/* 
 * If set, merge the attributes for this object with the passed attributes 
 */


/***************************************************************************/

@message word MSG_VIS_TEXT_GET_CHAR_ATTR(@stack VisTextGetAttrFlags flags,
					 VisTextCharAttrDiffs *diffs,
					 VisTextCharAttr *attrs,
       	    	    	    	         dword rangeEnd, 
					 dword rangeStart) = ax;
/*
 * 	Return the VisTextCharAttr structure for the specified range.
 *	PASS:
 *	    	attrs - pointer to buffer to hold VisTextCharAttrs
 *	    	diffs - pointer to buffer to hold VisTextCharAttrDiffs
 *	RETURN:
 *	    	VisTextCharAttr token (0 if multiple)
 *	    	buffers filled in
 */

/***************************************************************************/

@message void MSG_VIS_TEXT_ADD_CHAR_ATTR(@stack VisTextCharAttr *attrs) = ax;
/*
 * 	Add a given charAttr to the charAttr array and initialize its
 * 	reference count to one.
 *	Pass:	attrs  - pointer to VisTextCharAttr to add
 *	Return:	 VisTextCharAttr token
 *	Compat:	This method cannot be used on a text object that does not have
 *		multiple charAttrs
 */

/***************************************************************************/

@message void MSG_VIS_TEXT_REMOVE_CHAR_ATTR(word attrToken = cx);
/*
 *	Remove a given charAttr from the charAttr array.
 *	Pass:	attrToken  - token of VisTextCharAttr to remove
 *	Compat:	This method cannot be used on a text object that does not have
 *		multiple charAttrs
 */


/*---------------------------------------------------------------------------
 * 	Messages to set paragraph attributes (paraAttrs)
 *--------------------------------------------------------------------------*/

/*
 * Each of these messages takes a structure that indicates the range of text
 * to change and the values to change it to.
 */

/***************************************************************************/

@message void MSG_VIS_TEXT_SET_PARA_ATTR_BY_DEFAULT(@stack
					 VisTextDefaultParaAttr defParaAttrs,
       	    	    	    	         dword rangeEnd, dword rangeStart);
/*
 *	Set: the entire paraAttr structure via a default paraAttr
 */

/***************************************************************************/

@message void MSG_VIS_TEXT_SET_PARA_ATTR(@stack 
					 VisTextParaAttr *newParaAttrs,
       	    	    	    	         dword rangeEnd, dword rangeStart);
/*
 *	Set: the entire paraAttr structure via a VisTextParaAttr structure
 */

/***************************************************************************/

@message void MSG_VIS_TEXT_SET_PARA_ATTR_BY_TOKEN(@stack 
				    	  word paraAttrToken,
       	    	    	    	          dword rangeEnd, dword rangeStart);
/*
 *	Set: the entire paraAttr structure via a VisTextParaAttr token
 */

/***************************************************************************/

@message void MSG_VIS_TEXT_SET_BORDER_BITS(@stack
					   VisTextParaBorderFlags bitsToClear,
					   VisTextParaBorderFlags bitsToSet,
       	    	    	    	           dword rangeEnd, dword rangeStart);
/* 
 *	Set: the border bits
 */

/***************************************************************************/

@message void MSG_VIS_TEXT_SET_BORDER_WIDTH(@stack byte width,
       	    	    	    	           dword rangeEnd, dword rangeStart);
/* 
 *	Set: the border width
 */

/***************************************************************************/

@message void MSG_VIS_TEXT_SET_BORDER_SPACING(@stack byte width,
       	    	    	    	           dword rangeEnd, dword rangeStart);
/* 
 *	Set: the border spacing
 */

/***************************************************************************/

@message void MSG_VIS_TEXT_SET_BORDER_SHADOW(@stack byte width,
       	    	    	    	           dword rangeEnd, dword rangeStart);
/* 
 *	Set: the border shadow
 */

/***************************************************************************/

@importMessage MetaTextMessages, void MSG_VIS_TEXT_SET_BORDER_COLOR(@stack
					   ColorQuad color,
       	    	    	    	           dword rangeEnd, dword rangeStart);
/* 
 *	Set: the border color
 */
								    
/***************************************************************************/

@importMessage MetaTextMessages, void MSG_VIS_TEXT_SET_BORDER_GRAY_SCREEN(
				    @stack SystemDrawMask grayScreen,
       	    	    	    	    dword rangeEnd, dword rangeStart);
/* 
 *	Set: the border gray screen
 */

/***************************************************************************/

@importMessage MetaTextMessages, void MSG_VIS_TEXT_SET_BORDER_PATTERN(@stack
				    GraphicPattern hatch,
       	    	    	    	    dword rangeEnd, dword rangeStart);
/* 
 *	Set: the border pattern
 */

/***************************************************************************/

@importMessage MetaTextMessages, void MSG_VIS_TEXT_SET_PARA_ATTRIBUTES(@stack
				  VisTextParaAttrAttributes bitsToClear,
				  VisTextParaAttrAttributes bitsToSet,
       	    	    	    	  dword rangeEnd, dword rangeStart);
/*
 *	Set: the paragraph attribtues (justification, ...)
 */
			    	      	    	
/***************************************************************************/

@message void MSG_VIS_TEXT_SET_LINE_SPACING(@stack BBFixed lineSpacing,
					    dword rangeEnd, dword rangeStart);
/* 
 *	Set: the line spacing
 */

/***************************************************************************/

@message void MSG_VIS_TEXT_SET_DEFAULT_TABS(@stack word defaultTabs, 
					    dword rangeEnd, dword rangeStart);
/* 
 *	Set: the default tabs
 */

/***************************************************************************/

@message void MSG_VIS_TEXT_SET_LEFT_MARGIN(@stack
					    word position, /* points * 8 */
					    dword rangeEnd, dword rangeStart);
/* 
 *	Set: the left margin
 */

/***************************************************************************/

@message void MSG_VIS_TEXT_SET_RIGHT_MARGIN(@stack
					    word position, /* points * 8 */
					    dword rangeEnd, dword rangeStart);
/* 
 *	Set: the right margin
 */

/***************************************************************************/

@message void MSG_VIS_TEXT_SET_PARA_MARGIN(@stack
					    word position, /* points * 8 */
					    dword rangeEnd, dword rangeStart);
/* 
 *	Set: the paragraph margin
 */


/***************************************************************************/

@message void MSG_VIS_TEXT_SET_LEFT_AND_PARA_MARGIN(@stack
					    word position, /* points * 8 */
					    dword rangeEnd, dword rangeStart);
/* 
 *	Set: the left and the paragraph margin
 */

/***************************************************************************/

@message void MSG_VIS_TEXT_SET_SPACE_ON_TOP(@stack BBFixed spacing,
					    dword rangeEnd, dword rangeStart);
/* 
 *	Set: the space on top
 */

/***************************************************************************/

@message void MSG_VIS_TEXT_SET_SPACE_ON_BOTTOM(@stack BBFixed spacing,
					    dword rangeEnd, dword rangeStart);
/* 
 *	Set: the space on bottom
 */

/***************************************************************************/

@message void MSG_VIS_TEXT_SET_LEADING(@stack
				    	word leading, /* points * 8 */
				    	dword rangeEnd, dword rangeStart);
/* 
 *	Set: the leading
 */


/***************************************************************************/

@message void MSG_VIS_TEXT_SET_PARA_BG_COLOR(@stack ColorQuad color,
				    	dword rangeEnd, dword rangeStart);
/* 
 *	Set: the paragraph background color
 */

/***************************************************************************/

@message void MSG_VIS_TEXT_SET_PARA_BG_GRAY_SCREEN(@stack
				 	SystemDrawMask grayScreen,
				    	dword rangeEnd, dword rangeStart);
/* 
 *	Set: the paragraph background gray screen
 */

/***************************************************************************/

@message void MSG_VIS_TEXT_SET_PARA_BG_PATTERN(@stack
				    GraphicPattern hatch, 
				    dword rangeEnd, dword rangeStart);
/* 
 *	Set: the paragraph background pattern
 */

/***************************************************************************/

@message void MSG_VIS_TEXT_SET_TAB(@stack Tab tab, 
				    dword rangeEnd, dword rangeStart);
/* 
 *	Set: a tab
 */

/***************************************************************************/

@message void MSG_VIS_TEXT_CLEAR_TAB(@stack word position, /* points * 8 */
				    dword rangeEnd, dword rangeStart);
/* 
 *	Set: Clear a tab
 */

/***************************************************************************/

@message void MSG_VIS_TEXT_MOVE_TAB(@stack
				     word destPosition,     /* points * 8 */
				     word sourcePosition,   /* points * 8 */
				     dword rangeEnd, dword rangeStart);
/* 
 *	Set: Move a tab
 */

/***************************************************************************/

@message void MSG_VIS_TEXT_CLEAR_ALL_TABS(@stack
					  dword rangeEnd, dword rangeStart);
/* 
 *	Set: Clear all tabs
 */

/***************************************************************************/

@message void MSG_VIS_TEXT_SET_PREPEND_CHARS(@stack
				     char prependChars[4], /* XXX */
				     dword rangeEnd, dword rangeStart);
/* 
 *	Set: The characters to prepend at the start of a paragraph
 */


/***************************************************************************/

@message void MSG_VIS_TEXT_SET_HYPHENATION_PARAMS(@stack
				VisTextHyphenationInfo bitsToSet,
				VisTextHyphenationInfo bitsToClear,
				dword rangeEnd, dword rangeStart);
/* 
 *	Set: The hyphenation parameters
 */


/***************************************************************************/

@message void MSG_VIS_TEXT_SET_DROP_CAP_PARAMS(@stack
					    VisTextDropCapInfo bitsToSet,
					    VisTextDropCapInfo bitsToClear,
				    	    dword rangeEnd, dword rangeStart);
/* 
 *	Set: The drop cap parameters
 */

/***************************************************************************/

@message void MSG_VIS_TEXT_SET_KEEP_PARAMS(@stack
				       	    VisTextKeepInfo bitsToSet,
					    VisTextKeepInfo bitsToClear,
				    	    dword rangeEnd, dword rangeStart);
/* 
 *	Set: The keep (lines together) parameters
 */

/***************************************************************************/

@message void MSG_VIS_TEXT_SET_PARAGRAPH_NUMBER(@stack
					    word startingParaNumber,
				    	    dword rangeEnd, dword rangeStart);
/* 
 *	Set: The paragraph number
 */


/*--------------------------------------------------------------------------
 *	Other character attributes (charAttrs) messages
 *--------------------------------------------------------------------------*/

typedef WordFlags VisTextParaAttrFlags;
#define VTPAF_MULTIPLE_LEFT_MARGINS		0x8000
#define VTPAF_MULTIPLE_RIGHT_MARGINS		0x4000
#define VTPAF_MULTIPLE_PARA_MARGINS		0x2000
#define VTPAF_MULTIPLE_LINE_SPACINGS		0x1000
#define VTPAF_MULTIPLE_DEFAULT_TABS		0x0800
#define VTPAF_MULTIPLE_TOP_SPACING		0x0400
#define VTPAF_MULTIPLE_BOTTOM_SPACING		0x0200
#define VTPAF_MULTIPLE_LEADINGS			0x0100
#define VTPAF_MULTIPLE_BG_COLORS		0x0080
#define VTPAF_MULTIPLE_BG_GRAY_SCREENS		0x0040
#define VTPAF_MULTIPLE_BG_PATTERNS		0x0020
#define VTPAF_MULTIPLE_TAB_LISTS		0x0010
#define VTPAF_MULTIPLE_STYLES			0x0008
#define VTPAF_MULTIPLE_PREPEND_CHARS		0x0004
#define VTPAF_MULTIPLE_STARTING_PARA_NUMBERS	0x0002
#define VTPAF_MULTIPLE_NEXT_STYLES		0x0001

typedef WordFlags VisTextParaAttrFlags2;
#define VTPAF2_MULTIPLE_LANGUAGES		0x8000

typedef WordFlags VisTextParaAttrBorderFlags;
#define VTPABF_MULTIPLE_BORDER_LEFT		0x8000
#define VTPABF_MULTIPLE_BORDER_TOP		0x4000
#define VTPABF_MULTIPLE_BORDER_RIGHT		0x2000
#define VTPABF_MULTIPLE_BORDER_BOTTOM		0x1000
#define VTPABF_MULTIPLE_BORDER_DOUBLES		0x0800
#define VTPABF_MULTIPLE_BORDER_DRAW_INNERS	0x0400
#define VTPABF_MULTIPLE_BORDER_ANCHORS		0x0200
#define VTPABF_MULTIPLE_BORDER_WIDTHS		0x0100
#define VTPABF_MULTIPLE_BORDER_SPACINGS		0x0080
#define VTPABF_MULTIPLE_BORDER_SHADOWS		0x0040
#define VTPABF_MULTIPLE_BORDER_COLORS		0x0020
#define VTPABF_MULTIPLE_BORDER_GRAY_SCREENS	0x0010
#define VTPABF_MULTIPLE_BORDER_PATTERNS	    	0x0008

typedef struct {
    VisTextParaAttrFlags	VTPAD_diffs;
    VisTextParaAttrFlags2	VTPAD_diffs2;
    VisTextParaAttrBorderFlags	VTPAD_borderDiffs;
    VisTextParaAttrAttributes	VTPAD_attributes;
    VisTextHyphenationInfo	VTPAD_hyphenationInfo;
    VisTextKeepInfo		VTPAD_keepInfo;
    VisTextDropCapInfo		VTPAD_dropCapInfo;
} VisTextParaAttrDiffs;


/***************************************************************************/

@message word MSG_VIS_TEXT_GET_PARA_ATTR(@stack 
					 VisTextGetAttrFlags flags,
					 VisTextParaAttrDiffs *diffs,
					 VisTextMaxParaAttr *attrs,
					 dword rangeEnd, 
					 dword rangeStart) = ax;
/*
 *	Return the paraAttr structure for the specified range.
 */

/***************************************************************************/

@message word MSG_VIS_TEXT_ADD_PARA_ATTR(@stack VisTextParaAttr attrs) = ax;
/*
 *	Add a given paraAttr to the paraAttr array and initialize
 *	its reference count to one.
 *
 *	PASS:	attrs - VisTextParaAttr structure
 *	RETURN:	VisTextParaAttr token
 *	COMPAT:	This method cannot be used on a text object that does not
 *		have multiple paraAttrs
 */

/***************************************************************************/

@message void MSG_VIS_TEXT_REMOVE_PARA_ATTR(word token = cx);
/*
 *	Remove a given paraAttr from the paraAttr array.
 *
 *	PASS:	token - token of VisTextParaAttr to remove
 *	RETURN:	nothing
 *	COMPAT:	This method cannot be used on a text object that does not
 *		have multiple paraAttrs
 */

/*---------------------------------------------------------------------------
 *		Messages to deal with style sheets
 *--------------------------------------------------------------------------*/

/***************************************************************************/

@message void MSG_VIS_TEXT_SUBST_ATTR_TOKEN(@stack
					    Boolean *recalcFlag,
					    Boolean relayed,
					    Boolean updateRefFlag,
					    word runOffset,
					    word newToken,
					    word oldToken);
/* 
 * Substitute an attribute token as part of a style sheet change.  This message
 * exists to allow a higher level manager to pass this message to all text
 * objects sharing the same attribute arrays (and thus the same styles)
 *
 *	PASS:	recalcFlag - pointer to a Boolean flag
 *		relayed	- TRUE is relayed to like objects
 *		updateRefFlag - TRUE to update element references
 *		runOffset - offset of run array
 *		newToken - new token 
 *		oldToken - old token to replace
 *	RETURN: *recalcFlag is TRUE if recalc needed
 */
					    

/***************************************************************************/

@message void MSG_VIS_TEXT_RECALC_FOR_ATTR_CHANGE(Boolean relayed = cx);
/* 
 * Recalculate text objects as part of a style sheet change.  This message
 * exists to allow a higher level manager to pass this message to all text
 * objects sharing the same attribute arrays (and thus the same styles)
 *
 *	PASS:	relayed - TRUE if this message has been relayed to
 *		like text objects.
 *	RETURN: nothing
 */


/*---------------------------------------------------------------------------
 *		Messages to set type information
 *--------------------------------------------------------------------------*/

/*
 *	Definition of a text type element.  The hyperlinkName, 
 *	hyperlinkFile, and context fields are name array element tokens,
 *	or -1 for none.
 */
typedef struct {
    RefElementHeader	VTT_meta;
    word		VTT_hyperlinkName; /* name array element (-1 = none) */
    word		VTT_hyperlinkFile; /* name array element (-1 = none) */
    word		VTT_context;	   /* name array element (-1 = none) */
    byte		VTT_unused[1];
} VisTextType;


typedef ByteFlags VisTextSetContextFlags;	
#define VTCF_TOKEN	  			0x01
				/* TRUE: context and hyperlink are tokens */
#define VTCF_SHOWING_HYPERLINKS 		0x02
				/* TRUE: hyperlinks are shown in boxed style */
#define	VTCF_REDIRECT_HYPERLINKS		0x04
				/* TRUE: take hyperlinks pointing
				 *       to the context currently
				 *       set on passed range and
				 *       redirect them to point to
				 *       the context now being set */
#define VTCF_ENSURE_CONTEXT_NOT_ALREADY_SET	0x08
				/* TRUE: before setting context, make sure
				 *       it's  not already set somewhere */

			  
/***************************************************************************/

@message void MSG_VIS_TEXT_SET_HYPERLINK(@stack
					 VisTextSetContextFlags flags,
					 word file,
			    	    	 word context,
					 dword rangeEnd, dword rangeStart);
/*
 * 	Set: the hyperlink
 */
					 
/***************************************************************************/

@message void MSG_VIS_TEXT_SET_CONTEXT(@stack
					 VisTextSetContextFlags flags,
			    	    	 word context,
					 dword rangeEnd, dword rangeStart);
/*
 * Set the context for the specified range.
 *
 * Context:	Sent when context index or token is available to pass.
 * 		See also MSG_VIS_TEXT_SET_CONTEXT_GIVEN_NAME_TEXT.
 * Source:	Hyperlink controller, TextHelp controller
 * Destination:	Text object
 * Interception: May be intercepted.
 *
 */

@reserveMessages	    1;


typedef WordFlags VisTextTypeDiffs;
#define VTTF_MULTIPLE_HYPERLINKS	0x8000
#define VTTF_MULTIPLE_CONTEXTS		0x4000


/***************************************************************************/

@message TokenAsDWord MSG_VIS_TEXT_GET_TYPE(@stack
					   VisTextGetAttrFlags flags,
					   VisTextTypeDiffs *diffs,
					   VisTextType *type,
					   dword rangeEnd, 
					   dword rangeStart) = dx.ax;
/*
 *  Return the type for the specified range.
 *	PASS: 
 *	RETURN:	buffer filled in
 *	   	TokenAsDWord
 * 		  Use DWORD_TOKEN to get the type token (0 if multiple)
 *		  and DWORD_DATA to get VisTextTypeDiffs
 *	COMPAT:	This method cannot be used on a text object that does not have
 *		multiple types or does not have a name array
 */


/**************************************************************************/

@message word MSG_VIS_TEXT_ADD_TYPE(@stack VisTextType type) = ax;
/*
 * 	Add a given type to the type array and initialize its reference
 *	count to one, and return its token.
 *
 *	    PASS:   type    - VisTextType to add
 *	    RETURN: token   - type token
 *	    COMPAT: This method cannot be used on a text object that 
 *	    	    does not have multiple types.
 */

/**************************************************************************/

@message void MSG_VIS_TEXT_REMOVE_TYPE(word token = cx); 
/*
 * 	Remove a given type from the type array.
 *	    PASS: token - token of the type to remove
 *	    COMPAT: This method cannot be used on a text object that 
 *	    	    does not have multiple types.
 */


/*---------------------------------------------------------------------------
 * 	    Messages to set name information
 *--------------------------------------------------------------------------*/
/*
 *	 "Token" for names & types in the current file
 */
#define VIS_TEXT_CURRENT_FILE_TOKEN	-1 

typedef ByteEnum VisTextNameType;
#define	VTNT_CONTEXT	0
#define VTNT_FILE   	1

typedef ByteEnum VisTextContextType;
#define VTCT_TEXT   	0
#define VTCT_CATEGORY	1
#define VTCT_QUESTION	2
#define VTCT_ANSWER 	3
#define VTCT_DEFINITION	4
#define VTCT_FILE   	255

typedef struct {
    VisTextNameType 	VTND_type;
    VisTextContextType	VTND_contextType;
    word    	    	VTND_file;
    DBGroupAndItem  	VTND_helpText;
} VisTextNameData;


/**************************************************************************/

@message TokenAsDWord MSG_VIS_TEXT_ADD_NAME(@stack 
                                            VisTextNameData data,
                                            NameArrayAddFlags flags,
                                            word size,
                                            char *name) = dx.ax;

/* XXX:
 * 	Add a name to the name array (or add a reference to an existing name).
 *	Set the data for the name to the given data.
 *
 *	PASS:	name - pointer to name to add
 *		size - length of name (0 for NULL-terminated)
 *		flags - NameArrayAddFlags
 *		data - VisTextNameData to add for the name
 *
 *	RETURN:	TokenAsDWord
 * 		Use DWORD_TOKEN to get the new token
 *		and DWORD_DATA to get a word which is non-zero if the name 
 *		was newly added.
 *
 ******************
 * FIXED
 ******************
 *  -- This definition was originally passing the values on the stack in the
 *     wrong order.  They have now been (correctly) reversed as follows:
 *
 *       data - VisTextNameData to add for the name
 *       flags - NameArrayAddFlags
 *       size - length of name (0 for NULL-terminated)
 *       name - pointer to name to add
 *  
 */

/**************************************************************************/

@message word MSG_VIS_TEXT_FIND_NAME(@stack
				     char *name,
				     word size,
				     VisTextNameData *data) = ax;
/*
 *	Find a name in the name array.
 *	
 *	PASS:	name - pointer to name to find
 *	    	size - length of name (0 if NULL-terminated)
 *	    	data - pointer to VisTextNameData buffer for data (0 if none)
 *
 *	RETURN:	token, or CA_NULL_ELEMENT if not found.
 *
 *	COMPAT:	This method cannot be used on a text object that does not have
 *		multiple types
 */

/**************************************************************************/

@message word MSG_VIS_TEXT_FIND_NAME_BY_TOKEN(word token = bp, 
				      NameArrayMaxElement *buffer = cx:dx) = ax;
/*
 *	Return the data for a name token.
 *	
 *	PASS:	token - token of name to return data for
 *	    	buffer - NameyArrayMaxElement buffer to fill in
 *	RETURN:	buffer filled
 *              size of element (including header)
 *	COMPAT:	This method cannot be used on a text object that does not have
 *		multiple types
 */


/**************************************************************************/

@message void MSG_VIS_TEXT_ADD_REF_FOR_NAME(word token = cx);
/*
 *	Add a reference for a name.
 *
 *	Pass:	token - token of name to add reference for
 *	Return:	nothing
 *	Compat:	This method cannot be used on a text object that does not have
 *		multiple types
 */


/**************************************************************************/

@message void MSG_VIS_TEXT_REMOVE_NAME(word token = cx);
/*
 *	Remove a given name from the name array.
 *	
 *	Pass:	token - token of name to remove
 *	Return:	nothing
 *	Compat:	This method cannot be used on a text object that does not have
 *		multiple types
 */


/*--------------------------------------------------------------------------
 * 	    Messages to set graphic information
 *--------------------------------------------------------------------------*/
 
/*
 * "graphics" are a general purpose mechanism to embed things in the text
 * stream.  Graphics can have data stored several ways:
 *   * vm chains
 *   * db items
 *   * lmem chunks -- this format is not supported for cut/copy/paste
 *
 * graphics can be of several types
 *   * gstrings -- handled automatically
 *   * annotations -- handled automatically   *** NOT YET SUPPORTED ***
 *   * custom
 *
 * Graphics are treated as characters, and thus reasonably small graphics can
 * be in the middle of a line of text.
 *
 */

/*
 *	Size of opaque structure in VisTextGraphic
 */
#define VIS_TEXT_GRAPHIC_OPAQUE_SIZE	32

/*
 *	Types of graphics
 */
typedef ByteEnum VisTextGraphicType;
#define VTGT_GSTRING 0
#define VTGT_VARIABLE 1

/*
 *	Flags for graphics
 */
typedef WordFlags VisTextGraphicFlags;

#define VTGF_DRAW_FROM_BASELINE	    0x8000	
	/*  	Draw from baseline if set, else draw from top */
#define VTGF_HANDLES_POINTER	    0x4000  
	/* 	Graphic can deal with pointer messages */
#define VTGF_HOT_SPOT	    	    0x2000
	/* 	This GString graphic defines a hot spot */


/*
 *	Type dependent data
 *
 * VTGT_GSTRING: gstring
 *	VTG_opaque = VisTextGraphicGString
 */
typedef struct {
    TransMatrix	VTGG_tmatrix;
    XYOffset	VTGG_drawOffset;
} VisTextGraphicGString;

/*
 * VTGT_VARIABLE: message sent to object.  See documentation below.
 *	VTG_opaque = VisTextGraphicVariable
 */
typedef struct {
    ManufacturerID	VTGV_manufacturerID;
    VisTextVariableType	VTGV_type;
    byte		VTGV_privateData[VIS_TEXT_GRAPHIC_OPAQUE_SIZE-4];
} VisTextGraphicVariable;


typedef union {
    VisTextGraphicGString	VTGD_gstring;
    VisTextGraphicVariable	VTGD_variable;
    byte			VTGD_opaque[VIS_TEXT_GRAPHIC_OPAQUE_SIZE];
} VisTextGraphicData;


/*
 *	Definition of a text graphic element.
 */
typedef struct {
    RefElementHeader	VTG_meta;
    dword	    	VTG_vmChain;	   /* This is a dword value to pass
			    	    	    * to the VMChain routines.
					    *
					    * If only the low word is 0,
					    * then the high word is a VM
					    * handle.
					    *
					    * If both are non-zero, it is 
					    * a DB item (high word is group
					    * and low word is item)
					    *
					    * If the high word is 0, then the
					    * low word is an LMemChunk.
					    *
					    * If both are 0, there is no data.
					    */

    XYSize		VTG_size;   	/* Size of graphic (0 if dynamic) */
    VisTextGraphicType	VTG_type;
    VisTextGraphicFlags	VTG_flags;
    byte		VTG_reserved[4];
    VisTextGraphicData	VTG_data;
} VisTextGraphic;


#define VIS_TEXT_DEFAULT_GRAPHIC_WIDTH	10
#define VIS_TEXT_DEFAULT_GRAPHIC_HEIGHT	10


/****************************************************************************/

@message void MSG_VIS_TEXT_REPLACE_WITH_GRAPHIC(@stack
						VisTextGraphic graphic,
						word sourceFile,
						word pasteFrame,
					   	dword rangeEnd, 
					   	dword rangeStart);
/*
 *	Replace the given range with a graphic.
 *
 *	Pass:	graphic - VisTextGraphic
 *		sourceFile - source VM file
 *		pasteFrame - pointer to frame if quick paste,
 *					0 otherwise
 *	Compat:	As described above, only text objects stored in vm files can
 *		paste in graphics stored in vm blocks.
 */

/****************************************************************************/

@message void MSG_VIS_TEXT_GET_GRAPHIC_AT_POSITION(@stack 
				VisTextGraphic *retPtr, dword position);
/*
 *	Get the VisTextGraphic structure corresponding to a graphic
 *	at the passed position.
 */

/****************************************************************************/
@message SizeAsDWord MSG_VIS_TEXT_GRAPHIC_VARIABLE_SIZE(
				GStateHandle gstate = cx,
				VisTextGraphic *graphic = dx:bp) = dx.cx;
/*
 * 	Find the size of a variable graphic.  The default handler for
 *	this sends a MSG_GEN_DOCUMENT_GET_VARIABLE up the visual tree 
 *	(via MSG_VIS_VUP_CALL_OBJECT_OF_CLASS).
 *
 *	Pass:	gstate - GStateHandle 
 *		graphic - VisTextGraphic to find size of.
 *
 *	Return:	SizeAsDWord
 *		Use DWORD_WIDTH and DWORD_HEIGHT to get width, height
 */

/****************************************************************************/

@message SizeAsDWord MSG_VIS_TEXT_GRAPHIC_VARIABLE_DRAW(
				GStateHandle gstate = cx,
				VisTextGraphic *graphic = dx:bp) = dx.cx;
/*
 * 	Draw a variable graphic.  The default handler for
 *	this sends a MSG_GEN_DOCUMENT_GET_VARIABLE up the visual tree 
 *	(via MSG_VIS_VUP_CALL_OBJECT_OF_CLASS).
 *
 *	Pass:	GStateHandle gstate - gstate with font and current position set
 *		VisTextGraphic graphic
 *
 *	Return:	SizeAsDWord
 *		Use DWORD_WIDTH and DWORD_HEIGHT to get width, height
 */


/* 
 *	Not yet implemented........... 
 */
@message void MSG_VIS_TEXT_GRAPHIC_VARIABLE_START_SELECT(); /* NEEDS PROTOTYPE */
@message void MSG_VIS_TEXT_GRAPHIC_VARIABLE_OPEN(); /* NEEDS PROTOTYPE */
@message void MSG_VIS_TEXT_GRAPHIC_VARIABLE_CLOSE(); /* NEEDS PROTOTYPE */


/* 
 * Utility routine for compressing graphics 
 */

extern VMChain
   _pascal VisTextGraphicCompressGraphic(VisTextGraphic *graphic, 
					 FileHandle sourceFile,
					 FileHandle destFile,
					 BMFormat format,
					 byte compressFlag,
					 word xRes, word yRes);
/*
 * Copy a VisTextGraphic GString to a new GString, optimizing its bitmaps
 * along the way.
 *
 *	Pass:	graphic - pointer to the VisTextGraphic element
 *	    	    	  whose gstring is to be compressed.
 *	    	sourceFile - file containing the graphic's gstring
 *	    	destFile - file to create the new gstring in
 *	    	format - BMFormat to convert all bitmaps to
 *	    	compressFlag - non-zero to compress bitmaps
 *	        xRes - x Resolution to convert all bitmaps to
 *	        yRes - y Resolution to convert all bitmaps to
 *
 *	Return: VMChain of new GString
 */

/*---------------------------------------------------------------------------
 *	Utility routine for format numbers
 *--------------------------------------------------------------------------*/

extern void
    _pascal VisTextFormatNumber(char *buf, dword num, VisTextNumberType numtype);
/*
 * 	Format a number into a buffer.
 * 	This routine is commonly used by handlers for variable graphics.
 *	  PASS:
 *		char *buf - pointer to buffer
 *		dword num - number to format
 *		VisTextNumberType numType - format to use
 */



/*---------------------------------------------------------------------------
 *	Messages to load and save data in text objects.
 *--------------------------------------------------------------------------*/

/*
 * 	These data structures are used to store a text object in a DBItem.
 * 	Do not use these unless absolutely necessary.
 */

typedef ByteEnum VisTextSaveType;
#define	VTST_NONE 		0	/* nothing saved */
#define VTST_SINGLE_CHUNK 	1	/* single attr structure */
#define VTST_RUNS_ONLY 		2
#define VTST_RUNS_AND_ELEMENTS 	3

typedef WordFlags VisTextSaveDBFlags;
#define VTSDBF_TEXT 	    0x8000	/* set if text saved (0 = null text) */
#define VTSDBF_CHAR_ATTR    0x6000
#define VTSDBF_PARA_ATTR    0x1800
#define VTSDBF_TYPE 	    0x0600
#define VTSDBF_GRAPHIC 	    0x0180
#define VTSDBF_STYLE 	    0x0040
#define VTSDBF_REGION 	    0x0020 	/* not currently implemented */
#define VTSDBF_NAME 	    0x0010

#define VTSDBF_CHAR_ATTR_OFFSET	13
#define VTSDBF_PARA_ATTR_OFFSET	11
#define VTSDBF_TYPE_OFFSET  	9
#define VTSDBF_GRAPHIC_OFFSET  	7


/**************************************************************************/

@message DBGroupAndItem MSG_VIS_TEXT_SAVE_TO_DB_ITEM(
				    DBGroupAndItem item = cx.dx,
				    VisTextSaveDBFlags flags = bp) = cx.dx;
/* 
 *	Save a text object to a DB item. 
 *
 *	PASS:
 *		item - DBGroupAndItem to save to (or 0 to allocate)
 *		flags - VisTextSavedDBFlags
 */

@alias (MSG_VIS_TEXT_SAVE_TO_DB_ITEM) DBGroupAndItem
    MSG_VIS_TEXT_SAVE_TO_DB_GROUP_ITEM(DBGroup group = cx,
				    DBItem item = dx,
				    VisTextSaveDBFlags flags = bp) = cx.dx;

/**************************************************************************/

typedef struct {
    StyleSheetParams	VTSSSP_common;
    word		VTSSSP_graphicsElements; 
/* 	VMBlock of graphics elements */

    word		VTSSSP_treeBlock;
    word		VTSSSP_graphicTreeOffset; 
/* 	offset in treeBlock */
} VisTextSaveStyleSheetParams;


/**************************************************************************/

@message DBGroupAndItem MSG_VIS_TEXT_SAVE_TO_DB_ITEM_WITH_STYLES(@stack
				    FileHandle xferFile,
				    VisTextSaveDBFlags flags,
				    DBGroupAndItem item,
				    VisTextStyleSheetParams *params);
/*
 * Save a text object to a DB item, passing a StyleSheetParams structure.
 *
 * This message is intended for applications that have multiple text objects
 * sharing common attribute structures.  Only VTST_RUNS_ONLY should be passed
 * for charAttr and paraAttr (and likely type and graphic) and normally
 * VTST_STYLE will not be passed.
 *
 * 	PASS:	xferFile - if non-zero then the StyleSheetParams
 *			    are not initialized and this is the
 *			    file to put the arrays in.
 *		flags - VisTextSavedDBFlags 
 *		item - DBGroupAndItem to save to (0 to allocate one)
 *		params - StyleSheetParams 
 *
 * 	RETURN: saved DBGroupAndItem 
 */

/***************************************************************************/

@message void MSG_VIS_TEXT_LOAD_FROM_DB_ITEM(DBGroupAndItem item = cx.dx,
					     VMFileHandle file = bp);
/* 
 * 	Load a text object from a DBItem.
 *
 *	PASS:	item - DBGroupAndItem to load from
 *		file - VMFileHandle to use (or 0 to use the
 *			file associated with the text object)
 */

@alias (MSG_VIS_TEXT_LOAD_FROM_DB_ITEM) void
    MSG_VIS_TEXT_LOAD_FROM_DB_GROUP_ITEM(DBGroup group = cx,
					    DBItem item = dx,
					    VMFileHandle file = bp);

/***************************************************************************/

@message void MSG_VIS_TEXT_LOAD_FROM_DB_ITEM_WITH_STYLES(@stack
				    FileHandle file,
				    DBGroupAndItem item,
				    StyleSheetParams *params);
/* 
 * 	Load a text object from a DBItem, passing a 
 *	StyleSheetParams structure.
 *
 *	PASS: 	file - VMFileHandle to use (or 0 to use the
 *			file associated with the text object)
 *		item - DBGroupAndItem to load from 
 *		params - StyleSheetParams
 */

/***************************************************************************/

@message void MSG_VIS_TEXT_SET_VM_FILE(VMFileHandle file = cx);
/*
 *	Change the file handle with which the text object is associated.
 *
 *	PASS: 	file - FileHandle of file to associate with text object
 *	RETURN: nothing
 */


/*--------------------------------------------------------------------------
 *	Messages to create and destroy the data structures used to store
 *	attributes
 *-------------------------------------------------------------------------*/

/****************************************************************************/

@message void MSG_VIS_TEXT_CREATE_STORAGE(VisTextStorageFlags flags = cl,
					  byte regionFlag = ch);
/*
 *	Create storage structures for a text object.  Note that 
 *	additional levels of attribute storage can only be *set*.
 *
 *	These bits can be set:
 *		VTSF_MULTIPLE_CHAR_ATTRS, VTSF_MULTIPLE_PARA_ATTRS,
 *		VTSF_TYPES, VTSF_GRAPHICS
 *
 * 	PASS: 	flags - VisTextStorage flags to set
 *		regionFlag - non-zero to create regions
 * 	RETURN: nothing
 * 	COMPAT: Can be used with small or large objects as long as the
 *		object does not already have the structures to be added.
 */


/****************************************************************************/

typedef struct {
  VisTextStorageFlags	VTCEAP_storageFlags;	/* cl */
  byte			VTCEAP_blockOrChunk;	/* ch */
} VisTextChangeElementArrayParams;

@message void MSG_VIS_TEXT_CHANGE_ELEMENT_ARRAY(
				VisTextChangeElementArrayParams params = cx, 
				word arrayHandle = dx,
				word token = bp);
/*
 *	Change the element array being used for the text object.  This
 *	allows an application to easily set up multiple objects referencing
 *	common element arrays.
 *
 *	If you are changing multiple arrays, do the name and style arrays 
 *	first because to change the element array the text object must free
 *	the old element array. To do this it must know how this array is
 *	stored (with chunk or VM block). It does this by looking at the
 *	character attributes and assuming that the styles/names are stored
 *	in the same way.  Thus we must change the styles/names while the
 *	character attributes are still stored in a chunk so that the old
 *	style/name array will be freed correctly.
 *
 * PASS:
 *	flags - VisTextStorageFlags for field to replace.
 *		One of these bits should be set:
 *
 *			VTSF_MULTIPLE_CHAR_ATTRS
 *			VTSF_MULTIPLE_PARA_ATTRS
 *			VTSF_TYPES
 *			VTSF_GRAPHICS
 *			VTSF_STYLES
 *			VTSF_NAMES
 *
 *	blockOrChunk - non-zero if value passed in arrayHandle is 
 *			a VM block, zero if it is a chunk handle
 *	arrayHandle - VM block handle or chunk handle containing 
 *			element array (depends on blockOrChunk)
 *	token  - token for empty run to cover object (char, para, type)
 */

/****************************************************************************/

@message void MSG_VIS_TEXT_FREE_STORAGE(Boolean removeElementArrays = cx);
/*
 *	Remove all runs associated with this object.
 *	Basically all elements which are referred to have their reference
 *	counts decremented and if the reference counts go to zero, the
 *	elements are removed.
 *	Use caution with this method.
 *
 *	PASS:	removeElementArrays - TRUE to remove element arrays also
 *	RETURN:	nothing
 */


/*--------------------------------------------------------------------------
 *	Messages to create and manipulate transfer items
 *-------------------------------------------------------------------------*/
/*
 *
 *		Structure of a transfer item (TIF_TEXT)
 *
 * Note that some of the blocks in the tree are lmem blocks.  For VM chains the
 * first word of a block must be the VM block handle of the next linked data
 * block.  For the lmem code, the first word must be the block handle.
 * Also, the HF_LMEM bit in the handle must be set for the lmem code, but it
 * must not be set for the clipboard.
 *
 * To handle this conflict, the text object clears the HF_LMEM bit and stuffs
 * the VM block handle link (always 0 for now) before calling the clipboard.
 * When it gets a block from the clipboard, the text object locks it and
 * temporarily sets the HF_LMEM bit.
 *
 * The element arrays in lmem blocks use the chunk handle
 * "VM_ELEMENT_ARRAY_CHUNK" defined below.
 *
 */

#define VM_ELEMENT_ARRAY_CHUNK	(((sizeof(LMemBlockHeader)) + 3) & ~3)

typedef struct {
    VMChainTree	TTBH_meta;
    word	TTBH_reservedOther[20];
    VMChain	TTBH_text;
    VMChain	TTBH_charAttrRuns;
    VMChain	TTBH_paraAttrRuns;
    VMChain	TTBH_typeRuns;
    VMChain	TTBH_graphicRuns;
    VMChain	TTBH_charAttrElements;
    VMChain	TTBH_paraAttrElements;
    VMChain	TTBH_typeElements;
    VMChain	TTBH_graphicElements;
    VMChain	TTBH_styles;
    VMChain	TTBH_names;
    VMChain	TTBH_pageSetup;
    VMChain	TTBH_reservedVM[10];
} TextTransferBlockHeader;

/*
 *	The following structure is plugged into the TTBH_pageSetup field
 *	by apps during an export.
 */
typedef struct {
    VMChainLink	PSI_meta;
    XYSize  	PSI_page;
    PageLayout  PSI_layout;
    word    	PSI_numColumns;
    word    	PSI_columnSpacing;  	/* Points * 8 */
    word    	PSI_ruleWidth;		/* Pixels (points) */
/* The margins are relative to the edges of the page */
    word    	PSI_leftMargin;	    	/* Points * 8 */
    word    	PSI_rightMargin;    	/* Points * 8 */
    word    	PSI_topMargin;	    	/* Points * 8 */
    word    	PSI_bottomMargin;   	/* Points * 8 */
} PageSetupInfo;


/***************************************************************************/

extern 	void	/*XXX*/
    _pascal VTFClearSmartQuotes();
/* 
 *	Clear the variable that prohibits smart quotes.
 *
 *	PASS: 	nothing
 *	RETURN: nothing
 */


/***************************************************************************/

extern optr /*XXX*/
    _pascal TextAllocClipboardObject(VMFileHandle file, 
				     VisTextStorageFlags storageFlags,
			     	     byte regionFlag);
/*
 * 	Allocate a temporary object associated with the clipboard file 
 *	for purposes of producing a transfer item.
 *
 *	PASS:
 *		storageFlags - VisTextStorageFlags for object. 
 *		    Only the following bits may be set:
 *			VTSF_MULTIPLE_CHAR_ATTRS
 *			VTSF_MULTIPLE_PARA_ATTRS
 *			VTSF_TYPES
 *			VTSF_GRAPHICS
 *			VTSF_STYLES
 *		     The following are assumed set if flags = 0:
 *		VTSF_LARGE, VTSF_DEFAULT_CHAR_ATTR, VTSF_DEFAULT_PARA_ATTR
 *
 *		regionFlag - non-zero to create regions for object
 *
 *		file - FileHandle of file with which to associate object, 
 *			or 0 for clipboard file
 *	RETURN:
 *		optr - clipboard object
 */


typedef enum {
    TCO_COPY,
    TCO_RETURN_TRANSFER_FORMAT,
    TCO_RETURN_TRANSFER_ITEM,
    TCO_RETURN_NOTHING,
} TextClipboardOption;


/**************************************************************************/

extern VMBlockHandle	/*XXX*/
    _pascal TextFinishWithClipboardObject(optr obj, TextClipboardOption opt,
    			    	    	  optr owner, const char *name);
/*
 *	Finish with an object created by TextAllocClipboardObject
 *
 *	PASS:
 *		obj - optr
 *		opt - TextClipboardOption
 *		owner - optr of owner for clipboard item
 *		name - pointer to name for clipboard item (-1 for default)
 *
 * 	RETURN:
 *		object destroyed.
 *		Return value depends on value passed in opt:
 *		TCO_COPY			nothing; transfer item is
 *						generated from the object and
 *						set as the normal transfer item
 *		TCO_RETURN_TRANSFER_FORMAT	VM block handle to store in
 *						high word of TFI_vmChain (low
 *						word s/b 0)
 *		TCO_RETURN_TRANSFER_ITEM	VM block handle of block with
 *						TransferItemHeader and text
 *						rendered from the object in
 *						the appropriate formats
 *		TCO_RETURN_NOTHING		nothing. just destroys the
 *						text object.
 */

/**************************************************************************/

/*XXX*/
@message void MSG_VIS_TEXT_REPLACE_WITH_TEXT_TRANSFER_FORMAT(@stack
					VMBlockHandle block, 
					VMFileHandle file, word pasteFrame,
    	    	    	    	    	dword end, dword start);
/*
 *	Replace the given range with a text transfer item.  The range passed
 *	is the range to replace.  (0, 0) can be passed to insert and the
 *	beginning.  (TEXT_ADDRESS_PAST_END, TEXT_ADDRESS_PAST_END) can be
 *	passed to append at the end.
 *
 *	Pass:	block - VMBlockHandle
 *		file - VMFileHandle
 *		pasteFrame - ptr to frame if quick paste, 0 otherwise
 *		start, end - range to replace
 *	Return:	nothing
 */

/**************************************************************************/
/*XXX*/
@message VMBlockHandle MSG_VIS_TEXT_CREATE_TRANSFER_FORMAT(@stack 
					VMBlockHandle block, 
					VMFileHandle file, word pasteFrame,
    	    	    	    	    	dword end, dword start) = ax;
/*
 *	Create a text transfer item for a range of text.
 *
 *	Pass:	block - VMBlockHandle
 *		file - VMFileHandle
 *		pasteFrame - ptr to frame if quick paste, 0 otherwise
 *		start, end - range to replace
 *
 *	Return:	VMBlockHandle of newly created transfer block
 */


/*--------------------------------------------------------------------------
 *	      Methods for modifying text in a text object
 *--------------------------------------------------------------------------*/

/**************************************************************************/

@message void MSG_VIS_TEXT_REPLACE_ALL_PTR(const char *text = dx:bp,
				       word textLen = cx);
/*
 * Replace the entire text of an object with text referenced by a pointer.
 *	PASS:	text	= Pointer to the text string
 *		textLen	= String length, or 0 if null-terminated
 */

/**************************************************************************/

@message void MSG_VIS_TEXT_REPLACE_ALL_OPTR(optr o = dx:bp,
				       word textLen = cx);
/*
 * Replace the entire text of an object with text referenced by a chunk.
 *	PASS:	o	= Pointer to the text string
 *		textLen	= String length, or 0 if null-terminated
 */

/**************************************************************************/

@message void MSG_VIS_TEXT_REPLACE_ALL_BLOCK(word block = dx,
				       word textLen = cx);
/*
 * Replace the entire text of an object with text referenced by a block.
 *	PASS:	block	= Pointer to the text string
 *		textLen	= String length, or 0 if null-terminated
 */

/**************************************************************************/

@message void MSG_VIS_TEXT_REPLACE_ALL_VM_BLOCK(VMFileHandle file = dx,
				       VMBlockHandle block = bp,
				       word textLen = cx);
/*
 * Replace the entire text of an object with text referenced by a vm-block.
 *	PASS:	file	= file handle
 *		block	= vm block handle
 *		textLen	= String length, or 0 if null-terminated
 */

/**************************************************************************/

@message void MSG_VIS_TEXT_REPLACE_ALL_DB_ITEM(VMFileHandle file = dx,
				       DBGroup group = bp,
				       DBItem item = cx);
/*
 * Replace the entire text of an object with text referenced by a db-item.
 * The text is assumed to be NULL terminated.
 *
 *	PASS:	file	= file handle
 *		group	= Group number
 *	    	item	= Item number
 */


/**************************************************************************/

@message void MSG_VIS_TEXT_REPLACE_ALL_HUGE_ARRAY(VMFileHandle file = dx,
				       VMBlockHandle hugeArrayBlock = bp,
				       word textLen = cx);
/*
 * Replace the entire text of an object with text referenced by a huge-array.
 *
 *	PASS:	file	= file handle
 *		hugeArrayBlock	= HugeArray
 *		textLen	= String length, or 0 if null-terminated
 */


/**************************************************************************/

@message void MSG_VIS_TEXT_REPLACE_SELECTION_PTR(const char *text = dx:bp,
				       word textLen = cx);
/*
 * Replace the selection of an object with text referenced by a pointer.
 *	PASS:	text	= Pointer to the text string
 *		textLen	= String length, or 0 if null-terminated
 */

/**************************************************************************/

@message void MSG_VIS_TEXT_REPLACE_SELECTION_OPTR(optr o = dx:bp,
				       word textLen = cx);
/*
 * Replace the selection of an object with text referenced by a chunk.
 *	PASS:	o	= Pointer to the text string
 *		textLen	= String length, or 0 if null-terminated
 */

/**************************************************************************/

@message void MSG_VIS_TEXT_REPLACE_SELECTION_BLOCK(word block = dx,
				       word textLen = cx);
/*
 * Replace the selection of an object with text referenced by a block.
 *	PASS:	block	= Pointer to the text string
 *		textLen	= String length, or 0 if null-terminated
 */

/**************************************************************************/

@message void MSG_VIS_TEXT_REPLACE_SELECTION_VM_BLOCK(VMFileHandle file = dx,
				       VMBlockHandle block = bp,
				       word textLen = cx);
/*
 * Replace the selection of an object with text referenced by a vm-block.
 *	PASS:	file	= file handle
 *	    	block	= vm block handle
 *		textLen	= String length, or 0 if null-terminated
 */

/**************************************************************************/

@message void MSG_VIS_TEXT_REPLACE_SELECTION_DB_ITEM(VMFileHandle file = dx,
				       DBGroup group = bp,
				       DBItem item = cx);
/*
 * Replace the selection of an object with text referenced by a db-item.
 * The text is assumed to be NULL terminated.
 *	PASS:	file	= file handle
 *	    	group	= Group number
 *		item 	= Item number
 */

/**************************************************************************/

@message void MSG_VIS_TEXT_REPLACE_SELECTION_HUGE_ARRAY(VMFileHandle file = dx,
				       VMBlockHandle hugeArrayBlock = bp,
				       word textLen = cx);
/*
 * Replace the selection of an object with text referenced by a HugeArray
 *	PASS:	file	= file handle
 *	    	hugeArrayBlock	= HugeArray
 *		textLen	= String length, or 0 if null-terminated
 */

/**************************************************************************/

@message void MSG_VIS_TEXT_APPEND_PTR(const char *text = dx:bp,
				       word textLen = cx);
/*
 * Append to an object with text referenced by a pointer.
 *	PASS:	text	= Pointer to the text string
 *		textLen	= String length, or 0 if null-terminated
 */

/**************************************************************************/

@message void MSG_VIS_TEXT_APPEND_OPTR(optr o = dx:bp,
				       word textLen = cx);
/*
 * Append to an object with text referenced by an optr.
 *	PASS:	o	= Pointer to the text string
 *		textLen	= String length, or 0 if null-terminated
 */

/**************************************************************************/

@message void MSG_VIS_TEXT_APPEND_BLOCK(word block = dx,
				       word textLen = cx);
/*
 * Append to an object with text referenced by a block.
 *	PASS:	block	= Pointer to the text string
 *		textLen	= String length, or 0 if null-terminated
 */

/**************************************************************************/

@message void MSG_VIS_TEXT_APPEND_VM_BLOCK(VMFileHandle file = dx,
				       VMBlockHandle block = bp,
				       word textLen = cx);
/*
 * Append to an object with text referenced by a VMBlock 
 *	PASS:	file	= file handle
 *		block	= VMBlockHandle
 *		textLen	= String length, or 0 if null-terminated
 */

/**************************************************************************/

@message void MSG_VIS_TEXT_APPEND_DB_ITEM(VMFileHandle file = dx,
				       DBGroup group = bp,
				       DBItem item = cx);
/*
 * Append to an object with text referenced by a DBItem
 *	PASS:	file	= file handle
 *		group	= DBGroup
 *		item	= DBItem
 */

/**************************************************************************/

@message void MSG_VIS_TEXT_APPEND_HUGE_ARRAY(VMFileHandle file = dx,
				       VMBlockHandle hugeArrayBlock = bp,
				       word textLen = cx);
/*
 * Append to an object with text referenced by a HugeArray.
 *	PASS:	file	= file handle
 *		hugeArrayBlock	= HugeArray
 *		textLen	= String length, or 0 if null-terminated
 */

/**************************************************************************/

@message word MSG_VIS_TEXT_GET_ALL_PTR(const char *text = dx:bp) = cx;
/*
 * Get the entire text of an object into a buffer referenced by a pointer.
 *	PASS:	text	= Pointer to the text buffer
 *	RETURN:	word	= String length not counting the NULL
 */

/**************************************************************************/

@message ChunkHandle MSG_VIS_TEXT_GET_ALL_OPTR(optr o = dx:bp) = cx;
/*
 * Get the entire text of an object into a buffer referenced by a chunk.
 * The chunk will always exist on return.  It will contain at least a NULL.
 *
 *	PASS:	o = optr of block which is to contain chunk
 *		    pass the ChunkHandle of chunk to hold text, 
 *			  0 to allocate new chunk
 *
 *	RETURN:	ChunkHandle of the chunk in which text was placed.
 *	    	Chunk resized to be the size of the null-terminated text.
 */

/**************************************************************************/

@message MemHandle MSG_VIS_TEXT_GET_ALL_BLOCK(word block = dx) = cx;
/*
 * Get the entire text of an object into a buffer referenced by a block.
 * The block will always exist on return.  It will contain at least a NULL.
 *
 *	PASS:	block	= MemHandle of block to hold text
 *			= 0 to allocate new block
 *
 *	RETURN:	MemHandle of the block in which text was placed.
 *		Block resized to be the size of the null-terminated text.
 */

/**************************************************************************/

@message VMBlockHandle MSG_VIS_TEXT_GET_ALL_VM_BLOCK(VMFileHandle file = dx,
			       	VMBlockHandle block = bp) = cx;
/*
 * Get the entire text of an object into a buffer referenced by a VMBlock.
 * The VMBLock will always exist on return.  It will contain at least a NULL.
 *
 *	PASS:	file = FileHandle
 *		block	= VMBlockHandle of block to hold text
 *			= 0 to allocate new VMBlock.
 *
 *	RETURN:	VMBlockHandle of the block in which text was placed.  
 *	    	Block resized to be the size of the null-terminated text.
 */

/**************************************************************************/

@message DBGroupAndItem MSG_VIS_TEXT_GET_ALL_DB_ITEM(VMFileHandle file = dx,
					   DBGroup group = bp,
					   DBItem item = cx) = bp.cx;
/*
 * Get the entire text of an object into a buffer referenced by a DBItem.
 * The item will always exist on return.  It will contain at least a NULL.
 *
 *	PASS:	file 	= FileHandle
 *		group	= Group
 *		item	= Item, 0 to allocate new item.
 *
 *	RETURN:	DBGroupAndItem in which the text was placed.  
 *	    	DBItem resized to be the size of the null-terminated text.
 */


/**************************************************************************/

@message  VMBlockHandle MSG_VIS_TEXT_GET_ALL_HUGE_ARRAY(VMFileHandle file = dx,
				     VMBlockHandle hugeArrayBlock = bp) = cx;
/*
 * Get the entire text of an object into a buffer referenced by a HugeArray.
 * The HugeArray will always exist on return.  It will contain at least a NULL.
 *
 *	PASS:	file = FileHandle
 *		hugeArrayBlock	= HugeArray
 *				= 0 to allocate a new array
 *	RETURN:	VMBlockHandle of the array in which the text was placed.  
 *	    	Array resized to be size of the null-terminated text.
 */


/****************************************************************************/

@message word MSG_VIS_TEXT_GET_SELECTION_PTR(char *text = dx:bp) = cx;
/*
 * Get the selected text of an object into a buffer referenced by a pointer.
 *	PASS:	text 	= Pointer to the text string
 *	RETURN:	String length not counting the NULL
 */

/****************************************************************************/

typedef struct {
    word		VTGRS_length;
    word		VTGRS_handle;
    word		VTGRS_dx;
    DBGroup		VTGRS_group;
} VisTextGetReturnStruct;

@message void MSG_VIS_TEXT_GET_SELECTION_OPTR(
				VisTextGetReturnStruct *retVal = axcxdxbp,
				block MemHandle = dx,
				chunk ChunkHandle = bp);
/*
 * Get the selected text of an object into a buffer referenced by a chunk.
 * The chunk will always exist on return. It will contain at least a NULL.
 *
 *	PASS:	*retVal = VisTextGetReturnStruct
 *		block	= MemHandle of block containing chunk
 *		chunk	= ChunkHandle of chunk to hold text, 
 *			  0 to allocate new chunk
 *
 *	RETURN:	*retVal->VTGRS_length = string length, not counting the NULL
 *		*retVal->VTGRS_handle = ChunkHandle of the chunk in which text
 *					was placed.  Chunk resized to be the
 *					size of the null-terminated text.
 */
			

/****************************************************************************/

@message void MSG_VIS_TEXT_GET_SELECTION_BLOCK(
				VisTextGetReturnStruct *retVal = axcxdxbp,
				word block = dx);
/*
 * Get the selected text of an object into a buffer referenced by a block.
 * The block will always exist on return.  It will contain at least a NULL.
 *
 *	PASS:	*retVal = VisTextGetReturnStruct
 *		block	= MemHandle of block to hold text
 *			= 0 to allocate new block
 *
 *	RETURN:	retVal->VTGRS_length = string length, not counting the NULL
 *		retVal->VTGRS_handle = MemHandle of the block in which text
 *					was placed.  Block resized to be the
 *					size of the null-terminated text.
 */


/****************************************************************************/

@message void MSG_VIS_TEXT_GET_SELECTION_VM_BLOCK(
				VisTextGetReturnStruct *retVal = axcxdxbp,
				VMFileHandle file = dx,
			 	VMBlockHandle block = bp);
/*
 * Get the selected text of an object into a buffer referenced by a VMBlock.
 * The VMBLock will always exist on return.  It will contain at least a NULL.
 *
 *	PASS:	*retVal = VisTextGetReturnStruct
 *		file = FileHandle
 *		block	= VMBlockHandle of block to hold text
 *			= 0 to allocate new VMBlock.
 *
 *	RETURN:	*retVal->VTGRS_length = string length, not counting the NULL
 *		*retVal->VTGRS_handle = VMBlockHandle of the block in which
 *					text was placed.  Block resized to be
 *					the size of the null-terminated text.
 */

/****************************************************************************/

@message void MSG_VIS_TEXT_GET_SELECTION_DB_ITEM(
				VisTextGetReturnStruct *retVal = axcxdxbp,
				VMFileHandle file = dx,
		 		DBGroup group = bp,
				DBItem item = cx);
/*
 * Get the selected text of an object into a buffer referenced by a DBItem.
 * The item will always exist on return.  It will contain at least a NULL.
 *
 *	PASS:	*retVal = VisTextGetReturnStruct
 *		file 	= FileHandle
 *		group	= Group
 *		item	= Item, 0 to allocate new item.
 *
 *	RETURN:	*retVal->VTGRS_length = string length, not counting the NULL
 *		*retVal->VTGRS_handle = DBItem of the chunk in which the text
 *					was placed.  DBItem resized to be the
 *					size of the null-terminated text.
 *		*retVal->VTGRS_group = Group (may be different from above if
 *					DB_UNGROUPED passed)
 */

/****************************************************************************/

typedef struct {
    word		VTGHARS_bp;
    dword		VTGHARS_length;
    word		VTGHARS_handle;
} VisTextGetHugeArrayReturnStruct;

@message void MSG_VIS_TEXT_GET_SELECTION_HUGE_ARRAY(
			VisTextGetHugeArrayReturnStruct *retval = bpaxdxcx,
			VMFileHandle file = dx,
			VMBlockHandle hugeArrayBlock = bp);
/*
 * Get the selected text of an object into a buffer referenced by a HugeArray.
 * The HugeArray will always exist on return.  It will contain at least a NULL.
 *
 *	PASS:	*retVal = VisTextGetHugeArrayReturnStruct
 *		file = FileHandle
 *		hugeArrayBlock	= HugeArray
 *				= 0 to allocate a new array
 *	RETURN:	*retVal->VTGHARS_length = string length, not counting the NULL
 *		*retVal->VTGHARS_handle = Array handle of the chunk in which 
 *					the text was placed.  Array resized to
 *					be size of the null-terminated text.
 */
				

/****************************************************************************/

@message void MSG_VIS_TEXT_DELETE_ALL();
/* 
 *	Delete the entire text of an object.
 *	PASS: 	nothing
 *	RETURN: nothing
 */

/****************************************************************************/

@message void MSG_VIS_TEXT_DELETE_SELECTION();
/* 
 *	Delete the selected text of an object.
 *	PASS: 	nothing
 *	RETURN: nothing
 */

/****************************************************************************/

@message void MSG_VIS_TEXT_GET_SELECTION_RANGE(VisTextRange *vtr = dx:bp);
/*
 *	Get the range of the selection.
 *	PASS: 	vtr - VisTextRange to fill in
 *	RETURN:	vtr filled in
 */

/****************************************************************************/

@message void MSG_VIS_TEXT_SELECT_RANGE_SMALL(word start = cx, word end = dx);
/*
 *	Select a range in the object.
 *
 *	PASS:	start - start of range to select
 *		end - end of range to select
 *	RETURN: nothing
 *	COMPAT: this only works with small model objects.
 */
 
/****************************************************************************/

@message void MSG_VIS_TEXT_SELECT_ALL();
/*
 * 	Select the entire object.
 *	PASS: 	nothing
 *	RETURN: nothing
 */

/****************************************************************************/

@message void MSG_VIS_TEXT_SELECT_START();
/*
 * 	Place the cursor at the start of the text.
 *	PASS: 	nothing
 *	RETURN: nothing
 */

/****************************************************************************/

@message void MSG_VIS_TEXT_SELECT_END();
/*
 * 	Place the cursor at the end of the text.
 *	PASS: 	nothing
 *	RETURN: nothing
 */

/****************************************************************************/

@message void MSG_VIS_TEXT_SELECT_RELATIVE(word newStart = cx, 
					   word newEnd = dx);
/*
 *	Place the cursor at a position relative to its current one.
 *
 *	PASS:	start - new start selection relative to old start selection
 *		end   - new end selection relative to old end selection
 *	RETURN: nothing
 */

/****************************************************************************/


/*----------------------------------------------------------------------------
 *	Messages to change or get the state of the text object
 *---------------------------------------------------------------------------*/

/****************************************************************************/

@message VisTextStates MSG_VIS_TEXT_GET_STATE()=cl;
/* 	
 *	Get the VTI_state
 *	PASS:	nothing
 *	RETURN:	VisTextState
 */

/***************************************************************************/

@message VisTextFeatures MSG_VIS_TEXT_GET_FEATURES()=cx;
/* 	
 *	Get the VTI_features
 *	PASS:	nothing
 *	RETURN:	VisTextFeatures
 */

/***************************************************************************/

@message void MSG_VIS_TEXT_SET_FEATURES(VisTextFeatures bitsToSet=cx, 
					VisTextFeatures bitsToClear=dx);
/* 	
 *	Set the VTI_features
 *	PASS:	bitsToSet - VisTextFeatures to set
 *		bitsToClear - VisTextFeatures to clear
 *	RETURN:	nothing
 */


/***************************************************************************/

@message void MSG_VIS_TEXT_SET_MAX_LENGTH(word newMaxLength = cx);
/* 	
 *	Set the maximum length of the text.  If the current text is too long,
 *	text at the end is removed. This only applies to small text objects.
 *
 *	PASS:	newMaxLength - maximum length
 *	RETURN: nothing
 */

/***************************************************************************/

@message word MSG_VIS_TEXT_GET_MAX_LENGTH() = cx;
/* 	
 *	Get the maximum length of the text.  
 *
 *	PASS:	nothing
 *	RETURN: maximum length
 */

/***************************************************************************/

@message Boolean MSG_VIS_TEXT_GET_USER_MODIFIED_STATE() = cx;
/* 	
 *	Get the user modified status of the text object.
 *
 *	PASS:	nothing
 *	RETURN: TRUE if user modified
 */

/***************************************************************************/

@message void MSG_VIS_TEXT_SET_NOT_USER_MODIFIED();
/* 	
 *	Mark a text object as not user modified.
 *
 *	PASS:	nothing
 *	RETURN: nothing
 */

/***************************************************************************/

@message void MSG_VIS_TEXT_SET_USER_MODIFIED();
/* 	
 *	Mark a text object as user modified.
 *
 *	NOTE: 	This does *not* send out the MSG_META_TEXT_USER_MODIFIED
 *		notification.
 *
 *	PASS:	nothing
 *	RETURN: nothing
 */

/***************************************************************************/

typedef struct {
    byte    VTWCMR_redOrIndex;
    byte    VTWCMR_mapMode;
} VisTextWashColorModeRed;

typedef struct {
    byte    VTWCBG_green;
    byte    VTWCBG_blue;
} VisTextWashColorBlueGreen;


@message void MSG_VIS_TEXT_SET_WASH_COLOR(VisTextWashColorModeRed modeRed = cx,
				  VisTextWashColorBlueGreen blueGreen = dx);
/*
 *	Set the wash color for behind the text.
 *
 *	PASS:	modeRed - VisTextWashColorModeRed:
 *		  VTWCMR_mapMode     - VisTextColorMapMode
 *		  VTWCMR_redOrIndex  - if (mapMode == CF_RGB), Red
 *			    	    - if (mapMode == CF_INDEX), color index.
 *		blueGreen - VisTextWashColorBlueGreen:
 *		  VTWCBG_blue	    - Blue (if mapMode == CF_RGB)
 *		  VTWCBG_green	    - Green (if mapMode == CF_RGB)
 *
 *	RETURN: nothing
 *		

/***************************************************************************/

typedef struct {
    VisTextWashColorBlueGreen VTGWC_blueGreen;
    VisTextWashColorModeRed VTGWC_modeRed;
} VisTextGetWashColor;

@message void MSG_VIS_TEXT_GET_WASH_COLOR(VisTextGetWashColor *retVal = dxcx);
/*
 *	Set the wash color for behind the text.
 *
 *	PASS:	*retVal - VisTextGetWashColor
 *	RETURN: *retVal filled in
 */


/***************************************************************************/

@message void MSG_VIS_TEXT_MODIFY_EDITABLE_SELECTABLE(
		  VisTextStates setBits = cl, VisTextStates clearBits = ch);
/*
 *	Modify the editable and/or selectable state of the object
 *
 *	PASS:	setBits   - VisTextStates to set
 *		clearBits - VisTextStates to clear
 */


/*--------------------------------------------------------------------------
 *	Internal methods used by specific UI
 *--------------------------------------------------------------------------*/

@message void MSG_VIS_TEXT_UPDATE_GENERIC();	
/*
 *	Update the generic instance data from the visual instance data.
 *	PASS:	nothing
 *	RETURN: nothing
 */


/*--------------------------------------------------------------------------
 *	Messages that can be subclassed to add functionality
 *--------------------------------------------------------------------------*/

typedef struct {
    VisTextCharAttr	    	VTNCAC_charAttr;
    word	    	    	VTNCAC_charAttrToken;
    VisTextCharAttrDiffs	VTNCAC_charAttrDiffs;
} VisTextNotifyCharAttrChange;


typedef struct {
    VisTextMaxParaAttr	    	VTNPAC_paraAttr;
    word	    	    	VTNPAC_paraAttrToken;
    VisTextParaAttrDiffs	VTNPAC_paraAttrDiffs;
    sdword			VTNPAC_regionOffset;
    sword			VTNPAC_regionWidth;
    word			VTNPAC_selectedTab;
} VisTextNotifyParaAttrChange;


typedef struct {
    VisTextType	    	    	VTNTC_type;
    word	    	    	VTNTC_typeToken;
    VisTextTypeDiffs	    	VTNTC_typeDiffs;
    VisTextType		    	VTNTC_index;
} VisTextNotifyTypeChange;


typedef struct {
    dword	    	    	VTNSC_selectStart;
    dword	    	    	VTNSC_selectEnd;
    dword	    	    	VTNSC_lineNumber;
    dword	    	    	VTNSC_lineStart;
    word	    	    	VTNSC_region;
    dword	    	    	VTNSC_regionStartLine;
    dword	    	    	VTNSC_regionStartOffset;
} VisTextNotifySelectionChange;


typedef struct {
    Boolean	    	    	VTNHC_hyperlinkable;
} VisTextNotifyHyperlinkabilityChange;


typedef struct {
    dword	    	    	VTNCC_charCount;
    dword	    	    	VTNCC_wordCount;
    dword	    	    	VTNCC_lineCount;
    dword	    	    	VTNCC_paraCount;
} VisTextNotifyCountChange;


typedef ByteEnum VisTextNameChangeType;
#define	VTNCT_NULL	0
#define	VTNCT_ADD	1
#define	VTNCT_REMOVE	2
#define	VTNCT_RENAME	3

typedef	struct {
    word			VTNNC_count;
    VisTextNameType		VTNNC_type;		/* type of name */
    VisTextNameChangeType	VTNNC_changeType; 	/* type of change */	
    word			VTNNC_index;		/* index of name */
    word			VTNNC_fileIndex;	/* file index, if
						   	   VTNT_CONTEXT */
} VisTextNotifyNameChange;


typedef struct {
    dword 			VTCPC_lineNumber;
    dword 			VTCPC_rowNumber;
} VisTextCursorPositionChange;


typedef WordFlags VisTextNotificationFlags;
#define VTNF_SELECT_STATE	0x8000
#define VTNF_CHAR_ATTR		0x4000
#define VTNF_PARA_ATTR		0x2000
#define VTNF_TYPE		0x1000
#define VTNF_SELECTION		0x0800
#define VTNF_COUNT		0x0400
#define VTNF_STYLE_SHEET	0x0200
#define VTNF_STYLE		0x0100
#define VTNF_SEARCH_ENABLE	0x0080
#define VTNF_SPELL_ENABLE	0x0040
#define VTNF_NAME		0x0020
#define VTNF_CURSOR_POSITION	0x0010
#define VTNF_HYPERLINKABILITY	0x0008

#define VIS_TEXT_STANDARD_NOTIFICATION_FLAGS  	(VTNF_SELECT_STATE | \
						 VTNF_CHAR_ATTR | \
						 VTNF_PARA_ATTR | \
	    	    	    	    	    	 VTNF_TYPE | \
						 VTNF_STYLE | \
						 VTNF_STYLE_SHEET | \
						 VTNF_CURSOR_POSITION | \
						 VTNF_HYPERLINKABILITY)

#define VIS_TEXT_GAINED_TARGET_NOTIFICATION_FLAGS 	\
	    	    	    	(VIS_TEXT_STANDARD_NOTIFICATION_FLAGS | \
				 VTNF_SEARCH_ENABLE | \
				 VTNF_SPELL_ENABLE | \
				 VTNF_NAME)

typedef WordFlags VisTextNotifySendFlags;
#define VTNSF_UPDATE_APP_TARGET_GCN_LISTS	0x8000
/* 
 * 	Set if pertinent Application Target GCN Lists should be 
 * 	updated with changes in status.
 */

#define VTNSF_NULL_STATUS			0x4000
/*
 *	Send notification of null status, for all notification types 
 *	(used only to notify GCN Lists of loss of eligibility to update, 
 *	i.e. lost target). The text output will always be sent only 
 *	meaningful info.
 */

#define VTNSF_STRUCTURE_INITIALIZED		0x2000
/*
 * 	Set if the rest of the VisTextGenerateNotifyParams structure is
 *      initialized.
 */

#define VTNSF_SEND_AFTER_GENERATION		0x1000
/*
 *	Set to send the notifications after generating them.
 */

#define VTNSF_SEND_ONLY				0x0800
/*
 *	 Set to send the notifications *only*.
 */

#define VTNSF_RELAYED_TO_LIKE_TEXT_OBJECTS	0x0400
/*
 *    	Set if the message has been registered with the object responsible
 *	for relaying the message to multiple text objects.
 */


typedef struct {
    VisTextNotificationFlags	VTGNP_notificationTypes;
    VisTextNotifySendFlags	VTGNP_sendFlags;
    MemHandle			VTGNP_notificationBlocks[16];
} VisTextGenerateNotifyParams;


/***************************************************************************/

@message void MSG_VIS_TEXT_GENERATE_NOTIFY(VisTextGenerateNotifyParams
					    	    	    *params = ss:bp);
/*
 * Generate notification structures as needed and send them out.  This allows
 * subclasses to send out their own notifications and allows subclasses to
 * combine the notification data from several text objects.
 *
 * 	PASS: 	params - VisTextGenerateNotifyParams
 *	RETURN: nothing
 */

/***************************************************************************/

@message void MSG_VIS_TEXT_CHAR_ATTR_VIRTUAL_TO_PHYSICAL(VisTextCharAttr attr);
/*
 *	Convert a virtual charAttr to a physical charAttr.  This message is
 *	only sent if the VTS_SUBCLASS_VIRT_PHYS_TRANSLATION bit is set in
 *	VTS_states.  This message is sent before the default processing.
 *
 *	Pass:	attr - VisTextCharAttr
 *	Return:	none
 */

/***************************************************************************/

@message void MSG_VIS_TEXT_PARA_ATTR_VIRTUAL_TO_PHYSICAL(VisTextParaAttr attr);
/*
 *	Convert a virtual paraAttr to a physical paraAttr.  This message is
 *	only sent if the VTS_SUBCLASS_VIRT_PHYS_TRANSLATION bit is set in
 *	VTS_states.  This message is sent before the default processing.
 *
 *	Pass:	attr - VisTextParaAttr
 *	Return:	none
 */


/*---------------------------------------------------------------------------
 *	 The following methods are passed to the OD VTI_output
 *--------------------------------------------------------------------------*/

@importMessage	MetaTextMessages, void MSG_META_TEXT_USER_MODIFIED(
							optr obj = cx:dx);
/*
 *	Sent when the user modifies the text
 *	This message is sent to the text object itself first.
 *
 * NOTE:  the text object sends this notification first to its destination, &
 * then to itself for internal update.  If you intercept this message at the
 * destination, be aware the text object's MODIFIED state has not yet been
 * updated, & so operations that modify that state, such as
 * MSG_VIS_TEXT_SET_NOT_USER_MODIFIED, or MSG_GEN_TEXT_SET_MODIFIED_STATE,
 * may not be synchronously called.  If you need to perform such operations,
 * such as the case where you need to clear the modified status in order to
 * receive notification on every keypress, use the MF_FORCE_QUEUE and
 * MF_PLACE_AT_FRONT flags when sending the message, so as to allow the text
 * object to first finish updating itself.
 * 
 *	Pass:	obj - object
 *	Return:	none
 */

/****************************************************************************/

typedef	struct {
    CharFlags 	MTFP_charFlags;
    ShiftState	MTFP_shiftState;
    ToggleState MTFP_toggleState;
    byte	MTFP_scanCode;    
} MetaTextFilteredParameters;


@importMessage	MetaTextMessages, void MSG_META_TEXT_CR_FILTERED(
					word character = cx, 
					MetaTextFilteredParameters params=dx:bp);				
/*
 *	Sent when a CR is filtered out of the text input.
 *	This message is sent to the text object itself first.
 *
 *	Pass: 	character -
 *		params - MetaTextFilteredParameters
 *	Return:	none
 */

/****************************************************************************/

@importMessage	MetaTextMessages, void MSG_META_TEXT_TAB_FILTERED(
					word character = cx, 
					MetaTextFilteredParameters params=dx:bp);
/*
 *	Sent when a tab is filtered out of the text input.
 *	This message is sent to the text object itself first.
 *
 *	Pass: 	character = character value
 *		params - MetaTextFilteredParameters
 *	Return:	none
 */


/****************************************************************************/

@importMessage	MetaTextMessages, void MSG_META_TEXT_LOST_FOCUS(
					optr obj = cx:dx);
/*
 *	Sent when the text object loses the focus.
 *
 *	Pass:	obj - object
 *	Return:	none
 */

/****************************************************************************/

@importMessage	MetaTextMessages, void MSG_META_TEXT_GAINED_FOCUS(
					optr obj = cx:dx);
/*
 *	Sent when the text object gains the focus.
 *
 *	Pass:	obj - object
 *	Return:	none
 */

/****************************************************************************/

@importMessage	MetaTextMessages, void MSG_META_TEXT_LOST_TARGET(
					optr obj = cx:dx);
/*
 *	Sent when the text object loses the target.
 *
 *	Pass:	obj - object
 *	Return:	none
 */

/****************************************************************************/

@importMessage	MetaTextMessages, void MSG_META_TEXT_GAINED_TARGET(
					optr obj = cx:dx);
/*
 *	Sent when the text object gains the target.
 *
 *	Pass:	obj - object
 *	Return:	none
 */


/****************************************************************************/

@importMessage	MetaTextMessages, void MSG_META_TEXT_EMPTY_STATUS_CHANGED(
    	    	    	    		optr object = cx:dx, 
					Boolean hasTextFlag = bp);
/*
 * 	Sent when text object becomes empty or not empty
 *	This message is sent to the text object itself first.
 *
 *	Pass:	optr - text object
 *		hasTextFlag - TRUE if text is becoming non-empty
 *	Return:	none
 */


/****************************************************************************/

@importMessage	MetaTextMessages, void MSG_META_TEXT_NOT_USER_MODIFIED(
					optr obj = cx:dx);
/*
 * 	Sent when text object is set not user modified.
 *	This message is sent to the text object itself first.
 *
 *	Pass:	optr - text object
 *	Return:	none
 */


/*---------------------------------------------------------------------------
 * The following methods are assumed to be handled by a sub-class 
 * (usually the specific ui).
 *--------------------------------------------------------------------------*/

@message void MSG_VIS_TEXT_EDIT_DRAW();	
/*
 *	This method is invoked after the text has been drawn so that the
 *	specific UI or sub-class can handle anything special that it needs to.
 *
 *	Pass:	none
 *	Return:	none
 */


/****************************************************************************/

typedef WordFlags VisTextShowSelectionFlags;
#define VTSSF_DRAGGING		0x8000

@message void MSG_VIS_TEXT_SHOW_SELECTION(@stack
					    VisTextShowSelectionFlags flags,
					    MakeRectVisibleFlags yFlags,
    	    	    	    	    	    MakeRectVisibleMargin yMargin,
				    	    MakeRectVisibleFlags xFlags,
    	    	    	    	    	    MakeRectVisibleMargin xMargin,
    	    	    	    	    	    sdword bottom, sdword right,
    	    	    	    	    	    sdword top, sdword left);
/*
 *	Sent from the text display to allow subclasses of text display to make
 *	the current selection visible.  For instance, in an openlook text
 *	display the text may be in a window, and the openlook implementation
 *	can use this method handler to scroll the selection onscreen.  The
 *	text display doesn't handle this method itself.
 *
 *	Pass:	params - MakeRectVisibleParams (see gViewC.goh)
 *		flags - VisTextShowSelectionFlags
 *	Return:	none
 */

/**************************************************************************/

@message void MSG_VIS_TEXT_HEIGHT_NOTIFY(word newHeight = dx);
/*
 *	A method sent out by the object, to itself (for use in subclassing),
 *	which announces any change it text height.  Will be used to drive
 *	changes in visual box height, conversion to scrolled version.
 *
 *	For large objects newHeight is meaningless.  For large objects 
 *	this message *must* be passed to the superclass.
 *
 *	Pass:	newHeight - New height of text at current with (-1 if infinite)
 *	Return:	none
 */

/****************************************************************************/

@message void MSG_VIS_TEXT_ENTER_OVERSTRIKE_MODE(Boolean 
						 calledFromTextObject = cx);
/*
 *	Enter overstrike mode. Leave insert mode.
 *
 *	Pass:	calledFromTextObject - TRUE if called from the text object.
 *	Return:	none
 */

/****************************************************************************/

@message void MSG_VIS_TEXT_ENTER_INSERT_MODE(Boolean 
					     calledFromTextObject = cx);
/*
 *	Enter insert mode. Leave overstrike mode.
 *
 *	Pass:	calledFromTextObject - TRUE if called from the text object.
 *	Return:	none
 */

/****************************************************************************/

typedef struct {
    WBFixed	VTMDP_height;
    WBFixed	VTMDP_width;
} VisTextMinimumDimensionsParameters;

@message void MSG_VIS_TEXT_GET_MINIMUM_DIMENSIONS(
			VisTextMinimumDimensionsParameters *params = dx:bp);
/*
 * Figure the minimum dimensions of a text object whose geometry is valid and
 * which has been calculated. This is to allow applications which create
 * text objects to figure their minimum size, given some initial configuration.
 *
 * The height and width returned will already be accounting for the lr and tb
 * margin values, so the caller should not have to.
 *
 *	PASS:	params	= pointer to VisTextMinimumDimensionsParameters
 *	RETURN:	*params filled in
 */


/*---------------------------------------------------------------------------
 *	Filtering messages
 *--------------------------------------------------------------------------*/
/*
 * The text object allows various mechanisms for filtering text.  The simplest
 * is the VisTextFilter variable stored in VTI_filters, which covers most
 * basic filtering situations.
 *
 * More complex filtering can be implemented using the filtering messages
 * below.  Because these messages can impose a non-trivial performance
 * penalty, they are only sent out if the ATTR_VIS_TEXT_EXTENDED_FILTER
 * attribute exists.
 *
 * ATTR_VIS_TEXT_EXTENDED_FILTER allows several levels of filtering as
 * controlled by the data stored with it (VisTextExtendedFilterTypes)
 */

typedef ByteEnum VisTextExtendedFilterType;

#define VTEFT_REPLACE_PARAMS		0
/*	This causes MSG_VIS_TEXT_FILTER_VIA_REPLACE_PARAMS to be send */

#define VTEFT_CHARACTER_LEVELER_LEVEL	1
/*	This causes MSG_VIS_TEXT_FILTER_VIA_CHARACTER to be sent */

#define VTEFT_BEFORE_AFTER		2
/*	This causes MSG_VIS_TEXT_FILTER_VIA_BEFORE_AFTER to be sent */


/*
 *	TextReference structure - the following definitions apply to
 *	VisTextReplace and VisTextGetRange.
 */

/*
 * This structure defines a reference to text. It can be:
 *	Pointer
 *	Memory segment and chunk
 *	Memory block and chunk
 *	Memory block handle
 *	VM file and VM block
 *	VM file and DBase item
 *	VM file and huge-array handle
 */
typedef enum /* word */ {
    TRT_POINTER=0,		/* TextReferencePointer */
    TRT_SEGMENT_CHUNK=2,	/* TextReferenceSegmentChunk */
    TRT_OPTR=4,			/* TextReferenceBlockChunk */
    TRT_BLOCK=6,		/* TextReferenceBlock */
    TRT_VM_BLOCK=8,		/* TextReferenceVMBlock */
    TRT_DB_ITEM=10,		/* TextReferenceDBItem */
    TRT_HUGE_ARRAY=12,		/* TextReferenceHugeArray */
} TextReferenceType;

typedef struct {
    char _far *TRP_pointer;
   /*
    * MSG_VIS_TEXT_GET_TEXT_RANGE Documentation:
    * ------------------------------------------
    * VTGRF_RESIZE has no meaning with this sort of reference.
    *
    * The TRP_pointer field must always be filled in.
    *
    * VTGRF_ALLOCATE and VTGRF_ALLOCATE_ALWAYS are not valid flags to pass
    * with this type of text reference.
    *
    * This is the safest way to copy text out of a text object. Since the
    * caller allocates the block it can also handle errors in the allocation.
    */
} TextReferencePointer;


typedef struct {
    ChunkHandle	TRSC_chunk;
    Segment	TRSC_segment;
   /*
    * MSG_VIS_TEXT_GET_TEXT_RANGE Documentation:
    * ------------------------------------------
    * The TRSC_segment field must be filled in.
    *
    * It is assumed that the lmem heap will be able to accomodate this
    * allocation. The caller is responsible for ensuring that this is the
    * case.
    *
    * If VTGRF_RESIZE is passed then either the passed chunk or the allocated
    * chunk will be resized to accomodate the text.
    */
} TextReferenceSegmentChunk;

typedef struct {
    optr	TRBC_ref;
   /*
    * MSG_VIS_TEXT_GET_TEXT_RANGE Documentation:
    * ------------------------------------------
    * The handle field of the TRBC_ref field must be filled in. 
    *
    * It is assumed that the lmem heap will be able to accomodate this
    * allocation. The caller is responsible for ensuring that this is the
    * case.
    *
    * If VTGRF_RESIZE is passed then either the passed chunk or the allocated
    * chunk will be resized to accomodate the text.
    */
} TextReferenceBlockChunk;

typedef struct {
    MemHandle TRB_handle;
   /*
    * MSG_VIS_TEXT_GET_TEXT_RANGE Documentation:
    * ------------------------------------------
    * No fields need to be filled in in order to allocate a destination buffer.
    * The heap allocation request will be made with the HAF_NO_ERR flag.
    *
    * If VTGRF_RESIZE is passed then either the passed block or the allocated
    * block will be resized to accomodate the text.
    */
} TextReferenceBlock;

typedef struct {
    FileHandle 		TRVMB_file;
    VMBlockHandle 	TRVMB_block;
   /*
    * MSG_VIS_TEXT_GET_TEXT_RANGE Documentation:
    * ------------------------------------------
    * The TRVMB_file must be filled in if you want a VM block to be
    * allocated.
    *
    * If VTGRF_RESIZE is passed then either the passed vm-block or the 
    * allocated vm-block will be resized to accomodate the text.
    */
} TextReferenceVMBlock;

typedef struct {
    FileHandle 		TRDBI_file;
    DBItem		TRDBI_item;
    DBGroup		TRDBI_group;
   /*
    * MSG_VIS_TEXT_GET_TEXT_RANGE Documentation:
    * ------------------------------------------
    * Both the TRDBI_file and the TRDBI_group fields must be filled in if
    * you want a VM block to be allocated. 
    *
    * If the TRDBI_group field is set to DB_UNGROUPED then the item will be
    * allocated ungrouped. TRDBI_group will hold the group in which the
    * item was allocated on return.
    *
    * If VTGRF_RESIZE is passed then either the passed db-item or the allocated
    * db-item will be resized to accomodate the text.
    */
} TextReferenceDBItem;

typedef struct {
    FileHandle		TRHA_file;
    word		TRHA_array;
   /*
    * MSG_VIS_TEXT_GET_TEXT_RANGE Documentation:
    * ------------------------------------------
    * The TRHA_file field must be set if you want a huge-array to be 
    * allocated.
    *
    * It does not make sense to pass VTGRF_RESIZE when the text reference is
    * a huge-array. The huge-array will always be forced to be the correct
    * size for the text.
    */
} TextReferenceHugeArray;

/*
 *	A union containing all the various references.
 */
typedef union {
    TextReferencePointer 	TRU_pointer;
    TextReferenceSegmentChunk 	TRU_segChunk;
    TextReferenceBlockChunk 	TRU_blockChunk;
    TextReferenceBlock	 	TRU_block;
    TextReferenceVMBlock	TRU_vmBlock;
    TextReferenceDBItem	 	TRU_dbItem;
    TextReferenceHugeArray	TRU_hugeArray;
} TextReferenceUnion;

/*
 *	The typed reference
 */
typedef struct {
    TextReferenceType	TR_type;
    TextReferenceUnion 	TR_ref;
} TextReference;


typedef WordFlags VisTextReplaceFlags;

#define VTRF_FILTER			0x8000
/*	Set to filter replacement			*/

#define VTRF_KEYBOARD_INPUT		0x4000
/*	Set if data is coming from the kbd input	*/

#define VTRF_USER_MODIFICATION		0x2000
/*	Set if replace is due to a user action		*/

#define VTRF_UNDO			0x1000
/*	Set if replace is due to an undo		*/

#define VTRF_DO_NOT_SEND_CONTEXT_UPDATE	0x0800
/*	Set if this is part of a  multi-part replace, and so the
 *	text object should not send a context update (used internally
 *	to the text object only)
 */

#define VTRF_TRUNCATE	    	    	0x0400
/*	Truncated the inserted text as necessary to not overflow */


typedef	struct {
   /*
    * The VisTextRange *must* come first in this structure
    */
    VisTextRange	VTRP_range;	      /* Range to replace */
    dword		VTRP_insCount;	      /* # of characters to insert */
    TextReference	VTRP_textReference;   /* Reference to text to insert*/
    VisTextReplaceFlags VTRP_flags;		
} VisTextReplaceParameters;


/*
 * It is possible to ask the text object to compute the length of the text
 * being inserted by passing the following constant in the high word of the
 * VTRP_insCount field.
 */
#define INSERT_COMPUTE_TEXT_LENGTH	0x01ff

/****************************************************************************/

@message Boolean MSG_VIS_TEXT_FILTER_VIA_REPLACE_PARAMS(
			VisTextReplaceParameters *params= ss:bp) = carry;
/*
 *	Filter text that is about to be entered in the text object.
 *	PASS: 	params - VisTextReplaceParams
 *	RETURN: carry set to reject replacement
 */

/****************************************************************************/

@message word MSG_VIS_TEXT_FILTER_VIA_CHARACTER(word charToFilter = cx) = cx;
/*
 *	Filter text that is about to be entered in the text object.
 *	The text object calls this message for each character in the
 *	replacement text.
 *
 *	PASS: 	charToFilter - character
 *	RETURN: cx - 0 to reject replacement, otherwise the replacement char
 */


/****************************************************************************/

@message Boolean MSG_VIS_TEXT_FILTER_VIA_BEFORE_AFTER(
		ChunkHandle before = cx,
		ChunkHandle after  = dx,
		word	    frame  = bp) = carry;
/*
 * Filter text that is about to be entered in the text object.  This message
 * passes two buffers containing the current text in the text object and
 * the (proposed) new text for the object.
 *
 * This message can only be used on small text objects.
 *
 * If the buffer is going to be rejected it is legal to call text object
 * messages from within this handler
 *
 * PASS:
 *	ChunkHandle before	chunk handle to "before" text
 *	ChunkHandle after	chunk handle to "after" text
 *	word        frame	offset to VisTextReplaceParameters
 * RETURN:
 *	TRUE	to reject buffer
 *	FALSE	to accept buffer
 *
 *  To access the VisTextReplaceParamters you need to create a fptr.
 *  An example would be like:
 *
 *   VisTextReplaceParams *p = 
 *		(VisTextReplaceParams *)(((dword)&p &0xffff0000L) + frame);
 */

/*---------------------------------------------------------------------------
 *		Style sheet messages
 *--------------------------------------------------------------------------*/

@message void MSG_VIS_TEXT_LOAD_STYLE_SHEET(StyleSheetParams *params= ss:bp);
/*
 *	Merge data from a given style sheet
 *
 *	PASS: 	params - StyleSheetParams
 *	RETURN: nothing
 */

/***************************************************************************/

@message void MSG_VIS_TEXT_LOAD_STYLE_SHEET_PARAMS();
/*
 *  Fill in the passed StyleSheetParams structure.
 *
 *  WARNING: THIS MESSAGE CANNOT BE SENT FROM GOC.
 *
 *  Use the function MsgVisTextLoadStyleSheetParams() to send this message.
 *  It *MUST* be called from the same thread as that which is running the
 *  VisText object to get valid results.
 */


extern void
    _pascal MsgVisTextLoadStyleSheetParams(StyleSheetParams *params,
			    	    	   optr object,
					   word preserveArrays);
/*
 *  @call object::MSG_VIS_TEXT_LOAD_STYLE_SHEET_PARAMS();
 * 
 *  Pass:  	params - pointer to StyleSheetParams
 * 	    	object - optr of VisText object to send message to
 *	    	preserveArrays - nonzero to preserve transfer arrays
 *  Return: 	*params filled with return values
 *	    	
 */

/*---------------------------------------------------------------------------
 *		Geometry methods
 *--------------------------------------------------------------------------*/

/***************************************************************************/

@message word MSG_VIS_TEXT_GET_MIN_WIDTH() = cx;
/*
 *	Returns minimum width that can be supported for attributes of the
 *	text object.
 *
 *	Pass:	none
 *	Return:	minimum width which can be supported
 *	Compat:	Can be used with all text objects.
 */

/***************************************************************************/

@message word MSG_VIS_TEXT_GET_AVERAGE_CHAR_WIDTH() = cx;
/*
 *	Returns the average character width for the first font/charAttr
 *	combination.
 *
 *	Pass:	none
 *	Return:	average character width
 *	Compat:	Can be used with all text objects.
 */

/***************************************************************************/

@message word MSG_VIS_TEXT_CALC_HEIGHT(word width = cx, 
				       Boolean cacheResult = dx) = dx;
/*
 *	Returns the height of the text give a width.
 *
 *	Pass:	width - width to calculate height for
 *		cacheResult - TRUE if result should be cached.  This should
 *			only be passed from the specific UI.  If you are not
 *			the specific UI you should pass FALSE always.
 *	Return:	height of the text at given width
 *	Compat:	Cannot be used with document objects.
 */

/***************************************************************************/

@message word MSG_VIS_TEXT_GET_LINE_HEIGHT()=ax;
/*
 *	Get the height of a line in a single-line text object only. This will
 *	not work for multi-line objects - use MSG_VIS_TEXT_GET_LINE_INFO
 *	instead.
 *
 *	Pass:	nothing
 *	Return:	line height
 *	Compat:	Cannot be used with document objects.
 */

/***************************************************************************/

@message void MSG_VIS_TEXT_RECALC_AND_DRAW();
/*
 *	Recalculate and redraw the text object.  Call this after you have
 *	made a change to the text objects instance data without its knowledge.
 *
 *	Pass:	nothing
 *	Return:	nothing
 *	Compat:	Can be used with all text objects.
 */


/***************************************************************************/

@message word MSG_VIS_TEXT_GET_ONE_LINE_WIDTH(word charsToCalc = cx) = cx;
/*
 *	Calculate the width of the text if it were all to appear on one
 *	lien, assuming one charAttr.
 *
 *	Pass:	charsToCalc - number of chars to use in the calculation,
 *			    - 0 to use entire string
 *	Return:	width of the text 
 *	Compat:	Cannot be used with document objects.  Only intended for
 *		one line text objects.
 */

/***************************************************************************/

@message word MSG_VIS_TEXT_GET_SIMPLE_MIN_WIDTH() = cx;
/*
 *	Returns minimum width that can be supported for current text, font &
 *	charAttr.  Just like the regular version but assumes that the caller is
 *	not worried about keeping a width large enough for the largest border
 *	possible.
 *
 *	Pass:	none
 *	Return:	minimum width which can be supported
 */


/*---------------------------------------------------------------------------
 *
 *	 Methods to handle search and replace and spell	
 *
 *---------------------------------------------------------------------------*/

/* 
 * The structure at the front of all of the search/replace blocks 
 */
typedef struct { 
    word    searchSize;		/* number of chars in search string, 
				   including null-terminator */
    word    replaceSize;	/* number of chars in replace string, 
				   including null-terminator */
    byte    params;
    optr    replyObject; 	/* optr of object to send 
				   string-not-found message to */
    Message replyMsg;		/* Message sent to SRS_replyObject 
				   if the string was not found */
} SearchReplaceStruct;

/*	
 *	In the search replace messages below, the passed block has this
 *	format:
 *		SearchReplaceStruct<>
 *		data	Null-Terminated Search String
 *		data	Null-Terminated Replace string
 */

/*-------------------------------------------------------------------------
 *	Methods sent from the search and replace and spell check boxes
 *-------------------------------------------------------------------------*/


/**************************************************************************/

@importMessage MetaSearchSpellMessages, void MSG_SEARCH(MemHandle searchInfo = dx);

/*
 *	Method sent out by the search box to tell an object to start a
 *	search.  The search string may contain wildcard characters.
 *
 *	Pass: searchInfo - MemHandle of block containing words 
 *			   (should be freed by method handlers)
 */

/****************************************************************************/

@importMessage MetaSearchSpellMessages, void MSG_REPLACE_CURRENT(MemHandle replaceInfo = dx);
/*
 *	Method sent out by spell check library to tell the application to 
 *	replace the current string with the passed text.
 *
 *	Pass: searchInfo - MemHandle of block containing words 
 *			   (should be freed by method handlers)
 */

/****************************************************************************/

@importMessage MetaSearchSpellMessages, void MSG_REPLACE_ALL_OCCURRENCES(
				MemHandle replaceInfo = dx, 
				Boolean replaceFromBeginning = cx);
/*
 *	Method sent out by spell check library to tell the text object to
 *	replace all occurrences of the current word (after the start of the
 *	current selection) with the passed text.
 *
 *	Pass: replaceInfo - MemHandle of block containing words 
 *		   	(should be freed by method handlers)
 *	      replaceFromBeginning - TRUE if it should do a replace all
 *			throughout the entire document (as opposed to after
 *			the current position)
 *
 *	Return: nothing
 */

/****************************************************************************/

@importMessage MetaSearchSpellMessages, void MSG_REPLACE_ALL_OCCURRENCES_IN_SELECTION(MemHandle replaceInfo = dx);
/*
 *	Method sent out by spell check library to tell the text object to
 *	replace all occurrences of the current word in the selected area
 *	with the passed text.
 *
 *	Pass: replaceInfo - MemHandle of block containing words 
 *		   	(should be freed by method handlers)
 *	Return: nothing
 */


/****************************************************************************/

@importMessage MetaSearchSpellMessages, void MSG_ABORT_ACTIVE_SPELL();
@importMessage MetaSearchSpellMessages, void MSG_ABORT_ACTIVE_SEARCH();
/*
 *	Sent out to the GAGCNLT_APP_TARGET_NOTIFY_SEARCH_SPELL_CHANGE gcnlist
 *	to let the search/spell boxes know that the user has aborted the
 *	current search/spell.
 *
 *	Pass: nothing
 *	Return: nothing
 */


/****************************************************************************/

typedef enum {
    GSSOT_FIRST_OBJECT,
/*	This is used by the spell check code to determine in which object to
 *	start spell checking when the user clicks on "Check Entire Document".
 *	It is also used by the search code to wrap a search to the beginning
 *	after it has reached the end.
 */

    GSSOT_LAST_OBJECT,
/*
 *	This is used by the search code to wrap a backwards search around to
 *	the end.
 */

    GSSOT_NEXT_OBJECT,
/*
 *	This is used by the search/spell/replace all code to get the next
 *	object in which to continue a search/spell/replace all. At the end
 *	of the chain of objects, it should return 0:0.
 */

    GSSOT_PREV_OBJECT
/* 
 *	This is used by the backwards search code. After reaching the
 *	start of the chain, it should return 0:0.
 */
} GetSearchSpellObjectOption;


typedef WordFlags GetSearchSpellObjectParam;
#define GSSOP_RELAYED_FLAG	0x8000
#define GSSOP_TYPE		0x000f


@importMessage MetaSearchSpellMessages, optr MSG_META_GET_OBJECT_FOR_SEARCH_SPELL(GetSearchSpellObjectOption option = bp, optr curObject = cx:dx) = cx:dx;
/*
 *	This is a message that the text object sends to itself when it needs
 *	to determine in what object it should start/continue a search and
 *	replace (for example, a search can wrap across multiple objects - when
 *	the end of one object is reached, the text object sends this to
 *	itself, and the app can intercept this message to cause the search to
 *	continue in the appropriate object). 
 *
 *	Pass: option - GetSearchSpellObjectParam
 *	      curObject - the object that the search/replace is currently in
 *	Return: optr of requested object
 */

/****************************************************************************/

typedef enum {
    CL_STARTING_AT_POSITION,
/*	Gets "numCharsToGet" chars starting at GCP_position */
    CL_ENDING_AT_POSITION,
/*	Gets "numCharsToGet" chars ending at the passed selection */
    CL_CENTERED_AROUND_POSITION,
/*	Gets "numCharsToGet" chars centered around GCP_position */
    CL_CENTERED_AROUND_SELECTION,
/*	Gets "numCharsToGet" chars centered around the selection */
    CL_CENTERED_AROUND_SELECTION_START,
/*	Gets "numCharsToGet" chars centered around the start of selection */
    CL_GET_SELECTED_WORD
/*	Gets selection, or surrounding word, or whatever */
} ContextLocation;


@importMessage MetaSearchSpellMessages, void MSG_META_GET_CONTEXT(@stack
					     	dword position,
						ContextLocation location,
						word numCharsToGet,
						optr replyObj);
/*
 *	Gets information from the destination text object so it can be
 *	displayed on the screen.
 *
 *	Pass: 	position - desired position, if ContextLocation is
 *			not one of the "SELECTION" enums.
 *		location - ContextLocation
 *		numCharsToGet - maximum # chars to return
 *		replyObj - optr of object to replay to via MSG_META_CONTEXT
 *	Return: nothing
 */


/****************************************************************************/

@importMessage MetaSearchSpellMessages, void MSG_META_GENERATE_CONTEXT_NOTIFICATION (@stack
                                               	dword position,
						ContextLocation location,
						word numCharsToGet,
						optr replyObj);
/*
 *
 *	Creates a context block and sends it to the GAGCNLT_NOTIFY_TEXT_CONTEXT
 *	list.
 *
 *	Pass: 	position - desired position, if ContextLocation is
 *			not one of the "SELECTION" enums.
 *		location - ContextLocation
 *		numCharsToGet - maximum # chars to return
 *		replyObj - ignored
 *	Return: nothing
 */

/****************************************************************************/

typedef struct {
    optr    	    CD_object;
    /*	What object the context is coming from */
	
    dword   	    CD_numChars;
    /*	# chars in the text object */

    VisTextRange    CD_range;
    /* The range of characters that this context represents */

    VisTextRange    CD_selection;
    /* What the current text seletion is */
} ContextData;

@importMessage MetaSearchSpellMessages, void MSG_META_CONTEXT(
						      MemHandle data = bp);
/*
 *
 *	Message used to return context to the SpellControl object.
 *	list.
 *
 *	Pass: data - MemHandle of block containing ContextData
 *	Return: nothing (block is freed by SpellControl)
 */

/****************************************************************************/

@importMessage MetaSearchSpellMessages, void MSG_META_DISPLAY_OBJECT_FOR_SEARCH_SPELL();
/*
 *	Force the object onto the screen.
 *
 *	Pass:	none
 *	Return:	none
 */



/*---------------------------------------------------------------------------
 * These are used by the specific ui and are special, consider carefully 
 * whether or not you really want to use these.
 *--------------------------------------------------------------------------*/

@message void MSG_VIS_TEXT_SCROLL_ONE_LINE(word position = cx);
/*
 *	Scroll a one line object so a given position is displayed.
 *
 *	Pass:	position - position to make visible.
 *		     This position is kind of screwed up. It is the offset
 *		     into the text, plus the offset to the left edge of the
 *		     object, plus the lrMargin.
 *	Return:	nothing
 *	Compat:	Can only be used on one line objects
 */

/***************************************************************************/

@message sword MSG_VIS_TEXT_GET_SCROLL_AMOUNT(sword offset = dx,
					      sword scrollAmount = cx) = dx;
/*
 *	Decide the amount to scroll vertically.
 *
 *	Pass:	offset - offset to scroll from.
 *		scrollAmount - suggested amount to scroll. 
 *				(Positive or negative).
 *	Return:	amount to scroll.
 *	Compat:	Cannot be use on one line objects
 */


/***************************************************************************/

@message void MSG_VIS_TEXT_SCROLL_PAGE_UP();
@message void MSG_VIS_TEXT_SCROLL_PAGE_DOWN();
/*
 *	Scrolls a text object up or down a page if it's scrollable 
 *	PASS: 	nothing
 *	RETURN: nothing
 */

/***************************************************************************/

@message void MSG_VIS_TEXT_SCREEN_UPDATE();
/*
 *	Make the screen update itself
 *	PASS: 	nothing
 *	RETURN: nothing
 */


/*------------------------------------------------------------------------
 * 	These are used internally and shouldn't be used by anyone...
 *------------------------------------------------------------------------*/

@message void MSG_VIS_TEXT_FLASH_CURSOR_ON();
@message void MSG_VIS_TEXT_FLASH_CURSOR_OFF();
/*
 *	Flash the cursor on or off.
 *	PASS: 	nothing
 *	RETURN: nothing
 */

/***************************************************************************/

typedef ByteFlags SpellCheckFromOffsetFlags;
#define SCFOF_CHECK_NUM_CHARS		0x01
/* 	if set, will spell check the passed # chars */

@message void MSG_VIS_TEXT_SPELL_CHECK_FROM_OFFSET(@stack
						   optr	 replyObject,
						   dword startOffset,
						   dword numCharsToCheck,
						   SpellCheckFromOffsetFlags flags,
						   MemHandle icBuff);
/*
 *	Starts a spell check in this object at the passed offset.
 *	It ignores the SpellCheckStartOption field, and instead uses
 *	startOffset.
 *
 *	Pass: 	replyObject - object reply messages (such as 
 *				SPELL_CHECK_COMPLETED) should be sent to
 *		startOffset - offset into text to begin spell checking
 *		numCharsToCheck - total # chars to spell check (if we want
 *				to skip the next word, the size of that word
 *				is deducted from this total.)
 *		flags - flags to say whether or not to skip the
 *				next word in the document
 *		icBuff - ICBuff to pass to spell check library
 *
 *	Returns: nothing
 */

/***************************************************************************/

typedef ByteFlags SearchFromOffsetFlags;
#define SFOF_STOP_AT_STARTING_POINT	0x01
/*	Set (internally) if this search has wrapped around  	*/

typedef struct {
    optr	SFORS_object;	/* object that match was found in (0:0 if 
				   not found) */
    dword	SFORS_offset;	/* offset into object where was was found
				   (ala VisTextRange) */
    dword	SFORS_len;	/* length of the match */
} SearchFromOffsetReturnStruct;


@message void MSG_VIS_TEXT_SEARCH_FROM_OFFSET(@stack
			      	SearchFromOffsetReturnStruct *retStruct,
				SearchFromOffsetFlags flags,
				dword currentOffset,
				dword startOffset,
				dword startObject,
				MemHandle searchReplaceStruct);
/*
 *
 *	Does a wrap-around search from the passed offset into the text object.
 *
 *	Pass: 	retStruct - pointer to SearchFromOffsetReturnStruct
 *		flags - SearchFromOffsetFlags
 *		currentOffset - offset between chars in text object to
 *			start search (can range from 0 to <text size>).
 *		startOffset - offset into object where current search began.
 *			This offset is *not* an offset to a char, but rather
 *			an offset between chars (i.e. the beginning of an
 *			object is 0, between the first second chars = 1, etc.)
 *			(can range from 0 to <text size>)
 *		startObject - object where current search began
 *		searchReplaceStruct - handle of block with data in this
 *			format:
 *				SearchReplaceStruct<>
 *				data Null-terminated Search string
 *				data Null-terminated Replace string
 *		
 *
 *	Return: *retStruct filled in
 */

/****************************************************************************/

typedef WordFlags   ReplaceAllFromOffsetFlags;
#define	RAFOF_CONTINUING_REPLACE    0x8000
/* Set if this message was generated to continue a replace all sent to
 * a different object
 */
 
#define	RAFOF_HAS_UNDO 	    	    0x4000
/* Set if this action will be undoable - mainly used for error-checking,
 * to ensure that all objects involved in a ReplaceAll are undoable.
 */

@message word MSG_VIS_TEXT_REPLACE_ALL_OCCURRENCES_FROM_OFFSET(@stack 
				ReplaceAllFromOffsetFlags flags,
			 	dword offset,
			 	MemHandle infoHan) = cx;
/*
 *	Method sent out by text object to do a "replace all" from the passed
 *	offset.
 *
 *	Pass: 	flags - ReplaceAllFromOffsetFlags, they are set internally
 *			by the text object - do not set them.
 *		offset - offset in this object to begin replace all
 *		infoHan - handle of block with data in this format:
 *				SearchReplaceStruct<>
 *				data Null-terminated Search string
 *				data Null-terminated Replace string
 *		
 *		     (This replace all is assumed to start at the passed offset
 *		       and continue until the end of the chain of text objects
 *		       is reached)
 *
 *	Returns: number of replaces that actually occurred
 */


/***************************************************************************/

@message word MSG_VIS_TEXT_REPLACE_ALL_OCCURRENCES_IN_RANGE
    	    	    	(@stack VisTextRange range,
			 MemHandle infoHan) = cx;
/*
 *	Method sent out by text object to do a "replace all" over the passed
 *	range.
 *
 *	Pass:   range - VisTextRange to do replace all in
 *		infoHan - handle of block with data in this format:
 *				SearchReplaceStruct<>
 *				data Null-terminated Search string
 *				data Null-terminated Replace string
 *	NOTE: The sender of this message is responsible for freeing 
 *		the passed SearchReplaceStruct.
 *
 *	Return: number of replaces that actually occurred
 */


@reserveMessages 1;


/*---------------------------------------------------------------------------
 *	Text filters
 *--------------------------------------------------------------------------*/

typedef ByteEnum VisTextFilterClass;
#define VTFC_NO_FILTER	 		0	/* no filter */
#define VTFC_ALPHA 			1	/* alpha chars only */
#define VTFC_NUMERIC	 		2	/* numeric only */
#define VTFC_SIGNED_NUMERIC	 	3	/* signed numeric */
#define VTFC_SIGNED_DECIMAL	 	4	/* numeric, with decimal */
#define VTFC_FLOAT_DECIMAL	 	5	/* numeric, decimal, e, E */
#define VTFC_ALPHA_NUMERIC 		6	/* alphanumeric */
#define VTFC_FILENAMES	 		7	/* legal GEOS filenames */
#define VTFC_DOS_FILENAMES 		8	/* legal DOS filenames */
#define VTFC_DOS_PATH 			9	/* legal DOS path */
#define VTFC_DATE 			10	/* legal date */
#define VTFC_TIME	 		11 	/* legal time */
#define VTFC_DASHED_ALPHA_NUMERIC 	12	/* alphanumeric plus '-' */
#define VTFC_NORMAL_ASCII 		13	/* normal ascii chars */
#define VTFC_DOS_VOLUME_NAMES 		14	/* legal DOS volume names */
#define VTFC_DOS_CHARACTER_SET 		15	/* DOS character set */
#define VTFC_ALLOW_COLUMN_BREAKS 	16	/* allow column breaks */

typedef ByteFlags VisTextFilters;
#define VTF_NO_SPACES		0x80	/* no spaces allowed */
/* NOTE: This only filters out C_SPACE in text libraries v3.1 and below.
 *	 Starting with 3.2, non-breaking-spaces, em-spaces, etc get filtered
 *	 as well.
 */
#define VTF_NO_TABS		0x40	/* no tabs */
#define VTF_UPCASE_CHARS    	0x20	/* make uppercase */
#define VTF_FILTER_CLASS	0x1f	/* VisTextFilterClass */

/*
 * Specific UI's define mappings between keys and functions using the following
 * data structures.
 */
typedef enum /* word */ {
    VTKF_FORWARD_LINE=0,
    VTKF_BACKWARD_LINE=6,
    VTKF_SELECT_ADJUST_FORWARD_LINE=12,
    VTKF_SELECT_ADJUST_BACKWARD_LINE=18,
    VTKF_FORWARD_CHAR=24,
    VTKF_BACKWARD_CHAR=30,
    VTKF_FORWARD_WORD=36,
    VTKF_BACKWARD_WORD=42,
    VTKF_FORWARD_PARAGRAPH=48,
    VTKF_BACKWARD_PARAGRAPH=54,
    VTKF_START_OF_LINE=60,
    VTKF_END_OF_LINE=66,
    VTKF_START_OF_TEXT=72,
    VTKF_END_OF_TEXT=78,
    VTKF_SELECT_WORD=84,

/****************************************************************************/
/*	 None of the following entries are supported:
 *		VTKF_SELECT_LINE
 *		VTKF_SELECT_PARAGRAPH
 *		VTKF_SELECT_OBJECT
 */	
    VTKF_SELECT_LINE=90,
    VTKF_SELECT_PARAGRAPH=96,
    VTKF_SELECT_OBJECT=102,
/****************************************************************************/

    VTKF_SELECT_ADJUST_FORWARD_CHAR=108,
    VTKF_SELECT_ADJUST_BACKWARD_CHAR=114,
    VTKF_SELECT_ADJUST_FORWARD_WORD=120,
    VTKF_SELECT_ADJUST_BACKWARD_WORD=126,
    VTKF_SELECT_ADJUST_FORWARD_PARAGRAPH=132,
    VTKF_SELECT_ADJUST_BACKWARD_PARAGRAPH=138,
    VTKF_SELECT_ADJUST_TO_START=144,
    VTKF_SELECT_ADJUST_TO_END=150,
    VTKF_SELECT_ADJUST_START_OF_LINE=156,
    VTKF_SELECT_ADJUST_END_OF_LINE=162,
    VTKF_DELETE_BACKWARD_CHAR=168,
    VTKF_DELETE_BACKWARD_WORD=174,
    VTKF_DELETE_BACKWARD_LINE=180,
    VTKF_DELETE_BACKWARD_PARAGRAPH=186,
    VTKF_DELETE_TO_START=192,
    VTKF_DELETE_CHAR=198,
    VTKF_DELETE_WORD=204,
    VTKF_DELETE_LINE=210,
    VTKF_DELETE_PARAGRAPH=216,
    VTKF_DELETE_TO_END=222,
    VTKF_DELETE_EVERYTHING=228,
    VTKF_DESELECT=234,
    VTKF_TOGGLE_OVERSTRIKE_MODE=240,
    VTKF_TOGGLE_SMART_QUOTES=246,
    VTKF_PAGE_UP=252,
    VTKF_PAGE_DOWN=258,
    VTKF_INSERT_TIME=264,
    VTKF_INSERT_DATE=270,
    VTKF_INSERT_NAME=276,
    VTKF_SELECT_ADJUST_BACKWARD_PAGE=282,
    VTKF_SELECT_ADJUST_FORWARD_PAGE=288
} VisTextKeyFunction;


/************************************************************************/

@message void MSG_VIS_TEXT_DO_KEY_FUNCTION(VisTextKeyFunction func = cx,
					   word data = bp);
/*
 *	Perform one of the VisTextKeyFunction on a text object without
 *	having had to hit the proper key. Useful when GenDataTriggers are what
 *	are performing the function and you don't want to/can't figure out the
 *	shortcut being used by the specific UI to implement the function.
 *
 *	Pass:	func - VisTextKeyFunction to perform
 *		data - data for function
 *	Return:	nothing
 *	Compat:	Can be used with all text objects.
 */


/****************************************************************************
 *	      Method for getting text from a text object
 ****************************************************************************/

@message Boolean MSG_VIS_TEXT_REPLACE_TEXT(VisTextReplaceParameters 
					*params = ss:bp) = carry;
/*
 *	Replace a range of text with some new text.
 *
 *	Pass:	params - pointer to a VisTextReplaceParameters structure
 *			See VisTextReplace() for more details (below)
 *			on how to create and pass this structure.
 *			Really, you ought to look...
 *	Return:	TRUE if error
 *	Compat:	Can be used with all text objects
 */


/************************************************************************/

/*
 * It is important to know that if you pass the "allocate" or "allocate always"
 * flags there are some fields that need to be filled in. These are documented
 * in the various TextReference* structure definitions.
 */
typedef ByteFlags VisTextGetTextRangeFlags;
#define VTGTRF_ALLOCATE	    	0x80	/* set: allocate destination */
					/* clear: use destination provided */
#define VTGTRF_ALLOCATE_ALWAYS	0x40	/* set: allocate even if no text */
					/* clear: use destination provided */
#define VTGTRF_RESIZE_DEST	0x20	/* set: if possible resize the
					 * destination so that it is just
					 * large enough to hold the text and
					 * no larger. 
					 */

@message dword MSG_VIS_TEXT_GET_TEXT_RANGE(@stack 
					   VisTextGetTextRangeFlags flags,
					   TextReference reference,
					   dword rangeEnd, 
					   dword rangeStart) = dx.ax;
/*
 * Get a range of text from the text object. The buffer must be able to hold
 * the number of bytes requested. The caller is responsible for making sure
 * that this is the case. It is legal to ask for more characters than actually
 * exist in the text object.
 *	The returned string is null terminated in every case except
 *	when the user requests the string in a huge-array.
 *
 *	PASS:	flags - VisTextGetTextRangeFlags specifiying how to 
 *	    	    	allocate space for the text
 *	    	reference - TextReference specifying what type of
 *	    	    	buffer to allocate
 *	    	rangeEnd - end of range to get
 *	    	rangeStart - start of range to get
 *
 *	RETURN:	Number of characters in the returned string, not
 *			  counting any NULL terminator.
 *		If a buffer was allocated, the TextReferenceUnion
 *	    	structure will hold the handle of the appropriate type.
 */

/**************************************************************************/

@message void MSG_VIS_TEXT_SELECT_RANGE(@stack dword end, dword start);
/*
 *	Sets the selected area of the text to the passed range.
 *
 *	PASS:	end - end of range
 *		start - start of range
 *	RETURN: nothing
 *	COMPAT:	Can be used with all text objects.
 */

/**************************************************************************/

@message void MSG_VIS_TEXT_SHOW_POSITION(dword position);
/*
 *	Display a position in the text on the screen.
 *
 *	Pass:	position = Offset into the text to display.
 *		This can be any of the special values for VTR_start.
 *	Compat:	Can be used with all text objects
 */

/**************************************************************************/

@message void MSG_VIS_TEXT_SET_FILTER(VisTextFilters filter = cl);
/*
 *	Sets the current text filter.
 *
 *	Note: This does not affect any text that already exists in the text
 *	      object. 
 *	
 *	Pass: 	filter - VisTextFilters
 *	Return: nothing
 *	Compat: Can be used with all text objects
 */


/**************************************************************************/

@message VisTextFilters MSG_VIS_TEXT_GET_FILTER() = cl;
/*
 *	Gets the current text filter.
 *	
 *	Pass: nothing
 *	Return:  VisTextFilters
 *	Compat: Can be used with all text objects
 */

/**************************************************************************/

@message void MSG_VIS_TEXT_SET_OUTPUT(optr newOutput = cx:dx);
/*
 *	Sets the VTI_output field.
 *
 *	Pass: newOutput - new optr
 *	Return: nothing
 *	Compat: Can be used with all text objects
 */

/**************************************************************************/

@message optr MSG_VIS_TEXT_GET_OUTPUT() = cx:dx;
/*
 *	Gets the VTI_output field.
 *
 *	Pass: nothing
 *	Return: optr of Output object
 *	Compat: Can be used with all text objects
 */


/**************************************************************************/

@message void MSG_VIS_TEXT_SET_LR_MARGIN(byte lrMargin = cl);
/*
 *	Sets the VTI_lrMargin field.
 *	NOTE: Should not be used with GenText objects, as the specific UI
 *	      likes to set this itself.
 *
 * 	Pass: lrMargin - new Left/Right margin
 *	Return: nothing
 *	Compat: Should not be used with Gen-based text objects;
 */

/**************************************************************************/

@message byte MSG_VIS_TEXT_GET_LR_MARGIN() = cl;
/*
 *	Gets the VTI_lrMargin field.
 *	NOTE: Should not be used with GenText objects, as the specific UI
 *	      likes to set this itself.
 *
 * 	Pass: nothing
 *	Return: current Left/Right margin
 *	Compat: Should not be used with Gen-based text objects;
 */

/**************************************************************************/

@message void MSG_VIS_TEXT_SET_TB_MARGIN(byte tbMargin = cl);
/*
 *	Sets the VTI_tbMargin field.
 *	NOTE: Should not be used with GenText objects, as the specific UI
 *	      likes to set this itself.
 *
 * 	Pass: tbMargin - new top/bottom margin
 *	Return: nothing
 *	Compat: Should not be used with Gen-based text objects;
 */

/**************************************************************************/

@message byte MSG_VIS_TEXT_GET_TB_MARGIN() = cl;
/*
 *	Gets the VTI_tbMargin field.
 *	NOTE: Should not be used with GenText objects, as the specific UI
 *	      likes to set this itself.
 *
 * 	Pass: nothing
 *	Return: current top/bottom margin
 *	Compat: Should not be used with Gen-based text objects;
 */

/**************************************************************************/

typedef WordFlags VisTextHWRFlags;
#define	VTHWRF_NO_CONTEXT   	    0x8000
/*	 This is sent when the ink is being quick-copied to the object, or
 *	 in other cases where the user did not draw the ink on top of the
 *	 object, and so the position of the object is not useful information
 *	 for the recognizer.
 */
#define	VTHWRF_USE_PASSED_CONTEXT   0x4000

@message void MSG_VIS_TEXT_REPLACE_WITH_HWR(@stack HWRContext context,
					    MemHandle ink,
					    VisTextHWRFlags flags,
					    VisTextRange range);
/*
 *	Does HWR on the current text object.
 *
 *	PASS:	context - HWRContext
 *		ink - MemHandle of InkHeader block.  
 *			Call MemDecRefCount on ink block when done.
 *		flags - VisTextHWRFlags
 *		range - VisTextRange
 *
 *	RETURN: nothing
 */

/**************************************************************************/

@message void MSG_VIS_TEXT_SET_HWR_CONTEXT();
/*
 *	This sets up the context for the current handwriting recognition
 *	attempt. This allows the specific UI to set up the context depending
 *	upon what is visible.
 *
 *	NOTE: If you want to set your own context, do not pass this message
 *	      to the superclass, as the VisText handler resets the context
 *	      to "none".
 *
 *	Pass: nothing
 *	Returns: nothing
 */

/**************************************************************************/

@message void MSG_VIS_TEXT_SET_HWR_FILTER();
/*
 *	Sets up the filter for the current handwriting recognition attempt.
 *	This allows an app writer to set up his own custom filters instead.
 *
 *	Pass: nothing
 *	Returns: nothing
 */

/**************************************************************************/

@message void MSG_VIS_TEXT_SET_SELECTED_TAB(word position = cx);
/*
 *	Set the position of the selected tab.
 *
 *	Pass: position - position to set (13.3), -1 for none
 *	Returns: nothing
 */

/**************************************************************************/

@message dword MSG_VIS_TEXT_GET_TEXT_SIZE() = dx:ax;
/*
 *	Get the length of the text.
 *
 *	Pass:  nothing
 *	Returns: text length (number of chars)
 */

/**************************************************************************/

@message void MSG_VIS_TEXT_INVALIDATE_RANGE(VisTextRange *vtr = dx:bp);
/*
 * Invalidate a range in a suspended object or else force recalculation of
 * the range in an active object.
 *
 *	Pass:  vtr - pointer to VisTextRange
 *	Returns: nothing
 */

/**************************************************************************/

@message void MSG_VIS_TEXT_ATTRIBUTE_CHANGE();
/*
 *	The text object sends this message to itself when it is changing
 *	its attributes.
 *	PASS: nothing
 *	RETURN: nothing
 */

/**************************************************************************/

typedef	struct {
    LineInfo 	*VTGLIP_buffer;		/* Pointer to buffer to use */
	/* This method handler will return a LineInfo structure followed by
	 * a number of FieldInfo structures, depending upon how many tabs
	 * are in the line.
	 */
    word 	VTGLIP_bsize;		/* Size of buffer */
    dword 	VTGLIP_line;		/* Line to get information for */
} VisTextGetLineInfoParameters;

typedef	struct {
    word    	VTGLIRV_unused;
    word    	VTGLIRV_byteCount;
} VisTextGetLineInfoReturnValues;

@message Boolean MSG_VIS_TEXT_GET_LINE_INFO(
			VisTextGetLineInfoReturnValues *retValue = dxcx,
	    		VisTextGetLineInfoParameters *vtglip = dx:bp) = carry;
/*
 * Get line and field information associated with a given line of the
 * text object.
 *	PASS:	dx:bp	= VisTextGetLineInfoParameters
 *	RETURN:	if TRUE - 
 *	    	    Buffer filled with line info
 *		    *retValue->VTGLIRV_byteCount - Number of bytes copied
 *		FALSE if there is no such line
 */


/****************************************************************************/

/*
 * This is what is stored with each name in the ElementArray.
 */

typedef struct {
    NameArrayElement	VTNAE_meta;	
    VisTextNameData	VTNAE_data;	
} VisTextNameArrayElement;

typedef	ByteFlags VisTextNameCommonFlags;
#define	VTNCF_COLOR_MONIKERS_FOR_UNSET_CONTEXTS	0x80
						/* SET: use green gstring
						 *  monikers for context
						 *  names not yet applied
						 * CLEAR: use a regular text
						 *  moniker for all names
						 */
#define	VTNCF_DISABLE_MONIKERS_FOR_SET_CONTEXTS	0x40
						/* SET: disable monikers
						 *  for context names
						 *  applied to text
						 */

typedef struct {
    VisTextNameData		VTNCP_data;	/* type (context or file)
						 *  & file */
    word    	    		VTNCP_index;    /* index of name   	     */
    optr    	    		VTNCP_object;   /* OD of object to update    */
    word    	    		VTNCP_message;	/* message to send to object */
    VisTextNameCommonFlags	VTNCP_flags;	/* flags for some of the
						     messages that use
						     this structure */
    byte			VTNCP_unused;
} VisTextNameCommonParams;

/****************************************************************************/
 /*XXX*/
@message void MSG_VIS_TEXT_DEFINE_NAME(VisTextNameCommonParams *data=ss:bp);
/*
 *	Define a new name (context or file)
 *
 *	PASS:	data - ptr to VisTextNameCommonParams
 *			VTNCP_data - type and associated file
 *			VTNCP_object - text object with name
 *	RETURN: nothing
 */

/****************************************************************************/

 /*XXX*/
@message void MSG_VIS_TEXT_DELETE_NAME(VisTextNameCommonParams *data=ss:bp); 
/*
 *	Delete a name (context or file)
 *
 *	PASS:	data - ptr to VisTextNameCommonParams
 *			VTNCP_data - type and associated file
 *			VTNCP_index - index of name in list
 *	RETURN: nothing
 */

/****************************************************************************/

 /*XXX*/
@message void MSG_VIS_TEXT_RENAME_NAME(VisTextNameCommonParams *data=ss:bp); 
/*
 *	Rename a name (context or file)
 *
 *	PASS:	data - ptr to VisTextNameCommonParams
 *			VTNCP_data - type and associated file
 *			VTNCP_index - index of name in list
 *			VTNCP_object - text object with new name
 *	RETURN: nothing
 */

/****************************************************************************/

 /*XXX*/
@message void MSG_VIS_TEXT_UPDATE_NAME_LIST(VisTextNameCommonParams 
					    *data = ss:bp); 
/*
 *	Update a list of names
 *
 *	PASS:	data - ptr to VisTextNameCommonParams
 *			VTNCP_data - type and associated file
 *			VTNCP_object - list object to update
 *	RETURN: nothing
 */


/****************************************************************************/

 /*XXX*/
@message void MSG_VIS_TEXT_GET_NAME_LIST_MONIKER(VisTextNameCommonParams 
						 *data = ss:bp);
/*
 *	Get a moniker for a name list
 *
 *	PASS:	data - ptr to VisTextNameCommonParams
 *			VTNCP_data - type and associated file
 *			VTNCP_index - index of name in list
 *			VTNCP_object - object to update
 *	    	    	VTNCP_message - message to send to object
 *	RETURN: nothing
 */

/****************************************************************************/

 
typedef struct {
    VisTextRange VTFHLP_range;
} VisTextFollowHyperLinkParams;

/*XXX*/
@message void MSG_VIS_TEXT_FOLLOW_HYPERLINK(
    	    	    	VisTextFollowHyperLinkParams *params = ss:bp);
/*
 *	 Follow the selected hyperlink
 *
 * NOTE: if the selection includes more than one hyperlink, the run at
 * the start of the selection is used
 *
 *	Pass: params - VisTextFollowHyperLinkParams
 */


/****************************************************************************/

@message dword MSG_VIS_TEXT_GET_LINE_FROM_OFFSET(dword offset=cx.dx) = dx.ax;
/*
 * Return the line number given an offset into the text
 *
 * 	PASS:	offset - offset into text
 * 	RETURN: line number
 */

/****************************************************************************/

typedef struct {
    dword	VTGLOAFP_line;		/* Pass this - line to get info for */
    dword	VTGLOAFP_offset;	/* returned offset to line start */
    LineFlags	VTGLOAFP_flags;		/* returned LineFlags */
} VisTextGetLineOffsetAndFlagsParameters;

/*XXX*/
@message Boolean MSG_VIS_TEXT_GET_LINE_OFFSET_AND_FLAGS(
	VisTextGetLineOffsetAndFlagsParameters *params=dx:bp) = carry; 
/*
 *	Get the offset where a line starts and the LineFlags associated with
 *	that line.
 *	PASS:	params	= ptr to VisTextGetLineOffsetAndFlagsParameters
 *
 *	RETURN:	Buffer filled in
 *		TRUE if the line does not exist
 */

/****************************************************************************/

@message dword MSG_VIS_TEXT_GET_TEXT_POSITION_FROM_COORD(
					PointDWFixed *coord = ss:bp) = dx:ax;
/*
 * Get the nearest character position to the specified coordinate.
 *
 *	PASS:	coord - PointDWFixed to check
 *	RETURN:	dword - the nearest character position
 *	    	coord updated with the nearest valid X and Y positions 
 *			replacing the position of the event
 */


/****************************************************************************/

@message void MSG_VIS_TEXT_GET_NAME_LIST_NAME_TYPE(VisTextNameCommonParams 
						   *data=ss:bp); /*XXX*/
/*
 *	 Get and update the type for a name in a name list
 *
 *	PASS:	data - ptr to VisTextNameCommonParams
 *		    VTNCP_data - type and associated file
 *		    VTNCP_index - index of name in list
 *		    VTNCP_object - list object to update
 *	RETURN:	none
 */

/****************************************************************************/

@message void MSG_VIS_TEXT_CROSS_SECTION_REPLACE_ABORTED();
/*
 *	Notification that a cross section change has been aborted (sent
 *	by the text object to itself)
 *
 *	PASS:	nothing
 *	RETURN:	nothing
 */

/****************************************************************************/

@message void MSG_VIS_TEXT_SET_SPELL_IN_PROGRESS();	/* private */
@message void MSG_VIS_TEXT_SET_SEARCH_IN_PROGRESS(); 	/* private */
/*
 *	Basically just sets the "Search/Spell in progress" flag.
 *
 *	Pass: nothing
 *	Returns: nothing
 */

/****************************************************************************/

@message void MSG_VIS_TEXT_LOAD_FROM_DB_ITEM_FORMAT(void *data = cx:dx);
/*
 * Loads a text object with data that had been previously saved to a DB item.
 * This allows things (like the help control) to compact the DB item produced
 * by MSG_VIS_TEXT_SAVE_TO_DB_ITEM, then uncompact/load it.
 *
 *	 Pass: data - ptr to data to load
 *	 Return: nothing
 */


/****************************************************************************/

@message void MSG_VIS_TEXT_GET_RUN_BOUNDS(@stack VisTextRange *retVal, 
					  word runOffset, dword position);
/*
 * Gets the bounds of the run that starts at or before the passed position
 *
 * 	Pass: retVal - ptr to VisTextRange to fill in with the run bounds
 *	      runOffset - run offset
 *	      position - position to check for run around
 *
 * 	Return: VisTextRange pointed to retVal - filled in
 */

/****************************************************************************/

@protominor TextNewForZoomer

#define OFFSET_FOR_TYPE_RUNS	0
#define OFFSET_FOR_GRAPHIC_RUNS	1

/*XXX*/
@message void MSG_VIS_TEXT_FREE_ALL_STORAGE(Boolean removeElementArrays = cx);
/*
 *	Superset of MSG_VIS_TEXT_FREE_STORAGE.  Also frees text 
 *	storage and line structures storage.
 *
 *	 NOTE:  This message was added 6/17/93
 *
 *	 Pass: removeElementArrays - TRUE to remove element arrays also
 *	 Return: none
 */

@protoreset

/****************************************************************************/

@message void MSG_VIS_TEXT_GENERATE_CURSOR_POSITION_NOTIFICATION();
/*
 * Generate cursor position notification.
 *
 * Pass:       none
 * Return:     none
 */

/****************************************************************************/

@message dword MSG_VIS_TEXT_GET_SELECTION_START() = dx:cx;
/*
 * Get the selection start.
 *
 * Pass:         nothing
 *
 * Return:       Selection start
 */

/****************************************************************************/

@message GStateHandle MSG_VIS_TEXT_GET_GSTATE() = cx;
/*
 * Get the gstate of the text object's window.
 *
 * Pass:         nothing
 *
 * Return:       gstate handle
 */

/****************************************************************************/

typedef struct {
    Rectangle FTTBI_bounds;
    Point FTTBI_textOffset;
    sword FTTBI_baselineOffset;
    Handle FTTBI_layerID;
} FepTempTextBoundsInfo;

@message Boolean MSG_VIS_TEXT_GET_FEP_BOUNDS(@stack
				FepTempTextBoundsInfo boundsInfo) = carry;
/*
 * Get the cursor position in document coordinates.  (PIZZA only)
 *
 * Pass:    retVal - pointer to VisTextGetFEPBounds
 *	    rect - pointer Rectangle to place bounds in 
 *	    
 * Return:  TRUE iff bounds invalid
 *	    *retVal, *rect filled in
 */


/***************************************************************************/

@protominor TextNewForHelpEditor
@message void MSG_VIS_TEXT_DELETE_ALL_HYPERLINKS(@stack
					 VisTextSetContextFlags flags,
					 word file,
			    	    	 word context,
					 dword rangeEnd, dword rangeStart);
/*
 * 	Given a virtual range of text, clear all the hyperlinks
 *	within that range.  This routine is used by the help editor.
 *	The flags argument is ignored.  File should be GIGS_NONE and
 *	context should be 0.  These arguments are passed so that the
 *	routine can be easily called from the help editor.
 */
					 
/***************************************************************************/

@message void MSG_VIS_TEXT_UNSET_ALL_CONTEXTS(@stack
					 VisTextSetContextFlags flags,
			    	    	 word context,
					 dword rangeEnd, dword rangeStart);
/*
 *	Given a virtual range of text, unset all the contexts
 * 	within that range.  This routine is used by the help editor.
 *	The flags argument is ignored.  The context argument should
 *	be GIGS_NONE.  These arguments are passed only to be consistent
 *	with the way the help editor sends messages to the text object.
 */


typedef struct {
    dword   VTCOP_offset;	/* pass: offset to convert  	    */
    	    	    	    	/* return: offset of returned position */
    sdword   VTCOP_xPos;	/* return: x position of offset	    */
    sdword   VTCOP_yPos;    	/* return: y position of offset	    */
} VisTextConvertOffsetParams;

/***************************************************************************/

@message void MSG_VIS_TEXT_CONVERT_OFFSET_TO_COORDINATE(
			VisTextConvertOffsetParams *params = dx:bp);
/*
 * Convert an offset into the text into its document coordinate. If the
 * passed offset is beyond the end of the text, it will be updated to the
 * last valid offset and the coordinate of that offset will be returned.
 *
 *	Pass:	VisTextConvertOffsetParams
 *	Return: VisTextConvertOffsetParams filled in
 */

@protoreset

/***************************************************************************/

@protominor TextNewForCondo

@message void MSG_VIS_TEXT_SET_HYPERLINK_TEXT_STYLE(@stack
				  VisTextExtendedStyles extBitsToClear, 
				  VisTextExtendedStyles extBitsToSet,
				  TextStyle styleBitsToClear, 
				  TextStyle styleBitsToSet,
       	    	    	    	  dword rangeEnd, dword rangeStart);
/*
 * 	Given a virtual range of text, set a style on all the hyperlinks
 *	within that range.  This routine is used by the hyperlink controller.
 */

/***************************************************************************/

typedef WordFlags VisTextUpdateGraphicFlags;	
#define VTUGF_RECALC	    	(0x8000)    
/* recalc and redraw after updating */

#define VTUGF_NEW_ELEMENT	(0x4000)    
/* If the graphic being updated has multiple references, create a new
 * element for this run instead of changing the original.  
 */

typedef enum {
/*
 * No errors occurred, and the element was updated
 */
    UGRV_MODIFIED_ELEMENT,
	/* The graphic element's data was replaced with the passed data 
	 */
    UGRV_CREATED_NEW_ELEMENT,
	/* A new graphic element was created using the passed data, and the
	 * old element was left untouched 
	 */
/*
 * Errors occurred, so the element was not updated
 */
    UGRV_INVALID_GRAPHIC_TYPE,
	/* The passed VTG_type field contains an invalid value
	 */
    UGRV_INVALID_GRAPHIC_FLAGS,
	/* The passed VTG_flags field contains an invalid value
	 */
    UGRV_INVALID_GSTRING_SIZE,
	/* The passed VTG_size field contains an invalid value.
	 * A gstring graphic cannot have zero size.
	 */
    UGRV_INVALID_GSTRING_VMCHAIN_HANDLE,
	/* The passed VTG_vmChain.high field contains an invalid value.
	 * This field should contain the VMBlock handle for a VMChain.
	 */
    UGRV_INVALID_GSTRING_VMCHAIN,
	/* The passed vmChain contains invalid data
	 */
    UGRV_INVALID_VARIABLE_TYPE,
	/* The passed variable graphic type is invalid
	 */
    UGRV_INVALID_VARIABLE_VMCHAIN_HANDLE,
	/* The passed VTG_vmChain field is non-zero, but for a
	 * variable graphic it should be zero.
	 */
    UGRV_INVALID_VARIABLE_MANUFACTURER_ID,
	/* The value in VTG_data.VTGD_variable.VTGV_manufacturerID is invalid
	 */
    UGRV_INVALID_VARIABLE_PRIVATE_DATA,
	/* The values in VTG_data.VTGD_variable.VTGV_privateData do not
	 * match the expected data types.
	 */
} UpdateGraphicReturnValue;

@message UpdateGraphicReturnValue MSG_VIS_TEXT_UPDATE_GRAPHIC_ELEMENT(
				   @stack VisTextUpdateGraphicFlags flags,
			    	   VisTextGraphic graphic,
			    	   dword position) = ax;
/*
 * Updates the VisTextGraphic element for the graphic run at the passed 
 * position with the new graphic data (does not copy VTG_meta).  
 *
 * Be careful when changing the VTG_vmChain field, or modifying the
 * old VMChain.  Multiple runs may point to the same graphic element,
 * and if it is modified or replaced, all of those runs will take
 * on the characteristics of the new graphic, unless the VTUGF_NEW_ELEMENT 
 * flag is passed.  This flag will cause a new element to be created
 * for this run if the original graphic is used by more than 1 run.
 *
 * If the VTUGF_NEW_ELEMENT flag is passed, the VMChain in the new 
 * graphic must be a new VMChain, which is in the text object's file.
 * The caller should never free the old VMChain when this flag is passed.
 * 
 * If the VTUGF_NEW_ELEMENT flag is not passed, the caller can modify
 * or replace the old VMChain.  If replacing it (if the passed VTG_vmChain
 * field differs fromt the original graphic element's VTG_vmChain field),
 * the new VMChain must be in the same file as the old one (the text
 * object's file).  The caller should free the old VMChain if the return
 * value is UGRV_MODIFIED_ELEMENT and a new VMChain was passed in VTG_data.
 * 
 *
 *	Pass:	flags - VisTextUpdateGraphicFlags
 *	    	position - graphic's position in text
 *	    	graphic -  new VisTextGraphic
 *	Return: UpdateGraphicReturnValue
 */		

@protoreset

/***************************************************************************/

@protominor TextNewForPizza

@importMessage MetaTextMessages, void MSG_VIS_TEXT_SET_TEXT_MISC_MODE(@stack byte miscModeFlags,
					      dword rangeEnd, dword rangeStart);

/*
 * Set the text misc mode bits (eg. char vs. word spacing)
 */

@protoreset

/***************************************************************************/

@protominor TextNewerForCondo

@message void MSG_VIS_TEXT_NAME_TOKENS_TO_LIST_INDICES(
				VisTextNotifyTypeChange *type = ss:bp);
/*
 * Convert a VisTextType's name tokens to their list indices.
 *
 * Pass: 	type->VTNTC_type - filled with name tokens
 * Return:	type->VTNTC_index - filled with corresponding indices
 */

@importMessage MetaTextMessages, void MSG_META_TEXT_SET_HYPERLINK(@stack
					 VisTextSetContextFlags flags,
					 word file,
			    	    	 word context,
					 dword rangeEnd, dword rangeStart);
/*
* Context:	Sent to set a hyperlink on a range of text associated with
* 		the recipient object.
* Source:	Hyperlink controller
* Destination:	Text object or any object embedded in the text.
* Interception: Default behavior is to set a hyperlink on the currently
*		selected range of text. In order for an object embedded
*		in the text to be hyperlinkable, it must intercept
*		this message, alter the rangeEnd and rangeStart parameters
*		to specify the position	of its associated C_GRAPHIC
*		character, and then pass the message on to the text object.
*/

@importMessage MetaTextMessages, void MSG_META_TEXT_FOLLOW_HYPERLINK(@stack
					 dword rangeEnd, dword rangeStart);
/*
* Context:	Sent to follow a hyperlink on a range of text associated with
* 		the recipient object.
* Source:	Hyperlink controller
* Destination:	Text object or any object embedded in the text.
* Interception: Default behavior is to follow a hyperlink on the currently
*		selected range of text. In order for a hyperlink on an
*		object embedded to be followable, the object must intercept
*		this message, alter the VTFHLP_range field of the
*		passed VisTextFollowHyperlinkParams to specify the position
*		of its associated C_GRAPHIC character, and then pass
*		the message on to the text object.
*/


@message word MSG_VIS_TEXT_FIND_NAME_BY_INDEX(@stack char *name,
					      word file, VisTextNameType type,
					      word index) = ax;
/*
 *	Return the data for a name index
 *
 *	Pass:	char *name - buffer of size MaxNameArrayElement
 *	    	file - index of file name, if type = VTNT_CONTEXT
 *	    	type - VisTextNameType for index to find name for
 *	    	index - index to find name for
 *	Return:	name buffer filled with VisTextNameArrayElement 
 *		token for index, or CA_NULL_ELEMENT if 
 *			name was not found
 *	Compat:	This method cannot be used on a text object that does not have
 *		multiple types
 */


@protoreset

@protominor TextNewFor2_1

@message void MSG_VIS_TEXT_REGION_FROM_POINT(); /*XXX*/
/*
 *  INTERNAL USE ONLY
 *
 *  Get the region associated with a given point.
 *
 *  WARNING: THIS MESSAGE CANNOT BE SENT FROM GOC.
 */

@protoreset

@protominor TextEvenNewerForCondo

@message void	MSG_VIS_TEXT_GET_NAME_LIST_MONIKER_FRAME(
				VisTextNameCommonParams *data=ss:bp); /*XXX*/
/*
 * Gets a moniker for a name in the name list and uses a specified
 * message to pass it in a ReplaceItemMonikerFrame structure to a
 * specified object. Gets a text moniker for any name unless passed
 * the VTNCF_COLOR_UNSET_CONTEXT_NAMES flag, in which case
 * gets a text moniker for everything except context names not yet
 * assigned to pages - for those, gets a light green gstring moniker.
 *
 * Context:	Sent to get a name list moniker when the moniker should be
 * 		passed with a particular message to a particular object. If
 * 		one would like to get a regular text moniker and pass it
 * 		with MSG_GEN_DYNAMIC_LIST_REPLACE_ITEM_TEXT to a
 * 		dynamic list, one should use the simpler
 *		MSG_VIS_TEXT_GET_NAME_LIST_MONIKER instead of
 *		MSG_VIS_TEXT_GET_NAME_LIST_MONIKER_FRAME.
 * Source:	Hyperlink controller
 * Destination:	Text object
 * Interception: Not generally intercepted
 * Pass:	data	= ptr to VisTextNameCommonParams structure
 *			VTNCP_data	- type (context/file) &
 *					   associated file
 *			VTNCP_index	- index of name
 *			VTNCP_object	- object to update
 *			VTNCP_message	- message to send to object
 *			VTNCP_flags	- color unset context names?
 *		Passed to message:
 *			(@stack word item, ReplaceItemMonikerFlags flags, 
 *			word height, word width, word length,
 *			VisMonikerDataType dataType,
 *			VisMonikerSourceType sourceType,
 *			dword source);
 *		with
 *			source 		= pointer to data source
 *			item		= index of item in list
 *		and either
 *			sourceType	= VMST_FPTR
 *			dataType 	= VMDT_TEXT
 *			length		= 0
 *			itemFlags	= 0
 *		  *or*
 *			sourceType	= VMST_OPTR
 *			dataType 	= VMDT_GSTRING
 *			length		= 0
 *			width		= gstring width
 *			height		= gstring height
 *			itemFlags	= 0
 */

@protoreset

/****************************************************************************/

@protominor TextNew2ForPizza

@message void MSG_VIS_TEXT_GET_SINGLE_CHAR_ATTR(); /* Can't be prototyped */

@protoreset

@protominor	TextNew4ForCondo

@message void MSG_VIS_TEXT_SET_CONTEXT_GIVEN_NAME_TEXT(@stack
					optr object,
					VisTextSetContextFlags flags,
			    	    	word context,
					dword rangeEnd, dword rangeStart);
/*
 * Queries the passed object for a name, which should be a context name
 * in the current file, and uses that name to set a context on the
 * passed range of text. If the name is new, adds it to the name
 * array before setting the context. If the name is not that of a
 * context in the current file, displays an error message.
 *
 * Context:	Sent in place of MSG_VIS_TEXT_SET_CONTEXT when the
 * 		index or token for the context is not available,
 * 		possibly because the name is not yet defined.
 * Source:	Hyperlink controller
 * Destination:	Text object
 * Interception: Application may intercept to query the passed object
 * 		for the name string if necessary. For other purposes,
 * 		it's probably better to intercept MSG_VIS_TEXT_SET_CONTEXT.
 *		    
 * Return:	nothing
 */

@message void MSG_VIS_TEXT_REDIRECT_HYPERLINKS(@stack
					VisTextSetContextFlags flags,
			    	    	word context,
					dword rangeEnd, dword rangeStart);
/*
 * Redirects hyperlinks pointing to a particular file and context pair
 * to point to another.
 *
 * Context:	Sent to make one file/context pair take over another's duties.
 * Source:	Hyperlink controller or text object
 * Destination:	Text object
 * Interception: Application may intercept.
 */

@protoreset

@protominor TemplateWizard

@message MemHandle MSG_VIS_TEXT_RETURN_SELECTION_BLOCK(optr obj = cx:dx,
						       word message = bp) = cx;

@protoreset

@protominor TextNewForGPC

@message Boolean MSG_VIS_TEXT_PREP_FOR_QUICK_TRANSFER(@stack
                                               VMBlockHandle block,
                                               VMFileHandle file,
                                               word pasteFrame,
                                               dword end, dword start) = carry;
/*
 * Does common prep work for subclasses of VisText that want to specially
 * handle MSG_VIS_TEXT_REPLACE_WITH_TEXT_TRANSFER_FORMAT do do interesting
 * things when pasting
 *
 * Context:     Send to self in MSG_VIS_TEXT_REPLACE_WITH_TEXT_TRANSFER_FORMAT
 * Source:      Self
 * Destination: Self
 * Interception: Not normally intercepted
 * Return:      carry - set if paste will fail
 */

@protoreset

/****************************************************************************/

/*--------------------------------------------------------------------------
 * 	EXTERNAL state bits in the instance data
 *--------------------------------------------------------------------------*/
/*
 * Some of these state bits can be changed at any time, others must be set
 * set initially and cannot be changed.
 */

/* 
 *	VisTextFeatures reflect whether various features are 
 *	enabled in the text object.
 */
typedef WordFlags VisTextFeatures;
#define VTF_NO_WORD_WRAPPING		0x8000
	/* Set: no word-wrapping is desired. */
#define VTF_AUTO_HYPHENATE		0x4000
	/* Set: if we want to hyphenate. */
#define VTF_ALLOW_SMART_QUOTES		0x2000
	/* Set: allows smart quotes if they are enabled */
#define VTF_ALLOW_UNDO			0x1000
	/* Set: allows undo in this object */
#define VTF_SHOW_HIDDEN_TEXT		0x0800
	/* Set: show text marked as hidden. *** Not implemented *** */
#define VTF_OUTLINE_MODE		0x0400
	/* Set: show text in outline mode. *** Not implemented *** */
#define VTF_DONT_SHOW_SOFT_PAGE_BREAKS	0x0200
	/* Set: don't display soft (non C_PAGE_BREAK)
	   page breaks in VisLargeTextDisplayModes VLTDM_GALLEY and
	   above. */
#define VTF_DONT_SHOW_GRAPHICS		0x0100
	/* Set: draw graphics as gray rectangles.  *** Not implemented. *** */
#define VTF_TRANSPARENT			0x0080
	/* Set: don't use wash color on DRAW */
#define VTF_USE_50_PCT_TEXT_MASK    	0x0040
	/* Set: force 50% draw mask for drawing, regardless of char 
	 *  	attr runs.  Used by specific GenText objects.  */
#define VTF_RIGHT_TO_LEFT		0x0020
	/* Organize the characters from right to left on a per line basis */

/*
 * VisTextStates reflect various states of the text object
 */
typedef ByteFlags VisTextStates;
#define VTS_EDITABLE			0x80	/* set: text is editable */
#define VTS_SELECTABLE			0x40	/* set: text is selectable */
#define VTS_TARGETABLE			0x20	/* set: object is targetable */
#define VTS_ONE_LINE			0x10	/* set: object is limited to
						   one line */
#define VTS_SUBCLASS_VIRT_PHYS_TRANSLATION 0x08	/* set: send virtual to 
						 * physical charAttr/paraAttr
						 * translation messages to
						 * self (for subclass) */
#define VTS_OVERSTRIKE_MODE		0x04	/* set: overstrike mode */
#define VTS_USER_MODIFIED		0x02	/* set: text has changed */

/*--------------------------------------------------------------------------
 * 	EXTERNAL state bits in the instance data
 *--------------------------------------------------------------------------*/
/*
 * The following bits reflect the internal state of the text object.  These
 * bits should not be altered.
 */

/*
 * VisTextIntSelFlags reflect the selection state of the text object.
 */
typedef ByteEnum SelectionType;
#define ST_DOING_CHAR_SELECTION 0	
#define ST_DOING_WORD_SELECTION 1
#define ST_DOING_LINE_SELECTION 2
#define ST_DOING_PARA_SELECTION 3

typedef ByteFlags VisTextIntSelFlags;
#define VTISF_IS_TARGET			0x80	/* set if object is target */
#define VTISF_IS_FOCUS			0x40	/* set if object is focus */
#define VTISF_CURSOR_ON			0x20	/* set if cursor is drawn */
#define VTISF_CURSOR_ENABLED		0x10	/* set if cursor is enabled */
#define VTISF_DOING_SELECTION		0x08 	/* set if doing selection */
#define VTISF_DOING_DRAG_SELECTION	0x04	/* set if we have positioned
						 * the cursor (also doubles as
						 * flag that indicates we are
						 * doing quick-transfer
						 * feedback)		*/
#define VTISF_SELECTION_TYPE		0x03 	/* SelectionType */

/*
 *	VisTextIntFlags reflects the general internal state of the object
 */
typedef ByteEnum AdjustType;
#define AT_NORMAL 	0
#define AT_NO_ADJUST 	1
#define AT_PASTE 	2
#define AT_QUICK 	3
#define AT_ENTIRE_RANGE 4

typedef ByteEnum ActiveSearchSpellType;
#define ASST_NOTHING_ACTIVE 0
#define ASST_SPELL_ACTIVE 1
#define ASST_SEARCH_ACTIVE 2

#define	ASST_OFFSET 3	/* offset in VisTextIntFlags */

typedef ByteFlags VisTextIntFlags;
#define VTIF_HAS_LINES			0x80 
	/* set if has valid line structures */
#define VTIF_SUSPENDED			0x40 
	/* set if calculation suspended */
#define VTIF_UPDATE_PENDING		0x20
	/* set if update is about to be delivered */
#define VTIF_ACTIVE_SEARCH_SPELL	0x18 
	/* ActiveSearchSpellType - set if active search/spell session is
	 * in progress			
	 */
#define VTIF_HILITED			0x04
	/* set if we have drawn the hilite */
#define VTIF_ADJUST_TYPE		0x03 
	/* AdjustType - how to adjust the seletion */

/*
 * GSRefCountAndFlags reflects the state of the cached gstate
 */
typedef ByteFlags GSRefCountAndFlags;
#define GSRCAF_USE_DOC_CLIP_REGION	0x80
	/* If set, then use GrSetDocClipRect */
#define GSRCAF_REF_COUNT		0x7f


/*----------------------------------------------------------------------------
 *	Variable Instance data
 *---------------------------------------------------------------------------*/

    @vardata word ATTR_VIS_TEXT_TYPE_RUNS;
    @vardata word ATTR_VIS_TEXT_GRAPHIC_RUNS;
    @vardata word ATTR_VIS_TEXT_STYLE_ARRAY;
    @vardata word ATTR_VIS_TEXT_NAME_ARRAY;

typedef struct {
    word    	    VTSD_count;
    VisTextRange    VTSD_recalcRange;		/* range to recalculate */
    VisTextRange    VTSD_selectRange;		/* range to select */
    dword	    VTSD_showSelectionPos;	/* position to show */
    WordFlags	    VTSD_notifications;
    byte	    VTSD_needsRecalc;
} VisTextSuspendData;

    @vardata VisTextSuspendData ATTR_VIS_TEXT_SUSPEND_DATA;

    @vardata void ATTR_VIS_TEXT_NOTIFY_CONTENT;

    @vardata word ATTR_VIS_TEXT_SELECTED_TAB;

    @vardata void ATTR_VIS_TEXT_DO_NOT_INTERACT_WITH_SEARCH_CONTROL;
/*
 *	If set, these attrs keep the text object from sending 
 *	GWNT_SEARCH_SPELL_ENABLE_CHANGE.
 */

    @vardata VisTextExtendedFilterType ATTR_VIS_TEXT_EXTENDED_FILTER;

    @vardata word ATTR_VIS_TEXT_CHAR_ATTR_INSERTION_TOKEN;
    @vardata word ATTR_VIS_TEXT_TYPE_INSERTION_TOKEN;

/*
 *	TEMPORARY VARDATA
 */
typedef struct {
    dword	VTCRI_lastCharAttrRun;
    dword	VTCRI_lastParaAttrRun;
    dword	VTCRI_lastTypeRun;
    dword	VTCRI_lastGraphicRun;
} VisTextCachedRunInfo;

    @vardata VisTextCachedRunInfo TEMP_VIS_TEXT_CACHED_RUN_INFO;

    @vardata void TEMP_VIS_TEXT_FORCE_SEND_IS_LAST_REGION;

typedef struct {
    VMChain   	    VTCUI_vmChain;
    VMFileHandle    VTCUI_file;
} VisTextCachedUndoInfo;

    @vardata VisTextCachedUndoInfo TEMP_VIS_TEXT_CACHED_UNDO_INFO;

typedef struct {
    wchar    VTCFD_startOfRange;
    wchar    VTCFD_endOfRange;
} VisTextCustomFilterData;

    @vardata ChunkHandle ATTR_VIS_TEXT_CUSTOM_FILTER;
/*	
 *	This should contain the handle of a chunk containing an array of
 *	VisTextCustomFilterData structures. Each structure corresponds to a
 *	range of characters that the app wants to filter out.
 */

    @vardata void ATTR_VIS_TEXT_UPDATE_VIA_PROCESS;
/*
 *	Indicates that status updates must be sent via the process object
 *	because there are targetable text objects in multiple threads
 */

    @vardata void ATTR_VIS_TEXT_DOES_NOT_ACCEPT_INK;
/*
 *	When present, the VisText object will not accept ink.
 */

    @vardata WBFixed ATTR_VIS_TEXT_MINIMUM_SINGLE_LINE_HEIGHT;
/*
 *	For a one-line object, lets the object override the default line
 *	height, so graphics, etc can be put inside it.
 */

    @vardata void TEMP_VIS_TEXT_SYS_TARGET;

@protominor TextNewForZoomer

    @vardata void ATTR_VIS_TEXT_SEND_CONTEXT_NOTIFICATIONS_EVEN_IF_NOT_FOCUSED;
/*
 *	This sends out context notifications even if the object is
 *	not focused. Apps should beware when using this, to make sure
 * 	the object that this is on does *not* get modified while another
 *	text object has the focus.
 */

    @vardata void ATTR_VIS_TEXT_DO_NOT_NOTIFY_CONTENT;

@protoreset

    @vardata word ATTR_VIS_TEXT_ADD_SPACE_ON_TOP_TO_FIRST_LINE_OF_REGION;
/*
 *	This attribute causes vis-text (and gen-text) objects to add
 *	additional spacing above the first line of the object.
 *
 *	This helps fix up accent glitch problems in Vis and Gen text
 *	objects that aren't easily satisfied by the preceding ATTR_.
 *
 *	This attribute does not take effect if the paragraph on the
 *	first line of the region contains a top-line border.
 *
 *	************************************************************
 *	**** This ATTR may not be implemented on all systems.
 *	**** It was added specifically to handle European characters
 *	**** with accents. If I were to up the minor protocol for
 *	**** users of this ATTR, then applications which used it might
 *	**** not run on older systems, such as Zoomer-US. Therefore
 *	**** the protocol does not change. This means that applications
 *	**** which include this ATTR should continue to work on older
 *	**** system software, though this attribute might not have any
 *	**** effect
 *	************************************************************
 */

    @vardata word ATTR_VIS_TEXT_ADD_SPACE_TO_ALL_LINES;
/*
 *	This attribute causes vis-text (and gen-text) objects to add
 *	additional spacing above all lines of the object.
 *
 *	This attribute will take effect on *all* lines, including the
 *	first line, and including any lines with borders on them.
 *
 *	This means that if you have a border around a paragraph, and
 *	the object also has this hint, then the space between the
 *	top/bottom border and the text will include any addition space
 *	provided as part of this hint.
 *
 *	This attribute is intended to be added to objects where accent
 *	characters are getting messed up by redraws on the previous
 *	line, typically due to editing on that line. This may produce
 *	funny line spacing, so use it with care.
 *
 *	************************************************************
 *	**** This ATTR may not be implemented on all systems.
 *	**** It was added specifically to handle European characters
 *	**** with accents. If I were to up the minor protocol for
 *	**** users of this ATTR, then applications which used it might
 *	**** not run on older systems, such as Zoomer-US. Therefore
 *	**** the protocol does not change. This means that applications
 *	**** which include this ATTR should continue to work on older
 *	**** system software, though this attribute might not have any
 *	**** effect
 *	************************************************************
 */


    @vardata word ATTR_VIS_TEXT_NOTIFY_CURSOR_POSITION;
/*
 *	This causes cursor position notifications to be sent out.
 *	To improve proformance while quickly typing in text or quickly
 *	moving the cursor through text, a threshold time is specified.
 *	A new notification won't be sent out until the threshold time
 *	has past since the last notification was sent.  The time is
 *	specified in 1/60ths of a second.  A value of zero may be used
 *	to send notification all the time.
 */

    @vardata dword TEMP_VIS_TEXT_NOTIFY_CURSOR_POSITION_TIME;

typedef struct {
    word    TVTNCPID_handle;
    word    TVTNCPID_id;
} TVTNCPIData;

    @vardata TVTNCPIData TEMP_VIS_TEXT_NOTIFY_CURSOR_POSITION_INFO;

    @vardata void TEMP_VIS_TEXT_FREEING_OBJECT;
/*
 * This is added by the text object when it receives MSG_META_OBJ_FREE, to
 * prevent it from sending out notifications while exiting.
 */

    @vardata void TEMP_VIS_TEXT_UNDO_FOR_SUSPEND;
/*
 * This is added by the text object when it receives MSG_META_SUSPEND, so it
 * knows to encapsulate any subsequent undo actions in a single chain.
 */



@protominor	TextNewForQuickFax

    @vardata void ATTR_VIS_TEXT_DISABLE_OPTIMIZED_REDRAW; 
/*
 * This attribute causes vis-text objects to NOT use optimized
 * redraw (ie bit-blt) when inserting text. This is useful when an
 * Ink object overlaps a VisText object (we don't want the ink to
 * be blitted down with the text)
 */

@protoreset

@protominor TextNewFor2_1

@vardata void ATTR_VIS_TEXT_DONT_SHOW_POSITION_ON_GAINED_TARGET_EXCL;
/*
 * This attribute causes the vis-text objects to NOT call
 * MSG_VIS_TEXT_SHOW_POSITION whenever MSG_META_GAINED_TARGET_EXCL is
 * received.  This way if the cursor is outside the visible text window
 * when the target is gained the text will not automatically scroll to
 * the cursor position 
 */

@vardata void ATTR_VIS_TEXT_SHOW_POSITION_ON_GAINED_TARGET_EXCL;
/*
 * This attribute causes the vis-text object to call
 * MSG_VIS_TEXT_SHOW_POSITION whenever MSG_META_GAINED_TARGET_EXCL is
 * received.   This way if the cursor is outside the visible text window
 * when the target is gained the text will automatically scroll to
 * the cursor position 
 */

@vardata void ATTR_VIS_TEXT_DONT_BEEP_ON_INSERTION_ERROR;
/*
 * This attribute causes the vis-text object to not call the sound
 * routine with SST_ERROR, even though there was an error inserting
 * the character.
 */

@protoreset

@protominor TextNew2ForPizza

@vardata void ATTR_VIS_TEXT_NO_FEP;
/*
 * This attribute causes the text object to not interact with the FEP,
 * if any.  This is useful for numeric-only text fields, such as in
 * a calculator.   Only implemented in DBCS/Pizza.
 * NOTE: care should be taken in adding / removing this dynamically,
 * as chaos will result if the text object already has the focus,
 * and already interacted with / didn't interact with the FEP.
 */

@protoreset

@protominor	TextNewForJedi

@vardata void ATTR_VIS_TEXT_NOTIFY_EVEN_IF_NOT_TARGETED;
/*
 *  This attribute causes the vis-text object to send out notificiations
 *  to controllers even when it doesn't have the target.
 */

@protoreset

@protominor	TextNewForResponder

@vardata void ATTR_VIS_TEXT_XOR_SELECTION;
/*
 *  This attribute sets the text object in a state where the selected text will
 *  be xor'ed with some product-specific value, rather than inverted.  This
 *  is currently only handled in Responder, for achieving the black-text-on-
 *  light-grey-background effect similar to selected gadgetry in the UI.
 */


@protoreset

@protominor	TextNewForLeia

/* 
 * This etype is used by the specific UI to change text cursors for
 * Graffiti HWR modes.
 */
typedef enum /* word */ {
    VTCT_NORMAL_CURSOR=0,
    VTCT_CAPLOCK_CURSOR=2,
    VTCT_NUMLOCK_CURSOR=4,
    VTCT_EQNLOCK_CURSOR=6,
} VisTextCursorType;

@vardata	VisTextCursorType	TEMP_VIS_TEXT_CURSOR_TYPE;
/* 
 * This vardata is for internal use only.  If you put it on your
 * VisText object you'll probably have problems.  Don't use it.
 */

@protoreset

@protominor	TextNewForDove

@vardata void ATTR_VIS_TEXT_CURSOR_NO_FOCUS;
/*
 *  When set, this attribute will cause the text object to have a cursor 
 *  regardless of whether it has the focus or not. 
 */

@protoreset

@protominor	TextNewForPenelope

@vardata    void    ATTR_VIS_TEXT_NO_CURSOR;
/*
 * This attribute will cause the cursor *not* to be drawn even though the
 * text object is editable.
 */

@protoreset

@protominor TextFullWidthFilters

@vardata void ATTR_VIS_TEXT_ALLOW_FULLWIDTH_DIGITS;
/*
 * This attribute overrides any filtering (VTI_filters) and allows full-width
 * digits ('0' to '9') to be entered.  The other filter classes are obeyed
 * after that.  A custom filter will be done after that.
 */
@protoreset

@protominor TextNewForWM

@vardata void ATTR_VIS_TEXT_WRAP_AFTER_OVERFLOW;
@vardataAlias (ATTR_VIS_TEXT_WRAP_AFTER_OVERFLOW) word ATTR_VIS_TEXT_WRAP_AFTER_OVERFLOW_WITH_MAXIMUM;
/*
 * This hint can be used to suggest that the word wrapping functionality
 * be altered so that instead of wrapping words to fit within the bounds of
 * the text object, words are wrapped so that the word at the end of each
 * line will be allowed to cross the left bound.  Must be used without
 * VTF_NO_WORD_WRAPPING.  Also, although this is defined in VisTextClass,
 * only VisLargeTextClass currently supports this.
 */

@vardata void ATTR_VIS_TEXT_DONT_DRAW_BREAKS;
/*
 * this prevents drawing of column breaks and section breaks.
 */

@protoreset

@protominor TextShowSelectionAtTop

@vardata void TEMP_VIS_TEXT_SHOW_SELECTION_AT_TOP_LEFT;
/*
 * Attempt to show selection at top of window.
 */

@vardata void ATTR_VIS_TEXT_ALLOW_CROSS_SECTION_COPY ;

@protoreset

/*---------------------------------------------------------------------------
 *	Instance data
 *---------------------------------------------------------------------------*/

    @instance ChunkHandle	VTI_text = NullChunk;
	/* chunk containing the text 	*/

    @instance word		VTI_charAttrRuns = VIS_TEXT_INITIAL_CHAR_ATTR;
	/* CharAttr runs or single 	*/

    @instance word		VTI_paraAttrRuns = VIS_TEXT_INITIAL_PARA_ATTR;
	/* ParaAttr runs or single 	*/

    @instance VMFileHandle	VTI_vmFile = NullHandle;
	/* Handle of associated VM file */

    @instance word		VTI_lines = 0;
	/* Reference to line info 	*/

/*
 *	External states ........
 */
    @instance VisTextStorageFlags VTI_storageFlags = (VTSF_DEFAULT_CHAR_ATTR |
						      VTSF_DEFAULT_PARA_ATTR);
    @instance VisTextFeatures	VTI_features = 0;
    @instance VisTextStates	VTI_state = 0;

/*
 *	Internal states ........
 */
    @instance VisTextIntFlags	VTI_intFlags = 0;
    @instance VisTextIntSelFlags VTI_intSelFlags = 0;

    @instance GSRefCountAndFlags VTI_gsRefCount = 0;
	/* Reference count for gstate. 	*/

    @instance GStateHandle	VTI_gstate = NullHandle;
	/* Temporary GState 		*/

    @instance word		VTI_gstateRegion = -1;
	/* Region to which gstate has been translated.	*/

/*
 *	Selection variables
 */
    @instance dword		VTI_selectStart = 0;
	/* offset to selection start 	*/

    @instance dword		VTI_selectEnd = 0;
	/* offset to selection end 	*/

    @instance PointDWord	VTI_startEventPos = {0,0};
	/*
	 * Start event-pos holds the coordinate position of the original
	 * mouse event.
	 */
/*
 * The next group of variables are used to make selection work
 * right and also for optimizations.
 */
	;
    @instance dword		VTI_selectMinStart = 0;
    @instance dword		VTI_selectMinEnd = 0;
	/*
	 * minStart/End are set by the start-select handler and indicate the
	 * minimum range that must remain selected during drag-selection. The
	 * selection will never be smaller than this.
	 */

    @instance dword		VTI_lastOffset = 0;
	/* Last-offset holds the last character offset which the mouse 
	 * was over. This is used for optimizations since if the 
	 * character offset of the mouse event hasn't changed then 
	 * the selection can't have changed.
 	 */

    @instance word		VTI_goalPosition = 0;

/****************************************************************************/

    @instance Point		VTI_cursorPos = {0,0};
	/* The current cursor position */

    @instance word		VTI_cursorRegion = 0;
	/* The region the cursor is in */

    @instance word		VTI_leftOffset = 0;
	/* Offset from left edge of text to left edge of vis-bounds.
	 * Used for moving one line text edit object left/right. 
	 */

/*
 *	User set state information
 */
    @instance byte		VTI_lrMargin = 0;
    @instance byte		VTI_tbMargin = 0;
	/* padding around text */

    @instance ColorQuad		VTI_washColor = {
				    C_WHITE,	    /* CQ_redOrIndex */
    				    CF_INDEX,    /* CQ_info */
				    0,		/* CQ_green */
				    0		/* CQ_blue */
				};
	/* Background color and map mode */

    @instance word		VTI_maxLength = 10000;
	/* Max amount of text.  This applies only to small text objects.
	 * Large text objects cannot have a limit on their size. 
	 */

    @instance VisTextFilters	VTI_filters = 0;
	/* Pre-defined key filters */

    @instance optr		VTI_output;

/*
 *	Derived state information
 */
    @instance WBFixed		VTI_height = {0,0};
	/* height in points	*/

    @instance word		VTI_lastWidth = -1;
	/* Cached width, used to optimize resizing the object
	 * (via the geometry manager).  For more information see
	 * VisTextCalcHeight().
	 */

    @instance TimerHandle	VTI_timerHandle = NullHandle;
    @instance word		VTI_timerID = 0;

@endc

@ifdef __HIGHC__
pragma Alias(TextSearchInString, "TEXTSEARCHINSTRING");
pragma Alias(TextSearchInHugeArray, "TEXTSEARCHINHUGEARRAY");
pragma Alias(TextMapDefaultCharAttr, "TEXTMAPDEFAULTCHARATTR");
pragma Alias(TextFindDefaultCharAttr, "TEXTFINDDEFAULTCHARATTR");
pragma Alias(TextMapDefaultParaAttr, "TEXTMAPDEFAULTPARAATTR");
pragma Alias(TextFindDefaultParaAttr, "TEXTFINDDEFAULTPARAATTR");
pragma Alias(TextGetSystemCharAttrRun, "TEXTGETSYSTEMCHARATTRRUN");
pragma Alias(TextSetHyphenationCall, "TEXTSETHYPHENATIONCALL");
pragma Alias(TextAllocClipboardObject, "TEXTALLOCCLIPBOARDOBJECT");
pragma Alias(TextFinishWithClipboardObject, "TEXTFINISHWITHCLIPBOARDOBJECT");
pragma Alias(VisTextFormatNumber, "VISTEXTFORMATNUMBER");
pragma Alias(MsgVisTextLoadStyleSheetParams, "MSGVISTEXTLOADSTYLESHEETPARAMS");
pragma Alias(GetTokenForPosition, "GETTOKENFORPOSITION");

@endif

@endlib
@endif


