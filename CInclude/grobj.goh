/**************************************************************************
 * 
 *	Copyright (c) GeoWorks 1992 -- All Rights Reserved
 *
 * PROJECT:		PC GEOS
 * FILE:		grobj.goh
 *
 * AUTHOR:		Allen Schoonmaker
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	Allen 	2/20/92		Inital version
 *	Allen	4/22/92		Updated for controllers
 *	RainerB	11/12/22	Default value of GBI_curScaleFactor of GrObjBodyClass: Syntax fixed	
 *	MarcusG 11/03/24	Fixed methods and structs required by V-Convert	
 *
 * DESCRIPTION:
 *	This file is the C header file for the GrObj library 
 *
 *      $Id: grobj.goh,v 1.1 97/04/04 15:58:00 newdeal Exp $
 * 
 **************************************************************************/
@optimize
@deflib grobj

/* #include <graphics.h> */

@include <Objects/colorC.goh>
@include <Objects/styles.goh>
@include <Objects/vTextC.goh>
@include <Objects/gCtrlC.goh>
@include <Objects/bitmapC.goh>

/*-----------------------------------------------------------------------------
;	Structures and Constants (Added as needed)
-----------------------------------------------------------------------------*/

typedef WordFlags GrObjLocks;
#define	GOL_COPY 0x8000
#define	GOL_LOCK 0x4000
#define	GOL_SHOW 0x2000
#define	GOL_WRAP 0x1000
#define	GOL_MOVE 0x0800
#define	GOL_RESIZE 0x0400
#define	GOL_ROTATE 0x0200
#define GOL_SKEW 0x0100
#define	GOL_EDIT 0x0080
#define	GOL_DELETE 0x0040
#define	GOL_SELECT 0x0020
#define	GOL_ATTRIBUTE 0x0010
#define	GOL_GROUP 0x0008
#define	GOL_UNGROUP 0x0004
#define	GOL_DRAW 0x0002
#define	GOL_PRINT 0x0001

typedef struct {
	word	GOANS_suspendCount;
	optr	GOANS_optr;
	word	GOANS_message;
} GrObjActionNotificationStruct;


typedef enum {
    GOANT_NULL,
    GOANT_SELECTED,
    GOANT_UNSELECTED,
    GOANT_CREATED,
    GOANT_MOVED,
    GOANT_RESIZED,
    GOANT_ROTATED,
    GOANT_SKEWED,
    GOANT_TRANSFORMED,
    GOANT_ATTRED,
    GOANT_SPEC_MODIFIED,
    GOANT_DELETED,
    GOANT_PASTED,
    GOANT_WRAP_CHANGED
} GrObjActionNotificationType;


#define LINE_ATTR_COLOR_SIZE 3
#define LINE_ATTR_END_SIZE 1
#define LINE_ATTR_JOIN_SIZE 1
#define LINE_ATTR_MASK_SIZE 1
#define LINE_ATTR_DRAW_MODE_SIZE 1
#define LINE_ATTR_WIDTH_SIZE 4
#define LINE_ATTR_STYLE_SIZE 1
#define LINE_ATTR_MITER_LIMIT_SIZE 4
#define LINE_ATTR_TYPE_SIZE 1

typedef ByteFlags GrObjLineAttrInfoRecord; /* XXX */ 
#define	GOLAIR_ARROWHEAD_ON_START			0x80
#define	GOLAIR_ARROWHEAD_ON_END				0x40
#define	GOLAIR_ARROWHEAD_FILLED				0x20
#define	GOLAIR_ARROWHEAD_FILL_WITH_AREA_ATTRIBUTES	0x10

typedef enum {
    GOLAET_BASE
} GrObjLineAttrElementType;


typedef struct {
	StyleSheetElementHeader    GOBGOBLAE_styleElement;
	byte GOBLAE_r;
	byte GOBLAE_g;
	byte GOBLAE_b;
	LineEnd GOBLAE_end;
	LineJoin GOBLAE_join;
	WWFixed GOBLAE_width;
	SystemDrawMask GOBLAE_mask;
	LineStyle GOBLAE_style;
	MixMode GOBLAE_drawMode;
	WWFixed GOBLAE_miterLimit;
	GrObjLineAttrElementType GOBLAE_laeType;
	GrObjLineAttrInfoRecord GOBLAE_lineInfo;
	byte	GOBLAE_arrowheadAngle;
	byte	GOBLAE_arrowheadLength;
	word GOBLAE_reserved;
} GrObjBaseLineAttrElement;

#define FUTURE_LINE_ATTR_ELEMENT_DATA_SIZE 50

typedef struct {
	GrObjBaseLineAttrElement	GOFLAE_base;
	byte 		GOFLAE_future[FUTURE_LINE_ATTR_ELEMENT_DATA_SIZE];
} GrObjFullLineAttrElement;

typedef ByteFlags GrObjAreaAttrInfoRecord; /* XXX */ /* Untested structure */
#define 	GOAAIR_TRANSPARENT 	0x01  /* Don't draw object's BG */

typedef enum {
    GOAAET_BASE,
    GOAAET_GRADIENT
} GrObjAreaAttrElementType;

typedef struct {  /* XXX */ /* Untested structure */
	StyleSheetElementHeader 	GOBAAE_styleElement;
	byte				GOBAAE_r;
	byte 				GOBAAE_g;
	byte 				GOBAAE_b;
	SysDrawMask			GOBAAE_mask;
	MixMode 			GOBAAE_drawMode;
	GraphicPattern			GOBAEE_pattern;
	byte				GOBAEE_backR;
	byte				GOBAEE_backG;
	byte				GOBAEE_backB;
	byte    			GOBAEE_aaeType;
	GrObjAreaAttrInfoRecord 	GOBAAE_areaInfo;

		/* The following fields are unused, but must
		 * be initialized to zero. */
	byte				GOBAAE_reservedByte;
	word 				GOBAAE_reserved;
} GrObjBaseAreaAttrElement;

typedef	enum {
	GOGT_NONE,
	GOGT_LEFT_TO_RIGHT,
	GOGT_TOP_TO_BOTTOM,
	GOGT_RADIAL_RECT,
	GOGT_RADIAL_ELLIPSE
} GrObjGradientType;


typedef	struct {
	GrObjBaseAreaAttrElement GOGAAE_base;
	GrObjGradientType	GOGAAE_type;		
	byte			GOGAAE_endR;	
	byte			GOGAAE_endG;	
	byte			GOGAAE_endB;	
	word			GOGAAE_numIntervals;	
	word			GOGAAE_reserved;	
} GrObjGradientAreaAttrElement;


typedef WordFlags GrObjStyleFlags;		/* CHECKME */
#define GSF_AREA_COLOR_RELATIVE	(0x8000)
#define GSF_AREA_MASK_RELATIVE	(0x4000)
#define GSF_LINE_COLOR_RELATIVE	(0x2000)
#define GSF_LINE_MASK_RELATIVE	(0x1000)
#define GSF_LINE_WIDTH_RELATIVE	(0x0800)

typedef struct {		/* CHECKME */
    GrObjStyleFlags	GSPD_flags;
    word		GSPD_unused;
} GrObjStylePrivateData;

typedef struct {		/* CHECKME */
    NameArrayElement		GSE_meta;
    word			GSE_baseStyle;
    StyleElementFlags		GSE_flags;
    byte			GSE_reserved[6];
    GrObjStylePrivateData	GSE_privateData;
    word			GSE_areaAttrToken;
    word			GSE_lineAttrToken;
} GrObjStyleElement;


#define DEFAULT_MAX_LINE_WIDTH	7

#define SMALL_DESIRED_HANDLE_SIZE 5
#define MEDIUM_DESIRED_HANDLE_SIZE 8
#define LARGE_DESIRED_HANDLE_SIZE 12

#define DEFAULT_DESIRED_HANDLE_SIZE  MEDIUM_DESIRED_HANDLE_SIZE

typedef ByteFlags GrObjHandleSpecification;
#define	GOHS_HANDLE_LEFT 0x08
#define	GOHS_HANDLE_TOP 0x04
#define	GOHS_HANDLE_RIGHT 0x02
#define	GOHS_HANDLE_BOTTOM 0x01

typedef WordFlags GrObjFunctionsActive;		/* CHECKME */
/* 6 bits unused */
/*
 * This is true if the mouse event has
 * been sent to the ruler already. This
 * is used for cases like moving
 * multiple grobjs, where you only want
 * to snap the mouse once, and not a
 * kajillion times for each grobj
 */
#define GOFA_RULER_HAS_SEEN_EVENT	(0x0200)
/*
 * If true do all drawing operations in
 * high resolution mode
 */
#define GOFA_VIEW_ZOOMED	(0x0100)
/* If true, snap operation to grid */
#define GOFA_SNAP_TO	(0x0080)
/*
 * If true then do resize/create 
 * from center 
 */
#define GOFA_FROM_CENTER	(0x0040)
/* If true, rotate about opposite corner */
#define GOFA_ABOUT_OPPOSITE	(0x0020)
/* If true constrain resize,rotate,etc */
#define GOFA_CONSTRAIN	(0x0010)
/* Same as UIFA_ADJUST */
#define GOFA_ADJUST	(0x0008)
/* Same as UIFA_EXTEND */
#define GOFA_EXTEND	(0x0004)
/* needed for check hacks */
/* 2 bits unused */

typedef enum {
	GOWTT_DONT_WRAP,
	GOWTT_WRAP_AROUND_RECT,
	GOWTT_WRAP_AROUND_TIGHTLY,
	GOWTT_WRAP_INSIDE
} GrObjWrapTextType;

#define GROBJ_DEFAULT_WRAP_TYPE GOWTT_DONT_WRAP

typedef WordFlags GrObjAttrFlags;		/* CHECKME */

/*
 *  When this object is written out to
 *  the transfer format, locks won't be
 *  copied. 
 */
#define GOAF_DONT_COPY_LOCKS	(0x0200)

/*
 * True if object contains paste
 * inside children. Currently
 * only relevant for groups
 */
#define GOAF_HAS_PASTE_INSIDE_CHILDREN	(0x0100)

/*
 * Meaningless unless object is in
 * a group. If true then object
 * was pasted inside group and will
 * be drawn clipped to group's
 * normal children.
 */
#define GOAF_PASTE_INSIDE	(0x0080)

/*
 * If true grobject can be 
 * moved as a result of a
 * MSG_GO_INSERT_OR_DELETE_SPACE
 */
#define GOAF_INSERT_DELETE_MOVE_ALLOWED	(0x0040)

/*
 * If true grobject can be 
 * resized as a result of a
 * MSG_GO_INSERT_OR_DELETE_SPACE
 */
#define GOAF_INSERT_DELETE_RESIZE_ALLOWED	(0x0020)

/*
 * If true grobject can be 
 * deleted as a result of a
 * MSG_GO_INSERT_OR_DELETE_SPACE
 */
#define GOAF_INSERT_DELETE_DELETE_ALLOWED	(0x0010)
		
/*
 * if true then this object is used
 * for instructions in a template.
 */
#define GOAF_INSTRUCTION	(0x0008)

/*
 * if false, the resize deltas are
 * added to objects coordinates. if
 * true, a scale factor is calculated
 * and applied to objects transform
 */
#define GOAF_MULTIPLICATIVE_RESIZE	(0x0004)

/*
 * enum describing how to wrap text
 * with respect to object
 */
#define GrObjWrapTextType	(0x0002 | 0x0001)
#define GrObjWrapTextType_OFFSET	0


typedef ByteFlags GrObjOptimizationFlags;		/* CHECKME */
/*
 * Grobject has been added to body,
 * or the group it is in has been
 * added to the body
 */
#define GOOF_ADDED_TO_BODY	(0x80)

/* If true, objects is in a group */
#define GOOF_IN_GROUP	(0x40)

/*
 * If true, object is incomplete
 * and cannot be drawn, or invalidated
 * It may be missing
 * its normal transform or have
 * no attributes, etc.
 */
#define GOOF_GROBJ_INVALID	(0x20)

/* True if object is an attribute manager */
#define GOOF_ATTRIBUTE_MANAGER	(0x10)

/*
 * GrObj is floater. Don't need to
 * dirty the object when this
 * bit is set
 * because floater objects
 * are not actually in the document
 */
#define GOOF_FLOATER	(0x08)

/*
 * True if object has an action
 * notification od in it's var
 * data.
 */
#define GOOF_HAS_ACTION_NOTIFICATION	(0x04)

/*
 * If TRUE, object has vardata
 * ATTR_GO_PARENT_DIMENSIONS_OFFSET, which
 * holds offset from objects center to
 * center of parent dimensions
 */
#define GOOF_HAS_UNBALANCED_PARENT_DIMENSIONS	(0x02)

typedef	WordFlags	GrObjMessageOptimizationFlags;
#define	GOMOF_GET_DWF_SELECTION_HANDLE_BOUNDS 0x200
#define	GOMOF_SPECIAL_RESIZE_CONSTRAIN	0x100
#define	GOMOF_INVALIDATE_LINE		0x80
#define	GOMOF_INVALIDATE_AREA		0x40
#define	GOMOF_INVALIDATE		0x20
#define	GOMOF_NOTIFY_ACTION		0x10
#define	GOMOF_SEND_UI_NOTIFICATION	0x08
#define	GOMOF_DRAW_FG_AREA		0x04
#define	GOMOF_DRAW_FG_LINE		0x02
#define	GOMOF_DRAW_BG			0x01

typedef ByteFlags GrObjActionModes;
#define	GOAM_RESIZE 0x0080
#define	GOAM_MOVE 0x0040
#define	GOAM_ROTATE 0x0020
#define	GOAM_CHOOSE 0x0010
#define	GOAM_ACTION_ACTIVATED 0x0008
#define	GOAM_ACTION_PENDING 0x0004
#define	GOAM_ACTION_HAPPENING 0x0002
#define	GOAM_CREATE 0x0001

typedef ByteFlags GrObjActionEvent;
#define	GOAE_RULER_CONSTRAIN 0x40
#define	GOAE_IGNORING_CONSTRAIN 0x20
#define	GOAE_GAE 0x01

/*
 * 	Bits that will be lost if the object is discarded
 * 	Must be protected by incing in use count
 */

typedef ByteFlags GrObjTempModes;		/* CHECKME */
/* GrObj is in the selectionList */
#define GOTM_SELECTED	(0x80)

/*
 * GrObj is currently being edited
 * equivalent to having app target.
 */
#define GOTM_EDITED	(0x40)

/*
 * If true the object has drawn
 * some indicator to show the
 * user that it is being edit
 */
#define GOTM_EDIT_INDICATOR_DRAWN	(0x20)

/*
 * GrObjs selection handles have been
 * drawn 
 */
#define GOTM_HANDLES_DRAWN	(0x10)

/*
 * GrObjs handles are drawn in a
 * temporary state. Set by
 * DRAW_HANDLES_FORCE, 
 * DRAW_HANDLES_OPPOSITE and cleared by
 * DRAW_HANDLES_MATCH and DRAW_HANDLES
 * and UNDRAW_HANDLES. Mainly used
 * when drag selecting with pointer
 * to cut down the number of objects
 * that methods must be sent to.
 */
#define GOTM_TEMP_HANDLES	(0x08)

/*
 * True if the objects sprite has
 * been drawn	
 */
#define GOTM_SPRITE_DRAWN	(0x04)

/*
 * True if when the objects sprite
 * was drawn it was drawn at a
 * higher resolution. This bit
 * is meaningless if GOTM_SPRITE_DRAWN
 * is not set
 */
#define GOTM_SPRITE_DRAWN_HI_RES	(0x02)

/*
 * True if body has the system target
 * Bit is meaningless unless 
 * GOTM_SELECTED or GOTM_EDITED is
 * set. (body only updates objects
 * in selection list and with
 * app target.
 */
#define GOTM_SYS_TARGET	(0x01)

typedef ByteFlags GrObjFileStatus;
#define GOFS_MOUSE_GRAB 0x08
#define GOFS_SYS_TARGETED 0x04
#define GOFS_TARGETED 0x02
#define GOFS_OPEN 0x01

typedef WordFlags GrObjUINotificationTypes;		/* CHECKME */
/* True if style notification needs to be sent */
#define GOUINT_STYLE	(0x8000)
/* True if area notification needs to be sent */
#define GOUINT_AREA	(0x4000)
/* True if line notification needs to be sent */
#define GOUINT_LINE	(0x2000)
/* True if grobj specific selection state notification needs to be sent */
#define GOUINT_GROBJ_SELECT	(0x1000)
/* True if style notification needs to be sent */
#define GOUINT_STYLE_SHEET	(0x0800)
/* True if edit menu notification need be sent */
#define GOUINT_SELECT	(0x0400)

/*-----------------------------------------------------------------------------
	GrObj Controller Definitions
-----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
	GrObjStyleSheetControlClass	
-----------------------------------------------------------------------------*/
@class	GrObjStyleSheetControlClass, StyleSheetControlClass;

@default GCI_output = (TO_APP_TARGET);
@default GI_states = (@default & ~GS_ENABLED);
    @default SSCI_targetClass = (ClassStruct *)&GrObjBodyClass;
    @default SSCI_styledClass = (ClassStruct *)&GrObjClass;
@endc

/*-----------------------------------------------------------------------------
	GrObjAreaColorSelector	
-----------------------------------------------------------------------------*/
@class	GrObjAreaColorSelectorClass, ColorSelectorClass;



#define GOACS_DEFAULT_FEATURES (CSF_INDEX | CSF_RGB | CSF_DRAW_MASK | \
					CSF_PATTERN )

@default GCI_output = (TO_APP_TARGET);
@default GI_states = (@default | GS_ENABLED);

@endc

/*-----------------------------------------------------------------------------
	GrObjBackgroundColorSelector	
-----------------------------------------------------------------------------*/
@class	GrObjBackgroundColorSelectorClass, ColorSelectorClass;



#define GOBGCS_DEFAULT_FEATURES (CSF_INDEX | CSF_RGB )

@default GCI_output = (TO_APP_TARGET);
@default GI_states = (@default | GS_ENABLED);

@endc

/*-----------------------------------------------------------------------------
	GrObjStartingGradientColorSelector	
-----------------------------------------------------------------------------*/
@class	GrObjStartingGradientColorSelectorClass, ColorSelectorClass;



#define GOSGCS_DEFAULT_FEATURES (CSF_INDEX | CSF_RGB )

@default GCI_output = (TO_APP_TARGET);
@default GI_states = (@default & ~GS_ENABLED);

@endc


/*-----------------------------------------------------------------------------
	GrObjEndingGradientColorSelector	
-----------------------------------------------------------------------------*/
@class	GrObjEndingGradientColorSelectorClass, ColorSelectorClass;



#define GOSGCS_DEFAULT_FEATURES (CSF_INDEX | CSF_RGB )

@default GCI_output = (TO_APP_TARGET);
@default GI_states = (@default & ~GS_ENABLED);

@endc

/*-----------------------------------------------------------------------------
	GrObjObscureAttrControlClass	
-----------------------------------------------------------------------------*/
@class GrObjObscureAttrControlClass, GenControlClass;

@message void MSG_GOOAC_SET_WRAP_TEXT_TYPE(GrObjObscureAttr wrapTextType = cl);
@message void MSG_GOOAC_CHANGE_OBSCURE_ATTRS(GrObjFlags obscureAttrs = cl);

typedef ByteFlags GrObjObscureAttrControlFeatures;
#define GOOACF_INSTRUCTIONS		0x80
#define GOOACF_INSERT_OR_DELETE_MOVE	0x40
#define GOOACF_INSERT_OR_DELETE_RESIZE	0x20
#define GOOACF_INSERT_OR_DELETE_DELETE	0x10
#define GOOACF_DONT_WRAP		0x08
#define GOOACF_WRAP_INSIDE		0x04
#define GOOACF_WRAP_AROUND_RECT		0x02
#define GOOACF_WRAP_TIGHTLY		0x01


#define GOOAC_INSERT_OR_DELETE_FEATURES	(GOOACF_INSERT_OR_DELETE_MOVE | \
					GOOACF_INSERT_OR_DELETE_RESIZE | \
					GOOACF_INSERT_OR_DELETE_DELETE)

#define GOOAC_WRAP_FEATURES	(GOOACF_DONT_WRAP | GOOACF_WRAP_INSIDE | \
				GOOACF_WRAP_AROUND_RECT | GOOACF_WRAP_TIGHTLY)

#define GOOAC_DEFAULT_FEATURES 	(GOOACF_INSTRUCTIONS | GOOAC_WRAP_FEATURES | \
				 GOOAC_INSERT_OR_DELETE_FEATURES)

@default GCI_output = (TO_APP_TARGET);
@default GI_states = (@default | GS_ENABLED);

@endc

/*-----------------------------------------------------------------------------
	GrObjInstructionControlClass	
-----------------------------------------------------------------------------*/
@class GrObjInstructionControlClass, GenControlClass;

@message void MSG_GOIC_MAKE_INSTRUCTIONS_EDITABLE();
@message void MSG_GOIC_MAKE_INSTRUCTIONS_UNEDITABLE();
@message void MSG_GOIC_DELETE_INSTRUCTIONS();
@message void MSG_GOIC_SET_INSTRUCTION_ATTRS(GrObjDrawFlags drawFlags = cx);

typedef ByteFlags GrObjInstructionControlFeatures;		/* CHECKME */
/* 3 bits unused */
#define GOICF_DRAW	(0x10)
#define GOICF_PRINT	(0x08)
#define GOICF_MAKE_EDITABLE	(0x04)
#define GOICF_MAKE_UNEDITABLE	(0x02)
#define GOICF_DELETE	(0x01)

#define GOICF_DEFAULT_FEATURES 	(GOICF_DRAW | GOICF_PRINT | \
				GOICF_MAKE_EDITABLE | GOICF_MAKE_UNEDITABLE | \
				GOICF_DELETE)

@default GCI_output = (TO_APP_TARGET);

@endc

/*-----------------------------------------------------------------------------
	GrObjAreaAttrControlClass
-----------------------------------------------------------------------------*/
@class GrObjAreaAttrControlClass, GenControlClass;

@message void MSG_GOAAC_SET_MIX_MODE(MixMode mixMode = cl);
@message void MSG_GOAAC_SET_AREA_TRANSPARENCY(GrObjAreaAttrInfoRecord transparent = cl);

typedef ByteFlags GOAACFeatures;
#define	GOAACF_MM_CLEAR		0x0100
#define	GOAACF_MM_COPY		0x0080
#define	GOAACF_MM_NOP		0x0040
#define	GOAACF_MM_AND		0x0020
#define	GOAACF_MM_INVERT	0x0010
#define	GOAACF_MM_XOR		0x0008
#define	GOAACF_MM_SET		0x0004
#define	GOAACF_MM_OR		0x0002
#define	GOAACF_TRANSPARENCY	0x0001

#define GOAAC_DEFAULT_FEATURES (GOAACF_TRANSPARENCY | GOAACF_MM_COPY | \
				GOAACF_MM_INVERT | GOAACF_MM_XOR | \
				GOAACF_MM_AND | GOAACF_MM_OR)

#define GOAAC_DEFAULT_TOOLBOX_FEATURES	0

@default GCI_output = (TO_APP_TARGET);
@default GI_states = (@default | GS_ENABLED);

@endc

/*-----------------------------------------------------------------------------
	GrObjLineColorSelectorClass
-----------------------------------------------------------------------------*/
@class 	GrObjLineColorSelectorClass, ColorSelectorClass;



#define GOLCS_DEFAULT_FEATURES (CSF_INDEX | CSF_RGB | CSF_DRAW_MASK |						CSF_PATTERN)

@default GCI_output = (TO_APP_TARGET);
@default GI_states = (@default | GS_ENABLED);
@default CSI_toolboxPrefs = @default | (COO_LINE_ORIENTED << CTP_INDEX_ORIENTATION_OFFSET) | (COO_LINE_ORIENTED << CTP_DRAW_MASK_ORIENTATION_OFFSET);
@endc

/*-----------------------------------------------------------------------------
	GrObjLineAttrControlClass
-----------------------------------------------------------------------------*/
@class 	GrObjLineAttrControlClass, GenControlClass;

typedef WordFlags StandardArrowheadType;		/* CHECKME */
#define SAT_LENGTH	(0xfc00)
#define SAT_LENGTH_OFFSET	10
#define SAT_FILLED	(0x0200)
#define SAT_FILL_WITH_AREA_ATTRIBUTES	(0x0100)
#define SAT_ANGLE	(0x00ff)
#define SAT_ANGLE_OFFSET	0

@message void MSG_GOLAC_SET_LINE_VALUE_FROM_INDEX(word lineWidth = cx);
@message void MSG_GOLAC_SET_LINE_INDEX_FROM_VALUE(WWFixed lineWidth = dx.cx);

@message void MSG_GOLAC_SET_INTEGER_LINE_WIDTH(word lineWidth = cx);
@message void MSG_GOLAC_SET_LINE_WIDTH(WWFixed lineWidth = dx.cx);
@message void MSG_GOLAC_SET_LINE_STYLE(LineStyle style = cl);
@message void MSG_GOLAC_SET_ARROWHEAD_TYPE(StandardArrowheadType type = cx);
@message void MSG_GOLAC_SET_ARROWHEAD_WHICH_END(GrObjLineAttrInfoRecord whichEnds = cl);

typedef WordFlags GOLACFeatures;
#define	GOLACF_WIDTH_INDEX		0x0010
#define	GOLACF_WIDTH_VALUE		0x0008
#define	GOLACF_STYLE			0x0004
#define	GOLACF_ARROWHEAD_TYPE		0x0002
#define	GOLACF_ARROWHEAD_WHICH_END	0x0001

#define GOLAC_DEFAULT_FEATURES (GOLACF_WIDTH_INDEX | GOLACF_WIDTH_VALUE | \
				GOLACF_STYLE | GOLACF_ARROWHEAD_TYPE | \
				GOLACF_ARROWHEAD_WHICH_END)

typedef WordFlags GOLACToolboxFeatures;
#define	GOLACTF_WIDTH_INDEX		0x0002
#define	GOLACTF_STYLE			0x0001

#define GOLAC_DEFAULT_TOOLBOX_FEATURES (GOLACTF_WIDTH_INDEX | GOLACF_STYLE)

@default GCI_output = (TO_APP_TARGET);
@default GI_states = (@default | GS_ENABLED);

@endc


/*-----------------------------------------------------------------------------
	GrObjNudgeControlClass
-----------------------------------------------------------------------------*/
@class GrObjNudgeControlClass, GenControlClass;

typedef ByteFlags GrObjNudgeControlFeatures;		/* CHECKME */
/* 3 bits unused */
#define GONCF_NUDGE_LEFT	(0x10)
#define GONCF_NUDGE_RIGHT	(0x08)
#define GONCF_NUDGE_UP	(0x04)
#define GONCF_NUDGE_DOWN	(0x02)
#define GONCF_CUSTOM_MOVE	(0x01)

@message void MSG_GONC_NUDGE(sword xNudge = cx, sword yNudge = dx);
@message void MSG_GONC_CUSTOM_MOVE();
@message void MSG_GONC_SET_DISPLAY_FORMAT(GenValueDisplayFormat format = cl);

#define GROBJ_NUDGE_CONTROL_DEFAULT_FEATURES (GONCF_NUDGE_LEFT | \
						GONCF_NUDGE_RIGHT | \
						GONCF_NUDGE_UP | \
						GONCF_NUDGE_DOWN | \
						GONCF_CUSTOM_MOVE)

@default GCI_output = (TO_APP_TARGET);

@endc

/*-----------------------------------------------------------------------------
	GrObjMoveInsideControlClass
-----------------------------------------------------------------------------*/
@class GrObjMoveInsideControlClass, GrObjNudgeControlClass;
@endc

/*-----------------------------------------------------------------------------
	GrObjGroupControlClass
-----------------------------------------------------------------------------*/
@class GrObjGroupControlClass, GenControlClass;

@message void MSG_GOGC_GROUP();
@message void MSG_GOGC_UNGROUP();

typedef ByteFlags GOGCFeatures;
#define GOGCF_GROUP 0x02
#define GOGCF_UNGROUP 0x01

#define GOGC_DEFAULT_FEATURES (GOGCF_GROUP | GOGCF_UNGROUP)
#define GOGC_DEFAULT_TOOLBOX_FEATURES (GOGCF_GROUP | GOGCF_UNGROUP)

@default GCI_output = (TO_APP_TARGET);

@endc

/*-----------------------------------------------------------------------------
	GrObjDefaultAttributesControlClass
-----------------------------------------------------------------------------*/
@class GrObjDefaultAttributesControlClass, GenControlClass;

@message void MSG_GODAC_SET_DEFAULT_ATTRIBUTES();

typedef ByteFlags GODACFeatures;
#define GODACF_SET_DEFAULT_ATTRIBUTES 0x01

#define GODAC_DEFAULT_FEATURES (GODACF_SET_DEFAULT_ATTRIBUTES)
#define GODAC_DEFAULT_TOOLBOX_FEATURES (GODACF_SET_DEFAULT_ATTRIBUTES)

@default GCI_output = (TO_APP_TARGET);

@endc

/*-----------------------------------------------------------------------------
	GrObjPasteInsideControlClass
-----------------------------------------------------------------------------*/
@class GrObjPasteInsideControlClass, GenControlClass;

@message void MSG_GOPIC_PASTE_INSIDE();
@message void MSG_GOPIC_BREAKOUT_PASTE_INSIDE();

typedef ByteFlags GOPICFeatures;
#define GOPICF_PASTE_INSIDE 		0x0002
#define GOPICF_BREAKOUT_PASTE_INSIDE	0x0001

typedef ByteFlags GOPICToolboxFeatures;
#define GOPICTF_PASTE_INSIDE 		0x0002
#define GOPICTF_BREAKOUT_PASTE_INSIDE	0x0001

#define GOPIC_DEFAULT_FEATURES (GOPICF_PASTE_INSIDE | GOPICF_BREAKOUT_PASTE_INSIDE)
#define GOPIC_DEFAULT_TOOLBOX_FEATURES (GOPICTF_PASTE_INSIDE | GOPICTF_BREAKOUT_PASTE_INSIDE)

@default GCI_output = (TO_APP_TARGET);
@instance word GPICI_lastNumSelected = 0;

@endc

/*-----------------------------------------------------------------------------
	GrObjDuplicateControlClass
-----------------------------------------------------------------------------*/
@class GrObjDuplicateControlClass, GenControlClass;

@message void MSG_GROBJ_DUPLICATE_CONTROL_DUPLICATE();
@message void MSG_GROBJ_DUPLICATE_CONTROL_DUPLICATE_IN_PLACE();

typedef ByteFlags GrObjDuplicateControlFeatures;
#define GODCF_DUPLICATE			0x0002
#define GODCF_DUPLICATE_IN_PLACE	0x0001

typedef ByteFlags GrObjDuplicateControlToolboxFeatures;
#define GODCTF_DUPLICATE		0x0002
#define GODCTF_DUPLICATE_IN_PLACE	0x0001

#define GROBJ_DUPLICATE_CONTROL_DEFAULT_FEATURES (GODCF_DUPLICATE | GODCF_DUPLICATE_IN_PLACE)
#define GROBJ_DUPLICATE_CONTROL_DEFAULT_TOOLBOX_FEATURES (GODCTF_DUPLICATE | GODCTF_DUPLICATE_IN_PLACE)

@default GCI_output = (TO_APP_TARGET);

@endc

/*-----------------------------------------------------------------------------
	GrObjConvertControlClass
-----------------------------------------------------------------------------*/
@class GrObjConvertControlClass, GenControlClass;

@message void MSG_GOCC_CONVERT_TO_BITMAP();
@message void MSG_GOCC_CONVERT_TO_GRAPHIC();
@message void MSG_GOCC_CONVERT_FROM_GRAPHIC();

typedef ByteFlags GOCCFeatures;
#define GOCCF_CONVERT_TO_BITMAP 0x0004
#define GOCCF_CONVERT_TO_GRAPHIC 0x0002
#define GOCCF_CONVERT_FROM_GRAPHIC 0x0001

#define GROBJ_CONVERT_CONTROL_DEFAULT_FEATURES (GOCCF_CONVERT_TO_BITMAP | GOCCF_CONVERT_TO_GRAPHIC | GOCCF_CONVERT_FROM_GRAPHIC)
#define GROBJ_CONVERT_CONTROL_DEFAULT_TOOLBOX_FEATURES (GOCCF_CONVERT_TO_BITMAP | GOCCF_CONVERT_TO_GRAPHIC | GOCCF_CONVERT_FROM_GRAPHIC)

@default GCI_output = (TO_APP_TARGET);

@endc

/*-----------------------------------------------------------------------------
	GrObjCreateControlClass
-----------------------------------------------------------------------------*/
@class GrObjCreateControlClass, GenControlClass;

@message void MSG_GOCC_CREATE_GROBJ(ClassStruct *grobjClass = cx:dx);
@message void MSG_GOCC_CREATE_POLYGON(word nSides = cx);
@message void MSG_GOCC_CREATE_STAR(word nPoints = cx);

typedef ByteFlags GrObjCreateControlFeatures;
#define GOCCF_RECTANGLE			0x0200
#define GOCCF_ELLIPSE			0x0100
#define GOCCF_LINE			0x0080
#define GOCCF_ROUNDED_RECTANGLE		0x0040
#define GOCCF_ARC			0x0020
#define GOCCF_TRIANGLE			0x0010
#define GOCCF_HEXAGON			0x0008
#define GOCCF_OCTOGON			0x0004
#define GOCCF_FIVE_POINTED_STAR		0x0002
#define GOCCF_EIGHT_POINTED_STAR	0x0001

#define GROBJ_CREATE_CONTROL_DEFAULT_FEATURES 		0x03fb
#define GROBJ_CREATE_CONTROL_DEFAULT_TOOLBOX_FEATURES	0x03fb

@default GCI_output = (TO_APP_TARGET);
@default GI_states = (@default | GS_ENABLED);

@endc

/*-----------------------------------------------------------------------------
	GrObjLocksControlClass
-----------------------------------------------------------------------------*/
@class GrObjLocksControlClass, GenControlClass;

@message void MSG_GOLC_CHANGE_LOCKS();

#define GOLC_DEFAULT_FEATURES (GOL_MOVE | GOL_RESIZE | GOL_ROTATE)
#define GOLC_DEFAULT_TOOLBOX_FEATURES 0

@default GCI_output = (TO_APP_TARGET);

@endc

/*-----------------------------------------------------------------------------
	GrObjDepthControlClass	
-----------------------------------------------------------------------------*/
@class GrObjDepthControlClass, GenControlClass;

@message void MSG_GODC_BRING_TO_FRONT();
@message void MSG_GODC_SEND_TO_BACK();
@message void MSG_GODC_SHUFFLE_UP();
@message void MSG_GODC_SHUFFLE_DOWN();

typedef ByteFlags GODepthCFeatures;
#define	GODepthCF_BRING_TO_FRONT 0x0008
#define	GODepthCF_SEND_TO_BACK	 0x0004
#define	GODepthCF_SHUFFLE_UP 	 0x0002
#define	GODepthCF_SHUFFLE_DOWN	 0x0001

#define GODepthC_DEFAULT_FEATURES  (GODepthCF_BRING_TO_FRONT | \
					GODepthCF_SEND_TO_BACK | \
					GODepthCF_SHUFFLE_UP | \
					GODepthCF_SHUFFLE_DOWN)

#define GODepthC_DEFAULT_TOOLBOX_FEATURES (GODepthCF_BRING_TO_FRONT | \
					GODepthCF_SEND_TO_BACK | \
					GODepthCF_SHUFFLE_UP | \
					GODepthCF_SHUFFLE_DOWN)

@default GCI_output = (TO_APP_TARGET);

@endc

/*-----------------------------------------------------------------------------
	GrObjFlipControlClass	
-----------------------------------------------------------------------------*/
@class GrObjFlipControlClass, GenControlClass;

@message void MSG_GOFC_FLIP_HORIZONTALLY();
@message void MSG_GOFC_FLIP_VERTICALLY();

typedef ByteFlags GOFCFeatures;
#define	GOFCF_FLIP_HORIZONTALLY 0x02
#define	GOFCF_FLIP_VERTICALLY 0x01

@default GCI_output = (TO_APP_TARGET);

@endc

/*-----------------------------------------------------------------------------
	GrObjHandleControlClass	
-----------------------------------------------------------------------------*/

@class GrObjHandleControlClass, GenControlClass;

@message void MSG_GOHC_SET_HANDLES();

typedef ByteFlags GOHCFeatures;
#define	GOHCF_SMALL_HANDLES 0x08
#define	GOHCF_MEDIUM_HANDLES 0x04
#define	GOHCF_LARGE_HANDLES 0x02
#define GOHCF_INVISIBLE_HANDLES	0x01

#define GOHC_DEFAULT_FEATURES (GOHCF_SMALL_HANDLES | GOHCF_MEDIUM_HANDLES | \
 				GOHCF_LARGE_HANDLES | GOHCF_INVISIBLE_HANDLES)
#define GOHC_DEFAULT_TOOLBOX_FEATURES 0

@default GCI_output = (TO_APP_TARGET);
@default GI_states = (@default | GS_ENABLED);

@endc

/*-----------------------------------------------------------------------------
	GrObjRotateControlClass	
-----------------------------------------------------------------------------*/
@class GrObjRotateControlClass, GenControlClass;

typedef ByteFlags GrObjRotateControlFeatures;		/* CHECKME */
#define GORCF_45_DEGREES_CW	(0x80)
#define GORCF_90_DEGREES_CW	(0x40)
#define GORCF_135_DEGREES_CW	(0x20)
#define GORCF_180_DEGREES	(0x10)
#define GORCF_135_DEGREES_CCW	(0x08)
#define GORCF_90_DEGREES_CCW	(0x04)
#define GORCF_45_DEGREES_CCW	(0x02)
#define GORCF_CUSTOM_ROTATION	(0x01)

@message void MSG_GORC_ROTATE(WWFixed degrees = cx.dx);
/*
 * 	Outputs a MSG_GO_ROTATE to the target grobjs
 * 
 * 	PASS:		degrees - WWFixed rotation
 */


@message void MSG_GORC_CUSTOM_ROTATE();

#define GROBJ_ROTATE_CONTROL_DEFAULT_FEATURES 		0x00ff

@default GCI_output = (TO_APP_TARGET);

@endc

/*-----------------------------------------------------------------------------
	GrObjScaleControlClass	
-----------------------------------------------------------------------------*/
@class GrObjScaleControlClass, GenControlClass;

@message void MSG_GOSC_SCALE_HORIZONTALLY(WWFixed degrees = dx.cx);
@message void MSG_GOSC_SCALE_VERTICALLY(WWFixed degrees = dx.cx);
@message void MSG_GOSC_CUSTOM_SCALE();

typedef ByteFlags GrObjScaleControlFeatures;
#define GOSCF_HALF_WIDTH	0x0010
#define GOSCF_HALF_HEIGHT	0x0008
#define GOSCF_DOUBLE_WIDTH	0x0004
#define GOSCF_DOUBLE_HEIGHT	0x0002
#define GOSCF_CUSTOM_SCALE	0x0001

#define GROBJ_SCALE_CONTROL_DEFAULT_FEATURES	0x001f

@default GCI_output = (TO_APP_TARGET);

@endc

/*-----------------------------------------------------------------------------
	GrObjSkewControlClass	
-----------------------------------------------------------------------------*/
@class GrObjSkewControlClass, GenControlClass;

@message void MSG_GOSC_SKEW_HORIZONTALLY(WWFixed degrees = dx.cx);
@message void MSG_GOSC_SKEW_VERTICALLY(WWFixed degrees = dx.cx);
@message void MSG_GOSC_CUSTOM_SKEW();

typedef ByteFlags GrObjSkewControlFeatures;
#define GOSCF_LEFT		0x0010
#define GOSCF_RIGHT		0x0008
#define GOSCF_UP		0x0004
#define GOSCF_DOWN		0x0002
#define GOSCF_CUSTOM_SKEW	0x0001

#define GROBJ_SKEW_CONTROL_DEFAULT_FEATURES	0x001f

@default GCI_output = (TO_APP_TARGET);

@endc

/*-----------------------------------------------------------------------------
	GrObjTransformControlClass
-----------------------------------------------------------------------------*/
@class GrObjTransformControlClass, GenControlClass;

@message void MSG_GOTC_UNTRANSFORM();

typedef ByteFlags GOTransformCFeatures;
#define GOTCF_UNTRANSFORM 0x01

#define GOTransformC_DEFAULT_FEATURES (GOTCF_UNTRANSFORM)

@default GCI_output = (TO_APP_TARGET);

@endc

/*-----------------------------------------------------------------------------
	GrObjHideShowControlClass	
-----------------------------------------------------------------------------*/
@class GrObjHideShowControlClass, GenControlClass;

@message void MSG_GOHSC_HIDE();
@message void MSG_GOHSC_SHOW();

typedef ByteFlags GOHSCFeatures;
#define GOHSCF_HIDE	0x02
#define GOHSCF_SHOW	0x01

#define GOHSC_DEFAULT_FEATURES (GOHSCF_HIDE | GOHSCF_SHOW)

@default GCI_output = (TO_APP_TARGET);
@default GI_states = (@default | GS_ENABLED);

@endc

/*-----------------------------------------------------------------------------
	GrObjDraftModeControlClass	
-----------------------------------------------------------------------------*/
@class GrObjDraftModeControlClass, GenControlClass;

@message void MSG_GODMC_SET_DRAFT_MODE_STATUS(GrObjDrawFlags draftMode = cx);

typedef ByteFlags GODMCFeatures;
#define GODMCF_DRAFT_MODE	0x01

#define GODMC_DEFAULT_FEATURES (GODMCF_DRAFT_MODE)

@default GCI_output = (TO_APP_TARGET);

@endc


/*-----------------------------------------------------------------------------
	GrObjCustomShapeControlClass	
-----------------------------------------------------------------------------*/
@class GrObjCustomShapeControlClass, GenControlClass;

@message void MSG_GOCSC_CREATE_POLYGON();
@message void MSG_GOCSC_CREATE_STAR();

typedef ByteFlags GOCSCFeatures;		/* CHECKME */
/* 4 bits unused */
#define GOCSCF_NUM_POLYGON_SIDES	(0x08)
#define GOCSCF_POLYGON_RADIUS	(0x04)
#define GOCSCF_NUM_STAR_POINTS	(0x02)
#define GOCSCF_STAR_RADII	(0x01)

#define GOCSC_DEFAULT_FEATURES (0x0f)

@default GCI_output = (TO_APP_TARGET);
@default GI_states = (@default | GS_ENABLED);

@endc

/*-----------------------------------------------------------------------------
	GrObjCustomDuplicateControlClass	
-----------------------------------------------------------------------------*/
@class GrObjCustomDuplicateControlClass, GenControlClass;

@message void MSG_GOCDC_CUSTOM_DUPLICATE();

typedef ByteFlags GOCDCFeatures;
#define GOCDCF_REPETITIONS	0x10
#define GOCDCF_MOVE		0x08
#define GOCDCF_SCALE		0x04
#define GOCDCF_ROTATE		0x02
#define GOCDCF_SKEW		0x01

#define GOCDC_DEFAULT_FEATURES (GOCDCF_REPETITIONS | GOCDCF_MOVE | \
				GOCDCF_ROTATE | GOCDCF_SCALE | GOCDCF_SKEW)

@default GCI_output = (TO_APP_TARGET);
@default GII_type = GIT_PROPERTIES;
@default GII_visibility = GIV_DIALOG;

@endc


/*-----------------------------------------------------------------------------
	GrObjGradientFillControlClass	
-----------------------------------------------------------------------------*/
@class GrObjGradientFillControlClass, GenControlClass;

@message void MSG_GOGFC_SET_GRADIENT_TYPE(GrObjGradientType gradientType = cl);
@message void MSG_GOGFC_SET_NUMBER_OF_GRADIENT_INTERVALS(word nIntervals = dx);

typedef ByteFlags GrObjGradientFillControlFeatures;
#define GOGFCF_HORIZONTAL_GRADIENT	0x0010
#define GOGFCF_VERTICAL_GRADIENT	0x0008
#define GOGFCF_RADIAL_RECT_GRADIENT	0x0004
#define GOGFCF_RADIAL_ELLIPSE_GRADIENT	0x0002
#define GOGFCF_NUM_INTERVALS		0x0001

#define GOGFC_DEFAULT_FEATURES (GOGFCF_HORIZONTAL_GRADIENT | \
				GOGFCF_VERTICAL_GRADIENT | \
				GOGFCF_RADIAL_RECT_GRADIENT | \
				GOGFCF_RADIAL_ELLIPSE_GRADIENT | \
				GOGFCF_NUM_INTERVALS)

@default GCI_output = (TO_APP_TARGET);

@endc

/*-----------------------------------------------------------------------------
	GrObjAlignToGridControlClass
-----------------------------------------------------------------------------*/
@class GrObjAlignToGridControlClass, GenControlClass;

@message void MSG_GOATGC_ALIGN_TO_GRID(AlignToGridType type = cl);

typedef ByteFlags GOATGCFeatures;
#define GOATGCF_ALIGN_TO_GRID	0x01

#define GOATGC_DEFAULT_FEATURES (GOATGCF_ALIGN_TO_GRID)
#define GOATGC_DEFAULT_TOOLBOX_FEATURES 	0

@default GII_type = (GIT_COMMAND);
@default GCI_output = (TO_APP_TARGET);

@endc
/*------------------------------------------------------------------------
		GrObjAlignDistributeControlClass
------------------------------------------------------------------------*/
@class GrObjAlignDistributeControlClass, GenControlClass;

typedef WordFlags GrObjAlignDistributeControlFeatures;
#define	GOADCF_ALIGN_LEFT 0x8000
#define	GOADCF_ALIGN_CENTER_HORIZONTALLY 0x4000
#define	GOADCF_ALIGN_RIGHT 0x2000
#define	GOADCF_ALIGN_WIDTH 0x1000

#define	GOADCF_ALIGN_TOP 0x800
#define	GOADCF_ALIGN_CENTER_VERTICALLY 0x400
#define	GOADCF_ALIGN_BOTTOM 0x200
#define	GOADCF_ALIGN_HEIGHT 0x100

#define	GOADCF_DISTRIBUTE_LEFT 0x80
#define	GOADCF_DISTRIBUTE_CENTER_HORIZONTALLY 0x40
#define	GOADCF_DISTRIBUTE_RIGHT 0x20
#define	GOADCF_DISTRIBUTE_WIDTH 0x10

#define	GOADCF_DISTRIBUTE_TOP 0x8
#define	GOADCF_DISTRIBUTE_CENTER_VERTICALLY 0x4
#define	GOADCF_DISTRIBUTE_BOTTOM 0x2
#define	GOADCF_DISTRIBUTE_HEIGHT 0x1

#define GOADC_DEFAULT_FEATURES	(GrObjAlignDistributeControlFeatures)

@default GCI_output = (TO_APP_TARGET);
@default GII_type = GIT_PROPERTIES;
@default GII_visibility = GIV_DIALOG;

@endc
/*-----------------------------------------------------------------------------
	GrObjArcControlClass	
-----------------------------------------------------------------------------*/
@class GrObjArcControlClass, GenControlClass;

@message void MSG_GOAC_SET_START_ANGLE(WWFixed degrees = dx.cx);
@message void MSG_GOAC_SET_END_ANGLE(WWFixed degrees = dx.cx);
@message void MSG_GOAC_SET_ARC_CLOSE_TYPE(ArcCloseType closeType = cx);

typedef ByteFlags GOArcCFeatures;
#define GOACF_START_ANGLE	0x8
#define GOACF_END_ANGLE		0x4
#define GOACF_PIE_TYPE		0x2
#define GOACF_CHORD_TYPE	0x1

#define GOArcC_DEFAULT_FEATURES	(GOACF_START_ANGLE | GOACF_END_ANGLE | \
					GOACF_PIE_TYPE | GOACF_CHORD_TYPE)
#define GOArcC_DEFAULT_TOOLBOX_FEATURES 0

@default GCI_output = (TO_APP_TARGET);

@endc

/*-----------------------------------------------------------------------------
	GrObjBitmapToolControlClass	
-----------------------------------------------------------------------------*/
@class GrObjBitmapToolControlClass, VisBitmapToolControlClass;
@endc

/*-----------------------------------------------------------------------------
	GrObjToolControlClass	
-----------------------------------------------------------------------------*/
@class GrObjToolControlClass, GenControlClass;

@message void MSG_GOTC_SET_TOOL(word toolIndex = cx);

typedef WordFlags GOTCFeatures;
#define	GOTCF_PTR 		0x0800
#define	GOTCF_ROTATE_PTR	0x0400
#define	GOTCF_ZOOM		0x0200
#define	GOTCF_TEXT		0x0100
#define	GOTCF_LINE		0x0080
#define	GOTCF_RECT		0x0040
#define	GOTCF_ROUNDED_RECT	0x0020
#define	GOTCF_ELLIPSE		0x0010
#define	GOTCF_ARC		0x0008
#define	GOTCF_POLYLINE		0x0004
#define	GOTCF_POLYCURVE		0x0002
#define	GOTCF_SPLINE		0x0001

#define GOTC_DEFAULT_FEATURES (GOTCF_PTR | GOTCF_ROTATE_PTR | GOTCF_ZOOM | \
					GOTCF_TEXT | GOTCF_LINE | GOTCF_RECT | \
					GOTCF_ROUNDED_RECT | GOTCF_ELLIPSE | \
					GOTCF_ARC | GOTCF_POLYLINE | \
					GOTCF_POLYCURVE | GOTCF_SPLINE)

#define GOTC_DEFAULT_TOOLBOX_FEATURES (GOTC_DEFAULT_FEATURES)

    @vardata word ATTR_GROBJ_TOOL_CONTROL_POSITION_FOR_ADDED_TOOLS;

@default GCI_output = (TO_APP_TARGET);

@endc

/*-----------------------------------------------------------------------------
	GrObjToolItemClass	
-----------------------------------------------------------------------------*/
@class GrObjToolItemClass, GenItemClass;

typedef struct {
	word 		TICASID_pad;
	ClassStruct	*TICASID_class;
	word		TICASID_specInitData;
} ToolItemClassAndSpecInitData;

@message ToolItemClassAndSpecInitData MSG_GOTI_GET_TOOL_CLASS(ToolItemClassAndSpecInitData *retValue = axcxdxbp);

@message void MSG_GOTI_SELECT_SELF_IF_MATCH(ClassStruct *curToolClass = cx:dx,
					    word specInitData = bp);
/*
 * 	Object selects itself as the exclusive if the passed data match
 * 	the entry's instance data.
 * 
 * 	PASS:		cx:dx = class of tool
 * 			bp = MSG_GO_SPECIFIC_INITIALIZE data
 * 
 * 	RETURN:		nothing
 */

@instance ClassStruct 	*GOTII_toolClass = NullClass;
@instance word 		GOTII_specInitData = 0;

@endc

/*-----------------------------------------------------------------------------
;	GrObjHead Class Definition
-----------------------------------------------------------------------------*/

@class	GrObjHeadClass, MetaClass;

/*----------------------------------------------------------------------------
;	GrObjHead Class Methods and Structures
-----------------------------------------------------------------------------*/

@message void MSG_GH_SET_CURRENT_TOOL(ClassStruct *toolClass = cx:dx,
					   word initData = bp);    /* XXX */
/*
 * 	Sets the current tool class and instantiates a tool of this
 * 	class for the floater object and sends the new object
 * 	MSG_GO_OBJECT_SPECIFIC_INIITIALIZE with the data passed in bp
 * 
 *  Context:	Sent to head when user clicks on a tool in the tool
 * 		palette, or when app decides change the current tool
 *  Source:	Unrestricted. Generally application.
 *  Destination:	GrObjHead.
 *  Interception:	Unlikely
 * 		
 * 
 * PASS
 * 	cx:dx - fptr to Class of tool
 * 	bp - MSG_GO_GROBJ_SPECIFIC_INITIALIZE data
 * 
 * RETURN
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GH_SET_CURRENT_TOOL_WITH_DATA_BLOCK(ClassStruct *toolClass = cx:dx,
					   word initData = bp);    /* XXX */
/*
 * 	Sets the current tool class and instantiates a tool of this
 * 	class for the floater object and sends the new object
 * 	MSG_GO_OBJECT_SPECIFIC_INIITIALIZE with the data passed in bp
 * 
 * 	* READ ME *
 * 	Sending this message will not update the UI to reflect the
 * 	current tool, so the specific guardian should be sure that
 * 	the UI is going to be updated otherwise.
 * 
 *  Context:	Sent to head when user clicks on a tool in the tool
 * 		palette, or when app decides change the current tool
 *  Source:	Unrestricted. Generally application.
 *  Destination:	GrObjHead.
 *  Interception:	Unlikely
 * 		
 * 
 * PASS
 * 	cx:dx - fptr to Class of tool
 * 	^hbp - MSG_GO_GROBJ_SPECIFIC_INITIALIZE_WITH_DATA_BLOCK data
 * 
 * RETURN
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GH_SET_CURRENT_BODY(optr bodyOD = cx:dx);
/*
 *  	Set body to be current body under head.  This body will
 * 	remain the current on until another body sets itself as
 * 	the current or this body clears itself.
 * 
 *  Context:	Sent to GrObjHead by a GrObjBody when that
 * 		body gains the target.
 *  Source:	GrObjBody.
 *  Destination:	GrObjHead.
 *  Interception:	Unlikely
 * 		
 * PASS
 * 	cx:dx - OD of body
 * 
 * RETURN
 * 	nothing
 * 	
 * DESTROYED:
 * 	ax
 */


@message void MSG_GH_CLEAR_CURRENT_BODY(optr bodyOD = cx:dx);
/*
 *  	Clear the current body if it is the passed body od.
 * 
 *  Context:	Sent to GrObjHead by a GrObjBody when the body
 * 		loses the target
 *  Source:	GrObjBody.
 *  Destination:	GrObjHead.
 *  Interception:	Unlikely
 * 
 * PASS
 * 	cx:dx - OD of body
 * 
 * RETURN
 * 	nothing
 * 	
 * DESTROYED:
 * 	ax
 */


@message void MSG_GH_CLASSED_EVENT_TO_FLOATER(hptr messageHandle = cx);
/*
 * 	Send the encapuslated method to the floater object
 * 
 * PASS
 * 	cx - recorded message handle
 * 
 * RETURN
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */



@message void MSG_GH_CLASSED_EVENT_TO_FLOATER_IF_CURRENT_BODY(hptr messageHandle = cx, optr bodyOD = dx:bp);
/*
 * 	Send the encapuslated method to the floater object if
 * 	if passed body is the current one.
 * 
 * PASS
 * 	cx - recorded message handle
 * 	dx:bp - od of body
 * 
 * RETURN
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */



@message void MSG_GH_FLOATER_FINISHED_CREATE();
/*
 * 	Notify head that the current floater has just completed
 * 	creation of a new object
 * 
 * PASS
 * 	nothing
 * 		
 * RETURN
 * 	nothing	
 * 
 * DESTROYED:
 * 	ax
 */




typedef struct {
    word	CTV_grObjSpecificData;
    word	CTV_unused;
    ClassStruct *CTV_toolClass;	
} CurrentToolValues;

@message void MSG_GH_GET_CURRENT_TOOL(CurrentToolValues *retVal = bpaxdxcx);	/* XXX */
/*
 * 	Gets the current tool class.
 * 
 *  Source:	Unrestricted.
 *  Destination:	GrObjHead.
 *  Interception:	Unlikely
 * 		
 * 
 * PASS
 * 	nothing
 * 
 * RETURN
 * 	cx:dx - fptr to Class of tool
 * 	bp - MSG_GO_GROBJ_SPECIFIC_INITIALIZE data
 * 
 * DESTROYED:
 * 	ax
 */



typedef struct {		/* CHECKME */
    ClassStruct		*GONCT_toolClass;
    word		GONCT_specInitData;
} GrObjNotifyCurrentTool;

@message void MSG_GH_SEND_NOTIFY_CURRENT_TOOL();
/*
 * 	Sends notification regarding the current tool
 * 
 *  Source:	Unrestricted.
 *  Destination:	GrObjHead.
 *  Interception:	Unlikely
 * 		
 * 
 * PASS
 * 	nothing
 * 
 * RETURN
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GH_CALL_FLOATER(EventHandle event = cx);
/*
 * 	Dispatch encapsulated message to floater and return the floaters
 * 	return values to the caller
 * 
 *  Context:	Head Utility
 *  Source:	Unrestricted
 *  Destination:  GrObjHead
 *  Interception: Unlikely
 * 
 * PASS:		
 * 		cx - encapsulated message
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GH_SET_TEXT_TOOL_FOR_SEARCH_SPELL();
/*
 * 	When the user initiates a search or a spell check we must switch
 * 	to the text tool so that they can edit any text objects that
 * 	gain the target via the search or spell
 * 
 *  Context:	On MSG_SEARCH and MSG_SPELL_CHECK
 *  Source:	GrObjBody
 *  Destination:  GrObjHead
 *  Interception: The default handler sets the tool to the MultTextGuardianClass.
 * 		If you wish differnent behaviour then subclass the message
 * 		and set a different tool class, but don't call the superclass.
 * 
 * PASS:		
 * 	nothing	
 * 		
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */

/*-----------------------------------------------------------------------------
	GrObjHeadClass Instance Data, INSTANCE DATA, instance data
-----------------------------------------------------------------------------*/

@instance ClassStruct 	*GH_currentTool = NullClass;
@instance word		GH_initializeFloaterData = 0;
@instance optr		GH_currentBody;
@instance optr		GH_floater;

@endc


/*-----------------------------------------------------------------------------
;	GrObj Class Definition
-----------------------------------------------------------------------------*/
#define ObjDerefGrObj(obj)    ObjDeref1(obj)

@class	GrObjClass, MetaClass, master;

/*
 * XXX: Doesn't really return void
 */
@importMessage MetaGrObjMessages, void MSG_GROBJ_ACTION_NOTIFICATION(
	optr grobjOD = cx:dx,
	GrObjActionNotificationType type = bp);

/*-----------------------------------------------------------------------------
;	GrObj Class Methods and Structures
-----------------------------------------------------------------------------*/


#define HANDLE_MOVE 		0
#define HANDLE_CENTER		HANDLE_MOVE
#define HANDLE_LEFT_TOP		(GOHS_HANDLE_LEFT | GOHS_HANDLE_TOP)
#define HANDLE_MIDDLE_TOP	GOHS_HANDLE_TOP
#define HANDLE_RIGHT_TOP	(GOHS_HANDLE_RIGHT | GOHS_HANDLE_TOP)
#define HANDLE_LEFT_MIDDLE	GOHS_HANDLE_LEFT
#define HANDLE_RIGHT_MIDDLE	GOHS_HANDLE_RIGHT
#define HANDLE_LEFT_BOTTOM	(GOHS_HANDLE_LEFT | GOHS_HANDLE_BOTTOM)
#define HANDLE_MIDDLE_BOTTOM	GOHS_HANDLE_BOTTOM
#define HANDLE_RIGHT_BOTTOM	(GOHS_HANDLE_BOTTOM | GOHS_HANDLE_RIGHT)

typedef ByteFlags HandleUpdateMode;
#define HUM_NOW	    	    	0
#define HUM_MANUAL  	    	1


@message void MSG_GO_GAINED_SELECTION_LIST(HandleUpdateMode hum = dl);
/*
 * 	sent to an object when it gains the selection grab
 *
 * PASS:
 * 	hum - HandleUpdateMode
 */

@message void MSG_GO_LOST_SELECTION_LIST();
/*
 * 	sent to an object when it loses the selection grab
 * PASS:
 * 	nothing
 * RETURNS:
 * 	nothing
 * 	
 * DESTROYED:
 * 	ax
 */

@message void MSG_GO_BECOME_SELECTED(HandleUpdateMode hum = dl);
/*
 * 	Tell object to join the selection list, draw it's handle ...
 * 	and otherwise become selected
 * 	
 *  Context:	GrObj Utility
 *  Source:	Unrestricted
 *  Destination:  Any grobject
 *  Interception: If you wish to place additional restrictions 
 * 		(beyond GrObjLocks) on when an object can be selected, then
 * 		subclass this message and only call your superclass if
 * 		you are allowing the object to be selected. Behaviour
 * 		that you wish to add when an object actually becomes selected
 * 		should be handle in a subclass of MSG_GO_GAINED_SELECTION_LIST.
 * 
 * PASS:
 * 	dl - HandleUpdateMode
 * 
 * RETURNS:
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */




@message void MSG_GO_TOGGLE_SELECTION();
/*
 * 	Have object switch it selection status
 * 	
 * 	
 * PASS:
 * 	nothing
 * 
 * RETURNS:
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */




@message void MSG_GO_BECOME_UNSELECTED();
/*
 * 	Notify object that it is no longer selection
 * PASS:
 * 	nothing
 * 
 * RETURN:
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */



@message void MSG_GO_UNDRAW_SPRITE(GStateHandle gstate = dx);
/*
 * static
 * 	If the object's sprite is currently drawn, then erase it
 * 	Will use either quick sprite or tools specific sprite routine
 * 
 * PASS
 * 	dx - gstate or 0
 * 
 * RETURN:
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */



@message void MSG_GO_DRAW_SPRITE(GStateHandle gstate = dx,
				 GrObjFunctionsActive funcs = bp);
/*
 * 	Draw the object's sprite unless the sprite is already drawn
 * 
 *  Context:	While handling mouse events in move,resize,rotate modes
 *  Source:	Object itself
 *  Destination:  Object itself
 *  Interception: Unlikely. To change the image of the sprite subclass
 * 		MSG_GO_DRAW_SPRITE_LINE
 * 
 * PASS:		
 * 	dx - gstate or 0
 * 	bp - GrObjFunctionsActive (GOFA_VIEW_ZOOMED)
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */

@message void MSG_GO_DRAW_SPRITE_RAW(GStateHandle gstate = dx);
/*
 * static	
 * 	Called to update sprite image during an expose event. Draws
 * 	the appropriate sprite if the spriteDrawn flag is set, otherwise
 * 	does nothing.
 * 
 * PASS:
 * 	dx - gstate 
 * 
 * RETURN
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */

@message void MSG_GO_DRAW_HANDLES(GStateHandle gstate = dx);
/*
 * 	Draws handles to indicate object is selected. Only draws
 * 	the handles if the handlesDrawn flag is NOT set.
 * 
 * PASS:
 * 	dx - gstate or 0
 * 
 * RETURN
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GO_UNDRAW_HANDLES(GStateHandle gstate = dx);
/*
 * 	Erases the handles that indicate the object is selected.
 * 	Only erases the handles if the handlesDrawn flag IS set.
 * 
 * PASS:
 * 	dx - gstate or 0
 * 
 * RETURN
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */



@message void MSG_GO_DRAW_HANDLES_RAW(GStateHandle gstate = dx);
/*
 * 	Called to update the handles during an expose event. Draws
 * 	the handles if the handlesDraw flag is set, otherwise
 * 	does nothing
 * 
 * PASS
 * 	dx - gstate
 * 
 * RETURN:
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GO_DRAW_HANDLES_FORCE(GStateHandle gstate = dx);
/*
 * 	Draw handles of the object regardless of the state of the selected
 * 	bit. But don't draw them if the are already drawn
 * 	
 * 
 * PASS:
 * 	dx - gstate or 0
 * 
 * RETURN
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GO_DRAW_HANDLES_MATCH(GStateHandle gstate = dx);
/*
 * 	Draws or undraws the handles of the object to reflect
 * 	the state of the selected bit
 * 	
 * 
 * PASS:
 * 	dx - gstate or 0
 * 
 * RETURN
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GO_DRAW_HANDLES_OPPOSITE(GStateHandle gstate = dx);
/*
 * 	Draws or undraws the handles of the object to reflect
 * 	the opposite of the selected bit
 * 	
 * 
 * PASS:
 * 	dx - gstate or 0
 * 
 * RETURN
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GO_ACTIVATE_MOVE();
/*
 * 	Sets up object for move. Does not actually start move.
 * 	Need to send a MSG_GO_START_MOVE for that
 * 
 * PASS
 * 	nothing
 * RETURN
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */




@message void MSG_GO_ACTIVATE_RESIZE();
/*
 * 	Sets up object for resize. 
 * 
 *  Context:	Usually called when user clicks on resize handle
 *  Source:	Unrestricted, generally pointer object
 *  Destination:	Any grobj object that is not within a group. 
 *  Interception:	Unlikely
 * 
 * PASS:
 * 	nothing
 * 		
 * RETURN
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */



@message void MSG_GO_ACTIVATE_ROTATE();
/*
 * 	Sets up object for rotate. Does not actually start rotate
 * 	Need to send a MSG_GO_START_ROTATE for that
 * 
 * PASS:
 * 	nothing
 * 
 * RETURN
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */



typedef ByteFlags ActivateCreateFlags;		/* CHECKME */
/*
 * notify selected objects that
 * tool is activating
 */
#define ACF_NOTIFY	(0x01)


@message void MSG_GO_ACTIVATE_CREATE(ActivateCreateFlags flags = cl);
/*
 * 	Have object activate interactive create mode for the current body.
 * 	Object needs to set its modes bits, grab the mouse, set
 * 	its pointer image and notify the
 * 	selected and editable grobjects that there is a new tool.
 * 
 * 	Create mode is the standard mode for the floater. A floater
 * 	in create mode is allowed to switch to edit mode whenever
 * 	it wants for editing objects in the document. Many
 * 	GrObjVisGuardians do this switch on MSG_GO_LARGE_START_SELECT.
 * 
 * 
 *  Context:	When a new floater is instantiated for a body or
 * 		when the floater already exists but a new body
 * 		becomes the current one.
 *  Source:	GrObjHead
 *  Destination:	Floater only
 *  Interception:	Likely. The default handler is intended for shapes.
 * 		Other grobjects such as guardians or pointers 
 * 		will need to subclass this message.
 * 
 * 
 * PASS:
 * 	cl - ActivateCreateFlags
 * 
 * RETURN
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */



@message void MSG_GO_REACTIVATE_CREATE();
/*
 * 	Prepare the floater for interactive create again. Similar
 * 	to MSG_GO_ACTIVATE_CREATE, but it doesn't need to notify
 * 	the selected and editable grobjects
 * 
 *   Context:	Sent to the floater after it has already created
 * 		a grobject and needs to be ready to create
 * 		another one.
 *  Source:	GrObjHead
 *  Destination:	Floater only
 *  Interception:	Unlikely
 * 
 * PASS:
 * 	nothing
 * 	
 * RETURNS:
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


typedef struct {		/* CHECKME */

    PointDWFixed	GOMD_point;

/* Copy of ButtonInfo */
    ButtonInfo	GOMD_buttonInfo;

/* Copy of UIFunctionsActive */
    UIFunctionsActive	GOMD_uiFA;

    GrObjFunctionsActive	GOMD_goFA;

    GStateHandle	GOMD_gstate;
} GrObjMouseData;



@message MouseReturnFlags MSG_GO_START_CHOOSE_ABS(GrObjMouseData *mouseData = ss:bp) = ax;
/*
 * 	Starts the object choosing (mainly for pointer objects)
 * 	Using absolute mouse coords
 * 
 * PASS:
 * 	ss:bp - GrObjMouseData
 *  	
 * RETURN:
 * 	ax - MouseReturnFlags
 * 
 * DESTROYED:
 * 	nothing
 */



@message MouseReturnFlags MSG_GO_START_MOVE_ABS(GrObjMouseData *mouseData = ss:bp) = ax;
/*
 * 	Starts the object moving (mainly for pointer objects)
 * 	Using absolute mouse coords
 * 
 * 
 * PASS:
 * 	ss:bp - GrObjMouseData 
 * 	
 * RETURN:
 * 	ax - MouseReturnFlags
 * 
 * DESTROYED:
 * 	nothing
 */



@message MouseReturnFlags MSG_GO_JUMP_START_MOVE(
		GrObjFunctionsActive funcs = bp,
		GStateHandle gstate = dx) = ax;
/*
 * 	Jump starts interactive move by doing an activate, start and drag stuff
 * 
 *  Context:	Quickly start an interactive move. Usually called
 * 		when user clicks on move handle
 *  Source:	Unrestricted, generally pointer object
 *  Destination:	Any grobj object that is not within a group. 
 *  Interception:	Unlikely
 * 
 * PASS:
 * 	bp - GrObjFunctionsActive
 * 	dx - gstate or 0
 * 	
 * RETURN:
 * 	ax - MouseReturnFlags
 * 	bp - same as passed, except GOFA_RULER_HAS_SEEN_EVENT set
 * 
 * DESTROYED:
 * 	nothing
 */



@message MouseReturnFlags MSG_GO_JUMP_START_RESIZE(
		GrObjFunctionsActive funcs = bp,
		GStateHandle gstate = dx) = ax;
/*
 * 	Jump starts resize by doing an activate, start and drag stuff
 * 
 *  Context:	Quickly start an interactive resize. Usually called
 * 		when user clicks on resize handle
 *  Source:	Unrestricted, generally pointer object
 *  Destination:	Any grobj object that is not within a group. 
 *  Interception:	Unlikely
 * 
 * 
 * PASS:
 * 	bp - GrObjFunctionsActive
 * 	dx - gstate or 0
 * 
 * RETURN:
 * 	ax - MouseReturnFlags
 * 
 * DESTROYED:
 * 	nothing
 */



@message MouseReturnFlags MSG_GO_JUMP_START_ROTATE(
		GrObjFunctionsActive funcs = bp,
		GStateHandle gstate = dx) = ax;
/*
 * 	Jump starts interactive rotate by doing an 
 * 	activate, start and drag stuff
 * 
 *  Context:	Quickly start an interactive rotate. Usually called
 * 		when user clicks on handle with rotate pointer
 *  Source:	Unrestricted, generally pointer object
 *  Destination:	Any grobj object that is not within a group. 
 *  Interception:	Unlikely
 * 
 * PASS:
 * 	bp - GrObjFunctionsActive
 * 	dx - Gstate or 0
 * 	
 * RETURN:
 * 	ax - MouseReturnFlags
 * 
 * DESTROYED:
 * 	nothing
 */




@message MouseReturnFlags MSG_GO_PTR_CHOOSE_ABS(GrObjMouseData *mouseData = ss:bp) = ax;
/*
 * 	Called when a ptr event is received and the object is in choose mode
 * 
 * PASS:
 * 	ss:bp - GrObjMouseData
 * 
 * RETURN:
 * 	ax - MouseReturnFlags
 * 
 * DESTROYED:
 * 	nothing
 */




@message MouseReturnFlags MSG_GO_PTR_MOVE(
	GrObjMouseData *mouseData = ss:bp) = ax;
/*
 * 	Sent to update position of mouse during an interactive move
 * 	
 * 
 *  Context:	During an interactive resize. This message 
 * 		cooresponds to an MSG_META_PTR when the object is
 * 		in move mode
 *  Source:	Unrestricted, generally pointer object
 *  Destination:	Any grobj object that is not within a group. If the
 * 		object is not currently being moved interactively
 * 		the message will be ignored.
 *  Interception:	Unlikely
 * 
 * PASS:
 * 	ss:bp = GrObjMouseData
 * 		GOMD_point - deltas to move
 * 		GOMD_gstate - gstate to draw with
 * 		GOMD_goFA - GrObjFunctionsActive
 * 
 * RETURN:
 * 	ax - MouseReturnFlags
 * 
 * DESTROYED:
 * 	nothing
 */


typedef struct {		/* CHECKME */

    PointDWFixed	GORSMD_point;
/*
	CheckHack	< (offset GORSMD_point eq 0) >
*/

    GrObjHandleSpecification	GORSMD_anchor;
    GrObjHandleSpecification	GORSMD_grabbed;

    GrObjFunctionsActive	GORSMD_goFA;

    GStateHandle	GORSMD_gstate;


/*	align		word	*/

} GrObjResizeMouseData;



@message MouseReturnFlags MSG_GO_PTR_RESIZE(
	GrObjResizeMouseData *resizeMouseData = ss:bp) = ax;
/*
 * 	Sent to update position of mouse during an interactive resize
 * 	
 * 
 *  Context:	During an interactive resize. This message 
 * 		cooresponds to an MSG_META_PTR when the object is
 * 		in resize mode
 *  Source:	Unrestricted, generally pointer object
 *  Destination:	Any grobj object that is not within a group. If the
 * 		object is not currently being resized interactively
 * 		the message will be ignored.
 *  Interception:	Unlikely
 * 		
 * 		
 * 
 * PASS:
 * 	ss:bp = GrObjResizeMouseData
 * 		GORSMD_point - deltas to resize
 * 		GORSMD_gstate - gstate to draw with
 * 		GORSMD_goFA - GrObjFunctionsActive
 * 		GORSMD_anchor - anchored handle
 * 	
 * RETURN:
 * 	ax - MouseReturnFlags
 * 
 * DESTROYED:
 * 	nothing
 */


typedef struct {		/* CHECKME */

    WWFixed	GORMD_degrees;

    GrObjHandleSpecification	GORMD_anchor;

    GrObjFunctionsActive	GORMD_goFA;

    GStateHandle	GORMD_gstate;

/*	align word	*/

} GrObjRotateMouseData;



@message MouseReturnFlags MSG_GO_PTR_ROTATE(
	GrObjRotateMouseData *rotateMouseData ss:bp) = ax;
/*
 * 	Sent to update position of mouse during an interactive rotate
 * 	
 * 
 *  Context:	During an interactive rotate. This message 
 * 		cooresponds to an MSG_META_PTR when the object is
 * 		in rotate mode
 *  Source:	Unrestricted, generally pointer object
 *  Destination:	Any grobj object that is not within a group. If the
 * 		object is not currently being rotate interactively
 * 		the message will be ignored.
 *  Interception:	Unlikely
 * 		
 * 
 * PASS:
 * 	ss:bp - GrObjRotateMouseData
 * 		GORMD_degrees	- amount to rotate
 *  		GORMD_anchor	- handle to rotate about
 *  		GORMD_goFA	- GrObjFunctionsActive
 *  		GORMD_gstate	- gstate to draw sprite with..
 * 
 * RETURN:
 * 	ax - MouseReturnFlags
 * 
 * DESTROYED:
 * 	nothing
 */





@message MouseReturnFlags MSG_GO_PTR_MOVE_ABS(
	GrObjMouseData *mouseData = ss:bp) = ax;
/*
 * 	Sent when a ptr event is received and the object is in move mode.
 * 	Uses absolute mouse position.
 * 
 * PASS:
 *  	ss:bp = GrObjMouseData
 * 
 * RETURN:
 * 	ax - MouseReturnFlags
 * 
 * DESTROYED:
 * 	nothing
 */





@message MouseReturnFlags MSG_GO_END_CHOOSE_ABS(
	GrObjMouseData *mouseData = ss:bp) = ax;
/*
 * 	Sent when an end select event is received and the object is in 
 * 	choose mode. 
 * 
 * PASS:
 * 	ss:bp - GrObjMouseData
 * 
 * RETURN:
 * 	ax - MouseReturnFlags
 * 
 * DESTROYED:
 * 	nothing
 */



@message MouseReturnFlags MSG_GO_END_MOVE_ABS(
	GrObjMouseData *mouseData = ss:bp) = ax;
/*
 * 	Sent when an end move copy event is received and the object is in 
 * 	move mode. 
 * 
 * PASS:
 * 	ss:bp - GrObjMouseData
 * 
 * RETURN:
 * 	ax - MouseReturnFlags
 * 
 * DESTROYED:
 * 	nothing
 */




@message MouseReturnFlags MSG_GO_END_MOVE(
	GrObjMouseData *mouseData = ss:bp) = ax;
/*
 * 	Sent when an end move copy event is received and the object is in 
 * 	move mode. 
 * 
 * PASS:
 * 	ss:bp - GrObjMouseData
 * 
 * RETURN:
 * 	ax - MouseReturnFlags
 * 
 * DESTROYED:
 * 	nothing
 */




@message MouseReturnFlags MSG_GO_END_RESIZE(
	GrObjResizeMouseData *resizeMouseData = ss:bp) = ax;
/*
 * 	Sent to complete an interactive resize on an object
 * 
 * 
 *  Context:	At the end of an interactive resize. This message 
 * 		cooresponds to an MSG_META_END_SELECT when the object is
 * 		in resize mode
 *  Source:	Unrestricted, generally pointer object
 *  Destination:	Any grobj object that is not within a group. If the
 * 		object is not currently being resized interactively
 * 		the message will be ignored.
 *  Interception:	Possible. Generally call superclass first then perform
 * 		additional action, such as vis guardians sending
 * 		a notify geometry valid to their vis wards.
 * 
 * 
 * PASS:
 * 	ss:bp = GrObjResizeMouseData
 * 		GORSMD_point - deltas to resize
 * 		GORSMD_anchor - anchored handle
 * 		GORSMD_grabbed - grabbed handle
 * 		GORSMD_gstate - gstate to draw with
 * 		GORSMD_goFA - GrObjFunctionsActive
 * 
 * RETURN:
 * 	ax - MouseReturnFlags
 * 
 * DESTROYED:
 * 	nothing
 */




@message MouseReturnFlags MSG_GO_END_ROTATE(
	GrObjRotateMouseData *rotateMouseData ss:bp) = ax;
/*
 * 	Sent to complete an interactive rotate of an object
 * 
 * 
 *  Context:	At the end of an interactive rotate. This message 
 * 		cooresponds to an MSG_META_END_SELECT when the object is
 * 		in rotate mode
 *  Source:	Unrestricted, generally pointer object
 *  Destination:	Any grobj object that is not within a group. If the
 * 		object is not currently being rotated interactively
 * 		the message will be ignored.
 *  Interception:	Possible. Generally call superclass first then perform
 * 		additional action, such as vis guardians sending
 * 		a notify geometry valid to their vis wards.
 * 
 * PASS:
 * 	ss:bp - GrObjRotateMouseData
 * 
 * RETURN:
 * 	ax - MouseReturnFlags
 * 
 * DESTROYED:
 * 	nothing
 */





@message void MSG_GO_CLEAR();
/*
 * 	Tell grobject to destroy itself in an undoable fashion. 
 * 	It will remove itself from the body or group if necessary, 
 * 	release grabs, etc. The object itself will not actually be
 * 	destroyed until its undo action is freed.
 * 
 *  Context:	GrObj Utility
 *  Source:	Unrestricted
 *  Destination:  Any grobject
 *  Interception: Unlikely. If grobject has any extra data that must be
 * 		freed it should do so on MSG_META_FINAL_OBJ_FREE
 * 		
 * PASS:		
 * 	nothing
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */



@message void MSG_GO_INVERT_HANDLES(GStateHandle gstate = dx);
/*
 * 	Invert of handles of selected object
 * 
 * PASS:	
 * 	dx - gstate
 * 
 * RETURN
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


typedef struct {		/* CHECKME */
    WWFixed	GTM_e11;
    WWFixed	GTM_e12;
    WWFixed	GTM_e21;
    WWFixed	GTM_e22;
} GrObjTransMatrix;

typedef struct {		/* CHECKME */
    PointDWFixed	BI_center;
    WWFixed	BI_width;
    WWFixed	BI_height;
    GrObjTransMatrix	BI_transform;
/*	word	align	*/
} BasicInit;

@message void MSG_GO_INIT_BASIC_DATA(BasicInit *initData = ss:bp);
/*
 * 	Have object fill out its basic instance data from the
 * 	passed structure and calculate the remaining data
 * 	from it.
 *  
 * PASS
 * 	ss:bp - BasicInit
 * 
 * RETURN
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */

@message void MSG_GO_FLIP_HORIZ();
/*
 *	Flip object about its vertical axis.
 *
 *	Context:	GrObj Utility
 *	Source:		Unrestricted
 *	Destination:	Any GrObject
 *	Interception:	Unlikely
 *
 */

@message void MSG_GO_FLIP_VERT();
/*
 * 	Flip object about its horizontal axis.
 *
 *	Context:	GrObj Utility
 *	Source:		Unrestricted
 *	Destination:	Any GrObject
 *	Interception:	Unlikely
 *
 */

@message void MSG_GO_ROTATE(	 		/* XXX */
	GrObjHandleSpecification center = bp,
	WWFixedAsDWord 	         angle = dx.cx);
/*
 *	Rotate object x degrees.
 *
 *
 *	Context:	GrObj Utility
 *	Source:		Unrestricted
 *	Destination:	Any GrObject
 *	Interception:	Unlikely
 *
 *	Passed:	angle		Angle of rotation, degrees counterclockwise
 *		center		Which corner of object is acting as center of rotation
 *
 */


@message void MSG_GO_UNTRANSFORM();
/*
 *	Untransforms a grobj by setting its transformation matrix = I
 *
 *
 *	Context:	GrObj Utility
 *	Source:		Unrestricted
 *	Destination:	Any GrObject
 *	Interception:	Unlikely
 *
 */


@message void MSG_GO_MOVE(	 		/* XXX */
	PointDWFixed 	_far *distance = ss:bp);
/*
 *	Move an object relative by the passed distance.
 *
 *	Context:	GrObj Utility
 *	Source:		Unrestricted
 *	Destination:	Any GrObject
 *	Interception:	Unlikely
 *
 *	Passed:	distance	Amount to move object in parent's coordinates
 */

@message void MSG_GO_MOVE_CENTER_ABS(	 	/* XXX */
	PointDWFixed	_far *location = ss:bp);
/*
 *	Move object's center to the passed location.
 *
 *	Context:	GrObj Utility
 *	Source:		Unrestricted
 *	Destination:	Any GrObject
 *	Interception:	Unlikely
 *
 *	Passed: location 	Location to move object's center to w/in parent
 */

typedef ByteEnum CenterLeftRightWidth;		/* CHECKME */
#define CLRW_CENTER	0x0
#define CLRW_LEFT	0x1
#define CLRW_RIGHT	0x2
#define CLRW_WIDTH	0x3

typedef ByteEnum CenterTopBottomHeight;		/* CHECKME */
#define CTBH_CENTER	0x0
#define CTBH_TOP	0x1
#define CTBH_BOTTOM	0x2
#define CTBH_HEIGHT	0x3

typedef ByteFlags AlignType;		/* CHECKME */
#define AT_ALIGN_X	(0x80)
#define AT_DISTRIBUTE_X	(0x40)
#define CenterLeftRightWidth	(0x20 | 0x10)
#define CenterLeftRightWidth_OFFSET	4

#define AT_ALIGN_Y	(0x08)
#define AT_DISTRIBUTE_Y	(0x04)
#define CenterTopBottomHeight	(0x02 | 0x01)
#define CenterTopBottomHeight_OFFSET	0

typedef struct {		/* CHECKME */
/* AP_x and AP_y should be first */
    DWFixed	AP_x;
    DWFixed	AP_y;
    DWFixed	AP_spacingX;
    DWFixed	AP_spacingY;
    AlignType	AP_type;
} AlignParams;



@message void MSG_GO_ALIGN(AlignParams *alignParams = ss:bp);
/*
 * 	???
 * 
 * PASS
 * 	ss:bp = AlignParams
 * 
 * RETURN
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */

typedef ByteFlags AlignToGridType;		/* CHECKME */
#define ATGT_LEFT	(0x20)
#define ATGT_H_CENTER	(0x10)
#define ATGT_RIGHT	(0x08)
#define ATGT_TOP	(0x04)
#define ATGT_V_CENTER	(0x02)
#define ATGT_BOTTOM	(0x01)


@message void MSG_GO_ALIGN_TO_GRID(AlignToGridType type = cl);
/*
 * 	???
 * 
 * PASS
 * 	cl = AlignToGridType
 * 
 * RETURN
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */



@message void MSG_GO_SEND_ANOTHER_TOOL_ACTIVATED();
/*
 * 	Sent to grobject to have it send MSG_GO_ANOTHER_TOOL_ACTIVATED
 * 	to selected grobjects and edit and mouse grab
 * 
 *  Context:	Object generally sends this message when
 * 		handling MSG_GO_ACTIVATE_CREATE
 *  Source:	Floater
 *  Destination:	Floater
 *  Interception:	The default handler assumes the grobject is a shapes
 * 		Objects, such as guardians, pointer, whatever, need
 * 		to subclass this message and do the correct notification.
 * 		In this case the superclass should not be called
 * 
 * PASS:
 * 	nothing
 * 
 * RETURN:
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */

/*
 * Provides basic information about tool activating that most selected and
 * edited grobjects will be able to use to determine whether to remain
 * selected or edited.
 */

typedef ByteFlags AnotherToolActivatedFlags;		/* CHECKME */
/*
 * A pointer tool intended to word
 * on the normal move and resize
 * handles of an object
 */
#define ATAF_STANDARD_POINTER	(0x04)
/*
 * A shape drawing tool, rectangle
 * ellipse...		
 */
#define ATAF_SHAPE	(0x02)
/* A vis guardian object */
#define ATAF_GUARDIAN	(0x01)


@message void MSG_GO_ANOTHER_TOOL_ACTIVATED(optr callerOD = cx:dx,
				    AnotherToolActivatedFlags flags = bp);
/*
 * 	Sent to selected grobjects when another tool is activated.
 * 	Receiving object decides whether to drop selection or
 * 	show an edit indicator based on tool activating
 * 
 *  Context:	Object generally sends this message when
 * 		handling MSG_GO_ACTIVATE_CREATE
 *  Source:	Floater
 *  Destination:	Any grobj object
 *  Interception:	The default handler assumes the grobject is a shape
 * 		and drops the selection unless the activating
 * 		tool is a standardPointer. Objects that can be
 * 		edited, such as guardians, will want to subclass
 * 		this message. 
 * 
 * PASS:
 * 	cx:dx - od of caller
 * 	bp - AnotherToolActivatedFlags
 * 
 * RETURN:
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */



@message void MSG_GO_SPECIAL_RESIZE_CONSTRAIN(
		GrObjHandleSpecification grObjHandleSpec = cl);	/* XXX */
/*
 * 	Examines the information in the sprite instance data
 * 	which represents what the object will look like next.
 * 	If the resulting size,shape etc is not what we want
 * 	this routine should modify the sprite data appropriately
 * 
 * 	NOTE: this message has an associated GrObjMessageOptimizationFlags
 * 	bit. If you wish to subclass this message, you will need to 
 * 	set this bit in your object, otherwise the default handler
 * 	will be called directly.
 * 
 *  Context:	Sent to object during handling of MSG_GO_PTR_RESIZE, just
 * 		before new sprite is to be drawn. Only sent if
 * 		GOAF_SPECIAL_RESIZE_CONSTRAIN bit is set.
 *  Source:	Object itself
 *  Destination:  Object itself
 *  Interception: There is no default handler
 * 
 * PASS:		
 * 	cl - GrObjHandleSpecification of anchor		
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */



@message optr MSG_GO_DUPLICATE_FLOATER(optr bodyOD = cx:dx) = cx:dx;
/*
 *  	Duplicate the floater in a block that is returned from the
 * 	body via MSG_GB_GET_BLOCK_FOR_ONE_GROBJ. 
 * 
 * 
 *  Context:	When duplicate of floater is being added to the body.
 *  Source: 	Unrestricted, usually the body
 *  Destination:	The floater object
 *  Interception: If objects has instance data, chunks, other blocks that
 * 		need to be initialized or otherwise copied then
 * 		you must subclass this message and call your superclass
 * 		first. 
 * 
 * PASS
 * 	cx:dx - OD of body
 * 
 * RETURN
 * 	cx:dx - OD of new object
 * 
 * DESTROYED:
 * 	ax
 */



@message void MSG_GO_GRAB_MOUSE();
/*
 * 	Grab the mouse
 * 
 * PASS
 * 	nothing
 * RETURN
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GO_RELEASE_MOUSE();
/*
 * 	Release the mouse
 * 
 * PASS
 * 	nothing
 * RETURN
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */



@message Boolean MSG_GO_UNGROUPABLE() = carry;
/*
 *       	Determine if object consists of collection of objects in a
 * 	group that can be broken up into the indivdual objects
 * 
 * 
 * PASS
 * 	nothing
 * 
 * RETURN
 * 	stc - ungroupable
 * 	clc - groupable
 * 
 * DESTROYED:
 * 	ax
 */

#if 0		/* done in Objects/bitmapC.goh now */
typedef struct {		/* CHECKME */
    DWFixed	RDWF_left;
    DWFixed	RDWF_top;
    DWFixed	RDWF_right;
    DWFixed	RDWF_bottom;
} RectDWFixed;
#endif

typedef struct {		/* CHECKME */
    RectDWFixed	BRD_rect;
/*
	CheckHack	< (offset BRD_rect eq 0) >
*/
    GStateHandle	BRD_destGState;
    GStateHandle	BRD_parentGState;
/*
 * if zero, the rectangle
 * has not been initialized
 * It is generally ignored
 * except by groups
 */
    word	BRD_initialized;
							
} BoundingRectData;


@message void MSG_GO_GET_BOUNDING_RECTDWFIXED(
	BoundingRectData *retValue = ss:bp);
/*
 *       	Calculate and return the RectDWFixed that bounds the object
 * 	in the destination gstate coordinate system.
 * 
 * PASS
 * 	ss:bp - BoundingRectData
 * 		BRD_destGState
 * 		BRD_parentGState
 * 
 * RETURN
 * 	ss:bp - BoundingRectData
 * 		BRD_rect	
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GO_CALC_PARENT_DIMENSIONS();
/*
 *       	Have object recalcutate it's document coord width and height
 * 	using normalTransform, line width and such
 * 
 * PASS
 * 	nothing
 * 
 * RETURN
 * 	document dimensions set
 * 	
 * DESTROYED:
 * 	ax
 */




@message void MSG_GO_INIT_CREATE(PointDWFixed *origin = ss:bp);
/*
 *   Have object initialize its instance data for interactive creation
 * 
 *  Context:	Sent by object to itself in response to a receiving
 * 		a MSG_META_START_SELECT when in create mode.
 *  Source:	Generally sent by object to itself 
 *  Destination:	Any grobj object that has yet to be created.
 *  Interception:	Unlikely. 
 * 
 * PASS
 * 	ss:bp - PointDWFixed - location to start create from
 * 
 * RETURN
 * 
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */



/***************************************************************************/
@message void MSG_GO_NOTIFY_GROBJ_VALID(); 	/* XXX */
/* 
 * Notify object that it is ready for action. It's got a normalTransform
 * with valid position, size, etc, info and it has any attributes it 
 * needs.
 *
 */

typedef struct {
	WWFixed	RWWF_left;
	WWFixed RWWF_top;
	WWFixed RWWF_right;
	WWFixed RWWF_bottom;
} RectWWFixed;

typedef ByteEnum EvaluatePositionRating;		/* CHECKME */
#define	EVALUATE_NONE		0x0
#define	EVALUATE_SUB_LOW	0x1
#define	EVALUATE_LOW		0x2
#define	EVALUATE_SUB_MEDIUM	0x3
#define	EVALUATE_MEDIUM		0x4
#define	EVALUATE_SUB_HIGH	0x5
#define	EVALUATE_HIGH		0x6


typedef struct {
	GrObjHandleSpecification hitHandle;
	EvaluatePositionRating	evaluation;
} PositEvalAndHitHandle;

@message PositEvalAndHitHandle MSG_GO_EVALUATE_PARENT_POINT_FOR_HANDLE(
	PointDWFixed *parentCoord = ss:bp) = ax;
/*
 * 	Determine if one of the handles of the object would be hit
 * 	by the passed point
 * 
 *  Context:	Usually called as direct action of user clicking with
 * 		the pointer tool. 
 *  Source:	Unrestricted, generally the floater
 *  Destination:	Any grobj object. The message will be ignored if the
 * 		object's GOTM_HANDLES_DRAWN flag is not set
 *  Interception:	Possible. If object doesn't have normal 9 handles, such
 * 		as a line with only 3, it should subclass this message
 * 		and not call its superclass
 * 
 * PASS
 * 	ss:bp - PointDWFixed in PARENT
 * 
 * RETURN
 * 	al - EVALUATE_NONE - handles not hit
 * 		ah - destroyed
 * 	al - EVALUATE_HIGH - handle hit
 * 		ah - GrObjHandleSpecification of hit handle
 * 
 * 	dx - 0 ( blank EvaluatePositionNotes)
 * 
 * DESTROYED:
 * 	nothing
 */




@message void MSG_GO_INVERT_GROBJ_SPRITE(GStateHandle gstate = dx);
/*
 * 	Invert objects sprite
 * 
 * PASS
 * 	dx - gstate to draw or 0
 * 
 * RETURN
 * 	nothing
 * 
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GO_INVERT_GROBJ_NORMAL_SPRITE(GStateHandle gstate = dx);
/*
 * 	Invert normal image of object as if it were the sprite.
 * 	Used when interatively modifying groups
 * 
 * PASS
 * 	dx - gstate or 0
 * 
 * RETURN
 * 	nothing
 * 
 * 
 * DESTROYED:
 * 	ax
 */




@message void MSG_GO_INVALIDATE();
/*
 * 	Invalidate the bounding box of the object
 * 
 * 	NOTE: this message has an associated GrObjMessageOptimizationFlags
 * 	bit. If you wish to subclass this message, you will need to 
 * 	set this bit in your object, otherwise the default handler
 * 	will be called directly.
 * 
 *  Context:	GrObj Utility
 *  Source:	Unrestricted
 *  Destination:  Any grobject
 *  Interception: If you subclass this message you must set
 * 		GOMOF_INVALIDATE in the GOI_msgOptFlags field in
 * 		the object's instance data
 * 
 * PASS:		
 * 	nothing
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */



@message void MSG_GO_GET_DW_PARENT_BOUNDS(RectDWord *bounds = ss:bp); /* XXX */
/*
 * 	Get RectDWord bounds of object in PARENT coord system
 * 
 * 	NOTE: this message handler is not used internally so subclassing
 * 	it will do nothing. It is merely provided as an external interface
 * 
 * PASS
 * 	ss:bp - RectDWord
 * 
 * RETURN
 * 	ss:bp - RectDWord
 * 
 * DESTROYED:
 * 	ax
 */



@message void MSG_GO_GET_DWF_PARENT_BOUNDS(RectDWFixed *bounds = ss:bp);
/*
 * 	Get DWFixed bounds of object in PARENT coordinate system
 * 
 * 	NOTE: this message handler is not used internally so subclassing
 * 	it will do nothing. It is merely provided as an external interface
 * 
 * PASS
 * 	ss:bp - RectDWFixed
 * 
 * RETURN
 * 	ss:bp - RectDWFixed
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GO_GET_DWF_SELECTION_HANDLE_BOUNDS_FOR_TRIVIAL_REJECT(
	RectDWord *retValue = ss:bp); /* XXX */
/*
 * 	Get extended DWFixed objects bounds in document coordinates. 
 * 	The extension will cover things hanging off the object likes
 *        its handles. It is intended for trivially rejecting pointer 
 * 	events and clicks over handles of selected objects
 * 
 * 	For some objects, like rotated ellipses this bounds calculation
 * 	is non trivial, so they will just return the entire graphics system
 * 	as the bounds.
 * 	
 * 	This message can only be sent to objects not in groups. GrObjs
 * 	inside groups can't be selected, so they don't have handles. Even
 * 	if they did, this routine is not prepared to map the handle size 
 * 	from DOCUMENT coords into PARENT coords.
 * 
 * 	NOTE: this message has an associated GrObjMessageOptimizationFlags
 * 	bit. If you wish to subclass this message, you will need to 
 * 	set this bit in your object.
 * 	
 * PASS
 * 	ss:bp - RectDWFixed
 * 
 * RETURN
 * 	ss:bp - RectDWFixed
 * 
 * DESTROYED:
 * 	ax
 */

@message void MSG_GO_GET_WWF_PARENT_BOUNDS(RectWWFixed *retValue = ss:bp);
/*
 * 	Returns the RectWWFixed that surrounds the children in
 * 	PARENT coordinate system.
 * 
 * 	Only children in groups are guaranteed to have 
 * 	bounds that can be expressed in WWFixed so this
 * 	message can only be sent to children in groups
 * 
 * 	NOTE: this message handler is not used internally so subclassing
 * 	it will do nothing. It is merely provided as an external interface
 * 
 * PASS
 * 	ss:bp - RectWWFixed
 * 
 * RETURN
 * 	ss:bp - RectWWFixed
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GO_GET_WWF_OBJECT_BOUNDS( 	/* XXX */
				RectWWFixed *retValue = ss:bp);
/*
 * 	Returns the RectWWFixed that surrounds the children in
 * 	OBJECT coordinate system
 * 
 * 	NOTE: this message handler is not used internally so subclassing
 * 	it will do nothing. It is merely provided as an external interface
 * 
 * PASS
 * 	ss:bp - RectWWFixed
 * 
 * RETURN
 * 	ss:bp - RectWWFixed
 * 
 * DESTROYED:
 * 	ax
 */

typedef enum {
	DONT_SELECT_AFTER_EDIT,
	SELECT_AFTER_EDIT
} AfterEditAction;		/* CHECKME */

@message void MSG_GO_BECOME_UNEDITABLE(AfterEditAction afterEditAction = cl);
/*
 * 	Tell object to release edit grab
 * 
 *  Context:	Usually called as direct action of user. Either choosing
 * 		tool of another object, clicking on a different object to
 * 		edit.
 *  Source:	Unrestricted, often the floater or object being created
 *  Destination:	Any grobj object, in generally only GrObjVisGuardians 
 * 		can actually become editable.
 *  Interception:	Unlikely
 * 
 * PASS
 * 	cl - AfterEditAction
 * 
 * RETURN
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */

typedef WordFlags EvaluatePositionNotes;		/* CHECKME */
#define EPN_PADDING	(0xfffc)
#define EPN_PADDING_OFFSET	2
/* Objects selection lock is set. */
#define EPN_SELECTION_LOCK_SET	(0x0002)
/*
 * GrObj blocks out, covers up or
 * otherwise completely obscures objects
 * underneath it at the position
 */
#define EPN_BLOCKS_LOWER_OBJECTS	(0x0001)

typedef struct {
	EvaluatePositionRating	EPRAN_rating;
	byte			EPRAN_pad1;
	word			EPRAN_pad2;
	EvaluatePositionNotes	EPRAN_notes;
	word			EPRAN_pad3;
} EvaluatePositionRatingAndNotes;

@message void MSG_GO_EVALUATE_POSITION(EvaluatePositionRatingAndNotes *retVal = axcxdxbp, PointDWFixed *point = ss:bp);
/*
 * 	Have object evaluate the passed mouse position in terms 
 * 	of selection
 * 	
 * 
 * PASS
 * 	ss:bp - PointDWFixed
 * 
 * RETURN
 * 	al - EvaluatePositionRating
 * 	dx - EvaluatePositionNotes
 * 
 * DESTROYED:
 * 	ah
 */



@message void MSG_GO_EVALUATE_PARENT_POINT_FOR_SELECTION(EvaluatePositionRatingAndNotes *retVal = axcxdxbp, PointDWFixed *point = ss:bp);
/*
 * 	Have object evaluate the passed point in terms 
 * 	of selection. The point is in the PARENT's coordinate system
 * 
 *  Context:	Varied. Generally used when determine which object to
 * 		select from a mouse click
 *  Source:	Unrestricted
 *  Destination:	Any grobj object
 *  Interception:	Very likely. Most grobj object's are unique in their
 * 		rating of a point. It is unlikely that you will need
 * 		to call your superclass
 * 		
 * 		
 * PASS
 * 	ss:bp - PointDWFixed in PARENT coordinate system
 * 
 * RETURN
 * 	al - EvaluatePositionRating
 * 	dx - EvaluatePositionNotes
 * 
 * 
 * DESTROYED:
 * 	ah
 */

@message void MSG_GO_GET_CENTER(PointDWFixed *center = dx:bp); /* XXX */
/*
 * 	Return center of object
 * 
 * PASS
 * 	ss:bp - PointDWFixed
 * 
 * RETURN
 * 	ss:bp - PointDWFixed with center in it
 * 	
 * DESTROYED:
 * 	ax
 */

@message void MSG_GO_INIT_TO_DEFAULT_ATTRS(); 	/* XXX */
/*
 * Have object initialize its attributes to the current defaults
 */

@message void MSG_GO_DRAW(
	GStateHandle gstate = bp,
	DrawFlags drawFlags = cl,
	GrObjDrawFlags grObjDrawFlags = dx);

@message MouseReturnFlags MSG_GO_LARGE_START_SELECT(
	GrObjMouseData *mouseData = ss:bp) = ax;

@message MouseReturnFlags MSG_GO_LARGE_START_MOVE_COPY(
	GrObjMouseData *mouseData = ss:bp) = ax;

@message MouseReturnFlags MSG_GO_LARGE_END_SELECT(
	GrObjMouseData *mouseData = ss:bp) = ax;

@message MouseReturnFlags MSG_GO_LARGE_END_MOVE_COPY(
	GrObjMouseData *mouseData = ss:bp) = ax;

@message MouseReturnFlags MSG_GO_LARGE_DRAG_SELECT(
	GrObjMouseData *mouseData = ss:bp) = ax;

@message MouseReturnFlags MSG_GO_LARGE_DRAG_MOVE_COPY(
	GrObjMouseData *mouseData = ss:bp) = ax;

@message MouseReturnFlags MSG_GO_LARGE_PTR(
	GrObjMouseData *mouseData = ss:bp) = ax;

typedef struct {		/* CHECKME */
/* OD of group object */
    optr	AATGD_group;
/*
 * Value to subtract from center of child to position it correctly
 */
    PointDWFixed	AATGD_centerAdjust;

} AfterAddedToGroupData;

@message void MSG_GO_AFTER_ADDED_TO_GROUP(AfterAddedToGroupData *data = ss:bp);
/*
 * 	Sent to an object after it has been added to a group
 * 
 * PASS:
 * 	ss:bp - AfterAddedToGroupData
 * 
 * RETURN
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */



@message void MSG_GO_BEFORE_REMOVED_FROM_GROUP();
/*
 * 	Sent to an object just before it is removed from a group
 * 
 * PASS:
 * 	nothing
 * 
 * RETURN
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */



@message void MSG_GO_AFTER_ADDED_TO_BODY(); 	/* XXX */
/*
 * Sent to an object after it has been added to the body.
 *
 *	Context:	Sent to object that has just been added to body.
 *	Source:		GrObjBody only.
 *	Destination:	Any GrObj.
 *	Interception:	Possible.  Call super class before doing own processing
 *
 */

@message void MSG_GO_BEFORE_REMOVED_FROM_BODY(); 	/* XXX */
/*
 * 	Sent to an object just before it is removed from the body
 * 
 *  Context:	Sent to object that just before it is removed from body
 *  Source:	Body only
 *  Destination:	Any grobj object that has been added to body
 *  Interception:	Possible. Call super class after doing own processing.
 * 		Example, VisGuardian intercepts this message
 * 		to visually remove its ward from the body
 */

@message void MSG_GO_SET_AREA_ATTR( 	/* XXX  */
	GrObjBaseAreaAttrElement 	_far *attr = ss:bp);
/*
 *	Set the area attributes of the object.
 *
 *	Context:	GrObjUtility
 *	Source:		Unrestricted
 *	Destination:	Any grobj.  If the object has no area attributes,
 *			ignore the message.
 *	Interception:	Unlikely
 */

@message void MSG_GO_SET_AREA_COLOR(	 	/* XXX  */
	byte 	red = cl,
	byte 	green = ch,
	byte 	blue = dl);
/*
 *	Set the area color of the object.
 *	
 *	Context: 	GrObj Utility.
 *	Source:		Unrestricted.
 *	Destination:	Any GrObj.  If the object has no area atttributes
 *			it will ignore the message.
 *	Interception:	Unlikely.
 */

@message void MSG_GO_SET_AREA_MASK(	 	/* XXX */
	SysDrawMask 	mask = cl);
/*
 *	Set the area mask of the object.
 *
 *	Context:	GrObj Utility.
 *	Source:		Unrestricted.
 *	Destination:	Any GrObj.  If the object has no area attributes,
 *			then it will ignore this message.
 *	Interception: 	Unlikely.
 */

@message void MSG_GO_SET_AREA_DRAW_MODE( 	/* XXX */
	MixMode 	mode = cl);
/*
 *	Set the draw mode of the object in the area structure. The
 *	draw mode is actually used for both the line and area 
 *	drawing.
 *
 *	Context: 	GrObj Utility
 *	Source:		Unrestricted:
 *	Destination:	Any GrObj.  If the object has no area attributes,
 *			then it will ignore this message.
 *	Interception: 	Unlikely.
 */

@message void MSG_GO_SET_TRANSPARENCY(	 	/* XXX */
	byte 	transparent = cl );
/*
 *	Set the area info of the object.
 *
 *	Context: 	GrObj Utility
 *	Source:		Unrestricted:
 *	Destination:	Any GrObj.  If the object has no area attributes,
 *			then it will ignore this message.
 *	Interception: 	Unlikely.
 */

@message void MSG_GO_SET_LINE_ATTR(	 	/* XXX */
	GrObjBaseLineAttrElement 	_far *attr = ss:bp);
/*
 *	Set the line attributes of the object.
 *
 *	Context: 	GrObj Utility
 *	Source:		Unrestricted:
 *	Destination:	Any GrObj.  If the object has no line attributes,
 *			then it will ignore this message.
 *	Interception: 	Unlikely.
 */


@message void MSG_GO_SET_LINE_COLOR(	 	/* XXX */
	byte 	red = cl,
	byte	green = ch,
	byte 	blue = dl);
/* 
 *	Set the line color of the object.
 *
 *	Context: 	GrObj Utility
 *	Source:		Unrestricted:
 *	Destination:	Any GrObj.  If the object has no line attributes,
 *			then it will ignore this message.
 *	Interception: 	Unlikely.
 */


@message void MSG_GO_SET_LINE_MASK(SystemDrawMask drawMask = cl); /* XXX */


@message void MSG_GO_SET_LINE_END(	 	/* XXX */
	LineEnd 	end = cl);
/*
 *	Set the line end of the object.
 *
 *	Context: 	GrObj Utility
 *	Source:		Unrestricted:
 *	Destination:	Any GrObj.  If the object has no line attributes,
 *			then it will ignore this message.
 *	Interception: 	Unlikely.
 */

@message void MSG_GO_SET_LINE_JOIN(	 	/* XXX */
	LineJoin 	join = cl);
/*
 *	Set the line join of the object.
 *
 *	Context: 	GrObj Utility
 *	Source:		Unrestricted:
 *	Destination:	Any GrObj.  If the object has no line attributes,
 *			then it will ignore this message.
 *	Interception: 	Unlikely.
 */

@message void MSG_GO_SET_LINE_STYLE(	 	/* XXX */
	LineStyle 	style = cl);
/*
 *	Set the line style of the object.
 *
 *
 *	Context: 	GrObj Utility
 *	Source:		Unrestricted:
 *	Destination:	Any GrObj.  If the object has no line attributes,
 *			then it will ignore this message.
 *	Interception: 	Unlikely.
 */

@message void MSG_GO_SET_LINE_WIDTH(	 	/* XXX */
	WWFixed 	width = dx.cx);
/*
 *	Set the line width of the object.
 *
 *	Context: 	GrObj Utility
 *	Source:		Unrestricted:
 *	Destination:	Any GrObj.  If the object has no area attributes,
 *			then it will ignore this message.
 *	Interception: 	Unlikely.
 */

@message void MSG_GO_SET_LINE_MITER_LIMIT( 	/* XXX */
 	WWFixed 	miterLimit = dx.cx);
/*
 *	Set the miter limit for the object's corners.
 *
 *	Context: 	GrObj Utility
 *	Source:		Unrestricted:
 *	Destination:	Any GrObj.  If the object has no line attributes,
 *			then it will ignore this message.
 *	Interception: 	Unlikely.
 */

@message word MSG_GO_GET_GROBJ_AREA_TOKEN() = cx;
/*
 * 	Return the index of the GrObjBaseAreaAttrElement for this object
 * 
 * 
 *  Context:	GrObj utility
 *  Source:	Unrestricted
 *  Destination:	Any grobj object. If the object has no area attributes
 * 		it will not respond to the message.
 *  Interception:	Unlikely
 * 		
 * 
 * PASS:
 * 	nothing
 * 
 * RETURN
 * 	cx - token	
 * 	must always return carry set
 * 	
 * 
 * DESTROYED:
 * 	ax
 */


@message word MSG_GO_GET_GROBJ_LINE_TOKEN() = cx;
/*
 * 	Return the index of the GrObjBaseLineAttrElement for this object
 * 
 * 
 *  Context:	GrObj utility
 *  Source:	Unrestricted
 *  Destination:	Any grobj object. If the object has no line attributes
 * 		it will not respond to the message.
 *  Interception:	Unlikely
 * 		
 * 
 * PASS:
 * 	nothing
 * 
 * RETURN
 * 	cx - token	
 * 	must always return carry set
 * 	
 * DESTROYED:
 * 	ax
 */



@message void MSG_GO_SET_GROBJ_AREA_TOKEN(word token = cx);
/*
 * 	Set the area token for the object
 * 
 * 
 *  Context:	GrObj utility
 *  Source:	Unrestricted
 *  Destination:	Any grobj object. 
 *  Interception:	Unlikely
 * 		
 * 
 * PASS:
 * 	cx - token (CA_NULL_ELEMENT for return to base style)	
 * 
 * RETURN
 * 	nothing
 * 	
 * DESTROYED:
 * 	ax
 */



@message void MSG_GO_SET_GROBJ_LINE_TOKEN(word token = cx);
/*
 * 	Set the line token for the object
 * 
 * 
 *  Context:	GrObj utility
 *  Source:	Unrestricted
 *  Destination:	Any grobj object.
 *  Interception:	Unlikely
 * 		
 * 
 * PASS:
 * 	cx - token (CA_NULL_ELEMENT for return to base style)
 * 
 * RETURN
 * 	nothing
 * 	
 * DESTROYED:
 * 	ax
 */


@message void MSG_GO_SUBST_AREA_TOKEN(
	word oldToken = cx,
	word newToken = dx,
	Boolean updateReferenceCounts = bp);
/*
 * 	If GrObj's area token matches the passed "old" token, replace it
 * 	with the new token, updating the reference counts if specified
 * 
 *  Context:	GrObj Utility		
 *  Source:	Most likely from the style substitution callack
 *  Destination:	GrObj
 *  Interception:	Unlikely
 * 
 * PASS:		cx - old area token
 * 		dx - new area token
 * 		bp - nonzero if GrObjs should update reference counts
 * 			to both the old and new tokens
 * 
 * RETURN:	nothing
 * 
 * DESTROYED:	ax
 */

 

@message void MSG_GO_SUBST_LINE_TOKEN(
	word oldToken = cx,
	word newToken = dx,
	Boolean updateReferenceCounts = bp);
/*
 * 	If GrObj's line token matches the passed "old" token, replace it
 * 	with the new token, updating the reference counts if specified
 * 
 *  Context:	GrObjBody Utility		
 *  Source:	Most likely from the style substitution callack
 *  Destination:	GrObjBody
 *  Interception:	Unlikely
 * 
 * PASS:		cx - old line token
 * 		dx - new line token
 * 		bp - nonzero if GrObjs should update reference counts
 * 			to both the old and new tokens
 * 
 * RETURN:	nothing
 * 
 * DESTROYED:	ax
 */



typedef struct {		/* CHECKME */
    PointDWFixed	GOHAD_anchor;
/*
	CheckHack	< (offset GOHAD_anchor eq 0) >
*/
    GrObjHandleSpecification	GOHAD_handle;
} GrObjHandleAnchorData;




@message void MSG_GO_GET_ANCHOR_DOCUMENT(GrObjHandleAnchorData *data = ss:bp);
/*
 * :	Get coords of anchor point specified by 
 * 	GrObjHandleSpecification in DOCUMENT coords
 * 
 * PASS:
 * 	ss:bp - GrObjHandleAnchorData
 * 		GOHAD_handle - GrObjHandleSpecification
 * 
 * RETURN
 * 	ss:bp - GrObjHandleAnchorData
 * 		GOHAD_anchor
 * 
 * DESTROYED:
 * 	ax
 */


@message Boolean MSG_GO_BECOME_EDITABLE() = carry;
/*
 * 	Tell object to grab the edit grab
 * 
 *  Context:	Usually called as direct action of user. Either clicking on
 * 		object with edit tool or hitting edit menu item when one
 * 		object is selected.
 *  Source:	Unrestricted, often the floater or the body.
 *  Destination:	Any grobj object, in generally only GrObjVisGuardians 
 * 		can actually become editable.
 *  Interception:	Unlikely
 * 
 * PASS:
 * 	nothing
 * 
 * RETURNS:
 * 	stc - became editable
 * 	clc - didn't become editable, most likely due to edit lock
 * 
 * DESTROYED:
 * 	ax
 */



@message void MSG_GO_DRAW_EDIT_INDICATOR(GStateHandle gstate = dx);
/*
 * 	Draws something to indicate to the user that
 * 	this object is being edited
 * 
 *  Context:	When the objects is becoming editable
 *  Source:	Unrestricted, often the object itself on MSG_GO_BECOME_EDITABLE
 *  Destination:	Any grobj object that can be edited. If the object
 * 		is not currently being edited the message will be
 * 		ignored
 *  Interception:	Unlikely
 * 
 * 
 * PASS:
 * 	dx - gstate
 * 
 * RETURN
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GO_UNDRAW_EDIT_INDICATOR(GStateHandle gstate = dx);
/*
 * 	Erase the something that indicates to the user that
 * 	this object is being edited
 * 
 *  Context:	When the objects is becoming uneditable
 *  Source:	Unrestricted, often the object itself on MSG_GO_BECOME_UNEDITABLE
 *  Destination:	Any grobj object that can be edited. If the object's
 * 		edit marker is not currently drawn the message will be
 * 		ignored.
 *  Interception:	Unlikely
 * 
 * 
 * PASS:
 * 	dx - gstate
 * 
 * RETURN
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */



@message void MSG_GO_DRAW_EDIT_INDICATOR_RAW(GStateHandle gstate = dx);
/*
 * 	Called to update the something that indicates to the
 * 	user that this object is being edited during an expose event. Draws
 * 	the something if the indicatorDrawn flag is set, otherwise
 * 	does nothing
 * 
 *  Context:	During an expose event
 *  Source:	Unrestricted, most often the graphic body
 *  Destination:	Any grobj object that is being edited. If the object
 * 		is not being edited the message is ignored
 *  Interception:	Unlikely.
 * 
 * PASS
 * 	dx - gstate
 * 
 * RETURN:
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */



@message void MSG_GO_INVERT_EDIT_INDICATOR(GStateHandle gstate = dx);
/*
 * 	Invert the edit indicator
 * 
 *  Context:	When the edit indicator needs to be drawn/erased 
 *  Source:	Unrestricted, most often the object itself
 *  Destination:	Any grobj object that can be edited. 
 *  Interception:	Possible. If the object has its own special edit
 * 		indicator it should invert its indicator and not
 * 		call its superclass
 * 
 * PASS:	
 * 	dx - gstate
 * 
 * RETURN
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */



@message void MSG_GO_GROBJ_SPECIFIC_INITIALIZE(word initData = bp);
/*
 * 	Do any initialization that is necessary after the object
 * 	has been instantiated.
 * 
 *  Context:	Send to floater object immediately after it is 
 * 		instantiated. Must be sent to object before 
 * 		MSG_GO_ACTIVATE_CREATE
 *  Source:	GrObjHead
 *  Destination:	Only the floater
 *  Interception:	Likely. There is no default behaviour for this function.
 * 		Each object that expects special initialize data
 * 		must have a handler
 * 		
 * PASS:	
 * 	bp - object specific initialization data
 * 
 * RETURN
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GO_GROBJ_SPECIFIC_INITIALIZE_WITH_DATA_BLOCK(hptr initData = bp);
/*
 * 	Do any initialization that is necessary after the object
 * 	has been instantiated.
 * 
 *  Context:	Send to floater object immediately after it is 
 * 		instantiated. Must be sent to object before 
 * 		MSG_GO_ACTIVATE_CREATE
 *  Source:	GrObjHead
 *  Destination:	Only the floater
 *  Interception:	Likely. There is no default behaviour for this function.
 * 		Each object that expects special initialize data
 * 		must have a handler
 * 		
 * PASS:	
 * 	^hbp - object specific initialization data
 * 
 * RETURN
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */




@message void MSG_GO_APPLY_ATTRIBUTES_TO_GSTATE(GStateHandle gstate = bp);
/*
 * 	Have object apply any attributes that is possess in its
 * 	instance data to the passed gstate
 * 	
 *  Context:	Unlimited
 *  Source:	Anything
 *  Destination:	Any grobj object
 *  Interception:	Likely. There is no default handler for this message. Any
 * 		object that adds new attributes to its instance dataa
 * 		should subclass this message
 * 		
 * PASS:	
 * 	bp - gstate
 * 
 * RETURN
 * 	bp - gstate with attributes applied
 * 
 * DESTROYED:
 * 	ax
 */




@message word MSG_GO_SET_ACTION_NOTIFICATION_OUTPUT(	/* XXX */
	optr object = cx:dx,	/* Object which will receive notification */
	Message messageNumber = bp) = bp;
/*
 *	Specify the message and output descriptor for grobjects to
 * 	send notification to when an action is performed on them.
 * 	Many uses of the grobj will have no notification. 
 *
 *	When a GrObj sends out a notification it will put its OD in cx:dx
 *	and an appropriate GrObjActionNotificationType in bp.
 *
 *	The object which will receive notification must either be in the
 * 	same VM file as this GrObj or in a resource, because the GrObj will
 *	need to relocate and unrelocate it.
 *
 *	Sending MSG_GO_SET_ACTION_NOTIFICATION will remove any suspension of
 *	action notifications.
 *
 *	Context:	GrObj Utility
 *	Source:		Unrestricted
 *	Destination:	Any GrObject
 *	Interception:	Unlikely
 *	
 *	PASS:	object		optr of object to notify
 *				NULL to clear the output
 *		messageNumber 	message to send
 */

@message word MSG_GO_NOTIFY_ACTION(			/* XXX */
	GrObjActionNotificationType action = bp) = bp;
/*
 * 	Message that an object sends to itself to notify it that an action has
 *	been performed.The default handler sends the action notification output
 *	(see MSG_GO_SET_ACTION_NOTIFICATION_OUTPUT and 
 *	MSG_GB_SET_ACTION_NOTIFICATION_OUTPUT).If the GrObj doesnt have its own
 *	output, it will attempt to use the GrObjBody's action output.
 *
 *	Context:	GrObj Utility
 *	Source:		Generally the object itself
 *	Destination:	Any GrObject
 *	Interception:	Unlikely
 *
 *	Passed: action		What sort of action was performed
 */

@message void MSG_GO_NUDGE(				/* XXX */
	sword 	xDistance = cx,
	sword 	yDistance = dx);
/*
 *	Move an object a multipule of current device units (i.e. pixels).  This is
 *	generally used for moving an object one pixel on screen regardless of the
 *	scale factor in the view.
 *
 *	Context:	GrObj Utility
 *	Source:		Unrestricted, generally the UI or object itself.
 *	Destination:	Any GrObject
 *	Interception:	Unlikely
 *
 *	Passed: xDistance	number of device units to move horizontally
 *		yDistance	number of device units to move vertically
 */


@message void MSG_GO_SET_SIZE(			/* XXX */
	PointWWFixed 	_far *size = ss:bp);
/*
 *	Set the width and height of the object in points. The dimensions are
 *	calculated by mapping the objects' corners into document coords and
 *	calculating the distances between them. The center of the selection
 *	handles of a rectangle represent the corners mapped into document
 *	coords. The line thickness is not included in this calculation.
 *
 *	Context:	GrObj Utility
 *	Source:		Unrestricted, generally the UI or object itself.
 *	Destination:	Any GrObject
 *	Interception:	Unlikely
 *
 *	Passed: size 		Desired size 
 */

@message void MSG_GO_SET_POSITION(			/* XXX */
	PointDWFixed 	_far *location = ss:bp);
/*
 * 	Set the position of the upper left of a GrObj. The position set is in
 *	document coords unless the GrObj is in a group. Then the position is
 *	relative to the upper left of the group. I the GrObj has been rotated/
 *	skewed/transformed this sets the location of the selection handle that
 *	was originally at the upper left of the GrObj.
 *
 *	Context:	GrObj Utility
 *	Source:		Unrestricted, generally the UI or object itself.
 *	Destination:	Any GrObject
 *	Interception:	Unlikely
 *
 *	Passed:	location	New coordinates 
 */

@message dword MSG_GO_CHANGE_LOCKS(GrObjLocks setBits = cx,
				   GrObjLocks clearBits = dx) = cx.dx;

typedef struct {
	WWFixed 	GOSD_xScale;
	WWFixed 	GOSD_yScale;
} GrObjScaleData; 	

typedef struct {
	GrObjScaleData		 GOASD_scale; 		/* Scale factors */
	GrObjHandleSpecification GOASD_scaleAnchor;	/* Center of scaling */
	/* align word */
} GrObjAnchoredScaleData;

@message void MSG_GO_SCALE( 	/* XXX */
	GrObjAnchoredScaleData	_far *params = ss:bp);	
/*
 *	Scale a GrObj.
 *
 *	Context:	GrObj Utility
 *	Source:		Unrestricted
 *	Destination:	Any GrObject
 *	Interception:	Unlikely
 *
 *	Passed: params		A structure containing scale factors, and which handle
 *				to use as the center of scaling.
 */

typedef WordFlags GrObjBaseAreaAttrDiffs;
#define GOBAAD_MULTIPLE_ELEMENT_TYPES 		0x8000
#define GOBAAD_MULTIPLE_STYLE_ELEMENTS 		0x4000
#define GOBAAD_MULTIPLE_COLORS			0x2000
#define GOBAAD_MULTIPLE_BACKGROUND_COLORS	0x1000
#define GOBAAD_MULTIPLE_MASKS			0x0800
#define GOBAAD_MULTIPLE_PATTERNS		0x0400
#define GOBAAD_MULTIPLE_DRAW_MODES		0x0200
#define GOBAAD_MULTIPLE_INFOS			0x0100
#define	GOBAAD_MULTIPLE_GRADIENT_END_COLORS	0x0080
#define	GOBAAD_MULTIPLE_GRADIENT_TYPES		0x0040
#define	GOBAAD_MULTIPLE_GRADIENT_INTERVALS	0x0020
#define GOBAAD_FIRST_RECIPIENT 0x0001 
				/* A grobj knows that it's the first one to
				 * receive this data buffer if this flag is
				 * set (and should clear it). */
#define FUTURE_AREA_ATTR_ELEMENT_SIZE	50
typedef struct {
	GrObjBaseAreaAttrElement 	GOFAAE_base;
	byte 			GOFAAE_future[FUTURE_AREA_ATTR_ELEMENT_SIZE];
} GrObjFullAreaAttrElement;

typedef struct {
	GrObjBaseAreaAttrElement 	GNAAC_areaAttr;
	GrObjBaseAreaAttrDiffs		GNAAC_areaAttrDiffs;
} GrObjNotifyAreaAttrChange;

@message void MSG_GO_COMBINE_AREA_NOTIFICATION_DATA( 	/* XXX */
	Handle /* GrObjNotifyAreaAttrChange */	change = cx);
/*
 *	Combine this GrObj's attributes with the passed structure.
 *
 *	Context:	GrObj Utility
 *	Source:		Unrestricted
 *	Destination:	Any GrObject
 *	Interception:	Unlikely
 *
 *	Passed: change		Handle of structure containing changes.
 */

typedef ByteFlags GrObjGradientAttrDiffs;		/* CHECKME */
#define GGAD_MULTIPLE_END_COLORS	(0x80)
#define GGAD_MULTIPLE_TYPES	(0x40)
#define GGAD_MULTIPLE_INTERVALS	(0x20)
/* 4 bits unused */
/*
 * A grobj knows that it's the first
 * one to receive this data buffer if
 * this flag is set (and should clear it)
 */
#define GGAD_FIRST_RECIPIENT	(0x01)

typedef struct {		/* CHECKME */
    GrObjGradientType	GONGAC_type;
/* ending color red byte */
    byte	GONGAC_endR;
/* ending color green byte */
    byte	GONGAC_endG;
/* ending color blue byte */
    byte	GONGAC_endB;
    word	GONGAC_numIntervals;
    GrObjGradientAttrDiffs	GONGAC_diffs;
} GrObjNotifyGradientAttrChange;

@message void MSG_GO_COMBINE_GRADIENT_NOTIFICATION_DATA( 	/* XXX */
	Handle /* GrObjNotifyGradientAttrChange */	change = cx);
/*
 *	Combine this GrObj's attributes with the passed structure.
 *
 *	Context:	GrObj Utility
 *	Source:		Unrestricted
 *	Destination:	Any GrObject
 *	Interception:	Unlikely
 *
 *	Passed: change		Handle of structure containing changes.
 */

typedef WordFlags GrObjBaseLineAttrDiffs;		/* CHECKME */
#define GOBLAD_MULTIPLE_STYLE_ELEMENTS	(0x8000)
#define GOBLAD_MULTIPLE_ELEMENT_TYPES	(0x4000)
#define GOBLAD_MULTIPLE_COLORS	(0x2000)
#define GOBLAD_MULTIPLE_ENDS	(0x1000)
#define GOBLAD_MULTIPLE_JOINS	(0x0800)
#define GOBLAD_MULTIPLE_WIDTHS	(0x0400)
#define GOBLAD_MULTIPLE_MASKS	(0x0200)
#define GOBLAD_MULTIPLE_STYLES	(0x0100)
#define GOBLAD_ARROWHEAD_ON_START	(0x0080)
#define GOBLAD_ARROWHEAD_ON_END	(0x0040)
#define GOBLAD_ARROWHEAD_FILLED	(0x0020)
#define GOBLAD_ARROWHEAD_FILL_WITH_AREA_ATTRIBUTES	(0x0010)
#define GOBLAD_MULTIPLE_MITER_LIMITS	(0x0008)
#define GOBLAD_MULTIPLE_ARROWHEAD_ANGLES	(0x0004)
#define GOBLAD_MULTIPLE_ARROWHEAD_LENGTHS	(0x0002)
#define GOBLAD_FIRST_RECIPIENT	(0x0001)

typedef struct {		/* CHECKME */
    GrObjBaseLineAttrElement	GNLAC_lineAttr;
    GrObjBaseLineAttrDiffs	GNLAC_lineAttrDiffs;
} GrObjNotifyLineAttrChange;

@message void MSG_GO_COMBINE_LINE_NOTIFICATION_DATA( 	/* XXX */
	Handle /*GrObjNotifyLineAttrChange */	change = cx);
/*
 *	Combine this GrObj's attributes with the passed structure.
 *
 *	Context:	GrObj Utility
 *	Source:		Unrestricted
 *	Destination:	Any GrObject
 *	Interception:	Unlikely
 *
 *	Passed: change		Handle of structure containing changes.
 */

@message void MSG_GO_COMBINE_SELECT_STATE_NOTIFICATION_DATA(	/* XXX */
	Handle /* NotifySelectStateChange*/ 	change = cx);
/*
 *	Combine this GrObj's attributes with the passed structure.
 *
 *	Context:	GrObj Utility
 *	Source:		Unrestricted
 *	Destination:	Any GrObject
 *	Interception:	Unlikely
 *
 *	Passed: change		Handle of structure containing changes.
 */

typedef ByteFlags GrObjSelectionStateFlags;		/* CHECKME */
/* True if an object is being edited. */
#define GSSF_EDITING	(0x20)
/*
 * True if at least one of the objects
 * selected can be ungrouped.
 */
#define GSSF_UNGROUPABLE	(0x10)
/*
 * True if at least one of the objects
 * selected is some sort of text object
 */
#define GSSF_TEXT_SELECTED	(0x08)
/*
 * True if at least one of the objects
 * selected is some sort of bitmap object
 */
#define GSSF_BITMAP_SELECTED	(0x04)
/*
 * True if at least one of the objects
 * selected is some sort of spline object
 */
#define GSSF_SPLINE_SELECTED	(0x02)
/*
 * True if at least one of the objects
 * selected is some sort of arc object
 */
#define GSSF_ARC_SELECTED	(0x01)


typedef struct {
	word		GSS_numSelected;	/* Number of selected GrObjs */
	ClassStruct 	_far *GSS_classSelected; /* Class of selected GrObjs */
	GrObjSelectionStateFlags GSS_flags;
	GrObjAttrFlags	GSS_grObjFlags;
	GrObjLocks	GSS_locks;
} GrObjSelectionState;

typedef ByteFlags GrObjSelectionStateDiffs; /* XXX */
#define GSSD_MULTIPLE_CLASSES 0x80
#define	GSSD_MULTIPLE_ARC_CLOSE_TYPES 0x40
#define	GSSD_MULTIPLE_ARC_START_ANGLES 0x20
#define	GSSD_MULTIPLE_ARC_END_ANGLES 0x10

typedef struct {		/* CHECKME */
    GrObjSelectionState		GONSSC_selectionState;
    GrObjSelectionStateDiffs	GONSSC_selectionStateDiffs;
    GrObjAttrFlags		GONSSC_grObjFlagsDiffs;
    GrObjLocks			GONSSC_locksDiffs;
    ArcCloseType		GONSSC_arcCloseType;
    WWFixed			GONSSC_arcStartAngle;
    WWFixed			GONSSC_arcEndAngle;
} GrObjNotifySelectionStateChange;

@message void MSG_GO_COMBINE_SELECTION_STATE_NOTIFICATION_DATA( /* XXX */
	Handle /* GrObjNotifySelectionStateChange */	change = cx);
/*
 *	Combine this GrObj's attributes with the passed structure.
 *
 *	Context:	GrObj Utility
 *	Source:		Unrestricted
 *	Destination:	Any GrObject
 *	Interception:	Unlikely
 *
 *	Passed: change		Handle of structure containing changes.
 */



@message void MSG_GO_COMBINE_STYLE_NOTIFICATION_DATA(		/* XXX */
	Handle /* NotifyStyleChange */		change = cx);
/*
 *	Combine this GrObj's attributes with the passed structure.
 *
 *	Context:	GrObj Utility
 *	Source:		Unrestricted
 *	Destination:	Any GrObject
 *	Interception:	Unlikely
 *
 *	Passed: change		Handle of structure containing changes.
 */

@message void MSG_GO_COMBINE_STYLE_SHEET_NOTIFICATION_DATA(	/* XXX */
	Handle /* NotifyStyleSheetChange */	change = cx);

@message void MSG_GO_SEND_UI_NOTIFICATION( 	/* XXX */
	GrObjUINotificationTypes notifications = cx);

@message void MSG_GO_SUSPEND_ACTION_NOTIFICATION(); 	/* XXX */
/*	Prevent GrObj from sending out any action notifications. If the
 *	GrObj has no action suspension OD it will still record the 
 *	suspension and the suspension will be in place when the
 *	action output is set. 
 *	Nested suspend/unsuspend pairs are allowed.
 *	If a file is closed it will always reopen unsuspended. 
 *
 *	Context: 	GrObj Utility
 *	Source:		Unrestricted
 *	Destination:	Any GrObj
 *	Interception:	Unlikely
 */

@message void MSG_GO_UNSUSPEND_ACTION_NOTIFICATION(); 	/* XXX */
/*	Counterbalance a call to MSG_GO_SUSPEND_ACTION_NOTIFICATION.
 *	If all suspends have been balanced, the GrObj will be free
 *	to send out action notification. However, it will not send
 *	action notifications that were aborted during the suspended
 *	period. 
 *	If the GrObj is not suspended, this message is ignored.
 *
 *	Context:	GrObj Utility
 *	Source:		Unrestricted
 *	Destination:	Any GrObj
 *	Interception:	Unlikely
 *
 */

typedef struct {
	WWFixed 	GOSD_xDegrees; /* counter-clockwise */
	WWFixed 	GOSD_yDegrees; 
} GrObjSkewData;

typedef struct {
	GrObjSkewData			GOASD_degrees;
	GrObjHandleSpecification	GOASD_skewAnchor;
} GrObjAnchoredSkewData;

@message void MSG_GO_SKEW( 	/* XXX */
	GrObjAnchoredSkewData 	_far *params = ss:bp);
/*
 *	Skew a GrObj.
 *
 *	Context:	GrObj Utility.
 *	Source:		Unrestricted.
 *	Destination:	Any GrObj.
 *	Interception:	Unlikely.
 *
 *	Passed:	params		Structure containing skew amount and anchor
 *				of skew. 
 */

@message void MSG_GO_TRANSFORM( 	/* XXX */
	TransMatrix	_far *transformation = ss:bp);
/*
 *	Transform the GrObj. 
 *	This is generally used to apply a group's transformation to all
 *	the children in the group. Unlike MSG_GO_SCALE, ROTATE,...  a 
 *	handle is not anchored for the transformation. Instead the center
 *	of the GrObj is also transformed by the transformation.

 *	Context:	GrObj Utility.
 *	Source:		Unrestricted.
 *	Destination:	Any GrObj.
 *	Interception:	Unlikely.
 *
 *	Passed:	transormation 	transformation matrix.
 *				
 */

@message void MSG_GO_COMPLETE_CREATE();
/*
 * 	Complete interative create of an object. An object sends this
 * 	message to itself once it has set up its geometry and generally
 * 	cleaned up the state of its instance data. Upon handling this
 * 	message an object is expected to.
 * 	Send notify grobj valid to itself.
 * 	Calculate its parent dimensions.
 * 	Draw itself to the screen
 * 	Notify head of completed create
 * 	Send action notification
 * 	Become selected or editable
 * 
 *  Context:	Sent to object at completion of interactive create
 *  Source:	Unrestricted. Ususally sent by object to itself
 *  Destination:  Any grobject that has just finished being created.
 *  Interception: Highly likely. The default handler will not
 * 		cause the object to become selected or become editable.
 * 		Each object must subclass this message, call its super
 * 		and then make itself selected or edited. Guardians
 * 		may also wish to subclass this message so that
 * 		can reset their instance data to have the Identity matrix
 * 		in their OT_transform field		
 * 
 * PASS:		
 * 	nothing
 * 
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GO_COMPLETE_TRANSFORM(GrObjActionNotificationType type = bp);
/*
 * 	Object sends this message to itself to complete
 * 	a resize, rotate, skew or other transformation.
 * 	Object needs to calculate its parent dimensions,
 * 	adjust its position to make sure it is on the document,
 * 	invalidate itself and redraw handles if necessary.
 * 	Then send out MSG_GO_NOTIFY_ACTION to themselves.
 * 
 *  Context:	Sent at end of interactive resize, rotate, skew or
 * 		end of a static transformation ( eg.MSG_GO_ROTATE)
 *  Source:	Generally object itself
 *  Destination:  GrObject
 *  Interception: Objects, such as the SplineGuardian, needs to transform 
 * 		their points when ever a tranformation is
 * 		performed. Upon subclassing these objects should perform
 * 		their special function and then call their superclass.
 * 
 * PASS:		
 * 	bp - GrObjActionNotificationType (to be sent with MSG_GO_NOTIFY_ACTION)
 * 	
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */



@message void MSG_GO_COMPLETE_TRANSLATE(GrObjActionNotificationType type = bp);
/*
 * 	Object sends this message to itself to complete
 * 	a move or other translation.
 * 	Object needs to adjust its position to make sure 
 * 	it is on the document, invalidate itself and redraw 
 * 	handles if necessary. Then send out MSG_GO_NOTIFY_ACTION 
 * 	to themselves.
 * 
 *  Context:	Sent at end of interactive move or at the
 * 		end of a static transformation ( eg.MSG_GO_MOVE)
 *  Source:	Generally object itself
 *  Destination:  GrObject
 *  Interception: Objects such as the GrObjVisGuardian needs to have
 * 		their vis ward destroy any cached gstates when the
 * 		object is translated. They should call their superclass
 * .		and the destroy the gstate.
 * 
 * PASS:		
 * 	bp - GrObjActionNotificationType (to be sent with MSG_GO_NOTIFY_ACTION)
 * 	
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */



typedef struct {
	WWFixed 	GOGSP_height;
	WWFixed 	GOGSP_width;
} GOGetSizeParams;

@message void MSG_GO_GET_SIZE( 	/* XXX */
	GOGetSizeParams	_far *retValue = bpaxdxcx);
/*
 *	Return the width and height of the object in points. The dimensions
 *	are calculated by mapping the object's corners into document coords
 *	and calculating the distances between them. The center of the
 *	selection ahndles of a rectangle represent the corners mapped into
 *	document coords. The line thickness is not included in this
 *	calculation.
 *
 *	Context:	GrObj Utility
 *	Source:		Unrestricted, generally the UI or object itself.
 *	Destination:	Any GrObject
 *	Interception:	Unlikely
 *
 *	Passed:	retValue	Structure to hold return value
 *
 *	Return: retValue	Structure filled with size information.
 */


@message void MSG_GO_GET_POSITION( 	/* XXX */
	PointDWFixed 	_far *retValue = ss:bp);
/*
 *	Get the position of the upper left of a GrObj. The position is in
 *	document coords unless the GrObj is in a group. Then the position is
 *	relative to the upper left of the group. If the GrObj has been 
 *	rotated/skewed/transformed this gets the location of the selection
 *	handle that was originally at the upper left of the GrObj.
 *
 *	Context:	GrObj Utility
 *	Source:		Unrestricted, generally the UI or object itself.
 *	Destination:	Any GrObject
 *	Interception:	Unlikely
 *
 *	Passed: retValue	Structure to hold return value
 *
 *	Return: retValue	Structure filled with position information
 */

typedef struct {
	PointDWFixed 	GOID_position;
	WWFixed		GOID_width;
	WWFixed 	GOID_height;
} GrObjInitializeData;

@message void MSG_GO_INITIALIZE(GrObjInitializeData *data = ss:bp); /*XXX */
/*
 * Initialize position, size and default attributes of grobject
 *
 * Pass:
 *	GrObjInitializeData
 *
 * Return:
 *	nothing
 */

@message void MSG_GO_SCALE_ABOUT_PARENT_LEFT_TOP(GrObjScaleData *scaleData = ss:bp);
/*
 * 	Scales object [current matrix] [scale]. 
 *  	Obscure message which applies the scale along the PARENT axes
 * 	and keeps the left top of the PARENT bounds in the same place.
 * 	This is used in the handling of MSG_GO_INSERT_OR_DELETE_SPACE.
 * 
 *  Context:	GrObj Utility
 *  Source:	Unrestricted
 *  Destination:  Any grobject
 *  Interception: Unlikely
 * 
 * PASS:		
 * 	ss:bp - GrObjScaleData
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */



@message void MSG_GO_INSERT_OR_DELETE_SPACE(InsertOrDeleteSpaceParams *params = ss:bp);
/*
 * 	Insert or delete space in/from the grobject
 * 	MSG_VIS_LAYER_INSERT_OR_DELETE_SPACE for description of
 * 	parameters.
 * 
 *  Context:	GrObj Utility. Generally called when the body
 * 		recieves MSG_VIS_LAYER_INSERT_OR_DELETE_SPACE
 *  Source:	Unrestricted
 *  Destination:	GrObj
 *  Interception:	Unlikely.
 * 
 * PASS
 * 	ss:bp  - InsertDeleteSpaceParams
 * 
 * RETURN
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */



@message void MSG_GO_BEGIN_CREATE();
/*
 * 	Basically puts object in create mode. Sets position and other
 * 	geometry. Object is now ready to receive a start,ptr and end 
 * 	selects for use in creating itself. Undo will be turned off
 * 	until MSG_GO_END_CREATE is received. Undoing a create is
 * 	done by just deleting the object, so this prevent cluttering
 * 	up the undo chains with useless stuff
 * 		
 *  Context:	Sent to object after it has been duplicated from floater
 *  Source:	Floater
 *  Destination:  Duplicate of floater
 *  Interception: Possible. Call super class first
 * 
 * PASS:		
 * 	nothing
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


typedef WordFlags EndCreatePassFlags;		/* CHECKME */
/*
 * the UIFA_ADJUST flag was set in
 * start select that began object
 * creation.
 */
#define ECPF_ADJUSTED_CREATE	(0x0001)

typedef WordFlags EndCreateReturnFlags;		/* CHECKME */
#define ECRF_NOT_CREATING	(0x0002)	/* object was not in create mode. */
#define ECRF_DESTROYED	(0x0001)	/* object was destroyed */


@message EndCreateReturnFlags MSG_GO_END_CREATE(EndCreatePassFlags flags = cx) = cx;
/*
 * 	Bring creation to a screeching halt using whatever data
 * 	is currently stored in the object. Must turn undo back on,
 * 	it was ignored in MSG_GO_BEGIN_CREATE.
 * 
 *  Context:	Force basic drag create shapes this message is sent
 * 		upon receiving an END_SELECT while being created.
 * 		For more complex objects, such as spline, this message
 * 		is sent on double clicks and right mouse clicks.
 *  Source:	Unrestricted. Usually object itself. 
 *  Destination:  Grobject being created.
 *  Interception: Rects, ellipse,lines, etc can use the default handler, but
 * 		other objects will likely subclass this and not
 * 		call their superclass. Subclasses of this message
 * 		must send MSG_GO_SUSPEND_COMPLETE_CREATE to themselves unless
 * 		the object is destroyed.
 * 
 * PASS:		
 * 	cx - EndCreatePassFlags
 * 			
 * RETURN:	
 * 	cx - EndCreateReturnFlags
 * 
 * DESTROYED:
 * 	ax
 */



@message void MSG_GO_EVALUATE_PARENT_POINT_FOR_EDIT(EvaluatePositionRatingAndNotes *retVal = axcxdxbp, PointDWFixed *point = ss:bp);
/*
 * 	Have object evaluate the passed point in terms 
 * 	of editing. (ie could the object edit it self
 * 	at this point)(eg for a bitmap, anywhere within
 * 	its bounds, for a spline, somewhere along the spline
 * 	or drawn control points).
 * 
 *  Context:	Varied. Generally used when determine which object to
 * 		select from a mouse click
 *  Source:	Unrestricted
 *  Destination:	Any grobj object
 *  Interception:	Very likely. Most grobj object's are unique in their
 * 		rating of a point. It is unlikely that you will need
 * 		to call your superclass
 * 		
 * 		
 * PASS
 * 	ss:bp - PointDWFixed in PARENT coordinate system
 * 
 * RETURN
 * 	al - EvaluatePositionRating
 * 	dx - EvaluatePositionNotes
 * 
 * DESTROYED:
 * 	ah
 */

typedef struct {		/* CHECKME */

/*
 * Center of the object in
 * PARENT coords
 */
    PointDWFixed	OT_center;

/*
 * width of object in the
 * OBJECT coordinate system
 */
    WWFixed	OT_width;

/*
 * height of object in OBJECT
 * coordinate system.
 */
    WWFixed	OT_height;

/*
 * width of object in PARENT
 * coord. includes line
 * width and such so can
 * be used for invalidation, etc
 */
    WWFixed	OT_parentWidth;

/*
 * height of object in PARENT
 * coord. includes line
 * width and such so can
 * be used for invalidation, etc
 */
    WWFixed	OT_parentHeight;

    GrObjTransMatrix	OT_transform;

} ObjectTransform;

/*
 * 	This structure represents the subset of GrObj instance data
 * 	required to recover the object from a transfer item
 */
typedef struct {		/* CHECKME */
    GrObjAttrFlags	GODD_attrFlags;
    GrObjLocks	GODD_locks;
    word	GODD_areaToken;
    word	GODD_lineToken;
    ObjectTransform	GODD_normalTransform;
} GrObjDefiningData;


typedef struct {
	StyleSheetParams 	GTP_ssp;
	VisTextSaveStyleSheetParams    	GTP_textSSP;
	PointDWFixed	    	GTP_selectionCenterDOCUMENT;
	Handle			GTP_optBlock;
	Handle			GTP_vmFile;
	word 			GTP_curSlot;
	dword 			GTP_id;
	word 			GTP_curSize;
	word 			GTP_curPos;
} GrObjTransferParams;

@message void MSG_GO_CREATE_TRANSFER(GrObjTransferParams _far *params = ss:bp); /* XXX */
/* 
 * This message causes the GrObj to create either a VM block or a DB item in 
 * the VM override file, write any data needed to recreate the GrObj, and
 * store a 32 bit identifier in the passed tree block. 
 * Context:		Sent to object during Cut/Copy/Duplicate
 * Source:		Unrestricted
 * Destination:		Any grobj
 * Interception:	Any sublacss that requires more than just instance
 *			data to reconstruct itself will subclass this message
 *			to construct the VMChain necessary to do so.
 *
 * Note: The VM override file must be set: see VMSetThreadVMFile.
 *
 * Passed:	params	GrObjTransferParams structure
 *			VM override file set.
 * Return:	The GTP_curSlost field of params is updated to the next slot
 *			in the tree, specified by GTP_treeBlock. 
 */

@message void MSG_GO_REPLACE_WITH_TRANSFER(GrObjTransferParams _far *params = ss:bp);
/* 
 * This message causes an existing GrObj to read the passed transfer item and
 * "recreate" itself from that information.
 * Context: 		Sent to object during paste-type operations
 * Source:		Unrestricted
 * Destination:		Any GrObj
 * Interception: 	Any subclass that requires more than just instance data
 *			to reconstruct itself will subclass this message to
 *			parse the VMChain necessary to do so. 
 *
 * Note: The VM override file must be set: see VMSetThreadVMFile.
 * 
 * Passed:	params	GrObjTransferParams structure
 *			VM override file set.
 * Return:	nothing
 *
 */ 		

/*
 * MSG_GO_WRITE_INSTANCE_TO_TRANSFER --
 *
 *	This message causes the grobj to write any data needed to
 *	recreate the grobj into a transfer item.
 *	
 *	Context:	Sent to object during Cut/Copy/Duplicate
 *	Source:	    	Unrestricted
 *	Destination:  	Any grobj
 *	Interception: 	Any subclass with data necessary to recreate the object
 *	    	    	will subclass this message. The subclass will first call
 *	    	    	its superclass, then write in its extra data.
 *
 * 	Note: The VM override file must be set: see VMSetThreadVMFile.
 *	
 * 	Passed:	    *params - GrObjTransferParams structure
 *		    VM override file set.
 *	
 *	Return:	    params->GTP_curPos - updated to just past the last
 *	    	    	    	    	 written data (so superclass can
 *	    	    	    	    	 begin writing, etc.)
 */
@message void MSG_GO_WRITE_INSTANCE_TO_TRANSFER(GrObjTransferParams *params = ss:bp);

/*
 * MSG_GO_READ_INSTANCE_FROM_TRANSFER --
 *
 *	This message causes the grobj to read any data needed to
 *	recreate the grobj from a transfer item.
 *	
 *	Context:	Sent to object during paste-type operations
 *	Source:	    	Unrestricted
 *	Destination:  	Any grobj
 *	Interception: 	Any subclass with data necessary to recreate the object
 *	    	    	will subclass this message. The subclass will first call
 *	    	    	its superclass, then read in its extra data.
 *
 * 	Note: The VM override file must be set: see VMSetThreadVMFile.
 *	
 * 	Passed:	    *params - GrObjTransferParams structure
 *		    VM override file set.
 *	
 *	Return:	    params->GTP_curPos - updated to just past the last
 *	    	     	    	    	 read data (so superclass can begin
 *	    	    	    	    	 reading, etc.)
 */
@message void MSG_GO_READ_INSTANCE_FROM_TRANSFER(GrObjTransferParams *params = ss:bp);

typedef struct {
	MouseReturnFlags MRFAMI_flags;
	optr		 MRFAMI_image;
} MouseReturnFlagsAndMouseImage;

@message void MSG_GO_GET_POINTER_IMAGE(MouseReturnFlagsAndMouseImage *retVal = axcxdxbp, PointDWFixed *point = ss:bp);
/*
 * 	Return the optr of the mouse image.
 * 	
 *  Context:	Sent to object at end of every mouse event.
 *  Source:	Usually object itself
 *  Destination:  Any grobject
 *  Interception: Likely. The default pointer image is a +, if you don't
 * 		like it,subclass this message and don't call your
 * 		super class
 * 
 * PASS:		
 * 	ss:bp - PointDWFixed 
 * 
 * RETURN:	
 * 	ax - mask MRF_SET_POINTER_IMAGE
 * 	cx:dx - optr of mouse image
 * 	or
 * 	ax - mask MRF_CLEAR_POINTER_IMAGE
 * 	cx:dx - destroyed
 * 
 * DESTROYED:
 * 	see RETURN
 */



@message GrObjLocks MSG_GO_GET_LOCKS() = ax;
/*
 * 	Retrieve the GrObjLocks for the object.
 * 
 *  Context:	GrObj Utility
 *  Source:	Unrestricted
 *  Destination:  Any GrObject
 *  Interception:	Unlikely
 * 
 * PASS:		
 * 	nothing
 * 			
 * RETURN:	
 * 	ax - GrObjLocks
 * 
 * DESTROYED:
 * 	nothing
 */



@message void MSG_GO_DRAW_FG_AREA(DrawFlags drawFlags = cl, 
				GrObjDrawFlags grobjDrawFlags= bp,
				GStateHandle gstate = dx);
/*
 * 	Draw the foreground area components of an object.
 * 
 * 	NOTE: This handler does NOT set attributes or apply
 * 	the ObjectTransform. It is a mindless low level handler
 * 	that is concerned only with the shape to be drawn.
 * 
 *  Context:	GrObjClass Utility. Generally called 
 * 		during handling of MSG_GO_DRAW
 *  Source:	Unrestricted. Generally the object itself.
 *  Destination:  Any grobject. Generally the object itself.
 *  Interception: There is no default handler. Most likely every 
 * 		object will subclass this and not call their superclass.
 * 
 * PASS:		
 * 		cl - DrawFlags
 * 		bp - GrObjDrawFlags		
 * 		dx - gstate with the object's transform applied
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */




@message void MSG_GO_DRAW_BG_AREA(DrawFlags drawFlags = cl, 
				GrObjDrawFlags grobjDrawFlags= bp,
				GStateHandle gstate = dx);
/*
 * 	Draw the background area component of an object.
 * 
 * 	NOTE: This handler does NOT set attributes or apply
 * 	the ObjectTransform. It is a mindless low level handler
 * 	that is concerned only with the shape to be drawn.
 * 
 *  Context:	GrObjClass Utility. Generally called 
 * 		during handling of MSG_GO_DRAW
 *  Source:	Unrestricted. Generally the object itself.
 *  Destination:  Any grobject. Generally the object itself.
 *  Interception: Default handler draws a background rectangle.Most objects
 * 		will subclass this and not call their superclass.
 * 
 * PASS:		
 * 		cl - DrawFlags
 * 		bp - GrObjDrawFlags		
 * 		dx - gstate with object's transform applied
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */




@message void MSG_GO_DRAW_SPRITE_LINE(GStateHandle gstate = dx); /* XXX */
/*
 * 	Draw the sprite line image of an object using the 
 * 	spriteTransform.
 * 
 * 	NOTE: This handler does NOT set attributes or apply
 * 	the ObjectTransform. It is a mindless low level handler
 * 	that is concerned only with the shape to be drawn.
 * 
 *  Context:	GrObjClass Utility. Generally called 
 * 		during handling of MSG_GO_DRAW_SPRITE
 *  Source:	Unrestricted. Generally the object itself.
 *  Destination:  Any grobject. Generally the object itself.
 *  Interception: Most likely every object will subclass this and not
 * 		call their superclass.
 * 
 * PASS:		
 * 		dx - gstate
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GO_DRAW_NORMAL_SPRITE_LINE(GStateHandle gstate = dx);
/*
 * 	Draw the sprite line image of an object using the 
 * 	normalTransform.
 * 
 * 	NOTE: This handler does NOT set attributes or apply
 * 	the ObjectTransform. It is a mindless low level handler
 * 	that is concerned only with the shape to be drawn.
 * 
 *  Context:	GrObjClass Utility. Generally called 
 * 		during handling of MSG_GO_DRAW_SPRITE on objects
 * 		in a group.
 *  Source:	Unrestricted. Generally the object itself.
 *  Destination:  Any grobject. Generally the object itself.
 *  Interception: Most likely every object will subclass this and not
 * 		call their superclass.
 * 
 * PASS:		
 * 		dx - gstate
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */

@message void MSG_GO_DO_NOTHING();

@message void MSG_GO_ADD_POTENTIAL_SIZE_TO_BLOCK();
/*
 * 	Increments the potential size of this grobj's object block by
 * 	the amount of size the grobj could potentially expand to.
 * 
 *  Context:	Most likely the GrObj has just been instantiated
 *  Source:	Unrestricted
 *  Destination:  Any grobject
 *  Interception: Unlikely. You should subclass MSG_GO_GET_POTENTIAL_GROBJECT_SIZE
 * 		instead.
 * 		
 * PASS:		
 * 	nothing
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GO_SUBTRACT_POTENTIAL_SIZE_FROM_BLOCK();
/*
 * 	Decrements the potential size of this grobj's object block by
 * 	the amount of size the grobj could potentially expand to.
 * 
 *  Context:	Most likely the GrObj is about to be destroyed
 *  Source:	Unrestricted
 *  Destination:  Any grobject
 *  Interception: Unlikely. You should subclass MSG_GO_GET_POTENTIAL_GROBJECT_SIZE
 * 		instead.
 * 		
 * 		
 * PASS:		
 * 	nothing
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message ClassStruct *MSG_GO_GET_GROBJ_CLASS() = cx:dx;
/*
 * 	Returns the class representing the object's "leaf" class
 * 	according to The GrObj.
 * 
 * 	For example, if the Chart library subclassed EllipseClass,
 * 	the class tree would look like Meta->GrObj->Rect->Ellipse->ChartEllipse
 * 	This method would return EllipseClass, since that's the last
 * 	one known to GrObj.
 * 
 *  Context:	Sent by the object to itself when writing to the transfer item
 * 		so that in case a subclassing library writes the transfer
 * 		item, then goes away, we still have some class we can paste.
 *  Source:	The object itself, probably in the MSG_GO_CREATE_TRANSFER
 * 		method.
 *  Destination:  Any clipboardable grobj.
 * 
 *  Interception: DO NOT INTERCEPT THIS MESSAGE. That's the whole point,
 * 		isn't it?
 * 
 * PASS:		
 * 	nothing
 * 			
 * RETURN:	
 * 	cx:dx - a class ptr recognized by GrObj
 * 
 * DESTROYED:
 * 	ax
 */

typedef struct {		/* CHECKME */
    Message	GOUAT_freeMessage;
    Message	GOUAT_undoMessage;
} GrObjUndoAppType;


@message void MSG_GO_UNDO_REPLACE_GEOMETRY_INSTANCE_DATA(
	DBGroup group = dx,
	DBItem item = cx,
	VMFileHandle file = bp);
/*
 * 	Replace the objects instance data with the passed BasicInit data
 * 	as part of an undo operation. A new undo chain is generated first
 * 	so that this operation will be undoable.
 * 
 *  Context:	Send by object to itself while handling MSG_META_UNDO
 *  Source:	Object itself
 *  Destination:  Object itself
 *  Interception: Unlikely
 * 
 * PASS:		
 * 	dx - DB group
 * 	cx - DB item
 * 	bp - VM file handle
 * 
 * 	The referenced DBitem must contain a BasicInit structure
 * 
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */



@message void MSG_GO_GENERATE_UNDO_REPLACE_GEOMETRY_INSTANCE_DATA_ACTION();
/*
 * 	Generate an undo action for the objects current geometry
 * 	instance data
 * 
 *  Context:	Prior to any action that is undoable and changes the
 * 		objects geometry (ie MSG_GO_MOVE). Usually the object
 * 		calls MSG_GO_GENERATE_UNDO_REPLACE_GEOMETRY_INSTANCE_DATA_CHAIN
 * 		which sends this message sandwiched by MSG_GO_START_UNDO_CHAIN
 * 		and MSG_GO_END_UNDO_CHAIN
 * 
 *  Source:	Generally object itself
 *  Destination:  Generally object itself
 *  Interception: Unlikely
 * 
 * PASS:		
 * 	nothing
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GO_GENERATE_UNDO_REPLACE_GEOMETRY_INSTANCE_DATA_CHAIN(
	optr undoTextOD = cx:dx);
/*
 * 	Generate an undo chain for the objects current geometry
 * 	instance data.
 * 
 *  Context:	Prior to any action that is undoable and changes the
 * 		objects geometry (ie MSG_GO_MOVE)
 *  Source:	Generally object itself
 *  Destination:  Generally object itself
 *  Interception: Unlikely
 * 
 * PASS:		
 * 		cx:dx - optr of undo text
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */



@message void MSG_GO_CLEAR_SANS_UNDO();
/*
 * 	Tell grobject to destroy itself in an undoable fashion. 
 * 	It will remove itself from the body or group if necessary, 
 * 	release grabs, etc. Then the object will send MSG_META_OBJ_FREE
 * 	to complete its demise. This message will delete the object
 * 	even if it has the delete lock set.
 * 
 *  Context:	GrObj Utility
 *  Source:	Unrestricted
 *  Destination:  Any grobject
 *  Interception: Unlikely. If grobject has any extra data that must be
 * 		freed it should do so on MSG_META_FINAL_OBJ_FREE
 * 		
 * PASS:		
 * 	nothing
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */




@message void MSG_GO_REMOVE_FROM_BODY();
/*
 * 	Object will release any exclusives, drop selection, edit, 
 * 	remove itself from the body and generate an
 * 	undo chain to undo the removal.
 * 
 *  Context:	Generally used as part of MSG_GO_CLEAR and as
 * 		undo action for MSG_GB_ADD_GROBJ
 *  Source:	Generally object itself
 *  Destination:  Object itself
 *  Interception: Unlikely
 * 
 * PASS:		
 * 	nothing
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GO_REMOVE_FROM_GROUP();
/*
 * 	Have object remove itself from the group and generate an
 * 	undo chain to undo the removal.
 * 
 *  Context:	Generally used as part of MSG_GO_CLEAR
 *  Source:	Generally object itself
 *  Destination:  Object itself
 *  Interception: Unlikely
 * 
 * PASS:		
 * 	nothing
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */



@message void MSG_GO_RELEASE_EXCLS();
/*
 * 	Release mouse grabs, target, focus, gadget, selection, edit, etc
 * 
 *  Context:	GrObj Utilitity. Normal used when object is being cleared
 *  Source:	Unrestricted
 *  Destination:  Any grobject
 *  Interception: Unlikely
 * 
 * PASS:		
 * 	nothing
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */



@message void MSG_GO_GENERATE_UNDO_CLEAR_CHAIN();
/*
 * 	Generate an undo chain for undoing a clear.
 * 
 *  Context:	Sent when handling MSG_GO_CLEAR and as a result
 * 		of undoing and undo of a delete
 *  Source:	Object itself
 *  Destination:  Object itself
 *  Interception: Don't. Trust me.
 * 
 * PASS:		
 * 	nothing
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GO_GENERATE_UNDO_UNDO_CLEAR_CHAIN();
/*
 * 	Generate an undo chain for undoing an undo of a clear.
 * 
 *  Context:	Sent as a result of undoing a delete
 *  Source:	Object itself
 *  Destination:  Object itself
 *  Interception: Don't. Trust me.
 * 
 * PASS:		
 * 	nothing
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */



@message void MSG_GO_DEREF_A_GROBJ_AREA_TOKEN(word token = cx);
/*
 * 	Decrement the reference count for the passed area token
 * 
 *  Context:	Generally used as freeing undo action message
 *  Source:	Unrestricted
 *  Destination:  Any grobject
 *  Interception: Unlikely
 * 
 * PASS:		
 * 	cx - area token
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */



@message void MSG_GO_DEREF_A_GROBJ_LINE_TOKEN(word token = dx);
/*
 * 	Decrement the reference count for the passed line token
 * 
 *  Context:	Generally used as freeing undo action message
 *  Source:	Unrestricted
 *  Destination:  Any grobject
 *  Interception: Unlikely
 * 
 * PASS:		
 * 	cx - line token
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */



@message void MSG_GO_INVALIDATE_AREA();
/*
 * 	Invalidate object because of area attribute change.
 * 
 * 	NOTE: this message has an associated GrObjMessageOptimizationFlags
 * 	bit. If you wish to subclass this message, you will need to 
 * 	set this bit in your object, otherwise the default handler
 * 	will be called directly.
 * 
 *  Context:	When objects area attributes change
 *  Source:	Object itself
 *  Destination:  Object itself
 *  Interception: Objects without area attributes, such as lines,
 * 		should subclass this message and eat it.
 * 
 * PASS:		
 * 		nothing
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GO_INVALIDATE_LINE();
/*
 * 	Invalidate object because of line attribute change.
 * 
 * 	NOTE: this message has an associated GrObjMessageOptimizationFlags
 * 	bit. If you wish to subclass this message, you will need to 
 * 	set this bit in your object, otherwise the default handler
 * 	will be called directly.
 * 
 *  Context:	When objects line attributes change
 *  Source:	Object itself
 *  Destination:  Object itself
 *  Interception: Objects without line attributes
 * 		should subclass this message and eat it.
 * 
 * PASS:		
 * 		nothing
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GO_SUSPEND_COMPLETE_CREATE();
/*
 * 	Sends a MSG_META_SUSPEND/MSG_META_UNSUSPEND to the body around
 * 	sending MSG_GO_COMPLETE_CREATE to itself.
 * 
 *  Context:	Sent to object at completion of interactive create
 *  Source:	Unrestricted. Ususally sent by object to itself
 *  Destination:  Any grobject that has just finished being created.
 * 		i.e. After receiving MSG_GO_END_CREATE
 *  Interception: Don't. Please. Intercept MSG_GO_COMPLETE_CREATE if you
 * 		want to subclass something.
 * 
 * PASS:		
 * 	nothing
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */



typedef struct {
	GrObjOptimizationFlags	TSAOF_optFlags;
	GrObjTempModes		TSAOF_tempModes;
} GrObjTempStateAndOptFlags;

@message GrObjTempStateAndOptFlags MSG_GO_GET_TEMP_STATE_AND_OPT_FLAGS() = ax;
/*
 * 	Retrieve the GrObjTempModes for the object. Also returns
 * 	GrObjOptimizationFlags.
 * 
 *  Context:	GrObj Utility
 *  Source:	Unrestricted
 *  Destination:  Any GrObject
 *  Interception:	Unlikely
 * 
 * PASS:		
 * 	nothing
 * 			
 * RETURN:	
 * 	al - GrObjTempModes
 * 	ah - GrObjOptimizationFlags
 * 
 * DESTROYED:
 * 	nothing
 */


@message void MSG_GO_MAKE_INSTRUCTION();
/*
 * 	Make the grobject an instruction grobject. Instruction objects
 * 	are used mainly in templates. By default they do not print
 * 	and they generally are not selectable or editable
 * 
 *  Context:	GrObj Utility
 *  Source:	Unrestricted
 *  Destination:  Any grobject
 *  Interception: Unlikely
 * 
 * PASS:		
 * 	nothing
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GO_MAKE_NOT_INSTRUCTION();
/*
 * 	Make the grobject not an instruction grobject. 
 * 
 *  Context:	GrObj Utility
 *  Source:	Unrestricted
 *  Destination:  Any grobject
 *  Interception: Unlikely
 * 
 * PASS:		
 * 	nothing
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GO_SET_WRAP_TEXT_TYPE(GrObjWrapTextType type = cl);
/*
 * 	The GrObjWrapTextType for an object. The GrObjWrapTextType is
 * 	used by other applications, such as GeoWrite for wrapping text
 * 	around or inside objects
 * 
 *  Context:	GrObj Utility
 *  Source:	Unrestricted
 *  Destination:  Any grobject
 *  Interception: Unlikely
 * 
 * PASS:		
 * 			
 * 	cl - GrObjWrapTextType
 * 
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */



@message void MSG_GO_SET_PASTE_INSIDE(Boolean setPaste = cl);
/*
 *  Context:	GrObj Utility
 *  Source:	Unrestricted
 *  Destination:  Any grobject.
 *  Interception: Unlikely
 * 
 * PASS:		
 * 	cl - TRUE or FALSE
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */



@message void MSG_GO_SET_INSERT_DELETE_MOVE_ALLOWED(Boolean allowed = cl);
/*
 * 	If true then during a MSG_GO_INSERT_OR_DELETE space the object
 * 	can be moved.
 *  
 *  Context:	GrObj Utility
 *  Source:	Unrestricted
 *  Destination:  Any GrObject
 *  Interception: Unlikely
 * 
 * PASS:		
 * 	cl - TRUE/FALSE
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GO_SET_INSERT_DELETE_RESIZE_ALLOWED(Boolean allowed = cl);
/*
 * 	If true then during a MSG_GO_INSERT_OR_DELETE space the object
 * 	can be resized.
 *  
 *  Context:	GrObj Utility
 *  Source:	Unrestricted
 *  Destination:  Any GrObject
 *  Interception: Unlikely
 * 
 * PASS:		
 * 	cl - TRUE/FALSE
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GO_SET_INSERT_DELETE_DELETE_ALLOWED(Boolean allowed = cl);
/*
 * 	If true then during a MSG_GO_INSERT_OR_DELETE space the object
 * 	can be deleted.
 *  
 *  Context:	GrObj Utility
 *  Source:	Unrestricted
 *  Destination:  Any GrObject
 *  Interception: Unlikely
 * 
 * PASS:		
 * 	cl - TRUE/FALSE
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */



@message void MSG_GO_DRAW_PARENT_RECT(GStateHandle gstate = bp,
				      Boolean allowForWrap = cx);
/*
 * 	Draw the rectangle that bounds the object in PARENT coords..
 * 
 *  Context:	Generally used for drawing rectangle for 
 * 		wrapping text around when GOWTT_WRAP_AROUND_RECT is
 * 		set in object and GODF_DRAW_WRAP_TEXT_AROUND_ONLY
 * 		is passed with MSG_GO_DRAW
 *  Source:	Generally object itself
 *  Destination:  Generally object itself
 *  Interception: Unlikely
 * 
 * PASS:		
 * 	cx - non-zero the kick the rectangle out by an ammount appropriate
 * 	     for wrapping around
 * 	bp - gstate with PARENT transformation in it
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GO_NUKE_DATA_IN_OTHER_BLOCKS();
/*
 * 	Destroy any data the object stores in blocks other than its own.
 * 	Also object must decrement the interactible count to balance
 * 	all the incs is has done, otherwise the block it is in won't
 * 	get tossed.
 * 	Object MUST NOT send any message on the queue while
 * 	handling this.
 * 
 *  Context:	Generally sent as handlers for MSG_GO_CLEAR and 
 * 		MSG_GO_QUICK_TOTAL_BODY_CLEAR
 *  Source:	GrObject itself
 *  Destination:  Any grobject
 *  Interception: If object has data in other blocks or has mucked with
 * 		the interactible count is must subclass this message.
 * 		Do your own work first then call superclass.
 * 
 * PASS:		
 * 	nothing
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GO_DRAW_FG_AREA_HI_RES(DrawFlags drawFlags = cl, 
				GrObjDrawFlags grobjDrawFlags= bp,
				GStateHandle gstate = dx); /*XXX*/
/*
 * 	Draw the foreground area component of an object at a higher
 * 	resolution than 72 dpi. 
 * 
 * 	Normally an grobject is drawn at 72 dpi because the
 * 	the graphics system is optimized for non scaled drawing and 
 * 	the user is not viewing the image at a resolution higher
 * 	than 72 dpi. However, when printing or when the view is 
 * 	zoomed in, we can display at a higher resolution. This
 * 	is often done by applying a 1/4 scale factor to the
 * 	gstate and multiplying the coordinates of the object
 * 	by 4, bring the resolution up to 288 dpi.
 * 
 * 	NOTE: This handler does NOT set attributes or apply
 * 	the ObjectTransform. It is a mindless low level handler
 * 	that is concerned only with the shape to be drawn.
 * 
 *  Context:	GrObjClass Utility. Generally called 
 * 		during handling of MSG_GO_DRAW during printing
 * 		or when the view is zoomed in.
 *  Source:	Unrestricted. Generally the object itself.
 *  Destination:  Any grobject. Generally the object itself.
 *  Interception: There is no default behaviour. Most likely every 
 * 		object will subclass this and not call their superclass.
 * 		Objects whose images are built out at the device level,
 * 		such as text and bitmaps, and objects where it is 
 * 		impractical to modify the coordinates, such a gstrings,
 * 		should bind this message to the handler for 
 * 		MSG_GO_DRAW_FG_AREA
 * 
 * PASS:		
 * 		cl - DrawFlags
 * 		bp - GrObjDrawFlags		
 * 		dx - gstate with the object's transform applied
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */



@message void MSG_GO_DRAW_FG_LINE(DrawFlags drawFlags = cl, 
				GrObjDrawFlags grobjDrawFlags= bp,
				GStateHandle gstate = dx); /*XXX*/
/*
 * 	Draw the foreground line components of an object.
 * 
 * 	NOTE: This handler does NOT set attributes or apply
 * 	the ObjectTransform. It is a mindless low level handler
 * 	that is concerned only with the shape to be drawn.
 * 
 *  Context:	GrObjClass Utility. Generally called 
 * 		during handling of MSG_GO_DRAW
 *  Source:	Unrestricted. Generally the object itself.
 *  Destination:  Any grobject. Generally the object itself.
 *  Interception: There is no default handler. Most likely every 
 * 		object will subclass this and not call their superclass.
 * 
 * PASS:		
 * 		cl - DrawFlags
 * 		bp - GrObjDrawFlags		
 * 		dx - gstate with the object's transform applied
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GO_DRAW_FG_LINE_HI_RES(DrawFlags drawFlags = cl, 
				GrObjDrawFlags grobjDrawFlags= bp,
				GStateHandle gstate = dx); /*XXX*/
/*
 * 	Draw the foreground line component of an object at a higher
 * 	resolution than 72 dpi. 
 * 
 * 	Normally an grobject is drawn at 72 dpi because the
 * 	the graphics system is optimized for non scaled drawing and 
 * 	the user is not viewing the image at a resolution higher
 * 	than 72 dpi. However, when printing or when the view is 
 * 	zoomed in, we can display at a higher resolution. This
 * 	is often done by applying a 1/4 scale factor to the
 * 	gstate and multiplying the coordinates of the object
 * 	by 4, bring the resolution up to 288 dpi.
 * 
 * 	NOTE: This handler does NOT set attributes or apply
 * 	the ObjectTransform. It is a mindless low level handler
 * 	that is concerned only with the shape to be drawn.
 * 
 *  Context:	GrObjClass Utility. Generally called 
 * 		during handling of MSG_GO_DRAW during printing
 * 		or when the view is zoomed in.
 *  Source:	Unrestricted. Generally the object itself.
 *  Destination:  Any grobject. Generally the object itself.
 *  Interception: There is no default behaviour. Most likely every 
 * 		object will subclass this and not call their superclass.
 * 		Objects whose images are built out at the device level,
 * 		such as text and bitmaps, and objects where it is 
 * 		impractical to modify the coordinates, such a gstrings,
 * 		should bind this message to the handler for 
 * 		MSG_GO_DRAW_FG_LINE
 * 
 * PASS:		
 * 		cl - DrawFlags
 * 		bp - GrObjDrawFlags		
 * 		dx - gstate with the object's transform applied
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */




@message void MSG_GO_DRAW_CLIP_AREA(DrawFlags drawFlags = cl, 
				GrObjDrawFlags grobjDrawFlags= bp,
				GStateHandle gstate = dx); /*XXX*/
/*
 * 	Draw the shape that can be used for clipping text and
 * 	other images.
 * 
 * 	NOTE: This handler does NOT set attributes or apply
 * 	the ObjectTransform. It is a mindless low level handler
 * 	that is concerned only with the shape to be drawn.
 * 
 *  Context:	GrObjClass Utility. Generally called 
 * 		during handling of MSG_GO_DRAW for wrapping
 * 		text tightly around the object and for clipping
 * 		gradient fills to the object.
 *  Source:	Unrestricted. Generally the object itself.
 *  Destination:  Any grobject. Generally the object itself.
 *  Interception: There is no default handler. Most likely every 
 * 		object will subclass this and not call their superclass.
 * 		Most objects can just bind this message to the
 * 		handler for MSG_GO_DRAW_FG_AREA.
 * 
 * PASS:		
 * 		cl - DrawFlags
 * 		bp - GrObjDrawFlags		
 * 		dx - gstate with the object's transform applied
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */



@message void MSG_GO_DRAW_CLIP_AREA_HI_RES(DrawFlags drawFlags = cl, 
				GrObjDrawFlags grobjDrawFlags= bp,
				GStateHandle gstate = dx); /*XXX*/
/*
 * 	Draw the shape that can be used for clipping text and
 * 	other images at a higher resolution and 72 dpi
 * 
 * 	Normally an grobject is drawn at 72 dpi because the
 * 	the graphics system is optimized for non scaled drawing and 
 * 	the user is not viewing the image at a resolution higher
 * 	than 72 dpi. However, when printing or when the view is 
 * 	zoomed in, we can display at a higher resolution. This
 * 	is often done by applying a 1/4 scale factor to the
 * 	gstate and multiplying the coordinates of the object
 * 	by 4, bring the resolution up to 288 dpi.
 * 
 * 	NOTE: This handler does NOT set attributes or apply
 * 	the ObjectTransform. It is a mindless low level handler
 * 	that is concerned only with the shape to be drawn.
 * 
 *  Context:	GrObjClass Utility. Generally called 
 * 		during handling of MSG_GO_DRAW for wrapping
 * 		text tightly around the object and for clipping
 * 		gradient fills to the object during printing
 * 		or when the view is zoomed in.
 *  Source:	Unrestricted. Generally the object itself.
 *  Destination:  Any grobject. Generally the object itself.
 *  Interception: There is no default behaviour. Most likely every 
 * 		object will subclass this and not call their superclass.
 * 		Objects whose images are built out at the device level,
 * 		such as text and bitmaps, and objects where it is 
 * 		impractical to modify the coordinates, such a gstrings,
 * 		should bind this message to the handler for 
 * 		MSG_GO_DRAW_CLIP_AREA
 * 
 * PASS:		
 * 		cl - DrawFlags
 * 		bp - GrObjDrawFlags		
 * 		dx - gstate with the object's transform applied
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */




@message void MSG_GO_DRAW_FG_GRADIENT_AREA(DrawFlags drawFlags = cl, 
				GrObjDrawFlags grobjDrawFlags= bp,
				GStateHandle gstate = dx); /*XXX*/
/*
 * 	Draw a gradient fill for the foreground area components 
 * 	of an object.
 * 
 * 	NOTE: This handler does NOT need to apply
 * 	the ObjectTransform. It is a mindless low level handler
 * 	that is concerned only with the shape to be drawn.
 * 
 *  Context:	GrObjClass Utility. Generally called 
 * 		during handling of MSG_GO_DRAW
 *  Source:	Unrestricted. Generally the object itself.
 *  Destination:  Any grobject. Generally the object itself.
 *  Interception: Unlikely. The default handler clips the gradient
 * 		fill to the shape drawn by MSG_GO_DRAW_CLIP_AREA
 * 		
 * PASS:		
 * 		cl - DrawFlags
 * 		bp - GrObjDrawFlags		
 * 		dx - gstate with the object's transform applied
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */



@message void MSG_GO_DRAW_FG_GRADIENT_AREA_HI_RES(DrawFlags drawFlags = cl, 
				GrObjDrawFlags grobjDrawFlags= bp,
				GStateHandle gstate = dx); /*XXX*/
/*
 * 	Draw a gradient fill for the foreground area components 
 * 	of an object at a higher resolution than 72 dpi. 
 * 
 * 	Normally an grobject is drawn at 72 dpi because the
 * 	the graphics system is optimized for non scaled drawing and 
 * 	the user is not viewing the image at a resolution higher
 * 	than 72 dpi. However, when printing or when the view is 
 * 	zoomed in, we can display at a higher resolution. This
 * 	is often done by applying a 1/4 scale factor to the
 * 	gstate and multiplying the coordinates of the object
 * 	by 4, bring the resolution up to 288 dpi.
 * 
 * 	NOTE: This handler does NOT need to apply
 * 	the ObjectTransform. It is a mindless low level handler
 * 	that is concerned only with the shape to be drawn.
 * 
 *  Context:	GrObjClass Utility. Generally called 
 * 		during handling of MSG_GO_DRAW during printing
 * 		or when the view is zoomed in.
 *  Source:	Unrestricted. Generally the object itself.
 *  Destination:  Any grobject. Generally the object itself.
 *  Interception: There is no default behaviour. Most likely every 
 * 		object will subclass this and not call their superclass.
 * 		Objects whose images are built out at the device level,
 * 		such as text and bitmaps, and objects where it is 
 * 		impractical to modify the coordinates, such a gstrings,
 * 		should bind this message to the handler for 
 * 		MSG_GO_DRAW_FG_GRADIENT_AREA
 * 
 * PASS:		
 * 		cl - DrawFlags
 * 		bp - GrObjDrawFlags		
 * 		dx - gstate with the object's transform applied
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */



@message void MSG_GO_DRAW_BG_AREA_HI_RES(DrawFlags drawFlags = cl, 
				GrObjDrawFlags grobjDrawFlags= bp,
				GStateHandle gstate = dx); /*XXX*/
/*
 * 	Draw the background area and line components of an object at 
 * 	a higher resolution than 72 dpi. 
 * 
 * 	Normally an grobject is drawn at 72 dpi because the
 * 	the graphics system is optimized for non scaled drawing and 
 * 	the user is not viewing the image at a resolution higher
 * 	than 72 dpi. However, when printing or when the view is 
 * 	zoomed in, we can display at a higher resolution. This
 * 	is often done by applying a 1/4 scale factor to the
 * 	gstate and multiplying the coordinates of the object
 * 	by 4, bring the resolution up to 288 dpi.
 * 
 * 	NOTE: This handler does NOT set attributes or apply
 * 	the ObjectTransform. It is a mindless low level handler
 * 	that is concerned only with the shape to be drawn.
 * 
 *  Context:	GrObjClass Utility. Generally called 
 * 		during handling of MSG_GO_DRAW during printing
 * 		or when the view is zoomed in.
 *  Source:	Unrestricted. Generally the object itself.
 *  Destination:  Any grobject. Generally the object itself.
 *  Interception: There is no default behaviour. Most likely every 
 * 		object will subclass this and not call their superclass.
 * 		Objects whose images are built out at the device level,
 * 		such as text and bitmaps, and objects where it is 
 * 		impractical to modify the coordinates, such a gstrings,
 * 		should bind this message to the handler for 
 * 		MSG_GO_DRAW_BG_AREA
 * 
 * PASS:		
 * 		cl - DrawFlags
 * 		bp - GrObjDrawFlags		
 * 		dx - gstate with the object's transform applied
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */



@message void MSG_GO_SET_BG_COLOR(	 	/* XXX  */
	byte 	red = cl,
	byte 	green = ch,
	byte 	blue = dl);
/*
 * 	Set the bg area and line color of the object
 * 
 *  Context:	GrObj utility
 *  Source:	Unrestricted
 *  Destination:	Any grobj object. If the object has no area
 * 		attributes it will ignore the message
 *  Interception:	Unlikely
 * 		
 * 
 * PASS:
 * 	cl - r
 * 	ch - g
 * 	dl - b
 * 
 * RETURN
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */





@message void MSG_GO_SET_AREA_PATTERN(GraphicPattern pattern = cx);
/*
 * 	Set the area pattern of the object
 * 
 *  Context:	GrObj utility
 *  Source:	Unrestricted
 *  Destination:	Any grobj object. If the object has no area
 * 		attributes it will ignore the message
 *  Interception:	Unlikely
 * 		
 * 
 * PASS:
 * 	cx - GraphicPattern
 * 
 * 
 * RETURN
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */



@message void MSG_GO_SET_AREA_ATTR_ELEMENT_TYPE(GrObjAreaAttrElementType type = cl);
/*
 * 	Set the GrObjAreaAttrElementType of the object
 * 
 *  Context:	GrObj utility
 *  Source:	Unrestricted
 *  Destination:	Any grobj object. If the object has no area
 * 		attributes it will ignore the message
 *  Interception:	If the object doesn't support one or more of the
 * 		GrObjAreaAttrElementTypes then it should subclass
 * 		this message and not call it's super if one of
 * 		the offending types has been passed. For instance
 * 		the bitmap doesn't support GOAAET_GRADIENT.
 * 		
 * 
 * PASS:
 * 	cl - GrObjAreaAttrElementType
 * 
 * RETURN
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GO_SET_LINE_ATTR_ELEMENT_TYPE(GrObjLineAttrElementType type = cl);
/*
 * 	Set the GrObjLineAttrElementType of the object
 * 
 *  Context:	GrObj utility
 *  Source:	Unrestricted
 *  Destination:	Any grobj object. If the object has no area
 * 		attributes it will ignore the message
 *  Interception:	If the object doesn't support one or more of the
 * 		GrObjAreaAttrElementTypes then it should subclass
 * 		this message and not call it's super if one of
 * 		the offending types has been passed. 
 * 		
 * PASS:
 * 	cl - GrObjLineAttrElementType
 * 
 * RETURN
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */




@message void MSG_GO_SET_STARTING_GRADIENT_COLOR(	 	/* XXX  */
	byte 	red = cl,
	byte 	green = ch,
	byte 	blue = dl);
/*
 * 	Set the starting color for a gradient fill. If the object's
 * 	area attributes are not GOAAET_GRADIENT then the 
 * 	message will be ignored. See MSG_GO_AREA_ATTR_ELEMENT_TYPE
 * 
 *  Context:	GrObj Utility
 *  Source:	Unrestricted
 *  Destination:  Any grobject
 *  Interception: Unlikely
 * 
 * PASS:		
 * 	cl - r
 * 	ch - g
 * 	dl - b
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */



@message void MSG_GO_SET_ENDING_GRADIENT_COLOR(	 	/* XXX  */
	byte 	red = cl,
	byte 	green = ch,
	byte 	blue = dl);
/*
 * 	Set the ending color for a gradient fill. If the object's
 * 	area attributes are not GOAAET_GRADIENT then the 
 * 	message will be ignored. See MSG_GO_AREA_ATTR_ELEMENT_TYPE
 * 
 *  Context:	GrObj Utility
 *  Source:	Unrestricted
 *  Destination:  Any grobject
 *  Interception: Unlikely
 * 
 * PASS:		
 * 	cl - r
 * 	ch - g
 * 	dl - b
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */




@message void MSG_GO_SET_NUMBER_OF_GRADIENT_INTERVALS(word nIntervals = cx);
/*
 * 	Set the number of gradient intervals for a gradient fill. 
 * 	If the object's area attributes are not GOAAET_GRADIENT then the 
 * 	message will be ignored. See MSG_GO_AREA_ATTR_ELEMENT_TYPE.
 * 
 *  Context:	GrObj Utility
 *  Source:	Unrestricted
 *  Destination:  Any grobject
 *  Interception: Unlikely
 * 
 * PASS:		
 * 	cx - number of intervals
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GO_SET_GRADIENT_TYPE(GrObjGradientType type = cl);
/*
 * 	Set the type of the gradient fill. 
 * 	If the object's area attributes are not GOAAET_GRADIENT then the 
 * 	message will be ignored. See MSG_GO_AREA_ATTR_ELEMENT_TYPE.
 * 
 *  Context:	GrObj Utility
 *  Source:	Unrestricted
 *  Destination:  Any grobject
 *  Interception: Unlikely
 * 
 * PASS:		
 * 	cl - GrObjGradientType
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GO_SET_ARROWHEAD_ON_START(Boolean arrowOnStart = cl);
/*
 * 	If true then during object will draw an arrowhead at it's first
 * 	point. Not all objects support arrowheads.
 *  
 *  Context:	GrObj Utility
 *  Source:	Unrestricted
 *  Destination:  Any GrObject
 *  Interception: Unlikely
 * 
 * PASS:		
 * 	cl - TRUE/FALSE
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GO_SET_ARROWHEAD_ON_END(Boolean arrowOnEnd = cl);
/*
 * 	If true then during object will draw an arrowhead at it's final
 * 	point. Not all objects support arrowheads.
 *  
 *  Context:	GrObj Utility
 *  Source:	Unrestricted
 *  Destination:  Any GrObject
 *  Interception: Unlikely
 * 
 * PASS:		
 * 	cl - TRUE/FALSE
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GO_SET_ARROWHEAD_FILLED(Boolean filled = cl,
					  Boolean useAreaAttrs = ch);
/*
 * 	If true then arrowheads will be filled. If false then
 * 	they will be drawn with lines.
 * 	Not all objects support arrowheads.; 
 *  Context:	GrObj Utility
 *  Source:	Unrestricted
 *  Destination:  Any GrObject
 *  Interception: Unlikely
 * 
 * PASS:		
 * 	cl - TRUE/FALSE
 * 	ch - nonzero to fill with area attributes,
 * 	     zero to fill with line attributes
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GO_SET_ARROWHEAD_ANGLE(byte angle = cl);
/*
 * 	Set angle between the line and the arrowheads lines.
 *  	Not all objects support arrowheads.
 * 
 *  Context:	GrObj Utility
 *  Source:	Unrestricted
 *  Destination:  Any GrObject
 *  Interception: Unlikely
 * 
 * PASS:		
 * 	cl - angle (0-90)
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GO_SET_ARROWHEAD_LENGTH(byte length = cl);
/*
 * 	Set length of arrowhead line from line starting/ending point
 * 	Not all objects support arrowheads.
 *  
 *  Context:	GrObj Utility
 *  Source:	Unrestricted
 *  Destination:  Any GrObject
 *  Interception: Unlikely
 * 
 * PASS:		
 * 	cl - length in 72 dpi
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GO_NOTIFY_GROBJ_INVALID();
/*
 *  Notify the grobj that it is not valid.
 * 
 *  Context:	GrObj utility
 *  Source:	Unrestricted
 *  Destination:  any GrObject
 *  Interception: unlikely
 * 
 *  Pass:		nothing
 * 			
 *  Return:	nothing 
 * 
 *  Destroyed:	ax 
 */


@message void MSG_GO_SET_GROBJ_ATTR_FLAGS(GrObjAttrFlags bitsToSet = cx,
					  GrObjAttrFlags bitsToReset = dx);
/*
 * 	Set and reset bits in the GOI_attrFlags field.
 * 
 *  Context:	GrObj Utility. Generally used for undo.
 *  Source:	Unrestricted
 *  Destination:  Any grobject
 *  Interception: Unlikely
 * 
 * PASS:		
 * 	cx - GrObjAttrFlags bit to set
 * 	dx - GrObjAttrFlags bit to clear
 * 
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GO_SET_SYS_TARGET(Boolean setTarget = cl);
/*
 * 	Set/Clear bit in object that reflects  the body's system 
 * 	target excl status
 * 
 *  Context:	When object is added to selection list or when object
 * 		receives MSG_META_GAINED/LOST_SYS_TARGET_EXCL
 *  Source:	GrObjBody/Object itself
 *  Destination:  Selected grobjects
 *  Interception: Unlikley
 * 
 * PASS:		
 * 	cl - TRUE/FALSE
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */



@message void MSG_GO_SCALE_OBJECT( 	/* XXX */
	GrObjAnchoredScaleData	_far *params = ss:bp);	
/*
 * 	Scale a grobject in its own coordinate space. [current matrix][scale]
 * 	Anchors center of object.
 * 	
 *  Context:	GrObj Utility
 *  Source:	Unrestricted
 *  Destination:  Any GrObject
 *  Interception:	Unlikely
 * 
 * PASS:		
 * 	ss:bp - GrObjScaleData
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GO_GENERATE_UNDO_CLEAR_CHAIN_WITH_ACTION_NOTIFICATION();
/*
 * 	Generate an undo chain for undoing the redo of a clear and
 * 	send out a GOANT_REDO_DELETE action notification.
 * 
 *  Context:	Sent when handling MSG_GO_GENERATE_UNDO_UNDO_CLEAR_CHAIN
 * 		( undoing an undo of a delete )
 *  Source:	Object itself
 *  Destination:  Object itself
 *  Interception: Don't. Trust me.
 * 
 * PASS:		
 * 	nothing
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GO_RECREATE_CACHED_GSTATES();
/*
 * 	Have objects destroy and recreate any cached gstates
 * 
 *  Context:	Sent by body to target when body handles 
 * 		MSG_VIS_RECREATE_CACHED_GSTATES
 *  Source:	Unrestricted. Generally GrObjBody
 *  Destination:  Any grobject. Generally target
 *  Interception: If object has any cached gstates it must subclass this
 * 		message and call superclass
 * 
 * PASS:		
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */



@message void MSG_GO_DRAW_QUICK_VIEW(DrawFlags drawFlags = cl, 
				GrObjDrawFlags grobjDrawFlags= bp,
				GStateHandle gstate = dx); /*XXX*/
/*
 * 	Draw the basic shape of the objects as quickly as possible.
 * 	Most objects just draw their outline for this message
 * 
 * 	NOTE: This handler does NOT set attributes or apply
 * 	the ObjectTransform. It is a mindless low level handler
 * 	that is concerned only with the shape to be drawn.
 * 
 *  Context:	GrObjClass Utility. Generally called 
 * 		during handling of MSG_GO_DRAW when GODF_DRAW_QUICK_VIEW 
 * 		is set.
 *  Source:	Unrestricted. Generally the object itself.
 *  Destination:  Any grobject. Generally the object itself.
 *  Interception: The default handler draws a rectangle. Many objects bind
 * 		the message to their MSG_GO_DRAW_FG_LINE handler
 * 
 * PASS:		
 * 		cl - DrawFlags
 * 		bp - GrObjDrawFlags		
 * 		dx - gstate with the object's transform applied
 * 			line width = 0
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */



@message void MSG_GO_DRAW_SPRITE_LINE_HI_RES(GStateHandle gstate = dx);
/*
 * 	Draw the sprite line image of an object using the 
 * 	spriteTransform at a higher resolution than 72 dpi. 
 * 
 * 	Normally an grobject is drawn at 72 dpi because the
 * 	the graphics system is optimized for non scaled drawing and 
 * 	the user is not viewing the image at a resolution higher
 * 	than 72 dpi. However, when the view is 
 * 	zoomed in, we can display at a higher resolution. This
 * 	is often done by applying a 1/4 scale factor to the
 * 	gstate and multiplying the coordinates of the object
 * 	by 4, bring the resolution up to 288 dpi.
 * 
 * 	NOTE: This handler does NOT set attributes or apply
 * 	the ObjectTransform. It is a mindless low level handler
 * 	that is concerned only with the shape to be drawn.
 * 
 *  Context:	GrObjClass Utility. Generally called 
 * 		during handling of MSG_GO_DRAW_SPRITE
 *  Source:	Unrestricted. Generally the object itself.
 *  Destination:  Any grobject. Generally the object itself.
 *  Interception: Most likely every object will subclass this and not
 * 		call their superclass.
 * 
 * PASS:		
 * 		dx - gstate
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GO_DRAW_NORMAL_SPRITE_LINE_HI_RES(GStateHandle gstate = dx);
/*
 * 	Draw the sprite line image of an object using the 
 * 	normalTransform at a higher resolution than 72 dpi. 
 * 
 * 	Normally an grobject is drawn at 72 dpi because the
 * 	the graphics system is optimized for non scaled drawing and 
 * 	the user is not viewing the image at a resolution higher
 * 	than 72 dpi. However, when the view is 
 * 	zoomed in, we can display at a higher resolution. This
 * 	is often done by applying a 1/4 scale factor to the
 * 	gstate and multiplying the coordinates of the object
 * 	by 4, bring the resolution up to 288 dpi.
 * 
 * 	NOTE: This handler does NOT set attributes or apply
 * 	the ObjectTransform. It is a mindless low level handler
 * 	that is concerned only with the shape to be drawn.
 * 
 *  Context:	GrObjClass Utility. Generally called 
 * 		during handling of MSG_GO_DRAW_SPRITE on objects
 * 		in a group.
 *  Source:	Unrestricted. Generally the object itself.
 *  Destination:  Any grobject. Generally the object itself.
 *  Interception: Most likely every object will subclass this and not
 * 		call their superclass.
 * 
 * PASS:		
 * 		dx - gstate
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message GrObjAttrFlags MSG_GO_GET_GROBJ_ATTR_FLAGS() = cx;
/*
 * 	Retrieve bits in the GOI_attrFlags field.
 * 
 *  Context:	GrObj Utility. 
 *  Source:	Unrestricted
 *  Destination:  Any grobject
 *  Interception: Unlikely
 * 
 * PASS:		
 * 	nothing
 * 			
 * RETURN:	
 * 	cx - GrObjAttrFlags
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GO_MAKE_ATTRS_DEFAULT();
/*
 * 	Set the attributes of this object as the default attributes
 * 	in the GrObjAttributeManager.
 * 	Area,Line and GrObjAttrs
 * 
 *  Context:	GrObj Utility
 *  Source:	Unrestricted
 *  Destination:  Any grobject
 *  Interception: Unlikely
 * 
 * PASS:		
 * 	nothing
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


typedef ByteEnum GrObjPointerImageSituation;		/* CHECKME */
#define GOPIS_NORMAL	0x0
#define GOPIS_EDIT	0x1
#define GOPIS_CREATE	0x2
#define GOPIS_MOVE	0x3
#define GOPIS_RESIZE_ROTATE	0x4



@message void MSG_GO_GET_SITUATIONAL_POINTER_IMAGE(MouseReturnFlagsAndMouseImage *retVal = axcxdxbp, GrObjPointerImageSituation situation = cl);
/*
 * 	Get pointer image for object for specific situations
 * 
 *  Context:	GrObj Utility
 *  Source:	Unrestricted
 *  Destination:  Any grobject
 *  Interception: Likely. Call superclass for situations which your
 * 		object doesn't provide its own pointer image.
 * 
 * PASS:		
 * 		cl - GrObjPointerImageSituation
 * 			
 * RETURN:	
 * 		ah - high byte of MouseReturnFlags
 * 			MRF_SET_POINTER_IMAGE or MRF_CLEAR_POINTER_IMAGE
 * 		if MRF_SET_POINTER_IMAGE
 * 		cx:dx - optr of mouse image
 * DESTROYED:
 * 	al
 */

/*
CheckHack <offset MRF_SET_POINTER_IMAGE gt 7 >
*/
/*
CheckHack <offset MRF_CLEAR_POINTER_IMAGE gt 7 >
*/


@message void MSG_GO_OBJ_FREE();
/*
 * 	Free an object *now*. Used instead of MSG_META_OBJ_FREE to avoid
 * 	overflowing the handle table. MSG_META_OBJ_FREE puts a 
 * 	MSG_META_FINAL_OBJ_FREE on the queue. With a large number of objects
 * 	all doing this at the same time the handle table can easily overflow. 
 * 	MSG_GO_OBJ_FREE attempts to destroy the object without using the
 * 	queue.
 * 
 * 
 *  Context:	Low level utility for deleting objects when undo 
 * 		actions are being ignored.
 *  Source:	Sent internally usually. You really shouldn't send 
 * 		this yourself.
 *  Destination:  Any grobject
 *  Interception: The default handler increments the in use count of the
 * 		object and then sends MSG_META_FINAL_OBJ_FREE directly
 * 		to itself. This assumes that there are no messages in
 * 		the queue for the object. If your object may have messages
 * 		on the queue, such as the cursor flash messages
 * 		for the VisText, you should subclass this message,
 * 		send MSG_META_OBJ_FREE to yourself and don't call your
 * 		superclass.
 * 
 * PASS:		
 * 	nothing
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GO_ADJUST_CREATE();
/*
 * 	Bring creation to a screeching halt using whatever data
 * 	is currently stored in the object.
 * 
 *  Context:	Force basic drag create shapes this message is sent
 * 		upon receiving an END_SELECT while being created.
 * 		For more complex objects, such as spline, this message
 * 		is sent on double clicks and right mouse clicks.
 *  Source:	Unrestricted. Usually object itself. 
 *  Destination:  Grobject being created.
 *  Interception: Rects, ellipse,lines, etc can use the default handler, but
 * 		other objects will likely subclass this and not
 * 		call their superclass. Subclasses of this message
 * 		must send MSG_GO_SUSPEND_COMPLETE_CREATE to themselves unless
 * 		the object is destroyed.
 * 
 * PASS:		
 * 	nothing
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GO_GENERATE_UNDO_UNDO_CLEAR_CHAIN_WITH_ACTION_NOTIFICATION();
/*
 * 	Generate an undo chain for undoing an undo of a clear and
 * 	send out a GOANT_UNDO_DELETE action notification.
 * 
 *  Context:	Sent when handling MSG_GO_GENERATE_UNDO_CLEAR_CHAIN
 * 		( undoing an undo of a delete )
 *  Source:	Object itself
 *  Destination:  Object itself
 *  Interception: Don't. Trust me.
 * 
 * PASS:		
 * 	nothing
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GO_NUDGE_INSIDE(sword xNudge = cx, sword yNudge = dx);
/*
 * 	Move the paste inside children of a group a multiple of current 
 *        DEVICE units. As currently implemented this does not take
 *        into account transformations in the group, so the amount 
 * 	moved may vary.
 * 
 * 
 *  Context:	GrObj Utiltity
 *  Source:	Unrestricted, generally UI or object itself
 *  Destination:	Any grobj object
 *  Interception:	Unlikely
 * 
 * PASS
 * 	cx - number of device units in x to move
 * 	dx - number of device units in y to move
 * 
 * RETURN
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GO_MOVE_INSIDE(PointDWFixed *distance = ss:bp);
/*
 * 	Move only the paste inside children of a group relative 
 * 	by the passed distance.
 * 
 * 
 *  Context:	GrObj Utiltity
 *  Source:	Unrestricted, generally UI or object itself
 *  Destination:	Any grobj object
 *  Interception:	Unlikely 
 * 
 * PASS
 * 	ss:bp = PointDWFixed amount to move object in PARENT coords
 * 
 * RETURN
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */

@message void MSG_GO_REPLACE_GEOMETRY_INSTANCE_DATA(BasicInit *initData = ss:bp);
/*
 * 	Replaces the objects geometry related instance data with the
 * 	passed data.
 * 
 *  Context:	During undo of most geometry operations
 *  Source:	Object itself
 *  Destination:  Object itself
 *  Interception: Unlikely
 * 
 * PASS:		
 * 	ss:bp - BasicInit
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */

@message GrObjActionModes MSG_GO_CHECK_ACTION_MODES() = cx;
/*
 * 	Retrieve the GOI_actionModes field.
 * 
 *  Context:	GrObj Utility. 
 *  Source:	Unrestricted
 *  Destination:  Any grobject
 *  Interception: Unlikely
 * 
 * PASS:		
 * 	nothing
 * 			
 * RETURN:	
 * 	cx - GrObjActionModes
 * 
 * DESTROYED:
 * 	ax
 */



@message PositEvalAndHitHandle MSG_GO_EVALUATE_PARENT_POINT_FOR_HANDLE_MOVE_RESIZE(
	PointDWFixed *parentCoord = ss:bp) = ax;
/*
 * 	Determine if one of the handles of the object would be hit
 * 	by the passed point. Will ignore move handles of objects with
 * 	GOL_MOVE lock set. Will ignore resize handles of objects with
 * 	GOL_RESIZE lock set.
 * 
 *  Context:	Usually called as direct action of user clicking with
 * 		the pointer tool. 
 *  Source:	Unrestricted, generally the floater
 *  Destination:	Any grobj object. The message will be ignored if the
 * 		object's GOTM_HANDLES_DRAWN flag is not set
 *  Interception:	Possible. If object doesn't have normal 9 handles, such
 * 		as a line with only 3, it should subclass this message
 * 		and not call its superclass
 * 
 * PASS
 * 	ss:bp - PointDWFixed in PARENT
 * 
 * RETURN
 * 	al - EVALUATE_NONE - handles not hit
 * 		ah - destroyed
 * 	al - EVALUATE_HIGH - handle hit
 * 		ah - GrObjHandleSpecification of hit handle
 * 
 * 	dx - 0 ( blank EvaluatePositionNotes)
 * 
 * DESTROYED:
 * 	nothing
 */



@message PositEvalAndHitHandle MSG_GO_EVALUATE_PARENT_POINT_FOR_HANDLE_MOVE_ROTATE(
	PointDWFixed *parentCoord = ss:bp) = ax;
/*
 * 	Determine if one of the handles of the object would be hit
 * 	by the passed point. Will ignore move handles of objects with
 * 	GOL_MOVE lock set. Will ignore rotate handles of objects with
 * 	GOL_ROTATE lock set.
 * 
 *  Context:	Usually called as direct action of user clicking with
 * 		the pointer tool. 
 *  Source:	Unrestricted, generally the floater
 *  Destination:	Any grobj object. The message will be ignored if the
 * 		object's GOTM_HANDLES_DRAWN flag is not set
 *  Interception:	Possible. If object doesn't have normal 9 handles, such
 * 		as a line with only 3, it should subclass this message
 * 		and not call its superclass
 * 
 * PASS
 * 	ss:bp - PointDWFixed in PARENT
 * 
 * RETURN
 * 	al - EVALUATE_NONE - handles not hit
 * 		ah - destroyed
 * 	al - EVALUATE_HIGH - handle hit
 * 		ah - GrObjHandleSpecification of hit handle
 * 
 * 	dx - 0 ( blank EvaluatePositionNotes)
 * 
 * DESTROYED:
 * 	nothing
 */



typedef struct {
	word 	CLS_pad1;
	word	CLS_locksSetSoFar;
	word	CLS_locksClearSoFar;
	word	CLS_pad2;
} CombineLocksStruct;

@message void MSG_GO_COMBINE_LOCKS(
	CombineLocksStruct *retVal = axcxdxbp, 
	GrObjLocks setSoFar = cx,
	GrObjLocks clearSoFar = dx);
/*
 * 		This message or's the grobj's locks into the passed locks;
 * 		this is generally used in combination with other grobjs
 * 		(eg., all the selected grobjs) to find out what is
 * 		allowable and what is not for a set of grobjs
 * 		
 * PASS:		
 * 	cx - locks set so far
 * 	dx - locks clear so far
 * 			
 * RETURN:	
 * 	cx,dx - updated
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GO_DESELECT_IF_GROUP_LOCK_SET();
/*
 * 	If the object is selected and it has its group lock set it
 * 	will become unselected.
 * 
 *  Context:	Used before grouping and paste inside to avoid lots
 * 		of problems.
 *  Source:	GrObjBody
 *  Destination:  Selected GrObjs
 *  Interception: Unlikely
 * 
 * PASS:		
 * 	nothing
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GO_GET_POTENTIAL_GROBJECT_SIZE(word byteSize = cx);
/*
 * 	Return the number of bytes that the grobject can use up in
 *  	its block. This includess instance data, chunks and vardata, but
 * 	not data in other blocks created by this object.
 * 
 *  Context:	Used to keep track of which document blocks can
 * 		have more objects added to them. 
 *  Source:	Object itself.
 *  Destination:  Object itself
 *  Interception: The default handler will calculate the instance data size,
 * 		but if your object allocates chunks or vardata in its
 * 		block it must subclass this message. Call the superclass
 * 		first and then add in your extra bytes
 * 
 * PASS:		
 * 	nothing
 * 			
 * RETURN:	
 * 	cx - size in bytes
 * 
 * DESTROYED:
 * 	ax
 */



@message void MSG_GO_GROUP_GAINED_SELECTION_LIST();
/*
 * 	Notify grobjects in a group that the group has been selected
 * 
 *  Context:	Sent to grobjects in group when group receives 
 * 		MSG_GO_GAINED_SELECTION_LIST
 *  Source:	Group
 *  Destination:  GrObject in a group
 *  Interception: There is no default handler. Only under special circumstances
 * 		will you need to intercept this message. For instance, the 
 * 		text guardian intercepts this message and selects all text so
 * 		that text attribute changes can be applied correctly
 * 
 * PASS:		
 * 	nothing
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GO_GROUP_LOST_SELECTION_LIST();
/*
 * 	Notify grobjects in a group that the group is no longer selected
 * 
 *  Context:	Sent to grobjects in group when group receives 
 * 		MSG_GO_LOST__SELECTION_LIST
 *  Source:	Group
 *  Destination:  GrObject in a group
 *  Interception: There is no default handler. Only under special circumstances
 * 		will you need to intercept this message. For instance, the 
 * 		text guardian intercepts this message and deselects all text,
 * 		to counteract the selection of all the text in the handler
 * 		for MSG_GO_GROUP_GAINED_SELECTION_LIST.
 * 
 * PASS:		
 * 	nothing
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */

@message void MSG_GO_INVALIDATE_WITH_UNDO();
/*
 * 	Do a normal invalidate but create an undo action that also does
 * 	an invalidate.
 * 
 *  Context:	Obscure. Used currently so that when undoing a paste inside
 * 		the objects redraw without their insides.
 *  Source:	Unrestricted
 *  Destination:  Any grobject
 *  Interception: Not
 * 
 * PASS:		
 * 	nothing
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GO_AFTER_QUICK_PASTE();
/*
 * 	Send to object after it has been created by a quick paste. (ie
 * 	from quick move or quick copy). Object should either become
 * 	selected or edited.
 * 
 *  Context:	Sent to object after it has been created via a quick paste
 *  Source:	GrObjBody
 *  Destination:  GrObject
 *  Interception: Default handler selects object. Some objects will subclass
 * 		this and make themselves editable instead. Don't call
 * 		superclass in this case.
 * 
 * PASS:		
 * 	nothing
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GO_QUICK_TOTAL_BODY_CLEAR();
/*
 * 	The body is about to destroy all the blocks that its children are in.
 * 	The object must	destroy any data in blocks that the body doesn't
 * 	know about. 
 * 	Object MUST NOT send any message on the queue while
 * 	handling this.
 * 	Object can assume that there are no messages in the queue for it.
 * 
 *  Context:	Send by body when handling MSG_GO_CLEAR
 *  Source:	GrObjBody
 *  Destination:  Any grobject
 *  Interception: The default handler sends MSG_GO_NUKE_DATA_IN_OTHER_BLOCKS
 * 		to itself (in most cases you will be better off subclassing
 * 		that message). However, objects such as the guardians must 
 * 		cause there wards to nuke any extra data, so they subclass 
 * 		the message, send MSG_FINAL_OBJ_FREE to their wards and then
 * 		call their superclass.
 * 
 * PASS:		
 * 	nothing
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message Boolean MSG_GO_CLEAR_IF_NOT_WITHIN_BODY_BOUNDS() = carry;
/*
 * 	Causes the GrObj to delete itself if its bounds do not overlap the
 * 	body's bounds
 * 
 * PASS:		
 * 	nothing
 * 			
 * RETURN:	
 * 	carry set if object nukes itself
 * 
 * DESTROYED:
 * 	ax
 */



@message word MSG_GO_INC_CX_IF_COPYABLE(word iDunno = cx) = cx;
/*
 * 	Take a wild guess
 * 
 * PASS:		
 * 	cx - current count of copyable objects
 * 			
 * RETURN:	
 * 	cx - incremented if copyable
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GO_DESELECT_IF_COPY_LOCK_SET();
/*
 * 	If the object is selected and it has its copy lock set it
 * 	will become unselected.
 * 
 *  Context:	Used before copying to avoid lots of problems.
 *  Source:	GrObjBody
 *  Destination:  Selected GrObjs
 *  Interception: Unlikely
 * 
 * PASS:		
 * 	nothing
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GO_OBJ_FREE_GUARANTEED_NO_QUEUED_MESSAGES();
/*
 * 	Free an object *now*, with the full knowledge that no messages
 * 	are in the queue for this object, or its ward if it is a guardian.
 * 	This is a tough guarantee to make. You really don't want to be
 * 	sending this message unless you are very sure about what you are
 * 	doing. Currently this message is only used when freeing the undo
 * 	action that an object created when it received MSG_GO_CLEAR. On
 * 	MSG_GO_CLEAR the object releases all excls, is taken out of the
 * 	selection list, is removed from the body and creates an undo
 * 	action. By the time that undo action can be freed there will be
 * 	no messages in the queue for the object. If that undo action
 * 	is freed the object send this message to itself.
 * 
 * 	The object may not put any messages on any queues in the process
 * 	of handling this message.
 * 
 *  Context:	Low level utility for deleting objects. See above
 *  Source:	Sent internally usually. You really shouldn't send 
 * 		this yourself.
 *  Destination:  Any grobject
 *  Interception: Most objects use the same handler as MSG_GO_OBJ_FREE.
 * 		The guardian's subclass this message because they
 * 		normally free there wards with MSG_META_OBJ_FREE, which
 * 		results in a message on the queue. This is not allowed
 * 		when handling this message. So the guardians subclass
 * 		this message and destroy their wards by sending
 * 		MSG_META_FINAL_OBJ_FREE to the wards directly. The guardians
 * 		then call their superclass to destroy themselves.
 * 		
 * PASS:		
 * 	nothing
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */

					/* cannot be prototyped */
@message Boolean MSG_GO_QUICK_TRANSFER_TAKE_MOUSE_GRAB_IF_POSSIBLE() = carry;
/*
 *	INTERNAL USE ONLY
 *
 *	Checks to see if this object should take the mouse grab.  This 
 *	should only be called while a quick transfer is taking place and
 *	the body currently has the mouse grab.  It will take back the
 *	mouse grab IF it is NOT the floater, if it is the owner of the
 *	quick transfer object, and if the mouse event pointer position is
 *	within its bounds.  This is a highly specialized message.
 *
 * Context:	Highly specialized message.  See explanation.
 * Source:	GrObjBodyLargePtr
 * Destination:  Any GrObject
 * Interception: The default handler in GrObjClass will do nothing and return
 *		carry clear.  This is intended to be subclassed only by
 *		GrObjVisGuardianClass.
 *
 * Pass:	(No MF_STACK)
 *	ss:bp	= LargeMouseData
 *	^lcx:dx	= optr to the owner of the Quick Transfer Object
 *			
 * Return:
 *	carry:	SET	- Object was eligible and mouse was grabbed.
 *		CLEAR	- Object was not eligible, mouse grab was not changed.
 *
 *	cx, dx, bp - unchanged
 *	ax - destroyed
 *
 * WARNING:
 *	Do NOT send this message with MF_STACK because dx is not set to the
 *	size of the parameters on the stack.  As a result, this message must
 *	be sent and received by the same thread.
 *
 * GOC WARNING: THIS MESSAGE CANNOT BE SENT FROM GOC FOR THE REASON MENTIONED
 *              IN PREVIOUS WARNING.
 */

@protominor GrObjNewFor2_1

@message Boolean MSG_GO_IS_POINT_INSIDE_OBJECT_BOUNDS(PointDWFixed *coord =
							ss:bp) = carry;
/*
 *	Checks to see if the passed point is inside the object's bounds
 *
 * Context:	Mostly used to check mouse position.
 * Source:	Anyone.
 * Destination:  Any GrObject (the floater always returns false)
 * Interception: The GrObjClass handler should work in all cases.
 *
 * Pass:
 *	ss:bp	= PointDWFixed
 *	dx	= size PointDWFixed
 *			
 * Return:
 *	carry:	SET	- Point is inside bounds
 *		CLEAR	- Point is NOT inside bounds
 *
 *	cx, dx, bp - unchanged
 *	ax - destroyed
 *
 */

@message void MSG_GO_FLIP( 	/* XXX */
	GrObjAnchoredScaleData	_far *params = ss:bp);	
/*
 *	Same as MSG_GO_SCALE except the undo string is set correctly to
 *	flipString.
 *
 *	Scale a grobject. [current matrix][scale]
 *	Anchors center of object.
 *
 * Context:	 GrObj Utility
 * Source:	 Unrestricted
 * Destination:  Any GrObject
 * Interception: Unlikely
 *
 * Pass:
 *	ss:bp - GrObjScaleData
 *			
 * Return:
 *	nothing
 *
 *	cx, dx, bp - unchanged
 *	ax - destroyed
 *
 */
 
@protoreset

/*-----------------------------------------------------------------------------
;	GrObjClass Instance Data
-----------------------------------------------------------------------------*/



@instance LinkPart GOI_drawLink;
@instance LinkPart GOI_reverseLink;
@instance GrObjAttrFlags GOI_attrFlags = (GOAF_INSERT_DELETE_MOVE_ALLOWED | 	GOAF_INSERT_DELETE_RESIZE_ALLOWED | GOAF_INSERT_DELETE_DELETE_ALLOWED );
@instance GrObjOptimizationFlags GOI_optFlags = ( GOOF_GROBJ_INVALID );
@instance GrObjMessageOptimizationFlags GOI_msgOptFlags =(0);
@instance GrObjLocks GOI_locks = 0;
@instance GrObjActionModes GOI_actionModes = 0;
@instance GrObjTempModes GOI_tempState = 0;
@instance ChunkHandle GOI_normalTransform = NullChunk;
@instance ChunkHandle GOI_spriteTransform = NullChunk;
@instance word GOI_areaAttrToken = CA_NULL_ELEMENT;
@instance word GOI_lineAttrToken = CA_NULL_ELEMENT;

/*-----------------------------------------------------------------------------
;	GrObjClass VarData
-----------------------------------------------------------------------------*/

typedef struct {		/* CHECKME */
    optr	GOOMD_actionGrObj;
    PointDWFixed	GOOMD_origMousePt;
    GrObjHandleSpecification	GOOMD_oppositeHandle;
    GrObjHandleSpecification	GOOMD_grabbedHandle;
    WWFixed	GOOMD_initialAngle;
    PointDWFixed	GOOMD_oppositeAnchor;
    WWFixed	GOOMD_oppositeInitialAngle;
} GrObjObjManipData;


@vardata GrObjObjManipData ATTR_GO_OBJ_MANIP_DATA;
@vardata GrObjActionNotificationStruct ATTR_GO_ACTION_NOTIFICATION;
@vardata PointWWFixed	ATTR_GO_PARENT_DIMENSIONS_OFFSET;
@endc





/*-----------------------------------------------------------------------------
;	GrObjAttributeManager Class Definition
-----------------------------------------------------------------------------*/

@class	GrObjAttributeManagerClass, GrObjClass;

/*-----------------------------------------------------------------------------
;	GrObjAttributeManager Class Methods 
-----------------------------------------------------------------------------*/

/****************************************************************************/
@message void MSG_GOAM_CREATE_ALL_ARRAYS();		/*XXX*/
/*
 * 	Have the attribute mannager create all the arrays it needs to 
 * 	manage the attributes. See MSG_GOAM_ATTACH_AND_CREATE_ARRAYS for 
 * 	contrast.
 * 
 *  Context:	Sent shortly after the attribute manager has been
 * 		created and the user doesn't want to create and 
 * 		intialize any of the arrays him/herself.
 *  Source:	Generally GenDocument while handling 
 * 		MSG_GEN_DOCUMENT_INITIALIZE_DOCUMENT_FILE
 *  Destination:	GrObjAttributeManager
 *  Interception:	Unlikely
 * 
 * PASS
 * 	nothing
 * 
 * RETURN
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */

typedef struct {		/* CHECKME */

/*
 * VM block handle of element array
 * for area attributes. Chunk must
 * be at GROBJ_VM_ELEMENT_ARRAY_CHUNK
 * If 0, area array will be created.
 */
    VMBlockHandle	GOAMAD_areaAttrArrayHandle;

/*
 * Element number of default attributes
 * in area array. Value ignored if
 * 0 passed for areaAttrArrayHandle
 */
    word		GOAMAD_areaDefaultElement;

/*
 * VM block handle of element array
 * for line attributes. Chunk must
 * be at GROBJ_VM_ELEMENT_ARRAY_CHUNK
 * If 0, text array will be created.
 */
    VMBlockHandle	GOAMAD_lineAttrArrayHandle;

/*
 * Element number of default attributes
 * in line array. Value ignored if
 * 0 passed for lineAttrArrayHandle
 */
    word	GOAMAD_lineDefaultElement;

/*
 * VM block handle of element array
 * for grobj styles. Chunk must
 * be at GROBJ_VM_ELEMENT_ARRAY_CHUNK
 * If 0, style array will be created.
 */
    VMBlockHandle	GOAMAD_grObjStyleArrayHandle;

/*
 * VM block handle of element array
 * for char attributes. Chunk must
 * be at GROBJ_VM_ELEMENT_ARRAY_CHUNK
 * If 0, char array will be created.
 */
    VMBlockHandle	GOAMAD_charAttrArrayHandle;

/*
 * Element number of default attributes
 * in char array. Value ignored if
 * 0 passed for charAttrArrayHandle
 */
    word		GOAMAD_charDefaultElement;

/*
 * VM block handle of element array
 * for paragraph attributes. Chunk must
 * be at GROBJ_VM_ELEMENT_ARRAY_CHUNK
 * If 0, text array will be created.
 */
    VMBlockHandle	GOAMAD_paraAttrArrayHandle;

/*
 * Element number of default attributes
 * in paragraph array. Value ignored if
 * 0 passed for paraAttrArrayHandle
 */
    word		GOAMAD_paraDefaultElement;

/*
 * VM block handle of element array
 * for types. Chunk must
 * be at GROBJ_VM_ELEMENT_ARRAY_CHUNK
 * If 0, text array will be created.
 */
    VMBlockHandle	GOAMAD_typeArrayHandle;

/*
 * Element number of default attributes
 * in type array. Value ignored if
 * 0 passed for paraAttrArrayHandle
 */
    word		GOAMAD_typeDefaultElement;

/*
 * VM block handle of element array
 * for graphics. Chunk must
 * be at GROBJ_VM_ELEMENT_ARRAY_CHUNK
 * If 0, graphic array will be created.
 */
    VMBlockHandle	GOAMAD_graphicArrayHandle;

/*
 * VM block handle of element array
 * for graphics. Chunk must
 * be at GROBJ_VM_ELEMENT_ARRAY_CHUNK
 * If 0, graphic array will be created.
 */
    VMBlockHandle	GOAMAD_nameArrayHandle;

/*
 * VM block handle of element array
 * for text styles. Chunk must
 * be at GROBJ_VM_ELEMENT_ARRAY_CHUNK
 * If 0, style array will be created.
 */
    VMBlockHandle	GOAMAD_textStyleArrayHandle;

} GrObjAttributeManagerArrayDesc;


@message void MSG_GOAM_ATTACH_AND_CREATE_ARRAYS(
	GrObjAttributeManagerArrayDesc *desc = ss:bp);
/*
 * 	Have the attribute manager use the passed arrays and
 * 	create the ones not passed.
 * 	See MSG_GOAM_CREATE_ARRAYS for contrast.
 * 
 *  Context:	Sent shortly after the attribute manager has been
 * 		created and the user has created some or all of the
 * 		arrays need for attribute management
 *  Source:	Generally GenDocument while handling 
 * 		MSG_GEN_DOCUMENT_INITIALIZE_DOCUMENT_FILE
 *  Destination:	GrObjAttributeManager
 *  Interception:	Unlikely
 * 
 * PASS
 * 	ss:bp - GrObjAttributeManagerArrayDesc
 * 		For the three grobj arrays you must either pass all
 * 		three arrays or all three as 0
 * 		For the three text arrays you must either pass all
 * 		three arrays or all three as 0
 * 		
 * 
 * RETURN
 * 	nothing
 * 
 * 
 * DESTROYED:
 * 	ax
 */


@message word MSG_GOAM_ADD_AREA_ATTR_ELEMENT(
	GrObjBaseAreaAttrElement *element = ss:bp) = ax; /* Needs better proto */
/*
 * 	Add an element (or a new reference to an existing element)
 * 	in the area attr element array
 * 
 *  Context:	GrObjAttributeManager Utility		
 *  Source:	Any grobject under a GrObjBody that is attached to
 * 		the GrObjAttributeManager
 *  Destination:	GrObjAttributeManager
 *  Interception:	Unlikely
 * 
 * PASS
 * 	ss:bp - GrObjBaseAreaAttrElement
 * 
 * RETURN
 * 	ax - area token
 * 	stc - if this element newly added
 * 
 * DESTROYED:
 * 	nothing
 */


@message word MSG_GOAM_ADD_LINE_ATTR_ELEMENT(
	GrObjBaseLineAttrElement *element = ss:bp) = ax; /* Needs better proto */
/*
 * 	Add an element (or a new reference to an existing element)
 * 	in the line attr element array
 * 
 *  Context:	GrObjAttributeManager Utility		
 *  Source:	Any grobject under a GrObjBody that is attached to
 * 		the GrObjAttributeManager
 *  Destination:	GrObjAttributeManager
 *  Interception:	Unlikely
 * 
 * PASS
 * 	ss:bp - GrObjBaseLineAttrElement
 * 
 * RETURN
 * 	ax - line token
 * 	stc - if this element newly added
 * 
 * DESTROYED:
 * 	nothing
 */


@message Boolean MSG_GOAM_DEREF_AREA_ATTR_ELEMENT_TOKEN(
	word token = cx) = carry;
/*
 * 	Dereference element in area attr array (remove if
 * 	reference count geos to zero)
 * 
 *  Context:	GrObjAttributeManager Utility		
 *  Source:	Any grobject under a GrObjBody that is attached to
 * 		the GrObjAttributeManager
 *  Destination:	GrObjAttributeManager
 *  Interception:	Unlikely
 * 
 * PASS
 * 	cx - area token
 * 
 * RETURN
 * 	stc  - if element actually removed
 */


@message Boolean MSG_GOAM_DEREF_LINE_ATTR_ELEMENT_TOKEN(
	word token = cx) = carry;
/*
 * 	Dereference element in line attr array (remove if
 * 	reference count geos to zero)
 * 
 *  Context:	GrObjAttributeManager Utility		
 *  Source:	Any grobject under a GrObjBody that is attached to
 * 		the GrObjAttributeManager
 *  Destination:	GrObjAttributeManager
 *  Interception:	Unlikely
 * 
 * PASS
 * 	cx - line token
 * 
 * RETURN
 * 	stc  - if element actually removed
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GOAM_ADD_REF_AREA_ATTR_ELEMENT_TOKEN(word token = cx);
/*
 * 	Add reference to element in area attr array 
 * 
 *  Context:	GrObjAttributeManager Utility		
 *  Source:	Any grobject under a GrObjBody that is attached to
 * 		the GrObjAttributeManager
 *  Destination:	GrObjAttributeManager
 *  Interception:	Unlikely
 * 
 * PASS
 * 	cx - area token
 * 
 * RETURN
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */

@message void MSG_GOAM_ADD_REF_LINE_ATTR_ELEMENT_TOKEN(word token = cx);
/*
 * 	Add reference to element in line attr array 
 * 
 *  Context:	GrObjAttributeManager Utility		
 *  Source:	Any grobject under a GrObjBody that is attached to
 * 		the GrObjAttributeManager
 *  Destination:	GrObjAttributeManager
 *  Interception:	Unlikely
 * 
 * PASS
 * 	cx - line token
 * 
 * RETURN
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */



@message void MSG_GOAM_GET_FULL_AREA_ATTR_ELEMENT(); 	/* Needs Prototype */
/*
 * 	Get area attribute element from element array
 * 
 *  Context:	GrObjAttributeManager Utility		
 *  Source:	Unrestricted
 *  Destination:	GrObjAttributeManager
 *  Interception:	Unlikely
 * 
 * PASS
 * 	cx - area token
 * 	ss:bp - GrObjFullAreaAttrElement - empty
 * 
 * RETURN
 * 	carry set if passed token valid
 * 		ss:bp - GrObjFullAreaAttrElement - filled
 * 		ax - element size
 * 
 * 	carry clear if no information retured
 * 
 * DESTROYED:
 * 	ax
 */



@message void MSG_GOAM_GET_FULL_LINE_ATTR_ELEMENT(); 	/* Needs Prototype */
/*
 * 	Get line attribute element from element array
 * 
 *  Context:	GrObjAttributeManager Utility		
 *  Source:	Unrestricted
 *  Destination:	GrObjAttributeManager
 *  Interception:	Unlikely
 * 
 * PASS
 * 	cx - line token
 * 	ss:bp - GrObjFullLineAttrElement - empty
 * 
 * RETURN
 * 	carry set if passed token valid
 * 		ss:bp - GrObjFullLineAttrElement - filled
 * 		ax - element size
 * 
 * 	carry clear if no information retured
 * 
 * DESTROYED:
 * 	ax
 */

@message Boolean MSG_GOAM_GET_STYLE_ARRAY(word retVal = cx);
/*
 * 	Get the style array handle
 * 
 *  Context:	GrObjAttributeManager Utility		
 *  Source:	Unrestricted
 *  Destination:	GrObjAttributeManager
 *  Interception:	Unlikely
 * 
 * PASS
 * 	nothing
 * 
 * RETURN
 * 	carry set if valid value
 * 		cx - array block handle
 * 
 * 	carry clear if no information retured
 * 
 * DESTROYED:
 * 	nothing
 */

@message Boolean MSG_GOAM_GET_AREA_ATTR_ARRAY(word retVal = cx);
/*
 * 	Get the area array handle
 * 
 *  Context:	GrObjAttributeManager Utility		
 *  Source:	Unrestricted
 *  Destination:	GrObjAttributeManager
 *  Interception:	Unlikely
 * 
 * PASS
 * 	nothing
 * 
 * RETURN
 * 	carry set if valid value
 * 		cx - array block handle
 * 
 * 	carry clear if no information retured
 * 
 * DESTROYED:
 * 	nothing
 */

@message Boolean MSG_GOAM_GET_LINE_ATTR_ARRAY(word retVal = cx);
/*
 * 	Get the line array handle
 * 
 *  Context:	GrObjAttributeManager Utility		
 *  Source:	Unrestricted
 *  Destination:	GrObjAttributeManager
 *  Interception:	Unlikely
 * 
 * PASS
 * 	nothing
 * 
 * RETURN
 * 	carry set if valid value
 * 		cx - array block handle
 * 
 * 	carry clear if no information retured
 * 
 * DESTROYED:
 * 	nothing
 */

typedef struct {
	word	AALT_areaToken;
	word	AALT_pad1;
	word	AALT_message;
	word	AALT_pad2;
} AreaAndLineToken;

@message Boolean MSG_GOAM_GET_AREA_AND_LINE_TOKENS_FROM_STYLE(
	AreaAndLineToken *retVal = axcxdxbp,
	word token = cx) = carry;
/*
 * 	Returns the area and line tokens stored in the style
 * 	represented by the passed style token
 * 
 *  Context:	GrObjAttributeManager Utility		
 *  Source:	Unrestricted
 *  Destination:	GrObjAttributeManager
 *  Interception:	Unlikely
 * 
 * PASS
 * 		cx - style token
 * 
 * RETURN
 * 		carry set if style not found, else
 * 
 * 		carry clear
 * 		ax - area attr token
 * 		dx - line attr token
 * 
 * DESTROYED:
 * 	nothing
 */

@message void MSG_GOAM_ATTACH_BODY(optr bodyOD = cx:dx);
/*
 * 	add the passed GrObjBody OD to the GOAM's body list
 * 
 *  Context:	GrObjAttributeManager Utility		
 *  Source:	Most likely from MSG_GB_ATTACH_GOAM method
 *  Destination:	GrObjAttributeManager
 *  Interception:	Unlikely
 * 
 * PASS:		^lcx:dx = GrObjBody object
 * 
 * RETURN:	nothing
 * 
 * DESTROYED:
 * 		ax
 */


@message void MSG_GOAM_INVALIDATE_BODIES();
/*
 * 	send a MSG_GB_INVALIDATE to every GrObjBody in the GOAM's 
 * 	body list. eg., if a style changes and they all need to know
 * 	about it.
 * 
 *  Context:	GrObjAttributeManager Utility		
 *  Source:	Unlimited
 *  Destination:	GrObjAttributeManager
 *  Interception:	Unlikely
 * 
 * PASS:		nothing
 * 
 * RETURN:	nothing
 */



@message void MSG_GOAM_SUBST_AREA_TOKEN(
	word oldToken = cx,
	word newToken = dx,
	Boolean updateReferenceCounts = bp);
/*
 * 	Inform all the GrObjBodys in the GOAM's list that any GrObjs
 * 	with the passed "old" token should replace it with the new one,
 * 	updating the reference count if specified.
 * 
 *  Context:	GrObjAttributeManager Utility		
 *  Source:	Most likely from the style substitution callack
 *  Destination:	GrObjAttributeManager
 *  Interception:	Unlikely
 * 
 * PASS:		cx - old area token
 * 		dx - new area token
 * 		bp - nonzero if GrObjs should update reference counts
 * 			to both the old and new tokens
 * 
 * RETURN:	nothing
 * 
 * DESTROYED:	ax
 */


@message void MSG_GOAM_SUBST_LINE_TOKEN(
	word oldToken = cx,
	word newToken = dx,
	Boolean updateReferenceCounts = bp);
/*
 * 	Inform all the GrObjBodys in the GOAM's list that any GrObjs
 * 	with the passed "old" token should replace it with the new one,
 * 	updating the reference count if specified.
 * 
 *  Context:	GrObjAttributeManager Utility		
 *  Source:	Most likely from the style substitution callack
 *  Destination:	GrObjAttributeManager
 *  Interception:	Unlikely
 * 
 * PASS:		cx - old line token
 * 		dx - new line token
 * 		bp - nonzero if GrObjs should update reference counts
 * 			to both the old and new tokens
 * 
 * RETURN:	nothing
 * 
 * DESTROYED:	ax
 */

@message optr MSG_GOAM_GET_TEXT_OD() = cx:dx;
/*
 * 	Return the output descriptor of the text object that the
 * 	attribute manager uses to keep track of the default text
 * 	attributes.
 * 
 *  Context:	GrObjAttributeManager Utility
 *  Source:	Unrestricted
 *  Destination:  GrObjAttributeManager
 *  Interception: Unlikely
 * 
 * PASS:		
 * 	nothing
 * 			
 * RETURN:	
 * 	^lcx:dx - text od
 * 
 * DESTROYED:
 * 	ax
 */


typedef struct {		/* CHECKME */
    VMBlockHandle	GOTA_charAttrArray;
    VMBlockHandle	GOTA_paraAttrArray;
    VMBlockHandle	GOTA_typeArray;
    VMBlockHandle	GOTA_graphicArray;
    VMBlockHandle	GOTA_nameArray;
    VMBlockHandle	GOTA_textStyleArray;
} GrObjTextArrays;

@message void MSG_GOAM_GET_TEXT_ARRAYS(GrObjTextArrays *retVal = ss:bp);
/*
 * 	Return the vm block handles of the char, para and style arrays.
 * 
 *  Context:	GrObjAttributeManager Utility
 *  Source:	Unrestricted
 *  Destination:  GrObjAttributeManager
 *  Interception: Unlikey
 * 
 * PASS:		
 * 	ss:bp - GrObjTextArrays
 * 
 * RETURN:
 * 	ss:bp - structure filled
 * 
 * DESTROYED:
 * 	ax
 */

@message void MSG_GOAM_LOAD_STYLE_SHEET_PARAMS();	/* Needs Prototype */
/*
 * 	Fills out a StyleSheetParams struct
 * 
 *  Context:	GrObjAttributeManager Utility
 *  Source:	Unrestricted
 *  Destination:  GrObjAttributeManager
 *  Interception: Unlikey
 * 
 * PASS:		
 * 	ss:[bp] - empty StyleSheetParams
 * 	cx - nonzero to preserve xfer arrays
 * 
 * RETURN:	
 * 	ss:[bp] - StyleSheetParams
 * 
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GOAM_DETACH_BODY(optr bodyOD = cx:dx);
/*
 * 	Remove the passed GrObjBody OD from the GOAM's body list
 * 
 *  Context:	GrObjAttributeManager Utility		
 *  Source:	Most likely from the body when it is handling MSG_GB_CLEAR
 *  Destination:	GrObjAttributeManager
 *  Interception:	Unlikely
 * 
 * PASS:		^lcx:dx = GrObjBody object
 * 
 * RETURN:	nothing
 * 
 * DESTROYED:
 * 		ax
 */

@message void MSG_GOAM_SUBST_TEXT_ATTR_TOKEN(VisTextSubstAttrTokenParams *params = ss:bp);
/*
 * 	A text object has requested an attribute substitution, so we
 * 	need to relay the message to all text objects in all the bodies.
 * 
 *  Context:	Unrestricted.
 *  Source:	Unrestricted
 *  Destination:  GrObjBody
 *  Interception: Unlikely
 * 
 * PASS:		
 * 	ss:bp - VisTextSubstAttrTokenParams
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GOAM_RECALC_FOR_TEXT_ATTR_CHANGE(Boolean relayed = cx);
/*
 * 	A text object has requested an attribute substitution, so we
 * 	need to relay the message to all text objects in all the bodies
 * 
 *  Context:	Unrestricted.
 *  Source:	Unrestricted
 *  Destination:  GrObjBody
 *  Interception: Unlikely
 * 
 * PASS:
 * 	cx - nonzero if relayed to all text objects
 * RETURN:
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GOAM_LOAD_STYLE_SHEET();	/* Needs Prototype */
/*
 * 	Fills out a StyleSheetParams struct
 * 
 *  Context:	GrObjAttributeManager Utility
 *  Source:	Unrestricted
 *  Destination:  GrObjAttributeManager
 *  Interception: Unlikey
 * 
 * PASS:		
 * 	ss:[bp] - empty StyleSheetParams
 * 	cx - nonzero to preserve xfer arrays
 * 
 * RETURN:	
 * 	ss:[bp] - StyleSheetParams
 * 
 * 
 * DESTROYED:
 * 	ax
 */



@message void MSG_GOAM_SET_GROBJ_DRAW_FLAGS(GrObjDrawFlags flagsToSet = cx,
					  GrObjDrawFlags flagsToReset = dx); /* XXX */
/*
 * 	Sends a MSG_GB_SET_GROBJ_DRAW_FLAGS_NO_BROADCAST to all the GOAM's
 * 	bodies
 * 
 *  Context:	GOAM Utility
 *  Source:	Unrestricted
 *  Destination:  GOAM
 *  Interception: Unlikely
 * 
 * PASS:		
 * 
 * 	cx - GrObjDrawFlags to set
 * 	dx - GrObjDrawFlags to reset
 * 
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:  
 * 	ax
 */

/*-----------------------------------------------------------------------------
	GrObjAttributeManager Structures & Instance Data
-----------------------------------------------------------------------------*/
@default GOI_optFlags = ( /* GOI_optFlags*/ GOOF_GROBJ_INVALID | GOOF_ATTRIBUTE_MANAGER );

#define GROBJ_VM_ELEMENT_ARRAY_CHUNK	(sizeof (LMemblockHeader))	/*???*/

@instance word    GOAMI_areaAttrArrayHandle = 0;

@instance word    GOAMI_lineAttrArrayHandle = 0;

@instance word    GOAMI_grObjStyleArrayHandle = 0;

@instance ChunkHandle    GOAMI_bodyList = 0;

@instance word    GOAMI_charAttrArrayHandle = 0;

@instance word    GOAMI_paraAttrArrayHandle = 0;

@instance word    GOAMI_typeArrayHandle = 0;

@instance word    GOAMI_graphicArrayHandle = 0;

@instance word    GOAMI_nameArrayHandle = 0;

@instance word    GOAMI_textStyleArrayHandle = 0;

@instance optr    GOAMI_text;

@endc

/*-----------------------------------------------------------------------------
	GrObjBodyClass
-----------------------------------------------------------------------------*/

@class GrObjBodyClass, VisCompClass;

/*-----------------------------------------------------------------------------
	GrObjBodyClass
-----------------------------------------------------------------------------*/

@message GStateHandle MSG_GB_CREATE_GSTATE() = bp;
/*
 * 	For speed purposes the grobj keeps a cached gstate.
 * 	When something in the grobj requests a gstate we
 * 	create a gstate and copy the cached gstates transform
 * 	into the new one. This prevent us from having
 * 	to vup up the vis linking several more levels.
 * 	We don't use the cached gstate so that the caller can
 * 	function just as if it called GrCreateState and 
 * 	destroy the gstate when it is done.
 * 
 * PASS
 * 	nothing
 * 
 * RETURN
 * 	bp - gstate
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GB_INVALIDATE();
/*
 * 	Invalidate all the GrObjs under this body
 * 
 * PASS
 * 	nothing
 * 
 * RETURN
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GB_GIVE_ME_MOUSE_EVENTS(optr childOD = cx:dx);
/*
 * 	Tell body to send mouse events to a child
 * 
 * PASS
 * 	cx:dx - od of child
 * 
 * RETURN
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GB_DONT_GIVE_ME_MOUSE_EVENTS(optr childOD = cx:dx);
/*
 * 	Tell body to stop sending mouse events to a child
 * 
 * PASS
 * 	cx:dx - od of child
 * 
 * RETURN
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GB_ATTACH_HEAD(optr headOD = cx:dx);
/*
 * 	Set Head OD in instance data
 * 
 *  Context:	GrObjBody Utility
 *  Source:	Unrestricted. Generally the GenDocument on 
 * 		MSG_GEN_DOCUMENT_ATTACH_UI
 *  Destination:	GrObjBody
 *  Interception:	Unlikely
 */

/****************************************************************************/
@message void MSG_GB_ATTACH_GOAM(optr GrObjAttrManager = cx:dx);	/*XXX*/
/*
 * 	Set GrObjAttributeManager OD in instance data and attach the
 * 	body to the GOAM's bodyList.
 * 
 *  Context:	GrObjBody Utility
 *  Source:	Unrestricted. Generally the GenDocument on 
 * 		MSG_GEN_DOCUMENT_INITIALIZE_DOCUMENT_FILE
 *  Destination:	GrObjBody
 *  Interception:	Unlikely
 *
 * PASS
 * 	cx:dx - OD of GrObjAttributeManager
 * 
 * RETURN
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */



@message void MSG_GB_ATTACH_RULER(optr rulerOD = cx:dx);
/*
 * 	Set Ruler OD in instance data
 * 
 *  Context:	GrObjBody Utility
 *  Source:	Unrestricted. Generally the GenDocument on 
 * 		MSG_GEN_DOCUMENT_INITIALIZE_DOCUMENT_FILE
 *  Destination:	GrObjBody
 *  Interception:	Unlikely
 * 
 * PASS
 * 	cx:dx - OD of VisRuler
 * 
 * RETURN
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */

typedef WordFlags GrObjBodyAddGrObjFlags;
#define GOBAGOF_DRAW_LIST_POSITION 	0x8000
#define GOBAGOF_REFERENCE 		0x7fff
#define GOBAGOF_REFERENCE_OFFSET	0
#define GOBAGOR_FIRST CCO_FIRST
#define GOBAGOR_LAST  CCO_LAST

@message void MSG_GB_ADD_GROBJ(optr object = cx:dx,
				word flags = bp);	 	/* XXX */
/*
 * 	Add a graphic object to the GrObjbody and generate an
 * 	undo chain to undo the add. The object will be
 * 	notified via MSG_GO_AFTER_ADDED_TO_BODY that it has been added
 * 	to the body. The object will not be drawn. If the caller
 * 	wishes to have the object drawn at this time, then use
 * 	MSG_GB_ADD_GROBJ_THEN_DRAW insteads
 * 
 *  Context:	GrObjBody Utility
 *  Source:	Unrestricted
 *  Destination:	GrObjBody
 *  Interception:	Unlikely
 * 
 * PASS
 * 	cx:dx - optr of child to add
 * 	bp - GrObjBodyAddGrObjFlags
 * 
 * RETURN
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */



@message void MSG_GB_REMOVE_GROBJ(optr childOD = cx:dx);
/*
 * 	Remove a grobject from the graphic body and generate
 * 	undo chain to undo remove. Warning, this message
 * 	will not cause the child to release exclusives, drop selection,
 * 	drop edit and such. In general you should use 
 * 	MSG_GO_REMOVE_FROM_BODY which is sent to the child.
 * 	
 * 
 *  Context:	GrObj Body Utility	
 *  Source:	Unrestricted
 *  Destination:  Body
 *  Interception: Unlikely
 * 
 * PASS:		
 * 	^lcx:dx - child
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */




typedef struct {
	word	DOARDO_reverseDrawOrder;
	word	DOARDO_drawOrder;
} DrawOrderAndReverseDrawOrder;

@message Boolean MSG_GB_FIND_GROBJ(
	DrawOrderAndReverseDrawOrder retVal = dxcx,
	optr childOD = cx:dx) = carry;
/*
 * 	Find the position in the draw list and reverse list of child
 * 	of the body
 * 
 * PASS
 * 	cx:dx - optr of child to find
 * 
 * RETURN
 * 	stc - found
 * 		cx - position in draw list (0 = first child)
 * 		dx - position in reverse list (0 = first child)
 * 	clc - not found
 * 		cx,dx - destroyed
 * 
 * DESTROYED:
 * 	ax
 */



@message void MSG_GB_PULL_SELECTED_GROBJS_TO_FRONT();
/*
 * 	Bring the selected grobjs to the front of the document.
 * 	(i.e. move them to the end of the drawing list)
 * 
 *  Context:	GrObjBody Utility
 *  Source:	Unrestricuted
 *  Destination:  GrObj Body
 *  Interception: Unlikely
 *  Undo:		Generates an undo chain with text
 * 
 * PASS:		
 * 	nothing
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GB_PUSH_SELECTED_GROBJS_TO_BACK();
/*
 * 	Push the selected grobjs to the back of the document.
 * 	(i.e. move them to the begining of the drawing list)
 * 
 *  Context:	GrObjBody Utility
 *  Source:	Unrestricuted
 *  Destination:  GrObj Body
 *  Interception: Unlikely
 *  Undo:		Generates an undo chain with text
 * 
 * PASS:		
 * 	nothing
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GB_SHUFFLE_SELECTED_GROBJS_UP();
/*
 * 	Move selected grobjs one closer to end of the draw list
 * 
 *  Context:	GrObjBody Utility
 *  Source:	Unrestricted
 *  Destination:  GrObj Body
 *  Interception: Unlikely
 *  Undo:		Generates an undo chain with text
 * 
 * PASS
 * 	nothing
 * 
 * RETURN
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GB_SHUFFLE_SELECTED_GROBJS_DOWN();
/*
 * 	Move selected grobjs one closer to begining of the draw list
 * 	
 *  Context:	GrObjBody Utility
 *  Source:	Unrestricted
 *  Destination:  GrObj Body
 *  Interception: Unlikely
 *  Undo:		Generates an undo chain with text
 * 
 * 
 * PASS
 * 	nothing
 * RETURN
 * 	even less
 * DESTROYED:
 * 	ax
 */



@message void MSG_GB_SET_DESIRED_HANDLE_SIZE(byte handleSize = cl); /* XXX */
/*
 * 	set desired handle width for selected objects
 * 
 * PASS
 * 	cl - desired handle size (in DEVICE coords)
 * RETURN
 * 	nothing
 * DESTROYED:
 * 	ax
 */

@message byte MSG_GB_GET_DESIRED_HANDLE_SIZE() = al;
/*
 * 	set desired handle width for selected objects
 * 
 * PASS
 * 	nothing
 * RETURN
 * 	al - desired handle size (in DEVICE coords)
 * DESTROYED:
 * 	nothing
 */





/****************************************************************************/
@message void MSG_GB_ATTACH_UI(optr GrObjHead = cx:dx);	/* XXX */
/*
 * 	Prepare GrObjBody for opening
 * 
 *  Context:	MUST be sent to body after it has been added to the
 * 		document, which should be done on		
 * 		MSG_GEN_DOCUMENT_ATTACH_UI
 *  Source:	Generally GenDocument object
 *  Destination:	GrObjBody
 *  Interception:	Unlikely.
 * 
 * PASS
 * 	cx:dx - OD of GrObjHead
 * 	
 * 
 * RETURN
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GB_DETACH_UI();	 	/* XXX */
/*
 * 	Prepare GrObjBody for closing
 * 
 *  Context:	MUST be sent to body before it is removed from the
 * 		document, which should be done on		
 * 		MSG_GEN_DOCUMENT_DETACH_UI
 *  Source:	Generally GenDocument object
 *  Destination:	GrObjBody
 *  Interception:	Unlikely.
 * 
 * PASS
 * 	nothing
 * 	
 * 
 * RETURN
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */





@message void MSG_GB_ADD_GROBJ_TO_SELECTION_LIST(optr grobjOD = cx:dx,
						 HandleUpdateMode mode = bp);
/*
 * 	Add passed child to selection list.
 * 
 * 	NOTE: If you want to add a child to the body, send the child
 * 	MSG_GO_BECOME_SELECTED. DO NOT send this message to the body
 * 	with the child's od. The child may have its selection lock set
 * 	or other instance data that should prevent it from being selected.
 * 
 *  Context:	When a grobject is handling MSG_GO_BECOME_SELECTED.
 *  Source:	GrObject
 *  Destination:	GrObjBody
 *  Interception:	Unlikely.
 * 
 * PASS
 * 	cx:dx - OD of child
 * 	bp low - HandleUpdateMode
 * 
 * RETURN
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GB_REMOVE_GROBJ_FROM_SELECTION_LIST(optr grobjOD = cx:dx);
/*
 * 	Remove passed child from selection list
 * 
 * PASS
 * 	cx:dx - OD of child
 * 
 * RETURN
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GB_REMOVE_ALL_GROBJS_FROM_SELECTION_LIST();
/*
 * 	Removes all children from selection list
 * 
 * PASS
 * 	nothing
 * 
 * RETURN
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GB_SEND_CLASSED_EVENT_TO_SELECTED_GROBJS(EventHandle event = cx);
/*
 * 	Sends encapsulated classed event to all 
 * 	grobjects on selection list
 * 
 * PASS
 * 	cx - event handle
 * 
 * RETURN
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */



@message word MSG_GB_GET_NUM_SELECTED_GROBJS() = bp;
/*
 * 	return number of children in selection list
 * 
 * PASS
 * 	nothing
 * 
 * RETURN
 * 	bp - number of children
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GB_GET_BOUNDS_OF_SELECTED_GROBJS(RectDWord *bounds = ss:bp);
/*
 * 	Returns the bounds that encompass all the selected objects
 * 
 * PASS
 * 	ss:bp - RectDWord
 * 
 * RETURN
 * 	ss:bp - RectDWord
 * 
 * DESTROYED:
 * 	ax
 */



@message void MSG_GB_GET_DWF_BOUNDS_OF_SELECTED_GROBJS(RectDWFixed *bounds = ss:bp);
/*
 * 	Returns the bounds that encompass all the selected objects
 * 
 * PASS
 * 	ss:bp - RectDWFixed
 * 
 * RETURN
 * 	ss:bp - RectDWFixed
 * DESTROYED:
 * 	ax
 */


@message void MSG_GB_GET_SUMMED_DWF_DIMENSIONS_OF_SELECTED_GROBJS(RectDWFixed *bounds = ss:bp);
/*
 * 	Returns the summed heights/widths of all the selected objects
 * 
 * PASS
 * 	ss:bp - RectDWFixed
 * 
 * RETURN
 * 	ss:bp - RectDWFixed
 * DESTROYED:
 * 	ax
 */


typedef ByteFlags GrObjsInRectSpecial;		/* CHECKME */
/* 5 bits unused */
/*
 * don't send tempMessage to
 * objects with GOTM_TEMP_HANDLES
 * set
 */
#define GOIRS_IGNORE_TEMP	(0x04)

/*
 * don't send inRectMessage to
 * objects in rect
 */
#define GOIRS_IGNORE_RECT	(0x02)

/*
 * if both temp and inRect
 * conditions apply, send
 * neither. otherwise send
 * both. temp will always
 * be sent first.
 */
#define GOIRS_XOR_CHECK	(0x01)

typedef struct {
	word GOIRD_tempMessage;
	word GOIRD_tempMessageDX;
	word GOIRD_inRectMessage;
	word GOIRD_inRectMessageDX;
	RectDWord	GOIRD_rect;
	GrObjsInRectSpecial GOIRD_special;
/*	word align;	*/
} GrObjsInRectData;

@message void MSG_GB_DELETE_SELECTED_GROBJS();
/*
 * 	Delete all the children on the selected list
 * 
 * 
 * PASS
 * 	nothing
 * 
 * RETURN
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */



@message void MSG_GB_PROCESS_ALL_GROBJS_IN_RECT(GrObjsInRectData *rectData = ss:bp);
/*
 * 		Compares the visBounds of each object with the rectangle
 * 		for some condition. If condition is met, send method
 * 		to object with stack frame. The rect and condition flags
 * 		are in the TestRectangleStruct
 * 		
 * 
 * PASS
 * 	ss:bp - GrObjsInRectData
 * 	dx - size GrObjsInRectData
 * 
 * RETURN
 * 	nothing
 * DESTROYED:
 * 	ax
 */


@message void MSG_GB_INCREASE_POTENTIAL_EXPANSION(word potentialExpansion = cx,
						  hptr block = dx);
/*
 * 	Notify the tree that an object just instantiated could
 * 	expand to a maximum of the amount passed
 * 
 * PASS
 * 	cx - #bytes object may expand - may no be more than MAX_OBJ_EXPANSION
 * 	dx - handle of block
 * 
 * RETURN
 * 	nothing 
 * DESTROYED:
 * 	ax
 */




@message void MSG_GB_DECREASE_POTENTIAL_EXPANSION(word potentialExpansion = cx,
						  hptr block = dx);
/*
 * 	Notify the tree that an object about to be destroyed previously
 * 	increased the increased potential
 * 
 * PASS
 * 	cx - #bytes object may expand - may no be more than MAX_OBJ_EXPANSION
 * 	dx - handle of block
 * RETURN
 * 	nothing 
 * 
 * DESTROYED:
 * 	ax
 */



typedef ByteFlags PriorityListInstructions;		/* CHECKME */
/*
 * Do trivial reject check on bounds
 * of objects that include the selection
 * handles, instead of the normal
 * PARENT bounds which are only guaranteed
 * to surround the image
 */
#define PLI_CHECK_SELECTION_HANDLE_BOUNDS	(0x80)
/*
 * Only send messages to objects
 * that are in selection list
 */
#define PLI_ONLY_PROCESS_SELECTED	(0x40)
/*
 * Only send messages to objects
 * of class
 */
#define PLI_ONLY_PROCESS_CLASS	(0x20)
/*
 * Only insert items of class into
 * priority list
 */
#define PLI_ONLY_INSERT_CLASS	(0x10)
/*
 * Stop processing children after
 * an object evaluates high
 */
#define PLI_STOP_AT_FIRST_HIGH	(0x08)
/*
 * Only insert objects that evaluate
 * high
 */
#define PLI_ONLY_INSERT_HIGH	(0x04)
/*
 * Don't insert objects that
 * have their selection lock set.
 * These objects must return
 * EPN_SELECTION_LOCK_SET
 */
#define PLI_DONT_INSERT_OBJECTS_WITH_SELECTION_LOCK	(0x02)

typedef struct {		/* CHECKME */
    byte	PLI_align;
    word	PLI_message;
    PointDWFixed	PLI_point;
    PriorityListInstructions	PLI_instructions;
    word	PLI_maxElements;
    ClassStruct	*PLI_class;
} PLInit;

/*
CheckHack < offset PLI_class  eq (size PLInit-size PLI_class)>
*/

typedef struct {		/* CHECKME */
    optr	PLE_od;
    byte	PLE_priority;
    byte	PLE_other;
} PriorityListElement;


/*
 * If used as PriorityList message no message will actually be sent to object.
 * The bounds check will be considered sufficient for a high evaluation. No
 * other data or EvaluatePositionNotes will be set.
 */

#define PRIORITY_LIST_EVALUATE_PARENT_POINT_FOR_BOUNDS	0

typedef struct {		/* CHECKME */
/*
 * Method to send to each
 * object
 */
    word	PL_message;

/*
 * Document coord to be
 * examined by object
 */
    PointDWFixed	PL_point;

/*
 * Instructions for processing
 * of objects
 */
    PriorityListInstructions	PL_instructions;

/*
 * Class of object to be used
 * based on 
 * PriorityListInstructions
 */
    ClassStruct	*PL_class;

/*
 * Number of elements currently
 * in the list
 */
    word	PL_numElements;

/*
 * Maximum number of elements
 * allowed in list
 */
    word	PL_maxElements;

/*
 * Chunk handle of list
 * chunk array.
 */
    ChunkHandle	PL_list;
} PriorityList;



@message void MSG_GB_FILL_PRIORITY_LIST();
/*
 * 	Fill the GrObjBody's priority list
 * 
 * PASS
 * 	nothing
 * 
 * RETURN:
 * 	nothing
 * 	
 * DESTROYED:
 * 	ax
 */



@message void MSG_GB_MESSAGE_TO_FLOATER_IF_PARENT(Message floaterMessage = cx,
						  word data1 = dx,
						  word data2 = bp);
/*
 * 	Send method to floater if this body is its parent
 * 
 * PASS:
 * 	cx - method to send
 * 	dx,bp - method data
 * 
 * RETURN
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


typedef WordFlags GrObjUINotificationTypes;		/* CHECKME */
/* True if style notification needs to be sent */
#define GOUINT_STYLE	(0x8000)
/* True if area notification needs to be sent */
#define GOUINT_AREA	(0x4000)
/* True if line notification needs to be sent */
#define GOUINT_LINE	(0x2000)
/* True if grobj specific selection state notification needs to be sent */
#define GOUINT_GROBJ_SELECT	(0x1000)
/* True if style notification needs to be sent */
#define GOUINT_STYLE_SHEET	(0x0800)
/* True if edit menu notification need be sent */
#define GOUINT_SELECT	(0x0400)




@message void MSG_GB_UPDATE_UI_CONTROLLERS(GrObjUINotificationTypes types = cx);
/*
 * 	Update the GrObj controllers
 * 
 * PASS:
 * 	cx - GrObjUINotificationTypes
 * RETURN:
 * 	nothing
 * DESTROYED:
 * 	ax
 */


@message void MSG_GB_UPDATE_EXTENDED_AREA_ATTR_CONTROLLERS();
/*
 * 	Update the GrObj dealing with area attributes not of
 * 	type GOAAET_BASE
 * 
 * PASS:
 * 	nothing
 * RETURN:
 * 	nothing
 * DESTROYED:
 * 	ax
 */


@message void MSG_GB_UPDATE_EXTENDED_AREA_ATTR_CONTROLLERS_WITH_DEFAULTS();
/*
 * 	Update the GrObj dealing with area attributes not of
 * 	type GOAAET_BASE
 * 
 * PASS:
 * 	nothing
 * RETURN:
 * 	nothing
 * DESTROYED:
 * 	ax
 */


@message void MSG_GB_UPDATE_EXTENDED_LINE_ATTR_CONTROLLERS();
/*
 * 	Update the GrObj dealing with line attributes not of
 * 	type GOLAET_BASE
 * 
 * PASS:
 * 	nothing
 * RETURN:
 * 	nothing
 * DESTROYED:
 * 	ax
 */


@message void MSG_GB_UPDATE_EXTENDED_LINE_ATTR_CONTROLLERS_WITH_DEFAULTS();
/*
 * 	Update the GrObj dealing with line attributes not of
 * 	type GOLAET_BASE
 * 
 * PASS:
 * 	nothing
 * RETURN:
 * 	nothing
 * DESTROYED:
 * 	ax
 */


@message void MSG_GB_UPDATE_INSTRUCTION_CONTROLLERS();
/*
 * 	Update the GWNT_GROBJ_BODY_INSTRUCTION_FLAGS_CHANGE controllers
 * 	based on the body's instance data
 * 
 * PASS:
 * 	nothing
 * RETURN:
 * 	nothing
 * DESTROYED:
 * 	ax
 */


@message optr MSG_GB_ADD_DUPLICATE_FLOATER(optr dupOD = cx:dx) = cx:dx; 
/*
 * 	Add a duplicate of the passed object to the visual tree
 * 
 * PASS
 * 	cx:dx - OD of object to duplicate and add
 * 
 * RETURN
 * 	cx:dx - OD of new object
 * DESTROYED:
 * 	ax
 */



@message void MSG_GB_PRIORITY_LIST_RESET();
/*
 * 	Set the priority list back to zero elements
 * 
 * PASS
 * 	nothing	
 * 		
 * RETURN
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message word MSG_GB_PRIORITY_LIST_GET_NUM_ELEMENTS() = cx;
/*
 * 	Return number of elements in list
 * 
 * PASS
 * 	nothing	
 * 		
 * RETURN
 * 	cx - number of elements
 * 
 * DESTROYED:
 * 	ax
 */



typedef struct {
	byte    PE_priority;
	byte    PE_otherData;
	optr	PE_optr;
} PriorityElement;
	
@message Boolean MSG_GB_PRIORITY_LIST_GET_ELEMENT(PriorityElement *retVal = axcxdxbp, word elemNum = cx) = carry;
/*
 * 	Return info about an element in list
 * 
 * PASS
 * 	cx - element # (0 is first element)
 * 		
 * RETURN
 * 	stc - element doesn't exist
 * 	clc  - element exists
 * 		cx:dx - optr
 * 		al - priority
 * 		ah - other data
 * 	
 * DESTROYED:
 * 	ax
 */


@message void MSG_GB_PRIORITY_LIST_INIT(PLInit *init = cx:dx);
/*
 * 	Initialize priority list data
 * 
 * PASS
 * 	cx:dx - fptr to PLInit
 * 		
 * RETURN
 * 	nothing	
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GB_GROUP_SELECTED_GROBJS();
/*
 * 	Form a group composed of the selected children
 * 
 * PASS
 * 	nothing
 * 
 * RETURN
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GB_UNGROUP_SELECTED_GROUPS();
/*
 * 	Ungroup any selected children which are groups
 * 
 * PASS
 * 	nothing
 * 
 * RETURN
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message Boolean MSG_GB_TRANSFER_GROBJ_FROM_GROUP(CallBackMessageData *callbackData = ss:bp) = carry;
/*
 * 	Call back message for transfer children from group to
 * 	body during an ungroup	
 * 
 * PASS
 * 	ss:bp - CallBackMessageData
 * 		
 * RETURN
 * 	clc - keep processing children
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GB_CLOSE_FINISH_UP();		 	/* Needs Prototype */

@message void MSG_GB_CLEAR();
/*
 * 	Destroy the body, all its children, frees the blocks the
 * 	children are in but NOT the block the body is in.
 * 	More specifically, it releases all exclusives held by body, 
 * 	disconnects if from the head and attribute manager and sends 
 * 	MSG_META_OBJ_FREE to itself. On MSG_FINAL_OBJ_FREE the body
 * 	will send MSG_GO_QUICK_TOTAL_BODY_CLEAR to all its
 * 	children and the free all the children's blocks. This is done
 * 	instead of sending MSG_META_OBJ_FREE to each child because
 * 	that would flood the system queues with an alarming number
 * 	of messages.
 * 
 *  Context:	GrObjBody Utility
 *  Source:	Unrestricted
 *  Destination:  GrObjBody
 *  Interception: Unlikely
 * 
 * PASS:		
 * 	nothing
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */




@message void MSG_GB_ALIGN_SELECTED_GROBJS(AlignType type = cl);
/*
 * 	Aligns the selected objects according to the passed AlignType
 * 
 * PASS
 * 	cl = AlignType
 * 
 * RETURN
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GB_CREATE_SORTABLE_ARRAY();
/*
 * 	Allocates a block for a sortable selected array, and changes the
 * 	graphic body's instance data to point to it. The original array's
 * 	descriptor is stored in the new array's header.
 * 
 * PASS
 * 	nothing
 * 
 * RETURN
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GB_DESTROY_SORTABLE_ARRAY();
/*
 * 	Frees the block previously allocated for a sortable selected array,
 * 	(in handler for MSG_GB_CREATE_SORTABLE_ARRAY) and changes the
 * 	graphic body's instance data to point back to the original array.
 * 
 * PASS
 * 	nothing
 * 
 * RETURN
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */



@message void MSG_GB_FILL_SORTABLE_ARRAY_USING_GO_DWF_BOUNDS(word keyOffset = dx);
/*
 * 	Fills the Sortable array from the original array contained in
 * 	its header. The sortable array element is the OD from the
 * 	original element, plus a DWFixed key from the object specified
 * 	by the OD. The caller passes an offset into RectDWFixed to
 * 	specify which parameter from the object's bounds is to be
 * 	the key.
 * 
 * PASS
 * 	dx = offset into RectDWFixed of key
 * 
 * RETURN
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */



@message void MSG_GB_FILL_SORTABLE_ARRAY_USING_GO_CENTERS(word keyOffset = dx);
/*
 * 	Fills the Sortable array from the original array contained in
 * 	its header. The sortable array element is the OD from the
 * 	original element, plus a DWFixed key from the object specified
 * 	by the OD. The caller passes an offset into RectDWFixed to
 * 	specify which parameter from the object's bounds is to be
 * 	the key.
 * 
 * PASS
 * 	dx = offset into RectDWFixed of key
 * 
 * RETURN
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */

typedef struct {		/* CHECKME */
    ChunkArrayHeader	SAH_CAH;
    optr		SAH_originalArray;
} SortableArrayHeader;

typedef struct {		/* CHECKME */
    optr	SAE_OD;
    DWFixed	SAE_key;
} SortableArrayElement;

@message void MSG_GB_SORT_SORTABLE_ARRAY();
/*
 * 	Sort the sortable array based on each element's key.
 * 
 * PASS
 * 	nothing
 * 
 * RETURN
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GB_GET_CENTER_OF_SELECTED_GROBJS(PointDWFixed *center = ss:bp);
/*
 * 	Return the PointDWFixed center of the selected grobjs
 * 
 * PASS:
 * 		ss:bp = PointDWFixed
 * 		dx >= size PointDWFixed
 * 
 * RETURN:
 * 		ss:bp = PointDWFixed center
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GB_GET_CENTER_OF_FIRST_SELECTED_GROBJ(PointDWFixed *center = ss:bp);
/*
 * 	Return the PointDWFixed center of the first object in
 * 	the selection list
 * 
 * PASS:
 * 		ss:bp = PointDWFixed
 * 		dx >= size PointDWFixed
 * 
 * RETURN:
 * 		ss:bp = PointDWFixed center
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GB_GET_CENTER_OF_LAST_SELECTED_GROBJ(PointDWFixed *center = ss:bp);
/*
 * 	Return the PointDWFixed center of the last object in
 * 	the selection list
 * 
 * PASS:
 * 		ss:bp = PointDWFixed
 * 		dx >= size PointDWFixed
 * 
 * RETURN:
 * 		ss:bp = PointDWFixed center
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GB_GET_DWF_BOUNDS_OF_FIRST_SELECTED_GROBJ(RectDWFixed *bounds = ss:bp);
/*
 * 	Return the RectDWFixed bounds of the first object in
 * 	the selection list
 * 
 * PASS:
 * 		ss:bp = RectDWFixed
 * 		dx >= size RectDWFixed
 * 
 * RETURN:
 * 		ss:bp = RectDWFixed center
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GB_GET_DWF_BOUNDS_OF_LAST_SELECTED_GROBJ(RectDWFixed *bounds = ss:bp);
/*
 * 	Return the RectDWFixed bounds of the last object in
 * 	the selection list
 * 
 * PASS:
 * 		ss:bp = RectDWFixed
 * 		dx >= size RectDWFixed
 * 
 * RETURN:
 * 		ss:bp = RectDWFixed center
 * 
 * DESTROYED:
 * 	ax
 */



@message hptr MSG_GB_GET_BLOCK_FOR_ONE_GROBJ() = cx;
/*
 * 	Return a block in the file that the caller may add one object to.
 * 
 * PASS
 * 	nothing
 * 
 * RETURN
 * 	cx
 * 
 * DESTROYED:
 * 	ax
 */



@message WindowHandle MSG_GB_GET_WINDOW() = cx;
/*
 * 	Return window that document draws through
 * 	
 *  Context:	Unlimited
 *  Source:	Anything
 *  Destination:	GrObjBody
 *  Interception:	Unlikely.
 * 		
 * PASS:	
 * 	nothing
 * 
 * RETURN
 * 	cx - window
 * 
 * DESTROYED:
 * 	ax
 */




/****************************************************************************/
@message void MSG_GB_ADD_GROBJ_THEN_DRAW(optr object = cx:dx, 
					 word flags = bp);  	/*XXX*/
/* 	Add a graphic object to the graphic body. The object will be
 *	notified via MSG_GO_AFTER_ADDED_TO_BODY that it has been added
 *	to the body. If the object was added at the top of the draw list
 *	it will be sent a message draw, otherwise it will be invalidated.
 *
 * Pass: OD of graphic object to add
 *       GrObjBodyAddGrObjFlags
 * 
 * Return: nothing
 */

/****************************************************************************/
@message void MSG_GB_SET_BOUNDS(RectDWord *bounds = ss:bp );
/* 
 * 	Sets the bounds of the graphic body	
 *
 * Pass: RectDWord
 */ 

@message void MSG_GB_GET_BOUNDS(RectDWord *bounds = dx:bp); 	/* XXX */
/*
 * 	Returns the bounds that encompass all the selected objects
 * 
 * PASS
 * 	ss:bp - RectDWord
 * 
 * RETURN
 * 	ss:bp - RectDWord
 * 
 * DESTROYED:
 * 	ax
 */



@message void MSG_GB_SET_ACTION_NOTIFICATION_OUTPUT( /* XXX */
		optr 	object = cx:dx,	/* Object which will receive notification */
		Message	messageNumber = bp);
/* 
 *	Specify the message and OD for GrObjs to send notification to
 *	when an action is performed on them. GrObjs will use this notification
 *	in the body if they don't have one of their own. Many uses of the
 *	GrObj will have no notification.
 *	
 *	When a GrObj sends out a notification, it will put its OD in
 *	cx:dx and a GrObjActionNotificationType in bp.
 *
 *	Context:	GrObjBody Utility
 *	Source:		Unrestricted
 *	Destination:	GrObjBody
 *	Interception:	Unlikely
 *	
 *	PASS:	object		Optr of object to notify
 *		messageNumber	message to send
 *
 *	RETURN: Nothing
 */

@message void MSG_GB_SUSPEND_ACTION_NOTIFICATION(); /* XXX */
/* 	Prevent all GrObjs in the layer from sending out any action notifications,
 *	even if a given GrObj has its own output OD and message. If the body
 * 	has no action notification OD it will still record the suspension and the
 *	suspension will be in place when the action output is set.  Nested
 *	suspends and unsuspends are allowed. 
 *	If a file is closed it will always reopen unsuspended.
 *
 *	Context:	GrObjBody Utility
 *	Source:		Unrestricted
 *	Destination:	Any GrObjBody
 *	Interception:	Unlikely
 *
 */

@message void MSG_GB_UNSUSPEND_ACTION_NOTIFICATION(); /* XXX */
/* 	Counterbalance a call to MSG_GB_SUSPEND_ACTION_NOTIFICATION If all
 *	suspends have been balanced the GrObj will be free to send out
 *	action notifications that were aborted during the suspended period.
 *	If the body is not suspended, this message will be ignored. 
 *
 *	Context:	GrObjBody utility
 *	Source:		Unrestricted
 *	Destination:	Any GrObjBody
 *	Interception:	Unlikely
 *
 */


@message optr MSG_GB_INSTANTIATE_GROBJ(ClassStruct *class = cx:dx) = cx:dx; /*XXX */
/*
 *	Instantiate a grobject of the passed class in a block managed
 *	by the body.
 *
 * Pass:
 *	fptr to class of object to instantiate
 *
 * Return:
 *	OD of new object
 *
 */

@message void MSG_GB_SUBST_AREA_TOKEN(
	word oldToken = cx,
	word newToken = dx,
	Boolean updateReferenceCounts = bp);
/*
 * 	Inform any GrObjs with the passed "old" token to replace it with
 * 	the new one, updating the reference count if specified.
 * 
 *  Context:	GrObjBody Utility		
 *  Source:	Most likely from the style substitution callack
 *  Destination:	GrObjBody
 *  Interception:	Unlikely
 * 
 * PASS:		cx - old area token
 * 		dx - new area token
 * 		bp - nonzero if GrObjs should update reference counts
 * 			to both the old and new tokens
 * 
 * RETURN:	nothing
 * 
 * DESTROYED:	ax
 */



@message void MSG_GB_SUBST_LINE_TOKEN(
	word oldToken = cx,
	word newToken = dx,
	Boolean updateReferenceCounts = bp);
/*
 * 	Inform any GrObjs with the passed "old" token to replace it with
 * 	the new one, updating the reference count if specified.
 * 
 *  Context:	GrObjBody Utility		
 *  Source:	Most likely from the style substitution callack
 *  Destination:	GrObjBody
 *  Interception:	Unlikely
 * 
 * PASS:		cx - old line token
 * 		dx - new line token
 * 		bp - nonzero if GrObjs should update reference counts
 * 			to both the old and new tokens
 * 
 * RETURN:	nothing
 * 
 * DESTROYED:	ax
 */


@message void MSG_GB_CREATE_GROBJ_TRANSFER_FORMAT(); /* Needs prototype */
/*
 * 	Creates a VMChain necessary to recontruct the current selection
 * 
 *  Context:	GrObjBody Utility		
 *  Source:	Most likely from a MSG_CLIPBOARD_[CUT|COPY]
 *  Destination:	GrObjBody
 *  Interception:	Unlikely
 * 
 * PASS:		ss:[bp] - PointDWFixed origin
 * 		cx - VM file
 * 
 * RETURN:	ax - vm block handle of VMChainTree root
 * 
 * DESTROYED:	nothing
 */



typedef struct {
	VMBlockHandle    VMBHAD_vmBlockHandle;
	word		 VMBHAD_width;
	word		 VMBHAD_height;
} VMBlockHandleAndDims;

@message void MSG_GB_CREATE_GSTRING_TRANSFER_FORMAT(); /* Needs prototype */
/*
 * 	Creates a gstring representing the current selection
 * 
 *  Context:	GrObjBody Utility		
 *  Source:	Most likely from a MSG_CLIPBOARD_[CUT|COPY]
 *  Destination:	GrObjBody
 *  Interception:	Unlikely
 * 
 * PASS:		ss:[bp] - PointDWFixed origin
 * 		cx - VM file
 * 
 * RETURN:	ax - vm block handle of gstring
 * 		cx,dx - width/height of gstring
 * 
 * DESTROYED:	nothing
 */





@message void MSG_GB_SEND_CLASSED_EVENT_SET_DEFAULT_ATTRS(EventHandle event = cx, TravelOption travelOption = dx);
/*
 * 	The body sends this message to itself when processing
 * 	MSG_META_SEND_CLASSED_EVENT so that it can use the
 * 	message for setting default attributes. This handler
 * 	must not damage the original message. If it decides
 * 	to use the message it must duplicated it
 * 
 *  Context:	See Above
 *  Source:	GrObjBody
 *  Destination:  GrObjBody
 *  Interception: Possible. If you have subclassed the body to change
 * 		the default attribute setting behaviour then
 * 		you should subclass this message and not call
 * 		your superclass
 * 
 * PASS:		
 * 	cx - event handle
 * 	dx - TravelOption
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GB_CHANGE_GROBJ_DEPTH(optr grobjOD = cx:dx, GrObjBodyAddGrObjFlags flags = bp);
/*
 * 	Change grobjs position in the draw and reverse lists.
 * 	Note you can knock the selection array out of
 * 	draw order when using this message. You may
 * 	want to use MSG_GB_REORDER_SELECTION_ARRAY both before
 * 	and afterwards so that undo and redo work correctly.
 * 	
 * 
 *  Context:	Unrestricted
 *  Source:	Unrestricted
 *  Destination:  GrObjBody
 *  Interception: Unlikely
 *  Undo:		Generates an undo chain with "Depth Change" text
 * 
 * PASS:		
 * 	cx:dx - od of grobj to change depth of
 * 	bp - GrObjBodyAddGrObjFlags
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


typedef WordFlags GrObjDrawFlags;		/* CHECKME */

/*
 * Have objects draw themselves with MSG_GO_DRAW_QUICK_VIEW which is much
 * faster but not WYSIWYG
 */
#define GODF_DRAW_QUICK_VIEW	(0x0100)

/*
 * Draw the clip area only of the object
 */
#define GODF_DRAW_CLIP_ONLY	(0x0080)

/*
 * if true, then only draw objects with GOAF_WRAP set to GOWTT_WRAP_INSIDE
 */
#define GODF_DRAW_WRAP_TEXT_INSIDE_ONLY	(0x0040)

/*
 * if true, then only draw objects with GOAF_WRAP set to
 * GOWTT_WRAP_AROUND_RECT or GOWTT_WRAP_AROUND_TIGHTLY
 */
#define GODF_DRAW_WRAP_TEXT_AROUND_ONLY	(0x0020)

/*
 * If the object is capable it
 * should draw with more resolution.
 * Used for printing and when view
 * is scaled. 
 */
#define GODF_DRAW_WITH_INCREASED_RESOLUTION	(0x0010)

/*
 * if true, then draw objects
 * with GOAF_INSTRUCTION bit set
 */
#define GODF_DRAW_INSTRUCTIONS	(0x0008)

/*
 * if true, then only draw selected objects.
 */
#define GODF_DRAW_SELECTED_OBJECTS_ONLY	(0x0004)

/*
 * if true, then don't draw grid lines
 * sprites, handles, etc.
 */
#define GODF_DRAW_OBJECTS_ONLY	(0x0002)

/* if true then print instructions */
#define GODF_PRINT_INSTRUCTIONS	(0x0001)

@message void MSG_GB_DRAW(				/* XXX */
			GStateHandle 	gstate = bp,
			DrawFlags 	visDrawFlags = cl,
			GrObjDrawFlags 	GODrawFlags = dx);

/* Draw the GrObjs, grids, etc.
 *
 * Warning:	You probably want to send a MSG_VIS_DRAW instead. You should only
 *		send _this_ message if you know what you are doing.
 *
 * Context:		GrObjBody Utility
 * Source:		Unrestricted. Generally the GrObjBody itself. 
 * Destination:		GrObjBody
 * Interception:	Possible, but unlikely
 *
 */

@message void MSG_GB_EXPORT(ImpexTranslationParams *params = ss:bp);
/*
 * 	Create gstring in the vm file
 * 
 *  Context:	Sent to body by impex when user chooses export
 *  Source:	Impex
 *  Destination:  GrObjBody
 *  Interception: Unlikely
 * 
 * PASS:		
 * 	ss:bp - ImpexTranslationParams
 * 
 * RETURN:	
 * 	ss:bp - ImpexTranslationParams
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GB_GRAB_TARGET_FOCUS();
/*
 * 	Have the body grab the target and the focus
 * 
 *  Context:	Unrestricted. Generally sent by floater to body on 
 * 		start selects.
 *  Source:	Unrestricted
 *  Destination:  GrObjBody
 *  Interception: Unlikely
 * 
 * PASS:		
 * 	nothing
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GB_GENERATE_TEXT_NOTIFY(VisTextGenerateNotifyParams *params = ss:bp);
/*
 * 	Combine attrs from the selected text objects and send out notification
 * 
 *  Context:	Unrestricted.
 *  Source:	Unrestricted
 *  Destination:  GrObjBody
 *  Interception: Unlikely
 * 
 * PASS:		
 * 	ss:bp - VisTextGenerateNotifyParams
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GB_GENERATE_SPLINE_NOTIFY(SplineGenerateNotifyParams *params = ss:bp);
/*
 * 	Combine attrs from the selected splines and send out notification
 * 
 *  Context:	Unrestricted.
 *  Source:	Unrestricted
 *  Destination:  GrObjBody
 *  Interception: Unlikely
 * 
 * PASS:		
 * 	ss:bp - SplineGenerateNotifyParams
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GB_DETACH_GOAM();
/*
 * 	Clear GrObjAttributeManager OD in instance data and detach the
 * 	body from the GOAM's bodyList.
 * 
 *  Context:	GrObjBody Utility
 *  Source:	Unrestricted. 
 *  Destination:	GrObjBody
 *  Interception:	Unlikely
 */

@message void MSG_GB_IMPORT(ImpexTranslationParams *params = ss:bp);
/*
 * 	Handle import via impex
 * 
 *  Context:	Import
 *  Source:	Import Controller
 *  Destination:  GrObjBody
 *  Interception: Unlikely
 * 
 * PASS:		
 * 	ss:bp -  ImpexTranslatoinParams
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GB_CONVERT_SELECTED_GROBJS_TO_BITMAP();
/*
 * 	Replace any selected grobjs with an equivalent bitmap.
 * 
 *  Context:	GrObjBodyUtility
 *  Source:	Unrestricted
 *  Destination:  GrObjBody
 *  Interception: Unlikely
 * 
 * PASS:		
 * 	nothing
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GB_CONVERT_SELECTED_GROBJS_TO_GRAPHIC();
/*
 * 	Replace any selected grobjs with an equivalent gstring object.
 * 
 *  Context:	GrObjBodyUtility
 *  Source:	Unrestricted
 *  Destination:  GrObjBody
 *  Interception: Unlikely
 * 
 * PASS:		
 * 	nothing
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GB_IGNORE_UNDO_ACTIONS_AND_SUSPEND();
/*
 * 	An alternative to MSG_META_SUSPEND that will *not* generate
 * 	a new undo chain. This message is complemented by
 * 	MSG_GB_ACCEPT_UNDO_ACTIONS_AND_UNSUSPEND
 * 
 *  Context:	GrObjBodyUtility
 *  Source:	Unrestricted
 *  Destination:  GrObjBody
 *  Interception: Unlikely
 * 
 * PASS:		
 * 	nothing
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GB_UNSUSPEND_AND_ACCEPT_UNDO_ACTIONS();
/*
 * 	An alternative to MSG_META_UNSUSPEND that will *not* generate
 * 	a new undo chain. This message is complemented by
 * 	MSG_GB_IGNORE_UNDO_ACTIONS_AND_SUSPEND
 * 
 *  Context:	GrObjBodyUtility
 *  Source:	Unrestricted
 *  Destination:  GrObjBody
 *  Interception: Unlikely
 * 
 * PASS:		
 * 	nothing
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GB_MAKE_INSTRUCTIONS_SELECTABLE_AND_EDITABLE();
/*
 * 	Clear selection and edit locks on all instruction grobjects
 * 	currently in the document.
 * 
 *  Context:	GrObj Body Utility
 *  Source:	Unrestricted
 *  Destination:  GrObjBody
 *  Interception: Unlikely
 * 
 * PASS:		
 * 	nothing
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */



@message void MSG_GB_MAKE_INSTRUCTIONS_UNSELECTABLE_AND_UNEDITABLE();
/*
 * 	Set selection and edit locks on all instruction grobjects
 * 	currently in the document.
 * 
 *  Context:	GrObj Body Utility
 *  Source:	Unrestricted
 *  Destination:  GrObjBody
 *  Interception: Unlikely
 * 
 * PASS:		
 * 	nothing
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GB_SET_GROBJ_DRAW_FLAGS(GrObjDrawFlags flagsToSet = cx,
					  GrObjDrawFlags flagsToReset = dx); /* XXX */
/*
 * 	Set the GrObjDrawFlags that are used during the handling
 * 	of MSG_VIS_DRAW. This message will send a
 * 	MSG_GOAM_SET_GROBJ_DRAW_FLAGS to the attribute manager, which will
 * 	in turn send a MSG_GB_SET_GROBJ_DRAW_FLAGS_NO_BROADCAST to all
 * 	the relevant bodies
 * 
 *  Context:	GrObjBody Utility
 *  Source:	Unrestricted
 *  Destination:  GrObjBody
 *  Interception: Unlikely
 * 
 * PASS:		
 * 
 * 	cx - GrObjDrawFlags to set
 * 	dx - GrObjDrawFlags to reset
 * 
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GB_DELETE_INSTRUCTIONS();
/*
 * 	Delete all instruction objects in document
 * 	
 *  Context:	GrObjBody Utility
 *  Source:	Unrestricted
 *  Destination:  GrObjBody
 *  Interception: Unlikely
 * 
 * PASS:		
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GB_PASTE_INSIDE();
/*
 * 	Paste the clipboard objects inside the currently selected objects
 * 
 *  Context:	GrObjBody Utility
 *  Source:	Unrestricted
 *  Destination:  GrObjBody
 *  Interception: Unlikely
 * 
 * PASS:		
 * 	nothing
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GB_CLONE_SELECTED_GROBJS();
/*
 * 	Clone the selected grobjs (copy/paste in place)
 * 	
 *  Context:	GrObjBody Utility
 *  Source:	Unrestricted
 *  Destination:  GrObjBody
 *  Interception: Unlikely
 * 
 * PASS:		nothing
 * 			
 * RETURN:	nothing
 * 
 * DESTROYED:
 * 	ax
 */



@message optr MSG_GB_CREATE_POLYGON(word polyPoints = bp, word polyWidth = cx, word polyHeight = dx) = cx:dx;
/*
 * 	Create a polygon with the passed number of points
 * 	
 *  Context:	GrObjBody Utility
 *  Source:	Unrestricted
 *  Destination:  GrObjBody
 *  Interception: Unlikely
 * 
 * PASS:		bp - number of points in the polygon
 * 		cx,dx - width, height of polygon
 * 			
 * RETURN:	^lcx:dx - new polygon
 * 
 * DESTROYED:
 * 	ax
 */



@message optr MSG_GB_CREATE_STAR(SplineMakeStarParams *params = ss:bp) = cx:dx;
/*
 * 	Create a star with the passed number of points
 * 	
 *  Context:	GrObjBody Utility
 *  Source:	Unrestricted
 *  Destination:  GrObjBody
 *  Interception: Unlikely
 * 
 * PASS:		ss:[bp] - SplineMakeStarParams
 * 			
 * RETURN:	^lcx:dx - new star
 * 
 * DESTROYED:
 * 	ax
 */



@message void MSG_GB_SUBST_TEXT_ATTR_TOKEN(VisTextSubstAttrTokenParams *params = ss:bp);
/*
 * 	A text object has requested an attribute substitution, so we
 * 	need to relay the message to all text objects.
 * 
 *  Context:	Unrestricted.
 *  Source:	Unrestricted
 *  Destination:  GrObjBody
 *  Interception: Unlikely
 * 
 * PASS:		
 * 	ss:bp - VisTextSubstAttrTokenParams
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GB_RECALC_FOR_TEXT_ATTR_CHANGE();
/*
 * 	A text object has requested an attribute substitution, so we
 * 	need to relay the message to all text objects.
 * 
 *  Context:	Unrestricted.
 *  Source:	Unrestricted
 *  Destination:  GrObjBody
 *  Interception: Unlikely
 * 
 * PASS:		
 * 	nothing
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */



@message void MSG_GB_GET_BOUNDS_OF_GROBJS(RectDWord *retValue = dx:bp);
/*
 * 	Returns the bounds that encompass all the objects
 * 
 *  Context:	Unrestricted.
 *  Source:	Unrestricted
 *  Destination:  GrObjBody
 *  Interception: Unlikely
 * 
 * PASS
 * 	ss:bp - RectDWord
 * 
 * RETURN
 * 	ss:bp - RectDWord
 * 
 * DESTROYED:
 * 	ax
 */

typedef struct {
    word    	    	     GBCDP_repetitions;
    PointDWFixed    	     GBCDP_move;
    WWFixed 	    	     GBCDP_rotation;
    GrObjHandleSpecification GBCDP_rotateAnchor;
    GrObjAnchoredSkewData    GBCDP_skew;
    GrObjAnchoredScaleData   GBCDP_scale;
} GrObjBodyCustomDuplicateParams;

@message void MSG_GB_CUSTOM_DUPLICATE_SELECTED_GROBJS(
			     GrObjBodyCustomDuplicateParams *cdParams = dx:bp);
/*
 * 	Custom duplicate the selected GrObjs.
 * 
 *  Context:	Unrestricted.
 *  Source:	Unrestricted
 *  Destination:  GrObjBody
 *  Interception: Unlikely
 * 
 * PASS:		
 * 	ss:[bp] - GrObjBodyCustomDuplicateParams
 * 
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */



@message void MSG_GB_EXPORT_SELECTED_GROBJS(ImpexTranslationParams *params = ss:bp);
/*
 * 	Create gstring in the vm file
 * 
 *  Context:	Sent to body by impex when user chooses export
 *  Source:	Impex
 *  Destination:  GrObjBody
 *  Interception: Unlikely
 * 
 * PASS:		
 * 	ss:bp - ImpexTranslationParams
 * 
 * RETURN:	
 * 	ss:bp - ImpexTranslationParams
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GB_HIDE_UNSELECTED_GROBJS();
/*
 * 	Set the GOL_SHOW lock in all objects that are not in
 * 	the selection list.
 * 
 *  Context:	GrObjBody Utility
 *  Source:	Unrestricted
 *  Destination:  GrObjBody
 *  Interception: Unlikely
 * 
 * PASS:		
 * 	nothing
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GB_SHOW_ALL_GROBJS();
/*
 * 	Clear the GOL_SHOW lock in all objects
 * 
 * 
 *  Context:	GrObjBody Utility
 *  Source:	Unrestricted
 *  Destination:  GrObjBody
 *  Interception: Unlikely
 * 
 * PASS:		
 * 	nothing
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */

typedef struct {		/* CHECKME */
    ClassStruct		*GBCGP_class;
    word		padding[4];
    WWFixed		GBCGP_width;
    WWFixed		GBCGP_height;
} GrObjBodyCreateGrObjParams;


@message optr MSG_GB_CREATE_GROBJ(GrObjBodyCreateGrObjParams *params = ss:bp) = cx:dx;
/*
 * 	Creates a VMChain necessary to recontruct the current selection
 * 
 *  Context:	GrObjBody Utility		
 *  Source:	Most likely from a MSG_CLIPBOARD_[CUT|COPY]
 *  Destination:	GrObjBody
 *  Interception:	Unlikely
 * 
 * PASS:		ss:[bp] - PointDWFixed origin
 * 		cx - VM file
 * 
 * RETURN:	ax - vm block handle of VMChainTree root
 * 
 * DESTROYED:	nothing
 */


@message void MSG_GB_DUPLICATE_SELECTED_GROBJS();
/*
 * 	Duplicate the selected grobjs (copy/paste to center of window)
 * 	
 *  Context:	GrObjBody Utility
 *  Source:	Unrestricted
 *  Destination:  GrObjBody
 *  Interception: Unlikely
 * 
 * PASS:		nothing
 * 			
 * RETURN:	nothing
 * 
 * DESTROYED:
 * 	ax
 */



@message optr MSG_GB_FIND_NEXT_GROBJ_THAT_OVERLAPS(optr childOD = cx:dx) = cx:dx;
/*
 * 	Get the od of the next object in the draw list that has parent
 * 	bounds that overlap the parent bounds of the passed object
 * 
 *  Context:	Used as part of Pull Up/Push Down functionality
 *  Source:	Unrestricted. Generally GrObjBody
 *  Destination:  GrObjBody
 *  Interception: Unlikely
 * 
 * PASS:		
 * 	^lcx:dx - od of child
 * 			
 * RETURN:	
 * 	cx = 0 - no such object
 * 	or
 * 	^lcx:dx - object that overlaps
 * 
 * DESTROYED:
 * 	ax
 */




@message optr MSG_GB_FIND_PREV_GROBJ_THAT_OVERLAPS(optr childOD = cx:dx) = cx:dx;
/*
 * 	Get the od of the prev object in the draw list that has parent
 * 	bounds that overlap the parent bounds of the passed object
 * 
 *  Context:	Used as part of Pull Up/Push Down functionality
 *  Source:	Unrestricted. Generally GrObjBody
 *  Destination:  GrObjBody
 *  Interception: Unlikely
 * 
 * PASS:		
 * 	^lcx:dx - od of child
 * 			
 * RETURN:	
 * 	cx = 0 - no such object
 * 	or
 * 	^lcx:dx - object that overlaps
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GB_ZOOM_IN_ABOUT_POINT(PointDWFixed *point = ss:bp);
/*
 * 	Have the body scroll the point to the center of the screen
 * 	and zoom in.
 * 	
 * 
 *  Context:	GrObjBody Utility
 *  Source:	Unrestricted
 *  Destination:  GrObjBody
 *  Interception: If you wish different view zoom increments then 
 * 		subclass this message and don't call your superclass
 * 
 * PASS:		
 * 	ss:bp - PointDWFixed
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GB_ZOOM_OUT_ABOUT_POINT(PointDWFixed *point = ss:bp);
/*
 * 	Have the body scroll the point to the center of the screen
 * 	and zoom out.
 * 	
 * 
 *  Context:	GrObjBody Utility
 *  Source:	Unrestricted
 *  Destination:  GrObjBody
 *  Interception: If you wish different view zoom increments then 
 * 		subclass this message and don't call your superclass
 * 
 * PASS:		
 * 	ss:bp - PointDWFixed
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


/*
 *     The GrObjMouseReturnTypes are in the order in which they
 *     will be checked. As soon as one of the conditions is met
 *     the message returns without checking the remaining types.
 */

typedef enum {
	/*
	 * Mouse position is over a handle of a selected object.
	 */
	GOMRF_HANDLE,

	/*
	 * Mouse position is over the bounds of a GrObj
	 */
	GOMRF_BOUNDS,

	/*
	 * Mouse position isn't over anything interesting
	 */
	GOMRF_NOTHING
} GrObjMouseReturnType;

@message void MSG_GB_EVALUATE_MOUSE_POSITION(); /* Needs Prototype */
/*
 * 	Determine if the passed mouse position if over a 
 * 	handle or the bounds of any object and return
 * 	the mouse cursor image if so. The middle handle of
 * 	objects with GOL_MOVE set and the perimeter handles of
 * 	objects with GOL_RESIZE set will be ignored.
 * 
 *  Context:	GrObjBody Utility
 *  Source:	Unrestricted
 *  Destination:  GrObjBody
 *  Interception: Unlikley
 * 
 * PASS:		
 * 	ss:bp - PointDWFixed in GrObjBody's coordinate system
 * 			
 * RETURN:	
 * 	ah - MouseReturnFlags high byte
 * 	nothing or MRF_SET_POINTER_IMAGE or MRF_CLEAR_POINTER_IMAGE
 * 		al - GrObjMouseReturnType
 * 	cx:dx - optr of cursor image if MRF_SET_POINTER_IMAGE 
 * 		set in MouseReturnFlags
 * 
 * DESTROYED:
 * 	nothing
 */


@message Boolean MSG_GB_EVALUATE_POINT_FOR_HANDLE(PointDWFixed *point = ss:bp) = carry; /* Needs Prototype */
/*
 * 	Determine if passed point is over a handle of a selected grobj
 * 
 *  Context:	Unrestricted. Generally called from 
 * 		MSG_GB_EVALUATE_MOUSE_POSITION handler
 *  Source:	Unrestricted. Generally GrObjBody
 *  Destination:  GrObjBody
 *  Interception: Unlikely
 * 
 * PASS:		
 * 	ss:bp - PointDWFixed
 * 			
 * RETURN:	
 * 	stc - handle hit
 * 		al - GrObjHandleSpecification of hit handle
 * 
 * 	clc - no handle hit
 * 
 * DESTROYED:
 * 	ah
 */



@message Boolean MSG_GB_EVALUATE_POINT_FOR_BOUNDS(PointDWFixed *point = ss:bp) = carry;
/*
 * 	Determine if passed point is over PARENT bounds of a grobj
 * 
 *  Context:	Unrestricted. Generally called from 
 * 		MSG_GB_EVALUATE_MOUSE_POSITION handler
 *  Source:	Unrestricted. Generally GrObjBody
 *  Destination:  GrObjBody
 *  Interception: Unlikely
 * 
 * PASS:		
 * 	ss:bp - PointDWFixed
 * 			
 * RETURN:	
 * 	stc - handle hit
 * 
 * 	clc - no handle hit
 * 
 * DESTROYED:
 * 	ax
 */



@message void MSG_GB_SET_NORMAL_SIZE_ABOUT_POINT(PointDWFixed *point = ss:bp);
/*
 * 	Have the body scroll the point to the center of the screen
 * 	and set the view scale to 100%
 * 	
 * 
 *  Context:	GrObjBody Utility
 *  Source:	Unrestricted
 *  Destination:  GrObjBody
 *  Interception: If you wish different view zoom increments then 
 * 		subclass this message and don't call your superclass
 * 
 * PASS:		
 * 	ss:bp - PointDWFixed
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */



@message void MSG_GB_DRAW_GROBJ(optr grobjOD = cx:dx);
/*
 * 	Draw the passed grobj.If the grobj is the highest child it will
 * 	just be drawn, otherwise it will be invalidated
 * 
 *  Context:	GrObjBody Utility
 *  Source:	Unrestricted
 *  Destination:  GrObjBody
 *  Interception: Unlikely
 * 
 * PASS:		
 * 	cx:dx - optr of grobj		
 * 	
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GB_SEND_TO_SELECTED_GROBJS_SHARE_DATA(Message grobjMessage = cx, word data1 = dx, word data2 = bp);
/*
 * 	Sends encapsulated classed event to all 
 * 	grobjects on selection list
 * 
 * PASS
 * 	cx - grobj message #
 * 	dx, bp - other data
 * 
 * RETURN
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */



@message void MSG_GB_STANDARD_PASTE_CALL_BACK(optr grobjOD = cx:dx);
/*
 * 	The default handler adds the grobject to the body, draws it
 * 	and then adds the grobject to the selection list without 
 * 	drawing the grobjects handles.
 * 
 * 	For each object that is pasted in, the body either sends this
 * 	message to itself, or, if the body has ATTR_GB_PASTE_CALL_BACK 
 * 	in its vardata, it sends the message stored in the vardata to the
 * 	object stored in the vardata.
 * 
 * 	Upon handling MSG_META_CLIPBOARD_PASTE the body clears the 
 * 	ATTR_GB_PASTE_CALL_BACK vardata.
 * 
 *  	If wish to use your own ATTR_GB_PASTE_CALL_BACK back to perform
 * 	special paste functionality (like paste inside), then send
 * 	MSG_GB_PASTE which uses any existing vardata.
 * 
 *  Context:	Sent once for each object being pasted if the body doesn't
 * 		have a ATTR_GB_PASTE_CALL_BACK vardata.
 *  Source:	GrObjBody
 *  Destination:  GrObjBody
 *  Interception: Unlikely
 * 
 * PASS:		
 * 	^lcx:dx - grobject not a child of anything
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */



@message void MSG_GB_PASTE();
/*
 * 	Paste the clipboard objects inside the currently selected objects
 * 
 *  Context:	GrObjBody Utility
 *  Source:	Unrestricted
 *  Destination:  GrObjBody
 *  Interception: Unlikely
 * 
 * PASS:		
 * 	nothing
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GB_REORDER_SELECTION_ARRAY();
/*
 * 	Nuke and rebuild the selection array so that it is in draw order.
 * 	The array is rebuilt from objects that have their GOTM_SELECTED
 * 	bit set.
 * 
 * 	NOTE: for undo and redo to work correctly you will need to 
 * 	use this message both before and after you muck with the
 * 	selection array.
 * 
 *  Context:	GrObjBody Utility. Certain body functions such as
 * 		MSG_GB_SHUFFLE_SELECTED_GROBJS_DOWN and UP may 
 * 		knock the selection array out of draw order, so the
 * 		body sends this message to itself. Also, 
 * 		MSG_GB_CHANGE_GROBJ_DEPTH can muck the selection array
 * 		depending on how it is used. So be careful
 *  Source:	Unrestricted
 *  Destination:  GrObjBody
 *  Interception: Unlikely
 *  Undo:		Generates an undo chain with no text
 * 
 * PASS:		
 * 	nothing
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GB_ABORT_SEARCH_SPELL_MESSAGE(Message abortMessage = cx);
/*
 * 	Abort a search/spell message (because no text objects exist)
 * 
 *  Context:	Sent by the GrObjBody to itsself when receiving a search/spell
 * 		message and no text objects exist
 *  Source:	GrObjBody
 *  Destination:  GrObjBody
 *  Interception: Possible
 *  Undo:		-
 * 
 * PASS:		
 * 	cx - message to abort
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GB_QUICK_PASTE(PointDWFixed *pasteAt = ss:bp);
/*
 * 	Does a paste, drawing from the quick part of the clipboard
 * 
 *  Context:	GrObjBody Utility
 *  Source:	Unrestricted
 *  Destination:  GrObjBody
 *  Interception: Unlikely
 * 
 * PASS:		
 * 	nothing
 * 
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message GrObjDrawFlags MSG_GB_GET_GROBJ_DRAW_FLAGS(DrawFlags drawFlags = cl) 
								= dx; /* XXX */
/*
 * 	Get the GrObjDrawFlags that are used during the handling
 * 	of MSG_VIS_DRAW. This is mainly used by a caller of MSG_VIS_DRAW
 * 	who wants to modify the GrObjDrawFlags. To use the flags that
 * 	are returned you will need to call MSG_GB_DRAW instead of 
 * 	MSG_VIS_DRAW .
 * 
 *  Context:	GrObjBody Utility
 *  Source:	Unrestricted
 *  Destination:  GrObjBody
 *  Interception: Unlikely
 * 
 * PASS:		
 * 	cl - DrawFlags
 * 
 * RETURN:	
 * 	dx - GrObjDrawFlags
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GB_SET_BOUNDS_WITHOUT_MARKING_DIRTY(RectDWord *bounds = ss:bp );
/* 
 * 	Sets the bounds of the graphic body, but does not mark the object
 *	dirty.
 *
 * Pass: RectDWord
 */ 

@message void MSG_GB_SET_GROBJ_DRAW_FLAGS_NO_BROADCAST(GrObjDrawFlags flagsToSet = cx, GrObjDrawFlags flagsToReset = dx); /* XXX */
/*
 * 	This message sets the grobj draw flags without requesting that
 * 	the attribute manager update other bodies in its list.
 * 
 *  Context:	GrObjBody Utility
 *  Source:	Unrestricted
 *  Destination:  GrObjBody
 *  Interception: Unlikely
 * 
 * PASS:		
 * 
 * 	cx - GrObjDrawFlags to set
 * 	dx - GrObjDrawFlags to reset
 * 
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GB_QUICK_PASTE_CALL_BACK(optr grobjOD = cx:dx);
/*
 * 	The default handler adds the grobject to the body, draws it,
 * 	send MSG_GO_AFTER_QUICK_PASTE to the new object (generally
 * 	object will select itself, but some will go into edit mode), then
 * 	sends MSG_GO_SEND_ANOTHER_TOOL_ACTIVATED to the floater (this handles
 * 	problems of floater not matching mode the object goes into after quick
 * 	paste. eg. Doing quick move of spline with rectangle tool but can't
 * 	edit spline with rectangle tool).
 * 
 *  Context:	Sent to body after an object has been quick pasted
 *  Source:	GrObjBody
 *  Destination:  GrObjBody
 *  Interception: Unlikely
 * 
 * PASS:		
 * 	^lcx:dx - grobject not a child of anything
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */

/*----------------------------------------------------------------------------
	GrObjBody Constancs and Structures
----------------------------------------------------------------------------*/

typedef struct {		/* CHECKME */
    VMChainTree	GOTBH_meta;
    PointDWord	GOTBH_size;
    dword	GOTBH_areaAttrArray;
    dword	GOTBH_lineAttrArray;
    dword	GOTBH_styleArray;
    dword	GOTBH_charAttrRuns;
    dword	GOTBH_paraAttrRuns;
    dword	GOTBH_textStyleArray;
    dword	GOTBH_textGraphicElements;
    dword	GOTBH_textGraphicsTree;
} GrObjTransferBlockHeader;

typedef ByteFlags GrObjTiledDataFlags;		/* CHECKME */
#define GOTDF_VAR_DATA	(0x01)

typedef struct {		/* CHECKME */
    GrObjTiledDataFlags	GOTDD_tiledDataFlags;
    byte	GOTDD_protocol;
} GrObjTransferDataDirectory;

typedef struct {		/* CHECKME */
    EntryPointRelocation	GOEPR_fullRelocation;
    word	GOEPR_grObjEntryPoint;
} GrObjEntryPointRelocation;

typedef struct {		/* CHECKME */
    VMChainLink	VMLAGOR_link;
    GrObjEntryPointRelocation	VMLAGOR_relocation;
} VMLinkAndGrObjRelocation;


typedef ByteFlags GrObjBodyFlags;		/* CHECKME */
/* 5 bits unused */
/*
 *  True if body has an action notification
 * od in its var data
 */
#define GBF_HAS_ACTION_NOTIFICATION	(0x04)
/*
 * If true, GrObjBody will grab target
 * on vis open
 */
#define GBF_DEFAULT_TARGET	(0x02)
/*
 * if true, GrObjBody will grab focus
 * on vis open
 */
#define GBF_DEFAULT_FOCUS	(0x01)

typedef	WordFlags	GrObjBodyUnsuspendOps;

/*-----------------------------------------------------------------------------
	GrObjBodyClass Defaults
-----------------------------------------------------------------------------*/

@default VI_optFlags = 0;
@default VI_typeFlags = ( VTF_IS_COMPOSITE | VTF_IS_INPUT_NODE );
@default VI_attrs = ( VA_DRAWABLE | VA_DETECTABLE | VA_FULLY_ENABLED );

/*-----------------------------------------------------------------------------
	GrObjBodyClass Instance Data, INSTANCE DATA, instance data
-----------------------------------------------------------------------------*/

@instance RectDWord GBI_bounds = {0,0,0,0};
@instance CompPart GBI_drawComp = {NullOptr};
@instance CompPart GBI_reverseComp = {NullOptr};
@instance word GBI_childCount;
@instance optr GBI_selectionArray;
@instance HierarchicalGrab GBI_targetExcl = {NullOptr, 0};
@instance HierarchicalGrab GBI_focusExcl = {NullOptr, 0};
@instance optr GBI_mouseGrab;
@instance word GBI_objBlockArray; /* = NullHandle;*/
@instance GrObjFunctionsActive GBI_defaultOptions;
@instance GrObjFunctionsActive GBI_currentModifiers;
@instance GrObjFunctionsActive GBI_currentOptions;
@instance GrObjBodyFlags GBI_flags = (GBF_DEFAULT_TARGET | GBF_DEFAULT_FOCUS);
@instance GrObjDrawFlags GBI_drawFlags = (GODF_DRAW_INSTRUCTIONS);
@instance GrObjFileStatus GBI_fileStatus;
@instance word GBI_graphicsState = 0;
@instance optr GBI_head;
@instance optr GBI_goam;
@instance optr GBI_ruler;
@instance word GBI_priorityList = 0;
@instance byte GBI_desiredHandleSize = DEFAULT_DESIRED_HANDLE_SIZE;
@instance byte GBI_curHandleWidth = 0;
@instance byte GBI_curHandleHeight = 0;
@instance BBFixed GBI_curNudgeX = {0, 0};
@instance BBFixed GBI_curNudgeY = {0, 0};
@instance PointWWFixed	GBI_curScaleFactor = {{1,0}, {0,0}};
@instance PointDWFixed GBI_interestingPoint = {{0, -30000}, {0, -30000}};
@instance PointDWFixed GBI_lastPtr = {0,0};
@instance word	GBI_suspendCount = 0;
@instance GrObjBodyUnsuspendOps GBI_unsuspendOps = 0;
@instance VisTextNotificationFlags GBI_textUnsuspendOps = 0;
@instance word	GBI_reserved1 = 0;
@instance word	GBI_reserved2 = 0;


/*-----------------------------------------------------------------------------
;	GrObjBodyClass VarData
-----------------------------------------------------------------------------*/
@vardata GrObjActionNotificationStruct ATTR_GB_ACTION_NOTIFICATION;

typedef struct {
	word GOBPCBS_message;
	optr GOBPCBS_optr;
} GrObjBodyPasteCallBackStruct;

@vardata GrObjBodyPasteCallBackStruct ATTR_GB_PASTE_CALL_BACK;

@endc
/*-----------------------------------------------------------------------------
	GroupClass
-----------------------------------------------------------------------------*/

@class	GroupClass, GrObjClass;

/*-----------------------------------------------------------------------------
	GroupClass Methods
-----------------------------------------------------------------------------*/

typedef WordFlags GroupAddGrObjFlags;		/* CHECKME */
/*
 * For Adding;
 * Position of center of object is
 * already relative to center of 
 * group. Otherwise object center
 * is absolute and must be adjusted
 * when it is added.
 */
#define GAGOF_RELATIVE	(0x8000)
#define GAGOF_REFERENCE	(0x7fff)
#define GAGOF_REFERENCE_OFFSET	0

#define GAGOF_FIRST CCO_FIRST
#define GAGOF_LAST CCO_LAST

@message void MSG_GROUP_ADD_GROBJ(optr grobjOD = cx:dx, GroupAddGrObjFlags flags = bp);
/*
 * 	Add a child to the group and generate an undo chain to undo the add
 * 
 *  Context:	Group Utility
 *  Source:	Unrestricted
 *  Destination:  Group
 *  Interception: Unlikely
 * 
 * PASS:		
 * 	cx:dx - optr of child to add
 * 	bp - GroupAddGrObjFlags
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */



@message void MSG_GROUP_REMOVE_GROBJ(optr grobjOD = cx:dx);
/*
 * 	Remove the child from the group and generate and undo chain 
 * 	for undoing the add.
 * 
 *  Context:	Group Utility
 *  Source:	Unrestricted
 *  Destination:  Any group
 *  Interception: Unlikely
 * 
 * PASS:		
 * 	cx:dx - optr of child to remove
 * 
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */



@message GStateHandle MSG_GROUP_CREATE_GSTATE() = bp;
/*
 * 	Have a gstate created with the transformations of all groups
 * 	above it, plus its own
 * 
 * PASS
 *  	nothing
 * 		
 * RETURN
 * 	bp - gstate
 * 
 * DESTROYED:
 * 	ax
 */


typedef struct {		/* CHECKME */
    optr	CBMD_callBackOD;
    word	CBMD_callBackMessage;
    optr	CBMD_groupOD;
    optr	CBMD_childOD;
    word	CBMD_extraData1;
    word	CBMD_extraData2;
} CallBackMessageData;


@message Boolean MSG_GROUP_PROCESS_ALL_GROBJS_SEND_CALL_BACK_MESSAGE(CallBackMessageData *data = ss:bp);
/*
 * 	For each child in group send call back message to 
 * 	call back object with child's OD in cx:dx.
 * 	If call back message returns carry set it stops 
 * 	processing children and returns ax,cx,dx,bp from call back.
 * 
 * PASS
 * 	ss:bp - stack frame that starts with a CallBackMessageData structure
 *  	dx - size of struture on stack
 * 	     (dx must be passed even if using ObjCallInstanceNoLock or
 * 		calling from same thread)
 * 		
 * RETURN
 * 	clc - all children processed
 * 		ax,cx,dx,bp - same as passed
 * 	stc - not all children processed
 * 		ax,cx,dx,bp - from call back object message handler
 */



@message void MSG_GROUP_INITIALIZE();
/*
 * 	Initialize the ObjectTransform of a group for expansion
 * 	The group is initialized with no width and height because these
 * 	will be calculated later based on the objects added
 * 	to it. The group's center is initialized a 0,0. 
 * 	When the group is expanded (MSG_GROUP_EXPAND) the width and
 * 	height will be set so as to encompass all the children and
 * 	the group's center will be position correctly in the
 * 	middle of all the children.
 * 
 *  Context:	Sent to group right after it has been instantiated
 *  Source:	Unrestricted
 *  Destination:  A newly instantiated group
 *  Interception: Unlikely
 * 
 * PASS:		
 * 	nothing
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GROUP_EXPAND();
/*
 * 	Expand and position a group to contain all its children.
 * 
 *  Context:	Sent to group after children have been added. The 
 * 		added children must have their positions relative to
 * 		the groups center. This message is usually used
 * 		in concert with MSG_GROUP_INITIALIZE.
 *  Source:	Unrestricted
 *  Destination:  A group
 *  Interception: Unlikely
 * 
 * PASS:		
 * 	nothing
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */



@message optr MSG_GROUP_INSTANTIATE_GROBJ(ClassStruct *class = cx:dx) = cx:dx; /*XXX */
/*
 *	Instantiate a grobject of the passed class in a block managed
 *	by the body that the group is associated with. This message
 *	is functionally equivalent to MSG_GB_INSTANTIATE_GROBJ, it merely
 *	simplies the creation of groups.
 *
 * Pass:
 *	fptr to class of object to instantiate
 *
 * Return:
 *	OD of new object
 *
 */
@message void MSG_GROUP_SET_HAS_PASTE_INSIDE_CHILDREN(Boolean bool = cl);
/*
 * 	Set whether group has paste inside children. Group uses it
 * 	to determine which drawing commands to send to its children.
 * 
 *  Context:	Group Utility. Usually sent by body to newly 
 * 		instantiated group while body is handling MSG_GB_PASTE_INSIDE
 *  Source:	Unrestricted
 *  Destination:  Any group
 *  Interception: Unlikely
 * 
 * PASS:		
 * 	cl - TRUE/FALSE
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GROUP_PASTE_CALL_BACK_FOR_PASTE_INSIDE(optr grobjOD = cx:dx);
/*
 * 	Add the child to the group as a paste inside child
 * 
 *  Context:	Used with ATTR_GB_PASTE_CALL_BACK vardata in body. Each
 * 		object being pasted in will be sent to the group with
 * 		this message
 *  Source:	GrObjBody
 *  Destination:  Group
 *  Interception: Unlikely
 * 
 * PASS:		
 * 	^lcx:dx - od of new pasted grobject
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message GStateHandle MSG_GROUP_CREATE_GSTATE_FOR_BOUNDS_CALC() = bp;
/*
 * 	Create a gstate with no window and no body translation, but
 * 	includes the transformations of this group and all the
 * 	groups above it.
 * 
 * PASS
 *  	nothing
 * 		
 * RETURN
 * 	bp - gstate
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GROUP_VIS_TEXT_GENERATE_NOTIFY(VisTextGenerateNotifyParams *params = ss:bp);
/*
 * 	Group equivalent of MSG_VIS_TEXT_GENERATE_NOTIFY, so that we
 * 	update the ui for text objects in selected group.
 * 
 *  Context:	Sent to selected group when sending MSG_VIS_TEXT_GENERATE_NOTIFY
 * 		to the selected text objects 
 *  Source:	Usually GrObjBody 
 *  Destination:  Selected group
 *  Interception: Unlikely
 * 
 * PASS:		
 * 	same as MSG_VIS_TEXT_GENERATE_NOTIFY
 * 			
 * RETURN:	
 * 	same as MSG_VIS_TEXT_GENERATE_NOTIFY
 * 
 * DESTROYED:
 * 	same as MSG_VIS_TEXT_GENERATE_NOTIFY
 */


@message Boolean MSG_GROUP_CHECK_FOR_GROBJ_TEXTS();
/*
 * 	Determine if there are any text objects in the group
 * 
 *  Context:	Group Utility. Currently used as part of determining if there
 * 		are and selected text objects when deciding whether to
 * 		set the default text attrs.
 *  Source:	Unrestricted
 *  Destination:  Group
 *  Interception: unlikely
 * 
 * PASS:		
 * 	nothing
 * 			
 * RETURN:	
 * 	clc - no text objects in group
 * 	stc - at least one text object in group.
 * 
 * DESTROYED:
 * 	ax
 */

typedef	ByteFlags GroupUnsuspendOps;
#define GUO_EXPAND 0x01

@instance CompPart GI_drawHead;
@instance word GI_suspendCount;
@instance GroupUnsuspendOps GI_unsuspendOps;

@endc

/*-----------------------------------------------------------------------------
	PointerClass
-----------------------------------------------------------------------------*/

@class PointerClass, GrObjClass;

/*-----------------------------------------------------------------------------
	PointerClass Methods
-----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
	PointerClass Instance Data, INSTANCE DATA, instance data
-----------------------------------------------------------------------------*/

#define MIN_MARQUEE_DIMENSION 7
#define MAX_PRIORITY_LIST_ELEMENTS 5

typedef ByteFlags PointerModes;
#define PM_HANDLES_RESIZE 0x04
#define PM_HANDLES_ROTATE 0x02
#define PM_POINTER_IS_ACTION_OBJECT 0x01

@instance PointerModes PTR_modes;
 
@endc

/*-----------------------------------------------------------------------------
	RotatePointerClass
-----------------------------------------------------------------------------*/

@class RotatePointerClass, PointerClass;
@endc

/*-----------------------------------------------------------------------------
	ZoomPointerClass
-----------------------------------------------------------------------------*/

@class ZoomPointerClass, PointerClass;
@endc


/*-----------------------------------------------------------------------------
	Rect Class
-----------------------------------------------------------------------------*/
 
@class RectClass, GrObjClass;
@endc

/*-----------------------------------------------------------------------------
	RoundedRect Class
-----------------------------------------------------------------------------*/

@class RoundedRectClass, RectClass;
@message void MSG_RR_SET_RADIUS(word radius = cx);
/*
 * 	Set the radius of the corner of the rounded rect in pts
 * 
 *  Context:	RoundedRect Utility
 *  Source:	Unrestricted
 *  Destination:  RoundedRectClass
 *  Interception: Unlikely
 * 
 * PASS:		
 * 	cx - radius
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message word MSG_RR_GET_RADIUS() = cx;
/*
 * 	Get the radius of the corner of the rounded rect in pts
 * 
 *  Context:	RoundedRect Utility
 *  Source:	Unrestricted
 *  Destination:  RoundedRectClass
 *  Interception: Unlikely
 * 
 * PASS:		
 * 	nothing
 * 			
 * RETURN:	
 * 	cx - radius
 * 
 * DESTROYED:
 * 	ax
 */

@instance word RRI_radius;

@endc

/*-----------------------------------------------------------------------------
	Ellipse Class
-----------------------------------------------------------------------------*/

@class EllipseClass, RectClass;
@endc

/*-----------------------------------------------------------------------------
	Line Class
-----------------------------------------------------------------------------*/

@class LineClass, GrObjClass;


@endc

/*-----------------------------------------------------------------------------
	Arc Class
-----------------------------------------------------------------------------*/

@class ArcClass, GrObjClass;
@message void MSG_ARC_SET_START_ANGLE(WWFixedAsDWord angle = dx.cx);
/*
 * 	Set the starting angle of the ellipse
 * 
 *  Context:	Arc Utility
 *  Source:	Unrestricted
 *  Destination:  Unrestricted
 *  Interception: Unlikely
 * 
 * PASS:		
 * 	dx:cx - WWFixed angle
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */



@message void MSG_ARC_SET_END_ANGLE(WWFixedAsDWord angle = dx.cx);
/*
 * 	Set the ending angle of the ellipse
 * 
 *  Context:	Arc Utility
 *  Source:	Unrestricted
 *  Destination:  Unrestricted
 *  Interception: Unlikely
 * 
 * PASS:		
 * 	dx:cx - WWFixed angle
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */



@message void MSG_ARC_SET_ARC_CLOSE_TYPE(ArcCloseType type = cx);
/*
 * 	Set the ArcCloseType
 * 
 *  Context:	Arc Utility
 *  Source:	Unrestricted
 *  Destination:  Unrestricted
 *  Interception: Unlikely
 * 
 * PASS:		
 * 	cx - ArcCloseType
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_ARC_UNDO_REPLACE_ARC_GEOMETRY_INSTANCE_DATA(
	DBGroup group = dx,
	DBItem item = cx,
	VMFileHandle file = bp);
/*
 * 	Replace the arcs instance data with the passed ArcBasicInit data
 * 	as part of an undo operation. A new undo chain is generated first
 * 	so that this operation will be undoable.
 * 
 *  Context:	Send by object to itself while handling MSG_META_UNDO
 *  Source:	Object itself
 *  Destination:  Object itself
 *  Interception: Unlikely
 * 
 * PASS:		
 * 	dx - DB group
 * 	cx - DB item
 * 	bp - VM file handle
 * 
 * 	The referenced DBitem must contain a ArcBasicInit structure
 * 
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */



typedef struct {		/* CHECKME */
    ArcCloseType	ABI_arcCloseType;
    WWFixed		ABI_startAngle;
    WWFixed		ABI_endAngle;
    PointWWFixed	ABI_startPoint;
    PointWWFixed	ABI_endPoint;
    PointWWFixed	ABI_midPoint;
    WWFixed		ABI_radius;
} ArcBasicInit;

@message void MSG_ARC_REPLACE_ARC_GEOMETRY_INSTANCE_DATA(ArcBasicInit *initData = ss:bp);
/*
 * 	Replaces the arcs geometry related instance data with the
 * 	passed data.
 * 
 *  Context:	During undo of most geometry operations
 *  Source:	Object itself
 *  Destination:  Object itself
 *  Interception: Unlikely
 * 
 * PASS:		
 * 	ss:bp - ArcBasicInit
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@instance word AI_arcCloseType;
@instance WWFixed AI_startAngle;
@instance WWFixed AI_endAngle;
@instance PointWWFixed AI_startPoint;
@instance PointWWFixed AI_endPoint;
@instance PointWWFixed AI_midPoint;
@instance WWFixed AI_radius;

@endc

/*-----------------------------------------------------------------------------
	Gstring Class
-----------------------------------------------------------------------------*/

@class GStringClass, GrObjClass;

@message void MSG_GSO_SET_GSTRING(
	VMFileHandle	file = cx,
	VMBlockHandle	block = dx);
/*
 *  	Set the gstring object's gstring to the passed gstring. 
 * 	Any existing gstring will be destroyed.
 * 
 * 
 *  Context:	Unrestricted
 *  Source:	Unrestricted
 *  Destination:  GString GrObject
 *  Interception: unlikely
 * 
 *  PASS:
 * 	cx = VM file handle of gstring
 * 	dx = VM block handle of gstring
 * 
 * 	If CX = 0, 
 * 		The gstring MUST be in the vm file that the GString object
 * 		is in. The GString object will not make a copy of the
 * 		the gstring. The GString object will use the gstring directly 
 * 		and will destroy the gstring and the gstrings data if a 
 * 		new gstring is passed to the gstring object.
 * 		Make sure you fully understand the implications of this
 * 		before you do this.
 * 	ELSE
 * 		The passed gstring is copied into the GString objects 
 * 		vm file and the GString object uses the copy
 * 		
 *  Return:	
 * 	nothing 
 * 
 *  Destroyed:	
 * 	ax
 */


@message void MSG_GSO_SET_GSTRING_FOR_1X_CONVERT();
/*
 *  	Set the gstring object's gstring to the passed gstring. 
 * 	Any existing gstring will be destroyed. This does special
 * 	geometry that is only required when converting a 1.x
 * 	gstring object
 * 
 * 
 *  Context:	Unrestricted
 *  Source:	Unrestricted
 *  Destination:  GString GrObject
 *  Interception: unlikely
 * 
 *  PASS:
 * 	cx = VM file handle of gstring
 * 	dx = VM block handle of gstring
 * 
 * 	If CX = 0, 
 * 		The gstring MUST be in the vm file that the GString object
 * 		is in. The GString object will not make a copy of the
 * 		the gstring. The GString object will use the gstring directly 
 * 		and will destroy the gstring and the gstrings data if a 
 * 		new gstring is passed to the gstring object.
 * 		Make sure you fully understand the implications of this
 * 		before you do this.
 * 	ELSE
 * 		The passed gstring is copied into the GString objects 
 * 		vm file and the GString object uses the copy
 * 		
 *  Return:	
 * 	nothing 
 * 
 *  Destroyed:	
 * 	ax
 */

@instance word GSI_vmemBlockHandle;
@instance PointWWFixed GSI_gstringCenterTrans;
			
@endc


/*-----------------------------------------------------------------------------
	GrObjVisGuardianClass
-----------------------------------------------------------------------------*/

@class GrObjVisGuardianClass, GrObjClass;

@message void MSG_GOVG_UPDATE_VIS_WARD_WITH_STORED_DATA();
/*
 * 	Force the vis ward to reflect any attributes stored in
 * 	the guardian
 * 
 *  Context:	Unrestricted. E.g., when the vis ward is created or
 * 		preparing to be edited.
 *  Source:	Unrestricted
 *  Destination:	Any GrObjVisGuardian
 *  Interception:	Must be intercepted by any GrObjVisGuardian with special
 * 		data. No default handler.
 * 
 * PASS
 * 	nothing
 *  		
 * RETURN
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */



@message void MSG_GOVG_CONVERT_LARGE_MOUSE_DATA(); /* Needs prototype */
/*
 * 	Convert data in GrObjMouseData to LargeMouseData
 * 
 * PASS
 * 		ss:cx - GrObjMouseData - 
 * 				GOMD_point - in PARENT coords
 * 				GOMD_gstate - not used
 * 				GOMD_goFA -
 * 				GOMD_buttonInfo - from orig system mouse event
 * 		ss:bp - LargeMouseData - empty
 *  		
 * RETURN
 * 		ss:bp - LargeMouseData 
 * 			LMD_point - in OBJECT coords of OVP
 * 			LMD_buttonInfo
 * 			LMD_uiFA
 * 
 * WARNING: 	This routine takes data on two different areas 
 * 		of the stack and it returns data on the stack so it
 * 		may only be called from the same thread
 * DESTROYED:
 * 	ax
 */



@message optr MSG_GOVG_CREATE_VIS_WARD(MemHandle wardBlock = cx) = cx:dx; 	/* XXX */
/*
 * 	Create vis object that is ward of guardian
 * 
 *  Context:	Generally shortly after the guardian has been created
 *  Source:	The Guardian itself
 *  Destination:	The Guardian itself
 *  Interception:	Possible. If the ward has any special initialize that
 * 		needs to be done (eg MSG_SPLINE_INITIALIZE or setting
 * 		up the style arrays in the text object), it should
 * 		subclass this message, call its superclass and then
 * 		do any special initialization
 * 
 * PASS
 * 	cx - block to put ward in
 *  		
 * RETURN
 * 	cx:dx - OD of ward
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GOVG_ADD_VIS_WARD(optr wardOD = cx:dx);
/*
 * 	Add vis object as ward of guardian
 * 
 * PASS
 * 	cx:dx - od of ward
 *  		
 * RETURN
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GOVG_APPLY_OBJECT_TO_VIS_TRANSFORM(GStateHandle gstate = dx);
/*
 * 	Apply transformation from OBJECT coordinate system to
 * 	the VIS coordinate system
 * 	
 * 	This will transform VIS coordinates into OBJECT coordinates
 * 
 * PASS
 * 	dx - gstate
 *  		
 * RETURN
 * 	dx - gstate
 * 
 * DESTROYED:
 * 	ax
 */



@message GStateHandle MSG_GOVG_CREATE_GSTATE() = bp;
/*
 * 	Create a gstate for the ward with the transformation of the body,
 * 	all groups, and the guardian in it.
 * 	
 * 
 *  Context:	Called when ward needs a gstate
 *  Source:	Vis ward
 *  Destination:	Any object vis guardian
 *  Interception:	Unlikely
 * 
 * PASS:
 * 	nothing
 * 
 * RETURNS:
 * 	bp - gstate
 * 
 * DESTROYED:
 * 	ax
 */



@message void MSG_GOVG_VIS_BOUNDS_SETUP();
/*
 * 	Time to initialize the bounds of the ward and perform any
 * 	related actions
 * 	
 * 
 *  Context:	Usually called when guardian changes size.
 *  Source:	Unrestriced, usually the guardian itself
 *  Destination:	Any object vis guardian
 *  Interception:	Possibly. Probably will call the superclass first. The default
 * 		handler sets the ward's vis bounds to match the guardians
 * 		dimensions and then sends ward MSG_VIS_NOTIFY_GEOMETRY_VALID.
 * 		This causes the ward to do any recalculations, such as
 * 		rewrapping text	that it needs.
 * 
 * PASS:
 * 	nothing
 * 
 * RETURNS:
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */

typedef ByteEnum VisWardMouseEventType;		/* CHECKME */
#define VWMET_SMALL	0x0
#define VWMET_LARGE	0x1

@message void MSG_GOVG_SET_VIS_WARD_MOUSE_EVENT_TYPE(VisWardMouseEventTypes type = cl);
/*
 * 	Set type of mouse events that vis ward is interested in.
 * 	
 * 
 *  Context:	Unrestricted. Generally sent when vis ward grabs mouse
 *  Source:	Unrestricted, usually vis ward
 *  Destination:	Any object vis guardian
 *  Interception:	Unlikely. 
 * 
 * PASS
 * 	cl - VisWardMouseEventTypes
 *  		
 * RETURN
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GOVG_UPDATE_EDIT_GRAB_WITH_STORED_DATA();
/*
 * 	Send any stored data to the edit grab
 * 
 *  Context:	Unrestricted. Usually sent to the floater by itself
 * 		when it gets a start select in an object to edit
 * 		preparing to be edited.
 *  Source:	Unrestricted
 *  Destination:	Any GrObjVisGuardian
 *  Interception:	Must be intercepted by any GrObjVisGuardian with special
 * 		data. No default handler.
 * 
 * PASS
 * 	nothing
 *  		
 * RETURN
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */



@message void MSG_GOVG_NORMALIZE();
/*
 * 	Convert the object into a rectangle (not RectClass) and set
 * 	its GrObjTransMatrix as the Identity Matrix. The width
 * 	and height of the object will be rounded to the nearest integer
 * 
 *  Context:	GrObjVisGuardian Utility. Generally only used during
 * 		handling of MSG_GO_COMPLETE_CREATE to remove the
 * 		scale from the GrObjTransMatrix and set the objects
 * 		width and height to the size of the rectangle the
 * 		user has created.
 *  Source:	Unrestricted. Generally the object itself.
 *  Destination:  Any GrObjVisGuardian
 *  Interception: Unlikely
 * 
 * PASS:		
 * 	nothing			
 * 
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */



@message void MSG_GOVG_NOTIFY_VIS_WARD_CHANGE_BOUNDS(Rectangle *desiredBounds = ss:bp);
/*
 * 	Notify the guardian that the vis ward wishes to changes its
 * 	vis bounds.
 * 
 *  Context:	Sent to guardian when some action if performed on
 * 		the ward that causes it to want to change its vis 
 * 		bounds. Such as adding or deleting text or editing
 * 		spline bounds.
 *  Source:	Vis Ward
 *  Destination:  Guardian of ward changing bounds
 *  Interception: Possible. The default behaviour sets the OBJECT dimensions
 * 		to match the desired vis bounds. Sets the object's transform
 * 		to the identity matrix and moves the object the same amount
 * 		the center of the vis bounds moved by. Then it sets
 * 		the vis bounds of the ward to the desired size.
 * 
 * PASS:		
 * 	ss:bp - Rectangle, desired vis bounds
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message ClassStruct *MSG_GOVG_GET_EDIT_CLASS() = cx:dx;
/*
 * 	Return the highest class that the guardian can be used to edit.
 * 	It is assumed that if a guardian can edit a class it can
 * 	edit all subclasses of that class. For example, MultTextGuardianClass
 * 	can edit both TextGuardianClass and MultTextGuardianClass. 
 * 	TextGuardianClass class is the superclass of MultTextGuardianClass,
 * 	so the MultTextGuardianClass handler would return TextGuardianClass.
 *
 *
 *  Context:	GrObjVisGuardianUtility
 *  Source:	Unrestricted
 *  Destination:  GrObjVisGuardian
 *  Interception: The default handler returns the guardians class. If the
 * 		guardian can edit any of its superclasses, it needs to
 * 		intercept this message and not call its super class.
 * 
 * PASS:		
 * 	nothing
 * 			
 * RETURN:	
 * 	cx:dx - fptr to class
 * 
 * DESTROYED:
 * 	ax
 */

@message optr MSG_GOVG_GET_VIS_WARD_OD() = cx:dx;
/*
 * 	Return the output descriptor of the vis ward
 * 
 *  Context:	GrObjVisGuardian Utility
 *  Source:	Unrestricted
 *  Destination:  Unrestricted
 *  Interception: Unlikely
 * 
 * PASS:		
 * 	nothing
 * 		
 * RETURN:	
 * 	cx:dx - optr
 * 
 * DESTROYED:
 * 	ax
 */


@message VMChain MSG_GOVG_GET_TRANSFER_BLOCK_FROM_VIS_WARD(GrObjTransferParams *params = ss:bp) = cx.dx;
/*
 * 	Request a transfer block from the ward
 * 
 *  Context:	GrObjVisGuardian Utility
 *  Source:	Unrestricted
 *  Destination:  Unrestricted
 *  Interception: No default handler, so must handle for cut/copy/paste
 * 
 * PASS:		
 * 	VM override file set
 * 		
 * RETURN:	
 * 	cx:dx - 32 bit identifier from ward
 * 
 * DESTROYED:
 * 	ax
 */

@message void MSG_GOVG_CREATE_WARD_WITH_TRANSFER();
/*
 * 	Create a ward and pass it the passed 32 bit identifier
 * 
 *  Context:	GrObjVisGuardian Utility
 *  Source:	Unrestricted
 *  Destination:  Unrestricted
 *  Interception: No default handler, so must handle for cut/copy/paste
 * 
 * PASS:		
 * 	VM override file set
 * 	cx:dx - 32 bit identifier from ward
 * 		
 * RETURN:	^lcx:dx - new ward
 * 
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GOVG_SET_VIS_WARD_CLASS(ClassStruct _far *wardClass = cx:dx);
/*
 * 	Set the class of the vis ward. The class must be set before the
 * 	vis ward is created.
 * 
 *  Context:	After creating guardian with MSG_GB_CREATE_GROBJ and
 * 		before sending MSG_GO_INITIALIZE to the guardian.
 *  Source:	Unrestricted.
 *  Destination:  Guardian
 *  Interception: Unlikely
 * 
 * PASS:		
 * 		cx:dx - fptr to class of vis ward
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message GStateHandle MSG_GOVG_APPLY_SPRITE_OBJECT_TO_VIS_TRANSFORM(GStateHandle gstate = dx) = dx;
/*
 * 	Apply transformation from Sprite OBJECT coordinate system to
 * 	the VIS coordinate system
 * 	
 * 	This will transform VIS coordinates into Sprite OBJECT coordinates
 * 
 * PASS
 * 	dx - gstate
 *  		
 * RETURN
 * 	dx - gstate
 * 
 * DESTROYED:
 * 	ax
 */

@message Boolean MSG_GOVG_CHECK_FOR_EDIT_WITH_FIRST_START_SELECT() = carry;
/*
 * 	Determine if floater should edit object with the start select that
 * 	selects the object for editing.
 * 
 *  Context:	Sent to the floater that has just given the edit grab
 * 		to an object because the user clicked on the object.
 *  Source:	Floater
 *  Destination:  Floater
 *  Interception: The default hander returns carry set. If the floater
 * 		shouldn't edit the object with the start select then you
 * 		should return carry clear and not call the superclass.
 * 		For example, the beginner polyline and polycurve tools
 * 		normal add an anchor point when the user clicks on
 * 		the line of an existing spline.
 * 		But we don't want to add an anchor point
 * 		when the user is trying to choose the spline for editing.
 * 
 * PASS:		
 * 	nothing
 * 			
 * RETURN:	
 * 	carry set - edit object with the start select
 * 	carry clear - don't edit object with start select.
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GOVG_RULE_LARGE_START_SELECT_FOR_WARD(GrObjMouseData *data = ss:bp);
/*
 * 	Do any constrain/snap to grid of a start select before passing
 * 	the event to the Vis Ward
 * 
 *  Context:	Sent to the guardian just before passing the mouse event
 * 		on the the vis ward.
 *  Source:	Self
 *  Destination:  Self
 *  Interception: The default handler does normal grobj constrain. Most classes
 * 		will subclass, since the desired mouse constraint behavior
 * 		across classes is apparently quite varied.
 * 
 * PASS:		
 * 	ss:[bp] - GrObjMouseData
 * 			
 * RETURN:	
 * 	ss:[bp] - GrObjMouseData with ruled GOMD_point, if desired
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GOVG_RULE_LARGE_PTR_FOR_WARD(GrObjMouseData *data = ss:bp);
/*
 * 	Do any constrain/snap to grid of a ptr event before passing
 * 	the event to the Vis Ward
 * 
 *  Context:	Sent to the guardian just before passing the mouse event
 * 		on the the vis ward.
 *  Source:	Self
 *  Destination:  Self
 *  Interception: The default handler does normal grobj constrain. Most classes
 * 		will subclass, since the desired mouse constraint behavior
 * 		across classes is apparently quite varied.
 * 
 * PASS:		
 * 	ss:[bp] - GrObjMouseData
 * 			
 * RETURN:	
 * 	ss:[bp] - GrObjMouseData with ruled GOMD_point, if desired
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GOVG_RULE_LARGE_END_SELECT_FOR_WARD(GrObjMouseData *data = ss:bp);
/*
 * 	Do any constrain/snap to grid of an end select before passing
 * 	the event to the Vis Ward
 * 
 *  Context:	Sent to the guardian just before passing the mouse event
 * 		on the the vis ward.
 *  Source:	Self
 *  Destination:  Self
 *  Interception: The default handler does normal grobj constrain. Most classes
 * 		will subclass, since the desired mouse constraint behavior
 * 		across classes is apparently quite varied.
 * 
 * PASS:		
 * 	ss:[bp] - GrObjMouseData
 * 			
 * RETURN:	
 * 	ss:[bp] - GrObjMouseData with ruled GOMD_point, if desired
 * 
 * DESTROYED:
 * 	ax
 */



@message void MSG_GOVG_CLEAR_VIS_WARD_OD();
/*
 * 	Set GOVGI_ward to zero
 * 
 *  Context:	Sent by vis ward when it is handling MSG_META_FINAL_OBJ_FREE
 *  Source:	vis ward
 *  Destination:  vis ward's guardian
 *  Interception: No
 * 
 * PASS:		
 * 	nothing
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


typedef ByteFlags GrObjVisGuardianFlags;		/* CHECKME */
/*
 * If TRUE then the vis bounds of the
 * ward have changed since the last
 * time the bit was cleared. Each
 * guardian uses this bit differently
 * to help it determine when to 
 * send out GOANT_RESIZE action notifs.
 */
#define GOVGF_VIS_BOUNDS_HAVE_CHANGED	(0x80)

/*
 * if TRUE send large mouse
 * events to object. if FALSE send
 * small mouse events
 */
#define GOVGF_LARGE	(0x40)

/* For future expansion */
#define GOVGF_UNUSED	(0x20)

/* For future expansion */
#define GOVGF_ALSO_UNUSED	(0x10)

/*
 * if True then you must send
 * MSG_GOVG_APPLY_OBJECT_TO_VIS_TRANSFORM
 * to the object, otherwise a utililty
 * routine can be used.
 */
#define GOVGF_APPLY_OBJECT_TO_VIS_TRANSFORM	(0x08)

/*
 * if TRUE then floater can edit
 * existing objects in the document
 */
#define GOVGF_CAN_EDIT_EXISTING_OBJECTS	(0x04)

typedef ByteEnum GrObjVisGuardianCreateMode;		/* CHECKME */
/* New objects cannot be create with the guardian. */
#define GOVGCM_NO_CREATE	0x0

/*
 * Creating a new object is handled by the guardian and 
 * consists of dragging open a rectangular area. For example,
 * the text object.
 */
#define GOVGCM_GUARDIAN_CREATE	0x0

/*
 * Creating a new object is handled by the ward and mouse
 * events during create should be sent to the ward. For example,
 * creating bitmap with pencil.
 */
#define GOVGCM_VIS_WARD_CREATE	0x0

@instance optr GOVGI_ward;
@instance word *GOVGI_class;
@instance GrObjVisGuardianFlags   GOVGI_flags;

@endc

/*-----------------------------------------------------------------------------
	GrObjVisClass
-----------------------------------------------------------------------------*/
#define ObjDerefGrObjVis(obj) ObjDeref2(obj)

@class GrObjVisClass, VisClass, master, variant;

typedef struct {
	WWFixed    WWFC_y;
	WWFixed    WWFC_x;
} WWFixedCenter;

@message void MSG_GV_GET_WWFIXED_CENTER(WWFixedCenter retVal = bpaxdxcx);
/*
 * 	Get the WWFixed center of the visual bounds of the object
 * 	
 * 
 * PASS:
 * 	nothing
 * 
 * RETURN:
 * 	dx:cx - WWFixed x of center
 * 	bp:ax - WWFixed y of center
 * 
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GV_SET_GUARDIAN_LINK(optr guardianOD = cx:dx);
/*
 * 	Set guardian link to passed OD
 * 	
 * 
 * PASS:
 * 	cx:dx - od of guardian
 * 
 * RETURN:
 * 	nothing
 * 
 * 
 * DESTROYED:
 * 	ax
 */



@message void MSG_GV_SET_VIS_BOUNDS(Rectangle *bounds = ss:bp);
/*
 * 	Set the visual bounds of the vis ward
 * 
 *  Context:	Unrestricted.
 *  Source:	Unrestricted. Generally guardian
 *  Destination:  GrObjVis object
 *  Interception: Possible. The default handler sets the vis bounds using
 * 		standard VIS messages. Individual objects may have
 * 		an object specific message
 * 
 * PASS:		
 * 		ss:bp - Rectangle
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */



@message ClassStruct *MSG_GV_GET_GROBJ_VIS_CLASS() = cx:dx;
/*
 * 	Returns the class representing the object's "leaf" class
 * 	according to The GrObj.
 * 
 *  Context:	Sent by the object to itself when writing to the transfer item
 * 		so that in case a subclassing library writes the transfer
 * 		item, then goes away, we still have some class we can paste.
 *  Source:	Likely the guardian of the object, probably in the
 * 		MSG_GO_CREATE_TRANSFER method.
 *  Destination:  Any clipboardable GrObjVis.
 * 
 *  Interception: DO NOT INTERCEPT THIS MESSAGE. That's the whole point,
 * 		isn't it?
 * 
 * PASS:		
 * 	nothing
 * 			
 * RETURN:	
 * 	cx:dx - a class ptr recognized by GrObj
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GV_SET_REALIZED_AND_UPWARD_LINK(optr bodyOD = cx:dx);
/*
 * 	Set the object's realized bit and the upward link
 * 	to the body.
 * 
 *  Context:	Sent when guardian is added to the body
 *  Source:	Guardian
 *  Destination:  Ward
 *  Interception: Unlikely
 * 
 * PASS:		
 * 		cx:dx - od of body
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_GV_CLEAR_REALIZED_AND_UPWARD_LINK();
/*
 * 	Clear the object's realized bit and the upward link
 * 
 *  Context:	Sent when guardian is removed from the body
 *  Source:	Guardian
 *  Destination:  Ward
 *  Interception: Unlikely
 * 
 * PASS:		
 * 	nothing
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message optr MSG_GV_GET_GUARDIAN() = cx:dx;
/*
 * 	Return guardian of vis ward
 * 
 *  Context:	GrObjVis Utility
 *  Source:	Unrestricted
 *  Destination:  GrObjVis
 *  Interception: Unlikely
 * 
 * PASS:		
 * 	nothing		
 * 
 * RETURN:	
 * 	cx:dx - od of guardian
 */

@message word MSG_GV_GET_POTENTIAL_WARD_SIZE() = cx;
/*
 * 	Return the number of bytes that the ward can use up in
 *  	its block. This includess instance data, chunks and vardata, but
 * 	not data in other blocks created by this object.
 * 
 *  Context:	Used to keep track of which document blocks can
 * 		have more objects added to them. 
 *  Source:	Guardian
 *  Destination:  GrObjVis
 *  Interception: The default handler will calculate the instance data size,
 * 		but if your object allocates chunks or vardata in its
 * 		block it must subclass this message. Call the superclass
 * 		first and then add in your extra bytes
 * 
 * PASS:		
 * 	nothing
 * 			
 * RETURN:	
 * 	cx - size in bytes
 * 
 * DESTROYED:
 * 	ax
 */

@instance optr GVI_guardian;

@endc

/*-----------------------------------------------------------------------------
	BitmapGuardianClass
-----------------------------------------------------------------------------*/

@class BitmapGuardianClass, GrObjVisGuardianClass;

@message void MSG_BG_SET_TOOL_CLASS(ClassStruct _far *toolClass = cx:dx);
/*
 * 	Store class of bitmap tool
 * 
 *  Context:	BitmapGuardian Utility
 *  Source:	Unrestricted
 *  Destination:  BitmapGuardian
 *  Interception: Unlikely
 * 
 * PASS:		
 * 	cx:dx - fptr to tool class
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */

typedef ByteEnum BitmapGuardianBitmapPointerActiveStatus;		/* CHECKME */
#define BGBPAS_ACTIVE	0x0
#define BGBPAS_INACTIVE	0x0

@message void MSG_BG_SET_BITMAP_POINTER_ACTIVE_STATUS(
	BitmapGuardianBitmapPointerActiveStatus status = cl);
/*
 * 	Notify bitmap guardian whether there is an active BitmapPointer tool
 * 	
 *  Context:	When a BitmapPointer floater is created or destroyed,
 * 		it must notify the editing bitmap object,so the
 * 		bitmap knows whether to draw its real estate handles.
 * 		Also sent by object to itself when it loses the grab.
 *  Source: 	Unrestricted, usually the BitmapPointer or the object
 *  Destination:	Only BitmapGaurdians being edited
 *  Interception: Unlikely
 * 		
 * 
 * PASS
 * 	cl - BitmapGuardianBitmapPointerActiveStatus
 *  		
 * RETURN
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */

@message void MSG_BG_REAL_ESTATE_HANDLE_HIT_DETECTION();/* Needs Prototype */
/*
 * 	Determine if one of the real estate handles of the object would be hit
 * 	by the passed point
 * 
 *  Context:	Usually called as direct action of user clicking with
 * 		the bitmap pointer tool. 
 *  Source:	Unrestricted, generally the floater
 *  Destination:	Any BitmapGuardian object. The message will be ignored unless
 * 		both the GOTM_EDIT_INDICATOR_DRAWN and BGF_POINTER_ACTIVE
 * 		bits are set
 *  Interception:	Unlikely
 * 
 * PASS
 * 	ss:bp - PointDWFixed in PARENT
 * 
 * RETURN
 * 	al - EVALUATE_NONE - handles not hit
 * 		ah - destroyed
 * 	al - EVALUATE_HIGH - handle hit
 * 		ah - tranformFlags - only handle info applies
 * 
 * 	dx - 0 ( blank EvaluatePositionNotes)
 * 
 * DESTROYED:
 * 	see RETURN
 */


@message void MSG_BG_ACTIVATE_REAL_ESTATE_RESIZE(); 	/* Needs Prototype */
/*
 * 	Sets up object for real estate resize. 
 * 
 *  Context:	Usually called when user clicks on real estate resize handle
 *  Source:	Unrestricted, generally bitmap pointer object
 *  Destination:	BitmapGuardian that has edit grab
 *  Interception:	Unlikely
 */

@message void MSG_BG_JUMP_START_REAL_ESTATE_RESIZE(
	GrObjFunctionsActive fa = bp,
	GStateHandle gstate = dx);
/*
 * 	Jump starts resize by doing an activate, start and drag stuff
 * 
 *  Context:	Quickly start an interactive resize. Usually called
 * 		when user clicks on resize handle
 *  Source:	Unrestricted, generally bitmap pointer object
 *  Destination:	BitmapGuardian that has edit grab
 *  Interception:	Unlikely
 * 
 * 
 * PASS:
 * 	bp - GrObjFunctionsActive
 * 	dx - gstate or 0
 * 
 * RETURN:
 * 
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_BG_PTR_REAL_ESTATE_RESIZE(GrObjResizeMouseData *data = ss:bp);
/*
 * 	Sent to update position of mouse during an interactive resize
 * 	
 * 
 *  Context:	During an interactive resize. This message 
 * 		cooresponds to an MSG_META_PTR when the object is
 * 		in real estate resize mode
 *  Source:	Unrestricted, generally pointer object
 *  Destination:	BitmapGuardian that has edit grabbed and is being
 * 		real estate resized interactively
 *  Interception:	Unlikely
 * 		
 * 		
 * 
 * PASS:
 * 	ss:bp = GrObjResizeMouseData
 * 		GORSMD_point - deltas to resize
 * 		GORSMD_gstate - gstate to draw with
 * 		GORSMD_goFA - GrObjFunctionsActive
 * 		GORSMD_anchor - anchored handle
 * 	
 * RETURN:
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_BG_END_REAL_ESTATE_RESIZE(GrObjResizeMouseData *data = ss:bp);
/*
 * 	Sent to complete an interactive resize on an object
 * 
 * 
 *  Context:	At the end of an interactive resize. This message 
 * 		cooresponds to an MSG_META_END_SELECT when the object is
 * 		in real estate resize mode
 *  Source:	Unrestricted, generally bitmap pointer object
 *  Destination:	BitmapGuardian with edit grab. If the
 * 		object is not currently being resized interactively
 * 		the message will be ignored.
 *  Interception:	Unlikely
 * 
 * 
 * PASS:
 * 	ss:bp = GrObjResizeMouseData
 * 		GORSMD_point - deltas to resize
 * 		GORSMD_anchor - anchored handle
 * 		GORSMD_grabbed - grabbed handle
 * 		GORSMD_gstate - gstate to draw with
 * 		GORSMD_goFA - GrObjFunctionsActive
 * 
 * RETURN:
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_BG_CREATE_VIS_BITMAP(
	word width = cx,
	word height = dx,
	GStateHandle gstring = bp);
/*
 * 	Sent to force the bitmap to allocate its vidmem
 * 
 * 
 * PASS:
 * 	cx,dx - width, height of bitmap to allocate
 * 	bp - gstring to initialize bitmap with (0 for none)
 * 
 * RETURN:
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message ClassStruct *MSG_BG_GET_TOOL_CLASS() = cx:dx;
/*
 * 	Get stored class of bitmap tool
 * 
 *  Context:	BitmapGuardian Utility
 *  Source:	Unrestricted
 *  Destination:  BitmapGuardian
 *  Interception: Unlikely
 * 
 * PASS:		
 * 	nothing
 * 			
 * RETURN:	
 * 	cx:dx - fptr to tool class
 * 
 * DESTROYED:
 * 	ax
 */


typedef ByteFlags BitmapGuardianFlags;		/* CHECKME */
/*
 * if TRUE then the floater is a
 * BitmapPointer, so the bitmap
 * should display handles instead
 * of a dotted box for its edit indicator
 * and it should respond to clicks
 * on those handles. The BitmapPointer
 * is used for changing the bitmap
 * width and height.
 */
#define BGF_POINTER_ACTIVE	(0x02)
/*
 * if TRUE then current resize
 * action is actually a real
 * estate resize			
 */
#define BGF_REAL_ESTATE_RESIZE	(0x01)

typedef ByteEnum VisWardToolActiveStatus;		/* CHECKME */
#define VWTAS_ACTIVE	0x0
#define VWTAS_INACTIVE	0x0

typedef struct {		/* CHECKME */
    ClassStruct			*BGSID_toolClass;
    VisWardToolActiveStatus	BGSID_activeStatus;
} BitmapGuardianSpecificInitializationData;

@instance BitmapGuardianFlags BGI_flags;
@instance ClassStruct	*BGI_toolClass;

@endc

/*-----------------------------------------------------------------------------
	GrObjBitmapClass
-----------------------------------------------------------------------------*/

@class GrObjBitmapClass, GrObjVisClass;
/*	@uses VisBitmapClass;	when bitmap has C interface */
@endc


/*-----------------------------------------------------------------------------
	SplineGuardianClass
-----------------------------------------------------------------------------*/

@class SplineGuardianClass, GrObjVisGuardianClass;

@message void MSG_SG_SET_SPLINE_MODE(SplineGuardianMode mode = cl);
/*
 * 	Set the instance data in the guardian regarding Spline mode and
 * 	forward the info to the ward, if necessary.
 * 
 *  Context:	Spline Guardian utility
 *  Source: 	Unrestricted
 *  Destination:	Any SplineGuardian
 *  Interception: Unlikely
 * 		
 * 
 * PASS
 * 	cl - SplineGuardianMode
 *  		
 * RETURN
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_SG_GENERATE_SPLINE_NOTIFY(
	SplineGenerateNotifyParams *params = ss:bp);
/*
 * 	If relayed bit is set, then pass the message on down to the ward,
 * 	otherwise pass it up to the body.
 * 
 *  Context:	Unrestricted.
 *  Source:	Unrestricted
 *  Destination:  GrObjBody
 *  Interception: Unlikely
 * 
 * PASS:		
 * 	ss:bp - SplineGenerateNotifyParams
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */

@message void MSG_SG_SWITCH_TO_SPLINE_CREATE_MODE();
/*
 * 	Use SplineMode stored in SGI_splineCreateMode.
 * 
 *  Context:	Unrestricted. Generally sent by object to itself when
 * 		handling MSG_GO_BEGIN_CREATE.
 *  Source:	Unrestricted
 *  Destination:  SplineGuardian
 *  Interception: Unlikely
 * 
 * PASS:		
 * 	nothing
 * 
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_SG_SWITCH_TO_SPLINE_AFTER_CREATE_MODE();
/*
 * 	Use SplineMode stored in SGI_splineAfterCreateMode if the
 * 	SGI_splineMode field is one of the splines create modes.
 * 
 * 
 *  Context:	Unrestricted. Generally sent by object to itself when it
 * 		receives a double click.
 *  Source:	Unrestricted
 *  Destination:  SplineGuardian
 *  Interception: Unlikely
 * 
 * PASS:		
 * 	nothing
 * 
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_SG_SET_SPLINE_CREATE_AND_AFTER_CREATE_MODES();
/*
 * 	Set SGI_splineAfterCreateMode and SGI_splineCreateMode.
 * 
 *  Context:	Unrestricted. Generally sent to object by floater when
 * 		the floater is handling 
 * 		MSG_GOVG_UPDATE_EDIT_GRAB_WITH_STORED_DATA
 *  Source:	Unrestricted
 *  Destination:  SplineGuardian
 *  Interception: Unlikely
 * 
 * PASS:		
 * 	nothing
 * 
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */

@instance byte SGI_splineCreateMode;
@instance byte SGI_splineAfterCreateMode;
@instance byte SGI_splineMode;

@endc

/*-----------------------------------------------------------------------------
	GrObjSplineClass
-----------------------------------------------------------------------------*/

@class GrObjSplineClass, GrObjVisClass;
/*	@uses VisSplineClass;	when spline has C interface */
@endc

/*-----------------------------------------------------------------------------
	TextGuardianClass
-----------------------------------------------------------------------------*/

@class TextGuardianClass, GrObjVisGuardianClass;

@message void MSG_TG_CALC_DESIRED_MIN_HEIGHT();	/* XXX */
/*
 * 	Calculate and set the TGI_desiredMinHeight field in the text guardian
 * 	object based on the current OBJECT height
 * 
 *  Context:	TextGuardian Utility. Usually sent at the end of an
 * 		interactive resize or create.
 *  Source:	Unrestricted. Usually TextGuardian itself
 *  Destination:  Unrestricted. Usually TextGuardian itself
 *  Interception: Unlikely
 * 
 * PASS:		
 * 	nothing		
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */

@message void MSG_TG_SET_DESIRED_MIN_HEIGHT(word height = cx);
/*
 * 	Set the TGI_desiredMinHeight field in the text guardian object. 
 * 
 *  Context:	Unrestricted. Usually sent as result of 
 * 		MSG_TG_CALC_DESIRED_MIN_HEIGHT
 *  Source:	Unrestricted. Usually TextGuardian itself
 *  Destination:  Unrestricted. Usually TextGuardian itself
 *  Interception: Unlikely
 * 
 * PASS:		
 * 	cx - height in points
 * 
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */

@message void MSG_TG_HEIGHT_NOTIFY(word desiredHeight = dx);
/*
 * 	Adjust the height of the guardian and ward
 * 
 * 
 *  Context:	The ward received MSG_VIS_TEXT_HEIGHT_NOTIFY
 *  Source:	GrObjText vis ward
 *  Destination:  TextGuardian
 *  Interception: Unlikely
 * 
 * PASS:		
 * 		dx - height text object wants to be.
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_TG_GENERATE_TEXT_NOTIFY(
	VisTextGenerateNotifyParams *params = ss:bp);
/*
 * 	If relayed bit is set, then pass the message on down to the ward,
 * 	otherwise pass it up to the body.
 * 
 *  Context:	Unrestricted.
 *  Source:	Unrestricted
 *  Destination:  GrObjBody
 *  Interception: Unlikely
 * 
 * PASS:		
 * 	ss:bp - VisTextGenerateNotifyParams
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_TG_CALC_DESIRED_MAX_HEIGHT();	/* XXX */
/*
 * 	Calculate and set the TGI_desiredMaxHeight field in the text guardian
 * 	object based on the current OBJECT height
 * 
 *  Context:	TextGuardian Utility. Usually sent at the end of an
 * 		interactive resize or create.
 *  Source:	Unrestricted. Usually TextGuardian itself
 *  Destination:  Unrestricted. Usually TextGuardian itself
 *  Interception: Unlikely
 * 
 * PASS:		
 * 	nothing		
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */

@message void MSG_TG_SET_DESIRED_MAX_HEIGHT(word desiredHeight = cx);
/*
 * 	Set the TGI_desiredMaxHeight field in the text guardian object. 
 * 
 *  Context:	Unrestricted. Usually sent as result of 
 * 		MSG_TG_CALC_DESIRED_MAX_HEIGHT
 *  Source:	Unrestricted. Usually TextGuardian itself
 *  Destination:  Unrestricted. Usually TextGuardian itself
 *  Interception: Unlikely
 * 
 * PASS:		
 * 	cx - height in points
 * 
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@message void MSG_TG_SET_TEXT_GUARDIAN_FLAGS(
				TextGuardianFlags flagsToSet = cl,
				TextGuardianFlags flagsToReset = dl); /* XXX */
/*
 * 	Set the text guardian flags
 * 
 *  Context:	Text Guardian Utility
 *  Source:	Unrestricted
 *  Destination:  Text Guardian
 *  Interception: Unlikely
 * 
 * PASS:		
 * 	cl - TextGuardianFlags to set
 * 	dl - TextGuardianFlags to reset
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */

typedef ByteFlags TextGuardianFlags;		/* CHECKME */
/* 3 bits unused */
/*
 * If TRUE then text object
 * will not shrink below
 * the desiredMinHeight while
 * it is being edited or when
 * some attribute changes
 */
#define TGF_ENFORCE_DESIRED_MIN_HEIGHT	(0x10)

/*
 * If TRUE then text object
 * will not expand above
 * the desiredMaxHeight while
 * it is being edited or when
 * some attribute changes
 */
#define TGF_ENFORCE_DESIRED_MAX_HEIGHT	(0x08)

/*
 * If TRUE, text object
 * can grow beyond 
 * desiredMaxHeight during
 * editing, but when the
 * object stops be edited
 * it will shrink back to
 * desiredMaxHeight.
 * Meaningless if 
 * TGF_ENFORCE_DESIRED_MAX_HEIGHT
 * is not set.
 */
#define TGF_DISABLE_ENFORCED_DESIRED_MAX_HEIGHT_WHILE_EDITING	(0x04)

/*
 * If TRUE, then during resize
 * don't allow text
 * object to become shorter
 * than is necessary to display
 * all the text.
 */
#define TGF_ENFORCE_MIN_DISPLAY_SIZE	(0x02)

/*
 * If TRUE then when the
 * text object loses the
 * edit grab shrink
 * the width to minimum
 * needed to
 * hold the text. Used when
 * user clicks and releases
 * in the same spot to
 * create.
 */
#define TGF_SHRINK_WIDTH_TO_MIN_AFTER_EDIT	(0x01)

@instance TextGuardianFlags TGI_flags;
@instance word TGI_desiredMinHeight;
@instance word TGI_desiredMaxHeight;

@endc

/*-----------------------------------------------------------------------------
	MultTextGuardianClass
-----------------------------------------------------------------------------*/

@class MultTextGuardianClass, TextGuardianClass;
@endc

/*-----------------------------------------------------------------------------
	EditTextGuardianClass
-----------------------------------------------------------------------------*/

@class EditTextGuardianClass, TextGuardianClass;
@endc


/*-----------------------------------------------------------------------------
	GrObjTextClass
-----------------------------------------------------------------------------*/
@class GrObjTextClass, GrObjVisClass;

	@uses VisTextClass;

@message void MSG_GT_ADJUST_MARGINS_FOR_LINE_WIDTH(WWFixed thickness = dx.cx);
/*
 * 	Change the margins of the text object so that the test won't 
 * 	collide with the line drawn around it.
 * 
 *  Context:	Unrestricted. Usually sent when line attributes change
 *  Source:	Unrestricted. Generally TextGuardian
 *  Destination:  Any GrObjText
 *  Interception: Unlikely
 * 
 * PASS:		
 * 	dx:cx - WWFixed line thickness
 * 			
 * RETURN:	
 * 	nothing
 * 
 * DESTROYED:
 * 	ax
 */


@endc

/*-----------------------------------------------------------------------------
	GrObj External Declarations
-----------------------------------------------------------------------------*/
extern void
    _pascal GrObjBodyProcessAllGrObjsInDrawOrderCommon(optr grobjBody,
					       ObjCompCallType callType,
					       Message message,
					       word param1,
					       word param2,
					       word param3,
					       word *ax_return,
					       word *cx_return,
					       word *dx_return,
					       word *bp_return);

extern void
    _pascal GrObjBodyProcessSelectedGrObjsCommon(optr grobjBody,
					 Message message,
					 word param1,
					 word param2,
					 word param3,
					 word *ax_return,
					 word *cx_return,
					 word *dx_return,
					 word *bp_return);
extern void
    _pascal GrObjBodyProcessSelectedGrObjsCommonPassFlag(optr grobjBody,
					 Message message,
					 word param1,
					 word param2,
					 word param3,
					 ObjCompCallType flag,
					 word *ax_return,
					 word *cx_return,
					 word *dx_return,
					 word *bp_return);

extern void
	_pascal GrObjGetSpriteOBJECTDimensions(optr spriteObject,
					WWFixed *spriteWidth,
					WWFixed *spriteHeight);

extern void
	_pascal GrObjGetAbsSpriteOBJECTDimensions(optr spriteObject,
					WWFixed *spriteWidth,
					WWFixed *spriteHeight);

extern void
	_pascal GrObjGetNormalOBJECTDimensions(optr normalObject,
					WWFixed *normalWidth,
					WWFixed *normalHeight);

extern void
	_pascal GrObjCalcCorners(WWFixed objectWidth,
			WWFixed objectHeight,
			sword *negWidthOver2,
			sword *negHeightOver2,
			sword *posWidthOver2,
			sword *posHeightOver2,
			GStateHandle gstate);

extern void
	_pascal GrObjResizeSpriteRelativeToSprite(optr spriteObject,
					  word grObjHandleSpec,
					  PointDWFixed *objectDeltaResize);

extern optr
    	_pascal GrObjGetBodyOD(Segment grobjSeg);

extern void
    	_pascal GrObjMessageToBody(
			Segment grobjSeg,
			Message msg,
			word cx_param,
			word dx_param,
			word bp_param);

extern word
	_pascal GrObjBodySetGrObjDrawFlagsForDraw(
				optr grobjBody,
				word drawFlags);

typedef struct {
	word	LWAHD_maxLineWidth;
	byte	LWAHD_handleWidth;
	byte	LWAHD_handleHeight;
} LineWidthAndHandleDims;

extern LineWidthAndHandleDims
	_pascal GrObjGetCurrentHandleSize(Segment grobjSeg);
/*
 * Description:	Returns the current handle size and maximum line width
 *
 * Pass: 	grobjSeg - segment containing a GrObj
 *
 * Return:	current handle size and max line width
 */

extern void
	_pascal GrObjDrawOneHandle(
			optr grobjOD,
			GrObjHandleSpecification handleSpec,
			GStateHandle gstate,
			word handleWidth,
			word handleHeight);
/*
 * Description: Draw a selection/move handle
 *
 * Pass:	optr - OD of GrObj
 *		handleSpec - GrObjHandleSpecification for the handle you
 *			     wish to draw
 *		gstate - GState to draw handle to
 *		handleWidth - width of handle
 *		handleHeight - height of handle
 *
 * Return:	void
 */

typedef struct {
	word    NU_x;
	word    NU_y;
} NudgeUnits;

extern NudgeUnits
	_pascal GrObjGetCurrentNudgeUnits(Segment grobjSeg);
/*
 * Description:	Get the current nudge values. These represent the
 *		number of points that currently equal one screen pixel
 *		in x and y
 *
 * Pass:	grobjSeg - segment containing a GrObj
 *
 * Return:	Current amount to nudge in either direction
 */


extern void
	_pascal GrObjDraw32BitRect(
			RectDWord _far *rect,
			GStateHandle gstate);
/*
 * Description:	Draw a rectangle from 32 bit coordinates
 *
 * Pass:	rect - RectDWord to draw
 *		gstate - gstate to draw rectangle to
 *
 * Return:	void
 */

extern void
	_pascal GrObjBodyParseGString(
			optr bodyOD,
			VMFileHandle gstringFile,
			VMBlockHandle gstringBlock,
			PointDWFixed _far *origin);
/*
 * Description:	Just take the whole gstring and cram it into one gstring object
 *
 *	NOTE:******
 *	The caller must	have explicity set or cleared ATTR_GB_PASTE_CALL_BACK 
 *	before calling this routine.
 *
 * Pass:	optr - OD of GrObjBody
 *		gstringFile - VMFileHandle of file containing GString
 *		gstringBlock - VMBlockHandle within gstringFile of GString
 *		origin - location to center GString
 *
 * Return:	void
 */


extern void
	_pascal SplineGuardianTransformSplinePoints(optr guardianOD);
/*
 * Description:	Transform spline points by the scale factor from the
 *		vis bounds to the object dimensions.
 *
 * Pass:	optr - OD of the SplineGuardian
 *
 * Return:	void
 */

extern Boolean
	_pascal GrObjApplyNormalTransform(optr grobjOD,	GStateHandle gstate);
/*
 * Description:	Apply normal transform information to passed gstate
 *
 * Pass:	optr - OD of GrObj
 *		gstate - gstate to apply transform to
 *
 * Return:	true if GrObjTransMatrix of passed GrObj was the
 *		identity matrix
 */


extern optr
	_pascal GrObjTestSupportedTransferFormats(ClipboardItemFlags cif);
/*
 * Description:	Tests for "pasteable" formats on the clipboard
 *
 * Pass:	cif - ClipboardItemFlags (CIF_QUICK is the important one)
 *
 * Return:	owner of transfer item (null if no compatible transfer format
 *		available
 */




#ifdef __HIGHC__

pragma Alias (GrObjBodyProcessAllGrObjsInDrawOrderCommon,
	      "GROBJBODYPROCESSALLGROBJSINDRAWORDERCOMMON");
pragma Alias (GrObjBodyProcessSelectedGrObjsCommon,
	      "GROBJBODYPROCESSSELECTEDGROBJSCOMMON");
pragma Alias (GrObjBodyProcessSelectedGrObjsCommonPassFlag,
	      "GROBJBODYPROCESSSELECTEDGROBJSCOMMONPASSFLAG");
pragma Alias (GrObjGetSpriteOBJECTDimensions,
	      "GROBJGETSPRITEOBJECTDIMENSIONS");
pragma Alias (GrObjGetAbsSpriteOBJECTDimensions,
	      "GROBJGETABSSPRITEOBJECTDIMENSIONS");
pragma Alias (GrObjGetNormalOBJECTDimensions,
	      "GROBJGETNORMALOBJECTDIMENSIONS");
pragma Alias (GrObjResizeSpriteRelativeToSprite,
	      "GROBJRESIZESPRITERELATIVETOSPRITE");
pragma Alias (GrObjCalcCorners, "GROBJCALCCORNERS");
pragma Alias (GrObjGetBodyOD, "GROBJGETBODYOD");
pragma Alias (GrObjMessageToBody, "GROBJMESSAGETOBODY");
pragma Alias (GrObjBodySetGrObjDrawFlagsForDraw, 
				"GROBJBODYSETGROBJDRAWFLAGSFORDRAW");
pragma Alias (GrObjGetCurrentHandleSize, "GROBJGETCURRENTHANDLESIZE");
pragma Alias (GrObjDrawOneHandle, "GROBJDRAWONEHANDLE");
pragma Alias (GrObjGetCurrentNudgeUnits, "GROBJGETCURRENTNUDGEUNITS");
pragma Alias (GrObjDraw32BitRect, "GROBJDRAW32BITRECT");
pragma Alias (GrObjBodyParseGString, "GROBJBODYPARSEGSTRING");
pragma Alias (SplineGuardianTransformSplinePoints,
		"SPLINEGUARDIANTRANSFORMSPLINEPOINTS");
pragma Alias (GrObjApplyNormalTransform, "GROBJAPPLYNORMALTRANSFORM");
pragma Alias (GrObjTestSupportedTransferFormats,
		"GROBJTESTSUPPORTEDTRANSFERFORMATS");

#endif /* __HIGHC__ */




@endlib

