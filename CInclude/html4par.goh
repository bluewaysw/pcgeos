/***********************************************************************
 *
 * PROJECT:       HTML4Par
 * FILE:          html4par.goh
 *
 * AUTHOR:    Marcus Gr”ber
 *
 ***********************************************************************/

@include <product.goh>
#include <product.h>

@include <Objects/vLTextC.goh>    /* VisLargeText definitions */
#include <htmlfstr.h>
#include <awatcher.h>

#ifdef DO_DBCS
#define HTML_STATIC_BUF   128 /* TCHAR arrays */
#else
#define HTML_STATIC_BUF   256 /* covers most URLs, small for local var */
#endif
#define HTML_MAX_BUF     8000 /* absolute maximum supported URL length */
#define HTML_MIN_BUF      (sizeof(MemHandle)+sizeof(int)+1)

#define URL_MAX_TYPE            11
#define URL_MAX_SERVER          256
#define URL_MAX_USERNAME        64
#define URL_MAX_PASSWORD        64


/***************************************************************************
 *              Name Pool and Name Association support
 ***************************************************************************/

typedef word NameToken;

#define NAME_POOL_NONE  0

optr _pascal NamePoolCreate(VMFileHandle vmf);
void _pascal NamePoolFree(optr pool);

NameToken _pascal NamePoolTokenizeLen(optr pool, TCHAR *name, word len, Boolean required);
/* shorthand form for ASCIIZ strings: */
#define NamePoolTokenize(pool, name, required) NamePoolTokenizeLen(pool, name, 0, required)
NameToken _pascal NamePoolTokenizeLenDOS(optr pool, char *name, word len, Boolean required);
#define NamePoolTokenizeDOS(pool, name, required) NamePoolTokenizeLenDOS(pool, name, 0, required)

NameToken _pascal NamePoolFind(optr pool, TCHAR *name);
void _pascal NamePoolUseToken(optr pool, NameToken token);
void _pascal NamePoolReleaseToken(optr pool, NameToken token);
Boolean _pascal NamePoolTestEqual(optr pool, NameToken token, TCHAR *str);
Boolean _pascal NamePoolTestEqualI(optr pool, NameToken token, TCHAR *str);
void _pascal NamePoolCopy(optr pool, TCHAR *buf, word buflen, NameToken token,
  TCHAR **ptr);
Boolean _pascal NamePoolIsTokenValid(optr pool, NameToken token, Boolean doCrash) ;

NameToken _pascal NamePoolTokenizeFromPool(optr pool, optr pool2,
  NameToken tok2, Boolean required);

/*
 * The following function should be applied to every pointer returned by
 * NamePoolCopy() or similar functions after it is no longer needed.
 * It frees the associated memory if the buffer was allocated on the global
 * heap (rather than using the static buffer passed to the function).
 */
void _pascal NamePoolDestroyIfDynamic(void *p);

VMChain _pascal NamePoolVMSave(optr pool, VMFileHandle vmf);
optr _pascal NamePoolVMLoad(VMFileHandle vmf, VMChain vmc);
void _pascal NamePoolVMUnload(optr pool);
NameToken _pascal NamePoolTokenizeFromVM(optr pool,
  VMFileHandle vmf, VMChain vmc, NameToken vmtok, Boolean required);

optr CopyArrayWithTokens(MemHandle srcMem, ChunkHandle srcArray,
  VMFileHandle vmf, VMChain vmc, optr pool, ...);
optr CopyArrayWithTokensFromPool(optr array, optr srcPool,
   MemHandle dstMem, optr dstPool, ...);
void FreeArrayNameTokens(optr array, optr pool, ...);

optr _pascal NameAssocCreate(MemHandle mem, optr namePool);
void _pascal NameAssocFree(optr assoc);
void _pascal NameAssocAssociate(optr assoc, TCHAR *str1, TCHAR *str2);

/* The pointer returned by this function also has to be passed to
   NamePoolDestroyIfDynaic() when done with. */
Boolean _pascal NameAssocFindAssociation(optr assoc,
  TCHAR *key, TCHAR *ret, word bufsize, Boolean firstToSecond, TCHAR **ptr);

NameToken _pascal NamePoolConcatStr(optr pool, NameToken tok, TCHAR *str);

word _pascal NamePoolStrLength(optr pool, NameToken tok);

Boolean _pascal NamePoolInitializeDynamic(TCHAR *buf, int buflen, TCHAR *p, TCHAR **bufP);
Boolean _pascal NamePoolIsDynamic(TCHAR *p);
Boolean _pascal NamePoolResizeDynamic(TCHAR **p, int size);

/***************************************************************************
 *              Hypertext Transfer Item
 ***************************************************************************/

/* Utility function for removing a transfer item including all attached
   data (assuming that it may be more complex than a simple VMChain). */

void FreeHTMLTransferItem(VMFileHandle vmf, VMChain vmc);

/* Data type for length specifications, also allowing for non-pixel values */

typedef word HTMLmultiLength;
    #define HTML_LEN_VALUE_MASK 0x3FFF  /* value of length */
    #define HTML_LEN_UNIT_MASK  0xC000  /* unit of length */
    #define HTML_LEN_PIXEL      0x0000  /*   pixel (...="100") */
    #define HTML_LEN_PERCENT    0x8000  /*   percentage (...="75%") */
    #define HTML_LEN_PROPORTION 0x4000  /*   HTML 4: proportion (...="5*") */
    #define HTML_LEN_VARIABLE   0xC000  /* value: undefined size */

#define HTML_LEN_GET_UNIT(len) ((len) & HTML_LEN_UNIT_MASK)
#define HTML_LEN_GET_VALUE(len) ((len) & HTML_LEN_VALUE_MASK)


/* Manufacturer ID and types to identify variable graphics: */

#define HTML_VARGRAPH_MFGID           16431
#define HTML_VARGRAPH_TYPE_FORM       0x5700    /* form element placeholder */
#define HTML_VARGRAPH_TYPE_IMAGE      0x5701    /* unresolved image */

/*
   Main header block of transfer item, joining a standard text transfer
   item with some additional data.

   Note that all NameTokens used here, as well as those in the arrays
   referenced from the header, refer to the item's local name pool, i.e. they
   have to be transfered into an in-memory pool using NamePoolTokenizeFromVM()
   when needed.
 */

typedef struct {
  VMChainTree HTBH_meta;

  struct {
    WordFlags   HTBHO_fileInfo;
      #define HTML_FI_BACK_COLOR 0x0001 /* set if background color specified */
      #define HTML_FI_NON_JS_SCRIPT 0x4000 /* contains unknown script types */
      #define HTML_FI_EXT_SCRIPT 0x8000 /* some external scripts not loaded */
    NameToken   HTBHO_documentTitle;    /* <TITLE>...</TITLE> */
    NameToken   HTBHO_baseURI;          /* <BASE href=...> */
    NameToken   HTBHO_baseTarget;       /* <BASE target=...> */
    ColorQuad   HTBHO_backColor;
    VMChain     HTBHO_namePoolToUse;    /* name pool to use with this item */
#if EMBED_SUPPORT
    NameToken   HTBHO_embed;            /* single embedded object */
#endif
    word        HTBHO_topMargin ;       /* Margin to inset from the top */
    word        HTBHO_leftMargin ;      /* Margin to inset from the left */
    word        HTBHO_formattedWidth ;  /* Size last formatted, 0 for none */
    word        HTBHO_numFormattedCells;/* Number of cells finished out in page */
    ColorQuad   HTBHO_vlinkColor;       /* Color for visited links */
    ColorQuad   HTBHO_linkColor;        /* Color for unvisited links */
  } HTBH_other;

  VMChain       HTBH_transferItem;      /* chain of TIF_TEXT transfer item */
  VMChain       HTBH_arrayBlock;        /* block with additional arrays */
  VMChain       HTBH_namePoolLink;      /* link to local name pool, if any */
  VMChain       HTBH_cellArrayLink ;    /* VMChain to huge array of cells */
  VMChain       HTBH_tableArrayLink ;   /* VMChain to huge array of tables */
  VMChain       HTBH_lineArrayLink ;    /* VMChain to huge array of lines calculated */
  VMChain       HTBH_regionArrayLink ;  /* VMChain to huge array of regions */
  VMChain       HTBH_scriptCode;        /* VMChain to huge array of main script code */
} HypertextTransferBlockHeader;


/*
   Header of array block carrying additional data structures for
   the transfer item. This block may eventually be split up into
   multiple blocks in future versions if size constraints require it.
 */

typedef struct {
  LMemBlockHeader HABH_meta;

  /* used by HTMLTextClass */
  ChunkHandle     HABH_imageArray;
  ChunkHandle     HABH_anchorArray;
  ChunkHandle     HABH_formArray;       /* form element description, if any */
  ChunkHandle     HABH_tableArray;      /* table description, if any */
  ChunkHandle     HABH_cellArray;       /* cell description, if any */
  ChunkHandle     HABH_mapArray;        /* map description, if any */

  /* for use by higher level components */
  ChunkHandle     HABH_metaArray;       /* meta data, if any */
  ChunkHandle     HABH_frameArray;      /* frame set to use, if any */
  
  ChunkHandle     HABH_regionArray ;    /* Regions, if any */

  VMBlockHandle   HABH_lineArray ;      /* Calculated lines, if any */
  ChunkHandle     HABH_eventArray;      /* event data, if any */
} HypertextArrayBlockHeader;


/* 
 * Element of image array
 *
 * Conceptually, the only reason for this structure is that there is not ennough
 * room in the private data field of a VisTextGraphic to hold all the information
 * we need. As a result, we'll only store a pointer to this "extension" record
 * there to get to it quickly when a Variable Graphic is drawn.
 */

typedef struct {

  /*** Fields filled in by parser: ***/  

  dword pos;                            /* starting position of image */
#define HTML_IMAGE_POS_DOCUMENT_BACKGROUND          TEXT_ADDRESS_PAST_END
#define HTML_IMAGE_POS_TABLE_OR_CELL_BACKGROUND     (HTML_IMAGE_POS_DOCUMENT_BACKGROUND-1)
#define HTML_IMAGE_POS_RESERVED                     (TEXT_ADDRESS_PAST_END-0xFF)
  word len;                             /* length of image placeholder */

  NameToken name;                       /* NAME attribute (for JS) */

  WordFlags flags;                      /* additional flags describing image */
    #define HTML_IDF_RESOLVED   0x0001  /*  - image already loaded */
    #define HTML_IDF_ISMAP      0x0002  /*  - image is a server side map */
    #define HTML_IDF_SUBMIT     0x0004  /*  - image is graphical submit btn */
    #define HTML_IDF_RESOLVING  0x0008  /*  - image has been requested */
    #define HTML_IDF_SIZE_DIRTY 0x4000  /*  - size has changed recently */
    #define HTML_IDF_BROKEN     0x8000  /*  - image could not be resolved */
  XYSize size;                          /* target size, or 0 if not spec'd */
  word hspace,vspace;                   /* value of hspace,vspace attributes */
  word formElementIndex;                /* array member index of associated
                                           form element if IDF_SUBMIT is set */
  NameToken imageURL;                   /* name token of image URL */
  NameToken imageALT;                   /* alternative text of image (only if
                                           image has var graphic placeholder) */
  NameToken usemap;                     /* URL of associated map */

  /*** Fields set up at display time: ***/

  dword         HID_cacheToken;         /* Token of item in cache */
  NameToken     HID_resolvedURL;        /* Temporary name token of full URL */

  VMFileHandle  HID_vmf;                /* VM file reference of graphic */
  VMBlockHandle HID_vmb;
  word          HID_IADType;            /* Type of graphic */

  WWFixed       HID_tmatrixE11;         /* Partial transfer matrix:  e11 element */   
  WWFixed       HID_tmatrixE22;         /* Partial transfer matrix:  e22 element */   
  XYOffset      HID_drawOffset;         /* XY picture offset */

  /* Cached information */
  XYSize        HID_size;               /* Actual XY size of image in document */
  Point         HID_pos;                /* XY position of image on the document */

  /* Information for animations */
  word          HID_frame;              /*   Current frame */
    #define HTML_ANIMATION_VAR_FRAME_NOT_STARTED  0xFFFF
  word          HID_delay ;             /*   Current delay til next frame */
  word          HID_loopCount ;         /*   Number of times left to loop */
} HTMLimageData;

#define HTML_IMAGE_INDEX_NONE 0xFFFF

#define TOKEN_FIELDS_IMAGE_DATA \
  word_offsetof(HTMLimageData, imageURL), \
  word_offsetof(HTMLimageData, imageALT), \
  word_offsetof(HTMLimageData, usemap), 0xFFFF

/*
   Overlay for VisTextGraphic.VTGV_privateData[] field of
   a variable graphic serving as placeholder for an image
   in text transfer item that is either unresolved or
   defined through a reference into the image pool.
 */
typedef struct {
  word  HIGV_imageIndex;            /* index of associated image element */
} HTMLimageGraphicVariable;


/* Element of anchor array: */

typedef struct {
  dword pos;                            /* starting position of anchor */
  word len;                             /* length if HTML_ADF_NAME not set */
  WordFlags flags;
    #define HTML_ADF_NAME 0x0001        /*  - this is a name, not a link */
    #define HTML_ADF_MAP  0x0002        /*  - associated with a map area */
  NameToken linkOrName;                 /* name token of HREF or NAME param */
  NameToken target;                     /* if link: value of TARGET param */
} HTMLanchorData;

#define TOKEN_FIELDS_ANCHOR_DATA \
  word_offsetof(HTMLanchorData, linkOrName), \
  word_offsetof(HTMLanchorData, target), 0xFFFF


/* Element of form element array: */

typedef byte HTMLformType ;

#define FORM_ELEMENT_INVALID        CA_NULL_ELEMENT

typedef struct {
  dword         HFD_pos;                /* text position */
  HTMLformType  HFD_itemType;           /* type of form element */

    #define HTML_FORM_NONE      0       /* used to convey bad HTML */

    /* The following form elements are stored as variable graphics: */

    #define HTML_FORM_SELECT    1       /* header of selection menu */
    #define HTML_FORM_TEXT      2       /* text entry */
    #define HTML_FORM_TEXTAREA  3       /* multiline text entry */
    #define HTML_FORM_PASSWORD  4       /* password entry (=hidden text) */
    #define HTML_FORM_RADIO     5       /* radio button */
    #define HTML_FORM_CHECKBOX  6       /* checkbox */
    #define HTML_FORM_SUBMIT    7       /* submit button */
    #define HTML_FORM_RESET     8       /* reset button */
    #define HTML_FORM_FILE      9       /* file upload placeholder */
    #define HTML_FORM_BUTTON    10      /* button */

    /* Ordinal number of highest record type which is stored a var graphic: */
    #define HTML_FORM_LAST_EMBED  HTML_FORM_BUTTON

    /* The following form elements are not embededded as variable graphics,
       but as ISMAP graphics (IMAGE) or not at all (HEADER, HIDDEN, OPTION).
       They have to be processed specially, of course: */

    #define HTML_FORM_HEADER    100       /* global data for entire form */
    #define HTML_FORM_IMAGE     101       /* graphical submit field */
    #define HTML_FORM_HIDDEN    102       /* un-rendered, un-editable text */
    #define HTML_FORM_OPTION    103       /* A single selection in a SELECT
                                             menu. Selections will always
                                             follow the FORM_SELECT record */

  byte          HFD_formNumber;         /* Token to identify elements belonging
                                           to the same form. Elements of one
                                           form are always consecutive. */

  NameToken     HFD_name;               // Name of element in form, if any 
                                        //  HEADER: action=...
                                        //  OPTION: displayed string
  NameToken     HFD_value;              // Initial value or text of element
                                        //  FILE: accept=...
                                        //  TEXTAREA: contents of token
                                        //  HEADER: target= ...
  NameToken     HFD_prompt;             // Prompt for text input and choice
                                        // list dialogs
                                        //  HEADER: name=

  dword         HFD_runtimeState;       /* may be used to hold current
                                           contents at runtime */

  union {                               /* some variable fields */

    struct {
      WordFlags   options;
        /* method for submitting form */
        #define HTML_OPT_METHOD_MASK       0x000F
        /* default for Action URL: */
        #define HTML_OPT_METHOD_DEFAULT    0x0000
        #define HTML_OPT_METHOD_GET        0x0001
        #define HTML_OPT_METHOD_POST       0x0002

        /* encoding scheme to use */
        #define HTML_OPT_ENCODING_MASK     0x00F0
        /* default for specified method: */
        #define HTML_OPT_ENCODING_DEFAULT  0x0000
        /* application/x-www-form-urlencoded: */
        #define HTML_OPT_ENCODING_URL      0x0010
        /* multipart/form-data: */
        #define HTML_OPT_ENCODING_MULTI    0x0020
    } header;

    struct {                            /* HTML_FORM_SELECT */
      word        size;
      WordFlags   flags;
        #define HTML_SELECT_MULTI 0x0001        /* set: multiple selection */
	#define HTML_SELECT_ONCHANGE 0x0002     /* set: 'onChange' attribute */
      word        maxWidth ;            /* Cached width of longest line */
    } select;

    struct {                            /* HTML_FORM_OPTION */
      word        menuElement;          /* Element number of associated menu. */
      WordFlags   flags;
        #define HTML_OPTION_SELECTED 0x0001     /* set: selected by default */
	#define HTML_OPTION_DELETED  0x0002     /* set: deleted */
    } option;

    struct {                            /* HTML_FORM_CHECKBOX or ..._RADIO */
      WordFlags   flags;
        #define HTML_BOOLEAN_SELECTED 0x0001    /* set: selected by default */
    } checkbox_radio;

    struct {                            /* HTML_FORM_TEXT and PASSWORD */
      word        size, maxlen;
    } text_password;

    struct {                            /* HTML_FORM_TEXTAREA */
      word        rows, cols;
      word        selStart, selEnd;
      MemHandle   lines;
      ByteFlags   flags;
        #define HTML_TEXTAREA_READONLY 0x0001
    } textarea;

    struct {                            /* HTML_FORM_SUBMIT */
      Point       rel ;                 /* press location */
      word        flags ;
        #define HTML_SUBMIT_PRESSED 0x0001
	#define HTML_BUTTON_ONCLICK 0x0002
    } submit ;
  } HFD_var;

  sword x, y ;                           /* X & Y position in region */
} HTMLformData;

#define TOKEN_FIELDS_FORM_DATA \
  word_offsetof(HTMLformData, HFD_name), \
  word_offsetof(HTMLformData, HFD_value), \
  word_offsetof(HTMLformData, HFD_prompt), 0xFFFF

/*
   Overlay for VisTextGraphicVariable.VTGV_privateData[] field of
   form element variable graphics in text transfer item.
 */
typedef struct {
  word HFGV_formElementIndex;           /* array member index of form element */
                                        /* This is the index of an element of
                                           type HTMLformData in the array
                                           pointed to by HABH_formArray. */
} HTMLformGraphicVariable;


/* Element of frame array: */

typedef struct {

  WordFlags       HF_flags;
    #define HTML_FRF_COLS       0x0001  /*  - set if FRAMESET with COLS */
    #define HTML_FRF_SIZE_WIDTH 0x0002  /*  - set if size specifies width */
    #define HTML_FRF_NOBORDER   0x0010  /*  - if frame: has no visible border */
    #define HTML_FRF_SCROLLING  0x0020  /*  - use scrollbars if required */
    #define HTML_FRF_FORCE_SCROLL 0x0040  /*  - force scrollbars */
    #define HTML_FRF_FRAMESET   0x8000  /*  - is start of new frame set */
  HTMLmultiLength HF_size;
  word            HF_level;             /* level of current frame/frame set */
  NameToken       HF_name;              /* name to use for this window */
  NameToken       HF_url;               /* if frame: URL to show */

  /* The following fields are only filled when the structure is used
     for saving the state of a frame set. In this case, the title and
     base URI of the page containing the <FRAMESET> elements must be
     preserved because they cannot be retrieved from the contents of the
     individual frames' HTML files.
     In this case the HF_url field is also valid for a frame set. */

  NameToken       HF_title;             /* title of page */
  NameToken       HF_base;              /* URI base of page */
  NameToken       HF_target;            /* default target of page */
  NameToken       HF_referrer;          /* referrer of page */

  NameToken       HF_refreshURL ;
  word            HF_refreshTime ;
#define FRAME_REC_DEFAULT_MARGIN  HTML_EXTRA_MARGIN_USE_DEFAULT
  word            HF_marginWidth ;      /* marginWidth value or FRAME_REC_DEFAULT_MARGIN */
  word            HF_marginHeight ;     /* marginHeight value or FRAME_REC_DEFAULT_MARGIN */
} HTMLframeRec;

#define TOKEN_FIELDS_FRAME_REC \
  word_offsetof(HTMLframeRec, HF_name), \
  word_offsetof(HTMLframeRec, HF_url), \
  word_offsetof(HTMLframeRec, HF_title), \
  word_offsetof(HTMLframeRec, HF_base), \
  word_offsetof(HTMLframeRec, HF_target), \
  word_offsetof(HTMLframeRec, HF_referrer), \
  word_offsetof(HTMLframeRec, HF_refreshURL), \
  0xFFFF


/* Type to handle alignment */
typedef byte HTMLAlignment ;
#define HTML_ALIGN_NONE        0
#define HTML_ALIGN_LEFT        1
#define HTML_ALIGN_RIGHT       2

/* Elements of table/cell descriptor arrays: */

typedef struct {

  WordFlags HTD_flags;
    #define HTML_TABLE_HAS_BACKGROUNDS_MASK  0x0002 /* Flag telling if table or any of it's cells */
    #define HTML_TABLE_HAS_BACKGROUNDS_OFFSET 1     /* have backgrounds (optimization flag) */

    #define HTML_TABLE_DIRTY_LAYOUT_MASK 0x0004  /* Flag telling if table needs recalc */
    #define HTML_TABLE_DIRTY_LAYOUT_OFFSET    2

    #define HTML_TABLE_ALIGN_MASK    0x0018  /* Alignment of whole table */
    #define HTML_TABLE_ALIGN_OFFSET       3
    #define TABLE_GET_ALIGN(flags) \
      (((flags) & HTML_TABLE_ALIGN_MASK) >> HTML_TABLE_ALIGN_OFFSET)

    #define HTML_TABLE_JUSTIFY_MASK  0x0060  /* Justification (J_LEFT etc.) */
    #define HTML_TABLE_JUSTIFY_OFFSET     5
    #define TABLE_GET_JUSTIFY(flags) \
      (((flags) & HTML_TABLE_JUSTIFY_MASK) >> HTML_TABLE_JUSTIFY_OFFSET)

    #define HTML_TABLE_BACK_COLOR    0x0080  /* table has colored background */

    #define HTML_TABLE_BORDER_MASK   0x0F00  /* border in pixels (0 = none) */
    #define HTML_TABLE_BORDER_OFFSET      8
    #define TABLE_GET_BORDER(flags) \
      (((flags) & HTML_TABLE_BORDER_MASK) >> HTML_TABLE_BORDER_OFFSET)
    #define HTML_TABLE_MAX_BORDER    15      /* maximum border width */

    #define HTML_TABLE_LEVEL_MASK    0xF000  /* table level (0 = outside) */
    #define HTML_TABLE_LEVEL_OFFSET      12
    #define TABLE_GET_LEVEL(flags) \
      (((flags) & HTML_TABLE_LEVEL_MASK) >> HTML_TABLE_LEVEL_OFFSET)
    #define HTML_TABLE_MAX_LEVEL     15      /* maximum table nesting depth */

  HTMLmultiLength HTD_width;            /* table width */
  HTMLmultiLength HTD_height;           /* table height */
  HTMLmultiLength HTD_cellspacing;      /* spacing around border */
  HTMLmultiLength HTD_cellpadding;      /* spacing within border */

  ColorQuad HTD_backColor;              /* background color of cell, if any */

  word HTD_rows;                        /* number of rows, columns in table */
  byte HTD_cols;

  word HTD_firstCell;                   /* element index of first cell */

  word HTD_wantedWidth ;
  word HTD_minWidth ;                   /* last determined minimum width */
  word HTD_insetAmount ;                /* Amount to indent table */

  /* Cache values for faster formatting */
  word HTD_lastAvailableWidth ;
  dword HTD_lastX ;
  dword HTD_lastY ;
  dword HTD_lastHeight ;
  word HTD_lastTableWidth ;
  word HTD_lastXOffset ;

  word HTD_backgroundImage ;            /* Index to image or HTML_IMAGE_INDEX_NONE */
} HTMLtableData;


typedef struct {

  word HCD_table;                       /* element index of associated table */
  ByteFlags HCD_flags;
    #define HTML_CELL_VALIGN_MASK    0x03 /* vertical alignment */
    #define HTML_CELL_VALIGN_TOP     0x00
    #define HTML_CELL_VALIGN_CENTER  0x01
    #define HTML_CELL_VALIGN_BOTTOM  0x02

    #define HTML_CELL_BACK_COLOR     0x08 /* cell has colored background */

    #define HTML_CELL_PRE_TABLE      0x20 /* Cell is before table and empty */
    #define HTML_CELL_CONTINUE       0x40 /* continues after embedded table */
    #define HTML_CELL_NOT_EMPTY      0x80 /* associated with line break */

  ByteFlags HCD_flags2 ;
    #define HTML_CELL_BREAK_MASK        0x03 /* Flags used only with CONTINUE */
                                          /* cells. */
        #define HTML_CELL_BREAK_NONE       0
        #define HTML_CELL_BREAK_LEFT       1
        #define HTML_CELL_BREAK_RIGHT      2
        #define HTML_CELL_BREAK_BOTH       3
    #define HTML_CELL_DIRTY_LAYOUT_MASK 0x04

    #define HTML_CELL_JUSTIFY_MASK      0x18  /* Justification (J_LEFT etc.) */
    #define HTML_CELL_JUSTIFY_OFFSET       3
    #define CELL_GET_JUSTIFY(flags) \
      (((flags) & HTML_CELL_JUSTIFY_MASK) >> HTML_CELL_JUSTIFY_OFFSET)

  word HCD_row;                         /* row containing top edge  */
  byte HCD_col;                         /* column containing left edge */
  byte HCD_colspan;                     /* number of rows spanned by cell */
  byte HCD_rowspan;                     /* number of columns spanned */

  HTMLmultiLength HCD_width;            /* width of cell if fixed */
  HTMLmultiLength HCD_height;           /* height of cell if fixed */

  ColorQuad HCD_backColor;              /* background color of cell, if any */

  word HCD_minWidth;                    /* minimum required width based on
                                           actual content (pixels) */
  dword HCD_minHeight;                  /* minimum required height based on
                                           actual content (pixels) */
  word HCD_longestLine ;                /* Maximum line (pixels && <0x3FFF) */
    #define HTML_CELL_LONGEST_LINE_LIMIT  0x3FFF

  word HCD_x ;                         /* Current layout of this particular cell */
  dword HCD_y ;
  dword HCD_calcHeight ;
  word HCD_calcWidth ;
  word HCD_nextCellInTable ;
  word HCD_slackHeight ;               /* Amount of height not used in cell */
  word HCD_hardMinWidth ;              /* Width to use if squeezed */
  dword HCD_topY ;                     /* Y position before adjustment */
  word HCD_region ;                    /* Link to region in text */

  word HCD_backgroundImage ;           /* Image background or HTML_IMAGE_INDEX_NONE */
} HTMLcellData;

#define CELL_NEXT_IN_TABLE_UNKNOWN  0xFFFF


/* Element of map array (this is a variable sized array): */

typedef struct {

  NameToken HMD_name;                   /* name of map this item belongs to */
  word HMD_shape;
    #define HTML_MAP_SHAPE_DEFAULT 0
    #define HTML_MAP_SHAPE_RECT    1
    #define HTML_MAP_SHAPE_CIRCLE  2
    #define HTML_MAP_SHAPE_POLY    3

  word HMD_anchor;                      /* element # of associated anchor */

  HTMLmultiLength HMD_coord[1];         /* first coordinate value goes here */

} HTMLmapData;

#define TOKEN_FIELDS_MAP_DATA \
  word_offsetof(HTMLmapData, HMD_name), 0xFFFF


/* Element of meta data array */

typedef struct {

  ByteFlags HMD_flags;
    #define HTML_META_FLAGS_HTTP_EQUIV  0x01    /* name is http-equiv */

  NameToken HMD_name;
  NameToken HMD_content;

} HTMLmetaData;

#define TOKEN_FIELDS_META_DATA \
  word_offsetof(HTMLmetaData, HMD_name), \
  word_offsetof(HTMLmetaData, HMD_content), 0xFFFF


/* Event array */

/* Basic events supported by Netscape 3 */
typedef enum {
  HTML_EVENT_ABORT, HTML_EVENT_ERROR, HTML_EVENT_LOAD, HTML_EVENT_UNLOAD,

  HTML_EVENT_BLUR, HTML_EVENT_FOCUS, 
  HTML_EVENT_CHANGE, HTML_EVENT_RESET, HTML_EVENT_SUBMIT, HTML_EVENT_SELECT,

  HTML_EVENT_CLICK, HTML_EVENT_MOUSEOVER, HTML_EVENT_MOUSEOUT,
} HTMLEventType;

/* Objects that can fire events in our browser. Comments next to each object
   list the events supported by the respective object in NS3. Events marked
   with (*) are currently not implemented for this object. 

   Some possible events are not fired by the basic HTMLClass implementation.
   They are defined for use by subclasses that actually implement those
   functions. */

typedef enum {
  HTML_EVENT_NONE = 0,
    // (used as a default if no event applies)
  HTML_EVENT_OBJECT_BODY,
    // blur(*), focus(*), load(*), unload(*)
  HTML_EVENT_OBJECT_IMAGE,
    // abort(*), error, load
  HTML_EVENT_OBJECT_FORM,
    // reset, submit
  HTML_EVENT_OBJECT_ELEMENT,
    // blur, change, click, focus, mouseout, mouseover, select(*)
  HTML_EVENT_OBJECT_LINK,
    // click, mouseout, mouseover
  HTML_EVENT_OBJECT_AREA,
    // click, mouseout, mouseover
  HTML_EVENT_OBJECT_FRAMESET,
    // blur(*), focus(*), load(*), unload(*)
} HTMLEventObjectType;

typedef struct {
  HTMLEventType         HED_evt;        // What event?
  HTMLEventObjectType   HED_type;       // What type of object?
  word                  HED_obj;        // Which object of this type? Note that
                                        //   areas on image maps are identified
                                        //   by their corresponding link item.
  NameToken             HED_code;       // Script code for this event
} HTMLeventData;

#define TOKEN_FIELDS_EVENT_DATA \
  word_offsetof(HTMLeventData, HED_code), 0xFFFF


/***************************************************************************
 *              HTML Import
 ***************************************************************************/

typedef int ReadHTML_getc(dword data);  /* callback routine to get one char */
typedef int pcfm_getc(ReadHTML_getc *gc,dword data);

#define HTML_EXTRA_MARGIN_USE_DEFAULT  0xFFFF
typedef struct {
  VMFileHandle   HE_vmFile;             /* pass: VM file to use */
  WWFixedAsDWord HE_pointSize;
  FontID         HE_plainFont;
  FontID         HE_exampleFont;
  WordFlags      HE_options;
    #include "htmlopt.h"
  optr           HE_namePool;           /* pass: optr to name pool object */
  word           HE_marginWidth ;       /* left (& right) margin to force on doc */
  word           HE_marginHeight ;      /* top (& bottom) margin to force on doc */

  optr           HE_frame;              /* source frame */
  NameToken      HE_url;                /* URL of the document */

@ifdef JAVASCRIPT_SUPPORT
  void _pascal *HE_scriptHandler;       /* callback routine to handle scripts */
  dword          HE_scriptSrc;          /* HTML from script (document.write) */
  word           HE_scriptSrcOffset;    /* extra data for HE_scriptSrc */
@endif

  void _pascal *HE_getExtFile;          /* callback to request external file */

@ifdef DO_DBCS
  DosCodePage    HE_codePage;
@endif
} HTMLextra;

@ifdef JAVASCRIPT_SUPPORT
/* for handling script-generated HTML (i.e. document.write) */
#define _ScriptHandlerParams_ VMFileHandle file, VMBlockHandle code, dword offset, optr frame
typedef void _pascal _export proc_ScriptHandlerCallback(_ScriptHandlerParams_);
typedef void _pascal pcfm_ScriptHandlerCallback(_ScriptHandlerParams_, void *pf);

typedef struct _ScriptSrcHeader {
    NameToken url;           /* URL of page with script-generated HTML */
    VMFileHandle file;       /* huge-array holding script-generated HTML */
    VMBlockHandle block;
    word i;                  /* current read-position in huge-array */
    struct _ScriptSrcHeader *parent; 
			     /* enclosing script, or NULL if none */
} ScriptSrcHeader;
@endif

/*
 * Parse_GetExternalFile Parameters explained:
 *
 * Inputs:
 *     TCHAR *url                  -- (relative) URL of file to request
 *     optr frame                 -- frame as passed in HTMLext structure
 *     NameToken docurl           -- (absolute) URL of enclosing document 
 *     NameToken docbase          -- specified base URL, if any 
 *     word scriptIdx             -- index of script fragment on page, or 0
 *                                   if missing external scripts above this one
 *     VMFileHandle *vmf          -- suggested VM file to create HugeArray in
 * Outputs:
 *     Boolean                    -- returns TRUE if no error occured
 *     VMFileHandle *vmf          -- if successful, actual VM file with HA
 *     VMBlockHandle *retHA;      -- if successful, HugeArray with script text
 */
#define _GetExternalFileParams_ \
  TCHAR *url,optr frame,NameToken docurl,NameToken docbase, word scriptIdx, \
  VMFileHandle *vmf,VMBlockHandle *retHA

typedef Boolean _pascal _export proc_GetExternalFileCallback(_GetExternalFileParams_);
typedef Boolean _pascal pcfm_GetExternalFileCallback(_GetExternalFileParams_, void *pf);

int _pascal ParseHTMLFile(ReadHTML_getc *,dword,HTMLextra *, VMBlockHandle *);
int _pascal ParsePlainFile(ReadHTML_getc *,dword,HTMLextra *, VMBlockHandle *);

#define HFTT_ASSUME_HTML      0
#define HFTT_ASSUME_PLAIN     1

#define HFTT_SOURCE_FILENAME  0
#define HFTT_SOURCE_OPTR      1
@ifdef JAVASCRIPT_SUPPORT
#define HFTT_SOURCE_SCRIPT    2
@endif

int _pascal ParseAnyFile(word fileType, word fileSource, dword data,
  HTMLextra *ext, VMBlockHandle *item, AllocWatcherHandle watcher, dword *p_memUsed);
void _pascal ParseAbort(void) ;

/***************************************************************************
 *              HTML Export
 ***************************************************************************/

int _pascal CreateHTMLFile(optr, FileHandle out);


/***************************************************************************
 *              URL resolution
 ***************************************************************************/

Boolean _pascal ToolsParseURL(TCHAR *url, TCHAR *type, TCHAR *server, TCHAR *path);
TCHAR * _pascal ToolsMakeURL(TCHAR *type, TCHAR *server, TCHAR *path, TCHAR *url);
TCHAR * _pascal ToolsResolvePathname(TCHAR *cur, TCHAR *new);
int _pascal ToolsResolveRelativeURL(TCHAR *cur, TCHAR *url);
Boolean _pascal ToolsMakeURLAbsolute(TCHAR *cur, TCHAR *url, TCHAR *urldst);
void _pascal ToolsNormalizeURL(TCHAR *url);


/***************************************************************************
 *              Various utility functions
 ***************************************************************************/

void _pascal SysNotifyWithData(void *Ptr, word size, word notificationType,
  word listType);

void _pascal SysNotifyWithData(void *Ptr, word size, word notificationType,
  word listType);

/* Two routines to work around the incompatibility between the VMChain
   and LMem mechanisms: VMLockChainifiedLMemBlock() modifies a block which
   was part of a VMChain before to act as a proper LMem block again, while
   VMUnlock() reverts the change and makes the block chainable again. */
void * _pascal VMLockChainifiedLMemBlock(VMFileHandle vmf, VMBlockHandle vmb,
  MemHandle *mh);
void _pascal VMUnlockChainifiedLMemBlock(MemHandle mh);

DiskHandle _pascal ToolsParseDiskOrStandardPath(TCHAR **p);
word _pascal ToolsStringSectionFindKey(char *section, char *key,
  TCHAR *subKey, TCHAR *value, word bufSize, Boolean mapLeftToRight);
optr _pascal ToolsFormatMessage(optr msg,TCHAR *res);
TCHAR * _pascal ToolsFindExtension(TCHAR *p);
TCHAR * _pascal xstrncpy(TCHAR *dst, TCHAR *src, word size);
void _pascal DebugDialogPrintf(TCHAR *fmt, ...);
TCHAR * _pascal GetNthFromList(TCHAR *list, word n, Boolean whiteDel, word *size);
optr _pascal LMemDup(optr ch);
Boolean _pascal HTMLTranslateColor(char *p, ColorQuad *qc) ;
int _pascal HTMLTranslateCharNum(unsigned int num);
int _pascal HTMLTranslateChar(char *entity);


/***************************************************************************
 *              FormStrings
 ***************************************************************************/

void _export FormStringAppend(MemHandle mem, TCHAR *p_string) ;
void _export FormStringConvertAndAppend(MemHandle mem, TCHAR *p_string) ;
MemHandle _export FormStringCreate(void) ;
void * _export FormStringDerefData(MemHandle mem) ;

/***************************************************************************
 *              HTML-aware Text Object class
 ***************************************************************************/

/* Margin (in 1/72") to be left above and below the page in printouts */
#define HTML_TEXT_ORNAMENT_MARGIN 30

typedef dword T_cellArrayHandle ;
typedef dword T_tableArrayHandle ;

@class HTMLTextClass, VisLargeTextClass;

  @default VTI_features = @default | VTF_TRANSPARENT;
  @default VTI_state = @default | VTS_SELECTABLE | VTS_TARGETABLE;
  @default VLTI_displayMode = VLTDM_PAGE;
  @default VLTI_attrs = VLTA_EXACT_HEIGHT;

  @instance WordFlags      HTI_state = HTS_VIEW_NOT_OPENED;

    /* a change to the wash color was made, but not yet rendered: */
    #define HTS_WASH_COLOR_SUSPENDED             0x0001

    /* required to delay init reformatting until view size known: */
    #define HTS_VIEW_SUSPENDED_FOR_OPEN          0x2000
    #define HTS_VIEW_NOT_OPENED                  0x4000

    /* printing active flag */
    #define HTS_PRINTING                         0x8000

  @instance WordFlags      HTI_layoutState ;
    /* set whenever something may have caused a change to the table layout
       without fully redrawing / reformatting: */
    #define HTS_LAYOUT_DIRTY                            0x0001

    /* set whenever the height of the page has gone past HTI_maxViewHeight */
    /* Typically means the height needs to be invalidated and */
    /* reformatted again.  The real goal is to determine this as soon as */
    /* possible. */
    #define HTS_PAST_VIEW_HEIGHT                        0x0002

    /* Flag that tells if we are currently already calculating the layout */
    #define HTS_CALCULATING_LAYOUT                      0x0004

    /* Layout has determined it needs to start back at the top */
    #define HTS_RESTARTING_LAYOUT                       0x0008

    /* This flag indicates if the layout being calculated has had its drawing */
    /* turned off.  Drawing is to be turned on when LAYOUT starts so that */
    /* progressive formatting. */
    #define HTS_NEED_TO_REACTIVE_DRAWING                0x0010

    /* Flag to restart a layout while a layout is in progress */
    #define HTS_LAYOUT_RESTART_REQUESTED                0x0020

    #define HTS_LAYOUT_NEED_TO_BLAST_HARD_MIN_WIDTHS    0x0040
    #define HTS_CELL_REGION_LINKS_INVALID               0x0080

    /* Flag to note that we just zoomed and any optimizations for drawing */
    /* should be ignore. */
    #define HTS_LAYOUT_NEED_COMPLETE_PROGRESSIVE_REDRAW 0x0100

    /* Flag tlling that the boundaries of the web page MIGHT have changed */
    #define HTS_NEED_BOUNDARY_CALCULATION               0x0200

  @instance optr           HTI_pageSizeControlOD;

  @instance optr           HTI_imageArray;
  @instance optr           HTI_anchorArray;
  @instance optr           HTI_formArray;
  @instance T_tableArrayHandle HTI_tableArray;
  @instance T_cellArrayHandle  HTI_cellArray;
  @instance optr           HTI_mapArray;
  @instance optr           HTI_eventArray;

  @instance word           HTI_backgroundImage = CA_NULL_ELEMENT;
  @instance optr           HTI_myView = NullOptr;
  @instance optr           HTI_namePool = NullOptr;
  @instance sword          HTI_drawingOn = 0    ;  /* >=0 is on, <0 is off */

  /* Timer used to animation this object.  If Null, animation is */
  /* turned off */
  @instance TimerHandle    HTI_animationTimer = NullHandle ;
  @instance word           HTI_animationTimerID ;
  @instance dword          HTI_animationLastTime ;
  @instance MemHandle      HTI_animationChangeTable ;
  @instance word           HTI_grabbedFormElement = FORM_ELEMENT_INVALID ;

  @instance word           HTI_pageTopMargin = 0 ;
  @instance word           HTI_pageLeftMargin = 0 ;
  @instance word           HTI_viewWidth = 400 ;
  @instance word           HTI_formattedWidth = 400 ;
#define HTML_UNLIMITED_VIEW_HEIGHT  0xFFFFFFFF
#define HTML_INITIAL_VIEW_HEIGHT    0
  @instance dword          HTI_maxViewHeight = HTML_UNLIMITED_VIEW_HEIGHT ;
  @instance word           HTI_numFormattedCells = 0 ;

#define INVALIDATE_SWATH_START_NONE  0xFFFFFFFF
  @instance MemHandle      HTI_layoutStack = NullHandle ;

  /* VMChain of currently displayed Hypertext Transfer Item (in
     the file refered to by VTI_vmFile). */
  @instance VMChain HTI_transferItem = 0;

  /* File to go back to when trying to be "empty" */
  @instance VMFileHandle   HTI_emptyFile = NullHandle;

  @instance RectDWord      HTI_invalArea ;
  @instance dword          HTI_heightThreshold = 100 ;
  @instance word           HTI_lastStatusReported ;

  @instance NameToken      HTI_pendingAnchor = NAME_POOL_NONE;
  @instance MemHandle      HTI_waitingImages = NullHandle ;

  @instance ColorQuad      HTI_vlinkColor;
  @instance ColorQuad      HTI_linkColor;

@ifdef JAVASCRIPT_SUPPORT
  @instance HTMLEventType  HTI_pendingEvt_evt = HTML_EVENT_NONE;
  @instance HTMLEventObjectType HTI_pendingEvt_type;
  @instance word           HTI_pendingEvt_obj;
@endif

  @message void MSG_HTML_TEXT_INIT_STORAGE(VMFileHandle fileHan);
  @message void MSG_HTML_TEXT_DEINIT_STORAGE();
  @message void MSG_HTML_TEXT_DEINIT_EXTRA();

  @message word MSG_HTML_TEXT_LINK_FROM_POS(dword pos, word mode);
    #define HTML_CHP_EXACT        0
    #define HTML_CHP_PREVIOUS     1
    #define HTML_CHP_NEXT         2
  @message void MSG_HTML_TEXT_HIT_FROM_COORD(LargeMouseData *lmd,
    dword *posret, Point *relret, word *link, word *formElement, word *image);
  @message word MSG_HTML_TEXT_LINK_FROM_MAP(HTMLimageData *img, Point *rel);
  @message void MSG_HTML_TEXT_SELECT_LINK(word link);

  @message void MSG_HTML_TEXT_NEXT_HOTSPOT();
  @message void MSG_HTML_TEXT_PREV_HOTSPOT();
  @message Boolean MSG_HTML_TEXT_EXEC_HOTSPOT();
  @message void MSG_HTML_TEXT_EXEC_NTH_HOTSPOT(word nth);

  /*
   * Messages sent to self when hotspots are touched or executed.
   * Note that these messages have to call the superclass *after* performing
   * their actions to free the name token passed for the link parameters.
   */
  @message void MSG_HTML_TEXT_HOTSPOT_PTR(optr pool, 
               NameToken link, NameToken target);
  @message void MSG_HTML_TEXT_HOTSPOT_SELECT(optr pool,
               NameToken link, NameToken target, HTMLFormDataHandle postData);

  @message void MSG_HTML_TEXT_HOTSPOT_NOTIFY(word number, Message msg,
    TCHAR *data);
  
  #define POSITION_ANCHOR_SIZE 1+1+10+1   // "#" marker-char 10-digits "\0"
  @message int MSG_HTML_TEXT_GOTO_ANCHOR(optr pool, NameToken anchor);
  @message void MSG_HTML_TEXT_CREATE_POSITION_ANCHOR(TCHAR *buf);

  @message word MSG_HTML_TEXT_GET_IMAGE_COUNT();
  @message Boolean MSG_HTML_TEXT_TEST_UNRESOLVED_IMAGES();
  @message Boolean MSG_HTML_TEXT_TEST_BROKEN_AND_RESOLVING_IMAGES();

  @message Boolean MSG_HTML_TEXT_GET_IMAGE(word nImage, HTMLimageData *data);
  @message Boolean MSG_HTML_TEXT_RESOLVE_IMAGE(word nImage, HTMLimageData *data,
    word invalFrom, word invalTo);
 
  @message Boolean MSG_HTML_TEXT_MARK_IMAGE_UNRESOLVED(word nImage);
  @message Boolean MSG_HTML_TEXT_MARK_IMAGE_RESOLVING(word nImage);
  @message Boolean MSG_HTML_TEXT_MARK_IMAGE_BROKEN(word nImage);
  @message void MSG_HTML_TEXT_MARK_ALL_BROKEN_AND_RESOLVING_IMAGES_UNRESOLVED() ;

  @message void MSG_HTML_TEXT_TRACK_REPLACE(dword pos, sword len);

  @message void MSG_HTML_TEXT_SET_BACKGROUND(word nImage);

  @message void MSG_HTML_TEXT_SET_VIEW_OBJ(optr viewObject);

  @message word MSG_HTML_TEXT_FORM_ELEMENT_FROM_POS(dword pos) ;
  @message void MSG_HTML_TEXT_FORM_ELEMENT_START(word formElement, Point rel) ;
  @message void MSG_HTML_TEXT_INITIALIZE_FORM_ELEMENTS() ;
  @message void MSG_HTML_TEXT_FORM_RESET(word formNumber) ;
  @message void MSG_HTML_TEXT_FORM_RESET_ELEMENT(word formElement) ;
  @message void MSG_HTML_TEXT_FORM_SUBMIT(word formNumber, Boolean notify) ;
  @message TCHAR MSG_HTML_TEXT_FORM_APPEND_ELEMENT(
                       MemHandle formString,
                       word formElement,
                       TCHAR prefix,
		       WordFlags enctype) ;
  @message void MSG_HTML_TEXT_RECALC_PAGE();
  @message void MSG_HTML_TEXT_RECALC_COLUMNS();
  @message void MSG_HTML_TEXT_INITIALIZE_LAYOUT() ;
  @message void MSG_HTML_TEXT_DEINITIALIZE_FORM_ELEMENTS() ;   /* Internal */
  @message void MSG_HTML_TEXT_DRAW_TABLE_FRAME(GStateHandle gstate);

  @message void MSG_HTML_TEXT_PRINT_PAGE_ORNAMENTS(GStateHandle gstate,
    word curPage, word numPages, Rectangle *page);
  @message void MSG_HTML_TEXT_DRAWING_ON_OFF(Boolean isOn) ;

  @message void MSG_HTML_TEXT_CALCULATE_LAYOUT() ;

  /* Stop all calculations */
  @message void MSG_HTML_TEXT_ABORT_LAYOUT() ;

  /* The following message is no longer used, it just does nothing now */
  @message void MSG_HTML_TEXT_ADJUST_REGION_WIDTHS() ;

  @message void MSG_HTML_TEXT_SET_PAGE_SIZE_CONTROLLER(optr controller) ;
  @message VMChain MSG_HTML_TEXT_STORE_CONTENTS(VMFileHandle vmf, optr pool);
  @message void MSG_HTML_TEXT_UPDATE_ITEM();

  @message void MSG_HTML_TEXT_ANIMATIONS_ON() ;
  @message void MSG_HTML_TEXT_ANIMATIONS_OFF() ;
  @message void MSG_HTML_TEXT_ANIMATIONS_UPDATE() ;
  @message void MSG_HTML_TEXT_DRAW_ANIMATION_CHANGES() ;

  /* Retrieve upper right corner and index of associated cell record for the
     region starting at the passed position */
  @message word MSG_HTML_TEXT_GET_REGION_POSITION(dword rangeStart, RectDWord *position);

  @message word MSG_HTML_TEXT_FOCUS_FROM_POS(dword pos, word mode);
  @message void MSG_HTML_TEXT_FORM_ELEMENT_INVALIDATE(word formElement);
  @message void MSG_HTML_TEXT_FORM_ELEMENT_GRAB(word formElement) ;
  @message void MSG_HTML_TEXT_FORM_ELEMENT_RELEASE() ;
  @message void MSG_HTML_TEXT_FORM_ELEMENT_ADJUST_POS(word formElement, word x, word y) ;
  @message void MSG_HTML_TEXT_FORM_ELEMENT_START_AFTER_GRAB(word formElement, Point rel) ;
  @message void MSG_HTML_TEXT_CALCULATE_BOUNDARIES() ;
  @message void MSG_HTML_TEXT_INVALIDATE_IMAGE(VisTextGraphic *p_graphic, word nImage,
    word invalFrom, word invalTo);

  @message void MSG_HTML_TEXT_ATTACH_TO_ITEM(VMFileHandle vmf, VMChain vmc);
  @message void MSG_HTML_TEXT_SHOW_ITEM();

  @message void MSG_HTML_TEXT_INTERNAL_LAYOUT_UPDATE_EVENT() ;
  @message void MSG_HTML_TEXT_LAYOUT_START() ;
  @message void MSG_HTML_TEXT_LAYOUT_STOP() ;
  @message void MSG_HTML_TEXT_FORMATTING_STARTED() ;
  @message void MSG_HTML_TEXT_FORMATTING_ENDED() ;

  @message void MSG_HTML_TEXT_INTERNAL_INIT_INVAL_AREA(dword heightThreshold) ;
  @message void MSG_HTML_TEXT_INTERNAL_COLLECT_INVAL_AREA(
                    dword startX,
                    dword startY, 
                    dword endX,
                    dword endY) ;

  @message void MSG_HTML_TEXT_INTERNAL_FLUSH_INVAL_AREA() ;

  /* Subclass to get a status */
  @message void MSG_HTML_TEXT_FORMATTING_STATUS(word numCells, word numFormatted) ;

  @message void MSG_HTML_TEXT_FIND_FOCUS_FORM_ELEMENT();

  @vardata word ATTR_HTML_TEXT_PREVIOUS_NUM_CELLS_FORMATTED ;

/* ------------ */
  /* Creates a block to hold a waiting images list */
  @message void MSG_HTML_TEXT_WAITING_IMAGES_CREATE() ;

  /* Note that an image is waiting for a calculation */
  @message Boolean MSG_HTML_TEXT_WAITING_IMAGE_ADD(word imageIndex, word cellIndex) ;

  #define WAITING_IMAGE_NULL  0xFFFF
  /* Determine where an image is in the list and its index (or WAITING_IMAGE_NULL if none) */
  @message word MSG_HTML_TEXT_WAITING_IMAGE_FIND(word imageIndex) ;

  /* Remove from the list any images that have had their cell calculated.  This frees up */
  /* the list of items that are no longer needed. */
  @message word MSG_HTML_TEXT_WAITING_IMAGES_FLUSH_ONES_WITH_CELLS_CALCULATED() ;

  /* Force all the images to be freed. */
  @message void MSG_HTML_TEXT_WAITING_IMAGES_CLEAR() ;

  /* Tries to free all images, but if any are left, causes a recalculation to occur. */
  @message void MSG_HTML_TEXT_WAITING_IMAGES_RESOLVE(Boolean isLastUpdate) ;

  /* Get rid of the block associate with waiting images */
  @message void MSG_HTML_TEXT_WAITING_IMAGES_DESTROY() ;

/* ------------ */
  @message optr MSG_HTML_TEXT_GET_NAME_POOL();

  @message word MSG_HTML_TEXT_GET_FORM_ELEMENT_COUNT();
  @message Boolean MSG_HTML_TEXT_GET_FORM_ELEMENT(word n, HTMLformData *data);
  
  @message word MSG_HTML_TEXT_GET_LINK_COUNT();
  @message Boolean MSG_HTML_TEXT_GET_LINK(word n, HTMLanchorData *data);
  @message void MSG_HTML_TEXT_SET_LINK(word n, HTMLanchorData *data);

@ifdef JAVASCRIPT_SUPPORT
  /* Called whenever something happens for which there is an event handler.
     This message is meant to be subclassed... */
  @message Boolean MSG_HTML_TEXT_HANDLE_EVENT(HTMLEventType evt,
    HTMLEventObjectType type, word obj, NameToken code);

  /* The internal version of MSG_HTML_TEXT_HANDLE_EVENT that does the lookup
     in the event table to see if we have any handler code. This message can
     be subclassed to perform actions that have to be done on any event
     of a certain sort, no matter if there is a handler for it or not. */
  @message Boolean MSG_HTML_TEXT_FIRE_EVENT(HTMLEventType evt,
    HTMLEventObjectType type, word obj);

@endif

  @message void MSG_HTML_TEXT_SET_FORM_ELEMENT(word n, HTMLformData *data);

@ifdef JAVASCRIPT_SUPPORT
  @message void MSG_HTML_TEXT_FOCUS_FORM_ELEMENT(word formElement);

  @vardata word ATTR_HTML_TEXT_FOCUS_FORM_ELEMENT;
@endif

  @message void MSG_URL_TEXT_COPY_IMAGE_TO_CLIPBOARD(word imageNum) ;

@ifdef JAVASCRIPT_SUPPORT
  /* kbd activation of current selection */
  @message void MSG_HTML_TEXT_KBD_ACTIVATE();
@endif
  @message Boolean MSG_HTML_TEXT_IS_EMPTY() ;
  @message void MSG_HTML_TEXT_SET_TABLE_OR_CELL_BACKGROUND(word nImage);

  @message void MSG_HTML_TEXT_IDENTIFY_MIME_TYPE(char *name, TCHAR *mimeType);

  @message optr MSG_HTML_TEXT_GET_VIEW_OBJ();

  @message word MSG_HTML_TEXT_ADD_OPTION_ELEMENT(HTMLformData *data);
  @message void MSG_HTML_TEXT_REMOVE_OPTION_ELEMENT(word index);
  @message void MSG_HTML_TEXT_FORM_ELEMENT_REMOVE_TEXT_ENTRY();
@ifdef DO_DBCS
  @instance DosCodePage HTI_codePage = 0;
@endif
@endc;
